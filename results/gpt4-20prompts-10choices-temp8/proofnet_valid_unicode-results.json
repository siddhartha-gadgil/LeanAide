[
  {
    "docString": "If `r` is rational (`r â‰  0`) and `x` is irrational, prove that `r+x` is irrational.",
    "prompts": "[{\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (â†‘r * x) â†” LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `r * x`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\":\n  \"âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (x * â†‘r) â†” LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `x * r`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Reflexive r â†’ âˆ€ {x y : Î±}, (x â‰  y â†’ r x y) â†’ r x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`,\\nit suffices to show it holds when `x â‰  y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b â‰  0 â†’ Â¬EuclideanDomain.r (a * b) a\",\n  \"isProp\": true,\n  \"docString\": \"An additional constraint on `r`. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\\n  â†‘(Polynomial.aeval r) p = 0 â†’ IsFractionRing.num A r âˆ£ Polynomial.coeff p 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational root theorem part 1:\\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\\nthen the numerator of `r` divides the constant coefficient \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\\n  â†‘(Polynomial.aeval r) p = 0 â†’ â†‘(IsFractionRing.den A r) âˆ£ Polynomial.leadingCoeff p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational root theorem part 2:\\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\\nthen the denominator of `r` divides the leading coefficient \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ],\\n  Filter.Tendsto (fun r => râ»Â¹) Filter.atTop (nhdsWithin 0 (Set.Ioi 0))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `r â†¦ râ»Â¹` tends to `0` on the right as `r â†’ +âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b â‰  0 â†’ EuclideanDomain.r (EuclideanDomain.remainder a b) b\",\n  \"isProp\": true,\n  \"docString\": \"The relation `r` satisfies `r (a % b) b`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s : { x // x âˆˆ S })\\n  (t : R) (hst : â†‘s * t âˆˆ S), r /â‚’ s = r * t /â‚’ { val := â†‘s * t, property := hst }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fraction `r /â‚’ s` is equal to its expansion by an arbitrary factor `t` if `s * t âˆˆ S`. \"},\n {\"theorem\":\n  \"âˆ€ {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)],\\n  x ^ n = â†‘m â†’ Part.get (multiplicity (â†‘p) m) (_ : multiplicity.Finite (â†‘p) m) % n â‰  0 â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {r : Î± â†’ Î± â†’ Prop},\\n  WellFounded r â†’\\n    âˆ€ {a bot : Î±} {C : Î² â†’ Prop} {f : Î± â†’ Î²},\\n      (âˆ€ (b : Î±), f b â‰  f bot â†’ C (f b) â†’ âˆƒ c, r c b âˆ§ C (f c)) â†’ C (f a) â†’ C (f bot)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `r` be a well-founded relation on `Î±`, let `f : Î± â†’ Î²` be a function,\\nlet `C : Î² â†’ Prop`, and let `bot : Î±`.\\nThis induction principle shows that `C (f bot)` holds, given that\\n* some `a` satisfies `C (f a)`, and\\n* for each `b` such that `f b â‰  f bot` and `C (f b)` holds, there is `c`\\n  satisfying `r c b` and `C (f c)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¾ : â„}, Irrational Î¾ â†’ âˆ€ (q : â„š), âˆƒ q', |Î¾ - â†‘q'| < 1 / â†‘q'.den ^ 2 âˆ§ |Î¾ - â†‘q'| < |Î¾ - â†‘q|\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any rational approximation `q` to the irrational real number `Î¾`, there is\\na good rational approximation `q'` such that `|Î¾ - q'| < |Î¾ - q|`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {r r' râ‚ râ‚‚ : R}\\n  {s t : { x // x âˆˆ S }}, r * â†‘t = r' * â†‘t â†’ râ‚ * r * râ‚‚ /â‚’ s = râ‚ * r' * râ‚‚ /â‚’ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fractions which differ by a factor of the numerator can be proven equal if\\nthose factors expand to equal elements of `R`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Reflexive r â†’ âˆ€ {x y : Î±}, x â‰  y â†’ r x y â†” r x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`,\\nthen it holds whether or not `x â‰  y`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, padicValRat p â†‘n = â†‘(padicValNat p n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic value of an integer `z â‰  0` is its `p`-adic value as a rational. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"}]\n",
    "prompt_cons": "/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y :=\n\n/-- The product `r * x`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (â†‘r * x) â†” LiouvilleWith p x) :=\n\n/-- The product `x * r`, `r : â„š`, `r â‰  0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem âˆ€ {p x : â„} {r : â„š}, r â‰  0 â†’ (LiouvilleWith p (x * â†‘r) â†” LiouvilleWith p x) :=\n\n/-- To show a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`,\nit suffices to show it holds when `x â‰  y`. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Reflexive r â†’ âˆ€ {x y : Î±}, (x â‰  y â†’ r x y) â†’ r x y :=\n\n/-- If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- An additional constraint on `r`. -/\ntheorem âˆ€ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b â‰  0 â†’ Â¬EuclideanDomain.r (a * b) a :=\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x :=\n\n/-- Rational root theorem part 1:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the numerator of `r` divides the constant coefficient -/\ntheorem âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\n  â†‘(Polynomial.aeval r) p = 0 â†’ IsFractionRing.num A r âˆ£ Polynomial.coeff p 0 :=\n\n/-- Rational root theorem part 2:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the denominator of `r` divides the leading coefficient -/\ntheorem âˆ€ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\n  â†‘(Polynomial.aeval r) p = 0 â†’ â†‘(IsFractionRing.den A r) âˆ£ Polynomial.leadingCoeff p :=\n\n/-- The function `r â†¦ râ»Â¹` tends to `0` on the right as `r â†’ +âˆ`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ],\n  Filter.Tendsto (fun r => râ»Â¹) Filter.atTop (nhdsWithin 0 (Set.Ioi 0)) :=\n\n/-- The relation `r` satisfies `r (a % b) b`. -/\ntheorem âˆ€ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b â‰  0 â†’ EuclideanDomain.r (EuclideanDomain.remainder a b) b :=\n\n/-- A fraction `r /â‚’ s` is equal to its expansion by an arbitrary factor `t` if `s * t âˆˆ S`. -/\ntheorem âˆ€ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s : { x // x âˆˆ S })\n  (t : R) (hst : â†‘s * t âˆˆ S), r /â‚’ s = r * t /â‚’ { val := â†‘s * t, property := hst } :=\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem âˆ€ {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)],\n  x ^ n = â†‘m â†’ Part.get (multiplicity (â†‘p) m) (_ : multiplicity.Finite (â†‘p) m) % n â‰  0 â†’ Irrational x :=\n\n/-- Let `r` be a well-founded relation on `Î±`, let `f : Î± â†’ Î²` be a function,\nlet `C : Î² â†’ Prop`, and let `bot : Î±`.\nThis induction principle shows that `C (f bot)` holds, given that\n* some `a` satisfies `C (f a)`, and\n* for each `b` such that `f b â‰  f bot` and `C (f b)` holds, there is `c`\n  satisfying `r c b` and `C (f c)`. -/\ntheorem âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {r : Î± â†’ Î± â†’ Prop},\n  WellFounded r â†’\n    âˆ€ {a bot : Î±} {C : Î² â†’ Prop} {f : Î± â†’ Î²},\n      (âˆ€ (b : Î±), f b â‰  f bot â†’ C (f b) â†’ âˆƒ c, r c b âˆ§ C (f c)) â†’ C (f a) â†’ C (f bot) :=\n\n/-- Given any rational approximation `q` to the irrational real number `Î¾`, there is\na good rational approximation `q'` such that `|Î¾ - q'| < |Î¾ - q|`. -/\ntheorem âˆ€ {Î¾ : â„}, Irrational Î¾ â†’ âˆ€ (q : â„š), âˆƒ q', |Î¾ - â†‘q'| < 1 / â†‘q'.den ^ 2 âˆ§ |Î¾ - â†‘q'| < |Î¾ - â†‘q| :=\n\n/-- Fractions which differ by a factor of the numerator can be proven equal if\nthose factors expand to equal elements of `R`. -/\ntheorem âˆ€ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {r r' râ‚ râ‚‚ : R}\n  {s t : { x // x âˆˆ S }}, r * â†‘t = r' * â†‘t â†’ râ‚ * r * râ‚‚ /â‚’ s = râ‚ * r' * râ‚‚ /â‚’ s :=\n\n/-- If a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`,\nthen it holds whether or not `x â‰  y`. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}, Reflexive r â†’ âˆ€ {x y : Î±}, x â‰  y â†’ r x y â†” r x y :=\n\n/-- The `p`-adic value of an integer `z â‰  0` is its `p`-adic value as a rational. -/\ntheorem âˆ€ {p n : â„•}, padicValRat p â†‘n = â†‘(padicValNat p n) :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) â†” Ideal.IsPrime P :=\n\n/-- If `r` is rational (`r â‰  0`) and `x` is irrational, prove that `r+x` is irrational. -/\ntheorem",
    "choices": [
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {x : â„} {r : â„š}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {x : â„} {r : â„š}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {x : â„} (r : â„š), r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r x : â„}, Rational r â†’ Irrational x â†’ r â‰  0 â†’ Irrational (r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) ",
      "âˆ€ {r : â„š} {x : â„}, r â‰  0 â†’ Irrational x â†’ Irrational (â†‘r + x) "
    ]
  },
  {
    "docString": "Prove that there is no rational number whose square is `12`.",
    "prompts": "[{\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\": \"âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\": \"âˆ€ (self : â„š), self.den â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The denominator is nonzero. \"},\n {\"theorem\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n\",\n  \"isProp\": true,\n  \"docString\": \"Shows that all denominators are nonnegative. \"},\n {\"theorem\": \"Irrational goldenRatio\",\n  \"isProp\": true,\n  \"docString\": \"The golden ratio is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2\",\n  \"isProp\": true,\n  \"docString\": \"An inequality involving `2`. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"}]\n",
    "prompt_cons": "/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1 :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2} :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast :=\n\n/-- The denominator is nonzero. -/\ntheorem âˆ€ (self : â„š), self.den â‰  0 :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- Shows that all denominators are nonnegative. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n :=\n\n/-- The golden ratio is irrational. -/\ntheorem Irrational goldenRatio :=\n\n/-- An inequality involving `2`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Prove that there is no rational number whose square is `12`. -/\ntheorem",
    "choices": [
      "Â¬âˆƒ (q : â„š), q * q = 12 ",
      "Â¬âˆƒ (q : â„š), q ^ 2 = 12 ",
      "Â¬âˆƒ {q : â„š}, q * q = 12 ",
      "Â¬âˆƒ q : â„š, q ^ 2 = 12 ",
      "Irrational (Real.sqrt 12) ",
      "Â¬âˆƒ (a b : â„¤), b â‰  0 âˆ§ (a * a = 12 * (b * b)) ",
      "Â¬âˆƒ q : â„š, q * q = 12 ",
      "Â¬âˆƒ (q : â„š), q ^ 2 = 12 ",
      "Irrational (Real.sqrt 12) ",
      "Â¬âˆƒ q : â„š, q * q = 12 "
    ]
  },
  {
    "docString": "Let `A` be a nonempty set of real numbers which is bounded below. Let `-A` be the set of all numbers `-x`, where `x âˆˆ A`. Prove that `inf A = -sup (-A)`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±},\\n  BddBelow s â†’ BddAbove s â†’ Set.Nonempty s â†’ sInf s â‰¤ sSup s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is bounded below and above, and nonempty, its infimum is less than or equal to\\nits supremum.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  {p q : Seminorm ğ•œ E} {x : E}, BddBelow (Set.range fun u => â†‘p u + â†‘q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"},\n {\"theorem\":\n  \"âˆ€ {S : Set â„} {a : â„}, (âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ a) â†’ 0 â‰¤ a â†’ sSup S â‰¤ a\",\n  \"isProp\": true,\n  \"docString\":\n  \"As `0` is the default value for `Real.sSup` of the empty set or sets which are not bounded above, it\\nsuffices to show that all elements of `S` are bounded by a nonnegative number to show that `sSup S`\\nis bounded by this number.\\n\"},\n {\"theorem\": \"âˆ€ (S : Set â„), (âˆ€ (x : â„), x âˆˆ S â†’ 0 â‰¤ x) â†’ 0 â‰¤ sInf S\",\n  \"isProp\": true,\n  \"docString\":\n  \"As `0` is the default value for `Real.sInf` of the empty set, it suffices to show that `S` is\\nbounded below by `0` to show that `0 â‰¤ sInf S`.\\n\"},\n {\"theorem\": \"âˆ€ {Î¹ : Sort u_1} {f : Î¹ â†’ â„}, (âˆ€ (i : Î¹), 0 â‰¤ f i) â†’ 0 â‰¤ iInf f\",\n  \"isProp\": true,\n  \"docString\":\n  \"As `0` is the default value for `Real.sInf` of the empty set, it suffices to show that `f i` is\\nbounded below by `0` to show that `0 â‰¤ iInf f`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Sort u_1} {f : Î¹ â†’ â„}, (âˆ€ (i : Î¹), 0 â‰¤ f i) â†’ 0 â‰¤ â¨† (i : Î¹), f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"As `0` is the default value for `Real.sSup` of the empty set or sets which are not bounded above, it\\nsuffices to show that `f i` is nonnegative to show that `0 â‰¤ â¨† i, f i`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s t : Set Î±},\\n  BddBelow s â†’ BddBelow t â†’ Set.Nonempty (s âˆ© t) â†’ sInf s âŠ” sInf t â‰¤ sInf (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The infimum of an intersection of two sets is bounded below by the maximum of the\\ninfima of each set, if all sets are bounded below and nonempty.\"},\n {\"theorem\": \"âˆ€ (S : Set â„), (âˆ€ (x : â„), x âˆˆ S â†’ 0 â‰¤ x) â†’ 0 â‰¤ sSup S\",\n  \"isProp\": true,\n  \"docString\":\n  \"As `0` is the default value for `Real.sSup` of the empty set or sets which are not bounded above, it\\nsuffices to show that `S` is bounded below by `0` to show that `0 â‰¤ sSup S`.\\n\"},\n {\"theorem\": \"âˆ€ (S : Set â„), (âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ 0) â†’ sInf S â‰¤ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"As `0` is the default value for `Real.sInf` of the empty set or sets which are not bounded below, it\\nsuffices to show that `S` is bounded above by `0` to show that `sInf S â‰¤ 0`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  Set.Nonempty â†‘s1 â†’\\n    Set.Nonempty â†‘s2 â†’\\n      â†‘s1 âˆ© â†‘s2 = âˆ… â†’ AffineSubspace.direction s1 âŠ” AffineSubspace.direction s2 < AffineSubspace.direction (s1 âŠ” s2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sup of the directions of two nonempty affine subspaces with empty intersection is less than\\nthe direction of their sup. \"},\n {\"theorem\": \"âˆ€ (S : Set â„), (âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ 0) â†’ sSup S â‰¤ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"As `0` is the default value for `Real.sSup` of the empty set, it suffices to show that `S` is\\nbounded above by `0` to show that `sSup S â‰¤ 0`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {A B : Finset Î±}, A âŠ‚ B â†’ Finset.toColex A < Finset.toColex B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `A âŠ‚ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\\n`âŠ†` is not a linear order. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : ConditionallyCompleteLinearOrderedField Î±] (s : Set Î±) (a : Î±), BddAbove s â†’ a âˆˆ s â†’ a â‰¤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"`a â‰¤ sSup s` for all `a âˆˆ s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\\n  [inst_2 : OrderTopology Î±] [inst_3 : ConditionallyCompleteLinearOrder Î²] [inst_4 : TopologicalSpace Î²]\\n  [inst_5 : OrderClosedTopology Î²] {f : Î± â†’ Î²} {s : Set Î±},\\n  ContinuousAt f (sInf s) â†’ Antitone f â†’ Set.Nonempty s â†’ BddBelow s â†’ f (sInf s) = sSup (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an antitone function is continuous at the infimum of a nonempty bounded below set `s`,\\nthen it sends this infimum to the supremum of the image of `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\\n  [inst_2 : OrderTopology Î±] [inst_3 : ConditionallyCompleteLinearOrder Î²] [inst_4 : TopologicalSpace Î²]\\n  [inst_5 : OrderClosedTopology Î²] {f : Î± â†’ Î²} {s : Set Î±},\\n  ContinuousAt f (sInf s) â†’ Monotone f â†’ Set.Nonempty s â†’ BddBelow s â†’ f (sInf s) = sInf (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,\\nthen it sends this infimum to the infimum of the image of `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a\",\n  \"isProp\": true,\n  \"docString\": \"`-a â‰¤ b â†” -b â‰¤ a` on `EReal`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] â¦ƒs t : Set Î±â¦„, s âŠ† t â†’ BddBelow t â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"If `s âŠ† t` and `t` is bounded below, then so is `s`. \"}]\n",
    "prompt_cons": "/-- If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±},\n  BddBelow s â†’ BddAbove s â†’ Set.Nonempty s â†’ sInf s â‰¤ sSup s :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : NormedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  {p q : Seminorm ğ•œ E} {x : E}, BddBelow (Set.range fun u => â†‘p u + â†‘q (x - u)) :=\n\n/-- As `0` is the default value for `Real.sSup` of the empty set or sets which are not bounded above, it\nsuffices to show that all elements of `S` are bounded by a nonnegative number to show that `sSup S`\nis bounded by this number. -/\ntheorem âˆ€ {S : Set â„} {a : â„}, (âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ a) â†’ 0 â‰¤ a â†’ sSup S â‰¤ a :=\n\n/-- As `0` is the default value for `Real.sInf` of the empty set, it suffices to show that `S` is\nbounded below by `0` to show that `0 â‰¤ sInf S`. -/\ntheorem âˆ€ (S : Set â„), (âˆ€ (x : â„), x âˆˆ S â†’ 0 â‰¤ x) â†’ 0 â‰¤ sInf S :=\n\n/-- As `0` is the default value for `Real.sInf` of the empty set, it suffices to show that `f i` is\nbounded below by `0` to show that `0 â‰¤ iInf f`. -/\ntheorem âˆ€ {Î¹ : Sort u_1} {f : Î¹ â†’ â„}, (âˆ€ (i : Î¹), 0 â‰¤ f i) â†’ 0 â‰¤ iInf f :=\n\n/-- As `0` is the default value for `Real.sSup` of the empty set or sets which are not bounded above, it\nsuffices to show that `f i` is nonnegative to show that `0 â‰¤ â¨† i, f i`. -/\ntheorem âˆ€ {Î¹ : Sort u_1} {f : Î¹ â†’ â„}, (âˆ€ (i : Î¹), 0 â‰¤ f i) â†’ 0 â‰¤ â¨† (i : Î¹), f i :=\n\n/-- The infimum of an intersection of two sets is bounded below by the maximum of the\ninfima of each set, if all sets are bounded below and nonempty. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s t : Set Î±},\n  BddBelow s â†’ BddBelow t â†’ Set.Nonempty (s âˆ© t) â†’ sInf s âŠ” sInf t â‰¤ sInf (s âˆ© t) :=\n\n/-- As `0` is the default value for `Real.sSup` of the empty set or sets which are not bounded above, it\nsuffices to show that `S` is bounded below by `0` to show that `0 â‰¤ sSup S`. -/\ntheorem âˆ€ (S : Set â„), (âˆ€ (x : â„), x âˆˆ S â†’ 0 â‰¤ x) â†’ 0 â‰¤ sSup S :=\n\n/-- As `0` is the default value for `Real.sInf` of the empty set or sets which are not bounded below, it\nsuffices to show that `S` is bounded above by `0` to show that `sInf S â‰¤ 0`. -/\ntheorem âˆ€ (S : Set â„), (âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ 0) â†’ sInf S â‰¤ 0 :=\n\n/-- The sup of the directions of two nonempty affine subspaces with empty intersection is less than\nthe direction of their sup. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  Set.Nonempty â†‘s1 â†’\n    Set.Nonempty â†‘s2 â†’\n      â†‘s1 âˆ© â†‘s2 = âˆ… â†’ AffineSubspace.direction s1 âŠ” AffineSubspace.direction s2 < AffineSubspace.direction (s1 âŠ” s2) :=\n\n/-- As `0` is the default value for `Real.sSup` of the empty set, it suffices to show that `S` is\nbounded above by `0` to show that `sSup S â‰¤ 0`. -/\ntheorem âˆ€ (S : Set â„), (âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ 0) â†’ sSup S â‰¤ 0 :=\n\n/-- If `A âŠ‚ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\n`âŠ†` is not a linear order. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {A B : Finset Î±}, A âŠ‚ B â†’ Finset.toColex A < Finset.toColex B :=\n\n/-- `a â‰¤ sSup s` for all `a âˆˆ s`. -/\ntheorem âˆ€ {Î± : Type u_1} [self : ConditionallyCompleteLinearOrderedField Î±] (s : Set Î±) (a : Î±), BddAbove s â†’ a âˆˆ s â†’ a â‰¤ sSup s :=\n\n/-- If an antitone function is continuous at the infimum of a nonempty bounded below set `s`,\nthen it sends this infimum to the supremum of the image of `s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OrderTopology Î±] [inst_3 : ConditionallyCompleteLinearOrder Î²] [inst_4 : TopologicalSpace Î²]\n  [inst_5 : OrderClosedTopology Î²] {f : Î± â†’ Î²} {s : Set Î±},\n  ContinuousAt f (sInf s) â†’ Antitone f â†’ Set.Nonempty s â†’ BddBelow s â†’ f (sInf s) = sSup (f '' s) :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,\nthen it sends this infimum to the infimum of the image of `s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OrderTopology Î±] [inst_3 : ConditionallyCompleteLinearOrder Î²] [inst_4 : TopologicalSpace Î²]\n  [inst_5 : OrderClosedTopology Î²] {f : Î± â†’ Î²} {s : Set Î±},\n  ContinuousAt f (sInf s) â†’ Monotone f â†’ Set.Nonempty s â†’ BddBelow s â†’ f (sInf s) = sInf (f '' s) :=\n\n/-- A least element of a set is the infimum of this set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ sInf s = a :=\n\n/-- `-a â‰¤ b â†” -b â‰¤ a` on `EReal`. -/\ntheorem âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a :=\n\n/-- If `s âŠ† t` and `t` is bounded below, then so is `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] â¦ƒs t : Set Î±â¦„, s âŠ† t â†’ BddBelow t â†’ BddBelow s :=\n\n/-- Let `A` be a nonempty set of real numbers which is bounded below. Let `-A` be the set of all numbers `-x`, where `x âˆˆ A`. Prove that `inf A = -sup (-A)`. -/\ntheorem",
    "choices": [
      "âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup ((Î» x, -x) '' A) ",
      "âˆ€ (A : Set â„), BddBelow A â†’ Set.Nonempty A â†’ sInf A = -sSup (HasNegPart.neg â»Â¹' A) ",
      "âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (-A) ",
      "âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (Neg.neg '' A) ",
      "âˆ€ {A : Set â„}, Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (-A) ",
      "âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup ((Î» x, -x) '' A) ",
      "âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (Neg.neg '' A) ",
      "âˆ€ {A : Set â„}, Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (Neg.neg '' A) ",
      "âˆ€ (A : Set â„), Set.Nonempty A â†’ BddBelow A â†’ sInf A = -sSup (Set.Image (Î» (x : â„), -x) A) ",
      "forall {A : Set â„} (hâ‚ : A.nonempty) (hâ‚‚ : BddBelow A),\n  sInf A = -sSup {x | âˆƒ y âˆˆ A, x = -y} "
    ]
  },
  {
    "docString": "If `z` is a complex number, prove that there exists an `r â‰¥ 0` and a complex number `w` with `| w | = 1` such that `z = rw`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0]\",\n  \"isProp\": true,\n  \"docString\":\n  \"There are several equivalent ways to say that a number `z` is in fact a real number. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S â€¢ z| < 1`. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„‚ Ã— â„‚}, 0 < p.fst.re âˆ¨ p.fst.im â‰  0 â†’ ContinuousAt (fun x => x.fst ^ x.snd) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `z ^ w` is continuous in `(z, w)` provided that `z` does not belong to the interval\\n`(-âˆ, 0]` on the real line. See also `Complex.continuousAt_cpow_zero_of_re_pos` for a version that\\nworks for `z = 0` but assumes `0 < re w`. \"},\n {\"theorem\":\n  \"Filter.Tendsto cexp (Filter.comap Complex.re Filter.atBot) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\": \"`Complex.exp z â†’ 0` as `Complex.re z â†’ -âˆ`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : DivisionRing R] [inst_1 : CharZero R] {p r : R} {z : â„¤},\\n  z â‰  0 â†’ (z â€¢ r âˆˆ AddSubgroup.zmultiples p â†” âˆƒ k, r - â†‘k â€¢ (p / â†‘z) âˆˆ AddSubgroup.zmultiples p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`z â€¢ r` is a multiple of `p` iff `r` is `pk/z` above a multiple of `p`, where `0 â‰¤ k < |z|`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_1} {F : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  r â‰  0 â†’\\n    âˆ€ {a : â„},\\n      a âˆˆ Set.Ioo (-1) 1 â†’\\n        ((fun n => â€–p nâ€– * â†‘r ^ n) =O[Filter.atTop] fun x => a ^ x) â†’ â†‘r < FormalMultilinearSeries.radius p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `r â‰  0` and `â€–pâ‚™â€– râ¿ = O(aâ¿)` for some `-1 < a < 1`, then `r < p.radius`. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. \"},\n {\"theorem\":\n  \"âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\\n  0 < r â†’\\n    r â‰¤ R â†’\\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\\n        Set.Countable s â†’\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) â†’\\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"âˆ€ {c w : â„‚} {R : â„} {n : â„¤}, CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ Â¬w âˆˆ Metric.sphere c |R|\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `Î» z, (z - w) ^ n`, `n : â„¤`, is circle integrable on the circle with center `c` and\\nradius `|R|` if and only if `R = 0` or `0 â‰¤ n`, or `w` does not belong to this circle. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, padicValRat p â†‘n = â†‘(padicValNat p n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic value of an integer `z â‰  0` is its `p`-adic value as a rational. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„},\\n  a â‰¤ 0 â†’\\n    âˆ€ {z : â„‚},\\n      |z.im| â‰¤ b â†’\\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\\n$$\\\\left|exp^{a\\\\left(e^{z}+e^{-z}\\\\right)}\\\\right| \\\\le e^{a\\\\cos b \\\\exp^{|re z|}}.$$\\n\"},\n {\"theorem\": \"âˆ€ (s : â„‚), riemannCompletedZeta (1 - s) = riemannCompletedZeta s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann zeta functional equation, formulated for `Î›`: for any complex `s` we have\\n`Î› (1 - s) = Î› s`. \"}]\n",
    "prompt_cons": "/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0] :=\n\n/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2 :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- If `1 < |z|`, then `|S â€¢ z| < 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1 :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I) :=\n\n/-- If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- The function `z ^ w` is continuous in `(z, w)` provided that `z` does not belong to the interval\n`(-âˆ, 0]` on the real line. See also `Complex.continuousAt_cpow_zero_of_re_pos` for a version that\nworks for `z = 0` but assumes `0 < re w`. -/\ntheorem âˆ€ {p : â„‚ Ã— â„‚}, 0 < p.fst.re âˆ¨ p.fst.im â‰  0 â†’ ContinuousAt (fun x => x.fst ^ x.snd) p :=\n\n/-- `Complex.exp z â†’ 0` as `Complex.re z â†’ -âˆ`. -/\ntheorem Filter.Tendsto cexp (Filter.comap Complex.re Filter.atBot) (nhds 0) :=\n\n/-- `z â€¢ r` is a multiple of `p` iff `r` is `pk/z` above a multiple of `p`, where `0 â‰¤ k < |z|`. -/\ntheorem âˆ€ {R : Type u_1} [inst : DivisionRing R] [inst_1 : CharZero R] {p r : R} {z : â„¤},\n  z â‰  0 â†’ (z â€¢ r âˆˆ AddSubgroup.zmultiples p â†” âˆƒ k, r - â†‘k â€¢ (p / â†‘z) âˆˆ AddSubgroup.zmultiples p) :=\n\n/-- If `r â‰  0` and `â€–pâ‚™â€– râ¿ = O(aâ¿)` for some `-1 < a < 1`, then `r < p.radius`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_1} {F : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  r â‰  0 â†’\n    âˆ€ {a : â„},\n      a âˆˆ Set.Ioo (-1) 1 â†’\n        ((fun n => â€–p nâ€– * â†‘r ^ n) =O[Filter.atTop] fun x => a ^ x) â†’ â†‘r < FormalMultilinearSeries.radius p :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. -/\ntheorem âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\nequal to each other. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\n  0 < r â†’\n    r â‰¤ R â†’\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\n        Set.Countable s â†’\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) â†’\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\ Metric.closedBall c r) \\ s â†’ DifferentiableAt â„‚ f z) â†’\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z :=\n\n/-- The function `Î» z, (z - w) ^ n`, `n : â„¤`, is circle integrable on the circle with center `c` and\nradius `|R|` if and only if `R = 0` or `0 â‰¤ n`, or `w` does not belong to this circle. -/\ntheorem âˆ€ {c w : â„‚} {R : â„} {n : â„¤}, CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ Â¬w âˆˆ Metric.sphere c |R| :=\n\n/-- The `p`-adic value of an integer `z â‰  0` is its `p`-adic value as a rational. -/\ntheorem âˆ€ {p n : â„•}, padicValRat p â†‘n = â†‘(padicValNat p n) :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y :=\n\n/-- A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$ -/\ntheorem âˆ€ {a b : â„},\n  a â‰¤ 0 â†’\n    âˆ€ {z : â„‚},\n      |z.im| â‰¤ b â†’\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|) :=\n\n/-- Riemann zeta functional equation, formulated for `Î›`: for any complex `s` we have\n`Î› (1 - s) = Î› s`. -/\ntheorem âˆ€ (s : â„‚), riemannCompletedZeta (1 - s) = riemannCompletedZeta s :=\n\n/-- If `z` is a complex number, prove that there exists an `r â‰¥ 0` and a complex number `w` with `| w | = 1` such that `z = rw`. -/\ntheorem",
    "choices": [
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), 0 â‰¤ r âˆ§ w.abs = 1 âˆ§ z = r â€¢ w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), 0 â‰¤ r âˆ§ â†‘Complex.abs w = 1 âˆ§ z = â†‘r * w ",
      "âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ Complex.abs w = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ r w, r â‰¥ 0 âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ r w, 0 â‰¤ r âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r â€¢ w ",
      "âˆ€ (z : â„‚), âˆƒ r : â„, âˆƒ w : â„‚, 0 â‰¤ r âˆ§ abs w = 1 âˆ§ z = r * w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), 0 â‰¤ r âˆ§ âˆ¥wâˆ¥ = 1 âˆ§ z = r â€¢ w ",
      "âˆ€ (z : â„‚), âˆƒ (r : â„) (w : â„‚), r â‰¥ 0 âˆ§ â†‘Complex.abs w = 1 âˆ§ z = r â€¢ w "
    ]
  },
  {
    "docString": "If `x, y` are complex, prove that `||x|-|y|| â‰¤ |x-y|`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s\",\n  \"isProp\": true,\n  \"docString\": \"It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {x y : Î±}, x = y â†’ y â‰¤ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x = y` then `y â‰¤ x`. Note: this lemma uses `y â‰¤ x` instead of `x â‰¥ y`, because `le` is used\\nalmost exclusively in mathlib. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a\",\n  \"isProp\": true,\n  \"docString\": \"`-a â‰¤ b â†” -b â‰¤ a` on `EReal`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E},\\n  Â¬SameRay â„ x y â†’ â€–x + yâ€– < â€–xâ€– + â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a strictly convex space, if `x` and `y` are not in the same ray, then `â€–x + yâ€– < â€–xâ€– + â€–yâ€–`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : OrderedAddCommMonoid Î±] [self : Archimedean Î±] (x : Î±) {y : Î±}, 0 < y â†’ âˆƒ n, x â‰¤ n â€¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any two elements `x`, `y` such that `0 < y`, there exists a natural number `n`\\nsuch that `x â‰¤ n â€¢ y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {f : Î± â†’ â„} (K : â„),\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + K * dist x y) â†’ LipschitzOnWith (Real.toNNReal K) f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\\ndoesn't assume `0â‰¤K`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  inner (x - y) (x - y) = inner x x - 2 * inner x y + inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Expand `âŸªx - y, x - yâŸ«_â„` \"},\n {\"theorem\": \"âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : Î± â†’ â„} (K : NNReal),\\n  (âˆ€ (x y : Î±), f x â‰¤ f y + â†‘K * dist x y) â†’ LipschitzWith K f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\\nassumes `0â‰¤K`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {l : Filter Î±} {f : Î± â†’ E},\\n  Filter.Tendsto (fun y => â€–f yâ€–) l Filter.atTop â†’ âˆ€ (x : E), âˆ€á¶  (y : Î±) in l, f y â‰  x\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–yâ€– â†’ âˆ`, then we can assume `y â‰  x` for any fixed `x`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, a â‰¤ -b â†’ b â‰¤ -a\",\n  \"isProp\": true,\n  \"docString\": \"`a â‰¤ -b â†’ b â‰¤ -a` on ereal \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S â€¢ z| < 1`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E}\\n  {a b r : â„}, â€–xâ€– â‰¤ r â†’ â€–yâ€– â‰¤ r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ â€–a â€¢ x + b â€¢ yâ€– < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`\\nand `y` with positive coefficients has norm strictly less than `r`. \"},\n {\"theorem\":\n  \"âˆ€ {y : â„}, 0 < y â†’ Filter.Tendsto (fun x => x ^ y) Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `x ^ y` tends to `+âˆ` at `+âˆ` for any positive real `y`. \"},\n {\"theorem\":\n  \"âˆ€ {y : â„}, 0 < y â†’ Filter.Tendsto (fun x => x ^ (-y)) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `x ^ (-y)` tends to `0` at `+âˆ` for any positive real `y`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {x y : E},\\n  SameRay â„ x y â†’ â€–x + yâ€– = â€–xâ€– + â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are on the same ray, then the triangle inequality becomes the equality: the norm\\nof `x + y` is the sum of the norms of `x` and `y`. The converse is true for a strictly convex\\nspace. \"},\n {\"theorem\":\n  \"âˆ€ (a b : NNReal) {p q : â„}, Real.IsConjugateExponent p q â†’ a * b â‰¤ a ^ p / Real.toNNReal p + b ^ q / Real.toNNReal q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Young's inequality, `â„â‰¥0` version with real conjugate exponents. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y z : E}\\n  {a b r : â„},\\n  x âˆˆ Metric.closedBall z r â†’\\n    y âˆˆ Metric.closedBall z r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ Metric.ball z r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x â‰  y` belong to the same closed ball, then a convex combination of `x` and `y` with\\npositive coefficients belongs to the corresponding open ball. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. \"}]\n",
    "prompt_cons": "/-- It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s :=\n\n/-- If `x = y` then `y â‰¤ x`. Note: this lemma uses `y â‰¤ x` instead of `x â‰¥ y`, because `le` is used\nalmost exclusively in mathlib. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {x y : Î±}, x = y â†’ y â‰¤ x :=\n\n/-- `-a â‰¤ b â†” -b â‰¤ a` on `EReal`. -/\ntheorem âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a :=\n\n/-- In a strictly convex space, if `x` and `y` are not in the same ray, then `â€–x + yâ€– < â€–xâ€– + â€–yâ€–`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E},\n  Â¬SameRay â„ x y â†’ â€–x + yâ€– < â€–xâ€– + â€–yâ€– :=\n\n/-- For any two elements `x`, `y` such that `0 < y`, there exists a natural number `n`\nsuch that `x â‰¤ n â€¢ y`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : OrderedAddCommMonoid Î±] [self : Archimedean Î±] (x : Î±) {y : Î±}, 0 < y â†’ âˆƒ n, x â‰¤ n â€¢ y :=\n\n/-- For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\ndoesn't assume `0â‰¤K`. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {f : Î± â†’ â„} (K : â„),\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + K * dist x y) â†’ LipschitzOnWith (Real.toNNReal K) f s :=\n\n/-- Expand `âŸªx - y, x - yâŸ«_â„` -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  inner (x - y) (x - y) = inner x x - 2 * inner x y + inner y y :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y :=\n\n/-- For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\nassumes `0â‰¤K`. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : Î± â†’ â„} (K : NNReal),\n  (âˆ€ (x y : Î±), f x â‰¤ f y + â†‘K * dist x y) â†’ LipschitzWith K f :=\n\n/-- If `â€–yâ€– â†’ âˆ`, then we can assume `y â‰  x` for any fixed `x`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {l : Filter Î±} {f : Î± â†’ E},\n  Filter.Tendsto (fun y => â€–f yâ€–) l Filter.atTop â†’ âˆ€ (x : E), âˆ€á¶  (y : Î±) in l, f y â‰  x :=\n\n/-- Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- `a â‰¤ -b â†’ b â‰¤ -a` on ereal -/\ntheorem âˆ€ {a b : EReal}, a â‰¤ -b â†’ b â‰¤ -a :=\n\n/-- If `1 < |z|`, then `|S â€¢ z| < 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1 :=\n\n/-- If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`\nand `y` with positive coefficients has norm strictly less than `r`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E}\n  {a b r : â„}, â€–xâ€– â‰¤ r â†’ â€–yâ€– â‰¤ r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ â€–a â€¢ x + b â€¢ yâ€– < r :=\n\n/-- The function `x ^ y` tends to `+âˆ` at `+âˆ` for any positive real `y`. -/\ntheorem âˆ€ {y : â„}, 0 < y â†’ Filter.Tendsto (fun x => x ^ y) Filter.atTop Filter.atTop :=\n\n/-- The function `x ^ (-y)` tends to `0` at `+âˆ` for any positive real `y`. -/\ntheorem âˆ€ {y : â„}, 0 < y â†’ Filter.Tendsto (fun x => x ^ (-y)) Filter.atTop (nhds 0) :=\n\n/-- If `x` and `y` are on the same ray, then the triangle inequality becomes the equality: the norm\nof `x + y` is the sum of the norms of `x` and `y`. The converse is true for a strictly convex\nspace. -/\ntheorem âˆ€ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {x y : E},\n  SameRay â„ x y â†’ â€–x + yâ€– = â€–xâ€– + â€–yâ€– :=\n\n/-- Young's inequality, `â„â‰¥0` version with real conjugate exponents. -/\ntheorem âˆ€ (a b : NNReal) {p q : â„}, Real.IsConjugateExponent p q â†’ a * b â‰¤ a ^ p / Real.toNNReal p + b ^ q / Real.toNNReal q :=\n\n/-- If `x â‰  y` belong to the same closed ball, then a convex combination of `x` and `y` with\npositive coefficients belongs to the corresponding open ball. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y z : E}\n  {a b r : â„},\n  x âˆˆ Metric.closedBall z r â†’\n    y âˆˆ Metric.closedBall z r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ x + b â€¢ y âˆˆ Metric.ball z r :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y :=\n\n/-- If `x, y` are complex, prove that `||x|-|y|| â‰¤ |x-y|`. -/\ntheorem",
    "choices": [
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, |x| - |y| â‰¤ |x - y| ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) ",
      "âˆ€ {x y : â„‚}, |x| - |y| â‰¤ |x - y| ",
      "âˆ€ {x y : â„‚}, Complex.abs (Complex.abs x - Complex.abs y) â‰¤ Complex.abs (x - y) ",
      "âˆ€ (x y : â„‚), |x.abs - y.abs| â‰¤ (x - y).abs ",
      "âˆ€ {x y : â„‚}, abs (abs x - abs y) â‰¤ abs (x - y) "
    ]
  },
  {
    "docString": "Suppose `k â‰¥ 3`, `x, y âˆˆ â„^k`, `|x - y| = d > 0`, and `r > 0`. Prove that if `2r > d`, there are infinitely many `z âˆˆ â„^k` such that `|z-x|=|z-y|=r`.",
    "prompts": "[{\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} (d : X â†’ X â†’ NNReal) (dist_self : âˆ€ (x : X), d x x = 0) (dist_comm : âˆ€ (x y : X), d x y = d y x),\\n  (âˆ€ (xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ : X), d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚) (max (d xâ‚‚ xâ‚ƒ) (d xâ‚ƒ xâ‚„))) â†’ âˆ€ (x y : X), â†‘(d x y) â‰¤ 2 * dist x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a function `d : X â†’ X â†’ â„â‰¥0` such that `d x x = 0` and `d x y = d y x` for all `x`,\\n`y`. Let `dist` be the largest pseudometric distance such that `dist x y â‰¤ d x y`, see\\n`PseudoMetricSpace.ofPreNNDist`. Suppose that `d` satisfies the following triangle-like\\ninequality: `d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚, d xâ‚‚ xâ‚ƒ, d xâ‚ƒ xâ‚„)`. Then `d x y â‰¤ 2 * dist x y` for all\\n`x`, `y`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  â†‘r < FormalMultilinearSeries.radius p â†’ âˆƒ a, a âˆˆ Set.Ioo 0 1 âˆ§ âˆƒ C, C > 0 âˆ§ âˆ€ (n : â„•), â€–p nâ€– * â†‘r ^ n â‰¤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\\nfor some `0 < a < 1` and `C > 0`, `â€–p nâ€– * r ^ n â‰¤ C * a ^ n`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  â†‘r < FormalMultilinearSeries.radius p â†’ âˆƒ C, C > 0 âˆ§ âˆ€ (n : â„•), â€–p nâ€– * â†‘r ^ n â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : TopologicalSpace.SecondCountableTopology X] {s : Set X}\\n  {r : ENNReal}, r < dimH s â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (t : Set X), t âˆˆ nhdsWithin x s â†’ r < dimH t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `r` is less than the Hausdorff dimension of a set `s` in an (extended) metric space with\\nsecond countable topology, then there exists a point `x âˆˆ s` such that every neighborhood\\n`t` of `x` within `s` has Hausdorff dimension greater than `r`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  â†‘r < FormalMultilinearSeries.radius p â†’\\n    âˆƒ a, a âˆˆ Set.Ioo 0 1 âˆ§ (fun n => â€–p nâ€– * â†‘r ^ n) =o[Filter.atTop] fun x => a ^ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\\nfor some `0 < a < 1`, `â€–p nâ€– râ¿ = o(aâ¿)`. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±} {s t : Set Î±} {r : ENNReal},\\n  x âˆˆ s â†’ EMetric.hausdorffEdist s t < r â†’ âˆƒ y, y âˆˆ t âˆ§ edist x y < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the Hausdorff distance is `< r`, then any point in one of the sets has\\na corresponding point at distance `< r` in the other set \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  â†‘r < FormalMultilinearSeries.radius p â†’ (fun n => â€–p nâ€– * â†‘r ^ n) =o[Filter.atTop] fun x => 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿ = o(1)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_2 : MeasureTheory.Measure.OuterRegular Î¼] (A : Set Î±) (r : ENNReal),\\n  â†‘â†‘Î¼ A < r â†’ âˆƒ U, U âŠ‡ A âˆ§ IsOpen U âˆ§ â†‘â†‘Î¼ U < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `r` larger than the measure of a set `A`, there exists an open superset of `A` with\\nmeasure less than `r`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {l : Filter Î±} {f : Î± â†’ E},\\n  Filter.Tendsto (fun y => â€–f yâ€–) l Filter.atTop â†’ âˆ€ (x : E), âˆ€á¶  (y : Î±) in l, f y â‰  x\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–yâ€– â†’ âˆ`, then we can assume `y â‰  x` for any fixed `x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±} {r : â„},\\n  Set.Nonempty s â†’ (Metric.infDist x s < r â†” âˆƒ y, y âˆˆ s âˆ§ dist x y < r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal distance to a set is `< r` iff there exists a point in this set at distance `< r` \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_1} {F : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\\n  r â‰  0 â†’\\n    âˆ€ {a : â„},\\n      a âˆˆ Set.Ioo (-1) 1 â†’\\n        ((fun n => â€–p nâ€– * â†‘r ^ n) =O[Filter.atTop] fun x => a ^ x) â†’ â†‘r < FormalMultilinearSeries.radius p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `r â‰  0` and `â€–pâ‚™â€– râ¿ = O(aâ¿)` for some `-1 < a < 1`, then `r < p.radius`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E}\\n  {a b r : â„}, â€–xâ€– â‰¤ r â†’ â€–yâ€– â‰¤ r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ â€–a â€¢ x + b â€¢ yâ€– < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`\\nand `y` with positive coefficients has norm strictly less than `r`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±} {x : Î±} {r : â„},\\n  x âˆˆ s â†’ Metric.hausdorffDist s t < r â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ âˆƒ y, y âˆˆ t âˆ§ dist x y < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the Hausdorff distance is `< r`, then any point in one of the sets is at distance\\n`< r` of a point in the other set \"}]\n",
    "prompt_cons": "/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- Consider a function `d : X â†’ X â†’ â„â‰¥0` such that `d x x = 0` and `d x y = d y x` for all `x`,\n`y`. Let `dist` be the largest pseudometric distance such that `dist x y â‰¤ d x y`, see\n`PseudoMetricSpace.ofPreNNDist`. Suppose that `d` satisfies the following triangle-like\ninequality: `d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚, d xâ‚‚ xâ‚ƒ, d xâ‚ƒ xâ‚„)`. Then `d x y â‰¤ 2 * dist x y` for all\n`x`, `y`. -/\ntheorem âˆ€ {X : Type u_1} (d : X â†’ X â†’ NNReal) (dist_self : âˆ€ (x : X), d x x = 0) (dist_comm : âˆ€ (x y : X), d x y = d y x),\n  (âˆ€ (xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ : X), d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚) (max (d xâ‚‚ xâ‚ƒ) (d xâ‚ƒ xâ‚„))) â†’ âˆ€ (x y : X), â†‘(d x y) â‰¤ 2 * dist x y :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `râ‚ râ‚‚`\nsuch that `râ‚ â€¢ x = râ‚‚ â€¢ y`. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y â†’ x â‰  0 â†’ y â‰  0 â†’ âˆƒ râ‚ râ‚‚, 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y :=\n\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\nfor some `0 < a < 1` and `C > 0`, `â€–p nâ€– * r ^ n â‰¤ C * a ^ n`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  â†‘r < FormalMultilinearSeries.radius p â†’ âˆƒ a, a âˆˆ Set.Ioo 0 1 âˆ§ âˆƒ C, C > 0 âˆ§ âˆ€ (n : â„•), â€–p nâ€– * â†‘r ^ n â‰¤ C * a ^ n :=\n\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` is bounded. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  â†‘r < FormalMultilinearSeries.radius p â†’ âˆƒ C, C > 0 âˆ§ âˆ€ (n : â„•), â€–p nâ€– * â†‘r ^ n â‰¤ C :=\n\n/-- If `r` is less than the Hausdorff dimension of a set `s` in an (extended) metric space with\nsecond countable topology, then there exists a point `x âˆˆ s` such that every neighborhood\n`t` of `x` within `s` has Hausdorff dimension greater than `r`. -/\ntheorem âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : TopologicalSpace.SecondCountableTopology X] {s : Set X}\n  {r : ENNReal}, r < dimH s â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (t : Set X), t âˆˆ nhdsWithin x s â†’ r < dimH t :=\n\n/-- If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n :=\n\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\nfor some `0 < a < 1`, `â€–p nâ€– râ¿ = o(aâ¿)`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  â†‘r < FormalMultilinearSeries.radius p â†’\n    âˆƒ a, a âˆˆ Set.Ioo 0 1 âˆ§ (fun n => â€–p nâ€– * â†‘r ^ n) =o[Filter.atTop] fun x => a ^ x :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- If the Hausdorff distance is `< r`, then any point in one of the sets has\na corresponding point at distance `< r` in the other set -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±} {s t : Set Î±} {r : ENNReal},\n  x âˆˆ s â†’ EMetric.hausdorffEdist s t < r â†’ âˆƒ y, y âˆˆ t âˆ§ edist x y < r :=\n\n/-- If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {r : â„}, 1 < r â†’ (fun n => â†‘n ^ k) =o[Filter.atTop] fun n => r ^ n :=\n\n/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿ = o(1)`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  â†‘r < FormalMultilinearSeries.radius p â†’ (fun n => â€–p nâ€– * â†‘r ^ n) =o[Filter.atTop] fun x => 1 :=\n\n/-- Given `r` larger than the measure of a set `A`, there exists an open superset of `A` with\nmeasure less than `r`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_2 : MeasureTheory.Measure.OuterRegular Î¼] (A : Set Î±) (r : ENNReal),\n  â†‘â†‘Î¼ A < r â†’ âˆƒ U, U âŠ‡ A âˆ§ IsOpen U âˆ§ â†‘â†‘Î¼ U < r :=\n\n/-- If `â€–yâ€– â†’ âˆ`, then we can assume `y â‰  x` for any fixed `x`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {l : Filter Î±} {f : Î± â†’ E},\n  Filter.Tendsto (fun y => â€–f yâ€–) l Filter.atTop â†’ âˆ€ (x : E), âˆ€á¶  (y : Î±) in l, f y â‰  x :=\n\n/-- The minimal distance to a set is `< r` iff there exists a point in this set at distance `< r` -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±} {r : â„},\n  Set.Nonempty s â†’ (Metric.infDist x s < r â†” âˆƒ y, y âˆˆ s âˆ§ dist x y < r) :=\n\n/-- If `r â‰  0` and `â€–pâ‚™â€– râ¿ = O(aâ¿)` for some `-1 < a < 1`, then `r < p.radius`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_1} {F : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) {r : NNReal},\n  r â‰  0 â†’\n    âˆ€ {a : â„},\n      a âˆˆ Set.Ioo (-1) 1 â†’\n        ((fun n => â€–p nâ€– * â†‘r ^ n) =O[Filter.atTop] fun x => a ^ x) â†’ â†‘r < FormalMultilinearSeries.radius p :=\n\n/-- If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`\nand `y` with positive coefficients has norm strictly less than `r`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E}\n  {a b r : â„}, â€–xâ€– â‰¤ r â†’ â€–yâ€– â‰¤ r â†’ x â‰  y â†’ 0 < a â†’ 0 < b â†’ a + b = 1 â†’ â€–a â€¢ x + b â€¢ yâ€– < r :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x :=\n\n/-- If the Hausdorff distance is `< r`, then any point in one of the sets is at distance\n`< r` of a point in the other set -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±} {x : Î±} {r : â„},\n  x âˆˆ s â†’ Metric.hausdorffDist s t < r â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ âˆƒ y, y âˆˆ t âˆ§ dist x y < r :=\n\n/-- Suppose `k â‰¥ 3`, `x, y âˆˆ â„^k`, `|x - y| = d > 0`, and `r > 0`. Prove that if `2r > d`, there are infinitely many `z âˆˆ â„^k` such that `|z-x|=|z-y|=r`. -/\ntheorem",
    "choices": [
      "âˆ€ {k : â„•} [inst : FiniteDimensional â„ (EuclideanSpace â„ k)] {x y : EuclideanSpace â„ k} {r d : â„},\n  3 â‰¤ k â†’ dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒ t : Set (EuclideanSpace â„ k), Set.Infinite t âˆ§ âˆ€ z âˆˆ t, dist z x = r âˆ§ dist z y = r ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {x y : E} {r d : â„},\n  3 â‰¤ FiniteDimensional.finrank â„ E â†’\n  dist x y = d â†’ 0 < d â†’ 0 < r â†’ 2 * r > d â†’ âˆƒ A : Set E, Set.Infinite A âˆ§ âˆ€ z, z âˆˆ A â†’ dist z x = r âˆ§ dist z y = r ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] {x y : EuclideanSpace â„ k} {r d : â„},\n  dist x y = d â†’ 0 < d â†’ 0 < r â†’ 2 * r > d â†’\n  âˆƒ t : â„• â†’ EuclideanSpace â„ k, StrictMono t âˆ§ âˆ€ (n : â„•), dist (t n) x = r âˆ§ dist (t n) y = r ",
      "âˆ€ {k : â„•} (hk : k â‰¥ 3) {x y : EuclideanSpace â„ k} {d r : â„},\n  dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n  âˆƒ (âˆ : Set (EuclideanSpace â„ k)), âˆ€ z, z âˆˆ âˆ â†” dist z x = r âˆ§ dist z y = r ",
      "âˆ€ {k : â„•} [inst : LinearOrderedField â„] [inst_1 : NormedAddCommGroup (Fin k â†’ â„)] [inst_2 : NormedSpace â„ (Fin k â†’ â„)]\n  {x y : Fin k â†’ â„} {r d : â„},\n  k â‰¥ 3 â†’ dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’ âˆƒ f : â„¤ â†’ Fin k â†’ â„, Function.Injective f âˆ§ âˆ€ n : â„¤, dist (f n) x = r âˆ§ dist (f n) y = r ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] {x y : EuclideanSpace â„ (Finâ‚“ k)} {r d : â„},\n  dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’ âˆƒ f : â„¤ â†’ EuclideanSpace â„ (Finâ‚“ k), Function.Injective f âˆ§ âˆ€ n, dist (f n) x = r âˆ§ dist (f n) y = r ",
      "âˆ€ {k : â„•} {x y : â„^k}, 3 â‰¤ k â†’ âˆ¥x - yâˆ¥ > 0 â†’ âˆ€ (r : â„), r > 0 â†’ 2 * r > âˆ¥x - yâˆ¥ â†’ âˆƒ z : Set (â„^k), Set.Infinite z âˆ§ âˆ€ w âˆˆ z, âˆ¥w - xâˆ¥ = r âˆ§ âˆ¥w - yâˆ¥ = r ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] {x y : EuclideanSpace â„ (Finâ‚“ k)} {r d : â„},\n  dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’ âˆƒ f : â„¤ â†’ EuclideanSpace â„ (Finâ‚“ k),\n    StrictMono f âˆ§ âˆ€ (n : â„¤), dist (f n) x = r âˆ§ dist (f n) y = r ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] {x y : Finâ‚“ k â†’ â„} {d r : â„},\n  dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’\n    âˆƒ s : Set (Finâ‚“ k â†’ â„), Set.Infinite s âˆ§ âˆ€ z âˆˆ s, dist x z = r âˆ§ dist y z = r ",
      "âˆ€ {k : â„•} [inst : Fact (3 â‰¤ k)] {x y : EuclideanSpace â„ (Finâ‚“ k)} {r d : â„},\n  dist x y = d â†’ d > 0 â†’ r > 0 â†’ 2 * r > d â†’ âˆƒ t : â„, âˆƒ h : âˆ€ z, z âˆˆ t â†’ dist z 0 = r, Set.Infinite (t â€¢ (x - y) + x) "
    ]
  },
  {
    "docString": "If `k â‰¥ 2` and `ğ‘¥ âˆˆ â„^k`, prove that there exists `ğ‘¦ âˆˆ â„^k` such that `ğ‘¦ â‰  0` but `ğ‘¥ â‹… ğ‘¦ = 0`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±},\\n  âˆ‘á¶  (i : Î±) (_ : i âˆˆ s), f i â‰  0 â†’ âˆƒ x, x âˆˆ s âˆ§ f x â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the product of `f i` over `i âˆˆ s` is not equal to `0`, then there is some `x âˆˆ s`\\nsuch that `f x â‰  0`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\\n  (m : MeasureTheory.OuterMeasure Î±) {s : Set Î±}, â†‘m s â‰  0 â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (t : Set Î±), t âˆˆ nhdsWithin x s â†’ 0 < â†‘m t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m s â‰  0`, then for some point `x âˆˆ s` and any `t âˆˆ ğ“[s] x` we have `0 < m t`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] {ğ’œ : Finset (Finset Î±)} {s : Finset Î±} {k : â„•},\\n  s âˆˆ Finset.upShadow^[k] ğ’œ â†” âˆƒ t, t âˆˆ ğ’œ âˆ§ t âŠ† s âˆ§ Finset.card t + k = Finset.card s\",\n  \"isProp\": true,\n  \"docString\":\n  \"`t âˆˆ âˆ‚^k ğ’œ` iff `t` is exactly `k` elements more than something in `ğ’œ`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±},\\n  âˆá¶  (i : Î±) (_ : i âˆˆ s), f i â‰  1 â†’ âˆƒ x, x âˆˆ s âˆ§ f x â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the product of `f i` over `i âˆˆ s` is not equal to `1`, then there is some `x âˆˆ s` such that\\n`f x â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ : Finset (Finset Î±)} {s : Finset Î±} {k : â„•},\\n  s âˆˆ Finset.shadow^[k] ğ’œ â†” âˆƒ t, t âˆˆ ğ’œ âˆ§ s âŠ† t âˆ§ Finset.card t = Finset.card s + k\",\n  \"isProp\": true,\n  \"docString\":\n  \"`t âˆˆ âˆ‚^k ğ’œ` iff `t` is exactly `k` elements less than something in `ğ’œ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) {M : â„},\\n  0 â‰¤ M â†’ (âˆ€ (x : E), â€–xâ€– â‰  0 â†’ â€–â†‘f xâ€– â‰¤ M * â€–xâ€–) â†’ â€–fâ€– â‰¤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `â€–xâ€– â‰  0`, then one controls the norm of `A`. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {n : â„•}, n â‰  1 â†’ FormalMultilinearSeries.id ğ•œ E n = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, the `n`-th coefficient of `id ğ•œ E` is zero, by definition. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\": \"âˆ€ {a b k : â„•}, Nat.coprime a b â†’ k âˆ£ a â†’ k âˆ£ b â†’ k = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `k:â„•` divides coprime `a` and `b` then `k = 1` \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, 0 = a * b â†” a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` has no zero divisors, then the product of two elements equals zero iff one of them\\nequals zero. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} {x y : E}, Dense â†‘K â†’ x - y âˆˆ Ká—® â†’ x = y\",\n  \"isProp\": true,\n  \"docString\": \"If `S` is dense and `x - y âˆˆ Ká—®`, then `x = y`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` has no zero divisors, then the product of two elements is nonzero iff both of them\\nare nonzero. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection Ká—®] {v : E}, v âˆˆ K â†’ â†‘(orthogonalProjection Ká—®) v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The orthogonal projection onto `Ká—®` of an element of `K` is zero. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type v) [inst : IsROrC ğ•œ] {E : Type u} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E] (x : E),\\n  x â‰  0 â†’ âˆƒ g, â€–gâ€– = 1 âˆ§ â†‘g x = â†‘â€–xâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of Hahn-Banach. Given a nonzero element `x` of a normed space, there exists an\\nelement of the dual space, of norm `1`, whose value on `x` is `â€–xâ€–`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\\n  {B : BilinForm R M}, B â‰  0 â†’ BilinForm.IsSymm B â†’ âˆƒ x, Â¬BilinForm.IsOrtho B x x\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\\n`x : M` such that `B x x â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under multiplication. \"}]\n",
    "prompt_cons": "/-- A solution has `x â‰  0`. -/\ntheorem âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0 :=\n\n/-- If the product of `f i` over `i âˆˆ s` is not equal to `0`, then there is some `x âˆˆ s`\nsuch that `f x â‰  0`. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±},\n  âˆ‘á¶  (i : Î±) (_ : i âˆˆ s), f i â‰  0 â†’ âˆƒ x, x âˆˆ s âˆ§ f x â‰  0 :=\n\n/-- If `m s â‰  0`, then for some point `x âˆˆ s` and any `t âˆˆ ğ“[s] x` we have `0 < m t`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  (m : MeasureTheory.OuterMeasure Î±) {s : Set Î±}, â†‘m s â‰  0 â†’ âˆƒ x, x âˆˆ s âˆ§ âˆ€ (t : Set Î±), t âˆˆ nhdsWithin x s â†’ 0 < â†‘m t :=\n\n/-- If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. -/\ntheorem âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0 :=\n\n/-- `t âˆˆ âˆ‚^k ğ’œ` iff `t` is exactly `k` elements more than something in `ğ’œ`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] [inst_1 : Fintype Î±] {ğ’œ : Finset (Finset Î±)} {s : Finset Î±} {k : â„•},\n  s âˆˆ Finset.upShadow^[k] ğ’œ â†” âˆƒ t, t âˆˆ ğ’œ âˆ§ t âŠ† s âˆ§ Finset.card t + k = Finset.card s :=\n\n/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- If the product of `f i` over `i âˆˆ s` is not equal to `1`, then there is some `x âˆˆ s` such that\n`f x â‰  1`. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : Î± â†’ M} {s : Set Î±},\n  âˆá¶  (i : Î±) (_ : i âˆˆ s), f i â‰  1 â†’ âˆƒ x, x âˆˆ s âˆ§ f x â‰  1 :=\n\n/-- `t âˆˆ âˆ‚^k ğ’œ` iff `t` is exactly `k` elements less than something in `ğ’œ`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ : Finset (Finset Î±)} {s : Finset Î±} {k : â„•},\n  s âˆˆ Finset.shadow^[k] ğ’œ â†” âˆƒ t, t âˆˆ ğ’œ âˆ§ s âŠ† t âˆ§ Finset.card t = Finset.card s + k :=\n\n/-- If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M :=\n\n/-- If one controls the norm of every `A x`, `â€–xâ€– â‰  0`, then one controls the norm of `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) {M : â„},\n  0 â‰¤ M â†’ (âˆ€ (x : E), â€–xâ€– â‰  0 â†’ â€–â†‘f xâ€– â‰¤ M * â€–xâ€–) â†’ â€–fâ€– â‰¤ M :=\n\n/-- For `n â‰  1`, the `n`-th coefficient of `id ğ•œ E` is zero, by definition. -/\ntheorem âˆ€ (ğ•œ : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {n : â„•}, n â‰  1 â†’ FormalMultilinearSeries.id ğ•œ E n = 0 :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- If `k:â„•` divides coprime `a` and `b` then `k = 1` -/\ntheorem âˆ€ {a b k : â„•}, Nat.coprime a b â†’ k âˆ£ a â†’ k âˆ£ b â†’ k = 1 :=\n\n/-- If `Î±` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, 0 = a * b â†” a = 0 âˆ¨ b = 0 :=\n\n/-- If `S` is dense and `x - y âˆˆ Ká—®`, then `x = y`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} {x y : E}, Dense â†‘K â†’ x - y âˆˆ Ká—® â†’ x = y :=\n\n/-- If `Î±` has no zero divisors, then the product of two elements is nonzero iff both of them\nare nonzero. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroClass Mâ‚€] [inst_1 : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0 :=\n\n/-- The orthogonal projection onto `Ká—®` of an element of `K` is zero. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection Ká—®] {v : E}, v âˆˆ K â†’ â†‘(orthogonalProjection Ká—®) v = 0 :=\n\n/-- Corollary of Hahn-Banach. Given a nonzero element `x` of a normed space, there exists an\nelement of the dual space, of norm `1`, whose value on `x` is `â€–xâ€–`. -/\ntheorem âˆ€ (ğ•œ : Type v) [inst : IsROrC ğ•œ] {E : Type u} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E] (x : E),\n  x â‰  0 â†’ âˆƒ g, â€–gâ€– = 1 âˆ§ â†‘g x = â†‘â€–xâ€– :=\n\n/-- There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\n`x : M` such that `B x x â‰  0`. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\n  {B : BilinForm R M}, B â‰  0 â†’ BilinForm.IsSymm B â†’ âˆƒ x, Â¬BilinForm.IsOrtho B x x :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulRightInvariant Î¼ :=\n\n/-- If `k â‰¥ 2` and `ğ‘¥ âˆˆ â„^k`, prove that there exists `ğ‘¦ âˆˆ â„^k` such that `ğ‘¦ â‰  0` but `ğ‘¥ â‹… ğ‘¦ = 0`. -/\ntheorem",
    "choices": [
      "âˆ€ {k : â„•} (x : EuclideanSpace â„ k), 2 â‰¤ k â†’ âˆƒ y : EuclideanSpace â„ k, y â‰  0 âˆ§ x â‹… y = 0 ",
      "âˆ€ {k : â„•} {x : EuclideanSpace â„ k}, k â‰¥ 2 â†’ âˆƒ y, y â‰  0 âˆ§ inner x y = 0 ",
      "âˆ€ {k : â„•} {x : Finâ‚“ k â†’ â„}, k â‰¥ 2 â†’ âˆƒ y : Finâ‚“ k â†’ â„, y â‰  0 âˆ§ Finâ‚“.innerProduct x y = 0 ",
      "âˆ€ {k : â„•} {x : Finâ‚“ k â†’ â„}, k â‰¥ 2 â†’ âˆƒ y : Finâ‚“ k â†’ â„, y â‰  0 âˆ§ âŸªx, yâŸ« = 0 ",
      "âˆ€ {k : â„•} {x : EuclideanSpace â„ k}, k â‰¥ 2 â†’ âˆƒ y, y â‰  0 âˆ§ x â‹… y = 0 ",
      "âˆ€ {k : â„•} {x : EuclideanSpace â„ k}, 2 â‰¤ k â†’ âˆƒ y, y â‰  0 âˆ§ x â‹… y = 0 ",
      "âˆ€ {k : â„•} {x : â„^k}, 2 â‰¤ k â†’ âˆƒ y : â„^k, y â‰  0 âˆ§ (x â‹… y = 0) ",
      "âˆ€ {k : â„•} {x : â„^k}, 2 â‰¤ k â†’ âˆƒ y : â„^k, y â‰  0 âˆ§ x â‹… y = 0 ",
      "âˆ€ {k : â„•} {x : Finâ‚“ k â†’ â„}, 2 â‰¤ k â†’ âˆƒ y, y â‰  0 âˆ§ x â‹… y = 0 ",
      "âˆ€ {k : â„•} (x : Finâ‚“ k â†’ â„), 2 â‰¤ k â†’ âˆƒ y, y â‰  0 âˆ§ (Finset.sum Finset.univ fun i => x i * y i) = 0 "
    ]
  },
  {
    "docString": "Suppose `a, b âˆˆ â„^k`. Find `c âˆˆ â„^k` and `r > 0` such that `|x-a|=2|x-b|` if and only if `| x - c | = r`. Prove that `3c = 4b - a` and `3r = 2 |b - a|`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal b a c\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {a b c : Î±}, c âˆˆ Set.uIcc a b â†’ |b - c| â‰¤ |b - a|\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x âˆˆ [a, b]`, then the distance between `c` and `b` is less than or equal to\\nthat of `a` and `b`  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {a b c : Î±}, c âˆˆ Set.uIcc a b â†’ |c - a| â‰¤ |b - a|\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `c âˆˆ [a, b]`, then the distance between `a` and `c` is less than or equal to\\nthat of `a` and `b`  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedMonoid Î±] {a b : Î±}, a â‰¤ b â†’ âˆƒ c, b = a * c\",\n  \"isProp\": true,\n  \"docString\": \"For `a â‰¤ b`, there is a `c` so `b = a * c`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\\n`a` odd and `c` positive. \"},\n {\"theorem\": \"âˆ€ {a b k : â„•}, Nat.coprime a b â†’ k âˆ£ a â†’ k âˆ£ b â†’ k = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `k:â„•` divides coprime `a` and `b` then `k = 1` \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P}\\n  [inst_4 : FiniteDimensional â„ { x // x âˆˆ AffineSubspace.direction s }],\\n  FiniteDimensional.finrank â„ { x // x âˆˆ AffineSubspace.direction s } = 2 â†’\\n    âˆ€ {câ‚ câ‚‚ pâ‚ pâ‚‚ p : P},\\n      câ‚ âˆˆ s â†’\\n        câ‚‚ âˆˆ s â†’\\n          pâ‚ âˆˆ s â†’\\n            pâ‚‚ âˆˆ s â†’\\n              p âˆˆ s â†’\\n                âˆ€ {râ‚ râ‚‚ : â„},\\n                  câ‚ â‰  câ‚‚ â†’\\n                    pâ‚ â‰  pâ‚‚ â†’\\n                      dist pâ‚ câ‚ = râ‚ â†’\\n                        dist pâ‚‚ câ‚ = râ‚ â†’\\n                          dist p câ‚ = râ‚ â†’ dist pâ‚ câ‚‚ = râ‚‚ â†’ dist pâ‚‚ câ‚‚ = râ‚‚ â†’ dist p câ‚‚ = râ‚‚ â†’ p = pâ‚ âˆ¨ p = pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distances `râ‚` `râ‚‚` of `p` from two different points `câ‚` `câ‚‚` determine at\\nmost two points `pâ‚` `pâ‚‚` in a two-dimensional subspace containing those points\\n(two circles intersect in at most two points). \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal a b (-c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [inst_4 : FiniteDimensional â„ V],\\n  FiniteDimensional.finrank â„ V = 2 â†’\\n    âˆ€ {câ‚ câ‚‚ pâ‚ pâ‚‚ p : P} {râ‚ râ‚‚ : â„},\\n      câ‚ â‰  câ‚‚ â†’\\n        pâ‚ â‰  pâ‚‚ â†’\\n          dist pâ‚ câ‚ = râ‚ â†’\\n            dist pâ‚‚ câ‚ = râ‚ â†’ dist p câ‚ = râ‚ â†’ dist pâ‚ câ‚‚ = râ‚‚ â†’ dist pâ‚‚ câ‚‚ = râ‚‚ â†’ dist p câ‚‚ = râ‚‚ â†’ p = pâ‚ âˆ¨ p = pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distances `râ‚` `râ‚‚` of `p` from two different points `câ‚` `câ‚‚` determine at\\nmost two points `pâ‚` `pâ‚‚` in two-dimensional space (two circles intersect in at\\nmost two points). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CircularPreorder Î±] {a b c : Î±}, btw a b c â†’ btw b c a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` is between `a` and `c`, then `c` is between `b` and `a`.\\nThis is motivated by imagining three points on a circle. \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, a â‰¤ -b â†’ b â‰¤ -a\",\n  \"isProp\": true,\n  \"docString\": \"`a â‰¤ -b â†’ b â‰¤ -a` on ereal \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {f f' : â„ â†’ â„},\\n  a â‰¤ b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\\n      âˆ€ {m : â„}, f' a < m â†’ m < f' b â†’ m âˆˆ f' '' Set.Ioo a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a â‰¤ b` and `f' a < m < f' b`, then `f' c = m` for some\\n`c âˆˆ (a, b)`. \"},\n {\"theorem\": \"âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a\",\n  \"isProp\": true,\n  \"docString\": \"`-a â‰¤ b â†” -b â‰¤ a` on `EReal`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {f f' : â„ â†’ â„},\\n  a â‰¤ b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a â‰¤ b` and `f' b â‰¤ m â‰¤ f' a`, then `f' c = m` for some\\n`c âˆˆ [a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {f f' : â„ â†’ â„},\\n  a â‰¤ b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a â‰¤ b` and `f' a â‰¤ m â‰¤ f' b`, then `f' c = m` for some\\n`c âˆˆ [a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. \"}]\n",
    "prompt_cons": "/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c :=\n\n/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal b a c :=\n\n/-- If `x âˆˆ [a, b]`, then the distance between `c` and `b` is less than or equal to\nthat of `a` and `b` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {a b c : Î±}, c âˆˆ Set.uIcc a b â†’ |b - c| â‰¤ |b - a| :=\n\n/-- If `c âˆˆ [a, b]`, then the distance between `a` and `c` is less than or equal to\nthat of `a` and `b` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] {a b c : Î±}, c âˆˆ Set.uIcc a b â†’ |c - a| â‰¤ |b - a| :=\n\n/-- For `a â‰¤ b`, there is a `c` so `b = a * c`. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedMonoid Î±] {a b : Î±}, a â‰¤ b â†’ âˆƒ c, b = a * c :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0 :=\n\n/-- If `k:â„•` divides coprime `a` and `b` then `k = 1` -/\ntheorem âˆ€ {a b k : â„•}, Nat.coprime a b â†’ k âˆ£ a â†’ k âˆ£ b â†’ k = 1 :=\n\n/-- Distances `râ‚` `râ‚‚` of `p` from two different points `câ‚` `câ‚‚` determine at\nmost two points `pâ‚` `pâ‚‚` in a two-dimensional subspace containing those points\n(two circles intersect in at most two points). -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P}\n  [inst_4 : FiniteDimensional â„ { x // x âˆˆ AffineSubspace.direction s }],\n  FiniteDimensional.finrank â„ { x // x âˆˆ AffineSubspace.direction s } = 2 â†’\n    âˆ€ {câ‚ câ‚‚ pâ‚ pâ‚‚ p : P},\n      câ‚ âˆˆ s â†’\n        câ‚‚ âˆˆ s â†’\n          pâ‚ âˆˆ s â†’\n            pâ‚‚ âˆˆ s â†’\n              p âˆˆ s â†’\n                âˆ€ {râ‚ râ‚‚ : â„},\n                  câ‚ â‰  câ‚‚ â†’\n                    pâ‚ â‰  pâ‚‚ â†’\n                      dist pâ‚ câ‚ = râ‚ â†’\n                        dist pâ‚‚ câ‚ = râ‚ â†’\n                          dist p câ‚ = râ‚ â†’ dist pâ‚ câ‚‚ = râ‚‚ â†’ dist pâ‚‚ câ‚‚ = râ‚‚ â†’ dist p câ‚‚ = râ‚‚ â†’ p = pâ‚ âˆ¨ p = pâ‚‚ :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal a b (-c) :=\n\n/-- Distances `râ‚` `râ‚‚` of `p` from two different points `câ‚` `câ‚‚` determine at\nmost two points `pâ‚` `pâ‚‚` in two-dimensional space (two circles intersect in at\nmost two points). -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [inst_4 : FiniteDimensional â„ V],\n  FiniteDimensional.finrank â„ V = 2 â†’\n    âˆ€ {câ‚ câ‚‚ pâ‚ pâ‚‚ p : P} {râ‚ râ‚‚ : â„},\n      câ‚ â‰  câ‚‚ â†’\n        pâ‚ â‰  pâ‚‚ â†’\n          dist pâ‚ câ‚ = râ‚ â†’\n            dist pâ‚‚ câ‚ = râ‚ â†’ dist p câ‚ = râ‚ â†’ dist pâ‚ câ‚‚ = râ‚‚ â†’ dist pâ‚‚ câ‚‚ = râ‚‚ â†’ dist p câ‚‚ = râ‚‚ â†’ p = pâ‚ âˆ¨ p = pâ‚‚ :=\n\n/-- If `b` is between `a` and `c`, then `c` is between `b` and `a`.\nThis is motivated by imagining three points on a circle. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CircularPreorder Î±] {a b c : Î±}, btw a b c â†’ btw b c a :=\n\n/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b :=\n\n/-- `a â‰¤ -b â†’ b â‰¤ -a` on ereal -/\ntheorem âˆ€ {a b : EReal}, a â‰¤ -b â†’ b â‰¤ -a :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 :=\n\n/-- **Darboux's theorem**: if `a â‰¤ b` and `f' a < m < f' b`, then `f' c = m` for some\n`c âˆˆ (a, b)`. -/\ntheorem âˆ€ {a b : â„} {f f' : â„ â†’ â„},\n  a â‰¤ b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\n      âˆ€ {m : â„}, f' a < m â†’ m < f' b â†’ m âˆˆ f' '' Set.Ioo a b :=\n\n/-- `-a â‰¤ b â†” -b â‰¤ a` on `EReal`. -/\ntheorem âˆ€ {a b : EReal}, -a â‰¤ b â†” -b â‰¤ a :=\n\n/-- **Darboux's theorem**: if `a â‰¤ b` and `f' b â‰¤ m â‰¤ f' a`, then `f' c = m` for some\n`c âˆˆ [a, b]`. -/\ntheorem âˆ€ {a b : â„} {f f' : â„ â†’ â„},\n  a â‰¤ b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b :=\n\n/-- **Darboux's theorem**: if `a â‰¤ b` and `f' a â‰¤ m â‰¤ f' b`, then `f' c = m` for some\n`c âˆˆ [a, b]`. -/\ntheorem âˆ€ {a b : â„} {f f' : â„ â†’ â„},\n  a â‰¤ b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b :=\n\n/-- If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- Suppose `a, b âˆˆ â„^k`. Find `c âˆˆ â„^k` and `r > 0` such that `|x-a|=2|x-b|` if and only if `| x - c | = r`. Prove that `3c = 4b - a` and `3r = 2 |b - a|`. -/\ntheorem",
    "choices": [
      "âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {a b c : P} {r : â„},\n  (âˆ€ x : P, dist x a = 2 * dist x b â†” dist x c = r) â†’ 3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace V] [inst_3 : NormedAddTorsor V V],\n  âˆ€ {a b c : V} {r : â„},\n    (âˆ€ x, dist x a = 2 * dist x b â†” dist x c = r) â†’\n      3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a ",
      "âˆ€ {V : Type u_1} [inst : NormedGroup V] [inst_1 : InnerProductSpace â„ V] {a b : V},\n  âˆƒ (c : V) (r : â„), r > 0 âˆ§\n    (âˆ€ x, âˆ¥x - aâˆ¥ = 2 * âˆ¥x - bâˆ¥ â†” âˆ¥x - câˆ¥ = r) âˆ§\n    (3 â€¢ c = 4 â€¢ b - a) âˆ§ (3 * r = 2 * âˆ¥b - aâˆ¥) ",
      "âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {a b c : P} (r : â„),\n  (âˆ€ x : P, dist x a = 2 * dist x b â†” dist x c = r) â†’\n    3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a ",
      "âˆ€ {k a b c : â„} {r : â„},\n  (âˆ€ (x : â„), |x - a| = 2 * |x - b| â†” |x - c| = r) â†’\n    3 * c = 4 * b - a âˆ§ 3 * r = 2 * |b - a| ",
      "âˆ€ {k : â„•} {a b : Finâ‚“ (k + 1) â†’ â„},\n  âˆƒ c : Finâ‚“ (k + 1) â†’ â„,\n    âˆƒ r : â„,\n      (âˆ€ x : Finâ‚“ (k + 1) â†’ â„, dist x a = 2 * dist x b â†” dist x c = r) âˆ§\n        (3 â€¢ c = 4 â€¢ b - a) âˆ§ (3 * r = 2 * dist b a) ",
      "âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P],\n  âˆ€ {a b c : P} {r : â„},\n    (âˆ€ x : P, dist x a = 2 * dist x b â†” dist x c = r) â†’\n      3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a ",
      "âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {a b c : P} {r : â„},\n  (âˆ€ x, dist x a = 2 * dist x b â†” dist x c = r) â†’ 3 â€¢ c = 4 â€¢ b - a âˆ§ 3 * r = 2 * dist b a ",
      "âˆ€ {k : Type u_1} [inst : NormedGroup k] [inst_1 : NondiscreteNormedField k] {a b c : k} {r : â„},\n  (âˆ€ x : k, |x - a| = 2 * |x - b| â†” |x - c| = r) â†’ 3 * c = 4 * b - a âˆ§ 3 * r = 2 * |b - a| ",
      "âˆ€ {V : Type u_1} [inst : NormedGroup V] [inst_1 : NormedSpace â„ V] {a b c : V} {r : â„},\n  (âˆ€ x : V, |x - a| = 2 * |x - b| â†” |x - c| = r) â†’\n  (3 â€¢ c = 4 â€¢ b - a) âˆ§ (3 * r = 2 * |b - a|) "
    ]
  },
  {
    "docString": "Let `X` be a metric space in which every infinite subset has a limit point. Prove that `X` is separable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\\nsecond countable, then there exists a countable family of open sets in `X` that separates points\\nof `s`. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±], âˆƒ f, Isometry f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separable metric space embeds isometrically in `â„“^âˆ(â„•)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {Î² : Type u_1} [inst : TopologicalSpace Î²]\\n  [inst_1 : TopologicalSpace.SeparableSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î²],\\n  TopologicalSpace.SeparableSpace (Î± Ã— Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] {f : Î² â†’ Î±} [inst_1 : TopologicalSpace Î²],\\n  Inducing f â†’ âˆ€ {s : Set Î±}, TopologicalSpace.IsSeparable s â†’ TopologicalSpace.IsSeparable (f â»Â¹' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a separable set by an inducing map is separable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\\n  ContinuousOn f s â†’ TopologicalSpace.IsSeparable s â†’ TopologicalSpace.IsSeparable (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a map is continuous on a separable set `s`, then the image of `s` is also separable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\\n  HasCountableSeparatingOn X IsClosed s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists a countable family of open sets separating points of `s`, then there exists\\na countable family of closed sets separating points of `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²] [inst_3 : MeasurableSpace Î²] [inst_4 : BorelSpace Î²]\\n  {Î¹ : Type u_1} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [inst_5 : Filter.NeBot u]\\n  [inst_6 : Filter.IsCountablyGenerated u], (âˆ€ (i : Î¹), Measurable (f i)) â†’ Filter.Tendsto f u (nhds g) â†’ Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A limit (over a general filter) of measurable functions valued in a (pseudo) metrizable space is\\nmeasurable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"}]\n",
    "prompt_cons": "/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i) :=\n\n/-- A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\nsecond countable, then there exists a countable family of open sets in `X` that separates points\nof `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s :=\n\n/-- Every separable metric space embeds isometrically in `â„“^âˆ(â„•)`. -/\ntheorem âˆ€ (Î± : Type u) [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±], âˆƒ f, Isometry f :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î± :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U :=\n\n/-- The product of two separable spaces is a separable space. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {Î² : Type u_1} [inst : TopologicalSpace Î²]\n  [inst_1 : TopologicalSpace.SeparableSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î²],\n  TopologicalSpace.SeparableSpace (Î± Ã— Î²) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- The preimage of a separable set by an inducing map is separable. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] {f : Î² â†’ Î±} [inst_1 : TopologicalSpace Î²],\n  Inducing f â†’ âˆ€ {s : Set Î±}, TopologicalSpace.IsSeparable s â†’ TopologicalSpace.IsSeparable (f â»Â¹' s) :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- If a map is continuous on a separable set `s`, then the image of `s` is also separable. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\n  ContinuousOn f s â†’ TopologicalSpace.IsSeparable s â†’ TopologicalSpace.IsSeparable (f '' s) :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a :=\n\n/-- If there exists a countable family of open sets separating points of `s`, then there exists\na countable family of closed sets separating points of `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\n  HasCountableSeparatingOn X IsClosed s :=\n\n/-- A limit (over a general filter) of measurable functions valued in a (pseudo) metrizable space is\nmeasurable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²] [inst_3 : MeasurableSpace Î²] [inst_4 : BorelSpace Î²]\n  {Î¹ : Type u_1} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [inst_5 : Filter.NeBot u]\n  [inst_6 : Filter.IsCountablyGenerated u], (âˆ€ (i : Î¹), Measurable (f i)) â†’ Filter.Tendsto f u (nhds g) â†’ Measurable g :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- Let `X` be a metric space in which every infinite subset has a limit point. Prove that `X` is separable. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace.HasCountableBasisOfCompactSubsetsWithLimit X],\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : âˆ€ (A : Set X), Set.Infinite A â†’ HasCountableLimitPoints A],\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] (h : âˆ€ s : Set X, Set.Infinite s â†’ âˆƒ x, IsLimitPoint s x),\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : âˆ€ (s : Set X), Set.Infinite s â†’ âˆƒ x, IsLimitPoint s x],\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : âˆ€ (s : Set X), Set.Infinite s â†’ âˆƒ (p : X), IsLimitPointOf s],\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ (X : Type u_1) [inst : MetricSpace X] [inst_1 : TopologicalSpace X] (h : âˆ€ s : Set X, Set.Infinite s â†’ Exists (fun {p} => HasMem.Mem p (closure s))),\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ (X : Type u) [inst : MetricSpace X] [inst_1 : âˆ€ (s : Set X), Set.Infinite s â†’ âˆƒ x, IsLimitPoint s x],\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace.HasInfiniteSubsetLimitPoint X],\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : EveryInfiniteSetHasLimitPoint X],\n  TopologicalSpace.SeparableSpace X ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [H : âˆ€ (s : Set X), Set.Infinite s â†’ Set.Nonempty (SetOf IsLimitPoint s)],\n  TopologicalSpace.SeparableSpace X "
    ]
  },
  {
    "docString": "Suppose `EâŠ†â„^k` is uncountable, and let `P` be the set of condensation points of `E`. Prove that `P` is perfect.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\\n  âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"**Primitive element theorem** assuming E is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : EMetricSpace Î±] {K : NNReal} {f : Î± â†’ Î±} {s : Set Î±},\\n  IsComplete s â†’\\n    âˆ€ (hsf : Set.MapsTo f s s),\\n      ContractingWith K (Set.MapsTo.restrict f s s hsf) â†’\\n        âˆ€ {x : Î±},\\n          x âˆˆ s â†’\\n            edist x (f x) â‰  âŠ¤ â†’\\n              âˆƒ y,\\n                y âˆˆ s âˆ§\\n                  Function.IsFixedPt f y âˆ§\\n                    Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) âˆ§\\n                      âˆ€ (n : â„•), edist (f^[n] x) y â‰¤ edist x (f x) * â†‘K ^ n / (1 - â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Banach fixed-point theorem for maps contracting on a complete subset. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)],\\n  UniformContinuous Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion from `lp E p` to `âˆ€ i, E i` is uniformly continuous. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\": \"Summability of the `p`-series over `â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ âˆƒ V D, Set.Countable V âˆ§ Perfect D âˆ§ C = V âˆª D\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\\ncan be written as the union of a countable set and a perfect set.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (s : Set Î±), UniformContinuous fun x => Metric.infNndist x s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal distance to a set (as `â„â‰¥0`) is uniformly continuous in point \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} [inst : MetricSpace Î²]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : SemilatticeSup Î¹] [inst_2 : Nonempty Î¹] [inst_3 : Countable Î¹] {f : Î¹ â†’ Î± â†’ Î²}\\n  {g : Î± â†’ Î²} [inst_4 : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€ (n : Î¹), MeasureTheory.StronglyMeasurable (f n)) â†’\\n    MeasureTheory.StronglyMeasurable g â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\\n        âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ t, MeasurableSet t âˆ§ â†‘â†‘Î¼ t â‰¤ ENNReal.ofReal Îµ âˆ§ TendstoUniformlyOn f g Filter.atTop tá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"Egorov's theorem for finite measure spaces. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]\\n  (s : Set Î²),\\n  IsCompact s â†’\\n    âˆ€ (A : Set (BoundedContinuousFunction Î± Î²)),\\n      IsClosed A â†’\\n        (âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), f âˆˆ A â†’ â†‘f x âˆˆ s) â†’ (Equicontinuous fun x => â†‘â†‘x) â†’ IsCompact A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Second version, with pointwise equicontinuity and range in a compact subset. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {xâ‚€ : Î±} {K : Set Î²},\\n  IsCompact K â†’\\n    âˆ€ {P : Î± â†’ Î² â†’ Prop},\\n      (âˆ€ (y : Î²), y âˆˆ K â†’ âˆ€á¶  (z : Î± Ã— Î²) in nhds (xâ‚€, y), P z.fst z.snd) â†’\\n        âˆ€á¶  (x : Î±) in nhds xâ‚€, âˆ€ (y : Î²), y âˆˆ K â†’ P x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that `âˆ€ y âˆˆ K, P x y` holds for `x` close enough to `xâ‚€` when `K` is compact,\\nit is sufficient to show that for all `yâ‚€ âˆˆ K` there `P x y` holds for `(x, y)` close enough\\nto `(xâ‚€, yâ‚€)`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (K : Submodule ğ•œ E) [inst_3 : HasOrthogonalProjection K],\\n  ContinuousLinearMap.id ğ•œ E =\\n    ContinuousLinearMap.comp (Submodule.subtypeL K) (orthogonalProjection K) +\\n      ContinuousLinearMap.comp (Submodule.subtypeL Ká—®) (orthogonalProjection Ká—®)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space `E`, the projection maps onto a complete subspace `K` and its orthogonal\\ncomplement sum to the identity. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (K : Submodule ğ•œ E) [inst_3 : HasOrthogonalProjection K] (v : E), âˆƒ y, y âˆˆ K âˆ§ âˆƒ z, z âˆˆ Ká—® âˆ§ v = y + z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is complete, any `v` in `E` can be expressed as a sum of elements of `K` and `Ká—®`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {p : â„• â†’ Î± â†’ Prop},\\n  âˆ‘' (i : â„•), â†‘â†‘Î¼ {x | p i x} â‰  âŠ¤ â†’ â†‘â†‘Î¼ {x | âˆƒá¶  (n : â„•) in Filter.atTop, p n x} = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A version of the **Borel-Cantelli lemma**: if `páµ¢` is a sequence of predicates such that\\n`âˆ‘ Î¼ {x | páµ¢ x}` is finite, then the measure of `x` such that `páµ¢ x` holds frequently as `i â†’ âˆ` (or\\nequivalently, `páµ¢ x` holds for infinitely many `i`) is equal to zero. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {f : ğ•œ â†’ E} {r : ENNReal} {x : ğ•œ} {p : FormalMultilinearSeries ğ•œ ğ•œ E},\\n  HasFPowerSeriesOnBall f p x r â†’\\n    (âˆ€ (r' : NNReal), 0 < r' â†’ âˆƒ p', HasFPowerSeriesOnBall f p' x â†‘r') â†’ HasFPowerSeriesOnBall f p x âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : ğ•œ â†’ E` has power series representation `p` on a ball of some radius and for\\neach positive radius it has some power series representation, then `p` converges to `f` on the whole\\n`ğ•œ`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {f : CauSeq â„š (padicNorm p)},\\n  Â¬f â‰ˆ 0 â†’ âˆƒ N, âˆ€ (m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ padicNorm p (â†‘f n) = padicNorm p (â†‘f m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of the entries of a nonzero Cauchy sequence of rationals is eventually\\nconstant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C U : Set Î±}, Preperfect C â†’ IsOpen U â†’ Preperfect (U âˆ© C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a preperfect set and an open set is preperfect. \"}]\n",
    "prompt_cons": "/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f :=\n\n/-- **Primitive element theorem** assuming E is finite. -/\ntheorem âˆ€ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\n  âˆƒ Î±, FâŸ®Î±âŸ¯ = âŠ¤ :=\n\n/-- Banach fixed-point theorem for maps contracting on a complete subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : EMetricSpace Î±] {K : NNReal} {f : Î± â†’ Î±} {s : Set Î±},\n  IsComplete s â†’\n    âˆ€ (hsf : Set.MapsTo f s s),\n      ContractingWith K (Set.MapsTo.restrict f s s hsf) â†’\n        âˆ€ {x : Î±},\n          x âˆˆ s â†’\n            edist x (f x) â‰  âŠ¤ â†’\n              âˆƒ y,\n                y âˆˆ s âˆ§\n                  Function.IsFixedPt f y âˆ§\n                    Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) âˆ§\n                      âˆ€ (n : â„•), edist (f^[n] x) y â‰¤ edist x (f x) * â†‘K ^ n / (1 - â†‘K) :=\n\n/-- The coercion from `lp E p` to `âˆ€ i, E i` is uniformly continuous. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)],\n  UniformContinuous Subtype.val :=\n\n/-- Summability of the `p`-series over `â„¤`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\ncan be written as the union of a countable set and a perfect set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ âˆƒ V D, Set.Countable V âˆ§ Perfect D âˆ§ C = V âˆª D :=\n\n/-- The minimal distance to a set (as `â„â‰¥0`) is uniformly continuous in point -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (s : Set Î±), UniformContinuous fun x => Metric.infNndist x s :=\n\n/-- Egorov's theorem for finite measure spaces. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} [inst : MetricSpace Î²]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : SemilatticeSup Î¹] [inst_2 : Nonempty Î¹] [inst_3 : Countable Î¹] {f : Î¹ â†’ Î± â†’ Î²}\n  {g : Î± â†’ Î²} [inst_4 : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€ (n : Î¹), MeasureTheory.StronglyMeasurable (f n)) â†’\n    MeasureTheory.StronglyMeasurable g â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\n        âˆ€ {Îµ : â„}, 0 < Îµ â†’ âˆƒ t, MeasurableSet t âˆ§ â†‘â†‘Î¼ t â‰¤ ENNReal.ofReal Îµ âˆ§ TendstoUniformlyOn f g Filter.atTop tá¶œ :=\n\n/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst_2 : PseudoMetricSpace Î²]\n  (s : Set Î²),\n  IsCompact s â†’\n    âˆ€ (A : Set (BoundedContinuousFunction Î± Î²)),\n      IsClosed A â†’\n        (âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), f âˆˆ A â†’ â†‘f x âˆˆ s) â†’ (Equicontinuous fun x => â†‘â†‘x) â†’ IsCompact A :=\n\n/-- To show that `âˆ€ y âˆˆ K, P x y` holds for `x` close enough to `xâ‚€` when `K` is compact,\nit is sufficient to show that for all `yâ‚€ âˆˆ K` there `P x y` holds for `(x, y)` close enough\nto `(xâ‚€, yâ‚€)`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {xâ‚€ : Î±} {K : Set Î²},\n  IsCompact K â†’\n    âˆ€ {P : Î± â†’ Î² â†’ Prop},\n      (âˆ€ (y : Î²), y âˆˆ K â†’ âˆ€á¶  (z : Î± Ã— Î²) in nhds (xâ‚€, y), P z.fst z.snd) â†’\n        âˆ€á¶  (x : Î±) in nhds xâ‚€, âˆ€ (y : Î²), y âˆˆ K â†’ P x y :=\n\n/-- In a complete space `E`, the projection maps onto a complete subspace `K` and its orthogonal\ncomplement sum to the identity. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (K : Submodule ğ•œ E) [inst_3 : HasOrthogonalProjection K],\n  ContinuousLinearMap.id ğ•œ E =\n    ContinuousLinearMap.comp (Submodule.subtypeL K) (orthogonalProjection K) +\n      ContinuousLinearMap.comp (Submodule.subtypeL Ká—®) (orthogonalProjection Ká—®) :=\n\n/-- If `K` is complete, any `v` in `E` can be expressed as a sum of elements of `K` and `Ká—®`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (K : Submodule ğ•œ E) [inst_3 : HasOrthogonalProjection K] (v : E), âˆƒ y, y âˆˆ K âˆ§ âˆƒ z, z âˆˆ Ká—® âˆ§ v = y + z :=\n\n/-- A version of the **Borel-Cantelli lemma**: if `páµ¢` is a sequence of predicates such that\n`âˆ‘ Î¼ {x | páµ¢ x}` is finite, then the measure of `x` such that `páµ¢ x` holds frequently as `i â†’ âˆ` (or\nequivalently, `páµ¢ x` holds for infinitely many `i`) is equal to zero. -/\ntheorem âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {p : â„• â†’ Î± â†’ Prop},\n  âˆ‘' (i : â„•), â†‘â†‘Î¼ {x | p i x} â‰  âŠ¤ â†’ â†‘â†‘Î¼ {x | âˆƒá¶  (n : â„•) in Filter.atTop, p n x} = 0 :=\n\n/-- If a function `f : ğ•œ â†’ E` has power series representation `p` on a ball of some radius and for\neach positive radius it has some power series representation, then `p` converges to `f` on the whole\n`ğ•œ`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {f : ğ•œ â†’ E} {r : ENNReal} {x : ğ•œ} {p : FormalMultilinearSeries ğ•œ ğ•œ E},\n  HasFPowerSeriesOnBall f p x r â†’\n    (âˆ€ (r' : NNReal), 0 < r' â†’ âˆƒ p', HasFPowerSeriesOnBall f p' x â†‘r') â†’ HasFPowerSeriesOnBall f p x âŠ¤ :=\n\n/-- The `p`-adic norm of the entries of a nonzero Cauchy sequence of rationals is eventually\nconstant. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {f : CauSeq â„š (padicNorm p)},\n  Â¬f â‰ˆ 0 â†’ âˆƒ N, âˆ€ (m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ padicNorm p (â†‘f n) = padicNorm p (â†‘f m) :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- The intersection of a preperfect set and an open set is preperfect. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C U : Set Î±}, Preperfect C â†’ IsOpen U â†’ Preperfect (U âˆ© C) :=\n\n/-- Suppose `EâŠ†â„^k` is uncountable, and let `P` be the set of condensation points of `E`. Prove that `P` is perfect. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : T2Space Î±],\n  âˆ€ {E : Set Î±}, Uncountable E â†’ Preperfect (CondensationPoints Î± E) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {E : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  Â¬Set.Countable E â†’\n    âˆƒ P, Perfect P âˆ§ Set.Nonempty P âˆ§ âˆ€ (x : Î±), IsCondensationPoint x E â†” x âˆˆ P ",
      "forall {k : â„•} {E : Set (Finâ‚“ k â†’ â„)}, Â¬Set.Countable E â†’\n  let P ",
      "âˆ€ {k : â„•} {E : Set (EuclideanSpace â„ k)},\n  Â¬Set.Countable E â†’\n    let P ",
      "âˆ€ {k : â„•} {E : Set (Finâ‚“ (k + 1) â†’ â„)}, Â¬Set.Countable E â†’\n  âˆƒ P, Perfect P âˆ§ P âŠ† E âˆ§ P = {x | âˆ€ (n : â„•), âˆƒ r, 0 < r âˆ§ ClosedBall x r âˆ© E âŠ† ClosedBall x r âˆ© P} ",
      "âˆ€ {k : â„•} {E : Set (EuclideanSpace â„ k)} [_inst_1 : TopologicalSpace.SecondCountableTopology (EuclideanSpace â„ k)],\n  Â¬Set.Countable E â†’\n    âˆ€ {P : Set (EuclideanSpace â„ k)},\n      P = {x : EuclideanSpace â„ k | Filter.IsCondensationPt x (Filter.principal E)} â†’ Perfect P ",
      "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : LinearOrder Î±] [inst_3 : OrderTopology Î±],\n  (Exists fun [Nonempty Î±] => True) â†’\n  âˆ€ {E : Set Î±}, Set.Countable Eá¶œ â†’\n    let P ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] {C : Set Î±} {E : Set Î±},\n  IsCondensationPointOf C E â†’\n    Â¬Set.Countable E â†’\n      Perfect C ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±] {E : Set Î±},\n  Â¬Set.Countable E â†’\n    âˆ€ {P : Set Î±}, P = CondensationPoints E â†’ Perfect P ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {E : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±] [inst_2 : LinearOrder Î±] [inst_3 : OrderTopology Î±],\n  Â¬Set.Countable E â†’\n    let P "
    ]
  },
  {
    "docString": "Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ âˆƒ V D, Set.Countable V âˆ§ Perfect D âˆ§ C = V âˆª D\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\\ncan be written as the union of a countable set and a perfect set.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\\n  CompleteSpace ((i : Î¹) Ã— E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {As : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\\n    Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Countable {i | 0 < â†‘â†‘Î¼ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the union of disjoint measurable sets has finite measure, then there are only\\ncountably many members of the union whose measure is positive. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {Îµ : ENNReal},\\n  0 < Îµ â†’\\n    âˆ€ {As : Î¹ â†’ Set Î±},\\n      (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\\n        Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Finite {i | Îµ â‰¤ â†‘â†‘Î¼ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the union of disjoint measurable sets has finite measure, then there are only\\nfinitely many members of the union whose measure exceeds any given positive number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±},\\n  IsCompact s â†’ âˆ€ {e : â„}, 0 < e â†’ âˆƒ t, t âŠ† s âˆ§ Set.Finite t âˆ§ s âŠ† â‹ƒ (x : Î±) (_ : x âˆˆ t), Metric.ball x e\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any compact set in a pseudometric space can be covered by finitely many balls of a given\\npositive radius \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\\n  HasCountableSeparatingOn X IsClosed s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists a countable family of open sets separating points of `s`, then there exists\\na countable family of closed sets separating points of `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\\n  IsClosed s â†’\\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : MetricSpace Î±],\\n  (âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ Î² x F, âˆ€ (x y : Î±), F x = F y â†’ dist x y â‰¤ Îµ) â†’ TopologicalSpace.SecondCountableTopology Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A metric space is second countable if one can reconstruct up to any `Îµ>0` any element of the\\nspace from countably many data. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\\n  TopologicalSpace.FirstCountableTopology X\",\n  \"isProp\": true,\n  \"docString\": \"Every pseudo-metrizable space is first countable. \"}]\n",
    "prompt_cons": "/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i :=\n\n/-- The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\ncan be written as the union of a countable set and a perfect set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ âˆƒ V D, Set.Countable V âˆ§ Perfect D âˆ§ C = V âˆª D :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\n  CompleteSpace ((i : Î¹) Ã— E i) :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i) :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a :=\n\n/-- If the union of disjoint measurable sets has finite measure, then there are only\ncountably many members of the union whose measure is positive. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {As : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\n    Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Countable {i | 0 < â†‘â†‘Î¼ (As i)} :=\n\n/-- If the union of disjoint measurable sets has finite measure, then there are only\nfinitely many members of the union whose measure exceeds any given positive number. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {Îµ : ENNReal},\n  0 < Îµ â†’\n    âˆ€ {As : Î¹ â†’ Set Î±},\n      (âˆ€ (i : Î¹), MeasurableSet (As i)) â†’\n        Pairwise (Disjoint on As) â†’ â†‘â†‘Î¼ (â‹ƒ (i : Î¹), As i) â‰  âŠ¤ â†’ Set.Finite {i | Îµ â‰¤ â†‘â†‘Î¼ (As i)} :=\n\n/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î± :=\n\n/-- A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Any compact set in a pseudometric space can be covered by finitely many balls of a given\npositive radius -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±},\n  IsCompact s â†’ âˆ€ {e : â„}, 0 < e â†’ âˆƒ t, t âŠ† s âˆ§ Set.Finite t âˆ§ s âŠ† â‹ƒ (x : Î±) (_ : x âˆˆ t), Metric.ball x e :=\n\n/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤ :=\n\n/-- If there exists a countable family of open sets separating points of `s`, then there exists\na countable family of closed sets separating points of `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\n  HasCountableSeparatingOn X IsClosed s :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] {s : Set Î±},\n  IsClosed s â†’\n    âˆƒ S, Set.Finite S âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsClosed t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsIrreducible t) âˆ§ s = â‹ƒâ‚€ S :=\n\n/-- A metric space is second countable if one can reconstruct up to any `Îµ>0` any element of the\nspace from countably many data. -/\ntheorem âˆ€ {Î± : Type u} [inst : MetricSpace Î±],\n  (âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ Î² x F, âˆ€ (x y : Î±), F x = F y â†’ dist x y â‰¤ Îµ) â†’ TopologicalSpace.SecondCountableTopology Î± :=\n\n/-- Every pseudo-metrizable space is first countable. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\n  TopologicalSpace.FirstCountableTopology X :=\n\n/-- Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’\n    âˆƒ (P : Set Î±), âˆƒ (C : Set Î±),\n      Perfect P âˆ§ Set.Countable C âˆ§ s = P âˆª C ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ P A, Perfect P âˆ§ Set.Countable A âˆ§ s = P âˆª A ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ P A, Perfect P âˆ§ Set.Countable A âˆ§ s = P âˆª A ",
      "forall {Î± : Type u} [inst : MetricSpace Î±] [TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ t, Set.Countable t âˆ§ s = (s \\ t) âˆª (s âˆ© t) âˆ§ Perfect (s \\ t) ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, tâ‚ âŠ† s âˆ§ tâ‚‚ âŠ† s âˆ§ Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î±] {C : Set Î±},\n  IsClosed C â†’ âˆƒ P V, Perfect P âˆ§ Set.Countable V âˆ§ C = P âˆª V ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "forall {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Perfect tâ‚ âˆ§ Set.Countable tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.SeparableSpace Î±] {s : Set Î±},\n  IsClosed s â†’ âˆƒ tâ‚ tâ‚‚, Set.Countable tâ‚ âˆ§ Perfect tâ‚‚ âˆ§ s = tâ‚ âˆª tâ‚‚ "
    ]
  },
  {
    "docString": "Prove that convergence of `{s_n}` implies convergence of `{|s_n|}`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {s t : Set Î±}, BddBelow s â†’ BddBelow (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\": \"If `s` is bounded, then so is `s âˆ© t` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : â„• â†’ Set Î±},\\n  âˆ‘' (i : â„•), â†‘â†‘Î¼ (s i) â‰  âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"One direction of the **Borel-Cantelli lemma**: if (sáµ¢) is a sequence of sets such\\nthat `âˆ‘ Î¼ sáµ¢` is finite, then the limit superior of the `sáµ¢` is a null set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s\",\n  \"isProp\": true,\n  \"docString\": \"It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±], IsCompact s â†’ (TendstoLocallyUniformlyOn F f p s â†” TendstoUniformlyOn F f p s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a compact set `s`, locally uniform convergence on `s` is just uniform convergence on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„),\\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {s t : Set Î±}, BddAbove t â†’ BddAbove (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\": \"If `t` is bounded, then so is `s âˆ© t` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} {c : Î²},\\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ Filter.principal s) (nhds c) â†” TendstoUniformlyOn F (fun x => c) p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Uniform convergence on a set `s` to a constant function is equivalent to convergence in\\n`p Ã—Ë¢ ğ“Ÿ s`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {s : Set E}\\n  {f fâ‚ : E â†’ F} {n : â„•âˆ} {p : E â†’ FormalMultilinearSeries ğ•œ E F},\\n  HasFTaylorSeriesUpToOn n f p s â†’ (âˆ€ (x : E), x âˆˆ s â†’ fâ‚ x = f x) â†’ HasFTaylorSeriesUpToOn n fâ‚ p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions coincide on a set `s`, then a Taylor series for the first one is as well a\\nTaylor series for the second one. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {p : Filter Î¹} {g : Î¹ â†’ Î²} {b : Î²},\\n  Filter.Tendsto g p (nhds b) â†’ âˆ€ (s : Set Î±), TendstoUniformlyOn (fun n x => g n) (fun x => b) p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence `g` converges to some `b`, then the sequence of constant functions\\n`fun n â†¦ fun a â†¦ g n` converges to the constant function `fun a â†¦ b` on any set `s` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\\n  {Î½ : MeasureTheory.Measure Î²} [inst_2 : MeasureTheory.SigmaFinite Î½] {s : Set (Î± Ã— Î²)},\\n  â†‘â†‘(MeasureTheory.Measure.prod Î¼ Î½) s = 0 â†’ (fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)) =á¶ [MeasureTheory.Measure.ae Î¼] 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note: the converse is not true without assuming that `s` is measurable. For a counterexample,\\nsee Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type ua} [inst : UniformSpace Î±] {s : Set (Î± Ã— Î±)},\\n  s âˆˆ uniformity Î± â†’\\n    âˆ€ (n : â„•), âˆ€á¶  (t : Set (Î± Ã— Î±)) in Filter.smallSets (uniformity Î±), (fun x => compRel t x)^[n] t âŠ† s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s âˆˆ ğ“¤ Î±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ğ“¤ Î±`,\\nwe have `t â—‹ t â—‹ ... â—‹ t âŠ† s` (`n` compositions). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î© : Type u_1} {m0 : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©} [inst : MeasureTheory.IsProbabilityMeasure Î¼]\\n  {s : â„• â†’ Set Î©},\\n  (âˆ€ (n : â„•), MeasurableSet (s n)) â†’\\n    ProbabilityTheory.iIndepSet s â†’ âˆ‘' (n : â„•), â†‘â†‘Î¼ (s n) = âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sâ‚™)` such that\\n`âˆ‘ n, Î¼ sâ‚™ = âˆ`, `limsup sâ‚™` has measure 1. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s t : Set Î±},\\n  s âŠ† t â†’ â†‘â†‘Î¼ t â‰¤ â†‘â†‘Î¼ s â†’ MeasurableSet s â†’ â†‘â†‘Î¼ t â‰  âŠ¤ â†’ s =á¶ [MeasureTheory.Measure.ae Î¼] t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s âŠ† t`, `Î¼ t â‰¤ Î¼ s`, `Î¼ t â‰  âˆ`, and `s` is measurable, then `s =áµ[Î¼] t`. \"},\n {\"theorem\":\n  \"âˆ€ {Ï„ : Type u_2} {Î± : Type u_3} {Î² : Type u_1} [inst : TopologicalSpace Î²] (f : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : Set Î±)\\n  {c : Set Î²},\\n  IsCompact c â†’\\n    (âˆƒ v, v âˆˆ f âˆ§ closure (Set.image2 Ï• v s) âŠ† c) â†’\\n      âˆ€ {n : Set Î²}, IsOpen n â†’ omegaLimit f Ï• s âŠ† n â†’ âˆƒ u, u âˆˆ f âˆ§ closure (Set.image2 Ï• u s) âŠ† n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is eventually carried into any open neighbourhood of its Ï‰-limit:\\nif `c` is a compact set such that `closure {Ï• t x | t âˆˆ v, x âˆˆ s} âŠ† c` for some `v âˆˆ f`\\nand `n` is an open neighbourhood of `Ï‰ f Ï• s`, then for some `u âˆˆ f` we have\\n`closure {Ï• t x | t âˆˆ u, x âˆˆ s} âŠ† n`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] â¦ƒs t : Set Î±â¦„, s âŠ† t â†’ BddAbove t â†’ BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"If `s âŠ† t` and `t` is bounded above, then so is `s`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {s : Set G}, IsNormalSubgroup s â†’ âˆ€ (n : G), n âˆˆ s â†’ âˆ€ (g : G), g * n * gâ»Â¹ âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `s` is closed under conjugation. \"}]\n",
    "prompt_cons": "/-- If `s` is bounded, then so is `s âˆ© t` -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {s t : Set Î±}, BddBelow s â†’ BddBelow (s âˆ© t) :=\n\n/-- If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- One direction of the **Borel-Cantelli lemma**: if (sáµ¢) is a sequence of sets such\nthat `âˆ‘ Î¼ sáµ¢` is finite, then the limit superior of the `sáµ¢` is a null set. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : â„• â†’ Set Î±},\n  âˆ‘' (i : â„•), â†‘â†‘Î¼ (s i) â‰  âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 0 :=\n\n/-- It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s :=\n\n/-- For a compact set `s`, locally uniform convergence on `s` is just uniform convergence on `s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±], IsCompact s â†’ (TendstoLocallyUniformlyOn F f p s â†” TendstoUniformlyOn F f p s) :=\n\n/-- If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„),\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S' :=\n\n/-- If `t` is bounded, then so is `s âˆ© t` -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {s t : Set Î±}, BddAbove t â†’ BddAbove (s âˆ© t) :=\n\n/-- Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p Ã—Ë¢ ğ“Ÿ s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} {c : Î²},\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ Filter.principal s) (nhds c) â†” TendstoUniformlyOn F (fun x => c) p s :=\n\n/-- If two functions coincide on a set `s`, then a Taylor series for the first one is as well a\nTaylor series for the second one. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {s : Set E}\n  {f fâ‚ : E â†’ F} {n : â„•âˆ} {p : E â†’ FormalMultilinearSeries ğ•œ E F},\n  HasFTaylorSeriesUpToOn n f p s â†’ (âˆ€ (x : E), x âˆˆ s â†’ fâ‚ x = f x) â†’ HasFTaylorSeriesUpToOn n fâ‚ p s :=\n\n/-- If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n :=\n\n/-- If a sequence `g` converges to some `b`, then the sequence of constant functions\n`fun n â†¦ fun a â†¦ g n` converges to the constant function `fun a â†¦ b` on any set `s` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {p : Filter Î¹} {g : Î¹ â†’ Î²} {b : Î²},\n  Filter.Tendsto g p (nhds b) â†’ âˆ€ (s : Set Î±), TendstoUniformlyOn (fun n x => g n) (fun x => b) p s :=\n\n/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,\nsee Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\n  {Î½ : MeasureTheory.Measure Î²} [inst_2 : MeasureTheory.SigmaFinite Î½] {s : Set (Î± Ã— Î²)},\n  â†‘â†‘(MeasureTheory.Measure.prod Î¼ Î½) s = 0 â†’ (fun x => â†‘â†‘Î½ (Prod.mk x â»Â¹' s)) =á¶ [MeasureTheory.Measure.ae Î¼] 0 :=\n\n/-- If `s âˆˆ ğ“¤ Î±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ğ“¤ Î±`,\nwe have `t â—‹ t â—‹ ... â—‹ t âŠ† s` (`n` compositions). -/\ntheorem âˆ€ {Î± : Type ua} [inst : UniformSpace Î±] {s : Set (Î± Ã— Î±)},\n  s âˆˆ uniformity Î± â†’\n    âˆ€ (n : â„•), âˆ€á¶  (t : Set (Î± Ã— Î±)) in Filter.smallSets (uniformity Î±), (fun x => compRel t x)^[n] t âŠ† s :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- **The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sâ‚™)` such that\n`âˆ‘ n, Î¼ sâ‚™ = âˆ`, `limsup sâ‚™` has measure 1. -/\ntheorem âˆ€ {Î© : Type u_1} {m0 : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©} [inst : MeasureTheory.IsProbabilityMeasure Î¼]\n  {s : â„• â†’ Set Î©},\n  (âˆ€ (n : â„•), MeasurableSet (s n)) â†’\n    ProbabilityTheory.iIndepSet s â†’ âˆ‘' (n : â„•), â†‘â†‘Î¼ (s n) = âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 1 :=\n\n/-- If `s âŠ† t`, `Î¼ t â‰¤ Î¼ s`, `Î¼ t â‰  âˆ`, and `s` is measurable, then `s =áµ[Î¼] t`. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s t : Set Î±},\n  s âŠ† t â†’ â†‘â†‘Î¼ t â‰¤ â†‘â†‘Î¼ s â†’ MeasurableSet s â†’ â†‘â†‘Î¼ t â‰  âŠ¤ â†’ s =á¶ [MeasureTheory.Measure.ae Î¼] t :=\n\n/-- A set is eventually carried into any open neighbourhood of its Ï‰-limit:\nif `c` is a compact set such that `closure {Ï• t x | t âˆˆ v, x âˆˆ s} âŠ† c` for some `v âˆˆ f`\nand `n` is an open neighbourhood of `Ï‰ f Ï• s`, then for some `u âˆˆ f` we have\n`closure {Ï• t x | t âˆˆ u, x âˆˆ s} âŠ† n`. -/\ntheorem âˆ€ {Ï„ : Type u_2} {Î± : Type u_3} {Î² : Type u_1} [inst : TopologicalSpace Î²] (f : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : Set Î±)\n  {c : Set Î²},\n  IsCompact c â†’\n    (âˆƒ v, v âˆˆ f âˆ§ closure (Set.image2 Ï• v s) âŠ† c) â†’\n      âˆ€ {n : Set Î²}, IsOpen n â†’ omegaLimit f Ï• s âŠ† n â†’ âˆƒ u, u âˆˆ f âˆ§ closure (Set.image2 Ï• u s) âŠ† n :=\n\n/-- If `s âŠ† t` and `t` is bounded above, then so is `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] â¦ƒs t : Set Î±â¦„, s âŠ† t â†’ BddAbove t â†’ BddAbove s :=\n\n/-- The proposition that `s` is closed under conjugation. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {s : Set G}, IsNormalSubgroup s â†’ âˆ€ (n : G), n âˆˆ s â†’ âˆ€ (g : G), g * n * gâ»Â¹ âˆˆ s :=\n\n/-- Prove that convergence of `{s_n}` implies convergence of `{|s_n|}`. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] [inst_1 : IsAbs Î±] {s : â„• â†’ Î±}, Filter.Tendsto s Filter.atTop (nhds 0) â†’ Filter.Tendsto (fun n => abs (s n)) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u} [inst : NormedGroup Î±] {s : â„• â†’ Î±} {a : Î±}, Filter.Tendsto s Filter.atTop (nhds a) â†’ Filter.Tendsto (Î» n, âˆ¥s nâˆ¥) Filter.atTop (nhds âˆ¥aâˆ¥) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : OrderedRing Î²] [inst_2 : Nontrivial Î²] [inst_3 : CovariantClass Î± Î² Î² HMul.hMul LE.le] {s : Î± â†’ Î²}, Filter.Tendsto s Filter.atTop (nhds 0) â†’ Filter.Tendsto (Î» n, abs (s n)) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u} [inst : NormedGroup Î±] {s : â„• â†’ Î±} {a : Î±}, Filter.Tendsto s Filter.atTop (nhds a) â†’ Filter.Tendsto (Î» n, âˆ¥s nâˆ¥) Filter.atTop (nhds (âˆ¥aâˆ¥)) ",
      "âˆ€ {Î± : Type u} [inst : NormedGroup Î±] {s : â„• â†’ Î±}, CauchySeq s â†’ CauchySeq (fun n => âˆ¥s nâˆ¥) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedRing Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : TopologicalSpace Î²] {s : Î² â†’ Î±} {a : Î±} {f : Filter Î²},\n  Filter.Tendsto s f (nhds a) â†’ Filter.Tendsto (fun x => abs (s x)) f (nhds (abs a)) ",
      "âˆ€ {Î± : Type u} [inst : NormedGroup Î±] {s : â„• â†’ Î±} {a : Î±}, Filter.Tendsto s Filter.atTop (nhds a) â†’ Filter.Tendsto (fun n => âˆ¥s nâˆ¥) Filter.atTop (nhds âˆ¥aâˆ¥) ",
      "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {f : â„• â†’ Î±}, Filter.Tendsto f Filter.atTop (nhds 0) â†’ Filter.Tendsto (fun n => abs (f n)) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„), CauchySeq s â†’ CauchySeq (fun n => abs (s n)) ",
      "âˆ€ {Î± : Type u} [inst : NormedField Î±] {u : â„• â†’ Î±} {a : Î±},\n  Filter.Tendsto u Filter.atTop (nhds a) â†’ Filter.Tendsto (fun n => abs (u n)) Filter.atTop (nhds (abs a)) "
    ]
  },
  {
    "docString": "If `s_1=âˆš2`, and `s_{n+1}=âˆš(2+âˆšs_n)` for `(n=1,2,3, ...)`, prove that `{s_n}` converges, and that `s_n < 2` for `n=1,2,3, ...`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„),\\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\": \"âˆ€ {n : â„•} (self : Fin n), â†‘self < n\",\n  \"isProp\": true,\n  \"docString\": \"If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. \"},\n {\"theorem\":\n  \"âˆ€ {s : â„}, 0 < s â†’ MeasureTheory.IntegrableOn (fun x => rexp (-x) * x ^ (s - 1)) (Set.Ioi 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Euler integral for the `Î“` function converges for positive real `s`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\": \"For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. \"},\n {\"theorem\": \"âˆ€ {p : â„}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"âˆ€ {s : Set â„•}, Set.Infinite s â†’ âˆ€ {k : â„•}, 0 < k â†’ âˆƒ m, m âˆˆ s âˆ§ âˆƒ n, n âˆˆ s âˆ§ m < n âˆ§ m â‰¡ n [MOD k]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is an infinite set of natural numbers and `k > 0`, then `s` contains two elements `m < n`\\nthat are equal mod `k`. \"},\n {\"theorem\":\n  \"Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. \"},\n {\"theorem\": \"âˆ€ (s : â„), (fun x => x ^ s) =o[Filter.atTop] rexp\",\n  \"isProp\": true,\n  \"docString\": \"`x ^ s = o(exp x)` as `x â†’ âˆ` for any real `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {b : Î±},\\n  Set.Nonempty s â†’ (âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ b) â†’ (âˆ€ (ub : Î±), (âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ ub) â†’ b â‰¤ ub) â†’ sSup s = b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that\\n1) `b` is an upper bound\\n2) every other upper bound `b'` satisfies `b â‰¤ b'`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±] {a b : Î±},\\n  a < b â†’\\n    âˆ€ (s : Set Î±),\\n      List.TFAE\\n        [s âˆˆ nhdsWithin a (Set.Ioi a), s âˆˆ nhdsWithin a (Set.Ioc a b), s âˆˆ nhdsWithin a (Set.Ioo a b),\\n          âˆƒ u, u âˆˆ Set.Ioc a b âˆ§ Set.Ioo a u âŠ† s, âˆƒ u, u âˆˆ Set.Ioi a âˆ§ Set.Ioo a u âŠ† s]\",\n  \"isProp\": true,\n  \"docString\":\n  \"The following statements are equivalent:\\n\\n0. `s` is a neighborhood of `a` within `(a, +âˆ)`;\\n1. `s` is a neighborhood of `a` within `(a, b]`;\\n2. `s` is a neighborhood of `a` within `(a, b)`;\\n3. `s` includes `(a, u)` for some `u âˆˆ (a, b]`;\\n4. `s` includes `(a, u)` for some `u > a`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"If `s` has a least element, then it is bounded below. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n\",\n  \"isProp\": true,\n  \"docString\": \"The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. \"}]\n",
    "prompt_cons": "/-- If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. -/\ntheorem âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n :=\n\n/-- If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„),\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi :=\n\n/-- If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a :=\n\n/-- If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. -/\ntheorem âˆ€ {n : â„•} (self : Fin n), â†‘self < n :=\n\n/-- The Euler integral for the `Î“` function converges for positive real `s`. -/\ntheorem âˆ€ {s : â„}, 0 < s â†’ MeasureTheory.IntegrableOn (fun x => rexp (-x) * x ^ (s - 1)) (Set.Ioi 0) :=\n\n/-- For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n :=\n\n/-- If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p :=\n\n/-- If `s` is an infinite set of natural numbers and `k > 0`, then `s` contains two elements `m < n`\nthat are equal mod `k`. -/\ntheorem âˆ€ {s : Set â„•}, Set.Infinite s â†’ âˆ€ {k : â„•}, 0 < k â†’ âˆƒ m, m âˆˆ s âˆ§ âˆƒ n, n âˆˆ s âˆ§ m < n âˆ§ m â‰¡ n [MOD k] :=\n\n/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S' :=\n\n/-- `x ^ s = o(exp x)` as `x â†’ âˆ` for any real `s`. -/\ntheorem âˆ€ (s : â„), (fun x => x ^ s) =o[Filter.atTop] rexp :=\n\n/-- Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that\n1) `b` is an upper bound\n2) every other upper bound `b'` satisfies `b â‰¤ b'`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {b : Î±},\n  Set.Nonempty s â†’ (âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ b) â†’ (âˆ€ (ub : Î±), (âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ ub) â†’ b â‰¤ ub) â†’ sSup s = b :=\n\n/-- The following statements are equivalent:\n\n0. `s` is a neighborhood of `a` within `(a, +âˆ)`;\n1. `s` is a neighborhood of `a` within `(a, b]`;\n2. `s` is a neighborhood of `a` within `(a, b)`;\n3. `s` includes `(a, u)` for some `u âˆˆ (a, b]`;\n4. `s` includes `(a, u)` for some `u > a`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±] {a b : Î±},\n  a < b â†’\n    âˆ€ (s : Set Î±),\n      List.TFAE\n        [s âˆˆ nhdsWithin a (Set.Ioi a), s âˆˆ nhdsWithin a (Set.Ioc a b), s âˆˆ nhdsWithin a (Set.Ioo a b),\n          âˆƒ u, u âˆˆ Set.Ioc a b âˆ§ Set.Ioo a u âŠ† s, âˆƒ u, u âˆˆ Set.Ioi a âˆ§ Set.Ioo a u âŠ† s] :=\n\n/-- If `s` has a least element, then it is bounded below. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ BddBelow s :=\n\n/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n :=\n\n/-- If `s_1=âˆš2`, and `s_{n+1}=âˆš(2+âˆšs_n)` for `(n=1,2,3, ...)`, prove that `{s_n}` converges, and that `s_n < 2` for `n=1,2,3, ...`. -/\ntheorem",
    "choices": [
      "âˆ€ (n : â„•), 0 < Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n âˆ§ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n < 2 ",
      "s_nat_converges_lt_2 : âˆ€ (n : â„•), 0 < n â†’ Real.sqrtTwoAddSeries 0 n < 2 ",
      "âˆ€ (n : â„•), Real.sqrt (2 + Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n) < 2 ",
      "âˆ€ (n : â„•), Real.sqrt (2 + Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n) < 2 âˆ§ Filter.Tendsto Real.sqrtTwoAddSeries Filter.atTop (nhds 0) ",
      "Exists.intro (Real.sqrtTwoAddSeries (1 / 2) (Nat.succ n)) (And.intro (Real.sqrtTwoAddSeries.lt_two (Nat.succ n)) (Real.sqrtTwoAddSeries.step n))",
      "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î±] [inst_2 : SemilatticeSup Î±] {s : Î± â†’ â„•},\n  (âˆ€ n, s (n + 1) = Real.sqrt (2 + s n)) â†’ s 1 = Real.sqrt 2 â†’ Filter.Liminf Filter.atTop s < 2 ",
      "âˆ€ (s : â„• â†’ â„),\n  s 0 = Real.sqrt 2 â†’ (âˆ€ (n : â„•), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n)))\n  â†’ Filter.Tendsto s Filter.atTop (nhds (Real.sqrt 2)) âˆ§ âˆ€ (n : â„•), s n < 2 ",
      "âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ (N : â„•), âˆ€ (n : â„•), n â‰¥ N â†’ abs (Real.sqrt (2 + Real.sqrt (2 + ... + Real.sqrt 2)) - 2) < Îµ ",
      "âˆ€ {Î± : Type u} [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], (âˆ€ n, 1 â‰¤ n â†’ s n < 2) âˆ§ Filter.Tendsto s Filter.atTop (nhds (Real.sqrt 2)) ",
      "âˆ€ (s : â„• â†’ â„), (s 0 = Real.sqrt 2) â†’ (âˆ€ (n : â„•), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n))) â†’ (âˆƒ l, Filter.Tendsto s Filter.atTop (nhds l)) âˆ§ âˆ€ n, s n < 2 "
    ]
  },
  {
    "docString": "Prove that `lim_{nâ†’âˆ} Î£_{i<n} a_i = âˆ`, where `a_i = âˆš(i + 1) - âˆši`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {f : â„• â†’ Î² â†’ F} {u : â„• â†’ â„},\\n  Summable u â†’\\n    (âˆ€ (n : â„•) (x : Î²), â€–f n xâ€– â‰¤ u n) â†’\\n      TendstoUniformly (fun N x => Finset.sum (Finset.range N) fun n => f n x) (fun x => âˆ‘' (n : â„•), f n x) Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\\nVersion with index set `â„•`. \"},\n {\"theorem\": \"âˆ€ {n : â„•} (self : Fin n), â†‘self < n\",\n  \"isProp\": true,\n  \"docString\": \"If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\": \"âˆ€ (a : â„), Cardinal.mk â†‘(Set.Ici a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval [a, âˆ). \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} [inst : MeasurableSpace Î±] {Î¹ : Type u_1} [inst_1 : Countable Î¹] {f : Î¹ â†’ Î± â†’ ENNReal},\\n  (âˆ€ (i : Î¹), Measurable (f i)) â†’ Measurable fun x => âˆ‘' (i : Î¹), f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"note: `â„â‰¥0âˆ` can probably be generalized in a future version of this lemma. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\": \"âˆ€ (a : â„), Cardinal.mk â†‘(Set.Ioi a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval (a, âˆ). \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {f : â„• â†’ Î² â†’ F} {u : â„• â†’ â„},\\n  Summable u â†’\\n    âˆ€ {s : Set Î²},\\n      (âˆ€ (n : â„•) (x : Î²), x âˆˆ s â†’ â€–f n xâ€– â‰¤ u n) â†’\\n        TendstoUniformlyOn (fun N x => Finset.sum (Finset.range N) fun n => f n x) (fun x => âˆ‘' (n : â„•), f n x)\\n          Filter.atTop s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\\nVersion relative to a set, with index set `â„•`. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : Î± â†’ M} {a : Î±}, âˆ‘á¶  (i : Î±) (_ : i âˆˆ {a}), f i = f a\",\n  \"isProp\": true,\n  \"docString\": \"The sum of `f i` over `i âˆˆ {a}` equals `f a`.\"},\n {\"theorem\":\n  \"âˆ€ {Î© : Type u_1} {m0 : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©} [inst : MeasureTheory.IsProbabilityMeasure Î¼]\\n  {s : â„• â†’ Set Î©},\\n  (âˆ€ (n : â„•), MeasurableSet (s n)) â†’\\n    ProbabilityTheory.iIndepSet s â†’ âˆ‘' (n : â„•), â†‘â†‘Î¼ (s n) = âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sâ‚™)` such that\\n`âˆ‘ n, Î¼ sâ‚™ = âˆ`, `limsup sâ‚™` has measure 1. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddCommGroup Î±] [inst_1 : UniformSpace Î±] [inst_2 : CompleteSpace Î±]\\n  {f : Î² â†’ Î±}, Summable f â†” CauchySeq fun s => Finset.sum s fun b => f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** \"}]\n",
    "prompt_cons": "/-- Use the above equivalence to prove we have a limit. -/\ntheorem âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a) :=\n\n/-- proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a) :=\n\n/-- An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\nVersion with index set `â„•`. -/\ntheorem âˆ€ {Î² : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {f : â„• â†’ Î² â†’ F} {u : â„• â†’ â„},\n  Summable u â†’\n    (âˆ€ (n : â„•) (x : Î²), â€–f n xâ€– â‰¤ u n) â†’\n      TendstoUniformly (fun N x => Finset.sum (Finset.range N) fun n => f n x) (fun x => âˆ‘' (n : â„•), f n x) Filter.atTop :=\n\n/-- If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. -/\ntheorem âˆ€ {n : â„•} (self : Fin n), â†‘self < n :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- The cardinality of the interval [a, âˆ). -/\ntheorem âˆ€ (a : â„), Cardinal.mk â†‘(Set.Ici a) = Cardinal.continuum :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- note: `â„â‰¥0âˆ` can probably be generalized in a future version of this lemma. -/\ntheorem âˆ€ {Î± : Type u_2} [inst : MeasurableSpace Î±] {Î¹ : Type u_1} [inst_1 : Countable Î¹] {f : Î¹ â†’ Î± â†’ ENNReal},\n  (âˆ€ (i : Î¹), Measurable (f i)) â†’ Measurable fun x => âˆ‘' (i : Î¹), f i x :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- The cardinality of the interval (a, âˆ). -/\ntheorem âˆ€ (a : â„), Cardinal.mk â†‘(Set.Ioi a) = Cardinal.continuum :=\n\n/-- An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\nVersion relative to a set, with index set `â„•`. -/\ntheorem âˆ€ {Î² : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {f : â„• â†’ Î² â†’ F} {u : â„• â†’ â„},\n  Summable u â†’\n    âˆ€ {s : Set Î²},\n      (âˆ€ (n : â„•) (x : Î²), x âˆˆ s â†’ â€–f n xâ€– â‰¤ u n) â†’\n        TendstoUniformlyOn (fun N x => Finset.sum (Finset.range N) fun n => f n x) (fun x => âˆ‘' (n : â„•), f n x)\n          Filter.atTop s :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi :=\n\n/-- The sum of `f i` over `i âˆˆ {a}` equals `f a`. -/\ntheorem âˆ€ {Î± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : Î± â†’ M} {a : Î±}, âˆ‘á¶  (i : Î±) (_ : i âˆˆ {a}), f i = f a :=\n\n/-- **The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sâ‚™)` such that\n`âˆ‘ n, Î¼ sâ‚™ = âˆ`, `limsup sâ‚™` has measure 1. -/\ntheorem âˆ€ {Î© : Type u_1} {m0 : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©} [inst : MeasureTheory.IsProbabilityMeasure Î¼]\n  {s : â„• â†’ Set Î©},\n  (âˆ€ (n : â„•), MeasurableSet (s n)) â†’\n    ProbabilityTheory.iIndepSet s â†’ âˆ‘' (n : â„•), â†‘â†‘Î¼ (s n) = âŠ¤ â†’ â†‘â†‘Î¼ (Filter.limsup s Filter.atTop) = 1 :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddCommGroup Î±] [inst_1 : UniformSpace Î±] [inst_2 : CompleteSpace Î±]\n  {f : Î² â†’ Î±}, Summable f â†” CauchySeq fun s => Finset.sum s fun b => f b :=\n\n/-- Prove that `lim_{nâ†’âˆ} Î£_{i<n} a_i = âˆ`, where `a_i = âˆš(i + 1) - âˆši`. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±], Filter.Tendsto (Î» n, âˆ‘ i in Finset.range n, (Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (Î» n : â„•, âˆ‘ (i : â„•) in Finset.range n, Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [archimedean Î±], Filter.Tendsto (Î» n : â„•, Finset.sum (Finset.range n) (Î» i => Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘(i + 1)) - Real.sqrt â†‘i) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (â†‘i + 1) - Real.sqrt â†‘i) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) (Î»i => (Real.sqrt (i + 1) - Real.sqrt i))) Filter.atTop Filter.atTop ",
      "forall {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => sqrt (i + 1) - sqrt i) Filter.atTop Filter.atTop "
    ]
  },
  {
    "docString": "If `Î£ a_n` converges, and if `{b_n}` is monotonic and bounded, prove that `Î£ a_n b_n` converges.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {p : Filter Î¹} {g : Î¹ â†’ Î²} {b : Î²},\\n  Filter.Tendsto g p (nhds b) â†’ âˆ€ (s : Set Î±), TendstoUniformlyOn (fun n x => g n) (fun x => b) p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence `g` converges to some `b`, then the sequence of constant functions\\n`fun n â†¦ fun a â†¦ g n` converges to the constant function `fun a â†¦ b` on any set `s` \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n â‰¤\\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the sequence of denominators is monotone, that is `Bâ‚™ â‰¤ Bâ‚™â‚Šâ‚`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Monotone convergence theorem for nonincreasing sequences of functions \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†’\\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop â†’\\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„),\\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {u : â„• â†’ â„} (h : Subadditive u),\\n  BddBelow (Set.range fun n => u n / â†‘n) â†’ Filter.Tendsto (fun n => u n / â†‘n) Filter.atTop (nhds (Subadditive.lim h))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fekete's lemma: a subadditive sequence which is bounded below converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\\n  [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±] {f : Filter Î²} {u : Î² â†’ Î±} {s : Set Î±},\\n  Dense s â†’\\n    (âˆ€ (a : Î±), a âˆˆ s â†’ âˆ€ (b : Î±), b âˆˆ s â†’ a < b â†’ Â¬((âˆƒá¶  (n : Î²) in f, u n < a) âˆ§ âˆƒá¶  (n : Î²) in f, b < u n)) â†’\\n      autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¤ x_1) f u) _autoâœ â†’\\n        autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¥ x_1) f u) _autoâœÂ¹ â†’ âˆƒ c, Filter.Tendsto u f (nhds c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\\nworks if `a` and `b` are restricted to a dense subset.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’\\n        (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), HasFDerivAt (fun y => âˆ‘' (n : Î±), f n y) (âˆ‘' (n : Î±), f' n x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series is differentiable and its derivative is the sum of the derivatives. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} [inst : Filter.IsCountablyGenerated l],\\n  (âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.atTop l â†’ âˆƒ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) â†’\\n    Filter.Tendsto x l f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequence converges if every subsequence has a convergent subsequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (m : MeasureTheory.OuterMeasure Î±) {s : â„• â†’ Set Î±},\\n  (âˆ€ (n : â„•), s n âŠ† s (n + 1)) â†’\\n    âˆ‘' (k : â„•), â†‘m (s (k + 1) \\\\ s k) â‰  âŠ¤ â†’\\n      âˆ€ [inst : (i : â„•) â†’ DecidablePred fun x => x âˆˆ s i], â†‘m (â‹ƒ (n : â„•), s n) = â¨† (n : â„•), â†‘m (s n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s : â„• â†’ Set Î±` is a monotone sequence of sets such that `âˆ‘' k, m (s (k + 1) \\\\ s k) â‰  âˆ`,\\nthen `m (â‹ƒ n, s n) = â¨† n, m (s n)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Add Î±] [inst_1 : Preorder Î±] [inst_2 : Preorder Î²] {f g : Î² â†’ Î±}\\n  [inst_3 : CovariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1]\\n  [inst_4 : CovariantClass Î± Î± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\\n  StrictMono f â†’ Monotone g â†’ StrictMono fun x => f x + g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a strictly monotone function and a monotone function is\\nstrictly monotone.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\\n  Summable u â†’\\n    IsOpen s â†’\\n      IsPreconnected s â†’\\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\\nat a point, and all functions in the series are differentiable with a summable bound on the\\nderivatives, then the series converges everywhere on the set. \"}]\n",
    "prompt_cons": "/-- Monotone convergence theorem expressed with limits -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal} {F : Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), AEMeasurable (f n)) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Monotone fun n => f n x) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) â†’\n        Filter.Tendsto (fun n => âˆ«â» (x : Î±), f n x âˆ‚Î¼) Filter.atTop (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼)) :=\n\n/-- proof that a monotone function tends to `ğ“ a` as `x â†’ âˆ` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [self : SupConvergenceClass Î±] (a : Î±) (s : Set Î±),\n  IsLUB s a â†’ Filter.Tendsto CoeTC.coe Filter.atTop (nhds a) :=\n\n/-- If a sequence `g` converges to some `b`, then the sequence of constant functions\n`fun n â†¦ fun a â†¦ g n` converges to the constant function `fun a â†¦ b` on any set `s` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {p : Filter Î¹} {g : Î¹ â†’ Î²} {b : Î²},\n  Filter.Tendsto g p (nhds b) â†’ âˆ€ (s : Set Î±), TendstoUniformlyOn (fun n x => g n) (fun x => b) p s :=\n\n/-- Shows that the sequence of denominators is monotone, that is `Bâ‚™ â‰¤ Bâ‚™â‚Šâ‚`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n â‰¤\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1) :=\n\n/-- If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a) :=\n\n/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : â„• â†’ Î± â†’ ENNReal},\n  (âˆ€ (n : â„•), Measurable (f n)) â†’\n    (âˆ€ (n : â„•), f (Nat.succ n) â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f n) â†’\n      âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ«â» (a : Î±), â¨… (n : â„•), f n a âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼ :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i :=\n\n/-- If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„),\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- Fekete's lemma: a subadditive sequence which is bounded below converges. -/\ntheorem âˆ€ {u : â„• â†’ â„} (h : Subadditive u),\n  BddBelow (Set.range fun n => u n / â†‘n) â†’ Filter.Tendsto (fun n => u n / â†‘n) Filter.atTop (nhds (Subadditive.lim h)) :=\n\n/-- Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\nworks if `a` and `b` are restricted to a dense subset. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±] {f : Filter Î²} {u : Î² â†’ Î±} {s : Set Î±},\n  Dense s â†’\n    (âˆ€ (a : Î±), a âˆˆ s â†’ âˆ€ (b : Î±), b âˆˆ s â†’ a < b â†’ Â¬((âˆƒá¶  (n : Î²) in f, u n < a) âˆ§ âˆƒá¶  (n : Î²) in f, b < u n)) â†’\n      autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¤ x_1) f u) _autoâœ â†’\n        autoParam (Filter.IsBoundedUnder (fun x x_1 => x â‰¥ x_1) f u) _autoâœÂ¹ â†’ âˆƒ c, Filter.Tendsto u f (nhds c) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series is differentiable and its derivative is the sum of the derivatives. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’\n        (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), HasFDerivAt (fun y => âˆ‘' (n : Î±), f n y) (âˆ‘' (n : Î±), f' n x) x :=\n\n/-- A sequence converges if every subsequence has a convergent subsequence. -/\ntheorem âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} [inst : Filter.IsCountablyGenerated l],\n  (âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.atTop l â†’ âˆƒ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) â†’\n    Filter.Tendsto x l f :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- If `s : â„• â†’ Set Î±` is a monotone sequence of sets such that `âˆ‘' k, m (s (k + 1) \\ s k) â‰  âˆ`,\nthen `m (â‹ƒ n, s n) = â¨† n, m (s n)`. -/\ntheorem âˆ€ {Î± : Type u_1} (m : MeasureTheory.OuterMeasure Î±) {s : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), s n âŠ† s (n + 1)) â†’\n    âˆ‘' (k : â„•), â†‘m (s (k + 1) \\ s k) â‰  âŠ¤ â†’\n      âˆ€ [inst : (i : â„•) â†’ DecidablePred fun x => x âˆˆ s i], â†‘m (â‹ƒ (n : â„•), s n) = â¨† (n : â„•), â†‘m (s n) :=\n\n/-- The sum of a strictly monotone function and a monotone function is\nstrictly monotone. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Add Î±] [inst_1 : Preorder Î±] [inst_2 : Preorder Î²] {f g : Î² â†’ Î±}\n  [inst_3 : CovariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1]\n  [inst_4 : CovariantClass Î± Î± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictMono f â†’ Monotone g â†’ StrictMono fun x => f x + g x :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series converges everywhere on the set. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\n  Summable u â†’\n    IsOpen s â†’\n      IsPreconnected s â†’\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x :=\n\n/-- If `Î£ a_n` converges, and if `{b_n}` is monotonic and bounded, prove that `Î£ a_n b_n` converges. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedCommMonoid Î±] [inst_1 : OrderedCommMonoid Î²] {f : â„• â†’ Î±} {g : â„• â†’ Î²},\n  Summable f â†’\n    (âˆ€ (n : â„•), g n â‰¤ g (n + 1)) â†’\n      BddAbove (Set.Range g) â†’\n        Summable fun n => f n * g n ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedCommMonoid Î±] [inst_1 : LinearOrderedCommMonoid Î²] {a : â„• â†’ Î±} {b : â„• â†’ Î²},\n  Summable a â†’ Monotone b â†’ BddAbove (Set.Range b) â†’ Summable (fun n => a n * b n) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedCommMonoid Î±] [inst_1 : LinearOrderedCommRing Î²] {ua : Î± â†’+ â„} {u : â„• â†’ Î±}\n  {ub : Î² â†’+ â„} {v : â„• â†’ Î²},\n  Filter.Tendsto (fun n => ua (u n)) Filter.atTop (nhds 0) â†’\n    (Monotone v âˆ§ Bounded (Set.Range v)) â†’\n      Filter.Tendsto (fun n => (ua (u n)).toReal * ub (v n).toReal) Filter.atTop (nhds 0) ",
      "âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a b : â„• â†’ Î±},\n  Summable a â†’ BddAbove (Set.Range b) â†’ BddBelow (Set.Range b) â†’ Monotone b â†’ Summable (Î» n, a n * b n) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedCancelAddCommMonoid Î²] [inst_1 : TopologicalSpace Î²] {a b : â„• â†’ Î²} {c : Î²},\n  HasSum a c â†’\n    BddAbove (Set.Range b) â†’\n      Monotone b â†’ HasSum (fun n => a n * b n) (c * b 0) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : OrderedAddCommMonoid Î²] {a : â„• â†’ Î±} {b : â„• â†’ Î²},\n  HasSum a (âˆ‘' (n : â„•), a n) â†’\n    Monotone b â†’\n      BddAbove (Set.Range b) â†’\n        HasSum (fun n => a n * b n) (âˆ‘' (n : â„•), a n * b n) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedCommMonoid Î±] [inst_1 : LinearOrderedAddCommMonoid Î²]\n  [inst_2 : TopologicalSpace Î²] [inst_3 : OrderClosedTopology Î²] {f g : â„• â†’ Î±} {B : Î±},\n  HasSum f B â†’ Monotone g â†’ BddAbove (Set.Range g) â†’ HasSum (fun n => f n * g n) (B * g 0) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  {f : â„• â†’ Î±} {g : â„• â†’ Î²} [inst_3 : LinearOrderedAddCommMonoid Î²] {a : Î±} {b : Î²},\n  HasSum f a â†’\n    Monotone g â†’\n      BddAbove (Set.Range g) â†’\n        BddBelow (Set.Range g) â†’ HasSum (fun n => f n * g n) (a * b) ",
      "forall {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedCommMonoid Î±] [inst_1 : OrderedCommMonoid Î²] {a : â„• â†’ Î±} {b : â„• â†’ Î²},\n  Summable a â†’\n    BddBelow (Set.range b) â†’\n      BddAbove (Set.range b) â†’\n        Monotone b â†’\n          Summable fun n => a n * b n ",
      "forall {Î± : Type u_1} {Î² : Type u_2} [inst : OrderedCommMonoid Î±] [inst_1 : OrderedCommMonoid Î²]\n  {a : â„• â†’ Î±} {b : â„• â†’ Î²} {l : Î±},\n  HasSum a l â†’ Monotone b â†’ BddAbove (Set.Range b) â†’ HasSum (fun n => a n * b n) (l * b 0) "
    ]
  },
  {
    "docString": "Suppose `{p_n}` is a Cauchy sequence in a metric space `X`, and some sequence `{p_{n l}}` converges to a point `p âˆˆ X`. Prove that the full sequence `{p_n}` converges to `p`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\\n  CauchySeq F â†’\\n    âˆ€ {f : { x // x âˆˆ lp E p }},\\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\\n`lp E p`, then it converges to `f` in the `lp E p` topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\\n  (p : FormalMultilinearSeries ğ•œ E F),\\n  0 < FormalMultilinearSeries.radius p â†’\\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the sum of a converging power series `p` admits `p` as a power series.\\nThis is not totally obvious as we need to check the convergence of the series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†’\\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop â†’\\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î¹ : Type u_3} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 â‰¤ p)] {f : Î¹ â†’ { x // x âˆˆ MeasureTheory.Lp E p }}\\n  {g : { x // x âˆˆ MeasureTheory.Lp E p }} {l : Filter Î¹},\\n  Filter.Tendsto f l (nhds g) â†’ MeasureTheory.TendstoInMeasure Î¼ (fun n => â†‘â†‘(f n)) l â†‘â†‘g\",\n  \"isProp\": true,\n  \"docString\": \"Convergence in Lp implies convergence in measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ dist (u m) (u n) < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudometric space, Cauchy sequences are characterized by the fact that, eventually,\\nthe distance between its elements is arbitrarily small \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\\n  (b : Î² â†’ â„),\\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²]\\n  {Î³ : Type u_1} {F : Î² â†’ Î³ â†’ Î±} {s : Set Î³},\\n  UniformCauchySeqOn F Filter.atTop s â†”\\n    âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ âˆ€ (x : Î³), x âˆˆ s â†’ dist (F m x) (F n x) < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudometric space, uniform Cauchy sequences are characterized by the fact that,\\neventually, the distance between all its elements is uniformly, arbitrarily small \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {f : CauSeq â„š (padicNorm p)},\\n  Â¬f â‰ˆ 0 â†’ âˆƒ N, âˆ€ (m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ padicNorm p (â†‘f n) = padicNorm p (â†‘f m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of the entries of a nonzero Cauchy sequence of rationals is eventually\\nconstant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (B : â„• â†’ â„),\\n  (âˆ€ (n : â„•), 0 < B n) â†’\\n    (âˆ€ (u : â„• â†’ Î±),\\n        (âˆ€ (N n m : â„•), N â‰¤ n â†’ N â‰¤ m â†’ dist (u n) (u m) < B N) â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)) â†’\\n      CompleteSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A very useful criterion to show that a space is complete is to show that all sequences\\nwhich satisfy a bound of the form `dist (u n) (u m) < B N` for all `n m â‰¥ N` are\\nconverging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to\\n`0`, which makes it possible to use arguments of converging series, while this is impossible\\nto do in general for arbitrary Cauchy sequences. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\\n  {p : ENNReal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\\n  1 â‰¤ p â†’\\n    p â‰  âŠ¤ â†’\\n      (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\\n        MeasureTheory.Memâ„’p g p â†’\\n          MeasureTheory.UnifIntegrable f p Î¼ â†’\\n            MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\\n              Filter.Tendsto (fun n => MeasureTheory.snorm (f n - g) p Î¼) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Forward direction of Vitali's convergence theorem: if `f` is a sequence of uniformly integrable\\nfunctions that converge in measure to some function `g` in a finite measure space, then `f`\\nconverge in Lp to `g`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X},\\n  Metric.Bounded s â†’\\n    âˆ€ {x : â„• â†’ X},\\n      (âˆ€ (n : â„•), x n âˆˆ s) â†’ âˆƒ a, a âˆˆ closure s âˆ§ âˆƒ Ï†, StrictMono Ï† âˆ§ Filter.Tendsto (x âˆ˜ Ï†) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A version of Bolzano-Weistrass: in a proper metric space (eg. $â„^n$),\\nevery bounded sequence has a converging subsequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s\",\n  \"isProp\": true,\n  \"docString\": \"A sequence that converges uniformly is also uniformly Cauchy \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (n : Î²), n â‰¥ N â†’ dist (u n) (u N) < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A variation around the pseudometric characterization of Cauchy sequences \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"}]\n",
    "prompt_cons": "/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\n  CauchySeq F â†’\n    âˆ€ {f : { x // x âˆˆ lp E p }},\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\n  (p : FormalMultilinearSeries ğ•œ E F),\n  0 < FormalMultilinearSeries.radius p â†’\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p) :=\n\n/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- If the distance between `s n` and `s m`, `n â‰¤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„), (âˆ€ (n m : Î²), n â‰¤ m â†’ dist (s n) (s m) â‰¤ b n) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- Convergence in Lp implies convergence in measure. -/\ntheorem âˆ€ {Î± : Type u_1} {Î¹ : Type u_3} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 â‰¤ p)] {f : Î¹ â†’ { x // x âˆˆ MeasureTheory.Lp E p }}\n  {g : { x // x âˆˆ MeasureTheory.Lp E p }} {l : Filter Î¹},\n  Filter.Tendsto f l (nhds g) â†’ MeasureTheory.TendstoInMeasure Î¼ (fun n => â†‘â†‘(f n)) l â†‘â†‘g :=\n\n/-- In a pseudometric space, Cauchy sequences are characterized by the fact that, eventually,\nthe distance between its elements is arbitrarily small -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ dist (u m) (u n) < Îµ :=\n\n/-- If the distance between `s n` and `s m`, `n, m â‰¥ N` is bounded above by `b N`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {s : Î² â†’ Î±}\n  (b : Î² â†’ â„),\n  (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ dist (s n) (s m) â‰¤ b N) â†’ Filter.Tendsto b Filter.atTop (nhds 0) â†’ CauchySeq s :=\n\n/-- In a pseudometric space, uniform Cauchy sequences are characterized by the fact that,\neventually, the distance between all its elements is uniformly, arbitrarily small -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²]\n  {Î³ : Type u_1} {F : Î² â†’ Î³ â†’ Î±} {s : Set Î³},\n  UniformCauchySeqOn F Filter.atTop s â†”\n    âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ âˆ€ (x : Î³), x âˆˆ s â†’ dist (F m x) (F n x) < Îµ :=\n\n/-- The `p`-adic norm of the entries of a nonzero Cauchy sequence of rationals is eventually\nconstant. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {f : CauSeq â„š (padicNorm p)},\n  Â¬f â‰ˆ 0 â†’ âˆƒ N, âˆ€ (m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ padicNorm p (â†‘f n) = padicNorm p (â†‘f m) :=\n\n/-- A very useful criterion to show that a space is complete is to show that all sequences\nwhich satisfy a bound of the form `dist (u n) (u m) < B N` for all `n m â‰¥ N` are\nconverging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to\n`0`, which makes it possible to use arguments of converging series, while this is impossible\nto do in general for arbitrary Cauchy sequences. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (B : â„• â†’ â„),\n  (âˆ€ (n : â„•), 0 < B n) â†’\n    (âˆ€ (u : â„• â†’ Î±),\n        (âˆ€ (N n m : â„•), N â‰¤ n â†’ N â‰¤ m â†’ dist (u n) (u m) < B N) â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)) â†’\n      CompleteSpace Î± :=\n\n/-- Forward direction of Vitali's convergence theorem: if `f` is a sequence of uniformly integrable\nfunctions that converge in measure to some function `g` in a finite measure space, then `f`\nconverge in Lp to `g`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup Î²]\n  {p : ENNReal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\n  1 â‰¤ p â†’\n    p â‰  âŠ¤ â†’\n      (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\n        MeasureTheory.Memâ„’p g p â†’\n          MeasureTheory.UnifIntegrable f p Î¼ â†’\n            MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\n              Filter.Tendsto (fun n => MeasureTheory.snorm (f n - g) p Î¼) Filter.atTop (nhds 0) :=\n\n/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $â„^n$),\nevery bounded sequence has a converging subsequence. -/\ntheorem âˆ€ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X},\n  Metric.Bounded s â†’\n    âˆ€ {x : â„• â†’ X},\n      (âˆ€ (n : â„•), x n âˆˆ s) â†’ âˆƒ a, a âˆˆ closure s âˆ§ âˆƒ Ï†, StrictMono Ï† âˆ§ Filter.Tendsto (x âˆ˜ Ï†) Filter.atTop (nhds a) :=\n\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- A variation around the pseudometric characterization of Cauchy sequences -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ N, âˆ€ (n : Î²), n â‰¥ N â†’ dist (u n) (u N) < Îµ :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b :=\n\n/-- Suppose `{p_n}` is a Cauchy sequence in a metric space `X`, and some sequence `{p_{n l}}` converges to a point `p âˆˆ X`. Prove that the full sequence `{p_n}` converges to `p`. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {l : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto l p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ l) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±}\n  {Î¹ : Type*} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n  CauchySeq u â†’\n    Filter.Tendsto f p Filter.atTop â†’\n      âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : Nonempty Î²] [inst_2 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : MetricSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) "
    ]
  },
  {
    "docString": "Suppose `X` is a nonempty complete metric space, and `{G_n}` is a sequence of dense open sets of `X`. Prove Baire's theorem, namely, that `âˆ©_{n=1}^{âˆ} G_n` is not empty.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±]\\n  [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ âˆƒ s, Set.Nonempty (interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"One of the most useful consequences of Baire theorem: if a countable union of closed sets\\ncovers the space, then one of the sets has nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with `â‹ƒâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²}\\n  {f : (x : Î²) â†’ x âˆˆ S â†’ Set Î±},\\n  (âˆ€ (s : Î²) (H : s âˆˆ S), IsGÎ´ (f s H)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²) (H : s âˆˆ S), Dense (f s H)) â†’ Dense (â‹‚ (s : Î²) (h : s âˆˆ S), f s h)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {s t : Set Î±},\\n  IsGÎ´ s â†’ IsGÎ´ t â†’ Dense s â†’ Dense t â†’ Dense (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: the intersection of two dense GÎ´ sets is dense. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is an encodable type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is an encodable type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsGÎ´ (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\\nan index set which is an encodable type. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\\n  Metric.Bounded s â†’ IsCompact (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] {C : Set Î±},\\n  Perfect C â†’ Set.Nonempty C â†’ âˆ€ [inst_1 : CompleteSpace Î±], âˆƒ f, Set.range f âŠ† C âˆ§ Continuous f âˆ§ Function.Injective f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any nonempty perfect set in a complete metric space admits a continuous injection\\nfrom the Cantor space, `â„• â†’ Bool`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : ConditionallyCompleteLattice Î±] [inst_1 : SemilatticeSup Î²] {f g : Î² â†’ Î±},\\n  (Antitone fun n => Set.Icc (f n) (g n)) â†’ (âˆ€ (n : Î²), f n â‰¤ g n) â†’ â¨† (n : Î²), f n âˆˆ â‹‚ (n : Î²), Set.Icc (f n) (g n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Nested intervals lemma: if `[f n, g n]` is an antitone sequence of nonempty\\nclosed intervals, then `â¨† n, f n` belongs to all the intervals `[f n, g n]`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’L[ğ•œ] F)\\n  [inst_5 : CompleteSpace F],\\n  Function.Surjective â†‘f â†’ âˆƒ C, C â‰¥ 0 âˆ§ âˆ€ (y : F), âˆƒ x, dist (â†‘f x) y â‰¤ 1 / 2 * â€–yâ€– âˆ§ â€–xâ€– â‰¤ C * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"First step of the proof of the Banach open mapping theorem (using completeness of `F`):\\nby Baire's theorem, there exists a ball in `E` whose image closure has nonempty interior.\\nRescaling everything, it follows that any `y âˆˆ F` is arbitrarily well approached by\\nimages of elements of norm at most `C * â€–yâ€–`.\\nFor further use, we will only need such an element whose image\\nis within distance `â€–yâ€–/2` of `y`, to apply an iterative process. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"}]\n",
    "prompt_cons": "/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets\ncovers the space, then one of the sets has nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Nonempty Î±]\n  [inst_3 : Encodable Î²] {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ âˆƒ s, Set.Nonempty (interior (f s)) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `â‹ƒâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²}\n  {f : (x : Î²) â†’ x âˆˆ S â†’ Set Î±},\n  (âˆ€ (s : Î²) (H : s âˆˆ S), IsGÎ´ (f s H)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²) (H : s âˆˆ S), Dense (f s H)) â†’ Dense (â‹‚ (s : Î²) (h : s âˆˆ S), f s h) :=\n\n/-- Baire theorem: the intersection of two dense GÎ´ sets is dense. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {s t : Set Î±},\n  IsGÎ´ s â†’ IsGÎ´ t â†’ Dense s â†’ Dense t â†’ Dense (s âˆ© t) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is an encodable type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s) :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is an encodable type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsClosed (f s)) â†’ â‹ƒ (s : Î²), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²), interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\nan index set which is an encodable type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsGÎ´ (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s) :=\n\n/-- If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s) :=\n\n/-- The **Heineâ€“Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : ProperSpace Î±],\n  Metric.Bounded s â†’ IsCompact (closure s) :=\n\n/-- Any nonempty perfect set in a complete metric space admits a continuous injection\nfrom the Cantor space, `â„• â†’ Bool`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] {C : Set Î±},\n  Perfect C â†’ Set.Nonempty C â†’ âˆ€ [inst_1 : CompleteSpace Î±], âˆƒ f, Set.range f âŠ† C âˆ§ Continuous f âˆ§ Function.Injective f :=\n\n/-- Nested intervals lemma: if `[f n, g n]` is an antitone sequence of nonempty\nclosed intervals, then `â¨† n, f n` belongs to all the intervals `[f n, g n]`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : ConditionallyCompleteLattice Î±] [inst_1 : SemilatticeSup Î²] {f g : Î² â†’ Î±},\n  (Antitone fun n => Set.Icc (f n) (g n)) â†’ (âˆ€ (n : Î²), f n â‰¤ g n) â†’ â¨† (n : Î²), f n âˆˆ â‹‚ (n : Î²), Set.Icc (f n) (g n) :=\n\n/-- First step of the proof of the Banach open mapping theorem (using completeness of `F`):\nby Baire's theorem, there exists a ball in `E` whose image closure has nonempty interior.\nRescaling everything, it follows that any `y âˆˆ F` is arbitrarily well approached by\nimages of elements of norm at most `C * â€–yâ€–`.\nFor further use, we will only need such an element whose image\nis within distance `â€–yâ€–/2` of `y`, to apply an iterative process. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’L[ğ•œ] F)\n  [inst_5 : CompleteSpace F],\n  Function.Surjective â†‘f â†’ âˆƒ C, C â‰¥ 0 âˆ§ âˆ€ (y : F), âˆƒ x, dist (â†‘f x) y â‰¤ 1 / 2 * â€–yâ€– âˆ§ â€–xâ€– â‰¤ C * â€–yâ€– :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- Suppose `X` is a nonempty complete metric space, and `{G_n}` is a sequence of dense open sets of `X`. Prove Baire's theorem, namely, that `âˆ©_{n=1}^{âˆ} G_n` is not empty. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {Î² : Type u_2} [inst_2 : Encodable Î²]\n  {G : Î² â†’ Set X}, (âˆ€ (n : Î²), IsOpen (G n)) â†’ (âˆ€ (n : Î²), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : Î²), G n) ",
      "âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {G : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] [inst_2 : Nonempty X] {G : â„• â†’ Set X},\n  (âˆ€ n, IsOpen (G n) âˆ§ Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) ",
      "forall {Î± : Type u_1} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (f n) âˆ§ Dense (f n)) â†’ Set.Nonempty (â‹‚ (n : â„•), f n) ",
      "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : â„• â†’ Set Î±},\n  (âˆ€ n, IsOpen (S n)) â†’ (âˆ€ n, Dense (S n)) â†’ Set.Nonempty (â‹‚ n, S n) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : â„• â†’ Set X},\n  (âˆ€ n, IsOpen (G n) âˆ§ Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) ",
      "âˆ€ {Î± : Type u_2} [inst : MetricSpace Î±] [inst_1 : CompleteSpace Î±] {Î² : Type u_1} [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Set.Nonempty (â‹‚ (s : Î²), f s) ",
      "forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : â„• â†’ Set X},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) ",
      "forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : â„• â†’ Set X},\n  (âˆ€ n, IsOpen (G n)) â†’ (âˆ€ n, Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) ",
      "forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] [inst_2 : Nonempty X] {G : â„• â†’ Set X},\n  (âˆ€ (n : â„•), IsOpen (G n)) â†’ (âˆ€ (n : â„•), Dense (G n)) â†’ Set.Nonempty (â‹‚ (n : â„•), G n) "
    ]
  },
  {
    "docString": "If `f` is a continuous mapping of a metric space `X` into a metric space `Y`, prove that `f(âˆ‚E) âŠ† âˆ‚f(E)` for every set `E âŠ† X`. (`âˆ‚E` denotes the closure of `E`).",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f f' : â„ â†’ E}\\n  {a b : â„},\\n  a â‰¤ b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\\n        IntervalIntegrable f' MeasureTheory.volume a b â†’ âˆ« (y : â„) in a..b, f' y = f b - f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus-2: If `f : â„ â†’ E` is continuous on `[a, b]` (where `a â‰¤ b`) and\\nhas a derivative at `f' x` for all `x` in `(a, b)`, and `f'` is integrable on `[a, b]`, then\\n`âˆ« y in a..b, f' y` equals `f b - f a`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„â‰¥0âˆ)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’\\n          âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (ENNReal.ofReal (Î´ x)) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²}\\n  {f : Î± â†’ Î²}, Set.MapsTo f s t â†’ Continuous f â†’ IsClosed t â†’ Set.MapsTo f (closure s) t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\\n  {f : X â†’ Y}, Embedding f â†’ DiscreteTopology X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology induced under an inclusion `f : X â†’ Y` from the discrete topological space `Y`\\nis the discrete topology on `X`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  (f : PartitionOfUnity Î¹ X s) [inst_5 : ContinuousAdd E] {g : Î¹ â†’ X â†’ E},\\n  (âˆ€ (i : Î¹) (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt (g i) x) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f f' : â„‚ â†’ E}\\n  {c : â„‚} {R : â„},\\n  (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c |R| â†’ HasDerivWithinAt f (f' z) (Metric.sphere c |R|) z) â†’\\n    (âˆ® (z : â„‚) in C(c, R), f' z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f' : â„‚ â†’ E` is a derivative of a complex differentiable function on the circle\\n`Metric.sphere c |R|`, then `âˆ® z in C(c, R), f' z = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E} {s : Set â„‚},\\n  Set.Countable s â†’\\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f f' : â„‚ â†’ E}\\n  {c : â„‚} {R : â„},\\n  0 â‰¤ R â†’\\n    (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c R â†’ HasDerivWithinAt f (f' z) (Metric.sphere c R) z) â†’\\n      (âˆ® (z : â„‚) in C(c, R), f' z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f' : â„‚ â†’ E` is a derivative of a complex differentiable function on the circle\\n`Metric.sphere c R`, then `âˆ® z in C(c, R), f' z = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"}]\n",
    "prompt_cons": "/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- Fundamental theorem of calculus-2: If `f : â„ â†’ E` is continuous on `[a, b]` (where `a â‰¤ b`) and\nhas a derivative at `f' x` for all `x` in `(a, b)`, and `f'` is integrable on `[a, b]`, then\n`âˆ« y in a..b, f' y` equals `f b - f a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f f' : â„ â†’ E}\n  {a b : â„},\n  a â‰¤ b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\n        IntervalIntegrable f' MeasureTheory.volume a b â†’ âˆ« (y : â„) in a..b, f' y = f b - f a :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„â‰¥0âˆ)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (ENNReal.ofReal (Î´ x)) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’\n          âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f :=\n\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€– :=\n\n/-- If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f) :=\n\n/-- If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²}\n  {f : Î± â†’ Î²}, Set.MapsTo f s t â†’ Continuous f â†’ IsClosed t â†’ Set.MapsTo f (closure s) t :=\n\n/-- The topology induced under an inclusion `f : X â†’ Y` from the discrete topological space `Y`\nis the discrete topology on `X`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\n  {f : X â†’ Y}, Embedding f â†’ DiscreteTopology X :=\n\n/-- If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  (f : PartitionOfUnity Î¹ X s) [inst_5 : ContinuousAdd E] {g : Î¹ â†’ X â†’ E},\n  (âˆ€ (i : Î¹) (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt (g i) x) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x :=\n\n/-- If `f' : â„‚ â†’ E` is a derivative of a complex differentiable function on the circle\n`Metric.sphere c |R|`, then `âˆ® z in C(c, R), f' z = 0`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f f' : â„‚ â†’ E}\n  {c : â„‚} {R : â„},\n  (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c |R| â†’ HasDerivWithinAt f (f' z) (Metric.sphere c |R|) z) â†’\n    (âˆ® (z : â„‚) in C(c, R), f' z) = 0 :=\n\n/-- If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E} {s : Set â„‚},\n  Set.Countable s â†’\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\ s â†’ DifferentiableAt â„‚ f z) â†’\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- If `f' : â„‚ â†’ E` is a derivative of a complex differentiable function on the circle\n`Metric.sphere c R`, then `âˆ® z in C(c, R), f' z = 0`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f f' : â„‚ â†’ E}\n  {c : â„‚} {R : â„},\n  0 â‰¤ R â†’\n    (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c R â†’ HasDerivWithinAt f (f' z) (Metric.sphere c R) z) â†’\n      (âˆ® (z : â„‚) in C(c, R), f' z) = 0 :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- If `f` is a continuous mapping of a metric space `X` into a metric space `Y`, prove that `f(âˆ‚E) âŠ† âˆ‚f(E)` for every set `E âŠ† X`. (`âˆ‚E` denotes the closure of `E`). -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f : X â†’ Y},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ",
      "forall {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y]\n  {f : X â†’ Y} {E : Set X},\n    Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ",
      "forall {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ IsClosed E â†’ Set.MapsTo f (âˆ‚E) (âˆ‚(Set.Image f E)) ",
      "forall {X Y : Type u} [inst : EmetricSpace X] [inst_1 : EmetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ",
      "forall {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X â†’ Y) (E : Set X),\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ",
      " âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) ",
      "forall {X Y : Type} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (Set.Image f E)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {E : Set X},\n  Continuous f â†’ Set.MapsTo f (closure E) (closure (f '' E)) "
    ]
  },
  {
    "docString": "Let `f` and `g` be continuous mappings of a metric space `X` into a metric space `Y`, and let `E` be a dense subset of `X`. Prove that `f(E)` is dense in `f(X)`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : FiniteDimensional â„ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace â„ F]\\n  [inst_5 : FiniteDimensional â„ F] {f : E â†’ F} {s t : Set E},\\n  ContDiffOn â„ 1 f s â†’ Convex â„ s â†’ t âŠ† s â†’ dimH t < â†‘(FiniteDimensional.finrank â„ F) â†’ Dense (f '' t)á¶œ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A particular case of Sard's Theorem. Let `f : E â†’ F` be a map between finite dimensional real\\nvector spaces. Suppose that `f` is `CÂ¹` smooth on a convex set `s` of Hausdorff dimension strictly\\nless than the dimension of `F`. Then the complement of the image `f '' s` is dense in `F`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : C(X, â„)) (e : X â†’ Y), ClosedEmbedding e â†’ âˆƒ g, â†‘g âˆ˜ e = â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed\\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\\ncontinuous real-valued function `g : C(Y, â„)` such that `g âˆ˜ e = f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  (f : PartitionOfUnity Î¹ X s) {g : X â†’ E} {i : Î¹},\\n  (âˆ€ (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt g x) â†’ Continuous fun x => â†‘(â†‘f i) x â€¢ g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity on `s : Set X` and `g : X â†’ E` is continuous at every point of\\nthe topological support of some `f i`, then `fun x â†¦ f i x â€¢ g x` is continuous on the whole space.\\n\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  (f : PartitionOfUnity Î¹ X s) [inst_5 : ContinuousAdd E] {g : Î¹ â†’ X â†’ E},\\n  (âˆ€ (i : Î¹) (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt (g i) x) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\\n`g âˆ˜ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]\\n  [inst_2 : MeasurableSpace Î³] {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³}\\n  [inst_3 : TopologicalSpace Î³] [inst_4 : TopologicalSpace.MetrizableSpace Î³] [inst_5 : BorelSpace Î³],\\n  ProbabilityTheory.IdentDistrib f g â†’ MeasureTheory.AEStronglyMeasurable f Î¼ â†’ MeasureTheory.AEStronglyMeasurable g Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are identically distributed and `f` is a.e. strongly measurable, so is `g`. \"},\n {\"theorem\":\n  \"âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\\non `s`. Then there exists a continuous real-valued function `g : C(Y, â„)` such that\\n`g.restrict s = f`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– = â€–fâ€– âˆ§ BoundedContinuousFunction.compContinuous g e = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\\ninto a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous function, then there exists\\na bounded continuous function `g : Y â†’áµ‡ â„` of the same norm such that `g âˆ˜ e = f`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  [inst_3 : Nonempty X] (f : BoundedContinuousFunction X â„) {e : X â†’ Y},\\n  ClosedEmbedding e â†’ âˆƒ g, (âˆ€ (y : Y), âˆƒ xâ‚ xâ‚‚, â†‘g y âˆˆ Set.Icc (â†‘f xâ‚) (â†‘f xâ‚‚)) âˆ§ â†‘g âˆ˜ e = â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Then there\\nexists a bounded continuous function `g : Y â†’áµ‡ â„` such that `g âˆ˜ e = f` and each value `g y` belongs\\nto a closed interval `[f xâ‚, f xâ‚‚]` for some `xâ‚` and `xâ‚‚`.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²] {f : X â†’ Y}\\n  [inst : TopologicalSpace.SecondCountableTopology â†‘(Set.range f)],\\n  Measurable f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable (Set.restrict (Set.range f) g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a Borel measurable map from a Polish space to a topological space with second\\ncountable topology, then for any measurable space `Î²` and `g : Y â†’ Î²`, the composition `g âˆ˜ f` is\\nmeasurable if and only if the restriction of `g` to the range of `f` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’\\n    ContinuousWithinAt f s x â†’ Filter.Tendsto g p (nhdsWithin x s) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` tends uniformly to `f` on a set `s`, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ gâ‚™`\\ntends to `f x` if `f` is continuous at `x` within `s`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : NormedSpace â„ E] [inst_4 : OpensMeasurableSpace X]\\n  [inst_5 : T2Space X],\\n  MeasureTheory.LocallyIntegrable f â†’\\n    âˆ€ {g : X â†’ â„}, Continuous g â†’ HasCompactSupport g â†’ MeasureTheory.Integrable fun x => g x â€¢ f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is locally integrable and `g` is continuous with compact support,\\nthen `g â€¢ f` is integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E},\\n  MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\\n    âˆƒ ns, StrictMono ns âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun i => f (ns i) x) Filter.atTop (nhds (g x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a sequence of functions which converges in measure to `g`, then there exists a\\nsubsequence of `f` which converges a.e. to `g`. \"}]\n",
    "prompt_cons": "/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- A particular case of Sard's Theorem. Let `f : E â†’ F` be a map between finite dimensional real\nvector spaces. Suppose that `f` is `CÂ¹` smooth on a convex set `s` of Hausdorff dimension strictly\nless than the dimension of `F`. Then the complement of the image `f '' s` is dense in `F`. -/\ntheorem âˆ€ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : FiniteDimensional â„ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace â„ F]\n  [inst_5 : FiniteDimensional â„ F] {f : E â†’ F} {s t : Set E},\n  ContDiffOn â„ 1 f s â†’ Convex â„ s â†’ t âŠ† s â†’ dimH t < â†‘(FiniteDimensional.finrank â„ F) â†’ Dense (f '' t)á¶œ :=\n\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y â†’áµ‡ â„` of the norm `â€–gâ€– â‰¤ â€–fâ€– / 3`\nsuch that the distance between `g âˆ˜ e` and `f` is at most `(2 / 3) * â€–fâ€–`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– â‰¤ â€–fâ€– / 3 âˆ§ dist (BoundedContinuousFunction.compContinuous g e) f â‰¤ 2 / 3 * â€–fâ€– :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\ncontinuous real-valued function `g : C(Y, â„)` such that `g âˆ˜ e = f`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : C(X, â„)) (e : X â†’ Y), ClosedEmbedding e â†’ âˆƒ g, â†‘g âˆ˜ e = â†‘f :=\n\n/-- If `f` is a partition of unity on `s : Set X` and `g : X â†’ E` is continuous at every point of\nthe topological support of some `f i`, then `fun x â†¦ f i x â€¢ g x` is continuous on the whole space. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  (f : PartitionOfUnity Î¹ X s) {g : X â†’ E} {i : Î¹},\n  (âˆ€ (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt g x) â†’ Continuous fun x => â†‘(â†‘f i) x â€¢ g x :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  (f : PartitionOfUnity Î¹ X s) [inst_5 : ContinuousAdd E] {g : Î¹ â†’ X â†’ E},\n  (âˆ€ (i : Î¹) (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt (g i) x) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\n`g âˆ˜ f` is measurable if and only if `g` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g :=\n\n/-- If `f` and `g` are identically distributed and `f` is a.e. strongly measurable, so is `g`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]\n  [inst_2 : MeasurableSpace Î³] {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³}\n  [inst_3 : TopologicalSpace Î³] [inst_4 : TopologicalSpace.MetrizableSpace Î³] [inst_5 : BorelSpace Î³],\n  ProbabilityTheory.IdentDistrib f g â†’ MeasureTheory.AEStronglyMeasurable f Î¼ â†’ MeasureTheory.AEStronglyMeasurable g Î½ :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\non `s`. Then there exists a continuous real-valued function `g : C(Y, â„)` such that\n`g.restrict s = f`. -/\ntheorem âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f :=\n\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X â†’áµ‡ â„` is a bounded continuous function, then there exists\na bounded continuous function `g : Y â†’áµ‡ â„` of the same norm such that `g âˆ˜ e = f`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X â„) (e : C(X, Y)),\n  ClosedEmbedding â†‘e â†’ âˆƒ g, â€–gâ€– = â€–fâ€– âˆ§ BoundedContinuousFunction.compContinuous g e = f :=\n\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Then there\nexists a bounded continuous function `g : Y â†’áµ‡ â„` such that `g âˆ˜ e = f` and each value `g y` belongs\nto a closed interval `[f xâ‚, f xâ‚‚]` for some `xâ‚` and `xâ‚‚`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  [inst_3 : Nonempty X] (f : BoundedContinuousFunction X â„) {e : X â†’ Y},\n  ClosedEmbedding e â†’ âˆƒ g, (âˆ€ (y : Y), âˆƒ xâ‚ xâ‚‚, â†‘g y âˆˆ Set.Icc (â†‘f xâ‚) (â†‘f xâ‚‚)) âˆ§ â†‘g âˆ˜ e = â†‘f :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- If `f : X â†’ Y` is a Borel measurable map from a Polish space to a topological space with second\ncountable topology, then for any measurable space `Î²` and `g : Y â†’ Î²`, the composition `g âˆ˜ f` is\nmeasurable if and only if the restriction of `g` to the range of `f` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²] {f : X â†’ Y}\n  [inst : TopologicalSpace.SecondCountableTopology â†‘(Set.range f)],\n  Measurable f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable (Set.restrict (Set.range f) g) :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- If `Fâ‚™` tends uniformly to `f` on a set `s`, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ gâ‚™`\ntends to `f x` if `f` is continuous at `x` within `s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’\n    ContinuousWithinAt f s x â†’ Filter.Tendsto g p (nhdsWithin x s) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If `f` is locally integrable and `g` is continuous with compact support,\nthen `g â€¢ f` is integrable. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : NormedSpace â„ E] [inst_4 : OpensMeasurableSpace X]\n  [inst_5 : T2Space X],\n  MeasureTheory.LocallyIntegrable f â†’\n    âˆ€ {g : X â†’ â„}, Continuous g â†’ HasCompactSupport g â†’ MeasureTheory.Integrable fun x => g x â€¢ f x :=\n\n/-- If `f` is a sequence of functions which converges in measure to `g`, then there exists a\nsubsequence of `f` which converges a.e. to `g`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E},\n  MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\n    âˆƒ ns, StrictMono ns âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun i => f (ns i) x) Filter.atTop (nhds (g x)) :=\n\n/-- Let `f` and `g` be continuous mappings of a metric space `X` into a metric space `Y`, and let `E` be a dense subset of `X`. Prove that `f(E)` is dense in `f(X)`. -/\ntheorem",
    "choices": [
      "forall {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y] {f : X â†’ Y} {g : X â†’ Y} {E : Set X},\n  Continuous f â†’\n    Continuous g â†’\n      Dense E â†’\n        âˆ€ {U : Set Y}, IsOpen U â†’ Set.Nonempty (U âˆ© f '' E) â†’ Set.Nonempty (U âˆ© f '' Set.Univ) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ Dense E â†’ Dense (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  {f g : X â†’ Y} {E : Set X},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y]\n  [inst_3 : MetricSpace Y] {f : C(X, Y)} {E : Set X}, Dense E â†’ Dense (Set.Image (Î» x, â†‘f x) E) ",
      "forall {X Y : Type*} [EmetricSpace X] [EmetricSpace Y] [TopologicalSpace.SecondCountableTopology Y]\n  {f g : X â†’ Y} {E : Set X},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ Dense (f '' E) ",
      "forall {X Y : Type*} [topological_space X] [topological_space Y] [metric_space X] [metric_space Y] {f g : X â†’ Y} (E : set X),\n  dense E â†’ continuous f â†’ continuous g â†’ dense (f '' E) ",
      "âˆ€ {X : Type u_3} {Y : Type u_2} [inst : EmetricSpace X] [inst_1 : EmetricSpace Y] [inst_2 : TopologicalSpace X]\n  [inst_3 : TopologicalSpace Y] {f g : X â†’ Y} {e : Set X},\n  Dense e â†’ Continuous f â†’ Dense (Set.Image f e) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y] [inst_3 : MetricSpace Y]\n  {f : X â†’ Y} {E : Set X} {g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Dense E â†’ Dense (f '' E) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : MetricSpace Y] {f g : X â†’ Y} {s : Set X} {E : Set X},\n  Dense E â†’ Continuous f â†’ Continuous g â†’ f '' E âŠ† Closure (f '' s) ",
      "forall {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X]\n  [inst_2 : TopologicalSpace Y] [inst_3 : MetricSpace Y] {f g : X -> Y} {E : Set X},\n  Dense E ->\n  Continuous f ->\n  Continuous g ->\n  Dense (f '' E) "
    ]
  },
  {
    "docString": "If `f` is a real continuous function defined on a closed set `E âŠ† â„`, prove that there exist continuous real functions `g` on `â„` such that `g(x)=f(x)` for all `x âˆˆ E`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’\\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] [inst_4 : Nontrivial E] {f g : E â†’ F} {U : Set E},\\n  Metric.Bounded U â†’ DiffContOnCl â„‚ f U â†’ DiffContOnCl â„‚ g U â†’ Set.EqOn f g (frontier U) â†’ Set.EqOn f g (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two complex differentiable functions `f g : E â†’ F` are equal on the boundary of a bounded set\\n`U`, then they are equal on `closure U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’ Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ Set.EqOn f g S âˆ¨ Set.EqOn f (-g) S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then either `f = g` or `f = -g` on\\n`S`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ â„),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {Îµ : â„},\\n      0 < Îµ â†’\\n        âˆƒ g,\\n          (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§\\n            LowerSemicontinuous g âˆ§\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\\nto that of `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] [inst_4 : Nontrivial E] {f g : E â†’ F} {U : Set E},\\n  Metric.Bounded U â†’ DiffContOnCl â„‚ f U â†’ DiffContOnCl â„‚ g U â†’ Set.EqOn f g (frontier U) â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two complex differentiable functions `f g : E â†’ F` are equal on the boundary of a bounded set\\n`U`, then they are equal on `U`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ âˆ€ (y : â„), HasDerivAt f (g y) y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is the derivative of `f` everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ â„),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {Îµ : â„},\\n      0 < Îµ â†’\\n        âˆƒ g,\\n          (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§\\n            UpperSemicontinuous g âˆ§\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\\nof `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\\non `s`. Then there exists a continuous real-valued function `g : C(Y, â„)` such that\\n`g.restrict s = f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E},\\n  MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\\n    âˆƒ ns, StrictMono ns âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun i => f (ns i) x) Filter.atTop (nhds (g x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a sequence of functions which converges in measure to `g`, then there exists a\\nsubsequence of `f` which converges a.e. to `g`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  {f : PartitionOfUnity Î¹ X s} [inst_5 : ContinuousAdd E] {U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n    PartitionOfUnity.IsSubordinate f U â†’\\n      âˆ€ {g : Î¹ â†’ X â†’ E}, (âˆ€ (i : Î¹), ContinuousOn (g i) (U i)) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\\n`g : Î¹ â†’ X â†’ E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is a continuous function. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  (f : PartitionOfUnity Î¹ X s) [inst_5 : ContinuousAdd E] {g : Î¹ â†’ X â†’ E},\\n  (âˆ€ (i : Î¹) (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt (g i) x) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  (Î¼ : MeasureTheory.Measure Î±) [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] (f : MeasureTheory.SimpleFunc Î± NNReal)\\n  {Îµ : ENNReal},\\n  Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), â†‘f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a simple function `f` with values in `â„â‰¥0`, there exists a lower semicontinuous\\nfunction `g â‰¥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\\n`lintegral`.\\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E} {s : Set â„‚},\\n  Set.Countable s â†’\\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼]\\n  (f : MeasureTheory.SimpleFunc Î± NNReal),\\n  âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ â‰  âŠ¤ â†’\\n    âˆ€ {Îµ : ENNReal},\\n      Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), g x â‰¤ â†‘f x) âˆ§ UpperSemicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a simple function `f` with values in `â„â‰¥0`, there exists an upper semicontinuous\\nfunction `g â‰¤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\\n`lintegral`.\\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"}]\n",
    "prompt_cons": "/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S :=\n\n/-- For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\nintegral. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼ :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- If two complex differentiable functions `f g : E â†’ F` are equal on the boundary of a bounded set\n`U`, then they are equal on `closure U`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] [inst_4 : Nontrivial E] {f g : E â†’ F} {U : Set E},\n  Metric.Bounded U â†’ DiffContOnCl â„‚ f U â†’ DiffContOnCl â„‚ g U â†’ Set.EqOn f g (frontier U) â†’ Set.EqOn f g (closure U) :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’ Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ Set.EqOn f g S âˆ¨ Set.EqOn f (-g) S :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x :=\n\n/-- **Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\nto that of `f`. This function has to be `EReal`-valued in general. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ â„),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {Îµ : â„},\n      0 < Îµ â†’\n        âˆƒ g,\n          (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§\n            LowerSemicontinuous g âˆ§\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ :=\n\n/-- If two complex differentiable functions `f g : E â†’ F` are equal on the boundary of a bounded set\n`U`, then they are equal on `U`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] [inst_4 : Nontrivial E] {f g : E â†’ F} {U : Set E},\n  Metric.Bounded U â†’ DiffContOnCl â„‚ f U â†’ DiffContOnCl â„‚ g U â†’ Set.EqOn f g (frontier U) â†’ Set.EqOn f g U :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is the derivative of `f` everywhere. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ âˆ€ (y : â„), HasDerivAt f (g y) y :=\n\n/-- **Vitali-CarathÃ©odory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\nof `f`. This function has to be `EReal`-valued in general. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ â„),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {Îµ : â„},\n      0 < Îµ â†’\n        âˆƒ g,\n          (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§\n            UpperSemicontinuous g âˆ§\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) âˆ§\n                (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), EReal.toReal (g x) âˆ‚Î¼ + Îµ :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\non `s`. Then there exists a continuous real-valued function `g : C(Y, â„)` such that\n`g.restrict s = f`. -/\ntheorem âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f :=\n\n/-- If `f` is a sequence of functions which converges in measure to `g`, then there exists a\nsubsequence of `f` which converges a.e. to `g`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E},\n  MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\n    âˆƒ ns, StrictMono ns âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun i => f (ns i) x) Filter.atTop (nhds (g x)) :=\n\n/-- If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\n`g : Î¹ â†’ X â†’ E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is a continuous function. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  {f : PartitionOfUnity Î¹ X s} [inst_5 : ContinuousAdd E] {U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n    PartitionOfUnity.IsSubordinate f U â†’\n      âˆ€ {g : Î¹ â†’ X â†’ E}, (âˆ€ (i : Î¹), ContinuousOn (g i) (U i)) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x :=\n\n/-- If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  (f : PartitionOfUnity Î¹ X s) [inst_5 : ContinuousAdd E] {g : Î¹ â†’ X â†’ E},\n  (âˆ€ (i : Î¹) (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt (g i) x) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x :=\n\n/-- Given a simple function `f` with values in `â„â‰¥0`, there exists a lower semicontinuous\nfunction `g â‰¥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] (f : MeasureTheory.SimpleFunc Î± NNReal)\n  {Îµ : ENNReal},\n  Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), â†‘f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ + Îµ :=\n\n/-- If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E} {s : Set â„‚},\n  Set.Countable s â†’\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\ s â†’ DifferentiableAt â„‚ f z) â†’\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- Given a simple function `f` with values in `â„â‰¥0`, there exists an upper semicontinuous\nfunction `g â‰¤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼]\n  (f : MeasureTheory.SimpleFunc Î± NNReal),\n  âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ â‰  âŠ¤ â†’\n    âˆ€ {Îµ : ENNReal},\n      Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), g x â‰¤ â†‘f x) âˆ§ UpperSemicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ :=\n\n/-- If `f` is a real continuous function defined on a closed set `E âŠ† â„`, prove that there exist continuous real functions `g` on `â„` such that `g(x)=f(x)` for all `x âˆˆ E`. -/\ntheorem",
    "choices": [
      "forall {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {E : Set Y} (f : C(â†‘E, â„)),\n  IsClosed E â†’ âˆƒ g, ContinuousMap.restrict E g = f ",
      "âˆ€ {E : Set â„} {f : C(â†‘E, â„)},\n  IsClosed E â†’ âˆƒ g, Continuous g âˆ§ âˆ€ (x : â„), x âˆˆ E â†’ g x = f âŸ¨x, _âŸ© ",
      "âˆ€ {E : Type u_1} [inst : TopologicalSpace E] {E : Set â„} {f : E â†’ â„},\n  IsClosed E â†’ ContinuousOn f E â†’ âˆƒ g : â„ â†’ â„, Continuous g âˆ§ Set.EqOn g f E ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] {f : C(â†‘E, â„)}, IsClosed E â†’ âˆƒ g, Set.EqOn g (fun x => f x) E âˆ§ Continuous g ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : T2Space â„] {s : Set â„} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f ",
      "âˆ€ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : NormalSpace E] {s : Set E} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f ",
      "âˆ€ {E : Set â„} (f : C(â†‘E, â„)), IsClosed E â†’ âˆƒ g : C(â„, â„), âˆ€ (x : â„), x âˆˆ E â†’ g x = f x ",
      "âˆ€ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : NormalSpace E] {s : Set E} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f ",
      "âˆ€ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : NormalSpace E] {s : Set â„} (f : C(â†‘s, â„)),\n  IsClosed s â†’ âˆƒ g, ContinuousMap.restrict s g = f ",
      "âˆ€ {E : Set â„} [inst : TopologicalSpace â„] [inst_1 : T2Space â„] {f : C(â†‘E, â„)}, IsClosed E â†’ âˆƒ g, âˆ€ (x : â„), x âˆˆ E â†’ g x = f x "
    ]
  },
  {
    "docString": "If `f` is defined on `E`, the graph of `f` is the set of points `(x, f(x))`, for `x âˆˆ E`. In particular, if `E` is a set of real numbers, and `f` is real-valued, the graph of `f` is a subset of the plane. Suppose `E` is compact, and prove that `f` is continuous on `E` if and only if its graph is compact.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E} {s : Set â„‚},\\n  Set.Countable s â†’\\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ (z : â„‚), AnalyticAt â„‚ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is analytic at every point. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E}, DiffContOnCl â„‚ f (Metric.ball c â†‘R) â†’ 0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on an open disc of positive radius and is continuous\\non its closure, then it is analytic on the open disc with coefficients of the power series given by\\nCauchy integral formulas. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  (f : PartitionOfUnity Î¹ X s) [inst_5 : ContinuousAdd E] {g : Î¹ â†’ X â†’ E},\\n  (âˆ€ (i : Î¹) (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt (g i) x) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  {f : PartitionOfUnity Î¹ X s} [inst_5 : ContinuousAdd E] {U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n    PartitionOfUnity.IsSubordinate f U â†’\\n      âˆ€ {g : Î¹ â†’ X â†’ E}, (âˆ€ (i : Î¹), ContinuousOn (g i) (U i)) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\\n`g : Î¹ â†’ X â†’ E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is a continuous function. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, Continuous â†‘f.linear â†” Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is continuous iff `f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] {K : Set X} [inst_5 : TopologicalSpace.MetrizableSpace X],\\n  IsCompact K â†’ ContinuousOn f K â†’ MeasureTheory.IntegrableOn f K\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f` continuous on a compact set `K` is integrable on this set with respect to any\\nlocally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  (f : PartitionOfUnity Î¹ X s) {g : X â†’ E} {i : Î¹},\\n  (âˆ€ (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt g x) â†’ Continuous fun x => â†‘(â†‘f i) x â€¢ g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity on `s : Set X` and `g : X â†’ E` is continuous at every point of\\nthe topological support of some `f i`, then `fun x â†¦ f i x â€¢ g x` is continuous on the whole space.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]\\n  {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} [inst_2 : NormedAddCommGroup E]\\n  [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : NormedSpace â„ E] [inst_5 : CompleteSpace E]\\n  [inst_6 : MeasureTheory.SigmaFinite Î¼], Continuous fun f => âˆ« (x : Î±), âˆ« (y : Î²), â†‘â†‘f (x, y) âˆ‚Î½ âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map that sends an LÂ¹-function `f : Î± Ã— Î² â†’ E` to `âˆ«âˆ«f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²},\\n  s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : FiniteDimensional â„ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace â„ F]\\n  [inst_5 : FiniteDimensional â„ F] {f : E â†’ F} {s t : Set E},\\n  ContDiffOn â„ 1 f s â†’ Convex â„ s â†’ t âŠ† s â†’ dimH t < â†‘(FiniteDimensional.finrank â„ F) â†’ Dense (f '' t)á¶œ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A particular case of Sard's Theorem. Let `f : E â†’ F` be a map between finite dimensional real\\nvector spaces. Suppose that `f` is `CÂ¹` smooth on a convex set `s` of Hausdorff dimension strictly\\nless than the dimension of `F`. Then the complement of the image `f '' s` is dense in `F`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’ ContinuousAt f c â†’ AnalyticAt â„‚ f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Removable singularity** theorem, weak version. If `f : â„‚ â†’ E` is differentiable in a punctured\\nneighborhood of a point and is continuous at this point, then it is analytic at this point. \"}]\n",
    "prompt_cons": "/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E} {s : Set â„‚},\n  Set.Countable s â†’\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\ s â†’ DifferentiableAt â„‚ f z) â†’\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is analytic at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ (z : â„‚), AnalyticAt â„‚ f z :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on an open disc of positive radius and is continuous\non its closure, then it is analytic on the open disc with coefficients of the power series given by\nCauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E}, DiffContOnCl â„‚ f (Metric.ball c â†‘R) â†’ 0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  (f : PartitionOfUnity Î¹ X s) [inst_5 : ContinuousAdd E] {g : Î¹ â†’ X â†’ E},\n  (âˆ€ (i : Î¹) (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt (g i) x) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x :=\n\n/-- If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f) :=\n\n/-- If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\n`g : Î¹ â†’ X â†’ E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is a continuous function. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  {f : PartitionOfUnity Î¹ X s} [inst_5 : ContinuousAdd E] {U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n    PartitionOfUnity.IsSubordinate f U â†’\n      âˆ€ {g : Î¹ â†’ X â†’ E}, (âˆ€ (i : Î¹), ContinuousOn (g i) (U i)) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x :=\n\n/-- If `f` is an affine map, then its linear part is continuous iff `f` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, Continuous â†‘f.linear â†” Continuous â†‘f :=\n\n/-- A function `f` continuous on a compact set `K` is integrable on this set with respect to any\nlocally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] {K : Set X} [inst_5 : TopologicalSpace.MetrizableSpace X],\n  IsCompact K â†’ ContinuousOn f K â†’ MeasureTheory.IntegrableOn f K :=\n\n/-- If `f` is a partition of unity on `s : Set X` and `g : X â†’ E` is continuous at every point of\nthe topological support of some `f i`, then `fun x â†¦ f i x â€¢ g x` is continuous on the whole space. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  (f : PartitionOfUnity Î¹ X s) {g : X â†’ E} {i : Î¹},\n  (âˆ€ (x : X), x âˆˆ tsupport â†‘(â†‘f i) â†’ ContinuousAt g x) â†’ Continuous fun x => â†‘(â†‘f i) x â€¢ g x :=\n\n/-- The map that sends an LÂ¹-function `f : Î± Ã— Î² â†’ E` to `âˆ«âˆ«f` is continuous. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]\n  {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} [inst_2 : NormedAddCommGroup E]\n  [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : NormedSpace â„ E] [inst_5 : CompleteSpace E]\n  [inst_6 : MeasureTheory.SigmaFinite Î¼], Continuous fun f => âˆ« (x : Î±), âˆ« (y : Î²), â†‘â†‘f (x, y) âˆ‚Î½ âˆ‚Î¼ :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²},\n  s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s)) :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- A particular case of Sard's Theorem. Let `f : E â†’ F` be a map between finite dimensional real\nvector spaces. Suppose that `f` is `CÂ¹` smooth on a convex set `s` of Hausdorff dimension strictly\nless than the dimension of `F`. Then the complement of the image `f '' s` is dense in `F`. -/\ntheorem âˆ€ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : FiniteDimensional â„ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace â„ F]\n  [inst_5 : FiniteDimensional â„ F] {f : E â†’ F} {s t : Set E},\n  ContDiffOn â„ 1 f s â†’ Convex â„ s â†’ t âŠ† s â†’ dimH t < â†‘(FiniteDimensional.finrank â„ F) â†’ Dense (f '' t)á¶œ :=\n\n/-- **Removable singularity** theorem, weak version. If `f : â„‚ â†’ E` is differentiable in a punctured\nneighborhood of a point and is continuous at this point, then it is analytic at this point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’ ContinuousAt f c â†’ AnalyticAt â„‚ f c :=\n\n/-- If `f` is defined on `E`, the graph of `f` is the set of points `(x, f(x))`, for `x âˆˆ E`. In particular, if `E` is a set of real numbers, and `f` is real-valued, the graph of `f` is a subset of the plane. Suppose `E` is compact, and prove that `f` is continuous on `E` if and only if its graph is compact. -/\ntheorem",
    "choices": [
      "forall {X : Type u} {Y : Type v} [instX : TopologicalSpace X] [instY : TopologicalSpace Y] [inst : CompactSpace X]\n  {f : X â†’ Y}, Compact (SetOf fun p : X Ã— Y => p.2 = f p.1) â†” Continuous f ",
      "forall {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] [inst_3 : CompactSpace X] {E : Set X} {f : X â†’ Y},\n  IsCompact (SetOf (fun x => (x, f x)) for x in E) â†” ContinuousOn f E ",
      "forall {E : Type u} [inst : TopologicalSpace E] {Î± : Type v} [inst_1 : TopologicalSpace Î±] [inst_2 : T2Space Î±] {f : E â†’ Î±},\n  IsCompact (Function.Graph f) â†” IsCompact (Set.Range f) ",
      "forall {E : Type u_1} {F : Type u_2} [inst : TopologicalSpace E] [inst_1 : TopologicalSpace F]\n  [inst_2 : CompactSpace E] [inst_3 : T2Space E] [inst_4 : T2Space F] {f : E â†’ F},\n  Continuous f â†” IsCompact (Set.Graph f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {E : Set Î±} {f : Î± â†’ Î²},\n  IsCompact E â†’ (ContinuousOn f E â†” IsCompact (SetOf (Î» x, (x, f x)))) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {E : Set Î±} {f : Î± â†’ Î²},\n  IsCompact E â†’ (ContinuousOn f E â†” IsCompact (graph f E)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±},\n  IsCompact s â†’ (IsCompact (SetOf fun p => âˆƒ (x : Î±) (H : x âˆˆ s), p = (x, f x)) â†” ContinuousOn f s) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\n  {E : Set X} {f : X â†’ Y},\n  E âŠ† fgraph f â†” Compact (fgraph f) ",
      "forall {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²} {E : Set Î±},\n  IsCompact E â†’ (IsCompact (Set.Graph f E) â†” ContinuousOn f E) ",
      "forall {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {f : Î± â†’ Î²},\n  IsCompact s â†’ (IsCompact (SetOf fun p => p.1 âˆˆ s âˆ§ p.2 = f p.1) â†” ContinuousOn f s) "
    ]
  },
  {
    "docString": "Let `E` be a bounded set in `â„^1`. Prove that there exists a real function `f` such that `f` is uniformly continuous and is not bounded on `E`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ (ğ•œ : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst : NormedSpace ğ•œ E] [inst : Nontrivial E] (c : â„), âˆƒ x, c < â€–xâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is a nontrivial normed space over a nontrivially normed field `ğ•œ`, then `E` is unbounded:\\nfor any `c : â„`, there exists a vector `x : E` with norm strictly greater than `c`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f â‰¥ 1` on K. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\\n  {f : â„‚ â†’ E} {s : Set â„‚},\\n  Set.Countable s â†’\\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Î±} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : CompleteSpace E] {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ E} [inst_3 : MeasureTheory.IsFiniteMeasure Î¼],\\n  MeasureTheory.Integrable f â†’\\n    f =á¶ [MeasureTheory.Measure.ae Î¼] Function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨\\n      âˆƒ t, MeasurableSet t âˆ§ â†‘â†‘Î¼ t â‰  0 âˆ§ â†‘â†‘Î¼ tá¶œ â‰  0 âˆ§ â¨ (x : Î±) in t, f x âˆ‚Î¼ â‰  â¨ (x : Î±) in tá¶œ, f x âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : Î± â†’ E` is an integrable function, then either it is a.e. equal to the constant\\n`â¨ x, f x âˆ‚Î¼` or there exists a measurable set such that `Î¼ t â‰  0`, `Î¼ tá¶œ â‰  0`, and the average\\nvalues of `f` over `t` and `tá¶œ` are different. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {E : Type u_1} {m0 : MeasurableSpace Î±} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : CompleteSpace E] {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ E} {C : â„} [inst_3 : StrictConvexSpace â„ E]\\n  [inst_4 : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€áµ (x : Î±) âˆ‚Î¼, â€–f xâ€– â‰¤ C) â†’\\n    f =á¶ [MeasureTheory.Measure.ae Î¼] Function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨\\n      â€–âˆ« (x : Î±), f x âˆ‚Î¼â€– < ENNReal.toReal (â†‘â†‘Î¼ Set.univ) * C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is a strictly convex normed space and `f : Î± â†’ E` is a function such that `â€–f xâ€– â‰¤ C`\\na.e., then either this function is a.e. equal to its average value, or the norm of its integral is\\nstrictly less than `(Î¼ univ).toReal * C`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ 0 â‰¤ z.re â†’ 0 â‰¤ z.im â†’ â€–f zâ€– â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `c < 2`;\\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the first quadrant.\\n\\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed first quadrant. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Preorder Î±] [inst_1 : Nonempty Î±] [inst_2 : NoMinOrder Î±] [inst_3 : NoMaxOrder Î±],\\n  âˆƒ f, StrictMono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\\nmonotone function `f : â„¤ â†’ Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]\\n  {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} [inst_2 : NormedAddCommGroup E]\\n  [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : NormedSpace â„ E] [inst_5 : CompleteSpace E]\\n  [inst_6 : MeasureTheory.SigmaFinite Î¼], Continuous fun f => âˆ« (x : Î±), âˆ« (y : Î²), â†‘â†‘f (x, y) âˆ‚Î½ âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map that sends an LÂ¹-function `f : Î± Ã— Î² â†’ E` to `âˆ«âˆ«f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the first quadrant.\\n\\nThen `f` is equal to zero on the closed first quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds b) â†’\\n      Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n        HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) c b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\\nfinite limit `c` almost surely at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `c` at `b`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {Î¹ : Type u_3}\\n  {l : Filter Î¹} [inst_1 : Filter.NeBot l] [_i : Fact (1 â‰¤ p)] {F : Î¹ â†’ { x // x âˆˆ lp E p }},\\n  Metric.Bounded (Set.range F) â†’ âˆ€ {f : (a : Î±) â†’ E a}, Filter.Tendsto (id fun i => â†‘(F i)) l (nhds f) â†’ Memâ„“p f p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ (z : â„‚), AnalyticAt â„‚ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is analytic at every point. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds b) â†’ ContinuousAt f b â†’ HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) (f b) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f` is\\ncontinuous at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `f b` at `b`. \"}]\n",
    "prompt_cons": "/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- If `E` is a nontrivial normed space over a nontrivially normed field `ğ•œ`, then `E` is unbounded:\nfor any `c : â„`, there exists a vector `x : E` with norm strictly greater than `c`. -/\ntheorem âˆ€ (ğ•œ : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst : NormedSpace ğ•œ E] [inst : Nontrivial E] (c : â„), âˆƒ x, c < â€–xâ€– :=\n\n/-- For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f â‰¥ 1` on K. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x}) :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If `f : â„‚ â†’ E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : â„‚}\n  {f : â„‚ â†’ E} {s : Set â„‚},\n  Set.Countable s â†’\n    ContinuousOn f (Metric.closedBall c â†‘R) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.ball c â†‘R \\ s â†’ DifferentiableAt â„‚ f z) â†’\n        0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œ' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC ğ•œ] [inst_7 : Module ğ•œ E]\n  [inst_8 : ContinuousSMul ğ•œ E] [inst_9 : IsROrC ğ•œ'] [inst_10 : Module ğ•œ' F] [inst_11 : ContinuousSMul ğ•œ' F]\n  {Ïƒ : ğ•œ â†’+* ğ•œ'} [inst_12 : UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F),\n  (âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (â†‘f '' s)) â†’ Continuous â†‘f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f :=\n\n/-- If `f : Î± â†’ E` is an integrable function, then either it is a.e. equal to the constant\n`â¨ x, f x âˆ‚Î¼` or there exists a measurable set such that `Î¼ t â‰  0`, `Î¼ tá¶œ â‰  0`, and the average\nvalues of `f` over `t` and `tá¶œ` are different. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Î±} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : CompleteSpace E] {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ E} [inst_3 : MeasureTheory.IsFiniteMeasure Î¼],\n  MeasureTheory.Integrable f â†’\n    f =á¶ [MeasureTheory.Measure.ae Î¼] Function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨\n      âˆƒ t, MeasurableSet t âˆ§ â†‘â†‘Î¼ t â‰  0 âˆ§ â†‘â†‘Î¼ tá¶œ â‰  0 âˆ§ â¨ (x : Î±) in t, f x âˆ‚Î¼ â‰  â¨ (x : Î±) in tá¶œ, f x âˆ‚Î¼ :=\n\n/-- If `E` is a strictly convex normed space and `f : Î± â†’ E` is a function such that `â€–f xâ€– â‰¤ C`\na.e., then either this function is a.e. equal to its average value, or the norm of its integral is\nstrictly less than `(Î¼ univ).toReal * C`. -/\ntheorem âˆ€ {Î± : Type u_2} {E : Type u_1} {m0 : MeasurableSpace Î±} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : CompleteSpace E] {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ E} {C : â„} [inst_3 : StrictConvexSpace â„ E]\n  [inst_4 : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€áµ (x : Î±) âˆ‚Î¼, â€–f xâ€– â‰¤ C) â†’\n    f =á¶ [MeasureTheory.Measure.ae Î¼] Function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨\n      â€–âˆ« (x : Î±), f x âˆ‚Î¼â€– < ENNReal.toReal (â†‘â†‘Î¼ Set.univ) * C :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `c < 2`;\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the first quadrant.\n\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed first quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ 0 â‰¤ z.re â†’ 0 â‰¤ z.im â†’ â€–f zâ€– â‰¤ C :=\n\n/-- If `Î±` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\nmonotone function `f : â„¤ â†’ Î±`. -/\ntheorem âˆ€ (Î± : Type u) [inst : Preorder Î±] [inst_1 : Nonempty Î±] [inst_2 : NoMinOrder Î±] [inst_3 : NoMaxOrder Î±],\n  âˆƒ f, StrictMono f :=\n\n/-- The map that sends an LÂ¹-function `f : Î± Ã— Î² â†’ E` to `âˆ«âˆ«f` is continuous. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]\n  {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} [inst_2 : NormedAddCommGroup E]\n  [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : NormedSpace â„ E] [inst_5 : CompleteSpace E]\n  [inst_6 : MeasureTheory.SigmaFinite Î¼], Continuous fun f => âˆ« (x : Î±), âˆ« (y : Î²), â†‘â†‘f (x, y) âˆ‚Î½ âˆ‚Î¼ :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the first quadrant.\n\nThen `f` is equal to zero on the closed first quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im} :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\nfinite limit `c` almost surely at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `c` at `b`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds b) â†’\n      Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n        HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) c b :=\n\n/-- If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {Î¹ : Type u_3}\n  {l : Filter Î¹} [inst_1 : Filter.NeBot l] [_i : Fact (1 â‰¤ p)] {F : Î¹ â†’ { x // x âˆˆ lp E p }},\n  Metric.Bounded (Set.range F) â†’ âˆ€ {f : (a : Î±) â†’ E a}, Filter.Tendsto (id fun i => â†‘(F i)) l (nhds f) â†’ Memâ„“p f p :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is analytic at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ (z : â„‚), AnalyticAt â„‚ f z :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f` is\ncontinuous at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `f b` at `b`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds b) â†’ ContinuousAt f b â†’ HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) (f b) b :=\n\n/-- Let `E` be a bounded set in `â„^1`. Prove that there exists a real function `f` such that `f` is uniformly continuous and is not bounded on `E`. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Set â„} (hE : Metric.Bounded E),\n  âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ âˆ€ (M : â„), âˆƒ (x : â„) (H : x âˆˆ E), M < f x ",
      "âˆ€ (E : Set â„), Bounded E â†’ âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ âˆ€ K, Bounded (f '' E) â†’ Ennreal.ofReal K < Sup (f '' E) ",
      "âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ âˆ€ (M : â„), âˆƒ (x : â„), x âˆˆ E âˆ§ M < |f x| ",
      "âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ Â¬ BddAbove (f '' E) ",
      "âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ (âˆ€ (x : â„), x âˆˆ E â†’ Â¬Metric.Bounded (Set.Range f)) ",
      "âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ âˆ€ (M : â„), âˆƒ (x : â„), x âˆˆ E âˆ§ M < abs (f x) ",
      "âˆ€ (E : Set â„), Bounded E â†’ âˆƒ (f : â„ â†’ â„), âˆ€ (Îµ : â„), Îµ > 0 â†’ UniformContinuousOn f E âˆ§ Â¬Bounded (f '' E) ",
      "âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ (âˆ€ (x : â„), x âˆˆ E â†’ NotBounded f x) ",
      "âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ Â¬BoundedOn E f ",
      "âˆ€ {E : Set â„}, Metric.Bounded E â†’ âˆƒ (f : â„ â†’ â„), UniformContinuous f âˆ§ âˆ€ (C : â„), âˆƒ x âˆˆ E, C < |f x| "
    ]
  },
  {
    "docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformlyOn F f p s â†’\\n    (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} [inst_1 : TopologicalSpace Î±],\\n  x âˆˆ s â†’\\n    (âˆ€ (u : Set (Î² Ã— Î²)),\\n        u âˆˆ uniformity Î² â†’\\n          âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n      ContinuousWithinAt f s x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\nwithin a set at a point is continuous within this set at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {A : Set (Î² â†’ Î±)},\\n  Set.UniformEquicontinuous A â†’ Set.UniformEquicontinuous (closure A)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of functions is uniformly equicontinuous, its closure for the product topology is also\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ Equicontinuous F\",\n  \"isProp\": true,\n  \"docString\": \"Uniform equicontinuity implies equicontinuity. \"}]\n",
    "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousAt f x :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’ (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i) :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformlyOn F f p s â†’\n    (âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) â†’ âˆ€ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} [inst_1 : TopologicalSpace Î±],\n  x âˆˆ s â†’\n    (âˆ€ (u : Set (Î² Ã— Î²)),\n        u âˆˆ uniformity Î² â†’\n          âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n      ContinuousWithinAt f s x :=\n\n/-- If a set of functions is uniformly equicontinuous, its closure for the product topology is also\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {A : Set (Î² â†’ Î±)},\n  Set.UniformEquicontinuous A â†’ Set.UniformEquicontinuous (closure A) :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼ :=\n\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ Equicontinuous F :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {g : Î± â†’ Î²} {f : Î² â†’ Î³},\n  UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (f âˆ˜ g) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (g : Î² â†’ Î³) (f : Î± â†’ Î²),\n  UniformContinuous g â†’ UniformContinuous f â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "forall {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) "
    ]
  },
  {
    "docString": "Suppose `f` is a real function with domain `â„^1` which has the intermediate value property: if `f(a) < c < f(b)`, then `f(x) = c` for some `x` between `a` and `b`. Suppose also, for every rational `r`, that the set of all `x` with `f(x) = r` is closed. Prove that `f` is continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\\n  0 < r â†’\\n    r â‰¤ R â†’\\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\\n        Set.Countable s â†’\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) â†’\\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„},\\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsExtrOn f (Set.Icc a b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` takes either its maximum\\nor its minimum value at a point in the interior of the interval. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f x) â†’ a < b â†’ 0 < âˆ« (x : â„) in a..b, f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„ â†’ â„` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\\nof the interval, then its integral over `a..b` is strictly positive. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` has a local extremum at some\\npoint of the corresponding open interval. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  MonotoneOn f s â†’\\n    s âˆˆ nhds a â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\\nis continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a strictly monotone function on a left neighborhood of `a` and the image of this\\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, then `f` is continuous at `a`\\nfrom the left.\\n\\nThe assumption `hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ico b (f a)` is required because otherwise the\\nfunction `f : â„ â†’ â„` given by `f x = if x < 0 then x else x + 1` would be a counter-example at\\n`a = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds b) â†’\\n      Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n        HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) c b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\\nfinite limit `c` almost surely at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `c` at `b`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds a) â†’\\n      Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n        HasDerivAt (fun u => âˆ« (x : â„) in u..b, f x) (-c) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\\nfinite limit `c` almost surely at `a`, then `u â†¦ âˆ« x in u..b, f x` has derivative `-c` at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  (Î¼ : MeasureTheory.Measure Î±) [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] (f : MeasureTheory.SimpleFunc Î± NNReal)\\n  {Îµ : ENNReal},\\n  Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), â†‘f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a simple function `f` with values in `â„â‰¥0`, there exists a lower semicontinuous\\nfunction `g â‰¥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\\n`lintegral`.\\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds b) â†’\\n      Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n        deriv (fun u => âˆ« (x : â„) in a..u, f x) b = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f` has a finite\\nlimit `c` almost surely at `b`, then the derivative of `u â†¦ âˆ« x in a..u, f x` at `b` equals `c`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter b (nhdsWithin b s) (nhdsWithin b t)],\\n      StronglyMeasurableAtFilter f (nhdsWithin b t) â†’\\n        Filter.Tendsto f (nhdsWithin b t âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n          autoParam (UniqueDiffWithinAt â„ s b) _autoâœ â†’ derivWithin (fun u => âˆ« (x : â„) in a..u, f x) s b = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a finite\\nlimit `c` almost surely as `x` tends to `b` from the right or from the left, then the right\\n(resp., left) derivative of `u â†¦ âˆ« x in a..u, f x` at `b` equals `c`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter b (nhdsWithin b s) (nhdsWithin b t)],\\n      StronglyMeasurableAtFilter f (nhdsWithin b t) â†’\\n        Filter.Tendsto f (nhdsWithin b t âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n          HasDerivWithinAt (fun u => âˆ« (x : â„) in a..u, f x) c s b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a finite\\nlimit `c` almost surely as `x` tends to `b` from the right or from the left,\\nthen `u â†¦ âˆ« x in a..u, f x` has right (resp., left) derivative `c` at `b`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter a (nhdsWithin a s) (nhdsWithin a t)],\\n      StronglyMeasurableAtFilter f (nhdsWithin a t) â†’\\n        Filter.Tendsto f (nhdsWithin a t âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n          HasDerivWithinAt (fun u => âˆ« (x : â„) in u..b, f x) (-c) s a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a finite\\nlimit `c` almost surely as `x` tends to `a` from the right or from the left,\\nthen `u â†¦ âˆ« x in u..b, f x` has right (resp., left) derivative `-c` at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhdsWithin a (Set.Ici a) â†’\\n      (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousWithinAt f (Set.Ici a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a function strictly monotone on a right neighborhood of `a` and the\\nimage of this neighborhood under `f` meets every interval `(f a, b]`, `b > f a`, then `f` is\\ncontinuous at `a` from the right.\\n\\nThe assumption `hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b` is required because otherwise the\\nfunction `f : â„ â†’ â„` given by `f x = if x â‰¤ 0 then x else x + 1` would be a counter-example at\\n`a = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhds a â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’\\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is strictly monotone on a neighborhood of `a` and the image of this\\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval\\n`(f a, b]`, `b > f a`, then `f` is continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  (f : Î± â†’ NNReal),\\n  (MeasureTheory.Integrable fun x => â†‘(f x)) â†’\\n    âˆ€ {Îµ : â„},\\n      0 < Îµ â†’\\n        âˆƒ g,\\n          (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§\\n            LowerSemicontinuous g âˆ§\\n              (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§\\n                (MeasureTheory.Integrable fun x => ENNReal.toReal (g x)) âˆ§\\n                  âˆ« (x : Î±), ENNReal.toReal (g x) âˆ‚Î¼ < âˆ« (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an integrable function `f` with values in `â„â‰¥0` in a sigma-finite space, there exists a\\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\\nFormulation in terms of `integral`.\\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"}]\n",
    "prompt_cons": "/-- If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\nequal to each other. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\n  0 < r â†’\n    r â‰¤ R â†’\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\n        Set.Countable s â†’\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) â†’\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\ Metric.closedBall c r) \\ s â†’ DifferentiableAt â„‚ f z) â†’\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z :=\n\n/-- A continuous function on a closed interval with `f a = f b` takes either its maximum\nor its minimum value at a point in the interior of the interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„},\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsExtrOn f (Set.Icc a b) c :=\n\n/-- If `f : â„ â†’ â„` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\nof the interval, then its integral over `a..b` is strictly positive. -/\ntheorem âˆ€ {f : â„ â†’ â„} {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f x) â†’ a < b â†’ 0 < âˆ« (x : â„) in a..b, f x :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c :=\n\n/-- If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\nis continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  MonotoneOn f s â†’\n    s âˆˆ nhds a â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- If `f` is a strictly monotone function on a left neighborhood of `a` and the image of this\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, then `f` is continuous at `a`\nfrom the left.\n\nThe assumption `hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ico b (f a)` is required because otherwise the\nfunction `f : â„ â†’ â„` given by `f x = if x < 0 then x else x + 1` would be a counter-example at\n`a = 0`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\nfinite limit `c` almost surely at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `c` at `b`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds b) â†’\n      Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n        HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) c b :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\nfinite limit `c` almost surely at `a`, then `u â†¦ âˆ« x in u..b, f x` has derivative `-c` at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds a) â†’\n      Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n        HasDerivAt (fun u => âˆ« (x : â„) in u..b, f x) (-c) a :=\n\n/-- Given a simple function `f` with values in `â„â‰¥0`, there exists a lower semicontinuous\nfunction `g â‰¥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] (f : MeasureTheory.SimpleFunc Î± NNReal)\n  {Îµ : ENNReal},\n  Îµ â‰  0 â†’ âˆƒ g, (âˆ€ (x : Î±), â†‘f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(â†‘f x) âˆ‚Î¼ + Îµ :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f` has a finite\nlimit `c` almost surely at `b`, then the derivative of `u â†¦ âˆ« x in a..u, f x` at `b` equals `c`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds b) â†’\n      Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n        deriv (fun u => âˆ« (x : â„) in a..u, f x) b = c :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a finite\nlimit `c` almost surely as `x` tends to `b` from the right or from the left, then the right\n(resp., left) derivative of `u â†¦ âˆ« x in a..u, f x` at `b` equals `c`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter b (nhdsWithin b s) (nhdsWithin b t)],\n      StronglyMeasurableAtFilter f (nhdsWithin b t) â†’\n        Filter.Tendsto f (nhdsWithin b t âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n          autoParam (UniqueDiffWithinAt â„ s b) _autoâœ â†’ derivWithin (fun u => âˆ« (x : â„) in a..u, f x) s b = c :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a finite\nlimit `c` almost surely as `x` tends to `b` from the right or from the left,\nthen `u â†¦ âˆ« x in a..u, f x` has right (resp., left) derivative `c` at `b`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter b (nhdsWithin b s) (nhdsWithin b t)],\n      StronglyMeasurableAtFilter f (nhdsWithin b t) â†’\n        Filter.Tendsto f (nhdsWithin b t âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n          HasDerivWithinAt (fun u => âˆ« (x : â„) in a..u, f x) c s b :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a finite\nlimit `c` almost surely as `x` tends to `a` from the right or from the left,\nthen `u â†¦ âˆ« x in u..b, f x` has right (resp., left) derivative `-c` at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter a (nhdsWithin a s) (nhdsWithin a t)],\n      StronglyMeasurableAtFilter f (nhdsWithin a t) â†’\n        Filter.Tendsto f (nhdsWithin a t âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n          HasDerivWithinAt (fun u => âˆ« (x : â„) in u..b, f x) (-c) s a :=\n\n/-- If `f` is a function strictly monotone on a right neighborhood of `a` and the\nimage of this neighborhood under `f` meets every interval `(f a, b]`, `b > f a`, then `f` is\ncontinuous at `a` from the right.\n\nThe assumption `hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b` is required because otherwise the\nfunction `f : â„ â†’ â„` given by `f x = if x â‰¤ 0 then x else x + 1` would be a counter-example at\n`a = 0`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhdsWithin a (Set.Ici a) â†’\n      (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousWithinAt f (Set.Ici a) a :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- If a function `f` is strictly monotone on a neighborhood of `a` and the image of this\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval\n`(f a, b]`, `b > f a`, then `f` is continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhds a â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousAt f a :=\n\n/-- Given an integrable function `f` with values in `â„â‰¥0` in a sigma-finite space, there exists a\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `integral`.\nAuxiliary lemma for Vitali-CarathÃ©odory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasureTheory.Measure.WeaklyRegular Î¼] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  (f : Î± â†’ NNReal),\n  (MeasureTheory.Integrable fun x => â†‘(f x)) â†’\n    âˆ€ {Îµ : â„},\n      0 < Îµ â†’\n        âˆƒ g,\n          (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§\n            LowerSemicontinuous g âˆ§\n              (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§\n                (MeasureTheory.Integrable fun x => ENNReal.toReal (g x)) âˆ§\n                  âˆ« (x : Î±), ENNReal.toReal (g x) âˆ‚Î¼ < âˆ« (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- Suppose `f` is a real function with domain `â„^1` which has the intermediate value property: if `f(a) < c < f(b)`, then `f(x) = c` for some `x` between `a` and `b`. Suppose also, for every rational `r`, that the set of all `x` with `f(x) = r` is closed. Prove that `f` is continuous. -/\ntheorem",
    "choices": [
      "forall {f : â„ â†’ â„},\n  (âˆ€ a b c, f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ q : â„š, is_closed {x | f x = q}) â†’\n  continuous f ",
      "âˆ€ {f : â„ â†’ â„},\n  interval_valued f â†’\n    (âˆ€ (r : â„š), IsClosed (f â»Â¹' {â†‘r})) â†’ Continuous f ",
      "âˆ€ {f : â„ â†’ â„},\n  (IntervalIntegrable f MeasureTheory.volume 0 1 âˆ§ âˆ€ (x y : â„), f x < y â†’ f y â†’ âˆƒ x', x < x' âˆ§ x' < y âˆ§ f x' = f x âˆ¨ f x' = f y) â†’\n  (âˆ€ (r : â„š), IsClosed (f â»Â¹' {r})) â†’ Continuous f ",
      "forall {f : â„ â†’ â„},\n  (âˆ€ (a b : â„) (c : â„),\n    a â‰¤ b â†’ f a â‰¤ c â†’ c â‰¤ f b â†’ âˆƒ (x : â„), x âˆˆ Set.Icc a b âˆ§ f x = c) â†’\n  (âˆ€ (r : â„š), IsClosed (SetOf (Î» (x : â„), f x = coe r))) â†’\n  Continuous f ",
      "forall {f : â„ â†’ â„},\n  (âˆ€ {{a b : â„}} {c : â„}, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ r : â„š, IsClosed (f â»Â¹' {r})) â†’ Continuous f ",
      "forall {f : â„ â†’ â„},\n  (âˆ€ (a b : â„) (c : â„), a â‰¤ b â†’ f a â‰¤ c â†’ c â‰¤ f b â†’ âˆƒ x âˆˆ Set.Icc a b, f x = c) â†’\n  (âˆ€ r : â„š, IsClosed (f â»Â¹' {r})) â†’ Continuous f ",
      "forall {f : â„ â†’ â„},\n  (forall {a b c : â„}, a â‰¤ b -> f a < c -> c < f b -> âˆƒ x, a â‰¤ x âˆ§ x â‰¤ b âˆ§ f x = c) ->\n  (forall (r : â„š), IsClosed (f â»Â¹' {r})) ->\n  Continuous f ",
      "forall {f : â„ â†’ â„},\n  (âˆ€ {a b : â„} {c : â„}, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, x âˆˆ set.Ioo a b âˆ§ f x = c) â†’\n  (âˆ€ (q : â„š), is_closed {x : â„ | f x = â†‘q}) â†’\n  continuous f ",
      "forall {f : â„ â†’ â„} (hmono : âˆ€ a b : â„, a < b â†’ a < f a â†’ f a < f b â†’ f b < b),\n  (forall (q : â„š) (x : â„), f x = q â†’ âˆƒ s hs, x âˆˆ s âˆ§ IsClosed s) â†’\n  Continuous f ",
      "forall {f : â„ â†’ â„}, (âˆ€ a b c, a < b â†’ f a < c â†’ c < f b â†’ âˆƒ x, a < x âˆ§ x < b âˆ§ f x = c) â†’\n  (âˆ€ r : â„š, is_closed (f â»Â¹' {r})) â†’ continuous f "
    ]
  },
  {
    "docString": "Assume that `f` is a continuous real function defined in `(a, b)` such that `f((x+y)/2) â‰¤ (f(x)+f(y))/2` for all `x, y âˆˆ (a, b)`. Prove that `f` is convex.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E â†’ Î²},\\n  Convex ğ•œ s â†’\\n    (âˆ€ â¦ƒx : Eâ¦„,\\n        x âˆˆ s â†’\\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)) â†’\\n      ConcaveOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is concave it suffices to\\nverify the inequality `a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`. The\\nmain use case is `E = â„` however one can apply it, e.g., to `â„^n` with lexicographic order. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Monotone (deriv f) â†’ ConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is differentiable and `f'` is monotone on `â„` then `f` is convex. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `â„`, and `f''` is nonnegative on `â„`,\\nthen `f` is convex on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E â†’ Î²},\\n  Convex ğ•œ s â†’\\n    (âˆ€ â¦ƒx : Eâ¦„,\\n        x âˆˆ s â†’\\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)) â†’\\n      StrictConcaveOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is strictly concave it suffices\\nto verify the inequality `a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`.\\nThe main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommGroup Î²] [inst_3 : SMul ğ•œ E] [inst_4 : Module ğ•œ Î²] {s : Set E} {f : E â†’ Î²},\\n  ConvexOn ğ•œ s (-f) â†” ConcaveOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\": \"A function `-f` is convex iff `f` is concave. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x < C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ f y - f x < C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y âˆˆ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’ StrictConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on `â„`, and `f''` is strictly positive on `â„`,\\nthen `f` is strictly convex on `â„`.\\nNote that we don't require twice differentiability explicitly as it is already implied by the second\\nderivative being strictly positive, except at at most one point. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E â†’ Î²},\\n  Convex ğ•œ s â†’\\n    (âˆ€ â¦ƒx : Eâ¦„,\\n        x âˆˆ s â†’\\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) â†’\\n      ConvexOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is convex, it suffices to\\nverify the inequality `f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y` only for `x < y` and positive `a`,\\n`b`. The main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order.\\n\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\\n  ConvexOn ğ•œ s f â†”\\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : ğ•œ â†’ ğ•œ` is convex iff for any three points `x < y < z` the slope of the secant\\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommGroup Î²] [inst_3 : SMul ğ•œ E] [inst_4 : Module ğ•œ Î²] {s : Set E} {f : E â†’ Î²},\\n  StrictConvexOn ğ•œ s (-f) â†” StrictConcaveOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `-f` is strictly convex iff `f` is strictly concave. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          DifferentiableOn â„ (deriv f) (interior D) â†’ (âˆ€ (x : â„), x âˆˆ interior D â†’ 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ D f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on a convex set `D âŠ† â„`, is twice differentiable on its\\ninterior, and `f''` is nonnegative on the interior, then `f` is convex on `D`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          DifferentiableOn â„ (deriv f) (interior D) â†’ (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv^[2] f x â‰¤ 0) â†’ ConcaveOn â„ D f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on a convex set `D âŠ† â„`, is twice differentiable on its\\ninterior, and `f''` is nonpositive on the interior, then `f` is concave on `D`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E â†’ Î²},\\n  Convex ğ•œ s â†’\\n    (âˆ€ â¦ƒx : Eâ¦„,\\n        x âˆˆ s â†’\\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) < a â€¢ f x + b â€¢ f y) â†’\\n      StrictConvexOn ğ•œ s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is strictly convex, it suffices\\nto verify the inequality `f (a â€¢ x + b â€¢ y) < a â€¢ f x + b â€¢ f y` for `x < y` and positive `a`, `b`.\\nThe main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictMono (deriv f) â†’ StrictConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly monotone on `â„` then `f` is strictly\\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict monotonicity of `f'`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), deriv^[2] f x â‰¤ 0) â†’ ConcaveOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `â„`, and `f''` is nonpositive on `â„`,\\nthen `f` is concave on `â„`. \"}]\n",
    "prompt_cons": "/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is concave it suffices to\nverify the inequality `a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`. The\nmain use case is `E = â„` however one can apply it, e.g., to `â„^n` with lexicographic order. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)) â†’\n      ConcaveOn ğ•œ s f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\n`x < y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x :=\n\n/-- If a function `f` is differentiable and `f'` is monotone on `â„` then `f` is convex. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Monotone (deriv f) â†’ ConvexOn â„ Set.univ f :=\n\n/-- If a function `f` is twice differentiable on `â„`, and `f''` is nonnegative on `â„`,\nthen `f` is convex on `â„`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ Set.univ f :=\n\n/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is strictly concave it suffices\nto verify the inequality `a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)` for `x < y` and positive `a`, `b`.\nThe main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)) â†’\n      StrictConcaveOn ğ•œ s f :=\n\n/-- A function `-f` is convex iff `f` is concave. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Î²] [inst_3 : SMul ğ•œ E] [inst_4 : Module ğ•œ Î²] {s : Set E} {f : E â†’ Î²},\n  ConvexOn ğ•œ s (-f) â†” ConcaveOn ğ•œ s f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y âˆˆ D`,\n`x < y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x < C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ f y - f x < C * (y - x) :=\n\n/-- If a function `f` is continuous on `â„`, and `f''` is strictly positive on `â„`,\nthen `f` is strictly convex on `â„`.\nNote that we don't require twice differentiability explicitly as it is already implied by the second\nderivative being strictly positive, except at at most one point. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ (âˆ€ (x : â„), 0 < deriv^[2] f x) â†’ StrictConvexOn â„ Set.univ f :=\n\n/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is convex, it suffices to\nverify the inequality `f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y` only for `x < y` and positive `a`,\n`b`. The main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) â†’\n      ConvexOn ğ•œ s f :=\n\n/-- A function `f : ğ•œ â†’ ğ•œ` is convex iff for any three points `x < y < z` the slope of the secant\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] {s : Set ğ•œ} {f : ğ•œ â†’ ğ•œ},\n  ConvexOn ğ•œ s f â†”\n    Convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y) :=\n\n/-- A function `-f` is strictly convex iff `f` is strictly concave. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Î²] [inst_3 : SMul ğ•œ E] [inst_4 : Module ğ•œ Î²] {s : Set E} {f : E â†’ Î²},\n  StrictConvexOn ğ•œ s (-f) â†” StrictConcaveOn ğ•œ s f :=\n\n/-- If a function `f` is continuous on a convex set `D âŠ† â„`, is twice differentiable on its\ninterior, and `f''` is nonnegative on the interior, then `f` is convex on `D`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          DifferentiableOn â„ (deriv f) (interior D) â†’ (âˆ€ (x : â„), x âˆˆ interior D â†’ 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ D f :=\n\n/-- If a function `f` is continuous on a convex set `D âŠ† â„`, is twice differentiable on its\ninterior, and `f''` is nonpositive on the interior, then `f` is concave on `D`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          DifferentiableOn â„ (deriv f) (interior D) â†’ (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv^[2] f x â‰¤ 0) â†’ ConcaveOn â„ D f :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is strictly convex, it suffices\nto verify the inequality `f (a â€¢ x + b â€¢ y) < a â€¢ f x + b â€¢ f y` for `x < y` and positive `a`, `b`.\nThe main use case is `E = ğ•œ` however one can apply it, e.g., to `ğ•œ^n` with lexicographic order. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) < a â€¢ f x + b â€¢ f y) â†’\n      StrictConvexOn ğ•œ s f :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- If a function `f` is continuous and `f'` is strictly monotone on `â„` then `f` is strictly\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict monotonicity of `f'`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictMono (deriv f) â†’ StrictConvexOn â„ Set.univ f :=\n\n/-- If a function `f` is twice differentiable on `â„`, and `f''` is nonpositive on `â„`,\nthen `f` is concave on `â„`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), deriv^[2] f x â‰¤ 0) â†’ ConcaveOn â„ Set.univ f :=\n\n/-- Assume that `f` is a continuous real function defined in `(a, b)` such that `f((x+y)/2) â‰¤ (f(x)+f(y))/2` for all `x, y âˆˆ (a, b)`. Prove that `f` is convex. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ] {s : Set ğ•œ}\n  {f : ğ•œ â†’ ğ•œ},\n  ContinuousOn f s â†’\n    (âˆ€ â¦ƒx : ğ•œâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : ğ•œâ¦„, y âˆˆ s â†’ x < y â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn ğ•œ s f ",
      "âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Set.Ioo a b) â†’\n        (âˆ€ x y : â„, x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Set.Ioo a b) f ",
      "forall {a b : â„} (hab : a < b),\n  âˆ€ {f : â„ â†’ â„},\n    ContinuousOn f (Set.Ioo a b) â†’\n    (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n    ConvexOn â„ (Set.Ioo a b) f ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : LinearOrderedField ğ•œ] [inst_1 : OrderedAddCommGroup E]\n  [inst_2 : Module ğ•œ E] [inst_3 : LinearOrder Î²] [inst_4 : OrderedSmul ğ•œ Î²] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn ğ•œ s f ",
      "âˆ€ {a b : â„},\n  a < b â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f (Set.Ioo a b) â†’\n        (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n          ConvexOn â„ (Set.Ioo a b) f ",
      "âˆ€ {s : Set â„} {f : â„ â†’ â„},\n  Convex â„ s â†’\n    (âˆ€ â¦ƒx y : â„â¦„,\n        x âˆˆ s â†’\n          y âˆˆ s â†’ âˆ€ â¦ƒa b : â„â¦„, 0 < a â†’ 0 < b â†’ a + b = 2 â†’ f ((a â€¢ x + b â€¢ y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn â„ s f ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_3} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) â†’\n      ConvexOn ğ•œ s f ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] {s : Set E}\n  {f : E â†’ Î²},\n  Convex ğ•œ s â†’\n    (âˆ€ â¦ƒx : Eâ¦„,\n        x âˆˆ s â†’\n          âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ (âˆ€ (z : E), z = (x + y) / 2 â†’ f z â‰¤ (f x + f y) / 2)) â†’\n      ConvexOn ğ•œ s f ",
      "âˆ€ {a b : â„} (hab : a < b) {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ioo a b) â†’\n    (âˆ€ (x y : â„), x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn â„ (Set.Ioo a b) f ",
      "forall {a b : â„} (hab : a < b) {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ioo a b) â†’\n    (âˆ€ x y : â„, x âˆˆ Set.Ioo a b â†’ y âˆˆ Set.Ioo a b â†’ f ((x + y) / 2) â‰¤ (f x + f y) / 2) â†’\n      ConvexOn â„ (Set.Ioo a b) f "
    ]
  },
  {
    "docString": "Suppose `f'(x) > 0` in `(a, b)`. Prove that `f` is strictly increasing in `(a, b)`, and let `g` be its inverse function. Prove that `g` is differentiable, and that `g'(f(x)) = 1/f'(x)` for `(a < x < b)`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {Î² : Type u_1} [inst_1 : Preorder Î²] {f g : Î± â†’ Î²},\\n  Monotone f â†’ Antitone g â†’ f â‰¤ g â†’ âˆ€ (m n : Î±), f m â‰¤ g n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is monotone, `g` is antitone, and `f â‰¤ g`, then for all `a`, `b` we have `f a â‰¤ g b`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ},\\n  ContinuousAt g a â†’\\n    HasStrictDerivAt f f' (g a) â†’ f' â‰  0 â†’ (âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) â†’ HasStrictDerivAt g f'â»Â¹ a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\\nin the strict sense.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\\ninverse function. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\\n  ContinuousAt g a â†’\\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\\nan inverse function. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {a b : â„}\\n  {f f' : â„ â†’ â„} {g : â„ â†’ E},\\n  ContinuousOn f (Set.uIcc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo (min a b) (max a b) â†’ HasDerivWithinAt f (f' x) (Set.Ioi x) x) â†’\\n      ContinuousOn g (f '' Set.Ioo (min a b) (max a b)) â†’\\n        MeasureTheory.IntegrableOn g (f '' Set.uIcc a b) â†’\\n          MeasureTheory.IntegrableOn (fun x => f' x â€¢ (g âˆ˜ f) x) (Set.uIcc a b) â†’\\n            âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (u : â„) in f a..f b, g u\",\n  \"isProp\": true,\n  \"docString\":\n  \"Change of variables, general form. If `f` is continuous on `[a, b]` and has\\nright-derivative `f'` in `(a, b)`, `g` is continuous on `f '' (a, b)` and integrable on\\n`f '' [a, b]`, and `f' x â€¢ (g âˆ˜ f) x` is integrable on `[a, b]`,\\nthen we can substitute `u = f x` to get `âˆ« x in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« u in f a..f b, g u`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f' x â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x â‰¤ B' x` on `[a, b)`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„} {Î¼ : MeasureTheory.Measure â„},\\n  a â‰¤ b â†’\\n    IntervalIntegrable f Î¼ a b â†’\\n      IntervalIntegrable g Î¼ a b â†’\\n        f â‰¤á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ (Set.Ioc a b))] g â†’\\n          â†‘â†‘(MeasureTheory.Measure.restrict Î¼ (Set.Ioc a b)) {x | f x < g x} â‰  0 â†’\\n            âˆ« (x : â„) in a..b, f x âˆ‚Î¼ < âˆ« (x : â„) in a..b, g x âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are two functions that are interval integrable on `a..b`, `a â‰¤ b`,\\n`f x â‰¤ g x` for a.e. `x âˆˆ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\\nof nonzero measure, then `âˆ« x in a..b, f x âˆ‚Î¼ < âˆ« x in a..b, g x âˆ‚Î¼`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f x) â†’ a < b â†’ 0 < âˆ« (x : â„) in a..b, f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„ â†’ â„` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\\nof the interval, then its integral over `a..b` is strictly positive. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds b) â†’ ContinuousAt f b â†’ HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) (f b) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f` is\\ncontinuous at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `f b` at `b`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {a b : â„},\\n  0 < b â†’\\n    ContinuousOn f (Set.Ici a) â†’ (f =O[Filter.atTop] fun x => rexp (-b * x)) â†’ MeasureTheory.IntegrableOn f (Set.Ioi a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is continuous on `[a, âˆ)`, and is `O (exp (-b * x))` at `âˆ` for some `b > 0`, then\\n`f` is integrable on `(a, âˆ)`. \"},\n {\"theorem\": \"âˆ€ {f : â„ â†’ â„}, (âˆ€ (x : â„), 0 < deriv f x) â†’ StrictMono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f'` is positive, then\\n`f` is a strictly monotone function.\\nNote that we don't require differentiability explicitly as it already implied by the derivative\\nbeing strictly positive. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    âˆ€ {B B' : â„ â†’ â„},\\n      f a â‰¤ B a â†’\\n        ContinuousOn B (Set.Icc a b) â†’\\n          (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n            (âˆ€ (x : â„),\\n                x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), B' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n              âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by `B'`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter b (nhdsWithin b s) (nhdsWithin b t)],\\n      StronglyMeasurableAtFilter f (nhdsWithin b t) â†’\\n        ContinuousWithinAt f t b â†’\\n          autoParam (UniqueDiffWithinAt â„ s b) _autoâœ â†’ derivWithin (fun u => âˆ« (x : â„) in a..u, f x) s b = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` is continuous\\non the right or on the left at `b`, then the right (resp., left) derivative of\\n`u â†¦ âˆ« x in a..u, f x` at `b` equals `f b`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f f' : â„ â†’ E}\\n  {a b : â„},\\n  a â‰¤ b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\\n        IntervalIntegrable f' MeasureTheory.volume a b â†’ âˆ« (y : â„) in a..b, f' y = f b - f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus-2: If `f : â„ â†’ E` is continuous on `[a, b]` (where `a â‰¤ b`) and\\nhas a derivative at `f' x` for all `x` in `(a, b)`, and `f'` is integrable on `[a, b]`, then\\n`âˆ« y in a..b, f' y` equals `f b - f a`. \"}]\n",
    "prompt_cons": "/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- If `f` is monotone, `g` is antitone, and `f â‰¤ g`, then for all `a`, `b` we have `f a â‰¤ g b`. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {Î² : Type u_1} [inst_1 : Preorder Î²] {f g : Î± â†’ Î²},\n  Monotone f â†’ Antitone g â†’ f â‰¤ g â†’ âˆ€ (m n : Î±), f m â‰¤ g n :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\nin the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ},\n  ContinuousAt g a â†’\n    HasStrictDerivAt f f' (g a) â†’ f' â‰  0 â†’ (âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) â†’ HasStrictDerivAt g f'â»Â¹ a :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\n  ContinuousAt g a â†’\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- Change of variables, general form. If `f` is continuous on `[a, b]` and has\nright-derivative `f'` in `(a, b)`, `g` is continuous on `f '' (a, b)` and integrable on\n`f '' [a, b]`, and `f' x â€¢ (g âˆ˜ f) x` is integrable on `[a, b]`,\nthen we can substitute `u = f x` to get `âˆ« x in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« u in f a..f b, g u`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {a b : â„}\n  {f f' : â„ â†’ â„} {g : â„ â†’ E},\n  ContinuousOn f (Set.uIcc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo (min a b) (max a b) â†’ HasDerivWithinAt f (f' x) (Set.Ioi x) x) â†’\n      ContinuousOn g (f '' Set.Ioo (min a b) (max a b)) â†’\n        MeasureTheory.IntegrableOn g (f '' Set.uIcc a b) â†’\n          MeasureTheory.IntegrableOn (fun x => f' x â€¢ (g âˆ˜ f) x) (Set.uIcc a b) â†’\n            âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (u : â„) in f a..f b, g u :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x â‰¤ B' x` on `[a, b)`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f' x â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- If `f` and `g` are two functions that are interval integrable on `a..b`, `a â‰¤ b`,\n`f x â‰¤ g x` for a.e. `x âˆˆ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\nof nonzero measure, then `âˆ« x in a..b, f x âˆ‚Î¼ < âˆ« x in a..b, g x âˆ‚Î¼`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„} {Î¼ : MeasureTheory.Measure â„},\n  a â‰¤ b â†’\n    IntervalIntegrable f Î¼ a b â†’\n      IntervalIntegrable g Î¼ a b â†’\n        f â‰¤á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ (Set.Ioc a b))] g â†’\n          â†‘â†‘(MeasureTheory.Measure.restrict Î¼ (Set.Ioc a b)) {x | f x < g x} â‰  0 â†’\n            âˆ« (x : â„) in a..b, f x âˆ‚Î¼ < âˆ« (x : â„) in a..b, g x âˆ‚Î¼ :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- If `f : â„ â†’ â„` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\nof the interval, then its integral over `a..b` is strictly positive. -/\ntheorem âˆ€ {f : â„ â†’ â„} {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f x) â†’ a < b â†’ 0 < âˆ« (x : â„) in a..b, f x :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f` is\ncontinuous at `b`, then `u â†¦ âˆ« x in a..u, f x` has derivative `f b` at `b`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds b) â†’ ContinuousAt f b â†’ HasDerivAt (fun u => âˆ« (x : â„) in a..u, f x) (f b) b :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- If `f` is continuous on `[a, âˆ)`, and is `O (exp (-b * x))` at `âˆ` for some `b > 0`, then\n`f` is integrable on `(a, âˆ)`. -/\ntheorem âˆ€ {f : â„ â†’ â„} {a b : â„},\n  0 < b â†’\n    ContinuousOn f (Set.Ici a) â†’ (f =O[Filter.atTop] fun x => rexp (-b * x)) â†’ MeasureTheory.IntegrableOn f (Set.Ioi a) :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f'` is positive, then\n`f` is a strictly monotone function.\nNote that we don't require differentiability explicitly as it already implied by the derivative\nbeing strictly positive. -/\ntheorem âˆ€ {f : â„ â†’ â„}, (âˆ€ (x : â„), 0 < deriv f x) â†’ StrictMono f :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by `B'`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    âˆ€ {B B' : â„ â†’ â„},\n      f a â‰¤ B a â†’\n        ContinuousOn B (Set.Icc a b) â†’\n          (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n            (âˆ€ (x : â„),\n                x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), B' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n              âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` is continuous\non the right or on the left at `b`, then the right (resp., left) derivative of\n`u â†¦ âˆ« x in a..u, f x` at `b` equals `f b`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter b (nhdsWithin b s) (nhdsWithin b t)],\n      StronglyMeasurableAtFilter f (nhdsWithin b t) â†’\n        ContinuousWithinAt f t b â†’\n          autoParam (UniqueDiffWithinAt â„ s b) _autoâœ â†’ derivWithin (fun u => âˆ« (x : â„) in a..u, f x) s b = f b :=\n\n/-- Fundamental theorem of calculus-2: If `f : â„ â†’ E` is continuous on `[a, b]` (where `a â‰¤ b`) and\nhas a derivative at `f' x` for all `x` in `(a, b)`, and `f'` is integrable on `[a, b]`, then\n`âˆ« y in a..b, f' y` equals `f b - f a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f f' : â„ â†’ E}\n  {a b : â„},\n  a â‰¤ b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\n        IntervalIntegrable f' MeasureTheory.volume a b â†’ âˆ« (y : â„) in a..b, f' y = f b - f a :=\n\n/-- Suppose `f'(x) > 0` in `(a, b)`. Prove that `f` is strictly increasing in `(a, b)`, and let `g` be its inverse function. Prove that `g` is differentiable, and that `g'(f(x)) = 1/f'(x)` for `(a < x < b)`. -/\ntheorem",
    "choices": [
      "âˆ€ {f : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n    StrictMono f â†’\n      let g ",
      "âˆ€ {f : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n    (StrictMono f âˆ§\n      âˆ€ {x : â„},\n        x âˆˆ Set.Ioo a b â†’\n          âˆƒ g, (âˆ€ (y : â„), y âˆˆ Set.Ioo (f a) (f b) â†’ (g âˆ˜ f) y = y) âˆ§\n                    HasDerivAt g (deriv f x)â»Â¹ (f x)) ",
      "âˆ€ {f : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n      StrictMono f â†’\n        let g ",
      "âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f' x) â†’\n        StrictMonoOn f (Set.Ioo a b) âˆ§\n          âˆƒ (g : â„ â†’ â„),\n            ContinuousOn g (Set.Icc (f a) (f b)) âˆ§\n              (âˆ€ (y : â„), y âˆˆ Set.Ioo (f a) (f b) â†’ HasDerivAt g (1 / f' (g y)) y) ",
      "âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f' x) â†’\n    (StrictMono f âˆ§ âˆƒ g, âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ (HasDerivAt f (f' x) x âˆ§ HasDerivAt g (1 / f' (g x)) (f x))) ",
      "âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f' x) â†’\n    (StrictMono f âˆ§\n      âˆ€ {g : â„ â†’ â„},\n        (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ g (f x) = x) â†’ âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt g (1 / f' (f x)) (f x)) ",
      "forall {f f' : â„ â†’ â„} {a b : â„},\n  (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f' x) â†’\n      let g ",
      "âˆ€ {f : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n      (Exists g, âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ (HasDerivAt g (1 / deriv f (g x)) x) âˆ§ f (g x) = x) ",
      "âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < f' x) â†’\n        let g ",
      "âˆ€ {f : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 < deriv f x) â†’\n      StrictMono f âˆ§\n        âˆ€ {g : â„ â†’ â„},\n          (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ g (f x) = x) â†’\n            (âˆ€ (y : â„), y âˆˆ Set.Icc (f a) (f b) â†’ ContinuousOn g (Set.Icc (f a) (f b))) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt g (1 / deriv f (g (f x))) (f x)) "
    ]
  },
  {
    "docString": "If `C_0 + C_1/2 + â‹¯ + C_{n-1}/n + C_n/(n+1) = 0`, where `C_0, ..., C_n` are real constants, prove that the equation `C_0 + C_1x + â‹¯ + C_{n-1}x^{n-1} + C_nx^n = 0` has at least one real root between 0 and 1.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’\\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun Î¶ => Polynomial.X - â†‘Polynomial.C Î¶\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = âˆ (X - Î¼)`, where `Î¼`\\nvaries over the `n`-th roots of unity. \"},\n {\"theorem\":\n  \"âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„š),\\n  Finset.card (Set.toFinset (Polynomial.rootSet p â„‚)) =\\n    Finset.card (Set.toFinset (Polynomial.rootSet p â„)) +\\n      Finset.card\\n        (Equiv.Perm.support\\n          (â†‘(Polynomial.Gal.galActionHom p â„‚)\\n            (â†‘(Polynomial.Gal.restrict p â„‚) (AlgEquiv.restrictScalars â„š Complex.conjAe))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of complex roots equals the number of real roots plus\\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•+) (x : â„‚Ë£), x âˆˆ rootsOfUnity n â„‚ â†” âˆƒ i, i < â†‘n âˆ§ cexp (2 * â†‘Real.pi * Complex.I * (â†‘i / â†‘â†‘n)) = â†‘x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complex `n`-th roots of unity are exactly the\\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. \"},\n {\"theorem\":\n  \"âˆ€ {f : Polynomial â„‚}, 0 < Polynomial.degree f â†’ âˆƒ z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’ (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then\\n`âˆ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : DivisionRing ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : CharZero ğ•œ] [inst_3 : Algebra â„ ğ•œ]\\n  [inst_4 : ContinuousSMul â„ ğ•œ] [inst_5 : TopologicalDivisionRing ğ•œ] (x : ğ•œ),\\n  Filter.Tendsto (fun n => â†‘n / (â†‘n + x)) Filter.atTop (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The limit of `n / (n + x)` is 1, for any constant `x` (valid in `â„` or any topological division\\nalgebra over `â„`, e.g., `â„‚`).\\n\\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\\nstatement simultaneously on `â„š`, `â„` and `â„‚`. \"},\n {\"theorem\":\n  \"âˆ€ {p x : â„},\\n  LiouvilleWith p x â†’ âˆƒ C _hâ‚€, âˆƒá¶  (n : â„•) in Filter.atTop, 1 â‰¤ n âˆ§ âˆƒ m, x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < C / â†‘n ^ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant `C` provided by the definition of `LiouvilleWith` can be made positive.\\nWe also add `1 â‰¤ n` to the list of assumptions about the denominator. While it is equivalent to\\nthe original statement, the case `n = 0` breaks many arguments. \"},\n {\"theorem\":\n  \"Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] {n : â„•}, 1 < n â†’ Polynomial.coeff (Polynomial.cyclotomic n R) 0 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The constant term of `cyclotomic n R` is `1` if `2 â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R],\\n  Polynomial.roots (Polynomial.cyclotomic' n R) = (primitiveRoots n R).val\",\n  \"isProp\": true,\n  \"docString\":\n  \"The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’\\n      Polynomial.cyclotomic' n K =\\n        (Polynomial.X ^ n - 1) /â‚˜ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then\\n`cyclotomic' n K = (X ^ k - 1) /â‚˜ (âˆ i in Nat.properDivisors k, cyclotomic' i K)`. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\\n  IsPrimitiveRoot Î¶ n â†’\\n    Polynomial.cyclotomic n K = Finset.prod (primitiveRoots n K) fun Î¼ => Polynomial.X - â†‘Polynomial.C Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then\\n`cyclotomic n K = âˆ Î¼ in primitiveRoots n K, (X - C Î¼)`. In particular,\\n`cyclotomic n K = cyclotomic' n K` \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] [inst_2 : CharZero K] {Î¶ : K} {n : â„•+},\\n  IsPrimitiveRoot Î¶ â†‘n â†’ âˆƒ! P, Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' (â†‘n) K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is of characteristic `0` and there is a primitive `n`-th root of unity in `K`,\\nthen `cyclotomic n K` comes from a unique polynomial with integer coefficients. \"},\n {\"theorem\":\n  \"âˆ€ {S : Set â„•+} {A : Type u} {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] (x : B), x âˆˆ Algebra.adjoin A {b | âˆƒ n, n âˆˆ S âˆ§ b ^ â†‘n = 1}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`-th roots of unity, for `n âˆˆ S`, generate `B` as an `A`-algebra. \"}]\n",
    "prompt_cons": "/-- If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = âˆ (X - Î¼)`, where `Î¼`\nvaries over the `n`-th roots of unity. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun Î¶ => Polynomial.X - â†‘Polynomial.C Î¶ :=\n\n/-- For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. -/\ntheorem âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- The number of complex roots equals the number of real roots plus\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem âˆ€ (p : Polynomial â„š),\n  Finset.card (Set.toFinset (Polynomial.rootSet p â„‚)) =\n    Finset.card (Set.toFinset (Polynomial.rootSet p â„)) +\n      Finset.card\n        (Equiv.Perm.support\n          (â†‘(Polynomial.Gal.galActionHom p â„‚)\n            (â†‘(Polynomial.Gal.restrict p â„‚) (AlgEquiv.restrictScalars â„š Complex.conjAe)))) :=\n\n/-- The complex `n`-th roots of unity are exactly the\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. -/\ntheorem âˆ€ (n : â„•+) (x : â„‚Ë£), x âˆˆ rootsOfUnity n â„‚ â†” âˆƒ i, i < â†‘n âˆ§ cexp (2 * â†‘Real.pi * Complex.I * (â†‘i / â†‘â†‘n)) = â†‘x :=\n\n/-- **Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root -/\ntheorem âˆ€ {f : Polynomial â„‚}, 0 < Polynomial.degree f â†’ âˆƒ z, Polynomial.IsRoot f z :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`âˆ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’ (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1 :=\n\n/-- The limit of `n / (n + x)` is 1, for any constant `x` (valid in `â„` or any topological division\nalgebra over `â„`, e.g., `â„‚`).\n\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\nstatement simultaneously on `â„š`, `â„` and `â„‚`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : DivisionRing ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : CharZero ğ•œ] [inst_3 : Algebra â„ ğ•œ]\n  [inst_4 : ContinuousSMul â„ ğ•œ] [inst_5 : TopologicalDivisionRing ğ•œ] (x : ğ•œ),\n  Filter.Tendsto (fun n => â†‘n / (â†‘n + x)) Filter.atTop (nhds 1) :=\n\n/-- The constant `C` provided by the definition of `LiouvilleWith` can be made positive.\nWe also add `1 â‰¤ n` to the list of assumptions about the denominator. While it is equivalent to\nthe original statement, the case `n = 0` breaks many arguments. -/\ntheorem âˆ€ {p x : â„},\n  LiouvilleWith p x â†’ âˆƒ C _hâ‚€, âˆƒá¶  (n : â„•) in Filter.atTop, 1 â‰¤ n âˆ§ âˆƒ m, x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < C / â†‘n ^ p :=\n\n/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- The constant term of `cyclotomic n R` is `1` if `2 â‰¤ n`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] {n : â„•}, 1 < n â†’ Polynomial.coeff (Polynomial.cyclotomic n R) 0 = 1 :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R],\n  Polynomial.roots (Polynomial.cyclotomic' n R) = (primitiveRoots n R).val :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic' n K = (X ^ k - 1) /â‚˜ (âˆ i in Nat.properDivisors k, cyclotomic' i K)`. -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’\n      Polynomial.cyclotomic' n K =\n        (Polynomial.X ^ n - 1) /â‚˜ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ (p : Polynomial â„),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1 :=\n\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1 :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic n K = âˆ Î¼ in primitiveRoots n K, (X - C Î¼)`. In particular,\n`cyclotomic n K = cyclotomic' n K` -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  IsPrimitiveRoot Î¶ n â†’\n    Polynomial.cyclotomic n K = Finset.prod (primitiveRoots n K) fun Î¼ => Polynomial.X - â†‘Polynomial.C Î¼ :=\n\n/-- If `K` is of characteristic `0` and there is a primitive `n`-th root of unity in `K`,\nthen `cyclotomic n K` comes from a unique polynomial with integer coefficients. -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] [inst_2 : CharZero K] {Î¶ : K} {n : â„•+},\n  IsPrimitiveRoot Î¶ â†‘n â†’ âˆƒ! P, Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' (â†‘n) K :=\n\n/-- The `n`-th roots of unity, for `n âˆˆ S`, generate `B` as an `A`-algebra. -/\ntheorem âˆ€ {S : Set â„•+} {A : Type u} {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] (x : B), x âˆˆ Algebra.adjoin A {b | âˆƒ n, n âˆˆ S âˆ§ b ^ â†‘n = 1} :=\n\n/-- If `C_0 + C_1/2 + â‹¯ + C_{n-1}/n + C_n/(n+1) = 0`, where `C_0, ..., C_n` are real constants, prove that the equation `C_0 + C_1x + â‹¯ + C_{n-1}x^{n-1} + C_nx^n = 0` has at least one real root between 0 and 1. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R] (C : â„• â†’ R),\n  (Finset.sum (Finset.range (Nat.succ (Nat.succ (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Finset.range (Nat.succ (Nat.pred (Finset.card (Fin",
      "âˆ€ {C : â„• â†’ â„},\n  (âˆ‘ (i : â„•) in Finset.range (n + 1), C i / (â†‘i + 1)) = 0 â†’\n    âˆƒ x _hâ‚€ _hâ‚, (Finset.sum (Finset.range (n + 1)) fun i => C i * x ^ i) = 0 ",
      "âˆ€ (C : â„• â†’ â„), (Finset.sum (Finset.range (n + 1)) fun i => C i / (â†‘i + 1)) = 0 â†’\n  âˆƒ x _hâ‚€ : 0 < x, x < 1 âˆ§ Polynomial.eval x (Finset.sum (Finset.range (n + 1)) fun i => Polynomial.C (C i) * Polynomial.X ^ i) = 0 ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] [inst_1 : LinearOrderedField ğ•œ] [inst_2 : FloorRing ğ•œ],\n  (âˆ€ (C : â„ â†’ ğ•œ), âˆ‘ i in Finset.range (n + 1), C i * â†‘(i) / (â†‘(i + 1))) = 0 â†’\n    âˆƒ x _hâ‚€ _hâ‚, âˆ‘ i in Finset.range (n + 1), C (i) * (x ^ i) = 0 ",
      "âˆ€ {C : â„• â†’ â„},\n  (âˆ‘ (i : â„•) in Finset.range (n + 1), C i / (â†‘i + 1)) = 0 â†’\n    âˆƒ x _hâ‚€ : 0 â‰¤ x, âˆƒ _hâ‚ : x â‰¤ 1, (âˆ‘ (i : â„•) in Finset.range (n + 1), C i * x ^ i) = 0 ",
      "âˆ€ {C : â„• â†’ â„},\n  (âˆ‘ (i : â„•) in Finset.range (n + 2), C i / â†‘(i + 1)) = 0 â†’\n    (âˆƒ x _hâ‚€ _hâ‚, (âˆ‘ (i : â„•) in Finset.range (n + 1), C i * x ^ i) = 0) ",
      "âˆ€ (C : â„• â†’ â„),\n  (âˆ‘ i in Finset.range (n + 1), C i / (â†‘i + 1)) = 0 â†’\n    âˆƒ x âˆˆ Set.Icc (0 : â„) 1, Polynomial.eval x (Finset.sum (Finset.range (n + 1)) (Polynomial.monomial âˆ˜ nat.succ)) = 0 ",
      "âˆ€ {C : â„• â†’ â„},\n  (âˆ‘ n in Finset.range (Nat.succ (Nat.succ n)), C n / (â†‘n + 1)) = 0 â†’\n    âˆƒ x âˆˆ Set.Icc (0 : â„) 1, (âˆ‘ n in Finset.range (Nat.succ (Nat.succ n)), C n * x ^ n) = 0 ",
      "âˆ€ {C : â„• â†’ â„},\n  (âˆ‘ n, C n / (â†‘n + 1)) = 0 â†’\n    âˆƒ x _hâ‚€ _hâ‚, (Finset.sum (Finset.range (Nat.succ (Nat.succ _))) fun x_1 => C x_1 * x ^ x_1) = 0 ",
      "âˆ€ {n : â„•} {C : â„• â†’ â„},\n  (âˆ€ i, C i â‰  0) â†’\n  (C 0 + (âˆ‘ i in Finset.range n, C (i + 1) / (â†‘i + 1)) + C (n + 1) / (â†‘n + 1) = 0) â†’\n  âˆƒ x _hâ‚€ _hâ‚, Polynomial.eval x (Finset.sum (Finset.range (n + 2)) fun i => â†‘Polynomial.C (C i) * Polynomial.X ^ i) = 0 "
    ]
  },
  {
    "docString": "Suppose (a) `f` is continuous for `x â‰¥ 0`, (b) `f'(x)` exists for `x > 0`, (c) `f(0) = 0`, (d) `f'` is monotonically increasing. Put `g(x) = f(x)/x` for `(x > 0)` and prove that `g` is monotonically increasing.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\\n  (âˆ€ (Z : C) (g : Z âŸ¶ X), CategoryTheory.CategoryStruct.comp g f = 0 â†’ g = 0) â†’ CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g â‰« f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\\n  (âˆ€ (Z : C) (g : Y âŸ¶ Z), CategoryTheory.CategoryStruct.comp f g = 0 â†’ g = 0) â†’ CategoryTheory.Epi f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f â‰« g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x)\",\n  \"isProp\": true,\n  \"docString\": \"`x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {Î² : Type u_1} [inst_1 : Preorder Î²] {f g : Î± â†’ Î²},\\n  Monotone f â†’ Antitone g â†’ f â‰¤ g â†’ âˆ€ (m n : Î±), f m â‰¤ g n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is monotone, `g` is antitone, and `f â‰¤ g`, then for all `a`, `b` we have `f a â‰¤ g b`. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C â‰¤ deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `C â‰¤ f'`, then `f` grows at least as fast\\nas `C * x`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\\n  ContinuousAt g a â†’\\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\\nan inverse function. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhdsWithin a (Set.Ici a) â†’\\n      (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousWithinAt f (Set.Ici a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a function strictly monotone on a right neighborhood of `a` and the\\nimage of this neighborhood under `f` meets every interval `(f a, b]`, `b > f a`, then `f` is\\ncontinuous at `a` from the right.\\n\\nThe assumption `hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b` is required because otherwise the\\nfunction `f : â„ â†’ â„` given by `f x = if x â‰¤ 0 then x else x + 1` would be a counter-example at\\n`a = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  MonotoneOn f s â†’\\n    s âˆˆ nhds a â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\\nis continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C < deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x < y â†’ C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `C < f'`, then `f` grows faster than\\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ},\\n  ContinuousAt g a â†’\\n    HasStrictDerivAt f f' (g a) â†’ f' â‰  0 â†’ (âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) â†’ HasStrictDerivAt g f'â»Â¹ a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\\nin the strict sense.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\\ninverse function. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’ (âˆ€ (x : â„), x âˆˆ interior D â†’ 0 â‰¤ deriv f x) â†’ MonotoneOn f D\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is nonnegative, then\\n`f` is a monotone function on `D`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. \"}]\n",
    "prompt_cons": "/-- If `g â‰« f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. -/\ntheorem âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\n  (âˆ€ (Z : C) (g : Z âŸ¶ X), CategoryTheory.CategoryStruct.comp g f = 0 â†’ g = 0) â†’ CategoryTheory.Mono f :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- If `f â‰« g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. -/\ntheorem âˆ€ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y),\n  (âˆ€ (Z : C) (g : Y âŸ¶ Z), CategoryTheory.CategoryStruct.comp f g = 0 â†’ g = 0) â†’ CategoryTheory.Epi f :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f :=\n\n/-- `x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- If `f` is monotone, `g` is antitone, and `f â‰¤ g`, then for all `a`, `b` we have `f a â‰¤ g b`. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {Î² : Type u_1} [inst_1 : Preorder Î²] {f g : Î± â†’ Î²},\n  Monotone f â†’ Antitone g â†’ f â‰¤ g â†’ âˆ€ (m n : Î±), f m â‰¤ g n :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y âˆˆ D`,\n`x < y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x < y â†’ C * (y - x) < f y - f x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' â‰¤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `C â‰¤ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C â‰¤ deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\n  ContinuousAt g a â†’\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a :=\n\n/-- If `f` is a function strictly monotone on a right neighborhood of `a` and the\nimage of this neighborhood under `f` meets every interval `(f a, b]`, `b > f a`, then `f` is\ncontinuous at `a` from the right.\n\nThe assumption `hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b` is required because otherwise the\nfunction `f : â„ â†’ â„` given by `f x = if x â‰¤ 0 then x else x + 1` would be a counter-example at\n`a = 0`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhdsWithin a (Set.Ici a) â†’\n      (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousWithinAt f (Set.Ici a) a :=\n\n/-- If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\nis continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  MonotoneOn f s â†’\n    s âˆˆ nhds a â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `C < f'`, then `f` grows faster than\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C < deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x < y â†’ C * (y - x) < f y - f x :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\nin the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ},\n  ContinuousAt g a â†’\n    HasStrictDerivAt f f' (g a) â†’ f' â‰  0 â†’ (âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) â†’ HasStrictDerivAt g f'â»Â¹ a :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is nonnegative, then\n`f` is a monotone function on `D`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’ (âˆ€ (x : â„), x âˆˆ interior D â†’ 0 â‰¤ deriv f x) â†’ MonotoneOn f D :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- Suppose (a) `f` is continuous for `x â‰¥ 0`, (b) `f'(x)` exists for `x > 0`, (c) `f(0) = 0`, (d) `f'` is monotonically increasing. Put `g(x) = f(x)/x` for `(x > 0)` and prove that `g` is monotonically increasing. -/\ntheorem",
    "choices": [
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        MonotoneOn (deriv f) (Set.Ioi 0) â†’ MonotoneOn (Î» x, f x / x) (Set.Ioi 0) ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        MonotoneOn (deriv f) (Set.Ioi 0) â†’\n          MonotoneOn (Î» x, f x / x) (Set.Ioi 0) ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        Monotone (deriv f) â†’ âˆ€ â¦ƒx y : â„â¦„, 0 < x â†’ x â‰¤ y â†’ f x / x â‰¤ f y / y ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        MonotoneOn (deriv f) (Set.Ioi 0) â†’\n          MonotoneOn (fun x => f x / x) (Set.Ioi 0) ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        MonotoneOn (deriv f) (Set.Ioi 0) â†’\n          MonotoneOn (Î» (x : â„), f x / x) (Set.Ioi 0) ",
      "âˆ€ {f f' : â„ â†’ â„},\n  (âˆ€ x, 0 â‰¤ x â†’ ContinuousAt f x) â†’\n    (âˆ€ x, 0 < x â†’ HasDerivAt f (f' x) x) â†’\n      f 0 = 0 â†’\n        Monotone f' â†’\n          Monotone (Î» x, f x / x) ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n  DifferentiableOn â„ f (Set.Ioi 0) â†’\n  f 0 = 0 â†’ \n  MonotoneOn (deriv f) (Set.Ioi 0) â†’\n  MonotoneOn (Î» x, f x / x) (Set.Ioi 0) ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n    DifferentiableOn â„ f (Set.Ioi 0) â†’\n      f 0 = 0 â†’\n        MonotoneOn (deriv f) (Set.Ioi 0) â†’\n          MonotoneOn (Î» x, f x / x) (Set.Ioi 0) ",
      "âˆ€ {f : â„ â†’ â„},\n  (âˆ€ x, 0 â‰¤ x â†’ ContinuousAt f x) â†’\n  (âˆ€ x, 0 < x â†’ DifferentiableAt â„ f x) â†’\n  f 0 = 0 â†’\n  (âˆ€ x y, 0 < x â†’ x < y â†’ deriv f x â‰¤ deriv f y) â†’\n  âˆ€ â¦ƒx y : â„â¦„,\n    0 < x â†’ x < y â†’ (f x) / x â‰¤ (f y) / y ",
      "âˆ€ {f : â„ â†’ â„},\n  ContinuousOn f (Set.Ici 0) â†’\n  DifferentiableOn â„ f (Set.Ioi 0) â†’\n  f 0 = 0 â†’\n  MonotoneOn (deriv f) (Set.Ioi 0) â†’\n  MonotoneOn (Î» x, f x / x) (Set.Ioi 0) "
    ]
  },
  {
    "docString": "Suppose `a âˆˆ â„^1`, `f` is a twice-differentiable real function on `(a, âˆ)`, and `M_0, M_1, M_2` are the least upper bounds of `|f(x)|`, `|f'(x)|`, `|f''(x)|`, respectively, on `(a, âˆ)`. Prove that `M_1^2 â‰¤ 4 M_0 M_2`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {p : â„} {f g : Î± â†’ ENNReal},\\n  AEMeasurable f â†’\\n    AEMeasurable g â†’\\n      1 â‰¤ p â†’\\n        (âˆ«â» (a : Î±), (f + g) a ^ p âˆ‚Î¼) ^ (1 / p) â‰¤\\n          (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) + (âˆ«â» (a : Î±), g a ^ p âˆ‚Î¼) ^ (1 / p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Minkowski's inequality for functions `Î± â†’ â„â‰¥0âˆ`: the `â„’p` seminorm of the sum of two\\nfunctions is bounded by the sum of their `â„’p` seminorms. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C â‰¤ deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `C â‰¤ f'`, then `f` grows at least as fast\\nas `C * x`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„},\\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {f f' : â„ â†’ â„},\\n  a â‰¤ b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a â‰¤ b` and `f' a â‰¤ m â‰¤ f' b`, then `f' c = m` for some\\n`c âˆˆ [a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f' x â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x â‰¤ B' x` on `[a, b)`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `â„`, and `f''` is nonnegative on `â„`,\\nthen `f` is convex on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f f' : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        f a â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {f f' : â„ â†’ â„},\\n  a â‰¤ b â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a â‰¤ b` and `f' b â‰¤ m â‰¤ f' a`, then `f' c = m` for some\\n`c âˆˆ [a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        â€–f aâ€– â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ â€–f xâ€– = B x â†’ â€–f' xâ€– < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ â€–f xâ€– â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the norm of the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `â€–f aâ€– â‰¤ B a`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* the norm of `f'` is strictly less than `B'` whenever `â€–f xâ€– = B x`.\\n\\nThen `â€–f xâ€– â‰¤ B x` everywhere on `[a, b]`. We use one-sided derivatives in the assumptions\\nto make this theorem work for piecewise differentiable functions.\\n\"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : â„ â†’ E),\\n  Filter.Tendsto (Real.fourierIntegral f) (Filter.cocompact â„) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Riemann-Lebesgue lemma for functions on `â„`, formulated via `Real.fourierIntegral`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        â€–f aâ€– â‰¤ B a â†’\\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ â€–f' xâ€– â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ â€–f xâ€– â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the norm of the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `â€–f aâ€– â‰¤ B a`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* `B` has derivative `B'` everywhere on `â„`;\\n* we have `â€–f' xâ€– â‰¤ B x` everywhere on `[a, b)`.\\n\\nThen `â€–f xâ€– â‰¤ B x` everywhere on `[a, b]`. We use one-sided derivatives in the assumptions\\nto make this theorem work for piecewise differentiable functions.\\n\"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ 0 â‰¤ z.re â†’ z.im â‰¤ 0 â†’ â€–f zâ€– â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the fourth quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open fourth quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open fourth quadrant\\n  for some `c < 2`;\\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the fourth quadrant.\\n\\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed fourth quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} {E : Type u_1} [inst : NormedAddCommGroup E] {f : â„ â†’ E} {f' : â„ â†’ â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    (âˆ€ (x : â„),\\n        x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope (norm âˆ˜ f) x z < r) â†’\\n      âˆ€ {B B' : â„ â†’ â„},\\n        â€–f aâ€– â‰¤ B a â†’\\n          ContinuousOn B (Set.Icc a b) â†’\\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ â€–f xâ€– = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ â€–f xâ€– â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `â€–f aâ€– â‰¤ B a`;\\n* `B` has right derivative at every point of `[a, b)`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(â€–f zâ€– - â€–f xâ€–) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `â€–f xâ€– = B x`.\\n\\nThen `â€–f xâ€– â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {a b : â„},\\n  ContinuousOn f (Set.Icc a b) â†’\\n    âˆ€ {B B' : â„ â†’ â„},\\n      f a â‰¤ B a â†’\\n        ContinuousOn B (Set.Icc a b) â†’\\n          (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\\n            (âˆ€ (x : â„),\\n                x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), B' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\\n              âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a â‰¤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by `B'`.\\n\\nThen `f x â‰¤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±},\\n  m â‰¤ m0 â†’\\n    âˆ€ {f g : Î± â†’ â„},\\n      MeasureTheory.StronglyMeasurable f â†’\\n        MeasureTheory.IntegrableOn f s â†’\\n          MeasureTheory.StronglyMeasurable g â†’\\n            MeasureTheory.IntegrableOn g s â†’\\n              (âˆ€ (t : Set Î±), MeasurableSet t â†’ â†‘â†‘Î¼ t < âŠ¤ â†’ âˆ« (x : Î±) in t, g x âˆ‚Î¼ = âˆ« (x : Î±) in t, f x âˆ‚Î¼) â†’\\n                MeasurableSet s â†’ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ âˆ« (x : Î±) in s, â€–g xâ€– âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, â€–f xâ€– âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `m` be a sub-Ïƒ-algebra of `m0`, `f` an `m0`-measurable function and `g` an `m`-measurable\\nfunction, such that their integrals coincide on `m`-measurable sets with finite measure.\\nThen `âˆ« x in s, â€–g xâ€– âˆ‚Î¼ â‰¤ âˆ« x in s, â€–f xâ€– âˆ‚Î¼` on all `m`-measurable sets with finite measure. \"}]\n",
    "prompt_cons": "/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- Minkowski's inequality for functions `Î± â†’ â„â‰¥0âˆ`: the `â„’p` seminorm of the sum of two\nfunctions is bounded by the sum of their `â„’p` seminorms. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {p : â„} {f g : Î± â†’ ENNReal},\n  AEMeasurable f â†’\n    AEMeasurable g â†’\n      1 â‰¤ p â†’\n        (âˆ«â» (a : Î±), (f + g) a ^ p âˆ‚Î¼) ^ (1 / p) â‰¤\n          (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) + (âˆ«â» (a : Î±), g a ^ p âˆ‚Î¼) ^ (1 / p) :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `C â‰¤ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), C â‰¤ deriv f x) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f' â‰¤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x â‰¤ C * (y - x)` whenever `x â‰¤ y`. -/\ntheorem âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’ âˆ€ {C : (fun x => â„) 1}, (âˆ€ (x : â„), deriv f x â‰¤ C) â†’ âˆ€ â¦ƒx y : â„â¦„, x â‰¤ y â†’ f y - f x â‰¤ C * (y - x) :=\n\n/-- For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\nintegral. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) (f : Î± â†’ ENNReal),\n  âˆƒ g, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼ :=\n\n/-- **Darboux's theorem**: if `a â‰¤ b` and `f' a â‰¤ m â‰¤ f' b`, then `f' c = m` for some\n`c âˆˆ [a, b]`. -/\ntheorem âˆ€ {a b : â„} {f f' : â„ â†’ â„},\n  a â‰¤ b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x â‰¤ B' x` on `[a, b)`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f' x â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- If a function `f` is twice differentiable on `â„`, and `f''` is nonnegative on `â„`,\nthen `f` is convex on `â„`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’ (âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) â†’ ConvexOn â„ Set.univ f :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has derivative `B'` everywhere on `â„`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f f' : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        f a â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ f x = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- **Darboux's theorem**: if `a â‰¤ b` and `f' b â‰¤ m â‰¤ f' a`, then `f' c = m` for some\n`c âˆˆ [a, b]`. -/\ntheorem âˆ€ {a b : â„} {f f' : â„ â†’ â„},\n  a â‰¤ b â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) â†’\n      âˆ€ {m : â„}, f' a â‰¤ m â†’ m â‰¤ f' b â†’ m âˆˆ f' '' Set.Icc a b :=\n\n/-- General fencing theorem for continuous functions with an estimate on the norm of the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `â€–f aâ€– â‰¤ B a`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* `B` has derivative `B'` everywhere on `â„`;\n* the norm of `f'` is strictly less than `B'` whenever `â€–f xâ€– = B x`.\n\nThen `â€–f xâ€– â‰¤ B x` everywhere on `[a, b]`. We use one-sided derivatives in the assumptions\nto make this theorem work for piecewise differentiable functions. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        â€–f aâ€– â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ â€–f xâ€– = B x â†’ â€–f' xâ€– < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ â€–f xâ€– â‰¤ B x :=\n\n/-- The Riemann-Lebesgue lemma for functions on `â„`, formulated via `Real.fourierIntegral`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : â„ â†’ E),\n  Filter.Tendsto (Real.fourierIntegral f) (Filter.cocompact â„) (nhds 0) :=\n\n/-- General fencing theorem for continuous functions with an estimate on the norm of the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `â€–f aâ€– â‰¤ B a`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* `B` has derivative `B'` everywhere on `â„`;\n* we have `â€–f' xâ€– â‰¤ B x` everywhere on `[a, b)`.\n\nThen `â€–f xâ€– â‰¤ B x` everywhere on `[a, b]`. We use one-sided derivatives in the assumptions\nto make this theorem work for piecewise differentiable functions. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        â€–f aâ€– â‰¤ B a â†’\n          (âˆ€ (x : â„), HasDerivAt B (B' x) x) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ â€–f' xâ€– â‰¤ B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ â€–f xâ€– â‰¤ B x :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the fourth quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open fourth quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open fourth quadrant\n  for some `c < 2`;\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of the fourth quadrant.\n\nThen `â€–f zâ€–` is bounded from above by the same constant on the closed fourth quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚},\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f â†‘xâ€– â‰¤ C) â†’ (âˆ€ (x : â„), x â‰¤ 0 â†’ â€–f (â†‘x * Complex.I)â€– â‰¤ C) â†’ 0 â‰¤ z.re â†’ z.im â‰¤ 0 â†’ â€–f zâ€– â‰¤ C :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `â€–f aâ€– â‰¤ B a`;\n* `B` has right derivative at every point of `[a, b)`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(â€–f zâ€– - â€–f xâ€–) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `â€–f xâ€– = B x`.\n\nThen `â€–f xâ€– â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {a b : â„} {E : Type u_1} [inst : NormedAddCommGroup E] {f : â„ â†’ E} {f' : â„ â†’ â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    (âˆ€ (x : â„),\n        x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope (norm âˆ˜ f) x z < r) â†’\n      âˆ€ {B B' : â„ â†’ â„},\n        â€–f aâ€– â‰¤ B a â†’\n          ContinuousOn B (Set.Icc a b) â†’\n            (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n              (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ â€–f xâ€– = B x â†’ f' x < B' x) â†’ âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ â€–f xâ€– â‰¤ B x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a â‰¤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x âˆˆ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by `B'`.\n\nThen `f x â‰¤ B x` everywhere on `[a, b]`. -/\ntheorem âˆ€ {f : â„ â†’ â„} {a b : â„},\n  ContinuousOn f (Set.Icc a b) â†’\n    âˆ€ {B B' : â„ â†’ â„},\n      f a â‰¤ B a â†’\n        ContinuousOn B (Set.Icc a b) â†’\n          (âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt B (B' x) (Set.Ici x) x) â†’\n            (âˆ€ (x : â„),\n                x âˆˆ Set.Ico a b â†’ âˆ€ (r : â„), B' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), slope f x z < r) â†’\n              âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Icc a b â†’ f x â‰¤ B x :=\n\n/-- Let `m` be a sub-Ïƒ-algebra of `m0`, `f` an `m0`-measurable function and `g` an `m`-measurable\nfunction, such that their integrals coincide on `m`-measurable sets with finite measure.\nThen `âˆ« x in s, â€–g xâ€– âˆ‚Î¼ â‰¤ âˆ« x in s, â€–f xâ€– âˆ‚Î¼` on all `m`-measurable sets with finite measure. -/\ntheorem âˆ€ {Î± : Type u_1} {m m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±},\n  m â‰¤ m0 â†’\n    âˆ€ {f g : Î± â†’ â„},\n      MeasureTheory.StronglyMeasurable f â†’\n        MeasureTheory.IntegrableOn f s â†’\n          MeasureTheory.StronglyMeasurable g â†’\n            MeasureTheory.IntegrableOn g s â†’\n              (âˆ€ (t : Set Î±), MeasurableSet t â†’ â†‘â†‘Î¼ t < âŠ¤ â†’ âˆ« (x : Î±) in t, g x âˆ‚Î¼ = âˆ« (x : Î±) in t, f x âˆ‚Î¼) â†’\n                MeasurableSet s â†’ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ âˆ« (x : Î±) in s, â€–g xâ€– âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, â€–f xâ€– âˆ‚Î¼ :=\n\n/-- Suppose `a âˆˆ â„^1`, `f` is a twice-differentiable real function on `(a, âˆ)`, and `M_0, M_1, M_2` are the least upper bounds of `|f(x)|`, `|f'(x)|`, `|f''(x)|`, respectively, on `(a, âˆ)`. Prove that `M_1^2 â‰¤ 4 M_0 M_2`. -/\ntheorem",
    "choices": [
      "forall {a : â„} {f : â„ â†’ â„} {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n  Differentiable â„ f â†’ Differentiable â„ (deriv f) â†’\n    (âˆ€ x, a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n      (âˆ€ x, a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n        (âˆ€ x, a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {a : â„} {f : â„ â†’ â„} {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n  Differentiable â„ f â†’\n    Differentiable â„ (deriv f) â†’\n      (âˆ€ x, a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n        (âˆ€ x, a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n          (âˆ€ x, a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„} {a : â„},\n  Differentiable â„ f â†’\n    Differentiable â„ (deriv f) â†’\n      âˆ€ {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n        (âˆ€ (x : â„), a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n          (âˆ€ (x : â„), a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ (x : â„), a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„} {a : â„},\n  Differentiable â„ (deriv f) â†’\n    âˆ€ {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n      (âˆ€ (x : â„), a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n        (âˆ€ (x : â„), a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n          (âˆ€ (x : â„), a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {a : â„} {f : â„ â†’ â„} {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n  DifferentiableOn â„ f (Set.Ioi a) â†’\n    DifferentiableOn â„ (deriv f) (Set.Ioi a) â†’\n      (âˆ€ (x : â„), x > a â†’ abs (f x) â‰¤ Mâ‚€) â†’\n        (âˆ€ (x : â„), x > a â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n          (âˆ€ (x : â„), x > a â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ (a : â„) (f : â„ â†’ â„),\n  Differentiable â„ f â†’\n    Differentiable â„ (deriv f) â†’\n      (âˆƒ M_0 M_1 M_2,\n         (âˆ€ x, a < x â†’ abs (f x) â‰¤ M_0) âˆ§\n         (âˆ€ x, a < x â†’ abs (deriv f x) â‰¤ M_1) âˆ§\n         (âˆ€ x, a < x â†’ abs (deriv^[2] f x) â‰¤ M_2)) â†’\n        âˆ€ M_0 M_1 M_2, M_1 ^ 2 â‰¤ 4 * M_0 * M_2",
      "âˆ€ {a : â„} {f : â„ â†’ â„},\n  Differentiable â„ (deriv f) â†’\n    (âˆ€ (x : â„), a < x â†’ HasDerivWithinAt f (deriv f x) (Set.Ioi a) x) â†’\n      âˆ€ {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n        (âˆ€ (x : â„), a < x â†’ (abs (f x)) â‰¤ Mâ‚€) â†’\n          (âˆ€ (x : â„), a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ (x : â„), a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„} {a : â„},\n  (âˆ€ (x : â„), a < x â†’ Differentiable â„ f x) â†’\n    (âˆ€ (x : â„), a < x â†’ Differentiable â„ (deriv f) x) â†’\n      âˆ€ {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n        (âˆ€ (x : â„), a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n          (âˆ€ (x : â„), a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ (x : â„), a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {f : â„ â†’ â„} {a : â„},\n  Differentiable â„ (deriv f) â†’\n    (âˆ€ x, a < x â†’ HasDerivWithinAt f (deriv f x) (Set.Ioi a) x) â†’\n      âˆ€ {Mâ‚€ Mâ‚ Mâ‚‚ : â„},\n        (âˆ€ x, a < x â†’ abs (f x) â‰¤ Mâ‚€) â†’\n          (âˆ€ x, a < x â†’ abs (deriv f x) â‰¤ Mâ‚) â†’\n            (âˆ€ x, a < x â†’ abs (deriv^[2] f x) â‰¤ Mâ‚‚) â†’ Mâ‚ ^ 2 â‰¤ 4 * Mâ‚€ * Mâ‚‚ ",
      "âˆ€ {a : â„} {f : â„ â†’ â„},\n  Differentiable â„ (deriv f) â†’\n    (âˆ€ (z : â„), a < z â†’ âˆ€ (x : â„), x âˆˆ Set.Ioi z â†’ deriv^[2] f x â‰  âŠ¤) â†’\n      (âˆƒ M_0,\n          âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Ioi a â†’ abs (f x) â‰¤ M_0) â†’\n        (âˆƒ M_1,\n            âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Ioi a â†’ abs (deriv f x) â‰¤ M_1) â†’\n          (âˆƒ M_2,\n              âˆ€ â¦ƒx : â„â¦„, x âˆˆ Set.Ioi a â†’ abs (deriv^[2] f x) â‰¤ M_2) â†’ âˆ€ (M_0 M_1 M_2 : â„), M_1 ^ 2 â‰¤ 4 * M_0 * M_2 "
    ]
  },
  {
    "docString": "Let `X` be a topological space; let `A` be a subset of `X`. Suppose that for each `x âˆˆ A` there is an open set `U` containing `x` such that `U âŠ† A`. Show that `A` is open in `X`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T0Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ Set.Nonempty s â†’ IsOpen s â†’ âˆƒ x, x âˆˆ s âˆ§ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open finite set `S` in a Tâ‚€ space, there is some `x âˆˆ S` such that `{x}` is open. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [inst_1 : DiscreteTopology â†‘s] {x : Î±},\\n  x âˆˆ s â†’ âˆƒ U, U âˆˆ nhdsWithin x {x}á¶œ âˆ§ Disjoint U s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For point `x` in a discrete subset `s` of a topological space, there is a set `U`\\nsuch that\\n1. `U` is a punctured neighborhood of `x` (ie. `U âˆª {x}` is a neighbourhood of `x`),\\n2. `U` is disjoint from `s`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} (self : TopologicalSpace.OpenNhdsOf x), x âˆˆ self.carrier\",\n  \"isProp\": true,\n  \"docString\":\n  \"The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `K * V âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {s : Set X} [inst_1 : NormalSpace X]\\n  [inst_2 : ParacompactSpace X],\\n  IsClosed s â†’\\n    âˆ€ (U : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ âˆƒ f, PartitionOfUnity.IsSubordinate f U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\\n`s`, then there exists a `PartitionOfUnity Î¹ X s` that is subordinate to `U`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `V * K âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {s : Set X} [inst_1 : NormalSpace X]\\n  [inst_2 : ParacompactSpace X],\\n  IsClosed s â†’ âˆ€ (U : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ âˆƒ f, BumpCovering.IsSubordinate f U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\\n`s`, then there exists a `BumpCovering Î¹ X s` that is subordinate to `U`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\\nsecond countable, then there exists a countable family of open sets in `X` that separates points\\nof `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"A reformulation of the definition of locally compact space: In a locally compact space,\\nevery open set containing `x` has a compact subset containing `x` in its interior. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\\nsuch that `VV âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {s : Set X} [inst_1 : NormalSpace X],\\n  IsClosed s â†’\\n    âˆ€ (U : Î¹ â†’ Set X),\\n      (âˆ€ (i : Î¹), IsOpen (U i)) â†’ LocallyFinite U â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ âˆƒ f, PartitionOfUnity.IsSubordinate f U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a normal topological space and `U` is a locally finite open covering of a closed set\\n`s`, then there exists a `PartitionOfUnity Î¹ X s` that is subordinate to `U`. If `X` is a\\nparacompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\\n`BumpCovering.exists_isSubordinate`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V âŠ† U`.\"}]\n",
    "prompt_cons": "/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- Given an open finite set `S` in a Tâ‚€ space, there is some `x âˆˆ S` such that `{x}` is open. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T0Space Î±] {s : Set Î±},\n  Set.Finite s â†’ Set.Nonempty s â†’ IsOpen s â†’ âˆƒ x, x âˆˆ s âˆ§ IsOpen {x} :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U :=\n\n/-- For point `x` in a discrete subset `s` of a topological space, there is a set `U`\nsuch that\n1. `U` is a punctured neighborhood of `x` (ie. `U âˆª {x}` is a neighbourhood of `x`),\n2. `U` is disjoint from `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [inst_1 : DiscreteTopology â†‘s] {x : Î±},\n  x âˆˆ s â†’ âˆƒ U, U âˆˆ nhdsWithin x {x}á¶œ âˆ§ Disjoint U s :=\n\n/-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} (self : TopologicalSpace.OpenNhdsOf x), x âˆˆ self.carrier :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V) :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `K * V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U :=\n\n/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `PartitionOfUnity Î¹ X s` that is subordinate to `U`. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {s : Set X} [inst_1 : NormalSpace X]\n  [inst_2 : ParacompactSpace X],\n  IsClosed s â†’\n    âˆ€ (U : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ âˆƒ f, PartitionOfUnity.IsSubordinate f U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `V * K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U :=\n\n/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `BumpCovering Î¹ X s` that is subordinate to `U`. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {s : Set X} [inst_1 : NormalSpace X]\n  [inst_2 : ParacompactSpace X],\n  IsClosed s â†’ âˆ€ (U : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ âˆƒ f, BumpCovering.IsSubordinate f U :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\nsecond countable, then there exists a countable family of open sets in `X` that separates points\nof `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,\nevery open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U :=\n\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U :=\n\n/-- If `X` is a normal topological space and `U` is a locally finite open covering of a closed set\n`s`, then there exists a `PartitionOfUnity Î¹ X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {s : Set X} [inst_1 : NormalSpace X],\n  IsClosed s â†’\n    âˆ€ (U : Î¹ â†’ Set X),\n      (âˆ€ (i : Î¹), IsOpen (U i)) â†’ LocallyFinite U â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ âˆƒ f, PartitionOfUnity.IsSubordinate f U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U :=\n\n/-- Let `X` be a topological space; let `A` be a subset of `X`. Suppose that for each `x âˆˆ A` there is an open set `U` containing `x` such that `U âŠ† A`. Show that `A` is open in `X`. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, x âˆˆ U âˆ§ IsOpen U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x, x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x âˆˆ A, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ x, x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A ",
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] {A : Set X},\n  (âˆ€ (x : X), x âˆˆ A â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† A) â†’ IsOpen A "
    ]
  },
  {
    "docString": "If `T_Î±` is a family of topologies on `X`, show that `âˆ© T_Î±` is a topology on `X`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\\n  (F : Î¹ â†’ C(Î±, Î²)),\\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\\nit converges in the compact-open topology on each compact subset of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²],\\n  Inducing (â†‘UniformFun.ofFun âˆ˜ FunLike.coe)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on `Î± â†’áµ‡ Î²` is exactly the topology induced by the natural map to `Î± â†’áµ¤ Î²`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\\n  ContinuousMap.compactOpen =\\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ âˆ€ {s : Set Î±}, IsCompact s â†’ Set.Finite {i | Set.Nonempty (f i âˆ© s)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a compact set in a topological space `Î±` and `f : Î¹ â†’ Set Î±` is a locally finite\\nfamily of sets, then `f i âˆ© s` is nonempty only for a finitely many `i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\\n  TopologicalSpace.IsTopologicalBasis s â†’\\n    âˆ€ {t : Set (Set Î²)},\\n      TopologicalSpace.IsTopologicalBasis t â†’\\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\\ntopological bases on each of the two components. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (s : Set Î±),\\n  Continuous fun F => ContinuousMap.restrict s F\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any subset `s` of `Î±`, the restriction of continuous functions to `s` is continuous as a\\nfunction from `C(Î±, Î²)` to `C(s, Î²)` with their respective compact-open topologies. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T0Space Î±] {f : Î± â†’ Î²},\\n  Inducing f â†’ Function.Injective f\",\n  \"isProp\": true,\n  \"docString\": \"A topology `Inducing` map from a Tâ‚€ space is injective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} (s : Î¹ â†’ Set Î±),\\n  Filter.HasBasis (â¨… (i : Î¹), Filter.principal (s i)) (fun t => Set.Finite t) fun t => â‹‚ (i : Î¹) (_ : i âˆˆ t), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s : Î¹ â†’ Set Î±` is an indexed family of sets, then finite intersections of `s i` form a basis\\nof `â¨… i, ğ“Ÿ (s i)`.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] (b : Î¹ â†’ Set Î±),\\n  TopologicalSpace.IsTopologicalBasis (Set.range b) â†’\\n    (âˆ€ (i : Î¹), IsCompact (b i)) â†’\\n      âˆ€ (U : Set Î±), IsCompact U âˆ§ IsOpen U â†” âˆƒ s, Set.Finite s âˆ§ U = â‹ƒ (i : Î¹) (_ : i âˆˆ s), b i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` has a basis consisting of compact opens, then an open set in `Î±` is compact open iff\\nit is a finite union of some elements in the basis \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {Î³ : Type u_1}\\n  [inst_2 : AddCommMonoid Î²] [inst_3 : ContinuousAdd Î²] {f : Î³ â†’ C(Î±, Î²)} {g : C(Î±, Î²)},\\n  HasSum f g â†’ âˆ€ (x : Î±), HasSum (fun i => â†‘(f i) x) (â†‘g x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is locally compact, and an infinite sum of functions in `C(Î±, Î²)`\\nconverges to `g` (for the compact-open topology), then the pointwise sum converges to `g x` for\\nall `x âˆˆ Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T0Space Î±] {f : Î± â†’ Î²},\\n  Inducing f â†’ Embedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topology `Inducing` map from a Tâ‚€ space is a topological embedding. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type ua} [inst : UniformSpace Î±] {s : Set (Î± Ã— Î±)},\\n  s âˆˆ uniformity Î± â†’ âˆ€á¶  (t : Set (Î± Ã— Î±)) in Filter.smallSets (uniformity Î±), compRel t t âŠ† s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s âˆˆ ğ“¤ Î±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ğ“¤ Î±`,\\nwe have `t â—‹ t âŠ† s`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\\nsecond countable, then there exists a countable family of open sets in `X` that separates points\\nof `s`. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) (Î² : Type u_1) [t : TopologicalSpace Î²] [inst : TopologicalSpace.SecondCountableTopology Î²] (f : Î± â†’ Î²),\\n  TopologicalSpace.SecondCountableTopology Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î²` is a second-countable space, then its induced topology via\\n`f` on `Î±` is also second-countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : AddGroup Î±] [inst_2 : TopologicalAddGroup Î±],\\n  TopologicalAddGroup Î±áµƒáµ’áµ–\",\n  \"isProp\": true,\n  \"docString\": \"If addition is continuous in `Î±`, then it also is in `Î±áµƒáµ’áµ–`.\"}]\n",
    "prompt_cons": "/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–) :=\n\n/-- A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\n  (F : Î¹ â†’ C(Î±, Î²)),\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f) :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- The topology on `Î± â†’áµ‡ Î²` is exactly the topology induced by the natural map to `Î± â†’áµ¤ Î²`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²],\n  Inducing (â†‘UniformFun.ofFun âˆ˜ FunLike.coe) :=\n\n/-- The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  ContinuousMap.compactOpen =\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen :=\n\n/-- If `s` is a compact set in a topological space `Î±` and `f : Î¹ â†’ Set Î±` is a locally finite\nfamily of sets, then `f i âˆ© s` is nonempty only for a finitely many `i`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ âˆ€ {s : Set Î±}, IsCompact s â†’ Set.Finite {i | Set.Nonempty (f i âˆ© s)} :=\n\n/-- In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis s â†’\n    âˆ€ {t : Set (Set Î²)},\n      TopologicalSpace.IsTopologicalBasis t â†’\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- For any subset `s` of `Î±`, the restriction of continuous functions to `s` is continuous as a\nfunction from `C(Î±, Î²)` to `C(s, Î²)` with their respective compact-open topologies. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (s : Set Î±),\n  Continuous fun F => ContinuousMap.restrict s F :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- A topology `Inducing` map from a Tâ‚€ space is injective. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T0Space Î±] {f : Î± â†’ Î²},\n  Inducing f â†’ Function.Injective f :=\n\n/-- If `s : Î¹ â†’ Set Î±` is an indexed family of sets, then finite intersections of `s i` form a basis\nof `â¨… i, ğ“Ÿ (s i)`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} (s : Î¹ â†’ Set Î±),\n  Filter.HasBasis (â¨… (i : Î¹), Filter.principal (s i)) (fun t => Set.Finite t) fun t => â‹‚ (i : Î¹) (_ : i âˆˆ t), s i :=\n\n/-- If `Î±` has a basis consisting of compact opens, then an open set in `Î±` is compact open iff\nit is a finite union of some elements in the basis -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] (b : Î¹ â†’ Set Î±),\n  TopologicalSpace.IsTopologicalBasis (Set.range b) â†’\n    (âˆ€ (i : Î¹), IsCompact (b i)) â†’\n      âˆ€ (U : Set Î±), IsCompact U âˆ§ IsOpen U â†” âˆƒ s, Set.Finite s âˆ§ U = â‹ƒ (i : Î¹) (_ : i âˆˆ s), b i :=\n\n/-- If `Î±` is locally compact, and an infinite sum of functions in `C(Î±, Î²)`\nconverges to `g` (for the compact-open topology), then the pointwise sum converges to `g x` for\nall `x âˆˆ Î±`. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {Î³ : Type u_1}\n  [inst_2 : AddCommMonoid Î²] [inst_3 : ContinuousAdd Î²] {f : Î³ â†’ C(Î±, Î²)} {g : C(Î±, Î²)},\n  HasSum f g â†’ âˆ€ (x : Î±), HasSum (fun i => â†‘(f i) x) (â†‘g x) :=\n\n/-- A topology `Inducing` map from a Tâ‚€ space is a topological embedding. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T0Space Î±] {f : Î± â†’ Î²},\n  Inducing f â†’ Embedding f :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- If `s âˆˆ ğ“¤ Î±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ğ“¤ Î±`,\nwe have `t â—‹ t âŠ† s`. -/\ntheorem âˆ€ {Î± : Type ua} [inst : UniformSpace Î±] {s : Set (Î± Ã— Î±)},\n  s âˆˆ uniformity Î± â†’ âˆ€á¶  (t : Set (Î± Ã— Î±)) in Filter.smallSets (uniformity Î±), compRel t t âŠ† s :=\n\n/-- If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\nsecond countable, then there exists a countable family of open sets in `X` that separates points\nof `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s :=\n\n/-- If `Î²` is a second-countable space, then its induced topology via\n`f` on `Î±` is also second-countable. -/\ntheorem âˆ€ (Î± : Type u) (Î² : Type u_1) [t : TopologicalSpace Î²] [inst : TopologicalSpace.SecondCountableTopology Î²] (f : Î± â†’ Î²),\n  TopologicalSpace.SecondCountableTopology Î± :=\n\n/-- If addition is continuous in `Î±`, then it also is in `Î±áµƒáµ’áµ–`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : AddGroup Î±] [inst_2 : TopologicalAddGroup Î±],\n  TopologicalAddGroup Î±áµƒáµ’áµ– :=\n\n/-- If `T_Î±` is a family of topologies on `X`, show that `âˆ© T_Î±` is a topology on `X`. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  TopologicalSpace X ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {X : Type u} (T : X â†’ TopologicalSpace X),\n  TopologicalSpace (â¨… (x : X), (T x)) ",
      "âˆ€ {X : Type u} (T : Set (TopologicalSpace X)),\n  TopologicalSpace X ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  TopologicalSpace X "
    ]
  },
  {
    "docString": "Let `T_Î±` be a family of topologies on `X`. Show that there is a unique smallest topology on `X` containing all the collections `T_Î±`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\\n  ContinuousMap.compactOpen =\\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\\n  (F : Î¹ â†’ C(Î±, Î²)),\\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\\nit converges in the compact-open topology on each compact subset of `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²],\\n  Inducing (â†‘UniformFun.ofFun âˆ˜ FunLike.coe)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on `Î± â†’áµ‡ Î²` is exactly the topology induced by the natural map to `Î± â†’áµ¤ Î²`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] (b : Î¹ â†’ Set Î±),\\n  TopologicalSpace.IsTopologicalBasis (Set.range b) â†’\\n    (âˆ€ (i : Î¹), IsCompact (b i)) â†’\\n      âˆ€ (U : Set Î±), IsCompact U âˆ§ IsOpen U â†” âˆƒ s, Set.Finite s âˆ§ U = â‹ƒ (i : Î¹) (_ : i âˆˆ s), b i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` has a basis consisting of compact opens, then an open set in `Î±` is compact open iff\\nit is a finite union of some elements in the basis \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\\nsecond countable, then there exists a countable family of open sets in `X` that separates points\\nof `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type ua} [inst : UniformSpace Î±] {s : Set (Î± Ã— Î±)},\\n  s âˆˆ uniformity Î± â†’\\n    âˆ€ (n : â„•), âˆ€á¶  (t : Set (Î± Ã— Î±)) in Filter.smallSets (uniformity Î±), (fun x => compRel t x)^[n] t âŠ† s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s âˆˆ ğ“¤ Î±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ğ“¤ Î±`,\\nwe have `t â—‹ t â—‹ ... â—‹ t âŠ† s` (`n` compositions). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T0Space Î±] {f : Î± â†’ Î²},\\n  Inducing f â†’ Function.Injective f\",\n  \"isProp\": true,\n  \"docString\": \"A topology `Inducing` map from a Tâ‚€ space is injective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ (âˆ€ (i : Î¹), Set.Nonempty (f i)) â†’ Set.Finite Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of nonempty sets of `Î±` can have only\\nfinitely many elements, `Set.Finite` version. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning Î± are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T0Space Î±] {f : Î± â†’ Î²},\\n  Inducing f â†’ Embedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topology `Inducing` map from a Tâ‚€ space is a topological embedding. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {Î³ : Type u_1}\\n  [inst_2 : AddCommMonoid Î²] [inst_3 : ContinuousAdd Î²] {f : Î³ â†’ C(Î±, Î²)} {g : C(Î±, Î²)},\\n  HasSum f g â†’ âˆ€ (x : Î±), HasSum (fun i => â†‘(f i) x) (â†‘g x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is locally compact, and an infinite sum of functions in `C(Î±, Î²)`\\nconverges to `g` (for the compact-open topology), then the pointwise sum converges to `g x` for\\nall `x âˆˆ Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type ua} [inst : UniformSpace Î±] {s : Set (Î± Ã— Î±)},\\n  s âˆˆ uniformity Î± â†’ âˆ€á¶  (t : Set (Î± Ã— Î±)) in Filter.smallSets (uniformity Î±), compRel t t âŠ† s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s âˆˆ ğ“¤ Î±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ğ“¤ Î±`,\\nwe have `t â—‹ t âŠ† s`. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) (Î² : Type u_1) [t : TopologicalSpace Î²] [inst : TopologicalSpace.SecondCountableTopology Î²] (f : Î± â†’ Î²),\\n  TopologicalSpace.SecondCountableTopology Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î²` is a second-countable space, then its induced topology via\\n`f` on `Î±` is also second-countable. \"}]\n",
    "prompt_cons": "/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–) :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- The compact-open topology on `C(Î±, Î²)` is equal to the infimum of the compact-open topologies\non `C(s, Î²)` for `s` a compact subset of `Î±`.  The key point of the proof is that the union of the\ncompact subsets of `Î±` is equal to the union of compact subsets of the compact subsets of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  ContinuousMap.compactOpen =\n    â¨… (s : Set Î±) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- A family `F` of functions in `C(Î±, Î²)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : T2Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [inst_4 : Filter.NeBot l]\n  (F : Î¹ â†’ C(Î±, Î²)),\n  (âˆƒ f, Filter.Tendsto F l (nhds f)) â†”\n    âˆ€ (s : Set Î±), IsCompact s â†’ âˆƒ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- The topology on `Î± â†’áµ‡ Î²` is exactly the topology induced by the natural map to `Î± â†’áµ¤ Î²`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²],\n  Inducing (â†‘UniformFun.ofFun âˆ˜ FunLike.coe) :=\n\n/-- If `Î±` has a basis consisting of compact opens, then an open set in `Î±` is compact open iff\nit is a finite union of some elements in the basis -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] (b : Î¹ â†’ Set Î±),\n  TopologicalSpace.IsTopologicalBasis (Set.range b) â†’\n    (âˆ€ (i : Î¹), IsCompact (b i)) â†’\n      âˆ€ (U : Set Î±), IsCompact U âˆ§ IsOpen U â†” âˆƒ s, Set.Finite s âˆ§ U = â‹ƒ (i : Î¹) (_ : i âˆˆ s), b i :=\n\n/-- If `X` is a topological space, `s` is a set in `X` such that the induced topology is Tâ‚€ and is\nsecond countable, then there exists a countable family of open sets in `X` that separates points\nof `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space â†‘s]\n  [inst_2 : TopologicalSpace.SecondCountableTopology â†‘s], HasCountableSeparatingOn X IsOpen s :=\n\n/-- If `s âˆˆ ğ“¤ Î±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ğ“¤ Î±`,\nwe have `t â—‹ t â—‹ ... â—‹ t âŠ† s` (`n` compositions). -/\ntheorem âˆ€ {Î± : Type ua} [inst : UniformSpace Î±] {s : Set (Î± Ã— Î±)},\n  s âˆˆ uniformity Î± â†’\n    âˆ€ (n : â„•), âˆ€á¶  (t : Set (Î± Ã— Î±)) in Filter.smallSets (uniformity Î±), (fun x => compRel t x)^[n] t âŠ† s :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- A topology `Inducing` map from a Tâ‚€ space is injective. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T0Space Î±] {f : Î± â†’ Î²},\n  Inducing f â†’ Function.Injective f :=\n\n/-- If `Î±` is a compact space, then a locally finite family of nonempty sets of `Î±` can have only\nfinitely many elements, `Set.Finite` version. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ (âˆ€ (i : Î¹), Set.Nonempty (f i)) â†’ Set.Finite Set.univ :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- Distinct elements of a set of sets partitioning Î± are disjoint. -/\ntheorem âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id :=\n\n/-- A topology `Inducing` map from a Tâ‚€ space is a topological embedding. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T0Space Î±] {f : Î± â†’ Î²},\n  Inducing f â†’ Embedding f :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- If `Î±` is locally compact, and an infinite sum of functions in `C(Î±, Î²)`\nconverges to `g` (for the compact-open topology), then the pointwise sum converges to `g x` for\nall `x âˆˆ Î±`. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {Î³ : Type u_1}\n  [inst_2 : AddCommMonoid Î²] [inst_3 : ContinuousAdd Î²] {f : Î³ â†’ C(Î±, Î²)} {g : C(Î±, Î²)},\n  HasSum f g â†’ âˆ€ (x : Î±), HasSum (fun i => â†‘(f i) x) (â†‘g x) :=\n\n/-- If `s âˆˆ ğ“¤ Î±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ğ“¤ Î±`,\nwe have `t â—‹ t âŠ† s`. -/\ntheorem âˆ€ {Î± : Type ua} [inst : UniformSpace Î±] {s : Set (Î± Ã— Î±)},\n  s âˆˆ uniformity Î± â†’ âˆ€á¶  (t : Set (Î± Ã— Î±)) in Filter.smallSets (uniformity Î±), compRel t t âŠ† s :=\n\n/-- If `Î²` is a second-countable space, then its induced topology via\n`f` on `Î±` is also second-countable. -/\ntheorem âˆ€ (Î± : Type u) (Î² : Type u_1) [t : TopologicalSpace Î²] [inst : TopologicalSpace.SecondCountableTopology Î²] (f : Î± â†’ Î²),\n  TopologicalSpace.SecondCountableTopology Î± :=\n\n/-- Let `T_Î±` be a family of topologies on `X`. Show that there is a unique smallest topology on `X` containing all the collections `T_Î±`. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ t : TopologicalSpace X, (âˆ€ i : Î¹, T i â‰¤ t) âˆ§ âˆ€ t' : TopologicalSpace X, (âˆ€ i : Î¹, T i â‰¤ t') â†’ t â‰¤ t' ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ T', TopologicalSpace.IsMinimal T' âˆ§ âˆ€ (i : Î¹), T i â‰¤ T' ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! _inst : TopologicalSpace X, âˆ€ (i : Î¹), T i â‰¤ _inst ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ! (Tâ‚€ : TopologicalSpace X), âˆ€ (i : Î¹), T i â‰¤ Tâ‚€ ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {t : Î¹ â†’ TopologicalSpace X},\n  âˆƒ T_inf : TopologicalSpace X, (âˆ€ i, t i â‰¤ T_inf) âˆ§ âˆ€ {T : TopologicalSpace X}, (âˆ€ i, t i â‰¤ T) â†’ T_inf â‰¤ T ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ! (T_min : TopologicalSpace X), âˆ€ i, T i â‰¤ T_min ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (Tâ‚€ : TopologicalSpace X), âˆ€ (i : Î¹), T i â‰¤ Tâ‚€ ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} (T : Î¹ â†’ TopologicalSpace X),\n  âˆƒ t : TopologicalSpace X, (âˆ€ i, T i â‰¤ t) âˆ§ âˆ€ t' : TopologicalSpace X, (âˆ€ i, T i â‰¤ t') â†’ t â‰¤ t' ",
      "âˆ€ {X : Type u} {Î¹ : Type u_1} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (t : TopologicalSpace X), âˆ€ i, T i â‰¤ t ",
      "âˆ€ {X : Type u_1} {Î¹ : Type u_2} {T : Î¹ â†’ TopologicalSpace X},\n  âˆƒ! (t : TopologicalSpace X), âˆ€ i, T i â‰¤ t "
    ]
  },
  {
    "docString": "Show that if `A` is a basis for a topology on `X`, then the topology generated by `A` equals the intersection of all topologies on `X` that contain `A`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]\\n  {B : Î¹ â†’ Submodule R A}, SubmodulesRingBasis B â†’ âˆ€ (i j : Î¹), âˆƒ k, B k â‰¤ B i âŠ“ B j\",\n  \"isProp\": true,\n  \"docString\": \"Condition for `B` to be a filter basis on `A`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\\n  TopologicalSpace.IsTopologicalBasis s â†’\\n    âˆ€ {t : Set (Set Î²)},\\n      TopologicalSpace.IsTopologicalBasis t â†’\\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\\ntopological bases on each of the two components. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\\n  RingSubgroupsBasis B â†’ âˆ€ (x : A) (i : Î¹), âˆƒ j, â†‘(B j) âŠ† (fun x_1 => x * x_1) â»Â¹' â†‘(B i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any element `x : A` and any set `B` in the submodule basis on `A`,\\nthere is another basis element `B'` such that `B' * x` is in `B`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] {s : (i : Î¹) â†’ Set (Set (E i))},\\n  (âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (s i)) â†’\\n    TopologicalSpace.IsTopologicalBasis (â‹ƒ (i : Î¹), (fun u => Sigma.mk i '' u) '' s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a disjoint union space `Î£ i, E i`, one can form a topological basis by taking the union of\\ntopological bases on each of the parts of the space. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\\n  RingSubgroupsBasis B â†’ âˆ€ (x : A) (i : Î¹), âˆƒ j, â†‘(B j) âŠ† (fun x_1 => x_1 * x) â»Â¹' â†‘(B i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any element `x : A` and any set `B` in the submodule basis on `A`,\\nthere is another basis element `B'` such that `x * B'` is in `B`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (A : Type w) {M : Type vâ‚} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\\n  [inst_3 : AddCommMonoid M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M],\\n  Function.Surjective â†‘(algebraMap R A) â†’\\n    âˆ€ (X : Set M), Submodule.restrictScalars R (Submodule.span A X) = Submodule.span R X\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `A` is an `R`-algebra such that the induced morphism `R â†’+* A` is surjective, then the\\n`R`-module generated by a set `X` equals the `A`-module generated by `X`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\\n  RingSubgroupsBasis B â†’ âˆ€ (i : Î¹), âˆƒ j, â†‘(B j) * â†‘(B j) âŠ† â†‘(B i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\\nthat the set-theoretic product `B' * B'` is in `B`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  (âˆ€ (u : Set Î±), u âˆˆ s â†’ IsOpen u) â†’\\n    (âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ IsOpen u â†’ âˆƒ v, v âˆˆ s âˆ§ a âˆˆ v âˆ§ v âŠ† u) â†’ TopologicalSpace.IsTopologicalBasis s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of open sets `s` is such that every open neighbourhood contains some\\nmember of `s`, then `s` is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N) {H K : AddSubgroup G},\\n  AddMonoidHom.ker f â‰¤ H â†’ AddMonoidHom.ker f â‰¤ K â†’ AddSubgroup.map f H = AddSubgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`.\"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => â†‘(I ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_3} {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {P : Submodule R M} (b : Basis Î¹ R { x // x âˆˆ P }) {x : M}, x âˆˆ P â†” âˆƒ c, x = Finsupp.sum c fun i x => x â€¢ â†‘(â†‘b i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the submodule `P` has a basis, `x âˆˆ P` iff it is a linear combination of basis vectors. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] (b : Î¹ â†’ Set Î±),\\n  TopologicalSpace.IsTopologicalBasis (Set.range b) â†’\\n    (âˆ€ (i : Î¹), IsCompact (b i)) â†’\\n      âˆ€ (U : Set Î±), IsCompact U âˆ§ IsOpen U â†” âˆƒ s, Set.Finite s âˆ§ U = â‹ƒ (i : Î¹) (_ : i âˆˆ s), b i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` has a basis consisting of compact opens, then an open set in `Î±` is compact open iff\\nit is a finite union of some elements in the basis \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]\\n  {B : Î¹ â†’ Submodule R A}, SubmodulesRingBasis B â†’ âˆ€ (a : A) (i : Î¹), âˆƒ j, a â€¢ B j â‰¤ B i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any element `a : A` and any set `B` in the submodule basis on `A`,\\nthere is another basis element `B'` such that `a â€¢ B'` is in `B`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\\n  Algebra.IsIntegral R A â†’ âˆ€ (x : B), IsIntegral A x â†’ IsIntegral R x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an R-algebra all of whose elements are integral over R,\\nand x is an element of an A-algebra that is integral over A, then x is integral over R.\"}]\n",
    "prompt_cons": "/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- Condition for `B` to be a filter basis on `A`. -/\ntheorem âˆ€ {Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]\n  {B : Î¹ â†’ Submodule R A}, SubmodulesRingBasis B â†’ âˆ€ (i j : Î¹), âˆƒ k, B k â‰¤ B i âŠ“ B j :=\n\n/-- In a sum space `Î± âŠ• Î²`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis s â†’\n    âˆ€ {t : Set (Set Î²)},\n      TopologicalSpace.IsTopologicalBasis t â†’\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s âˆª (fun u => Sum.inr '' u) '' t) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V) :=\n\n/-- For any element `x : A` and any set `B` in the submodule basis on `A`,\nthere is another basis element `B'` such that `B' * x` is in `B`. -/\ntheorem âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\n  RingSubgroupsBasis B â†’ âˆ€ (x : A) (i : Î¹), âˆƒ j, â†‘(B j) âŠ† (fun x_1 => x * x_1) â»Â¹' â†‘(B i) :=\n\n/-- In a disjoint union space `Î£ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] {s : (i : Î¹) â†’ Set (Set (E i))},\n  (âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (s i)) â†’\n    TopologicalSpace.IsTopologicalBasis (â‹ƒ (i : Î¹), (fun u => Sigma.mk i '' u) '' s i) :=\n\n/-- For any element `x : A` and any set `B` in the submodule basis on `A`,\nthere is another basis element `B'` such that `x * B'` is in `B`. -/\ntheorem âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\n  RingSubgroupsBasis B â†’ âˆ€ (x : A) (i : Î¹), âˆƒ j, â†‘(B j) âŠ† (fun x_1 => x_1 * x) â»Â¹' â†‘(B i) :=\n\n/-- If `A` is an `R`-algebra such that the induced morphism `R â†’+* A` is surjective, then the\n`R`-module generated by a set `X` equals the `A`-module generated by `X`. -/\ntheorem âˆ€ (R : Type u) (A : Type w) {M : Type vâ‚} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  [inst_3 : AddCommMonoid M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M],\n  Function.Surjective â†‘(algebraMap R A) â†’\n    âˆ€ (X : Set M), Submodule.restrictScalars R (Submodule.span A X) = Submodule.span R X :=\n\n/-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\nthat the set-theoretic product `B' * B'` is in `B`. -/\ntheorem âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\n  RingSubgroupsBasis B â†’ âˆ€ (i : Î¹), âˆƒ j, â†‘(B j) * â†‘(B j) âŠ† â†‘(B i) :=\n\n/-- If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  (âˆ€ (u : Set Î±), u âˆˆ s â†’ IsOpen u) â†’\n    (âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ IsOpen u â†’ âˆƒ v, v âˆˆ s âˆ§ a âˆˆ v âˆ§ v âŠ† u) â†’ TopologicalSpace.IsTopologicalBasis s :=\n\n/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f â‰¤ H â†’ AddMonoidHom.ker f â‰¤ K â†’ AddSubgroup.map f H = AddSubgroup.map f K â†’ H = K :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K :=\n\n/-- For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => â†‘(I ^ n) :=\n\n/-- If the submodule `P` has a basis, `x âˆˆ P` iff it is a linear combination of basis vectors. -/\ntheorem âˆ€ {Î¹ : Type u_3} {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {P : Submodule R M} (b : Basis Î¹ R { x // x âˆˆ P }) {x : M}, x âˆˆ P â†” âˆƒ c, x = Finsupp.sum c fun i x => x â€¢ â†‘(â†‘b i) :=\n\n/-- If `Î±` has a basis consisting of compact opens, then an open set in `Î±` is compact open iff\nit is a finite union of some elements in the basis -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] (b : Î¹ â†’ Set Î±),\n  TopologicalSpace.IsTopologicalBasis (Set.range b) â†’\n    (âˆ€ (i : Î¹), IsCompact (b i)) â†’\n      âˆ€ (U : Set Î±), IsCompact U âˆ§ IsOpen U â†” âˆƒ s, Set.Finite s âˆ§ U = â‹ƒ (i : Î¹) (_ : i âˆˆ s), b i :=\n\n/-- For any element `a : A` and any set `B` in the submodule basis on `A`,\nthere is another basis element `B'` such that `a â€¢ B'` is in `B`. -/\ntheorem âˆ€ {Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]\n  {B : Î¹ â†’ Submodule R A}, SubmodulesRingBasis B â†’ âˆ€ (a : A) (i : Î¹), âˆƒ j, a â€¢ B j â‰¤ B i :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- If A is an R-algebra all of whose elements are integral over R,\nand x is an element of an A-algebra that is integral over A, then x is integral over R. -/\ntheorem âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\n  Algebra.IsIntegral R A â†’ âˆ€ (x : B), IsIntegral A x â†’ IsIntegral R x :=\n\n/-- Show that if `A` is a basis for a topology on `X`, then the topology generated by `A` equals the intersection of all topologies on `X` that contain `A`. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis s â†’ t = â‹‚â‚€ {u : Set (Set Î±) | s âŠ† u âˆ§ (TopologicalSpace.generateFrom u).is_open = id} ",
      "âˆ€ {Î± : Type u} (A : Set (Set Î±)),\n  TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace Î± | A âŠ† t.open_set} ",
      "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = inf {t : TopologicalSpace Î± | A âŠ† t.sets} ",
      "âˆ€ {Î± : Type u} {A : Set (Set Î±)}, TopologicalSpace.IsTopologicalBasis A â†’ TopologicalSpace.generateFrom A = â¨… (t : TopologicalSpace Î±) (h : A âŠ† t.1), t ",
      "forall {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = â¨… (t : TopologicalSpace Î±), A âŠ† t.sets â†’ t ",
      "âˆ€ {Î± : Type u} {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’\n    TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace Î± | A âŠ† t.opens} ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis s â†’\n    t = â¨… (u : TopologicalSpace Î±), HasSubset.Subset s u.2 â†’ u ",
      "âˆ€ {Î± : Type u} {A : Set (Set Î±)} [t : TopologicalSpace Î±],\n  TopologicalSpace.generateFrom A = Inf {t' : TopologicalSpace Î± | A âŠ† t'.opens} ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {A : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis A â†’ t = â¨… (u : TopologicalSpace Î±), TopologicalSpace.generateFrom A â‰¤ u ",
      "âˆ€ {Î± : Type u} (A : Set (Set Î±)), TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace Î± | A âŠ† t.s} "
    ]
  },
  {
    "docString": "Show that the lower limit topology `â„_l` and the `K`-topology `â„_K` are not comparable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  Algebra.IsIntegral K L â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `L/K` is an algebraic field extension, then the Krull topology on `L â‰ƒâ‚[K] L` is\\ntotally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  Algebra.IsIntegral K L â†’ T2Space (L â‰ƒâ‚[K] L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `L/K` is an algebraic extension, then the Krull topology on `L â‰ƒâ‚[K] L` is Hausdorff. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L], TopologicalGroup (L â‰ƒâ‚[K] L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a field extension `L/K`, the Krull topology on `L â‰ƒâ‚[K] L` makes it a topological group. \"},\n {\"theorem\":\n  \"âˆ€ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\\n  âˆƒ f, Embedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A Tâ‚ƒ topological space with second countable topology can be embedded into `l^âˆ = â„• â†’áµ‡ â„`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] (a : Î±),\\n  IsClosed (Set.Ici a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left-closed right-infinite intervals [a, âˆ) are closed in the lower topology. \"},\n {\"theorem\": \"Â¬IsField â„¤\",\n  \"isProp\": true,\n  \"docString\": \"`â„¤` with its usual ring structure is not a field. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D] {J : Type w}\\n  [inst_2 : CategoryTheory.Category J] (K : CategoryTheory.Functor J C) (F : CategoryTheory.Functor C D)\\n  [inst_3 : CategoryTheory.Limits.HasLimit (CategoryTheory.Functor.comp K F)]\\n  [inst_4 : CategoryTheory.CreatesLimit K F], CategoryTheory.Limits.HasLimit K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `F` creates the limit of `K` and `K â‹™ F` has a limit, then `K` has a limit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {f : Î± â†’ â„} (K : â„),\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + K * dist x y) â†’ LipschitzOnWith (Real.toNNReal K) f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\\ndoesn't assume `0â‰¤K`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {k l : â„•},\\n  k â‰  l â†’ Disjoint (primitiveRoots k R) (primitiveRoots l R)\",\n  \"isProp\": true,\n  \"docString\": \"The sets `primitiveRoots k R` are pairwise disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K], IsCompl K Ká—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` admits an orthogonal projection, `K` and `Ká—®` are complements of each other. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (f : Module.End K V) (Î¼ : K),\\n  Disjoint (Module.End.generalizedEigenrange f Î¼ (FiniteDimensional.finrank K V))\\n    (â†‘(Module.End.generalizedEigenspace f Î¼) (FiniteDimensional.finrank K V))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Generalized eigenrange and generalized eigenspace for exponent `finrank K V` are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : Î± â†’ â„} (K : NNReal),\\n  (âˆ€ (x y : Î±), f x â‰¤ f y + â†‘K * dist x y) â†’ LipschitzWith K f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\\nassumes `0â‰¤K`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±),\\n  Disjoint (nhds x) (Filter.cocompact Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, the filters `ğ“ x` and `cocompact Î±` are disjoint for all `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E], UniformSpace.toTopologicalSpace â‰¤ WeakDual.instTopologicalSpace\",\n  \"isProp\": true,\n  \"docString\":\n  \"The weak-star topology is coarser than the dual-norm topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : VAdd Î“ T] [self : ProperlyDiscontinuousVAdd Î“ T]\\n  {K L : Set T}, IsCompact K â†’ IsCompact L â†’ Set.Finite {Î³ | (fun x => Î³ +áµ¥ x) '' K âˆ© L â‰  âˆ…}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two compact sets `K` and `L`, `Î³ +áµ¥ K âˆ© L` is nonempty for finitely many `Î³`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ â„¬ : Finset (Finset Î±)} [inst_1 : Fintype Î±],\\n  IsLowerSet â†‘ğ’œ â†’ IsUpperSet â†‘â„¬ â†’ 2 ^ Fintype.card Î± * Finset.card (ğ’œ âˆ© â„¬) â‰¤ Finset.card ğ’œ * Finset.card â„¬\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Harris-Kleitman inequality**: Lower sets and upper sets of finsets anticorrelate. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ â„¬ : Finset (Finset Î±)} [inst_1 : Fintype Î±],\\n  IsUpperSet â†‘ğ’œ â†’ IsLowerSet â†‘â„¬ â†’ 2 ^ Fintype.card Î± * Finset.card (ğ’œ âˆ© â„¬) â‰¤ Finset.card ğ’œ * Finset.card â„¬\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Harris-Kleitman inequality**: Upper sets and lower sets of finsets anticorrelate. \"}]\n",
    "prompt_cons": "/-- If `L/K` is an algebraic field extension, then the Krull topology on `L â‰ƒâ‚[K] L` is\ntotally disconnected. -/\ntheorem âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  Algebra.IsIntegral K L â†’ IsTotallyDisconnected Set.univ :=\n\n/-- If `L/K` is an algebraic extension, then the Krull topology on `L â‰ƒâ‚[K] L` is Hausdorff. -/\ntheorem âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  Algebra.IsIntegral K L â†’ T2Space (L â‰ƒâ‚[K] L) :=\n\n/-- For a field extension `L/K`, the Krull topology on `L â‰ƒâ‚[K] L` makes it a topological group. -/\ntheorem âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L], TopologicalGroup (L â‰ƒâ‚[K] L) :=\n\n/-- A Tâ‚ƒ topological space with second countable topology can be embedded into `l^âˆ = â„• â†’áµ‡ â„`. -/\ntheorem âˆ€ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  âˆƒ f, Embedding f :=\n\n/-- Left-closed right-infinite intervals [a, âˆ) are closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] (a : Î±),\n  IsClosed (Set.Ici a) :=\n\n/-- `â„¤` with its usual ring structure is not a field. -/\ntheorem Â¬IsField â„¤ :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- If `F` creates the limit of `K` and `K â‹™ F` has a limit, then `K` has a limit. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D] {J : Type w}\n  [inst_2 : CategoryTheory.Category J] (K : CategoryTheory.Functor J C) (F : CategoryTheory.Functor C D)\n  [inst_3 : CategoryTheory.Limits.HasLimit (CategoryTheory.Functor.comp K F)]\n  [inst_4 : CategoryTheory.CreatesLimit K F], CategoryTheory.Limits.HasLimit K :=\n\n/-- For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\ndoesn't assume `0â‰¤K`. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {f : Î± â†’ â„} (K : â„),\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + K * dist x y) â†’ LipschitzOnWith (Real.toNNReal K) f s :=\n\n/-- If `â€–râ‚â€– < râ‚‚`, then for any natural `k` we have `n ^ k râ‚ ^ n = o (râ‚‚ ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„},\n  â€–râ‚â€– < râ‚‚ â†’ (fun n => â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] fun n => râ‚‚ ^ n :=\n\n/-- The sets `primitiveRoots k R` are pairwise disjoint. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {k l : â„•},\n  k â‰  l â†’ Disjoint (primitiveRoots k R) (primitiveRoots l R) :=\n\n/-- If `K` admits an orthogonal projection, `K` and `Ká—®` are complements of each other. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection K], IsCompl K Ká—® :=\n\n/-- Generalized eigenrange and generalized eigenspace for exponent `finrank K V` are disjoint. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (f : Module.End K V) (Î¼ : K),\n  Disjoint (Module.End.generalizedEigenrange f Î¼ (FiniteDimensional.finrank K V))\n    (â†‘(Module.End.generalizedEigenspace f Î¼) (FiniteDimensional.finrank K V)) :=\n\n/-- For functions to `â„`, it suffices to prove `f x â‰¤ f y + K * dist x y`; this version\nassumes `0â‰¤K`. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : Î± â†’ â„} (K : NNReal),\n  (âˆ€ (x y : Î±), f x â‰¤ f y + â†‘K * dist x y) â†’ LipschitzWith K f :=\n\n/-- In a locally compact space, the filters `ğ“ x` and `cocompact Î±` are disjoint for all `Î±`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±),\n  Disjoint (nhds x) (Filter.cocompact Î±) :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K :=\n\n/-- The weak-star topology is coarser than the dual-norm topology. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E], UniformSpace.toTopologicalSpace â‰¤ WeakDual.instTopologicalSpace :=\n\n/-- Given two compact sets `K` and `L`, `Î³ +áµ¥ K âˆ© L` is nonempty for finitely many `Î³`. -/\ntheorem âˆ€ {Î“ : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : VAdd Î“ T] [self : ProperlyDiscontinuousVAdd Î“ T]\n  {K L : Set T}, IsCompact K â†’ IsCompact L â†’ Set.Finite {Î³ | (fun x => Î³ +áµ¥ x) '' K âˆ© L â‰  âˆ…} :=\n\n/-- **Harris-Kleitman inequality**: Lower sets and upper sets of finsets anticorrelate. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ â„¬ : Finset (Finset Î±)} [inst_1 : Fintype Î±],\n  IsLowerSet â†‘ğ’œ â†’ IsUpperSet â†‘â„¬ â†’ 2 ^ Fintype.card Î± * Finset.card (ğ’œ âˆ© â„¬) â‰¤ Finset.card ğ’œ * Finset.card â„¬ :=\n\n/-- **Harris-Kleitman inequality**: Upper sets and lower sets of finsets anticorrelate. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ â„¬ : Finset (Finset Î±)} [inst_1 : Fintype Î±],\n  IsUpperSet â†‘ğ’œ â†’ IsLowerSet â†‘â„¬ â†’ 2 ^ Fintype.card Î± * Finset.card (ğ’œ âˆ© â„¬) â‰¤ Finset.card ğ’œ * Finset.card â„¬ :=\n\n/-- Show that the lower limit topology `â„_l` and the `K`-topology `â„_K` are not comparable. -/\ntheorem",
    "choices": [
      "Â¬(UniformSpace.toTopologicalSpace â‰¤ LowerTopology â„ âˆ§ UniformSpace.toTopologicalSpace â‰¤ KTopology â„) ",
      "NotComparable TopologicalSpace.lowerLimitTopology (TopologicalSpace.kTopology â„) ",
      "â„_l_not_le_â„_K : (OrderTopology.lowerLimitTopology â„).toTopologicalSpace â‰  (OrderTopology.KTopology â„).toTopologicalSpace ",
      "DisjointLowerLimitTopoKTopology : Disjoint LowerLimitTopo KTopology ",
      "Â¬(UniformSpace.toTopologicalSpace â„_l â‰¤ UniformSpace.toTopologicalSpace â„_K) âˆ§\n  Â¬(UniformSpace.toTopologicalSpace â„_K â‰¤ UniformSpace.toTopologicalSpace â„_l) ",
      "NotComparable â„_l â„_K ",
      "not_le_of_gt : âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, a < b â†’ Â¬b â‰¤ a ",
      "Â¬(TopologicalSpace.generateFrom (Set.range Set.Ioi) â‰¤ TopologicalSpace.generateFrom\n    (insert (Set.Iio (Real.sqrt 2)) (set.range (Î» (i : â„¤), Set.Ioo (coe i) (coe i + 1))))) âˆ§\n  Â¬(TopologicalSpace.generateFrom\n    (insert (Set.Iio (Real.sqrt 2)) (set.range (Î» (i : â„¤), Set.Ioo (coe i) (coe i + 1)))) â‰¤\n      TopologicalSpace.generateFrom (Set.range Set.Ioi)) ",
      "not_comparable_lower_K : TopologicalSpace â„_l â‰¤ TopologicalSpace â„_K â†’ Â¬TopologicalSpace â„_K â‰¤ TopologicalSpace â„_l ",
      ": â„_l â‰  â„_K âˆ§ âˆ€ (Uâ‚ : Set â„), IsOpen Uâ‚ â†’ âˆ€ (Uâ‚‚ : Set â„), IsOpen Uâ‚‚ â†’ Uâ‚ â‰  Uâ‚‚ "
    ]
  },
  {
    "docString": "Show that the collection `{(a,b) | a < b, a and b rational}` is a basis that generates a topology different from the lower limit topology on `â„`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n â‰¤\\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the sequence of denominators is monotone, that is `Bâ‚™ â‰¤ Bâ‚™â‚Šâ‚`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V â†’\\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\\n  t = TopologicalSpace.generateFrom s â†’\\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type ua} [inst : UniformSpace Î±], Filter.HasBasis (uniformity Î±) (fun V => V âˆˆ uniformity Î± âˆ§ IsOpen V) id\",\n  \"isProp\": true,\n  \"docString\": \"Open elements of `ğ“¤ Î±` form a basis of `ğ“¤ Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\\n  Algebra.discr K â†‘b â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => â†‘(I ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedAddCommGroup Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : NoMaxOrder Î±] {a : Î±},\\n  0 < a â†’ Filter.HasBasis (nhds a) (fun Îµ => 0 < Îµ âˆ§ Îµ â‰¤ a) fun Îµ => Set.Ioo (a - Îµ) (a + Îµ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` is positive we can form a basis from only nonnegative `Set.Ioo` intervals \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\\n      MeasureTheory.Integrable bound â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type ua} [inst : UniformSpace Î±],\\n  Filter.HasBasis (uniformity Î±) (fun V => V âˆˆ uniformity Î± âˆ§ IsOpen V âˆ§ SymmetricRel V) id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Open elements `s : Set (Î± Ã— Î±)` of `ğ“¤ Î±` such that `(x, y) âˆˆ s â†” (y, x) âˆˆ s` form a basis\\nof `ğ“¤ Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\\n  IsUnit (Algebra.discr K â†‘b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (s : Set Î±), UniformContinuous fun x => Metric.infNndist x s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal distance to a set (as `â„â‰¥0`) is uniformly continuous in point \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {Î“â‚€ : Type v} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€] (v : Valuation R Î“â‚€),\\n  RingSubgroupsBasis fun Î³ => Valuation.ltAddSubgroup v Î³\",\n  \"isProp\": true,\n  \"docString\":\n  \"The basis of open subgroups for the topology on a ring determined by a valuation. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {ğ•œ : Type u_2} [inst : NonUnitalNonAssocRing R] [inst_1 : LinearOrderedField ğ•œ]\\n  [inst_2 : TopologicalSpace R] [inst_3 : TopologicalAddGroup R] (norm : R â†’ ğ•œ),\\n  (âˆ€ (x : R), 0 â‰¤ norm x) â†’\\n    (âˆ€ (x y : R), norm (x * y) â‰¤ norm x * norm y) â†’\\n      (Filter.HasBasis (nhds 0) (fun x => 0 < x) fun Îµ => {x | norm x < Îµ}) â†’ TopologicalRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a (possibly non-unital and/or non-associative) ring `R` admits a submultiplicative\\nnonnegative norm `norm : R â†’ ğ•œ`, where `ğ•œ` is a linear ordered field, and the open balls\\n`{ x | norm x < Îµ }`, `Îµ > 0`, form a basis of neighborhoods of zero, then `R` is a topological\\nring. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [top : TopologicalSpace R] [inst_1 : TopologicalRing R] {J : Ideal R},\\n  IsAdic J â†” (âˆ€ (n : â„•), IsOpen â†‘(J ^ n)) âˆ§ âˆ€ (s : Set R), s âˆˆ nhds 0 â†’ âˆƒ n, â†‘(J ^ n) âŠ† s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological ring is `J`-adic if and only if it admits the powers of `J` as a basis of\\nopen neighborhoods of zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : Filter Î±} {a : Î±} {s : Set Î±},\\n  a âˆˆ s â†’ IsOpen s â†’ Filter.principal s â‰¤ f â†’ nhds a â‰¤ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\\nthe principal filter of some open set `s` containing `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] {Î¹' : Type u_1} [inst_1 : Fintype Î¹'] [inst_2 : Fintype Î¹]\\n  [inst_3 : DecidableEq Î¹'] (K : Type u) [inst_4 : Field K] [inst_5 : NumberField K] {b : Basis Î¹ â„š K}\\n  {b' : Basis Î¹' â„š K},\\n  (âˆ€ (i : Î¹) (j : Î¹'), IsIntegral â„¤ (Basis.toMatrix b (â†‘b') i j)) â†’\\n    (âˆ€ (i : Î¹') (j : Î¹), IsIntegral â„¤ (Basis.toMatrix b' (â†‘b) i j)) â†’ Algebra.discr â„š â†‘b = Algebra.discr â„š â†‘b'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` and `b'` are `â„š`-bases of a number field `K` such that\\n`âˆ€ i j, IsIntegral â„¤ (b.toMatrix b' i j)` and `âˆ€ i j, IsIntegral â„¤ (b'.toMatrix b i j)` then\\n`discr â„š b = discr â„š b'`. \"}]\n",
    "prompt_cons": "/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    IsOpenMap Quotient.mk' â†’ TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- Shows that the sequence of denominators is monotone, that is `Bâ‚™ â‰¤ Bâ‚™â‚Šâ‚`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n â‰¤\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {Ï€ : X â†’ Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V â†’\n    QuotientMap Ï€ â†’ IsOpenMap Ï€ â†’ TopologicalSpace.IsTopologicalBasis (Set.image Ï€ '' V) :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f => â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s}) :=\n\n/-- Open elements of `ğ“¤ Î±` form a basis of `ğ“¤ Î±`. -/\ntheorem âˆ€ {Î± : Type ua} [inst : UniformSpace Î±], Filter.HasBasis (uniformity Î±) (fun V => V âˆˆ uniformity Î± âˆ§ IsOpen V) id :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b â‰  0`. -/\ntheorem âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\n  Algebra.discr K â†‘b â‰  0 :=\n\n/-- For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => â†‘(I ^ n) :=\n\n/-- If `a` is positive we can form a basis from only nonnegative `Set.Ioo` intervals -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedAddCommGroup Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : NoMaxOrder Î±] {a : Î±},\n  0 < a â†’ Filter.HasBasis (nhds a) (fun Îµ => 0 < Îµ âˆ§ Îµ â‰¤ a) fun Îµ => Set.Ioo (a - Îµ) (a + Îµ) :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst_4 : CompleteSpace F] {T : Set Î± â†’ E â†’L[â„] F} {C : â„} (hT : MeasureTheory.DominatedFinMeasAdditive Î¼ T C)\n  {Î¹ : Type u_4} {l : Filter Î¹} [inst_5 : Filter.IsCountablyGenerated l] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„),\n  (âˆ€á¶  (n : Î¹) in l, MeasureTheory.AEStronglyMeasurable (fs n) Î¼) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, â€–fs n aâ€– â‰¤ bound a) â†’\n      MeasureTheory.Integrable bound â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => MeasureTheory.setToFun Î¼ T hT (fs n)) l (nhds (MeasureTheory.setToFun Î¼ T hT f)) :=\n\n/-- Open elements `s : Set (Î± Ã— Î±)` of `ğ“¤ Î±` such that `(x, y) âˆˆ s â†” (y, x) âˆˆ s` form a basis\nof `ğ“¤ Î±`. -/\ntheorem âˆ€ {Î± : Type ua} [inst : UniformSpace Î±],\n  Filter.HasBasis (uniformity Î±) (fun V => V âˆˆ uniformity Î± âˆ§ IsOpen V âˆ§ SymmetricRel V) id :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem âˆ€ {Î± : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} {l : Filter Î¹}\n  [inst : Filter.IsCountablyGenerated l] {F : Î¹ â†’ Î± â†’ ENNReal} {f : Î± â†’ ENNReal} (bound : Î± â†’ ENNReal),\n  (âˆ€á¶  (n : Î¹) in l, Measurable (F n)) â†’\n    (âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) â†’\n      âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤ â†’\n        (âˆ€áµ (a : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => F n a) l (nhds (f a))) â†’\n          Filter.Tendsto (fun n => âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼)) :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. -/\ntheorem âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : Fintype Î¹] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis Î¹ K L),\n  IsUnit (Algebra.discr K â†‘b) :=\n\n/-- The minimal distance to a set (as `â„â‰¥0`) is uniformly continuous in point -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (s : Set Î±), UniformContinuous fun x => Metric.infNndist x s :=\n\n/-- The basis of open subgroups for the topology on a ring determined by a valuation. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {Î“â‚€ : Type v} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€] (v : Valuation R Î“â‚€),\n  RingSubgroupsBasis fun Î³ => Valuation.ltAddSubgroup v Î³ :=\n\n/-- If a (possibly non-unital and/or non-associative) ring `R` admits a submultiplicative\nnonnegative norm `norm : R â†’ ğ•œ`, where `ğ•œ` is a linear ordered field, and the open balls\n`{ x | norm x < Îµ }`, `Îµ > 0`, form a basis of neighborhoods of zero, then `R` is a topological\nring. -/\ntheorem âˆ€ {R : Type u_1} {ğ•œ : Type u_2} [inst : NonUnitalNonAssocRing R] [inst_1 : LinearOrderedField ğ•œ]\n  [inst_2 : TopologicalSpace R] [inst_3 : TopologicalAddGroup R] (norm : R â†’ ğ•œ),\n  (âˆ€ (x : R), 0 â‰¤ norm x) â†’\n    (âˆ€ (x y : R), norm (x * y) â‰¤ norm x * norm y) â†’\n      (Filter.HasBasis (nhds 0) (fun x => 0 < x) fun Îµ => {x | norm x < Îµ}) â†’ TopologicalRing R :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- A topological ring is `J`-adic if and only if it admits the powers of `J` as a basis of\nopen neighborhoods of zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [top : TopologicalSpace R] [inst_1 : TopologicalRing R] {J : Ideal R},\n  IsAdic J â†” (âˆ€ (n : â„•), IsOpen â†‘(J ^ n)) âˆ§ âˆ€ (s : Set R), s âˆˆ nhds 0 â†’ âˆƒ n, â†‘(J ^ n) âŠ† s :=\n\n/-- To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\nthe principal filter of some open set `s` containing `a`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : Filter Î±} {a : Î±} {s : Set Î±},\n  a âˆˆ s â†’ IsOpen s â†’ Filter.principal s â‰¤ f â†’ nhds a â‰¤ f :=\n\n/-- If `b` and `b'` are `â„š`-bases of a number field `K` such that\n`âˆ€ i j, IsIntegral â„¤ (b.toMatrix b' i j)` and `âˆ€ i j, IsIntegral â„¤ (b'.toMatrix b i j)` then\n`discr â„š b = discr â„š b'`. -/\ntheorem âˆ€ {Î¹ : Type w} [inst : DecidableEq Î¹] {Î¹' : Type u_1} [inst_1 : Fintype Î¹'] [inst_2 : Fintype Î¹]\n  [inst_3 : DecidableEq Î¹'] (K : Type u) [inst_4 : Field K] [inst_5 : NumberField K] {b : Basis Î¹ â„š K}\n  {b' : Basis Î¹' â„š K},\n  (âˆ€ (i : Î¹) (j : Î¹'), IsIntegral â„¤ (Basis.toMatrix b (â†‘b') i j)) â†’\n    (âˆ€ (i : Î¹') (j : Î¹), IsIntegral â„¤ (Basis.toMatrix b' (â†‘b) i j)) â†’ Algebra.discr â„š â†‘b = Algebra.discr â„š â†‘b' :=\n\n/-- Show that the collection `{(a,b) | a < b, a and b rational}` is a basis that generates a topology different from the lower limit topology on `â„`. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±],\n  Â¬TopologicalSpace.IsTopologicalBasis {ab | âˆƒ (a b : Î±) (ha : HasMem.Mem a â„š) (hb : HasMem.Mem b â„š), ab = (a, b) âˆ§ a < b} ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedField Î±] [inst_2 : OrderTopology Î±],\n  TopologicalSpace.generateFrom\n    (SetOf fun s => âˆƒ (i j : â„š), 0 < j - i âˆ§ s = Set.Ioo (i : Î±) (j : Î±)) â‰  TopologicalSpace.generateFrom (SetOf Set.Ioi) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace.SecondCountableTopology Î±],\n  TopologicalSpace.IsTopologicalBasis (SetOf fun s => âˆƒ (a b : â„š), a < b âˆ§ s = Set.Ioo (a : Î±) (b : Î±)) âˆ§\n  t â‰  TopologicalSpace.generateFrom (SetOf fun b => âˆƒ a, b = Set.Ioi a) ",
      "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±],\n  let S ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenseOrder Î±],\n  âˆƒ b, TopologicalSpace.IsTopologicalBasis b âˆ§ TopologicalSpace.generateFrom b â‰  Filter.lowerComplete Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedField Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  TopologicalSpace.generateFrom\n    {s : Set Î± | âˆƒ a b : â„š, a < b âˆ§ s = Set.Ioo (coe a) (coe b)} â‰ \n    TopologicalSpace.generateFrom\n      {s : Set Î± | âˆƒ a b : Î±, a < b âˆ§ s = Set.Ico a b} ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedField Î±] [order : OrderTopology Î±] [floor : FloorRing Î±],\n  TopologicalSpace.generateFrom {s : Set Î± | âˆƒ (a : Î±) (H : a < a + 1), s = Set.Ioo a (a + 1)} â‰  TopologicalSpace.generateFrom {s : Set Î± | âˆƒ a b (H : a < b) (hâ‚ : a âˆˆ â„š) (hâ‚‚ : b âˆˆ â„š), s = Set.Ioo a b} ",
      "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : NoMinOrder Î±],\n  Â¬TopologicalSpace.IsTopologicalBasis (SetOf fun s => âˆƒ a b : Î±, a < b âˆ§ s = Set.Ioo a b) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrderedField Î±] [inst_2 : OrderTopology Î±], \n  let s ",
      "{Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±],\n  Filter.HasBasis (Filter.principal {a b : Î± | a < b âˆ§ âˆƒ l H r H, a = l âˆ§ b = r}) (fun V => True) id "
    ]
  },
  {
    "docString": "A map `f: X â†’ Y` is said to be an open map if for every open set `U` of `X`, the set `f(U)` is open in `Y`. Show that `Ï€â‚: X Ã— Y â†’ X` and `Ï€â‚‚: X Ã— Y â†’ Y` are open maps.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} {Y : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)]\\n  {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X, Y i)},\\n  (âˆ€ (i : Î¹), ContinuousMap.Homotopic (fâ‚€ i) (fâ‚ i)) â†’\\n    ContinuousMap.Homotopic (ContinuousMap.pi fâ‚€) (ContinuousMap.pi fâ‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each `fâ‚€ i : C(X, Y i)` is homotopic to `fâ‚ i : C(X, Y i)`, then `ContinuousMap.pi fâ‚€` is\\nhomotopic to `ContinuousMap.pi fâ‚`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, IsOpenMap â†‘f.linear â†” IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is an open map iff `f` is an open map. \"},\n {\"theorem\":\n  \"âˆ€ {X Y S : TopCat} {f : X âŸ¶ S} {g : Y âŸ¶ S},\\n  OpenEmbedding â†‘f â†’\\n    OpenEmbedding â†‘g â†’\\n      OpenEmbedding\\n        â†‘(CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : FiniteDimensional ğ•œ E]\\n  (f : F â†’â‚—[ğ•œ] E), Function.Surjective â†‘f â†’ IsOpenMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A surjective linear map `f` with finite dimensional codomain is an open map. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (ğ’° : AlgebraicGeometry.Scheme.OpenCover Y),\\n      (âˆ€ (i : ğ’°.J), P CategoryTheory.Limits.pullback.snd) â†’ P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` holds for `f âˆ£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.  \"},\n {\"theorem\":\n  \"âˆ€ {X Y Z : Type u} (f g : X âŸ¶ Y) (Ï€ : Y âŸ¶ Z)\\n  (e : CategoryTheory.CategoryStruct.comp f Ï€ = CategoryTheory.CategoryStruct.comp g Ï€),\\n  CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.Cofork.ofÏ€ Ï€ e) â†’\\n    âˆ€ (U : Set Y), f â»Â¹' U = g â»Â¹' U â†’ Ï€ â»Â¹' (Ï€ '' U) = U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Ï€ : Y âŸ¶ Z` is an equalizer for `(f, g)`, and `U âŠ† Y` such that `f â»Â¹' U = g â»Â¹' U`,\\nthen `Ï€ â»Â¹' (Ï€ '' U) = U`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²}\\n  {f : Î± â†’ Î²}, Set.MapsTo f s t â†’ Continuous f â†’ IsClosed t â†’ Set.MapsTo f (closure s) t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] {Y : Type u_2} [inst_2 : TopologicalSpace Y],\\n  IsClosedMap Prod.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact topological space, then `Prod.snd : X Ã— Y â†’ Y` is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  [inst_5 : MeasureTheory.Measure.IsMulRightInvariant Î¼],\\n  MeasureTheory.MeasurePreserving fun z => (z.fst * z.snd, z.snd)\",\n  \"isProp\": true,\n  \"docString\": \"The map `(x, y) â†¦ (xy, y)` preserves the measure `Î¼ Ã— Î½`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\\n`g âˆ˜ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_3} {R : Type u_1} {M : Î¹ â†’ Type u_2} {N : Type u_4} [dec_Î¹ : DecidableEq Î¹] [inst : Semiring R]\\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] [inst_3 : AddCommMonoid N]\\n  [inst_4 : Module R N] â¦ƒÏ† Ïˆ : (Î â‚€ (i : Î¹), M i) â†’â‚—[R] Nâ¦„,\\n  (âˆ€ (i : Î¹) (x : M i), â†‘Ï† (DFinsupp.single i x) = â†‘Ïˆ (DFinsupp.single i x)) â†’ Ï† = Ïˆ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two `R`-linear maps from `Î â‚€ i, M i` which agree on each `single i x` agree everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\\n  [inst_3 : ContinuousConstSMul Î“ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group action is an open\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {n : â„•âˆ}\\n  {E' : Type u_1} [inst_5 : NormedAddCommGroup E'] [inst_6 : NormedSpace ğ•œ E'] {F' : Type u_3}\\n  [inst_7 : NormedAddCommGroup F'] [inst_8 : NormedSpace ğ•œ F'] {s : Set E} {t : Set E'} {f : E â†’ F} {g : E' â†’ F'},\\n  ContDiffOn ğ•œ n f s â†’ ContDiffOn ğ•œ n g t â†’ ContDiffOn ğ•œ n (Prod.map f g) (s Ã—Ë¢ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product map of two `C^n` functions on a set is `C^n` on the product set. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q),\\n  CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f)\",\n  \"isProp\": true,\n  \"docString\": \"The map `p : P âŸ¶ image f` is an epimorphism \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\\n  AnalyticOn â„‚ g U â†’\\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `â„‚`). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\\n  Set.InvOn f g (Function.fixedPoints (f âˆ˜ g)) (Function.fixedPoints (g âˆ˜ f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two maps `f : Î± â†’ Î²` and `g : Î² â†’ Î±` are inverse of each other on the sets of fixed points\\nof `f âˆ˜ g` and `g âˆ˜ f`, respectively. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} [inst : AddGroup Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Î“ T]\\n  [inst_3 : ContinuousConstVAdd Î“ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group\\naction is an open quotient. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second projection in a product of topological spaces sends open sets to open sets. \"}]\n",
    "prompt_cons": "/-- If each `fâ‚€ i : C(X, Y i)` is homotopic to `fâ‚ i : C(X, Y i)`, then `ContinuousMap.pi fâ‚€` is\nhomotopic to `ContinuousMap.pi fâ‚`. -/\ntheorem âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type u_1} {Y : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)]\n  {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X, Y i)},\n  (âˆ€ (i : Î¹), ContinuousMap.Homotopic (fâ‚€ i) (fâ‚ i)) â†’\n    ContinuousMap.Homotopic (ContinuousMap.pi fâ‚€) (ContinuousMap.pi fâ‚) :=\n\n/-- If `f` is an affine map, then its linear part is an open map iff `f` is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, IsOpenMap â†‘f.linear â†” IsOpenMap â†‘f :=\n\n/-- If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. -/\ntheorem âˆ€ {X Y S : TopCat} {f : X âŸ¶ S} {g : Y âŸ¶ S},\n  OpenEmbedding â†‘f â†’\n    OpenEmbedding â†‘g â†’\n      OpenEmbedding\n        â†‘(CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one) :=\n\n/-- A surjective linear map `f` with finite dimensional codomain is an open map. -/\ntheorem âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module ğ•œ E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ğ•œ E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul ğ•œ F] [inst_10 : CompleteSpace ğ•œ] [inst_11 : T2Space E] [inst_12 : FiniteDimensional ğ•œ E]\n  (f : F â†’â‚—[ğ•œ] E), Function.Surjective â†‘f â†’ IsOpenMap â†‘f :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- If `P` holds for `f âˆ£_ U` for an open cover `U` of `Y`, then `P` holds for `f`. -/\ntheorem âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (ğ’° : AlgebraicGeometry.Scheme.OpenCover Y),\n      (âˆ€ (i : ğ’°.J), P CategoryTheory.Limits.pullback.snd) â†’ P f :=\n\n/-- If `Ï€ : Y âŸ¶ Z` is an equalizer for `(f, g)`, and `U âŠ† Y` such that `f â»Â¹' U = g â»Â¹' U`,\nthen `Ï€ â»Â¹' (Ï€ '' U) = U`. -/\ntheorem âˆ€ {X Y Z : Type u} (f g : X âŸ¶ Y) (Ï€ : Y âŸ¶ Z)\n  (e : CategoryTheory.CategoryStruct.comp f Ï€ = CategoryTheory.CategoryStruct.comp g Ï€),\n  CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.Cofork.ofÏ€ Ï€ e) â†’\n    âˆ€ (U : Set Y), f â»Â¹' U = g â»Â¹' U â†’ Ï€ â»Â¹' (Ï€ '' U) = U :=\n\n/-- If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²}\n  {f : Î± â†’ Î²}, Set.MapsTo f s t â†’ Continuous f â†’ IsClosed t â†’ Set.MapsTo f (closure s) t :=\n\n/-- If `X` is a compact topological space, then `Prod.snd : X Ã— Y â†’ Y` is a closed map. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] {Y : Type u_2} [inst_2 : TopologicalSpace Y],\n  IsClosedMap Prod.snd :=\n\n/-- The map `(x, y) â†¦ (xy, y)` preserves the measure `Î¼ Ã— Î½`. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  [inst_5 : MeasureTheory.Measure.IsMulRightInvariant Î¼],\n  MeasureTheory.MeasurePreserving fun z => (z.fst * z.snd, z.snd) :=\n\n/-- If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\n`g âˆ˜ f` is measurable if and only if `g` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g :=\n\n/-- Two `R`-linear maps from `Î â‚€ i, M i` which agree on each `single i x` agree everywhere. -/\ntheorem âˆ€ {Î¹ : Type u_3} {R : Type u_1} {M : Î¹ â†’ Type u_2} {N : Type u_4} [dec_Î¹ : DecidableEq Î¹] [inst : Semiring R]\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] [inst_3 : AddCommMonoid N]\n  [inst_4 : Module R N] â¦ƒÏ† Ïˆ : (Î â‚€ (i : Î¹), M i) â†’â‚—[R] Nâ¦„,\n  (âˆ€ (i : Î¹) (x : M i), â†‘Ï† (DFinsupp.single i x) = â†‘Ïˆ (DFinsupp.single i x)) â†’ Ï† = Ïˆ :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\nquotient. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : Group Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Î“ T]\n  [inst_3 : ContinuousConstSMul Î“ T], IsOpenMap Quotient.mk' :=\n\n/-- The product map of two `C^n` functions on a set is `C^n` on the product set. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {n : â„•âˆ}\n  {E' : Type u_1} [inst_5 : NormedAddCommGroup E'] [inst_6 : NormedSpace ğ•œ E'] {F' : Type u_3}\n  [inst_7 : NormedAddCommGroup F'] [inst_8 : NormedSpace ğ•œ F'] {s : Set E} {t : Set E'} {f : E â†’ F} {g : E' â†’ F'},\n  ContDiffOn ğ•œ n f s â†’ ContDiffOn ğ•œ n g t â†’ ContDiffOn ğ•œ n (Prod.map f g) (s Ã—Ë¢ t) :=\n\n/-- The map `p : P âŸ¶ image f` is an epimorphism -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q),\n  CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f) :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `â„‚`). -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\n  AnalyticOn â„‚ g U â†’\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s) :=\n\n/-- Any two maps `f : Î± â†’ Î²` and `g : Î² â†’ Î±` are inverse of each other on the sets of fixed points\nof `f âˆ˜ g` and `g âˆ˜ f`, respectively. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Set.InvOn f g (Function.fixedPoints (f âˆ˜ g)) (Function.fixedPoints (g âˆ˜ f)) :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. -/\ntheorem âˆ€ {Î“ : Type u_1} [inst : AddGroup Î“] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Î“ T]\n  [inst_3 : ContinuousConstVAdd Î“ T], IsOpenMap Quotient.mk' :=\n\n/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.snd :=\n\n/-- A map `f: X â†’ Y` is said to be an open map if for every open set `U` of `X`, the set `f(U)` is open in `Y`. Show that `Ï€â‚: X Ã— Y â†’ X` and `Ï€â‚‚: X Ã— Y â†’ Y` are open maps. -/\ntheorem",
    "choices": [
      "{X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst ",
      "forall {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ",
      "âˆ€ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²],\n  IsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst ",
      "{X Y : Type u} [TopologicalSpace X] [TopologicalSpace Y],\nIsOpenMap Prod.fst âˆ§ IsOpenMap Prod.snd "
    ]
  },
  {
    "docString": "Show that if `U` is open in `X` and `A` is closed in `X`, then `U - A` is open in `X`, and `A - U` is closed in `X`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U Z : Set Î±},\\n  IsPreirreducible Z â†’ Set.Nonempty U â†’ IsOpen U â†’ U âŠ† S â†’ S âŠ† Z â†’ IsIrreducible S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `âˆ… â‰  U âŠ† S âŠ† Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\\nsuch that `VV âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\\n  x â‰  y â†’\\n    âˆƒ Uâ‚,\\n      Uâ‚ âˆˆ nhds x âˆ§\\n        âˆƒ Vâ‚,\\n          Vâ‚ âˆˆ nhds x âˆ§\\n            âˆƒ Uâ‚‚,\\n              Uâ‚‚ âˆˆ nhds y âˆ§\\n                âˆƒ Vâ‚‚,\\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ V + K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `V + K âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `V * K âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `K * V âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (ğ’° : AlgebraicGeometry.Scheme.OpenCover Y),\\n      (âˆ€ (i : ğ’°.J), P CategoryTheory.Limits.pullback.snd) â†’ P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` holds for `f âˆ£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.  \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (U : TopologicalSpace.Opens â†‘â†‘Y.toPresheafedSpace), P f â†’ P (f âˆ£_ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` holds for `f : X âŸ¶ Y`, then `P` holds for `f âˆ£_ U` for any `U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {s : Set X} [inst_1 : NormalSpace X]\\n  [inst_2 : ParacompactSpace X],\\n  IsClosed s â†’\\n    âˆ€ (U : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ âˆƒ f, PartitionOfUnity.IsSubordinate f U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\\n`s`, then there exists a `PartitionOfUnity Î¹ X s` that is subordinate to `U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {X : TopCat} {Î¹ : Type w} (U : Î¹ â†’ TopologicalSpace.Opens â†‘X),\\n  CategoryTheory.Functor.Final (TopCat.Presheaf.SheafCondition.pairwiseToOpensLeCover U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The diagram consisting of the `U i` and `U i âŠ“ U j` is cofinal in the diagram\\nof all opens contained in some `U i`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {X Y S : TopCat} {f : X âŸ¶ S} {g : Y âŸ¶ S},\\n  OpenEmbedding â†‘f â†’\\n    OpenEmbedding â†‘g â†’\\n      OpenEmbedding\\n        â†‘(CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {s : Set X} [inst_1 : NormalSpace X]\\n  [inst_2 : ParacompactSpace X],\\n  IsClosed s â†’ âˆ€ (U : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ âˆƒ f, BumpCovering.IsSubordinate f U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\\n`s`, then there exists a `BumpCovering Î¹ X s` that is subordinate to `U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} {x : Î±} {U : Set Î±},\\n  AccPt x (Filter.principal C) â†’ U âˆˆ nhds x â†’ AccPt x (Filter.principal (U âˆ© C))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is an accumulation point of a set `C` and `U` is a neighborhood of `x`,\\nthen `x` is an accumulation point of `U âˆ© C`. \"}]\n",
    "prompt_cons": "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- If `âˆ… â‰  U âŠ† S âŠ† Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U Z : Set Î±},\n  IsPreirreducible Z â†’ Set.Nonempty U â†’ IsOpen U â†’ U âŠ† S â†’ S âŠ† Z â†’ IsIrreducible S :=\n\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U :=\n\n/-- Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\n  x â‰  y â†’\n    âˆƒ Uâ‚,\n      Uâ‚ âˆˆ nhds x âˆ§\n        âˆƒ Vâ‚,\n          Vâ‚ âˆˆ nhds x âˆ§\n            âˆƒ Uâ‚‚,\n              Uâ‚‚ âˆˆ nhds y âˆ§\n                âˆƒ Vâ‚‚,\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚ :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `V + K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ V + K âŠ† U :=\n\n/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `V * K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `K * V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U :=\n\n/-- If `P` holds for `f âˆ£_ U` for an open cover `U` of `Y`, then `P` holds for `f`. -/\ntheorem âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (ğ’° : AlgebraicGeometry.Scheme.OpenCover Y),\n      (âˆ€ (i : ğ’°.J), P CategoryTheory.Limits.pullback.snd) â†’ P f :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- If `P` holds for `f : X âŸ¶ Y`, then `P` holds for `f âˆ£_ U` for any `U`. -/\ntheorem âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (U : TopologicalSpace.Opens â†‘â†‘Y.toPresheafedSpace), P f â†’ P (f âˆ£_ U) :=\n\n/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `PartitionOfUnity Î¹ X s` that is subordinate to `U`. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {s : Set X} [inst_1 : NormalSpace X]\n  [inst_2 : ParacompactSpace X],\n  IsClosed s â†’\n    âˆ€ (U : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ âˆƒ f, PartitionOfUnity.IsSubordinate f U :=\n\n/-- In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V) :=\n\n/-- The diagram consisting of the `U i` and `U i âŠ“ U j` is cofinal in the diagram\nof all opens contained in some `U i`. -/\ntheorem âˆ€ {X : TopCat} {Î¹ : Type w} (U : Î¹ â†’ TopologicalSpace.Opens â†‘X),\n  CategoryTheory.Functor.Final (TopCat.Presheaf.SheafCondition.pairwiseToOpensLeCover U) :=\n\n/-- If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. -/\ntheorem âˆ€ {X Y S : TopCat} {f : X âŸ¶ S} {g : Y âŸ¶ S},\n  OpenEmbedding â†‘f â†’\n    OpenEmbedding â†‘g â†’\n      OpenEmbedding\n        â†‘(CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one) :=\n\n/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `BumpCovering Î¹ X s` that is subordinate to `U`. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {s : Set X} [inst_1 : NormalSpace X]\n  [inst_2 : ParacompactSpace X],\n  IsClosed s â†’ âˆ€ (U : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ s âŠ† â‹ƒ (i : Î¹), U i â†’ âˆƒ f, BumpCovering.IsSubordinate f U :=\n\n/-- If `x` is an accumulation point of a set `C` and `U` is a neighborhood of `x`,\nthen `x` is an accumulation point of `U âˆ© C`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} {x : Î±} {U : Set Î±},\n  AccPt x (Filter.principal C) â†’ U âˆˆ nhds x â†’ AccPt x (Filter.principal (U âˆ© C)) :=\n\n/-- Show that if `U` is open in `X` and `A` is closed in `X`, then `U - A` is open in `X`, and `A - U` is closed in `X`. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U - A) âˆ§ IsClosed (A - U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U - A) âˆ§ IsClosed (A - U) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U - A) âˆ§ IsClosed (A - U) ",
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] {U A : Set X},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U - A) âˆ§ IsClosed (A - U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {U A : Set X},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {U A : Set Î±},\n  IsOpen U â†’ IsClosed A â†’ IsOpen (U \\ A) âˆ§ IsClosed (A \\ U) "
    ]
  },
  {
    "docString": "Let `Y` be an ordered set in the order topology. Let `f, g: X â†’ Y` be continuous. Let `h: X â†’ Y` be the function `h(x) = min {f(x), g(x)}`. Show that `h` is continuous.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x)\",\n  \"isProp\": true,\n  \"docString\": \"`x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’\\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\\n  ContinuousAt g a â†’\\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\\nan inverse function. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\\n  IsPreconnected s â†’\\n    âˆ€ {a b : X},\\n      a âˆˆ s â†’\\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\\nthen for some `x âˆˆ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\\n`g âˆ˜ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : NormedSpace â„ E] [inst_4 : OpensMeasurableSpace X]\\n  [inst_5 : T2Space X],\\n  MeasureTheory.LocallyIntegrable f â†’\\n    âˆ€ {g : X â†’ â„}, Continuous g â†’ HasCompactSupport g â†’ MeasureTheory.Integrable fun x => g x â€¢ f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is locally integrable and `g` is continuous with compact support,\\nthen `g â€¢ f` is integrable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y] {K : NNReal} {f : X â†’ Y} {s : Set X},\\n  LipschitzOnWith K f s â†’ dimH (f '' s) â‰¤ dimH s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X â†’ Y` is Lipschitz continuous on `s`, then `dimH (f '' s) â‰¤ dimH s`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ},\\n  ContinuousAt g a â†’\\n    HasStrictDerivAt f f' (g a) â†’ f' â‰  0 â†’ (âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) â†’ HasStrictDerivAt g f'â»Â¹ a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\\nin the strict sense.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\\ninverse function. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {Î¼ : MeasureTheory.Measure X} [inst_3 : NormedSpace â„ E] [inst_4 : OpensMeasurableSpace X] [inst_5 : T2Space X]\\n  {f : X â†’ â„},\\n  MeasureTheory.LocallyIntegrable f â†’\\n    âˆ€ {g : X â†’ E}, Continuous g â†’ HasCompactSupport g â†’ MeasureTheory.Integrable fun x => f x â€¢ g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is locally integrable and `g` is continuous with compact support,\\nthen `f â€¢ g` is integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LE Î²] {f g : Î± â†’ Î²} {a : Î±},\\n  f â‰¤á¶ [nhds a] g â†’ âˆ€á¶  (y : Î±) in nhds a, f â‰¤á¶ [nhds y] g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f x â‰¤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\\n`f x â‰¤ g x` in a neighbourhood of `y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\\n  [inst_6 : OrderClosedTopology Î´] {s : Set Î±} [hs : Set.OrdConnected s] {f : Î± â†’ Î´},\\n  ContinuousOn f s â†’ âˆ€ {a b : Î±}, a âˆˆ s â†’ b âˆˆ s â†’ Set.SurjOn f s (Set.uIcc (f a) (f b))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\\n  {f : PartitionOfUnity Î¹ X s} [inst_5 : ContinuousAdd E] {U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n    PartitionOfUnity.IsSubordinate f U â†’\\n      âˆ€ {g : Î¹ â†’ X â†’ E}, (âˆ€ (i : Î¹), ContinuousOn (g i) (U i)) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\\n`g : Î¹ â†’ X â†’ E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is a continuous function. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : SMul M Î±] [self : MulAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g â€¢ x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g â€¢ x = y`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. \"}]\n",
    "prompt_cons": "/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- `x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG}\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ğ•œ G] {f : E â†’ F â†’ G} {g : E â†’ F} {n : â„•âˆ},\n  ContDiff ğ•œ n (Function.uncurry f) â†’ Continuous g â†’ 1 â‰¤ n â†’ Continuous fun x => fderiv ğ•œ (f x) (g x) :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- If a function `f x y` is such that `y â†¦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] [inst_3 : DiscreteTopology Î±] {f : Î± â†’ Î² â†’ Î³},\n  (âˆ€ (a : Î±), Continuous (f a)) â†’ Continuous (Function.uncurry f) :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F},\n  ContinuousAt g a â†’\n    HasFDerivAt f (â†‘f') (g a) â†’ (âˆ€á¶  (y : F) in nhds a, f (g y) = y) â†’ HasFDerivAt g (â†‘(ContinuousLinearEquiv.symm f')) a :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {s : Set X},\n  IsPreconnected s â†’\n    âˆ€ {a b : X},\n      a âˆˆ s â†’\n        b âˆˆ s â†’ âˆ€ {f g : X â†’ Î±}, ContinuousOn f s â†’ ContinuousOn g s â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, x âˆˆ s âˆ§ f x = g x :=\n\n/-- If `f : X â†’ Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `Î±` and `g : Y â†’ Î±`, the composition\n`g âˆ˜ f` is measurable if and only if `g` is measurable. -/\ntheorem âˆ€ {X : Type u_2} {Y : Type u_1} {Î² : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace Î²]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X â†’ Y},\n  Measurable f â†’ Function.Surjective f â†’ âˆ€ {g : Y â†’ Î²}, Measurable (g âˆ˜ f) â†” Measurable g :=\n\n/-- If `f` is locally integrable and `g` is continuous with compact support,\nthen `g â€¢ f` is integrable. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : NormedSpace â„ E] [inst_4 : OpensMeasurableSpace X]\n  [inst_5 : T2Space X],\n  MeasureTheory.LocallyIntegrable f â†’\n    âˆ€ {g : X â†’ â„}, Continuous g â†’ HasCompactSupport g â†’ MeasureTheory.Integrable fun x => g x â€¢ f x :=\n\n/-- If `f : X â†’ Y` is Lipschitz continuous on `s`, then `dimH (f '' s) â‰¤ dimH s`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y] {K : NNReal} {f : X â†’ Y} {s : Set X},\n  LipschitzOnWith K f s â†’ dimH (f '' s) â‰¤ dimH s :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\nin the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ},\n  ContinuousAt g a â†’\n    HasStrictDerivAt f f' (g a) â†’ f' â‰  0 â†’ (âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) â†’ HasStrictDerivAt g f'â»Â¹ a :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U âˆˆ ğ“ X` and a function `g : X â†’ E` that is\ncontinuous on `U` and sends each `y âˆˆ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x âˆˆ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’\n    (âˆ€ (x : X), âˆƒ U, U âˆˆ nhds x âˆ§ âˆƒ g, ContinuousOn g U âˆ§ âˆ€ (y : X), y âˆˆ U â†’ g y âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- If `f` is locally integrable and `g` is continuous with compact support,\nthen `f â€¢ g` is integrable. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {Î¼ : MeasureTheory.Measure X} [inst_3 : NormedSpace â„ E] [inst_4 : OpensMeasurableSpace X] [inst_5 : T2Space X]\n  {f : X â†’ â„},\n  MeasureTheory.LocallyIntegrable f â†’\n    âˆ€ {g : X â†’ E}, Continuous g â†’ HasCompactSupport g â†’ MeasureTheory.Integrable fun x => f x â€¢ g x :=\n\n/-- If `f x â‰¤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x â‰¤ g x` in a neighbourhood of `y`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : LE Î²] {f g : Î± â†’ Î²} {a : Î±},\n  f â‰¤á¶ [nhds a] g â†’ âˆ€á¶  (y : Î±) in nhds a, f â‰¤á¶ [nhds y] g :=\n\n/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. -/\ntheorem âˆ€ {Î± : Type u} [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : DenselyOrdered Î±] {Î´ : Type u_1} [inst_4 : LinearOrder Î´] [inst_5 : TopologicalSpace Î´]\n  [inst_6 : OrderClosedTopology Î´] {s : Set Î±} [hs : Set.OrdConnected s] {f : Î± â†’ Î´},\n  ContinuousOn f s â†’ âˆ€ {a b : Î±}, a âˆˆ s â†’ b âˆˆ s â†’ Set.SurjOn f s (Set.uIcc (f a) (f b)) :=\n\n/-- If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\n`g : Î¹ â†’ X â†’ E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is a continuous function. -/\ntheorem âˆ€ {Î¹ : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero â„ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul â„ E] {s : Set X}\n  {f : PartitionOfUnity Î¹ X s} [inst_5 : ContinuousAdd E] {U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n    PartitionOfUnity.IsSubordinate f U â†’\n      âˆ€ {g : Î¹ â†’ X â†’ E}, (âˆ€ (i : Î¹), ContinuousOn (g i) (U i)) â†’ Continuous fun x => âˆ‘á¶  (i : Î¹), â†‘(â†‘f i) x â€¢ g i x :=\n\n/-- There is `g` such that `g â€¢ x = y`. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : SMul M Î±] [self : MulAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g â€¢ x = y :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X â†’ Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x âˆˆ t x` for all\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. -/\ntheorem âˆ€ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module â„ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul â„ E] {t : X â†’ Set E},\n  (âˆ€ (x : X), Convex â„ (t x)) â†’ (âˆ€ (x : X), âˆƒ c, âˆ€á¶  (y : X) in nhds x, c âˆˆ t y) â†’ âˆƒ g, âˆ€ (x : X), â†‘g x âˆˆ t x :=\n\n/-- Let `Y` be an ordered set in the order topology. Let `f, g: X â†’ Y` be continuous. Let `h: X â†’ Y` be the function `h(x) = min {f(x), g(x)}`. Show that `h` is continuous. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x) ",
      "forall {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [LinearOrder Y]\n  [OrderTopology Y] (f g : X â†’ Y),\n  Continuous f â†’ Continuous g â†’ Continuous (fun x => min (f x) (g x)) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n[inst_3 : OrderTopology Y] {f g h : X â†’ Y},\n(âˆ€ (x : X), h x = min (f x) (g x)) â†’ Continuous f â†’ Continuous g â†’ Continuous h ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y] [inst_3 : OrderTopology Y]\n  {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "forall {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n[inst_3 : OrderTopology Y] {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y},\n  Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x) ",
      "âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ Continuous fun x => min (f x) (g x) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n[inst_3 : OrderTopology Y] {f g : X â†’ Y},\nContinuous f â†’ Continuous g â†’ Continuous fun x => LinearOrder.min (f x) (g x) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X â†’ Y}, Continuous f â†’ Continuous g â†’ Continuous (Î» x, min (f x) (g x)) "
    ]
  },
  {
    "docString": "Let `x_1, x_2, ...` be a sequence of the points of the product space `Î  X_Î±`. Show that this sequence converges to the point `x` if and only if the sequence `Ï€_Î±(x_i)` converges to `Ï€_Î±(x)` for each `Î±`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {Î³ : Type u_1}\\n  [inst_2 : AddCommMonoid Î²] [inst_3 : ContinuousAdd Î²] {f : Î³ â†’ C(Î±, Î²)} {g : C(Î±, Î²)},\\n  HasSum f g â†’ âˆ€ (x : Î±), HasSum (fun i => â†‘(f i) x) (â†‘g x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is locally compact, and an infinite sum of functions in `C(Î±, Î²)`\\nconverges to `g` (for the compact-open topology), then the pointwise sum converges to `g x` for\\nall `x âˆˆ Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\\n  CauchySeq F â†’\\n    âˆ€ {f : { x // x âˆˆ lp E p }},\\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\\n`lp E p`, then it converges to `f` in the `lp E p` topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} [inst : Filter.IsCountablyGenerated l],\\n  (âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.atTop l â†’ âˆƒ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) â†’\\n    Filter.Tendsto x l f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequence converges if every subsequence has a convergent subsequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\\n  CauchySeq u â†’\\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop â†’\\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {p : Filter Î¹} {c : Î²},\\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ âŠ¤) (nhds c) â†” TendstoUniformly F (fun x => c) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Uniform convergence to a constant function is equivalent to convergence in `p Ã—Ë¢ âŠ¤`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\\n  Summable u â†’\\n    IsOpen s â†’\\n      IsPreconnected s â†’\\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\\nat a point, and all functions in the series are differentiable with a summable bound on the\\nderivatives, then the series converges everywhere on the set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\": \"âˆ€ {Î¾ : â„¤} (n : â„•), Real.convergent (â†‘Î¾) n = â†‘Î¾\",\n  \"isProp\": true,\n  \"docString\": \"If `Î¾` is an integer, all its convergents equal `Î¾`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Î³ : Type u_1} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] [inst : MeasurableSpace Î³]\\n  {Î² : Type u_3} [inst_1 : MeasurableSpace Î²] [hÎ³ : OpensMeasurableSpace Î³] [inst_2 : Countable Î¹] {l : Filter Î¹}\\n  [inst_3 : Filter.IsCountablyGenerated l] {f : Î¹ â†’ Î² â†’ Î³},\\n  (âˆ€ (i : Î¹), Measurable (f i)) â†’ MeasurableSet {x | âˆƒ c, Filter.Tendsto (fun n => f n x) l (nhds c)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of points for which a measurable sequence of functions converges is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.FirstCountableTopology Î±] {u : â„• â†’ Î±} {x : Î±},\\n  MapClusterPt x Filter.atTop u â†’ âˆƒ Ïˆ, StrictMono Ïˆ âˆ§ Filter.Tendsto (u âˆ˜ Ïˆ) Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first-countable space, a cluster point `x` of a sequence\\nis the limit of some subsequence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\\n  (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\\n      MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence a.e. implies convergence in measure in a finite measure space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n =á¶ [ğ“ x] F`. \"}]\n",
    "prompt_cons": "/-- If `Î±` is locally compact, and an infinite sum of functions in `C(Î±, Î²)`\nconverges to `g` (for the compact-open topology), then the pointwise sum converges to `g x` for\nall `x âˆˆ Î±`. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {Î³ : Type u_1}\n  [inst_2 : AddCommMonoid Î²] [inst_3 : ContinuousAdd Î²] {f : Î³ â†’ C(Î±, Î²)} {g : C(Î±, Î²)},\n  HasSum f g â†’ âˆ€ (x : Î±), HasSum (fun i => â†‘(f i) x) (â†‘g x) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {K : Set Î±},\n  IsComplete K â†’ âˆ€ {u : Î² â†’ Î±}, (âˆ€ (n : Î²), u n âˆˆ K) â†’ CauchySeq u â†’ âˆƒ v, v âˆˆ K âˆ§ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [_i : Fact (1 â‰¤ p)]\n  {F : â„• â†’ { x // x âˆˆ lp E p }},\n  CauchySeq F â†’\n    âˆ€ {f : { x // x âˆˆ lp E p }},\n      Filter.Tendsto (id fun i => â†‘(F i)) Filter.atTop (nhds â†‘f) â†’ Filter.Tendsto F Filter.atTop (nhds f) :=\n\n/-- A sequence converges if every subsequence has a convergent subsequence. -/\ntheorem âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} [inst : Filter.IsCountablyGenerated l],\n  (âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.atTop l â†’ âˆƒ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) â†’\n    Filter.Tendsto x l f :=\n\n/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : UniformSpace Î²] {ğ”– : Set (Set Î±)} [inst_1 : T2Space Î²],\n  â‹ƒâ‚€ ğ”– = Set.univ â†’ T2Space (UniformOnFun Î± Î² ğ”–) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] {u : Î² â†’ Î±},\n  CauchySeq u â†’\n    âˆ€ {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop â†’\n        âˆ€ {a : Î±}, Filter.Tendsto (u âˆ˜ f) p (nhds a) â†’ Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- Uniform convergence to a constant function is equivalent to convergence in `p Ã—Ë¢ âŠ¤`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {p : Filter Î¹} {c : Î²},\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ âŠ¤) (nhds c) â†” TendstoUniformly F (fun x => c) p :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series converges everywhere on the set. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\n  Summable u â†’\n    IsOpen s â†’\n      IsPreconnected s â†’\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- If `Î¾` is an integer, all its convergents equal `Î¾`. -/\ntheorem âˆ€ {Î¾ : â„¤} (n : â„•), Real.convergent (â†‘Î¾) n = â†‘Î¾ :=\n\n/-- The set of points for which a measurable sequence of functions converges is measurable. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Î³ : Type u_1} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] [inst : MeasurableSpace Î³]\n  {Î² : Type u_3} [inst_1 : MeasurableSpace Î²] [hÎ³ : OpensMeasurableSpace Î³] [inst_2 : Countable Î¹] {l : Filter Î¹}\n  [inst_3 : Filter.IsCountablyGenerated l] {f : Î¹ â†’ Î² â†’ Î³},\n  (âˆ€ (i : Î¹), Measurable (f i)) â†’ MeasurableSet {x | âˆƒ c, Filter.Tendsto (fun n => f n x) l (nhds c)} :=\n\n/-- In a first-countable space, a cluster point `x` of a sequence\nis the limit of some subsequence. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.FirstCountableTopology Î±] {u : â„• â†’ Î±} {x : Î±},\n  MapClusterPt x Filter.atTop u â†’ âˆƒ Ïˆ, StrictMono Ïˆ âˆ§ Filter.Tendsto (u âˆ˜ Ïˆ) Filter.atTop (nhds x) :=\n\n/-- Convergence a.e. implies convergence in measure in a finite measure space. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [inst_1 : MeasureTheory.IsFiniteMeasure Î¼],\n  (âˆ€ (n : â„•), MeasureTheory.AEStronglyMeasurable (f n) Î¼) â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) â†’\n      MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g :=\n\n/-- Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =á¶ [ğ“ x] F`. -/\ntheorem âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F :=\n\n/-- Let `x_1, x_2, ...` be a sequence of the points of the product space `Î  X_Î±`. Show that this sequence converges to the point `x` if and only if the sequence `Ï€_Î±(x_i)` converges to `Ï€_Î±(x)` for each `Î±`. -/\ntheorem",
    "choices": [
      "âˆ€ {J : Type u_1} {X : J â†’ Type u_2} [inst : (j : J) â†’ TopologicalSpace (X j)] {x : (j : J) â†’ X j} {x_i : â„• â†’ (j : J) â†’ X j},\n  Filter.Tendsto x_i Filter.atTop (nhds x) â†” âˆ€ (j : J), Filter.Tendsto (fun n => x_i n j) Filter.atTop (nhds (x j)) ",
      "âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {p : â„• â†’ Î  i, Ï€ i} {x : Î  i, Ï€ i},\n  Filter.Tendsto p Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => p n i) Filter.atTop (nhds (x i)) ",
      "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] {x : (i : Î¹) â†’ X i} {x_1 : â„• â†’ (i : Î¹) â†’ X i},\n  Filter.Tendsto x_1 Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x_1 n i) Filter.atTop (nhds (x i)) ",
      "âˆ€ {Î± : Type u_2} {X : Î± â†’ Type u_1} [inst : (a : Î±) â†’ TopologicalSpace (X a)] {x : (a : Î±) â†’ X a} {xâ‚€ : â„• â†’ (a : Î±) â†’ X a},\n  Filter.Tendsto xâ‚€ Filter.atTop (nhds x) â†” âˆ€ a, Filter.Tendsto (fun n => xâ‚€ n a) Filter.atTop (nhds (x a)) ",
      "âˆ€ {Î± : Type u_3} {Ï€ : Î± â†’ Type u_1} [inst : (i : Î±) â†’ TopologicalSpace (Ï€ i)] {x : (i : Î±) â†’ Ï€ i} {x_seq : â„• â†’ (i : Î±) â†’ Ï€ i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) â†” âˆ€ (i : Î±), Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i)) ",
      "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] {x : (i : Î¹) â†’ X i} {x_seq : â„• â†’ (i : Î¹) â†’ X i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (Î» n => x_seq n i) Filter.atTop (nhds (x i)) ",
      "âˆ€ {Î¹ : Type u_2} {X : Î¹ â†’ Type u_1} [_i : (i : Î¹) â†’ TopologicalSpace (X i)] {x : (i : Î¹) â†’ X i} {x' : â„• â†’ (i : Î¹) â†’ X i},\n  Filter.Tendsto x' Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x' n i) Filter.atTop (nhds (x i)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] {X : Î± â†’ Type u_2} [inst_1 : (a : Î±) â†’ TopologicalSpace (X a)]\n  {x : (a : Î±) â†’ X a} {xÎ¹ : â„• â†’ (a : Î±) â†’ X a},\n  Filter.Tendsto xÎ¹ Filter.atTop (nhds x) â†” âˆ€ (a : Î±), Filter.Tendsto (fun n => xÎ¹ n a) Filter.atTop (nhds (x a)) ",
      "âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {x : (i : Î¹) â†’ Ï€ i} {x_i : â„• â†’ (i : Î¹) â†’ Ï€ i},\n  Filter.Tendsto x_i Filter.atTop (nhds x) â†” âˆ€ (i : Î¹), Filter.Tendsto (fun n => x_i n i) Filter.atTop (nhds (x i)) ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : (a : Î±) â†’ TopologicalSpace (Î² a)] {A : Î±} {F : â„• â†’ (Î  a, Î² a)} {x : Î  a, Î² a},\n  Filter.Tendsto F Filter.atTop (nhds x) â†” âˆ€ a, Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (x a)) "
    ]
  },
  {
    "docString": "Define `f_n: [0,1] â†’ â„` by the equation `f_n(x) = x^n`. Show that the sequence `(f_n(x))` converges for each `x âˆˆ [0,1]`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift) (x : â„),\\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : â„` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), ConvexOn â„ (Set.Ici 0) fun x => x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"`x^n`, `n : â„•` is convex on `[0, +âˆ)` for all `n`.\\n\\nWe give an elementary proof rather than using the second derivative test, since this lemma is\\nneeded early in the analysis library. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 2 â‰¤ n â†’ StrictConvexOn â„ (Set.Ici 0) fun x => x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"`x^n`, `n : â„•` is strictly convex on `[0, +âˆ)` for all `n` greater than `2`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(â„, E)},\\n  (Summable fun n => â€–ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight â†‘n))â€–) â†’\\n    MeasureTheory.Integrable â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sequence with `n`-th term the the sup norm of `Î» x, f (x + n)` on the interval `Icc 0 1`,\\nfor `n âˆˆ â„¤`, is summable, then `f` is integrable on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ (f : C(â†‘unitInterval, â„)), Filter.Tendsto (fun n => bernsteinApproximation n f) Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Bernstein approximations\\n```\\nâˆ‘ k : Fin (n+1), f (k/n : â„) * n.choose k * x^k * (1-x)^(n-k)\\n```\\nfor a continuous function `f : C([0,1], â„)` converge uniformly to `f` as `n` tends to infinity.\\n\\nThis is the proof given in [Richard Beals' *Analysis, an introduction*][beals-analysis], Â§7D,\\nand reproduced on wikipedia.\\n\"},\n {\"theorem\":\n  \"âˆ€ {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto f Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n =á¶ [ğ“ x] F`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, Even n â†’ n â‰  0 â†’ StrictConvexOn â„ Set.univ fun x => x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"`x^n`, `n : â„•` is strictly convex on the whole real line whenever `n â‰  0` is even. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\": \"For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalAddGroup Î±] {a b : Î±}\\n  {f g : â„• â†’ Î±}, HasSum f a â†’ HasSum g b â†’ HasSum (Int.rec f g) (a + b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` are both convergent then so is the `â„¤`-indexed\\nsequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...`. \"},\n {\"theorem\": \"âˆ€ {p : â„}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±} {x : Î±}, Monotone f â†’ x â‰¤ f x â†’ Monotone fun n => f^[n] x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone map and `x â‰¤ f x` at some point `x`, then the iterates `f^[n] x` form\\na monotone sequence. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : DivisionRing ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : CharZero ğ•œ] [inst_3 : Algebra â„ ğ•œ]\\n  [inst_4 : ContinuousSMul â„ ğ•œ] [inst_5 : TopologicalDivisionRing ğ•œ] (x : ğ•œ),\\n  Filter.Tendsto (fun n => â†‘n / (â†‘n + x)) Filter.atTop (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The limit of `n / (n + x)` is 1, for any constant `x` (valid in `â„` or any topological division\\nalgebra over `â„`, e.g., `â„‚`).\\n\\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\\nstatement simultaneously on `â„š`, `â„` and `â„‚`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {n : â„•âˆ} {f' : E â†’ FormalMultilinearSeries ğ•œ E F}, HasFTaylorSeriesUpTo n f f' â†’ ContDiff ğ•œ n f\",\n  \"isProp\": true,\n  \"docString\": \"If `f` has a Taylor series up to `n`, then it is `C^n`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), Filter.Tendsto (fun x => rexp x / x ^ n) Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `exp(x)/x^n` tends to `+âˆ` at `+âˆ`, for any natural number `n` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"}]\n",
    "prompt_cons": "/-- For any `x : â„` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem âˆ€ (f : CircleDeg1Lift) (x : â„),\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a) :=\n\n/-- `x^n`, `n : â„•` is convex on `[0, +âˆ)` for all `n`.\n\nWe give an elementary proof rather than using the second derivative test, since this lemma is\nneeded early in the analysis library. -/\ntheorem âˆ€ (n : â„•), ConvexOn â„ (Set.Ici 0) fun x => x ^ n :=\n\n/-- `x^n`, `n : â„•` is strictly convex on `[0, +âˆ)` for all `n` greater than `2`. -/\ntheorem âˆ€ {n : â„•}, 2 â‰¤ n â†’ StrictConvexOn â„ (Set.Ici 0) fun x => x ^ n :=\n\n/-- If the sequence with `n`-th term the the sup norm of `Î» x, f (x + n)` on the interval `Icc 0 1`,\nfor `n âˆˆ â„¤`, is summable, then `f` is integrable on `â„`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(â„, E)},\n  (Summable fun n => â€–ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight â†‘n))â€–) â†’\n    MeasureTheory.Integrable â†‘f :=\n\n/-- The Bernstein approximations\n```\nâˆ‘ k : Fin (n+1), f (k/n : â„) * n.choose k * x^k * (1-x)^(n-k)\n```\nfor a continuous function `f : C([0,1], â„)` converge uniformly to `f` as `n` tends to infinity.\n\nThis is the proof given in [Richard Beals' *Analysis, an introduction*][beals-analysis], Â§7D,\nand reproduced on wikipedia. -/\ntheorem âˆ€ (f : C(â†‘unitInterval, â„)), Filter.Tendsto (fun n => bernsteinApproximation n f) Filter.atTop (nhds f) :=\n\n/-- An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity. -/\ntheorem âˆ€ {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto f Filter.atTop Filter.atTop :=\n\n/-- Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =á¶ [ğ“ x] F`. -/\ntheorem âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F :=\n\n/-- `x^n`, `n : â„•` is strictly convex on the whole real line whenever `n â‰  0` is even. -/\ntheorem âˆ€ {n : â„•}, Even n â†’ n â‰  0 â†’ StrictConvexOn â„ Set.univ fun x => x ^ n :=\n\n/-- For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` are both convergent then so is the `â„¤`-indexed\nsequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalAddGroup Î±] {a b : Î±}\n  {f g : â„• â†’ Î±}, HasSum f a â†’ HasSum g b â†’ HasSum (Int.rec f g) (a + b) :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p :=\n\n/-- If `f` is a monotone map and `x â‰¤ f x` at some point `x`, then the iterates `f^[n] x` form\na monotone sequence. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {f : Î± â†’ Î±} {x : Î±}, Monotone f â†’ x â‰¤ f x â†’ Monotone fun n => f^[n] x :=\n\n/-- The limit of `n / (n + x)` is 1, for any constant `x` (valid in `â„` or any topological division\nalgebra over `â„`, e.g., `â„‚`).\n\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\nstatement simultaneously on `â„š`, `â„` and `â„‚`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : DivisionRing ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : CharZero ğ•œ] [inst_3 : Algebra â„ ğ•œ]\n  [inst_4 : ContinuousSMul â„ ğ•œ] [inst_5 : TopologicalDivisionRing ğ•œ] (x : ğ•œ),\n  Filter.Tendsto (fun n => â†‘n / (â†‘n + x)) Filter.atTop (nhds 1) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- If `f` has a Taylor series up to `n`, then it is `C^n`. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {n : â„•âˆ} {f' : E â†’ FormalMultilinearSeries ğ•œ E F}, HasFTaylorSeriesUpTo n f f' â†’ ContDiff ğ•œ n f :=\n\n/-- The function `exp(x)/x^n` tends to `+âˆ` at `+âˆ`, for any natural number `n` -/\ntheorem âˆ€ (n : â„•), Filter.Tendsto (fun x => rexp x / x ^ n) Filter.atTop Filter.atTop :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- Define `f_n: [0,1] â†’ â„` by the equation `f_n(x) = x^n`. Show that the sequence `(f_n(x))` converges for each `x âˆˆ [0,1]`. -/\ntheorem",
    "choices": [
      "âˆ€ (x : â„) (hx : 0 â‰¤ x) (hx' : x â‰¤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ (n : â„•) (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ (x : â„), x âˆˆ Set.Icc 0 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ (x : â„), 0 â‰¤ x âˆ§ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ (x : â„), x âˆˆ [0, 1] â†’ Filter.Tendsto (fun n => x^n) Filter.atTop (nhds 0) ",
      "âˆ€ (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ {x : â„} (hx : 0 â‰¤ x) (hx' : x â‰¤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ (x : â„) (hx : x âˆˆ Set.Icc 0 1), Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "forall (x : â„), 0 â‰¤ x â†’ x â‰¤ 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "âˆ€ (x : â„) (hx : x âˆˆ Set.Icc 0 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) "
    ]
  },
  {
    "docString": "Let `X` be a topological space and let `Y` be a metric space. Let `f_n: X â†’ Y` be a sequence of continuous functions. Let `x_n` be a sequence of points of `X` converging to `x`. Show that if the sequence `(f_n)` converges uniformly to `f`, then `(f_n(x_n))` converges to `f(x)`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  ContinuousAt f x â†’\\n    Filter.Tendsto g p (nhds x) â†’\\n      (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u) â†’\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` converges locally uniformly on a neighborhood of `x` to a function `f` which is\\ncontinuous at `x`, and `gâ‚™` tends to `x`, then `Fâ‚™ (gâ‚™)` tends to `f x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_3} {l : Filter Î¹} {E : Type u_1} [inst : NormedAddCommGroup E] {ğ•œ : Type u_4} [inst_1 : IsROrC ğ•œ]\\n  [inst_2 : NormedSpace ğ•œ E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace ğ•œ G] {f : Î¹ â†’ E â†’ G}\\n  {g : E â†’ G} {f' : Î¹ â†’ E â†’ E â†’L[ğ•œ] G} {g' : E â†’ E â†’L[ğ•œ] G} {x : E},\\n  TendstoUniformlyOnFilter f' g' l (nhds x) â†’\\n    (âˆ€á¶  (n : Î¹ Ã— E) in l Ã—Ë¢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) â†’\\n      (âˆ€á¶  (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) â†’\\n        TendstoUniformlyOnFilter (fun n y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (f n y - f n x)) (fun y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (g y - g x)) l\\n          (nhds x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f_n â†’ g` pointwise and the derivatives `(f_n)' â†’ h` _uniformly_ converge, then\\nin fact for a fixed `y`, the difference quotients `â€–z - yâ€–â»Â¹ â€¢ (f_n z - f_n y)` converge\\n_uniformly_ to `â€–z - yâ€–â»Â¹ â€¢ (g z - g y)` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  ContinuousWithinAt f s x â†’\\n    Filter.Tendsto g p (nhdsWithin x s) â†’\\n      (âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u) â†’\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\\nwhich is continuous at `x` within `s `, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ (gâ‚™)` tends\\nto `f x`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n =á¶ [ğ“ x] F`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {Ï€ : X â†’ Sort u_1} {f : â„• â†’ (x : X) â†’ Ï€ x},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’\\n    âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, âˆ€á¶  (y : X) in nhds x, f n y = F y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F : Î  a, Î² a` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n y = F y` in a neighbourhood of `x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [inst_2 : CompactSpace Î±],\\n  Filter.Tendsto F p (nhds f) â†” TendstoUniformly (fun i a => â†‘(F i) a) (â†‘f) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence in the compact-open topology is the same as uniform convergence for sequences of\\ncontinuous functions on a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E},\\n  MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\\n    âˆƒ ns, StrictMono ns âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun i => f (ns i) x) Filter.atTop (nhds (g x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a sequence of functions which converges in measure to `g`, then there exists a\\nsubsequence of `f` which converges a.e. to `g`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformlyOn F f p s â†’\\n    ContinuousWithinAt f s x â†’\\n      x âˆˆ s â†’ Filter.Tendsto g p (nhdsWithin x s) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` tends locally uniformly to `f` on a set `s`, and `gâ‚™` tends to `x` within `s`, then\\n`Fâ‚™ gâ‚™` tends to `f x` if `f` is continuous at `x` within `s` and `x âˆˆ s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformlyOn F f p s â†’\\n    ContinuousWithinAt f s x â†’ Filter.Tendsto g p (nhdsWithin x s) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` tends uniformly to `f` on a set `s`, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ gâ‚™`\\ntends to `f x` if `f` is continuous at `x` within `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’\\n    ContinuousAt f x â†’ Filter.Tendsto g p (nhds x) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` tends locally uniformly to `f`, and `gâ‚™` tends to `x`, then `Fâ‚™ gâ‚™` tends to `f x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {f : X â†’ Y}\\n  {x : X},\\n  (âˆƒ y, Filter.Tendsto f (nhdsWithin x A) (nhds y)) â†’ Filter.Tendsto f (nhdsWithin x A) (nhds (extendFrom A f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` converges to some `y` as `x` tends to `xâ‚€` within `A`,\\nthen `f` tends to `extendFrom A f x` as `x` tends to `xâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’\\n    ContinuousAt f x â†’ Filter.Tendsto g p (nhds x) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fâ‚™` tends uniformly to `f`, and `gâ‚™` tends to `x`, then `Fâ‚™ gâ‚™` tends to `f x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s\",\n  \"isProp\": true,\n  \"docString\": \"A sequence that converges uniformly is also uniformly Cauchy \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\\n  Summable u â†’\\n    IsOpen s â†’\\n      IsPreconnected s â†’\\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\\nat a point, and all functions in the series are differentiable with a summable bound on the\\nderivatives, then the series converges everywhere on the set. \"},\n {\"theorem\":\n  \"âˆ€ {T : â„} [hT : Fact (0 < T)] {f : C(AddCircle T, â„‚)},\\n  Summable (fourierCoeff â†‘f) â†’ HasSum (fun i => fourierCoeff (â†‘f) i â€¢ fourier i) f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sequence of Fourier coefficients of `f` is summable, then the Fourier series converges\\nuniformly to `f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±} {x y : Î±},\\n  Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) â†’ ContinuousAt f y â†’ Function.IsFixedPt f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the iterates `f^[n] x` converge to `y` and `f` is continuous at `y`,\\nthen `y` is a fixed point for `f`. \"}]\n",
    "prompt_cons": "/-- If `Fâ‚™` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `gâ‚™` tends to `x`, then `Fâ‚™ (gâ‚™)` tends to `f x`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  ContinuousAt f x â†’\n    Filter.Tendsto g p (nhds x) â†’\n      (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u) â†’\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If `f_n â†’ g` pointwise and the derivatives `(f_n)' â†’ h` _uniformly_ converge, then\nin fact for a fixed `y`, the difference quotients `â€–z - yâ€–â»Â¹ â€¢ (f_n z - f_n y)` converge\n_uniformly_ to `â€–z - yâ€–â»Â¹ â€¢ (g z - g y)` -/\ntheorem âˆ€ {Î¹ : Type u_3} {l : Filter Î¹} {E : Type u_1} [inst : NormedAddCommGroup E] {ğ•œ : Type u_4} [inst_1 : IsROrC ğ•œ]\n  [inst_2 : NormedSpace ğ•œ E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace ğ•œ G] {f : Î¹ â†’ E â†’ G}\n  {g : E â†’ G} {f' : Î¹ â†’ E â†’ E â†’L[ğ•œ] G} {g' : E â†’ E â†’L[ğ•œ] G} {x : E},\n  TendstoUniformlyOnFilter f' g' l (nhds x) â†’\n    (âˆ€á¶  (n : Î¹ Ã— E) in l Ã—Ë¢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) â†’\n      (âˆ€á¶  (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) â†’\n        TendstoUniformlyOnFilter (fun n y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (f n y - f n x)) (fun y => (â†‘â€–y - xâ€–)â»Â¹ â€¢ (g y - g x)) l\n          (nhds x) :=\n\n/-- If `Fâ‚™` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\nwhich is continuous at `x` within `s `, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ (gâ‚™)` tends\nto `f x`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  ContinuousWithinAt f s x â†’\n    Filter.Tendsto g p (nhdsWithin x s) â†’\n      (âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u) â†’\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =á¶ [ğ“ x] F`. -/\ntheorem âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F :=\n\n/-- Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F : Î  a, Î² a` such that for any `x`, for sufficiently large values of `n`, we have\n`f n y = F y` in a neighbourhood of `x`. -/\ntheorem âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {Ï€ : X â†’ Sort u_1} {f : â„• â†’ (x : X) â†’ Ï€ x},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’\n    âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, âˆ€á¶  (y : X) in nhds x, f n y = F y :=\n\n/-- Convergence in the compact-open topology is the same as uniform convergence for sequences of\ncontinuous functions on a compact space. -/\ntheorem âˆ€ {Î± : Type uâ‚} {Î² : Type uâ‚‚} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ}\n  {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [inst_2 : CompactSpace Î±],\n  Filter.Tendsto F p (nhds f) â†” TendstoUniformly (fun i a => â†‘(F i) a) (â†‘f) p :=\n\n/-- If `f` is a sequence of functions which converges in measure to `g`, then there exists a\nsubsequence of `f` which converges a.e. to `g`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : MetricSpace E]\n  {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E},\n  MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g â†’\n    âˆƒ ns, StrictMono ns âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, Filter.Tendsto (fun i => f (ns i) x) Filter.atTop (nhds (g x)) :=\n\n/-- If `Fâ‚™` tends locally uniformly to `f` on a set `s`, and `gâ‚™` tends to `x` within `s`, then\n`Fâ‚™ gâ‚™` tends to `f x` if `f` is continuous at `x` within `s` and `x âˆˆ s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformlyOn F f p s â†’\n    ContinuousWithinAt f s x â†’\n      x âˆˆ s â†’ Filter.Tendsto g p (nhdsWithin x s) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If `Fâ‚™` tends uniformly to `f` on a set `s`, and `gâ‚™` tends to `x` within `s`, then `Fâ‚™ gâ‚™`\ntends to `f x` if `f` is continuous at `x` within `s`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±}\n  {p : Filter Î¹} {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  TendstoUniformlyOn F f p s â†’\n    ContinuousWithinAt f s x â†’ Filter.Tendsto g p (nhdsWithin x s) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If `Fâ‚™` tends locally uniformly to `f`, and `gâ‚™` tends to `x`, then `Fâ‚™ gâ‚™` tends to `f x`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’\n    ContinuousAt f x â†’ Filter.Tendsto g p (nhds x) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- If `f` converges to some `y` as `x` tends to `xâ‚€` within `A`,\nthen `f` tends to `extendFrom A f x` as `x` tends to `xâ‚€`. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {f : X â†’ Y}\n  {x : X},\n  (âˆƒ y, Filter.Tendsto f (nhdsWithin x A) (nhds y)) â†’ Filter.Tendsto f (nhdsWithin x A) (nhds (extendFrom A f x)) :=\n\n/-- If `Fâ‚™` tends uniformly to `f`, and `gâ‚™` tends to `x`, then `Fâ‚™ gâ‚™` tends to `f x`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹}\n  {g : Î¹ â†’ Î±} [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’\n    ContinuousAt f x â†’ Filter.Tendsto g p (nhds x) â†’ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ UniformCauchySeqOn F p s :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series converges everywhere on the set. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\n  Summable u â†’\n    IsOpen s â†’\n      IsPreconnected s â†’\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x :=\n\n/-- If the sequence of Fourier coefficients of `f` is summable, then the Fourier series converges\nuniformly to `f`. -/\ntheorem âˆ€ {T : â„} [hT : Fact (0 < T)] {f : C(AddCircle T, â„‚)},\n  Summable (fourierCoeff â†‘f) â†’ HasSum (fun i => fourierCoeff (â†‘f) i â€¢ fourier i) f :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- If the iterates `f^[n] x` converge to `y` and `f` is continuous at `y`,\nthen `y` is a fixed point for `f`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±} {x y : Î±},\n  Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) â†’ ContinuousAt f y â†’ Function.IsFixedPt f y :=\n\n/-- Let `X` be a topological space and let `Y` be a metric space. Let `f_n: X â†’ Y` be a sequence of continuous functions. Let `x_n` be a sequence of points of `X` converging to `x`. Show that if the sequence `(f_n)` converges uniformly to `f`, then `(f_n(x_n))` converges to `f(x)`. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    ContinuousAt f x â†’ Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {x : X} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ (X â†’ Y)} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    ContinuousAt f x â†’ Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f_n : â„• â†’ X â†’ Y} {f : X â†’ Y} {x_n : â„• â†’ X}\n  {x : X},\n  TendstoUniformly f_n f Filter.atTop â†’\n    Filter.Tendsto x_n Filter.atTop (nhds x) â†’ ContinuousAt f x â†’ Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {f_n : â„• â†’ X â†’ Y} {x_n : â„• â†’ X} {x : X},\n  TendstoUniformly (fun n => f_n n) f Filter.atTop â†’\n    Filter.Tendsto x_n Filter.atTop (nhds x) â†’ ContinuousAt f x â†’ Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    Filter.Tendsto x_n p (nhds x) â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
      "forall {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {x : X} {f : X â†’ Y} {f_n : â„• â†’ X â†’ Y}\n  {x_n : â„• â†’ X}, Filter.Tendsto x_n Filter.atTop (nhds x) â†’ TendstoUniformly f_n f Filter.atTop â†’\n    Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x)) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X â†’ Y} {fn : â„• â†’ X â†’ Y},\n  TendstoUniformly (fun n x => fn n x) f Filter.atTop â†’\n    âˆ€ {x : X} {xn : â„• â†’ X}, Filter.Tendsto xn Filter.atTop (nhds x) â†’ Filter.Tendsto (fun n => fn n (xn n)) Filter.atTop (nhds (f x)) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : MetricSpace Y] {f : X â†’ Y} {Î¹ : Type u_3}\n  {p : Filter Î¹} {F : Î¹ â†’ X â†’ Y} {x : X} {x_n : Î¹ â†’ X},\n  TendstoUniformly F f p â†’\n    Filter.Tendsto x_n p (nhds x) â†’ ContinuousAt f x â†’ Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) "
    ]
  },
  {
    "docString": "If `A âŠ† X`, a retraction of `X` onto `A` is a continuous map `r: X â†’ A` such that `r(a) = a` for each `a âˆˆ A`. Show that a retraction is a quotient map.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {E : â„• â†’ Type u_1} [inst : (n : â„•) â†’ TopologicalSpace (E n)] [inst_1 : âˆ€ (n : â„•), DiscreteTopology (E n)]\\n  {s : Set ((n : â„•) â†’ E n)},\\n  IsClosed s â†’ Set.Nonempty s â†’ âˆƒ f, (âˆ€ (x : (n : â„•) â†’ E n), x âˆˆ s â†’ f x = x) âˆ§ Set.range f = s âˆ§ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a closed nonempty subset `s` of `Î  (n : â„•), E n`, there exists a retraction onto this\\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. \"},\n {\"theorem\":\n  \"âˆ€ (Râ‚ : Type u_2) {A : Type u_1} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : Algebra Râ‚ A] (I : Ideal A),\\n  Function.Surjective â†‘(Ideal.Quotient.mkâ‚ Râ‚ I)\",\n  \"isProp\": true,\n  \"docString\": \"The canonical morphism `A â†’â‚[Râ‚] I.quotient` is surjective. \"},\n {\"theorem\": \"âˆ€ {Î± : Sort u} {Î² : Sort v}, Function.Injective fun e => â†‘e\",\n  \"isProp\": true,\n  \"docString\": \"The map `(r â‰ƒ s) â†’ (r â†’ s)` is injective. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (r : Setoid Î±), Setoid.ker Quotient.mk'' = r\",\n  \"isProp\": true,\n  \"docString\":\n  \"The kernel of the quotient map induced by an equivalence relation r equals r. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], Subsingleton (Quotient âŠ¤.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by `âŠ¤ : DiscreteQuotient X` is a `Subsingleton`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\\nthen `R â†’ R[X]/P` is an integral map. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective â†‘(algebraMap R A) â†’ âˆ€ (p : â„•) [inst : CharP R p], CharP A p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the algebra map `R â†’+* A` is injective then `A` has the same characteristic as `R`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] {r : HomRel C} [self : CategoryTheory.Congruence r] {X Y : C},\\n  IsEquiv (X âŸ¶ Y) r\",\n  \"isProp\": true,\n  \"docString\": \"`r` is an equivalence on every hom-set. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (r : Setoid Î±), EqvGen.Setoid Setoid.r = r\",\n  \"isProp\": true,\n  \"docString\": \"The equivalence closure of an equivalence relation r is r. \"},\n {\"theorem\":\n  \"âˆ€ (Râ‚ : Type u_2) {A : Type u_1} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : Algebra Râ‚ A] (I : Ideal A),\\n  RingHom.ker â†‘(Ideal.Quotient.mkâ‚ Râ‚ I) = I\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of `A â†’â‚[Râ‚] I.quotient` is `I`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (P : Ideal (Polynomial R)),\\n  Function.Injective\\n    â†‘(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)\\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\\n        (_ :\\n          P â‰¤\\n            Ideal.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\\n              (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be an ideal in `R[x]`.  The map\\n`R[x]/P â†’ (R / (P âˆ© R))[x] / (P / (P âˆ© R))`\\nis injective.\\n\"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) (A : Type w) {M : Type vâ‚} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\\n  [inst_3 : AddCommMonoid M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M],\\n  Function.Surjective â†‘(algebraMap R A) â†’\\n    âˆ€ (X : Set M), Submodule.restrictScalars R (Submodule.span A X) = Submodule.span R X\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `A` is an `R`-algebra such that the induced morphism `R â†’+* A` is surjective, then the\\n`R`-module generated by a set `X` equals the `A`-module generated by `X`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"âˆ€ {E : â„• â†’ Type u_1} [inst : (n : â„•) â†’ TopologicalSpace (E n)] [inst_1 : âˆ€ (n : â„•), DiscreteTopology (E n)]\\n  {s : Set ((n : â„•) â†’ E n)},\\n  IsClosed s â†’ Set.Nonempty s â†’ âˆƒ f, (âˆ€ (x : (n : â„•) â†’ E n), x âˆˆ s â†’ f x = x) âˆ§ Set.range f = s âˆ§ LipschitzWith 1 f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a closed nonempty subset `s` of `Î  (n : â„•), E n`, there exists a Lipschitz retraction\\nonto this set, i.e., a Lipschitz map with range equal to `s`, equal to the identity on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {P A : Type u} [inst_1 : CommRing A] [inst_2 : Algebra R A] [inst_3 : CommRing P]\\n  [inst_4 : Algebra R P] (f : P â†’â‚[R] A),\\n  Function.Surjective â†‘f â†’\\n    âˆ€ [inst_5 : Algebra.FormallySmooth R P],\\n      Algebra.FormallySmooth R A â†” âˆƒ g, AlgHom.comp (AlgHom.kerSquareLift f) g = AlgHom.id R A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P â†’â‚[R] A` be a surjection with kernel `J`, and `P` a formally smooth `R`-algebra,\\nthen `A` is formally smooth over `R` iff the surjection `P â§¸ J ^ 2 â†’â‚[R] A` has a section.\\n\\nGeometric intuition: we require that a first-order thickening of `Spec A` inside `Spec P` admits\\na retraction. \"},\n {\"theorem\":\n  \"âˆ€ {Ïƒ : Type u_1} {R : Type u_2} {S : Type u_3} [inst : CommRing R] [inst_1 : CommRing S] (f : R â†’+* S)\\n  [inst_2 : IsLocalRingHom f], IsLocalRingHom (MvPowerSeries.map Ïƒ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map `A[[X]] â†’ B[[X]]` induced by a local ring hom `A â†’ B` is local \"}]\n",
    "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ Function.Surjective f â†’ QuotientMap f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- Given a closed nonempty subset `s` of `Î  (n : â„•), E n`, there exists a retraction onto this\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. -/\ntheorem âˆ€ {E : â„• â†’ Type u_1} [inst : (n : â„•) â†’ TopologicalSpace (E n)] [inst_1 : âˆ€ (n : â„•), DiscreteTopology (E n)]\n  {s : Set ((n : â„•) â†’ E n)},\n  IsClosed s â†’ Set.Nonempty s â†’ âˆƒ f, (âˆ€ (x : (n : â„•) â†’ E n), x âˆˆ s â†’ f x = x) âˆ§ Set.range f = s âˆ§ Continuous f :=\n\n/-- The canonical morphism `A â†’â‚[Râ‚] I.quotient` is surjective. -/\ntheorem âˆ€ (Râ‚ : Type u_2) {A : Type u_1} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : Algebra Râ‚ A] (I : Ideal A),\n  Function.Surjective â†‘(Ideal.Quotient.mkâ‚ Râ‚ I) :=\n\n/-- The map `(r â‰ƒ s) â†’ (r â†’ s)` is injective. -/\ntheorem âˆ€ {Î± : Sort u} {Î² : Sort v}, Function.Injective fun e => â†‘e :=\n\n/-- The kernel of the quotient map induced by an equivalence relation r equals r. -/\ntheorem âˆ€ {Î± : Type u_1} (r : Setoid Î±), Setoid.ker Quotient.mk'' = r :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- The quotient by `âŠ¤ : DiscreteQuotient X` is a `Subsingleton`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], Subsingleton (Quotient âŠ¤.toSetoid) :=\n\n/-- If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\nthen `R â†’ R[X]/P` is an integral map. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C) :=\n\n/-- If the algebra map `R â†’+* A` is injective then `A` has the same characteristic as `R`. -/\ntheorem âˆ€ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Function.Injective â†‘(algebraMap R A) â†’ âˆ€ (p : â„•) [inst : CharP R p], CharP A p :=\n\n/-- `r` is an equivalence on every hom-set. -/\ntheorem âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] {r : HomRel C} [self : CategoryTheory.Congruence r] {X Y : C},\n  IsEquiv (X âŸ¶ Y) r :=\n\n/-- The equivalence closure of an equivalence relation r is r. -/\ntheorem âˆ€ {Î± : Type u_1} (r : Setoid Î±), EqvGen.Setoid Setoid.r = r :=\n\n/-- The kernel of `A â†’â‚[Râ‚] I.quotient` is `I`. -/\ntheorem âˆ€ (Râ‚ : Type u_2) {A : Type u_1} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : Algebra Râ‚ A] (I : Ideal A),\n  RingHom.ker â†‘(Ideal.Quotient.mkâ‚ Râ‚ I) = I :=\n\n/-- Let `P` be an ideal in `R[x]`.  The map\n`R[x]/P â†’ (R / (P âˆ© R))[x] / (P / (P âˆ© R))`\nis injective. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (P : Ideal (Polynomial R)),\n  Function.Injective\n    â†‘(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\n        (_ :\n          P â‰¤\n            Ideal.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\n              (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P))) :=\n\n/-- If `A` is an `R`-algebra such that the induced morphism `R â†’+* A` is surjective, then the\n`R`-module generated by a set `X` equals the `A`-module generated by `X`. -/\ntheorem âˆ€ (R : Type u) (A : Type w) {M : Type vâ‚} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  [inst_3 : AddCommMonoid M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M],\n  Function.Surjective â†‘(algebraMap R A) â†’\n    âˆ€ (X : Set M), Submodule.restrictScalars R (Submodule.span A X) = Submodule.span R X :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â†‘(Con.mk' c) :=\n\n/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology â†‘s â†’ t âŠ† s â†’ DiscreteTopology â†‘t :=\n\n/-- Given a closed nonempty subset `s` of `Î  (n : â„•), E n`, there exists a Lipschitz retraction\nonto this set, i.e., a Lipschitz map with range equal to `s`, equal to the identity on `s`. -/\ntheorem âˆ€ {E : â„• â†’ Type u_1} [inst : (n : â„•) â†’ TopologicalSpace (E n)] [inst_1 : âˆ€ (n : â„•), DiscreteTopology (E n)]\n  {s : Set ((n : â„•) â†’ E n)},\n  IsClosed s â†’ Set.Nonempty s â†’ âˆƒ f, (âˆ€ (x : (n : â„•) â†’ E n), x âˆˆ s â†’ f x = x) âˆ§ Set.range f = s âˆ§ LipschitzWith 1 f :=\n\n/-- Let `P â†’â‚[R] A` be a surjection with kernel `J`, and `P` a formally smooth `R`-algebra,\nthen `A` is formally smooth over `R` iff the surjection `P â§¸ J ^ 2 â†’â‚[R] A` has a section.\n\nGeometric intuition: we require that a first-order thickening of `Spec A` inside `Spec P` admits\na retraction. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {P A : Type u} [inst_1 : CommRing A] [inst_2 : Algebra R A] [inst_3 : CommRing P]\n  [inst_4 : Algebra R P] (f : P â†’â‚[R] A),\n  Function.Surjective â†‘f â†’\n    âˆ€ [inst_5 : Algebra.FormallySmooth R P],\n      Algebra.FormallySmooth R A â†” âˆƒ g, AlgHom.comp (AlgHom.kerSquareLift f) g = AlgHom.id R A :=\n\n/-- The map `A[[X]] â†’ B[[X]]` induced by a local ring hom `A â†’ B` is local -/\ntheorem âˆ€ {Ïƒ : Type u_1} {R : Type u_2} {S : Type u_3} [inst : CommRing R] [inst_1 : CommRing S] (f : R â†’+* S)\n  [inst_2 : IsLocalRingHom f], IsLocalRingHom (MvPowerSeries.map Ïƒ f) :=\n\n/-- If `A âŠ† X`, a retraction of `X` onto `A` is a continuous map `r: X â†’ A` such that `r(a) = a` for each `a âˆˆ A`. Show that a retraction is a quotient map. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {f : Î± â†’ Î²},\n  IsOpenMap f â†’ Continuous f â†’ (âˆ€ (a : Î±), a âˆˆ A â†’ f a = a) â†’ Set.range f = A â†’ QuotientMap f ",
      "âˆ€ {X : Type u_1} {A : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace A] {f : X â†’ A},\n  Continuous f â†’ Set.range f = Set.range (Set.restrict f A) â†’ (âˆ€ x : A, Set.restrict f A x = x) â†’ QuotientMap f ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {r : Î± â†’ Î²},\n  IsRetraction A r â†’ QuotientMap r ",
      "âˆ€ {X : Type u_1} {A : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace A] {r : X â†’ A},\n  IsRetraction r â†’ QuotientMap r ",
      "âˆ€ {Î± : Type u_1} {A : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace A] {f : Î± â†’ A},\n  Continuous f â†’ (âˆ€ (a : A), f a = a) â†’ Set.range f = Set.univ â†’ QuotientMap f ",
      "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {r : Î± â†’ Î²},\n  IsRetract A r â†’ Continuous r â†’ QuotientMap r ",
      "âˆ€ {X : Type u_1} {A : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace A] {r : X â†’ A},\n  Continuous r â†’ (âˆ€ a, r a = a) â†’ QuotientMap r ",
      "âˆ€ {X : Type u_1} {A : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace A] {r : X â†’ A},\n  (âˆ€ (a : A), r a = a) â†’ Continuous r â†’ Function.Injective id â†’ QuotientMap r ",
      "âˆ€ {X : Type u_1} {A : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace A] {r : X â†’ A},\n  IsRetraction A r â†’ Continuous r â†’ QuotientMap r ",
      "âˆ€ {X : Type u_1} {A : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace A] {r : X â†’ A},\n  Continuous r â†’ (âˆ€ (a : A), r a = a) â†’ QuotientMap r "
    ]
  },
  {
    "docString": "Let `{A_n}` be a sequence of connected subspaces of `X`, such that `A_n âˆ© A_{n+1} â‰  âˆ…` for all `n`. Show that `â‹ƒ A_n` is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X\",\n  \"isProp\": true,\n  \"docString\": \"A path-connected space must be nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\\n  ConnectedSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is not a compact space, then `OnePoint X` is a connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’\\n    Pairwise (Disjoint on s) â†’\\n      âˆ€ [inst_2 : Finite Î¹], (âˆ€ (i : Î¹), IsClosed (s i)) â†’ â‹ƒ (i : Î¹), s i = Set.univ â†’ Subsingleton Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\\n  (s : Î¹ â†’ Set (â„™ K V)),\\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] {s : (i : Î¹) â†’ Set (Set (E i))},\\n  (âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (s i)) â†’\\n    TopologicalSpace.IsTopologicalBasis (â‹ƒ (i : Î¹), (fun u => Sigma.mk i '' u) '' s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a disjoint union space `Î£ i, E i`, one can form a topological basis by taking the union of\\ntopological bases on each of the parts of the space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (Z : â„• â†’ Set Î±),\\n  (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\\n    (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ IsCompact (Z 0) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem for sequences indexed by `â„•`:\\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Pairwise (Disjoint on s) â†’ (âˆ€ (i : Î¹), IsClopen (s i)) â†’ Subsingleton Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any disjoint family of non-empty clopen subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : ConditionallyCompleteLattice Î±] [inst_1 : SemilatticeSup Î²] {f g : Î² â†’ Î±},\\n  (Antitone fun n => Set.Icc (f n) (g n)) â†’ (âˆ€ (n : Î²), f n â‰¤ g n) â†’ â¨† (n : Î²), f n âˆˆ â‹‚ (n : Î²), Set.Icc (f n) (g n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Nested intervals lemma: if `[f n, g n]` is an antitone sequence of nonempty\\nclosed intervals, then `â¨† n, f n` belongs to all the intervals `[f n, g n]`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : TopologicalSpace ğ•œ] [inst_1 : OrderedRing ğ•œ] [inst_2 : AddCommMonoid E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ğ•œ E] {A B : Set E},\\n  IsExposed ğ•œ A B â†’ Set.Nonempty B â†’ âˆƒ l a, B = {x | x âˆˆ A âˆ§ a â‰¤ â†‘l x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\\ndoesn't intersect `A`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with `â‹ƒâ‚€`. \"}]\n",
    "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2 :=\n\n/-- A path-connected space must be nonempty. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S) :=\n\n/-- If `X` is not a compact space, then `OnePoint X` is a connected space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\n  ConnectedSpace (OnePoint X) :=\n\n/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’\n    Pairwise (Disjoint on s) â†’\n      âˆ€ [inst_2 : Finite Î¹], (âˆ€ (i : Î¹), IsClosed (s i)) â†’ â‹ƒ (i : Î¹), s i = Set.univ â†’ Subsingleton Î¹ :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i) :=\n\n/-- In a disjoint union space `Î£ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] {s : (i : Î¹) â†’ Set (Set (E i))},\n  (âˆ€ (i : Î¹), TopologicalSpace.IsTopologicalBasis (s i)) â†’\n    TopologicalSpace.IsTopologicalBasis (â‹ƒ (i : Î¹), (fun u => Sigma.mk i '' u) '' s i) :=\n\n/-- Cantor's intersection theorem for sequences indexed by `â„•`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (Z : â„• â†’ Set Î±),\n  (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\n    (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ IsCompact (Z 0) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) :=\n\n/-- In a preconnected space, any disjoint family of non-empty clopen subsets has at most one\nelement. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Pairwise (Disjoint on s) â†’ (âˆ€ (i : Î¹), IsClopen (s i)) â†’ Subsingleton Î¹ :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- Nested intervals lemma: if `[f n, g n]` is an antitone sequence of nonempty\nclosed intervals, then `â¨† n, f n` belongs to all the intervals `[f n, g n]`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : ConditionallyCompleteLattice Î±] [inst_1 : SemilatticeSup Î²] {f g : Î² â†’ Î±},\n  (Antitone fun n => Set.Icc (f n) (g n)) â†’ (âˆ€ (n : Î²), f n â‰¤ g n) â†’ â¨† (n : Î²), f n âˆˆ â‹‚ (n : Î²), Set.Icc (f n) (g n) :=\n\n/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : TopologicalSpace ğ•œ] [inst_1 : OrderedRing ğ•œ] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ğ•œ E] {A B : Set E},\n  IsExposed ğ•œ A B â†’ Set.Nonempty B â†’ âˆƒ l a, B = {x | x âˆˆ A âˆ§ a â‰¤ â†‘l x} :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `â‹ƒâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s) :=\n\n/-- Let `{A_n}` be a sequence of connected subspaces of `X`, such that `A_n âˆ© A_{n+1} â‰  âˆ…` for all `n`. Show that `â‹ƒ A_n` is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), IsConnected (s i)) â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (s i âˆ© s (i + 1))) â†’ IsConnected (â‹ƒ (i : Î¹), s i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’ (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : LinearOrder Î¹] [inst_2 : SuccOrder Î¹] {A : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), IsConnected (A i)) â†’ (âˆ€ (i : Î¹), Set.Nonempty (A i âˆ© A (succ i))) â†’ IsConnected (â‹ƒ (i : Î¹), A i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (i : â„•), IsConnected (A i)) â†’ (âˆ€ (i : â„•), Set.Nonempty (A i âˆ© A (i + 1))) â†’ IsConnected (â‹ƒ (i : â„•), A i) ",
      "âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î¹] {X : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), IsConnected (X i)) â†’\n    (âˆ€ (i j : Î¹), i < j â†’ Set.Nonempty (X i âˆ© X j)) â†’ IsConnected (â‹ƒ (i : Î¹), X i) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {Î¹ : Type u_2} [inst_1 : LinearOrder Î¹] {A : Î¹ â†’ Set X},\n  (âˆ€ (n : Î¹), IsConnected (A n)) â†’\n    (âˆ€ (n : Î¹), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : Î¹), A n) ",
      "âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [_inst_1 : PreconnectedSpace Î±] {s : Î¹ â†’ Set Î±} {l : â„• â†’ Î¹}\n  (hls : âˆ€ (n : â„•), s (l n) âˆ© s (l (n + 1)) â‰  âˆ…),\n  (âˆ€ (n : â„•), IsConnected (s (l n))) â†’ IsConnected (â‹ƒ (n : â„•), s (l n)) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {A : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsConnected (A n)) â†’\n    (âˆ€ (n : â„•), Set.Nonempty (A n âˆ© A (n + 1))) â†’ IsConnected (â‹ƒ (n : â„•), A n) "
    ]
  },
  {
    "docString": "Show that if `X` is an infinite set, it is connected in the finite complement topology.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Infinite Î±], IrreducibleSpace (CofiniteTopology Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite type with cofinite topology is an irreducible topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\\n  Â¬Continuous â†‘CofiniteTopology.of.symm\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is an infinite type with discrete topology (e.g., `â„•`), then the identity map from\\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {Î± : Type uâ‚}\\n  {Î² : Type u_1} {s : Set (Î² â†’ M)},\\n  Set.Definable A L s â†’ âˆ€ (f : Î± â†’ Î²) [inst_1 : Finite Î±] [inst_2 : Finite Î²], Set.Definable A L ((fun g => g âˆ˜ f) '' s)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that definability is closed under finite projections. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type u} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.IsCofiltered J]\\n  {F : CategoryTheory.Functor J Profinite} (C : CategoryTheory.Limits.Cone F) {U : Set â†‘C.pt.toCompHaus.toTop},\\n  CategoryTheory.Limits.IsLimit C â†’ IsClopen U â†’ âˆƒ j V x, U = â†‘(CategoryTheory.NatTrans.app C.Ï€ j) â»Â¹' V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a cofiltered limit of profinite sets, then any clopen subset of `X` arises from\\na clopen set in one of the terms in the limit.\\n\"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] (a : Î±),\\n  IsClosed (Set.Ici a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left-closed right-infinite intervals [a, âˆ) are closed in the lower topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\": \"Filter.Tendsto Int.cast Filter.cofinite (Filter.cocompact â„)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Under the coercion from `â„¤` to `â„`, inverse images of compact sets are finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\\n  ConnectedSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is not a compact space, then `OnePoint X` is a connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"}]\n",
    "prompt_cons": "/-- An infinite type with cofinite topology is an irreducible topological space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Infinite Î±], IrreducibleSpace (CofiniteTopology Î±) :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s) :=\n\n/-- If `X` is an infinite type with discrete topology (e.g., `â„•`), then the identity map from\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\n  Â¬Continuous â†‘CofiniteTopology.of.symm :=\n\n/-- Shows that definability is closed under finite projections. -/\ntheorem âˆ€ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {Î± : Type uâ‚}\n  {Î² : Type u_1} {s : Set (Î² â†’ M)},\n  Set.Definable A L s â†’ âˆ€ (f : Î± â†’ Î²) [inst_1 : Finite Î±] [inst_2 : Finite Î²], Set.Definable A L ((fun g => g âˆ˜ f) '' s) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- A locally finite preconnected infinite graph has at least one end. -/\ntheorem âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G) :=\n\n/-- If `X` is a cofiltered limit of profinite sets, then any clopen subset of `X` arises from\na clopen set in one of the terms in the limit. -/\ntheorem âˆ€ {J : Type u} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.IsCofiltered J]\n  {F : CategoryTheory.Functor J Profinite} (C : CategoryTheory.Limits.Cone F) {U : Set â†‘C.pt.toCompHaus.toTop},\n  CategoryTheory.Limits.IsLimit C â†’ IsClopen U â†’ âˆƒ j V x, U = â†‘(CategoryTheory.NatTrans.app C.Ï€ j) â»Â¹' V :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- Left-closed right-infinite intervals [a, âˆ) are closed in the lower topology. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LowerTopology Î±] (a : Î±),\n  IsClosed (Set.Ici a) :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SecondCountableTopology Î±],\n  âˆƒ b, Set.Countable b âˆ§ t = TopologicalSpace.generateFrom b :=\n\n/-- Under the coercion from `â„¤` to `â„`, inverse images of compact sets are finite. -/\ntheorem Filter.Tendsto Int.cast Filter.cofinite (Filter.cocompact â„) :=\n\n/-- The complement of a closed set is an open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ :=\n\n/-- If `X` is not a compact space, then `OnePoint X` is a connected space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\n  ConnectedSpace (OnePoint X) :=\n\n/-- A finite union of finsets is finite. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a)) :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- Show that if `X` is an infinite set, it is connected in the finite complement topology. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], ConnectedSpace (CofiniteTopology Î±) ",
      "âˆ€ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) ",
      "âˆ€ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) ",
      "âˆ€ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], ConnectedSpace (CofiniteTopology Î±) ",
      "âˆ€ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : CofiniteTopology X],\n  ConnectedSpace X ",
      "âˆ€ {Î± : Type u_1} [inst : Infinite Î±], ConnectedSpace (CofiniteTopology Î±) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : CofiniteTopology X], ConnectedSpace X ",
      "âˆ€ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) "
    ]
  },
  {
    "docString": "Let `A` be a proper subset of `X`, and let `B` be a proper subset of `Y`. If `X` and `Y` are connected, show that `(X Ã— Y) - (A Ã— B)` is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X Y S : TopCat} {f : X âŸ¶ S} {g : Y âŸ¶ S},\\n  OpenEmbedding â†‘f â†’\\n    OpenEmbedding â†‘g â†’\\n      OpenEmbedding\\n        â†‘(CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X Y Z A : C} {g : Y âŸ¶ Z} {aâ‚ aâ‚‚ : A âŸ¶ Y}\\n  (h : CategoryTheory.IsKernelPair g aâ‚ aâ‚‚) (f : X âŸ¶ Z) [inst_1 : CategoryTheory.Limits.HasPullback f g]\\n  [inst_2 : CategoryTheory.Limits.HasPullback f (CategoryTheory.CategoryStruct.comp aâ‚ g)],\\n  CategoryTheory.IsKernelPair CategoryTheory.Limits.pullback.fst\\n    (CategoryTheory.Limits.pullback.map f (CategoryTheory.CategoryStruct.comp aâ‚ g) f g\\n      (CategoryTheory.CategoryStruct.id X) aâ‚ (CategoryTheory.CategoryStruct.id Z)\\n      (_ :\\n        CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Z) =\\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f)\\n      (_ :\\n        CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp aâ‚ g)\\n            (CategoryTheory.CategoryStruct.id Z) =\\n          CategoryTheory.CategoryStruct.comp aâ‚ g))\\n    (CategoryTheory.Limits.pullback.map f (CategoryTheory.CategoryStruct.comp aâ‚ g) f g\\n      (CategoryTheory.CategoryStruct.id X) aâ‚‚ (CategoryTheory.CategoryStruct.id Z)\\n      (_ :\\n        CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Z) =\\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f)\\n      (_ :\\n        CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp aâ‚ g)\\n            (CategoryTheory.CategoryStruct.id Z) =\\n          CategoryTheory.CategoryStruct.comp aâ‚‚ g))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `aâ‚ aâ‚‚ : A âŸ¶ Y` is a kernel pair for `g : Y âŸ¶ Z`, then `aâ‚ Ã—[Z] X` and `aâ‚‚ Ã—[Z] X`\\n(`A Ã—[Z] X âŸ¶ Y Ã—[Z] X`) is a kernel pair for `Y Ã—[Z] X âŸ¶ X`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any two points of a set are contained in a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"âˆ€ (C : Type u) [inst : CategoryTheory.Category C]\\n  [inst_1 : âˆ€ {X Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)],\\n  CategoryTheory.Limits.HasBinaryCoproducts C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.continuants g n = ppred â†’\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred â†’\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚` and `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] {Y : Type u_2} [inst_2 : TopologicalSpace Y],\\n  IsClosedMap Prod.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact topological space, then `Prod.snd : X Ã— Y â†’ Y` is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : TopologicalSpace ğ•œ] [inst_1 : OrderedRing ğ•œ] [inst_2 : AddCommMonoid E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ğ•œ E] {A B : Set E},\\n  IsExposed ğ•œ A B â†’ Set.Nonempty B â†’ âˆƒ l a, B = {x | x âˆˆ A âˆ§ a â‰¤ â†‘l x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\\ndoesn't intersect `A`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\\n  RingSubgroupsBasis B â†’ âˆ€ (i : Î¹), âˆƒ j, â†‘(B j) * â†‘(B j) âŠ† â†‘(B i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\\nthat the set-theoretic product `B' * B'` is in `B`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {B : C} {X Y : CategoryTheory.Subobject B}\\n  (f : CategoryTheory.Subobject.underlying.obj X â‰… CategoryTheory.Subobject.underlying.obj Y),\\n  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.Subobject.arrow Y) = CategoryTheory.Subobject.arrow X â†’ X = Y\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\\nthe arrows. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} (x : Î±),\\n  (âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any point of a set is joined to a fixed point by a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {sâ‚ sâ‚‚ : Set M}, IsSubmonoid sâ‚ â†’ IsSubmonoid sâ‚‚ â†’ IsSubmonoid (sâ‚ âˆ© sâ‚‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two submonoids of a monoid `M` is a submonoid of `M`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N) {H K : AddSubgroup G},\\n  AddMonoidHom.ker f â‰¤ H â†’ AddMonoidHom.ker f â‰¤ K â†’ AddSubgroup.map f H = AddSubgroup.map f K â†’ H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±) (c : Set (Set Î±)),\\n  (âˆ€ (s : Set Î±), s âˆˆ c â†’ x âˆˆ s) â†’ (âˆ€ (s : Set Î±), s âˆˆ c â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A union of a family of preconnected sets with a common point is preconnected as well. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\\n  RingSubgroupsBasis B â†’ âˆ€ (x : A) (i : Î¹), âˆƒ j, â†‘(B j) âŠ† (fun x_1 => x_1 * x) â»Â¹' â†‘(B i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any element `x : A` and any set `B` in the submodule basis on `A`,\\nthere is another basis element `B'` such that `x * B'` is in `B`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±},\\n  IsConnected s â†’ âˆ€ (f : Î± â†’ Î²), ContinuousOn f s â†’ IsConnected (f '' s)\",\n  \"isProp\": true,\n  \"docString\": \"The image of a connected set is connected as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"}]\n",
    "prompt_cons": "/-- If `X âŸ¶ S`, `Y âŸ¶ S` are open embeddings, then so is `X Ã—â‚› Y âŸ¶ S`. -/\ntheorem âˆ€ {X Y S : TopCat} {f : X âŸ¶ S} {g : Y âŸ¶ S},\n  OpenEmbedding â†‘f â†’\n    OpenEmbedding â†‘g â†’\n      OpenEmbedding\n        â†‘(CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one) :=\n\n/-- If `aâ‚ aâ‚‚ : A âŸ¶ Y` is a kernel pair for `g : Y âŸ¶ Z`, then `aâ‚ Ã—[Z] X` and `aâ‚‚ Ã—[Z] X`\n(`A Ã—[Z] X âŸ¶ Y Ã—[Z] X`) is a kernel pair for `Y Ã—[Z] X âŸ¶ X`. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X Y Z A : C} {g : Y âŸ¶ Z} {aâ‚ aâ‚‚ : A âŸ¶ Y}\n  (h : CategoryTheory.IsKernelPair g aâ‚ aâ‚‚) (f : X âŸ¶ Z) [inst_1 : CategoryTheory.Limits.HasPullback f g]\n  [inst_2 : CategoryTheory.Limits.HasPullback f (CategoryTheory.CategoryStruct.comp aâ‚ g)],\n  CategoryTheory.IsKernelPair CategoryTheory.Limits.pullback.fst\n    (CategoryTheory.Limits.pullback.map f (CategoryTheory.CategoryStruct.comp aâ‚ g) f g\n      (CategoryTheory.CategoryStruct.id X) aâ‚ (CategoryTheory.CategoryStruct.id Z)\n      (_ :\n        CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Z) =\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f)\n      (_ :\n        CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp aâ‚ g)\n            (CategoryTheory.CategoryStruct.id Z) =\n          CategoryTheory.CategoryStruct.comp aâ‚ g))\n    (CategoryTheory.Limits.pullback.map f (CategoryTheory.CategoryStruct.comp aâ‚ g) f g\n      (CategoryTheory.CategoryStruct.id X) aâ‚‚ (CategoryTheory.CategoryStruct.id Z)\n      (_ :\n        CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Z) =\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f)\n      (_ :\n        CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp aâ‚ g)\n            (CategoryTheory.CategoryStruct.id Z) =\n          CategoryTheory.CategoryStruct.comp aâ‚‚ g)) :=\n\n/-- If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s :=\n\n/-- If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts -/\ntheorem âˆ€ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 : âˆ€ {X Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)],\n  CategoryTheory.Limits.HasBinaryCoproducts C :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚` and `Bâ‚™ = bâ‚™ * Bâ‚™â‚‹â‚ + aâ‚™ * Bâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.continuants g n = ppred â†’\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred â†’\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- If `X` is a compact topological space, then `Prod.snd : X Ã— Y â†’ Y` is a closed map. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] {Y : Type u_2} [inst_2 : TopologicalSpace Y],\n  IsClosedMap Prod.snd :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : TopologicalSpace ğ•œ] [inst_1 : OrderedRing ğ•œ] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ğ•œ E] {A B : Set E},\n  IsExposed ğ•œ A B â†’ Set.Nonempty B â†’ âˆƒ l a, B = {x | x âˆˆ A âˆ§ a â‰¤ â†‘l x} :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\nthat the set-theoretic product `B' * B'` is in `B`. -/\ntheorem âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\n  RingSubgroupsBasis B â†’ âˆ€ (i : Î¹), âˆƒ j, â†‘(B j) * â†‘(B j) âŠ† â†‘(B i) :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G â†’* N) {H K : Subgroup G},\n  MonoidHom.ker f â‰¤ H â†’ MonoidHom.ker f â‰¤ K â†’ Subgroup.map f H = Subgroup.map f K â†’ H = K :=\n\n/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {B : C} {X Y : CategoryTheory.Subobject B}\n  (f : CategoryTheory.Subobject.underlying.obj X â‰… CategoryTheory.Subobject.underlying.obj Y),\n  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.Subobject.arrow Y) = CategoryTheory.Subobject.arrow X â†’ X = Y :=\n\n/-- If any point of a set is joined to a fixed point by a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} (x : Î±),\n  (âˆ€ (y : Î±), y âˆˆ s â†’ âˆƒ t, t âŠ† s âˆ§ x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t) â†’ IsPreconnected s :=\n\n/-- The intersection of two submonoids of a monoid `M` is a submonoid of `M`. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {sâ‚ sâ‚‚ : Set M}, IsSubmonoid sâ‚ â†’ IsSubmonoid sâ‚‚ â†’ IsSubmonoid (sâ‚ âˆ© sâ‚‚) :=\n\n/-- Given `f(A) = f(B)`, `ker f â‰¤ A`, and `ker f â‰¤ B`, deduce that `A = B`. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G â†’+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f â‰¤ H â†’ AddMonoidHom.ker f â‰¤ K â†’ AddSubgroup.map f H = AddSubgroup.map f K â†’ H = K :=\n\n/-- A union of a family of preconnected sets with a common point is preconnected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±) (c : Set (Set Î±)),\n  (âˆ€ (s : Set Î±), s âˆˆ c â†’ x âˆˆ s) â†’ (âˆ€ (s : Set Î±), s âˆˆ c â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ c) :=\n\n/-- For any element `x : A` and any set `B` in the submodule basis on `A`,\nthere is another basis element `B'` such that `x * B'` is in `B`. -/\ntheorem âˆ€ {A : Type u_1} {Î¹ : Type u_2} [inst : Ring A] {B : Î¹ â†’ AddSubgroup A},\n  RingSubgroupsBasis B â†’ âˆ€ (x : A) (i : Î¹), âˆƒ j, â†‘(B j) âŠ† (fun x_1 => x_1 * x) â»Â¹' â†‘(B i) :=\n\n/-- The image of a connected set is connected as well. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±},\n  IsConnected s â†’ âˆ€ (f : Î± â†’ Î²), ContinuousOn f s â†’ IsConnected (f '' s) :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S : Set (Set Î±)},\n  DirectedOn (fun x x_1 => x âŠ† x_1) S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) â†’ IsPreconnected (â‹ƒâ‚€ S) :=\n\n/-- Let `A` be a proper subset of `X`, and let `B` be a proper subset of `Y`. If `X` and `Y` are connected, show that `(X Ã— Y) - (A Ã— B)` is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {B : Set Î²} {X : Set Î±} {Y : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected ((X Ã— Y) \\ (A Ã— B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {X : Set Î±} {Y : Set Î²} {A : Set Î±} {B : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected ((X.prod Y) - (A.prod B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {A : Set Î±} {B : Set Î²} {X : Set Î±} {Y : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected ((X.prod Y) \\ (A.prod B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {X : Set Î±} {Y : Set Î²}\n  (hX : IsConnected X) (hY : IsConnected Y) {A : Set Î±} {B : Set Î²} (hAX : A âŠ‚ X) (hBY : B âŠ‚ Y),\n  IsConnected ((X.prod Y) \\ (A.prod B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {X : Set Î±} {Y : Set Î²} {A : Set Î±}\n  {B : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected ((X Ã— Y) \\ (A Ã— B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {sâ‚ : Set Î±} {sâ‚‚ : Set Î²} {X : Set Î±} {Y : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’\n    sâ‚ âŠ† X â†’ sâ‚ â‰  X â†’ sâ‚‚ âŠ† Y â†’ sâ‚‚ â‰  Y â†’\n      IsConnected ((X Ã— Y) \\ (sâ‚ Ã— sâ‚‚)) ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ â†’\n    IsProperSubset B Set.univ â†’\n      IsConnected X â†’\n        IsConnected Y â†’ IsConnected ((Set.prod Set.univ Set.univ) - (A Ã—Ë¢ B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [_inst_1 : TopologicalSpace Î±] [_inst_2 : TopologicalSpace Î²] {A : Set Î±} {B : Set Î²} {X : Set Î±} {Y : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’ IsConnected ((X.prod Y) - (A.prod B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  {X : Set Î±} {Y : Set Î²} {A : Set Î±} {B : Set Î²},\n  IsConnected X â†’ IsConnected Y â†’ A âŠ‚ X â†’ B âŠ‚ Y â†’\n    IsConnected ((X.prod Y) \\ (A.prod B)) ",
      "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {X Y : Set Î±},\n  IsConnected X â†’ IsConnected Y â†’ âˆ€ {A : Set Î±} {B : Set Î²},\n    A âŠ† X â†’ B âŠ† Y â†’ (A â‰  X âˆ¨ B â‰  Y) â†’ IsConnected (X.prod Y \\ A.prod B) "
    ]
  },
  {
    "docString": "Let `f: S^1 â†’ â„` be a continuous map. Show there exists a point `x` of `S^1` such that `f(x) = f(-x)`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Ring ğ•œ] [inst_4 : NoZeroDivisors ğ•œ],\\n  IsPreconnected S â†’ ContinuousOn f S â†’ Set.EqOn (f ^ 2) 1 S â†’ Set.EqOn f 1 S âˆ¨ Set.EqOn f (-1) S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a function `Î± â†’ ğ•œ` which is continuous on a preconnected set `S`, and\\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. \"},\n {\"theorem\":\n  \"âˆ€ {Gâ‚€ : Type u_1} [inst : Zero Gâ‚€] [inst_1 : Inv Gâ‚€] [inst_2 : TopologicalSpace Gâ‚€] [self : HasContinuousInvâ‚€ Gâ‚€]\\n  â¦ƒx : Gâ‚€â¦„, x â‰  0 â†’ ContinuousAt Inv.inv x\",\n  \"isProp\": true,\n  \"docString\": \"The map `fun x â†¦ xâ»Â¹` is continuous at all nonzero points. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’ Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ Set.EqOn f g S âˆ¨ Set.EqOn f (-g) S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then either `f = g` or `f = -g` on\\n`S`. \"},\n {\"theorem\":\n  \"âˆ€ {z : â„} {f : â„ â†’ â„} {u : â„}, HasDerivAt f u z â†’ HasDerivAt (fun y => â†‘(f y)) (â†‘u) z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : â„ â†’ â„` is differentiable at a (real) point `x`, then it is also\\ndifferentiable as a function `â„ â†’ â„‚`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’\\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : AddCommGroup E] [inst_2 : TopologicalAddGroup E]\\n  [inst_3 : Module â„ E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  0 âˆˆ s â†’ Convex â„ s â†’ IsOpen s â†’ âˆ€ {xâ‚€ : E}, Â¬xâ‚€ âˆˆ s â†’ âˆƒ f, â†‘f xâ‚€ = 1 âˆ§ âˆ€ (x : E), x âˆˆ s â†’ â†‘f x < 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a set `s` which is a convex neighbourhood of `0` and a point `xâ‚€` outside of it, there is\\na continuous linear functional `f` separating `xâ‚€` and `s`, in the sense that it sends `xâ‚€` to 1 and\\nall of `s` to values strictly below `1`. \"},\n {\"theorem\":\n  \"âˆ€ (x : â„) (y : â„‚), 0 < y.re âˆ¨ x â‰  0 â†’ ContinuousAt (fun p => â†‘p.fst ^ p.snd) (x, y)\",\n  \"isProp\": true,\n  \"docString\": \"Continuity of `(x, y) â†¦ x ^ y` as a function on `â„ Ã— â„‚`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter a (nhdsWithin a s) (nhdsWithin a t)],\\n      StronglyMeasurableAtFilter f (nhdsWithin a t) â†’\\n        ContinuousWithinAt f t a â†’\\n          autoParam (UniqueDiffWithinAt â„ s a) _autoâœ â†’ derivWithin (fun u => âˆ« (x : â„) in u..b, f x) s a = -f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` is continuous\\non the right or on the left at `a`, then the right (resp., left) derivative of\\n`u â†¦ âˆ« x in u..b, f x` at `a` equals `-f a`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_1} [inst_1 : AddCommMonoid N]\\n  (f : AddSubmonoid.LocalizationMap S N) (z : N),\\n  AddSubmonoid.LocalizationMap.mk' f (AddSubmonoid.LocalizationMap.sec f z).fst\\n      (AddSubmonoid.LocalizationMap.sec f z).snd =\\n    z\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a localization map `f : M â†’+ N` for a Submonoid `S âŠ† M`, for all `z : N`\\nwe have that if `x : M, y âˆˆ S` are such that `z + f y = f x`, then `f x - f y = z`.\"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup F]\\n  [inst_2 : InnerProductSpace â„ E] [inst_3 : InnerProductSpace â„ F] {f : E â†’ F} {x : E},\\n  ConformalAt f x â†” âˆƒ c, 0 < c âˆ§ âˆ€ (u v : E), inner (â†‘(fderiv â„ f x) u) (â†‘(fderiv â„ f x) v) = c * inner u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A real differentiable map `f` is conformal at point `x` if and only if its\\ndifferential `fderiv â„ f x` at that point scales every inner product by a positive scalar. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a strictly monotone function on a left neighborhood of `a` and the image of this\\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, then `f` is continuous at `a`\\nfrom the left.\\n\\nThe assumption `hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ico b (f a)` is required because otherwise the\\nfunction `f : â„ â†’ â„` given by `f x = if x < 0 then x else x + 1` would be a counter-example at\\n`a = 0`. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift) {x : â„} {m : â„¤}, â†‘f x = x + â†‘m â†’ CircleDeg1Lift.translationNumber f = â†‘m\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f x - x` is an integer number `m` for some point `x`, then `Ï„ f = m`.\\nOn the circle this means that a map with a fixed point has rotation number zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds a) â†’ ContinuousAt f a â†’ deriv (fun u => âˆ« (x : â„) in u..b, f x) a = -f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f` is continuous\\nat `a`, then the derivative of `u â†¦ âˆ« x in u..b, f x` at `a` equals `-f a`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictAnti (deriv f) â†’ StrictConcaveOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly antitone on `â„` then `f` is strictly\\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict antitonicity of `f'`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] {x : Î±}, Continuous fun f => â†‘f x\",\n  \"isProp\": true,\n  \"docString\": \"When `x` is fixed, `(f : Î± â†’áµ‡ Î²) â†¦ f x` is continuous. \"}]\n",
    "prompt_cons": "/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- If `f` is a function `Î± â†’ ğ•œ` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Ring ğ•œ] [inst_4 : NoZeroDivisors ğ•œ],\n  IsPreconnected S â†’ ContinuousOn f S â†’ Set.EqOn (f ^ 2) 1 S â†’ Set.EqOn f 1 S âˆ¨ Set.EqOn f (-1) S :=\n\n/-- The map `fun x â†¦ xâ»Â¹` is continuous at all nonzero points. -/\ntheorem âˆ€ {Gâ‚€ : Type u_1} [inst : Zero Gâ‚€] [inst_1 : Inv Gâ‚€] [inst_2 : TopologicalSpace Gâ‚€] [self : HasContinuousInvâ‚€ Gâ‚€]\n  â¦ƒx : Gâ‚€â¦„, x â‰  0 â†’ ContinuousAt Inv.inv x :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’ Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ Set.EqOn f g S âˆ¨ Set.EqOn f (-g) S :=\n\n/-- If a function `f : â„ â†’ â„` is differentiable at a (real) point `x`, then it is also\ndifferentiable as a function `â„ â†’ â„‚`. -/\ntheorem âˆ€ {z : â„} {f : â„ â†’ â„} {u : â„}, HasDerivAt f u z â†’ HasDerivAt (fun y => â†‘(f y)) (â†‘u) z :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S :=\n\n/-- Given a set `s` which is a convex neighbourhood of `0` and a point `xâ‚€` outside of it, there is\na continuous linear functional `f` separating `xâ‚€` and `s`, in the sense that it sends `xâ‚€` to 1 and\nall of `s` to values strictly below `1`. -/\ntheorem âˆ€ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : AddCommGroup E] [inst_2 : TopologicalAddGroup E]\n  [inst_3 : Module â„ E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  0 âˆˆ s â†’ Convex â„ s â†’ IsOpen s â†’ âˆ€ {xâ‚€ : E}, Â¬xâ‚€ âˆˆ s â†’ âˆƒ f, â†‘f xâ‚€ = 1 âˆ§ âˆ€ (x : E), x âˆˆ s â†’ â†‘f x < 1 :=\n\n/-- Continuity of `(x, y) â†¦ x ^ y` as a function on `â„ Ã— â„‚`. -/\ntheorem âˆ€ (x : â„) (y : â„‚), 0 < y.re âˆ¨ x â‰  0 â†’ ContinuousAt (fun p => â†‘p.fst ^ p.snd) (x, y) :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f x` is continuous\non the right or on the left at `a`, then the right (resp., left) derivative of\n`u â†¦ âˆ« x in u..b, f x` at `a` equals `-f a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    âˆ€ {s t : Set â„} [inst_3 : intervalIntegral.FTCFilter a (nhdsWithin a s) (nhdsWithin a t)],\n      StronglyMeasurableAtFilter f (nhdsWithin a t) â†’\n        ContinuousWithinAt f t a â†’\n          autoParam (UniqueDiffWithinAt â„ s a) _autoâœ â†’ derivWithin (fun u => âˆ« (x : â„) in u..b, f x) s a = -f a :=\n\n/-- Given a localization map `f : M â†’+ N` for a Submonoid `S âŠ† M`, for all `z : N`\nwe have that if `x : M, y âˆˆ S` are such that `z + f y = f x`, then `f x - f y = z`. -/\ntheorem âˆ€ {M : Type u_2} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_1} [inst_1 : AddCommMonoid N]\n  (f : AddSubmonoid.LocalizationMap S N) (z : N),\n  AddSubmonoid.LocalizationMap.mk' f (AddSubmonoid.LocalizationMap.sec f z).fst\n      (AddSubmonoid.LocalizationMap.sec f z).snd =\n    z :=\n\n/-- Let `f : â„ â†’ â„` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ (âˆ€ (x : â„), 0 â‰¤ deriv f x) â†’ Monotone f :=\n\n/-- A real differentiable map `f` is conformal at point `x` if and only if its\ndifferential `fderiv â„ f x` at that point scales every inner product by a positive scalar. -/\ntheorem âˆ€ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup F]\n  [inst_2 : InnerProductSpace â„ E] [inst_3 : InnerProductSpace â„ F] {f : E â†’ F} {x : E},\n  ConformalAt f x â†” âˆƒ c, 0 < c âˆ§ âˆ€ (u v : E), inner (â†‘(fderiv â„ f x) u) (â†‘(fderiv â„ f x) v) = c * inner u v :=\n\n/-- If `f` is a strictly monotone function on a left neighborhood of `a` and the image of this\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, then `f` is continuous at `a`\nfrom the left.\n\nThe assumption `hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ico b (f a)` is required because otherwise the\nfunction `f : â„ â†’ â„` given by `f x = if x < 0 then x else x + 1` would be a counter-example at\n`a = 0`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a :=\n\n/-- If `f x - x` is an integer number `m` for some point `x`, then `Ï„ f = m`.\nOn the circle this means that a map with a fixed point has rotation number zero. -/\ntheorem âˆ€ (f : CircleDeg1Lift) {x : â„} {m : â„¤}, â†‘f x = x + â†‘m â†’ CircleDeg1Lift.translationNumber f = â†‘m :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f` is continuous\nat `a`, then the derivative of `u â†¦ âˆ« x in u..b, f x` at `a` equals `-f a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds a) â†’ ContinuousAt f a â†’ deriv (fun u => âˆ« (x : â„) in u..b, f x) a = -f a :=\n\n/-- If a function `f` is continuous and `f'` is strictly antitone on `â„` then `f` is strictly\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict antitonicity of `f'`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictAnti (deriv f) â†’ StrictConcaveOn â„ Set.univ f :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- When `x` is fixed, `(f : Î± â†’áµ‡ Î²) â†¦ f x` is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] {x : Î±}, Continuous fun f => â†‘f x :=\n\n/-- Let `f: S^1 â†’ â„` be a continuous map. Show there exists a point `x` of `S^1` such that `f(x) = f(-x)`. -/\ntheorem",
    "choices": [
      "âˆ€ (f : CircleDeg1Lift), âˆƒ x : â„, â†‘f x = â†‘f (-x) ",
      "âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = â†‘f (-x) ",
      "âˆ€ (f : â†¥circle â†’ â„) [inst : Continuous f], âˆƒ x, f x = f (-x) ",
      "âˆ€ {f : CircleDeg1Lift}, Continuous â†‘f â†’ âˆƒ x, â†‘f x = â†‘f (-x) ",
      "âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f (x + 0.5) = â†‘f x ",
      "âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f (x + 0.5) = â†‘f x ",
      "âˆ€ (f : Circle â†’ â„) [inst : Continuous f], âˆƒ x : Circle, f x = f (-x) ",
      "âˆ€ {f : CircleEquivReflexive â„}, Continuous â†‘f â†’ âˆƒ x, â†‘f x = â†‘f (-x) ",
      "âˆ€ (f : CircleMap â†’ â„), Continuous f â†’ âˆƒ x, f x = f (-x) ",
      "âˆ€ {f : Circle â†’ â„}, Continuous f â†’ âˆƒ x, f x = f (-x) "
    ]
  },
  {
    "docString": "Let `X` be locally path connected. Show that every connected open set in `X` is path connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is path connected. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {U W : Set X},\\n  IsPathConnected W â†’ W âŠ† U â†’ IsPathConnected (Subtype.val â»Â¹' W)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\\nambient type `U` (when `U` contains `W`). \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\\n  ConnectedSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is not a compact space, then `OnePoint X` is a connected space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of a homeomorphism is a locally connected space, then the domain is also\\na locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X\",\n  \"isProp\": true,\n  \"docString\": \"A path-connected space must be nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a connected set is connected as well. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y],\\n  SimplyConnectedSpace Y â†” PathConnectedSpace Y âˆ§ âˆ€ (x y : Y), Subsingleton (Path.Homotopic.Quotient x y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is simply connected iff it is path connected, and there is at most one path\\nup to homotopy between any two points. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} (self : TopologicalSpace.OpenNhdsOf x), x âˆˆ self.carrier\",\n  \"isProp\": true,\n  \"docString\":\n  \"The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SimplyConnectedSpace X] {x y : X} (pâ‚ pâ‚‚ : Path x y),\\n  Path.Homotopic pâ‚ pâ‚‚\",\n  \"isProp\": true,\n  \"docString\": \"In a simply connected space, any two paths are homotopic \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally connected charts, then the space itself is\\nlocally connected. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"A reformulation of the definition of locally compact space: In a locally compact space,\\nevery open set containing `x` has a compact subset containing `x` in its interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z : Set Î±}, IsClopen Z â†’ â‹ƒ (x : Î±) (_ : x âˆˆ Z), connectedComponent x = Z\",\n  \"isProp\": true,\n  \"docString\": \"A clopen set is the union of its connected components. \"}]\n",
    "prompt_cons": "/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- A nonempty convex set is path connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s :=\n\n/-- If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\nambient type `U` (when `U` contains `W`). -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {U W : Set X},\n  IsPathConnected W â†’ W âŠ† U â†’ IsPathConnected (Subtype.val â»Â¹' W) :=\n\n/-- If `X` is not a compact space, then `OnePoint X` is a connected space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\n  ConnectedSpace (OnePoint X) :=\n\n/-- Any two points in a path-connected space must be joined by a continuous path. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y :=\n\n/-- If the codomain of a homeomorphism is a locally connected space, then the domain is also\na locally connected space. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î± :=\n\n/-- A path-connected space must be nonempty. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X :=\n\n/-- The closure of a connected set is connected as well. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsConnected s â†’ IsConnected (closure s) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- A space is simply connected iff it is path connected, and there is at most one path\nup to homotopy between any two points. -/\ntheorem âˆ€ {Y : Type u_1} [inst : TopologicalSpace Y],\n  SimplyConnectedSpace Y â†” PathConnectedSpace Y âˆ§ âˆ€ (x y : Y), Subsingleton (Path.Homotopic.Quotient x y) :=\n\n/-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} (self : TopologicalSpace.OpenNhdsOf x), x âˆˆ self.carrier :=\n\n/-- In a simply connected space, any two paths are homotopic -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SimplyConnectedSpace X] {x y : X} (pâ‚ pâ‚‚ : Path x y),\n  Path.Homotopic pâ‚ pâ‚‚ :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î± :=\n\n/-- If a topological space admits an atlas with locally connected charts, then the space itself is\nlocally connected. -/\ntheorem âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- A locally finite preconnected infinite graph has at least one end. -/\ntheorem âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G) :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U) :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,\nevery open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- A clopen set is the union of its connected components. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z : Set Î±}, IsClopen Z â†’ â‹ƒ (x : Î±) (_ : x âˆˆ Z), connectedComponent x = Z :=\n\n/-- Let `X` be locally path connected. Show that every connected open set in `X` is path connected. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U â†’ IsConnected U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] {C : Set X},\n  IsConnected C â†’ IsOpen C â†’ IsPathConnected C ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {s : Set X},\n  IsConnected s â†’ IsOpen s â†’ IsPathConnected s ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U â†’ IsOpen U â†’ IsPathConnected U "
    ]
  },
  {
    "docString": "Let `X` be a compact Hausdorff space. Let `A` be a collection of closed connected subsets of `X` that is simply ordered by proper inclusion. Then `Y = â‹‚_{A âˆˆ A} A` is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\\n  (Î¼ : MeasureTheory.Measure X), MeasureTheory.Measure.InnerRegular Î¼ IsCompact IsClosed\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a `Ïƒ`-compact space, any closed set can be approximated by a compact subset. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\\n  ConnectedSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is not a compact space, then `OnePoint X` is a connected space. \"}]\n",
    "prompt_cons": "/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- The **Heineâ€“Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V) :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- In a `Ïƒ`-compact space, any closed set can be approximated by a compact subset. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\n  (Î¼ : MeasureTheory.Measure X), MeasureTheory.Measure.InnerRegular Î¼ IsCompact IsClosed :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s : Set Î±}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n\n/-- If `X` is not a compact space, then `OnePoint X` is a connected space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\n  ConnectedSpace (OnePoint X) :=\n\n/-- Let `X` be a compact Hausdorff space. Let `A` be a collection of closed connected subsets of `X` that is simply ordered by proper inclusion. Then `Y = â‹‚_{A âˆˆ A} A` is connected. -/\ntheorem",
    "choices": [
      "forall {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X] (A : Set (Set X)),\n  DirectedOn (fun a b => a âŠ‚ b) A â†’\n  (âˆ€ (a : Set X), a âˆˆ A â†’ IsClosed a âˆ§ IsConnected a) â†’\n  let Y ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X],\n  âˆ€ (A : Set (Set X)), (âˆ€ (s : Set X), s âˆˆ A â†’ (IsClosed s âˆ§ IsConnected s)) â†’\n  (âˆ€ (s t : Set X), s âˆˆ A â†’ t âˆˆ A â†’ s âŠ† t âˆ¨ t âŠ† s) â†’\n  IsConnected (Set.Interâ‚“ A) ",
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X] (A : Set (Set X)),\n  (âˆ€ (s : Set X), HasMem.Mem s A â†’ IsClosed s âˆ§ IsPreconnected s) â†’\n  DirectedOn (fun s t => HasSubset.Subset s t âˆ¨ HasSubset.Subset t s) A â†’\n  IsPreconnected (â‹‚â‚€ A) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X] {A : Set (Set X)},\n  (âˆ€ (x : Set X), x âˆˆ A â†’ IsClosed x âˆ§ IsPreconnected x) â†’ DirectedOn (HasSubset.Subset.on A) A â†’\n  IsPreconnected (â‹‚â‚€ A) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X]\n  (A : Set (Set X)) (H : âˆ€ (a : Set X), a âˆˆ A â†’ IsConnected a âˆ§ IsClosed a),\n  (âˆ€ (a b : Set X), a âˆˆ A â†’ b âˆˆ A â†’ a = b âˆ¨ a âŠ‚ b âˆ¨ b âŠ‚ a) â†’ âˆƒ Y, Y = â‹‚â‚€ A âˆ§ IsConnected Y ",
      "forall {X : Type u} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X]\n  {A : Set (Set X)}, (âˆ€ (x : Set X), x âˆˆ A â†’ â„ (IsClosed x âˆ§ IsPreconnected x)) â†’\n  DirectedOn (fun x y => x âŠ† y) A â†’ âˆ€ (Y : Set X), Y = Set.Interâ‚“ A â†’ IsPreconnected Y ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  {A : Set (Set X)}, (âˆ€ (a : Set X), a âˆˆ A â†’ IsClosed a âˆ§ IsConnected a) â†’\n  DirectedOn HasSubset.Subset A â†’ âˆƒ Y, Y = â‹‚â‚€ A âˆ§ IsConnected Y ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X] {A : Set (Set X)},\n  (âˆ€ (s : Set X), s âˆˆ A â†’ IsClosed s âˆ§ IsPreconnected s) â†’ Zorn.Chain HasSubset.Subset A â†’\n  IsPreconnected (â‹‚â‚€ A) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  {A : Set (Set X)}, âˆ€ (hA : A âŠ† {s : Set X | IsConnected s âˆ§ IsClosed s})\n  (hs : DirectedOn (HasSubset.Subset Ï€) A),\n  IsConnected (â‹‚â‚€ A) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X] {A : Set (Set X)},\n  (âˆ€ (x : Set X), x âˆˆ A â†’ IsClosed x âˆ§ IsPreconnected x) â†’ (âˆ€ (x : Set X), x âˆˆ A â†’ âˆ€ (y : Set X), y âˆˆ A â†’ x = y âˆ¨ x âŠ† y) â†’\n  IsPreconnected (â‹‚â‚€ A) "
    ]
  },
  {
    "docString": "Show that a connected metric space having more than one point is uncountable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\\n  Measurable f â†’ MeasureTheory.StronglyMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies strongly measurable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\\n  TopologicalSpace.FirstCountableTopology X\",\n  \"isProp\": true,\n  \"docString\": \"Every pseudo-metrizable space is first countable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} [inst_1 : TopologicalSpace.SecondCountableTopology X],\\n  IsOpenMap Quotient.mk' â†’ TopologicalSpace.SecondCountableTopology (Quotient S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open quotient of a second countable space is second countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\\n  CompleteSpace ((i : Î¹) Ã— E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : MetricSpace Î±],\\n  (âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ Î² x F, âˆ€ (x y : Î±), F x = F y â†’ dist x y â‰¤ Îµ) â†’ TopologicalSpace.SecondCountableTopology Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A metric space is second countable if one can reconstruct up to any `Îµ>0` any element of the\\nspace from countably many data. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] {f : Î± â†’ Î²} {x : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasurableSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\\n  Measurable f â†’ MeasureTheory.AEStronglyMeasurable f Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies ae strongly measurable. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : ProperSpace Î±], TopologicalSpace.SecondCountableTopology Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A proper pseudo metric space is sigma compact, and therefore second countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] [inst_1 : Countable Î¹]\\n  [inst_2 : âˆ€ (i : Î¹), TopologicalSpace.SecondCountableTopology (E i)],\\n  TopologicalSpace.SecondCountableTopology ((i : Î¹) Ã— E i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A countable disjoint union of second countable spaces is second countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²]\\n  [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²] {f : Î± â†’ Î²},\\n  Monotone f â†’\\n    âˆ€ [inst_4 : TopologicalSpace Î±] [inst : OrderTopology Î±] [inst : TopologicalSpace.SecondCountableTopology Î²],\\n      Set.Countable {x | Â¬ContinuousAt f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the set of points where a monotone function is not continuous\\nis at most countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î±], Set.Countable {x | nhdsWithin x (Set.Iio x) = âŠ¥}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of points which are isolated on the left is countable when the space is\\nsecond-countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"}]\n",
    "prompt_cons": "/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [inst : MeasurableSpace Î²]\n  [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\n  Measurable f â†’ MeasureTheory.StronglyMeasurable f :=\n\n/-- Every pseudo-metrizable space is first countable. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\n  TopologicalSpace.FirstCountableTopology X :=\n\n/-- An open quotient of a second countable space is second countable. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} [inst_1 : TopologicalSpace.SecondCountableTopology X],\n  IsOpenMap Quotient.mk' â†’ TopologicalSpace.SecondCountableTopology (Quotient S) :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem âˆ€ {Î¹ : Type u_2} {E : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ MetricSpace (E i)] [inst_1 : âˆ€ (i : Î¹), CompleteSpace (E i)],\n  CompleteSpace ((i : Î¹) Ã— E i) :=\n\n/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- A metric space is second countable if one can reconstruct up to any `Îµ>0` any element of the\nspace from countably many data. -/\ntheorem âˆ€ {Î± : Type u} [inst : MetricSpace Î±],\n  (âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆƒ Î² x F, âˆ€ (x y : Î±), F x = F y â†’ dist x y â‰¤ Îµ) â†’ TopologicalSpace.SecondCountableTopology Î± :=\n\n/-- In a space with second countable topology, measurable implies ae strongly measurable. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î²] {f : Î± â†’ Î²} {x : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasurableSpace Î²] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Î²]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î²] [inst_4 : OpensMeasurableSpace Î²],\n  Measurable f â†’ MeasureTheory.AEStronglyMeasurable f Î¼ :=\n\n/-- A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i :=\n\n/-- A proper pseudo metric space is sigma compact, and therefore second countable. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : ProperSpace Î±], TopologicalSpace.SecondCountableTopology Î± :=\n\n/-- A countable disjoint union of second countable spaces is second countable. -/\ntheorem âˆ€ {Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (E i)] [inst_1 : Countable Î¹]\n  [inst_2 : âˆ€ (i : Î¹), TopologicalSpace.SecondCountableTopology (E i)],\n  TopologicalSpace.SecondCountableTopology ((i : Î¹) Ã— E i) :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0 :=\n\n/-- In a second countable space, the set of points where a monotone function is not continuous\nis at most countable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : ConditionallyCompleteLinearOrder Î²]\n  [inst_2 : TopologicalSpace Î²] [inst_3 : OrderTopology Î²] {f : Î± â†’ Î²},\n  Monotone f â†’\n    âˆ€ [inst_4 : TopologicalSpace Î±] [inst : OrderTopology Î±] [inst : TopologicalSpace.SecondCountableTopology Î²],\n      Set.Countable {x | Â¬ContinuousAt f x} :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (interior (s i))) â†’ Set.Countable a :=\n\n/-- The set of points which are isolated on the left is countable when the space is\nsecond-countable. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î±], Set.Countable {x | nhdsWithin x (Set.Iio x) = âŠ¥} :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem âˆ€ {Î³ : Type w} [inst : EMetricSpace Î³] {s : Set Î³}, IsCompact s â†’ âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s = closure t :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Set.Nonempty s â†’ EMetric.infEdist x s â‰  âŠ¤ :=\n\n/-- Show that a connected metric space having more than one point is uncountable. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±], Nonempty Î± âˆ§ âˆƒ x y, x â‰  y â†’ Â¬Set.Countable Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±], Nonempty Î± â†’ âˆƒ x y, x â‰  y â†’ Â¬Set.Countable Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±],\n  Set.Nonempty (SetOf fun x => Exists fun {y} => x â‰  y) â†’ Â¬Set.Countable (SetOf fun x => Exists fun {y} => x â‰  y) ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±], Set.Nonempty (Î± Ã— Î±) â†’ Â¬Set.Countable Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [self : ConnectedSpace Î±], Set.Nonempty Î± â†’ Â¬Set.Countable Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±], Â¬(âˆƒ x y, x â‰  y) â†’ Set.Countable (Set.Univ : Set Î±) â†’ False ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [self : ConnectedSpace Î±], Set.Nonempty (Î± â†’ False) â†’ Â¬Set.Countable Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : ConnectedSpace Î±] [inst_2 : Nontrivial Î±],\n  Â¬Set.Countable (Set.Univ : Set Î±) ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [ConnectedSpace Î±], Â¬Set.Countable Î± â†’ 2 â‰¤ cardinal.mk Î± ",
      "âˆ€ {Î± : Type u} [inst : MetricSpace Î±] [inst_1 : TopologicalSpace.ConnectedSpace Î±],\n  2 â‰¤ cardinal.mk Î± â†’ Â¬Set.Countable Î± "
    ]
  },
  {
    "docString": "Show that `X` is countably compact if and only if every nested sequence `C_1 âŠ‡ C_2 âŠ‡ â‹¯` of closed nonempty sets of `X` has a nonempty intersection.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (Z : â„• â†’ Set Î±),\\n  (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\\n    (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ IsCompact (Z 0) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem for sequences indexed by `â„•`:\\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  IsSeqCompact s â†’ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ“¤ Î²` is countably generated, then any sequentially compact set is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.NonemptyCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with `â‹ƒâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty\\ninterior is locally compact.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty interior\\nis locally compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the type of nonempty compact subsets is second countable \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±],\\n  CompactIccSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A closed interval in a conditionally complete linear order is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {s : (i : Î¹) â†’ Set (Ï€ i)},\\n  (âˆ€ (i : Î¹), IsCompact (s i)) â†’ IsCompact {x | âˆ€ (i : Î¹), x i âˆˆ s i}\",\n  \"isProp\": true,\n  \"docString\": \"**Tychonoff's theorem**: product of compact sets is compact. \"}]\n",
    "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Cantor's intersection theorem for sequences indexed by `â„•`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (Z : â„• â†’ Set Î±),\n  (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’\n    (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’ IsCompact (Z 0) â†’ (âˆ€ (i : â„•), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) :=\n\n/-- If `ğ“¤ Î²` is countably generated, then any sequentially compact set is compact. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  IsSeqCompact s â†’ IsCompact s :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±),\n  Directed (fun x x_1 => x âŠ‡ x_1) Z â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (Z i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (Z i)) â†’ (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ Set.Nonempty (â‹‚ (i : Î¹), Z i) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.NonemptyCompacts Î±) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `â‹ƒâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s) :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty interior\nis locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s)) :=\n\n/-- In a second countable space, the type of nonempty compact subsets is second countable -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts Î±) :=\n\n/-- A closed interval in a conditionally complete linear order is compact. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : ConditionallyCompleteLinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±],\n  CompactIccSpace Î± :=\n\n/-- **Tychonoff's theorem**: product of compact sets is compact. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {s : (i : Î¹) â†’ Set (Ï€ i)},\n  (âˆ€ (i : Î¹), IsCompact (s i)) â†’ IsCompact {x | âˆ€ (i : Î¹), x i âˆˆ s i} :=\n\n/-- Show that `X` is countably compact if and only if every nested sequence `C_1 âŠ‡ C_2 âŠ‡ â‹¯` of closed nonempty sets of `X` has a nonempty intersection. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (C : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), IsClosed (C i)) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (C i)) â†’\n          (âˆ€ (i : â„•), C (i + 1) âŠ† C i) â†’ Set.Nonempty (â‹‚ (i : â„•), C i) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (C : â„• â†’ Set Î±), (âˆ€ (i : â„•), IsClosed (C i)) â†’\n      (âˆ€ (i : â„•), Set.Nonempty (C i)) â†’ âˆ€ (i : â„•), C (i + 1) âŠ† C i â†’ Set.Nonempty (â‹‚ (i : â„•), C i) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact (Set.univ : Set Î±) â†”\n    âˆ€ (C : â„• â†’ Set Î±), (âˆ€ (i : â„•), IsClosed (C i)) â†’\n      (âˆ€ (i : â„•), Set.Nonempty (C i)) â†’ (âˆ€ (i : â„•), C (i + 1) âŠ† C i) â†’ Set.Nonempty (â‹‚ (i : â„•), C i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (Z : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), IsClosed (Z i)) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (Z i)) â†’\n          (âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) â†’ Set.Nonempty (â‹‚ (i : â„•), Z i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (C : â„• â†’ Set Î±),\n      (âˆ€ (i : â„•), IsClosed (C i)) â†’\n        (âˆ€ (i : â„•), Set.Nonempty (C i)) â†’ (âˆ€ (i : â„•), C (i + 1) âŠ† C i) â†’ Set.Nonempty (â‹‚ (i : â„•), C i) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (C : â„• â†’ Set Î±), (âˆ€ (i : â„•), IsClosed (C i)) â†’\n      (âˆ€ (i : â„•), Set.Nonempty (C i)) â†’ âˆ€ (i : â„•), C (i + 1) âŠ† C i â†’ Set.Nonempty (â‹‚ (i : â„•), C i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†” âˆ€ (C : â„• â†’ Set Î±), (âˆ€ (i : â„•), IsClosed (C i)) â†’ (âˆ€ (i : â„•), Set.Nonempty (C i)) â†’ (âˆ€ (i : â„•), C (i + 1) âŠ† C i) â†’ Set.Nonempty (â‹‚ (i : â„•), C i) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  IsCountablyCompact Î± â†”\n    âˆ€ (C : â„• â†’ Set Î±), (âˆ€ (i : â„•), IsClosed (C i)) â†’\n      (âˆ€ (i : â„•), Set.Nonempty (C i)) â†’ (âˆ€ (i : â„•), C (i + 1) âŠ† C i) â†’ Set.Nonempty (â‹‚ (i : â„•), C i) ",
      "forall {Î± : Type u} [topological_space Î±], is_countably_compact Î± â†”\n  âˆ€ (C : â„• â†’ set Î±), (âˆ€ (i : â„•), is_closed (C i)) â†’\n    (âˆ€ (i : â„•), set.nonempty (C i)) â†’ set.nonempty (â‹‚ (i : â„•), C i) ",
      "forall {Î± : Type u} [topological_space Î±],\n  is_countably_compact Î± â†”\n    âˆ€ (C : â„• â†’ set Î±),\n      (âˆ€ (i : â„•), is_closed (C i)) â†’\n        (âˆ€ (i : â„•), set.nonempty (C i)) â†’ (âˆ€ (i : â„•), C (i + 1) âŠ† C i) â†’ set.nonempty (â‹‚ (i : â„•), C i) "
    ]
  },
  {
    "docString": "Show that the rationals `â„š` are not locally compact.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±),\\n  Disjoint (nhds x) (Filter.cocompact Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, the filters `ğ“ x` and `cocompact Î±` are disjoint for all `Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : NoncompactSpace Î±], Â¬IsCompact Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"In a noncompact space, `Set.univ` is not a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\": \"Filter.Tendsto Int.cast Filter.cofinite (Filter.cocompact â„)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Under the coercion from `â„¤` to `â„`, inverse images of compact sets are finite. \"},\n {\"theorem\": \"Â¬IsField â„¤\",\n  \"isProp\": true,\n  \"docString\": \"`â„¤` with its usual ring structure is not a field. \"},\n {\"theorem\": \"âˆ€ (p : â„) [inst : Fact (0 < p)], CompactSpace (AddCircle p)\",\n  \"isProp\": true,\n  \"docString\": \"The \\\"additive circle\\\" `â„ â§¸ (â„¤ âˆ™ p)` is compact. \"},\n {\"theorem\": \"Â¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Non-Denumerability of the Continuum**: The reals are not countable. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : â„ â†’ E),\\n  Filter.Tendsto (fun w => âˆ« (v : â„), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-(v * w)))) â€¢ f v)\\n    (Filter.cocompact â„) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\": \"The Riemann-Lebesgue lemma for functions on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\": \"For spaces that are not Hausdorff. \"},\n {\"theorem\": \"Â¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„), ProperlyDiscontinuousVAdd { x // x âˆˆ â†‘AddSubgroup.opposite (AddSubgroup.zmultiples p) } â„\",\n  \"isProp\": true,\n  \"docString\":\n  \"The action on `â„` by right multiplication of its the subgroup `zmultiples p` (the multiples of\\n`p:â„`) is properly discontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], BaireSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second theorem states that locally compact spaces are Baire. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R], Â¬IsField R\",\n  \"isProp\": true,\n  \"docString\": \"A discrete valuation ring `R` is not a field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\": \"âˆ€ (r : â„), r â‰  0 â†’ Real.sign r = -1 âˆ¨ Real.sign r = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is useful for working with `â„Ë£` \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : Finite Î¹], LocallyCompactSpace ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In general it suffices that all but finitely many of the spaces are compact,\\nbut that's not straightforward to state and use. \"}]\n",
    "prompt_cons": "/-- In a locally compact space, the filters `ğ“ x` and `cocompact Î±` are disjoint for all `Î±`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±),\n  Disjoint (nhds x) (Filter.cocompact Î±) :=\n\n/-- In a noncompact space, `Set.univ` is not a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : NoncompactSpace Î±], Â¬IsCompact Set.univ :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- If `X` is a non-compact space, then `âˆ` is not an isolated point of `OnePoint X`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}á¶œ) :=\n\n/-- Under the coercion from `â„¤` to `â„`, inverse images of compact sets are finite. -/\ntheorem Filter.Tendsto Int.cast Filter.cofinite (Filter.cocompact â„) :=\n\n/-- `â„¤` with its usual ring structure is not a field. -/\ntheorem Â¬IsField â„¤ :=\n\n/-- The \"additive circle\" `â„ â§¸ (â„¤ âˆ™ p)` is compact. -/\ntheorem âˆ€ (p : â„) [inst : Fact (0 < p)], CompactSpace (AddCircle p) :=\n\n/-- **Non-Denumerability of the Continuum**: The reals are not countable. -/\ntheorem Â¬Set.Countable Set.univ :=\n\n/-- The Riemann-Lebesgue lemma for functions on `â„`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : â„ â†’ E),\n  Filter.Tendsto (fun w => âˆ« (v : â„), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-(v * w)))) â€¢ f v)\n    (Filter.cocompact â„) (nhds 0) :=\n\n/-- For spaces that are not Hausdorff. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : âˆ€ (i : Î¹), CompactSpace (Ï€ i)],\n  LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) :=\n\n/-- The complex numbers are not countable. -/\ntheorem Â¬Set.Countable Set.univ :=\n\n/-- The action on `â„` by right multiplication of its the subgroup `zmultiples p` (the multiples of\n`p:â„`) is properly discontinuous. -/\ntheorem âˆ€ (p : â„), ProperlyDiscontinuousVAdd { x // x âˆˆ â†‘AddSubgroup.opposite (AddSubgroup.zmultiples p) } â„ :=\n\n/-- The second theorem states that locally compact spaces are Baire. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], BaireSpace Î± :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- A discrete valuation ring `R` is not a field. -/\ntheorem âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R], Â¬IsField R :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I â‰  0 â†’ Set.Finite {v | v.asIdeal âˆ£ I} :=\n\n/-- This lemma is useful for working with `â„Ë£` -/\ntheorem âˆ€ (r : â„), r â‰  0 â†’ Real.sign r = -1 âˆ¨ Real.sign r = 1 :=\n\n/-- In general it suffices that all but finitely many of the spaces are compact,\nbut that's not straightforward to state and use. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)]\n  [inst_1 : âˆ€ (i : Î¹), LocallyCompactSpace (Ï€ i)] [inst_2 : Finite Î¹], LocallyCompactSpace ((i : Î¹) â†’ Ï€ i) :=\n\n/-- Show that the rationals `â„š` are not locally compact. -/\ntheorem",
    "choices": [
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š ",
      "Â¬LocallyCompactSpace â„š "
    ]
  },
  {
    "docString": "Show that if `X` is a Hausdorff space that is locally compact at the point `x`, then for each neighborhood `U` of `x`, there is a neighborhood `V` of `x` such that `âˆª V` is compact and `âˆª V âŠ† U`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"A reformulation of the definition of locally compact space: In a locally compact space,\\nevery open set containing `x` has a compact subset containing `x` in its interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `K * V âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} (self : TopologicalSpace.OpenNhdsOf x), x âˆˆ self.carrier\",\n  \"isProp\": true,\n  \"docString\":\n  \"The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `V * K âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ V + K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `V + K âŠ† U`.\"}]\n",
    "prompt_cons": "/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- In a locally compact space, for every containment `K âŠ† U` of a compact set `K` in an open\nset `U`, there is a compact neighborhood `L` such that `K âŠ† L âŠ† U`: equivalently, there is a\ncompact `L` such that `K âŠ† interior L` and `L âŠ† U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [hÎ± : LocallyCompactSpace Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ L, IsCompact L âˆ§ K âŠ† interior L âˆ§ L âŠ† U :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,\nevery open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {x : Î±} {U : Set Î±},\n  IsOpen U â†’ x âˆˆ U â†’ âˆƒ K, IsCompact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- In a locally compact Tâ‚‚ space, given a compact set `K` inside an open set `U`, we can find a\nopen set `V` between these sets with compact closure: `K âŠ† V` and the closure of `V` is inside `U`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K U : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ IsCompact (closure V) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `K * V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {x : Î±} (self : TopologicalSpace.OpenNhdsOf x), x âˆˆ self.carrier :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `V * K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `V + K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ V + K âŠ† U :=\n\n/-- Show that if `X` is a Hausdorff space that is locally compact at the point `x`, then for each neighborhood `U` of `x`, there is a neighborhood `V` of `x` such that `âˆª V` is compact and `âˆª V âŠ† U`. -/\ntheorem",
    "choices": [
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x : Î±} {U : Set Î±},\n  LocallyCompactSpace.LocalCompactness x â†’ IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (â‹ƒ V) âˆ§ (â‹ƒ V) âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] (x : Î±) {U : Set Î±},\n  LocallyCompactSpace.LocallyCompact x â†’ IsOpen U â†’ x âˆˆ U â†’ âˆƒ V : TopologicalSpace.OpenNhdsOf x, IsCompact (â‹ƒ V) âˆ§ (â‹ƒ V) âŠ† U ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x : Î±} {U : Set Î±} (hx : âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) (hU : U âˆˆ nhds x),\n  âˆƒ V : Set Î±, V âˆˆ nhds x âˆ§ IsCompact (Union V) âˆ§ Union V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x : Î±} (h : LocallyCompactSpace Î±) {U : Set Î±},\n  U âˆˆ nhds x â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (â‹ƒ V) âˆ§ â‹ƒ V âŠ† U ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x : Î±} {U : Set Î±},\n  LocallyCompactSpace Î± â†’ IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsCompact (closure V) âˆ§ x âˆˆ V âˆ§ V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x : Î±} {U : Set Î±},\n  LocallyCompactSpace.nhds_basis Î± x â†’ IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : T2Space X] {x : X} {U : Set X},\n  LocallyCompactSpace.LocalCompact x â†’ IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] (x : Î±) {U : Set Î±},\n  IsOpen U â†’ x âˆˆ U â†’ LocallyCompactSpace.LocalCompact x â†’ âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x âˆ§ K âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x : Î±} {U : Set Î±},\n  LocallyCompactSpace.LocalCompact Î± x â†’ IsOpen U â†’ x âˆˆ U â†’\n    âˆƒ V, V âˆˆ nhds x âˆ§ IsCompact (set.Union V) âˆ§ set.Union V âŠ† U ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {x : Î±} {U : Set Î±},\n  IsOpen U â†’ x âˆˆ U â†’ LocallyCompactSpace x â†’ âˆƒ V, IsOpen V âˆ§ x âˆˆ V âˆ§ IsCompact (closure V) âˆ§ closure V âŠ† U "
    ]
  },
  {
    "docString": "Show that if `X` has a countable dense subset, every collection of disjoint open sets in `X` is countable.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, Set.Countable s âˆ§ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"There exists a countable dense set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {t : Set Î¹} {s : Set Î±},\\n  IsGÎ´ s â†’\\n    Dense s â†’\\n      Set.Countable t â†’\\n        âˆ€ {f : Î¹ â†’ Set Î±},\\n          (âˆ€ (i : Î¹), i âˆˆ t â†’ IsClosed (f i)) â†’\\n            s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), f i â†’ Dense (â‹ƒ (i : Î¹) (_ : i âˆˆ t), interior (f i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a countable family of closed sets cover a dense `GÎ´` set, then the union of their interiors\\nis dense. Formulated here with a union over a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with `â‹ƒâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹},\\n  Set.PairwiseDisjoint a s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is an encodable type. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\\n  HasCountableSeparatingOn X IsClosed s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists a countable family of open sets separating points of `s`, then there exists\\na countable family of closed sets separating points of `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±},\\n  s âˆˆ residual Î± â†”\\n    âˆƒ S, (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsOpen t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ Dense t) âˆ§ Set.Countable S âˆ§ â‹‚â‚€ S âŠ† s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is residual iff it includes a countable intersection of dense open sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, Dense s â†’ Dense t â†’ IsOpen t â†’ Dense (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a dense set with an open dense set is a dense set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, Dense s â†’ Dense t â†’ IsOpen s â†’ Dense (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of an open dense set with a dense set is a dense set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²}\\n  {f : (x : Î²) â†’ x âˆˆ S â†’ Set Î±},\\n  (âˆ€ (s : Î²) (H : s âˆˆ S), IsGÎ´ (f s H)) â†’\\n    Set.Countable S â†’ (âˆ€ (s : Î²) (H : s âˆˆ S), Dense (f s H)) â†’ Dense (â‹‚ (s : Î²) (h : s âˆˆ S), f s h)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"}]\n",
    "prompt_cons": "/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- There exists a countable dense set. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, Set.Countable s âˆ§ Dense s :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsOpen (f s)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) â†’ Dense (â‹‚ (s : Î²) (_ : s âˆˆ S), f s) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ (s : Î²), s âˆˆ S â†’ IsClosed (f s)) â†’\n    Set.Countable S â†’ â‹ƒ (s : Î²) (_ : s âˆˆ S), f s = Set.univ â†’ Dense (â‹ƒ (s : Î²) (_ : s âˆˆ S), interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsGÎ´ s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i :=\n\n/-- If a countable family of closed sets cover a dense `GÎ´` set, then the union of their interiors\nis dense. Formulated here with a union over a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {t : Set Î¹} {s : Set Î±},\n  IsGÎ´ s â†’\n    Dense s â†’\n      Set.Countable t â†’\n        âˆ€ {f : Î¹ â†’ Set Î±},\n          (âˆ€ (i : Î¹), i âˆˆ t â†’ IsClosed (f i)) â†’\n            s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), f i â†’ Dense (â‹ƒ (i : Î¹) (_ : i âˆˆ t), interior (f i)) :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  Dense s â†” âˆ€ (U : Set Î±), IsOpen U â†’ Set.Nonempty U â†’ Set.Nonempty (U âˆ© s) :=\n\n/-- The set of finite subsets of a countable set is countable. -/\ntheorem âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s} :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `â‹ƒâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsClosed s) â†’\n    Set.Countable S â†’ â‹ƒâ‚€ S = Set.univ â†’ Dense (â‹ƒ (s : Set Î±) (_ : s âˆˆ S), interior s) :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is an encodable type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] [inst_2 : Encodable Î²]\n  {f : Î² â†’ Set Î±}, (âˆ€ (s : Î²), IsOpen (f s)) â†’ (âˆ€ (s : Î²), Dense (f s)) â†’ Dense (â‹‚ (s : Î²), f s) :=\n\n/-- If there exists a countable family of open sets separating points of `s`, then there exists\na countable family of closed sets separating points of `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\n  HasCountableSeparatingOn X IsClosed s :=\n\n/-- A set is residual iff it includes a countable intersection of dense open sets. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±},\n  s âˆˆ residual Î± â†”\n    âˆƒ S, (âˆ€ (t : Set Î±), t âˆˆ S â†’ IsOpen t) âˆ§ (âˆ€ (t : Set Î±), t âˆˆ S â†’ Dense t) âˆ§ Set.Countable S âˆ§ â‹‚â‚€ S âŠ† s :=\n\n/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, Dense s â†’ Dense t â†’ IsOpen t â†’ Dense (s âˆ© t) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, Dense s â†’ Dense t â†’ IsOpen s â†’ Dense (s âˆ© t) :=\n\n/-- Baire theorem: a countable intersection of dense GÎ´ sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set Î²}\n  {f : (x : Î²) â†’ x âˆˆ S â†’ Set Î±},\n  (âˆ€ (s : Î²) (H : s âˆˆ S), IsGÎ´ (f s H)) â†’\n    Set.Countable S â†’ (âˆ€ (s : Î²) (H : s âˆˆ S), Dense (f s H)) â†’ Dense (â‹‚ (s : Î²) (h : s âˆˆ S), f s h) :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- Show that if `X` has a countable dense subset, every collection of disjoint open sets in `X` is countable. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±},\n  Set.PairwiseDisjoint Set.Univ s â†’ (âˆ€ (i : Î¹), IsOpen (s i)) â†’ Set.Countable {i : Î¹ | Set.Nonempty (s i)} ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±},\n  Set.PairwiseDisjoint Set.Univ s â†’\n    (âˆ€ (i : Î¹), IsOpen (s i)) â†’ (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Set.Countable {i : Î¹ | s i â‰  âˆ…} ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ Set.Countable a ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a ",
      "forall {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), IsOpen (s i)) â†’ DisjointUnion s â†’ Set.Countable (range s) ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±},\n  Set.PairwiseDisjoint (Set.Range s) (Î» (x y : Set Î±), Disjoint x y) â†’\n    (âˆ€ (i : Î¹), IsOpen (s i)) â†’ (âˆ€ (i : Î¹), Set.Nonempty (s i)) â†’ Set.Countable (Set.Range s) ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±},\n  (âˆ€ (i : Î¹), IsOpen (s i)) â†’\n    Set.PairwiseDisjoint Set.Univ s â†’ Set.Countable (Function.Support s) ",
      "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ Set.Countable a "
    ]
  },
  {
    "docString": "Show that if `X` is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\\n  x â‰  y â†’\\n    âˆƒ Uâ‚,\\n      Uâ‚ âˆˆ nhds x âˆ§\\n        âˆƒ Vâ‚,\\n          Vâ‚ âˆˆ nhds x âˆ§\\n            âˆƒ Uâ‚‚,\\n              Uâ‚‚ âˆˆ nhds y âˆ§\\n                âˆƒ Vâ‚‚,\\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Hausdorff distance between two sets and their closures coincide \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T5Space Î±] â¦ƒs t : Set Î±â¦„,\\n  Disjoint (closure s) t â†’ Disjoint s (closure t) â†’ Disjoint (nhdsSet s) (nhdsSet t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `closure s` is disjoint with `t` and `s` is disjoint with `closure t`, then `s` and `t`\\nadmit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” closure s = closure t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two sets are at zero Hausdorff distance if and only if they have the same closures \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T25Space Î±] â¦ƒx y : Î±â¦„,\\n  x â‰  y â†’ Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two distinct points in a Tâ‚‚.â‚… space, their filters of closed neighborhoods are\\ndisjoint. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\\nsuch that `VV âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\\n  HasCountableSeparatingOn X IsClosed s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists a countable family of open sets separating points of `s`, then there exists\\na countable family of closed sets separating points of `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±}, EMetric.hausdorffEdist s t = 0 â†” closure s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two sets are at zero Hausdorff edistance if and only if they have the same closure \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  IsClosed s â†’ IsClosed t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” s = t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two closed sets are at zero Hausdorff distance if and only if they coincide \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Metric.hausdorffDist s (closure s) = 0\",\n  \"isProp\": true,\n  \"docString\": \"The Hausdorff distance between a set and its closure vanish \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"}]\n",
    "prompt_cons": "/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Z a b : Set Î±},\n  IsClopen Z â†’ Z âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (Z âˆ© a) :=\n\n/-- Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\n  x â‰  y â†’\n    âˆƒ Uâ‚,\n      Uâ‚ âˆˆ nhds x âˆ§\n        âˆƒ Vâ‚,\n          Vâ‚ âˆˆ nhds x âˆ§\n            âˆƒ Uâ‚‚,\n              Uâ‚‚ âˆˆ nhds y âˆ§\n                âˆƒ Vâ‚‚,\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚ :=\n\n/-- The Hausdorff distance between two sets and their closures coincide -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- If `closure s` is disjoint with `t` and `s` is disjoint with `closure t`, then `s` and `t`\nadmit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T5Space Î±] â¦ƒs t : Set Î±â¦„,\n  Disjoint (closure s) t â†’ Disjoint s (closure t) â†’ Disjoint (nhdsSet s) (nhdsSet t) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- Two sets are at zero Hausdorff distance if and only if they have the same closures -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” closure s = closure t) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- Given two distinct points in a Tâ‚‚.â‚… space, their filters of closed neighborhoods are\ndisjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T25Space Î±] â¦ƒx y : Î±â¦„,\n  x â‰  y â†’ Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure) :=\n\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U :=\n\n/-- If there exists a countable family of open sets separating points of `s`, then there exists\na countable family of closed sets separating points of `s`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\n  HasCountableSeparatingOn X IsClosed s :=\n\n/-- Two sets are at zero Hausdorff edistance if and only if they have the same closure -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±}, EMetric.hausdorffEdist s t = 0 â†” closure s = closure t :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U) :=\n\n/-- Two closed sets are at zero Hausdorff distance if and only if they coincide -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” s = t) :=\n\n/-- The Hausdorff distance between a set and its closure vanish -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Metric.hausdorffDist s (closure s) = 0 :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {K U V : Set Î±},\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚ :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- Show that if `X` is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ Uâ‚ Uâ‚‚, IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ s âŠ† Uâ‚ âˆ§ t âŠ† Uâ‚‚ âˆ§ Disjoint (closure Uâ‚) (closure Uâ‚‚) ",
      "forall {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (A B : Set Î±),\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ A âŠ† U âˆ§ B âŠ† V âˆ§ Disjoint (closure U) (closure V) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] {s t : Set X}, \n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedByCloseds s t ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ s âŠ† U âˆ§ t âŠ† V âˆ§ Disjoint (closure U) (closure V) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ Separated (closure s) (closure t) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) "
    ]
  },
  {
    "docString": "Show that a closed subspace of a normal space is normal.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k â†‘s = s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Coercing a subspace to a set then taking the affine span produces the original subspace. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  (Q : AffineSubspace ğ•œ E), Convex ğ•œ â†‘Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `Tâ‚…` space is a `Tâ‚…` space. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œâ‚ : Type u_1} {ğ•œâ‚‚ : Type u_2} [inst : NontriviallyNormedField ğ•œâ‚] [inst_1 : NormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œâ‚ â†’+* ğ•œâ‚‚}\\n  {Mâ‚ : Type u_3} {Mâ‚‚ : Type u_4} [inst_2 : SeminormedAddCommGroup Mâ‚] [inst_3 : AddCommGroup Mâ‚‚]\\n  [inst_4 : NormedSpace ğ•œâ‚ Mâ‚] [inst_5 : Module ğ•œâ‚‚ Mâ‚‚] [inst_6 : UniformSpace Mâ‚‚] [inst_7 : UniformAddGroup Mâ‚‚]\\n  [inst_8 : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [inst_9 : T2Space Mâ‚‚] [inst_10 : CompleteSpace Mâ‚‚],\\n  IsClosed {f | IsCompactOperator â†‘f}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of compact operators from a normed space to a complete topological vector space is\\nclosed. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {u : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsOpen (u i)) â†’\\n    (âˆ€ (x : X), Set.Finite {i | x âˆˆ u i}) â†’\\n      â‹ƒ (i : Î¹), u i = Set.univ â†’\\n        âˆƒ v, Set.iUnion v = Set.univ âˆ§ (âˆ€ (i : Î¹), IsOpen (v i)) âˆ§ âˆ€ (i : Î¹), closure (v i) âŠ† u i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \\\"shrunk\\\"\\nto a new open cover so that the closure of each new open set is contained in the corresponding\\noriginal open set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (Kâ‚ Kâ‚‚ : Submodule ğ•œ E), Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of two orthogonal subspaces equals the subspace orthogonal\\nto the sup. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ğ•œ E] {s : Set E},\\n  Convex ğ•œ s â†’ Convex ğ•œ (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"}]\n",
    "prompt_cons": "/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- Coercing a subspace to a set then taking the affine span produces the original subspace. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k â†‘s = s :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤ :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- Affine subspaces are convex. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  (Q : AffineSubspace ğ•œ E), Convex ğ•œ â†‘Q :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- A subspace of a `Tâ‚…` space is a `Tâ‚…` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x } :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2 :=\n\n/-- The set of compact operators from a normed space to a complete topological vector space is\nclosed. -/\ntheorem âˆ€ {ğ•œâ‚ : Type u_1} {ğ•œâ‚‚ : Type u_2} [inst : NontriviallyNormedField ğ•œâ‚] [inst_1 : NormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œâ‚ â†’+* ğ•œâ‚‚}\n  {Mâ‚ : Type u_3} {Mâ‚‚ : Type u_4} [inst_2 : SeminormedAddCommGroup Mâ‚] [inst_3 : AddCommGroup Mâ‚‚]\n  [inst_4 : NormedSpace ğ•œâ‚ Mâ‚] [inst_5 : Module ğ•œâ‚‚ Mâ‚‚] [inst_6 : UniformSpace Mâ‚‚] [inst_7 : UniformAddGroup Mâ‚‚]\n  [inst_8 : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [inst_9 : T2Space Mâ‚‚] [inst_10 : CompleteSpace Mâ‚‚],\n  IsClosed {f | IsCompactOperator â†‘f} :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new open cover so that the closure of each new open set is contained in the corresponding\noriginal open set. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {u : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsOpen (u i)) â†’\n    (âˆ€ (x : X), Set.Finite {i | x âˆˆ u i}) â†’\n      â‹ƒ (i : Î¹), u i = Set.univ â†’\n        âˆƒ v, Set.iUnion v = Set.univ âˆ§ (âˆ€ (i : Î¹), IsOpen (v i)) âˆ§ âˆ€ (i : Î¹), closure (v i) âŠ† u i :=\n\n/-- The inf of two orthogonal subspaces equals the subspace orthogonal\nto the sup. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (Kâ‚ Kâ‚‚ : Submodule ğ•œ E), Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—® :=\n\n/-- In a topological vector space, the closure of a convex set is convex. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ğ•œ E] {s : Set E},\n  Convex ğ•œ s â†’ Convex ğ•œ (closure s) :=\n\n/-- Show that a closed subspace of a normal space is normal. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {s : Set Î±},\n  IsClosed s â†’ NormalSpace {x // x âˆˆ s} ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {S : Set Î±},\n  IsClosed S â†’ NormalSpace { x // x âˆˆ S } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (S : Subspace Î±), IsClosed â†‘S â†’ NormalSpace â†‘S ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±),\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s : Set Î±},\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] (A : Set Î±),\n  IsClosed A â†’ NormalSpace {x // x âˆˆ A} ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±),\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±),\n  IsClosed s â†’ NormalSpace (Subspace Î± s) ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±),\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {s : Submodule Î±},\n  IsClosed â†‘s â†’ NormalSpace { x // x âˆˆ s } "
    ]
  },
  {
    "docString": "Show that if `Î  X_Î±` is regular, then so is `X_Î±`. Assume that each `X_Î±` is nonempty.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Array Î±)\",\n  \"isProp\": true,\n  \"docString\": \"If `Î±` is countable, then so is `Array Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : AddGroup Î±] [inst_2 : TopologicalAddGroup Î±],\\n  TopologicalAddGroup Î±áµƒáµ’áµ–\",\n  \"isProp\": true,\n  \"docString\": \"If addition is continuous in `Î±`, then it also is in `Î±áµƒáµ’áµ–`.\"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Finset Î±)\",\n  \"isProp\": true,\n  \"docString\": \"If `Î±` is countable, then so is `Finset Î±`. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Multiset Î±)\",\n  \"isProp\": true,\n  \"docString\": \"If `Î±` is countable, then so is `Multiset Î±`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : SeminormedAddCommGroup Î²] [inst_2 : Nonempty Î±]\\n  [inst_3 : One Î²] [inst_4 : NormOneClass Î²], NormOneClass (BoundedContinuousFunction Î± Î²)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `â€–(1 : Î²)â€– = 1`, then `â€–(1 : Î± â†’áµ‡ Î²)â€– = 1` if `Î±` is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Mul Î±] [inst_2 : ContinuousMul Î±], ContinuousMul Î±áµáµ’áµ–\",\n  \"isProp\": true,\n  \"docString\":\n  \"If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {p : Finset Î± â†’ Prop} [inst : DecidableEq Î±] (s : Finset Î±),\\n  p âˆ… â†’ (âˆ€ â¦ƒa : Î±â¦„ {s : Finset Î±}, Â¬a âˆˆ s â†’ p s â†’ p (insert a s)) â†’ p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a proposition about an arbitrary `Finset Î±`,\\nit suffices to prove it for the empty `Finset`,\\nand to show that if it holds for some `Finset Î±`,\\nthen it holds for the `Finset` obtained by inserting a new element.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {p : (s : Finset Î±) â†’ Finset.Nonempty s â†’ Prop},\\n  (âˆ€ (a : Î±), p {a} (_ : Finset.Nonempty {a})) â†’\\n    (âˆ€ â¦ƒa : Î±â¦„ (s : Finset Î±) (h : Â¬a âˆˆ s) (hs : Finset.Nonempty s),\\n        p s hs â†’ p (Finset.cons a s h) (_ : Finset.Nonempty (Finset.cons a s h))) â†’\\n      âˆ€ {s : Finset Î±} (hs : Finset.Nonempty s), p s hs\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a proposition about a nonempty `s : Finset Î±`, it suffices to show it holds for all\\nsingletons and that if it holds for nonempty `t : Finset Î±`, then it also holds for the `Finset`\\nobtained by inserting an element in `t`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²},\\n  (Î± â†’+* Î²) â†’ âˆ€ [inst : Nontrivial Î²], Nontrivial Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a homomorphism `f : Î± â†’+* Î²` and `Î²` is nontrivial, then `Î±` is nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\\n  UniformGroup (UniformFun Î± G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a uniform group, then `Î± â†’áµ¤ G` is a uniform group as well. \"},\n {\"theorem\": \"âˆ€ {Î± : Sort u} {p : Prop}, Nonempty Î± â†’ (Î± â†’ p) â†’ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The elimination principle for `Nonempty Î±`. If `Nonempty Î±`, and we can\\nprove `p` given any element `x : Î±`, then `p` holds. Note that it is essential\\nthat `p` is a `Prop` here; the version with `p` being a `Sort u` is equivalent\\nto `Classical.choice`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] {ğ”– : Set (Set Î±)} [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\\n  UniformGroup (UniformOnFun Î± G ğ”–)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `ğ”– : Set (Set Î±)`. If `G` is a uniform group, then `Î± â†’áµ¤[ğ”–] G` is a uniform group as\\nwell. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : UniformSpace Î²] (ğ”– : Set (Set Î±)),\\n  Set.Nonempty ğ”– â†’\\n    DirectedOn (fun x x_1 => x âŠ† x_1) ğ”– â†’\\n      Filter.HasBasis (uniformity (UniformOnFun Î± Î² ğ”–)) (fun SV => SV.fst âˆˆ ğ”– âˆ§ SV.snd âˆˆ uniformity Î²) fun SV =>\\n        UniformOnFun.gen ğ”– SV.fst SV.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ”– : Set (Set Î±)` is nonempty and directed, then the uniformity of `Î± â†’áµ¤[ğ”–] Î²` admits the\\nfamily `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` as a filter basis. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning Î± are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {m : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} {Î¹ : Type u_1} [inst : Countable Î¹]\\n  [inst : Nonempty Î¹] (t : Î¹ â†’ Set Î±),\\n  (âˆ€ (n : Î¹), MeasurableSet (t n)) â†’\\n    âˆ€ (g : Î¹ â†’ Î± â†’ Î²),\\n      (âˆ€ (n : Î¹), Measurable (g n)) â†’\\n        (Pairwise fun i j => Set.EqOn (g i) (g j) (t i âˆ© t j)) â†’ âˆƒ f, Measurable f âˆ§ âˆ€ (n : Î¹), Set.EqOn f (g n) (t n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `t i` be a nonempty countable family of measurable sets in `Î±`. Let `g i : Î± â†’ Î²` be a\\nfamily of measurable functions such that `g i` agrees with `g j` on `t i âˆ© t j`. Then there exists\\na measurable function `f : Î± â†’ Î²` that agrees with each `g i` on `t i`.\\n\\nWe only need the assumption `[Nonempty Î¹]` to prove `[Nonempty (Î± â†’ Î²)]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} (i : Î¹) [inst : Infinite (Ï€ i)] [inst : âˆ€ (i : Î¹), Nonempty (Ï€ i)],\\n  Infinite ((i : Î¹) â†’ Ï€ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If at least one `Ï€ i` is infinite and the rest nonempty, the pi type of all `Ï€` is infinite. \"}]\n",
    "prompt_cons": "/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- If `Î±` is a compact space, then a locally finite family of sets of `Î±` can have only finitely\nmany nonempty elements. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î¹ : Type u_1} [inst_1 : CompactSpace Î±] {f : Î¹ â†’ Set Î±},\n  LocallyFinite f â†’ Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- To show that an invariant Ïƒ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {Î¼ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite Î¼]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant Î¼] {K : Set G},\n  IsCompact K â†’ Set.Nonempty (interior K) â†’ â†‘â†‘Î¼ K â‰  âŠ¤ â†’ MeasureTheory.Measure.Regular Î¼ :=\n\n/-- If `Î±` is countable, then so is `Array Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Array Î±) :=\n\n/-- If addition is continuous in `Î±`, then it also is in `Î±áµƒáµ’áµ–`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : AddGroup Î±] [inst_2 : TopologicalAddGroup Î±],\n  TopologicalAddGroup Î±áµƒáµ’áµ– :=\n\n/-- If `Î±` is countable, then so is `Finset Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Finset Î±) :=\n\n/-- If `Î±` is countable, then so is `Multiset Î±`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Countable Î±], Countable (Multiset Î±) :=\n\n/-- If `â€–(1 : Î²)â€– = 1`, then `â€–(1 : Î± â†’áµ‡ Î²)â€– = 1` if `Î±` is nonempty. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : SeminormedAddCommGroup Î²] [inst_2 : Nonempty Î±]\n  [inst_3 : One Î²] [inst_4 : NormOneClass Î²], NormOneClass (BoundedContinuousFunction Î± Î²) :=\n\n/-- If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Mul Î±] [inst_2 : ContinuousMul Î±], ContinuousMul Î±áµáµ’áµ– :=\n\n/-- To prove a proposition about an arbitrary `Finset Î±`,\nit suffices to prove it for the empty `Finset`,\nand to show that if it holds for some `Finset Î±`,\nthen it holds for the `Finset` obtained by inserting a new element. -/\ntheorem âˆ€ {Î± : Type u_1} {p : Finset Î± â†’ Prop} [inst : DecidableEq Î±] (s : Finset Î±),\n  p âˆ… â†’ (âˆ€ â¦ƒa : Î±â¦„ {s : Finset Î±}, Â¬a âˆˆ s â†’ p s â†’ p (insert a s)) â†’ p s :=\n\n/-- To prove a proposition about a nonempty `s : Finset Î±`, it suffices to show it holds for all\nsingletons and that if it holds for nonempty `t : Finset Î±`, then it also holds for the `Finset`\nobtained by inserting an element in `t`. -/\ntheorem âˆ€ {Î± : Type u_1} {p : (s : Finset Î±) â†’ Finset.Nonempty s â†’ Prop},\n  (âˆ€ (a : Î±), p {a} (_ : Finset.Nonempty {a})) â†’\n    (âˆ€ â¦ƒa : Î±â¦„ (s : Finset Î±) (h : Â¬a âˆˆ s) (hs : Finset.Nonempty s),\n        p s hs â†’ p (Finset.cons a s h) (_ : Finset.Nonempty (Finset.cons a s h))) â†’\n      âˆ€ {s : Finset Î±} (hs : Finset.Nonempty s), p s hs :=\n\n/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_3} [inst : (i : Î¹) â†’ TopologicalSpace (Ï€ i)] {X : Type u_1} (f : (i : Î¹) â†’ X â†’ Ï€ i),\n  Inducing fun x i => f i x :=\n\n/-- If there is a homomorphism `f : Î± â†’+* Î²` and `Î²` is nontrivial, then `Î±` is nontrivial. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²},\n  (Î± â†’+* Î²) â†’ âˆ€ [inst : Nontrivial Î²], Nontrivial Î± :=\n\n/-- If `G` is a uniform group, then `Î± â†’áµ¤ G` is a uniform group as well. -/\ntheorem âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformFun Î± G) :=\n\n/-- The elimination principle for `Nonempty Î±`. If `Nonempty Î±`, and we can\nprove `p` given any element `x : Î±`, then `p` holds. Note that it is essential\nthat `p` is a `Prop` here; the version with `p` being a `Sort u` is equivalent\nto `Classical.choice`. -/\ntheorem âˆ€ {Î± : Sort u} {p : Prop}, Nonempty Î± â†’ (Î± â†’ p) â†’ p :=\n\n/-- Let `ğ”– : Set (Set Î±)`. If `G` is a uniform group, then `Î± â†’áµ¤[ğ”–] G` is a uniform group as\nwell. -/\ntheorem âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] {ğ”– : Set (Set Î±)} [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformOnFun Î± G ğ”–) :=\n\n/-- If `ğ”– : Set (Set Î±)` is nonempty and directed, then the uniformity of `Î± â†’áµ¤[ğ”–] Î²` admits the\nfamily `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` as a filter basis. -/\ntheorem âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : UniformSpace Î²] (ğ”– : Set (Set Î±)),\n  Set.Nonempty ğ”– â†’\n    DirectedOn (fun x x_1 => x âŠ† x_1) ğ”– â†’\n      Filter.HasBasis (uniformity (UniformOnFun Î± Î² ğ”–)) (fun SV => SV.fst âˆˆ ğ”– âˆ§ SV.snd âˆˆ uniformity Î²) fun SV =>\n        UniformOnFun.gen ğ”– SV.fst SV.snd :=\n\n/-- Distinct elements of a set of sets partitioning Î± are disjoint. -/\ntheorem âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id :=\n\n/-- Let `t i` be a nonempty countable family of measurable sets in `Î±`. Let `g i : Î± â†’ Î²` be a\nfamily of measurable functions such that `g i` agrees with `g j` on `t i âˆ© t j`. Then there exists\na measurable function `f : Î± â†’ Î²` that agrees with each `g i` on `t i`.\n\nWe only need the assumption `[Nonempty Î¹]` to prove `[Nonempty (Î± â†’ Î²)]`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {m : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} {Î¹ : Type u_1} [inst : Countable Î¹]\n  [inst : Nonempty Î¹] (t : Î¹ â†’ Set Î±),\n  (âˆ€ (n : Î¹), MeasurableSet (t n)) â†’\n    âˆ€ (g : Î¹ â†’ Î± â†’ Î²),\n      (âˆ€ (n : Î¹), Measurable (g n)) â†’\n        (Pairwise fun i j => Set.EqOn (g i) (g j) (t i âˆ© t j)) â†’ âˆƒ f, Measurable f âˆ§ âˆ€ (n : Î¹), Set.EqOn f (g n) (t n) :=\n\n/-- If at least one `Ï€ i` is infinite and the rest nonempty, the pi type of all `Ï€` is infinite. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} (i : Î¹) [inst : Infinite (Ï€ i)] [inst : âˆ€ (i : Î¹), Nonempty (Ï€ i)],\n  Infinite ((i : Î¹) â†’ Ï€ i) :=\n\n/-- Show that if `Î  X_Î±` is regular, then so is `X_Î±`. Assume that each `X_Î±` is nonempty. -/\ntheorem",
    "choices": [
      "forall {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst : (i : Î¹) â†’ Nonempty (X i)] [inst_1 : (i : Î¹) â†’ T2Space (X i)] [inst_2 : (i : Î¹) â†’ RegularSpace (X i)],\n  RegularSpace ((i : Î¹) â†’ X i) ",
      "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst : (i : Î¹) â†’ Nonempty (X i)] [inst : (i : Î¹) â†’ RegularSpace (X i)],\n  RegularSpace ((i : Î¹) â†’ X i) ",
      "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst_1 : (i : Î¹) â†’ Nonempty (X i)]\n  [inst_2 : (i : Î¹) â†’ TopologicalSpace.RegularSpace (X i)],\n  TopologicalSpace.RegularSpace ((i : Î¹) â†’ X i) ",
      "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst_1 : âˆ€ (i : Î¹), Nonempty (X i)]\n  (h : âˆ€ (i : Î¹), TopologicalSpace.RegularSpace (X i)),\n  TopologicalSpace.RegularSpace ((i : Î¹) â†’ X i) ",
      "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : âˆ€ (i : Î¹), TopologicalSpace (X i)] [inst : âˆ€ (i : Î¹), Nonempty (X i)]\n  [inst_1 : âˆ€ (i : Î¹), T2Space (X i)] [inst_2 : TopologicalSpace.SecondCountableTopology (Î  i, X i)],\n  RegularSpace (Î  i, X i) â†’ âˆ€ (i : Î¹), RegularSpace (X i) ",
      "forall {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (Î± : Î¹) â†’ TopologicalSpace (X Î±)] [inst : âˆ€ (Î± : Î¹), Nonempty (X Î±)]\n  (h : âˆ€ Î± : Î¹, MeasureTheory.Measure.Regular (MeasureTheory.Measure.pi (Î» _, _inst_1 Î±))),\n  âˆ€ Î± : Î¹, MeasureTheory.Measure.Regular (MeasureTheory.Measure.pi (Î» _, _inst_1 Î±)) ",
      "âˆ€ {Î± : Type u_1} {X_Î± : Î± â†’ Type u_2} [inst : (a : Î±) â†’ TopologicalSpace (X_Î± a)] [inst_1 : (âˆ€ (a : Î±), Nonempty (X_Î± a))]\n  [inst_2 : RegularSpace ((a : Î±) â†’ X_Î± a)], (a : Î±) â†’ RegularSpace (X_Î± a) ",
      "âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : âˆ€ (i : Î¹), TopologicalSpace (X i)] [inst_1 : âˆ€ (i : Î¹), T2Space (X i)]\n  [inst_2 : Nonempty Î¹] [inst_3 : âˆ€ (i : Î¹), Nonempty (X i)] [inst_4 : RegularSpace ((i : Î¹) â†’ X i)],\n  âˆ€ (i : Î¹), RegularSpace (X i) ",
      "âˆ€ {Î± : Type u_1} {Î¹ : Type u_2} [inst : (Î± : Î¹) â†’ TopologicalSpace (Î± Î±)] [inst_1 : âˆ€ (Î± : Î¹), Nonempty (Î± Î±)]\n  [inst_2 : âˆ€ (Î± : Î¹), RegularSpace (Î± Î±)], RegularSpace ((Î± : Î¹) â†’ Î± Î±) ",
      "forall {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst : (i : Î¹) â†’ Nonempty (X i)] [inst_1 : RegularSpace ((i : Î¹) â†’ X i)],\n  forall (i : Î¹), RegularSpace (X i) "
    ]
  },
  {
    "docString": "Show that every locally compact Hausdorff space is regular.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, any measure constructed from a content is regular. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\\n  [inst_3 : BorelSpace X] (Î¼ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼],\\n  MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any locally finite measure on a `Ïƒ`-compact (e)metric space is regular. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], BaireSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second theorem states that locally compact spaces are Baire. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’ â‹ƒ (a : Î±), s a = Set.univ â†’ âˆƒ Î² t x x, LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every open cover of a paracompact space assumes a locally finite refinement. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\\n  TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\\nis also true for locally compact spaces. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure \"}]\n",
    "prompt_cons": "/-- In a locally compact space, any measure constructed from a content is regular. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure Î¼) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- Any locally finite measure on a `Ïƒ`-compact (e)metric space is regular. -/\ntheorem âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\n  [inst_3 : BorelSpace X] (Î¼ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼],\n  MeasureTheory.Measure.Regular Î¼ :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\n  Nonempty (TopologicalSpace.PositiveCompacts Î±) :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- The second theorem states that locally compact spaces are Baire. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], BaireSpace Î± :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- Every open cover of a paracompact space assumes a locally finite refinement. -/\ntheorem âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’ â‹ƒ (a : Î±), s a = Set.univ â†’ âˆƒ Î² t x x, LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a :=\n\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\nis also true for locally compact spaces. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±],\n  TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î± :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] (x : Î±),\n  âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (closure U) :=\n\n/-- Show that every locally compact Hausdorff space is regular. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ",
      "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± "
    ]
  },
  {
    "docString": "Let `X` be completely regular, let `A` and `B` be disjoint closed subsets of `X`. Show that if `A` is compact, there is a continuous function `f: X â†’ [0, 1]` such that `f(A) = {0}` and `f(B) = {1}`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f â‰¥ 1` on K. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\\nother. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\\nthen there exists a continuous function `f : X â†’ â„` such that\\n\\n* `f` equals zero on `s`;\\n* `f` equals one on `t`;\\n* `0 â‰¤ f x â‰¤ 1` for all `x`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] {K : Set X} [inst_5 : TopologicalSpace.MetrizableSpace X],\\n  IsCompact K â†’ ContinuousOn f K â†’ MeasureTheory.IntegrableOn f K\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f` continuous on a compact set `K` is integrable on this set with respect to any\\nlocally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"On an empty space, bounded continuous functions are at distance 0. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (s : Set Î±),\\n  Continuous fun F => ContinuousMap.restrict s F\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any subset `s` of `Î±`, the restriction of continuous functions to `s` is continuous as a\\nfunction from `C(Î±, Î²)` to `C(s, Î²)` with their respective compact-open topologies. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : CompactSpace Î²] [inst_4 : UniformSpace Î³] (f : Î± â†’ Î² â†’ Î³),\\n  Continuous â†¿f â†’ âˆ€ (x : Î±), TendstoUniformly f (f x) (nhds x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous family of functions `Î± â†’ Î² â†’ Î³` tends uniformly to its value at `x` if `Î±` is\\nlocally compact and `Î²` is compact. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\\n    Continuous â†‘g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : CompactSpace Î²] [inst_4 : UniformSpace Î³] {f : Î± â†’ Î² â†’ Î³} {x : Î±}\\n  {U : Set Î±}, U âˆˆ nhds x â†’ ContinuousOn (â†¿f) (U Ã—Ë¢ Set.univ) â†’ TendstoUniformly f (f x) (nhds x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family of functions `Î± â†’ Î² â†’ Î³` tends uniformly to its value at `x` if `Î±` is locally compact,\\n`Î²` is compact and `f` is continuous on `U Ã— (univ : Set Î²)` for some neighborhood `U` of `x`. \"}]\n",
    "prompt_cons": "/-- For any compact subset `K âŠ† X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f â‰¥ 1` on K. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (â†‘Î› '' {f | âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x}) :=\n\n/-- Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\nother. -/\ntheorem âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1 :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\nthen there exists a continuous function `f : X â†’ â„` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 â‰¤ f x â‰¤ 1` for all `x`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- A function `f` continuous on a compact set `K` is integrable on this set with respect to any\nlocally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] {K : Set X} [inst_5 : TopologicalSpace.MetrizableSpace X],\n  IsCompact K â†’ ContinuousOn f K â†’ MeasureTheory.IntegrableOn f K :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : OrderClosedTopology Î±]\n  [inst_2 : TopologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²},\n  IsClosed s â†’ ContinuousOn f s â†’ ContinuousOn g s â†’ IsClosed {x | x âˆˆ s âˆ§ f x â‰¤ g x} :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f) :=\n\n/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0 :=\n\n/-- For any subset `s` of `Î±`, the restriction of continuous functions to `s` is continuous as a\nfunction from `C(Î±, Î²)` to `C(s, Î²)` with their respective compact-open topologies. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (s : Set Î±),\n  Continuous fun F => ContinuousMap.restrict s F :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A continuous family of functions `Î± â†’ Î² â†’ Î³` tends uniformly to its value at `x` if `Î±` is\nlocally compact and `Î²` is compact. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : CompactSpace Î²] [inst_4 : UniformSpace Î³] (f : Î± â†’ Î² â†’ Î³),\n  Continuous â†¿f â†’ âˆ€ (x : Î±), TendstoUniformly f (f x) (nhds x) :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem âˆ€ {ğ•œ : Type u_3} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E â†’â‚—[ğ•œ] F),\n  (âˆ€ (u : â„• â†’ E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â†‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â†‘g x) â†’\n    Continuous â†‘g :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A family of functions `Î± â†’ Î² â†’ Î³` tends uniformly to its value at `x` if `Î±` is locally compact,\n`Î²` is compact and `f` is continuous on `U Ã— (univ : Set Î²)` for some neighborhood `U` of `x`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : LocallyCompactSpace Î±] [inst_3 : CompactSpace Î²] [inst_4 : UniformSpace Î³] {f : Î± â†’ Î² â†’ Î³} {x : Î±}\n  {U : Set Î±}, U âˆˆ nhds x â†’ ContinuousOn (â†¿f) (U Ã—Ë¢ Set.univ) â†’ TendstoUniformly f (f x) (nhds x) :=\n\n/-- Let `X` be completely regular, let `A` and `B` be disjoint closed subsets of `X`. Show that if `A` is compact, there is a continuous function `f: X â†’ [0, 1]` such that `f(A) = {0}` and `f(B) = {1}`. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegular X] {A B : Set X},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ IsCompact A â†’\n    âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] [inst_2 : T1Space X] {A B : Set X},\n  IsCompact A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] [inst_2 : LocallyCompactSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {A B : Set X},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ IsCompact A â†’\n    âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ (f : X â†’ â„),\n    Continuous f âˆ§ Set.EqOn f 0 A âˆ§ Set.EqOn f 1 B âˆ§ âˆ€ (x : X), f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’\n  âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X] [inst_2 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed B â†’ Disjoint A B â†’\n  âˆƒ f : X â†’ â„, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ Continuous f âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 "
    ]
  },
  {
    "docString": "Let `X` be completely regular. Show that `X` is connected if and only if the Stone-ÄŒech compactification of `X` is connected.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\\n  ConnectedSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is not a compact space, then `OnePoint X` is a connected space. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} (M : Type u_2) [inst : Monoid R] [inst_1 : MulAction R M] (a : RË£), IsSMulRegular M â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"Any element in `RË£` is `M`-regular. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V} [inst_2 : DecidableRel G.Adj]\\n  {n k â„“ Î¼ : â„•},\\n  SimpleGraph.IsSRGWith G n k â„“ Î¼ â†’ SimpleGraph.IsSRGWith Gá¶œ n (n - k - 1) (n - (2 * k - Î¼) - 2) (n - (2 * k - â„“))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a strongly regular graph is strongly regular. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\\n  [inst_3 : BorelSpace X] (Î¼ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼],\\n  MeasureTheory.Measure.Regular Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any locally finite measure on a `Ïƒ`-compact (e)metric space is regular. \"},\n {\"theorem\": \"âˆ€ {X Y : Compactum} (f : X âŸ¶ Y), Continuous f.f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of compacta is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (A : Subalgebra â„ C(X, â„)),\\n  Subalgebra.SeparatesPoints A â†’ Subalgebra.topologicalClosure A = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Stone-Weierstrass Approximation Theorem**,\\nthat a subalgebra `A` of `C(X, â„)`, where `X` is a compact topological space,\\nis dense if it separates points.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\\n  [inst_3 : IsScalarTower R S M], IsSMulRegular M a â†’ IsSMulRegular M s â†’ IsSMulRegular M (a â€¢ s)\",\n  \"isProp\": true,\n  \"docString\": \"The product of `M`-regular elements is `M`-regular. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\": \"âˆ€ (Î¹ : Type u_1) [inst : Fintype Î¹], IsCompact (stdSimplex â„ Î¹)\",\n  \"isProp\": true,\n  \"docString\": \"`stdSimplex â„ Î¹` is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of a homeomorphism is a locally connected space, then the domain is also\\na locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is path connected. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"}]\n",
    "prompt_cons": "/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- If `X` is not a compact space, then `OnePoint X` is a connected space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\n  ConnectedSpace (OnePoint X) :=\n\n/-- Any element in `RË£` is `M`-regular. -/\ntheorem âˆ€ {R : Type u_1} (M : Type u_2) [inst : Monoid R] [inst_1 : MulAction R M] (a : RË£), IsSMulRegular M â†‘a :=\n\n/-- A nonempty convex set is connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there\nis some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => âˆƒ U, IsClopen U âˆ§ x âˆˆ U âˆ§ Â¬y âˆˆ U) â†’ IsTotallyDisconnected Set.univ :=\n\n/-- The complement of a strongly regular graph is strongly regular. -/\ntheorem âˆ€ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V} [inst_2 : DecidableRel G.Adj]\n  {n k â„“ Î¼ : â„•},\n  SimpleGraph.IsSRGWith G n k â„“ Î¼ â†’ SimpleGraph.IsSRGWith Gá¶œ n (n - k - 1) (n - (2 * k - Î¼) - 2) (n - (2 * k - â„“)) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- Any locally finite measure on a `Ïƒ`-compact (e)metric space is regular. -/\ntheorem âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\n  [inst_3 : BorelSpace X] (Î¼ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼],\n  MeasureTheory.Measure.Regular Î¼ :=\n\n/-- Any morphism of compacta is continuous. -/\ntheorem âˆ€ {X Y : Compactum} (f : X âŸ¶ Y), Continuous f.f :=\n\n/-- The **Stone-Weierstrass Approximation Theorem**,\nthat a subalgebra `A` of `C(X, â„)`, where `X` is a compact topological space,\nis dense if it separates points. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (A : Subalgebra â„ C(X, â„)),\n  Subalgebra.SeparatesPoints A â†’ Subalgebra.topologicalClosure A = âŠ¤ :=\n\n/-- The product of `M`-regular elements is `M`-regular. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\n  [inst_3 : IsScalarTower R S M], IsSMulRegular M a â†’ IsSMulRegular M s â†’ IsSMulRegular M (a â€¢ s) :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- `stdSimplex â„ Î¹` is compact. -/\ntheorem âˆ€ (Î¹ : Type u_1) [inst : Fintype Î¹], IsCompact (stdSimplex â„ Î¹) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- If the codomain of a homeomorphism is a locally connected space, then the domain is also\na locally connected space. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [i : LocallyConnectedSpace Î²],\n  Î± â‰ƒâ‚œ Î² â†’ LocallyConnectedSpace Î± :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- A nonempty convex set is path connected. -/\ntheorem âˆ€ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  Convex â„ s â†’ Set.Nonempty s â†’ IsPathConnected s :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- Let `X` be completely regular. Show that `X` is connected if and only if the Stone-ÄŒech compactification of `X` is connected. -/\ntheorem",
    "choices": [
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : PreconnectedSpace X],\n  PreconnectedSpace (StoneCechCompactification X) â†’ PreconnectedSpace X ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : TotallyDisconnectedSpace X] [inst_3 : RegularSpace X],\n  ConnectedSpace (StoneCechCompactification X) â†” ConnectedSpace X ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) ",
      "âˆ€ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (Ultrafilter.Lim X) ",
      "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X],\n  ConnectedSpace X â†” ConnectedSpace (StoneCech X) "
    ]
  },
  {
    "docString": "Prove that `-(-v) = v` for every `v âˆˆ V`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (v : E), â†‘(reflection (Submodule.span ğ•œ {v})á—®) v = -v\",\n  \"isProp\": true,\n  \"docString\": \"The reflection in `(ğ•œ âˆ™ v)á—®` of `v` is `-v`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\\n  I â‰  0 â†’\\n    Associates.count (Associates.mk v.asIdeal)\\n        (Associates.factors\\n          (Associates.mk\\n            (âˆá¶  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I))) =\\n      Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `v` in `âˆ_v v^(val_v(I))` equals `val_v(I)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\\n  Matrix.IsSymm (Matrix.circulant v) â†’ âˆ€ (i : n), v (-i) = v i\",\n  \"isProp\": true,\n  \"docString\": \"If `circulant v` is symmetric, `âˆ€ i j : I, v (- i) = v i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\\n  Matrix.IsSymm (Matrix.circulant v) â†” âˆ€ (i : n), v (-i) = v i\",\n  \"isProp\": true,\n  \"docString\": \"A circulant of `v` is symmetric iff `v` equals its reverse. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} (self : UniformSpace.Core Î±), (Filter.lift' self.uniformity fun s => compRel s s) â‰¤ self.uniformity\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every set `u âˆˆ uniformity`, there exists `v âˆˆ uniformity` such that `v â—‹ v âŠ† u`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R),\\n  âˆƒ Ï€, IsDedekindDomain.HeightOneSpectrum.intValuationDef v Ï€ = â†‘(â†‘Multiplicative.ofAdd (-1))\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists `Ï€ âˆˆ R` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] (K : Type u_1)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R),\\n  âˆƒ Ï€, â†‘(IsDedekindDomain.HeightOneSpectrum.valuation v) Ï€ = â†‘(â†‘Multiplicative.ofAdd (-1))\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists `Ï€ âˆˆ K` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {Î± : Type u_1} {v w : Vector Î± n}, (âˆ€ (m : Fin n), Vector.get v m = Vector.get w m) â†’ v = w\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two `v w : Vector Î± n` are equal iff they are equal at every single index. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Î“â‚€]\\n  [inst_2 : Nontrivial Î“â‚€] (v : AddValuation K Î“â‚€) {x : K}, â†‘v x = âŠ¤ â†” x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is an additive valuation on a division ring then `v(x) = âŠ¤` iff `x = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"The `v`-adic valuation of `0 : R` equals 0. \"},\n {\"theorem\":\n  \"âˆ€ {v : Sat.Valuation} {a : Prop} {n : â„•}, (v n â†” a) â†’ Sat.Literal.reify v (Sat.Literal.pos n) Â¬a\",\n  \"isProp\": true,\n  \"docString\": \"The reification of a positive literal `Â¬âŸ¦aâŸ§_v â‰¡ Â¬a`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The `v`-adic valuation of `1 : R` equals 1. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Î“â‚€]\\n  [inst_2 : Nontrivial Î“â‚€] (v : Valuation K Î“â‚€) {x : K}, â†‘v x = 0 â†” x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} [inst : NormedField ğ•œ] {l : Filter Î±} {u v : Î± â†’ ğ•œ}, u =O[l] v â†’ u / v * v =á¶ [l] u\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `u = O(v)` along `l`, then `(u / v) * v = u` eventually at `l`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] {S : AddSubgroup M} (x : M â§¸ S), â€–-xâ€– = â€–xâ€–\",\n  \"isProp\": true,\n  \"docString\": \"The norm on the quotient satisfies `â€–-xâ€– = â€–xâ€–`. \"},\n {\"theorem\":\n  \"âˆ€ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R},\\n  Matrix.Nondegenerate M â†’ âˆ€ {v : m â†’ R}, (âˆ€ (w : m â†’ R), Matrix.dotProduct v (Matrix.mulVec M w) = 0) â†’ v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `M` is nondegenerate and `w â¬ M â¬ v = 0` for all `w`, then `v = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} [inst : NormedField ğ•œ] {l : Filter Î±} {u v : Î± â†’ ğ•œ}, u =o[l] v â†’ u / v * v =á¶ [l] u\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `u = o(v)` along `l`, then `(u / v) * v = u` eventually at `l`. \"},\n {\"theorem\":\n  \"âˆ€ {v : Sat.Valuation} {l : Sat.Literal} {a : Prop},\\n  Sat.Literal.reify v l a â†’ Sat.Clause.reify v (Sat.Clause.cons l Sat.Clause.nil) a\",\n  \"isProp\": true,\n  \"docString\": \"The reification of a singleton clause `Â¬âŸ¦lâŸ§_v â‰¡ Â¬âŸ¦lâŸ§_v`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x y : R),\\n  IsDedekindDomain.HeightOneSpectrum.intValuationDef v (x * y) =\\n    IsDedekindDomain.HeightOneSpectrum.intValuationDef v x * IsDedekindDomain.HeightOneSpectrum.intValuationDef v y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `v`-adic valuation of a product equals the product of the valuations. \"}]\n",
    "prompt_cons": "/-- The reflection in `(ğ•œ âˆ™ v)á—®` of `v` is `-v`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), â†‘(reflection (Submodule.span ğ•œ {v})á—®) v = -v :=\n\n/-- The multiplicity of `v` in `âˆ_v v^(val_v(I))` equals `val_v(I)`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\n  I â‰  0 â†’\n    Associates.count (Associates.mk v.asIdeal)\n        (Associates.factors\n          (Associates.mk\n            (âˆá¶  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I))) =\n      Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I)) :=\n\n/-- If `circulant v` is symmetric, `âˆ€ i j : I, v (- i) = v i`. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\n  Matrix.IsSymm (Matrix.circulant v) â†’ âˆ€ (i : n), v (-i) = v i :=\n\n/-- A circulant of `v` is symmetric iff `v` equals its reverse. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n â†’ Î±},\n  Matrix.IsSymm (Matrix.circulant v) â†” âˆ€ (i : n), v (-i) = v i :=\n\n/-- For every set `u âˆˆ uniformity`, there exists `v âˆˆ uniformity` such that `v â—‹ v âŠ† u`. -/\ntheorem âˆ€ {Î± : Type u} (self : UniformSpace.Core Î±), (Filter.lift' self.uniformity fun s => compRel s s) â‰¤ self.uniformity :=\n\n/-- There exists `Ï€ âˆˆ R` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R),\n  âˆƒ Ï€, IsDedekindDomain.HeightOneSpectrum.intValuationDef v Ï€ = â†‘(â†‘Multiplicative.ofAdd (-1)) :=\n\n/-- There exists `Ï€ âˆˆ K` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] (K : Type u_1)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R),\n  âˆƒ Ï€, â†‘(IsDedekindDomain.HeightOneSpectrum.valuation v) Ï€ = â†‘(â†‘Multiplicative.ofAdd (-1)) :=\n\n/-- Two `v w : Vector Î± n` are equal iff they are equal at every single index. -/\ntheorem âˆ€ {n : â„•} {Î± : Type u_1} {v w : Vector Î± n}, (âˆ€ (m : Fin n), Vector.get v m = Vector.get w m) â†’ v = w :=\n\n/-- If `v` is an additive valuation on a division ring then `v(x) = âŠ¤` iff `x = 0`. -/\ntheorem âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Î“â‚€]\n  [inst_2 : Nontrivial Î“â‚€] (v : AddValuation K Î“â‚€) {x : K}, â†‘v x = âŠ¤ â†” x = 0 :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- The `v`-adic valuation of `0 : R` equals 0. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0 :=\n\n/-- The reification of a positive literal `Â¬âŸ¦aâŸ§_v â‰¡ Â¬a`. -/\ntheorem âˆ€ {v : Sat.Valuation} {a : Prop} {n : â„•}, (v n â†” a) â†’ Sat.Literal.reify v (Sat.Literal.pos n) Â¬a :=\n\n/-- The `v`-adic valuation of `1 : R` equals 1. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 1 = 1 :=\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Î“â‚€]\n  [inst_2 : Nontrivial Î“â‚€] (v : Valuation K Î“â‚€) {x : K}, â†‘v x = 0 â†” x = 0 :=\n\n/-- If `u = O(v)` along `l`, then `(u / v) * v = u` eventually at `l`. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} [inst : NormedField ğ•œ] {l : Filter Î±} {u v : Î± â†’ ğ•œ}, u =O[l] v â†’ u / v * v =á¶ [l] u :=\n\n/-- The norm on the quotient satisfies `â€–-xâ€– = â€–xâ€–`. -/\ntheorem âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] {S : AddSubgroup M} (x : M â§¸ S), â€–-xâ€– = â€–xâ€– :=\n\n/-- If `M` is nondegenerate and `w â¬ M â¬ v = 0` for all `w`, then `v = 0`. -/\ntheorem âˆ€ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R},\n  Matrix.Nondegenerate M â†’ âˆ€ {v : m â†’ R}, (âˆ€ (w : m â†’ R), Matrix.dotProduct v (Matrix.mulVec M w) = 0) â†’ v = 0 :=\n\n/-- If `u = o(v)` along `l`, then `(u / v) * v = u` eventually at `l`. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} [inst : NormedField ğ•œ] {l : Filter Î±} {u v : Î± â†’ ğ•œ}, u =o[l] v â†’ u / v * v =á¶ [l] u :=\n\n/-- The reification of a singleton clause `Â¬âŸ¦lâŸ§_v â‰¡ Â¬âŸ¦lâŸ§_v`. -/\ntheorem âˆ€ {v : Sat.Valuation} {l : Sat.Literal} {a : Prop},\n  Sat.Literal.reify v l a â†’ Sat.Clause.reify v (Sat.Clause.cons l Sat.Clause.nil) a :=\n\n/-- The `v`-adic valuation of a product equals the product of the valuations. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x y : R),\n  IsDedekindDomain.HeightOneSpectrum.intValuationDef v (x * y) =\n    IsDedekindDomain.HeightOneSpectrum.intValuationDef v x * IsDedekindDomain.HeightOneSpectrum.intValuationDef v y :=\n\n/-- Prove that `-(-v) = v` for every `v âˆˆ V`. -/\ntheorem",
    "choices": [
      "âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
      "âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
      "âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
      "âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
      "âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] (v : Î±), -(-v) = v ",
      "forall {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
      "âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
      "âˆ€ {V : Type u_2} [inst : AddGroup V] (v : V), -(-v) = v ",
      "âˆ€ {Î± : Type u} {V : Type v} [inst : AddGroup V] [inst_1 : Module Î± V] (v : V), -(-v) = v ",
      "âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v "
    ]
  },
  {
    "docString": "Give an example of a nonempty subset `U` of `â„^2` such that `U` is closed under addition and under taking additive inverses (meaning `-u âˆˆ U` whenever `u âˆˆ U`), but `U` is not a subspace of `â„^2`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under addition. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under subtraction \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\\n  x â‰  y â†’\\n    âˆƒ Uâ‚,\\n      Uâ‚ âˆˆ nhds x âˆ§\\n        âˆƒ Vâ‚,\\n          Vâ‚ âˆˆ nhds x âˆ§\\n            âˆƒ Uâ‚‚,\\n              Uâ‚‚ âˆˆ nhds y âˆ§\\n                âˆƒ Vâ‚‚,\\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ V + K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `V + K âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\\nsuch that `VV âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x : R}, x âˆˆ s â†’ -x âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under negation. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], Filter.HasBasis (nhds 0) (fun Î³ => Î³ â‰  0) Set.Iio\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a linearly ordered group with zero element adjoined, `U` is a neighbourhood of `0` if and\\nonly if there exists a nonzero element `Î³â‚€` such that `Iio Î³â‚€ âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subsemiring is closed under addition. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `K * V âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {u : Set P}, IsOpen u â†’ Set.Nonempty u â†’ affineSpan â„ u = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty open set is `âŠ¤`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `V * K âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocSemiring R] {s : Set R}, s âŠ† â†‘(NonUnitalSubsemiring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The non-unital subsemiring generated by a set includes the set. \"}]\n",
    "prompt_cons": "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- A non-unital subring is closed under addition. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s :=\n\n/-- A non-unital subring is closed under subtraction -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s :=\n\n/-- Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\n  x â‰  y â†’\n    âˆƒ Uâ‚,\n      Uâ‚ âˆˆ nhds x âˆ§\n        âˆƒ Vâ‚,\n          Vâ‚ âˆˆ nhds x âˆ§\n            âˆƒ Uâ‚‚,\n              Uâ‚‚ âˆˆ nhds y âˆ§\n                âˆƒ Vâ‚‚,\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚ :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `V + K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ V + K âŠ† U :=\n\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- A non-unital subring is closed under negation. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x : R}, x âˆˆ s â†’ -x âˆˆ s :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s U : Set Î±},\n  U âˆˆ â¨† (x : Î±) (_ : x âˆˆ s), nhds x â†’ âˆƒ V, s âŠ† V âˆ§ IsOpen V âˆ§ V âŠ† U :=\n\n/-- A non-unital subring is closed under multiplication. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s :=\n\n/-- In a linearly ordered group with zero element adjoined, `U` is a neighbourhood of `0` if and\nonly if there exists a nonzero element `Î³â‚€` such that `Iio Î³â‚€ âŠ† U`. -/\ntheorem âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], Filter.HasBasis (nhds 0) (fun Î³ => Î³ â‰  0) Set.Iio :=\n\n/-- A subsemiring is closed under addition. -/\ntheorem âˆ€ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `K * V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U :=\n\n/-- The affine span of a nonempty open set is `âŠ¤`. -/\ntheorem âˆ€ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {u : Set P}, IsOpen u â†’ Set.Nonempty u â†’ affineSpan â„ u = âŠ¤ :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `V * K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- The non-unital subsemiring generated by a set includes the set. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocSemiring R] {s : Set R}, s âŠ† â†‘(NonUnitalSubsemiring.closure s) :=\n\n/-- Give an example of a nonempty subset `U` of `â„^2` such that `U` is closed under addition and under taking additive inverses (meaning `-u âˆˆ U` whenever `u âˆˆ U`), but `U` is not a subspace of `â„^2`. -/\ntheorem",
    "choices": [
      "example : âˆƒ (U : Set (â„ Ã— â„)), (âˆ€ {x y : â„ Ã— â„}, x âˆˆ U â†’ y âˆˆ U â†’ x + y âˆˆ U) âˆ§ (âˆ€ {x : â„ Ã— â„}, x âˆˆ U â†’ -x âˆˆ U) âˆ§ Â¬(vector_space.subset_span U) ",
      "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\nlemma sum_subset_open_nhds_zero {M : Type u_1} [TopologicalSpace M] [AddMonoid M] [ContinuousAdd M] {U : Set M}\n  (hU : U âˆˆ nhds 0) : âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U ",
      "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem sub_additive_compact {M : Type u_1} [TopologicalSpace M] [AddMonoid M] [ContinuousAdd M] {U : Set M}\n  (hU : U âˆˆ nhds 0) : âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U ",
      "example : âˆƒ (U : Set (â„ Ã— â„)), (âˆ€ (u v : â„ Ã— â„), u âˆˆ U â†’ v âˆˆ U â†’ u + v âˆˆ U) âˆ§ (âˆ€ (u : â„ Ã— â„), u âˆˆ U â†’ -u âˆˆ U) âˆ§ Â¬(âˆ€ (a : â„) (u : â„ Ã— â„), u âˆˆ U â†’ (a * u.1, a * u.2) âˆˆ U) ",
      "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem open_neighborhood_add_open_neighborhood {M : Type u_1} [TopologicalSpace M] [AddMonoid M] [ContinuousAdd M] {U : Set M} (h : U âˆˆ nhds 0) :\n  âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U ",
      "example : âˆƒ U : Set (â„ Ã— â„), (âˆ€ u v âˆˆ U, u + v âˆˆ U) âˆ§ (âˆ€ u âˆˆ U, -u âˆˆ U) âˆ§ Â¬(âˆ€ u v : â„ Ã— â„, (âˆ€ a b, a â€¢ u + b â€¢ v âˆˆ U) â†’ u âˆˆ U) ",
      "example : âˆƒ (U : Set (â„ Ã— â„)), (âˆ€ u v âˆˆ U, u + v âˆˆ U) âˆ§ (âˆ€ u âˆˆ U, -u âˆˆ U) âˆ§ Â¬(âˆ€ u v âˆˆ U, u - v âˆˆ U) ",
      "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem open_add_set {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M}\n  (hU : U âˆˆ nhds 0) : âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U ",
      "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem open_neigh_of_zero {M : Type u_1} [TopologicalSpace M] [AddMonoid M] [ContinuousAdd M] {U : Set M}\n  (hU : U âˆˆ nhds 0) : âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U ",
      "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem open_neigh_zero_sum {M : Type u_1} [TopologicalSpace M] [AddMonoid M] [ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U "
    ]
  },
  {
    "docString": "Prove that the intersection of any collection of subspaces of `V` is a subspace of `V`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\\n  (s : Î¹ â†’ Set (â„™ K V)),\\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `Tâ‚…` space is a `Tâ‚…` space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\\n  IsCompact s â†’\\n    âˆ€ (Z : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  (Q : AffineSubspace ğ•œ E), Convex ğ•œ â†‘Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 â‰¤ s2 â†” â†‘s1 âŠ† â†‘s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `â‰¤` order on subspaces is the same as that on the corresponding sets. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k â†‘s = s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Coercing a subspace to a set then taking the affine span produces the original subspace. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), â†‘s1 âŠ“ â†‘s2 = â†‘s1 âˆ© â†‘s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of two affine subspaces, coerced to a set, is the intersection of the two sets of\\npoints. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M] {sâ‚ sâ‚‚ : Set M}, IsSubmonoid sâ‚ â†’ IsSubmonoid sâ‚‚ â†’ IsSubmonoid (sâ‚ âˆ© sâ‚‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two submonoids of a monoid `M` is a submonoid of `M`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (s : Set (Submodule ğ•œ E)), â¨… (K : Submodule ğ•œ E) (_ : K âˆˆ s), Ká—® = (sSup s)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : SigmaCompactSpace Î±],\\n  âˆƒ K, (âˆ€ (n : â„•), IsCompact (K n)) âˆ§ â‹ƒ (n : â„•), K n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Ïƒ-compact space, there exists (by definition) a countable collection of compact subspaces\\nthat cover the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {sâ‚ sâ‚‚ : AffineSubspace k P} {p : P},\\n  p âˆˆ sâ‚ â†’ p âˆˆ sâ‚‚ â†’ (sâ‚ = sâ‚‚ â†” AffineSubspace.direction sâ‚ = AffineSubspace.direction sâ‚‚)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with nonempty intersection are equal if and only if their directions are\\nequal. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} [inst : Monoid M] {Î¹ : Sort u_1} {s : Î¹ â†’ Set M},\\n  (âˆ€ (y : Î¹), IsSubmonoid (s y)) â†’ IsSubmonoid (Set.iInter s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of an indexed set of submonoids of a monoid `M` is a submonoid of `M`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\\n  {W : Projectivization.Subspace K V},\\n  S âŠ† â†‘W â†’ W â‰¤ Projectivization.Subspace.span S â†’ Projectivization.Subspace.span S = W\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of points in projective space is contained in a subspace, and that subspace is\\ncontained in the span of the set of points, then the span of the set of points is equal to\\nthe subspace. \"}]\n",
    "prompt_cons": "/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace.span (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), Projectivization.Subspace.span (s i) :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 â†’ Set.Nonempty (â†‘s1 âˆ© â†‘s2) â†’ s1 = s2 :=\n\n/-- A subspace of a `Tâ‚…` space is a `Tâ‚…` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x } :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {Î¹ : Type v},\n  IsCompact s â†’\n    âˆ€ (Z : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), IsClosed (Z i)) â†’\n        (âˆ€ (t : Finset Î¹), Set.Nonempty (s âˆ© â‹‚ (i : Î¹) (_ : i âˆˆ t), Z i)) â†’ Set.Nonempty (s âˆ© â‹‚ (i : Î¹), Z i) :=\n\n/-- Affine subspaces are convex. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedRing ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  (Q : AffineSubspace ğ•œ E), Convex ğ•œ â†‘Q :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span â†‘W = W :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S â‰¤ W â†” S âŠ† â†‘W :=\n\n/-- The `â‰¤` order on subspaces is the same as that on the corresponding sets. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 â‰¤ s2 â†” â†‘s1 âŠ† â†‘s2 :=\n\n/-- Coercing a subspace to a set then taking the affine span produces the original subspace. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k â†‘s = s :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- The inf of two affine subspaces, coerced to a set, is the intersection of the two sets of\npoints. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), â†‘s1 âŠ“ â†‘s2 = â†‘s1 âˆ© â†‘s2 :=\n\n/-- The intersection of two submonoids of a monoid `M` is a submonoid of `M`. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {sâ‚ sâ‚‚ : Set M}, IsSubmonoid sâ‚ â†’ IsSubmonoid sâ‚‚ â†’ IsSubmonoid (sâ‚ âˆ© sâ‚‚) :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (s : Set (Submodule ğ•œ E)), â¨… (K : Submodule ğ•œ E) (_ : K âˆˆ s), Ká—® = (sSup s)á—® :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- In a Ïƒ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : SigmaCompactSpace Î±],\n  âˆƒ K, (âˆ€ (n : â„•), IsCompact (K n)) âˆ§ â‹ƒ (n : â„•), K n = Set.univ :=\n\n/-- Two affine subspaces with nonempty intersection are equal if and only if their directions are\nequal. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {sâ‚ sâ‚‚ : AffineSubspace k P} {p : P},\n  p âˆˆ sâ‚ â†’ p âˆˆ sâ‚‚ â†’ (sâ‚ = sâ‚‚ â†” AffineSubspace.direction sâ‚ = AffineSubspace.direction sâ‚‚) :=\n\n/-- The intersection of an indexed set of submonoids of a monoid `M` is a submonoid of `M`. -/\ntheorem âˆ€ {M : Type u_2} [inst : Monoid M] {Î¹ : Sort u_1} {s : Î¹ â†’ Set M},\n  (âˆ€ (y : Î¹), IsSubmonoid (s y)) â†’ IsSubmonoid (Set.iInter s) :=\n\n/-- If a set of points in projective space is contained in a subspace, and that subspace is\ncontained in the span of the set of points, then the span of the set of points is equal to\nthe subspace. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (â„™ K V)}\n  {W : Projectivization.Subspace K V},\n  S âŠ† â†‘W â†’ W â‰¤ Projectivization.Subspace.span S â†’ Projectivization.Subspace.span S = W :=\n\n/-- Prove that the intersection of any collection of subspaces of `V` is a subspace of `V`. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (s : Î¹ â†’ Projectivization.Subspace K V),\n  IsSubspace (Set.Interâ‚“ fun i => â†‘(s i)) ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  {s : Î¹ â†’ Submodule K V}, Submodule K V (â‹‚ (i : Î¹), s i) ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (s : Î¹ â†’ Submodule K V),\n  IsSubspace K (â‹‚ (i : Î¹), s i) ",
      "âˆ€ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Set (â„™ K V)),\n  Projectivization.Subspace (â‹‚ (i : Î¹), s i) = â¨… (i : Î¹), Projectivization.Subspace (s i) ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_3}\n  (s : Î¹ â†’ Projectivization.Subspace K V),\n  Projectivization.Subspace (K ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (s : Set (â„™ K V)),\n  IsSubspace (â‹‚â‚€ s) ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_3}\n  (s : Î¹ â†’ Projectivization.Subspace K V), IsSubspace (â‹‚ (i : Î¹), â†‘(s i)) ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type u_1}\n  (X : Î¹ â†’ Submodule K V),\n  IsSubmodule (â‹‚ (i : Î¹), X i) ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Submodule K V), IsSubmodule (â‹‚ (i : Î¹), s i) ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Submodule K V), Submodule K V "
    ]
  },
  {
    "docString": "Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if `dim V = 1` and `T âˆˆ L(V, V)`, then there exists `a âˆˆ F` such that `T v = a v` for all `v âˆˆ V`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} {Mâ‚‚ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid Mâ‚‚]\\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚] {f : M â†’ Mâ‚‚}, IsLinearMap R f â†’ âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x\",\n  \"isProp\": true,\n  \"docString\": \"A linear map preserves scalar multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace ğ•œ V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\\n    fun p => p.fst â€¢ p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f * g = 1 â†’ g * f = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional space, if linear maps are inverse to each other on one side then they\\nare also inverse to each other on the other side. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\\n  1 â€¢ x = x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication by one is the identity. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f * g = 1 â†” g * f = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\\nthey are inverse to each other on the other side. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ğ•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ğ•œ F]\\n  [inst_10 : FiniteDimensional ğ•œ E] [inst_11 : FiniteDimensional ğ•œ F], FiniteDimensional ğ•œ (E â†’L[ğ•œ] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} [inst : AddCommGroup M] {ğ•œ : Type u_1} [inst_1 : Field ğ•œ] [inst_2 : Module ğ•œ M] (f : M â†’â‚—[ğ•œ] M),\\n  â†‘LinearMap.det f â‰  1 â†’ FiniteDimensional ğ•œ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a linear map has determinant different from `1`, then the space is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Mâ‚‚ : Type u_2} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid Mâ‚‚] {R : Type u_3} {S : Type u_4}\\n  [inst_2 : Semiring S] [inst_3 : SMul R M] [inst_4 : Module S M] [inst_5 : SMul R Mâ‚‚] [inst_6 : Module S Mâ‚‚]\\n  [self : LinearMap.CompatibleSMul M Mâ‚‚ R S] (fâ‚— : M â†’â‚—[S] Mâ‚‚) (c : R) (x : M), â†‘fâ‚— (c â€¢ x) = c â€¢ â†‘fâ‚— x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Scalar multiplication by `R` of `M` can be moved through linear maps. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A vector space has dimension at most `1` if and only if there is a\\nsingle vector of which all vectors are multiples. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x : F) (r : â„),\\n  inner x (r â€¢ x) = r * (â€–xâ€– * â€–xâ€–)\",\n  \"isProp\": true,\n  \"docString\": \"The inner product of a vector with a multiple of itself. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Fâ‚— : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fâ‚—]\\n  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedSpace ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—),\\n  â€–ContinuousLinearMap.smulRight c fâ€– = â€–câ€– * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the tensor product of a scalar linear map and of an element of a normed space\\nis the product of the norms. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†” Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, a linear map is injective if and only if it is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : ContinuousSMul â„ E] {F : Type u_3} [inst_4 : AddCommGroup F] [inst_5 : Module â„ F]\\n  [inst_6 : TopologicalSpace F] [inst_7 : ContinuousSMul â„ F] [inst_8 : T2Space F] {G : Type u_1}\\n  [inst_9 : AddMonoidHomClass G E F] (f : G), Continuous â†‘f â†’ âˆ€ (c : â„) (x : E), â†‘f (c â€¢ x) = c â€¢ â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous additive map between two vector spaces over `â„` is `â„`-linear. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} {Mâ‚ƒ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid Mâ‚ƒ]\\n  [inst_3 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ}, â†‘f 1 = â†‘g 1 â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two `Ïƒ`-linear maps from `R` are equal on `1`, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type v} {Mâ‚‚ : Type w} [inst : Semiring R]\\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (Mâ‚ i)] [inst_2 : AddCommMonoid Mâ‚‚] [inst_3 : (i : Î¹) â†’ Module R (Mâ‚ i)]\\n  [inst_4 : Module R Mâ‚‚] (self : MultilinearMap R Mâ‚ Mâ‚‚) [inst_5 : DecidableEq Î¹] (m : (i : Î¹) â†’ Mâ‚ i) (i : Î¹) (c : R)\\n  (x : Mâ‚ i),\\n  MultilinearMap.toFun self (Function.update m i (c â€¢ x)) = c â€¢ MultilinearMap.toFun self (Function.update m i x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A multilinear map is compatible with scalar multiplication in every argument. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_5} {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  (b : Basis Î¹ R M) {Râ‚ : Type u_2} [inst_3 : Semiring Râ‚] {Ïƒ : R â†’+* Râ‚} {Mâ‚ : Type u_4} [inst_4 : AddCommMonoid Mâ‚]\\n  [inst_5 : Module Râ‚ Mâ‚] {fâ‚ fâ‚‚ : M â†’â‚›â‚—[Ïƒ] Mâ‚}, (âˆ€ (i : Î¹), â†‘fâ‚ (â†‘b i) = â†‘fâ‚‚ (â†‘b i)) â†’ fâ‚ = fâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linear maps are equal if they are equal on basis vectors. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} {F : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : SeminormedAddCommGroup F]\\n  [inst_2 : NormedSpace â„ E] [inst_3 : NormedSpace â„ F] {f : E â†’L[â„] F} {C : NNReal},\\n  (âˆ€ (x : E), â€–xâ€–â‚Š = 1 â†’ â€–â†‘f xâ€–â‚Š â‰¤ C) â†’ â€–fâ€–â‚Š â‰¤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a continuous real linear map `f`, if one controls the norm of every `f x`, `â€–xâ€–â‚Š = 1`, then\\none controls the norm of `f`. \"}]\n",
    "prompt_cons": "/-- A linear map preserves scalar multiplication. -/\ntheorem âˆ€ {R : Type u} {M : Type v} {Mâ‚‚ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid Mâ‚‚]\n  [inst_3 : Module R M] [inst_4 : Module R Mâ‚‚] {f : M â†’ Mâ‚‚}, IsLinearMap R f â†’ âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x :=\n\n/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace ğ•œ V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\n    fun p => p.fst â€¢ p.snd :=\n\n/-- In a finite-dimensional space, if linear maps are inverse to each other on one side then they\nare also inverse to each other on the other side. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f * g = 1 â†’ g * f = 1 :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- Scalar multiplication by one is the identity. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\n  1 â€¢ x = x :=\n\n/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f * g = 1 â†” g * f = 1 :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ğ•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ğ•œ F]\n  [inst_10 : FiniteDimensional ğ•œ E] [inst_11 : FiniteDimensional ğ•œ F], FiniteDimensional ğ•œ (E â†’L[ğ•œ] F) :=\n\n/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem âˆ€ {M : Type u_2} [inst : AddCommGroup M] {ğ•œ : Type u_1} [inst_1 : Field ğ•œ] [inst_2 : Module ğ•œ M] (f : M â†’â‚—[ğ•œ] M),\n  â†‘LinearMap.det f â‰  1 â†’ FiniteDimensional ğ•œ M :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- Scalar multiplication by `R` of `M` can be moved through linear maps. -/\ntheorem âˆ€ {M : Type u_1} {Mâ‚‚ : Type u_2} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid Mâ‚‚] {R : Type u_3} {S : Type u_4}\n  [inst_2 : Semiring S] [inst_3 : SMul R M] [inst_4 : Module S M] [inst_5 : SMul R Mâ‚‚] [inst_6 : Module S Mâ‚‚]\n  [self : LinearMap.CompatibleSMul M Mâ‚‚ R S] (fâ‚— : M â†’â‚—[S] Mâ‚‚) (c : R) (x : M), â†‘fâ‚— (c â€¢ x) = c â€¢ â†‘fâ‚— x :=\n\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v :=\n\n/-- The inner product of a vector with a multiple of itself. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x : F) (r : â„),\n  inner x (r â€¢ x) = r * (â€–xâ€– * â€–xâ€–) :=\n\n/-- The norm of the tensor product of a scalar linear map and of an element of a normed space\nis the product of the norms. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Fâ‚— : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fâ‚—]\n  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedSpace ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—),\n  â€–ContinuousLinearMap.smulRight c fâ€– = â€–câ€– * â€–fâ€– :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v :=\n\n/-- On a finite-dimensional space, a linear map is injective if and only if it is surjective. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†” Function.Surjective â†‘f :=\n\n/-- A continuous additive map between two vector spaces over `â„` is `â„`-linear. -/\ntheorem âˆ€ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : ContinuousSMul â„ E] {F : Type u_3} [inst_4 : AddCommGroup F] [inst_5 : Module â„ F]\n  [inst_6 : TopologicalSpace F] [inst_7 : ContinuousSMul â„ F] [inst_8 : T2Space F] {G : Type u_1}\n  [inst_9 : AddMonoidHomClass G E F] (f : G), Continuous â†‘f â†’ âˆ€ (c : â„) (x : E), â†‘f (c â€¢ x) = c â€¢ â†‘f x :=\n\n/-- If two `Ïƒ`-linear maps from `R` are equal on `1`, then they are equal. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} {Mâ‚ƒ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid Mâ‚ƒ]\n  [inst_3 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ}, â†‘f 1 = â†‘g 1 â†’ f = g :=\n\n/-- A multilinear map is compatible with scalar multiplication in every argument. -/\ntheorem âˆ€ {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type v} {Mâ‚‚ : Type w} [inst : Semiring R]\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (Mâ‚ i)] [inst_2 : AddCommMonoid Mâ‚‚] [inst_3 : (i : Î¹) â†’ Module R (Mâ‚ i)]\n  [inst_4 : Module R Mâ‚‚] (self : MultilinearMap R Mâ‚ Mâ‚‚) [inst_5 : DecidableEq Î¹] (m : (i : Î¹) â†’ Mâ‚ i) (i : Î¹) (c : R)\n  (x : Mâ‚ i),\n  MultilinearMap.toFun self (Function.update m i (c â€¢ x)) = c â€¢ MultilinearMap.toFun self (Function.update m i x) :=\n\n/-- Two linear maps are equal if they are equal on basis vectors. -/\ntheorem âˆ€ {Î¹ : Type u_5} {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (b : Basis Î¹ R M) {Râ‚ : Type u_2} [inst_3 : Semiring Râ‚] {Ïƒ : R â†’+* Râ‚} {Mâ‚ : Type u_4} [inst_4 : AddCommMonoid Mâ‚]\n  [inst_5 : Module Râ‚ Mâ‚] {fâ‚ fâ‚‚ : M â†’â‚›â‚—[Ïƒ] Mâ‚}, (âˆ€ (i : Î¹), â†‘fâ‚ (â†‘b i) = â†‘fâ‚‚ (â†‘b i)) â†’ fâ‚ = fâ‚‚ :=\n\n/-- For a continuous real linear map `f`, if one controls the norm of every `f x`, `â€–xâ€–â‚Š = 1`, then\none controls the norm of `f`. -/\ntheorem âˆ€ {E : Type u_1} {F : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : SeminormedAddCommGroup F]\n  [inst_2 : NormedSpace â„ E] [inst_3 : NormedSpace â„ F] {f : E â†’L[â„] F} {C : NNReal},\n  (âˆ€ (x : E), â€–xâ€–â‚Š = 1 â†’ â€–â†‘f xâ€–â‚Š â‰¤ C) â†’ â€–fâ€–â‚Š â‰¤ C :=\n\n/-- Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if `dim V = 1` and `T âˆˆ L(V, V)`, then there exists `a âˆˆ F` such that `T v = a v` for all `v âˆˆ V`. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V],\n  Module.rank K V = 1 â†’ âˆ€ (f : V â†’â‚—[K] V), âˆƒ (a : K), âˆ€ (v : V), â†‘f v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V â‰¤ 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), â†‘T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ (v : V), T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ (a : K), âˆ€ (v : V), T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (f : V â†’â‚—[K] V), âˆƒ (a : K), âˆ€ (v : V), â†‘f v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ (v : V), T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ (v : V), T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ v : V, T v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Module.rank K V = 1 â†’ âˆƒ a, âˆ€ (v : V), â†‘f v = a â€¢ v ",
      "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ v : V, T v = a â€¢ v "
    ]
  },
  {
    "docString": "Suppose `p âˆˆ P(â„‚)` has degree `m`. Prove that `p` has `m` distinct roots if and only if `p` and its derivative `p'` have no roots in common.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„•), padicNorm p â†‘m = 1 â†” Â¬p âˆ£ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\\n    Finset.card\\n        (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p)) \\\\ Multiset.toFinset (Polynomial.roots p)) +\\n      1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial `p` is at most the number of roots of its derivative\\nthat are not roots of `p` plus one. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„¤), padicNorm p â†‘m = 1 â†” Â¬â†‘p âˆ£ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime that does not divide `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\\nand of `Î¼ ^ p` are the same. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•},\\n      Nat.coprime m n â†’ Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly â„¤ Î¼)) (Î¼ ^ m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m : â„•` is coprime with `n`,\\nthen the minimal polynomial of a primitive `n`-th root of unity `Î¼`\\nhas `Î¼ ^ m` as root. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\\n  Polynomial.Splits (RingHom.id K) p â†” â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial splits if and only if it has as many roots as its degree. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•}, Nat.coprime m n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m : â„•` is coprime with `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\\nand of `Î¼ ^ m` are the same. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is separable. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} [inst : Field K] {P : Polynomial K},\\n  Polynomial.Monic P â†’\\n    Polynomial.Splits (RingHom.id K) P â†’\\n      Polynomial.coeff P 0 = (-1) ^ Polynomial.natDegree P * Multiset.prod (Polynomial.roots P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a monic polynomial that splits, then `coeff P 0` equals the product of the roots. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•},\\n  Nat.Prime p â†’\\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal (Polynomial R)},\\n  P â‰  âŠ¥ â†’\\n    (âˆ€ (x : R), â†‘Polynomial.C x âˆˆ P â†’ x = 0) â†’\\n      âˆƒ p, p âˆˆ P âˆ§ Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) p â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"This technical lemma asserts the existence of a polynomial `p` in an ideal `P âŠ‚ R[x]`\\nthat is non-zero in the quotient `R / (P âˆ© R) [x]`.  The assumptions are equivalent to\\n`P â‰  0` and `P âˆ© R = (0)`.\\n\"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  â†‘Multiset.card (Polynomial.roots p) â‰¤ â†‘Multiset.card (Polynomial.roots (â†‘Polynomial.derivative p)) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial (counted with multiplicities) is at most the number of\\nroots of its derivative (counted with multiplicities) plus one. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\\n  â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p â†’\\n    â†‘Polynomial.C (Polynomial.leadingCoeff p) *\\n        Multiset.prod (Multiset.map (fun a => Polynomial.X - â†‘Polynomial.C a) (Polynomial.roots p)) =\\n      p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial `p` that has as many roots as its degree\\ncan be written `p = p.leadingCoeff * âˆ(X - a)`, for `a` in `p.roots`. \"},\n {\"theorem\":\n  \"âˆ€ {m p k : â„•}, m âˆˆ Set.Ioo (p * k) (p * (k + 1)) â†’ padicValNat p m = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic valuation of `m` equals zero if it is between `p * k` and `p * (k + 1)` for\\nsome `k`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] {a : â„¤}, multiplicity.Finite (â†‘p) a â†” a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `p : â„•` in `a : â„¤` is finite exactly when `a â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"}]\n",
    "prompt_cons": "/-- The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„•), padicNorm p â†‘m = 1 â†” Â¬p âˆ£ m :=\n\n/-- The number of roots of a real polynomial `p` is at most the number of roots of its derivative\nthat are not roots of `p` plus one. -/\ntheorem âˆ€ (p : Polynomial â„),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\n    Finset.card\n        (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p)) \\ Multiset.toFinset (Polynomial.roots p)) +\n      1 :=\n\n/-- The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (m : â„¤), padicNorm p â†‘m = 1 â†” Â¬â†‘p âˆ£ m :=\n\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\nand of `Î¼ ^ p` are the same. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p) :=\n\n/-- If `m : â„•` is coprime with `n`,\nthen the minimal polynomial of a primitive `n`-th root of unity `Î¼`\nhas `Î¼ ^ m` as root. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•},\n      Nat.coprime m n â†’ Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly â„¤ Î¼)) (Î¼ ^ m) :=\n\n/-- A polynomial splits if and only if it has as many roots as its degree. -/\ntheorem âˆ€ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.Splits (RingHom.id K) p â†” â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p :=\n\n/-- If `m : â„•` is coprime with `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\nand of `Î¼ ^ m` are the same. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•}, Nat.coprime m n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ m) :=\n\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `Î¼` is separable. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [inst_3 : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼)) :=\n\n/-- If `P` is a monic polynomial that splits, then `coeff P 0` equals the product of the roots. -/\ntheorem âˆ€ {K : Type v} [inst : Field K] {P : Polynomial K},\n  Polynomial.Monic P â†’\n    Polynomial.Splits (RingHom.id K) P â†’\n      Polynomial.coeff P 0 = (-1) ^ Polynomial.natDegree P * Multiset.prod (Polynomial.roots P) :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m â‰¤ n`. -/\ntheorem âˆ€ {p : â„•},\n  Nat.Prime p â†’\n    âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : â„•},\n      m â‰¤ n â†’ Irreducible (Polynomial.cyclotomic (p ^ n) R) â†’ Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ (p : Polynomial â„),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1 :=\n\n/-- This technical lemma asserts the existence of a polynomial `p` in an ideal `P âŠ‚ R[x]`\nthat is non-zero in the quotient `R / (P âˆ© R) [x]`.  The assumptions are equivalent to\n`P â‰  0` and `P âˆ© R = (0)`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {P : Ideal (Polynomial R)},\n  P â‰  âŠ¥ â†’\n    (âˆ€ (x : R), â†‘Polynomial.C x âˆˆ P â†’ x = 0) â†’\n      âˆƒ p, p âˆˆ P âˆ§ Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) p â‰  0 :=\n\n/-- The number of roots of a real polynomial (counted with multiplicities) is at most the number of\nroots of its derivative (counted with multiplicities) plus one. -/\ntheorem âˆ€ (p : Polynomial â„),\n  â†‘Multiset.card (Polynomial.roots p) â‰¤ â†‘Multiset.card (Polynomial.roots (â†‘Polynomial.derivative p)) + 1 :=\n\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1 :=\n\n/-- A polynomial `p` that has as many roots as its degree\ncan be written `p = p.leadingCoeff * âˆ(X - a)`, for `a` in `p.roots`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  â†‘Multiset.card (Polynomial.roots p) = Polynomial.natDegree p â†’\n    â†‘Polynomial.C (Polynomial.leadingCoeff p) *\n        Multiset.prod (Multiset.map (fun a => Polynomial.X - â†‘Polynomial.C a) (Polynomial.roots p)) =\n      p :=\n\n/-- The `p`-adic valuation of `m` equals zero if it is between `p * k` and `p * (k + 1)` for\nsome `k`. -/\ntheorem âˆ€ {m p k : â„•}, m âˆˆ Set.Ioo (p * k) (p * (k + 1)) â†’ padicValNat p m = 0 :=\n\n/-- The multiplicity of `p : â„•` in `a : â„¤` is finite exactly when `a â‰  0`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] {a : â„¤}, multiplicity.Finite (â†‘p) a â†” a â‰  0 :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- Suppose `p âˆˆ P(â„‚)` has degree `m`. Prove that `p` has `m` distinct roots if and only if `p` and its derivative `p'` have no roots in common. -/\ntheorem",
    "choices": [
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.degree p = m â†’\n    (m = Multiset.card (Polynomial.roots p) â†”\n     âˆ€ (a : R), Polynomial.IsRoot p a â†’ Â¬Polynomial.IsRoot (Polynomial.derivative p) a) ",
      "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = Multiset.card (Polynomial.roots p) â†”\n    âˆ€ (a : R), Polynomial.rootMultiplicity a p â‰¤ 1 ",
      "âˆ€ {R : Type u} [inst : Field R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = Fintype.card (Polynomial.rootSet p R) â†”\n    Disjoint (Polynomial.rootSet p R) (Polynomial.rootSet (Polynomial.derivative p) R) ",
      "âˆ€ {p : Polynomial â„‚} {m : â„•},\n  Polynomial.natDegree p = m â†’\n    (p â‰  0 â†’\n       (âˆ€ a, Polynomial.IsRoot p a â†” Polynomial.IsRoot (â†‘Polynomial.derivative p) a â†’ False) â†”\n         m = Multiset.card (Polynomial.roots p)) ",
      "âˆ€ {p : Polynomial â„‚},\n  Polynomial.natDegree p = Multiset.card (Multiset.toFinset (Polynomial.roots p)) â†”\n    âˆ€ a : â„‚, (multiplicity (Polynomial.X - â†‘Polynomial.C a) p).isGreatest (Polynomial.rootMultiplicity a p) ",
      "âˆ€ {p : Polynomial â„‚},\n  Polynomial.natDegree p = Multiset.card (Multiset.toFinset (Polynomial.roots p)) â†”\n    âˆ€ (x : â„‚), Â¬(Polynomial.IsRoot p x âˆ§ Polynomial.IsRoot (â†‘Polynomial.derivative p) x) ",
      "âˆ€ {p : Polynomial â„‚},\n  Polynomial.degrees (â†‘Polynomial.derivative p) = Polynomial.degrees p - 1 â†’\n    (âˆ€ a, Polynomial.IsRoot p a â†” Â¬Polynomial.IsRoot (â†‘Polynomial.derivative p) a) â†”\n      Finset.card (Multiset.toFinset (Polynomial.roots p)) = Polynomial.natDegree p ",
      "âˆ€ {p : Polynomial â„‚},\n  Polynomial.natDegree p = Finset.card (Multiset.toFinset (Polynomial.roots p)) â†”\n  Multiset.Disjoint (Polynomial.roots p) (Polynomial.roots (â†‘Polynomial.derivative p)) ",
      "âˆ€ {p : Polynomial â„‚},\n  Polynomial.natDegree p = Finset.card (Multiset.toFinset (Polynomial.roots p)) â†”\n    Multiset.disjoint (Polynomial.roots p) (Polynomial.roots (â†‘Polynomial.derivative p)) ",
      "âˆ€ {m : â„•} {p : Polynomial â„‚},\n  Polynomial.natDegree p = m â†’\n    ((âˆ€ a : â„‚, Polynomial.rootMultiplicity a p â‰¤ 1) â†”\n     âˆ€ a : â„‚, Â¬Polynomial.IsRoot p a âˆ¨ Â¬Polynomial.IsRoot (â†‘Polynomial.derivative p) a) "
    ]
  },
  {
    "docString": "Suppose that `S, T âˆˆ L(V)` are such that `S T = T S`. Prove that `null (T - Î» I)` is invariant under `S` for every `Î» âˆˆ F`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {X : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : TopologicalSpace X] {S : Set C(X, ğ•œ)},\\n  (âˆ€ (f : C(X, ğ•œ)), f âˆˆ S â†’ â†‘(AlgHom.compLeftContinuous â„ â†‘IsROrC.conjAe (_ : Continuous â†‘IsROrC.conjCle)) f âˆˆ S) â†’\\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ (Algebra.adjoin ğ•œ S))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g + h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsAddLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under addition. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {G : Type u_2} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} (f : Î± â†’ G),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {F : Î¹ â†’ Î± â†’ G} {l : Filter Î¹},\\n      (âˆ€á¶  (i : Î¹) in l, MeasureTheory.Integrable (F i)) â†’\\n        Filter.Tendsto (fun i => âˆ«â» (x : Î±), â†‘â€–F i x - f xâ€–â‚Š âˆ‚Î¼) l (nhds 0) â†’\\n          Filter.Tendsto (fun i => âˆ« (x : Î±), F i x âˆ‚Î¼) l (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"If `F i â†’ f` in `L1`, then `âˆ« x, F i x âˆ‚Î¼ â†’ âˆ« x, f x âˆ‚Î¼`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T â‰¤ S â†’\\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\\n      [inst_5 : Fintype (M â§¸ T)],\\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"theorem\":\n  \"âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Submodule.span R' s â†’ âˆƒ t, t â€¢ x âˆˆ Submodule.span R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ span R' s`,\\nthen `t â€¢ x âˆˆ span R s` for some `t : M`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {f : Î± â†’ E} {s t : Set Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_2 : NormedSpace â„ E],\\n  MeasureTheory.NullMeasurableSet t â†’\\n    s âŠ† t â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ t \\\\ s â†’ f x = 0) â†’ âˆ« (x : Î±) in t, f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function vanishes almost everywhere on `t \\\\ s` with `s âŠ† t`, then its integrals on `s`\\nand `t` coincide if `t` is null-measurable. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h + g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsAddRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under addition. \"},\n {\"theorem\": \"RingHom.LocalizationPreserves @RingHom.Finite\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {Î± : Type u_2} [inst : Group G] [inst_1 : MulAction G Î±] [inst_2 : MeasurableSpace Î±] {s t : Set Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasurableSpace G] [inst_4 : MeasurableSMul G Î±]\\n  [inst_5 : MeasureTheory.SMulInvariantMeasure G Î± Î¼] [inst_6 : Countable G],\\n  MeasureTheory.IsFundamentalDomain G s â†’\\n    MeasureTheory.NullMeasurableSet t â†’ â†‘â†‘Î¼ s < â†‘â†‘Î¼ t â†’ âˆƒ x, x âˆˆ t âˆ§ âˆƒ y, y âˆˆ t âˆ§ âˆƒ g, g â‰  1 âˆ§ g â€¢ x = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the action of a countable group `G` admits an invariant measure `Î¼` with a fundamental domain\\n`s`, then every null-measurable set `t` of measure strictly greater than `Î¼ s` contains two\\npoints `x y` such that `g â€¢ x = y` for some `g â‰  1`. \"},\n {\"theorem\":\n  \"âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Algebra.adjoin R' s â†’ âˆƒ t, t â€¢ x âˆˆ Algebra.adjoin R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ adjoin R' s`,\\nthen `t â€¢ x âˆˆ adjoin R s` for some `t : M`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\\n  RingHom.ker (algebraMap R S) â‰  âŠ¤ â†’\\n    âˆ€ (f : V'' â†’â‚—[R] V),\\n      Function.Injective â†‘f â†’\\n        âˆ€ (f' : V'' â†’â‚—[R] V') {Î¹ : Type u_4} {b : Î¹ â†’ V''}, LinearIndependent S (â†‘f' âˆ˜ b) â†’ LinearIndependent K (â†‘f âˆ˜ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\\n\\nThe statement we prove is actually slightly more general:\\n * it suffices that the inclusion `algebraMap R S : R â†’ S` is nontrivial\\n * the function `f' : V'' â†’ V'` doesn't need to be injective\\n\"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (S T : V â†’â‚—[â„‚] V),\\n  (âˆ€ (x : V), inner (â†‘S x) x = inner (â†‘T x) x) â†” S = T\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linear maps `S` and `T` are equal, if and only if the identity `âŸªS x, xâŸ«_â„‚ = âŸªT x, xâŸ«_â„‚` holds\\nfor all `x`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  IntermediateField.fixingSubgroup âŠ¥ = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"This lemma says that `Gal(L/K) = L â‰ƒâ‚[K] L` \"},\n {\"theorem\":\n  \"âˆ€ (F : Type u_2) [inst : Field F] {E : Type u_1} [inst_1 : Field E] [inst_2 : Algebra F E] (S T : Set E),\\n  IntermediateField.restrictScalars F (IntermediateField.adjoin { x // x âˆˆ IntermediateField.adjoin F S } T) =\\n    IntermediateField.restrictScalars F (IntermediateField.adjoin { x // x âˆˆ IntermediateField.adjoin F T } S)\",\n  \"isProp\": true,\n  \"docString\": \"`F[S][T] = F[T][S]` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} {Mâ‚ƒ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid Mâ‚ƒ]\\n  [inst_3 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ}, â†‘f 1 = â†‘g 1 â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two `Ïƒ`-linear maps from `R` are equal on `1`, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {Î± : Type u_2} [inst : AddGroup G] [inst_1 : AddAction G Î±] [inst_2 : MeasurableSpace Î±] {s t : Set Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasurableSpace G] [inst_4 : MeasurableVAdd G Î±]\\n  [inst_5 : MeasureTheory.VAddInvariantMeasure G Î± Î¼] [inst_6 : Countable G],\\n  MeasureTheory.IsAddFundamentalDomain G s â†’\\n    MeasureTheory.NullMeasurableSet t â†’ â†‘â†‘Î¼ s < â†‘â†‘Î¼ t â†’ âˆƒ x, x âˆˆ t âˆ§ âˆƒ y, y âˆˆ t âˆ§ âˆƒ g, g â‰  0 âˆ§ g +áµ¥ x = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the additive action of a countable group `G` admits an invariant measure `Î¼` with\\na fundamental domain `s`, then every null-measurable set `t` of measure strictly greater than\\n`Î¼ s` contains two points `x y` such that `g +áµ¥ x = y` for some `g â‰  0`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s t : Set Î±},\\n  s =á¶ [MeasureTheory.Measure.ae Î¼] t â†’ â†‘â†‘Î¼ s = â†‘â†‘Î¼ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are equal modulo a set of measure zero, then `Î¼ s = Î¼ t`. \"}]\n",
    "prompt_cons": "/-- Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S' :=\n\n/-- If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {X : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : TopologicalSpace X] {S : Set C(X, ğ•œ)},\n  (âˆ€ (f : C(X, ğ•œ)), f âˆˆ S â†’ â†‘(AlgHom.compLeftContinuous â„ â†‘IsROrC.conjAe (_ : Continuous â†‘IsROrC.conjCle)) f âˆˆ S) â†’\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ (Algebra.adjoin ğ•œ S)) :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼ :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g + h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsAddLeftInvariant Î¼ :=\n\n/-- If `F i â†’ f` in `L1`, then `âˆ« x, F i x âˆ‚Î¼ â†’ âˆ« x, f x âˆ‚Î¼`. -/\ntheorem âˆ€ {Î± : Type u_3} {G : Type u_2} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} (f : Î± â†’ G),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {F : Î¹ â†’ Î± â†’ G} {l : Filter Î¹},\n      (âˆ€á¶  (i : Î¹) in l, MeasureTheory.Integrable (F i)) â†’\n        Filter.Tendsto (fun i => âˆ«â» (x : Î±), â†‘â€–F i x - f xâ€–â‚Š âˆ‚Î¼) l (nhds 0) â†’\n          Filter.Tendsto (fun i => âˆ« (x : Î±), F i x âˆ‚Î¼) l (nhds (âˆ« (x : Î±), f x âˆ‚Î¼)) :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulRightInvariant Î¼ :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T â‰¤ S â†’\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\n      [inst_5 : Fintype (M â§¸ T)],\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T) :=\n\n/-- If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ span R' s`,\nthen `t â€¢ x âˆˆ span R s` for some `t : M`. -/\ntheorem âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Submodule.span R' s â†’ âˆƒ t, t â€¢ x âˆˆ Submodule.span R s :=\n\n/-- If a function vanishes almost everywhere on `t \\ s` with `s âŠ† t`, then its integrals on `s`\nand `t` coincide if `t` is null-measurable. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {f : Î± â†’ E} {s t : Set Î±}\n  {Î¼ : MeasureTheory.Measure Î±} [inst_2 : NormedSpace â„ E],\n  MeasureTheory.NullMeasurableSet t â†’\n    s âŠ† t â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ t \\ s â†’ f x = 0) â†’ âˆ« (x : Î±) in t, f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼ :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under addition. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h + g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsAddRightInvariant Î¼ :=\n\n/-- If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra. -/\ntheorem RingHom.LocalizationPreserves @RingHom.Finite :=\n\n/-- If the action of a countable group `G` admits an invariant measure `Î¼` with a fundamental domain\n`s`, then every null-measurable set `t` of measure strictly greater than `Î¼ s` contains two\npoints `x y` such that `g â€¢ x = y` for some `g â‰  1`. -/\ntheorem âˆ€ {G : Type u_1} {Î± : Type u_2} [inst : Group G] [inst_1 : MulAction G Î±] [inst_2 : MeasurableSpace Î±] {s t : Set Î±}\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasurableSpace G] [inst_4 : MeasurableSMul G Î±]\n  [inst_5 : MeasureTheory.SMulInvariantMeasure G Î± Î¼] [inst_6 : Countable G],\n  MeasureTheory.IsFundamentalDomain G s â†’\n    MeasureTheory.NullMeasurableSet t â†’ â†‘â†‘Î¼ s < â†‘â†‘Î¼ t â†’ âˆƒ x, x âˆˆ t âˆ§ âˆƒ y, y âˆˆ t âˆ§ âˆƒ g, g â‰  1 âˆ§ g â€¢ x = y :=\n\n/-- If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ adjoin R' s`,\nthen `t â€¢ x âˆˆ adjoin R s` for some `t : M`. -/\ntheorem âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Algebra.adjoin R' s â†’ âˆƒ t, t â€¢ x âˆˆ Algebra.adjoin R s :=\n\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebraMap R S : R â†’ S` is nontrivial\n * the function `f' : V'' â†’ V'` doesn't need to be injective -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\n  RingHom.ker (algebraMap R S) â‰  âŠ¤ â†’\n    âˆ€ (f : V'' â†’â‚—[R] V),\n      Function.Injective â†‘f â†’\n        âˆ€ (f' : V'' â†’â‚—[R] V') {Î¹ : Type u_4} {b : Î¹ â†’ V''}, LinearIndependent S (â†‘f' âˆ˜ b) â†’ LinearIndependent K (â†‘f âˆ˜ b) :=\n\n/-- Two linear maps `S` and `T` are equal, if and only if the identity `âŸªS x, xâŸ«_â„‚ = âŸªT x, xâŸ«_â„‚` holds\nfor all `x`. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (S T : V â†’â‚—[â„‚] V),\n  (âˆ€ (x : V), inner (â†‘S x) x = inner (â†‘T x) x) â†” S = T :=\n\n/-- This lemma says that `Gal(L/K) = L â‰ƒâ‚[K] L` -/\ntheorem âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  IntermediateField.fixingSubgroup âŠ¥ = âŠ¤ :=\n\n/-- `F[S][T] = F[T][S]` -/\ntheorem âˆ€ (F : Type u_2) [inst : Field F] {E : Type u_1} [inst_1 : Field E] [inst_2 : Algebra F E] (S T : Set E),\n  IntermediateField.restrictScalars F (IntermediateField.adjoin { x // x âˆˆ IntermediateField.adjoin F S } T) =\n    IntermediateField.restrictScalars F (IntermediateField.adjoin { x // x âˆˆ IntermediateField.adjoin F T } S) :=\n\n/-- If two `Ïƒ`-linear maps from `R` are equal on `1`, then they are equal. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} {Mâ‚ƒ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid Mâ‚ƒ]\n  [inst_3 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ}, â†‘f 1 = â†‘g 1 â†’ f = g :=\n\n/-- If the additive action of a countable group `G` admits an invariant measure `Î¼` with\na fundamental domain `s`, then every null-measurable set `t` of measure strictly greater than\n`Î¼ s` contains two points `x y` such that `g +áµ¥ x = y` for some `g â‰  0`. -/\ntheorem âˆ€ {G : Type u_1} {Î± : Type u_2} [inst : AddGroup G] [inst_1 : AddAction G Î±] [inst_2 : MeasurableSpace Î±] {s t : Set Î±}\n  {Î¼ : MeasureTheory.Measure Î±} [inst_3 : MeasurableSpace G] [inst_4 : MeasurableVAdd G Î±]\n  [inst_5 : MeasureTheory.VAddInvariantMeasure G Î± Î¼] [inst_6 : Countable G],\n  MeasureTheory.IsAddFundamentalDomain G s â†’\n    MeasureTheory.NullMeasurableSet t â†’ â†‘â†‘Î¼ s < â†‘â†‘Î¼ t â†’ âˆƒ x, x âˆˆ t âˆ§ âˆƒ y, y âˆˆ t âˆ§ âˆƒ g, g â‰  0 âˆ§ g +áµ¥ x = y :=\n\n/-- If two sets are equal modulo a set of measure zero, then `Î¼ s = Î¼ t`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s t : Set Î±},\n  s =á¶ [MeasureTheory.Measure.ae Î¼] t â†’ â†‘â†‘Î¼ s = â†‘â†‘Î¼ t :=\n\n/-- Suppose that `S, T âˆˆ L(V)` are such that `S T = T S`. Prove that `null (T - Î» I)` is invariant under `S` for every `Î» âˆˆ F`. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u} {V : Type v} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] (S T : End ğ•œ V) (hST : S * T = T * S),\n  âˆ€ (Î» : ğ•œ), LinearMap.IsInvariantSubspace (S : V â†’â‚›â‚—[ğ•œ] V) (LinearMap.ker (T - Î» â€¢ LinearMap.id)) ",
      "âˆ€ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] (S T : V â†’â‚—[F] V),\n  S.comp T = T.comp S â†’ âˆ€ (Î» : F), LinearMap.IsInvariantSubspace (S : V â†’â‚—[F] V) (LinearMap.nullSpace (T - LinearMap.id *â‚— Î»)) ",
      "âˆ€ {ğ•œ : Type u} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] {S T : Module.End ğ•œ V},\n  S.comp T = T.comp S â†’ âˆ€ (Î» : ğ•œ), Submodule.map S (Module.End.eigenspace T Î») â‰¤ Module.End.eigenspace T Î» ",
      "âˆ€ {F : Type u_1} {V : Type u_2} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] {S T : V â†’â‚—[F] V},\n  (âˆ€ (x : V), S (T x) = T (S x)) â†’\n    âˆ€ (Î» : F) (x : V), x âˆˆ (LinearMap.ker (T - algebraMap F (V â†’â‚—[F] V) Î»)) â†’ S x âˆˆ (LinearMap.ker (T - algebraMap F (V â†’â‚—[F] V) Î»)) ",
      "âˆ€ {F : Type u_1} {V : Type u_2} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] {S T : V â†’â‚—[F] V},\n  S.comp T = T.comp S â†’\n    âˆ€ Î» : F, LinearMap.submoduleInvariant (LinearMap.ker (T - LinearMap.smulLeft LinearMap.id Î»)) S ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] {S T : End ğ•œ V} (h : S * T = T * S),\n  âˆ€ (Î» : ğ•œ), LinearMap.range (S.restrict (LinearMap.ker (T - â‡‘algebraMap ğ•œ (End ğ•œ V) Î»))) â‰¤ LinearMap.ker (T - â‡‘algebraMap ğ•œ (End ğ•œ V) Î») ",
      "âˆ€ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  (S T : End F V) (h : S * T = T * S),\n  âˆ€ (Î» : F), Submodule.map (S.restrict_scalars F) (Submodule.null âˆ˜ End.sub_apply_right_hom T (LinearMap.id F V) âˆ˜ HasScalar.smul Î») =\n    Submodule.null âˆ˜ End.sub_apply_right_hom T (LinearMap.id F V) âˆ˜ HasScalar.smul Î» ",
      "âˆ€ {K : Type u} [inst : Field K] {V : Type u_1} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T S : End K V),\n  T.comp S = S.comp T â†’ âˆ€ (Î» : K), Submodule.map S (End.eigenspace T Î») â‰¤ End.eigenspace T Î» ",
      "âˆ€ {F : Type u_1} {V : Type u_2} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] (S T : V â†’â‚—[F] V)\n  (hST : S * T = T * S), âˆ€ Î» : F, LinearMap.IsInvariantUnder (LinearMap.nullSpace (T - Î» â€¢ LinearMap.id)) S ",
      "âˆ€ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] (S T : End F V),\n  S.comp T = T.comp S â†’ âˆ€ (Î» : F), Submodule.map S (Ker (T - algebraMap F (End F V) Î»)) = Ker (T - algebraMap F (End F V) Î») "
    ]
  },
  {
    "docString": "Suppose `T âˆˆ L(V)` is such that every vector in `V` is an eigenvector of `T`. Prove that `T` is a scalar multiple of the identity operator.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace ğ•œ V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\\n    fun p => p.fst â€¢ p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x : F) (r : â„),\\n  inner x (r â€¢ x) = r * (â€–xâ€– * â€–xâ€–)\",\n  \"isProp\": true,\n  \"docString\": \"The inner product of a vector with a multiple of itself. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] (f : Module.End K V),\\n  â¨† (Î¼ : K) (k : â„•), â†‘(Module.End.generalizedEigenspace f Î¼) k = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 0 â†’ Prop},\\n  (âˆ€ (r : R),\\n      P (â†‘(algebraMap R (CliffordAlgebra Q)) r)\\n        (_ : â†‘(algebraMap R (CliffordAlgebra Q)) r âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 0},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 0), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even parts, it suffices to show it is true on the\\nscalars, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q : QuadraticForm R M} (a b : M),\\n  â†‘(CliffordAlgebra.Î¹ Q) a * â†‘(CliffordAlgebra.Î¹ Q) b + â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\\n    â†‘(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (â†‘Q) a b)\",\n  \"isProp\": true,\n  \"docString\": \"The symmetric product of vectors is a scalar \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), âˆƒ c, Module.End.HasEigenvalue f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every linear operator on a vector space over an algebraically closed field has\\nan eigenvalue. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\\n  IsSelfAdjoint T â†’\\n    âˆ€ {xâ‚€ : E},\\n      xâ‚€ â‰  0 â†’\\n        IsMinOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨… (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    Module.End.HasEigenvalue T â†‘(â¨† (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\\nfinite-dimensional vector space is an eigenvalue for that operator. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\\n  IsSelfAdjoint T â†’\\n    âˆ€ {xâ‚€ : E},\\n      xâ‚€ â‰  0 â†’\\n        IsMaxOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨† (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a maximum of the Rayleigh quotient of `T` on a sphere centred\\nat the origin is an eigenvector of `T`, with eigenvalue the global supremum of the Rayleigh\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    Module.End.HasEigenvalue T â†‘(â¨… (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The infimum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\\nfinite-dimensional vector space is an eigenvalue for that operator. \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : SMul Î“ T] [self : ContinuousConstSMul Î“ T]\\n  (Î³ : Î“), Continuous fun x => Î³ â€¢ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The scalar multiplication `(â€¢) : Î“ â†’ T â†’ T` is continuous in the second argument. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (n : â„¤) (x : E), (â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\\nagree on inverses of integer numbers in `R` and `S`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) (n : ZMod 2) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q n â†’ Prop},\\n  (âˆ€ (v : CliffordAlgebra Q) (h : v âˆˆ LinearMap.range (CliffordAlgebra.Î¹ Q) ^ ZMod.val n),\\n      P v (_ : v âˆˆ â¨† (i : { n_1 // â†‘n_1 = n }), LinearMap.range (CliffordAlgebra.Î¹ Q) ^ â†‘i)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q n} {hy : y âˆˆ CliffordAlgebra.evenOdd Q n},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q n)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q n},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q n)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q n), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even or odd part, it suffices to show it is true on the\\nscalars or vectors (respectively), closed under addition, and under left-multiplication by a pair\\nof vectors. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\\n          P x hx â†’\\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under multiplication. \"}]\n",
    "prompt_cons": "/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace ğ•œ V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf ğ•œ ğ•œ) (modelWithCornersSelf ğ•œ V)) (modelWithCornersSelf ğ•œ V)\n    fun p => p.fst â€¢ p.snd :=\n\n/-- The inner product of a vector with a multiple of itself. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x : F) (r : â„),\n  inner x (r â€¢ x) = r * (â€–xâ€– * â€–xâ€–) :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem âˆ€ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v â‰  0) (hw : w â‰  0), Projectivization.mk K v hv = Projectivization.mk K w hw â†” âˆƒ a, a â€¢ w = v :=\n\n/-- The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] (f : Module.End K V),\n  â¨† (Î¼ : K) (k : â„•), â†‘(Module.End.generalizedEigenspace f Î¼) k = âŠ¤ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 0 â†’ Prop},\n  (âˆ€ (r : R),\n      P (â†‘(algebraMap R (CliffordAlgebra Q)) r)\n        (_ : â†‘(algebraMap R (CliffordAlgebra Q)) r âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 0},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 0)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 0), P x hx :=\n\n/-- The symmetric product of vectors is a scalar -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (a b : M),\n  â†‘(CliffordAlgebra.Î¹ Q) a * â†‘(CliffordAlgebra.Î¹ Q) b + â†‘(CliffordAlgebra.Î¹ Q) b * â†‘(CliffordAlgebra.Î¹ Q) a =\n    â†‘(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (â†‘Q) a b) :=\n\n/-- Every linear operator on a vector space over an algebraically closed field has\nan eigenvalue. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), âˆƒ c, Module.End.HasEigenvalue f c :=\n\n/-- For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\nquotient. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {xâ‚€ : E},\n      xâ‚€ â‰  0 â†’\n        IsMinOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨… (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€ :=\n\n/-- The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    Module.End.HasEigenvalue T â†‘(â¨† (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2) :=\n\n/-- For a self-adjoint operator `T`, a maximum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global supremum of the Rayleigh\nquotient. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {xâ‚€ : E},\n      xâ‚€ â‰  0 â†’\n        IsMaxOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨† (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- The infimum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    Module.End.HasEigenvalue T â†‘(â¨… (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2) :=\n\n/-- The scalar multiplication `(â€¢) : Î“ â†’ T â†’ T` is continuous in the second argument. -/\ntheorem âˆ€ {Î“ : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : SMul Î“ T] [self : ContinuousConstSMul Î“ T]\n  (Î³ : Î“), Continuous fun x => Î³ â€¢ x :=\n\n/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on inverses of integer numbers in `R` and `S`. -/\ntheorem âˆ€ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (n : â„¤) (x : E), (â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x :=\n\n/-- To show a property is true on the even or odd part, it suffices to show it is true on the\nscalars or vectors (respectively), closed under addition, and under left-multiplication by a pair\nof vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) (n : ZMod 2) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q n â†’ Prop},\n  (âˆ€ (v : CliffordAlgebra Q) (h : v âˆˆ LinearMap.range (CliffordAlgebra.Î¹ Q) ^ ZMod.val n),\n      P v (_ : v âˆˆ â¨† (i : { n_1 // â†‘n_1 = n }), LinearMap.range (CliffordAlgebra.Î¹ Q) ^ â†‘i)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q n} {hy : y âˆˆ CliffordAlgebra.evenOdd Q n},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q n)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q n},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q n)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q n), P x hx :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) â†’ x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop},\n  (âˆ€ (v : M), P (â†‘(CliffordAlgebra.Î¹ Q) v) (_ : â†‘(CliffordAlgebra.Î¹ Q) v âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n    (âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1},\n        P x hx â†’ P y hy â†’ P (x + y) (_ : x + y âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n      (âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1},\n          P x hx â†’\n            P (â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x)\n              (_ : â†‘(CliffordAlgebra.Î¹ Q) mâ‚ * â†‘(CliffordAlgebra.Î¹ Q) mâ‚‚ * x âˆˆ CliffordAlgebra.evenOdd Q 1)) â†’\n        âˆ€ (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulRightInvariant Î¼ :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼ :=\n\n/-- Suppose `T âˆˆ L(V)` is such that every vector in `V` is an eigenvector of `T`. Prove that `T` is a scalar multiple of the identity operator. -/\ntheorem",
    "choices": [
      "âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ (c : K), Module.End.HasEigenvector T c v) â†’ âˆƒ (c : K), T = c â€¢ LinearMap.id ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V)\n  (h_eigvec : âˆ€ (v : V), v â‰  0 â†’ âˆƒ (Î¼ : K), T v = Î¼ â€¢ v),\n  âˆƒ (c : K), T = c â€¢ LinearMap.id ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), âˆƒ (c : K), T v = c â€¢ v) â†’ (âˆƒ (c : K), T = c â€¢ LinearMap.id) ",
      "âˆ€ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V]\n  (T : LinearMap K V V),\n  (âˆ€ v : V, âˆƒ Î¼ : K, T v = Î¼ â€¢ v) â†’\n    âˆƒ (c : K), T = c â€¢ LinearMap.id ",
      "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), âˆƒ (c : K), v â‰  0 â†’ T v = c â€¢ v) â†’ T = Algebra.id.smul (Module.End.eigenvalue T) ",
      "forall {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V]\n  (T : Module.End K V) (h_eigenvector : âˆ€ (v : V), v â‰  0 â†’ âˆƒ (Î¼ : K), Module.End.HasEigenvector T Î¼ v),\n  (âˆƒ (c : K), T = c â€¢ LinearMap.id) ",
      "forall {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ c, T v = c â€¢ v) â†’ (âˆƒ c, T = c â€¢ (LinearMap.id : Module.End K V)) ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ (c : K), T v = c â€¢ v) â†’ (âˆƒ (c : K), âˆ€ (v : V), T v = c â€¢ v) ",
      "âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : Module.End K V},\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ c, T v = c â€¢ v) â†’ (âˆƒ c, T = c â€¢ 1) ",
      "âˆ€ {ğ•œ : Type u} {V : Type v} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] (T : Module.End ğ•œ V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ (c : ğ•œ), T v = c â€¢ v) â†’ T = (Module.End.trace ğ•œ V T) â€¢ (1 : Module.End ğ•œ V) "
    ]
  },
  {
    "docString": "Suppose that `T âˆˆ L(V)` has `dim V` distinct eigenvalues and that `S âˆˆ L(V)` has the same eigenvectors as `T` (not necessarily with the same eigenvalues). Prove that `S T = T S`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Submodule.span R' s â†’ âˆƒ t, t â€¢ x âˆˆ Submodule.span R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ span R' s`,\\nthen `t â€¢ x âˆˆ span R s` for some `t : M`.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\": \"RingHom.LocalizationPreserves @RingHom.Finite\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (S T : V â†’â‚—[â„‚] V),\\n  (âˆ€ (x : V), inner (â†‘S x) x = inner (â†‘T x) x) â†” S = T\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linear maps `S` and `T` are equal, if and only if the identity `âŸªS x, xâŸ«_â„‚ = âŸªT x, xâŸ«_â„‚` holds\\nfor all `x`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (f : Module.End K V) (Î¼ : K) {k : â„•},\\n  FiniteDimensional.finrank K V â‰¤ k â†’\\n    â†‘(Module.End.generalizedEigenspace f Î¼) k = â†‘(Module.End.generalizedEigenspace f Î¼) (FiniteDimensional.finrank K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T â‰¤ S â†’\\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\\n      [inst_5 : Fintype (M â§¸ T)],\\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M' : Type v'}\\n  [inst_3 : AddCommGroup M'] [inst_4 : Module R M'],\\n  (M â‰ƒâ‚—[R] M') â†’ Cardinal.lift (Module.rank R M) = Cardinal.lift (Module.rank R M')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension, a version with different\\nuniverses. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (n : â„¤) (x : E), (â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\\nagree on inverses of integer numbers in `R` and `S`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {X : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : TopologicalSpace X] {S : Set C(X, ğ•œ)},\\n  (âˆ€ (f : C(X, ğ•œ)), f âˆˆ S â†’ â†‘(AlgHom.compLeftContinuous â„ â†‘IsROrC.conjAe (_ : Continuous â†‘IsROrC.conjCle)) f âˆˆ S) â†’\\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ (Algebra.adjoin ğ•œ S))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. \"},\n {\"theorem\":\n  \"âˆ€ {n : Type u_1} {ğ•œ : Type u_2} [inst : Field ğ•œ] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (P : Matrix n n ğ•œ â†’ Prop)\\n  (M : Matrix n n ğ•œ),\\n  (âˆ€ (D : n â†’ ğ•œ), Matrix.det (Matrix.diagonal D) = Matrix.det M â†’ P (Matrix.diagonal D)) â†’\\n    (âˆ€ (t : Matrix.TransvectionStruct n ğ•œ), P (Matrix.TransvectionStruct.toMatrix t)) â†’\\n      (âˆ€ (A B : Matrix n n ğ•œ), P A â†’ P B â†’ P (Matrix.mul A B)) â†’ P M\",\n  \"isProp\": true,\n  \"docString\":\n  \"Induction principle for matrices based on transvections: if a property is true for all diagonal\\nmatrices, all transvections, and is stable under product, then it is true for all matrices. This is\\nthe useful way to say that matrices are generated by diagonal matrices and transvections.\\n\\nWe state a slightly more general version: to prove a property for a matrix `M`, it suffices to\\nassume that the diagonal matrices we consider have the same determinant as `M`. This is useful to\\nobtain similar principles for `SLâ‚™` or `GLâ‚™`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {K : Submodule ğ•œ E} {x y : E}, Dense â†‘K â†’ x - y âˆˆ Ká—® â†’ x = y\",\n  \"isProp\": true,\n  \"docString\": \"If `S` is dense and `x - y âˆˆ Ká—®`, then `x = y`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] {Î¹ : Type v} [dec_Î¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w}\\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] (i : Î¹) (c : R) (x : M i),\\n  â†‘(DirectSum.of M i) (c â€¢ x) = c â€¢ â†‘(DirectSum.of M i) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Scalar multiplication commutes with the inclusion of each component into the direct sum. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] {Î¹ : Type v} [dec_Î¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w}\\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] (s : Finset Î¹) (c : R)\\n  (x : (i : â†‘â†‘s) â†’ M â†‘i), â†‘(DirectSum.mk M s) (c â€¢ x) = c â€¢ â†‘(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\":\n  \"âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Algebra.adjoin R' s â†’ âˆƒ t, t â€¢ x âˆˆ Algebra.adjoin R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ adjoin R' s`,\\nthen `t â€¢ x âˆˆ adjoin R s` for some `t : M`.\"}]\n",
    "prompt_cons": "/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ span R' s`,\nthen `t â€¢ x âˆˆ span R s` for some `t : M`. -/\ntheorem âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Submodule.span R' s â†’ âˆƒ t, t â€¢ x âˆˆ Submodule.span R s :=\n\n/-- Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S' :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra. -/\ntheorem RingHom.LocalizationPreserves @RingHom.Finite :=\n\n/-- Two linear maps `S` and `T` are equal, if and only if the identity `âŸªS x, xâŸ«_â„‚ = âŸªT x, xâŸ«_â„‚` holds\nfor all `x`. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (S T : V â†’â‚—[â„‚] V),\n  (âˆ€ (x : V), inner (â†‘S x) x = inner (â†‘T x) x) â†” S = T :=\n\n/-- Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (f : Module.End K V) (Î¼ : K) {k : â„•},\n  FiniteDimensional.finrank K V â‰¤ k â†’\n    â†‘(Module.End.generalizedEigenspace f Î¼) k = â†‘(Module.End.generalizedEigenspace f Î¼) (FiniteDimensional.finrank K V) :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem âˆ€ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V â‰ƒâ‚—[K] V') â†” Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T â‰¤ S â†’\n    âˆ€ [inst_3 : DecidablePred fun x => x âˆˆ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M â§¸ S)]\n      [inst_5 : Fintype (M â§¸ T)],\n      Fintype.card { x // x âˆˆ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M â§¸ S) = Fintype.card (M â§¸ T) :=\n\n/-- Two linearly equivalent vector spaces have the same dimension, a version with different\nuniverses. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M' : Type v'}\n  [inst_3 : AddCommGroup M'] [inst_4 : Module R M'],\n  (M â‰ƒâ‚—[R] M') â†’ Cardinal.lift (Module.rank R M) = Cardinal.lift (Module.rank R M') :=\n\n/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on inverses of integer numbers in `R` and `S`. -/\ntheorem âˆ€ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (n : â„¤) (x : E), (â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x :=\n\n/-- If a set `S` is conjugation-invariant, then its `ğ•œ`-span is conjugation-invariant. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {X : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : TopologicalSpace X] {S : Set C(X, ğ•œ)},\n  (âˆ€ (f : C(X, ğ•œ)), f âˆˆ S â†’ â†‘(AlgHom.compLeftContinuous â„ â†‘IsROrC.conjAe (_ : Continuous â†‘IsROrC.conjCle)) f âˆˆ S) â†’\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ (Algebra.adjoin ğ•œ S)) :=\n\n/-- Induction principle for matrices based on transvections: if a property is true for all diagonal\nmatrices, all transvections, and is stable under product, then it is true for all matrices. This is\nthe useful way to say that matrices are generated by diagonal matrices and transvections.\n\nWe state a slightly more general version: to prove a property for a matrix `M`, it suffices to\nassume that the diagonal matrices we consider have the same determinant as `M`. This is useful to\nobtain similar principles for `SLâ‚™` or `GLâ‚™`. -/\ntheorem âˆ€ {n : Type u_1} {ğ•œ : Type u_2} [inst : Field ğ•œ] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (P : Matrix n n ğ•œ â†’ Prop)\n  (M : Matrix n n ğ•œ),\n  (âˆ€ (D : n â†’ ğ•œ), Matrix.det (Matrix.diagonal D) = Matrix.det M â†’ P (Matrix.diagonal D)) â†’\n    (âˆ€ (t : Matrix.TransvectionStruct n ğ•œ), P (Matrix.TransvectionStruct.toMatrix t)) â†’\n      (âˆ€ (A B : Matrix n n ğ•œ), P A â†’ P B â†’ P (Matrix.mul A B)) â†’ P M :=\n\n/-- If `S` is dense and `x - y âˆˆ Ká—®`, then `x = y`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} {x y : E}, Dense â†‘K â†’ x - y âˆˆ Ká—® â†’ x = y :=\n\n/-- Scalar multiplication commutes with the inclusion of each component into the direct sum. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] {Î¹ : Type v} [dec_Î¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w}\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] (i : Î¹) (c : R) (x : M i),\n  â†‘(DirectSum.of M i) (c â€¢ x) = c â€¢ â†‘(DirectSum.of M i) x :=\n\n/-- Scalar multiplication commutes with direct sums. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] {Î¹ : Type v} [dec_Î¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w}\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] (s : Finset Î¹) (c : R)\n  (x : (i : â†‘â†‘s) â†’ M â†‘i), â†‘(DirectSum.mk M s) (c â€¢ x) = c â€¢ â†‘(DirectSum.mk M s) x :=\n\n/-- If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ adjoin R' s`,\nthen `t â€¢ x âˆˆ adjoin R s` for some `t : M`. -/\ntheorem âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Algebra.adjoin R' s â†’ âˆƒ t, t â€¢ x âˆˆ Algebra.adjoin R s :=\n\n/-- Suppose that `T âˆˆ L(V)` has `dim V` distinct eigenvalues and that `S âˆˆ L(V)` has the same eigenvectors as `T` (not necessarily with the same eigenvalues). Prove that `S T = T S`. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V] {T S : V â†’â‚—[ğ•œ] V},\n  (âˆ€ (Î¼ : ğ•œ), Fintype.card { x // x âˆˆ Module.End.eigenspace T Î¼ } = 1) â†’\n  (âˆ€ (Î¼ : ğ•œ) (v : V), v âˆˆ Module.End.eigenspace S Î¼ â†’ v âˆˆ â‹ƒ (Î¼' : ğ•œ), Module.End.eigenspace T Î¼') â†’\n    LinearMap.commute T S ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  {T S : V â†’â‚—[ğ•œ] V}, (âˆƒ t, Module.End.HasDistinctEigenvalues ğ•œ T t) â†’\n    (âˆ€ (Î¼ : ğ•œ) (v : V), Module.End.HasEigenvector T Î¼ v â†” Module.End.HasEigenvector S Î¼ v) â†’ T.comp S = S.comp T ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V] (T S : V â†’â‚—[ğ•œ] V),\n  (âˆ€ (Î¼ : ğ•œ), Module.End.eigenvalues T Î¼ â†’ Module.End.eigenvalues S Î¼) â†’\n    Module.End.hasDistinctEigenvalues T â†’ S.comp T = T.comp S ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T S : E â†’â‚—[ğ•œ] E} [inst_3 : FiniteDimensional ğ•œ E],\n  (âˆ€ (Î¼ : ğ•œ), Module.End.eigenvalue T Î¼ â†’ FiniteDimensional.finrank ğ•œ (Module.End.eigenspace T Î¼) = 1) â†’\n  (âˆ€ (Î¼ : ğ•œ) (x : E), x âˆˆ Module.End.eigenspace T Î¼ â†’ x âˆˆ Module.End.eigenspace S Î¼) â†’\n  LinearMap.commute T S ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  {T S : Module.End ğ•œ V} (hT : LinearMap.IsDiagonalizable T) (h_eig : âˆ€ v, v â‰  0 â†’ T v = 0 â†’ S v = 0) (h_dim : FiniteDimensional.finrank ğ•œ V = Module.End.eigenvalues T.card),\n  T.comp S = S.comp T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  {T S : V â†’â‚—[ğ•œ] V}, LinearMap.IsDiagonalizable T â†’\n    (âˆ€ x : V, x â‰  0 â†’ âˆƒ Î¼, S x = Î¼ â€¢ x) â†’\n      (âˆƒ Î¼â‚€, âˆ€ (x : V), x â‰  0 â†’ âˆƒ Î¼, S (T x) = Î¼â‚€ â€¢ S x) â†’ T * S = S * T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  (T S : V â†’â‚—[ğ•œ] V), LinearMap.HasDistinctEigenvalues T â†’ LinearMap.HasCommonEigenvectors T S â†’ S.comp T = T.comp S ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E] [inst_3 : FiniteDimensional ğ•œ E]\n  {T S : E â†’â‚—[ğ•œ] E} (hT : LinearMap.HasDistinctEigenvalues T) (hTS : âˆ€ Î¼ : ğ•œ, âˆƒ v, v â‰  0 âˆ§ T v = Î¼ â€¢ v â†” S v = Î¼ â€¢ v),\n  T * S = S * T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V] {T S : V â†’â‚—[ğ•œ] V},\n  LinearMap.IsDiagonalizable T â†’ LinearMap.IsDiagonalizable S â†’\n  (âˆ€ x : V, HasMem.Mem x (Module.End.eigenspace T) â†’ HasMem.Mem x (Module.End.eigenspace S)) â†’\n  LinearMap.commute S T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  {T S : V â†’â‚—[ğ•œ] V},\n  Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank ğ•œ V â†’\n    (âˆ€ (x : V) (Î¼ : ğ•œ), x âˆˆ Module.End.eigenspace S Î¼ â†” x âˆˆ Module.End.eigenspace T Î¼) â†’ S.comp T = T.comp S "
    ]
  },
  {
    "docString": "Suppose `u, v âˆˆ V`. Prove that `âŸ¨u, vâŸ© = 0` if and only if `||u|| â‰¤ ||u + a v||` for all `a âˆˆ F`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\\n  MeasurableSet u â†’\\n    MeasurableSet v â†’\\n      MeasurableSet w â†’\\n        MeasureTheory.VectorMeasure.restrict s u â‰¤ MeasureTheory.VectorMeasure.restrict 0 u â†’\\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\\n  MeasurableSet u â†’\\n    MeasurableSet v â†’\\n      MeasurableSet w â†’\\n        MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} (self : UniformSpace.Core Î±), (Filter.lift' self.uniformity fun s => compRel s s) â‰¤ self.uniformity\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every set `u âˆˆ uniformity`, there exists `v âˆˆ uniformity` such that `v â—‹ v âŠ† u`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedAddMonoid Î±] (a b : Î±), a â‰¤ a + b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a â‰¤ a + b` \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 â†” U âŸ‚ V\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} [inst : NormedField ğ•œ] {l : Filter Î±} {u v : Î± â†’ ğ•œ}, u =O[l] v â†’ u / v * v =á¶ [l] u\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `u = O(v)` along `l`, then `(u / v) * v = u` eventually at `l`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded s â†’\\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (v : E), â†‘(orthogonalProjection (Submodule.span ğ•œ {v})á—®) v = 0\",\n  \"isProp\": true,\n  \"docString\": \"The orthogonal projection onto `(ğ•œ âˆ™ v)á—®` of `v` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Î“â‚€]\\n  [inst_2 : Nontrivial Î“â‚€] (v : AddValuation K Î“â‚€) {x : K}, â†‘v x = âŠ¤ â†” x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is an additive valuation on a division ring then `v(x) = âŠ¤` iff `x = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedAddGroup E] {f : Î± â†’ E} {a : Î± â†’ â„} {tâ‚€ : Filter Î±},\\n  (âˆ€ (n : Î±), â€–f nâ€– â‰¤ a n) â†’ Filter.Tendsto a tâ‚€ (nhds 0) â†’ Filter.Tendsto f tâ‚€ (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Special case of the sandwich theorem: if the norm of `f` is bounded by a real\\nfunction `a` which tends to `0`, then `f` tends to `0`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s\",\n  \"isProp\": true,\n  \"docString\": \"It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s t : Set Î±},\\n  s â‰¤á¶ [MeasureTheory.Measure.ae Î¼] t â†’ â†‘â†‘Î¼ s â‰¤ â†‘â†‘Î¼ t\",\n  \"isProp\": true,\n  \"docString\": \"If `s âŠ† t` modulo a set of measure `0`, then `Î¼ s â‰¤ Î¼ t`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {u v : E}, v âˆˆ (Submodule.span ğ•œ {u})á—® â†” inner v u = 0\",\n  \"isProp\": true,\n  \"docString\": \"A vector in `(ğ•œ âˆ™ u)á—®` is orthogonal to `u`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} [inst : NormedField ğ•œ] {l : Filter Î±} {u v : Î± â†’ ğ•œ}, u =o[l] v â†’ u / v * v =á¶ [l] u\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `u = o(v)` along `l`, then `(u / v) * v = u` eventually at `l`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. \"}]\n",
    "prompt_cons": "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasurableSet w â†’\n        MeasureTheory.VectorMeasure.restrict s u â‰¤ MeasureTheory.VectorMeasure.restrict 0 u â†’\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0 :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasurableSet w â†’\n        MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0 :=\n\n/-- Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- For every set `u âˆˆ uniformity`, there exists `v âˆˆ uniformity` such that `v â—‹ v âŠ† u`. -/\ntheorem âˆ€ {Î± : Type u} (self : UniformSpace.Core Î±), (Filter.lift' self.uniformity fun s => compRel s s) â‰¤ self.uniformity :=\n\n/-- For any `a` and `b`, `a â‰¤ a + b` -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedAddMonoid Î±] (a b : Î±), a â‰¤ a + b :=\n\n/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 â†” U âŸ‚ V :=\n\n/-- If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x :=\n\n/-- For all `a` and `b` of `Gâ‚€`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : Mul Mâ‚€] [inst_1 : Zero Mâ‚€] [self : NoZeroDivisors Mâ‚€] {a b : Mâ‚€}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- If `u = O(v)` along `l`, then `(u / v) * v = u` eventually at `l`. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} [inst : NormedField ğ•œ] {l : Filter Î±} {u v : Î± â†’ ğ•œ}, u =O[l] v â†’ u / v * v =á¶ [l] u :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded s â†’\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- The orthogonal projection onto `(ğ•œ âˆ™ v)á—®` of `v` is zero. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (v : E), â†‘(orthogonalProjection (Submodule.span ğ•œ {v})á—®) v = 0 :=\n\n/-- If `v` is an additive valuation on a division ring then `v(x) = âŠ¤` iff `x = 0`. -/\ntheorem âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Î“â‚€]\n  [inst_2 : Nontrivial Î“â‚€] (v : AddValuation K Î“â‚€) {x : K}, â†‘v x = âŠ¤ â†” x = 0 :=\n\n/-- Special case of the sandwich theorem: if the norm of `f` is bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `0`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedAddGroup E] {f : Î± â†’ E} {a : Î± â†’ â„} {tâ‚€ : Filter Î±},\n  (âˆ€ (n : Î±), â€–f nâ€– â‰¤ a n) â†’ Filter.Tendsto a tâ‚€ (nhds 0) â†’ Filter.Tendsto f tâ‚€ (nhds 0) :=\n\n/-- It suffices to prove `[[x, y]] âŠ† s` for `x y âˆˆ s`, `x â‰¤ y`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±},\n  Set.OrdConnected s â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s :=\n\n/-- If `s âŠ† t` modulo a set of measure `0`, then `Î¼ s â‰¤ Î¼ t`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s t : Set Î±},\n  s â‰¤á¶ [MeasureTheory.Measure.ae Î¼] t â†’ â†‘â†‘Î¼ s â‰¤ â†‘â†‘Î¼ t :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- A vector in `(ğ•œ âˆ™ u)á—®` is orthogonal to `u`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {u v : E}, v âˆˆ (Submodule.span ğ•œ {u})á—® â†” inner v u = 0 :=\n\n/-- If `u = o(v)` along `l`, then `(u / v) * v = u` eventually at `l`. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} [inst : NormedField ğ•œ] {l : Filter Î±} {u v : Î± â†’ ğ•œ}, u =o[l] v â†’ u / v * v =á¶ [l] u :=\n\n/-- If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M :=\n\n/-- Suppose `u, v âˆˆ V`. Prove that `âŸ¨u, vâŸ© = 0` if and only if `||u|| â‰¤ ||u + a v||` for all `a âˆˆ F`. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (u v : E), inner u v = 0 â†” âˆ€ a : ğ•œ, âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (u v : E), inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a * vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (u v : E), inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (u v : E), inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ E] {u v : E}, inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (u v : E), inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ E] {u v : E},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {u v : E}, inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (u v : E), inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {u v : E},\n  inner u v = 0 â†” âˆ€ (a : ğ•œ), âˆ¥uâˆ¥ â‰¤ âˆ¥u + a â€¢ vâˆ¥ "
    ]
  },
  {
    "docString": "Prove that if `V` is a complex inner-product space, then `âŸ¨u, vâŸ© = (||u + v||^2 - ||u - v||^2 + ||u + i v||^2 i - ||u - i v||^2 i) / 4` for all `u, v âˆˆ V`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\\n  LinearMap.IsSymmetric T â†” âˆ€ (v : V), â†‘(starRingEnd â„‚) (inner (â†‘T v) v) = inner (â†‘T v) v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear operator on a complex inner product space is symmetric precisely when\\n`âŸªT v, vâŸ«_â„‚` is real for all v.\"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace â„ V]\\n  [inst_6 : FiniteDimensional â„ V],\\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-inner v w))) â€¢ f v)\\n    (Filter.cocompact V) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\\n`âˆ« v, exp (-2 * Ï€ * âŸªw, vâŸ« * I) â€¢ f v` tends to 0 as `w â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im\",\n  \"isProp\": true,\n  \"docString\":\n  \"The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  inner x y * inner x y â‰¤ inner x x * inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Cauchyâ€“Schwarz inequality for real inner products. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸ : Real.Angle) (f : V â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x : V), â†‘f (â†‘(Orientation.rotation o Î¸) x) = â†‘(Real.Angle.expMapCircle Î¸) * â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\\ncomplex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (f : V â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x y : V), Orientation.oangle o x y = â†‘(Complex.arg (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The oriented angle on an oriented real inner product space of dimension 2 can be evaluated in\\nterms of a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x : E), â†‘f (â†‘(Orientation.rightAngleRotation o) x) = Complex.I * â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\\nevaluated in terms of a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector inner product form. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E] {n : â„•}\\n  [_i : Fact (FiniteDimensional.finrank â„ E = n)] (o : Orientation â„ E (Fin n)) {v : Fin n â†’ E},\\n  (Pairwise fun i j => inner (v i) (v j) = 0) â†’ |â†‘(Orientation.volumeForm o) v| = Finset.prod Finset.univ fun i => â€–v iâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `v` be an indexed family of `n` orthogonal vectors in an oriented `n`-dimensional\\nreal inner product space `E`. The output of the volume form of `E` when evaluated on `v` is, up to\\nsign, the product of the norms of the vectors `v i`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F), |inner x y / (â€–xâ€– * â€–yâ€–)| â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real inner product of two vectors, divided by the product of their\\nnorms, has absolute value at most 1. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  |inner x y / (â€–xâ€– * â€–yâ€–)| = 1 â†” x â‰  0 âˆ§ âˆƒ r, r â‰  0 âˆ§ y = r â€¢ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of two vectors, divided by the product of their\\nnorms, has absolute value 1 if and only if they are nonzero and one is\\na multiple of the other. One form of equality case for Cauchy-Schwarz. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.kahler o) x) y = â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Kahler form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module â„ V] [inst_9 : ContinuousSMul â„ V]\\n  [inst_10 : FiniteDimensional â„ V] (Î¼ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\\n  Filter.Tendsto (VectorFourier.fourierIntegral Real.fourierChar Î¼ (LinearMap.flip (topDualPairing â„ V)) f)\\n    (Filter.cocompact (V â†’L[â„] â„)) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Riemann-Lebesgue lemma, formulated in terms of `VectorFourier.fourierIntegral` (with the\\npairing in the definition of `fourier_integral` taken to be the canonical pairing between `V` and\\nits dual space). \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E] {n : â„•}\\n  [_i : Fact (FiniteDimensional.finrank â„ E = n)] (o : Orientation â„ E (Fin n)) (v : Fin n â†’ E),\\n  |â†‘(Orientation.volumeForm o) v| â‰¤ Finset.prod Finset.univ fun i => â€–v iâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `v` be an indexed family of `n` vectors in an oriented `n`-dimensional real inner\\nproduct space `E`. The output of the volume form of `E` when evaluated on `v` is bounded in absolute\\nvalue by the product of the norms of the vectors `v i`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\\n  Set.Nonempty K â†’ IsComplete K â†’ Convex â„ K â†’ âˆ€ (u : F), âˆƒ v, v âˆˆ K âˆ§ â€–u - vâ€– = â¨… (w : â†‘K), â€–u - â†‘wâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"Existence of minimizers\\nLet `u` be a point in a real inner product space, and let `K` be a nonempty complete convex subset.\\nThen there exists a (unique) `v` in `K` that minimizes the distance `â€–u - vâ€–` to `u`.\\n \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module â„ V] [inst_9 : ContinuousSMul â„ V]\\n  [inst_10 : FiniteDimensional â„ V] (Î¼ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-â†‘w v))) â€¢ f v âˆ‚Î¼)\\n    (Filter.cocompact (V â†’L[â„] â„)) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\\ndual space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (K : Submodule ğ•œ E), IsComplete â†‘K â†’ âˆ€ (u : E), âˆƒ v, v âˆˆ K âˆ§ â€–u - vâ€– = â¨… (w : â†‘â†‘K), â€–u - â†‘wâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"Existence of projections on complete subspaces.\\nLet `u` be a point in an inner product space, and let `K` be a nonempty complete subspace.\\nThen there exists a (unique) `v` in `K` that minimizes the distance `â€–u - vâ€–` to `u`.\\nThis point `v` is usually called the orthogonal projection of `u` onto `K`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. \"}]\n",
    "prompt_cons": "/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re :=\n\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`âŸªT v, vâŸ«_â„‚` is real for all v. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsSymmetric T â†” âˆ€ (v : V), â†‘(starRingEnd â„‚) (inner (â†‘T v) v) = inner (â†‘T v) v :=\n\n/-- Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\n`âˆ« v, exp (-2 * Ï€ * âŸªw, vâŸ« * I) â€¢ f v` tends to 0 as `w â†’ âˆ`. -/\ntheorem âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace â„ V]\n  [inst_6 : FiniteDimensional â„ V],\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-inner v w))) â€¢ f v)\n    (Filter.cocompact V) (nhds 0) :=\n\n/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im :=\n\n/-- Cauchyâ€“Schwarz inequality for real inner products. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  inner x y * inner x y â‰¤ inner x x * inner y y :=\n\n/-- Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\ncomplex-number representation of the space. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸ : Real.Angle) (f : V â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x : V), â†‘f (â†‘(Orientation.rotation o Î¸) x) = â†‘(Real.Angle.expMapCircle Î¸) * â†‘f x :=\n\n/-- The oriented angle on an oriented real inner product space of dimension 2 can be evaluated in\nterms of a complex-number representation of the space. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (f : V â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x y : V), Orientation.oangle o x y = â†‘(Complex.arg (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y)) :=\n\n/-- The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\nevaluated in terms of a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x : E), â†‘f (â†‘(Orientation.rightAngleRotation o) x) = Complex.I * â†‘f x :=\n\n/-- Pythagorean theorem, vector inner product form. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- Let `v` be an indexed family of `n` orthogonal vectors in an oriented `n`-dimensional\nreal inner product space `E`. The output of the volume form of `E` when evaluated on `v` is, up to\nsign, the product of the norms of the vectors `v i`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E] {n : â„•}\n  [_i : Fact (FiniteDimensional.finrank â„ E = n)] (o : Orientation â„ E (Fin n)) {v : Fin n â†’ E},\n  (Pairwise fun i j => inner (v i) (v j) = 0) â†’ |â†‘(Orientation.volumeForm o) v| = Finset.prod Finset.univ fun i => â€–v iâ€– :=\n\n/-- The real inner product of two vectors, divided by the product of their\nnorms, has absolute value at most 1. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F), |inner x y / (â€–xâ€– * â€–yâ€–)| â‰¤ 1 :=\n\n/-- The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  |inner x y / (â€–xâ€– * â€–yâ€–)| = 1 â†” x â‰  0 âˆ§ âˆƒ r, r â‰  0 âˆ§ y = r â€¢ x :=\n\n/-- The Kahler form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.kahler o) x) y = â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y :=\n\n/-- The Riemann-Lebesgue lemma, formulated in terms of `VectorFourier.fourierIntegral` (with the\npairing in the definition of `fourier_integral` taken to be the canonical pairing between `V` and\nits dual space). -/\ntheorem âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module â„ V] [inst_9 : ContinuousSMul â„ V]\n  [inst_10 : FiniteDimensional â„ V] (Î¼ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\n  Filter.Tendsto (VectorFourier.fourierIntegral Real.fourierChar Î¼ (LinearMap.flip (topDualPairing â„ V)) f)\n    (Filter.cocompact (V â†’L[â„] â„)) (nhds 0) :=\n\n/-- Let `v` be an indexed family of `n` vectors in an oriented `n`-dimensional real inner\nproduct space `E`. The output of the volume form of `E` when evaluated on `v` is bounded in absolute\nvalue by the product of the norms of the vectors `v i`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E] {n : â„•}\n  [_i : Fact (FiniteDimensional.finrank â„ E = n)] (o : Orientation â„ E (Fin n)) (v : Fin n â†’ E),\n  |â†‘(Orientation.volumeForm o) v| â‰¤ Finset.prod Finset.univ fun i => â€–v iâ€– :=\n\n/-- Existence of minimizers\nLet `u` be a point in a real inner product space, and let `K` be a nonempty complete convex subset.\nThen there exists a (unique) `v` in `K` that minimizes the distance `â€–u - vâ€–` to `u`. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Set.Nonempty K â†’ IsComplete K â†’ Convex â„ K â†’ âˆ€ (u : F), âˆƒ v, v âˆˆ K âˆ§ â€–u - vâ€– = â¨… (w : â†‘K), â€–u - â†‘wâ€– :=\n\n/-- Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\ndual space. -/\ntheorem âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module â„ V] [inst_9 : ContinuousSMul â„ V]\n  [inst_10 : FiniteDimensional â„ V] (Î¼ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-â†‘w v))) â€¢ f v âˆ‚Î¼)\n    (Filter.cocompact (V â†’L[â„] â„)) (nhds 0) :=\n\n/-- Existence of projections on complete subspaces.\nLet `u` be a point in an inner product space, and let `K` be a nonempty complete subspace.\nThen there exists a (unique) `v` in `K` that minimizes the distance `â€–u - vâ€–` to `u`.\nThis point `v` is usually called the orthogonal projection of `u` onto `K`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (K : Submodule ğ•œ E), IsComplete â†‘K â†’ âˆ€ (u : E), âˆƒ v, v âˆˆ K âˆ§ â€–u - vâ€– = â¨… (w : â†‘â†‘K), â€–u - â†‘wâ€– :=\n\n/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A :=\n\n/-- Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- Prove that if `V` is a complex inner-product space, then `âŸ¨u, vâŸ© = (||u + v||^2 - ||u - v||^2 + ||u + i v||^2 i - ||u - i v||^2 i) / 4` for all `u, v âˆˆ V`. -/\ntheorem",
    "choices": [
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â€–u + vâ€– * â€–u + vâ€– - â€–u - vâ€– * â€–u - vâ€– + (â€–u + Complex.I * vâ€– * â€–u + Complex.I * vâ€–) * Complex.I - (â€–u - Complex.I * vâ€– * â€–u - Complex.I * vâ€–) * Complex.I) / 4 ",
      "forall {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] (u v : V),\n  inner u v = (â€–u + vâ€– * â€–u + vâ€– - â€–u - vâ€– * â€–u - vâ€– + is_R_or_C.I * (â€–u + is_R_or_C.I * vâ€– * â€–u + is_R_or_C.I * vâ€– - â€–u - is_R_or_C.I * vâ€– * â€–u - is_R_or_C.I * vâ€–)) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â†‘(â€–u + vâ€– * â€–u + vâ€–) - â†‘(â€–u - vâ€– * â€–u - vâ€–) + â†‘(â€–u + I * vâ€– * â€–u + I * vâ€–) * I - â†‘(â€–u - I * vâ€– * â€–u - I * vâ€–) * I) / 4 ",
      "forall {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  (u v : V), inner u v = (1/4) * ((âˆ¥u + vâˆ¥^2 - âˆ¥u - vâˆ¥^2) + (âˆ¥u + IsROrC.i * vâˆ¥^2 - âˆ¥u - IsROrC.i * vâˆ¥^2) * IsROrC.i) ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â€–u + vâ€– * â€–u + vâ€– - â€–u - vâ€– * â€–u - vâ€– + â€–u + Complex.i â€¢ vâ€– * â€–u + Complex.i â€¢ vâ€– * Complex.i - â€–u - Complex.i â€¢ vâ€– * â€–u - Complex.i â€¢ vâ€– * Complex.i) / 4 ",
      "forall {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (u v : E), inner u v = ((â€–u + vâ€– * â€–u + vâ€– - â€–u - vâ€– * â€–u - vâ€–) + (â€–u + IsROrC.i * vâ€– * â€–u + IsROrC.i * vâ€– - â€–u - IsROrC.i * vâ€– * â€–u - IsROrC.i * vâ€–) * IsROrC.i) / 4 ",
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = ((norm (u + v) ^ 2 - norm (u - v) ^ 2 + norm (u + complex.I * v) ^ 2 * complex.I\n              - norm (u - complex.I * v) ^ 2 * complex.I) / 4) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  (u v : V), inner u v = (â€–u + vâ€–^2 - â€–u - vâ€–^2 + â€–u + (IsROrC.i * v)â€–^2 * IsROrC.i - â€–u - (IsROrC.i * v)â€–^2 * IsROrC.i) / 4 ",
      "forall {ğ•œ : Type u_1} {V : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  (u v : V), inner u v = (â€–u + vâ€– * â€–u + vâ€– - â€–u - vâ€– * â€–u - vâ€– + (â€–u + IsROrC.i * vâ€– * â€–u + IsROrC.i * vâ€–) * IsROrC.i - (â€–u - IsROrC.i * vâ€– * â€–u - IsROrC.i * vâ€–) * IsROrC.i) / 4 ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (u v : V),\n  inner u v = (â€–u + vâ€– * â€–u + vâ€– - â€–u - vâ€– * â€–u - vâ€– + (â€–u + Complex.I * vâ€– * â€–u + Complex.I * vâ€– * Complex.I - â€–u - Complex.I * vâ€– * â€–u - Complex.I * vâ€– * Complex.I)) / 4 "
    ]
  },
  {
    "docString": "Suppose `U` is a subspace of `V`. Prove that `UâŠ¥ = {0}` if and only if `U = V`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 â†” U âŸ‚ V\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\\n  U âŸ‚ V â†’ ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from an orthogonal submodule `V` is the zero map. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\\nsuch that `VV âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ V + K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `V + K âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V âŠ† U`.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E],\\n  reflection âŠ¥ = LinearIsometryEquiv.neg ğ•œ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Reflection through the trivial subspace {0} is just negation. \"},\n {\"theorem\":\n  \"âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], Filter.HasBasis (nhds 0) (fun Î³ => Î³ â‰  0) Set.Iio\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a linearly ordered group with zero element adjoined, `U` is a neighbourhood of `0` if and\\nonly if there exists a nonzero element `Î³â‚€` such that `Iio Î³â‚€ âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\\n  MeasurableSet u â†’\\n    MeasurableSet v â†’\\n      MeasurableSet w â†’\\n        MeasureTheory.VectorMeasure.restrict s u â‰¤ MeasureTheory.VectorMeasure.restrict 0 u â†’\\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P} [inst_4 : Nonempty { x // x âˆˆ s }]\\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] {p : P},\\n  dist p â†‘(â†‘(EuclideanGeometry.orthogonalProjection s) p) = 0 â†” p âˆˆ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The distance to a point's orthogonal projection is 0 iff it lies in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) (V : Type u_1) (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P], AffineSubspace.direction âŠ¥ = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"The direction of `âŠ¥` is the submodule `âŠ¥`. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {s : AffineSubspace k P}, Set.Nonempty â†‘s â†’ (AffineSubspace.direction s = âŠ¤ â†” s = âŠ¤)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty affine subspace is `âŠ¤` if and only if its direction is `âŠ¤`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\\n  MeasurableSet u â†’\\n    MeasurableSet v â†’\\n      MeasurableSet w â†’\\n        MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (s : Set (Submodule ğ•œ E)), â¨… (K : Submodule ğ•œ E) (_ : K âˆˆ s), Ká—® = (sSup s)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `K * V âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (Kâ‚ Kâ‚‚ : Submodule ğ•œ E), Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of two orthogonal subspaces equals the subspace orthogonal\\nto the sup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `V * K âŠ† U`. \"}]\n",
    "prompt_cons": "/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 â†” U âŸ‚ V :=\n\n/-- The projection into `U` from an orthogonal submodule `V` is the zero map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U],\n  U âŸ‚ V â†’ ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U âˆˆ nhds 0 â†’ âˆƒ V, IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U :=\n\n/-- If `U â‰¤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\n  U â‰¤ V â†’ âˆ€ (x : E), â†‘(orthogonalProjection U) â†‘(â†‘(orthogonalProjection V) x) = â†‘(orthogonalProjection U) x :=\n\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV âŠ† U`. -/\ntheorem âˆ€ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\n  U âˆˆ nhds 1 â†’ âˆƒ V, IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `V + K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ V + K âŠ† U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 0 âˆ§ K + V âŠ† U :=\n\n/-- Reflection through the trivial subspace {0} is just negation. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E],\n  reflection âŠ¥ = LinearIsometryEquiv.neg ğ•œ :=\n\n/-- In a linearly ordered group with zero element adjoined, `U` is a neighbourhood of `0` if and\nonly if there exists a nonzero element `Î³â‚€` such that `Iio Î³â‚€ âŠ† U`. -/\ntheorem âˆ€ {Î“â‚€ : Type u_1} [inst : LinearOrderedCommGroupWithZero Î“â‚€], Filter.HasBasis (nhds 0) (fun Î³ => Î³ â‰  0) Set.Iio :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasurableSet w â†’\n        MeasureTheory.VectorMeasure.restrict s u â‰¤ MeasureTheory.VectorMeasure.restrict 0 u â†’\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0 :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem âˆ€ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (â„™ K V)),\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T :=\n\n/-- The distance to a point's orthogonal projection is 0 iff it lies in the subspace. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P} [inst_4 : Nonempty { x // x âˆˆ s }]\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] {p : P},\n  dist p â†‘(â†‘(EuclideanGeometry.orthogonalProjection s) p) = 0 â†” p âˆˆ s :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- The direction of `âŠ¥` is the submodule `âŠ¥`. -/\ntheorem âˆ€ (k : Type u_2) (V : Type u_1) (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], AffineSubspace.direction âŠ¥ = âŠ¥ :=\n\n/-- A nonempty affine subspace is `âŠ¤` if and only if its direction is `âŠ¤`. -/\ntheorem âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s : AffineSubspace k P}, Set.Nonempty â†‘s â†’ (AffineSubspace.direction s = âŠ¤ â†” s = âŠ¤) :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v w : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasurableSet w â†’\n        MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\n          â†‘s w = 0 â†’ w âŠ† u â†’ v âŠ† w â†’ â†‘s v = 0 :=\n\n/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (s : Set (Submodule ğ•œ E)), â¨… (K : Submodule ğ•œ E) (_ : K âˆˆ s), Ká—® = (sSup s)á—® :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `K * V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U :=\n\n/-- The inf of two orthogonal subspaces equals the subspace orthogonal\nto the sup. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (Kâ‚ Kâ‚‚ : Submodule ğ•œ E), Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—® :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `V * K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U :=\n\n/-- Suppose `U` is a subspace of `V`. Prove that `UâŠ¥ = {0}` if and only if `U = V`. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "forall {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (U V : Submodule ğ•œ E), UâŠ¥ = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} ,\n  Uá—® = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  UâŠ¥ = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ Uá—® = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  UâŠ¥ = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  UâŠ¥ = âŠ¥ â†” U = V ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  Uá—® = âŠ¥ â†” U = V "
    ]
  },
  {
    "docString": "Prove that if `T âˆˆ L(V)` is normal, then `range T = range T*`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {Î¼ : MeasureTheory.Measure Î±}\\n  (P : (Î± â†’ E) â†’ Prop),\\n  (âˆ€ (c : E) â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ P (Set.indicator s fun x => c)) â†’\\n    (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„,\\n        Disjoint (Function.support f) (Function.support g) â†’\\n          MeasureTheory.Integrable f â†’ MeasureTheory.Integrable g â†’ P f â†’ P g â†’ P (f + g)) â†’\\n      IsClosed {f | P â†‘â†‘f} â†’\\n        (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ MeasureTheory.Integrable f â†’ P f â†’ P g) â†’\\n          âˆ€ â¦ƒf : Î± â†’ Eâ¦„, MeasureTheory.Integrable f â†’ P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary integrable function in a normed group,\\nit suffices to show that\\n* the property holds for (multiples of) characteristic functions;\\n* is closed under addition;\\n* the set of functions in the `LÂ¹` space for which the property holds is closed.\\n* the property is closed under the almost-everywhere equal relation.\\n\\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\\na simple function with a multiple of a characteristic function and that the intersection\\nof their images is a subset of `{0}`).\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : Ring S] [inst_2 : Algebra R S] {Î¹ : Type w}\\n  [inst_3 : Fintype Î¹], Basis Î¹ R S â†’ âˆ€ (x : R), â†‘(Algebra.norm R) (â†‘(algebraMap R S) x) = x ^ Fintype.card Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is in the base ring `K`, then the norm is `x ^ [L : K]`. \"},\n {\"theorem\":\n  \"âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Submodule.span R' s â†’ âˆƒ t, t â€¢ x âˆˆ Submodule.span R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ span R' s`,\\nthen `t â€¢ x âˆˆ span R s` for some `t : M`.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³]\\n  [inst_2 : T2Space Î³] {f : Î± â†’ Î²}, DenseRange f â†’ âˆ€ {g h : Î² â†’ Î³}, Continuous g â†’ Continuous h â†’ g âˆ˜ f = h âˆ˜ f â†’ g = h\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two continuous functions to a t2-space that agree on the dense range of a function are equal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\\n  {Î¼ : MeasureTheory.Measure Î±} [_i : Fact (1 â‰¤ p)],\\n  p â‰  âŠ¤ â†’\\n    âˆ€ (P : { x // x âˆˆ MeasureTheory.Lp E p } â†’ Prop),\\n      (âˆ€ (c : E) {s : Set Î±} (hs : MeasurableSet s) (hÎ¼s : â†‘â†‘Î¼ s < âŠ¤),\\n          P â†‘(MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : â†‘â†‘Î¼ s â‰  âŠ¤) c)) â†’\\n        (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„ (hf : MeasureTheory.Memâ„’p f p) (hg : MeasureTheory.Memâ„’p g p),\\n            Disjoint (Function.support f) (Function.support g) â†’\\n              P (MeasureTheory.Memâ„’p.toLp f hf) â†’\\n                P (MeasureTheory.Memâ„’p.toLp g hg) â†’ P (MeasureTheory.Memâ„’p.toLp f hf + MeasureTheory.Memâ„’p.toLp g hg)) â†’\\n          IsClosed {f | P f} â†’ âˆ€ (f : { x // x âˆˆ MeasureTheory.Lp E p }), P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary `Lp` function in a second countable Borel normed group, it\\nsuffices to show that\\n* the property holds for (multiples of) characteristic functions;\\n* is closed under addition;\\n* the set of functions in `Lp` for which the property holds is closed.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_3} {Râ‚‚ : Type u_6} {M : Type u_2} {Mâ‚‚ : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M] [inst_3 : Semiring Râ‚‚] [inst_4 : AddCommMonoid Mâ‚‚] [inst_5 : Module Râ‚‚ Mâ‚‚] {F : Type u_5}\\n  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : SemilinearMapClass F Ïƒâ‚â‚‚ M Mâ‚‚] {Î¹ : Type u_1} {v : Î¹ â†’ M} {f g : F},\\n  Submodule.span R (Set.range v) = âŠ¤ â†’ (âˆ€ (i : Î¹), â†‘f (v i) = â†‘g (v i)) â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the range of `v : Î¹ â†’ M` generates the whole module and linear maps `f`, `g` are equal at\\neach `v i`, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) {M : â„},\\n  0 â‰¤ M â†’ (âˆ€ (x : E), â€–xâ€– â‰  0 â†’ â€–â†‘f xâ€– â‰¤ M * â€–xâ€–) â†’ â€–fâ€– â‰¤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `â€–xâ€– â‰  0`, then one controls the norm of `A`. \"},\n {\"theorem\": \"âˆ€ {x : â„}, Liouville x â†’ Transcendental â„¤ x\",\n  \"isProp\": true,\n  \"docString\": \"**Liouville's Theorem** \"},\n {\"theorem\":\n  \"âˆ€ {Î“ : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : SMul Î“ T] [self : ContinuousConstSMul Î“ T]\\n  (Î³ : Î“), Continuous fun x => Î³ â€¢ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The scalar multiplication `(â€¢) : Î“ â†’ T â†’ T` is continuous in the second argument. \"},\n {\"theorem\":\n  \"âˆ€ {L : Type u_2} (K : Type u_1) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L] [inst_4 : IsGalois K L] (x : { x // x âˆˆ NumberField.ringOfIntegers L }),\\n  x âˆ£\\n    â†‘(algebraMap { x // x âˆˆ NumberField.ringOfIntegers K } { x // x âˆˆ NumberField.ringOfIntegers L })\\n      (â†‘(RingOfIntegers.norm K) x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `L/K` is a finite Galois extension of fields, then, for all `(x : ğ“ L)` we have that\\n`x âˆ£ algebraMap (ğ“ K) (ğ“ L) (norm K x)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type u_2} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] {Î² : Type u_1} [inst : TopologicalSpace Î²]\\n  [inst_1 : T2Space Î²] [inst_2 : MeasurableSpace Î²] [inst_3 : BorelSpace Î²] {f : Î³ â†’ Î²},\\n  Continuous f â†’ Function.Injective f â†’ MeasurableSet (Set.range f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Lusin-Souslin theorem: the range of a continuous injective function defined on a Polish\\nspace is Borel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\\n  {Î¼ : MeasureTheory.Measure Î±} [_i : Fact (1 â‰¤ p)],\\n  p â‰  âŠ¤ â†’\\n    âˆ€ (P : (Î± â†’ E) â†’ Prop),\\n      (âˆ€ (c : E) â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ P (Set.indicator s fun x => c)) â†’\\n        (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„,\\n            Disjoint (Function.support f) (Function.support g) â†’\\n              MeasureTheory.Memâ„’p f p â†’ MeasureTheory.Memâ„’p g p â†’ P f â†’ P g â†’ P (f + g)) â†’\\n          IsClosed {f | P â†‘â†‘f} â†’\\n            (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ MeasureTheory.Memâ„’p f p â†’ P f â†’ P g) â†’\\n              âˆ€ â¦ƒf : Î± â†’ Eâ¦„, MeasureTheory.Memâ„’p f p â†’ P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary `Memâ„’p` function in a second countable\\nBorel normed group, it suffices to show that\\n* the property holds for (multiples of) characteristic functions;\\n* is closed under addition;\\n* the set of functions in the `Láµ–` space for which the property holds is closed.\\n* the property is closed under the almost-everywhere equal relation.\\n\\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\\na simple function with a multiple of a characteristic function and that the intersection\\nof their images is a subset of `{0}`).\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Fâ‚— : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fâ‚—]\\n  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedSpace ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—),\\n  â€–ContinuousLinearMap.smulRight c fâ€– = â€–câ€– * â€–fâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the tensor product of a scalar linear map and of an element of a normed space\\nis the product of the norms. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {G : Type u_2} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} (f : Î± â†’ G),\\n  MeasureTheory.Integrable f â†’\\n    âˆ€ {F : Î¹ â†’ Î± â†’ G} {l : Filter Î¹},\\n      (âˆ€á¶  (i : Î¹) in l, MeasureTheory.Integrable (F i)) â†’\\n        Filter.Tendsto (fun i => âˆ«â» (x : Î±), â†‘â€–F i x - f xâ€–â‚Š âˆ‚Î¼) l (nhds 0) â†’\\n          Filter.Tendsto (fun i => âˆ« (x : Î±), F i x âˆ‚Î¼) l (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))\",\n  \"isProp\": true,\n  \"docString\": \"If `F i â†’ f` in `L1`, then `âˆ« x, F i x âˆ‚Î¼ â†’ âˆ« x, f x âˆ‚Î¼`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {t : TopologicalSpace ğ•œ},\\n  TopologicalAddGroup ğ•œ â†’ ContinuousSMul ğ•œ ğ•œ â†’ T2Space ğ•œ â†’ t = UniformSpace.toTopologicalSpace\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ğ•œ` is a nontrivially normed field, any T2 topology on `ğ•œ` which makes it a topological\\nvector space over itself (with the norm topology) is *equal* to the norm topology. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T1Space Î²] {f : Î± â†’ Î²}\\n  {a : Î±} {b : Î²}, Filter.Tendsto f (nhds a) (nhds b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a function to a `T1Space` is continuous at some point `a`, it suffices to prove that\\n`f` admits *some* limit at `a`. \"},\n {\"theorem\": \"âˆ€ {d : â„¤}, MonoidHom.mker Zsqrtd.normMonoidHom = unitary (â„¤âˆšd)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The kernel of the norm map on `â„¤âˆšd` equals the submonoid of unitary elements. \"}]\n",
    "prompt_cons": "/-- To prove something for an arbitrary integrable function in a normed group,\nit suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `LÂ¹` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`). -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {Î¼ : MeasureTheory.Measure Î±}\n  (P : (Î± â†’ E) â†’ Prop),\n  (âˆ€ (c : E) â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ P (Set.indicator s fun x => c)) â†’\n    (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„,\n        Disjoint (Function.support f) (Function.support g) â†’\n          MeasureTheory.Integrable f â†’ MeasureTheory.Integrable g â†’ P f â†’ P g â†’ P (f + g)) â†’\n      IsClosed {f | P â†‘â†‘f} â†’\n        (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ MeasureTheory.Integrable f â†’ P f â†’ P g) â†’\n          âˆ€ â¦ƒf : Î± â†’ Eâ¦„, MeasureTheory.Integrable f â†’ P f :=\n\n/-- If `x` is in the base ring `K`, then the norm is `x ^ [L : K]`. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : Ring S] [inst_2 : Algebra R S] {Î¹ : Type w}\n  [inst_3 : Fintype Î¹], Basis Î¹ R S â†’ âˆ€ (x : R), â†‘(Algebra.norm R) (â†‘(algebraMap R S) x) = x ^ Fintype.card Î¹ :=\n\n/-- If `S` is an `R' = Mâ»Â¹R` algebra, and `x âˆˆ span R' s`,\nthen `t â€¢ x âˆˆ span R s` for some `t : M`. -/\ntheorem âˆ€ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x âˆˆ Submodule.span R' s â†’ âˆƒ t, t â€¢ x âˆˆ Submodule.span R s :=\n\n/-- Two continuous functions to a t2-space that agree on the dense range of a function are equal. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³]\n  [inst_2 : T2Space Î³] {f : Î± â†’ Î²}, DenseRange f â†’ âˆ€ {g h : Î² â†’ Î³}, Continuous g â†’ Continuous h â†’ g âˆ˜ f = h âˆ˜ f â†’ g = h :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NontriviallyNormedField ğ•œâ‚‚] [inst_3 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F},\n  Filter.Tendsto (fun n x => â†‘(f n) x) Filter.atTop (nhds â†‘g) â†’ CauchySeq f â†’ Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : RingHomIsometric Ïƒâ‚â‚‚]\n  (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : NNReal), (âˆ€ (x : E), â€–xâ€–â‚Š â‰  0 â†’ â€–â†‘f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ M :=\n\n/-- To prove something for an arbitrary `Lp` function in a second countable Borel normed group, it\nsuffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in `Lp` for which the property holds is closed. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\n  {Î¼ : MeasureTheory.Measure Î±} [_i : Fact (1 â‰¤ p)],\n  p â‰  âŠ¤ â†’\n    âˆ€ (P : { x // x âˆˆ MeasureTheory.Lp E p } â†’ Prop),\n      (âˆ€ (c : E) {s : Set Î±} (hs : MeasurableSet s) (hÎ¼s : â†‘â†‘Î¼ s < âŠ¤),\n          P â†‘(MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : â†‘â†‘Î¼ s â‰  âŠ¤) c)) â†’\n        (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„ (hf : MeasureTheory.Memâ„’p f p) (hg : MeasureTheory.Memâ„’p g p),\n            Disjoint (Function.support f) (Function.support g) â†’\n              P (MeasureTheory.Memâ„’p.toLp f hf) â†’\n                P (MeasureTheory.Memâ„’p.toLp g hg) â†’ P (MeasureTheory.Memâ„’p.toLp f hf + MeasureTheory.Memâ„’p.toLp g hg)) â†’\n          IsClosed {f | P f} â†’ âˆ€ (f : { x // x âˆˆ MeasureTheory.Lp E p }), P f :=\n\n/-- If the range of `v : Î¹ â†’ M` generates the whole module and linear maps `f`, `g` are equal at\neach `v i`, then they are equal. -/\ntheorem âˆ€ {R : Type u_3} {Râ‚‚ : Type u_6} {M : Type u_2} {Mâ‚‚ : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring Râ‚‚] [inst_4 : AddCommMonoid Mâ‚‚] [inst_5 : Module Râ‚‚ Mâ‚‚] {F : Type u_5}\n  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : SemilinearMapClass F Ïƒâ‚â‚‚ M Mâ‚‚] {Î¹ : Type u_1} {v : Î¹ â†’ M} {f g : F},\n  Submodule.span R (Set.range v) = âŠ¤ â†’ (âˆ€ (i : Î¹), â†‘f (v i) = â†‘g (v i)) â†’ f = g :=\n\n/-- If one controls the norm of every `A x`, `â€–xâ€– â‰  0`, then one controls the norm of `A`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) {M : â„},\n  0 â‰¤ M â†’ (âˆ€ (x : E), â€–xâ€– â‰  0 â†’ â€–â†‘f xâ€– â‰¤ M * â€–xâ€–) â†’ â€–fâ€– â‰¤ M :=\n\n/-- **Liouville's Theorem** -/\ntheorem âˆ€ {x : â„}, Liouville x â†’ Transcendental â„¤ x :=\n\n/-- The scalar multiplication `(â€¢) : Î“ â†’ T â†’ T` is continuous in the second argument. -/\ntheorem âˆ€ {Î“ : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : SMul Î“ T] [self : ContinuousConstSMul Î“ T]\n  (Î³ : Î“), Continuous fun x => Î³ â€¢ x :=\n\n/-- If `L/K` is a finite Galois extension of fields, then, for all `(x : ğ“ L)` we have that\n`x âˆ£ algebraMap (ğ“ K) (ğ“ L) (norm K x)`. -/\ntheorem âˆ€ {L : Type u_2} (K : Type u_1) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L] [inst_4 : IsGalois K L] (x : { x // x âˆˆ NumberField.ringOfIntegers L }),\n  x âˆ£\n    â†‘(algebraMap { x // x âˆˆ NumberField.ringOfIntegers K } { x // x âˆˆ NumberField.ringOfIntegers L })\n      (â†‘(RingOfIntegers.norm K) x) :=\n\n/-- The Lusin-Souslin theorem: the range of a continuous injective function defined on a Polish\nspace is Borel-measurable. -/\ntheorem âˆ€ {Î³ : Type u_2} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] {Î² : Type u_1} [inst : TopologicalSpace Î²]\n  [inst_1 : T2Space Î²] [inst_2 : MeasurableSpace Î²] [inst_3 : BorelSpace Î²] {f : Î³ â†’ Î²},\n  Continuous f â†’ Function.Injective f â†’ MeasurableSet (Set.range f) :=\n\n/-- To prove something for an arbitrary `Memâ„’p` function in a second countable\nBorel normed group, it suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `Láµ–` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`). -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\n  {Î¼ : MeasureTheory.Measure Î±} [_i : Fact (1 â‰¤ p)],\n  p â‰  âŠ¤ â†’\n    âˆ€ (P : (Î± â†’ E) â†’ Prop),\n      (âˆ€ (c : E) â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ P (Set.indicator s fun x => c)) â†’\n        (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„,\n            Disjoint (Function.support f) (Function.support g) â†’\n              MeasureTheory.Memâ„’p f p â†’ MeasureTheory.Memâ„’p g p â†’ P f â†’ P g â†’ P (f + g)) â†’\n          IsClosed {f | P â†‘â†‘f} â†’\n            (âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ MeasureTheory.Memâ„’p f p â†’ P f â†’ P g) â†’\n              âˆ€ â¦ƒf : Î± â†’ Eâ¦„, MeasureTheory.Memâ„’p f p â†’ P f :=\n\n/-- Suppose we are given `âˆ‘ i, láµ¢ * sáµ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`láµ¢` and `sáµ¢`. To check that an `x : S` falls in `S'`, we only need to show that\n`sáµ¢ ^ n â€¢ x âˆˆ S'` for some `n` for each `sáµ¢`. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {Î¹ : Type u_2} (Î¹' : Finset Î¹) (s l : Î¹ â†’ S),\n  (Finset.sum Î¹' fun i => l i * s i) = 1 â†’\n    (âˆ€ (i : Î¹), s i âˆˆ S') â†’ (âˆ€ (i : Î¹), l i âˆˆ S') â†’ âˆ€ (x : S), (âˆ€ (i : Î¹), âˆƒ n, s i ^ n â€¢ x âˆˆ S') â†’ x âˆˆ S' :=\n\n/-- The norm of the tensor product of a scalar linear map and of an element of a normed space\nis the product of the norms. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Fâ‚— : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fâ‚—]\n  [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedSpace ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—),\n  â€–ContinuousLinearMap.smulRight c fâ€– = â€–câ€– * â€–fâ€– :=\n\n/-- If `F i â†’ f` in `L1`, then `âˆ« x, F i x âˆ‚Î¼ â†’ âˆ« x, f x âˆ‚Î¼`. -/\ntheorem âˆ€ {Î± : Type u_3} {G : Type u_2} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} (f : Î± â†’ G),\n  MeasureTheory.Integrable f â†’\n    âˆ€ {F : Î¹ â†’ Î± â†’ G} {l : Filter Î¹},\n      (âˆ€á¶  (i : Î¹) in l, MeasureTheory.Integrable (F i)) â†’\n        Filter.Tendsto (fun i => âˆ«â» (x : Î±), â†‘â€–F i x - f xâ€–â‚Š âˆ‚Î¼) l (nhds 0) â†’\n          Filter.Tendsto (fun i => âˆ« (x : Î±), F i x âˆ‚Î¼) l (nhds (âˆ« (x : Î±), f x âˆ‚Î¼)) :=\n\n/-- If `ğ•œ` is a nontrivially normed field, any T2 topology on `ğ•œ` which makes it a topological\nvector space over itself (with the norm topology) is *equal* to the norm topology. -/\ntheorem âˆ€ {ğ•œ : Type u} [hnorm : NontriviallyNormedField ğ•œ] {t : TopologicalSpace ğ•œ},\n  TopologicalAddGroup ğ•œ â†’ ContinuousSMul ğ•œ ğ•œ â†’ T2Space ğ•œ â†’ t = UniformSpace.toTopologicalSpace :=\n\n/-- To prove a function to a `T1Space` is continuous at some point `a`, it suffices to prove that\n`f` admits *some* limit at `a`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T1Space Î²] {f : Î± â†’ Î²}\n  {a : Î±} {b : Î²}, Filter.Tendsto f (nhds a) (nhds b) â†’ ContinuousAt f a :=\n\n/-- The kernel of the norm map on `â„¤âˆšd` equals the submonoid of unitary elements. -/\ntheorem âˆ€ {d : â„¤}, MonoidHom.mker Zsqrtd.normMonoidHom = unitary (â„¤âˆšd) :=\n\n/-- Prove that if `T âˆˆ L(V)` is normal, then `range T = range T*`. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_4} [_inst_1 : Field ğ•œ] [_inst_4 : AddCommGroup V] [_inst_5 : Module ğ•œ V] (T : V â†’â‚—[ğ•œ] V),\n  IsNormal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_7} [inst : Field ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] [inst_2 : FiniteDimensional ğ•œ V] {T : V â†’SL[RingHom.id ğ•œ] V},\n  T.is_normal â†’ ContinuousLinearMap.range T = ContinuousLinearMap.range (ContinuousLinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : NormedField ğ•œ] [inst_1 : NormedSpace ğ•œ V] {T : V â†’â‚—[ğ•œ] V},\n  LinearMap.IsNormal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "âˆ€ {ğ•œ : Type u} {V : Type u_1} [is_R_or_C ğ•œ] [inst : NormedSpace ğ•œ V] [inst_1 : InnerProductSpace ğ•œ V] (T : V â†’â‚—áµ¢[ğ•œ] V),\n  LinearIsometry.isNormal T â†’ LinearMap.range (LinearIsometry.toLinearMap T) = LinearMap.range (LinearIsometry.toLinearMap Táµ¥) ",
      "âˆ€ {ğ•œ : Type u} {V : Type v} [F : Field ğ•œ] [AddCommGroup V] [Module ğ•œ V] {T : V â†’â‚—[ğ•œ] V},\n  LinearMap.IsNormal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "LinearMap.range_eq_of_normal {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : InnerProductSpace ğ•œ V]\n {T : V â†’â‚—[ğ•œ] V}, LinearMap.IsNormal T â†’ LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "forall {ğ•œ : Type u} {V : Type v} [inst : Field ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] {T : V â†’â‚—[ğ•œ] V},\n  IsNormal T â†’ LinearMap.range T = LinearMap.range (InnerProductSpace.continuousLinearMapOfBilin T.adjoint) ",
      "forall {ğ•œ : Type u_1} {V : Type u_2} [field ğ•œ] [add_comm_group V] [vector_space ğ•œ V] {T : V â†’â‚—[ğ•œ] V},\n  LinearMap.is_normal T -> LinearMap.range T = LinearMap.range (LinearMap.is_dual_map T) ",
      "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} [inst : Field ğ•œ] [inst_1 : InnerProductSpace ğ•œ V] [inst_2 : FiniteDimensional ğ•œ V]\n  (T : V â†’â‚—[ğ•œ] V), T.IsNormal â†’ (ContinuousLinearMap.ofLinear T).range = (ContinuousLinearMap.ofLinear T.star).range ",
      "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst_1 : Is_R_or_C ğ•œ] [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E},\n  ContinuousLinearMap.normal T â†’ ContinuousLinearMap.range T = ContinuousLinearMap.range (ContinuousLinearMap.adjoint T) "
    ]
  },
  {
    "docString": "Suppose `V` is a complex inner-product space and `T âˆˆ L(V)` is a normal operator such that `T^9 = T^8`. Prove that `T` is self-adjoint and `T^2 = T`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  (T : E â†’â‚—[ğ•œ] E), LinearMap.IsSymmetric T â†” LinearMap.IsSelfAdjoint sesqFormOfInner T\",\n  \"isProp\": true,\n  \"docString\":\n  \"An operator `T` on an inner product space is symmetric if and only if it is\\n`LinearMap.IsSelfAdjoint` with respect to the sesquilinear form given by the inner product. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\\n  LinearMap.IsSymmetric T â†” âˆ€ (v : V), â†‘(starRingEnd â„‚) (inner (â†‘T v) v) = inner (â†‘T v) v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear operator on a complex inner product space is symmetric precisely when\\n`âŸªT v, vâŸ«_â„‚` is real for all v.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ğ•œ E], (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\\nfinite-dimensional inner product space is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space is an invariant subspace of the operator. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T0Space Î±] â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y\",\n  \"isProp\": true,\n  \"docString\": \"Two inseparable points in a Tâ‚€ space are equal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] (U : Submodule ğ•œ E) [inst_4 : CompleteSpace { x // x âˆˆ U }],\\n  IsSelfAdjoint (ContinuousLinearMap.comp (Submodule.subtypeL U) (orthogonalProjection U))\",\n  \"isProp\": true,\n  \"docString\": \"The orthogonal projection is self-adjoint. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous linear operator is self-adjoint iff it is equal to its adjoint. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im\",\n  \"isProp\": true,\n  \"docString\":\n  \"The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    âˆ€ [inst_3 : FiniteDimensional ğ•œ E], DirectSum.IsInternal fun Î¼ => Module.End.eigenspace T (â†‘T Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator on a finite-dimensional inner product space `E` gives\\nan internal direct sum decomposition of `E`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±], NormalSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"A `Tâ‚…` space is a `Tâ‚„` space. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] {a : A},\\n  IsSelfAdjoint a â†’ spectrum â„‚ a = Complex.ofReal' âˆ˜ Complex.re '' spectrum â„‚ a\",\n  \"isProp\": true,\n  \"docString\": \"The spectrum of a selfadjoint is real \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `Tâ‚…` space is a `Tâ‚…` space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\\n    âˆ€ (x : E), â†‘f (â†‘(Orientation.rightAngleRotation o) x) = Complex.I * â†‘f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\\nevaluated in terms of a complex-number representation of the space. \"}]\n",
    "prompt_cons": "/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {A : E â†’L[ğ•œ] E}, IsSelfAdjoint A â†’ LinearMap.IsSymmetric â†‘A :=\n\n/-- An operator `T` on an inner product space is symmetric if and only if it is\n`LinearMap.IsSelfAdjoint` with respect to the sesquilinear form given by the inner product. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (T : E â†’â‚—[ğ•œ] E), LinearMap.IsSymmetric T â†” LinearMap.IsSelfAdjoint sesqFormOfInner T :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼) :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—® :=\n\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`âŸªT v, vâŸ«_â„‚` is real for all v. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsSymmetric T â†” âˆ€ (v : V), â†‘(starRingEnd â„‚) (inner (â†‘T v) v) = inner (â†‘T v) v :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ğ•œ E], (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥ :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ â¦ƒv : Eâ¦„, v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (â¨† (Î¼ : ğ•œ), Module.End.eigenspace T Î¼)á—® :=\n\n/-- Two inseparable points in a Tâ‚€ space are equal. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T0Space Î±] â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y :=\n\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼ :=\n\n/-- The orthogonal projection is self-adjoint. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] (U : Submodule ğ•œ E) [inst_4 : CompleteSpace { x // x âˆˆ U }],\n  IsSelfAdjoint (ContinuousLinearMap.comp (Submodule.subtypeL U) (orthogonalProjection U)) :=\n\n/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚) (x y : G),\n  inner x y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).re :=\n\n/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A :=\n\n/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x y : E), â†‘(â†‘(Orientation.areaForm o) x) y = (â†‘(starRingEnd â„‚) (â†‘f x) * â†‘f y).im :=\n\n/-- The eigenspaces of a self-adjoint operator on a finite-dimensional inner product space `E` gives\nan internal direct sum decomposition of `E`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ [inst_3 : FiniteDimensional ğ•œ E], DirectSum.IsInternal fun Î¼ => Module.End.eigenspace T (â†‘T Î¼) :=\n\n/-- A `Tâ‚…` space is a `Tâ‚„` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±], NormalSpace Î± :=\n\n/-- The spectrum of a selfadjoint is real -/\ntheorem âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] {a : A},\n  IsSelfAdjoint a â†’ spectrum â„‚ a = Complex.ofReal' âˆ˜ Complex.re '' spectrum â„‚ a :=\n\n/-- A subspace of a `Tâ‚…` space is a `Tâ‚…` space. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T5Space Î±] {p : Î± â†’ Prop}, T5Space { x // p x } :=\n\n/-- The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\nevaluated in terms of a complex-number representation of the space. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (f : E â‰ƒâ‚—áµ¢[â„] â„‚),\n  â†‘(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation â†’\n    âˆ€ (x : E), â†‘f (â†‘(Orientation.rightAngleRotation o) x) = Complex.I * â†‘f x :=\n\n/-- Suppose `V` is a complex inner-product space and `T âˆˆ L(V)` is a normal operator such that `T^9 = T^8`. Prove that `T` is self-adjoint and `T^2 = T`. -/\ntheorem",
    "choices": [
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V],\n  âˆ€ {T : V â†’â‚—[â„‚] V}, LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsNormal T â†’ T^9 = T^8 â†’ IsSelfAdjoint T âˆ§ T^2 = T ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {V : Type u_2} [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace ğ•œ V]\n  {T : V â†’â‚—[ğ•œ] V},\n  LinearMap.IsNormal T â†’\n  (T ^ 9 = T ^ 8) â†’\n    (IsSelfAdjoint T âˆ§ T ^ 2 = T) ",
      "forall {V : Type u_1} [inst : InnerProductSpace â„‚ V] {T : V â†’â‚—[â„‚] V},\n  LinearMap.IsNormal T â†’ T^9 = T^8 â†’ IsSelfAdjoint T âˆ§ T^2 = T ",
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsNormal T â†’ (T ^ 9 = T ^ 8) â†’ IsSelfAdjoint T âˆ§ (T ^ 2 = T) ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ LinearMap.IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ IsSelfAdjoint T âˆ§ T ^ 2 = T ",
      "âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V),\n  LinearMap.IsNormal T â†’ T ^ 9 = T ^ 8 â†’ IsSelfAdjoint T âˆ§ T ^ 2 = T "
    ]
  },
  {
    "docString": "Suppose `T âˆˆ L(V)` is self-adjoint, `Î» âˆˆ F`, and `Îµ > 0`. Prove that if there exists `v âˆˆ V` such that `||v|| = 1` and `||T v - Î» v|| < Îµ`, then `T` has an eigenvalue `Î»'` such that `|Î» - Î»'| < Îµ`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\\n  IsSelfAdjoint T â†’\\n    âˆ€ {xâ‚€ : E},\\n      xâ‚€ â‰  0 â†’\\n        IsMinOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨… (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M) (m : M) {Îµ : â„},\\n  0 < Îµ â†’ âˆƒ s, s âˆˆ S âˆ§ â€–m + sâ€– < â€–â†‘(QuotientAddGroup.mk' S) mâ€– + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `m : M` and any `0 < Îµ`, there is `s âˆˆ S` such that `â€–m + sâ€– < â€–mk' S mâ€– + Îµ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X) {Îµ : NNReal},\\n  0 < Îµ â†’ âˆƒ f, (âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x) âˆ§ â†‘Î› f < rieszContentAux Î› K + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Riesz content can be approximated arbitrarily well by evaluating the positive linear\\nfunctional on test functions: for any `Îµ > 0`, there exists a bounded continuous nonnegative\\nfunction f on X such that `f â‰¥ 1` on K and such that `Î»(K) â‰¤ Î› f < Î»(K) + Îµ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\\n  IsSelfAdjoint T â†’\\n    âˆ€ {xâ‚€ : E},\\n      xâ‚€ â‰  0 â†’\\n        IsLocalExtrOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\\n          Module.End.HasEigenvector (â†‘T) (â†‘(ContinuousLinearMap.rayleighQuotient T xâ‚€)) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a local extremum of the Rayleigh quotient of `T` on a sphere\\ncentred at the origin is an eigenvector of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous linear operator is self-adjoint iff it is equal to its adjoint. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] {S : AddSubgroup M} (x : M â§¸ S) {Îµ : â„},\\n  0 < Îµ â†’ âˆƒ m, â†‘(QuotientAddGroup.mk' S) m = x âˆ§ â€–mâ€– < â€–xâ€– + Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : M â§¸ S` and any `0 < Îµ`, there is `m : M` such that `mk' S m = x`\\nand `â€–mâ€– < â€–xâ€– + Îµ`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\\n  â¦ƒf g : DualNumber R â†’â‚[R] Aâ¦„, â†‘f DualNumber.eps = â†‘g DualNumber.eps â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"For two algebra morphisms out of `R[Îµ]` to agree, it suffices for them to agree on `Îµ`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\\n  IsSelfAdjoint T â†’\\n    âˆ€ {xâ‚€ : E},\\n      xâ‚€ â‰  0 â†’\\n        IsMaxOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨† (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a maximum of the Rayleigh quotient of `T` on a sphere centred\\nat the origin is an eigenvector of `T`, with eigenvalue the global supremum of the Rayleigh\\nquotient. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ Î½ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î¼]\\n  [inst_1 : MeasureTheory.IsFiniteMeasure Î½],\\n  Â¬MeasureTheory.Measure.MutuallySingular Î¼ Î½ â†’\\n    âˆƒ Îµ,\\n      0 < Îµ âˆ§\\n        âˆƒ E,\\n          MeasurableSet E âˆ§\\n            0 < â†‘â†‘Î½ E âˆ§\\n              MeasureTheory.VectorMeasure.restrict 0 E â‰¤\\n                MeasureTheory.VectorMeasure.restrict\\n                  (MeasureTheory.Measure.toSignedMeasure Î¼ - MeasureTheory.Measure.toSignedMeasure (Îµ â€¢ Î½)) E\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two finite measures `Î¼` and `Î½` are not mutually singular, there exists some `Îµ > 0` and\\na measurable set `E`, such that `Î½(E) > 0` and `E` is positive with respect to `Î¼ - ÎµÎ½`.\\n\\nThis lemma is useful for the Lebesgue decomposition theorem. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    Module.End.HasEigenvalue T â†‘(â¨… (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The infimum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\\nfinite-dimensional vector space is an eigenvalue for that operator. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    Module.End.HasEigenvalue T â†‘(â¨† (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\\nfinite-dimensional vector space is an eigenvalue for that operator. \"},\n {\"theorem\": \"âˆ€ {x : â„}, Liouville x â†’ Transcendental â„¤ x\",\n  \"isProp\": true,\n  \"docString\": \"**Liouville's Theorem** \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’\\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : CompleteSpace E] {v : â„ â†’ E â†’ E}\\n  {tMin tâ‚€ tMax : â„} (xâ‚€ : E) {C R : â„} {L : NNReal},\\n  IsPicardLindelof v tMin tâ‚€ tMax xâ‚€ L R C â†’\\n    âˆƒ f, f tâ‚€ = xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ Set.Icc tMin tMax â†’ HasDerivWithinAt f (v t (f t)) (Set.Icc tMin tMax) t\",\n  \"isProp\": true,\n  \"docString\": \"Picard-LindelÃ¶f (Cauchy-Lipschitz) theorem. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {A : E â†’L[â„] E} {Î´ : NNReal},\\n  ApproximatesLinearOn f A s Î´ â†’\\n    MeasurableSet s â†’\\n      âˆ€ (f' : E â†’ E â†’L[â„] E),\\n        (âˆ€ (x : E), x âˆˆ s â†’ HasFDerivWithinAt f (f' x) s x) â†’\\n          âˆ€áµ (x : E) âˆ‚MeasureTheory.Measure.restrict Î¼ s, â€–f' x - Aâ€–â‚Š â‰¤ Î´\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a differentiable function `f` is approximated by a linear map `A` on a set `s`, up to `Î´`,\\nthen at almost every `x` in `s` one has `â€–f' x - Aâ€– â‰¤ Î´`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—®\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. \"}]\n",
    "prompt_cons": "/-- For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\nquotient. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {xâ‚€ : E},\n      xâ‚€ â‰  0 â†’\n        IsMinOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨… (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€ :=\n\n/-- For any `m : M` and any `0 < Îµ`, there is `s âˆˆ S` such that `â€–m + sâ€– < â€–mk' S mâ€– + Îµ`. -/\ntheorem âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M) (m : M) {Îµ : â„},\n  0 < Îµ â†’ âˆƒ s, s âˆˆ S âˆ§ â€–m + sâ€– < â€–â†‘(QuotientAddGroup.mk' S) mâ€– + Îµ :=\n\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼ :=\n\n/-- The Riesz content can be approximated arbitrarily well by evaluating the positive linear\nfunctional on test functions: for any `Îµ > 0`, there exists a bounded continuous nonnegative\nfunction f on X such that `f â‰¥ 1` on K and such that `Î»(K) â‰¤ Î› f < Î»(K) + Îµ`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (Î› : BoundedContinuousFunction X NNReal â†’â‚—[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X) {Îµ : NNReal},\n  0 < Îµ â†’ âˆƒ f, (âˆ€ (x : X), x âˆˆ K â†’ 1 â‰¤ â†‘f x) âˆ§ â†‘Î› f < rieszContentAux Î› K + Îµ :=\n\n/-- For a self-adjoint operator `T`, a local extremum of the Rayleigh quotient of `T` on a sphere\ncentred at the origin is an eigenvector of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {xâ‚€ : E},\n      xâ‚€ â‰  0 â†’\n        IsLocalExtrOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\n          Module.End.HasEigenvector (â†‘T) (â†‘(ContinuousLinearMap.rayleighQuotient T xâ‚€)) xâ‚€ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  {n : â„•} (hn : FiniteDimensional.finrank ğ•œ E = n) (v : E) (i : Fin n),\n  â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (â†‘T v) i =\n    â†‘(LinearMap.IsSymmetric.eigenvalues hT hn i) * â†‘(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] {A : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint A â†” â†‘LinearMap.adjoint A = A :=\n\n/-- For any `x : M â§¸ S` and any `0 < Îµ`, there is `m : M` such that `mk' S m = x`\nand `â€–mâ€– < â€–xâ€– + Îµ`. -/\ntheorem âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] {S : AddSubgroup M} (x : M â§¸ S) {Îµ : â„},\n  0 < Îµ â†’ âˆƒ m, â†‘(QuotientAddGroup.mk' S) m = x âˆ§ â€–mâ€– < â€–xâ€– + Îµ :=\n\n/-- For two algebra morphisms out of `R[Îµ]` to agree, it suffices for them to agree on `Îµ`. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  â¦ƒf g : DualNumber R â†’â‚[R] Aâ¦„, â†‘f DualNumber.eps = â†‘g DualNumber.eps â†’ f = g :=\n\n/-- For a self-adjoint operator `T`, a maximum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global supremum of the Rayleigh\nquotient. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {xâ‚€ : E},\n      xâ‚€ â‰  0 â†’\n        IsMaxOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 â€–xâ‚€â€–) xâ‚€ â†’\n          Module.End.HasEigenvector (â†‘T) (â†‘(â¨† (x : { x // x â‰  0 }), ContinuousLinearMap.rayleighQuotient T â†‘x)) xâ‚€ :=\n\n/-- If two finite measures `Î¼` and `Î½` are not mutually singular, there exists some `Îµ > 0` and\na measurable set `E`, such that `Î½(E) > 0` and `E` is positive with respect to `Î¼ - ÎµÎ½`.\n\nThis lemma is useful for the Lebesgue decomposition theorem. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (Î¼ Î½ : MeasureTheory.Measure Î±) [inst : MeasureTheory.IsFiniteMeasure Î¼]\n  [inst_1 : MeasureTheory.IsFiniteMeasure Î½],\n  Â¬MeasureTheory.Measure.MutuallySingular Î¼ Î½ â†’\n    âˆƒ Îµ,\n      0 < Îµ âˆ§\n        âˆƒ E,\n          MeasurableSet E âˆ§\n            0 < â†‘â†‘Î½ E âˆ§\n              MeasureTheory.VectorMeasure.restrict 0 E â‰¤\n                MeasureTheory.VectorMeasure.restrict\n                  (MeasureTheory.Measure.toSignedMeasure Î¼ - MeasureTheory.Measure.toSignedMeasure (Îµ â€¢ Î½)) E :=\n\n/-- The infimum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    Module.End.HasEigenvalue T â†‘(â¨… (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2) :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] [dec_ğ•œ : DecidableEq ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional ğ•œ E]\n  (v : E) (Î¼ : Module.End.Eigenvalues T),\n  â†‘(LinearMap.IsSymmetric.diagonalization hT) (â†‘T v) Î¼ = â†‘T Î¼ â€¢ â†‘(LinearMap.IsSymmetric.diagonalization hT) v Î¼ :=\n\n/-- The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] [_i : Nontrivial E] {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    Module.End.HasEigenvalue T â†‘(â¨† (x : { x // x â‰  0 }), â†‘IsROrC.re (inner (â†‘T â†‘x) â†‘x) / â€–â†‘xâ€– ^ 2) :=\n\n/-- **Liouville's Theorem** -/\ntheorem âˆ€ {x : â„}, Liouville x â†’ Transcendental â„¤ x :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    OrthogonalFamily ğ•œ (fun Î¼ => { x // x âˆˆ Module.End.eigenspace T Î¼ }) fun Î¼ =>\n      Submodule.subtypeâ‚—áµ¢ (Module.End.eigenspace T Î¼) :=\n\n/-- Picard-LindelÃ¶f (Cauchy-Lipschitz) theorem. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : CompleteSpace E] {v : â„ â†’ E â†’ E}\n  {tMin tâ‚€ tMax : â„} (xâ‚€ : E) {C R : â„} {L : NNReal},\n  IsPicardLindelof v tMin tâ‚€ tMax xâ‚€ L R C â†’\n    âˆƒ f, f tâ‚€ = xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ Set.Icc tMin tMax â†’ HasDerivWithinAt f (v t (f t)) (Set.Icc tMin tMax) t :=\n\n/-- If a differentiable function `f` is approximated by a linear map `A` on a set `s`, up to `Î´`,\nthen at almost every `x` in `s` one has `â€–f' x - Aâ€– â‰¤ Î´`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {A : E â†’L[â„] E} {Î´ : NNReal},\n  ApproximatesLinearOn f A s Î´ â†’\n    MeasurableSet s â†’\n      âˆ€ (f' : E â†’ E â†’L[â„] E),\n        (âˆ€ (x : E), x âˆˆ s â†’ HasFDerivWithinAt f (f' x) s x) â†’\n          âˆ€áµ (x : E) âˆ‚MeasureTheory.Measure.restrict Î¼ s, â€–f' x - Aâ€–â‚Š â‰¤ Î´ :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ (Î¼ : ğ•œ) (v : E), v âˆˆ (Module.End.eigenspace T Î¼)á—® â†’ â†‘T v âˆˆ (Module.End.eigenspace T Î¼)á—® :=\n\n/-- Shows that `|v - Aâ‚™ / Bâ‚™| â‰¤ 1 / (Bâ‚™ * Bâ‚™â‚Šâ‚)`. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  Â¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n â†’\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| â‰¤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- Suppose `T âˆˆ L(V)` is self-adjoint, `Î» âˆˆ F`, and `Îµ > 0`. Prove that if there exists `v âˆˆ V` such that `||v|| = 1` and `||T v - Î» v|| < Îµ`, then `T` has an eigenvalue `Î»'` such that `|Î» - Î»'| < Îµ`. -/\ntheorem",
    "choices": [
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, IsSelfAdjoint T â†’\n    âˆ€ (Î» : ğ•œ) (Îµ : â„), 0 < Îµ â†’\n      âˆƒ v, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» â€¢ vâˆ¥ < Îµ â†’\n        âˆƒ Î»', Module.End.HasEigenvalue T Î»' âˆ§ |Î» - Î»'| < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ {Î» : ğ•œ} {Îµ : â„},\n      0 < Îµ â†’\n        âˆƒ (v : E),\n          âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» â€¢ vâˆ¥ < Îµ â†’\n            âˆƒ (Î¼ : ğ•œ), Module.End.HasEigenvalue T Î¼ âˆ§ |Î» - Î¼| < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E} (hT : IsSelfAdjoint T) {Î» : ğ•œ} {Îµ : â„},\n  0 < Îµ â†’\n    âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» vâˆ¥ < Îµ â†’\n      âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ {Î» : ğ•œ} {Îµ : â„}, 0 < Îµ â†’\n      (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n        âˆƒ Î»', Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î» : ğ•œ} {Îµ : â„},\n  0 < Îµ â†’\n    (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n      âˆƒ Î»' : ğ•œ, Module.End.HasEigenvalue T Î»' âˆ§ |Î» - Î»'| < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’\n    âˆ€ (Î» : ğ•œ) (Îµ : â„),\n      0 < Îµ â†’\n        âˆƒ (v : E), âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» â€¢ vâˆ¥ < Îµ â†’\n          âˆƒ (Î»' : ğ•œ), Module.End.HasEigenvalue T Î»' âˆ§ |Î» - Î»'| < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ (Î» : ğ•œ) (Îµ : â„), 0 < Îµ â†’\n    (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n      âˆƒ Î»' : ğ•œ, Eigenvalue T Î»' âˆ§ |Î» - Î»'| < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E},\n  LinearMap.IsSymmetric T â†’\n    âˆ€ (Î» : ğ•œ) (Îµ : â„), 0 < Îµ â†’\n      (âˆƒ v : E, âˆ¥vâˆ¥ = 1 âˆ§ âˆ¥T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n        âˆƒ Î»' : Module.End.Eigenvalues T, abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : CompleteSpace E] {T : E â†’L[ğ•œ] E},\n  IsSelfAdjoint T â†’\n    âˆ€ (Î» : ğ•œ) (Îµ : â„),\n      0 < Îµ â†’\n        (âˆƒ v : E, â€–vâ€– = 1 âˆ§ âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ) â†’\n          âˆƒ Î»', HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E} (hT : LinearMap.IsSymmetric T) (Î» : ğ•œ) {Îµ : â„},\n  0 < Îµ â†’\n    âˆ€ {v : E},\n      v â‰  0 â†’\n        âˆ¥vâˆ¥ = 1 â†’\n          âˆ¥â†‘T v - Î» â€¢ vâˆ¥ < Îµ â†’\n            âˆƒ Î»', Module.End.HasEigenvalue T Î»' âˆ§ abs (Î» - Î»') < Îµ "
    ]
  },
  {
    "docString": "For all odd `n` show that `8 | n^2 - 1`.",
    "prompts": "[{\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\": \"âˆ€ {n : â„¤}, n % 4 = 3 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `Ï‡â‚„ n = -1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {n a : â„•}, Even a â†’ (Odd (n % a) â†” Odd n)\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"theorem\": \"âˆ€ (n : â„¤), â†‘ZMod.Ï‡â‚ˆ â†‘n = â†‘ZMod.Ï‡â‚ˆ â†‘(n % 8)\",\n  \"isProp\": true,\n  \"docString\": \"The value of `Ï‡â‚ˆ n`, for `n : â„¤`, depends only on `n % 8`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {Ï‡ : MulChar R R'},\\n  MulChar.IsQuadratic Ï‡ â†’ âˆ€ {n : â„•}, Odd n â†’ Ï‡ ^ n = Ï‡\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"},\n {\"theorem\": \"âˆ€ {n a : â„•}, Odd n â†’ Even a â†’ Odd (n % a)\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `Ï‡â‚„ n = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. \"},\n {\"theorem\": \"âˆ€ (n : â„•), â†‘ZMod.Ï‡â‚ˆ â†‘n = â†‘ZMod.Ï‡â‚ˆ â†‘(n % 8)\",\n  \"isProp\": true,\n  \"docString\": \"The value of `Ï‡â‚ˆ n`, for `n : â„•`, depends only on `n % 8`. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd m â†’ Odd n â†’ qrSign m n ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `m` and `n` are odd, then the square of `qrSign m n` is `1`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` \"},\n {\"theorem\": \"âˆ€ {n a : â„•}, Even a â†’ (Even (n % a) â†” Even n)\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is even, then `n` is even iff `n % a` is even. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"âˆ€ {n x y : â„¤}, n = x ^ 2 + y ^ 2 â†’ IsCoprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the integer `n` is a sum of two squares of coprime integers,\\nthen `-1` is a square modulo `n`. \"}]\n",
    "prompt_cons": "/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1 :=\n\n/-- If `n % 4 = 3`, then `Ï‡â‚„ n = -1`. -/\ntheorem âˆ€ {n : â„¤}, n % 4 = 3 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = -1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- If `a` is even, then `n` is odd iff `n % a` is odd. -/\ntheorem âˆ€ {n a : â„•}, Even a â†’ (Odd (n % a) â†” Odd n) :=\n\n/-- The value of `Ï‡â‚ˆ n`, for `n : â„¤`, depends only on `n % 8`. -/\ntheorem âˆ€ (n : â„¤), â†‘ZMod.Ï‡â‚ˆ â†‘n = â†‘ZMod.Ï‡â‚ˆ â†‘(n % 8) :=\n\n/-- The `n`th power of a quadratic character is itself, when `n` is odd. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {Ï‡ : MulChar R R'},\n  MulChar.IsQuadratic Ï‡ â†’ âˆ€ {n : â„•}, Odd n â†’ Ï‡ ^ n = Ï‡ :=\n\n/-- If `n` is odd and `a` is even, then `n % a` is odd. -/\ntheorem âˆ€ {n a : â„•}, Odd n â†’ Even a â†’ Odd (n % a) :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- If `n % 4 = 1`, then `Ï‡â‚„ n = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = 1 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1) :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 :=\n\n/-- The value of `Ï‡â‚ˆ n`, for `n : â„•`, depends only on `n % 8`. -/\ntheorem âˆ€ (n : â„•), â†‘ZMod.Ï‡â‚ˆ â†‘n = â†‘ZMod.Ï‡â‚ˆ â†‘(n % 8) :=\n\n/-- When `m` and `n` are odd, then the square of `qrSign m n` is `1`. -/\ntheorem âˆ€ {m n : â„•}, Odd m â†’ Odd n â†’ qrSign m n ^ 2 = 1 :=\n\n/-- `a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹ :=\n\n/-- If `a` is even, then `n` is even iff `n % a` is even. -/\ntheorem âˆ€ {n a : â„•}, Even a â†’ (Even (n % a) â†” Even n) :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- If the integer `n` is a sum of two squares of coprime integers,\nthen `-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„¤}, n = x ^ 2 + y ^ 2 â†’ IsCoprime x y â†’ IsSquare (-1) :=\n\n/-- For all odd `n` show that `8 | n^2 - 1`. -/\ntheorem",
    "choices": [
      "forall_odd_n_eight_divides_pow_minus_one : âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ",
      "âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) ",
      "forall {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) ",
      "âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ",
      "forall_odd_n_8_dvd_n_squared_minus_one : âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) ",
      "âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ",
      "forall_odd_n_eight_divides_nsq_minus_one : âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ",
      "âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n^2 - 1) ",
      "âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) ",
      "âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) "
    ]
  },
  {
    "docString": "Show that 2 is divisible by `(1 + i)^2` in `â„¤[i]`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n\",\n  \"isProp\": true,\n  \"docString\": \"The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. \"},\n {\"theorem\": \"âˆ€ {n : â„•} (self : Fin n), â†‘self < n\",\n  \"isProp\": true,\n  \"docString\": \"If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} {D : Type uâ‚‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D]\\n  (i : CategoryTheory.Functor D C) [inst_2 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_3 : CategoryTheory.CartesianClosed C],\\n  (âˆ€ (B : D) (A : C), (A âŸ¹ i.obj B) âˆˆ CategoryTheory.Functor.essImage i) â†’ CategoryTheory.ExponentialIdeal i\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show `i` is an exponential ideal it suffices to show that `A âŸ¹ iB` is \\\"in\\\" `D` for any `A` in\\n`C` and `B` in `D`.\\n\"},\n {\"theorem\":\n  \"âˆ€ (N : â„•) {j : â„},\\n  0 < j â†’\\n    âˆ€ {c : â„},\\n      1 < c â†’\\n        (Finset.sum (Finset.filter (fun x => j < â†‘âŒŠc ^ xâŒ‹â‚Š) (Finset.range N)) fun i => 1 / â†‘âŒŠc ^ iâŒ‹â‚Š ^ 2) â‰¤\\n          c ^ 5 * (c - 1)â»Â¹ ^ 3 / j ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of `1/âŒŠc^iâŒ‹â‚Š^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\\nconstant. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•},\\n  0 < n â†’\\n    âˆ€ (R : Type u_1) [inst : CommRing R],\\n      (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic i R) = Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\": \"`âˆ i in Nat.divisors n, cyclotomic i R = X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} [inst : NeZero n] (i : ZMod (2 * n)), orderOf (QuaternionGroup.a i) = 2 * n / Nat.gcd (2 * n) (ZMod.val i)\",\n  \"isProp\": true,\n  \"docString\": \"If `0 < n`, then `a i` has order `(2 * n) / gcd (2 * n) i`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : â„•},\\n  IsPrimitiveRoot Î¶ (2 ^ k) â†’\\n    2 â‰¤ k â†’\\n      âˆ€ [H : IsCyclotomicExtension {2 ^ k} K L],\\n        Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’ â†‘(Algebra.norm K) (Î¶ - 1) = 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`,\\nthen the norm of `Î¶ - 1` is `2`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : â„•},\\n  2 â‰¤ k â†’\\n    âˆ€ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],\\n      Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’ â†‘(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`,\\nthen the norm of `zeta (2 ^ k) K L - 1` is `2`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\\n  {Ï‡ : MulChar R â„¤},\\n  MulChar.IsQuadratic Ï‡ â†’\\n    âˆ€ {Ï‡' : MulChar R' â„¤},\\n      MulChar.IsQuadratic Ï‡' â†’\\n        âˆ€ [inst_3 : Nontrivial R''], ringChar R'' â‰  2 â†’ âˆ€ {a : R} {a' : R'}, â†‘(â†‘Ï‡ a) = â†‘(â†‘Ï‡' a') â†’ â†‘Ï‡ a = â†‘Ï‡' a'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two values of quadratic characters with target `â„¤` agree after coercion into a ring\\nof characteristic not `2`, then they agree in `â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2\",\n  \"isProp\": true,\n  \"docString\": \"An inequality involving `2`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’ (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then\\n`âˆ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {Ïƒ : Type u_1} (n : â„•) (Ï† : MvPolynomial Ïƒ â„¤),\\n  â†‘MvPolynomial.C â†‘n âˆ£ Ï† â†” â†‘(MvPolynomial.map (Int.castRingHom (ZMod n))) Ï† = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial over the integers is divisible by `n : â„•`\\nif and only if it is zero over `ZMod n`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"}]\n",
    "prompt_cons": "/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n :=\n\n/-- If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. -/\ntheorem âˆ€ {n : â„•} (self : Fin n), â†‘self < n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- To show `i` is an exponential ideal it suffices to show that `A âŸ¹ iB` is \"in\" `D` for any `A` in\n`C` and `B` in `D`. -/\ntheorem âˆ€ {C : Type uâ‚} {D : Type uâ‚‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D]\n  (i : CategoryTheory.Functor D C) [inst_2 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_3 : CategoryTheory.CartesianClosed C],\n  (âˆ€ (B : D) (A : C), (A âŸ¹ i.obj B) âˆˆ CategoryTheory.Functor.essImage i) â†’ CategoryTheory.ExponentialIdeal i :=\n\n/-- The sum of `1/âŒŠc^iâŒ‹â‚Š^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\nconstant. -/\ntheorem âˆ€ (N : â„•) {j : â„},\n  0 < j â†’\n    âˆ€ {c : â„},\n      1 < c â†’\n        (Finset.sum (Finset.filter (fun x => j < â†‘âŒŠc ^ xâŒ‹â‚Š) (Finset.range N)) fun i => 1 / â†‘âŒŠc ^ iâŒ‹â‚Š ^ 2) â‰¤\n          c ^ 5 * (c - 1)â»Â¹ ^ 3 / j ^ 2 :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- `âˆ i in Nat.divisors n, cyclotomic i R = X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•},\n  0 < n â†’\n    âˆ€ (R : Type u_1) [inst : CommRing R],\n      (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic i R) = Polynomial.X ^ n - 1 :=\n\n/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- If `0 < n`, then `a i` has order `(2 * n) / gcd (2 * n) i`. -/\ntheorem âˆ€ {n : â„•} [inst : NeZero n] (i : ZMod (2 * n)), orderOf (QuaternionGroup.a i) = 2 * n / Nat.gcd (2 * n) (ZMod.val i) :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1) :=\n\n/-- If `â€–râ€– < 1`, then `âˆ‘' n : â„•, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NormedField ğ•œ] [inst_1 : CompleteSpace ğ•œ] {r : ğ•œ},\n  â€–râ€– < 1 â†’ âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`,\nthen the norm of `Î¶ - 1` is `2`. -/\ntheorem âˆ€ {K : Type u} {L : Type v} [inst : Field L] {Î¶ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : â„•},\n  IsPrimitiveRoot Î¶ (2 ^ k) â†’\n    2 â‰¤ k â†’\n      âˆ€ [H : IsCyclotomicExtension {2 ^ k} K L],\n        Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’ â†‘(Algebra.norm K) (Î¶ - 1) = 2 :=\n\n/-- If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`,\nthen the norm of `zeta (2 ^ k) K L - 1` is `2`. -/\ntheorem âˆ€ {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : â„•},\n  2 â‰¤ k â†’\n    âˆ€ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],\n      Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’ â†‘(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2 :=\n\n/-- If two values of quadratic characters with target `â„¤` agree after coercion into a ring\nof characteristic not `2`, then they agree in `â„¤`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\n  {Ï‡ : MulChar R â„¤},\n  MulChar.IsQuadratic Ï‡ â†’\n    âˆ€ {Ï‡' : MulChar R' â„¤},\n      MulChar.IsQuadratic Ï‡' â†’\n        âˆ€ [inst_3 : Nontrivial R''], ringChar R'' â‰  2 â†’ âˆ€ {a : R} {a' : R'}, â†‘(â†‘Ï‡ a) = â†‘(â†‘Ï‡' a') â†’ â†‘Ï‡ a = â†‘Ï‡' a' :=\n\n/-- An inequality involving `2`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2 :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`âˆ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. -/\ntheorem âˆ€ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’ (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1 :=\n\n/-- A polynomial over the integers is divisible by `n : â„•`\nif and only if it is zero over `ZMod n`. -/\ntheorem âˆ€ {Ïƒ : Type u_1} (n : â„•) (Ï† : MvPolynomial Ïƒ â„¤),\n  â†‘MvPolynomial.C â†‘n âˆ£ Ï† â†” â†‘(MvPolynomial.map (Int.castRingHom (ZMod n))) Ï† = 0 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- Show that 2 is divisible by `(1 + i)^2` in `â„¤[i]`. -/\ntheorem",
    "choices": [
      "âˆ€ (x y : â„¤), (1 + (x * x - y * y) + (2 * x * y) * I) * (1 - (x * x - y * y) - (2 * x * y) * I) = 2 ",
      "IsSquare 2 ",
      "divisible_by_1_plus_i_sq : IsUnit (2 / ((1 + Complex.i) * (1 + Complex.i))) ",
      "Lean\n/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem sum_geometricâ‚‚ {n : â„•} : (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n ",
      "/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem sum_inv_two_pow_eq_two_mul_inv_two_pow (n : â„•) : (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n ",
      "/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem sum_inv_powers_of_two (n : â„•) : (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n ",
      "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Algebra â„¤ R], (1 + I) ^ 2 = 2 ",
      "divisible_by_one_plus_i_sq : IsUnit ((1 + I) ^ 2 : â„¤[i])â»Â¹ * 2 ",
      "div_two_by_one_plus_i_squared : (1 + I) * (1 + I) = 2 ",
      "div_two_one_add_i_squared : (1 + I) * (1 + I) = 2 "
    ]
  },
  {
    "docString": "Define `Î›(n) = log p` if `n` is a power of `p` and zero otherwise. Prove that `Î£_{d | n} Î¼(n / d) log d = Î›(n)`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R} {n : â„•},\\n  0 < n â†’\\n    IsPrimitiveRoot Î¶ n â†’\\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun Î¶ => Polynomial.X - â†‘Polynomial.C Î¶\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = âˆ (X - Î¼)`, where `Î¼`\\nvaries over the `n`-th roots of unity. \"},\n {\"theorem\":\n  \"âˆƒ c, âˆ€ (n : â„•), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) â‰¤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n â‰¤ 1/4 * âˆ‘' 1/k^2`  \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„}, 0 < a â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1)) (Real.log (1 + aâ»Â¹))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Expansion of `log (1 + aâ»Â¹)` as a series in powers of `1 / (2 * a + 1)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\\n  {Î¼ : MeasureTheory.Measure Î±},\\n  p â‰  0 â†’\\n    p â‰  âŠ¤ â†’\\n      âˆ€ {P : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ } â†’ Prop},\\n        (âˆ€ (c : E) {s : Set Î±} (hs : MeasurableSet s) (hÎ¼s : â†‘â†‘Î¼ s < âŠ¤),\\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : â†‘â†‘Î¼ s â‰  âŠ¤) c)) â†’\\n          (âˆ€ â¦ƒf g : MeasureTheory.SimpleFunc Î± Eâ¦„ (hf : MeasureTheory.Memâ„’p (â†‘f) p) (hg : MeasureTheory.Memâ„’p (â†‘g) p),\\n              Disjoint (Function.support â†‘f) (Function.support â†‘g) â†’\\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) â†’\\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) â†’\\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) â†’\\n            âˆ€ (f : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ }), P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary `Lp` simple function, with `0 < p < âˆ`, it suffices to show\\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\\nsets and is closed under addition (of functions with disjoint support). \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is left invariant under multiplication. \"},\n {\"theorem\": \"âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime that does not divide `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\\nand of `Î¼ ^ p` are the same. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\\n    MeasureTheory.Measure.IsMulRightInvariant Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `Î¼` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’\\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•},\\n      Nat.coprime m n â†’ Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly â„¤ Î¼)) (Î¼ ^ m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m : â„•` is coprime with `n`,\\nthen the minimal polynomial of a primitive `n`-th root of unity `Î¼`\\nhas `Î¼ ^ m` as root. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : MeasurableSpace X] [inst_2 : BorelSpace X] {dâ‚ dâ‚‚ : â„},\\n  dâ‚ < dâ‚‚ â†’\\n    âˆ€ (s : Set X),\\n      â†‘â†‘(MeasureTheory.Measure.hausdorffMeasure dâ‚‚) s = 0 âˆ¨ â†‘â†‘(MeasureTheory.Measure.hausdorffMeasure dâ‚) s = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `dâ‚ < dâ‚‚`, then for any set `s` we have either `Î¼H[dâ‚‚] s = 0`, or `Î¼H[dâ‚] s = âˆ`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (Ïˆ : AddChar R R') (n : â„•),\\n  Ïˆ ^ n = AddChar.mulShift Ïˆ â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is a natural number, then `Ïˆ ^ n = mulShift Ïˆ n`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [inst_1 : UniqueFactorizationMonoid Î±]\\n  [inst_2 : NormalizationMonoid Î±] [inst_3 : DecidableEq Î±] {x : Î±} {n : â„•}, factorization (x ^ n) = n â€¢ factorization x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `x^n` is `n` times the power in `x` \"},\n {\"theorem\":\n  \"âˆ€ {p : ENNReal} {Î¹ : Type u_2} [inst : Fintype Î¹] [inst_1 : Fact (1 â‰¤ p)] {Î² : Type u_1}\\n  [inst_2 : SeminormedAddCommGroup Î²],\\n  p â‰  âŠ¤ â†’\\n    âˆ€ (b : Î²),\\n      â€–â†‘(PiLp.equiv p fun x => Î²).symm (Function.const Î¹ b)â€–â‚Š = â†‘(Fintype.card Î¹) ^ ENNReal.toReal (1 / p) * â€–bâ€–â‚Š\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p = âˆ`, this lemma does not hold without the additional assumption `Nonempty Î¹` because\\nthe left-hand side simplifies to `0`, while the right-hand side simplifies to `â€–bâ€–â‚Š`. See\\n`PiLp.nnnorm_equiv_symm_const'` for a version which exchanges the hypothesis `p â‰  âˆ` for\\n`Nonempty Î¹`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : NormalSpace Î±]\\n  [inst_3 : BorelSpace Î±] {E : Type u_2} [inst_4 : NormedAddCommGroup E] {Î¼ : MeasureTheory.Measure Î±} {p : ENNReal}\\n  [inst_5 : NormedSpace â„ E] [inst_6 : MeasureTheory.Measure.OuterRegular Î¼],\\n  p â‰  âŠ¤ â†’\\n    âˆ€ {s u : Set Î±},\\n      IsClosed s â†’\\n        IsOpen u â†’\\n          s âŠ† u â†’\\n            â†‘â†‘Î¼ s â‰  âŠ¤ â†’\\n              âˆ€ (c : E) {Îµ : ENNReal},\\n                Îµ â‰  0 â†’\\n                  âˆƒ f,\\n                    Continuous f âˆ§\\n                      MeasureTheory.snorm (fun x => f x - Set.indicator s (fun _y => c) x) p Î¼ â‰¤ Îµ âˆ§\\n                        (âˆ€ (x : Î±), â€–f xâ€– â‰¤ â€–câ€–) âˆ§ Function.support f âŠ† u âˆ§ MeasureTheory.Memâ„’p f p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A variant of Urysohn's lemma, `â„’^p` version, for an outer regular measure `Î¼`:\\nconsider two sets `s âŠ† u` which are respectively closed and open with `Î¼ s < âˆ`, and a vector `c`.\\nThen one may find a continuous function `f` equal to `c` on `s` and to `0` outside of `u`,\\nbounded by `â€–câ€–` everywhere, and such that the `â„’^p` norm of `f - s.indicator (fun y â†¦ c)` is\\narbitrarily small. Additionally, this function `f` belongs to `â„’^p`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (E : Type u_2) {m0 : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup E]\\n  (p : ENNReal) {Î´ : ENNReal},\\n  Î´ â‰  0 â†’\\n    âˆƒ Î·,\\n      0 < Î· âˆ§\\n        âˆ€ (f g : Î± â†’ E),\\n          MeasureTheory.AEStronglyMeasurable f Î¼ â†’\\n            MeasureTheory.AEStronglyMeasurable g Î¼ â†’\\n              MeasureTheory.snorm f p Î¼ â‰¤ Î· â†’ MeasureTheory.snorm g p Î¼ â‰¤ Î· â†’ MeasureTheory.snorm (f + g) p Î¼ < Î´\",\n  \"isProp\": true,\n  \"docString\":\n  \"Technical lemma to control the addition of functions in `L^p` even for `p < 1`: Given `Î´ > 0`,\\nthere exists `Î·` such that two functions bounded by `Î·` in `L^p` have a sum bounded by `Î´`. One\\ncould take `Î· = Î´ / 2` for `p â‰¥ 1`, but the point of the lemma is that it works also for `p < 1`.\\n\"},\n {\"theorem\":\n  \"âˆ€ (Î¾ : â„) (n : â„•), Real.convergent Î¾ (n + 1) = â†‘âŒŠÎ¾âŒ‹ + (Real.convergent (Int.fract Î¾)â»Â¹ n)â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `(n+1)`th convergent of `Î¾` is the `n`th convergent of `1/(fract Î¾)`. \"},\n {\"theorem\": \"âˆ€ {p : â„}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges\\nif and only if `1 < p`. \"}]\n",
    "prompt_cons": "/-- If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = âˆ (X - Î¼)`, where `Î¼`\nvaries over the `n`-th roots of unity. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun Î¶ => Polynomial.X - â†‘Polynomial.C Î¶ :=\n\n/-- For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n â‰¤ 1/4 * âˆ‘' 1/k^2` -/\ntheorem âˆƒ c, âˆ€ (n : â„•), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) â‰¤ c :=\n\n/-- The minimal polynomial of a root of unity `Î¼` divides `X ^ n - 1`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.X ^ n - 1 :=\n\n/-- Expansion of `log (1 + aâ»Â¹)` as a series in powers of `1 / (2 * a + 1)`. -/\ntheorem âˆ€ {a : â„}, 0 < a â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1)) (Real.log (1 + aâ»Â¹)) :=\n\n/-- To prove something for an arbitrary `Lp` simple function, with `0 < p < âˆ`, it suffices to show\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\nsets and is closed under addition (of functions with disjoint support). -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\n  {Î¼ : MeasureTheory.Measure Î±},\n  p â‰  0 â†’\n    p â‰  âŠ¤ â†’\n      âˆ€ {P : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ } â†’ Prop},\n        (âˆ€ (c : E) {s : Set Î±} (hs : MeasurableSet s) (hÎ¼s : â†‘â†‘Î¼ s < âŠ¤),\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : â†‘â†‘Î¼ s â‰  âŠ¤) c)) â†’\n          (âˆ€ â¦ƒf g : MeasureTheory.SimpleFunc Î± Eâ¦„ (hf : MeasureTheory.Memâ„’p (â†‘f) p) (hg : MeasureTheory.Memâ„’p (â†‘g) p),\n              Disjoint (Function.support â†‘f) (Function.support â†‘g) â†’\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) â†’\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) â†’\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) â†’\n            âˆ€ (f : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ }), P f :=\n\n/-- An alternative way to prove that `Î¼` is left invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => g * h) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulLeftInvariant Î¼ :=\n\n/-- For any `p`, the power of `p` in `n^k` is `k` times the power in `n` -/\ntheorem âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n :=\n\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `Î¼`\nand of `Î¼ ^ p` are the same. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : â„•} [hprime : Fact (Nat.Prime p)],\n      Â¬p âˆ£ n â†’ minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p) :=\n\n/-- An alternative way to prove that `Î¼` is right invariant under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (Î¼ : MeasureTheory.Measure G),\n  (âˆ€ (g : G) (A : Set G), MeasurableSet A â†’ â†‘â†‘Î¼ ((fun h => h * g) â»Â¹' A) = â†‘â†‘Î¼ A) â†”\n    MeasureTheory.Measure.IsMulRightInvariant Î¼ :=\n\n/-- If `m : â„•` is coprime with `n`,\nthen the minimal polynomial of a primitive `n`-th root of unity `Î¼`\nhas `Î¼ ^ m` as root. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : CommRing K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’\n    âˆ€ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : â„•},\n      Nat.coprime m n â†’ Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly â„¤ Î¼)) (Î¼ ^ m) :=\n\n/-- If `dâ‚ < dâ‚‚`, then for any set `s` we have either `Î¼H[dâ‚‚] s = 0`, or `Î¼H[dâ‚] s = âˆ`. -/\ntheorem âˆ€ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : MeasurableSpace X] [inst_2 : BorelSpace X] {dâ‚ dâ‚‚ : â„},\n  dâ‚ < dâ‚‚ â†’\n    âˆ€ (s : Set X),\n      â†‘â†‘(MeasureTheory.Measure.hausdorffMeasure dâ‚‚) s = 0 âˆ¨ â†‘â†‘(MeasureTheory.Measure.hausdorffMeasure dâ‚) s = âŠ¤ :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- If `n` is a natural number, then `Ïˆ ^ n = mulShift Ïˆ n`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (Ïˆ : AddChar R R') (n : â„•),\n  Ïˆ ^ n = AddChar.mulShift Ïˆ â†‘n :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- For any `p`, the power of `p` in `x^n` is `n` times the power in `x` -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [inst_1 : UniqueFactorizationMonoid Î±]\n  [inst_2 : NormalizationMonoid Î±] [inst_3 : DecidableEq Î±] {x : Î±} {n : â„•}, factorization (x ^ n) = n â€¢ factorization x :=\n\n/-- When `p = âˆ`, this lemma does not hold without the additional assumption `Nonempty Î¹` because\nthe left-hand side simplifies to `0`, while the right-hand side simplifies to `â€–bâ€–â‚Š`. See\n`PiLp.nnnorm_equiv_symm_const'` for a version which exchanges the hypothesis `p â‰  âˆ` for\n`Nonempty Î¹`. -/\ntheorem âˆ€ {p : ENNReal} {Î¹ : Type u_2} [inst : Fintype Î¹] [inst_1 : Fact (1 â‰¤ p)] {Î² : Type u_1}\n  [inst_2 : SeminormedAddCommGroup Î²],\n  p â‰  âŠ¤ â†’\n    âˆ€ (b : Î²),\n      â€–â†‘(PiLp.equiv p fun x => Î²).symm (Function.const Î¹ b)â€–â‚Š = â†‘(Fintype.card Î¹) ^ ENNReal.toReal (1 / p) * â€–bâ€–â‚Š :=\n\n/-- A variant of Urysohn's lemma, `â„’^p` version, for an outer regular measure `Î¼`:\nconsider two sets `s âŠ† u` which are respectively closed and open with `Î¼ s < âˆ`, and a vector `c`.\nThen one may find a continuous function `f` equal to `c` on `s` and to `0` outside of `u`,\nbounded by `â€–câ€–` everywhere, and such that the `â„’^p` norm of `f - s.indicator (fun y â†¦ c)` is\narbitrarily small. Additionally, this function `f` belongs to `â„’^p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : NormalSpace Î±]\n  [inst_3 : BorelSpace Î±] {E : Type u_2} [inst_4 : NormedAddCommGroup E] {Î¼ : MeasureTheory.Measure Î±} {p : ENNReal}\n  [inst_5 : NormedSpace â„ E] [inst_6 : MeasureTheory.Measure.OuterRegular Î¼],\n  p â‰  âŠ¤ â†’\n    âˆ€ {s u : Set Î±},\n      IsClosed s â†’\n        IsOpen u â†’\n          s âŠ† u â†’\n            â†‘â†‘Î¼ s â‰  âŠ¤ â†’\n              âˆ€ (c : E) {Îµ : ENNReal},\n                Îµ â‰  0 â†’\n                  âˆƒ f,\n                    Continuous f âˆ§\n                      MeasureTheory.snorm (fun x => f x - Set.indicator s (fun _y => c) x) p Î¼ â‰¤ Îµ âˆ§\n                        (âˆ€ (x : Î±), â€–f xâ€– â‰¤ â€–câ€–) âˆ§ Function.support f âŠ† u âˆ§ MeasureTheory.Memâ„’p f p :=\n\n/-- Technical lemma to control the addition of functions in `L^p` even for `p < 1`: Given `Î´ > 0`,\nthere exists `Î·` such that two functions bounded by `Î·` in `L^p` have a sum bounded by `Î´`. One\ncould take `Î· = Î´ / 2` for `p â‰¥ 1`, but the point of the lemma is that it works also for `p < 1`. -/\ntheorem âˆ€ {Î± : Type u_1} (E : Type u_2) {m0 : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±) [inst : NormedAddCommGroup E]\n  (p : ENNReal) {Î´ : ENNReal},\n  Î´ â‰  0 â†’\n    âˆƒ Î·,\n      0 < Î· âˆ§\n        âˆ€ (f g : Î± â†’ E),\n          MeasureTheory.AEStronglyMeasurable f Î¼ â†’\n            MeasureTheory.AEStronglyMeasurable g Î¼ â†’\n              MeasureTheory.snorm f p Î¼ â‰¤ Î· â†’ MeasureTheory.snorm g p Î¼ â‰¤ Î· â†’ MeasureTheory.snorm (f + g) p Î¼ < Î´ :=\n\n/-- The `(n+1)`th convergent of `Î¾` is the `n`th convergent of `1/(fract Î¾)`. -/\ntheorem âˆ€ (Î¾ : â„) (n : â„•), Real.convergent Î¾ (n + 1) = â†‘âŒŠÎ¾âŒ‹ + (Real.convergent (Int.fract Î¾)â»Â¹ n)â»Â¹ :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges\nif and only if `1 < p`. -/\ntheorem âˆ€ {p : â„}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p :=\n\n/-- Define `Î›(n) = log p` if `n` is a power of `p` and zero otherwise. Prove that `Î£_{d | n} Î¼(n / d) log d = Î›(n)`. -/\ntheorem",
    "choices": [
      "âˆ€ {n : â„•}, (Finset.sum (Nat.divisors n) fun d => MoebiusFunction.moebius (n / d) * Real.log â†‘d) = Nat.ArithmeticFunction.logs.nat_apply n ",
      "âˆ€ (n : â„•), Finset.sum (Nat.divisors n) (fun d => Moebius.moebius (n / d) * Real.log d) = ite (Nat.PrimePow n) (Real.log (Nat.minFac n)) 0 ",
      "âˆ€ (n : â„•),\n  Finset.sum (Nat.divisors n) (fun d => Moebius.moebius d * Real.log d) = if n = 0 then 0 else Real.log (Nat.gcd n (Nat.minFac n)) ",
      "âˆ€ (n : â„•),\n  (Finset.sum (Nat.divisors n) (Î» d => (Î¼ n / d) * Real.log d)) = if h : âˆƒ p k, Nat.Prime p âˆ§ 0 < k âˆ§ p ^ k = n then Real.log (Classical.some h) else 0 ",
      "âˆ€ (n : â„•),\n  (Finset.sum (Nat.divisors n) fun d => Moebius.moebius d * (Real.log d)) = (if n = 0 then 0 else Nat.Prime.log (Nat.factorization n).support.prod) ",
      "âˆ€ (n : â„•), Finset.sum (Nat.divisors n) (fun d => Moebius.moebius d * Real.log d) = AddChar.Î› n ",
      "âˆ€ n : â„•, (âˆ‘ d in n.divisors, Moebius.moebiusFunction (n / d) * Real.log d) = if Nat.Prime (Nat.minFac n) âˆ§ n = Nat.minFac n ^ Nat.factorization n (Nat.minFac n) then Real.log (Nat.minFac n) else 0 ",
      "âˆ€ (n : â„•),\n  (Finset.sum (Nat.divisors n) fun d => Moebius.moebius d * Real.log (n / d)) = if n = 1 then 0 else Real.log (Nat.minFac n) ",
      "âˆ€ (n : â„•), Finset.sum (Finset.filter (Î» (d : â„•), d âˆ£ n) (Finset.range (n + 1))) (Î» (d : â„•), Moebius.moebius (n / d) * Real.log â†‘d) = ite (n = 1) 0 (Real.log (â†‘(Nat.minFac n))) ",
      "âˆ€ (n : â„•), (Finset.sum (Nat.divisors n) fun d => MoebiusFunction.moebius d * Real.log (â†‘(n / d))) = AddChar.logPow n "
    ]
  },
  {
    "docString": "Show that there are infinitely many primes congruent to `-1` modulo 6.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], â†‘(Nat.factorial (p - 1)) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {k : â„•} (n : â„•), k â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¡ 1 [MOD k]\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there exists an arbitrarily large prime `p` such that\\n`p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {m n : â„•}, Nat.coprime m n â†’ IsSquare (-1) â†’ IsSquare (-1) â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo coprime natural numbers `m` and `n`, then `-1` is also\\na square modulo `m*n`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"âˆ€ {l : List â„¤}, List.prod l = -1 â†’ -1 âˆˆ l\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product of integers is `-1`, then at least one factor must be `-1`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first modified cyclotomic polyomial is `X - 1`. \"}]\n",
    "prompt_cons": "/-- For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]} :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], â†‘(Nat.factorial (p - 1)) = -1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- For any positive `k : â„•` there exists an arbitrarily large prime `p` such that\n`p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•} (n : â„•), k â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¡ 1 [MOD k] :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- If `-1` is a square modulo coprime natural numbers `m` and `n`, then `-1` is also\na square modulo `m*n`. -/\ntheorem âˆ€ {m n : â„•}, Nat.coprime m n â†’ IsSquare (-1) â†’ IsSquare (-1) â†’ IsSquare (-1) :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1) :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- If a product of integers is `-1`, then at least one factor must be `-1`. -/\ntheorem âˆ€ {l : List â„¤}, List.prod l = -1 â†’ -1 âˆˆ l :=\n\n/-- The first cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- The first modified cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1 :=\n\n/-- Show that there are infinitely many primes congruent to `-1` modulo 6. -/\ntheorem",
    "choices": [
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ (-1) [MOD 6]} :",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ -1 [MOD 6]} "
    ]
  },
  {
    "docString": "Show that the equation `7x^3 + 2 = y^3` has no solution in integers.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x â‰  0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {l : Filter Î±} {f : Î± â†’ E},\\n  Filter.Tendsto (fun y => â€–f yâ€–) l Filter.atTop â†’ âˆ€ (x : E), âˆ€á¶  (y : Î±) in l, f y â‰  x\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–yâ€– â†’ âˆ`, then we can assume `y â‰  x` for any fixed `x`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d},\\n  0 < Pell.Solutionâ‚.x a â†’ 0 < Pell.Solutionâ‚.y a â†’ âˆ€ (n : â„•), 0 < Pell.Solutionâ‚.y (a ^ Nat.succ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `(x, y)` is a solution with `x` and `y` positive, then all its powers with positive\\nnatural exponents have positive `y`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d},\\n  0 < Pell.Solutionâ‚.x a â†’ 0 < Pell.Solutionâ‚.y a â†’ âˆ€ {n : â„¤}, 0 < n â†’ 0 < Pell.Solutionâ‚.y (a ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `(x, y)` is a solution with `x` and `y` positive, then all its powers with positive\\nexponents have positive `y`. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 0 < Pell.Solutionâ‚.x a â†’ âˆ€ (n : â„¤), 0 < Pell.Solutionâ‚.x (a ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `(x, y)` is a solution with `x` positive, then all its powers have positive `x`. \"},\n {\"theorem\": \"âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, a â‰  1 âˆ§ a â‰  -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `d` is a positive integer that is not a square, then there exists a nontrivial solution\\nto the Pell equation `x^2 - d*y^2 = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x â†’ minpoly A x â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F â‰  2 â†’ âˆ€ (a : F), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = a})) = â†‘(quadraticChar F) a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of solutions to `x^2 = a` is determined by the quadratic character. \"},\n {\"theorem\":\n  \"âˆ€ {p : Polynomial â„¤},\\n  Polynomial.IsUnitTrinomial p â†’\\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a b : Pell.Solutionâ‚ d},\\n  0 < Pell.Solutionâ‚.x a â†’\\n    0 < Pell.Solutionâ‚.y a â†’ 0 < Pell.Solutionâ‚.x b â†’ 0 < Pell.Solutionâ‚.y b â†’ 0 < Pell.Solutionâ‚.y (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of solutions with `x` and `y` positive is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : VAdd M Î±] [self : AddAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g +áµ¥ x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g +áµ¥ x = y`. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Disjoint (LinearMap.range (ExteriorAlgebra.Î¹ R)) 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The generators of the exterior algebra are disjoint from its scalars. \"},\n {\"theorem\":\n  \"âˆ€ {y : â„}, 0 < y â†’ Filter.Tendsto (fun x => x ^ (-y)) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `x ^ (-y)` tends to `0` at `+âˆ` for any positive real `y`. \"}]\n",
    "prompt_cons": "/-- A solution with `x > 1` must have `y â‰  0`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 1 < Pell.Solutionâ‚.x a â†’ Pell.Solutionâ‚.y a â‰  0 :=\n\n/-- A solution has `x â‰  0`. -/\ntheorem âˆ€ {d : â„¤}, 0 â‰¤ d â†’ âˆ€ (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a â‰  0 :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- If `â€–yâ€– â†’ âˆ`, then we can assume `y â‰  x` for any fixed `x`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {l : Filter Î±} {f : Î± â†’ E},\n  Filter.Tendsto (fun y => â€–f yâ€–) l Filter.atTop â†’ âˆ€ (x : E), âˆ€á¶  (y : Î±) in l, f y â‰  x :=\n\n/-- If `(x, y)` is a solution with `x` and `y` positive, then all its powers with positive\nnatural exponents have positive `y`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d},\n  0 < Pell.Solutionâ‚.x a â†’ 0 < Pell.Solutionâ‚.y a â†’ âˆ€ (n : â„•), 0 < Pell.Solutionâ‚.y (a ^ Nat.succ n) :=\n\n/-- If `(x, y)` is a solution with `x` and `y` positive, then all its powers with positive\nexponents have positive `y`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d},\n  0 < Pell.Solutionâ‚.x a â†’ 0 < Pell.Solutionâ‚.y a â†’ âˆ€ {n : â„¤}, 0 < n â†’ 0 < Pell.Solutionâ‚.y (a ^ n) :=\n\n/-- If `(x, y)` is a solution with `x` positive, then all its powers have positive `x`. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, 0 < Pell.Solutionâ‚.x a â†’ âˆ€ (n : â„¤), 0 < Pell.Solutionâ‚.x (a ^ n) :=\n\n/-- If `d` is a positive integer that is not a square, then there exists a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem âˆ€ {d : â„¤}, 0 < d â†’ Â¬IsSquare d â†’ âˆƒ a, a â‰  1 âˆ§ a â‰  -1 :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x â†’ minpoly A x â‰  0 :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x :=\n\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F â‰  2 â†’ âˆ€ (a : F), â†‘(Finset.card (Set.toFinset {x | x ^ 2 = a})) = â†‘(quadraticChar F) a + 1 :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem âˆ€ {p : Polynomial â„¤},\n  Polynomial.IsUnitTrinomial p â†’\n    (âˆ€ (z : â„‚), Â¬(â†‘(Polynomial.aeval z) p = 0 âˆ§ â†‘(Polynomial.aeval z) (Polynomial.mirror p) = 0)) â†’ Irreducible p :=\n\n/-- The set of solutions with `x` and `y` positive is closed under multiplication. -/\ntheorem âˆ€ {d : â„¤} {a b : Pell.Solutionâ‚ d},\n  0 < Pell.Solutionâ‚.x a â†’\n    0 < Pell.Solutionâ‚.y a â†’ 0 < Pell.Solutionâ‚.x b â†’ 0 < Pell.Solutionâ‚.y b â†’ 0 < Pell.Solutionâ‚.y (a * b) :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R â‰  2 â†’ 2 â‰  0 :=\n\n/-- There is `g` such that `g +áµ¥ x = y`. -/\ntheorem âˆ€ {M : Type u_1} {Î± : Type u_2} [inst : VAdd M Î±] [self : AddAction.IsPretransitive M Î±] (x y : Î±), âˆƒ g, g +áµ¥ x = y :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- The generators of the exterior algebra are disjoint from its scalars. -/\ntheorem âˆ€ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Disjoint (LinearMap.range (ExteriorAlgebra.Î¹ R)) 1 :=\n\n/-- The function `x ^ (-y)` tends to `0` at `+âˆ` for any positive real `y`. -/\ntheorem âˆ€ {y : â„}, 0 < y â†’ Filter.Tendsto (fun x => x ^ (-y)) Filter.atTop (nhds 0) :=\n\n/-- Show that the equation `7x^3 + 2 = y^3` has no solution in integers. -/\ntheorem",
    "choices": [
      "âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 ",
      "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "no_solution_7x3_plus_2_eq_y3 : âˆ€ (x y : â„¤), 7 * x^3 + 2 â‰  y^3 ",
      "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "no_solution_7x3_plus_2_eq_y3 : âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "âˆ€ {x y : â„¤}, 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "integers_7x3_plus_2_ne_y3 : âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "âˆ€ (x y : â„¤), 7 * x ^ 3 + 2 â‰  y ^ 3 ",
      "forall {x y : â„¤}, 7 * x^3 + 2 â‰  y^3 "
    ]
  },
  {
    "docString": "Let `p` and `q` be distinct odd primes such that `p - 1` divides `q - 1`. If `(n, pq) = 1`, show that `n^(q 1) â‰¡ 1 (mod pq)`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2) :=\n\n/-- Let `p` and `q` be distinct odd primes such that `p - 1` divides `q - 1`. If `(n, pq) = 1`, show that `n^(q 1) â‰¡ 1 (mod pq)`. -/\ntheorem",
    "choices": [
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] ",
      "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘(p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD â†‘(p * q)] ",
      "forall {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] ",
      "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘(p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (â†‘p * â†‘q)] ",
      "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„•}, IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [MOD (p * q)] ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ (n ^ (q - 1)) â‰¡ 1 [ZMOD (p * q)] ",
      "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  q â†’ p % 2 = 1 â†’ q % 2 = 1 â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘(p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD â†‘(p * q)] ",
      "âˆ€ {p q n : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ IsCoprime n (p * q) â†’ (n ^ (q - 1)) â‰¡ 1 [ZMOD (p * q)] ",
      "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„¤}, IsCoprime n (â†‘p * â†‘q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (â†‘p * â†‘q)] ",
      "âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ (p - 1) âˆ£ (q - 1) â†’ âˆ€ {n : â„•}, IsCoprime n (p * q) â†’ n ^ (q - 1) â‰¡ 1 [ZMOD (p * q)] "
    ]
  },
  {
    "docString": "Consider a prime `p` of the form `4t + 3`. Show that `a` is a primitive root modulo `p` if and only if `-a` has order `(p - 1) / 2`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 â†’ IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\\n`x` and `y`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p â‰  1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {a p k : â„•}, Nat.Prime p â†’ Â¬a âˆ£ p ^ k â†’ a âˆ£ p ^ (k + 1) â†’ a = p ^ (k + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime,\\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\\nthen `a = p^(k+1)`.\\n\"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. \"},\n {\"theorem\":\n  \"âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"}]\n",
    "prompt_cons": "/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 â†” Â¬IsSquare â†‘a :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 â†’ IsSquare â†‘a :=\n\n/-- If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\n`x` and `y`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3 :=\n\n/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- If `p` is prime,\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\nthen `a = p^(k+1)`. -/\ntheorem âˆ€ {a p k : â„•}, Nat.Prime p â†’ Â¬a âˆ£ p ^ k â†’ a âˆ£ p ^ (k + 1) â†’ a = p ^ (k + 1) :=\n\n/-- We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2) :=\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/\ntheorem âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b) :=\n\n/-- Consider a prime `p` of the form `4t + 3`. Show that `a` is a primitive root modulo `p` if and only if `-a` has order `(p - 1) / 2`. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„•}, p % 4 = 3 â†’ a.gcd p = 1 â†’ \n  (âˆ€ (x : â„•), ZMod.p_unit a ^ x â‰  1) â†” (âˆ€ (x : â„•), x < (p - 1) / 2 â†’ ZMod.p_unit (-a) ^ x â‰  1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] (a : â„•), p % 4 = 3 â†’ (is_primitive_root a p â†” order_of (-a) = (p - 1) / 2) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), p % 4 = 3 â†’ (is_primitive_root a p â†” order_of (-a) = (p - 1) / 2) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ âˆ€ {a : â„•}, IsPrimitiveRoot a p â†” orderOf (-a : ZMod p) = (p - 1) / 2 ",
      "âˆ€ {p a : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ (nat_primitive_root a p â†” order_of (-a) = (p - 1) / 2) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£),\n  p % 4 = 3 â†’ is_primitive_root a (p - 1) â†” order_of (-a) = (p - 1) / 2 ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ âˆ€ {a : â„•}, ZMod.isPrimitiveRoot a p â†” ZMod.isPrimitiveRoot (-a) ((p - 1) / 2) ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ âˆ€ (a : ZMod p), a.is_primitive_root â†” ((-a) ^ ((p - 1) / 2) â‰  1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„•}, p % 4 = 3 â†’ IsPrimitiveRoot a p â†” order_of (Units.mk (-a) (-a) (a * -a) sorry) = (p - 1) / 2 ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p % 4 = 3 â†’ âˆ€ (a : â„•), Nat.Coprime a p â†’ is_primitive_root a p â†” order_of (-a) = (p - 1) / 2 "
    ]
  },
  {
    "docString": "Let `p` be an odd prime. Show that `a` is a primitive root modulo `p` if and only if `a^((p - 1) / q) â‰¢ 1 (mod p)` for all prime divisors `q` of `p - 1`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p â‰  1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p = 1 â†’ â†‘a â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 â†’ IsSquare â†‘a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p â†’ (p âˆ£ List.prod L â†” âˆƒ a, a âˆˆ L âˆ§ p âˆ£ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Prime `p` divides the product of a list `L` iff it divides some `a âˆˆ L` \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. \"},\n {\"theorem\":\n  \"âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"theorem\":\n  \"âˆ€ {a p k : â„•}, Nat.Prime p â†’ Â¬a âˆ£ p ^ k â†’ a âˆ£ p ^ (k + 1) â†’ a = p ^ (k + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime,\\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\\nthen `a = p^(k+1)`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ {p a b : â„•}, Nat.coprime a b â†’ p âˆˆ Nat.factors a â†’ â†‘(Nat.factorization (a * b)) p = â†‘(Nat.factorization a) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then the power of `p` in `a` is the same that in `a * b`,\\nfor any `b` coprime to `a`. \"}]\n",
    "prompt_cons": "/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p â‰  1`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [pp : Fact (Nat.Prime p)], â†‘a = 0 â†” Int.gcd a â†‘p â‰  1 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p = 1 â†’ â†‘a â‰  0 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem âˆ€ {a : â„¤} {p : â„•} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 â†’ IsSquare â†‘a :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0 :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p â‰  0 â†’ âˆ€ {a : R} {n : â„•}, n â‰¤ Polynomial.rootMultiplicity a p â†” (Polynomial.X - â†‘Polynomial.C a) ^ n âˆ£ p :=\n\n/-- Prime `p` divides the product of a list `L` iff it divides some `a âˆˆ L` -/\ntheorem âˆ€ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p â†’ (p âˆ£ List.prod L â†” âˆƒ a, a âˆˆ L âˆ§ p âˆ£ a) :=\n\n/-- If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1 :=\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/\ntheorem âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b) :=\n\n/-- If `p` is prime,\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\nthen `a = p^(k+1)`. -/\ntheorem âˆ€ {a p k : â„•}, Nat.Prime p â†’ Â¬a âˆ£ p ^ k â†’ a âˆ£ p ^ (k + 1) â†’ a = p ^ (k + 1) :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem âˆ€ {p q : â„•} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p â‰  q â†’ padicNorm p â†‘q = 1 :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- If `p` is a prime factor of `a` then the power of `p` in `a` is the same that in `a * b`,\nfor any `b` coprime to `a`. -/\ntheorem âˆ€ {p a b : â„•}, Nat.coprime a b â†’ p âˆˆ Nat.factors a â†’ â†‘(Nat.factorization (a * b)) p = â†‘(Nat.factorization a) p :=\n\n/-- Let `p` be an odd prime. Show that `a` is a primitive root modulo `p` if and only if `a^((p - 1) / q) â‰¢ 1 (mod p)` for all prime divisors `q` of `p - 1`. -/\ntheorem",
    "choices": [
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„•}, a â‰  0 â†’ Nat.gcd a p = 1 â†’ (âˆ€ q, Nat.Prime q â†’ q âˆ£ p - 1 â†’ Â¬(a ^ ((p - 1) / q) â‰¡ 1 [MOD p])) â†” IsPrimitiveRoot a p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, IsPrimitiveRoot a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, (âˆ€ q, Nat.Prime q â†’ q âˆ£ (p - 1) â†’ a ^ ((p - 1) / q) â‰  1) â†” isPrimitiveRoot a (p - 1) ",
      "forall {p : â„•} [hp : Fact (Nat.Prime p)], p â‰  2 â†’ âˆ€ {a : ZMod p},\n  a.is_primitive_root p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„•}, a â‰  0 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†” is_primitive_root a p ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ {a : ZMod p}, IsPrimitiveRoot a p â†” (âˆ€ q : â„•, Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) ",
      "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ (a : â„•), is_primitive_root a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ (p - 1) â†’ a ^ ((p - 1) / q) â‰  1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ âˆ€ {a : â„•}, IsPrimitiveRoot a p â†” (âˆ€ q, Nat.Prime q â†’ q âˆ£ p - 1 â†’ Â¬pow_mod a ((p - 1) / q) p = 1) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, p â‰  2 â†’ (Nat.PrimeRoot a p â†” (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1)) ",
      "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†” Nat.primeRoot a "
    ]
  },
  {
    "docString": "Show that any prime divisor of `x^4 - x^2 + 1` is congruent to 1 modulo 12.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first modified cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare (-1) â†” Fintype.card F % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `F` iff `#F` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\\nof two squares. Also known as **Fermat's Christmas theorem**. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\": \"âˆ€ {x k l : â„•}, 1 < x â†’ (x ^ k âˆ£ x ^ l â†” k â‰¤ l)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {m n : â„•}, Nat.coprime m n â†’ IsSquare (-1) â†’ IsSquare (-1) â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo coprime natural numbers `m` and `n`, then `-1` is also\\na square modulo `m*n`. \"}]\n",
    "prompt_cons": "/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The first modified cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1 :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The first cyclotomic polyomial is `X - 1`. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1 :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (x : (ZMod p)Ë£), (âˆƒ y, y ^ 2 = x) â†” x ^ (p / 2) = 1 :=\n\n/-- `-1` is a square in `F` iff `#F` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare (-1) â†” Fintype.card F % 4 â‰  3 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem âˆ€ {d : â„¤} (a : Pell.Solutionâ‚ d), Pell.Solutionâ‚.x a ^ 2 - d * Pell.Solutionâ‚.y a ^ 2 = 1 :=\n\n/-- If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`. -/\ntheorem âˆ€ {x k l : â„•}, 1 < x â†’ (x ^ k âˆ£ x ^ l â†” k â‰¤ l) :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ (IsSquare a â†” a ^ (p / 2) = 1) :=\n\n/-- If `-1` is a square modulo coprime natural numbers `m` and `n`, then `-1` is also\na square modulo `m*n`. -/\ntheorem âˆ€ {m n : â„•}, Nat.coprime m n â†’ IsSquare (-1) â†’ IsSquare (-1) â†’ IsSquare (-1) :=\n\n/-- Show that any prime divisor of `x^4 - x^2 + 1` is congruent to 1 modulo 12. -/\ntheorem",
    "choices": [
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x^4 - x^2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ (x ^ 4 - x ^ 2 + 1) â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•} [inst : Fact (Nat.Prime p)], p âˆ£ (x ^ 4 - x ^ 2 + 1) â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x^4 - x^2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•} (hp : Nat.Prime p), p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 ",
      "âˆ€ {x p : â„•}, Nat.Prime p â†’ p âˆ£ x ^ 4 - x ^ 2 + 1 â†’ p % 12 = 1 "
    ]
  },
  {
    "docString": "Show that if `a` is negative, then `p â‰¡ q (4a)` together with `p âˆ¤ a` imply `(a / p) = (a / q)`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y â‰  0 â†’ x ^ 2 = -y ^ 2 â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The square of the symbol is 1 if `p âˆ¤ a`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p (a ^ 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\\n`x` and `y`. \"},\n {\"theorem\": \"âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] {q : â„š}, padicNorm p q = 0 â†’ q = 0\",\n  \"isProp\": true,\n  \"docString\": \"If the `p`-adic norm of `q` is 0, then `q` is `0`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. \"}]\n",
    "prompt_cons": "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ legendreSym q â†‘p = -legendreSym p â†‘q :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ legendreSym q â†‘p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p â†‘q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p â‰  2 â†’ q â‰  2 â†’ p â‰  q â†’ legendreSym q â†‘p * legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- **Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p] :=\n\n/-- If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y â‰  0 â†’ x ^ 2 = -y ^ 2 â†’ p % 4 â‰  3 :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 â†’ q â‰  2 â†’ (IsSquare â†‘q â†” IsSquare â†‘p) :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p - 1) = 1 :=\n\n/-- If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a â‰  0 â†’ a ^ (p / 2) = 1 âˆ¨ a ^ (p / 2) = -1 :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 â†’ q % 4 = 3 â†’ p â‰  q â†’ (IsSquare â†‘q â†” Â¬IsSquare â†‘p) :=\n\n/-- We have the congruence `legendreSym p a â‰¡ a ^ (p / 2) mod p`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : â„¤), â†‘(legendreSym p a) = â†‘a ^ (p / 2) :=\n\n/-- The square of the symbol is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1 :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p (a ^ 2) = 1 :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem âˆ€ (p : â„•) (a : ZMod p), a ^ (p - 1) = 1 â†’ (âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) â†’ Nat.Prime p :=\n\n/-- If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\n`x` and `y`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {a : â„¤},\n  jacobiSym a p = -1 â†’ âˆ€ {x y : â„¤}, â†‘p âˆ£ x ^ 2 - a * y ^ 2 â†’ â†‘p âˆ£ x âˆ§ â†‘p âˆ£ y :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p â‰  1`, then `a : ZMod p` is zero. -/\ntheorem âˆ€ {a : â„¤} {p : â„•}, Nat.Prime p â†’ Int.gcd a â†‘p â‰  1 â†’ â†‘a = 0 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (a : (ZMod p)Ë£), a ^ (p - 1) = 1 :=\n\n/-- If the `p`-adic norm of `q` is 0, then `q` is `0`. -/\ntheorem âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] {q : â„š}, padicNorm p q = 0 â†’ q = 0 :=\n\n/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem âˆ€ {a : â„¤} {n : â„•}, jacobiSym a n = -1 â†’ âˆƒ p x, p âˆ£ n âˆ§ jacobiSym a p = -1 :=\n\n/-- Show that if `a` is negative, then `p â‰¡ q (4a)` together with `p âˆ¤ a` imply `(a / p) = (a / q)`. -/\ntheorem",
    "choices": [
      "âˆ€ {a : â„¤} {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p â‰¡ q [ZMOD 4 * a] â†’ â†‘a % â†‘p â‰  0 â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "/-- If `a` is negative, then `p â‰¡ q (4a)` together with `p âˆ¤ a` imply `(a / p) = (a / q)`. -/\ntheorem âˆ€ {a : â„¤} {p q : â„•}, a < 0 â†’ p % (4 * -a) = q % (4 * -a) â†’ Â¬â†‘p âˆ£ a â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a p q : â„¤}, a < 0 â†’ p % (4 * a) = q % (4 * a) â†’ Â¬â†‘p âˆ£ a â†’ legendreSym a p = legendreSym a q ",
      "âˆ€ {p q a : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % (4 * a) = q % (4 * a) â†’ Â¬p âˆ£ a â†’ legendreSym a p = legendreSym a q ",
      "âˆ€ {a : â„¤} {p q : â„•} [Fact (Nat.Prime p)] [Fact (Nat.Prime q)],\n  a < 0 â†’ p % (4 * a) = q % (4 * a) â†’ â†‘p âˆ£ a â†’ â†‘q âˆ£ a â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a : â„¤} {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p % (4 * a) = q % (4 * a) â†’ Â¬(â†‘p âˆ£ a) â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a : â„¤} {p q : â„•}, a < 0 â†’ p % (4 * -a) = q % (4 * -a) â†’ â†‘p âˆ£ a â†’ â†‘q âˆ£ a â†’ legendreSym p a = legendreSym q a ",
      "âˆ€ {a p q : â„¤},\n  a < 0 â†’ p % (4 * a) = q % (4 * a) â†’ Â¬p âˆ£ a â†’ Â¬q âˆ£ a â†’ legendreSym a p = legendreSym a q ",
      "âˆ€ {a : â„¤} {p q : â„•} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  a < 0 â†’ (p % (4 * -a) = q % (4 * -a)) â†’ Â¬(â†‘p âˆ£ a) â†’ legendreSym a â†‘p = legendreSym a â†‘q ",
      "âˆ€ {a : â„¤} {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 â†’ p â‰¡ q [ZMOD 4 * a] â†’ Â¬p âˆ£ a â†’ legendreSym a â†‘p = legendreSym a â†‘q "
    ]
  },
  {
    "docString": "Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2\",\n  \"isProp\": true,\n  \"docString\": \"An inequality involving `2`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b â†’\\n    1 â‰¤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the integer parts of the continued fraction are at least one. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal b a c\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. \"},\n {\"theorem\": \"âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ {m n : â„•+}, PNat.factorMultiset m â‰¤ PNat.factorMultiset n â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"We now have four different results that all encode the\\nidea that inequality of multisets corresponds to divisibility\\nof positive integers. \"},\n {\"theorem\": \"âˆ€ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note that most of the lemmas about powers of two refer to it as `sq`. \"},\n {\"theorem\":\n  \"âˆ€ {x y z : â„¤},\\n  PythagoreanTriple x y z â†’\\n    (PythagoreanTriple x y z â†”\\n      âˆƒ k m n,\\n        (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§\\n          (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2)))\",\n  \"isProp\": true,\n  \"docString\": \"**Formula for Pythagorean Triples** \"},\n {\"theorem\":\n  \"âˆ€ (n : â„¤), â†‘ZMod.Ï‡â‚„ â†‘n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1\",\n  \"isProp\": true,\n  \"docString\": \"An explicit description of `Ï‡â‚„` on integers / naturals \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two finite adÃ¨les is a finite adÃ¨le. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 :=\n\n/-- An inequality involving `2`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2 :=\n\n/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b â†’\n    1 â‰¤ b :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ Fermat42.Minimal b a c :=\n\n/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42.Minimal a b c â†’ IsCoprime a b :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- We now have four different results that all encode the\nidea that inequality of multisets corresponds to divisibility\nof positive integers. -/\ntheorem âˆ€ {m n : â„•+}, PNat.factorMultiset m â‰¤ PNat.factorMultiset n â†” m âˆ£ n :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem âˆ€ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a :=\n\n/-- **Formula for Pythagorean Triples** -/\ntheorem âˆ€ {x y z : â„¤},\n  PythagoreanTriple x y z â†’\n    (PythagoreanTriple x y z â†”\n      âˆƒ k m n,\n        (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§\n          (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2))) :=\n\n/-- An explicit description of `Ï‡â‚„` on integers / naturals -/\ntheorem âˆ€ (n : â„¤), â†‘ZMod.Ï‡â‚„ â†‘n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1 :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem âˆ€ {a b c : â„¤}, Fermat42 a b c â†’ âˆƒ a0 b0 c0, Fermat42.Minimal a0 b0 c0 âˆ§ a0 % 2 = 1 :=\n\n/-- The sum of two finite adÃ¨les is a finite adÃ¨le. -/\ntheorem âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  {x y : DedekindDomain.ProdAdicCompletions R K},\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y) :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways. -/\ntheorem",
    "choices": [
      "â„•.smallest_two_diff_cube_sum_two_ways : âˆƒ a b c d, a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 âˆ§ a â‰  c âˆ§ 0 < a âˆ§ a < b âˆ§ c < d âˆ§ 0 < c âˆ§ a ^ 3 + b ^ 3 = 1729 ",
      "Exists.intro (1729 : â„•) (id (Iff.mpr And.intro (Iff.mpr Int.eq_or_eq_neg (Or.intro (Exists.intro 1 (Exists.intro 12 (Exists.intro 9 (Exists.intro 10 (And.intro (add_eq_of_eq_sub (Eq.symm (Eq.mpr (eq_self_iff_true (1 * 1 * 1 + 12 * 12 * 12 - 9 * 9 * 9 - 10 * 10 * 10)) trivial))) (Or.intro (Exists.intro (-1) (Exists.intro (-12) (Exists.intro (-9) (Exists.intro (-10) (And.intro (Eq.trans (neg_add_neg (1 * 1 * 1) (12 * 12 * 12)) (Eq.trans (neg_add_neg (9 * 9 * 9) (10 * 10 * 10)) rfl)) trivial))))) trivial)))))) (Exists.intro 1 (Exists.intro 10 (Exists.intro 9 (Exists.intro 12 (And.intro (add_eq_of_eq_sub (Eq.symm (Eq.mpr (eq_self_iff_true (1 * 1 * 1 + 10 * 10 * 10 - 9 * 9 * 9 - 12 * 12 * 12)) trivial))) (Or.intro (Exists.intro (-1) (Exists.intro (-10) (Exists.intro (-9) (Exists.intro (-12) (And.intro (Eq.trans (neg_add_neg (1 * 1 * 1) (10 * 10 * 10)) (Eq.trans (neg_add_neg (9 * 9 * 9) (12 * 12 * 12)) rfl)) trivial))))) trivial))))))) (Eq.mpr (propext Nat.lt_one_add_iff_ne_zero) (Eq.mpr (propext not_false_iff) trivial))))",
      "âŠ¢ âˆƒ x1 y1 x2 y2 : â„¤, x1 â‰  x2 âˆ§ y1 â‰  y2 âˆ§ x1 ^ 3 + y1 ^ 3 = x2 ^ 3 + y2 ^ 3 âˆ§ 0 < x1 ^ 3 + y1 ^ 3 âˆ§ âˆ€ k : â„•, k < 1729 â†’ Â¬(âˆƒ x y : â„¤, x â‰  y âˆ§ x ^ 3 + y ^ 3 = â†‘k) ",
      "Int.eq 1729 ((1 : â„¤) ^ 3 + 12 ^ 3) (9 ^ 3 + 10 ^ 3) ",
      "Int1729 ",
      "â„•.smallest_1729 ",
      "Lean.isSmallInt 1729 â†’ âˆƒ p q r s : â„¤, p â‰  q âˆ§ r â‰  s âˆ§ p ^ 3 + r ^ 3 = 1729 âˆ§ q ^ 3 + s ^ 3 = 1729 ",
      "Nat.min_fac_eq 1729 ",
      "smallest_1729 : âˆƒ x1 y1 x2 y2, x1 â‰  x2 âˆ§ y1 â‰  y2 âˆ§ x1 ^ 3 + y1 ^ 3 = x2 ^ 3 + y2 ^ 3 âˆ§ x1 ^ 3 + y1 ^ 3 = 1729 ",
      "Int1729IsSmallest "
    ]
  },
  {
    "docString": "Suppose that `f` is holomorphic in an open set `Î©`. Prove that if `Re(f)` is constant, then `f` is constant.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\\nfor some value `v`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\\n  AnalyticOn â„‚ g U â†’\\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `â„‚`). \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {G : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace ğ•œ G]\\n  {f : ğ•œ â†’ G}, Differentiable ğ•œ f â†’ (âˆ€ (x : ğ•œ), deriv f x = 0) â†’ âˆ€ (x y : ğ•œ), f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ğ•œ â†’ G`, `ğ•œ = R` or `ğ•œ = â„‚`, is differentiable everywhere and its derivative equal zero,\\nthen it is a constant function. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] {X Y : C}\\n  {f : X âŸ¶ Y}, f = 0 â†’ âˆ€ [inst_4 : CategoryTheory.Limits.HasImage f], CategoryTheory.Limits.image.Î¹ f = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If we know `f = 0`,\\nit requires a little work to conclude `image.Î¹ f = 0`,\\nbecause `f = g` only implies `image f â‰… image g`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î³ : Type u_1} [inst : UniformSpace Î±] {f : Î± â†’ Î³} [inst_1 : TopologicalSpace Î³] [inst_2 : Zero Î³],\\n  HasCompactSupport f â†’ Filter.Tendsto f (Filter.cocompact Î±) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` has compact support, then `f` tends to zero at infinity.\"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚}, AnalyticAt â„‚ f zâ‚€ â†’ (âˆ€á¶  (z : â„‚) in nhds zâ‚€, f z = f zâ‚€) âˆ¨ nhds (f zâ‚€) â‰¤ Filter.map f (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : â„‚ â†’ â„‚` which is analytic at a point `zâ‚€` is either constant in a neighborhood\\nof `zâ‚€`, or behaves locally like an open function (in the sense that the image of every neighborhood\\nof `zâ‚€` is a neighborhood of `f zâ‚€`, as in `isOpenMap_iff_nhds_le`). For a function `f : E â†’ â„‚`\\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’\\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\\n  0 < r â†’\\n    r â‰¤ R â†’\\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\\n        Set.Countable s â†’\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) â†’\\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology Î±] [inst_3 : OpensMeasurableSpace Î±] {f : Î± â†’ Î±}\\n  {Î¼ : MeasureTheory.Measure Î±},\\n  MeasureTheory.Conservative f Î¼ â†’ âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€ (s : Set Î±), s âˆˆ nhds x â†’ âˆƒá¶  (n : â„•) in Filter.atTop, f^[n] x âˆˆ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"PoincarÃ© recurrence theorem. Let `f : Î± â†’ Î±` be a conservative dynamical system on a topological\\nspace with second countable topology and measurable open sets. Then almost every point `x : Î±`\\nis recurrent: it visits every neighborhood `s âˆˆ ğ“ x` infinitely many times. \"}]\n",
    "prompt_cons": "/-- If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\nfor some value `v`. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `â„‚`). -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\n  AnalyticOn â„‚ g U â†’\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s) :=\n\n/-- If `f : ğ•œ â†’ G`, `ğ•œ = R` or `ğ•œ = â„‚`, is differentiable everywhere and its derivative equal zero,\nthen it is a constant function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {G : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace ğ•œ G]\n  {f : ğ•œ â†’ G}, Differentiable ğ•œ f â†’ (âˆ€ (x : ğ•œ), deriv f x = 0) â†’ âˆ€ (x y : ğ•œ), f x = f y :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If we know `f = 0`,\nit requires a little work to conclude `image.Î¹ f = 0`,\nbecause `f = g` only implies `image f â‰… image g`. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] {X Y : C}\n  {f : X âŸ¶ Y}, f = 0 â†’ âˆ€ [inst_4 : CategoryTheory.Limits.HasImage f], CategoryTheory.Limits.image.Î¹ f = 0 :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t :=\n\n/-- The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€) :=\n\n/-- If `f` has compact support, then `f` tends to zero at infinity. -/\ntheorem âˆ€ {Î± : Type u_2} {Î³ : Type u_1} [inst : UniformSpace Î±] {f : Î± â†’ Î³} [inst_1 : TopologicalSpace Î³] [inst_2 : Zero Î³],\n  HasCompactSupport f â†’ Filter.Tendsto f (Filter.cocompact Î±) (nhds 0) :=\n\n/-- A function `f : â„‚ â†’ â„‚` which is analytic at a point `zâ‚€` is either constant in a neighborhood\nof `zâ‚€`, or behaves locally like an open function (in the sense that the image of every neighborhood\nof `zâ‚€` is a neighborhood of `f zâ‚€`, as in `isOpenMap_iff_nhds_le`). For a function `f : E â†’ â„‚`\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚}, AnalyticAt â„‚ f zâ‚€ â†’ (âˆ€á¶  (z : â„‚) in nhds zâ‚€, f z = f zâ‚€) âˆ¨ nhds (f zâ‚€) â‰¤ Filter.map f (nhds zâ‚€) :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S :=\n\n/-- If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\nequal to each other. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\n  0 < r â†’\n    r â‰¤ R â†’\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\n        Set.Countable s â†’\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) â†’\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\ Metric.closedBall c r) \\ s â†’ DifferentiableAt â„‚ f z) â†’\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z :=\n\n/-- PoincarÃ© recurrence theorem. Let `f : Î± â†’ Î±` be a conservative dynamical system on a topological\nspace with second countable topology and measurable open sets. Then almost every point `x : Î±`\nis recurrent: it visits every neighborhood `s âˆˆ ğ“ x` infinitely many times. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±]\n  [inst_2 : TopologicalSpace.SecondCountableTopology Î±] [inst_3 : OpensMeasurableSpace Î±] {f : Î± â†’ Î±}\n  {Î¼ : MeasureTheory.Measure Î±},\n  MeasureTheory.Conservative f Î¼ â†’ âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€ (s : Set Î±), s âˆˆ nhds x â†’ âˆƒá¶  (n : â„•) in Filter.atTop, f^[n] x âˆˆ s :=\n\n/-- Suppose that `f` is holomorphic in an open set `Î©`. Prove that if `Re(f)` is constant, then `f` is constant. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F} {Î© : Set E}, IsOpen Î© â†’ DifferentiableOn â„‚ f Î© â†’\n    (âˆ€ (x y : E), x âˆˆ Î© â†’ y âˆˆ Î© â†’ (f x).re = (f y).re) â†’ âˆ€ (x y : E), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y ",
      "forall {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set â„‚} {f : â„‚ â†’ E},\n  DifferentiableOn â„‚ f Î© â†’\n    IsOpen Î© â†’\n      (âˆ€ (x : â„‚), x âˆˆ Î© â†’ âˆ€ (y : â„‚), y âˆˆ Î© â†’ (f x).re = (f y).re) â†’\n        âˆ€ (x : â„‚), x âˆˆ Î© â†’ âˆ€ (y : â„‚), y âˆˆ Î© â†’ f x = f y ",
      "forall {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ â„‚) f U â†’\n    IsOpen U â†’ Set.EqOn (â‡‘ContinuousLinearMap.reClm âˆ˜ f) (Function.const M (â‡‘ContinuousLinearMap.reClm (f (Classical.arbitrary M)))) U â†’\n      Set.EqOn f (Function.const M (f (Classical.arbitrary M))) U ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {Î© : Set â„‚},\n  DifferentiableOn â„‚ f Î© â†’ IsOpen Î© â†’ (âˆ€ {x : â„‚}, x âˆˆ Î© â†’ âˆ€ {y : â„‚}, y âˆˆ Î© â†’ Re (f x) = Re (f y)) â†’ âˆ€ (x y : â„‚), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {Î© : Set â„‚},\n  IsOpen Î© â†’ DifferentiableOn â„‚ f Î© â†’ (âˆ€ (z : â„‚), z âˆˆ Î© â†’ (f z).re = (f (Classical.some _)).re) â†’ âˆƒ c, âˆ€ (z : â„‚), z âˆˆ Î© â†’ f z = c ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {Î© : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f Î© â†’ IsOpen Î© â†’ (âˆ€ (z : â„‚), z âˆˆ Î© â†’ (f z).re = (f Î©.some).re) â†’ âˆ€ (z : â„‚), z âˆˆ Î© â†’ f z = f Î©.some ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {s : Set E} {f : E â†’ F},\n  DifferentiableOn â„‚ f s â†’ IsOpen s â†’ (âˆ€ (x : E), x âˆˆ s â†’ (f x).re = (f x).im) â†’ âˆ€ (a b : E), a âˆˆ s â†’ b âˆˆ s â†’ f a = f b ",
      "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set E} {f : E â†’ â„‚},\n  DifferentiableOn â„‚ f Î© â†’ IsOpen Î© â†’ (âˆ€ (x : E), x âˆˆ Î© â†’ (f x).re = (f x).re) â†’ âˆ€ (x y : E), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F} {Î© : Set E},\n  DifferentiableOn â„‚ f Î© â†’\n    IsOpen Î© â†’ (âˆ€ {x y : E}, x âˆˆ Î© â†’ y âˆˆ Î© â†’ (f x).re = (f y).re) â†’ âˆ€ {x y : E}, x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y ",
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ â„‚) f U â†’\n    IsOpen U â†’ IsPreconnected U â†’ (âˆ€ x âˆˆ U, (f x).re = 0) â†’ âˆ€ x y âˆˆ U, f x = f y "
    ]
  },
  {
    "docString": "Suppose that `f` is holomorphic in an open set `Î©`. Prove that if `|f|` is constant, then `f` is constant.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\\n  AnalyticOn â„‚ g U â†’\\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `â„‚`). \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\\nfor some value `v`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {G : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace ğ•œ G]\\n  {f : ğ•œ â†’ G}, Differentiable ğ•œ f â†’ (âˆ€ (x : ğ•œ), deriv f x = 0) â†’ âˆ€ (x y : ğ•œ), f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ğ•œ â†’ G`, `ğ•œ = R` or `ğ•œ = â„‚`, is differentiable everywhere and its derivative equal zero,\\nthen it is a constant function. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ ENNReal},\\n  âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ€ {Îµ : ENNReal}, Îµ â‰  0 â†’ âˆƒ Î´, Î´ > 0 âˆ§ âˆ€ (s : Set Î±), â†‘â†‘Î¼ s < Î´ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ < Îµ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` has finite integral, then `âˆ«â» x in s, f x âˆ‚Î¼` is absolutely continuous in `s`: it tends\\nto zero as `Î¼ s` tends to zero. This lemma states states this fact in terms of `Îµ` and `Î´`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î³ : Type u_1} [inst : UniformSpace Î±] {f : Î± â†’ Î³} [inst_1 : TopologicalSpace Î³] [inst_2 : Zero Î³],\\n  HasCompactSupport f â†’ Filter.Tendsto f (Filter.cocompact Î±) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` has compact support, then `f` tends to zero at infinity.\"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚}, AnalyticAt â„‚ f zâ‚€ â†’ (âˆ€á¶  (z : â„‚) in nhds zâ‚€, f z = f zâ‚€) âˆ¨ nhds (f zâ‚€) â‰¤ Filter.map f (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : â„‚ â†’ â„‚` which is analytic at a point `zâ‚€` is either constant in a neighborhood\\nof `zâ‚€`, or behaves locally like an open function (in the sense that the image of every neighborhood\\nof `zâ‚€` is a neighborhood of `f zâ‚€`, as in `isOpenMap_iff_nhds_le`). For a function `f : E â†’ â„‚`\\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] {a b : Î±} (h : a â‰¤ b) (f : Î± â†’ Î²),\\n  (âˆ€ (x : Î±), x < a â†’ f x = f a) â†’ (âˆ€ (x : Î±), b < x â†’ f x = f b) â†’ Set.IccExtend h (f âˆ˜ Subtype.val) = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : Î± â†’ Î²` is a constant both on $(-âˆ, a]$ and on $[b, +âˆ)$, then the extension of this\\nfunction from $[a, b]$ to the whole line is equal to the original function. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {ğ•œ : Type u_2} {G : Type u_3}\\n  [inst_2 : IsROrC ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace ğ•œ G] {f : E â†’ G}\\n  {s : Set E} {x y : E},\\n  Convex â„ s â†’ DifferentiableOn ğ•œ f s â†’ (âˆ€ (x : E), x âˆˆ s â†’ fderivWithin ğ•œ f s x = 0) â†’ x âˆˆ s â†’ y âˆˆ s â†’ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has zero FrÃ©chet derivative at every point of a convex set,\\nthen it is a constant on this set. \"}]\n",
    "prompt_cons": "/-- If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E â†’ â„‚`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `â„‚`). -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {U : Set E} {g : E â†’ â„‚},\n  AnalyticOn â„‚ g U â†’\n    IsPreconnected U â†’ (âˆƒ w, âˆ€ (z : E), z âˆˆ U â†’ g z = w) âˆ¨ âˆ€ (s : Set E), s âŠ† U â†’ IsOpen s â†’ IsOpen (g '' s) :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E â†’ F` is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆ€ (z w : E), f z = f w :=\n\n/-- A holomorphic function on a compact connected complex manifold is the constant function `f â‰¡ v`,\nfor some value `v`. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆƒ v, f = Function.const M v :=\n\n/-- If `f : ğ•œ â†’ G`, `ğ•œ = R` or `ğ•œ = â„‚`, is differentiable everywhere and its derivative equal zero,\nthen it is a constant function. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {G : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace ğ•œ G]\n  {f : ğ•œ â†’ G}, Differentiable ğ•œ f â†’ (âˆ€ (x : ğ•œ), deriv f x = 0) â†’ âˆ€ (x y : ğ•œ), f x = f y :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c :=\n\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {x : E'},\n  ContDiffAt ğ•‚ 1 f x â†’ âˆƒ K t, t âˆˆ nhds x âˆ§ LipschitzOnWith K f t :=\n\n/-- If `f` has finite integral, then `âˆ«â» x in s, f x âˆ‚Î¼` is absolutely continuous in `s`: it tends\nto zero as `Î¼ s` tends to zero. This lemma states states this fact in terms of `Îµ` and `Î´`. -/\ntheorem âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ ENNReal},\n  âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰  âŠ¤ â†’ âˆ€ {Îµ : ENNReal}, Îµ â‰  0 â†’ âˆƒ Î´, Î´ > 0 âˆ§ âˆ€ (s : Set Î±), â†‘â†‘Î¼ s < Î´ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ < Îµ :=\n\n/-- If `f` has compact support, then `f` tends to zero at infinity. -/\ntheorem âˆ€ {Î± : Type u_2} {Î³ : Type u_1} [inst : UniformSpace Î±] {f : Î± â†’ Î³} [inst_1 : TopologicalSpace Î³] [inst_2 : Zero Î³],\n  HasCompactSupport f â†’ Filter.Tendsto f (Filter.cocompact Î±) (nhds 0) :=\n\n/-- The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€) :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f :=\n\n/-- A function `f : â„‚ â†’ â„‚` which is analytic at a point `zâ‚€` is either constant in a neighborhood\nof `zâ‚€`, or behaves locally like an open function (in the sense that the image of every neighborhood\nof `zâ‚€` is a neighborhood of `f zâ‚€`, as in `isOpenMap_iff_nhds_le`). For a function `f : E â†’ â„‚`\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚}, AnalyticAt â„‚ f zâ‚€ â†’ (âˆ€á¶  (z : â„‚) in nhds zâ‚€, f z = f zâ‚€) âˆ¨ nhds (f zâ‚€) â‰¤ Filter.map f (nhds zâ‚€) :=\n\n/-- If `f : â„‚ â†’ E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {n : â„•âˆ} {s : Set â„‚}\n  {f : â„‚ â†’ E}, DifferentiableOn â„‚ f s â†’ IsOpen s â†’ ContDiffOn â„‚ n f s :=\n\n/-- If `f : Î± â†’ Î²` is a constant both on $(-âˆ, a]$ and on $[b, +âˆ)$, then the extension of this\nfunction from $[a, b]$ to the whole line is equal to the original function. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] {a b : Î±} (h : a â‰¤ b) (f : Î± â†’ Î²),\n  (âˆ€ (x : Î±), x < a â†’ f x = f a) â†’ (âˆ€ (x : Î±), b < x â†’ f x = f b) â†’ Set.IccExtend h (f âˆ˜ Subtype.val) = f :=\n\n/-- If a function has zero FrÃ©chet derivative at every point of a convex set,\nthen it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {ğ•œ : Type u_2} {G : Type u_3}\n  [inst_2 : IsROrC ğ•œ] [inst_3 : NormedSpace ğ•œ E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace ğ•œ G] {f : E â†’ G}\n  {s : Set E} {x y : E},\n  Convex â„ s â†’ DifferentiableOn ğ•œ f s â†’ (âˆ€ (x : E), x âˆˆ s â†’ fderivWithin ğ•œ f s x = 0) â†’ x âˆˆ s â†’ y âˆˆ s â†’ f x = f y :=\n\n/-- Suppose that `f` is holomorphic in an open set `Î©`. Prove that if `|f|` is constant, then `f` is constant. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set â„‚} {f : â„‚ â†’ E},\n  IsOpen Î© â†’ DifferentiableOn â„‚ f Î© â†’ (âˆ€ (x : â„‚), x âˆˆ Î© â†’ âˆ¥f xâˆ¥ = âˆ¥f 0âˆ¥) â†’ âˆ€ (x y : â„‚), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {Î© : Set E} {f : E â†’ F},\n  DifferentiableOn â„‚ f Î© â†’ IsOpen Î© â†’ (âˆ€ x : E, x âˆˆ Î© â†’ âˆ¥f xâˆ¥ = âˆ¥f (Classical.arbitrary Î©)âˆ¥) â†’ âˆ€ x y : E, x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set E} {f : E â†’ â„‚},\n  DifferentiableOn â„‚ f Î© â†’ IsOpen Î© â†’ (âˆ€ (x : E), x âˆˆ Î© â†’ Complex.abs (f x) = Complex.abs (f (Classical.arbitrary Î©))) â†’\n    âˆ€ (x y : E), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_4} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {Î© : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f Î© â†’\n    IsOpen Î© â†’ (âˆ€ (x : M), x âˆˆ Î© â†’ Complex.abs (f x) = Complex.abs (f (Classical.choice (_ : Nonempty M)))) â†’\n    âˆ€ (x y : M), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_3 : TopologicalSpace M]\n  [inst_4 : ChartedSpace H M] [SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {s : Set M} {x y : M},\n  IsOpen s â†’ DifferentiableOn â„‚ f s â†’ (âˆ€ (x : M), x âˆˆ s â†’ Complex.abs (f x) = Complex.abs (f y)) â†’ x âˆˆ s â†’ y âˆˆ s â†’ f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_4} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {Î© : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f Î© â†’\n    IsOpen Î© â†’ (âˆ€ (x : M), x âˆˆ Î© â†’ Complex.abs (f x) = 1) â†’ âˆƒ c : F, âˆ€ (x : M), x âˆˆ Î© â†’ f x = c ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : E â†’ â„‚} {Î© : Set E},\n  IsOpen Î© â†’ DifferentiableOn â„‚ f Î© â†’ (âˆ€ (x : E), x âˆˆ Î© â†’ Complex.abs (f x) = Complex.abs (f 0)) â†’ âˆ€ (x : E), x âˆˆ Î© â†’ f x = f 0 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {Î© : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ â„‚) f Î© â†’\n    IsOpen Î© â†’ (âˆ€ x âˆˆ Î©, Complex.abs (f x) = Complex.abs (f (Classical.arbitrary M))) â†’ âˆ€ x y âˆˆ Î©, f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚} {Î© : Set M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ â„‚) f Î© â†’\n    IsOpen Î© â†’ (âˆ€ (x : M), x âˆˆ Î© â†’ Complex.abs (f x) = Complex.abs (f (Classical.arbitrary M))) â†’ âˆ€ (x y : M), x âˆˆ Î© â†’ y âˆˆ Î© â†’ f x = f y ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {Î© : Set E} {f : E â†’ â„‚},\n  DifferentiableOn â„‚ f Î© â†’ IsOpen Î© â†’ âˆ€ x âˆˆ Î©, Complex.abs (f x) = Complex.abs (f (Classical.arbitrary E)) â†’ âˆ€ x y âˆˆ Î©, f x = f y "
    ]
  },
  {
    "docString": "Prove that the power series `Î£ zn/n^2` converges at every point of the unit circle.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\\n  Summable u â†’\\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `â„â‰¥0`-valued series. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\\n  CircleIntegrable f c R â†’\\n    â†‘Complex.abs w < R â†’\\n      HasSum (fun n => âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\\n        (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\\n`Metric.ball c R`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\\n  CircleIntegrable f c R â†’\\n    â†‘Complex.abs w < R â†’\\n      HasSum (fun n => â†‘(cauchyPowerSeries f c R n) fun x => w)\\n        ((2 * â†‘Real.pi * Complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\\ndisc `Metric.ball c R`. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"âˆ€ {t : â„}, 0 < t â†’ Summable fun n => rexp (-Real.pi * t * (â†‘n + 1) ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"The sum defining `zetaKernelâ‚` is convergent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\\n  Summable u â†’\\n    IsOpen s â†’\\n      IsPreconnected s â†’\\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\\nat a point, and all functions in the series are differentiable with a summable bound on the\\nderivatives, then the series converges everywhere on the set. \"},\n {\"theorem\":\n  \"âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\\n  HasFPowerSeriesOnBall f p x r â†’\\n    â†‘r' < r â†’\\n      âˆƒ a,\\n        a âˆˆ Set.Ioo 0 1 âˆ§\\n          âˆƒ C,\\n            C > 0 âˆ§\\n              âˆ€ (y : E),\\n                y âˆˆ Metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), â€–f (x + y) - FormalMultilinearSeries.partialSum p n yâ€– â‰¤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion, then it is exponentially close to the partial\\nsums of this power series on strict subdisks of the disk of convergence. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\\n  (p : FormalMultilinearSeries ğ•œ E F),\\n  0 < FormalMultilinearSeries.radius p â†’\\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the sum of a converging power series `p` admits `p` as a power series.\\nThis is not totally obvious as we need to check the convergence of the series. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  (p q : FormalMultilinearSeries ğ•œ E F),\\n  min (FormalMultilinearSeries.radius p) (FormalMultilinearSeries.radius q) â‰¤ FormalMultilinearSeries.radius (p + q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The radius of the sum of two formal series is at least the minimum of their two radii. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' â†’\\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ (Î¾ : â„) (n : â„•), Real.convergent Î¾ (n + 1) = â†‘âŒŠÎ¾âŒ‹ + (Real.convergent (Int.fract Î¾)â»Â¹ n)â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `(n+1)`th convergent of `Î¾` is the `n`th convergent of `1/(fract Î¾)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"}]\n",
    "prompt_cons": "/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  {p : FormalMultilinearSeries ğ•œ E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {xâ‚€ : E},\n  Summable u â†’\n    (âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x) â†’\n      (âˆ€ (n : Î±) (x : E), â€–f' n xâ€– â‰¤ u n) â†’ (Summable fun n => f n xâ‚€) â†’ âˆ€ (x : E), Summable fun n => f n x :=\n\n/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ NNReal} {r : NNReal}, (âˆ€ (b : Î²), g b â‰¤ f b) â†’ HasSum f r â†’ âˆƒ p, p â‰¤ r âˆ§ HasSum g p :=\n\n/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\n`Metric.ball c R`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\n  CircleIntegrable f c R â†’\n    â†‘Complex.abs w < R â†’\n      HasSum (fun n => âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\n        (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) :=\n\n/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\n  CircleIntegrable f c R â†’\n    â†‘Complex.abs w < R â†’\n      HasSum (fun n => â†‘(cauchyPowerSeries f c R n) fun x => w)\n        ((2 * â†‘Real.pi * Complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem âˆ€ {Î² : Type u_1} {f g : Î² â†’ â„}, (âˆ€ (b : Î²), 0 â‰¤ g b) â†’ (âˆ€ (b : Î²), g b â‰¤ f b) â†’ Summable f â†’ Summable g :=\n\n/-- The sum defining `zetaKernelâ‚` is convergent. -/\ntheorem âˆ€ {t : â„}, 0 < t â†’ Summable fun n => rexp (-Real.pi * t * (â†‘n + 1) ^ 2) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {m : MeasurableSpace Î±}\n  {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_1} [inst_2 : Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î¹ â†’ Î± â†’ â„),\n  (âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼) â†’\n    (âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a) â†’\n      (âˆ€áµ (a : Î±) âˆ‚Î¼, Summable fun n => bound n a) â†’\n        (MeasureTheory.Integrable fun a => âˆ‘' (n : Î¹), bound n a) â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, HasSum (fun n => F n a) (f a)) â†’ HasSum (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼) :=\n\n/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series converges everywhere on the set. -/\ntheorem âˆ€ {Î± : Type u_1} {ğ•œ : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : Î± â†’ â„}\n  [inst_5 : NormedSpace ğ•œ F] {f : Î± â†’ E â†’ F} {f' : Î± â†’ E â†’ E â†’L[ğ•œ] F} {s : Set E} {xâ‚€ : E},\n  Summable u â†’\n    IsOpen s â†’\n      IsPreconnected s â†’\n        (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x) â†’\n          (âˆ€ (n : Î±) (x : E), x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) â†’\n            xâ‚€ âˆˆ s â†’ (Summable fun x => f x xâ‚€) â†’ âˆ€ {x : E}, x âˆˆ s â†’ Summable fun n => f n x :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem âˆ€ {m : â„} {f : â„• â†’ â„•}, 1 < m â†’ (âˆ€ (i : â„•), i â‰¤ f i) â†’ Summable fun i => 1 / m ^ f i :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹},\n  TendstoUniformlyOn F f p s â†’ âˆ€ {x : Î±}, x âˆˆ s â†’ Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\n  HasFPowerSeriesOnBall f p x r â†’\n    â†‘r' < r â†’\n      âˆƒ a,\n        a âˆˆ Set.Ioo 0 1 âˆ§\n          âˆƒ C,\n            C > 0 âˆ§\n              âˆ€ (y : E),\n                y âˆˆ Metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), â€–f (x + y) - FormalMultilinearSeries.partialSum p n yâ€– â‰¤ C * a ^ n :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] [inst_5 : CompleteSpace F]\n  (p : FormalMultilinearSeries ğ•œ E F),\n  0 < FormalMultilinearSeries.radius p â†’\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p) :=\n\n/-- The radius of the sum of two formal series is at least the minimum of their two radii. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p q : FormalMultilinearSeries ğ•œ E F),\n  min (FormalMultilinearSeries.radius p) (FormalMultilinearSeries.radius q) â‰¤ FormalMultilinearSeries.radius (p + q) :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' â†’\n    (âˆ€á¶  (x : Î±) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) â†’ TendstoUniformlyOnFilter F f p p' :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- The `(n+1)`th convergent of `Î¾` is the `n`th convergent of `1/(fract Î¾)`. -/\ntheorem âˆ€ (Î¾ : â„) (n : â„•), Real.convergent Î¾ (n + 1) = â†‘âŒŠÎ¾âŒ‹ + (Real.convergent (Int.fract Î¾)â»Â¹ n)â»Â¹ :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : CompleteSpace Î±] {u : Î² â†’ Î±},\n  CauchySeq u â†’ âˆƒ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- Prove that the power series `Î£ zn/n^2` converges at every point of the unit circle. -/\ntheorem",
    "choices": [
      "âˆ€ (z : â„‚), Complex.abs z = 1 â†’ Summable (Î» n => z ^ n / (â†‘n + 1) ^ 2) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {z : ğ•œ},\n  Complex.abs (coeFn (algebraMap â„ ğ•œ) (Complex.abs z)) = 1 â†’\n    Summable (Î» n => z ^ n / â†‘(n ^ 2)) ",
      "âˆ€ (z : â„‚), Complex.abs z = 1 â†’ Summable (Î» n => z ^ n / (â†‘n + 1) ^ 2) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] (z : ğ•œ), IsROrC.abs z = 1 â†’ Summable fun n => z ^ n / â†‘(n ^ 2) ",
      "âˆ€ {â„‚ : Type u_1} [inst : NontriviallyNormedField â„‚] {z : â„‚},\n  Complex.abs z = 1 â†’ Summable fun n => z ^ n / (â†‘n) ^ 2 ",
      "âˆ€ z : â„‚, Complex.abs z = 1 â†’ Summable (Î» n, z ^ n / â†‘(n ^ 2)) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {z : ğ•œ}, IsROrC.abs z = 1 â†’ Summable (Î» n, z ^ n / (â†‘n + 1) ^ 2) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (z : ğ•œ), âˆ¥zâˆ¥ = 1 â†’ Summable (Î» n => z ^ n / (â†‘n) ^ 2) ",
      "âˆ€ {â„‚ : Type u_1} [inst : IsROrC â„‚], Summable (Î» n, Complex.abs (1 / (â†‘n + 1) ^ 2)) ",
      "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ], Summable (Î» (n : â„•), (Complex.exp (ğ•œ.is_R_or_C.mul_I â†‘(2 * n * Real.pi)) / â†‘(n ^ 2))) "
    ]
  },
  {
    "docString": "Suppose `f` is continuous in a region `Î©`. Prove that any two primitives of `f` (if they exist) differ by a constant.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’\\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\\n  (f' : â„‚ â†’ â„‚ â†’L[â„] E) (z w : â„‚) (s : Set â„‚),\\n  Set.Countable s â†’\\n    ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\\n      (âˆ€ (x : â„‚),\\n          x âˆˆ Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im) \\\\ s â†’\\n            HasFDerivAt f (f' x) x) â†’\\n        MeasureTheory.IntegrableOn (fun z => Complex.I â€¢ â†‘(f' z) 1 - â†‘(f' z) Complex.I)\\n            (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\\n          (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) -\\n                  âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\\n                Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\\n              Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\\n            âˆ« (x : â„) in z.re..w.re,\\n              âˆ« (y : â„) in z.im..w.im, Complex.I â€¢ â†‘(f' (â†‘x + â†‘y * Complex.I)) 1 - â†‘(f' (â†‘x + â†‘y * Complex.I)) Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose that a function `f : â„‚ â†’ E` is continuous on a closed rectangle with opposite corners at\\n`z w : â„‚`, is *real* differentiable at all but countably many points of the corresponding open\\nrectangle, and $\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}$ is integrable on this rectangle. Then the\\nintegral of `f` over the boundary of the rectangle is equal to the integral of\\n$2i\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}=i\\\\frac{\\\\partial f}{\\\\partial x}-\\\\frac{\\\\partial f}{\\\\partial y}$\\nover the rectangle. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, Continuous â†‘f.linear â†” Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is continuous iff `f` is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictMono (deriv f) â†’ StrictConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly monotone on `â„` then `f` is strictly\\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict monotonicity of `f'`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictAnti (deriv f) â†’ StrictConcaveOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly antitone on `â„` then `f` is strictly\\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict antitonicity of `f'`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ âˆ€ (y : â„), HasDerivAt f (g y) y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is the derivative of `f` everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Monotone (deriv f) â†’ ConvexOn â„ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is differentiable and `f'` is monotone on `â„` then `f` is convex. \"},\n {\"theorem\":\n  \"âˆ€ {D : Set â„},\\n  Convex â„ D â†’\\n    âˆ€ {f : â„ â†’ â„},\\n      ContinuousOn f D â†’\\n        DifferentiableOn â„ f (interior D) â†’\\n          âˆ€ {C : (fun x => â„) 1},\\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\\n`x â‰¤ y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {n : â„•âˆ} {m : â„•}, â†‘m â‰¤ n â†’ ContDiff ğ•œ n f â†’ Continuous fun x => iteratedFDeriv ğ•œ m f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is `C^n` then its `m`-times iterated derivative is continuous for `m â‰¤ n`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"âˆ€ {f g : â„ â†’ â„} {a b : â„},\\n  a < b â†’\\n    ContinuousOn f (Set.Icc a b) â†’\\n      ContinuousOn g (Set.Icc a b) â†’\\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. \"}]\n",
    "prompt_cons": "/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem âˆ€ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X â†’ E} {Î¼ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Î¼] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f â†’ MeasureTheory.LocallyIntegrable f :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S :=\n\n/-- Suppose that a function `f : â„‚ â†’ E` is continuous on a closed rectangle with opposite corners at\n`z w : â„‚`, is *real* differentiable at all but countably many points of the corresponding open\nrectangle, and $\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then the\nintegral of `f` over the boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\n  (f' : â„‚ â†’ â„‚ â†’L[â„] E) (z w : â„‚) (s : Set â„‚),\n  Set.Countable s â†’\n    ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n      (âˆ€ (x : â„‚),\n          x âˆˆ Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im) \\ s â†’\n            HasFDerivAt f (f' x) x) â†’\n        MeasureTheory.IntegrableOn (fun z => Complex.I â€¢ â†‘(f' z) 1 - â†‘(f' z) Complex.I)\n            (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n          (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) -\n                  âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\n                Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\n              Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\n            âˆ« (x : â„) in z.re..w.re,\n              âˆ« (y : â„) in z.im..w.im, Complex.I â€¢ â†‘(f' (â†‘x + â†‘y * Complex.I)) 1 - â†‘(f' (â†‘x + â†‘y * Complex.I)) Complex.I :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g :=\n\n/-- If `f` is an affine map, then its linear part is continuous iff `f` is continuous. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_3} {Pâ‚‚ : Type u_5} [inst : NormedField ğ•œ]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, Continuous â†‘f.linear â†” Continuous â†‘f :=\n\n/-- If a function `f` is continuous and `f'` is strictly monotone on `â„` then `f` is strictly\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict monotonicity of `f'`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictMono (deriv f) â†’ StrictConvexOn â„ Set.univ f :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- If a function `f` is continuous and `f'` is strictly antitone on `â„` then `f` is strictly\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict antitonicity of `f'`. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Continuous f â†’ StrictAnti (deriv f) â†’ StrictConcaveOn â„ Set.univ f :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is the derivative of `f` everywhere. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ âˆ€ (y : â„), HasDerivAt f (g y) y :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- If a function `f` is differentiable and `f'` is monotone on `â„` then `f` is convex. -/\ntheorem âˆ€ {f : â„ â†’ â„}, Differentiable â„ f â†’ Monotone (deriv f) â†’ ConvexOn â„ Set.univ f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C â‰¤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) â‰¤ f y - f x` whenever `x, y âˆˆ D`,\n`x â‰¤ y`. -/\ntheorem âˆ€ {D : Set â„},\n  Convex â„ D â†’\n    âˆ€ {f : â„ â†’ â„},\n      ContinuousOn f D â†’\n        DifferentiableOn â„ f (interior D) â†’\n          âˆ€ {C : (fun x => â„) 1},\n            (âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) â†’\n              âˆ€ (x : â„), x âˆˆ D â†’ âˆ€ (y : â„), y âˆˆ D â†’ x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- If `f` is `C^n` then its `m`-times iterated derivative is continuous for `m â‰¤ n`. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {n : â„•âˆ} {m : â„•}, â†‘m â‰¤ n â†’ ContDiff ğ•œ n f â†’ Continuous fun x => iteratedFDeriv ğ•œ m f x :=\n\n/-- If a function `f : M â†’ F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M â†’ F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf â„‚ F) f U â†’\n    IsPreconnected U â†’ IsCompact U â†’ IsOpen U â†’ a âˆˆ U â†’ b âˆˆ U â†’ f a = f b :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem âˆ€ {f g : â„ â†’ â„} {a b : â„},\n  a < b â†’\n    ContinuousOn f (Set.Icc a b) â†’\n      ContinuousOn g (Set.Icc a b) â†’\n        (âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) â†’\n          (âˆƒ c, c âˆˆ Set.Icc a b âˆ§ f c < g c) â†’ âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem âˆ€ {X : Type u} {Î± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Î±] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : OrderClosedTopology Î±] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X â†’ Î±},\n  Continuous f â†’ Continuous g â†’ f a â‰¤ g a â†’ g b â‰¤ f b â†’ âˆƒ x, f x = g x :=\n\n/-- Suppose `f` is continuous in a region `Î©`. Prove that any two primitives of `f` (if they exist) differ by a constant. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : â„ â†’ E} {F G : â„ â†’ E},\n  (âˆ€ (x : â„), HasDerivAt F (f x) x) â†’\n    (âˆ€ (x : â„), HasDerivAt G (f x) x) â†’\n      ContinuousOn f (Set.Interval F.a G.a) â†’\n        ContinuousOn F (Set.Interval F.a G.a) â†’\n          ContinuousOn G (Set.Interval F.a G.a) â†’\n            âˆƒ (C : E), âˆ€ (x : â„), x âˆˆ Set.Interval F.a G.a â†’ F x = G x + C ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T1Space Y] [inst_3 : LinearOrder Y]\n  [inst_4 : OrderClosedTopology Y] {f F G : X â†’ Y},\n  Continuous f â†’ (âˆ€ (x : X), HasDerivAt F (f x) x) â†’ (âˆ€ (x : X), HasDerivAt G (f x) x) â†’ âˆƒ c, âˆ€ (x : X), F x = G x + c ",
      "âˆ€ {Î© : Type u_1} [inst : MeasurableSpace Î©] [inst_1 : BorelSpace Î©] [inst_2 : TopologicalSpace Î©] [inst_3 : OpensMeasurableSpace Î©]\n  {f Fâ‚ Fâ‚‚ : Î© â†’ â„},\n  Continuous f â†’\n    Fâ‚ =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict volume (interior Î©))] f.antiderivative â†’\n      Fâ‚‚ =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict volume (interior Î©))] f.antiderivative â†’\n        Continuous Fâ‚ â†’ Continuous Fâ‚‚ â†’ âˆƒ C, âˆ€ (x : Î©), x âˆˆ interior Î© â†’ Fâ‚ x = Fâ‚‚ x + C ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„ F] {f : E â†’ F} {gâ‚ gâ‚‚ : E â†’ F} {Î© : Set E},\n  ContinuousOn f Î© â†’\n    HasPrimitiveWithinAt f gâ‚ Î© â†’\n      HasPrimitiveWithinAt f gâ‚‚ Î© â†’\n        ContinuousOn gâ‚ Î© â†’ ContinuousOn gâ‚‚ Î© â†’ âˆ€ (x : E), x âˆˆ Î© â†’ gâ‚ x = gâ‚‚ x + (gâ‚ (Classical.some (_ : âˆƒ x, x âˆˆ Î©)) - gâ‚‚ (Classical.some (_ : âˆƒ x, x âˆˆ Î©))) ",
      "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T1Space Y] {Î© : Set X}\n  [inst_3 : IsRegion Î©] {f Fâ‚ Fâ‚‚ : X â†’ Y},\n  ContinuousOn f Î© â†’\n    (âˆ€ (x : X), x âˆˆ Î© â†’ HasDerivWithinAt Fâ‚ (f x) Î© x) â†’\n      (âˆ€ (x : X), x âˆˆ Î© â†’ HasDerivWithinAt Fâ‚‚ (f x) Î© x) â†’\n        âˆƒ (C : Y), âˆ€ (x : X), x âˆˆ Î© â†’ Fâ‚ x = Fâ‚‚ x + C ",
      "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„ F] {f : E â†’ F} {s : Set E} {gâ‚ gâ‚‚ : F} {U : Set E},\n  ContinuousOn f s â†’\n    HasIntegralOn â„ gâ‚ f U s â†’\n      HasIntegralOn â„ gâ‚‚ f U s â†’\n        âˆ€ (x : E), x âˆˆ s â†’ gâ‚ x = gâ‚‚ x + (gâ‚ (Classical.some (_ : âˆƒ x, x âˆˆ s)) - gâ‚‚ (Classical.some (_ : âˆƒ x, x âˆˆ s))) ",
      "âˆ€ {â„ : Type u_1} {E : Type u_2} [inst : MeasurableSpace â„] [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace â„ E]\n  {F : Type u_3} [inst_3 : NormedGroup F] [inst_4 : NormedSpace â„ F] {fâ‚ fâ‚‚ : â„ â†’ F} {f : â„ â†’ E} {Î© : Set â„},\n  ContinuousOn f Î© â†’\n  (âˆ€ (x : â„), x âˆˆ Î© â†’ HasDerivWithinAt fâ‚ (f x) Î© x) â†’\n    (âˆ€ (x : â„), x âˆˆ Î© â†’ HasDerivWithinAt fâ‚‚ (f x) Î© x) â†’\n      âˆƒ (C : F), âˆ€ (x : â„), x âˆˆ Î© â†’ fâ‚ x = fâ‚‚ x + C ",
      "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : AddCommGroup X] [inst_2 : TopologicalAddGroup X]\n  {f Fâ‚ Fâ‚‚ : â„ â†’ X},\n  ContinuousOn f (Set.Interval Fâ‚ Fâ‚‚) â†’\n    (âˆ€ (x : â„), x âˆˆ Set.Interval Fâ‚ Fâ‚‚ â†’ HasDerivAt Fâ‚ (f x) x) â†’\n      (âˆ€ (x : â„), x âˆˆ Set.Interval Fâ‚ Fâ‚‚ â†’ HasDerivAt Fâ‚‚ (f x) x) â†’\n        âˆƒ (C : X), âˆ€ (x : â„), x âˆˆ Set.Interval Fâ‚ Fâ‚‚ â†’ Fâ‚ x = Fâ‚‚ x + C ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y] [inst_3 : AddGroup Y] [inst_4 : TopologicalAddGroup Y]\n  {f Fâ‚ Fâ‚‚ : X â†’ Y},\n  Continuous f â†’\n    (âˆ€ x, HasDerivAt Fâ‚ (f x) x) â†’\n      (âˆ€ x, HasDerivAt Fâ‚‚ (f x) x) â†’\n        âˆƒ c : Y, âˆ€ (x : X), Fâ‚ x = Fâ‚‚ x + c ",
      "âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y] {m : MeasurableSpace X}\n  {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsComplete Î¼] {f : X â†’ Y} {Fâ‚ Fâ‚‚ : MeasureTheory.VectorMeasure X Y},\n  Continuous f â†’\n    Fâ‚ âˆˆ MeasureTheory.VectorMeasure.primitive Î¼ f â†’\n      Fâ‚‚ âˆˆ MeasureTheory.VectorMeasure.primitive Î¼ f â†’ Fâ‚ = Fâ‚‚ "
    ]
  },
  {
    "docString": "Let `Î©` be a bounded open subset of `â„‚`, and `Ï•: Î© â†’ Î©` a holomorphic function. Prove that if there exists a point `zâ‚€ âˆˆ Î©` such that `Ï•(zâ‚€) = zâ‚€` and `Ï•'(zâ‚€) = 1`, then `Ï•` is linear.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ (K : Subfield â„‚) {Ïˆ : { x // x âˆˆ K } â†’+* â„‚},\\n  UniformContinuous â†‘Ïˆ â†’ Ïˆ.toFun = â†‘(Subfield.subtype K) âˆ¨ Ïˆ.toFun = â†‘(starRingEnd â„‚) âˆ˜ â†‘(Subfield.subtype K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `K` a subfield of `â„‚` and let `Ïˆ : K â†’+* â„‚` a ring homomorphism. Assume that `Ïˆ` is uniform\\ncontinuous, then `Ïˆ` is either the inclusion map or the composition of the inclusion map with the\\ncomplex conjugation. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} {Mâ‚ƒ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid Mâ‚ƒ]\\n  [inst_3 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ}, â†‘f 1 = â†‘g 1 â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two `Ïƒ`-linear maps from `R` are equal on `1`, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_3} {R : Type u_1} {M : Î¹ â†’ Type u_2} {N : Type u_4} [dec_Î¹ : DecidableEq Î¹] [inst : Semiring R]\\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] [inst_3 : AddCommMonoid N]\\n  [inst_4 : Module R N] â¦ƒÏ† Ïˆ : (Î â‚€ (i : Î¹), M i) â†’â‚—[R] Nâ¦„,\\n  (âˆ€ (i : Î¹), LinearMap.comp Ï† (DFinsupp.lsingle i) = LinearMap.comp Ïˆ (DFinsupp.lsingle i)) â†’ Ï† = Ïˆ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two `R`-linear maps from `Î â‚€ i, M i` which agree on each `single i x` agree everywhere.\\n\\nSee note [partially-applied ext lemmas].\\nAfter apply this lemma, if `M = R` then it suffices to verify `Ï† (single a 1) = Ïˆ (single a 1)`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : â„ â†’ E),\\n  Filter.Tendsto (fun w => âˆ« (v : â„), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-(v * w)))) â€¢ f v)\\n    (Filter.cocompact â„) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\": \"The Riemann-Lebesgue lemma for functions on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + Ï„ f`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\\n  IsPreconnected S â†’\\n    ContinuousOn f S â†’\\n      ContinuousOn g S â†’\\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\\nother. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : AddCommGroup E] [inst_2 : TopologicalAddGroup E]\\n  [inst_3 : Module â„ E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  0 âˆˆ s â†’ Convex â„ s â†’ IsOpen s â†’ âˆ€ {xâ‚€ : E}, Â¬xâ‚€ âˆˆ s â†’ âˆƒ f, â†‘f xâ‚€ = 1 âˆ§ âˆ€ (x : E), x âˆˆ s â†’ â†‘f x < 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a set `s` which is a convex neighbourhood of `0` and a point `xâ‚€` outside of it, there is\\na continuous linear functional `f` separating `xâ‚€` and `s`, in the sense that it sends `xâ‚€` to 1 and\\nall of `s` to values strictly below `1`. \"},\n {\"theorem\": \"âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚], HasStrictDerivAt (exp ğ•‚) 1 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The exponential map in `ğ•‚ = â„` or `ğ•‚ = â„‚` has strict derivative `1` at zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {p : FormalMultilinearSeries ğ•œ ğ•œ E} {f : ğ•œ â†’ E} {x : ğ•œ},\\n  HasFPowerSeriesAt f p x â†’ f =á¶ [nhds x] 0 â†’ p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A one-dimensional formal multilinear series representing a locally zero function is zero. \"},\n {\"theorem\":\n  \"âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant function 1 is invariant under any element of `SL(2, â„¤)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\\n  {Î¼ : MeasureTheory.Measure Î±},\\n  p â‰  0 â†’\\n    p â‰  âŠ¤ â†’\\n      âˆ€ {P : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ } â†’ Prop},\\n        (âˆ€ (c : E) {s : Set Î±} (hs : MeasurableSet s) (hÎ¼s : â†‘â†‘Î¼ s < âŠ¤),\\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : â†‘â†‘Î¼ s â‰  âŠ¤) c)) â†’\\n          (âˆ€ â¦ƒf g : MeasureTheory.SimpleFunc Î± Eâ¦„ (hf : MeasureTheory.Memâ„’p (â†‘f) p) (hg : MeasureTheory.Memâ„’p (â†‘g) p),\\n              Disjoint (Function.support â†‘f) (Function.support â†‘g) â†’\\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) â†’\\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) â†’\\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) â†’\\n            âˆ€ (f : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ }), P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary `Lp` simple function, with `0 < p < âˆ`, it suffices to show\\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\\nsets and is closed under addition (of functions with disjoint support). \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚}, AnalyticAt â„‚ f zâ‚€ â†’ (âˆ€á¶  (z : â„‚) in nhds zâ‚€, f z = f zâ‚€) âˆ¨ nhds (f zâ‚€) â‰¤ Filter.map f (nhds zâ‚€)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : â„‚ â†’ â„‚` which is analytic at a point `zâ‚€` is either constant in a neighborhood\\nof `zâ‚€`, or behaves locally like an open function (in the sense that the image of every neighborhood\\nof `zâ‚€` is a neighborhood of `f zâ‚€`, as in `isOpenMap_iff_nhds_le`). For a function `f : E â†’ â„‚`\\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (s : Set Î±), LipschitzWith 1 fun x => Metric.infNndist x s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal distance to a set (as `â„â‰¥0`) is Lipschitz in point with constant 1 \"}]\n",
    "prompt_cons": "/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- Let `K` a subfield of `â„‚` and let `Ïˆ : K â†’+* â„‚` a ring homomorphism. Assume that `Ïˆ` is uniform\ncontinuous, then `Ïˆ` is either the inclusion map or the composition of the inclusion map with the\ncomplex conjugation. -/\ntheorem âˆ€ (K : Subfield â„‚) {Ïˆ : { x // x âˆˆ K } â†’+* â„‚},\n  UniformContinuous â†‘Ïˆ â†’ Ïˆ.toFun = â†‘(Subfield.subtype K) âˆ¨ Ïˆ.toFun = â†‘(starRingEnd â„‚) âˆ˜ â†‘(Subfield.subtype K) :=\n\n/-- If two `Ïƒ`-linear maps from `R` are equal on `1`, then they are equal. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} {Mâ‚ƒ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid Mâ‚ƒ]\n  [inst_3 : Module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ}, â†‘f 1 = â†‘g 1 â†’ f = g :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- The *open mapping theorem* for holomorphic functions, local version: is a function `g : E â†’ â„‚`\nis analytic at a point `zâ‚€`, then either it is constant in a neighborhood of `zâ‚€`, or it maps every\nneighborhood of `zâ‚€` to a neighborhood of `zâ‚€`. For the particular case of a holomorphic function on\n`â„‚`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {g : E â†’ â„‚} {zâ‚€ : E},\n  AnalyticAt â„‚ g zâ‚€ â†’ (âˆ€á¶  (z : E) in nhds zâ‚€, g z = g zâ‚€) âˆ¨ nhds (g zâ‚€) â‰¤ Filter.map g (nhds zâ‚€) :=\n\n/-- Two `R`-linear maps from `Î â‚€ i, M i` which agree on each `single i x` agree everywhere.\n\nSee note [partially-applied ext lemmas].\nAfter apply this lemma, if `M = R` then it suffices to verify `Ï† (single a 1) = Ïˆ (single a 1)`. -/\ntheorem âˆ€ {Î¹ : Type u_3} {R : Type u_1} {M : Î¹ â†’ Type u_2} {N : Type u_4} [dec_Î¹ : DecidableEq Î¹] [inst : Semiring R]\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] [inst_3 : AddCommMonoid N]\n  [inst_4 : Module R N] â¦ƒÏ† Ïˆ : (Î â‚€ (i : Î¹), M i) â†’â‚—[R] Nâ¦„,\n  (âˆ€ (i : Î¹), LinearMap.comp Ï† (DFinsupp.lsingle i) = LinearMap.comp Ïˆ (DFinsupp.lsingle i)) â†’ Ï† = Ïˆ :=\n\n/-- The Riemann-Lebesgue lemma for functions on `â„`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : â„ â†’ E),\n  Filter.Tendsto (fun w => âˆ« (v : â„), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-(v * w)))) â€¢ f v)\n    (Filter.cocompact â„) (nhds 0) :=\n\n/-- If `f` is a continuous monotone map `â„ â†’ â„`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + Ï„ f`. -/\ntheorem âˆ€ (f : CircleDeg1Lift), Continuous â†‘f â†’ âˆƒ x, â†‘f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z :=\n\n/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem âˆ€ {Î± : Type u_2} {ğ•œ : Type u_1} {f g : Î± â†’ ğ•œ} {S : Set Î±} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace ğ•œ]\n  [inst_2 : T1Space ğ•œ] [inst_3 : Field ğ•œ] [inst_4 : HasContinuousInvâ‚€ ğ•œ] [inst_5 : ContinuousMul ğ•œ],\n  IsPreconnected S â†’\n    ContinuousOn f S â†’\n      ContinuousOn g S â†’\n        Set.EqOn (f ^ 2) (g ^ 2) S â†’ (âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) â†’ âˆ€ {y : Î±}, y âˆˆ S â†’ f y = g y â†’ Set.EqOn f g S :=\n\n/-- Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\nother. -/\ntheorem âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1 :=\n\n/-- Given a set `s` which is a convex neighbourhood of `0` and a point `xâ‚€` outside of it, there is\na continuous linear functional `f` separating `xâ‚€` and `s`, in the sense that it sends `xâ‚€` to 1 and\nall of `s` to values strictly below `1`. -/\ntheorem âˆ€ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : AddCommGroup E] [inst_2 : TopologicalAddGroup E]\n  [inst_3 : Module â„ E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\n  0 âˆˆ s â†’ Convex â„ s â†’ IsOpen s â†’ âˆ€ {xâ‚€ : E}, Â¬xâ‚€ âˆˆ s â†’ âˆƒ f, â†‘f xâ‚€ = 1 âˆ§ âˆ€ (x : E), x âˆˆ s â†’ â†‘f x < 1 :=\n\n/-- The exponential map in `ğ•‚ = â„` or `ğ•‚ = â„‚` has strict derivative `1` at zero. -/\ntheorem âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚], HasStrictDerivAt (exp ğ•‚) 1 0 :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {f : E â†’ F}, Differentiable â„‚ f â†’ Metric.Bounded (Set.range f) â†’ âˆƒ c, âˆ€ (z : E), f z = c :=\n\n/-- A one-dimensional formal multilinear series representing a locally zero function is zero. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {p : FormalMultilinearSeries ğ•œ ğ•œ E} {f : ğ•œ â†’ E} {x : ğ•œ},\n  HasFPowerSeriesAt f p x â†’ f =á¶ [nhds x] 0 â†’ p = 0 :=\n\n/-- The constant function 1 is invariant under any element of `SL(2, â„¤)`. -/\ntheorem âˆ€ (A : Matrix.SpecialLinearGroup (Fin 2) â„¤), SlashAction.map â„‚ 0 A 1 = 1 :=\n\n/-- To prove something for an arbitrary `Lp` simple function, with `0 < p < âˆ`, it suffices to show\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\nsets and is closed under addition (of functions with disjoint support). -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\n  {Î¼ : MeasureTheory.Measure Î±},\n  p â‰  0 â†’\n    p â‰  âŠ¤ â†’\n      âˆ€ {P : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ } â†’ Prop},\n        (âˆ€ (c : E) {s : Set Î±} (hs : MeasurableSet s) (hÎ¼s : â†‘â†‘Î¼ s < âŠ¤),\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : â†‘â†‘Î¼ s â‰  âŠ¤) c)) â†’\n          (âˆ€ â¦ƒf g : MeasureTheory.SimpleFunc Î± Eâ¦„ (hf : MeasureTheory.Memâ„’p (â†‘f) p) (hg : MeasureTheory.Memâ„’p (â†‘g) p),\n              Disjoint (Function.support â†‘f) (Function.support â†‘g) â†’\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) â†’\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) â†’\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) â†’\n            âˆ€ (f : { x // x âˆˆ MeasureTheory.Lp.simpleFunc E p Î¼ }), P f :=\n\n/-- A function `f : â„‚ â†’ â„‚` which is analytic at a point `zâ‚€` is either constant in a neighborhood\nof `zâ‚€`, or behaves locally like an open function (in the sense that the image of every neighborhood\nof `zâ‚€` is a neighborhood of `f zâ‚€`, as in `isOpenMap_iff_nhds_le`). For a function `f : E â†’ â„‚`\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {zâ‚€ : â„‚}, AnalyticAt â„‚ f zâ‚€ â†’ (âˆ€á¶  (z : â„‚) in nhds zâ‚€, f z = f zâ‚€) âˆ¨ nhds (f zâ‚€) â‰¤ Filter.map f (nhds zâ‚€) :=\n\n/-- The minimal distance to a set (as `â„â‰¥0`) is Lipschitz in point with constant 1 -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (s : Set Î±), LipschitzWith 1 fun x => Metric.infNndist x s :=\n\n/-- Let `Î©` be a bounded open subset of `â„‚`, and `Ï•: Î© â†’ Î©` a holomorphic function. Prove that if there exists a point `zâ‚€ âˆˆ Î©` such that `Ï•(zâ‚€) = zâ‚€` and `Ï•'(zâ‚€) = 1`, then `Ï•` is linear. -/\ntheorem",
    "choices": [
      "âˆ€ {Î© : Set â„‚} (hÎ© : IsOpen Î©) (h_bdd : Metric.Bounded Î©) {Ï• : â„‚ â†’ â„‚},\n  DifferentiableOn â„‚ Ï• Î© â†’\n    Set.MapsTo Ï• Î© Î© â†’\n      âˆ€ {zâ‚€ : â„‚}, zâ‚€ âˆˆ Î© â†’ Ï• zâ‚€ = zâ‚€ â†’ HasDerivAt Ï• 1 zâ‚€ â†’ âˆƒ (a : â„‚), âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = zâ‚€ + a * (z - zâ‚€) ",
      "theorem linear_if_deriv_eq_one\n  {Î© : Set â„‚} (hÎ© : IsOpen Î©) (hbdd : Metric.Bounded Î©) {Ï• : â„‚ â†’ â„‚}\n  (hÏ• : âˆ€ z âˆˆ Î©, AnalyticAt â„‚ Ï• z) {zâ‚€ : â„‚} (hzâ‚€ : zâ‚€ âˆˆ Î©)\n  (hfâ‚ : Ï• zâ‚€ = zâ‚€) (hf' : HasDerivAt Ï• 1 zâ‚€) :\n  âˆƒ (a b : â„‚), âˆ€ z âˆˆ Î©, Ï• z = a * z + b ",
      "âˆ€ {Î© : Set â„‚} {Ï• : â„‚ â†’ â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      DifferentiableOn â„‚ Ï• Î© â†’\n        Set.MapsTo Ï• Î© Î© â†’\n          âˆƒ (zâ‚€ : â„‚), zâ‚€ âˆˆ Î© âˆ§ Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivWithinAt Ï• 1 Î© zâ‚€ â†’ IsLinearMap â„‚ Ï• ",
      "âˆ€ {Î© : Set â„‚} [inst : IsOpen Î©],\n  Bounded Î© â†’\n    âˆ€ {Ï• : â„‚ â†’ â„‚}, AnalyticOn â„‚ Î© Ï• â†’\n      (âˆƒ zâ‚€, zâ‚€ âˆˆ Î© âˆ§ Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivWithinAt Ï• 1 Î© zâ‚€) â†’\n        Linear.IsLinear Ï• ",
      "âˆ€ {Î© : Set â„‚},\n  IsOpen Î© â†’\n  Metric.Bounded Î© â†’\n  âˆ€ {Ï• : â„‚ â†’ â„‚},\n    DifferentiableOn â„‚ Ï• Î© â†’ Set.MapsTo Ï• Î© Î© â†’\n      âˆ€ {zâ‚€ : â„‚}, zâ‚€ âˆˆ Î© â†’ Ï• zâ‚€ = zâ‚€ â†’ HasDerivAt Ï• 1 zâ‚€ â†’\n        âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = zâ‚€ + (z - zâ‚€) ",
      "âˆ€ {Î© : Set â„‚} (hÎ© : IsOpen Î©) [inst : Metric.Bounded Î©] {Ï• : â„‚ â†’ â„‚},\n  DifferentiableOn â„‚ Ï• Î© â†’\n    Set.MapsTo Ï• Î© Î© â†’\n      âˆ€ {zâ‚€ : â„‚}, zâ‚€ âˆˆ Î© â†’ Ï• zâ‚€ = zâ‚€ â†’ HasDerivAt Ï• 1 zâ‚€ â†’ âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = zâ‚€ + (z - zâ‚€) ",
      "âˆ€ {Î© : Set â„‚} {Ï• : â„‚ â†’ â„‚}, IsOpen Î© â†’ Metric.Bounded Î© â†’ DifferentiableOn â„‚ Ï• Î© â†’\n  ContinuousOn Ï• Î© â†’ BoundedLinearMap â„ â„‚ â„‚ â†’\n  (âˆƒ zâ‚€, zâ‚€ âˆˆ Î© âˆ§ Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï• 1 zâ‚€) â†’\n  âˆ€ z, z âˆˆ Î© â†’ Ï• z = z + (Ï• zâ‚€ - zâ‚€) ",
      "âˆ€ {Î© : Set â„‚} [inst : MetricSpace â„‚] [inst_1 : BoundedSubset Î©] {Ï• : â„‚ â†’ â„‚},\n  DifferentiableOn â„‚ Ï• Î© â†’\n    Set.MapsTo Ï• Î© Î© â†’\n      âˆƒ zâ‚€ âˆˆ Î©, (Ï• zâ‚€ = zâ‚€ âˆ§ HasStrictDerivAt Ï• 1 zâ‚€) â†’\n        âˆ€ (z : â„‚) (hz : z âˆˆ Î©), Ï• z = z + (Ï• zâ‚€ - zâ‚€) * (z - zâ‚€) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {Î© : Set â„‚}, IsOpen Î© â†’ Metric.Bounded Î© â†’\n  âˆ€ {Ï• : â„‚ â†’ â„‚}, DifferentiableOn â„‚ Ï• Î© â†’ Set.MapsTo Ï• Î© Î© â†’\n    âˆƒ zâ‚€ âˆˆ Î©, Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï• 1 zâ‚€ â†’\n      âˆƒ (a : â„‚) (b : â„‚), âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = a * z + b ",
      "âˆ€ {Î© : Set â„‚} {Ï• : â„‚ â†’ â„‚},\n  IsOpen Î© â†’\n    Metric.Bounded Î© â†’\n      DifferentiableOn â„‚ Ï• Î© â†’\n        Set.MapsTo Ï• Î© Î© â†’\n          âˆƒ (zâ‚€ : â„‚), zâ‚€ âˆˆ Î© âˆ§ Ï• zâ‚€ = zâ‚€ âˆ§ HasDerivAt Ï• 1 zâ‚€ â†’\n            âˆ€ (z : â„‚), z âˆˆ Î© â†’ Ï• z = z + (Ï• zâ‚€ - zâ‚€) "
    ]
  },
  {
    "docString": "Show that `âˆ«_{-âˆ}^{âˆ} cos x / (x^2 + a^2) dx = Ï€ e^{-a} / a` for `a > 0`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (a : â„) {b : â„}, 0 < b â†’ MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a)\",\n  \"isProp\": true,\n  \"docString\": \"`exp (-b * x)` is integrable on `(a, âˆ)`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•), âˆ« (x : â„) in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral of `|x - a| ^ n` over `Î™ a b`. This integral appears in the proof of the\\nPicard-LindelÃ¶f/Cauchy-Lipschitz theorem. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\\nwhich is studied in `Data.Real.Pi.Wallis` and other places. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„}, a < -1 â†’ âˆ€ {c : â„}, 0 < c â†’ MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `0 < c`, then `(Î» t : â„, t ^ a)` is integrable on `(c, âˆ)` for all `a < -1`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•),\\n  âˆ« (x : â„) in a..b, Real.cos x ^ (n + 2) =\\n    (Real.cos b ^ (n + 1) * Real.sin b - Real.cos a ^ (n + 1) * Real.sin a) / (â†‘n + 2) +\\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.cos x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `cos x ^ n` for any natural `n â‰¥ 2`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"âˆ€ {a : â„}, 0 < a â†’ âˆ€ (b : â„), (fun x => rexp (-a * x)) =o[Filter.atTop] fun x => x ^ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"`exp (-a * x) = o(x ^ s)` as `x â†’ âˆ`, for any positive `a` and real `s`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„},\\n  a â‰¤ 0 â†’\\n    âˆ€ {z : â„‚},\\n      |z.im| â‰¤ b â†’\\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\\n$$\\\\left|exp^{a\\\\left(e^{z}+e^{-z}\\\\right)}\\\\right| \\\\le e^{a\\\\cos b \\\\exp^{|re z|}}.$$\\n\"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds a) â†’ ContinuousAt f a â†’ deriv (fun u => âˆ« (x : â„) in u..b, f x) a = -f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f` is continuous\\nat `a`, then the derivative of `u â†¦ âˆ« x in u..b, f x` at `a` equals `-f a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds a) â†’\\n      Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n        HasDerivAt (fun u => âˆ« (x : â„) in u..b, f x) (-c) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\\nfinite limit `c` almost surely at `a`, then `u â†¦ âˆ« x in u..b, f x` has derivative `-c` at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds a) â†’ ContinuousAt f a â†’ HasDerivAt (fun u => âˆ« (x : â„) in u..b, f x) (-f a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f` is\\ncontinuous at `a`, then `u â†¦ âˆ« x in u..b, f x` has derivative `-f a` at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_4} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {ğ•œ : Type u_1} [inst_1 : IsROrC ğ•œ]\\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace â„ E] [inst_4 : NormedSpace ğ•œ E]\\n  [inst_5 : CompleteSpace E] {H : Type u_2} [inst_6 : NormedAddCommGroup H] [inst_7 : NormedSpace ğ•œ H] {F : H â†’ Î± â†’ E}\\n  {F' : Î± â†’ H â†’L[ğ•œ] E} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„},\\n  0 < Îµ â†’\\n    (âˆ€á¶  (x : H) in nhds xâ‚€, MeasureTheory.AEStronglyMeasurable (F x) Î¼) â†’\\n      MeasureTheory.Integrable (F xâ‚€) â†’\\n        MeasureTheory.AEStronglyMeasurable F' Î¼ â†’\\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, LipschitzOnWith (â†‘Real.nnabs (bound a)) (fun x => F x a) (Metric.ball xâ‚€ Îµ)) â†’\\n            MeasureTheory.Integrable bound â†’\\n              (âˆ€áµ (a : Î±) âˆ‚Î¼, HasFDerivAt (fun x => F x a) (F' a) xâ‚€) â†’\\n                MeasureTheory.Integrable F' âˆ§ HasFDerivAt (fun x => âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"Differentiation under integral of `x â†¦ âˆ« F x a` at a given point `xâ‚€`, assuming\\n`F xâ‚€` is integrable, `x â†¦ F x a` is locally Lipschitz on a ball around `xâ‚€` for ae `a`\\n(with a ball radius independent of `a`) with integrable Lipschitz bound, and `F x` is ae-measurable\\nfor `x` in a possibly smaller neighborhood of `xâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {ğ•œ : Type u_1} [inst_1 : IsROrC ğ•œ]\\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace â„ E] [inst_4 : NormedSpace ğ•œ E]\\n  [inst_5 : CompleteSpace E] {F F' : ğ•œ â†’ Î± â†’ E} {xâ‚€ : ğ•œ} {Îµ : â„},\\n  0 < Îµ â†’\\n    (âˆ€á¶  (x : ğ•œ) in nhds xâ‚€, MeasureTheory.AEStronglyMeasurable (F x) Î¼) â†’\\n      MeasureTheory.Integrable (F xâ‚€) â†’\\n        MeasureTheory.AEStronglyMeasurable (F' xâ‚€) Î¼ â†’\\n          âˆ€ {bound : Î± â†’ â„},\\n            (âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : ğ•œ), x âˆˆ Metric.ball xâ‚€ Îµ â†’ â€–F' x aâ€– â‰¤ bound a) â†’\\n              MeasureTheory.Integrable bound â†’\\n                (âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : ğ•œ), x âˆˆ Metric.ball xâ‚€ Îµ â†’ HasDerivAt (fun x => F x a) (F' x a) x) â†’\\n                  MeasureTheory.Integrable (F' xâ‚€) âˆ§\\n                    HasDerivAt (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€\",\n  \"isProp\": true,\n  \"docString\":\n  \"Derivative under integral of `x â†¦ âˆ« F x a` at a given point `xâ‚€ : â„`, assuming\\n`F xâ‚€` is integrable, `x â†¦ F x a` is differentiable on an interval around `xâ‚€` for ae `a`\\n(with interval radius independent of `a`) with derivative uniformly bounded by an integrable\\nfunction, and `F x` is ae-measurable for `x` in a possibly smaller neighborhood of `xâ‚€`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\\n  {a b : â„},\\n  IntervalIntegrable f MeasureTheory.volume a b â†’\\n    StronglyMeasurableAtFilter f (nhds a) â†’\\n      Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\\n        deriv (fun u => âˆ« (x : â„) in u..b, f x) a = -c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f` has a finite\\nlimit `c` almost surely at `a`, then the derivative of `u â†¦ âˆ« x in u..b, f x` at `a` equals `-c`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {a b : â„}\\n  {Î¼ : MeasureTheory.Measure â„} [inst_3 : MeasureTheory.IsFiniteMeasure Î¼] (c : E),\\n  âˆ« (x : â„) in a..b, c âˆ‚Î¼ = (ENNReal.toReal (â†‘â†‘Î¼ (Set.Iic b)) - ENNReal.toReal (â†‘â†‘Î¼ (Set.Iic a))) â€¢ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î¼` is a finite measure then `âˆ« x in a..b, c âˆ‚Î¼ = (Î¼ (Iic b) - Î¼ (Iic a)) â€¢ c`. \"},\n {\"theorem\": \"âˆ€ (a : â„), Cardinal.mk â†‘(Set.Iic a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval (-âˆ, a]. \"}]\n",
    "prompt_cons": "/-- `exp (-b * x)` is integrable on `(a, âˆ)`. -/\ntheorem âˆ€ (a : â„) {b : â„}, 0 < b â†’ MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a) :=\n\n/-- Integral of `|x - a| ^ n` over `Î™ a b`. This integral appears in the proof of the\nPicard-LindelÃ¶f/Cauchy-Lipschitz theorem. -/\ntheorem âˆ€ {a b : â„} (n : â„•), âˆ« (x : â„) in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1) :=\n\n/-- Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. -/\ntheorem âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n :=\n\n/-- If `0 < c`, then `(Î» t : â„, t ^ a)` is integrable on `(c, âˆ)` for all `a < -1`. -/\ntheorem âˆ€ {a : â„}, a < -1 â†’ âˆ€ {c : â„}, 0 < c â†’ MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c) :=\n\n/-- The reduction formula for the integral of `cos x ^ n` for any natural `n â‰¥ 2`. -/\ntheorem âˆ€ {a b : â„} (n : â„•),\n  âˆ« (x : â„) in a..b, Real.cos x ^ (n + 2) =\n    (Real.cos b ^ (n + 1) * Real.sin b - Real.cos a ^ (n + 1) * Real.sin a) / (â†‘n + 2) +\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.cos x ^ n :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`Ï€ < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â†’ 1 / 4 ^ n â‰¤ a â†’ Real.pi < a :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (Ï€ / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < Ï€`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem âˆ€ (n : â„•) {a : â„}, Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2 â†’ a < Real.pi :=\n\n/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (a b : A),\n  â†‘(PowerSeries.rescale a) (PowerSeries.exp A) * â†‘(PowerSeries.rescale b) (PowerSeries.exp A) =\n    â†‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- `exp (-a * x) = o(x ^ s)` as `x â†’ âˆ`, for any positive `a` and real `s`. -/\ntheorem âˆ€ {a : â„}, 0 < a â†’ âˆ€ (b : â„), (fun x => rexp (-a * x)) =o[Filter.atTop] fun x => x ^ b :=\n\n/-- A supporting lemma for the **Phragmen-LindelÃ¶f principle** in a horizontal strip. If `z : â„‚`\nbelongs to a horizontal strip `|Complex.im z| â‰¤ b`, `b â‰¤ Ï€ / 2`, and `a â‰¤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$ -/\ntheorem âˆ€ {a b : â„},\n  a â‰¤ 0 â†’\n    âˆ€ {z : â„‚},\n      |z.im| â‰¤ b â†’\n        b â‰¤ Real.pi / 2 â†’ â†‘Complex.abs (cexp (â†‘a * (cexp z + cexp (-z)))) â‰¤ rexp (a * Real.cos b * rexp |z.re|) :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f` is continuous\nat `a`, then the derivative of `u â†¦ âˆ« x in u..b, f x` at `a` equals `-f a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds a) â†’ ContinuousAt f a â†’ deriv (fun u => âˆ« (x : â„) in u..b, f x) a = -f a :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f x` has a\nfinite limit `c` almost surely at `a`, then `u â†¦ âˆ« x in u..b, f x` has derivative `-c` at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds a) â†’\n      Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n        HasDerivAt (fun u => âˆ« (x : â„) in u..b, f x) (-c) a :=\n\n/-- **Fundamental theorem of calculus-1**: if `f : â„ â†’ E` is integrable on `a..b` and `f` is\ncontinuous at `a`, then `u â†¦ âˆ« x in u..b, f x` has derivative `-f a` at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds a) â†’ ContinuousAt f a â†’ HasDerivAt (fun u => âˆ« (x : â„) in u..b, f x) (-f a) a :=\n\n/-- Differentiation under integral of `x â†¦ âˆ« F x a` at a given point `xâ‚€`, assuming\n`F xâ‚€` is integrable, `x â†¦ F x a` is locally Lipschitz on a ball around `xâ‚€` for ae `a`\n(with a ball radius independent of `a`) with integrable Lipschitz bound, and `F x` is ae-measurable\nfor `x` in a possibly smaller neighborhood of `xâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_4} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {ğ•œ : Type u_1} [inst_1 : IsROrC ğ•œ]\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace â„ E] [inst_4 : NormedSpace ğ•œ E]\n  [inst_5 : CompleteSpace E] {H : Type u_2} [inst_6 : NormedAddCommGroup H] [inst_7 : NormedSpace ğ•œ H] {F : H â†’ Î± â†’ E}\n  {F' : Î± â†’ H â†’L[ğ•œ] E} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„},\n  0 < Îµ â†’\n    (âˆ€á¶  (x : H) in nhds xâ‚€, MeasureTheory.AEStronglyMeasurable (F x) Î¼) â†’\n      MeasureTheory.Integrable (F xâ‚€) â†’\n        MeasureTheory.AEStronglyMeasurable F' Î¼ â†’\n          (âˆ€áµ (a : Î±) âˆ‚Î¼, LipschitzOnWith (â†‘Real.nnabs (bound a)) (fun x => F x a) (Metric.ball xâ‚€ Îµ)) â†’\n            MeasureTheory.Integrable bound â†’\n              (âˆ€áµ (a : Î±) âˆ‚Î¼, HasFDerivAt (fun x => F x a) (F' a) xâ‚€) â†’\n                MeasureTheory.Integrable F' âˆ§ HasFDerivAt (fun x => âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€ :=\n\n/-- Derivative under integral of `x â†¦ âˆ« F x a` at a given point `xâ‚€ : â„`, assuming\n`F xâ‚€` is integrable, `x â†¦ F x a` is differentiable on an interval around `xâ‚€` for ae `a`\n(with interval radius independent of `a`) with derivative uniformly bounded by an integrable\nfunction, and `F x` is ae-measurable for `x` in a possibly smaller neighborhood of `xâ‚€`. -/\ntheorem âˆ€ {Î± : Type u_2} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {ğ•œ : Type u_1} [inst_1 : IsROrC ğ•œ]\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace â„ E] [inst_4 : NormedSpace ğ•œ E]\n  [inst_5 : CompleteSpace E] {F F' : ğ•œ â†’ Î± â†’ E} {xâ‚€ : ğ•œ} {Îµ : â„},\n  0 < Îµ â†’\n    (âˆ€á¶  (x : ğ•œ) in nhds xâ‚€, MeasureTheory.AEStronglyMeasurable (F x) Î¼) â†’\n      MeasureTheory.Integrable (F xâ‚€) â†’\n        MeasureTheory.AEStronglyMeasurable (F' xâ‚€) Î¼ â†’\n          âˆ€ {bound : Î± â†’ â„},\n            (âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : ğ•œ), x âˆˆ Metric.ball xâ‚€ Îµ â†’ â€–F' x aâ€– â‰¤ bound a) â†’\n              MeasureTheory.Integrable bound â†’\n                (âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : ğ•œ), x âˆˆ Metric.ball xâ‚€ Îµ â†’ HasDerivAt (fun x => F x a) (F' x a) x) â†’\n                  MeasureTheory.Integrable (F' xâ‚€) âˆ§\n                    HasDerivAt (fun n => âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€ :=\n\n/-- Fundamental theorem of calculus: if `f : â„ â†’ E` is integrable on `a..b` and `f` has a finite\nlimit `c` almost surely at `a`, then the derivative of `u â†¦ âˆ« x in u..b, f x` at `a` equals `-c`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {c : E}\n  {a b : â„},\n  IntervalIntegrable f MeasureTheory.volume a b â†’\n    StronglyMeasurableAtFilter f (nhds a) â†’\n      Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) â†’\n        deriv (fun u => âˆ« (x : â„) in u..b, f x) a = -c :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (n : â„•),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => â†‘(k ^ p) * â†‘(algebraMap â„š A) (â†‘(Nat.factorial p))â»Â¹ :=\n\n/-- If `Î¼` is a finite measure then `âˆ« x in a..b, c âˆ‚Î¼ = (Î¼ (Iic b) - Î¼ (Iic a)) â€¢ c`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {a b : â„}\n  {Î¼ : MeasureTheory.Measure â„} [inst_3 : MeasureTheory.IsFiniteMeasure Î¼] (c : E),\n  âˆ« (x : â„) in a..b, c âˆ‚Î¼ = (ENNReal.toReal (â†‘â†‘Î¼ (Set.Iic b)) - ENNReal.toReal (â†‘â†‘Î¼ (Set.Iic a))) â€¢ c :=\n\n/-- The cardinality of the interval (-âˆ, a]. -/\ntheorem âˆ€ (a : â„), Cardinal.mk â†‘(Set.Iic a) = Cardinal.continuum :=\n\n/-- Show that `âˆ«_{-âˆ}^{âˆ} cos x / (x^2 + a^2) dx = Ï€ e^{-a} / a` for `a > 0`. -/\ntheorem",
    "choices": [
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in (-Real.pi) ..Real.pi, Real.cos x / (x^2 + a^2) = (Real.pi * rexp(-a)) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) / a ",
      "âˆ€ (a : â„), 0 < a â†’ âˆ« x in Set.Iic âŠ¤, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) / a ",
      "forall {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * (Real.exp (-a)) / a ",
      "forall_pos_gt_of_integrable_real_of_exponential_decay {a : â„} (ha : 0 < a) :\n  âˆ« (x : â„) in âŠ¥..âŠ¤, Real.cos x / (x^2 + a^2) = Real.pi * rexp (-a) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, (Real.cos x) / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x^2 + a^2) = Ï€ * rexp (-a) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -âˆ..âˆ, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * (rexp (-a) / a) ",
      "âˆ€ (a : â„), 0 < a â†’ âˆ« x in â„, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) / a ",
      "âˆ€ {a : â„}, 0 < a â†’ âˆ« (x : â„) in -Real.pi..Real.pi, Real.cos x / (x^2 + a^2) = Real.pi * rexp (-a) / a "
    ]
  },
  {
    "docString": "Show that `âˆ«_0^1 log(sin Ï€ x) dx = -log 2`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•),\\n  âˆ« (x : â„) in a..b, Real.sin x ^ (n + 2) =\\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (â†‘n + 2) +\\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `sin x ^ n` for any natural `n â‰¥ 2`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\\nwhich is studied in `Data.Real.Pi.Wallis` and other places. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * x ^ (2 * k + 1)) (Real.log (1 + x) - Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. \"},\n {\"theorem\": \"Real.sin (Real.pi / 6) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `Ï€ / 6` is `1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ (x : â„), Real.cos x â‰  0 â†’ deriv (fun y => Real.tan y - y) x = â†‘1 / Real.cos x ^ 2 - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The derivative of `tan x - x` is `1/(cos x)^2 - 1` away from the zeroes of cos. \"},\n {\"theorem\": \"âˆ€ (x : â„), 0 < x â†’ x â‰¤ 1 â†’ |Real.log x * x| < 1\",\n  \"isProp\": true,\n  \"docString\": \"Bound for `|log x * x|` in the interval `(0, 1]`. \"},\n {\"theorem\": \"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `Ï€ / 3` is `âˆš3 / 2`. \"},\n {\"theorem\": \"Real.cos (Real.pi / 3) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `Ï€ / 3` is `1 / 2`. \"},\n {\"theorem\": \"âˆ€ {x : â„}, 0 < x â†’ x < Real.pi / 2 â†’ x < Real.tan x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `0 < x < Ï€/2` we have `x < tan x`.\\n\\nThis is proved by checking that the function `tan x - x` vanishes\\nat zero and has non-negative derivative. \"},\n {\"theorem\": \"Real.cos (Real.pi / 6) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `Ï€ / 6` is `âˆš3 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (n : â„•),\\n  âˆ« (x : â„) in a..b, Real.cos x ^ (n + 2) =\\n    (Real.cos b ^ (n + 1) * Real.sin b - Real.cos a ^ (n + 1) * Real.sin a) / (â†‘n + 2) +\\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.cos x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `cos x ^ n` for any natural `n â‰¥ 2`. \"},\n {\"theorem\":\n  \"âˆ€ {a : â„}, 0 < a â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1)) (Real.log (1 + aâ»Â¹))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Expansion of `log (1 + aâ»Â¹)` as a series in powers of `1 / (2 * a + 1)`. \"},\n {\"theorem\": \"Real.Gamma (1 / 2) = Real.sqrt Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"The special-value formula `Î“(1/2) = âˆšÏ€`, which is equivalent to the Gaussian integral. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]\\n  {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} [inst_2 : NormedAddCommGroup E]\\n  [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : NormedSpace â„ E] [inst_5 : CompleteSpace E]\\n  [inst_6 : MeasureTheory.SigmaFinite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„,\\n  MeasureTheory.Integrable f â†’\\n    MeasureTheory.Integrable g â†’\\n      âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼ =\\n        âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼\",\n  \"isProp\": true,\n  \"docString\": \"Double integrals commute with subtraction. \"},\n {\"theorem\": \"âˆ€ (x : â„‚), HasDerivAt Complex.cos (-Complex.sin x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complex cosine function is everywhere differentiable, with the derivative `-sin x`. \"},\n {\"theorem\":\n  \"Filter.Tendsto\\n  (fun k => Finset.prod (Finset.range k) fun i => (2 * â†‘i + 2) / (2 * â†‘i + 1) * ((2 * â†‘i + 2) / (2 * â†‘i + 3)))\\n  Filter.atTop (nhds (Real.pi / 2))\",\n  \"isProp\": true,\n  \"docString\": \"Wallis' product formula for `Ï€ / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace â„ V]\\n  [inst_6 : FiniteDimensional â„ V],\\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-inner v w))) â€¢ f v)\\n    (Filter.cocompact V) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\\n`âˆ« v, exp (-2 * Ï€ * âŸªw, vâŸ« * I) â€¢ f v` tends to 0 as `w â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„} (m n : â„•),\\n  âˆ« (x : â„) in a..b, Real.sin x ^ (2 * m + 1) * Real.cos x ^ n =\\n    âˆ« (u : â„) in Real.cos b..Real.cos a, u ^ n * (1 - u ^ 2) ^ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"Simplification of the integral of `sin x ^ m * cos x ^ n`, case `m` is odd. \"}]\n",
    "prompt_cons": "/-- The reduction formula for the integral of `sin x ^ n` for any natural `n â‰¥ 2`. -/\ntheorem âˆ€ {a b : â„} (n : â„•),\n  âˆ« (x : â„) in a..b, Real.sin x ^ (n + 2) =\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (â†‘n + 2) +\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.sin x ^ n :=\n\n/-- Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. -/\ntheorem âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * â†‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. -/\ntheorem âˆ€ {x : â„}, |x| < 1 â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * x ^ (2 * k + 1)) (Real.log (1 + x) - Real.log (1 - x)) :=\n\n/-- The sine of `Ï€ / 6` is `1 / 2`. -/\ntheorem Real.sin (Real.pi / 6) = 1 / 2 :=\n\n/-- The derivative of `tan x - x` is `1/(cos x)^2 - 1` away from the zeroes of cos. -/\ntheorem âˆ€ (x : â„), Real.cos x â‰  0 â†’ deriv (fun y => Real.tan y - y) x = â†‘1 / Real.cos x ^ 2 - 1 :=\n\n/-- Bound for `|log x * x|` in the interval `(0, 1]`. -/\ntheorem âˆ€ (x : â„), 0 < x â†’ x â‰¤ 1 â†’ |Real.log x * x| < 1 :=\n\n/-- The sine of `Ï€ / 3` is `âˆš3 / 2`. -/\ntheorem Real.sin (Real.pi / 3) = Real.sqrt 3 / 2 :=\n\n/-- The cosine of `Ï€ / 3` is `1 / 2`. -/\ntheorem Real.cos (Real.pi / 3) = 1 / 2 :=\n\n/-- For all `0 < x < Ï€/2` we have `x < tan x`.\n\nThis is proved by checking that the function `tan x - x` vanishes\nat zero and has non-negative derivative. -/\ntheorem âˆ€ {x : â„}, 0 < x â†’ x < Real.pi / 2 â†’ x < Real.tan x :=\n\n/-- The cosine of `Ï€ / 6` is `âˆš3 / 2`. -/\ntheorem Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 :=\n\n/-- The reduction formula for the integral of `cos x ^ n` for any natural `n â‰¥ 2`. -/\ntheorem âˆ€ {a b : â„} (n : â„•),\n  âˆ« (x : â„) in a..b, Real.cos x ^ (n + 2) =\n    (Real.cos b ^ (n + 1) * Real.sin b - Real.cos a ^ (n + 1) * Real.sin a) / (â†‘n + 2) +\n      (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, Real.cos x ^ n :=\n\n/-- Expansion of `log (1 + aâ»Â¹)` as a series in powers of `1 / (2 * a + 1)`. -/\ntheorem âˆ€ {a : â„}, 0 < a â†’ HasSum (fun k => 2 * (1 / (2 * â†‘k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1)) (Real.log (1 + aâ»Â¹)) :=\n\n/-- The special-value formula `Î“(1/2) = âˆšÏ€`, which is equivalent to the Gaussian integral. -/\ntheorem Real.Gamma (1 / 2) = Real.sqrt Real.pi :=\n\n/-- Double integrals commute with subtraction. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²]\n  {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} [inst_2 : NormedAddCommGroup E]\n  [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : NormedSpace â„ E] [inst_5 : CompleteSpace E]\n  [inst_6 : MeasureTheory.SigmaFinite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„,\n  MeasureTheory.Integrable f â†’\n    MeasureTheory.Integrable g â†’\n      âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼ =\n        âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼ :=\n\n/-- The complex cosine function is everywhere differentiable, with the derivative `-sin x`. -/\ntheorem âˆ€ (x : â„‚), HasDerivAt Complex.cos (-Complex.sin x) x :=\n\n/-- Wallis' product formula for `Ï€ / 2`. -/\ntheorem Filter.Tendsto\n  (fun k => Finset.prod (Finset.range k) fun i => (2 * â†‘i + 2) / (2 * â†‘i + 1) * ((2 * â†‘i + 2) / (2 * â†‘i + 3)))\n  Filter.atTop (nhds (Real.pi / 2)) :=\n\n/-- Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\n`âˆ« v, exp (-2 * Ï€ * âŸªw, vâŸ« * I) â€¢ f v` tends to 0 as `w â†’ âˆ`. -/\ntheorem âˆ€ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : V â†’ E)\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace â„ V]\n  [inst_6 : FiniteDimensional â„ V],\n  Filter.Tendsto (fun w => âˆ« (v : V), â†‘(â†‘Real.fourierChar (â†‘Multiplicative.ofAdd (-inner v w))) â€¢ f v)\n    (Filter.cocompact V) (nhds 0) :=\n\n/-- Simplification of the integral of `sin x ^ m * cos x ^ n`, case `m` is odd. -/\ntheorem âˆ€ {a b : â„} (m n : â„•),\n  âˆ« (x : â„) in a..b, Real.sin x ^ (2 * m + 1) * Real.cos x ^ n =\n    âˆ« (u : â„) in Real.cos b..Real.cos a, u ^ n * (1 - u ^ 2) ^ m :=\n\n/-- Show that `âˆ«_0^1 log(sin Ï€ x) dx = -log 2`. -/\ntheorem",
    "choices": [
      "(âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x))) = -Real.log 2 ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "Real.integral_sin_pow_log ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "Real.integral_sin_pow_log (0..1) = -Real.log 2 ",
      "Real.integral_sin_pi_log : âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "integral_sin_pi_log_sin 0 1 = -Real.log 2 ",
      "âˆ« (x : â„) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 "
    ]
  },
  {
    "docString": "Show that there is no holomorphic function `f` in the unit disc `D` that extends continuously to `âˆ‚D` such that `f(z) = 1/z` for `z âˆˆ âˆ‚D`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\\n  0 â‰¤ R â†’\\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\\n      Set.Countable s â†’\\n        ContinuousOn f (Metric.closedBall c R) â†’\\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\\\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\\nthen the integral $\\\\oint_{|z-c|=R}f(z)\\\\,dz$ equals zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\\nother. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"On an empty space, bounded continuous functions are at distance 0. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"},\n {\"theorem\":\n  \"âˆ€ {Gâ‚€ : Type u_1} [inst : Zero Gâ‚€] [inst_1 : Inv Gâ‚€] [inst_2 : TopologicalSpace Gâ‚€] [self : HasContinuousInvâ‚€ Gâ‚€]\\n  â¦ƒx : Gâ‚€â¦„, x â‰  0 â†’ ContinuousAt Inv.inv x\",\n  \"isProp\": true,\n  \"docString\": \"The map `fun x â†¦ xâ»Â¹` is continuous at all nonzero points. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the first quadrant.\\n\\nThen `f` is equal to zero on the closed first quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f f' : â„‚ â†’ E}\\n  {c : â„‚} {R : â„},\\n  (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c |R| â†’ HasDerivWithinAt f (f' z) (Metric.sphere c |R|) z) â†’\\n    (âˆ® (z : â„‚) in C(c, R), f' z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f' : â„‚ â†’ E` is a derivative of a complex differentiable function on the circle\\n`Metric.sphere c |R|`, then `âˆ® z in C(c, R), f' z = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f f' : â„‚ â†’ E}\\n  {c : â„‚} {R : â„},\\n  0 â‰¤ R â†’\\n    (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c R â†’ HasDerivWithinAt f (f' z) (Metric.sphere c R) z) â†’\\n      (âˆ® (z : â„‚) in C(c, R), f' z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f' : â„‚ â†’ E` is a derivative of a complex differentiable function on the circle\\n`Metric.sphere c R`, then `âˆ® z in C(c, R), f' z = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’\\n    ((fun z => f z - f c) =o[nhdsWithin c {c}á¶œ] fun z => (z - c)â»Â¹) â†’\\n      Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (limUnder (nhdsWithin c {c}á¶œ) f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\\n  0 < r â†’\\n    r â‰¤ R â†’\\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\\n        Set.Countable s â†’\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) â†’\\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_1 : TopologicalSpace G]\\n  [inst_2 : Group G] [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G]\\n  [inst_5 : MeasureTheory.Measure.IsMulLeftInvariant Î¼] [inst_6 : MeasureTheory.Measure.Regular Î¼],\\n  Î¼ â‰  0 â†’ âˆ€ {f : G â†’ ENNReal}, Continuous f â†’ (âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nonzero regular left invariant measures, the integral of a continuous nonnegative function\\n`f` is 0 iff `f` is 0. \"},\n {\"theorem\": \"âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚], HasStrictDerivAt (exp ğ•‚) 1 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The exponential map in `ğ•‚ = â„` or `ğ•‚ = â„‚` has strict derivative `1` at zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_1 : TopologicalSpace G]\\n  [inst_2 : AddGroup G] [inst_3 : TopologicalAddGroup G] [inst_4 : BorelSpace G]\\n  [inst_5 : MeasureTheory.Measure.IsAddLeftInvariant Î¼] [inst_6 : MeasureTheory.Measure.Regular Î¼],\\n  Î¼ â‰  0 â†’ âˆ€ {f : G â†’ ENNReal}, Continuous f â†’ (âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nonzero regular left invariant measures, the integral of a continuous nonnegative\\nfunction `f` is 0 iff `f` is 0.\"}]\n",
    "prompt_cons": "/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ âˆ€ (a b : M), f a = f b :=\n\n/-- **Cauchy-Goursat theorem** for a disk: if `f : â„‚ â†’ E` is continuous on a closed disk\n`{z | â€–z - câ€– â‰¤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {R : â„},\n  0 â‰¤ R â†’\n    âˆ€ {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚},\n      Set.Countable s â†’\n        ContinuousOn f (Metric.closedBall c R) â†’\n          (âˆ€ (z : â„‚), z âˆˆ Metric.ball c R \\ s â†’ DifferentiableAt â„‚ f z) â†’ (âˆ® (z : â„‚) in C(c, R), f z) = 0 :=\n\n/-- Given two disjoint closed sets in a Hausdorff Ïƒ-compact finite dimensional manifold, there\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\nother. -/\ntheorem âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Set.EqOn (â†‘f) 0 s âˆ§ Set.EqOn (â†‘f) 1 t âˆ§ âˆ€ (x : M), â†‘f x âˆˆ Set.Icc 0 1 :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ IsLocallyConstant f :=\n\n/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²]\n  {f g : BoundedContinuousFunction Î± Î²} [inst_2 : IsEmpty Î±], dist f g = 0 :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ ContinuousOn f (EMetric.ball x r) :=\n\n/-- The map `fun x â†¦ xâ»Â¹` is continuous at all nonzero points. -/\ntheorem âˆ€ {Gâ‚€ : Type u_1} [inst : Zero Gâ‚€] [inst_1 : Inv Gâ‚€] [inst_2 : TopologicalSpace Gâ‚€] [self : HasContinuousInvâ‚€ Gâ‚€]\n  â¦ƒx : Gâ‚€â¦„, x â‰  0 â†’ ContinuousAt Inv.inv x :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the first quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the first quadrant.\n\nThen `f` is equal to zero on the closed first quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im} :=\n\n/-- If `f' : â„‚ â†’ E` is a derivative of a complex differentiable function on the circle\n`Metric.sphere c |R|`, then `âˆ® z in C(c, R), f' z = 0`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f f' : â„‚ â†’ E}\n  {c : â„‚} {R : â„},\n  (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c |R| â†’ HasDerivWithinAt f (f' z) (Metric.sphere c |R|) z) â†’\n    (âˆ® (z : â„‚) in C(c, R), f' z) = 0 :=\n\n/-- If `f' : â„‚ â†’ E` is a derivative of a complex differentiable function on the circle\n`Metric.sphere c R`, then `âˆ® z in C(c, R), f' z = 0`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f f' : â„‚ â†’ E}\n  {c : â„‚} {R : â„},\n  0 â‰¤ R â†’\n    (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c R â†’ HasDerivWithinAt f (f' z) (Metric.sphere c R) z) â†’\n      (âˆ® (z : â„‚) in C(c, R), f' z) = 0 :=\n\n/-- **Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’\n    ((fun z => f z - f c) =o[nhdsWithin c {c}á¶œ] fun z => (z - c)â»Â¹) â†’\n      Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (limUnder (nhdsWithin c {c}á¶œ) f)) :=\n\n/-- If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\nequal to each other. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\n  0 < r â†’\n    r â‰¤ R â†’\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\n        Set.Countable s â†’\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) â†’\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\ Metric.closedBall c r) \\ s â†’ DifferentiableAt â„‚ f z) â†’\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- For nonzero regular left invariant measures, the integral of a continuous nonnegative function\n`f` is 0 iff `f` is 0. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_1 : TopologicalSpace G]\n  [inst_2 : Group G] [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G]\n  [inst_5 : MeasureTheory.Measure.IsMulLeftInvariant Î¼] [inst_6 : MeasureTheory.Measure.Regular Î¼],\n  Î¼ â‰  0 â†’ âˆ€ {f : G â†’ ENNReal}, Continuous f â†’ (âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0) :=\n\n/-- The exponential map in `ğ•‚ = â„` or `ğ•‚ = â„‚` has strict derivative `1` at zero. -/\ntheorem âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚], HasStrictDerivAt (exp ğ•‚) 1 0 :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0 :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0} :=\n\n/-- Proof of the continuity of the map. -/\ntheorem âˆ€ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â†‘f :=\n\n/-- For nonzero regular left invariant measures, the integral of a continuous nonnegative\nfunction `f` is 0 iff `f` is 0. -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_1 : TopologicalSpace G]\n  [inst_2 : AddGroup G] [inst_3 : TopologicalAddGroup G] [inst_4 : BorelSpace G]\n  [inst_5 : MeasureTheory.Measure.IsAddLeftInvariant Î¼] [inst_6 : MeasureTheory.Measure.Regular Î¼],\n  Î¼ â‰  0 â†’ âˆ€ {f : G â†’ ENNReal}, Continuous f â†’ (âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0) :=\n\n/-- Show that there is no holomorphic function `f` in the unit disc `D` that extends continuously to `âˆ‚D` such that `f(z) = 1/z` for `z âˆˆ âˆ‚D`. -/\ntheorem",
    "choices": [
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {D : Set â„‚} {f : â„‚ â†’ E},\n  D = Metric.Ball 0 1 â†’\n  ContinuousOn f (Closure D) â†’\n  Set.EqOn f (Î» z, zâ»Â¹) (Closure (Metric.Sphere 0 1)) â†’ False ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {D : Set â„‚} (hd : âˆ€ z âˆˆ âˆ‚D, âˆ¥zâˆ¥ = 1),\n  Â¬âˆƒ (f : â„‚ â†’ E), DifferentiableOn â„‚ f (Interior D) âˆ§ ContinuousOn f D âˆ§ âˆ€ (z : â„‚), z âˆˆ âˆ‚D â†’ f z = (zâ»Â¹) â€¢ 1 ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚},\n  ContinuousOn f (Metric.sphere 0 1) â†’\n    (âˆ€ (z : â„‚), z âˆˆ Metric.sphere 0 1 â†’ f z = zâ»Â¹) â†’\n      Â¬MDifferentiable I (modelWithCornersSelf â„‚ â„‚) f ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  ContinuousOn f (Metric.closedBall 0 1) â†’\n    Set.EqOn f (Î» z, zâ»Â¹) (Metric.sphere 0 1) â†’ False ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] (f : M â†’ â„‚),\n  (âˆ€ (z : â„‚), z âˆˆ Metric.sphere 0 1 â†’ f z = zâ»Â¹) â†’\n    ContinuousOn f (Metric.sphere 0 1) â†’\n      Â¬(MDifferentiable I (modelWithCornersSelf â„‚ â„‚) f âˆ§ ContinuousOn f (Metric.closedBall 0 1)) ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {D : â„• â†’ PartialHolomorphic E (Metric.ClosedBall 0 1)},\n  MDifferentiableOnCl I (ModelWithCornersSelf â„‚ E) (fun z => z + 1 / z) (Metric.ClosedBall 0 1) â†’\n    ContinuousOn (fun z => z + 1 / z) (Metric.ClosedBall 0 1) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.Sphere 0 1 â†’ (fun z => z + 1 / z) z = 1 / z) â†’ False ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚},\n  ContinuousOn f (Closure (Metric.Ball 0 1)) â†’\n    Set.EqOn f (Î» (z : â„‚), zâ»Â¹) (Metric.Sphere 0 1) â†’ False ",
      "âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace â„‚ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners â„‚ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M â†’ F},\n  MDifferentiable I (modelWithCornersSelf â„‚ F) f â†’ f âˆ‰ ContinuousOn f (Metric.ClosedBall 0 1) âˆ§\n    âˆ€ (z : â„‚), z âˆˆ Metric.sphere 0 1 â†’ f z = (z - 0)â»Â¹ â†’ False ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners â„‚ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {f : M â†’ â„‚},\n  ContinuousOn f (metric.sphere (0 : â„‚) 1) â†’\n  Set.EqOn f (Î» z, (z : â„‚)â»Â¹) (metric.sphere (0 : â„‚) 1) â†’\n  Â¬ MDifferentiable I (modelWithCornersSelf â„‚ â„‚) f ",
      "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E],\n  Â¬âˆƒ (f : â„‚ â†’ E), ContinuousOn f (Metric.closedBall 0 1) âˆ§ DifferentiableOn â„‚ f (Metric.ball 0 1) âˆ§\n    âˆ€ (z : â„‚), z âˆˆ Metric.sphere 0 1 â†’ f z = (zâ»Â¹) "
    ]
  },
  {
    "docString": "For `j âˆˆ {1, 2, 3, 4}`, let `z_j` be a complex number with `|z_j| = 1` and `z_j â‰  1`. Prove that `3 - z_1 - z_2 - z_3 - z_4 + z_1 z_2 z_3 z_4 â‰  0`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\": \"âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y â‰  0 â†’ x ^ 2 = -y ^ 2 â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0]\",\n  \"isProp\": true,\n  \"docString\":\n  \"There are several equivalent ways to say that a number `z` is in fact a real number. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S â€¢ z| < 1`. \"},\n {\"theorem\": \"âˆ€ {x : â„}, 0 â‰¤ x â†’ âˆ€ (y z : â„), x ^ y * x ^ z â‰¤ x ^ (y + z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `0 â‰¤ x`, the only problematic case in the equality `x ^ y * x ^ z = x ^ (y + z)` is for\\n`x = 0` and `y + z = 0`, where the right hand side is `1` while the left hand side can vanish.\\nThe inequality is always true, though, and given in this lemma. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {G : Type u_1} [inst : AddGroup G] (g : Fin (n + 1) â†’ G) (j : Fin (n + 1)) (k : Fin n),\\n  -Fin.partialSum g (Fin.succAbove (Fin.succ j) (Fin.castSucc k)) + Fin.partialSum g (Fin.succ (Fin.succAbove j k)) =\\n    Fin.contractNth j (fun x x_1 => x + x_1) g k\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `(gâ‚€, gâ‚, ..., gâ‚™)` be a tuple of elements in `Gâ¿âºÂ¹`.\\nThen if `k < j`, this says `-(gâ‚€ + gâ‚ + ... + gâ‚–â‚‹â‚) + (gâ‚€ + gâ‚ + ... + gâ‚–) = gâ‚–`.\\nIf `k = j`, it says `-(gâ‚€ + gâ‚ + ... + gâ‚–â‚‹â‚) + (gâ‚€ + gâ‚ + ... + gâ‚–â‚Šâ‚) = gâ‚– + gâ‚–â‚Šâ‚`.\\nIf `k > j`, it says `-(gâ‚€ + gâ‚ + ... + gâ‚–) + (gâ‚€ + gâ‚ + ... + gâ‚–â‚Šâ‚) = gâ‚–â‚Šâ‚.`\\nUseful for defining group cohomology.\"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\": \"âˆ€ {n : â„¤}, n % 4 = 3 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `Ï‡â‚„ n = -1`. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•}, a % 4 = 3 â†’ b % 4 = 3 â†’ jacobiSym (â†‘a) b = -jacobiSym (â†‘b) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\\nboth congruent to `3` mod `4`, then `J(a | b) = -J(b | a)`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. \"},\n {\"theorem\":\n  \"âˆ€ (a : â„¤) {b : â„•}, Odd b â†’ jacobiSym (-a) b = â†‘ZMod.Ï‡â‚„ â†‘b * jacobiSym a b\",\n  \"isProp\": true,\n  \"docString\": \"If `b` is odd, then `J(-a | b) = Ï‡â‚„ b * J(a | b)`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} (self : ComplexShape Î¹) {i i' j : Î¹}, ComplexShape.Rel self i j â†’ ComplexShape.Rel self i' j â†’ i = i'\",\n  \"isProp\": true,\n  \"docString\": \"There is at most one nonzero differential to `X j`. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofilteredOrEmpty C] {i j j' : C}\\n  (f : j âŸ¶ i) (f' : j' âŸ¶ i), âˆƒ k g g', CategoryTheory.CategoryStruct.comp g f = CategoryTheory.CategoryStruct.comp g' f'\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every cospan `j âŸ¶ i âŸµ j'`,\\nthere exists a cone `j âŸµ k âŸ¶ j'` such that the square commutes. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"âˆ€ (a : â„¤), jacobiSym a 0 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The symbol `J(a | 0)` has the value `1`. \"}]\n",
    "prompt_cons": "/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.re = (z + â†‘(starRingEnd â„‚) z) / 2 :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem âˆ€ (z : â„‚), â†‘z.im = (z - â†‘(starRingEnd â„‚) z) / (2 * Complex.I) :=\n\n/-- If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y â‰  0 â†’ x ^ 2 = -y ^ 2 â†’ p % 4 â‰  3 :=\n\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem âˆ€ {K : Type u_1} [inst : IsROrC K] (z : K),\n  List.TFAE [â†‘(starRingEnd K) z = z, âˆƒ r, â†‘r = z, â†‘(â†‘IsROrC.re z) = z, â†‘IsROrC.im z = 0] :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], IsSquare (-1) â†” p % 4 â‰  3 :=\n\n/-- If `1 < |z|`, then `|S â€¢ z| < 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, 1 < â†‘Complex.normSq â†‘z â†’ â†‘Complex.normSq â†‘(ModularGroup.S â€¢ z) < 1 :=\n\n/-- For `0 â‰¤ x`, the only problematic case in the equality `x ^ y * x ^ z = x ^ (y + z)` is for\n`x = 0` and `y + z = 0`, where the right hand side is `1` while the left hand side can vanish.\nThe inequality is always true, though, and given in this lemma. -/\ntheorem âˆ€ {x : â„}, 0 â‰¤ x â†’ âˆ€ (y z : â„), x ^ y * x ^ z â‰¤ x ^ (y + z) :=\n\n/-- Let `(gâ‚€, gâ‚, ..., gâ‚™)` be a tuple of elements in `Gâ¿âºÂ¹`.\nThen if `k < j`, this says `-(gâ‚€ + gâ‚ + ... + gâ‚–â‚‹â‚) + (gâ‚€ + gâ‚ + ... + gâ‚–) = gâ‚–`.\nIf `k = j`, it says `-(gâ‚€ + gâ‚ + ... + gâ‚–â‚‹â‚) + (gâ‚€ + gâ‚ + ... + gâ‚–â‚Šâ‚) = gâ‚– + gâ‚–â‚Šâ‚`.\nIf `k > j`, it says `-(gâ‚€ + gâ‚ + ... + gâ‚–) + (gâ‚€ + gâ‚ + ... + gâ‚–â‚Šâ‚) = gâ‚–â‚Šâ‚.`\nUseful for defining group cohomology. -/\ntheorem âˆ€ {n : â„•} {G : Type u_1} [inst : AddGroup G] (g : Fin (n + 1) â†’ G) (j : Fin (n + 1)) (k : Fin n),\n  -Fin.partialSum g (Fin.succAbove (Fin.succ j) (Fin.castSucc k)) + Fin.partialSum g (Fin.succ (Fin.succAbove j k)) =\n    Fin.contractNth j (fun x x_1 => x + x_1) g k :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- If `n % 4 = 3`, then `Ï‡â‚„ n = -1`. -/\ntheorem âˆ€ {n : â„¤}, n % 4 = 3 â†’ â†‘ZMod.Ï‡â‚„ â†‘n = -1 :=\n\n/-- The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\nboth congruent to `3` mod `4`, then `J(a | b) = -J(b | a)`. -/\ntheorem âˆ€ {a b : â„•}, a % 4 = 3 â†’ b % 4 = 3 â†’ jacobiSym (â†‘a) b = -jacobiSym (â†‘b) a :=\n\n/-- If `1 < k` then `(âˆ‘ i in range k, Î¶ ^ i) = 0`. -/\ntheorem âˆ€ {R : Type u_1} {k : â„•} [inst : CommRing R] [inst_1 : IsDomain R] {Î¶ : R},\n  IsPrimitiveRoot Î¶ k â†’ 1 < k â†’ (Finset.sum (Finset.range k) fun i => Î¶ ^ i) = 0 :=\n\n/-- Shows that `Aâ‚™ = bâ‚™ * Aâ‚™â‚‹â‚ + aâ‚™ * Aâ‚™â‚‹â‚‚`. -/\ntheorem âˆ€ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp â†’\n    GeneralizedContinuedFraction.numerators g n = ppredA â†’\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA â†’\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- If `b` is odd, then `J(-a | b) = Ï‡â‚„ b * J(a | b)`. -/\ntheorem âˆ€ (a : â„¤) {b : â„•}, Odd b â†’ jacobiSym (-a) b = â†‘ZMod.Ï‡â‚„ â†‘b * jacobiSym a b :=\n\n/-- There is at most one nonzero differential to `X j`. -/\ntheorem âˆ€ {Î¹ : Type u_1} (self : ComplexShape Î¹) {i i' j : Î¹}, ComplexShape.Rel self i j â†’ ComplexShape.Rel self i' j â†’ i = i' :=\n\n/-- For every cospan `j âŸ¶ i âŸµ j'`,\nthere exists a cone `j âŸµ k âŸ¶ j'` such that the square commutes. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofilteredOrEmpty C] {i j j' : C}\n  (f : j âŸ¶ i) (f' : j' âŸ¶ i), âˆƒ k g g', CategoryTheory.CategoryStruct.comp g f = CategoryTheory.CategoryStruct.comp g' f' :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The symbol `J(a | 0)` has the value `1`. -/\ntheorem âˆ€ (a : â„¤), jacobiSym a 0 = 1 :=\n\n/-- For `j âˆˆ {1, 2, 3, 4}`, let `z_j` be a complex number with `|z_j| = 1` and `z_j â‰  1`. Prove that `3 - z_1 - z_2 - z_3 - z_4 + z_1 z_2 z_3 z_4 â‰  0`. -/\ntheorem",
    "choices": [
      "âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚}, Complex.abs zâ‚ = 1 â†’ zâ‚ â‰  1 â†’ Complex.abs zâ‚‚ = 1 â†’ zâ‚‚ â‰  1 â†’ Complex.abs zâ‚ƒ = 1 â†’ zâ‚ƒ â‰  1 â†’ Complex.abs zâ‚„ = 1 â†’ zâ‚„ â‰  1 â†’\n  3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0 ",
      "âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚},\n  zâ‚ â‰  1 â†’ Complex.abs zâ‚ = 1 â†’\n  zâ‚‚ â‰  1 â†’ Complex.abs zâ‚‚ = 1 â†’\n  zâ‚ƒ â‰  1 â†’ Complex.abs zâ‚ƒ = 1 â†’\n  zâ‚„ â‰  1 â†’ Complex.abs zâ‚„ = 1 â†’\n  3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0 ",
      "âˆ€ {zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚}, Complex.normSq zâ‚ = 1 â†’ zâ‚ â‰  1 â†’ Complex.normSq zâ‚‚ = 1 â†’ zâ‚‚ â‰  1 â†’ Complex.normSq zâ‚ƒ = 1 â†’ zâ‚ƒ â‰  1 â†’ Complex.normSq zâ‚„ = 1 â†’ zâ‚„ â‰  1 â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0 ",
      "âˆ€ {z1 z2 z3 z4 : â„‚}, z1 â‰  1 â†’ z2 â‰  1 â†’ z3 â‰  1 â†’ z4 â‰  1 â†’ Complex.normSq z1 = 1 â†’ Complex.normSq z2 = 1 â†’ Complex.normSq z3 = 1 â†’ Complex.normSq z4 = 1 â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ {z1 z2 z3 z4 : â„‚},\n  (Complex.normSq z1 = 1 âˆ§ z1 â‰  1) â†’\n  (Complex.normSq z2 = 1 âˆ§ z2 â‰  1) â†’\n  (Complex.normSq z3 = 1 âˆ§ z3 â‰  1) â†’\n  (Complex.normSq z4 = 1 âˆ§ z4 â‰  1) â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ (z1 z2 z3 z4 : â„‚),\n  Complex.abs z1 = 1 â†’ z1 â‰  1 â†’\n  Complex.abs z2 = 1 â†’ z2 â‰  1 â†’\n  Complex.abs z3 = 1 â†’ z3 â‰  1 â†’\n  Complex.abs z4 = 1 â†’ z4 â‰  1 â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ {z1 z2 z3 z4 : â„‚}, Complex.abs z1 = 1 â†’ z1 â‰  1 â†’ Complex.abs z2 = 1 â†’ z2 â‰  1 â†’ Complex.abs z3 = 1 â†’ z3 â‰  1 â†’ Complex.abs z4 = 1 â†’ z4 â‰  1 â†’ 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ {z1 z2 z3 z4 : â„‚}, Complex.abs z1 = 1 â†’ z1 â‰  1 â†’ Complex.abs z2 = 1 â†’ z2 â‰  1 â†’ Complex.abs z3 = 1 â†’ z3 â‰  1 â†’ Complex.abs z4 = 1 â†’ z4 â‰  1 â†’\n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 â‰  0 ",
      "âˆ€ (zâ‚ zâ‚‚ zâ‚ƒ zâ‚„ : â„‚), Complex.abs zâ‚ = 1 â†’ zâ‚ â‰  1 â†’ Complex.abs zâ‚‚ = 1 â†’ zâ‚‚ â‰  1 â†’ Complex.abs zâ‚ƒ = 1 â†’ zâ‚ƒ â‰  1 â†’ Complex.abs zâ‚„ = 1 â†’ zâ‚„ â‰  1 â†’ 3 - zâ‚ - zâ‚‚ - zâ‚ƒ - zâ‚„ + zâ‚ * zâ‚‚ * zâ‚ƒ * zâ‚„ â‰  0 ",
      "âˆ€ {z_1 z_2 z_3 z_4 : â„‚}, Complex.normSq z_1 = 1 â†’ z_1 â‰  1 â†’ Complex.normSq z_2 = 1 â†’ z_2 â‰  1 â†’ Complex.normSq z_3 = 1 â†’ z_3 â‰  1 â†’ Complex.normSq z_4 = 1 â†’ z_4 â‰  1 â†’ 3 - z_1 - z_2 - z_3 - z_4 + z_1 * z_2 * z_3 * z_4 â‰  0 "
    ]
  },
  {
    "docString": "Let `n` be a positive integer, and let `f_n(z) = n + (n - 1)z + (n - 2)z^2 + â‹¯ + z^(n - 1)`. Prove that `f_n` has no roots in the closed unit disk `{z âˆˆ â„‚: |z| â‰¤ 1}`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•+) (x : â„‚Ë£), x âˆˆ rootsOfUnity n â„‚ â†” âˆƒ i, i < â†‘n âˆ§ cexp (2 * â†‘Real.pi * Complex.I * (â†‘i / â†‘â†‘n)) = â†‘x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complex `n`-th roots of unity are exactly the\\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ğ•œ E H} {M : Type u_4}\\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace ğ•œ E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\\n  {I' : ModelWithCorners ğ•œ E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : M â†’ M'} {x : M} {n : â„•},\\n  ContMDiffAt I I' (â†‘n) f x â†” âˆ€á¶  (x' : M) in nhds x, ContMDiffAt I I' (â†‘n) f x'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note: This does not hold for `n = âˆ`. `f` being `C^âˆ` at `x` means that for every `n`, `f` is\\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R C : â„},\\n  0 < R â†’\\n    ContinuousOn f (Metric.sphere c R) â†’\\n      (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c R â†’ â€–f zâ€– â‰¤ C) â†’\\n        (âˆƒ z, z âˆˆ Metric.sphere c R âˆ§ â€–f zâ€– < C) â†’ â€–âˆ® (z : â„‚) in C(c, R), f zâ€– < 2 * Real.pi * R * C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is continuous on the circle `|z - c| = R`, `R > 0`, the `â€–f zâ€–` is less than or equal to\\n`C : â„` on this circle, and this norm is strictly less than `C` at some point `z` of the circle,\\nthen `â€–âˆ® z in C(c, R), f zâ€– < 2 * Ï€ * R * C`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„¤} {c w : â„‚} {R : â„}, n < 0 â†’ w âˆˆ Metric.sphere c |R| â†’ (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\\ncenter `c` and radius `|R|`, so the integral `âˆ® z in C(c, R), (z - w) ^ n` is equal to zero. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {x : â„} {n : â„•},\\n  ConvexOn â„ (Set.Ioi 0) f â†’\\n    (âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + Real.log y) â†’ 2 â‰¤ n â†’ 0 < x â†’ f â†‘n + x * Real.log (â†‘n - 1) â‰¤ f (â†‘n + x)\",\n  \"isProp\": true,\n  \"docString\": \"Linear lower bound for `f (x + n)` on unit interval \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„ â†’ â„} {x : â„} {n : â„•},\\n  ConvexOn â„ (Set.Ioi 0) f â†’\\n    (âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + Real.log y) â†’ n â‰  0 â†’ 0 < x â†’ x â‰¤ 1 â†’ f (â†‘n + x) â‰¤ f â†‘n + x * Real.log â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Linear upper bound for `f (x + n)` on unit interval \"},\n {\"theorem\":\n  \"âˆ€ {c w : â„‚} {R : â„} {n : â„¤}, CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ Â¬w âˆˆ Metric.sphere c |R|\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `Î» z, (z - w) ^ n`, `n : â„¤`, is circle integrable on the circle with center `c` and\\nradius `|R|` if and only if `R = 0` or `0 â‰¤ n`, or `w` does not belong to this circle. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(â„, E)},\\n  (Summable fun n => â€–ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight â†‘n))â€–) â†’\\n    MeasureTheory.Integrable â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sequence with `n`-th term the the sup norm of `Î» x, f (x + n)` on the interval `Icc 0 1`,\\nfor `n âˆˆ â„¤`, is summable, then `f` is integrable on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\\n  0 < r â†’\\n    r â‰¤ R â†’\\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\\n        Set.Countable s â†’\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) â†’\\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s â†’ DifferentiableAt â„‚ f z) â†’\\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•), WittVector.IsPoly p fun R _Rcr x => x * â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication by `n` is a polynomial function. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\": \"For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•+) (A : Type w) (B : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [inst_3 : IsCyclotomicExtension {n} A B], IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"`zeta n A B` is a primitive `n`-th root of unity. \"},\n {\"theorem\":\n  \"âˆ€ {f : â„‚ â†’ â„‚} {c : â„‚} {R : â„},\\n  DifferentiableOn â„‚ f (Metric.ball c R) â†’\\n    Set.MapsTo f (Metric.ball c R) (Metric.ball c R) â†’ f c = c â†’ 0 < R â†’ â†‘Complex.abs (deriv f c) â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk of positive radius to itself and the\\ncenter of this disk to itself, then the absolute value of the derivative of `f` at the center of\\nthis disk is at most `1`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’\\n    ((fun z => f z - f c) =o[nhdsWithin c {c}á¶œ] fun z => (z - c)â»Â¹) â†’\\n      Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (limUnder (nhdsWithin c {c}á¶œ) f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. \"}]\n",
    "prompt_cons": "/-- If `z âˆˆ ğ’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`. -/\ntheorem âˆ€ {z : UpperHalfPlane}, z âˆˆ ModularGroup.fdo â†’ âˆ€ (n : â„¤), 1 < â†‘Complex.normSq â†‘(ModularGroup.T ^ n â€¢ z) :=\n\n/-- If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) â‰¤ abs z`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„},\n  DifferentiableOn â„‚ f (Metric.ball 0 R) â†’\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) â†’\n      f 0 = 0 â†’ â†‘Complex.abs z < R â†’ â†‘Complex.abs (f z) â‰¤ â†‘Complex.abs z :=\n\n/-- The complex `n`-th roots of unity are exactly the\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. -/\ntheorem âˆ€ (n : â„•+) (x : â„‚Ë£), x âˆˆ rootsOfUnity n â„‚ â†” âˆƒ i, i < â†‘n âˆ§ cexp (2 * â†‘Real.pi * Complex.I * (â†‘i / â†‘â†‘n)) = â†‘x :=\n\n/-- For all `n âˆˆ S`, there exists a primitive `n`-th root of unity in `B`. -/\ntheorem âˆ€ {S : Set â„•+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] {n : â„•+}, n âˆˆ S â†’ âˆƒ r, IsPrimitiveRoot r â†‘n :=\n\n/-- Note: This does not hold for `n = âˆ`. `f` being `C^âˆ` at `x` means that for every `n`, `f` is\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ğ•œ E H} {M : Type u_4}\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace ğ•œ E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\n  {I' : ModelWithCorners ğ•œ E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : M â†’ M'} {x : M} {n : â„•},\n  ContMDiffAt I I' (â†‘n) f x â†” âˆ€á¶  (x' : M) in nhds x, ContMDiffAt I I' (â†‘n) f x' :=\n\n/-- If `f` is continuous on the circle `|z - c| = R`, `R > 0`, the `â€–f zâ€–` is less than or equal to\n`C : â„` on this circle, and this norm is strictly less than `C` at some point `z` of the circle,\nthen `â€–âˆ® z in C(c, R), f zâ€– < 2 * Ï€ * R * C`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R C : â„},\n  0 < R â†’\n    ContinuousOn f (Metric.sphere c R) â†’\n      (âˆ€ (z : â„‚), z âˆˆ Metric.sphere c R â†’ â€–f zâ€– â‰¤ C) â†’\n        (âˆƒ z, z âˆˆ Metric.sphere c R âˆ§ â€–f zâ€– < C) â†’ â€–âˆ® (z : â„‚) in C(c, R), f zâ€– < 2 * Real.pi * R * C :=\n\n/-- If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\ncenter `c` and radius `|R|`, so the integral `âˆ® z in C(c, R), (z - w) ^ n` is equal to zero. -/\ntheorem âˆ€ {n : â„¤} {c w : â„‚} {R : â„}, n < 0 â†’ w âˆˆ Metric.sphere c |R| â†’ (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- Linear lower bound for `f (x + n)` on unit interval -/\ntheorem âˆ€ {f : â„ â†’ â„} {x : â„} {n : â„•},\n  ConvexOn â„ (Set.Ioi 0) f â†’\n    (âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + Real.log y) â†’ 2 â‰¤ n â†’ 0 < x â†’ f â†‘n + x * Real.log (â†‘n - 1) â‰¤ f (â†‘n + x) :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0 :=\n\n/-- Linear upper bound for `f (x + n)` on unit interval -/\ntheorem âˆ€ {f : â„ â†’ â„} {x : â„} {n : â„•},\n  ConvexOn â„ (Set.Ioi 0) f â†’\n    (âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + Real.log y) â†’ n â‰  0 â†’ 0 < x â†’ x â‰¤ 1 â†’ f (â†‘n + x) â‰¤ f â†‘n + x * Real.log â†‘n :=\n\n/-- The function `Î» z, (z - w) ^ n`, `n : â„¤`, is circle integrable on the circle with center `c` and\nradius `|R|` if and only if `R = 0` or `0 â‰¤ n`, or `w` does not belong to this circle. -/\ntheorem âˆ€ {c w : â„‚} {R : â„} {n : â„¤}, CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ Â¬w âˆˆ Metric.sphere c |R| :=\n\n/-- If the sequence with `n`-th term the the sup norm of `Î» x, f (x + n)` on the interval `Icc 0 1`,\nfor `n âˆˆ â„¤`, is summable, then `f` is integrable on `â„`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(â„, E)},\n  (Summable fun n => â€–ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight â†‘n))â€–) â†’\n    MeasureTheory.Integrable â†‘f :=\n\n/-- If `f : â„‚ â†’ E` is continuous the closed annulus `r â‰¤ â€–z - câ€– â‰¤ R`, `0 < r â‰¤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)â»Â¹ â€¢ f z`) over the circles `â€–z - câ€– = r` and `â€–z - câ€– = R` are\nequal to each other. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {c : â„‚} {r R : â„},\n  0 < r â†’\n    r â‰¤ R â†’\n      âˆ€ {f : â„‚ â†’ E} {s : Set â„‚},\n        Set.Countable s â†’\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) â†’\n            (âˆ€ (z : â„‚), z âˆˆ (Metric.ball c R \\ Metric.closedBall c r) \\ s â†’ DifferentiableAt â„‚ f z) â†’\n              (âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `Î¼` divides `cyclotomic n â„¤`. -/\ntheorem âˆ€ {n : â„•} {K : Type u_1} [inst : Field K] {Î¼ : K},\n  IsPrimitiveRoot Î¼ n â†’ 0 < n â†’ âˆ€ [inst_1 : CharZero K], minpoly â„¤ Î¼ âˆ£ Polynomial.cyclotomic n â„¤ :=\n\n/-- Multiplication by `n` is a polynomial function. -/\ntheorem âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•), WittVector.IsPoly p fun R _Rcr x => x * â†‘n :=\n\n/-- For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n :=\n\n/-- `zeta n A B` is a primitive `n`-th root of unity. -/\ntheorem âˆ€ (n : â„•+) (A : Type w) (B : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsCyclotomicExtension {n} A B], IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) â†‘n :=\n\n/-- The **Schwarz Lemma**: if `f : â„‚ â†’ â„‚` sends an open disk of positive radius to itself and the\ncenter of this disk to itself, then the absolute value of the derivative of `f` at the center of\nthis disk is at most `1`. -/\ntheorem âˆ€ {f : â„‚ â†’ â„‚} {c : â„‚} {R : â„},\n  DifferentiableOn â„‚ f (Metric.ball c R) â†’\n    Set.MapsTo f (Metric.ball c R) (Metric.ball c R) â†’ f c = c â†’ 0 < R â†’ â†‘Complex.abs (deriv f c) â‰¤ 1 :=\n\n/-- **Removable singularity** theorem: if a function `f : â„‚ â†’ E` is complex differentiable on a\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚},\n  (âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) â†’\n    ((fun z => f z - f c) =o[nhdsWithin c {c}á¶œ] fun z => (z - c)â»Â¹) â†’\n      Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (limUnder (nhdsWithin c {c}á¶œ) f)) :=\n\n/-- Let `n` be a positive integer, and let `f_n(z) = n + (n - 1)z + (n - 2)z^2 + â‹¯ + z^(n - 1)`. Prove that `f_n` has no roots in the closed unit disk `{z âˆˆ â„‚: |z| â‰¤ 1}`. -/\ntheorem",
    "choices": [
      "âˆ€ (n : â„•), 0 < n â†’ âˆ€ (z : â„‚), Complex.abs z â‰¤ 1 â†’ Â¬IsRoot (Polynomial.of_finsupp (Finset.sum (Finset.range n) (Î» (i : â„•), Finsupp.single (n - 1 - i) (â†‘n - â†‘i)))) z ",
      "âˆ€ (n : â„•) (hn : n > 0), âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Polynomial.eval z (Polynomial.sum (finset.range n.succ) (Î» (i : â„•), Polynomial.C (â†‘n - â†‘i) * Polynomial.X ^ i)) â‰  0 ",
      "âˆ€ {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬Polynomial.IsRoot (Polynomial.monomial n 1 - Finset.sum (Finset.range n) fun k => Polynomial.monomial k (â†‘â†‘n - â†‘k)) z ",
      "âˆ€ {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), Complex.abs z â‰¤ 1 â†’ Â¬Polynomial.isRoot (Polynomial.iteratedDeriv (Polynomial.monomial n 1) n) z ",
      "âˆ€ {n : â„•},\n  0 < n â†’\n    âˆ€ z : â„‚, z âˆˆ Metric.ClosedBall 0 1 â†’ Â¬Polynomial.isRoot (Polynomial.monomial (n - 1) 1 - Finset.sum (Finset.range n) Polynomial.C) z ",
      "âˆ€ {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), Complex.abs z â‰¤ 1 â†’ Â¬Polynomial.root (Finset.sum (Finset.range n) (fun k => Polynomial.C (â†‘n - â†‘k) * (Polynomial.X ^ k))) z ",
      "âˆ€ (n : â„•), 0 < n â†’ âˆ€ (z : â„‚), Metric.ClosedBall 0 1 z â†’ IsPrimitiveRoot (f_n n z) â†‘n ",
      "âˆ€ (n : â„•), n > 0 â†’ âˆ€ (z : â„‚), Complex.abs z â‰¤ 1 â†’ Â¬(polynomial.eval z (polynomial.Chebyshev.T (â„‚) n) = 0) ",
      "âˆ€ {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), â†‘Complex.abs z â‰¤ 1 â†’ Â¬Polynomial.IsRoot (Polynomial.Chebyshev.T â„‚ n) z ",
      "âˆ€ {n : â„•}, 0 < n â†’ âˆ€ (z : â„‚), z âˆˆ Metric.closed_ball 0 1 â†’ Polynomial.eval z (finset.sum (finset.range n) (Î» (i : â„•), (n - i) â€¢ Polynomial.X ^ i)) â‰  0 "
    ]
  },
  {
    "docString": "Suppose that `f(x) = Î£ c_i x^i` is a power series for which each coefficient `c_i` is 0 or 1. Show that if `f(2/3) = 3/2`, then `f(1/2)` must be irrational.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r â†’ âˆ€ (y : E), HasFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` has a power series `p` around `x`, then the function `z â†¦ f (z - y)` has the\\nsame power series around `x + y`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\\n  CircleIntegrable f c R â†’\\n    â†‘Complex.abs w < R â†’\\n      HasSum (fun n => âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\\n        (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\\n`Metric.ball c R`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\\n  CircleIntegrable f c R â†’\\n    â†‘Complex.abs w < R â†’\\n      HasSum (fun n => â†‘(cauchyPowerSeries f c R n) fun x => w)\\n        ((2 * â†‘Real.pi * Complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\\ndisc `Metric.ball c R`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] (Ï† : PowerSeries R), IsUnit Ï† â†’ IsUnit (â†‘(PowerSeries.constantCoeff R) Ï†)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a formal power series is invertible, then so is its constant coefficient.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddCommGroup G] [inst_2 : TopologicalAddGroup G]\\n  {f : Î± â†’ G}, Summable f â†’ Filter.Tendsto f Filter.cofinite (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Series divergence test: if `f` is a convergent series, then `f x` tends to zero along\\n`cofinite`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±},\\n  (âˆ€ (n : â„•), dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) â†’ CauchySeq f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E},\\n  HasFPowerSeriesAt f p x â†’\\n    (fun y => f y.fst - f y.snd - â†‘(p 1) fun x => y.fst - y.snd) =O[nhds (x, x)] fun y => â€–y - (x, x)â€– * â€–y.fst - y.sndâ€–\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` has formal power series `âˆ‘ n, pâ‚™` at `x`, then\\n`f y - f z - p 1 (fun _ â†¦ y - z) = O(â€–(y, z) - (x, x)â€– * â€–y - zâ€–)` as `(y, z) â†’ (x, x)`.\\nIn particular, `f` is strictly differentiable at `x`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† Ïˆ : PowerSeries R},\\n  Ï† = Ïˆ â†” âˆ€ (n : â„•), â†‘(PowerSeries.coeff R n) Ï† = â†‘(PowerSeries.coeff R n) Ïˆ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two formal power series are equal if all their coefficients are equal.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] (Ï† : PowerSeries R),\\n  Ï† - â†‘(PowerSeries.C R) (â†‘(PowerSeries.constantCoeff R) Ï†) =\\n    (PowerSeries.mk fun p => â†‘(PowerSeries.coeff R (p + 1)) Ï†) * PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two ways of removing the constant coefficient of a power series are the same. \"},\n {\"theorem\":\n  \"âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : Semiring R] (Ï† : MvPowerSeries Ïƒ R),\\n  IsUnit Ï† â†’ IsUnit (â†‘(MvPowerSeries.constantCoeff Ïƒ R) Ï†)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a multivariate formal power series is invertible,\\nthen so is its constant coefficient.\"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `Î¶(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\\n  HasFPowerSeriesOnBall f p x r â†’\\n    â†‘r' < r â†’\\n      âˆƒ a,\\n        a âˆˆ Set.Ioo 0 1 âˆ§\\n          âˆƒ C,\\n            C > 0 âˆ§\\n              âˆ€ (y : E),\\n                y âˆˆ Metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), â€–f (x + y) - FormalMultilinearSeries.partialSum p n yâ€– â‰¤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion, then it is exponentially close to the partial\\nsums of this power series on strict subdisks of the disk of convergence. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (n : â„•),\\n  â†‘n < PowerSeries.order Ï† â†’ â†‘(PowerSeries.coeff R n) Ï† = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`th coefficient of a formal power series is `0` if `n` is strictly\\nsmaller than the order of the power series.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  {p : FormalMultilinearSeries ğ•œ E F} {r : ENNReal} {f : E â†’ F} {x : E} [inst_5 : CompleteSpace F],\\n  HasFPowerSeriesOnBall f p x r â†’\\n    HasFPowerSeriesOnBall (fderiv ğ•œ f)\\n      (ContinuousLinearMap.compFormalMultilinearSeries\\n        (â†‘(ContinuousLinearEquiv.mk (continuousMultilinearCurryFin1 ğ•œ E F).toLinearEquiv))\\n        (FormalMultilinearSeries.changeOriginSeries p 1))\\n      x r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has a power series on a ball, then so does its derivative. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (h : (PowerSeries.order Ï†).Dom),\\n  â†‘(PowerSeries.coeff R (Part.get (PowerSeries.order Ï†) h)) Ï† â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the order of a formal power series is finite,\\nthen the coefficient indexed by the order is nonzero.\"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {n : â„•âˆ} {f' : E â†’ FormalMultilinearSeries ğ•œ E F}, HasFTaylorSeriesUpTo n f f' â†’ ContDiff ğ•œ n f\",\n  \"isProp\": true,\n  \"docString\": \"If `f` has a Taylor series up to `n`, then it is `C^n`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] [inst_1 : Nontrivial R], PowerSeries.order 1 = 0\",\n  \"isProp\": true,\n  \"docString\": \"The order of the formal power series `1` is `0`.\"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ (z : â„‚) {R : NNReal}, 0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f z â†‘R) z âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `f : â„‚ â†’ E` is differentiable, the `cauchyPowerSeries f z R` represents `f` as a power\\nseries centered at `z` in the entirety of `â„‚`, regardless of `R : â„â‰¥0`, with `0 < R`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\\n  HasFPowerSeriesOnBall f p x r â†’\\n    â†‘r' < r â†’\\n      TendstoUniformlyOn (fun n y => FormalMultilinearSeries.partialSum p n (y - x)) f Filter.atTop (Metric.ball x â†‘r')\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion at `x`, then it is the uniform limit of the\\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f y`\\nis the uniform limit of `p.partialSum n (y - x)` there. \"}]\n",
    "prompt_cons": "/-- If a function `f` has a power series `p` around `x`, then the function `z â†¦ f (z - y)` has the\nsame power series around `x + y`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r â†’ âˆ€ (y : E), HasFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) r :=\n\n/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\n`Metric.ball c R`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\n  CircleIntegrable f c R â†’\n    â†‘Complex.abs w < R â†’\n      HasSum (fun n => âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\n        (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) :=\n\n/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚},\n  CircleIntegrable f c R â†’\n    â†‘Complex.abs w < R â†’\n      HasSum (fun n => â†‘(cauchyPowerSeries f c R n) fun x => w)\n        ((2 * â†‘Real.pi * Complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) :=\n\n/-- If a formal power series is invertible, then so is its constant coefficient. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] (Ï† : PowerSeries R), IsUnit Ï† â†’ IsUnit (â†‘(PowerSeries.constantCoeff R) Ï†) :=\n\n/-- Series divergence test: if `f` is a convergent series, then `f x` tends to zero along\n`cofinite`. -/\ntheorem âˆ€ {Î± : Type u_2} {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddCommGroup G] [inst_2 : TopologicalAddGroup G]\n  {f : Î± â†’ G}, Summable f â†’ Filter.Tendsto f Filter.cofinite (nhds 0) :=\n\n/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±},\n  (âˆ€ (n : â„•), dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) â†’ CauchySeq f :=\n\n/-- If `f` has formal power series `âˆ‘ n, pâ‚™` at `x`, then\n`f y - f z - p 1 (fun _ â†¦ y - z) = O(â€–(y, z) - (x, x)â€– * â€–y - zâ€–)` as `(y, z) â†’ (x, x)`.\nIn particular, `f` is strictly differentiable at `x`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E},\n  HasFPowerSeriesAt f p x â†’\n    (fun y => f y.fst - f y.snd - â†‘(p 1) fun x => y.fst - y.snd) =O[nhds (x, x)] fun y => â€–y - (x, x)â€– * â€–y.fst - y.sndâ€– :=\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† Ïˆ : PowerSeries R},\n  Ï† = Ïˆ â†” âˆ€ (n : â„•), â†‘(PowerSeries.coeff R n) Ï† = â†‘(PowerSeries.coeff R n) Ïˆ :=\n\n/-- Two ways of removing the constant coefficient of a power series are the same. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] (Ï† : PowerSeries R),\n  Ï† - â†‘(PowerSeries.C R) (â†‘(PowerSeries.constantCoeff R) Ï†) =\n    (PowerSeries.mk fun p => â†‘(PowerSeries.coeff R (p + 1)) Ï†) * PowerSeries.X :=\n\n/-- If a multivariate formal power series is invertible,\nthen so is its constant coefficient. -/\ntheorem âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : Semiring R] (Ï† : MvPowerSeries Ïƒ R),\n  IsUnit Ï† â†’ IsUnit (â†‘(MvPowerSeries.constantCoeff Ïƒ R) Ï†) :=\n\n/-- We have `Î¶(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\n  HasFPowerSeriesOnBall f p x r â†’\n    â†‘r' < r â†’\n      âˆƒ a,\n        a âˆˆ Set.Ioo 0 1 âˆ§\n          âˆƒ C,\n            C > 0 âˆ§\n              âˆ€ (y : E),\n                y âˆˆ Metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), â€–f (x + y) - FormalMultilinearSeries.partialSum p n yâ€– â‰¤ C * a ^ n :=\n\n/-- The `n`th coefficient of a formal power series is `0` if `n` is strictly\nsmaller than the order of the power series. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (n : â„•),\n  â†‘n < PowerSeries.order Ï† â†’ â†‘(PowerSeries.coeff R n) Ï† = 0 :=\n\n/-- If a function has a power series on a ball, then so does its derivative. -/\ntheorem âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  {p : FormalMultilinearSeries ğ•œ E F} {r : ENNReal} {f : E â†’ F} {x : E} [inst_5 : CompleteSpace F],\n  HasFPowerSeriesOnBall f p x r â†’\n    HasFPowerSeriesOnBall (fderiv ğ•œ f)\n      (ContinuousLinearMap.compFormalMultilinearSeries\n        (â†‘(ContinuousLinearEquiv.mk (continuousMultilinearCurryFin1 ğ•œ E F).toLinearEquiv))\n        (FormalMultilinearSeries.changeOriginSeries p 1))\n      x r :=\n\n/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} (h : (PowerSeries.order Ï†).Dom),\n  â†‘(PowerSeries.coeff R (Part.get (PowerSeries.order Ï†) h)) Ï† â‰  0 :=\n\n/-- If `f` has a Taylor series up to `n`, then it is `C^n`. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {n : â„•âˆ} {f' : E â†’ FormalMultilinearSeries ğ•œ E F}, HasFTaylorSeriesUpTo n f f' â†’ ContDiff ğ•œ n f :=\n\n/-- The order of the formal power series `1` is `0`. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] [inst_1 : Nontrivial R], PowerSeries.order 1 = 0 :=\n\n/-- When `f : â„‚ â†’ E` is differentiable, the `cauchyPowerSeries f z R` represents `f` as a power\nseries centered at `z` in the entirety of `â„‚`, regardless of `R : â„â‰¥0`, with `0 < R`. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ (z : â„‚) {R : NNReal}, 0 < R â†’ HasFPowerSeriesOnBall f (cauchyPowerSeries f z â†‘R) z âŠ¤ :=\n\n/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {ğ•œâ‚‚ : Type u_3} {E : Type u_4} {F : Type u_5} {ğ“• : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [inst_6 : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F]\n  (f : ğ“•), Continuous â†‘f â†’ âˆ€ {x : E}, â€–xâ€– = 0 â†’ â€–â†‘f xâ€– = 0 :=\n\n/-- If a function admits a power series expansion at `x`, then it is the uniform limit of the\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f y`\nis the uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E} {r : ENNReal} {r' : NNReal},\n  HasFPowerSeriesOnBall f p x r â†’\n    â†‘r' < r â†’\n      TendstoUniformlyOn (fun n y => FormalMultilinearSeries.partialSum p n (y - x)) f Filter.atTop (Metric.ball x â†‘r') :=\n\n/-- Suppose that `f(x) = Î£ c_i x^i` is a power series for which each coefficient `c_i` is 0 or 1. Show that if `f(2/3) = 3/2`, then `f(1/2)` must be irrational. -/\ntheorem",
    "choices": [
      "forall {R : Type u_1} [inst : CommRing R] {Ï† : PowerSeries R} (h : âˆ€ (n : â„•), â†‘(PowerSeries.coeff R n) Ï† = 0 âˆ¨ â†‘(PowerSeries.coeff R n) Ï† = 1),\n  Ï†.eval (2 / 3) = 3 / 2 â†’ Â¬(Ï†.eval (1 / 2)).is_rat ",
      "forall (f : â„• â†’ â„š) (h : âˆ€ n, f n = 0 âˆ¨ f n = 1),\n  ((âˆ‘' (n : â„•), f n * (2/3)^n) = 3/2) â†’ Irrational (âˆ‘' (n : â„•), f n * (1/2)^n) ",
      "Â¬âˆƒ (q : â„š), âˆ€ {R : â„} [inst : Semiring R] [inst_1 : Nontrivial R] {Ï† : PowerSeries R},\n  (âˆ€ (n : â„•), â†‘(PowerSeries.coeff R n) Ï† = 0 âˆ¨ â†‘(PowerSeries.coeff R n) Ï† = 1) â†’\n    evalPowerSeries (2 / 3) Ï† = 3 / 2 â†’\n      evalPowerSeries (1 / 2) Ï† = â†‘q ",
      "âˆ€ {R : Type u_1} [inst : Semiring R] (p : PowerSeries R),\n  (âˆ€ (n : â„•), PowerSeries.coeff R n p = 0 âˆ¨ PowerSeries.coeff R n p = 1) â†’\n    p.eval (2 / 3) = 3 / 2 â†’ Irrational (p.eval (1 / 2)) ",
      "âˆ€ {R : Type u_1} [inst : Field R] [inst_1 : CharZero R] {f : PowerSeries R},\n  (âˆ€ (n : â„•), â†‘(PowerSeries.coeff R n) f = 0 âˆ¨ â†‘(PowerSeries.coeff R n) f = 1) â†’\n    f (2 / 3) = 3 / 2 â†’ Irrational (f (1 / 2)) ",
      "irrationalFormalPowerSeriesSumOneHalf :\n  âˆ€ {R : Type u_1} [inst : CommRing R] {Ï† : PowerSeries R},\n  (âˆ€ (n : â„•), â†‘(PowerSeries.coeff R n) Ï† = 0 âˆ¨ â†‘(PowerSeries.coeff R n) Ï† = 1) â†’\n  Ï†.eval (2 / 3) = 3 / 2 â†’ Irrational (Ï†.eval (1 / 2)) ",
      "âˆ€ (f : â„• â†’ â„š) (hf : âˆ€ i, f i = 0 âˆ¨ f i = 1),\n  (HasSum (fun i => f i * (2 / 3) ^ i) (3 / 2)) â†’ Irrational (HasSum (fun i => f i * (1 / 2) ^ i)) ",
      "forall {Î± : Type u_1} [inst : DiscreteLinearOrderedField Î±] {f : â„• â†’ Î±},\n  (âˆ€ n, f n = 0 âˆ¨ f n = 1) â†’\n    (âˆ€ x, HasSum (fun n => f n * x ^ n) 3 / 2) â†’\n      Irrational (HasSum (fun n => f n * (1 / 2) ^ n)) ",
      "âˆ€ {R : Type u_1} [inst : OrderedRing R] [archimedean R] (f : PowerSeries R),\n  (âˆ€ (n : â„•), â†‘(PowerSeries.coeff R n) f = 0 âˆ¨ â†‘(PowerSeries.coeff R n) f = 1) â†’\n    f (2/3) = 3/2 â†’ Irrational (f (1/2)) ",
      "âˆ€ {R : Type u_1} [inst : Field R] (f : PowerSeries R),\n  (âˆ€ (n : â„•), â†‘(PowerSeries.coeff R n) f = 0 âˆ¨ â†‘(PowerSeries.coeff R n) f = 1) â†’\n  f (2 / 3) = 3 / 2 â†’ Irrational (f (1 / 2)) "
    ]
  },
  {
    "docString": "Prove that for each positive integer `n`, the number `10^(10^(10^n)) + 10^(10^n) + 10^n - 1` is not prime.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, 1 < b â†’ d âˆˆ Nat.digits b m â†’ d < b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b expansion of n are all less than b, if b â‰¥ 2 \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n\",\n  \"isProp\": true,\n  \"docString\": \"The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"âˆ€ {b : â„•} {l : List â„•}, (âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) â†’ Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l\",\n  \"isProp\": true,\n  \"docString\": \"an n-digit number in base b + 2 is less than (b + 2)^n \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. \"},\n {\"theorem\":\n  \"âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"âˆ€ {b : â„•} {l : List â„•}, 1 < b â†’ (âˆ€ (x : â„•), x âˆˆ l â†’ x < b) â†’ Nat.ofDigits b l < b ^ List.length l\",\n  \"isProp\": true,\n  \"docString\": \"an n-digit number in base b is less than b^n if b > 1 \"},\n {\"theorem\":\n  \"âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•), WittVector.IsPoly p fun R _Rcr x => x * â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication by `n` is a polynomial function. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"}]\n",
    "prompt_cons": "/-- If `n` is a nonzero natural number and `p â‰  1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (p : â„•), p â‰  1 â†’ âˆƒ e n', Â¬p âˆ£ n' âˆ§ n = p ^ e * n' :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n â‰  0 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedSemifield Î±] (n : â„•) (a : Î±),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- `a ^ -(n + 1) = (a ^ (n + 1))â»Â¹` -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (n : â„•) (a : Î±),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (â†‘(Nat.succ n)) a)â»Â¹ :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 3 â†’ (-1) ^ (n / 2) = -1 :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- The digits in the base b expansion of n are all less than b, if b â‰¥ 2 -/\ntheorem âˆ€ {b m d : â„•}, 1 < b â†’ d âˆˆ Nat.digits b m â†’ d < b :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1 :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ (n : â„•), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem âˆ€ {n : â„•}, â†‘(Nat.factorial (n - 1)) = -1 â†’ n â‰  1 â†’ Nat.Prime n :=\n\n/-- an n-digit number in base b + 2 is less than (b + 2)^n -/\ntheorem âˆ€ {b : â„•} {l : List â„•}, (âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) â†’ Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l :=\n\n/-- **Wilson's Theorem**: For `n â‰  1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem âˆ€ {n : â„•}, n â‰  1 â†’ (Nat.Prime n â†” â†‘(Nat.factorial (n - 1)) = -1) :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- an n-digit number in base b is less than b^n if b > 1 -/\ntheorem âˆ€ {b : â„•} {l : List â„•}, 1 < b â†’ (âˆ€ (x : â„•), x âˆˆ l â†’ x < b) â†’ Nat.ofDigits b l < b ^ List.length l :=\n\n/-- Multiplication by `n` is a polynomial function. -/\ntheorem âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•), WittVector.IsPoly p fun R _Rcr x => x * â†‘n :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„•}, 0 < n â†’ Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- Prove that for each positive integer `n`, the number `10^(10^(10^n)) + 10^(10^n) + 10^n - 1` is not prime. -/\ntheorem",
    "choices": [
      "âˆ€ (n : â„•), (0 < n) â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), 0 < n â†’ Â¬ Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), 0 < n â†’ Â¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ {n : â„•}, 0 < n â†’ Â¬ Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ (n : â„•), 0 < n â†’ Â¬ Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬ Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), n > 0 â†’ Â¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "âˆ€ (n : â„•), 0 < n â†’ Â¬ Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) "
    ]
  },
  {
    "docString": "Prove that there exist infinitely many integers `n` such that `n, n + 1, n + 2` are each the sum of the squares of two integers.",
    "prompts": "[{\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. \"},\n {\"theorem\":\n  \"âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\": \"âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds for all sufficiently large `n`.\\n\"},\n {\"theorem\": \"âˆ€ {n x y : â„¤}, n = x ^ 2 + y ^ 2 â†’ IsCoprime x y â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the integer `n` is a sum of two squares of coprime integers,\\nthen `-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n\",\n  \"isProp\": true,\n  \"docString\": \"The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {m n : â„•}, Nat.coprime m n â†’ IsSquare (-1) â†’ IsSquare (-1) â†’ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo coprime natural numbers `m` and `n`, then `-1` is also\\na square modulo `m*n`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.choose n 2 = n * (n - 1) / 2\",\n  \"isProp\": true,\n  \"docString\": \"`choose n 2` is the `n`-th triangle number. \"},\n {\"theorem\":\n  \"âˆ€ {x y z : â„¤},\\n  PythagoreanTriple x y z â†’\\n    (PythagoreanTriple x y z â†”\\n      âˆƒ k m n,\\n        (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§\\n          (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2)))\",\n  \"isProp\": true,\n  \"docString\": \"**Formula for Pythagorean Triples** \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \"},\n {\"theorem\": \"âˆ€ {n : â„•} (self : Composition n), List.sum self.blocks = n\",\n  \"isProp\": true,\n  \"docString\": \"Proof that `blocks` sums to `n`\"},\n {\"theorem\":\n  \"Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"}]\n",
    "prompt_cons": "/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆƒ a b, n = a ^ 2 * b âˆ§ IsSquare (-1) :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„•}, n = x ^ 2 + y ^ 2 â†’ Nat.coprime x y â†’ IsSquare (-1) :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n) :=\n\n/-- Proves that Bertrand's postulate holds for all sufficiently large `n`. -/\ntheorem âˆ€ (n : â„•), 512 â‰¤ n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- If the integer `n` is a sum of two squares of coprime integers,\nthen `-1` is a square modulo `n`. -/\ntheorem âˆ€ {n x y : â„¤}, n = x ^ 2 + y ^ 2 â†’ IsCoprime x y â†’ IsSquare (-1) :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem âˆ€ (n : â„•), (âˆ‘' (i : â„•), if n â‰¤ i then 2â»Â¹ ^ i else 0) = 2 * 2â»Â¹ ^ n :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤ :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- If `-1` is a square modulo coprime natural numbers `m` and `n`, then `-1` is also\na square modulo `m*n`. -/\ntheorem âˆ€ {m n : â„•}, Nat.coprime m n â†’ IsSquare (-1) â†’ IsSquare (-1) â†’ IsSquare (-1) :=\n\n/-- `choose n 2` is the `n`-th triangle number. -/\ntheorem âˆ€ (n : â„•), Nat.choose n 2 = n * (n - 1) / 2 :=\n\n/-- **Formula for Pythagorean Triples** -/\ntheorem âˆ€ {x y z : â„¤},\n  PythagoreanTriple x y z â†’\n    (PythagoreanTriple x y z â†”\n      âˆƒ k m n,\n        (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§\n          (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2))) :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±] {x y : Î±}, 0 < x â†’ y < 1 â†’ âˆƒ n, y ^ n < x :=\n\n/-- Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p :=\n\n/-- Proof that `blocks` sums to `n` -/\ntheorem âˆ€ {n : â„•} (self : Composition n), List.sum self.blocks = n :=\n\n/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => â†‘n / (2 * â†‘n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- Prove that there exist infinitely many integers `n` such that `n, n + 1, n + 2` are each the sum of the squares of two integers. -/\ntheorem",
    "choices": [
      "âˆƒá¶  (n : â„¤) in Filter.atTop, (âˆƒ x y, n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ u v, n + 1 = u ^ 2 + v ^ 2) âˆ§ (âˆƒ r s, n + 2 = r ^ 2 + s ^ 2) ",
      "âˆƒ (f : â„• â†’ â„•), âˆ€ (n : â„•), (âˆƒ x y, f n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, f (n + 1) = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, f (n + 2) = x ^ 2 + y ^ 2) ",
      "âˆƒ f : â„• â†’ â„•, StrictMono f âˆ§ âˆ€ n, (âˆƒ xâ‚ yâ‚, f n = xâ‚ ^ 2 + yâ‚ ^ 2) âˆ§ (âˆƒ xâ‚‚ yâ‚‚, f n + 1 = xâ‚‚ ^ 2 + yâ‚‚ ^ 2) âˆ§ (âˆƒ xâ‚ƒ yâ‚ƒ, f n + 2 = xâ‚ƒ ^ 2 + yâ‚ƒ ^ 2) ",
      "âˆƒá¶  (n : â„¤) in Filter.atTop, (âˆƒ a b, n = a ^ 2 + b ^ 2) âˆ§ (âˆƒ c d, n + 1 = c ^ 2 + d ^ 2) âˆ§ (âˆƒ e f, n + 2 = e ^ 2 + f ^ 2) ",
      "âˆƒ (f : â„• â†’ â„•), âˆ€ N, âˆƒ n, N â‰¤ n âˆ§ (âˆƒ x y, n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, n + 1 = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, n + 2 = x ^ 2 + y ^ 2) ",
      "âˆƒ f : â„• â†’ â„•, âˆ€ n : â„•, (âˆƒ a b, (f n) = a ^ 2 + b ^ 2) âˆ§ (âˆƒ c d, (f n) + 1 = c ^ 2 + d ^ 2) âˆ§ (âˆƒ e f, (f n) + 2 = e ^ 2 + f ^ 2) ",
      "âˆ€ (N : â„¤), âˆƒ n, N â‰¤ n âˆ§ (âˆƒ xâ‚ yâ‚ xâ‚‚ yâ‚‚ xâ‚ƒ yâ‚ƒ : â„¤, n = xâ‚ ^ 2 + yâ‚ ^ 2 âˆ§ n + 1 = xâ‚‚ ^ 2 + yâ‚‚ ^ 2 âˆ§ n + 2 = xâ‚ƒ ^ 2 + yâ‚ƒ ^ 2) ",
      "âˆ€ (N : â„•), âˆƒ n : â„•, N < n âˆ§ (âˆƒ x1 y1 x2 y2 x3 y3 : â„•, n = x1 ^ 2 + y1 ^ 2 âˆ§ n + 1 = x2 ^ 2 + y2 ^ 2 âˆ§ n + 2 = x3 ^ 2 + y3 ^ 2) ",
      "âˆƒá¶  (n : â„¤) in Filter.atTop, (âˆƒ a b, n = a ^ 2 + b ^ 2) âˆ§ (âˆƒ c d, n + 1 = c ^ 2 + d ^ 2) âˆ§ (âˆƒ e f, n + 2 = e ^ 2 + f ^ 2) ",
      "âˆƒ (f : â„• â†’ â„•), StrictMono f âˆ§ âˆ€ (n : â„•), (âˆƒ x y, f n = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, f n + 1 = x ^ 2 + y ^ 2) âˆ§ (âˆƒ x y, f n + 2 = x ^ 2 + y ^ 2) "
    ]
  },
  {
    "docString": "Let `f` be a real function on the real line with continuous third derivative. Prove that there exists a point `a` such that...",
    "prompts": "[{\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` has a local extremum at some\\npoint of the corresponding open interval. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E},\\n  DifferentiableOn â„ f s â†’\\n    ContinuousWithinAt f s a â†’\\n      s âˆˆ nhdsWithin a (Set.Iio a) â†’\\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Iio a)) (nhds e) â†’ HasDerivWithinAt f e (Set.Iic a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is differentiable on the left of a point `a : â„`, continuous at `a`, and\\nits derivative also converges at `a`, then `f` is differentiable on the left at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E},\\n  DifferentiableOn â„ f s â†’\\n    ContinuousWithinAt f s a â†’\\n      s âˆˆ nhdsWithin a (Set.Ioi a) â†’\\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Ioi a)) (nhds e) â†’ HasDerivWithinAt f e (Set.Ici a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is differentiable on the right of a point `a : â„`, continuous at `a`, and\\nits derivative also converges at `a`, then `f` is differentiable on the right at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  MonotoneOn f s â†’\\n    s âˆˆ nhds a â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\\nis continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ âˆ€ (y : â„), HasDerivAt f (g y) y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is the derivative of `f` everywhere. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\\n  {f' : E â†’L[ğ•œ] F} {a : E},\\n  HasStrictFDerivAt f f' a â†’ âˆ€ {c : NNReal}, Subsingleton E âˆ¨ 0 < c â†’ âˆƒ s, s âˆˆ nhds a âˆ§ ApproximatesLinearOn f f' s c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` has derivative `f'` at `a` in the strict sense and `c > 0`, then `f` approximates `f'`\\nwith constant `c` on some neighborhood of `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ f '' s âˆˆ nhds (f a) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\\nand the image of this set under `f` is a neighborhood of `f a`, then `f` is continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {a : â„}\\n  {s : Set â„},\\n  (âˆ€ (x : â„), x âˆˆ s â†’ IntervalIntegrable f MeasureTheory.volume a x) â†’\\n    Continuous f â†’ DifferentiableOn â„ (fun u => âˆ« (x : â„) in a..u, f x) s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The integral of a continuous function is differentiable on a real set `s`. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„ â†’ â„) {a b : â„},\\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsExtrOn f (Set.Icc a b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` takes either its maximum\\nor its minimum value at a point in the interior of the interval. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\\n    (âˆƒ c,\\n        c < 2 âˆ§\\n          âˆƒ B,\\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T1Space Î²] {f : Î± â†’ Î²}\\n  {a : Î±} {b : Î²}, Filter.Tendsto f (nhds a) (nhds b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a function to a `T1Space` is continuous at some point `a`, it suffices to prove that\\n`f` admits *some* limit at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ closure (f '' s) âˆˆ nhds (f a) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\\nand the closure of the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is\\ncontinuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : Preorder Î²] {a : Î±} {f : Î± â†’ Î²},\\n  MonotoneOn f (Set.Iic a) â†’ MonotoneOn f (Set.Ici a) â†’ Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is monotone both on `(-âˆ, a]` and `[a, âˆ)`, then it is monotone on the whole line. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhds a â†’\\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’\\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is strictly monotone on a neighborhood of `a` and the image of this\\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval\\n`(f a, b]`, `b > f a`, then `f` is continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, MonotoneOn f s â†’ s âˆˆ nhds a â†’ f '' s âˆˆ nhds (f a) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is monotone on a neighborhood of `a` and the\\nimage of this neighborhood under `f` is a neighborhood of `f a`, then `f` is continuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, MonotoneOn f s â†’ s âˆˆ nhds a â†’ closure (f '' s) âˆˆ nhds (f a) â†’ ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is monotone on a neighborhood of `a` and the\\nclosure of the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is\\ncontinuous at `a`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’\\n      closure (f '' s) âˆˆ nhdsWithin (f a) (Set.Iic (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is strictly monotone on a left neighborhood of\\n`a` and the closure of the image of this neighborhood under `f` is a left neighborhood of `f a`,\\nthen `f` is continuous at `a` from the left. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\\n  StrictMonoOn f s â†’\\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’ f '' s âˆˆ nhdsWithin (f a) (Set.Iic (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` with a densely ordered codomain is strictly monotone on a left neighborhood of\\n`a` and the image of this neighborhood under `f` is a left neighborhood of `f a`, then `f` is\\ncontinuous at `a` from the left. \"}]\n",
    "prompt_cons": "/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„}, a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsLocalExtr f c :=\n\n/-- If a function is differentiable on the left of a point `a : â„`, continuous at `a`, and\nits derivative also converges at `a`, then `f` is differentiable on the left at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E},\n  DifferentiableOn â„ f s â†’\n    ContinuousWithinAt f s a â†’\n      s âˆˆ nhdsWithin a (Set.Iio a) â†’\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Iio a)) (nhds e) â†’ HasDerivWithinAt f e (Set.Iic a) a :=\n\n/-- If a function is differentiable on the right of a point `a : â„`, continuous at `a`, and\nits derivative also converges at `a`, then `f` is differentiable on the right at `a`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E},\n  DifferentiableOn â„ f s â†’\n    ContinuousWithinAt f s a â†’\n      s âˆˆ nhdsWithin a (Set.Ioi a) â†’\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Ioi a)) (nhds e) â†’ HasDerivWithinAt f e (Set.Ici a) a :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ HasDerivAt f (g x) x :=\n\n/-- If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\nis continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  MonotoneOn f s â†’\n    s âˆˆ nhds a â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo b (f a)) â†’\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioo (f a) b) â†’ ContinuousAt f a :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is the derivative of `f` everywhere. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {x : â„},\n  (âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) â†’ ContinuousAt f x â†’ ContinuousAt g x â†’ âˆ€ (y : â„), HasDerivAt f (g y) y :=\n\n/-- If `f` has derivative `f'` at `a` in the strict sense and `c > 0`, then `f` approximates `f'`\nwith constant `c` on some neighborhood of `a`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â†’L[ğ•œ] F} {a : E},\n  HasStrictFDerivAt f f' a â†’ âˆ€ {c : NNReal}, Subsingleton E âˆ¨ 0 < c â†’ âˆƒ s, s âˆˆ nhds a âˆ§ ApproximatesLinearOn f f' s c :=\n\n/-- If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\nand the image of this set under `f` is a neighborhood of `f a`, then `f` is continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ f '' s âˆˆ nhds (f a) â†’ ContinuousAt f a :=\n\n/-- The integral of a continuous function is differentiable on a real set `s`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {f : â„ â†’ E} {a : â„}\n  {s : Set â„},\n  (âˆ€ (x : â„), x âˆˆ s â†’ IntervalIntegrable f MeasureTheory.volume a x) â†’\n    Continuous f â†’ DifferentiableOn â„ (fun u => âˆ« (x : â„) in a..u, f x) s :=\n\n/-- A continuous function on a closed interval with `f a = f b` takes either its maximum\nor its minimum value at a point in the interior of the interval. -/\ntheorem âˆ€ (f : â„ â†’ â„) {a b : â„},\n  a < b â†’ ContinuousOn f (Set.Icc a b) â†’ f a = f b â†’ âˆƒ c, c âˆˆ Set.Ioo a b âˆ§ IsExtrOn f (Set.Icc a b) c :=\n\n/-- **Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c,\n        c < 2 âˆ§\n          âˆƒ B,\n            f =O[Filter.comap (â†‘Complex.abs) Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n              rexp (B * â†‘Complex.abs z ^ c)) â†’\n      (âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) â†’\n        (âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0} :=\n\n/-- To prove a function to a `T1Space` is continuous at some point `a`, it suffices to prove that\n`f` admits *some* limit at `a`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T1Space Î²] {f : Î± â†’ Î²}\n  {a : Î±} {b : Î²}, Filter.Tendsto f (nhds a) (nhds b) â†’ ContinuousAt f a :=\n\n/-- If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\nand the closure of the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is\ncontinuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, StrictMonoOn f s â†’ s âˆˆ nhds a â†’ closure (f '' s) âˆˆ nhds (f a) â†’ ContinuousAt f a :=\n\n/-- If `f` is monotone both on `(-âˆ, a]` and `[a, âˆ)`, then it is monotone on the whole line. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : Preorder Î²] {a : Î±} {f : Î± â†’ Î²},\n  MonotoneOn f (Set.Iic a) â†’ MonotoneOn f (Set.Ici a) â†’ Monotone f :=\n\n/-- If a function `f` is strictly monotone on a neighborhood of `a` and the image of this\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval\n`(f a, b]`, `b > f a`, then `f` is continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhds a â†’\n      (âˆ€ (b : Î²), b < f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ico b (f a)) â†’\n        (âˆ€ (b : Î²), b > f a â†’ âˆƒ c, c âˆˆ s âˆ§ f c âˆˆ Set.Ioc (f a) b) â†’ ContinuousAt f a :=\n\n/-- If a function `f` with a densely ordered codomain is monotone on a neighborhood of `a` and the\nimage of this neighborhood under `f` is a neighborhood of `f a`, then `f` is continuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, MonotoneOn f s â†’ s âˆˆ nhds a â†’ f '' s âˆˆ nhds (f a) â†’ ContinuousAt f a :=\n\n/-- A complex differentiable function `f : â„‚ â†’ E` is continuously differentiable at every point. -/\ntheorem âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] {f : â„‚ â†’ E},\n  Differentiable â„‚ f â†’ âˆ€ {n : â„•âˆ}, ContDiff â„‚ n f :=\n\n/-- If a function `f` with a densely ordered codomain is monotone on a neighborhood of `a` and the\nclosure of the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is\ncontinuous at `a`. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±}, MonotoneOn f s â†’ s âˆˆ nhds a â†’ closure (f '' s) âˆˆ nhds (f a) â†’ ContinuousAt f a :=\n\n/-- If a function `f` with a densely ordered codomain is strictly monotone on a left neighborhood of\n`a` and the closure of the image of this neighborhood under `f` is a left neighborhood of `f a`,\nthen `f` is continuous at `a` from the left. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’\n      closure (f '' s) âˆˆ nhdsWithin (f a) (Set.Iic (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a :=\n\n/-- If a function `f` with a densely ordered codomain is strictly monotone on a left neighborhood of\n`a` and the image of this neighborhood under `f` is a left neighborhood of `f a`, then `f` is\ncontinuous at `a` from the left. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : LinearOrder Î²] [inst_4 : TopologicalSpace Î²] [inst_5 : OrderTopology Î²] [inst_6 : DenselyOrdered Î²]\n  {f : Î± â†’ Î²} {s : Set Î±} {a : Î±},\n  StrictMonoOn f s â†’\n    s âˆˆ nhdsWithin a (Set.Iic a) â†’ f '' s âˆˆ nhdsWithin (f a) (Set.Iic (f a)) â†’ ContinuousWithinAt f (Set.Iic a) a :=\n\n/-- Let `f` be a real function on the real line with continuous third derivative. Prove that there exists a point `a` such that... -/\ntheorem",
    "choices": [
      "âˆ€ {f : â„ â†’ â„} {s : Set â„} (hs : DifferentiableOn â„ f s) (hf : ContinuousOn (deriv^[3]) f s),\n  âˆƒ a âˆˆ s, deriv^[3] f a = 0 ",
      "âˆ€ {f : â„ â†’ â„},\n  (Differentiable â„ f âˆ§ âˆ€ (x : â„), (deriv^[3] f) x = 0) â†’\n    âˆƒ a, deriv f a = 0 âˆ§ deriv^[2] f a = 0 ",
      "âˆ€ (f : â„ â†’ â„),\n  ContinuousOn (deriv^[3] f) â„ â†’\n  âˆƒ a, deriv^[2] f a = 0 âˆ§ HasDerivAt (deriv^[2] f) (deriv^[3] f a) a ",
      "âˆ€ {f : â„ â†’ â„}, (âˆ€ x, continuous (deriv^[3] f) x) â†’ âˆƒ a, (deriv^[3] f a) (f a - a) = 6 ",
      "âˆ€ {f : â„ â†’ â„} (hderiv : âˆ€ x, DifferentiableAt â„ (deriv^[3]) x) (x y z : â„),\n  âˆƒ a, deriv^[3] a (x * y * z) = (x * y * z) * (deriv^[3] a x + deriv^[3] a y + deriv^[3] a z) ",
      "âˆ€ {f : â„ â†’ â„}, ContinuousOn (deriv^[3]) f â„ â†’ âˆƒ a, HasDerivAt f (-f a / 2) a ",
      "âˆ€ (f : â„ â†’ â„),\n  ContinuousOn (deriv^[3]) â„ f â„ â†’\n    âˆƒ a, deriv^[3] f a = deriv^[2] f a * (deriv f a)^2 + (deriv^[2] f a)^2 * deriv f a ",
      "âˆ€ {f : â„ â†’ â„},\n  Differentiable â„ f â†’\n  (âˆ€ {x : â„}, DifferentiableAt â„ (deriv f) x) â†’\n  Continuous (deriv (deriv (deriv f))) â†’\n  âˆƒ a, deriv (deriv (deriv f)) a * a = 2 * (deriv (deriv f) a) - 2 * f a + 4 * deriv f a - 6 * a ",
      "âˆ€ {f : â„ â†’ â„},\n  Continuous (deriv^[3] f) â†’\n  âˆƒ a, deriv^[3] f a = 0 âˆ§ deriv f a = 0 âˆ§ deriv^[2] f a = 0 ",
      "âˆ€ (f : â„ â†’ â„),\n  Continuous (deriv^[3] f) â†’\n  âˆƒ a, IsLocalExtr (deriv^[2] f) a âˆ§ deriv (deriv f) a = 0 âˆ§ deriv^[3] f a â‰  0 "
    ]
  },
  {
    "docString": "Let `(p_n)` be a sequence and `f: â„• â†’ â„•`. The sequence `(q_k)_{k âˆˆ â„•}` with `q_k = p_{f(k)}` is called a rearrangement of `(p_n)`. Show that if `f` is an injection, the limit of a sequence is unaffected by rearrangement.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto f Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity. \"},\n {\"theorem\":\n  \"âˆ€ (f : CircleDeg1Lift) (x : â„),\\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : â„` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {Ï€ : X â†’ Sort u_1} {f : â„• â†’ (x : X) â†’ Ï€ x},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’\\n    âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, âˆ€á¶  (y : X) in nhds x, f n y = F y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F : Î  a, Î² a` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n y = F y` in a neighbourhood of `x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n =á¶ [ğ“ x] F`. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M â†’* P),\\n  Function.Injective â†‘(Con.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {Î¹ : Type u_3}\\n  {l : Filter Î¹} [inst_1 : Filter.NeBot l] [_i : Fact (1 â‰¤ p)] {F : Î¹ â†’ { x // x âˆˆ lp E p }},\\n  Metric.Bounded (Set.range F) â†’ âˆ€ {f : (a : Î±) â†’ E a}, Filter.Tendsto (id fun i => â†‘(F i)) l (nhds f) â†’ Memâ„“p f p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p\",\n  \"isProp\": true,\n  \"docString\": \"Summability of the `p`-series over `â„¤`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  {p' : Filter Î±},\\n  TendstoUniformlyOnFilter F f p p' â†” Filter.Tendsto (fun q => (f q.snd, F q.fst q.snd)) (p Ã—Ë¢ p') (uniformity Î²)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequence of functions `Fâ‚™` converges uniformly on a filter `p'` to a limiting function `f` w.r.t.\\nfilter `p` iff the function `(n, x) â†¦ (f x, Fâ‚™ x)` converges along `p Ã—Ë¢ p'` to the uniformity.\\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `p'`.\\n\"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {Ï€ : X â†’ Sort u_1} {f : â„• â†’ (x : X) â†’ Ï€ x},\\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’\\n    âˆƒ F, âˆ€ (x : X), âˆ€á¶  (p : â„• Ã— X) in Filter.atTop Ã—Ë¢ nhds x, f p.fst p.snd = F p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\\nfunction `F : Î  a, Î² a` such that for any `x`, we have `f n x = F x` on the product of an infinite\\ninterval `[N, +âˆ)` and a neighbourhood of `x`.\\n\\nWe formulate the conclusion in terms of the product of filter `Filter.atTop` and `ğ“ x`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrder Î±] {f : Fin n â†’ Î±}, Tuple.sort f = Equiv.refl (Fin n) â†” Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"The permutation that sorts `f` is the identity if and only if `f` is monotone. \"},\n {\"theorem\":\n  \"âˆ€ (f : â„• â†’ NNReal), Filter.Tendsto (fun i => âˆ‘' (k : â„•), f (k + i)) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `f : â„• â†’ â„â‰¥0`, then `âˆ‘' k, f (k + i)` tends to zero. This does not require a summability\\nassumption on `f`, as otherwise all sums are zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\\n  TendstoUniformly F f p â†” Filter.Tendsto (fun q => (f q.snd, F q.fst q.snd)) (p Ã—Ë¢ âŠ¤) (uniformity Î²)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequence of functions `Fâ‚™` converges uniformly to a limiting function `f` w.r.t.\\nfilter `p` iff the function `(n, x) â†¦ (f x, Fâ‚™ x)` converges along `p Ã—Ë¢ âŠ¤` to the uniformity.\\nIn other words: one knows nothing about the behavior of `x` in this limit.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u_2} [inst : MeasurableSpace Î²] {p : ENNReal} {E : Type u_1} [inst_1 : NormedAddCommGroup E] {f : Î² â†’ E}\\n  {Î¼ : MeasureTheory.Measure Î²},\\n  MeasureTheory.Memâ„’p f p â†’\\n    p â‰  âŠ¤ â†’ âˆ€ {Îµ : ENNReal}, Îµ â‰  0 â†’ âˆƒ g, MeasureTheory.snorm (f - â†‘g) p Î¼ < Îµ âˆ§ MeasureTheory.Memâ„’p (â†‘g) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any function in `â„’p` can be approximated by a simple function if `p < âˆ`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u} {V' : Type u_2} [inst : DivisionRing K] [inst_1 : AddCommGroup V]\\n  [inst_2 : AddCommGroup V'] [inst_3 : Module K V] [inst_4 : Module K V'] {p : Submodule K V}\\n  (f : { x // x âˆˆ p } â†’â‚—[K] V'), âˆƒ g, LinearMap.comp g (Submodule.subtype p) = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any linear map `f : p â†’â‚—[K] V'` defined on a subspace `p` can be extended to the whole\\nspace. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(â„, E)},\\n  (Summable fun n => â€–ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight â†‘n))â€–) â†’\\n    MeasureTheory.Integrable â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sequence with `n`-th term the the sup norm of `Î» x, f (x + n)` on the interval `Icc 0 1`,\\nfor `n âˆˆ â„¤`, is summable, then `f` is integrable on `â„`. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E}, HasFPowerSeriesAt 0 p x â†’ âˆ€ (n : â„•) (y : E), (â†‘(p n) fun x => y) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a formal multilinear series `p` represents the zero function at `x : E`, then the\\nterms `p n (fun i â†¦ y)` appearing the in sum are zero for any `n : â„•`, `y : E`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} {c : CategoryTheory.Limits.Fork f f},\\n  CategoryTheory.Limits.IsLimit c â†’ CategoryTheory.IsIso (CategoryTheory.Limits.Fork.Î¹ c)\",\n  \"isProp\": true,\n  \"docString\": \"Every equalizer of `(f, f)` is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalAddGroup Î±]\\n  [inst_3 : T2Space Î±] (f : â„• â†’ Î±), Filter.Tendsto (fun i => âˆ‘' (k : â„•), f (k + i)) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `f : â„• â†’ Î±`, then `âˆ‘' k, f (k + i)` tends to zero. This does not require a summability\\nassumption on `f`, as otherwise all sums are zero. \"}]\n",
    "prompt_cons": "/-- An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity. -/\ntheorem âˆ€ {f : â„• â†’ â„•}, Function.Injective f â†’ Filter.Tendsto f Filter.atTop Filter.atTop :=\n\n/-- For any `x : â„` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem âˆ€ (f : CircleDeg1Lift) (x : â„),\n  Filter.Tendsto (fun n => (â†‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F : Î  a, Î² a` such that for any `x`, for sufficiently large values of `n`, we have\n`f n y = F y` in a neighbourhood of `x`. -/\ntheorem âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {Ï€ : X â†’ Sort u_1} {f : â„• â†’ (x : X) â†’ Ï€ x},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’\n    âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, âˆ€á¶  (y : X) in nhds x, f n y = F y :=\n\n/-- Let `f : â„• â†’ Î± â†’ Î²` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F :  Î± â†’ Î²` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =á¶ [ğ“ x] F`. -/\ntheorem âˆ€ {Î± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : â„• â†’ X â†’ Î±},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’ âˆƒ F, âˆ€ (x : X), âˆ€á¶  (n : â„•) in Filter.atTop, f n =á¶ [nhds x] F :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem âˆ€ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M â†’* P),\n  Function.Injective â†‘(Con.kerLift f) :=\n\n/-- If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {Î¹ : Type u_3}\n  {l : Filter Î¹} [inst_1 : Filter.NeBot l] [_i : Fact (1 â‰¤ p)] {F : Î¹ â†’ { x // x âˆˆ lp E p }},\n  Metric.Bounded (Set.range F) â†’ âˆ€ {f : (a : Î±) â†’ E a}, Filter.Tendsto (id fun i => â†‘(F i)) l (nhds f) â†’ Memâ„“p f p :=\n\n/-- Summability of the `p`-series over `â„¤`. -/\ntheorem âˆ€ {p : â„•}, (Summable fun n => 1 / â†‘n ^ p) â†” 1 < p :=\n\n/-- A sequence of functions `Fâ‚™` converges uniformly on a filter `p'` to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) â†¦ (f x, Fâ‚™ x)` converges along `p Ã—Ë¢ p'` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `p'`. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  {p' : Filter Î±},\n  TendstoUniformlyOnFilter F f p p' â†” Filter.Tendsto (fun q => (f q.snd, F q.fst q.snd)) (p Ã—Ë¢ p') (uniformity Î²) :=\n\n/-- Let `f : â„• â†’ Î  a, Î² a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x â‰  f n x}` is locally finite. Then there exists a\nfunction `F : Î  a, Î² a` such that for any `x`, we have `f n x = F x` on the product of an infinite\ninterval `[N, +âˆ)` and a neighbourhood of `x`.\n\nWe formulate the conclusion in terms of the product of filter `Filter.atTop` and `ğ“ x`. -/\ntheorem âˆ€ {X : Type u_2} [inst : TopologicalSpace X] {Ï€ : X â†’ Sort u_1} {f : â„• â†’ (x : X) â†’ Ï€ x},\n  (LocallyFinite fun n => {x | f (n + 1) x â‰  f n x}) â†’\n    âˆƒ F, âˆ€ (x : X), âˆ€á¶  (p : â„• Ã— X) in Filter.atTop Ã—Ë¢ nhds x, f p.fst p.snd = F p.snd :=\n\n/-- If `f : â„• â†’ Î±` has sum `a`, then the partial sums `âˆ‘_{i=0}^{n-1} f i` converge to `a`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : AddCommMonoid Î±] [inst_1 : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±},\n  HasSum f a â†’ Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a) :=\n\n/-- The permutation that sorts `f` is the identity if and only if `f` is monotone. -/\ntheorem âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrder Î±] {f : Fin n â†’ Î±}, Tuple.sort f = Equiv.refl (Fin n) â†” Monotone f :=\n\n/-- For `f : â„• â†’ â„â‰¥0`, then `âˆ‘' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. -/\ntheorem âˆ€ (f : â„• â†’ NNReal), Filter.Tendsto (fun i => âˆ‘' (k : â„•), f (k + i)) Filter.atTop (nhds 0) :=\n\n/-- A sequence of functions `Fâ‚™` converges uniformly to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) â†¦ (f x, Fâ‚™ x)` converges along `p Ã—Ë¢ âŠ¤` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\n  TendstoUniformly F f p â†” Filter.Tendsto (fun q => (f q.snd, F q.fst q.snd)) (p Ã—Ë¢ âŠ¤) (uniformity Î²) :=\n\n/-- Any function in `â„’p` can be approximated by a simple function if `p < âˆ`. -/\ntheorem âˆ€ {Î² : Type u_2} [inst : MeasurableSpace Î²] {p : ENNReal} {E : Type u_1} [inst_1 : NormedAddCommGroup E] {f : Î² â†’ E}\n  {Î¼ : MeasureTheory.Measure Î²},\n  MeasureTheory.Memâ„’p f p â†’\n    p â‰  âŠ¤ â†’ âˆ€ {Îµ : ENNReal}, Îµ â‰  0 â†’ âˆƒ g, MeasureTheory.snorm (f - â†‘g) p Î¼ < Îµ âˆ§ MeasureTheory.Memâ„’p (â†‘g) p :=\n\n/-- Any linear map `f : p â†’â‚—[K] V'` defined on a subspace `p` can be extended to the whole\nspace. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u} {V' : Type u_2} [inst : DivisionRing K] [inst_1 : AddCommGroup V]\n  [inst_2 : AddCommGroup V'] [inst_3 : Module K V] [inst_4 : Module K V'] {p : Submodule K V}\n  (f : { x // x âˆˆ p } â†’â‚—[K] V'), âˆƒ g, LinearMap.comp g (Submodule.subtype p) = f :=\n\n/-- If the sequence with `n`-th term the the sup norm of `Î» x, f (x + n)` on the interval `Icc 0 1`,\nfor `n âˆˆ â„¤`, is summable, then `f` is integrable on `â„`. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(â„, E)},\n  (Summable fun n => â€–ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight â†‘n))â€–) â†’\n    MeasureTheory.Integrable â†‘f :=\n\n/-- If a formal multilinear series `p` represents the zero function at `x : E`, then the\nterms `p n (fun i â†¦ y)` appearing the in sum are zero for any `n : â„•`, `y : E`. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  {p : FormalMultilinearSeries ğ•œ E F} {x : E}, HasFPowerSeriesAt 0 p x â†’ âˆ€ (n : â„•) (y : E), (â†‘(p n) fun x => y) = 0 :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {Î² : Type u_2} [inst_1 : Ring Î²] {abv : Î² â†’ Î±}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Î² abv] (s : CauSeq Î² abv), âˆƒ b, s â‰ˆ CauSeq.const abv b :=\n\n/-- Every equalizer of `(f, f)` is an isomorphism. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} {c : CategoryTheory.Limits.Fork f f},\n  CategoryTheory.Limits.IsLimit c â†’ CategoryTheory.IsIso (CategoryTheory.Limits.Fork.Î¹ c) :=\n\n/-- For `f : â„• â†’ Î±`, then `âˆ‘' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalAddGroup Î±]\n  [inst_3 : T2Space Î±] (f : â„• â†’ Î±), Filter.Tendsto (fun i => âˆ‘' (k : â„•), f (k + i)) Filter.atTop (nhds 0) :=\n\n/-- Let `(p_n)` be a sequence and `f: â„• â†’ â„•`. The sequence `(q_k)_{k âˆˆ â„•}` with `q_k = p_{f(k)}` is called a rearrangement of `(p_n)`. Show that if `f` is an injection, the limit of a sequence is unaffected by rearrangement. -/\ntheorem",
    "choices": [
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ â„•} {p q : â„• â†’ Î±},\n  Function.Injective f â†’\n  (âˆ€ k, q k = p (f k)) â†’ (Filter.Tendsto p Filter.atTop (nhds a) â†” Filter.Tendsto q Filter.atTop (nhds a)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {f : â„• â†’ â„•} {p : â„• â†’ Î±},\n  Function.Injective f â†’ Filter.Tendsto p Filter.atTop (nhds (lim p)) â†’ Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds (lim p)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•},\n  Function.Injective f â†’\n    (Filter.Tendsto p Filter.atTop (ğ“ (l : Î±)) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (ğ“ l)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : LinearOrder Î±] [inst_2 : OrderTopology Î±] {a : Î±} {f : â„• â†’ â„•}\n  {p : â„• â†’ Î±},\n    Function.Injective f â†’\n    Filter.Tendsto p Filter.atTop (nhds a) â†’\n    Filter.Tendsto (fun n => p (f n)) Filter.atTop (nhds a) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {f : â„• â†’ â„•} {p : â„• â†’ Î±},\n  Function.Injective f â†’\n  (âˆƒ a : Î±, Filter.Tendsto p Filter.atTop (nhds a)) â†”\n  (âˆƒ a : Î±, Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds a)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] {f : â„• â†’ â„•} (hf : Function.Injective f) {p : â„• â†’ Î±},\n  Filter.Tendsto p Filter.atTop (nhds l) â†’ Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds l) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {f : â„• â†’ â„•} {p : â„• â†’ Î±},\n  Function.Injective f â†’\n    (âˆ€ l, Filter.Tendsto p Filter.atTop (nhds l) â†” Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds l)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {p : â„• â†’ Î±} {f : â„• â†’ â„•},\n  Function.Injective f â†’ Filter.Tendsto p Filter.atTop (nhds (lim p)) â†’ Filter.Tendsto (p âˆ˜ f) Filter.atTop (nhds (lim p)) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : AddCommMonoid Î±] {f : â„• â†’ Î±},\n  HasSum f â†’ âˆ€ (g : â„• â†’ â„•), Function.Injective g â†’ HasSum (f âˆ˜ g) ",
      "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {a : Î±} {f : â„• â†’ â„•} {p q : â„• â†’ Î±},\n  Function.Injective f â†’\n  Filter.Tendsto p Filter.atTop (nhds a) â†’\n  (q = fun k => p (f k)) â†’\n  Filter.Tendsto q Filter.atTop (nhds a) "
    ]
  },
  {
    "docString": "Let `ğ’¯` be the collection of open subsets of a metric space `M`, and `ğ’¦` the collection of closed subsets. Show that there is a bijection from `ğ’¯` onto `ğ’¦`.",
    "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  IsCompact s â†’\\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type u_1} [inst_4 : MetricSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : Î¹ â†’ Set M},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : M), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : M), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `M` be a smooth Ïƒ-compact manifold with a metric. Let `K : Î¹ â†’ Set M` be a locally finite\\nfamily of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for all\\n`i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and `x âˆˆ K i`,\\nwe have `Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\\n`Metric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_2 : MeasureTheory.Measure.Regular Î¼] â¦ƒU : Set Î±â¦„,\\n  IsOpen U â†’ âˆ€ {r : ENNReal}, r < â†‘â†‘Î¼ U â†’ âˆƒ K, K âŠ† U âˆ§ IsCompact K âˆ§ r < â†‘â†‘Î¼ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î¼` is a regular measure, then any open set can be approximated by a compact subset. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type u_1} [inst_4 : EMetricSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : Î¹ â†’ Set M},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’\\n          âˆƒ Î´, (âˆ€ (x : M), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : M), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `M` be a smooth Ïƒ-compact manifold with extended distance. Let `K : Î¹ â†’ Set M` be a locally\\nfinite family of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for\\nall `i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and\\n`x âˆˆ K i`, we have `EMetric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’\\n          âˆ€ (x : X),\\n            âˆ€á¶  (p : ENNReal Ã— X) in nhds 0 Ã—Ë¢ nhds x, âˆ€ (i : Î¹), p.snd âˆˆ K i â†’ EMetric.closedBall p.snd p.fst âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets in an emetric space. Let\\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then for any point\\n`x : X`, for sufficiently small `r : â„â‰¥0âˆ` and for `y` sufficiently close to `x`, for all `i`, if\\n`y âˆˆ K i`, then `EMetric.closedBall y r âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\\n  [inst_5 : ChartedSpace H M] {s : Set M} {U : M â†’ Set M} [inst_6 : T2Space M] [inst_7 : SigmaCompactSpace M],\\n  IsClosed s â†’ (âˆ€ (x : M), x âˆˆ s â†’ U x âˆˆ nhds x) â†’ âˆƒ Î¹ f, SmoothBumpCovering.IsSubordinate f U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `M` be a smooth manifold with corners modelled on a finite dimensional real vector space.\\nSuppose also that `M` is a Hausdorff `Ïƒ`-compact topological space. Let `s` be a closed set\\nin `M` and `U : M â†’ Set M` be a collection of sets such that `U x âˆˆ ğ“ x` for every `x âˆˆ s`.\\nThen there exists a smooth bump covering of `s` that is subordinate to `U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\\n  [inst_2 : MeasureTheory.Measure.WeaklyRegular Î¼] â¦ƒU : Set Î±â¦„,\\n  IsOpen U â†’ âˆ€ {r : ENNReal}, r < â†‘â†‘Î¼ U â†’ âˆƒ F, F âŠ† U âˆ§ IsClosed F âˆ§ r < â†‘â†‘Î¼ F\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Î¼` is a weakly regular measure, then any open set can be approximated by a closed subset. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’\\n          âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (ENNReal.ofReal (Î´ x)) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„â‰¥0âˆ)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x â†‘(â†‘Î´ x) âŠ† U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\\nexists a positive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`,\\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\\n  (Î¼ : MeasureTheory.Measure X), MeasureTheory.Measure.InnerRegular Î¼ IsCompact IsClosed\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a `Ïƒ`-compact space, any closed set can be approximated by a compact subset. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `K * V âŠ† U`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\\n  x â‰  y â†’\\n    âˆƒ Uâ‚,\\n      Uâ‚ âˆˆ nhds x âˆ§\\n        âˆƒ Vâ‚,\\n          Vâ‚ âˆˆ nhds x âˆ§\\n            âˆƒ Uâ‚‚,\\n              Uâ‚‚ âˆˆ nhds y âˆ§\\n                âˆƒ Vâ‚‚,\\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `V * K âŠ† U`. \"}]\n",
    "prompt_cons": "/-- For every finite open cover `Uáµ¢` of a compact set, there exists a compact cover `Káµ¢ âŠ† Uáµ¢`. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  IsCompact s â†’\n    âˆ€ {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±),\n      (âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) â†’\n        s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ t), U i â†’\n          âˆƒ K, (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (_ : i âˆˆ t), K i :=\n\n/-- Let `M` be a smooth Ïƒ-compact manifold with a metric. Let `K : Î¹ â†’ Set M` be a locally finite\nfamily of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for all\n`i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and `x âˆˆ K i`,\nwe have `Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type u_1} [inst_4 : MetricSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : Î¹ â†’ Set M},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : M), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : M), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be a metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets, let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there exists a\npositive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`, we have\n`Metric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ Metric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- If `Î¼` is a regular measure, then any open set can be approximated by a compact subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_2 : MeasureTheory.Measure.Regular Î¼] â¦ƒU : Set Î±â¦„,\n  IsOpen U â†’ âˆ€ {r : ENNReal}, r < â†‘â†‘Î¼ U â†’ âˆƒ K, K âŠ† U âˆ§ IsCompact K âˆ§ r < â†‘â†‘Î¼ K :=\n\n/-- Let `M` be a smooth Ïƒ-compact manifold with extended distance. Let `K : Î¹ â†’ Set M` be a locally\nfinite family of closed sets, let `U : Î¹ â†’ Set M` be a family of open sets such that `K i âŠ† U i` for\nall `i`. Then there exists a positive smooth function `Î´ : M â†’ â„â‰¥0` such that for any `i` and\n`x âˆˆ K i`, we have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type u_1} [inst_4 : EMetricSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : Î¹ â†’ Set M},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’\n          âˆƒ Î´, (âˆ€ (x : M), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : M), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i :=\n\n/-- A uniform space with countably generated `ğ“¤ X` is pseudo metrizable. -/\ntheorem âˆ€ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Let `K : Î¹ â†’ Set X` be a locally finite family of closed sets in an emetric space. Let\n`U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then for any point\n`x : X`, for sufficiently small `r : â„â‰¥0âˆ` and for `y` sufficiently close to `x`, for all `i`, if\n`y âˆˆ K i`, then `EMetric.closedBall y r âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’\n          âˆ€ (x : X),\n            âˆ€á¶  (p : ENNReal Ã— X) in nhds 0 Ã—Ë¢ nhds x, âˆ€ (i : Î¹), p.snd âˆˆ K i â†’ EMetric.closedBall p.snd p.fst âŠ† U i :=\n\n/-- Let `M` be a smooth manifold with corners modelled on a finite dimensional real vector space.\nSuppose also that `M` is a Hausdorff `Ïƒ`-compact topological space. Let `s` be a closed set\nin `M` and `U : M â†’ Set M` be a collection of sets such that `U x âˆˆ ğ“ x` for every `x âˆˆ s`.\nThen there exists a smooth bump covering of `s` that is subordinate to `U`. -/\ntheorem âˆ€ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {H : Type uH}\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners â„ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] {s : Set M} {U : M â†’ Set M} [inst_6 : T2Space M] [inst_7 : SigmaCompactSpace M],\n  IsClosed s â†’ (âˆ€ (x : M), x âˆˆ s â†’ U x âˆˆ nhds x) â†’ âˆƒ Î¹ f, SmoothBumpCovering.IsSubordinate f U :=\n\n/-- If `Î¼` is a weakly regular measure, then any open set can be approximated by a closed subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_2 : MeasureTheory.Measure.WeaklyRegular Î¼] â¦ƒU : Set Î±â¦„,\n  IsOpen U â†’ âˆ€ {r : ENNReal}, r < â†‘â†‘Î¼ U â†’ âˆƒ F, F âŠ† U âˆ§ IsClosed F âˆ§ r < â†‘â†‘Î¼ F :=\n\n/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem âˆ€ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (Î¼ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular Î¼ IsClosed IsOpen :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with â‹‚â‚€. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {S : Set (Set Î±)},\n  (âˆ€ (s : Set Î±), s âˆˆ S â†’ IsOpen s) â†’ Set.Countable S â†’ (âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) â†’ Dense (â‹‚â‚€ S) :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (ENNReal.ofReal (Î´ x)) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’\n          âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (ENNReal.ofReal (â†‘Î´ x)) âŠ† U i :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„â‰¥0âˆ)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x (â†‘Î´ x) âŠ† U i :=\n\n/-- Let `X` be an extended metric space. Let `K : Î¹ â†’ Set X` be a locally finite family of closed\nsets, let `U : Î¹ â†’ Set X` be a family of open sets such that `K i âŠ† U i` for all `i`. Then there\nexists a positive continuous function `Î´ : C(X, â„â‰¥0)` such that for any `i` and `x âˆˆ K i`,\nwe have `EMetric.closedBall x (Î´ x) âŠ† U i`. -/\ntheorem âˆ€ {Î¹ : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsClosed (K i)) â†’\n    (âˆ€ (i : Î¹), IsOpen (U i)) â†’\n      (âˆ€ (i : Î¹), K i âŠ† U i) â†’\n        LocallyFinite K â†’ âˆƒ Î´, (âˆ€ (x : X), 0 < â†‘Î´ x) âˆ§ âˆ€ (i : Î¹) (x : X), x âˆˆ K i â†’ EMetric.closedBall x â†‘(â†‘Î´ x) âŠ† U i :=\n\n/-- In a `Ïƒ`-compact space, any closed set can be approximated by a compact subset. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\n  (Î¼ : MeasureTheory.Measure X), MeasureTheory.Measure.InnerRegular Î¼ IsCompact IsClosed :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `K * V âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ K * V âŠ† U :=\n\n/-- Given two points `x â‰  y`, we can find neighbourhoods `x âˆˆ Vâ‚ âŠ† Uâ‚` and `y âˆˆ Vâ‚‚ âŠ† Uâ‚‚`,\nwith the `Vâ‚–` closed and the `Uâ‚–` open, such that the `Uâ‚–` are disjoint. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T3Space Î±] {x y : Î±},\n  x â‰  y â†’\n    âˆƒ Uâ‚,\n      Uâ‚ âˆˆ nhds x âˆ§\n        âˆƒ Vâ‚,\n          Vâ‚ âˆˆ nhds x âˆ§\n            âˆƒ Uâ‚‚,\n              Uâ‚‚ âˆˆ nhds y âˆ§\n                âˆƒ Vâ‚‚,\n                  Vâ‚‚ âˆˆ nhds y âˆ§ IsClosed Vâ‚ âˆ§ IsClosed Vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Disjoint Uâ‚ Uâ‚‚ :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `V * K âŠ† U`. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K â†’ IsOpen U â†’ K âŠ† U â†’ âˆƒ V, V âˆˆ nhds 1 âˆ§ V * K âŠ† U :=\n\n/-- Let `ğ’¯` be the collection of open subsets of a metric space `M`, and `ğ’¦` the collection of closed subsets. Show that there is a bijection from `ğ’¯` onto `ğ’¦`. -/\ntheorem",
    "choices": [
      "âˆ€ {M : Type u_1} [inst : MetricSpace M],\n  âˆƒ (f : Set M â†’ Set M), (âˆ€ (U : Set M), IsOpen U â†’ IsClosed (f U)) âˆ§ (âˆ€ (K : Set M), IsClosed K â†’ IsOpen (f K)) âˆ§\n    (âˆ€ (Uâ‚ Uâ‚‚ : Set M), IsOpen Uâ‚ â†’ IsOpen Uâ‚‚ â†’ f Uâ‚ = f Uâ‚‚ â†’ Uâ‚ = Uâ‚‚) âˆ§\n    (âˆ€ (Kâ‚ Kâ‚‚ : Set M), IsClosed Kâ‚ â†’ IsClosed Kâ‚‚ â†’ f Kâ‚ = f Kâ‚‚ â†’ Kâ‚ = Kâ‚‚) ",
      "âˆ€ {M : Type u_1} [inst : MetricSpace M],\n  âˆƒ (f : Set M â†’ Set M), (âˆ€ U, IsOpen U â†’ IsClosed (f U)) âˆ§ (âˆ€ K, IsClosed K â†’ âˆƒ U, IsOpen U âˆ§ f U = K) âˆ§ (âˆ€ Uâ‚ Uâ‚‚, IsOpen Uâ‚ â†’ IsOpen Uâ‚‚ â†’ f Uâ‚ = f Uâ‚‚ â†’ Uâ‚ = Uâ‚‚) ",
      "âˆ€ {M : Type u_1} [inst : MetricSpace M],\n  âˆƒ (f : {s : Set M // IsOpen s} â‰ƒ {s : Set M // IsClosed s}),\n    âˆ€ (s : {s : Set M // IsOpen s}), IsOpen (f s).val âˆ§ IsClosed (f s).val ",
      "âˆ€ {M : Type u_1} [inst : MetricSpace M],\n  âˆƒ (f : Set (Set M) â†’ Set (Set M)),\n    (âˆ€ (T : Set M), IsOpen T â†’ IsClosed (f T)) âˆ§\n      (âˆ€ (K : Set M), IsClosed K â†’ âˆƒ T, IsOpen T âˆ§ f T = K) âˆ§\n        (âˆ€ (Tâ‚ Tâ‚‚ : Set M), IsOpen Tâ‚ â†’ IsOpen Tâ‚‚ â†’ f Tâ‚ = f Tâ‚‚ â†’ Tâ‚ = Tâ‚‚) ",
      "âˆ€ {M : Type u_1} [inst : MetricSpace M] [inst_1 : MeasurableSpace M] (Î¼ : MeasureTheory.Measure M),\n  (âˆƒ (Î¦ : Set (Set M) â†’ Set (Set M)),\n    (âˆ€ (U : Set M), IsOpen U â†’ IsClosed (Î¦ U)) âˆ§\n      (âˆ€ (U : Set M), IsOpen U â†’ Uá¶œ = Î¦ U) âˆ§\n        (âˆ€ (K : Set M), IsClosed K â†’ Î¦ Ká¶œ = K) âˆ§\n          âˆ€ (Uâ‚ Uâ‚‚ : Set M), IsOpen Uâ‚ â†’ IsOpen Uâ‚‚ â†’ (Uâ‚ = Uâ‚‚ â†” Î¦ Uâ‚ = Î¦ Uâ‚‚)) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (f : Set (Set X)), (âˆ€ (s : Set X), IsOpen s â†’ f s = sá¶œ) âˆ§ (âˆ€ (s : Set X), IsClosed s â†’ f s = sá¶œ) âˆ§\n    âˆ€ (sâ‚ sâ‚‚ : Set X), IsOpen sâ‚ â†’ IsOpen sâ‚‚ â†’ (f sâ‚ = f sâ‚‚ â†’ sâ‚ = sâ‚‚) âˆ§ (f sâ‚á¶œ = f sâ‚‚á¶œ â†’ sâ‚á¶œ = sâ‚‚á¶œ) ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (Ï† : {s // IsOpen s} â‰ƒ {s // IsClosed s}), True ",
      "âˆ€ {M : Type u} [inst : MetricSpace M], âˆƒ (Ïˆ : {U // IsOpen U} â‰ƒ {K // IsClosed K}), True ",
      "âˆ€ {X : Type u_1} [inst : MetricSpace X],\n  âˆƒ (F : Set (Set X) â†’ Set X),\n    (âˆ€ (U : Set X), IsOpen U â†’ IsClosed (F U)) âˆ§\n      (âˆ€ (C : Set X), IsClosed C â†’ âˆƒ U, IsOpen U âˆ§ C = F U) âˆ§\n        (âˆ€ (U1 U2 : Set X), IsOpen U1 â†’ IsOpen U2 â†’ F U1 = F U2 â†’ U1 = U2) ",
      "âˆ€ {M : Type u} [inst : MetricSpace M], âˆƒ (Ïˆ : {U // IsOpen U} â‰ƒ {K // IsClosed K}), true "
    ]
  }
]