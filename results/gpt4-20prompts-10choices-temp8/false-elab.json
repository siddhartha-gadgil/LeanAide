{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures":
 ["Every ring is a field.",
  "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
  "A finitely-presented group containing a torsion element is finite.",
  "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.",
  "The characteristic polynomial of every matrix has real roots.",
  "The number of partitions of a finite set is a prime number.",
  "The automorphism group of an Abelian group is cyclic.",
  "If a module over a ring is free, then the ring is commutative.",
  "Implication `→` is symmetric. If `P → Q` then `Q → P`."],
 "elaborated-prompts":
 [{"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
   "some-correct": null,
   "prompt": "Every vector space is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V ",
    "∀ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V "]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
   "some-correct": null,
   "prompt": "Every group is a torsion monoid.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    " ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p",
   "some-correct": null,
   "prompt": "Every finite simple group has prime order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : IsSimpleGroup G], ∃ p, Nat.Prime p ∧ Fintype.card G = p"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], IsPrimePow (Fintype.card G)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], IsPrimePow (Fintype.card G) ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : IsSimpleGroup G],\n  ∃ p : ℕ, Nat.Prime p ∧ Fintype.card G = p ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
   "some-correct": null,
   "prompt": "Every finite group is simple.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p → IsSimpleGroup G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card G = p → IsSimpleGroup G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p",
   "some-correct": null,
   "prompt": "Every finite group has prime order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p → IsSimpleGroup G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card G = p → IsSimpleGroup G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Nat.Prime p ∧ Fintype.card G = p ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ?m.641938 s = 0",
   "some-correct": null,
   "prompt": "Every set has Lebesgue measure zero.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ?m.641938 s = 0"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s → ?m.560860 μ s = 0"],
    ["∀ {s : Set ℝ}, ?m.641759 = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["forall {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α), MeasurableSet s → ↑↑μ s = 0 ",
    "∀ {s : Set ℝ}, ↑↑MeasureTheory.volume s = 0 ",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ↑↑MeasureTheory.volume s = 0 "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
   "some-correct": null,
   "prompt": "If a topological space is compact, then every subset is compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, x ∈ t ∧ IsClosed t ∧ t ⊆ s) → IsClosed s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ u, IsClosed u ∧ x ∈ u ∧ u ⊆ t) → IsClosed s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x, x ∈ s → ∃ (t : Set α), IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ u, x ∈ u ∧ IsClosed u ∧ u ⊆ t) → IsClosed s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ (t : Set α), x ∈ t ∧ IsClosed t ∧ t ⊆ s) → IsClosed s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ t ∈ t, x ∈ t) → IsClosed t → IsClosed s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1",
   "some-correct": null,
   "prompt": "Any finite order element in a group is equal to the identity.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1",
     "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1"],
    ["∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 → x = 1",
     "∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 ↔ x = 1"],
    ["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
     "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1"],
    ["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, x ^ n = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 → x = 1 ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, x ^ n = 1 ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 ↔ x = 1 ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n : ℕ, x ^ n = 1 ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1 ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1 ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n : ℕ, 0 < n ∧ x ^ n = 1 ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n : ℕ, 0 < n ∧ x ^ n = 1 "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt":
   "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G"],
    ["∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ",
    "∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G "]},
  {"theorem":
   "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f",
   "some-correct": null,
   "prompt":
   "Every injective homomorphism from a finitely generated free group to itself is surjective.",
   "groups":
   [["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f",
     "∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α →* FreeGroup α}, Function.Injective ↑f → Function.Surjective ↑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f"],
    ["∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α → FreeGroup α}, Function.Injective f → Function.Surjective f",
     "∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α → FreeGroup α}, Function.Injective f → Function.Surjective f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α → FreeGroup α), Function.Injective f → Function.Surjective f"],
    ["∀ {ι : Type u_1} [inst : Fintype ι] {f : FreeGroup ι →* FreeGroup ι}, Function.Injective ↑f → Function.Surjective ↑f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α → FreeGroup α},\n  (Function.Injective f) → (Function.Surjective f) ",
    "∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α → FreeGroup α},\n  Function.Injective f → Function.Surjective f ",
    "∀ {ι : Type u_1} [inst : Fintype ι] {f : FreeGroup ι →* FreeGroup ι},\n  Function.Injective ↑f → Function.Surjective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α →* FreeGroup α}, Function.Injective ↑f → Function.Surjective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α → FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f "]},
  {"theorem": "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K",
   "some-correct": null,
   "prompt": "Every division ring is either a field or finite.",
   "groups":
   [["∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K",
     "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K",
     "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K"],
    ["∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Nonempty (Fintype K)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K ",
    "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K ",
    "∀ (K : Type u_1) [inst : DivisionRing K], (IsField K) ∨ Finite K ",
    "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Nonempty (Fintype K) "]},
  {"theorem": "∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
   "some-correct": null,
   "prompt": "Every natural number is the product of two primes.",
   "groups":
   [["∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"],
    ["∀ (n : ℕ), n > 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), n > 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"],
    ["∀ (n : ℕ), n ≠ 0 → n ≠ 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), n ≠ 0 → n ≠ 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ",
    "∀ (n : ℕ), n ≠ 0 → n ≠ 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ",
    "∀ (n : ℕ), n ≠ 0 → n ≠ 1 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ",
    "∀ (n : ℕ), n > 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ",
    "∀ (n : ℕ), n > 1 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ",
    "∀ (n : ℕ), n ≠ 0 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ",
    "∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ",
    "∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ",
    "∀ (n : ℕ), n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ",
    "∀ (n : ℕ), n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q "]},
  {"theorem": "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2",
   "some-correct": null,
   "prompt": "Every even number is the square of a natural number.",
   "groups":
   [["∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2",
     "∀ {n : ℕ}, Even n → ∃ a, n = a ^ 2",
     "∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2",
     "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2",
     "∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2",
     "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2",
     "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2",
     "∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2"],
    ["∀ {n : ℕ}, Even n → ∃ x, n = 2 * x ^ 2",
     "∀ {n : ℕ}, Even n → ∃ k, n = 2 * k ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ",
    "∀ {n : ℕ}, Even n → ∃ a, n = a ^ 2 ",
    "∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2 ",
    "∀ {n : ℕ}, Even n → ∃ x, n = 2 * x ^ 2 ",
    "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ",
    "∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2 ",
    "∀ {n : ℕ}, Even n → ∃ k, n = 2 * k ^ 2 ",
    "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ",
    "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ",
    "∀ {n : ℕ}, Even n → ∃ x : ℕ, n = x ^ 2 "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0",
   "some-correct": null,
   "prompt": "Every normal subgroup of a group has finite index.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0",
     "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [self : Subgroup.Normal N], Subgroup.index N ≠ 0",
     "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.index N ≠ 0",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0"],
    ["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.Normal H → Subgroup.FiniteIndex H",
     "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N], Subgroup.FiniteIndex N"],
    ["∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N],\n  Subgroup.FiniteIndex N → Subgroup.index N ≠ 0"],
    ["{G : Type u_1} →\n  [inst : Group G] → (H : Subgroup G) → [inst_1 : Subgroup.Normal H] → Subgroup.FiniteIndex H → Fintype (G ⧸ H)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H → Fintype (G ⧸ H) ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.Normal H → Subgroup.FiniteIndex H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 ",
    "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [self : Subgroup.Normal N], Subgroup.index N ≠ 0 ",
    "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.index N ≠ 0 ",
    "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N], Subgroup.FiniteIndex N ",
    "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N], Subgroup.FiniteIndex N → Subgroup.index N ≠ 0 ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 "]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
   "some-correct": null,
   "prompt":
   "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
     "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
     "∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
     "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
     "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
     "∀ {R : Type u} [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
     "∀ (R : Type u) [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
     "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
     "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M"],
    ["∀ {R : Type u} [inst : CommRing R] [hR : Nontrivial R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M ",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P],\n  ∃! M, Ideal.IsMaximal M ∧ P ≤ M ",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ",
    "∀ {R : Type u} [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ",
    "∀ (R : Type u) [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ",
    "∀ {R : Type u} [inst : CommRing R] [hR : Nontrivial R] (P : Ideal R), Ideal.IsPrime P → ∃! (M : Submodule R R), Ideal.IsMaximal M ∧ P ≤ M "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["forall {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f ",
    "forall {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  (f : α → β), Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f "]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f)",
   "some-correct": null,
   "prompt": "Every uniformly continuous function is bounded above.",
   "groups":
   [["∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f)",
     "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f)",
     "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f)"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ",
    "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ",
    "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
   "some-correct": null,
   "prompt":
   "If every compact subset of a topological space is closed, then the space is compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α],\n  (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α],\n  (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α "]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y)",
   "some-correct": null,
   "prompt":
   "In a commutative ring, the sum of idempotent elements is idempotent.",
   "groups":
   [["∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y)",
     "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {R : Type u_1} [inst : CommRing R] {a b : R}, IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {R : Type u_1} [self : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {R : Type u_1} [inst : CommRing R] (e₁ e₂ : R), IsIdempotentElem e₁ → IsIdempotentElem e₂ → IsIdempotentElem (e₁ + e₂)",
     "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)"],
    ["∀ {R : Type u_1} [inst : CommRing R] (x y : R),\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)",
     "∀ {R : Type u_1} [inst : CommRing R] (x y : R),\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y) ",
    "∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y) ",
    "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
    "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
    "∀ {R : Type u_1} [inst : CommRing R] {a b : R},\n  IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
    "∀ {R : Type u_1} [self : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
    "∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y) ",
    "∀ {R : Type u_1} [inst : CommRing R] (e₁ e₂ : R), IsIdempotentElem e₁ → IsIdempotentElem e₂ → IsIdempotentElem (e₁ + e₂) ",
    "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
    "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α], ∃! m, ∀ (a : α), a ≤ m",
   "some-correct": null,
   "prompt":
   "If a poset has a maximal element, then it has a unique minimal element.",
   "groups":
   [["∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α], ∃! m, ∀ (a : α), a ≤ m",
     "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α], ∃! m, ∀ (a : α), a ≤ m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : Nonempty α] (H : ∃ x, ∀ y, y ≤ x),\n  ∃! x, ∀ y, x ≤ y ",
    "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α],\n  ∃! m, ∀ (a : α), a ≤ m ",
    "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α],\n  ∃! m : α, ∀ (a : α), a ≤ m ",
    "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α], (∃ a, ∀ b, a ≤ b) → ∃! a, ∀ b, b ≤ a "]},
  {"theorem":
   "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
   "groups":
   [["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y",
     "∀ {α : Type u_1} {f : α → α} {x : α} {n : ℕ}, Function.IsFixedPt f x → 0 < n → ∃ y, Function.IsPeriodicPt f n y"],
    ["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x",
     "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x"],
    ["∀ {α : Type u_1} {f : α → α} [inst : LinearOrderedField α] {x : α},\n  Function.IsFixedPt f x → 0 < x → x < 1 → ∀ (n : ℕ), ∃ y, Function.IsPeriodicPt f n y ∧ 0 < y ∧ y < 1"],
    ["∀ {α : Type u_1} {f : α → α} {a b : α} [inst : LinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderClosedTopology α],\n  a ≤ b →\n    a ≤ f a ∧ f a ≤ b ∨ a ≤ f b ∧ f b ≤ b → ∀ (n : ℕ), 0 < n → Function.IsPeriodicPt f n a ∨ Function.IsPeriodicPt f n b"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x ",
    "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ (y : α), Function.IsPeriodicPt f n y ",
    "∀ {α : Type u_1} {f : α → α} {a b : α} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  (hab : a ≤ b) (hf : a ≤ f a ∧ f a ≤ b ∨ a ≤ f b ∧ f b ≤ b),\n  (∀ (n : ℕ), 0 < n → Function.IsPeriodicPt f n a ∨ Function.IsPeriodicPt f n b) ",
    "∀ {α : Type u_1} {f : α → α} {x : α} {n : ℕ},\n  Function.IsFixedPt f x → 0 < n → ∃ y, Function.IsPeriodicPt f n y ",
    "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x ",
    "∀ {α : Type u_1} {f : α → α} [inst : LinearOrderedField α] {x : α},\n  Function.IsFixedPt f x → 0 < x → x < 1 → ∀ (n : ℕ), ∃ y, Function.IsPeriodicPt f n y ∧ 0 < y ∧ y < 1 "]},
  {"theorem": "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets contains the union of their complements.",
   "groups":
   [["∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ",
     "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ",
     "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ ⊆ (s ∪ t)ᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ"],
    ["∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∪ Bᶜ",
     "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∪ Bᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ"],
    ["∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ ",
    "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ ⊆ (s ∪ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∪ Bᶜ ",
    "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∪ Bᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ "]},
  {"theorem": "∀ (q : ℚ), ∃ x, x * x = q",
   "some-correct": null,
   "prompt": "The square root of an rational number is rational.",
   "groups":
   [["∀ (q : ℚ), ∃ x, x * x = q",
     "∀ (q : ℚ), ∃ r, r * r = q",
     "∀ (q : ℚ), ∃ r, r * r = q",
     "∀ (q : ℚ), ∃ r, r * r = q",
     "∀ (q : ℚ), ∃ r, r * r = q"],
    ["∀ (q : ℚ), ∃ r, Real.sqrt ↑q = r",
     "∀ (q : ℚ), ∃ r, Real.sqrt ↑q = r",
     "∀ (q : ℚ), ∃ r, Real.sqrt ↑q = r",
     "∀ (q : ℚ), ∃ r, Real.sqrt ↑q = r",
     "∀ (q : ℚ), ∃ r, Real.sqrt ↑q = r"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (q : ℚ), ∃ r, Real.sqrt ↑q = ↑r ",
    "∀ (q : ℚ), ∃ r, Real.sqrt ↑q = ↑r ",
    "∀ (q : ℚ), ∃ x, x * x = q ",
    "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
    "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
    "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
    "∀ (q : ℚ), ∃ r, Real.sqrt q = ↑r ",
    "∀ (q : ℚ), ∃ r, Real.sqrt q = r ",
    "∀ (q : ℚ), ∃ r : ℚ, r * r = q ",
    "∀ (q : ℚ), ∃ r, Real.sqrt ↑q = ↑r "]},
  {"theorem":
   "∀ {R : Type u_1} [inst : Ring R], (∀ (a b : R), IsUnit a → IsUnit b → IsUnit (a * b)) → ∀ (x y : R), x * y = y * x",
   "some-correct": null,
   "prompt":
   "If the set of units of a ring forms a group then the ring is commutative.",
   "groups":
   [["∀ {R : Type u_1} [inst : Ring R], (∀ (a b : R), IsUnit a → IsUnit b → IsUnit (a * b)) → ∀ (x y : R), x * y = y * x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : Ring R], (∀ a b : R, IsUnit a → IsUnit b → IsUnit (a * b)) → ∀ (x y : R), x * y = y * x "]},
  {"theorem": "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
   "some-correct": null,
   "prompt":
   "Every natural number larger than `10` is the sum of a square and a prime.",
   "groups":
   [["∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
     "∀ (n : ℕ), 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
     "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
     "∀ (n : ℕ), 10 < n → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y",
     "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
     "∀ {n : ℕ}, 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
     "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
     "∀ (n : ℕ), 10 < n → ∃ a p, n = a ^ 2 + p ∧ Nat.Prime p"],
    ["∀ (n : ℕ), 10 < n → ∃ p x, Nat.Prime p ∧ n = x ^ 2 + p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
    "∀ (n : ℕ), 10 < n → ∃ x y p, n = x ^ 2 + p ∧ Nat.Prime p ",
    "∀ (n : ℕ), 10 < n → ∃ p x, Nat.Prime p ∧ n = x ^ 2 + p ",
    "∀ (n : ℕ), 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
    "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
    "∀ (n : ℕ), 10 < n → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ",
    "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
    "∀ {n : ℕ}, 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
    "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ",
    "∀ (n : ℕ), 10 < n → ∃ a p, n = a ^ 2 + p ∧ Nat.Prime p "]},
  {"theorem":
   "∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12642836, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C)",
   "some-correct": null,
   "prompt":
   "The initial object of a category is isomorphic to its terminal object.",
   "groups":
   [["∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12642836, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C)",
     "∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12643339, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C)",
     "∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12643339, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C)",
     "∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12643339, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C)",
     "∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12642836, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C)"],
    ["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.13151040, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasInitial C] → [inst_2 : CategoryTheory.Limits.HasTerminal C] → ⊥_ C ≅ ⊤_ C"],
    ["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.13150538, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasInitial C] → [inst_2 : CategoryTheory.Limits.HasTerminal C] → ⊥_ C ≅ ⊤_ C"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  ⊥_ C ≅ ⊤_ C ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.initial C ≅ CategoryTheory.Limits.terminal C ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g",
   "some-correct": null,
   "prompt":
   "If the composition of two functions is continuous, then each of them is continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g"],
    ["∀ {α : Type u_3} {β : Type u_1} {γ : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {g : β → γ} {f : α → β}, Continuous (g ∘ f) → Continuous f → Continuous g"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ}, h = g ∘ f → Continuous h → Continuous f → Continuous g ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ} {h : α → γ}, h = g ∘ f → Continuous h → Continuous f → Continuous g ",
    "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ} {h : α → γ}, h = (g ∘ f) → Continuous h → Continuous f → Continuous g ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ},\n  Continuous (g ∘ f) → Continuous f → Continuous g ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ} {h : α → γ}, h = (g ∘ f) → Continuous h → Continuous f → Continuous g ",
    "∀ {α : Type u_3} {β : Type u_1} {γ : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {g : β → γ} {f : α → β},\n  Continuous (g ∘ f) → Continuous f → Continuous g "]},
  {"theorem":
   "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
   "some-correct": null,
   "prompt":
   "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
   "groups":
   [["∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0",
   "some-correct": null,
   "prompt":
   "If an element maps to zero under a ring homomorphism, then it is zero.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0",
     "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0",
     "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0",
     "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0",
     "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0"],
    ["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, ?m.13802177 = 0 → r = 0"],
    ["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, ?m.13800141 = 0 → r ∈ RingHom.ker f"],
    ["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} (x : R), ?m.13798522 x = 0 → x = 0"],
    ["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} (r : R), ?m.13801159 r = 0 → r = 0"],
    ["∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R →+* S) (a : R),\n  ?m.13801516 f a = 0 → a = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} (x : R), ↑f x = 0 → x = 0 ",
    "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, ↑f r = 0 → r ∈ RingHom.ker f ",
    "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ",
    "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ",
    "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} (r : R), (↑f r = 0) → r = 0 ",
    "∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R →+* S) (a : R),\n  ↑f a = 0 → a = 0 ",
    "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ",
    "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, ↑f r = 0 → r = 0 ",
    "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ",
    "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 "]},
  {"theorem": "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
   "some-correct": null,
   "prompt":
   "Two natural numbers are equal if and only if they are both divisible by some prime number.",
   "groups":
   [["∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n"],
    ["∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ (p ∣ m ↔ p ∣ n)) ↔ m = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ (p ∣ m ↔ p ∣ n)) ↔ m = n ",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n "]}],
 "elaborated": 31}