Writing to file: thm-elab-12-8-false-20-8.json

If every proper closed set of a topological space is compact, then the space itself is compact.

success

theorem ∀ {X : Type u_1} [inst : TopologicalSpace X], (∀ (S : Set X), IsClosed S → IsCompact S) → CompactSpace X

total : 1

elaborated: 1

Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x * x + y * y = p

total : 2

elaborated: 2

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

success

theorem ∀ {x y : ℤ},
  (∃ x1 x2 x3 x4 y1 y2 y3 y4, x = x1 ^ 2 + x2 ^ 2 + x3 ^ 2 + x4 ^ 2 ∧ y = y1 ^ 2 + y2 ^ 2 + y3 ^ 2 + y4 ^ 2) →
    ∃ x1 x2 x3 x4, x * y = x1 ^ 2 + x2 ^ 2 + x3 ^ 2 + x4 ^ 2

total : 3

elaborated: 3

A ring with all elements idempotent is commutative.

success

theorem ∀ {α : Type u} [inst : Ring α] {a : α}, a ^ 2 = a → ∀ (b : α), Commute a b

total : 4

elaborated: 4

There are infinitely many pairs of primes that differ exactly by `2`.

success

theorem ℕ → ∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ b = a + 2

total : 5

elaborated: 5

Every finite division ring is a field.

success

theorem ∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K

total : 6

elaborated: 6

If each of two types can be mapped injectively into the other, then there is a bijection between them.

success

theorem ∀ {α : Type u} {β : Type v} [inst : Nonempty α] [inst : Nonempty β],
  (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → ∃ h, Function.bijective h

total : 7

elaborated: 7

A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.

Writing to file: false-elab-12-8-false-20-8.json

Every ring is a field.

success

theorem ∀ (R : Type u) [inst : Ringₓ R], IsField R

total : 1

elaborated: 1

Every vector space is finite dimensional.

success

theorem ∀ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  FiniteDimensional K V

total : 2

elaborated: 2

Every group is a torsion monoid.

success

theorem ∀ {G : Type u_1} [inst : Groupₓ G], Monoidₓ.IsTorsion G

total : 3

elaborated: 3

Every finite simple group has prime order.

success

theorem ∀ {G : Type u} [inst : Fintype G] [inst_1 : Groupₓ G], IsSimpleGroup G → IsPrimePow (Fintype.card G)

total : 4

elaborated: 4

Every finite group is simple.

success

theorem ∀ {G : Type u} [inst : Groupₓ G] [inst_1 : Fintype G], IsSimpleGroup G

total : 5

elaborated: 5

Every finite group has prime order.

success

theorem ∀ {G : Type u} [inst : Group G] [inst : Fintype G], IsPrimePow (Fintype.card G)

total : 6

elaborated: 6

Every set has Lebesgue measure zero.

success

theorem ∀ {α : Type u_1} {m : MeasureTheory.MeasureSpace α} (s : Set α), coeFn MeasureTheory.volume.toOuterMeasure s = 0

total : 7

elaborated: 7

If a topological space is compact, then every subset is compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α], CompactSpace α → ∀ {s : Set α}, IsCompact s

total : 8

elaborated: 8

Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  measure_theory.measurable  s ) ->  (  hb :  ¬  borel  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  measure_theory.measurable  s ) ->  (  hb :  ¬  borelₓ  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  measure_theory.measurable  s ) ->  (  hb :  ¬  borel  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  measure_theory.measurable  s ) ->  (  hb :  ¬  borelₓ  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :  MeasurableSet  s ) ->  (  hn :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :  MeasurableSet  s ) ->  (  hn :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :   MeasurableSet  s ∧  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :   MeasurableSet  s ∧  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  (  hs :  MeasurableSet  s ) ->  (  hn :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  (  hs :  MeasurableSet  s ) ->  (  hn :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   MeasurableSet  s ∧  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   MeasurableSet  s ∧  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

: true → (∀ {A : set ℝ}, measurable_iff_lebesgue.1 A.is_measurable ∧ ¬borel_measurable A → measure_theory.measure_space.volume A = 0) 

 (   ∀   (  s  :  Set    ℝ  ℝ  )  ,   (    MeasurableSet  s ∧  s ∉  borel_measurable_sets    ℝ  ℝ  ) →  (    ⇑   MeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  sMeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  s =  0  )  )

 (   ∀   (  s  :  Setₓ    ℝ  ℝ  )  ,   (    MeasurableSet  s ∧  s ∉  borel_measurable_sets    ℝ  ℝ  ) →  (    ⇑   MeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  sMeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  s =  0  )  )

 ∀   (  s  :  Set    ℝ  ℝ  )  ,    measure_theory.measurable  s ∧  ¬  measure_theory.measurable_set  s →   MeasureTheory.MeasureSpace.volume  s =  0

 ∀   (  s  :  Setₓ    ℝ  ℝ  )  ,    measure_theory.measurable  s ∧  ¬  measure_theory.measurable_set  s →   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   measure_theory.measure.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   measure_theory.measure.volume  s =  0

 {  α :  Type  u_1 } ->  (  s :  Set  α ) ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :   MeasurableSet  s ∧  ¬  (   borel_measurable_set  s  ) ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  (  s :  Setₓ  α ) ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :   MeasurableSet  s ∧  ¬  (   borel_measurable_set  s  ) ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 (  γ :  Type  u_3 ) ->  (  s :  Set  γ ) ->  [  MeasurableSpace  γ ] ->  [  BorelSpace  γ ] ->  (  hs :  Borel_measure_theory.is_measurable  s ) ->  (  hns :  ¬  Borel_measurable  s ) ->   volume  s =  0

 (  γ :  Type  u_3 ) ->  (  s :  Setₓ  γ ) ->  [  MeasurableSpace  γ ] ->  [  BorelSpace  γ ] ->  (  hs :  Borel_measure_theory.is_measurable  s ) ->  (  hns :  ¬  Borel_measurable  s ) ->   volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  TopologicalSpace  α ] ->  [  topological_space.t2_space  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  hns :  ¬  borel_measurable  s ) ->   (   MeasureTheory.Measure  s  ) =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  TopologicalSpace  α ] ->  [  topological_space.t2_space  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  hns :  ¬  borel_measurable  s ) ->   (   MeasureTheory.Measure  s  ) =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  {  ν :  MeasureTheory.Measure  α } ->  [  MeasureTheory.SigmaFinite  ν ] ->  [  BorelSpace  α ] ->  (  h :  MeasurableSet  s ) ->  (  h' :  ¬  borel_measurable  s ) ->   ν  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  {  ν :  MeasureTheory.Measure  α } ->  [  MeasureTheory.SigmaFinite  ν ] ->  [  BorelSpace  α ] ->  (  h :  MeasurableSet  s ) ->  (  h' :  ¬  borel_measurable  s ) ->   ν  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  (  s :  Set  α ) ->  [  BorelSpace  α ] ->  (  m₁ :  MeasurableSet  s ) ->  (  m₂ :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  (  s :  Setₓ  α ) ->  [  BorelSpace  α ] ->  (  m₁ :  MeasurableSet  s ) ->  (  m₂ :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->   MeasurableSet  s →   ¬  borel_measurable  s →   volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->   MeasurableSet  s →   ¬  borel_measurable  s →   volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  Measurable  s ) ->  (  h :  ¬  MeasurableSet  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  Measurable  s ) ->  (  h :  ¬  MeasurableSet  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  hb :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  hb :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  {  m :  measure  α } ->  [  MeasureTheory.SigmaFinite  m ] ->  (  hs :  MeasurableSet  s ) ->  (  hB :  ¬  MeasurableSet  s ) ->   m  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  {  m :  measure  α } ->  [  MeasureTheory.SigmaFinite  m ] ->  (  hs :  MeasurableSet  s ) ->  (  hB :  ¬  MeasurableSet  s ) ->   m  s =  0

failed to elaborate

outputs: #[{α : Type u_1} {s : set α} [measurable_space α] [borel_space α] (hs : measure_theory.measurable s) (hb : ¬borel s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] (h : measurable_set s) (hn : ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] (hs : measurable_set s ∧ ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (h : ¬borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {s : set α} {m : measurable_space α} [borel_space α] (hs : measurable_set s) (hn : ¬borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (h : ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (h : measurable_set s ∧ ¬borel_measurable s) : measure_theory.measure_space.volume s = 0 , : true → (∀ {A : set ℝ}, measurable_iff_lebesgue.1 A.is_measurable ∧ ¬borel_measurable A → measure_theory.measure_space.volume A = 0) , : (∀ (s : set ℝ), (measurable_set s ∧ s ∉ borel_measurable_sets ℝ) → (⇑measure_theory.measure_space.volume s = 0)) ,  : ∀ (s : set ℝ),  measure_theory.measurable s ∧ ¬measure_theory.measurable_set s → measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (h : ¬ borel_measurable s) : measure_theory.measure.volume s = 0 , {α : Type u_1} (s : set α) [measurable_space α] [borel_space α] (h : measurable_set s ∧ ¬(borel_measurable_set s)) : measure_theory.measure_space.volume s = 0 ,  (γ : Type u_3) (s : set γ) [measurable_space γ] [borel_space γ] (hs : Borel_measure_theory.is_measurable s) (hns : ¬ Borel_measurable s) : volume s = 0 , {α : Type u_1} {m : measurable_space α} [topological_space α] [topological_space.t2_space α] [borel_space α] {s : set α} (hs : measurable_set s) (hns : ¬ borel_measurable s) : (measure_theory.measure s) = 0 , {α : Type u_1} {s : set α} [measurable_space α] {ν : measure_theory.measure α} [measure_theory.sigma_finite ν] [borel_space α] (h : measurable_set s) (h' : ¬ borel_measurable s) : ν s = 0 , {α : Type u_1} {m : measurable_space α} (s : set α) [borel_space α] (m₁ : measurable_set s) (m₂ : ¬borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] : measurable_set s → ¬ borel_measurable s → volume s = 0 , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] (hs : measurable s) (h : ¬ measurable_set s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (hb : ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {s : set α} [measurable_space α] {m : measure α} [measure_theory.sigma_finite m] (hs : measurable_set s) (hB : ¬ measurable_set s) : m s = 0 ]

total : 9

elaborated: 8

A finitely-presented group containing a torsion element is finite.

success

theorem ∀ {G : Type u} [inst : Groupₓ G] [inst_1 : Fintype G], Groupₓ.Fg G → ∃ a, a ≠ 1 ∧ IsOfFinOrder a → Monoidₓ.IsTorsion G

total : 10

elaborated: 9

If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},
  (∀ (x : α), x ∈ s → ∃ t, t ⊂ s ∧ IsClosed t ∧ x ∈ t) → IsClosed s

total : 11

elaborated: 10

A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.

success

theorem ∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)

total : 12

elaborated: 11

Any finite order element in a group is equal to the identity.

success

theorem ∀ {G : Type u} [inst : Monoidₓ G] {x : G} [inst_1 : Fintype G], IsOfFinOrder x → x = 1

total : 13

elaborated: 12

If a subgroup of a group is torsion-free, then the group itself is torsion free.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Set  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Setₓ  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Set  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Setₓ  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Set  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Setₓ  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u } ->  [  Group  G ] ->  {  H :  Set  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 {  G :  Type  u } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 (  H :  Type  u_1 ) ->  [  Group  H ] ->  (  G :  Type  u_2 ) ->  [  Group  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Group  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Group  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Group  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Group  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Set  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Setₓ  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Set  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Setₓ  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Set  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Setₓ  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Set  G } ->  [  Group  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Set  G } ->  [  Groupₓ  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Set  G } ->  [  Groupₓₓ  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Setₓ  G } ->  [  Group  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Setₓ  G } ->  [  Groupₓ  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Setₓ  G } ->  [  Groupₓₓ  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Set  G } ->  [  Group  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Set  G } ->  [  Groupₓ  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Set  G } ->  [  Groupₓₓ  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Setₓ  G } ->  [  Group  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Setₓ  G } ->  [  Groupₓ  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Setₓ  G } ->  [  Groupₓₓ  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Group  G ] ->  [  Group  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Group  G ] ->  [  Groupₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Group  G ] ->  [  Groupₓₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [  Group  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [  Groupₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [  Groupₓₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [  Group  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [  Groupₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [  Groupₓₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Set  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Setₓ  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Set  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Set  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  {  H :  Set  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  {  H :  Setₓ  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  {  H :  Set  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  {  H :  Setₓ  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  {  H :  Set  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

failed to elaborate

outputs: #[{G : Type u_1} [group G] (H : subgroup G) (torsion_free_H : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] (H : subgroup G) (h : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] {H : set G} [is_subgroup H] (h : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] {H : set G} [is_subgroup H] (hN : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] [hN : nontrivial G] {S : set G} : is_subgroup S → monoid.is_torsion_free S → monoid.is_torsion_free G , {G : Type u_1} [group G] {H : set G} (hH : normal subgroup.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u} [group G] {H : set G} (hH : H ⊆ torsion_free G) : torsion_free G = G , (H : Type u_1) [group H] (G : Type u_2) [group G] [hG : group.is_torsion_free (G ⊓ H)]: group.is_torsion_free G , {G : Type u_1} [group G] {N : set G} (h : is_subgroup N) (ntf : monoid.is_torsion_free N) : monoid.is_torsion_free G , {G : Type u_1} {S : set G} [group G] (H : is_subgroup S) (hf : monoid.is_torsion_free S) : monoid.is_torsion_free G , {G : Type u_1} {H : set G} [group G] (H_torsion_free : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} (H : Type u_2) [group G] [group H] [hS : is_subgroup H] (Htf : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [hG:group G] {H : set G} (hH : is_subgroup H) (hFT : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [hG : group G] [hN : nontrivial G] {H : set G} (hH : is_subgroup H) (tH : monoid.is_torsion_free H) (N : H ≠ ∅) : monoid.is_torsion_free G , {G : Type u_1} [hG : group G] {H : set G} [hH : is_subgroup H] : monoid.is_torsion_free H → monoid.is_torsion_free G , {G : Type u_1} [group G] {H : set G} [is_subgroup H] (torsion_free_H : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [comm_group G] {H : set G} (h : H ⊆ G) (Ht : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [hG : group G] {H : set G} (hH : is_subgroup H) (hHF : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] (H : subgroup G) (hH : monoid.is_torsion_free H) : monoid.is_torsion_free G ]

total : 14

elaborated: 12

Every injective homomorphism from a finitely generated free group to itself is surjective.

success

theorem ∀ {n : ℕ} {α : Type u} [inst : Fintype α] [inst : DecidableEq α] {f : FreeGroup α → FreeGroup α},
  Function.Injective f → Function.Surjective f

total : 15

elaborated: 13

Every division ring is either a field or finite.

success

theorem ∀ (K : Type u) [inst : DivisionRing K], IsField K ∨ Finite K

total : 16

elaborated: 14

Every natural number is the product of two primes.

success

theorem ∀ {n : ℕ}, n ≠ 0 → ∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ n = a * b

total : 17

elaborated: 15

Every even number is the square of a natural number.

success

theorem ∀ (n : ℕ), n % 2 = 0 → ∃ m, n = m ^ 2

total : 18

elaborated: 16

Every normal subgroup of a group has finite index.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   subgroup.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   subgroup.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   subgroup.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   subgroup.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   subgroup.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   subgroup.quotient  G N  )

 {  G :  Type  u } ->  [  Group  G ] ->  {  U :  Subgroup  G } ->  [ U.normal ] ->  U.index ∈  Fintype.card  G.carrier_type

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  U :  Subgroup  G } ->  [ U.normal ] ->  U.index ∈  Fintype.card  G.carrier_type

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  U :  Subgroup  G } ->  [ U.normal ] ->  U.index ∈  Fintype.card  G.carrier_type

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintype   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintypeₓ   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintype   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintypeₓ   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintype   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintypeₓ   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     n  :  ℕ ,  N.index = n

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     n  :  ℕ ,  N.index = n

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     n  :  ℕ ,  N.index = n

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->   Fintype.card  G ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->   Fintype.card  G ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->   Fintype.card  G ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->   (  N.index   :  ℕ ) ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->   (  N.index   :  ℕ ) ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->   (  N.index   :  ℕ ) ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  [ H.normal ] ->   Fintype.card  H.quotient = H.index

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  [ H.normal ] ->   Fintype.card  H.quotient = H.index

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  [ H.normal ] ->   Fintype.card  H.quotient = H.index

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintype  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintypeₓ  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintype  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintypeₓ  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintype  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintypeₓ  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  hN :  N ≠  ⊥ ) ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  hN :  N ≠  ⊥ ) ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  hN :  N ≠  ⊥ ) ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->   0 < H.index

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->   0 < H.index

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->   0 < H.index

{G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype ∥N.quotient : G / N∥ 

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     m  :  ℕ ,  ∀  g   : G ,   m * g ∈ N

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     m  :  ℕ ,  ∀  g   : G ,   m * g ∈ N

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     m  :  ℕ ,  ∀  g   : G ,   m * g ∈ N

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ hN : N.normal ] ->  ∃    (   d :  ℕ ) ,  N.index = d

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ hN : N.normal ] ->  ∃    (   d :  ℕ ) ,  N.index = d

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ hN : N.normal ] ->  ∃    (   d :  ℕ ) ,  N.index = d

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N  )

failed to elaborate

outputs: #[{G : Type u_1} [group G] {H : subgroup G} [H.normal] : fintype G , {G : Type u_1} [hG : group G] {N : subgroup G} [N.normal] : fintype (quotient_group.quotient N.normalizer) , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (subgroup.quotient G N) , {G : Type u} [group G] {U : subgroup G} [U.normal] : U.index ∈ fintype.card G.carrier_type , {G : Type u_1} [group G] {N : subgroup G} [N.normal] (h : group.fintype G) : fintype ↥(N.normalizer / N) , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : ∃ n : ℕ, N.index = n , {G : Type u_1} [group G] (N : subgroup G) [N.normal] : fintype.card G ≠ 0 , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : (N.index : ℕ) ≠ 0 , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (quotient_group.quotient (↑N)) , {G : Type u_1} [group G] (H : subgroup G) [H.normal] : fintype.card H.quotient = H.index , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : ∃ (s : fintype N), s.card * s.card = card G , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype N.coset_stabilizer.fixed_points , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (G / (N : set G)) , {G : Type u_1} [group G] {N : subgroup G} [N.normal] (hN : N ≠ ⊥) : N.index ≠ 0 , {G : Type u_1} [group G] {H : subgroup G} [H.normal] : 0 < H.index , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype ∥N.quotient : G / N∥ , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : ∃ m : ℕ, ∀ g : G, m * g ∈ N , {G : Type u_1} [group G] {N : subgroup G} [hN : N.normal] : ∃ (d : ℕ), N.index = d , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype G , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (quotient N) ]

total : 19

elaborated: 16

The characteristic polynomial of every matrix has real roots.

No valid output from Codex; outputs below

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  CommRing  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓ  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓₓ  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  CommRing  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓ  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓₓ  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

{n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [integral_domain R] (M : matrix n n R) : ∀ r ∈ M.charpoly.roots.to_finset.sort (by apply_instance), r ∈ M.charpoly.roots_over ℝ 

 {  α :  Type  u } ->  [  CommRing  α ] ->  (  M :  Matrix   ℕ  ℕ α ) ->  ∀   (  x  :  ℂ  )  ,   polynomial.eval₂  complex.conj x M.charpoly =  polynomial.eval₂  complex.conj x.conj M.charpoly

 {  α :  Type  u } ->  [  CommRingₓ  α ] ->  (  M :  Matrix   ℕ  ℕ α ) ->  ∀   (  x  :  ℂ  )  ,   polynomial.eval₂  complex.conj x M.charpoly =  polynomial.eval₂  complex.conj x.conj M.charpoly

 {  α :  Type  u } ->  [  CommRingₓₓ  α ] ->  (  M :  Matrix   ℕ  ℕ α ) ->  ∀   (  x  :  ℂ  )  ,   polynomial.eval₂  complex.conj x M.charpoly =  polynomial.eval₂  complex.conj x.conj M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  [  CommRing   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  [  CommRingₓ   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  [  CommRingₓₓ   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  [  CommRing   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  [  CommRingₓ   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  [  CommRingₓₓ   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  Field  R ] ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  A :  Matrix  n n R ) ->  ∀  x   : R ,    A.charpoly.eval  x =  0 →  x ∈   ℝ  ℝ

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  Field  R ] ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  A :  Matrix  n n R ) ->  ∀  x   : R ,    A.charpoly.eval  x =  0 →  x ∈   ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  discrete_field  R ] ->  {  M :  Matrix  n n R } ->  ∀   (  r  : R  )  ,   r.is_root_of   (  M.charpoly  ) →  r ∈   ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  discrete_field  R ] ->  {  M :  Matrix  n n R } ->  ∀   (  r  : R  )  ,   r.is_root_of   (  M.charpoly  ) →  r ∈   ℝ  ℝ

 (  R :  Type  u ) ->  [  CommRing  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 (  R :  Type  u ) ->  [  CommRing  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v_1 } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->     (  M.charpoly  ) . aeval    ℝ  ℝ =  0

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v_1 } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->     (  M.charpoly  ) . aeval    ℝ  ℝ =  0

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->  ∀  x   : R ,    M.charpoly.eval  x =  0 →  x ∈   @ polynomial.roots  R  _  (   polynomial.roots_to_polynomial  M.charpoly  )

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->  ∀  x   : R ,    M.charpoly.eval  x =  0 →  x ∈   @ polynomial.roots  R  _  (   polynomial.roots_to_polynomial  M.charpoly  )

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  {  K :  Type  u_2 } ->  [  Field  K ] ->  (  M :  Matrix  n n K ) ->    (   M.charpoly.root_set   ℂ  ) . to_finset.card =  0

 {  n :  Type  u_1 } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  {  K :  Type  u_2 } ->  [  Field  K ] ->  (  M :  Matrix  n n K ) ->    (   M.charpoly.root_set   ℂ  ) . to_finset.card =  0

 {  R :  Type* } ->  [  CommRing  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  R :  Type* } ->  [  CommRing  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  R :  Type* } ->  [  CommRingₓ  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  R :  Type* } ->  [  CommRingₓ  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  R :  Type* } ->  [  CommRingₓₓ  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  R :  Type* } ->  [  CommRingₓₓ  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  (  M :  Matrix  n n  ℂ ) ->   M.charpoly.roots_of  ℝ.field =  M.charpoly.roots_of  ℂ.field

{n : Type u} [fintype n] {R : Type v} [decidable_eq n] [comm_ring R] (M : matrix n n R) : have wf (@has_well_founded.r (@linear_equiv.to_matrix n n R M M)) 

 {  n :  Type  u_1 } ->  (  nnonneg :  n ≥  0 ) ->  {  R :  Type  u_2 } ->  [  integral_domain  R ] ->  [  CharP  R  2 ] ->  [  has_1  R ] ->  [  Zero  R ] ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->  ∀   (  q  :  Polynomial  R  )  ,   M.charpoly.roots_count  q =  M.charpoly.real_roots_count  q

 {  n :  Type  u_1 } ->  (  nnonneg :  n ≥  0 ) ->  {  R :  Type  u_2 } ->  [  integral_domain  R ] ->  [  CharP  R  2 ] ->  [  has_1  R ] ->  [  Zero  R ] ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n R ) ->  ∀   (  q  :  Polynomial  R  )  ,   M.charpoly.roots_count  q =  M.charpoly.real_roots_count  q

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type* } ->  (  M :  Matrix   (   Fin  n  )  (   Fin  n  )  ℂ ) ->  ∀  z   :  ℂ ,    z ^ M.nat_dim ∈  ↑  (   M.charpoly.roots   ℂ  ) →  z ∈   ℝ  ℝ

 {  n :  Type* } ->  (  M :  Matrix   (   Fin  n  )  (   Finₓ  n  )  ℂ ) ->  ∀  z   :  ℂ ,    z ^ M.nat_dim ∈  ↑  (   M.charpoly.roots   ℂ  ) →  z ∈   ℝ  ℝ

 {  n :  Type* } ->  (  M :  Matrix   (   Finₓ  n  )  (   Fin  n  )  ℂ ) ->  ∀  z   :  ℂ ,    z ^ M.nat_dim ∈  ↑  (   M.charpoly.roots   ℂ  ) →  z ∈   ℝ  ℝ

 {  n :  Type* } ->  (  M :  Matrix   (   Finₓ  n  )  (   Finₓ  n  )  ℂ ) ->  ∀  z   :  ℂ ,    z ^ M.nat_dim ∈  ↑  (   M.charpoly.roots   ℂ  ) →  z ∈   ℝ  ℝ

failed to elaborate

outputs: #[{n : Type u_1} [decidable_eq n] [fintype n] {R : Type u_2} [comm_ring R] {A : matrix n n R} : A.charpoly.roots.to_finset.card = (A.charpoly.roots ℝ).to_finset.card , {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {M : matrix n n R} : ∀ r, M.charpoly.is_root r → r ∈ ℝ , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [integral_domain R] (M : matrix n n R) : ∀ r ∈ M.charpoly.roots.to_finset.sort (by apply_instance), r ∈ M.charpoly.roots_over ℝ , {α : Type u} [comm_ring α] (M : matrix ℕ ℕ α) : ∀ (x : ℂ), polynomial.eval₂ complex.conj x M.charpoly = polynomial.eval₂ complex.conj x.conj M.charpoly , {n : Type u_1} [decidable_eq n] [fintype n] [comm_ring ℂ] (M : matrix n n ℂ) : polynomial.all_roots_are_real M.charpoly , {R : Type u} {n : Type v} [field R] [decidable_eq n] [fintype n] (A : matrix n n R) : ∀ x : R, A.charpoly.eval x = 0 → x ∈ ℝ , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type u_2} [discrete_field R] {M : matrix n n R} : ∀ (r : R), r.is_root_of (M.charpoly) → r ∈ ℝ , (R : Type u) [comm_ring R] [decidable_eq R] {n : Type u_1} [fintype n] (M : matrix n n R) :
  ∀ ⦃x : R⦄, M.charpoly.is_root x ↔ ⟪x, 0⟫ ∈ M.eigen_roots , {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v_1} [discrete_field R] (M : matrix n n R) : (M.charpoly).aeval ℝ = 0 , {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [discrete_field R] (M : matrix n n R) : ∀ x : R, M.charpoly.eval x = 0 → x ∈ @polynomial.roots R _ (polynomial.roots_to_polynomial M.charpoly) , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : ∀ a, a ∈ M.charpoly.root_set ℝ ↔ a.re ∈ M.charpoly.root_set ℝ , {n : Type u_1} [fintype n] [decidable_eq n] {K : Type u_2} [field K] (M : matrix n n K) : (M.charpoly.root_set ℂ).to_finset.card = 0 , {R : Type*} [comm_ring R] {n : Type*} [decidable_eq n] [fintype n] (A : matrix n n R) (hp : A.det ≠ 0) :
  ∀ z, z ∈ A.char_poly.root_set ℂ → z ∈ A.char_poly.root_set ℝ , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n ℂ) : all_roots_are_real M.charpoly , {n : Type u} [fintype n] [decidable_eq n] {R : Type v} [comm_ring R] (M : matrix n n R) :
  ∃ (S : finset ℂ), S.card = M.nrows ∧ (∀ (x : ℂ), x ∈ S → is_root M.charpoly x) , {n : Type u} [decidable_eq n] (M : matrix n n ℂ) : M.charpoly.roots_of ℝ.field = M.charpoly.roots_of ℂ.field , {n : Type u} [fintype n] {R : Type v} [decidable_eq n] [comm_ring R] (M : matrix n n R) : have wf (@has_well_founded.r (@linear_equiv.to_matrix n n R M M)) , {n : Type u_1} (nnonneg : n ≥ 0) {R : Type u_2} [integral_domain R] [char_p R 2] [has_1 R] [has_zero R] [decidable_eq n] [fintype n] (M : matrix n n R) :
  ∀ (q : polynomial R), M.charpoly.roots_count q = M.charpoly.real_roots_count q , {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {x : matrix n n R} : ∀ r : R, polynomial.is_root (x.charpoly) r ↔ ∃ (c : ℂ), x.eigenvalue c = r , {n : Type*} (M : matrix (fin n) (fin n) ℂ) : ∀ z : ℂ, z ^ M.nat_dim ∈ ↑(M.charpoly.roots ℂ) → z ∈ ℝ ]

total : 20

elaborated: 16

In a commutative ring, every prime ideal is contained in a unique maximal ideal.

No valid output from Codex; outputs below

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ Pmax : P.is_prime ] ->  ∃!    (   M :  Ideal  R ) ,   P ≤ M ∧ M.is_maximal

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ Pmax : P.is_prime ] ->  ∃!    (   M :  Ideal  R ) ,   P ≤ M ∧ M.is_maximal

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ Pmax : P.is_prime ] ->  ∃!    (   M :  Ideal  R ) ,   P ≤ M ∧ M.is_maximal

 {  α :  Type  u } ->  [  CommRing  α ] ->  (  P :  Ideal  α ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  α ,  M.is_maximal ∧  P ⊆ M

 {  α :  Type  u } ->  [  CommRingₓ  α ] ->  (  P :  Ideal  α ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  α ,  M.is_maximal ∧  P ⊆ M

 {  α :  Type  u } ->  [  CommRingₓₓ  α ] ->  (  P :  Ideal  α ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  α ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  m ⊆ P

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  m ⊆ P

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  m ⊆ P

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hp : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  M ⊆ P

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hp : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  M ⊆ P

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hp : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  M ⊆ P

 {  R :  Type  u } ->  [  CommRing  R ] ->  Function.Injective   (   λ P :  Ideal  R ,  Ideal.comap   (   algebraMap  R R  ) P  )

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  Function.Injective   (   λ P :  Ideal  R ,  Ideal.comap   (   algebraMap  R R  ) P  )

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  Function.Injective   (   λ P :  Ideal  R ,  Ideal.comap   (   algebraMap  R R  ) P  )

 (  R :  Type  u ) ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  p ≤ M

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  p ≤ M

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  p ≤ M

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ HP : P.is_prime ] ->  ∃!     M  ,  prime_ideal_maximal_of_prime_ideal  P M

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ HP : P.is_prime ] ->  ∃!     M  ,  prime_ideal_maximal_of_prime_ideal  P M

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ HP : P.is_prime ] ->  ∃!     M  ,  prime_ideal_maximal_of_prime_ideal  P M

 {  R :  Type  u } ->  [  CommRing  R ] ->  [  IsNoetherianRing  R ] ->  (  p :  Ideal  R ) ->  [ h : p.is_prime ] ->  ∃     M  :  Ideal  R ,  M.is_maximal ∧  p ⊆ M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  [  IsNoetherianRing  R ] ->  (  p :  Ideal  R ) ->  [ h : p.is_prime ] ->  ∃     M  :  Ideal  R ,  M.is_maximal ∧  p ⊆ M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  [  IsNoetherianRing  R ] ->  (  p :  Ideal  R ) ->  [ h : p.is_prime ] ->  ∃     M  :  Ideal  R ,  M.is_maximal ∧  p ⊆ M

 {  R :  Type  u } ->  [  CommRing  R ] ->  ∀   {  P  :  Ideal  R }  ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ≤ M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  ∀   {  P  :  Ideal  R }  ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ≤ M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  ∀   {  P  :  Ideal  R }  ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ≤ M

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  α :  Type  u } ->  [  CommRing  α ] ->  {  P :  Ideal  α } ->  [ primeP : P.is_prime ] ->  ∃    (   m :  Ideal  α ) ,  m.is_maximal ∧  P ⊆ m

 {  α :  Type  u } ->  [  CommRingₓ  α ] ->  {  P :  Ideal  α } ->  [ primeP : P.is_prime ] ->  ∃    (   m :  Ideal  α ) ,  m.is_maximal ∧  P ⊆ m

 {  α :  Type  u } ->  [  CommRingₓₓ  α ] ->  {  P :  Ideal  α } ->  [ primeP : P.is_prime ] ->  ∃    (   m :  Ideal  α ) ,  m.is_maximal ∧  P ⊆ m

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  (  hP : P.is_prime ) ->  ∃!    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  (  hP : P.is_prime ) ->  ∃!    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  (  hP : P.is_prime ) ->  ∃!    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  α :  Type  u } ->  [  CommRing  α ] ->  (  P :  Ideal  α ) ->  [ HP : P.is_prime ] ->  ∃     m  ,  (   ∀  j   :  Ideal  α ,  m.is_maximal →  (    P ⊆ m ↔  P = j  )  )

 {  α :  Type  u } ->  [  CommRingₓ  α ] ->  (  P :  Ideal  α ) ->  [ HP : P.is_prime ] ->  ∃     m  ,  (   ∀  j   :  Ideal  α ,  m.is_maximal →  (    P ⊆ m ↔  P = j  )  )

 {  α :  Type  u } ->  [  CommRingₓₓ  α ] ->  (  P :  Ideal  α ) ->  [ HP : P.is_prime ] ->  ∃     m  ,  (   ∀  j   :  Ideal  α ,  m.is_maximal →  (    P ⊆ m ↔  P = j  )  )

 (  R :  Type  u ) ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  ,  M.is_maximal ∧  M ∈  ideal.nhds  P

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  ,  M.is_maximal ∧  M ∈  ideal.nhds  P

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  ,  M.is_maximal ∧  M ∈  ideal.nhds  P

 (  R :  Type  u ) ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  P ≤  (   unique_maximal_ideal  P  )

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  P ≤  (   unique_maximal_ideal  P  )

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  P ≤  (   unique_maximal_ideal  P  )

 {  R :  Type* } ->  [  CommRing  R ] ->  {  P :  Ideal  R } ->  (  hP : P.is_prime ) ->  ∃     M  ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type* } ->  [  CommRingₓ  R ] ->  {  P :  Ideal  R } ->  (  hP : P.is_prime ) ->  ∃     M  ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type* } ->  [  CommRingₓₓ  R ] ->  {  P :  Ideal  R } ->  (  hP : P.is_prime ) ->  ∃     M  ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type* } ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type* } ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type* } ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRing  R ] ->  ∀  P   :  Ideal  R ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  ideal.subset  P M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  ∀  P   :  Ideal  R ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  ideal.subset  P M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  ∀  P   :  Ideal  R ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  ideal.subset  P M

failed to elaborate

outputs: #[{R : Type u} [comm_ring R] (P : ideal R) [Pmax : P.is_prime] : ∃! (M : ideal R), P ≤ M ∧ M.is_maximal , {α : Type u} [comm_ring α] (P : ideal α) [hP : P.is_prime] : ∃! M : ideal α, M.is_maximal ∧ P ⊆ M , {R : Type u} [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃ m : ideal R, m.is_maximal ∧ m ⊆ P , {R : Type u_1} [comm_ring R] (P : ideal R) [hp : P.is_prime] : ∃! M : ideal R, M.is_maximal ∧ M ⊆ P , {R : Type u} [comm_ring R] : function.injective (λ P : ideal R, ideal.comap (algebra_map R R) P) , (R : Type u) [comm_ring R] (p : ideal R) [hp : p.is_prime] : ∃! M : ideal R, M.is_maximal ∧ p ≤ M , {R : Type u_1} [comm_ring R] (p : ideal R) [is_prime p] : ∃! (m : ideal R), m.is_maximal ∧ p ⊆ m , {R : Type u} [comm_ring R] (p : ideal R) [is_prime p] : ∃! m : ideal R, m.is_maximal ∧ p ⊆ m , {R : Type u_1} [comm_ring R] (P : ideal R) [HP : P.is_prime] : ∃! M, prime_ideal_maximal_of_prime_ideal P M , {R : Type u} [comm_ring R] [is_noetherian_ring R] (p : ideal R) [h : p.is_prime] : ∃ M : ideal R, M.is_maximal ∧ p ⊆ M , {R : Type u} [comm_ring R] : ∀ {P : ideal R}, P.is_prime → ∃! M : ideal R, M.is_maximal ∧ P ≤ M , {R : Type u_1} [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃! M : ideal R, M.is_maximal ∧ P ⊆ M , {α : Type u} [comm_ring α] {P : ideal α} [primeP : P.is_prime] : ∃ (m : ideal α), m.is_maximal ∧ P ⊆ m , {R : Type u} [comm_ring R] (P : ideal R) (hP : P.is_prime) : ∃! (M : ideal R), M.is_maximal ∧ P ⊆ M , {α : Type u} [comm_ring α] (P : ideal α) [HP : P.is_prime] : ∃ m, (∀ j : ideal α, m.is_maximal → (P ⊆ m ↔ P = j)) , (R : Type u) [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃! M, M.is_maximal ∧ M ∈ ideal.nhds P , (R : Type u) [comm_ring R] (P : ideal R) [hP : P.is_prime] : P ≤ (unique_maximal_ideal P) , {R : Type*} [comm_ring R] {P : ideal R} (hP : P.is_prime) : ∃ M, M.is_maximal ∧ P ⊆ M , {R : Type*} [comm_ring R] (p : ideal R) [hp : p.is_prime] : ∃ m : ideal R, m.is_maximal ∧ p ⊆ m , {R : Type u} [comm_ring R] : ∀ P : ideal R, P.is_prime → ∃! M : ideal R, M.is_maximal ∧ ideal.subset P M ]

total : 21

elaborated: 16

Every continuous function is uniformly continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},
  Continuous f → UniformContinuous f

total : 22

elaborated: 17

Every uniformly continuous function is bounded above.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  OrderTop  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  OrderTop  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  TopologicalSpace  β ] ->  [  orderable_top  β ] ->  [  UniformAddGroup  β ] ->  {  f :  α → β } ->  (  hf :  uniformly_continuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  TopologicalSpace  β ] ->  [  orderable_top  β ] ->  [  UniformAddGroup  β ] ->  {  f :  α → β } ->  (  hf :  uniformly_continuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  HasDist  α ] ->  [  ConditionallyCompleteLinearOrder  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  HasDist  α ] ->  [  ConditionallyCompleteLinearOrder  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  PseudoMetricSpace  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  PseudoMetricSpace  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  SemilatticeSup  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  SemilatticeSup  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  LinearOrder  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  LinearOrderₓ  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  LinearOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrder  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrderₓ  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  TopologicalSpace  β ] ->  [  OrderTop  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x  ,  c ≥  f  x

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  TopologicalSpace  β ] ->  [  OrderTop  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x  ,  c ≥  f  x

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  TopologicalSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  TopologicalSpace  α ] ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  CompleteSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x  ,   f  x ≤ c

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  CompleteSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x  ,   f  x ≤ c

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  LinearOrder  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  LinearOrderₓ  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  LinearOrderₓₓ  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrder  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrderₓ  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrderₓₓ  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  PseudoMetricSpace  α ] ->  [  PseudoMetricSpace  β ] ->  (  f :  α → β ) ->  (  h_f :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  TopologicalSpace  α ] ->  [  PseudoMetricSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  Nonempty  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpaceₓ  β ] ->  [  Nonempty  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpace  β ] ->  [  Nonempty  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpaceₓ  β ] ->  [  Nonempty  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  TendstoUniformly  f  (   λ x ,  0  ) at_top

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  TendstoUniformly  f  (   λ x ,  0  ) at_top

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  TendstoUniformly  f  (   λ x ,  0  ) at_top

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  TendstoUniformly  f  (   λ x ,  0  ) at_top

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  SemilatticeSup  β ] ->  [  ∀  a   : α ,  Decidable   (    f  a =  ⊤  ) ] ->  (  h :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x   : α ,   f  x ≤ c

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  SemilatticeSup  β ] ->  [  ∀  a   : α ,  Decidable   (    f  a =  ⊤  ) ] ->  (  h :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x   : α ,   f  x ≤ c

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  ConditionallyCompleteLinearOrder  β ] ->  (  f :  α → β ) ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  ConditionallyCompleteLinearOrder  β ] ->  (  f :  α → β ) ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrder  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrder  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrderₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrderₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrder  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrder  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrderₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrderₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  PseudoMetricSpace  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  PseudoMetricSpace  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

failed to elaborate

outputs: #[{α : Type u_1} {β : Type u_2} [uniform_space α] [order_top β] {f : α → β} (hf : uniform_continuous f) : bdd_above (range f) , {α : Type u} {β : Type v}
  [uniform_space α] [topological_space β] [orderable_top β] [uniform_add_group β]
  {f : α → β} (hf : uniformly_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [has_dist α] [conditionally_complete_linear_order β] {f : α → β} (h : uniform_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [pseudo_metric_space β] {f : α → β} (h : uniform_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space β] {f : α → β} (hf : uniform_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [semilattice_sup β] {f : α → β} (hf : uniform_continuous f) : bdd_above (set.range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [linear_order β] [order_top β] [separated_space α] {f : α → β} (hf : uniform_continuous f) : ∃ M, ∀ x, f x ≤ M , {α : Type u} {β : Type v} [uniform_space α] [topological_space β] [order_top β] {f : α → β} (h : uniform_continuous f) : ∃ c : β, ∀ x, c ≥ f x , {α : Type u} {β : Type v} [topological_space α] [uniform_space β] {f : α → β} (hf : uniform_continuous f) : bdd_above f , {α : Type u_1} {β : Type u_2} [uniform_space α] [complete_space β] {f : α → β} (hf : uniform_continuous f) : ∃ c : β, ∀ x, f x ≤ c , {α : Type u} {β : Type v} [uniform_space α] [linear_order β] [uniform_continuous_on_univ β] {f : α → β} (hf : uniform_continuous f) : ∃ C : β, ∀ x, f x ≤ C , {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {f : α → β} (hf : uniform_continuous f) : bdd_above (set.range f) , {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] (f : α → β) (h_f : uniform_continuous f) : bdd_above (set.range f) , {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f : α → β} (hf : uniform_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [nonempty β] {f : α → β} (hf : uniform_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {f : α → β} (hf : uniform_continuous f) : tendsto_uniformly f (λ x, 0) at_top , {α : Type u_1} {β : Type u_2} [uniform_space α] {f : α → β} [semilattice_sup β] [∀ a:α, decidable (f a = ⊤)] (h : uniform_continuous f) : ∃ c : β, ∀ x : α, f x ≤ c , {α : Type u_1} {β : Type u_2} [uniform_space α] [conditionally_complete_linear_order β] (f : α → β) (hf : uniform_continuous f) : bdd_above (set.range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] {f : α → β} [partial_order β] [order_top β] [densely_ordered β] {s : set α} (h : uniform_continuous_on f s) : bdd_above (range $ λ x, f x) , {α : Type u} {β : Type v} [uniform_space α] [pseudo_metric_space β] {f : α → β} (h : uniform_continuous f) : bdd_above (range f) ]

total : 23

elaborated: 17

If every compact subset of a topological space is closed, then the space is compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},
  (∀ (x : Set α), IsCompact x → IsClosed x) → IsCompact s → IsClosed s

total : 24

elaborated: 18

In a commutative ring, the sum of idempotent elements is idempotent.

success

theorem ∀ {R : Type u_1} [inst : CommRing R] {a b : R}, a * a = a → b * b = b → (a + b) * (a + b) = a + b

total : 25

elaborated: 19

The number of partitions of a finite set is a prime number.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) ->  Nat.Prime   (  s.partitions.card  )

 (  s :  Finset  α ) ->  Nat.Prime   (  s.card.partitions  )

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  (  s :  Finset  α ) ->  Nat.Prime  s.card_partitions

 {  n :  ℕ } ->  (  H :  n >  0 ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣  nat.partition  n

 {  α :  Type  u } ->  [  Fintype  α ] ->  Nat.Prime   (   Fintype.card   (   partitions  α  )  )

 {  α :  Type  u } ->  [  Fintypeₓ  α ] ->  Nat.Prime   (   Fintype.card   (   partitions  α  )  )

 {  α :  Type  u } ->  {  L :  Finset  α } ->  [ hp :  Fintype  α ] ->  Nat.Prime   (  L.finset_partitions.card  )

 {  α :  Type  u } ->  {  L :  Finset  α } ->  [ hp :  Fintypeₓ  α ] ->  Nat.Prime   (  L.finset_partitions.card  )

 {  α :  Type* } ->  (  s :  Finset  α ) ->  ∃     p  :  ℕ ,   Nat.Prime  p ∧  p = s.card_partitions

 (  R :  Type  u ) ->  [  Fintype  R ] ->  Nat.Prime  partitions.card

 (  R :  Type  u ) ->  [  Fintypeₓ  R ] ->  Nat.Prime  partitions.card

 {  α :  Type  u_1 } ->  [  Fintype  α ] ->  Nat.Prime    (   Fintype.card  α  ) . partitions.card

 {  α :  Type  u_1 } ->  [  Fintypeₓ  α ] ->  Nat.Prime    (   Fintype.card  α  ) . partitions.card

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) ->  [  Fintype  α ] ->  Nat.Prime  s.card_partitions

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) ->  [  Fintypeₓ  α ] ->  Nat.Prime  s.card_partitions

 {  α :  Type  u_1 } ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p =  Fintype.card  α.partitions

 {  α :  Type  u_1 } ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p =  Fintype.card  α.partitions

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) ->  Prime   (  s.partitions.card  )

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  (  s :  Finset  α ) ->  Fact   (   Nat.Prime  s.card.partitions  )

 {  α :  Type  u_1 } ->  [  Fintype  α ] ->  Nat.Prime   (   Fintype.card   (   partitions  α  )  )

 {  α :  Type  u_1 } ->  [  Fintypeₓ  α ] ->  Nat.Prime   (   Fintype.card   (   partitions  α  )  )

 (  s :  Finset  α ) ->  Nat.Prime   (   partitions.card  s  )

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) -> s.card.partitions.card.prime

 {  α :  Type  u_1 } ->  [  Fintype  α ] ->  Nat.Prime    (   partitions  α  ) . card

 {  α :  Type  u_1 } ->  [  Fintypeₓ  α ] ->  Nat.Prime    (   partitions  α  ) . card

 (  s :  Finset   ℕ ) ->  Nat.Prime  s.card_partition

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) ->  Nat.Prime   (  s.card_partitions  )

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  (  s :  Finset  α ) ->  Nat.Prime   (   card_partitions  s  )

failed to elaborate

outputs: #[{α : Type u_1} (s : finset α) : nat.prime (s.partitions.card) , (s : finset α) : nat.prime (s.card.partitions) , {α : Type u_1} [decidable_eq α] (s : finset α) : nat.prime s.card_partitions , {n : ℕ} (H : n > 0) : ∃ (p : ℕ), nat.prime p ∧ p ∣ nat.partition n , {α : Type u} [fintype α] : nat.prime (fintype.card (partitions α)) , {α : Type u} {L : finset α} [hp : fintype α] : nat.prime (L.finset_partitions.card) , {α : Type*} (s : finset α) : ∃ p : ℕ, nat.prime p ∧ p = s.card_partitions , (R : Type u) [fintype R] : nat.prime partitions.card , {α : Type u_1} [fintype α] : nat.prime (fintype.card α).partitions.card , {α : Type u_1} (s : finset α) [fintype α] : nat.prime s.card_partitions , {α : Type u_1} [fintype α] [decidable_eq α] : ∃ (p : ℕ), nat.prime p ∧ p = fintype.card α.partitions , {α : Type u_1} (s : finset α) : prime (s.partitions.card) , {α : Type u_1} [decidable_eq α] (s : finset α) : fact (nat.prime s.card.partitions) , {α : Type u_1} [fintype α] : nat.prime (fintype.card (partitions α)) , (s : finset α) : nat.prime (partitions.card s) , {α : Type u_1} (s : finset α) : s.card.partitions.card.prime , {α : Type u_1} [fintype α] : nat.prime (partitions α).card , (s : finset ℕ) : nat.prime s.card_partition , {α : Type u_1} (s : finset α) : nat.prime (s.card_partitions) , {α : Type u_1} [decidable_eq α] (s : finset α) : nat.prime (card_partitions s) ]

total : 26

elaborated: 19

If a poset has a maximal element, then it has a unique minimal element.

success

theorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α],
  (∃ a, IsMax a) → (∃ a, IsLeast { a' | a ≤ a' } a) ∧ (∃ a, IsMax a) ∧ (∃ a, IsMin a) ∧ ∃ a, IsMax a

total : 27

elaborated: 20

The automorphism group of an Abelian group is cyclic.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  Fintype  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  Fintypeₓ  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintypeₓ  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  Fintype  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  Fintypeₓ  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  [  Fintype  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  [  Fintypeₓ  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  [  Fintype  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  [  Fintypeₓ  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  [  Fintype  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  [  Fintypeₓ  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  AddGroup  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  AddGroupₓ  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  AddGroupₓₓ  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  AddGroup  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  AddGroupₓ  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  AddGroupₓₓ  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [ h :  is_abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [ h :  is_abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [ h :  is_abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  α :  Type  u } ->  [  Group  α ] ->  [ h :  IsLieAbelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [ h :  IsLieAbelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [ h :  IsLieAbelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (    ℤ ≃* G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (    ℤ ≃* G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (    ℤ ≃* G  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  abelian  α ] ->  IsCyclic   (   aut  α  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.automorphisms  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.automorphisms  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.automorphisms  G  )

 {  G :  Type  u_1 } ->  (  G :  Type  u_2 ) ->  [  AddGroup  G ] ->  [  AddTorsor  G P ] ->  [  add_torsor.is_add_group_action  G P Add ] ->  (  p : P ) ->  ∃    (   g : G )  (   n :  ℕ ) ,  is_torsion_element  g n

 {  G :  Type  u_1 } ->  (  G :  Type  u_2 ) ->  [  AddGroupₓ  G ] ->  [  AddTorsor  G P ] ->  [  add_torsor.is_add_group_action  G P Add ] ->  (  p : P ) ->  ∃    (   g : G )  (   n :  ℕ ) ,  is_torsion_element  g n

 {  G :  Type  u_1 } ->  (  G :  Type  u_2 ) ->  [  AddGroupₓₓ  G ] ->  [  AddTorsor  G P ] ->  [  add_torsor.is_add_group_action  G P Add ] ->  (  p : P ) ->  ∃    (   g : G )  (   n :  ℕ ) ,  is_torsion_element  g n

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   aut  G  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  CommGroup  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  CommGroupₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  CommGroupₓₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  CommGroup  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  CommGroupₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  CommGroupₓₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  CommGroup  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  CommGroupₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  CommGroupₓₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abel  G ] ->  {  n :  ℕ } ->  (  h :   Fintype.card   (   group_aut  G  ) = n ) ->  IsCyclic   (   group_aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abel  G ] ->  {  n :  ℕ } ->  (  h :   Fintype.card   (   group_aut  G  ) = n ) ->  IsCyclic   (   group_aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abel  G ] ->  {  n :  ℕ } ->  (  h :   Fintype.card   (   group_aut  G  ) = n ) ->  IsCyclic   (   group_aut  G  )

 {  G :  Type  u_1 } ->  [  AddGroup  G ] ->  [  is_abelian  G ] ->  IsCyclic   (   auto_equiv  G  )

 {  G :  Type  u_1 } ->  [  AddGroupₓ  G ] ->  [  is_abelian  G ] ->  IsCyclic   (   auto_equiv  G  )

 {  G :  Type  u_1 } ->  [  AddGroupₓₓ  G ] ->  [  is_abelian  G ] ->  IsCyclic   (   auto_equiv  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  CommGroup  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  CommGroupₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  CommGroupₓₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  CommGroup  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  CommGroupₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  CommGroupₓₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  CommGroup  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  CommGroupₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  CommGroupₓₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  α :  Type  u } ->  [  AddGroup  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  AddGroupₓ  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  AddGroupₓₓ  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

failed to elaborate

outputs: #[{G : Type u_1} [group G] [fintype G] [h : is_abelian_group G] : is_cyclic (@aut G G _ h) , {G : Type u_1} [comm_group G] [fintype G] {a : G} (h : ∃ (b : G), (auto G) a = ⟨λ (b₁ : G), ∃ (n : ℤ), b₁ = b ^ n, (fintype.card G)⁻¹⟩) : is_cyclic (auto G) , {α : Type u} [monoid α] [add_group α] [is_abelian_group α] : is_cyclic (monoid_aut α) , {G : Type u_1} [group G] [abelian G] : is_cyclic (group.aut G) , {G : Type u_1} [group G] [h : is_abelian G] : is_cyclic (group.aut G) , {α : Type u} [group α] [h : is_lie_abelian α] : is_cyclic (aut α) , {α : Type u} [monoid α] [group_with_zero α] [fintype α] [decidable_eq α] [add_group α] [add_torsor α α] (h : is_lie_abelian α) : is_cyclic (group_with_zero.mop.to_group (subtype.range (λ (a : α), a ≠ 0))) , {G : Type u_1} [comm_group G] : is_cyclic (aut G) , {G : Type u_1} [group G] [abelian G] : is_cyclic (ℤ ≃* G) , {α : Type u} [group α] [abelian α] : is_cyclic (aut α) , {G : Type u_1} [group G] [abelian G] : is_cyclic (group.automorphisms G) , {G : Type u_1} (G : Type u_2) [add_group G] [add_torsor G P] [add_torsor.is_add_group_action G P add] (p : P) : ∃ (g : G) (n : ℕ), is_torsion_element g n , {G : Type u_1} [group G] [abelian G] : is_cyclic (aut G) , {α : Type u} [group α] [comm_group α] : is_cyclic (group.aut α) , {α : Type u} [group α] [is_abelian α] : is_cyclic (aut α) , {G : Type u_1} [group G] [abel G] {n : ℕ} (h : fintype.card (group_aut G) = n) : is_cyclic (group_aut G) , {G : Type u_1} [add_group G] [is_abelian G] : is_cyclic (auto_equiv G) , {G : Type u_1} [group G] [comm_group G] : is_cyclic (group.aut G) , {G : Type u_1} [group G] [abelian G] : is_cyclic (automorphism_group G) , {α : Type u} [add_group α] [is_abelian α] : is_cyclic (aut α) ]

total : 28

elaborated: 20

If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.

success

theorem ∀ {f : ℕ → ℕ} (x : ℕ), f x = x → ∀ {n : ℕ}, 0 < n → Function.IsPeriodicPt f n x

total : 29

elaborated: 21

The complement of the union of two sets contains the union of their complements.

No valid output from Codex; outputs below

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∩  - t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∩  - t

 {  α :  Type  u } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   (   - s  ) ∪  (   - t  )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   (   - s  ) ∪  (   - t  )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  {  s t :  Set  α } ->   set.compl   (   s ∪ t  ) ⊆   set.compl  s ∪  set.compl  t

 {  α :  Type  u_1 } ->  {  s t :  Setₓ  α } ->   set.compl   (   s ∪ t  ) ⊆   set.compl  s ∪  set.compl  t

 {  α :  Type  u_1 } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆  (    - s ∩  - t  )

 {  α :  Type  u_1 } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆  (    - s ∩  - t  )

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

{α : Type u_1} {s t : set α} : (s ∪ t)ᶜ ⊆ (sᶜ ∪ tᶜ) 

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )  ) =   (   - s  ) ∩  (   - t  )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )  ) =   (   - s  ) ∩  (   - t  )

{α : Type u} {s t : set α} : (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ 

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->    -  (   s ∪ t  ) ⊇   - s ∪  - t   -  (   s ∪ ts ∪ t  ) ⊇   - s ∪  - t   -  (   s ∪ t  ) ⊇   - s ∪  - t

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->    -  (   s ∪ t  ) ⊇   - s ∪  - t   -  (   s ∪ ts ∪ t  ) ⊇   - s ∪  - t   -  (   s ∪ t  ) ⊇   - s ∪  - t

{α : Type u_1} [topological_space α] {s t : set α} : sᶜ ∪ tᶜ = (s ∪ t)ᶜ 

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

{α : Type u} [topological_space α] {s t : set α} : (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ 

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   set.compl   (   s ∪ t  ) ⊆   set.compl  s ∪  set.compl  t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   set.compl   (   s ∪ t  ) ⊆   set.compl  s ∪  set.compl  t

failed to elaborate

outputs: #[{α : Type u} [topological_space α] {s t : set α} : -(s ∪ t) ⊆ -s ∩ -t , {α : Type u} {s t : set α} : -(s ∪ t) ⊆ (-s) ∪ (-t) , {α : Type u} {s t : set α} : -(s ∪ t) ⊆ -s ∪ -t , {α : Type u_1} {s t : set α} : -(s ∪ t) ⊆ -s ∪ -t , {α : Type u_1} {s t : set α} : set.compl (s ∪ t) ⊆ set.compl s ∪ set.compl t , {α : Type u_1} {s t : set α} : -(s ∪ t) ⊆ (-s ∩ -t) , {α : Type u_1} [topological_space α] {s t : set α} : - (s ∪ t) ⊆ - s ∪ - t , {α : Type u_1} {s t : set α} : (s ∪ t)ᶜ ⊆ (sᶜ ∪ tᶜ) , {α : Type u} {s t : set α} : (-(s ∪ t)) = (-s) ∩ (-t) , {α : Type u} {s t : set α} : (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ , {α : Type u_1} [topological_space α] {s t : set α} : -(s ∪ t) ⊇ -s ∪ -t , {α : Type u_1} [topological_space α] {s t : set α} : sᶜ ∪ tᶜ = (s ∪ t)ᶜ , {α : Type u} {s t : set α} : (-(s ∪ t) : set α) ⊆ (-s : set α) ∪ (-t : set α) , {α : Type u} [topological_space α] {s t : set α} : (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ , {α : Type u} [topological_space α] {s t : set α} : set.compl (s ∪ t) ⊆ set.compl s ∪ set.compl t ]

total : 30

elaborated: 21

The square root of an rational number is rational.

No valid output from Codex; outputs below

 {  q :  ℚ } ->  (  hq :  q ≥  0 ) ->  ∃    (   p :  ℚ ) ,   p * p = q

 (  a :  ℚ ) ->  ∃    (   b :  ℚ ) ,   b * b = a

 (  q :  ℚ ) ->  ∃    (   r :  ℚ ) ,   r * r = q

 (  x :  ℚ ) ->  ∃    (   y :  ℚ ) ,   IsSquare  y ∧  y = x

 (  q :  ℚ ) ->  ∃    (   q' :  ℚ ) ,   q' * q' = q

 {  q :  ℚ } ->  (  hq :  q ≥  0 ) ->  ∃    (   r :  ℚ ) ,   r * r = q

 {  q :  ℚ } ->   IsSquare  q →  ∃    (   p :  ℚ ) ,  q =  p ^  2

 (  q :  ℚ ) ->   IsSquare  q →  ∃    (   q' :  ℚ ) ,  q =  q' * q'

 {  q :  ℚ } ->  (  hq :  q ≥  0 ) ->  ∃    (   r :  ℚ ) ,   r ^  2 = q

 (  x :  ℚ ) ->  ∃    (   y :  ℚ ) ,   rat.sqrt  x =  (  y   :   ℝ  ℝ )

 (  q :  ℚ ) ->   IsSquare  q →  ∃    (   r :  ℚ ) ,   r * r = q

 (  q :  ℚ ) ->  ∃    (   p :  ℚ ) ,  q =  p * p

 (  x :  ℚ ) ->  ∃    (   y :  ℚ ) ,   y * y = x

 (  q :  ℚ ) ->  is_rational   (    (   ↑ q   :   ℝ  ℝ ) *  sqrt   2  )

 (  q :  ℚ ) ->   IsSquare  q →  ∃    (   q :  ℚ ) ,   q * q = q

 (  q :  ℚ ) ->  ∃     r  :  ℚ ,   r ^  2 = q

{q : ℚ} : ∃ (r : ℚ), r*r = q 

 (  x :  ℚ ) ->   IsSquare  x →  ∃    (   q :  ℚ ) ,   q * q = x

 {  q :  ℚ } ->  ∃    (   r :  ℚ ) ,   r * r = q

failed to elaborate

outputs: #[{q : ℚ} (hq : q ≥ 0) : ∃ (p : ℚ), p * p = q , (a : ℚ) : ∃ (b : ℚ), b * b = a , (q : ℚ) : ∃ (r : ℚ), r * r = q , (x : ℚ) : ∃ (y : ℚ), is_square y ∧ y = x , (q : ℚ) : ∃ (q' : ℚ), q' * q' = q , {q : ℚ} (hq : q ≥ 0) : ∃ (r : ℚ), r * r = q , {q : ℚ} : is_square q → ∃ (p : ℚ), q = p ^ 2 , (q : ℚ) : is_square q → ∃ (q' : ℚ), q = q' * q' , {q : ℚ} (hq : q ≥ 0) : ∃ (r : ℚ), r ^ 2 = q , (x : ℚ) : ∃ (y : ℚ), rat.sqrt x = (y : ℝ) , (q : ℚ) : is_square q → ∃ (r : ℚ), r * r = q , (q : ℚ) : ∃ (p : ℚ), q = p * p , (x : ℚ) : ∃ (y : ℚ), y * y = x , (q : ℚ) : is_rational ((↑q : ℝ) * sqrt 2) , (q : ℚ) : is_square q → ∃ (q : ℚ), q * q = q , (q : ℚ) : ∃ r : ℚ, r ^ 2 = q , {q : ℚ} : ∃ (r : ℚ), r*r = q , (x : ℚ) : is_square x → ∃ (q : ℚ), q * q = x , {q : ℚ} : ∃ (r : ℚ), r * r = q ]

total : 31

elaborated: 21

If a module over a ring is free, then the ring is commutative.

success

theorem {R : Type u} →
  {M : Type v} → [inst : Ringₓ R] → [inst_1 : AddCommGroupₓ M] → [inst_2 : Module R M] → Module.Free R M → CommRing R

total : 32

elaborated: 22

If the set of units of a ring forms a group then the ring is commutative.

success

theorem {α : Type u} → [inst : Ringₓ α] → Group (Units α) → CommRing α

total : 33

elaborated: 23

Every natural number larger than `10` is the sum of a square and a prime.

success

theorem ∀ (n : ℕ), 10 < n → ∃ a b, a ^ 2 + b ^ 2 = n ∧ Nat.Prime b

total : 34

elaborated: 24

The initial object of a category is isomorphic to its terminal object.

No valid output from Codex; outputs below

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  C ≌ C

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Iso.refl   (   ⊥_ C  )  )

{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (category_theory.limits.terminal.from ⊥_ C)) 

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  category_theory.iso   (   ⊥_ C  )  (   ⊤_ C  )

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

 {  C :  Type  u₁ } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  [  category_theory.has_self_equiv  C ] ->  (  i : C ) ->  (  t : C ) ->  (  a :  i ⟶ t ) ->  [  category_theory.initial  a ] ->  [  category_theory.terminal  a ] ->  i ≅ t

 {  C :  Type  u₁ } ->  [  CategoryTheory.Category  C ] ->  [  category_theory.limits.has_initial_terminal_object  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasBinaryProducts  C ] ->  [  CategoryTheory.Limits.HasBinaryCoproducts  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  category_theory.iso   (   CategoryTheory.Limits.terminal.from   (   ⊥_ C  )  )  (   CategoryTheory.Limits.initial.to   (   {    X    :  C × C }  )  )

{C : Type u} [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_initial C] : category_theory.is_iso ⊤_ C 

{C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : (⊥_ C).to ⟶ (⊤_ C) ≅ 𝟙 (⊥_ C) 

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  (  h :  CategoryTheory.Limits.initial.to   (   ⊤_ C  ) ) ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

failed to elaborate

outputs: #[{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : C ≌ C , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.iso.refl (⊥_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (category_theory.limits.terminal.from ⊥_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.iso (⊥_ C) (⊤_ C) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] [category_theory.has_self_equiv C] (i : C) (t : C) (a : i ⟶ t) [category_theory.initial a] [category_theory.terminal a] : i ≅ t , {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial_terminal_object C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_terminal C] [category_theory.limits.has_initial C] : category_theory.iso (category_theory.limits.terminal.from (⊥_ C)) (category_theory.limits.initial.to ({X : C × C})) , {C : Type u} [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_initial C] : category_theory.is_iso ⊤_ C , {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : (⊥_ C).to ⟶ (⊤_ C) ≅ 𝟙 (⊥_ C) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (h : category_theory.limits.initial.to (⊤_ C)) : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) ]

total : 35

elaborated: 24

If the composition of two functions is continuous, then each of them is continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]
  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f ∧ Continuous g

total : 36

elaborated: 25

If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.

success

theorem ∀ {S : Type ?u.9708663} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c

total : 37

elaborated: 26

If an element maps to zero under a ring homomorphism, then it is zero.

success

theorem ∀ {α : Type u} {β : Type v} [inst : Ringₓ α] [inst_1 : Ringₓ β] {f : α → β}, IsRingHom f → ∀ (x : α), f x = 0 → x = 0

total : 38

elaborated: 27

Implication `→` is symmetric. If `P → Q` then `Q → P`.

success

theorem ∀ {p q : Prop}, (p → q) → q → p

total : 39

elaborated: 28

Two natural numbers are equal if and only if they are both divisible by some prime number.

success

theorem ∀ {m n : ℕ}, m = n ↔ ∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n

total : 40

elaborated: 29

Writing to file: silly-elab-12-8-false-20-8.json

Every prime number is `2` or odd.

success

theorem ∀ (p : ℕ), Nat.Prime p → p = 2 ∨ 1 < p ∧ p % 2 = 1

total : 1

elaborated: 1

There are infinitely many odd natural numbers.

success

theorem ∀ {n : ℕ}, ∃ m, m ≥ n ∧ Odd m

total : 2

elaborated: 2

The smallest odd prime is `3`.

success

theorem ∀ {p : ℕ}, Fact (Nat.Prime p) ∧ p > 2 → p = 3

total : 3

elaborated: 3

There are infinitely many odd prime numbers.

success

theorem ∀ (p : ℕ), ∃ q, q ≠ p ∧ q % 2 = 1 ∧ Nat.Prime q

total : 4

elaborated: 4

If a vector space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Module.rank K V = 2 → FiniteDimensional K V

total : 5

elaborated: 5

Every field is a division ring.

success

theorem {α : Type u} → [inst : Field α] → DivisionRing α

total : 6

elaborated: 6

If a space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Module.rank K V = 2 → FiniteDimensional K V

total : 7

elaborated: 7

Every natural number has a successor.

success

theorem ∀ {α : Type u} (a : ℕ), ∃ b, b > a

total : 8

elaborated: 8

Every natural number is less than its successor.

success

theorem ∀ (n : ℕ), n < Nat.succ n

total : 9

elaborated: 9

Every set is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s

total : 10

elaborated: 10

Every set of Borel measure zero is Lebesgue measurable.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->    MeasureTheory.Measure  s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->    MeasureTheory.Measure  s =  0 →  MeasurableSet  s

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  T2Space  α ] ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  measure_theory.measurable  s

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  T2Space  α ] ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  measure_theory.measurable  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hm :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hm :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  BorelSpace  α ] ->  [  measure_space  α ] ->  (  h :   volume  s =  0 ) ->  Measurable  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  BorelSpace  α ] ->  [  measure_space  α ] ->  (  h :   volume  s =  0 ) ->  Measurable  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->    ν  s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->    ν  s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  m :  MeasureTheory.Measure  α } ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  m :  MeasureTheory.Measure  α } ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  {  ν :  MeasureTheory.Measure  α } ->  (  hν : ν.is_borel ) ->  (  hs :   ν  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  {  ν :  MeasureTheory.Measure  α } ->  (  hν : ν.is_borel ) ->  (  hs :   ν  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  measure_theory.borel_space  α ] ->  {  s :  Set  α } ->  (  h :   measure_theory.volume  m s =  0 ) ->  measure_theory.measurable_set  s

 {  α :  Type  u_1 } ->  {  m :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  measure_theory.borel_space  α ] ->  {  s :  Setₓ  α } ->  (  h :   measure_theory.volume  m s =  0 ) ->  measure_theory.measurable_set  s

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  ν :  MeasureTheory.Measure  β } ->  [  MeasurableSpace  α ] ->  [  MeasurableSpace  β ] ->  [  BorelSpace  α ] ->  [  BorelSpace  β ] ->  {  s :  Set  α } ->  {  t :  Set  β } ->  (  hν :   measure_theory.measure.borel_measure  ν t =  0 ) ->  (  h :  s ⊆ t ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  ν :  MeasureTheory.Measure  β } ->  [  MeasurableSpace  α ] ->  [  MeasurableSpace  β ] ->  [  BorelSpace  α ] ->  [  BorelSpace  β ] ->  {  s :  Set  α } ->  {  t :  Setₓ  β } ->  (  hν :   measure_theory.measure.borel_measure  ν t =  0 ) ->  (  h :  s ⊆ t ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  ν :  MeasureTheory.Measure  β } ->  [  MeasurableSpace  α ] ->  [  MeasurableSpace  β ] ->  [  BorelSpace  α ] ->  [  BorelSpace  β ] ->  {  s :  Setₓ  α } ->  {  t :  Set  β } ->  (  hν :   measure_theory.measure.borel_measure  ν t =  0 ) ->  (  h :  s ⊆ t ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  ν :  MeasureTheory.Measure  β } ->  [  MeasurableSpace  α ] ->  [  MeasurableSpace  β ] ->  [  BorelSpace  α ] ->  [  BorelSpace  β ] ->  {  s :  Setₓ  α } ->  {  t :  Setₓ  β } ->  (  hν :   measure_theory.measure.borel_measure  ν t =  0 ) ->  (  h :  s ⊆ t ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  m :  MeasureTheory.Measure  α } ->  (  hs :   borel_measure  m s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  m :  MeasureTheory.Measure  α } ->  (  hs :   borel_measure  m s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  {  m :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->    measure  m s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  {  m :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->    measure  m s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  {  m :  measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :   m  s =  0 ) ->  Measurable  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  {  m :  measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :   m  s =  0 ) ->  Measurable  s

{α : Type u_1} {m : measurable_space α} [borel_space α] {s : set α} ⦃hn : measure_theory.volume s = 0⦄ : measurable_set s 

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->    MeasureTheory.Measure  α s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->    MeasureTheory.Measure  α s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :   MeasureTheory.Measure  α s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :   MeasureTheory.Measure  α s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  MeasurableSet   ↑  {   x   : α |   MeasureTheory.MeasureSpace.volume    {  xx }  {    xx    } =  0 }

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Set  α } ->  (  h :   MeasureTheory.Measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   MeasureTheory.Measure  s =  0 ) ->  MeasurableSet  s

failed to elaborate

outputs: #[{α : Type u_1} {m : measurable_space α} [borel_space α] {s : set α} (h : borel_measure s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} : measure_theory.measure s = 0 → measurable_set s , {α : Type u} [topological_space α] [t2_space α] [measurable_space α] [borel_space α] {s : set α} (h : measure_theory.measure_space.volume s = 0) : measure_theory.measurable s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hm : borel_measure s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measure_theory.measure_space.volume s = 0) : measurable_set s , {α : Type u_1} {s : set α} [borel_space α] [measure_space α] (h : volume s = 0) : is_measurable s , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] : ν s = 0 → measurable_set s , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] {m : measure_theory.measure α} (h : measure_theory.measure_space.volume s = 0) : measurable_set s , {α : Type u_1} {s : set α} {ν : measure_theory.measure α} (hν : ν.is_borel) (hs : ν s = 0) : measurable_set s , {α : Type u_1} {m : measure_theory.measure α} [measurable_space α] [measure_theory.borel_space α] {s : set α} (h : measure_theory.volume m s = 0) : measure_theory.measurable_set s , {α : Type u_1} {β : Type u_2} {ν : measure_theory.measure β} [measurable_space α] [measurable_space β] [borel_space α] [borel_space β] {s : set α} {t : set β} (hν : measure_theory.measure.borel_measure ν t = 0) (h : s ⊆ t) : measurable_set s , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] {m : measure_theory.measure α} (hs : borel_measure m s = 0) : measurable_set s , {α : Type u_1} {s : set α} {m : measure_theory.measure α} [measurable_space α] [borel_space α] : measure m s = 0 → measurable_set s , {α : Type u_1} {s : set α} {m : measure α} [measurable_space α] [borel_space α] (h : m s = 0) : is_measurable s , {α : Type u_1} {m : measurable_space α} [borel_space α] {s : set α} ⦃hn : measure_theory.volume s = 0⦄ : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (h : borel_measure s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} : measure_theory.measure α s = 0 → measurable_set s , {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measure_theory.measure α s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] : measurable_set ↑{x : α | measure_theory.measure_space.volume {x} = 0} , {α : Type u_1} [measurable_space α] {s : set α} (h : measure_theory.measure s = 0) : measurable_set s ]

total : 11

elaborated: 10

No prime number is a perfect square.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ n, n * n = p

total : 12

elaborated: 11

Every odd prime number is greater than `2`.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Odd p → p > 2

total : 13

elaborated: 12

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

Writing to file: silly-elab-12-8-false-20-8.json

Every prime number is `2` or odd.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1

total : 1

elaborated: 1

There are infinitely many odd natural numbers.

success

theorem ∀ (n : ℕ), ∃ n, n > n ∧ Odd n

total : 2

elaborated: 2

The smallest odd prime is `3`.

success

theorem ∀ (n : ℕ), Fact (Nat.Prime n) → n ≠ 2 → n = 3

total : 3

elaborated: 3

There are infinitely many odd prime numbers.

success

theorem ∀ (k : ℕ), ∃ n, 2 * k + 1 ≤ n ∧ Nat.Prime n

total : 4

elaborated: 4

If a vector space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Module.rank K V ≤ 2 → FiniteDimensional K V

total : 5

elaborated: 5

Every field is a division ring.

success

theorem (K : Type u) → [inst : Field K] → DivisionRing K

total : 6

elaborated: 6

If a space has dimension `2` then it is finite dimensional.

success

theorem {R : Type u_1} →
  [inst : Ringₓ R] → (n m : ℕ) → (v : Fin m → Fin n → R) → m ≤ 2 → LinearIndependent R v → m ≤ n → Fin m → Fin n → R

total : 7

elaborated: 7

Every natural number has a successor.

success

theorem ∀ {n : ℕ}, ∃ k, n < k

total : 8

elaborated: 8

Every natural number is less than its successor.

success

theorem ∀ (n : ℕ), n < Nat.succ n

total : 9

elaborated: 9

Every set is Lebesgue measurable.

success

theorem {α : Type u_1} → MeasurableSpace α

total : 10

elaborated: 10

Every set of Borel measure zero is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} {m : MeasurableSpace α} {s : Set α}, coeFn MeasureTheory.volume.toOuterMeasure s = 0 → MeasurableSet s

total : 11

elaborated: 11

No prime number is a perfect square.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ m, p = m * m

total : 12

elaborated: 12

Every odd prime number is greater than `2`.

success

theorem ∀ (p : ℕ) [hprime : Fact (Nat.Prime p)], Odd p → 2 < p

total : 13

elaborated: 13

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

success

theorem ∀ {a b : ℕ},
  (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →
    (∃ x y z w, b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) → ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2

total : 14

elaborated: 14

Every compact topological space is locally compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α

total : 15

elaborated: 15

Every continuous function is uniformly continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},
  Continuous f → UniformContinuous f

total : 16

elaborated: 16

`6` is not the sum of two distinct prime numbers.

success

theorem ∀ (a b : ℕ), Prime a → Prime b → 6 = a + b → a = 3 ∧ b = 3

total : 17

elaborated: 17

No integer is irrational.

No valid output from Codex; outputs below

{x : ℤ} (hxr : irrational x) : false 

 (  a :  ℤ ) ->  ¬  Irrational  a

 ¬  ∃    (   n :  ℤ ) ,  Irrational  n

 {  m :  ℤ } ->  Irrational  m

 ∀   (  x  :  ℤ  )  ,  Irrational   (   ↑ x   :   ℝ  ℝ )

 {  x :   ℝ  ℝ } ->  (  hx :  ∃    (   n :  ℤ ) ,  x = n ) ->  ¬  Irrational  x

 {  x :   ℝ  ℝ } ->  (  hxr :  ∀   (  p  :  ℕ  )  ,  x ≠ p ) ->  Irrational  x

 {  n :  ℤ } ->  ¬  Irrational   ↑ n

 ∀   {  x  :  ℤ }  ,  Irrational  x

 (  m :  ℤ ) ->  ¬  Irrational  m

 {  x :  ℤ } ->  Irrational  x

{x : ℤ} (hx : irrational x) : false 

 {  x :   ℝ  ℝ } ->  (  hxr :  x =  (   ↑ x   :   ℝ  ℝ ) ) ->  ¬  Irrational  x

 {  x :   ℝ  ℝ } ->  (  hx :  Int  x ) ->  ¬  Irrational  x

{n : ℤ} : irrational n → false 

 : ¬∃ : n : ℤ, irrational n 

 (  x :  ℤ ) ->  ¬  Irrational  x

 {  r :   ℝ  ℝ } ->  (  hirr :  Irrational  r ) ->  ¬  has_rat.of_rat  r

failed to elaborate

outputs: #[{x : ℤ} (hxr : irrational x) : false , (a : ℤ) : ¬irrational a , : ¬∃ (n : ℤ), irrational n , {m : ℤ} : irrational m ,  : ∀ (x : ℤ), irrational (↑x : ℝ) , {x : ℝ} (hx : ∃ (n : ℤ), x = n) : ¬irrational x , {x : ℝ} (hxr : ∀ (p : ℕ), x ≠ p) : irrational x , {n : ℤ} : ¬irrational ↑n ,  : ∀ {x : ℤ}, irrational x , (m : ℤ) : ¬ irrational m , {x : ℤ} : irrational x , {x : ℤ} (hx : irrational x) : false , {x : ℝ} (hxr : x = (↑x : ℝ)) : ¬irrational x , {x : ℝ} (hx : is_int x) : ¬irrational x , {n : ℤ} : irrational n → false ,  : ¬∃ : n : ℤ, irrational n , (x : ℤ) : ¬irrational x , {r : ℝ} (hirr : irrational r) : ¬has_rat.of_rat r ]

total : 18

elaborated: 17

The identity element in a ring is a unit.

success

theorem ∀ {α : Type u} [inst : Ringₓ α], IsUnit 1

total : 19

elaborated: 18

Every subgroup of a group is a group.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  {  G :  Group  α } ->  Group   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Group  α } ->  Group   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Group  α } ->  Groupₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Group  α } ->  Groupₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Group  α } ->  Groupₓₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Group  α } ->  Groupₓₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Group   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Group   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Groupₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Groupₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Groupₓₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Groupₓₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Group   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Group   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Groupₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Groupₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Groupₓₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Groupₓₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u_1 } ->  [  Monoid  α ] ->  monoid.is_submonoid  α

 {  α :  Type  u_1 } ->  [  Monoidₓ  α ] ->  monoid.is_submonoid  α

 {  G :  Type  u } ->  [  Group  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Group  H

 {  G :  Type  u } ->  [  Group  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓ  H

 {  G :  Type  u } ->  [  Group  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓₓ  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Group  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓ  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓₓ  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Group  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓ  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓₓ  H

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  Π ( H :  Subgroup  G ) ,  Group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓₓ  H

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  group.group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  group.group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  group.group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Subgroup  G ) ->  Group   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Subgroup  G ) ->  Groupₓ   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Subgroup  G ) ->  Groupₓₓ   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Subgroup  G ) ->  Group   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Subgroup  G ) ->  Groupₓ   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Subgroup  G ) ->  Groupₓₓ   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Subgroup  G ) ->  Group   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Subgroup  G ) ->  Groupₓ   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Subgroup  G ) ->  Groupₓₓ   (   Subtype  s  )

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

failed to elaborate

outputs: #[{G : Type u_1} [group G] (H : subgroup G) : group H , {α : Type u_1} [group α] {s : set α} (h_sub : is_subgroup s) : group.group s , {G : Type u_1} [group G] {H : subgroup G} : group H , {α : Type u_1} [group α] (s : set α) (hs : is_subgroup s) : group s , {α : Type u} {G : group α} : is_group (↑G : set α) , {α : Type u_1} [monoid α] : monoid.is_submonoid α , {G : Type u} [group G] : ∀ (H : subgroup G), group H , {α : Type u} [group α] {s : set α} (hs : is_subgroup s) : group s , {G : Type u_1} [group G] : Π (H : subgroup G), group H , {α : Type u_1} [group α] {s : subgroup α} : group s , {G : Type u_1} [group G] (H : subgroup G) : group.group H , {G : Type u_1} [group G] (s : subgroup G) : group (subtype s) , {α : Type u_1} [group α] {s : set α} (hs : is_subgroup s) : group s ]

total : 20

elaborated: 18

The sum of two natural numbers is a natural number.

Writing to file: silly-elab-12-8-false-20-8.json

Every prime number is `2` or odd.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1

total : 1

elaborated: 1

There are infinitely many odd natural numbers.

success

theorem ∀ (n : ℕ), ∃ m, m % 2 = 1 ∧ m ≥ n

total : 2

elaborated: 2

The smallest odd prime is `3`.

success

theorem ∀ (n : ℕ) [inst : Fact (Nat.Prime n)], n = 3 → n = 3 ∨ n = 5

total : 3

elaborated: 3

There are infinitely many odd prime numbers.

success

theorem ∀ (n : ℕ), ∃ p, n < p ∧ Nat.Prime p ∧ p % 2 = 1

total : 4

elaborated: 4

If a vector space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Module.rank K V = 2 → FiniteDimensional K V

total : 5

elaborated: 5

Every field is a division ring.

success

theorem (K : Type u) → [inst : Field K] → DivisionRing K

total : 6

elaborated: 6

If a space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V] (ι : Type u_1)
  [inst_3 : Unique ι], Nonempty (Basis ι K V) → FiniteDimensional K V

total : 7

elaborated: 7

Every natural number has a successor.

success

theorem ∀ (n : ℕ), ∃ n', n' = Nat.succ n

total : 8

elaborated: 8

Every natural number is less than its successor.

success

theorem ∀ (n : ℕ), n < Nat.succ n

total : 9

elaborated: 9

Every set is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, MeasurableSet s

total : 10

elaborated: 10

Every set of Borel measure zero is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : MeasurableSpace α] [inst_3 : BorelSpace α]
  {s : Set α}, coeFn MeasureTheory.volume.toOuterMeasure s = 0 → MeasurableSet s

total : 11

elaborated: 11

No prime number is a perfect square.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ a, a ^ 2 = p

total : 12

elaborated: 12

Every odd prime number is greater than `2`.

success

theorem ∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p

total : 13

elaborated: 13

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

success

theorem ∀ {a b c d e f g h : ℤ},
  a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = e ^ 2 + f ^ 2 + g ^ 2 + h ^ 2 →
    (a + b) * (a + b) + (c + d) * (c + d) = (e + f) * (e + f) + (g + h) * (g + h)

total : 14

elaborated: 14

Every compact topological space is locally compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α

total : 15

elaborated: 15

Every continuous function is uniformly continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),
  Continuous f → UniformContinuous f

total : 16

elaborated: 16

`6` is not the sum of two distinct prime numbers.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (q : ℕ) [inst : Fact (Nat.Prime q)], p < 6 ∧ q < 6 ∧ p ≠ q → p + q ≠ 6

total : 17

elaborated: 17

No integer is irrational.

No valid output from Codex; outputs below

 {  x :  ℤ } ->  ¬  Irrational  x

 ∀   (  z  :  ℤ  )  ,  Irrational  z

 {  n :  ℤ } ->  Irrational  n

{x : ℝ} (hxirr : irrational x) (hxint : ¬(∃ (n : ℤ), x = ↑n)) : false 

 {  m :  ℤ } ->  (  hm :  m ≠  0 ) ->  ¬  Irrational   (   ↑ m   :   ℝ  ℝ )

 {  x :   ℝ  ℝ } ->   Irrational  x →  ¬  ∃    (   m :  ℤ ) ,  x = m

 (  z :  ℤ ) ->  Irrational  z

 {  x :   ℝ  ℝ } ->  ∀   (  y  :  ℤ  )  ,   x =  ↑ y →  Irrational  x

 {  x :   ℝ  ℝ } ->  (  hxr :  x ∈  ℤ ) ->  ¬  Irrational  x

 {  x :   ℝ  ℝ } ->  x.nat_abs.irrational ↔  x ∉  Set.Range   (  Coe   :   ℤ →   ℝ  ℝ )

{x : ℤ} : irrational x → false 

 {  z :  ℤ } ->  Irrational  z

 ∀   (  x  :  ℤ  )  ,  ¬  Irrational   (   ↑ x   :   ℝ  ℝ )

 (  x :  ℤ ) ->  Irrational  x

 {  x :   ℝ  ℝ } ->  (  hx :  x ∈  ℤ ) ->  ¬  Irrational  x

{x : ℝ} (hx : ∃ (m : ℤ), x = m) : irrational x → false 

failed to elaborate

outputs: #[{x : ℤ} : ¬irrational x ,  : ∀ (z : ℤ), irrational z , {n : ℤ} : irrational n , {x : ℝ} (hxirr : irrational x) (hxint : ¬(∃ (n : ℤ), x = ↑n)) : false , {m : ℤ} (hm : m ≠ 0) : ¬irrational (↑m : ℝ) , {x : ℝ} : irrational x → ¬∃ (m : ℤ), x = m , (z : ℤ) : irrational z , {x : ℝ} : ∀ (y : ℤ), x = ↑y → irrational x , {x : ℝ} (hxr : x ∈ ℤ) : ¬irrational x , {x : ℝ} : x.nat_abs.irrational ↔ x ∉ set.range (coe : ℤ → ℝ) , {x : ℤ} : irrational x → false , {z : ℤ} : irrational z ,  : ∀ (x : ℤ), ¬irrational (↑x : ℝ) , (x : ℤ) : irrational x , {x : ℝ} (hx : x ∈ ℤ) : ¬ irrational x , {x : ℝ} (hx : ∃ (m : ℤ), x = m) : irrational x → false ]

total : 18

elaborated: 17

The identity element in a ring is a unit.

success

theorem ∀ {X : Type u_1} [inst : Ringₓ X], IsUnit 1

total : 19

elaborated: 18

Every subgroup of a group is a group.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Group  s.carrier

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Group  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Group  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  h :  Subgroup  α ) ->  Group   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  h :  Subgroup  α ) ->  Groupₓ   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  h :  Subgroup  α ) ->  Groupₓₓ   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  h :  Subgroup  α ) ->  Group   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  h :  Subgroup  α ) ->  Groupₓ   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  h :  Subgroup  α ) ->  Groupₓₓ   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  h :  Subgroup  α ) ->  Group   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  h :  Subgroup  α ) ->  Groupₓ   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  h :  Subgroup  α ) ->  Groupₓₓ   (  Subtype.val   :  h.carrier → α )

failed to elaborate

outputs: #[{G : Type u_1} [group G] {H : subgroup G} : group H , {α : Type u_1} [group α] (s : subgroup α) : group s , {α : Type u_1} [group α] {s : subgroup α} : group s , {α : Type u_1} [group α] (s : set α) (hs : is_submonoid s) : is_group s , {G : Type u_1} [group G] (H : subgroup G) : group H , {α : Type u} [group α] {s : set α} (hs : is_subgroup s) : group s , {α : Type u} [group α] {s : set α} (ssubg : is_subgroup s) : group s , {G : Type u_1} [group G] (s : set G) [is_subgroup s] : group s , {α : Type u_1} [group α] (s : subgroup α) : group s.carrier , {α : Type u_1} [group α] (s : set α) (hs : is_subgroup s) : group s , {G : Type u_1} [group G] {H : subgroup G} : @group G (↑H : set G) , {G : Type u} [group G] (H : subgroup G) : group H , {α : Type u_1} [group α] (h : subgroup α) : is_group (subtype.val : h.carrier → α) ]

total : 20

elaborated: 18

The sum of two natural numbers is a natural number.

success

theorem ∀ {m n : ℕ}, m ≥ 0 → n ≥ 0 → m + n ≥ 0

total : 21

elaborated: 19

The identity element of a group has finite order.

success

theorem ∀ {G : Type u} [inst : Groupₓ G], IsOfFinOrder 1

total : 22

elaborated: 20

`7` is a prime number.

success

theorem ∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ p = 3 ∨ p = 5 ∨ p = 7

total : 23

elaborated: 21

There are `3` prime numbers below `8`.

success

theorem ∃ p q r, Prime p ∧ Prime q ∧ Prime r ∧ p < 8 ∧ q < 8 ∧ r < 8

total : 24

elaborated: 22

The empty set is contained in every finite set.

success

theorem ∀ {α : Type u} [inst : DecidableEq α] (s : Finset α), ∅ ⊂ s

total : 25

elaborated: 23

Every infinite set contains a finite set.

No valid output from Codex; outputs below

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α ) ,    t ⊂ s  tt ⊂ s  tt ⊂ s  t ⊂ s  t ⊂ s ∧ t.finite

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,    t ⊂ s  tt ⊂ s  tt ⊂ s  t ⊂ s  t ⊂ s ∧ t.finite

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α ) ,    t ⊂ s  tt ⊂ s  tt ⊂ s  t ⊂ s  t ⊂ s ∧ t.finite

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,    t ⊂ s  tt ⊂ s  tt ⊂ s  t ⊂ s  t ⊂ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α )  (   h :  Finite  t ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   h :  Finite  t ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α )  (   h :  Finite  t ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   h :  Finite  t ) ,  t ⊆ s

 {  α :  Type  w } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,   t ⊆ s ∧ t.finite

 {  α :  Type  w } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,   t ⊆ s ∧ t.finite

 {  α :  Type  w } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,   t ⊆ s ∧ t.finite

 {  α :  Type  w } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃     t  :  Set  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃     t  :  Setₓ  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃     t  :  Set  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃     t  :  Setₓ  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  s.infinite →  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  s.infinite →  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  s.infinite →  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  s.infinite →  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  s.infinite →  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  s.infinite →  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  s.infinite →  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  s.infinite →  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  i : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  i : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

 {  α :  Type* } ->  {  f :  Set  α } ->  (  hf' : f.infinite ) ->  ∃    (   f' :  Finset  α ) ,  ∀  x  ,   x ∈ f' →  x ∈ f

 {  α :  Type* } ->  {  f :  Setₓ  α } ->  (  hf' : f.infinite ) ->  ∃    (   f' :  Finset  α ) ,  ∀  x  ,   x ∈ f' →  x ∈ f

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

{α : Type u} (s : set α) (h : s.infinite) : ∃ (t : set α) (h : s ⊆ t ∧ t.finite), true 

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h :  ∃    (   t :  Set  α ) ,  t.finite ∧  s ⊆ t ) -> s.infinite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h :  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  s ⊆ t ) -> s.infinite

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h :  ∃    (   t :  Set  α ) ,  t.finite ∧  s ⊆ t ) -> s.infinite

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h :  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  s ⊆ t ) -> s.infinite

 {  α :  Type  } ->  [  DecidableEq  α ] ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃    (   f :  Finset  α ) ,  f.infinite_to_finite  s

 {  α :  Type  } ->  [  DecidableEq  α ] ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃    (   f :  Finset  α ) ,  f.infinite_to_finite  s

 {  α :  Type  u_1 } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->   s ∩   (   range  finset.card  ) . powerset.nonempty.to_set.finite.to_set ≠  ∅

 {  α :  Type  u_1 } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->   s ∩   (   range  finset.card  ) . powerset.nonempty.to_set.finite.to_set ≠  ∅

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  s ⊆ t

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  s ⊆ t

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  s ⊆ t

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  s ⊆ t

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

failed to elaborate

outputs: #[{α : Type u} {s : set α} (hs : s.infinite) : ∃ (t : set α), t ⊂ s ∧ t.finite , {α : Type u} (s : set α) (h : s.infinite) : ∃ t : set α, t.finite ∧ t ⊆ s , {α : Type u} {s : set α} (h : s.infinite) : ∃ (t : set α) (h : finite t), t ⊆ s , {α : Type w} (s : set α) (h : s.infinite) : ∃ t : set α, t ⊆ s ∧ t.finite , {α : Type u} {s : set α} (hs : s.infinite) : ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type u} (s : set α) (hs : s.infinite) : ∃ t : set α, finite t ∧ t ⊆ s , {α : Type u} {s : set α} : s.infinite → ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type u} (s : set α) : s.infinite → ∃ t : set α, t.finite ∧ t ⊆ s , {α : Type u} (s : set α) (i : s.infinite) : ∃ (t : finset α), t ⊆ s , {α : Type*} {f : set α} (hf' : f.infinite) : ∃ (f' : finset α), ∀ x, x ∈ f' → x ∈ f , {α : Type u} (s : set α) (h_inf : s.infinite) : ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : set α) (h : s ⊆ t ∧ t.finite), true , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : set α), t ⊆ s ∧ t.finite , {α : Type u} (s : set α) (h : ∃ (t : set α), t.finite ∧ s ⊆ t) : s.infinite , {α : Type} [decidable_eq α] (s : set α) (hs : s.infinite) :  ∃ (f : finset α), f.infinite_to_finite s , {α : Type u_1} (s : set α) (h : s.infinite) : s ∩ (range finset.card).powerset.nonempty.to_set.finite.to_set ≠ ∅ , {α : Type u} {s : set α} (h : s.infinite) : ∃ t : set α, finite t ∧ t ⊆ s , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : set α), t.finite ∧ s ⊆ t , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : finset α), t ⊆ s ]

total : 26

elaborated: 23

Every commutative ring is a monoid.

success

theorem {α : Type u} → [inst : CommRing α] → CommMonoid α

total : 27

elaborated: 24

There is no field of order `10`.

success

theorem ∀ (n : ℕ), n ≠ 2 → n ≠ 5 → Fintype.card (Finₓ n) ≠ 10

total : 28

elaborated: 25

Every odd natural number is the sum of two distinct natural numbers.

success

theorem ∀ {n : ℕ}, Odd n → ∃ m k, k ≠ m ∧ k + m = n

total : 29

elaborated: 26

Every element in the trivial group has finite order.

success

theorem ∀ (G : Type u_1) [inst : Groupₓ G], IsOfFinOrder 1

total : 30

elaborated: 27

The square of an even number is even.

success

theorem ∀ {n : ℕ}, Even n → Even (n * n)

total : 31

elaborated: 28

Every commutative division ring is a field.

success

theorem ∀ (K : Type u) [inst : CommGroup K] [inst : Semiring K] [inst : Monoid K] [inst : DivisionRing K], IsField K

total : 32

elaborated: 29

The image of the identity element under the identity map is the identity element.

success

theorem ∀ {α : Type u} [inst : Group α] (a : α), id a = a

total : 33

elaborated: 30

Every point is a fixed point of the identity function on a space.

success

theorem ∀ {α : Type u} (a : α), Function.IsFixedPt id a

total : 34

elaborated: 31

The diameter of a singleton space is `0`.

success

theorem ∀ {α : Type u} [inst : PseudoMetricSpace α] (a : α), Metric.diam (?m.2691279 a) = 0

total : 35

elaborated: 32

Every group is non-empty.

success

theorem ∀ {α : Type u} [inst : Group α], Nonempty α

total : 36

elaborated: 33

All connected components of a topological space are connected.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] {x : α}, IsConnected (ConnectedComponent x)

total : 37

elaborated: 34

The ring of integers has a maximal ideal.

success

theorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ringₓ B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B}
  (hx : IsIntegral A x), ∃ p, ?m.2769709 hx p

total : 38

elaborated: 35

The numbers `3`, `4` and `5` form a Pythagorean triple.

success

theorem PythagoreanTriple 3 4 5

total : 39

elaborated: 36

A vector space with the empty set as basis is trivial. 

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Basis Empty K V → Nontrivial V

total : 40

elaborated: 37

Writing to file: thm-elab-12-8-false-20-8.json

If every proper closed set of a topological space is compact, then the space itself is compact.

success

theorem ∀ {X : Type u} [inst : TopologicalSpace X] {P : Set (Set X)} (h : ∀ (C : Set X), C ∈ P → IsClosed C)
  (hp : ∀ (C : Set X), IsCompact C ∨ C ∈ P), IsCompact (?m.77360 h hp)

total : 1

elaborated: 1

Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, p = a * a + b * b

total : 2

elaborated: 2

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

success

theorem ∀ {a b : ℕ},
  (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →
    (∃ x y z w, b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) → ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2

total : 3

elaborated: 3

A ring with all elements idempotent is commutative.

success

theorem ∀ {R : Type u_1} [inst : Ring R], CommRing R → (∀ {a : R}, a * a = a) → ∀ {a b : R}, a * b = b * a

total : 4

elaborated: 4

There are infinitely many pairs of primes that differ exactly by `2`.

success

theorem ∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p + 2 = q ∧ q ≤ n

total : 5

elaborated: 5

Every finite division ring is a field.

success

theorem ∀ (K : Type u) [inst : Fintype K] [inst : DivisionRing K], IsField K

total : 6

elaborated: 6

If each of two types can be mapped injectively into the other, then there is a bijection between them.

success

theorem ∀ {α : Type u_1} {β : Type u_2}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → ∃ h, Function.bijective h

total : 7

elaborated: 7

A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.

No valid output from Codex; outputs below

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  (  hG :  ∀   (  v w  : V  )  ,   G.degree  v =  G.degree  w ) ->  (  H :  ∀   (  v w  : V  )  ,   G.degree   (   G.common_neighbours  v w  ) =  1 ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  (  hG :  ∀   (  v w  : V  )  ,   G.degree  v =  G.degree  w ) ->  (  H :  ∀   (  v w  : V  )  ,   G.degree   (   G.common_neighbours  v w  ) =  1 ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,  G.adj  v w

{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (hp : ∀ (v₁ v₂ : V), G.degree v₁ = G.degree v₂ → ∃ (w : V), (v₁, w) ∈ G.adj ∧ (v₂, w) ∈ G.adj ∧ ∀ (z : V), (v₁, z) ∈ G.adj ∧ (v₂, z) ∈ G.adj → z = w) : ∃ (w : V), ∀ (

 (  G :  SimpleGraph   ℕ ) ->  [  Fintype   ℕ ] ->  [  DecidableRel  G.adj ] ->  (  hG :  ∀   (  x y  :  ℕ  )  ,   Fintype.card   (   G.common_neighbours  x y  ) =  1 ) ->  ∃    (   x :  ℕ ) ,   G.degree  x =   Fintype.card   ℕ -  1

 (  G :  SimpleGraph   ℕ ) ->  [  Fintypeₓ   ℕ ] ->  [  DecidableRel  G.adj ] ->  (  hG :  ∀   (  x y  :  ℕ  )  ,   Fintype.card   (   G.common_neighbours  x y  ) =  1 ) ->  ∃    (   x :  ℕ ) ,   G.degree  x =   Fintype.card   ℕ -  1

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  (  h :  ∀   (  v w  : V  )  ,   G.adj  v w ↔  ∃    (   z : V ) ,   G.adj  v z ∧  G.adj  w z ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   v ≠ w →  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  (  h :  ∀   (  v w  : V  )  ,   G.adj  v w ↔  ∃    (   z : V ) ,   G.adj  v z ∧  G.adj  w z ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   v ≠ w →  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  [  Fintype   (   V →  Prop  ) ] ->  (  H :  ∀   (  v₁ v₂  : V  )  ,   v₁ ≠ v₂ →   finite.card   (   G.common_neighbours  v₁ v₂  ) =  1 ) ->  ∃    (   v₀ : V ) ,  ∀   (  v  : V  )  ,   v ≠ v₀ →  G.adj  v₀ v

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  [  Fintypeₓ   (   V →  Prop  ) ] ->  (  H :  ∀   (  v₁ v₂  : V  )  ,   v₁ ≠ v₂ →   finite.card   (   G.common_neighbours  v₁ v₂  ) =  1 ) ->  ∃    (   v₀ : V ) ,  ∀   (  v  : V  )  ,   v ≠ v₀ →  G.adj  v₀ v

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  [  Fintype   (   V →  Prop  ) ] ->  (  H :  ∀   (  v₁ v₂  : V  )  ,   v₁ ≠ v₂ →   finite.card   (   G.common_neighbours  v₁ v₂  ) =  1 ) ->  ∃    (   v₀ : V ) ,  ∀   (  v  : V  )  ,   v ≠ v₀ →  G.adj  v₀ v

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  [  Fintypeₓ   (   V →  Prop  ) ] ->  (  H :  ∀   (  v₁ v₂  : V  )  ,   v₁ ≠ v₂ →   finite.card   (   G.common_neighbours  v₁ v₂  ) =  1 ) ->  ∃    (   v₀ : V ) ,  ∀   (  v  : V  )  ,   v ≠ v₀ →  G.adj  v₀ v

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  (  h :  ∀   (  v w  : V  )  ,   Fintype.card   {   x   : V |   G.adj  v x ∧  G.adj  w x } =  1 ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   v ≠ w →  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  (  h :  ∀   (  v w  : V  )  ,   Fintype.card   {   x   : V |   G.adj  v x ∧  G.adj  w x } =  1 ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   v ≠ w →  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  (  H :  ∀   (  v₁ v₂  : V  )  ,   Fintype.card   {   v   : V |   G.adj  v₁ v ∧  G.adj  v₂ v } =  1 ) ->  [  Nonempty  V ] ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   w ≠ v →  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  (  H :  ∀   (  v₁ v₂  : V  )  ,   Fintype.card   {   v   : V |   G.adj  v₁ v ∧  G.adj  v₂ v } =  1 ) ->  [  Nonempty  V ] ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   w ≠ v →  G.adj  v w

 {  V :  Type  u } ->  [  Fintype  V ] ->  (  G :  SimpleGraph  V ) ->  [  DecidableRel  G.adj ] ->  (  hG :  ∀   (  v  : V  )  ,   G.degree  v =  card   (   G.neighbourhood  v  ) ) ->  (  H :  ∀   (  u v  : V  )  ,   G.degree   (   G.common_neighbourhood  u v  ) =  1 ) ->  ∃    (   v : V ) ,   G.degree  v =   card   (   G.neighbourhood  v  ) -  1

 {  V :  Type  u } ->  [  Fintypeₓ  V ] ->  (  G :  SimpleGraph  V ) ->  [  DecidableRel  G.adj ] ->  (  hG :  ∀   (  v  : V  )  ,   G.degree  v =  card   (   G.neighbourhood  v  ) ) ->  (  H :  ∀   (  u v  : V  )  ,   G.degree   (   G.common_neighbourhood  u v  ) =  1 ) ->  ∃    (   v : V ) ,   G.degree  v =   card   (   G.neighbourhood  v  ) -  1

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  DecidableRel  G.adj ] ->  [  Fintype  V ] ->  (  h :  ∀   (  u v  : V  )  ,  ∀   (  w  : V  )  ,    G.adj  w u ∧  G.adj  w v ↔   w = u ∨  w = v ) ->  ∃    (   x : V ) ,  ∀   (  v  : V  )  ,   (   x ≠ v  ) →  G.adj  x v

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  DecidableRel  G.adj ] ->  [  Fintypeₓ  V ] ->  (  h :  ∀   (  u v  : V  )  ,  ∀   (  w  : V  )  ,    G.adj  w u ∧  G.adj  w v ↔   w = u ∨  w = v ) ->  ∃    (   x : V ) ,  ∀   (  v  : V  )  ,   (   x ≠ v  ) →  G.adj  x v

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->   G.min_degree ≥  2 →  ∃    (   v : V ) ,  ∀   (  u  : V  )  ,   u ≠ v →  G.adj  u v

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->   G.min_degree ≥  2 →  ∃    (   v : V ) ,  ∀   (  u  : V  )  ,   u ≠ v →  G.adj  u v

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  [  Nonempty  V ] ->  [  DecidableEq  V ] ->  (  h :  ∀   (  u v  : V  )  ,   G.adj  u v →   G.degree  u =  G.degree  v ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  [  Nonempty  V ] ->  [  DecidableEq  V ] ->  (  h :  ∀   (  u v  : V  )  ,   G.adj  u v →   G.degree  u =  G.degree  v ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  (  h :  ∀   (  x y  : V  )  ,   card  G.common_neighbours x y =  1 ) ->  ∃    (   x : V ) ,  ∀   (  y  : V  )  ,   x ≠ y →  y ∈  G.neighbourhood  x

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  (  h :  ∀   (  x y  : V  )  ,   card  G.common_neighbours x y =  1 ) ->  ∃    (   x : V ) ,  ∀   (  y  : V  )  ,   x ≠ y →  y ∈  G.neighbourhood  x

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  (  h :  ∀  v w   : V ,     G.degree  v =  1 ∧   G.degree  w =  1 →   G.common_neighbours  v w.val =  (   ⊤   :  Finset  V ) ) ->  ∃     v  : V ,  ∀  w   : V ,   w ≠ v →  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  (  h :  ∀  v w   : V ,     G.degree  v =  1 ∧   G.degree  w =  1 →   G.common_neighbours  v w.val =  (   ⊤   :  Finset  V ) ) ->  ∃     v  : V ,  ∀  w   : V ,   w ≠ v →  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  (  h :  ∀   (  v₁ v₂  : V  )  ,   Fintype.card   (   v₁.common_neighbours  v₂  ) =  1 ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   v ≠ w →  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  (  h :  ∀   (  v₁ v₂  : V  )  ,   Fintype.card   (   v₁.common_neighbours  v₂  ) =  1 ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   v ≠ w →  G.adj  v w

 {  V :  Type  u_1 } ->  [  DecidableEq  V ] ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  (  h :  ∀   {  x y  }  ,   x ≠ y →    G.degree  x =  1 ∨   G.degree  y =  1 ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   w ≠ v →  G.adj  v w

 {  V :  Type  u_1 } ->  [  DecidableEq  V ] ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  (  h :  ∀   {  x y  }  ,   x ≠ y →    G.degree  x =  1 ∨   G.degree  y =  1 ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   w ≠ v →  G.adj  v w

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  (  hf :   Fintype.card  V <   ∞  ∞  ∞ ) ->  (  hd :  ∀   (  v₁ v₂  : V  )  ,     G.degree  v₁ ≤  1 ∧   G.degree  v₂ ≤  1 →   G.degree   (   G.common_neighbour  v₁ v₂  ) ≤  1 ) ->  Nonempty  V

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  (  hG :   ∀   (  v₁ v₂ v₃  : V  )  ,   G.adj  v₁ v₂ ↔  G.adj  v₁ v₃ ↔  G.adj  v₂ v₃ ) ->  (  hG' :  ∀   (  v₁ v₂  : V  )  ,  ¬  (   G.adj  v₁ v₂  ) ) ->  ∃    (   v : V ) ,  ∀   (  x  : V  )  ,  G.adj  v x

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  (  hG :   ∀   (  v₁ v₂ v₃  : V  )  ,   G.adj  v₁ v₂ ↔  G.adj  v₁ v₃ ↔  G.adj  v₂ v₃ ) ->  (  hG' :  ∀   (  v₁ v₂  : V  )  ,  ¬  (   G.adj  v₁ v₂  ) ) ->  ∃    (   v : V ) ,  ∀   (  x  : V  )  ,  G.adj  v x

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  [  Nonempty  V ] ->  (  H :  ∀   (  a b   )  ,   card   (   G.common_neighbours  a b  ) =  1 ) -> G.has_universal

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  [  Nonempty  V ] ->  (  H :  ∀   (  a b   )  ,   card   (   G.common_neighbours  a b  ) =  1 ) -> G.has_universal

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintype  V ] ->  [  DecidableRel  G.adj ] ->  (  H :  ∀   (  u v  : V  )  ,   card   (     G.neighbourhood  u ⊓  G.neighbourhood  v   G.neighbourhood  u ⊓  G.neighbourhood  v  ) =  1 ) ->  ∃    (   u : V ) ,  ∀   (  v  : V  )  ,   u ≠ v →  u.adj  v

 {  V :  Type  u } ->  (  G :  SimpleGraph  V ) ->  [  Fintypeₓ  V ] ->  [  DecidableRel  G.adj ] ->  (  H :  ∀   (  u v  : V  )  ,   card   (     G.neighbourhood  u ⊓  G.neighbourhood  v   G.neighbourhood  u ⊓  G.neighbourhood  v  ) =  1 ) ->  ∃    (   u : V ) ,  ∀   (  v  : V  )  ,   u ≠ v →  u.adj  v

 {  V :  Type  u } ->  [  Fintype  V ] ->  {  G :  SimpleGraph  V } ->  [  DecidableRel  G.adj ] ->  (  hdeg :  ∀   (  v w  : V  )  ,   set.card   {   u  |   G.adj  u v ∧  G.adj  u w } =  1 ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   (    w ≠ v →  G.adj  v w  ) ∧  (    w = v →  ¬  G.adj  v w  )

 {  V :  Type  u } ->  [  Fintypeₓ  V ] ->  {  G :  SimpleGraph  V } ->  [  DecidableRel  G.adj ] ->  (  hdeg :  ∀   (  v w  : V  )  ,   set.card   {   u  |   G.adj  u v ∧  G.adj  u w } =  1 ) ->  ∃    (   v : V ) ,  ∀   (  w  : V  )  ,   (    w ≠ v →  G.adj  v w  ) ∧  (    w = v →  ¬  G.adj  v w  )

failed to elaborate

outputs: #[{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (hG : ∀ (v w : V), G.degree v = G.degree w) (H : ∀ (v w : V), G.degree (G.common_neighbours v w) = 1) : ∃ (v : V), ∀ (w : V), G.adj v w , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (hp : ∀ (v₁ v₂ : V), G.degree v₁ = G.degree v₂ → ∃ (w : V), (v₁, w) ∈ G.adj ∧ (v₂, w) ∈ G.adj ∧ ∀ (z : V), (v₁, z) ∈ G.adj ∧ (v₂, z) ∈ G.adj → z = w) : ∃ (w : V), ∀ (, (G : simple_graph ℕ) [fintype ℕ] [decidable_rel G.adj] (hG : ∀ (x y : ℕ), fintype.card (G.common_neighbours x y) = 1) : ∃ (x : ℕ), G.degree x = fintype.card ℕ - 1 , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (h : ∀ (v w : V), G.adj v w ↔ ∃ (z : V), G.adj v z ∧ G.adj w z) : ∃ (v : V), ∀ (w : V), v ≠ w → G.adj v w , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [fintype (V → Prop)] (H : ∀ (v₁ v₂ : V), v₁ ≠ v₂ → finite.card (G.common_neighbours v₁ v₂) = 1) : ∃ (v₀ : V), ∀ (v : V), v ≠ v₀ → G.adj v₀ v , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (h : ∀ (v w : V), fintype.card {x : V | G.adj v x ∧ G.adj w x} = 1) : ∃ (v : V), ∀ (w : V), v ≠ w → G.adj v w , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (H : ∀ (v₁ v₂ : V), fintype.card {v : V | G.adj v₁ v ∧ G.adj v₂ v} = 1) [nonempty V] : ∃ (v : V), ∀ (w : V), w ≠ v → G.adj v w , {V : Type u} [fintype V] (G : simple_graph V) [decidable_rel G.adj] (hG : ∀ (v : V), G.degree v = card (G.neighbourhood v)) (H : ∀ (u v : V), G.degree (G.common_neighbourhood u v) = 1) : ∃ (v : V), G.degree v = card (G.neighbourhood v) - 1 , {V : Type u} (G : simple_graph V) [decidable_rel G.adj] [fintype V] (h : ∀ (u v : V), ∀ (w : V), G.adj w u ∧ G.adj w v ↔ w = u ∨ w = v) : ∃ (x : V), ∀ (v : V), (x ≠ v) → G.adj x v , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] : G.min_degree ≥ 2 → ∃ (v : V), ∀ (u : V), u ≠ v → G.adj u v , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] [decidable_eq V] (h : ∀ (u v : V), G.adj u v → G.degree u = G.degree v) : ∃ (v : V), ∀ (w : V), G.adj v w , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (h : ∀ (x y : V), card G.common_neighbours x y = 1) : ∃ (x : V), ∀ (y : V), x ≠ y → y ∈ G.neighbourhood x , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (h : ∀ v w : V, G.degree v = 1 ∧ G.degree w = 1 → G.common_neighbours v w.val = (⊤ : finset V)) : ∃ v : V, ∀ w : V, w ≠ v → G.adj v w , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (h : ∀ (v₁ v₂ : V), fintype.card (v₁.common_neighbours v₂) = 1) : ∃ (v : V), ∀ (w : V), v ≠ w → G.adj v w , {V : Type u_1} [decidable_eq V] (G : simple_graph V) [fintype V] (h : ∀ {x y}, x ≠ y → G.degree x = 1 ∨ G.degree y = 1) : ∃ (v : V), ∀ (w : V), w ≠ v → G.adj v w , {V : Type u} (G : simple_graph V) (hf : fintype.card V < ∞) (hd : ∀ (v₁ v₂ : V), G.degree v₁ ≤ 1 ∧ G.degree v₂ ≤ 1 → G.degree (G.common_neighbour v₁ v₂) ≤ 1): nonempty V , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (hG : ∀ (v₁ v₂ v₃ : V), G.adj v₁ v₂ ↔ G.adj v₁ v₃ ↔ G.adj v₂ v₃) (hG' : ∀ (v₁ v₂ : V), ¬(G.adj v₁ v₂)) : ∃ (v : V), ∀ (x : V), G.adj v x , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] (H : ∀ (a b), card (G.common_neighbours a b) = 1) : G.has_universal , {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (H : ∀ (u v : V), card (G.neighbourhood u ⊓ G.neighbourhood v) = 1) : ∃ (u : V), ∀ (v : V), u ≠ v → u.adj v , {V : Type u} [fintype V] {G : simple_graph V} [decidable_rel G.adj] (hdeg : ∀ (v w : V), set.card {u | G.adj u v ∧ G.adj u w} = 1) : ∃ (v : V), ∀ (w : V), (w ≠ v → G.adj v w) ∧ (w = v → ¬G.adj v w) ]

total : 8

elaborated: 7

The number of partitions with odd parts is equal to the number of partitions with distinct parts.

No valid output from Codex; outputs below

 (  n :  ℕ ) ->   partitions.restricted_compositions  n =  partitions.distinct_compositions  n

 (  n :  ℕ ) ->   nat.partitions  n =  nat.partitions_with_distinct_odd_parts  n

 (  n :  ℕ ) ->   partition.number_of_partitions_with_odd_parts  n =  partition.number_of_partitions_with_distinct_parts  n

 (  n :  ℕ ) ->   partitions.odd  n =  partitions.distinct  n

 (  n :  ℕ ) ->   partitions.filter   (   λ p : partition ,   p.parts.to_multiset.card %  2 =  1  ) n =  partitions.distinct  n

 {  n :  ℕ } ->   partition.odd_part  n =  partition.distinct  n

 (  n :  ℕ ) ->   partition.count_by_distinct   (   partition.odd  n  ) =  partition.count_by_distinct   (   partition.noduplicate  n  )

{n : ℕ} : ∑ (p : partition (2*n+1)) ((2*n+1).has_odd_partition p), p.card = ∑ (p : partition (2*n+1)) ((2*n+1).has_distinct_partition p), p.card 

 (  n :  ℕ ) ->   partition.odd  n =  partition.distinct  n

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  (  s :  Finset  α ) ->  s.multiset.partitions_with_odd_parts.card = s.multiset.distinct_partitions.card

 ∀   (  n  :  ℕ  )  ,   nnpart  n =  nnrdistpart  n

 (  n :  ℕ ) ->    (   partition.setoid  n  ) . card =  partition.setoid.distinct_odd  n

 {  n :  ℕ } ->  (  h :   0 < n ) ->   partition.fintype.card_odd_parts  n =  partition.fintype.card_distinct_parts  n

 (  n :  ℕ ) ->   partitions.nat  n ~>  partitions.odd  n

: Σ' (λ p : partition_on ℕ, p.odd_part = p) =
  Σ' (λ q : partition_on ℕ, q.distinct_part) 

 (  n :  ℕ ) ->    (   partitions.of_nat  n  ) . odd_parts.card =   (   partitions.of_nat  n  ) . distinct_parts.card

 (  n :  ℕ ) ->   partitions.card   ⟨  n , partitions.nat.parts_gt_1 ⟩ =  partitions.card   ⟨  n , partitions.nat.parts_distinct ⟩

 ∀   (  n  :  ℕ  )  ,   (   ∑     (   p   :  partition   (   n +  1  ) ) ,    (  p   :  Multiset   ℕ ) . card =  1  ) =  (   ∑     (   p   :  partition   (   n +  1  ) ) ,    (  p.odd_parts   :  Multiset   ℕ ) . card =  1  )

 {  k :  ℕ } ->    (   partitions.odd_parts  k  ) . card =   (   partitions.distinct_parts  k  ) . card

 (  n :  ℕ ) ->   card   (   partition.odd  n  ) =  card   (   partition.distinct  n  )

failed to elaborate

outputs: #[(n : ℕ) : partitions.restricted_compositions n = partitions.distinct_compositions n , (n : ℕ) : nat.partitions n = nat.partitions_with_distinct_odd_parts n , (n : ℕ) : partition.number_of_partitions_with_odd_parts n = partition.number_of_partitions_with_distinct_parts n , (n : ℕ) : partitions.odd n = partitions.distinct n , (n : ℕ) : partitions.filter (λ p : partition, p.parts.to_multiset.card % 2 = 1) n = partitions.distinct n , {n : ℕ} : partition.odd_part n = partition.distinct n , (n : ℕ) : partition.count_by_distinct (partition.odd n) = partition.count_by_distinct (partition.noduplicate n) , {n : ℕ} : ∑ (p : partition (2*n+1)) ((2*n+1).has_odd_partition p), p.card = ∑ (p : partition (2*n+1)) ((2*n+1).has_distinct_partition p), p.card , (n : ℕ) : partition.odd n = partition.distinct n , {α : Type u_1} [decidable_eq α] (s : finset α) : s.multiset.partitions_with_odd_parts.card = s.multiset.distinct_partitions.card , : ∀ (n : ℕ), nnpart n = nnrdistpart n , (n : ℕ) : (partition.setoid n).card = partition.setoid.distinct_odd n , {n : ℕ} (h : 0 < n) : partition.fintype.card_odd_parts n = partition.fintype.card_distinct_parts n , (n : ℕ) : partitions.nat n ~> partitions.odd n , : Σ' (λ p : partition_on ℕ, p.odd_part = p) =
  Σ' (λ q : partition_on ℕ, q.distinct_part) , (n : ℕ) : (partitions.of_nat n).odd_parts.card = (partitions.of_nat n).distinct_parts.card , (n : ℕ) : partitions.card ⟨n, partitions.nat.parts_gt_1⟩ = partitions.card ⟨n, partitions.nat.parts_distinct⟩ , : ∀ (n : ℕ), (∑  (p : partition (n + 1)), (p : multiset ℕ).card = 1) = (∑  (p : partition (n + 1)), (p.odd_parts : multiset ℕ).card = 1) , {k : ℕ} : (partitions.odd_parts k).card = (partitions.distinct_parts k).card , (n : ℕ) : card (partition.odd n) = card (partition.distinct n) ]

total : 9

elaborated: 7

Every non-empty poset in which every chain has an upper bound contains a maximal element.

success

theorem ∀ {α : Type u_1} {r : α → α → Prop},
  (∀ (c : Set α) (a : IsChain r c), ∃ ub, ∀ (a : α), a ∈ c → r a ub) → Nonempty α → ∃ m, ∀ (a : α), r m a → r a m

total : 10

elaborated: 8

A group whose automorphism group is cyclic is Abelian.

No valid output from Codex; outputs below

 {  G :  Type  u } ->  [  Group  G ] ->  (  h_cyclic :  IsCyclic   (   group_aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  h_cyclic :  IsCyclic   (   group_aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  h_cyclic :  IsCyclic   (   group_aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  CommGroup  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  CommGroupₓ  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  CommGroupₓₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  CommGroup  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  CommGroupₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  CommGroupₓₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  CommGroup  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  CommGroupₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  CommGroupₓₓ  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  n :  ℕ } ->  (  hn :  IsCyclic   (   group_aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  n :  ℕ } ->  (  hn :  IsCyclic   (   group_aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  n :  ℕ } ->  (  hn :  IsCyclic   (   group_aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  {  H :  Type  w } ->  [  Group  H ] ->  (  f :  G ≃o H ) ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  {  H :  Type  w } ->  [  Groupₓ  H ] ->  (  f :  G ≃o H ) ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  {  H :  Type  w } ->  [  Groupₓₓ  H ] ->  (  f :  G ≃o H ) ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  H :  Type  w } ->  [  Group  H ] ->  (  f :  G ≃o H ) ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  H :  Type  w } ->  [  Groupₓ  H ] ->  (  f :  G ≃o H ) ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  H :  Type  w } ->  [  Groupₓₓ  H ] ->  (  f :  G ≃o H ) ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  H :  Type  w } ->  [  Group  H ] ->  (  f :  G ≃o H ) ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  H :  Type  w } ->  [  Groupₓ  H ] ->  (  f :  G ≃o H ) ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  H :  Type  w } ->  [  Groupₓₓ  H ] ->  (  f :  G ≃o H ) ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  (  h :  IsCyclic  group_aut G ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  h :  IsCyclic  group_aut G ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  h :  IsCyclic  group_aut G ) ->  is_abelian  G

 {  G :  Type  u_2 } ->  [  Group  G ] ->  (  h :  ∀   (  n  :  ℕ  )  ,   n ≠  0 →  ∀   (  H  :  groups.finset   (   perm  G  )  )  ,   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   H ≠  ∅ →    groups.finset.card  H = n →  ∃    (   x : H ) ,  H =  {   y  |  ∃    (   m :  ℕ ) ,  y =  Pow  x m } ) ->  CommGroup  G

 {  G :  Type  u_2 } ->  [  Group  G ] ->  (  h :  ∀   (  n  :  ℕ  )  ,   n ≠  0 →  ∀   (  H  :  groups.finset   (   perm  G  )  )  ,   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   H ≠  ∅ →    groups.finset.card  H = n →  ∃    (   x : H ) ,  H =  {   y  |  ∃    (   m :  ℕ ) ,  y =  Pow  x m } ) ->  CommGroupₓ  G

 {  G :  Type  u_2 } ->  [  Group  G ] ->  (  h :  ∀   (  n  :  ℕ  )  ,   n ≠  0 →  ∀   (  H  :  groups.finset   (   perm  G  )  )  ,   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   H ≠  ∅ →    groups.finset.card  H = n →  ∃    (   x : H ) ,  H =  {   y  |  ∃    (   m :  ℕ ) ,  y =  Pow  x m } ) ->  CommGroupₓₓ  G

 {  G :  Type  u_2 } ->  [  Groupₓ  G ] ->  (  h :  ∀   (  n  :  ℕ  )  ,   n ≠  0 →  ∀   (  H  :  groups.finset   (   perm  G  )  )  ,   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   H ≠  ∅ →    groups.finset.card  H = n →  ∃    (   x : H ) ,  H =  {   y  |  ∃    (   m :  ℕ ) ,  y =  Pow  x m } ) ->  CommGroup  G

 {  G :  Type  u_2 } ->  [  Groupₓ  G ] ->  (  h :  ∀   (  n  :  ℕ  )  ,   n ≠  0 →  ∀   (  H  :  groups.finset   (   perm  G  )  )  ,   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   H ≠  ∅ →    groups.finset.card  H = n →  ∃    (   x : H ) ,  H =  {   y  |  ∃    (   m :  ℕ ) ,  y =  Pow  x m } ) ->  CommGroupₓ  G

 {  G :  Type  u_2 } ->  [  Groupₓ  G ] ->  (  h :  ∀   (  n  :  ℕ  )  ,   n ≠  0 →  ∀   (  H  :  groups.finset   (   perm  G  )  )  ,   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   H ≠  ∅ →    groups.finset.card  H = n →  ∃    (   x : H ) ,  H =  {   y  |  ∃    (   m :  ℕ ) ,  y =  Pow  x m } ) ->  CommGroupₓₓ  G

 {  G :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  (  h :  ∀   (  n  :  ℕ  )  ,   n ≠  0 →  ∀   (  H  :  groups.finset   (   perm  G  )  )  ,   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   H ≠  ∅ →    groups.finset.card  H = n →  ∃    (   x : H ) ,  H =  {   y  |  ∃    (   m :  ℕ ) ,  y =  Pow  x m } ) ->  CommGroup  G

 {  G :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  (  h :  ∀   (  n  :  ℕ  )  ,   n ≠  0 →  ∀   (  H  :  groups.finset   (   perm  G  )  )  ,   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   H ≠  ∅ →    groups.finset.card  H = n →  ∃    (   x : H ) ,  H =  {   y  |  ∃    (   m :  ℕ ) ,  y =  Pow  x m } ) ->  CommGroupₓ  G

 {  G :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  (  h :  ∀   (  n  :  ℕ  )  ,   n ≠  0 →  ∀   (  H  :  groups.finset   (   perm  G  )  )  ,   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   (   ∀   (  x  : H  )  ,  is_automorphism  x  ) →   H ≠  ∅ →    groups.finset.card  H = n →  ∃    (   x : H ) ,  H =  {   y  |  ∃    (   m :  ℕ ) ,  y =  Pow  x m } ) ->  CommGroupₓₓ  G

{G : Type u_1} [group G] [fintype G] (h : is_group_isomorphic (aut_group G) (ℤ/2ℤ)) : comm_group G 

 {  G :  Type  u } ->  [  Group  G ] ->  (  H :  IsCyclic   (   aut  G  ) ) ->  CommGroup  G

 {  G :  Type  u } ->  [  Group  G ] ->  (  H :  IsCyclic   (   aut  G  ) ) ->  CommGroupₓ  G

 {  G :  Type  u } ->  [  Group  G ] ->  (  H :  IsCyclic   (   aut  G  ) ) ->  CommGroupₓₓ  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  IsCyclic   (   aut  G  ) ) ->  CommGroup  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  IsCyclic   (   aut  G  ) ) ->  CommGroupₓ  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  IsCyclic   (   aut  G  ) ) ->  CommGroupₓₓ  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  H :  IsCyclic   (   aut  G  ) ) ->  CommGroup  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  H :  IsCyclic   (   aut  G  ) ) ->  CommGroupₓ  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  H :  IsCyclic   (   aut  G  ) ) ->  CommGroupₓₓ  G

 {  α :  Type  u } ->  [  Group  α ] ->  {  f :  α ≃ₜ α } ->   IsCyclic   (   automorphism_group  α  ) →  commutative_group  α

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  f :  α ≃ₜ α } ->   IsCyclic   (   automorphism_group  α  ) →  commutative_group  α

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  f :  α ≃ₜ α } ->   IsCyclic   (   automorphism_group  α  ) →  commutative_group  α

{α : Type u} [group α] {β} [group β] [fintype β] (h : Π (g h : β → β), (g ∘ h) ∈ automorphism_group β → g ∈ automorphism_group β → h ∈ automorphism_group β → g = h) : comm_group α 

 {  α :  Type  u_1 } ->  [  Group  α ] ->  [  Fintype   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroup  α

 {  α :  Type  u_1 } ->  [  Group  α ] ->  [  Fintype   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓ  α

 {  α :  Type  u_1 } ->  [  Group  α ] ->  [  Fintype   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓₓ  α

 {  α :  Type  u_1 } ->  [  Group  α ] ->  [  Fintypeₓ   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroup  α

 {  α :  Type  u_1 } ->  [  Group  α ] ->  [  Fintypeₓ   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓ  α

 {  α :  Type  u_1 } ->  [  Group  α ] ->  [  Fintypeₓ   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓₓ  α

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  [  Fintype   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroup  α

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  [  Fintype   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓ  α

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  [  Fintype   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓₓ  α

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  [  Fintypeₓ   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroup  α

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  [  Fintypeₓ   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓ  α

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  [  Fintypeₓ   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓₓ  α

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  [  Fintype   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroup  α

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  [  Fintype   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓ  α

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  [  Fintype   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓₓ  α

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  [  Fintypeₓ   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroup  α

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  [  Fintypeₓ   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓ  α

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  [  Fintypeₓ   (   group_aut  α  ) ] ->  {  n :  ℕ } ->  (  h :  IsCyclic   (   group_aut  α  ) n ) ->  CommGroupₓₓ  α

 {  G :  Type  u } ->  [  Group  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  h :  IsCyclic   (   automorphism_group  G  ) ) ->  is_abelian  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  h :  IsCyclic  group.automorphism_group G ) ->  is_abelian  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  h :  IsCyclic  group.automorphism_group G ) ->  is_abelian  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  h :  IsCyclic  group.automorphism_group G ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  [  is_cyclic_group   (   aut  G  ) ] ->  is_abelian_group  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  is_cyclic_group   (   aut  G  ) ] ->  is_abelian_group  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  [  is_cyclic_group   (   aut  G  ) ] ->  is_abelian_group  G

 (  G :  Type  u ) ->  [  Group  G ] ->  (  h :  ∃    (   n :  ℕ ) ,  ∀   (  f  :  G ≃* G  )  ,  n ∣  nat_degree  f ) ->  is_abelian_group  G

 (  G :  Type  u ) ->  [  Groupₓ  G ] ->  (  h :  ∃    (   n :  ℕ ) ,  ∀   (  f  :  G ≃* G  )  ,  n ∣  nat_degree  f ) ->  is_abelian_group  G

 (  G :  Type  u ) ->  [  Groupₓₓ  G ] ->  (  h :  ∃    (   n :  ℕ ) ,  ∀   (  f  :  G ≃* G  )  ,  n ∣  nat_degree  f ) ->  is_abelian_group  G

 {  G :  Type  u } ->  [  Group  G ] ->  [  Fintype   (   aut  G  ) ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  [  Fintypeₓ   (   aut  G  ) ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype   (   aut  G  ) ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintypeₓ   (   aut  G  ) ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  [  Fintype   (   aut  G  ) ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  [  Fintypeₓ   (   aut  G  ) ] ->  (  h :  IsCyclic   (   aut  G  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  [  Fintype   (   group_aut  G  ) ] ->   IsCyclic   (   group_aut  G  ) →  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  [  Fintypeₓ   (   group_aut  G  ) ] ->   IsCyclic   (   group_aut  G  ) →  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype   (   group_aut  G  ) ] ->   IsCyclic   (   group_aut  G  ) →  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintypeₓ   (   group_aut  G  ) ] ->   IsCyclic   (   group_aut  G  ) →  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  [  Fintype   (   group_aut  G  ) ] ->   IsCyclic   (   group_aut  G  ) →  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  [  Fintypeₓ   (   group_aut  G  ) ] ->   IsCyclic   (   group_aut  G  ) →  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  {  α :  Type  v } ->  [  Group  α ] ->  (  f :  α →  G → G ) ->  (  hf :  is_group_action  f ) ->  (  h :  IsCyclic   (   automorphism_group  f  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  {  α :  Type  v } ->  [  Groupₓ  α ] ->  (  f :  α →  G → G ) ->  (  hf :  is_group_action  f ) ->  (  h :  IsCyclic   (   automorphism_group  f  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Group  G ] ->  {  α :  Type  v } ->  [  Groupₓₓ  α ] ->  (  f :  α →  G → G ) ->  (  hf :  is_group_action  f ) ->  (  h :  IsCyclic   (   automorphism_group  f  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  α :  Type  v } ->  [  Group  α ] ->  (  f :  α →  G → G ) ->  (  hf :  is_group_action  f ) ->  (  h :  IsCyclic   (   automorphism_group  f  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  α :  Type  v } ->  [  Groupₓ  α ] ->  (  f :  α →  G → G ) ->  (  hf :  is_group_action  f ) ->  (  h :  IsCyclic   (   automorphism_group  f  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  α :  Type  v } ->  [  Groupₓₓ  α ] ->  (  f :  α →  G → G ) ->  (  hf :  is_group_action  f ) ->  (  h :  IsCyclic   (   automorphism_group  f  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  α :  Type  v } ->  [  Group  α ] ->  (  f :  α →  G → G ) ->  (  hf :  is_group_action  f ) ->  (  h :  IsCyclic   (   automorphism_group  f  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  α :  Type  v } ->  [  Groupₓ  α ] ->  (  f :  α →  G → G ) ->  (  hf :  is_group_action  f ) ->  (  h :  IsCyclic   (   automorphism_group  f  ) ) ->  is_abelian  G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  α :  Type  v } ->  [  Groupₓₓ  α ] ->  (  f :  α →  G → G ) ->  (  hf :  is_group_action  f ) ->  (  h :  IsCyclic   (   automorphism_group  f  ) ) ->  is_abelian  G

failed to elaborate

outputs: #[{G : Type u} [group G] (h_cyclic : is_cyclic (group_aut G)) : is_abelian G , {G : Type u_1} [group G] (h : is_cyclic (automorphism_group G)) : comm_group G , {G : Type u_1} [group G] (h : is_cyclic (aut G)) : is_abelian G , {G : Type u_1} [group G] {n : ℕ} (hn : is_cyclic (group_aut G)) : is_abelian G , {G : Type u} [group G] {H : Type w} [group H] (f : G ≃o H) (h : is_cyclic (automorphism_group G)) : is_abelian G , {G : Type u} [group G] (h : is_cyclic group_aut G) : is_abelian G , {G : Type u_2} [group G] (h : ∀ (n : ℕ), n ≠ 0 → ∀ (H : groups.finset (perm G)), (∀ (x : H), is_automorphism x) → (∀ (x : H), is_automorphism x) → H ≠ ∅ → groups.finset.card H = n → ∃ (x : H), H = {y | ∃ (m : ℕ), y = pow x m}) : comm_group G , {G : Type u_1} [group G] [fintype G] (h : is_group_isomorphic (aut_group G) (ℤ/2ℤ)) : comm_group G , {G : Type u} [group G] (H : is_cyclic (aut G)) : is_comm_group G , {α : Type u} [group α] {f : α ≃ₜ α} : is_cyclic (automorphism_group α) → commutative_group α , {α : Type u} [group α] {β} [group β] [fintype β] (h : Π (g h : β → β), (g ∘ h) ∈ automorphism_group β → g ∈ automorphism_group β → h ∈ automorphism_group β → g = h) : comm_group α , {α : Type u_1} [group α] [fintype (group_aut α)] {n : ℕ} (h : is_cyclic (group_aut α) n) : is_comm_group α , {G : Type u} [group G] (h : is_cyclic (automorphism_group G)) : is_abelian G , {G : Type u_1} [group G] (h : is_cyclic group.automorphism_group G) : is_abelian G , {G : Type u} [group G] (h : is_cyclic (aut G)) : is_abelian G , {G : Type u} [group G] [is_cyclic_group (aut G)] : is_abelian_group G , (G : Type u) [group G] (h : ∃ (n : ℕ), ∀ (f : G ≃* G), n ∣ nat_degree f) : is_abelian_group G , {G : Type u} [group G] [fintype (aut G)] (h : is_cyclic (aut G)) : is_abelian G , {G : Type u} [group G] [fintype (group_aut G)] : is_cyclic (group_aut G) → is_abelian G , {G : Type u} [group G] {α : Type v} [group α] (f : α → G → G) (hf : is_group_action f) (h : is_cyclic (automorphism_group f)) : is_abelian G ]

total : 11

elaborated: 8

A uniformly continuous function of a uniformly continuous function is uniformly continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]
  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},
  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)

total : 12

elaborated: 9

A uniformly continuous function of a uniformly continuous function is uniformly continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]
  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},
  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)

total : 13

elaborated: 10

A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.

No valid output from Codex; outputs below

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  (   ∀   (  s t  :  Set  X  )  ,   Disjoint  s t →   IsClosed  s →   IsClosed  t →  ∃    (   f :  X →   ℝ  ℝ ) ,   Continuous  f ∧   Set.EqOn  f  0 s ∧   Set.EqOn  f  1 t ∧  ∀   (  x  : X  )  ,   f  x ∈  Set.Icc   0  1  )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  (   ∀   (  s t  :  Setₓ  X  )  ,   Disjoint  s t →   IsClosed  s →   IsClosed  t →  ∃    (   f :  X →   ℝ  ℝ ) ,   Continuous  f ∧   Set.EqOn  f  0 s ∧   Set.EqOn  f  1 t ∧  ∀   (  x  : X  )  ,   f  x ∈  Set.Icc   0  1  )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   {  s t  :  Set  X }  (  hs  :  IsClosed  s  )  (  ht  :  IsClosed  t  )  (  hd  :  Disjoint  s t  )  ,  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   {  s t  :  Setₓ  X }  (  hs  :  IsClosed  s  )  (  ht  :  IsClosed  t  )  (  hd  :  Disjoint  s t  )  ,  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  {  s t :  Set  X } ->  (  hs :  IsClosed  s ) ->  (  ht :  IsClosed  t ) ->  (  hd :  Disjoint  s t ) ->   NormalSpace  X ↔  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  {  s t :  Setₓ  X } ->  (  hs :  IsClosed  s ) ->  (  ht :  IsClosed  t ) ->  (  hd :  Disjoint  s t ) ->   NormalSpace  X ↔  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->   NormalSpace  α ↔  ∀   (  s t  :  Set  α  )  (  hs  :  IsClosed  s  )  (  ht  :  IsClosed  t  )  (  hd  :  Disjoint  s t  )  ,  ∃    (   f :  BoundedContinuousFunction  α   ℝ  ℝ ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : α  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->   NormalSpace  α ↔  ∀   (  s t  :  Setₓ  α  )  (  hs  :  IsClosed  s  )  (  ht  :  IsClosed  t  )  (  hd  :  Disjoint  s t  )  ,  ∃    (   f :  BoundedContinuousFunction  α   ℝ  ℝ ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : α  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  T2Space  X ] ->   NormalSpace  X ↔  ∀  s t   :  Set  X ,   IsClosed  s →   IsClosed  t →   IsClosed  s →   Disjoint  s t →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  T2Space  X ] ->   NormalSpace  X ↔  ∀  s t   :  Setₓ  X ,   IsClosed  s →   IsClosed  t →   IsClosed  s →   Disjoint  s t →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  (  hX :  NormalSpace  X ) ->  {  s t :  Set  X } ->  (  hs :  IsClosed  s ) ->  (  ht :  IsClosed  t ) ->  (  hdisj :  Disjoint  s t ) ->  ∃    (   f :  C( X ,   ℝ  ℝ ) )  (   hf :  local_homeomorph.is_open_map   (   f.comp  continuous_map.continuous_induced_r2l  ) ) ,   Set.EqOn   ⇑ f  0 s ∧  Set.EqOn   ⇑ f  1 t

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  (  hX :  NormalSpace  X ) ->  {  s t :  Setₓ  X } ->  (  hs :  IsClosed  s ) ->  (  ht :  IsClosed  t ) ->  (  hdisj :  Disjoint  s t ) ->  ∃    (   f :  C( X ,   ℝ  ℝ ) )  (   hf :  local_homeomorph.is_open_map   (   f.comp  continuous_map.continuous_induced_r2l  ) ) ,   Set.EqOn   ⇑ f  0 s ∧  Set.EqOn   ⇑ f  1 t

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  {  s t :  Set  X } ->  (  hs :  IsClosed  s ) ->  (  ht :  IsClosed  t ) ->  (  hd :  Disjoint  s t ) ->   NormalSpace  X ↔  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧  Set.EqOn   ⇑ f  1 t

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  {  s t :  Setₓ  X } ->  (  hs :  IsClosed  s ) ->  (  ht :  IsClosed  t ) ->  (  hd :  Disjoint  s t ) ->   NormalSpace  X ↔  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧  Set.EqOn   ⇑ f  1 t

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   {  P Q  :  Set  X }  ,   IsClosed  P →   IsClosed  Q →   Disjoint  P Q →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 P ∧   Set.EqOn   ⇑ f  1 Q ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   {  P Q  :  Setₓ  X }  ,   IsClosed  P →   IsClosed  Q →   Disjoint  P Q →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 P ∧   Set.EqOn   ⇑ f  1 Q ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->   NormalSpace  α ↔  ∀   (  s t  :  Set  α  )  ,   IsClosed  s →   IsClosed  t →   Disjoint  s t →  ∃    (   f :  C( α ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : α  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->   NormalSpace  α ↔  ∀   (  s t  :  Setₓ  α  )  ,   IsClosed  s →   IsClosed  t →   Disjoint  s t →  ∃    (   f :  C( α ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : α  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->   NormalSpace  α ↔  ∀   (  s t  :  Set  α  )  (  h1  :  IsClosed  s  )  (  h2  :  IsClosed  t  )  (  h3  :  Disjoint  s t  )  ,  ∃    (   f :  α →   ℝ  ℝ ) ,   Continuous  f ∧   Set.EqOn  f  0 s ∧  Set.EqOn  f  1 t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->   NormalSpace  α ↔  ∀   (  s t  :  Setₓ  α  )  (  h1  :  IsClosed  s  )  (  h2  :  IsClosed  t  )  (  h3  :  Disjoint  s t  )  ,  ∃    (   f :  α →   ℝ  ℝ ) ,   Continuous  f ∧   Set.EqOn  f  0 s ∧  Set.EqOn  f  1 t

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   {  s t  :  Set  X }  ,   IsClosed  s →   IsClosed  t →   Disjoint  s t →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧  Set.EqOn   ⇑ f  1 t

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   {  s t  :  Setₓ  X }  ,   IsClosed  s →   IsClosed  t →   Disjoint  s t →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧  Set.EqOn   ⇑ f  1 t

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   {  s t  :  Set  X }  ,   IsClosed  s →   IsClosed  t →   Disjoint  s t →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   {  s t  :  Setₓ  X }  ,   IsClosed  s →   IsClosed  t →   Disjoint  s t →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   (  c d  :  Set  X  )  ,   IsClosed  c →   IsClosed  d →   Disjoint  c d →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 c ∧   Set.EqOn   ⇑ f  1 d ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   (  c d  :  Setₓ  X  )  ,   IsClosed  c →   IsClosed  d →   Disjoint  c d →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 c ∧   Set.EqOn   ⇑ f  1 d ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  (   ∀   (  s t  :  Set  X  )  ,   IsClosed  s →   IsClosed  t →   Disjoint  s t →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1  )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  (   ∀   (  s t  :  Setₓ  X  )  ,   IsClosed  s →   IsClosed  t →   Disjoint  s t →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1  )

 {  X :  Type* } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   (  s t  :  Set  X  )  (  hs  :  IsClosed  s  )  (  ht  :  IsClosed  t  )  (  hd  :  Disjoint  s t  )  ,  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type* } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   (  s t  :  Setₓ  X  )  (  hs  :  IsClosed  s  )  (  ht  :  IsClosed  t  )  (  hd  :  Disjoint  s t  )  ,  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   {  s t  :  Set  X }  (  h_closed_s  :  IsClosed  s  )  (  h_closed_t  :  IsClosed  t  )  (  h_disjoint  :  Disjoint  s t  )  ,  (   ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1  )

 {  X :  Type  u } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   {  s t  :  Setₓ  X }  (  h_closed_s  :  IsClosed  s  )  (  h_closed_t  :  IsClosed  t  )  (  h_disjoint  :  Disjoint  s t  )  ,  (   ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : X  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1  )

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->  (  hs :  IsClosed  s ) ->  (  ht :  IsClosed  t ) ->  (  hd :  Disjoint  s t ) ->   NormalSpace  α ↔  ∃    (   f :  C( α ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : α  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->  (  hs :  IsClosed  s ) ->  (  ht :  IsClosed  t ) ->  (  hd :  Disjoint  s t ) ->   NormalSpace  α ↔  ∃    (   f :  C( α ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧   Set.EqOn   ⇑ f  1 t ∧  ∀   (  x  : α  )  ,   ⇑   f  x ∈  Set.Icc   0  1  ⇑   f  xf  x ∈  Set.Icc   0  1  ⇑   f  x ∈  Set.Icc   0  1

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   (  s t  :  Set  X  )  ,   IsClosed  s →   IsClosed  t →   Disjoint  s t →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧  Set.EqOn   ⇑ f  1 t

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   NormalSpace  X ↔  ∀   (  s t  :  Setₓ  X  )  ,   IsClosed  s →   IsClosed  t →   Disjoint  s t →  ∃    (   f :  C( X ,   ℝ  ℝ ) ) ,   Set.EqOn   ⇑ f  0 s ∧  Set.EqOn   ⇑ f  1 t

failed to elaborate

outputs: #[{X : Type u_1} [topological_space X] : normal_space X ↔ (∀ (s t : set X), disjoint s t → is_closed s → is_closed t → ∃ (f : X → ℝ), continuous f ∧ set.eq_on f 0 s ∧ set.eq_on f 1 t ∧ ∀ (x : X), f x ∈ set.Icc 0 1) , {X : Type u_1} [topological_space X] : normal_space X ↔ ∀ {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t), ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 , {X : Type u_1} [topological_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : normal_space X ↔ ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 , {α : Type u_1} [topological_space α] : normal_space α ↔ ∀ (s t : set α) (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t), ∃ (f : bounded_continuous_function α ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : α), ⇑f x ∈ set.Icc 0 1 , {X : Type u_1} [t2_space X] : normal_space X ↔ ∀ s t : set X, is_closed s → is_closed t → is_closed s → disjoint s t → ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 , {X : Type u_1} [topological_space X] (hX : normal_space X) {s t : set X} (hs : is_closed s) (ht : is_closed t) (hdisj : disjoint s t) : ∃ (f : C(X, ℝ)) (hf : local_homeomorph.is_open_map (f.comp continuous_map.continuous_induced_r2l)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t , {X : Type u_1} [topological_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : normal_space X ↔ ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t , {X : Type u_1} [topological_space X] : normal_space X ↔ ∀ {P Q : set X}, is_closed P → is_closed Q → disjoint P Q → ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 P ∧ set.eq_on ⇑f 1 Q ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 , {α : Type u_1} [topological_space α] : normal_space α ↔ ∀ (s t : set α), is_closed s → is_closed t → disjoint s t → ∃ (f : C(α, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : α), ⇑f x ∈ set.Icc 0 1 , {α : Type u} [topological_space α] : normal_space α ↔ ∀ (s t : set α) (h1 : is_closed s) (h2 : is_closed t) (h3 : disjoint s t), ∃ (f : α → ℝ), continuous f ∧ set.eq_on f 0 s ∧ set.eq_on f 1 t , {X : Type u_1} [topological_space X] : normal_space X ↔ ∀ {s t : set X}, is_closed s → is_closed t → disjoint s t → ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t , {X : Type u_1} [topological_space X] : normal_space X ↔ ∀ {s t : set X}, is_closed s → is_closed t → disjoint s t → ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 , {X : Type u_1} [topological_space X] : normal_space X ↔ ∀ (c d : set X), is_closed c → is_closed d → disjoint c d → ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 c ∧ set.eq_on ⇑f 1 d ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 , {X : Type u_1} [topological_space X] : normal_space X ↔ (∀ (s t : set X), is_closed s → is_closed t → disjoint s t → ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1) , {X : Type*} [topological_space X] : normal_space X ↔ ∀ (s t : set X) (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t), ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 , {X : Type u} [topological_space X] : normal_space X ↔ ∀ {s t : set X} (h_closed_s : is_closed s) (h_closed_t : is_closed t) (h_disjoint : disjoint s t),
  (∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1) , {α : Type u_1} [topological_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : normal_space α ↔ ∃ (f : C(α, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : α), ⇑f x ∈ set.Icc 0 1 , {X : Type u_1} [topological_space X] : normal_space X ↔ ∀ (s t : set X), is_closed s → is_closed t → disjoint s t → ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ]

total : 14

elaborated: 10

If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.

success

theorem ∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsPeriodicPt f 3 x → ∀ {n : ℕ}, 0 < n → Function.IsPeriodicPt f n x

total : 15

elaborated: 11

A terminal object in a category is unique up to unique isomorphism.

success

theorem ∀ {C : Type u} [inst : CategoryTheory.Category C] {A B : C} (hA : CategoryTheory.Limits.IsTerminal A),
  CategoryTheory.Limits.IsTerminal B → CategoryTheory.IsIso (CategoryTheory.Limits.IsTerminal.from hA B)

total : 16

elaborated: 12

The complement of the union of two sets is the intersection of their complements.

No valid output from Codex; outputs below

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) =   (   - s  ) ∩  (   - t  )

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) =   (   - s  ) ∩  (   - t  )

{α : Type u} {s t : set α} : (s ∪ t)ᶜ = sᶜ ∩ tᶜ 

{α : Type u_1} [topological_space α] {s t : set α} : (s ∪ t)ᶜ = sᶜ ∩ tᶜ 

 {  α :  Type  u_1 } ->  [  SemilatticeInf  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u_1 } ->  [  SemilatticeInf  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u_1 } ->  (  s t :  Set  α ) ->   -  (   s ∪ t  ) =  (    - s ∩  - t  )

 {  α :  Type  u_1 } ->  (  s t :  Setₓ  α ) ->   -  (   s ∪ t  ) =  (    - s ∩  - t  )

 {  α :  Type  u } ->  [  SemilatticeInf  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u } ->  [  SemilatticeInf  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) =   (   - s  ) ∩  (   - t  )

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) =   (   - s  ) ∩  (   - t  )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

{α : Type u_1} {s t : set α} : sᶜ ∪ tᶜ = (s ∩ t)ᶜ 

 {  α :  Type  u_1 } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

 {  α :  Type  u_1 } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) =   - s ∩  - t

{α : Type u} {s t : set α} : (s ∪ t)ᶜ = (sᶜ) ∩ (tᶜ) 

failed to elaborate

outputs: #[{α : Type u} [topological_space α] {s t : set α} : -(s ∪ t) = -s ∩ -t , {α : Type u} [topological_space α] {s t : set α} : -(s ∪ t) = (-s) ∩ (-t) , {α : Type u} {s t : set α} : (s ∪ t)ᶜ = sᶜ ∩ tᶜ , {α : Type u_1} [topological_space α] {s t : set α} : (s ∪ t)ᶜ = sᶜ ∩ tᶜ , {α : Type u_1} [semilattice_inf α] {s t : set α} : -(s ∪ t) = -s ∩ -t , {α : Type u} {s t : set α} : - (s ∪ t) = -s ∩ -t , {α : Type u} [topological_space α] {s t : set α} : - (s ∪ t) = - s ∩ - t , {α : Type u_1} (s t : set α) : -(s ∪ t) = (-s ∩ -t) , {α : Type u} [semilattice_inf α] {s t : set α} : -(s ∪ t) = -s ∩ -t , {α : Type u_1} [topological_space α] {s t : set α} : -(s ∪ t) = (-s) ∩ (-t) , {α : Type u} {s t : set α} : -(s ∪ t) = -s ∩ -t , {α : Type u_1} {s t : set α} : sᶜ ∪ tᶜ = (s ∩ t)ᶜ , {α : Type u_1} {s t : set α} : - (s ∪ t) = - s ∩ - t , {α : Type u} {s t : set α} : (s ∪ t)ᶜ = (sᶜ) ∩ (tᶜ) ]

total : 17

elaborated: 12

The sum of the cubes of two positive integers is never equal to the cube of a third integer.

success

theorem ∀ {a b : ℕ}, a ≥ 1 → b ≥ 1 → ¬∃ c, a ^ 3 + b ^ 3 = c ^ 3

total : 18

elaborated: 13

If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.

success

theorem ∀ {G : Type u} [inst : Groupₓ G] {a b : G}, (∀ (g : G), orderOf g = 2) → Commute a b

total : 19

elaborated: 14

The product of two consecutive natural numbers is even.

success

theorem ∀ {m n : ℕ}, m = n + 1 → Even (m * n)

total : 20

elaborated: 15

Every index 2 subgroup of a group is normal.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  (  h1 :  index  H  2 ) ->  H ≤  normalizer  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  (  h1 :  index  H  2 ) ->  H ≤  normalizer  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  (  h1 :  index  H  2 ) ->  H ≤  normalizer  G

 {  G :  Type  u_1 } ->  (  H :  Subgroup  G ) ->  (  hG :   Fintype.card  G =   2 *  Fintype.card  H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  {  s :  Subgroup  G } ->  [  Group  G ] ->  (  h :   s.index_pow   2 =  2 ) ->  IsNormalSubgroup  s

 {  G :  Type  u_1 } ->  {  s :  Subgroup  G } ->  [  Groupₓ  G ] ->  (  h :   s.index_pow   2 =  2 ) ->  IsNormalSubgroup  s

 {  G :  Type  u_1 } ->  {  s :  Subgroup  G } ->  [  Groupₓₓ  G ] ->  (  h :   s.index_pow   2 =  2 ) ->  IsNormalSubgroup  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  (  h :   index  G H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  (  h :   index  G H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  (  h :   index  G H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  N :  Subgroup  G ) ->  (  hN :   Fintype.card   (   G / N  ) =  2 ) ->  IsNormalSubgroup  N

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  N :  Subgroup  G ) ->  (  hN :   Fintype.card   (   G / N  ) =  2 ) ->  IsNormalSubgroup  N

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  N :  Subgroup  G ) ->  (  hN :   Fintype.card   (   G / N  ) =  2 ) ->  IsNormalSubgroup  N

 {  G H :  Type* } ->  [  Group  G ] ->  (  h :  H ⊆ G ) ->  (  card_hG :    @ Fintype.card  G H =  2 ) ->  IsNormalSubgroup  H

 {  G H :  Type* } ->  [  Groupₓ  G ] ->  (  h :  H ⊆ G ) ->  (  card_hG :    @ Fintype.card  G H =  2 ) ->  IsNormalSubgroup  H

 {  G H :  Type* } ->  [  Groupₓₓ  G ] ->  (  h :  H ⊆ G ) ->  (  card_hG :    @ Fintype.card  G H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  (  H :  Type  u ) ->  [  Group  G ] ->  [  Group  H ] ->  (  f :  H → G ) ->  (  e :   LeftCoset  f H =  RightCoset  f H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  (  H :  Type  u ) ->  [  Group  G ] ->  [  Groupₓ  H ] ->  (  f :  H → G ) ->  (  e :   LeftCoset  f H =  RightCoset  f H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  (  H :  Type  u ) ->  [  Group  G ] ->  [  Groupₓₓ  H ] ->  (  f :  H → G ) ->  (  e :   LeftCoset  f H =  RightCoset  f H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  (  H :  Type  u ) ->  [  Groupₓ  G ] ->  [  Group  H ] ->  (  f :  H → G ) ->  (  e :   LeftCoset  f H =  RightCoset  f H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  (  H :  Type  u ) ->  [  Groupₓ  G ] ->  [  Groupₓ  H ] ->  (  f :  H → G ) ->  (  e :   LeftCoset  f H =  RightCoset  f H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  (  H :  Type  u ) ->  [  Groupₓ  G ] ->  [  Groupₓₓ  H ] ->  (  f :  H → G ) ->  (  e :   LeftCoset  f H =  RightCoset  f H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  (  H :  Type  u ) ->  [  Groupₓₓ  G ] ->  [  Group  H ] ->  (  f :  H → G ) ->  (  e :   LeftCoset  f H =  RightCoset  f H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  (  H :  Type  u ) ->  [  Groupₓₓ  G ] ->  [  Groupₓ  H ] ->  (  f :  H → G ) ->  (  e :   LeftCoset  f H =  RightCoset  f H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  (  H :  Type  u ) ->  [  Groupₓₓ  G ] ->  [  Groupₓₓ  H ] ->  (  f :  H → G ) ->  (  e :   LeftCoset  f H =  RightCoset  f H ) ->  IsNormalSubgroup  H

{G : Type u_1} {H : subgroup G} [group G] (hH : #|G : H| = 2) : is_normal_subgroup H 

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  (  h :    card  G /  card  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  (  h :    card  G /  card  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  (  h :    card  G /  card  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  (  h :    Fintype.card  G /  Fintype.card  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  (  h :    Fintype.card  G /  Fintype.card  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  (  h :    Fintype.card  G /  Fintype.card  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  (  h :   Fintype.card  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  (  h :   Fintype.card  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  (  h :   Fintype.card  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  [  Fact   (    2 ∣  index_of_subgroup  H  ) ] ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  [  Fact   (    2 ∣  index_of_subgroup  H  ) ] ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  [  Fact   (    2 ∣  index_of_subgroup  H  ) ] ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  (  ht :   index_of  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  (  ht :   index_of  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  (  ht :   index_of  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  (  h :   Fintype.card   H *  2 =  Fintype.card  G ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  (  h :   Fintype.card   H *  2 =  Fintype.card  G ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  (  h :   Fintype.card   H *  2 =  Fintype.card  G ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  (  h :   [ G : H ] =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  (  h :   [ G : H ] =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  (  h :   [ G : H ] =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  (  hH :    Fintype.card  G /  2 =  Fintype.card  H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  (  hH :    Fintype.card  G /  2 =  Fintype.card  H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  (  hH :    Fintype.card  G /  2 =  Fintype.card  H ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  (  hH :   subgroup.index  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  (  hH :   subgroup.index  H =  2 ) ->  IsNormalSubgroup  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  (  hH :   subgroup.index  H =  2 ) ->  IsNormalSubgroup  H

{G : Type u_1} [group G] (H : subgroup G) (h : ∣G : H∣ = 2) : is_normal_subgroup H 

{H G : Type u_1} [group H] [group G] (a : H → G) (ha : is_group_hom a) (h2 : fintype.card (a '' H) = 2) : is_normal_subgroup H 

failed to elaborate

outputs: #[{G : Type u_1} [group G] {H : subgroup G} (h1 : index H 2) : H ≤ normalizer G , {G : Type u_1} (H : subgroup G) (hG : fintype.card G = 2 * fintype.card H) : is_normal_subgroup H , {G : Type u_1} {s : subgroup G} [group G] (h : s.index_pow 2 = 2) : is_normal_subgroup s , {G : Type u_1} [group G] {H : subgroup G} (h : index G H = 2) : is_normal_subgroup H , {G : Type u_1} [group G] (N : subgroup G) (hN : fintype.card (G / N) = 2) : is_normal_subgroup N , {G H : Type*} [group G] (h : H ⊆ G) (card_hG : @fintype.card G H = 2) : is_normal_subgroup H , {G : Type u_1} (H : Type u) [group G] [group H] (f : H → G) (e : left_coset f H = right_coset f H) : is_normal_subgroup H , {G : Type u_1} {H : subgroup G} [group G] (hH : #|G : H| = 2) : is_normal_subgroup H , {G : Type u_1} [group G] {H : subgroup G} (h : card G / card H = 2) : is_normal_subgroup H , {G : Type u_1} [group G] (H : subgroup G) (h : fintype.card G / fintype.card H = 2) : is_normal_subgroup H , {G : Type u_1} [group G] {H : subgroup G} (h : fintype.card H = 2) : is_normal_subgroup H , {G : Type u_1} [group G] (H : subgroup G) [fact (2 ∣ index_of_subgroup H)] : is_normal_subgroup H , {G : Type u_1} [group G] {H : subgroup G} (ht : index_of H = 2) : is_normal_subgroup H , {G : Type u_1} [group G] {H : subgroup G} (h : fintype.card H * 2 = fintype.card G) : is_normal_subgroup H , {G : Type u_1} [group G] {H : subgroup G} (h : [G : H] = 2) : is_normal_subgroup H , {G : Type u_1} [group G] (H : subgroup G) (hH : fintype.card G / 2 = fintype.card H) : is_normal_subgroup H , {G : Type u_1} [group G] {H : subgroup G} (hH : subgroup.index H = 2) : is_normal_subgroup H , {G : Type u_1} [group G] (H : subgroup G) (h : ∣G : H∣ = 2) : is_normal_subgroup H , {H G : Type u_1} [group H] [group G] (a : H → G) (ha : is_group_hom a) (h2 : fintype.card (a '' H) = 2) : is_normal_subgroup H ]

total : 21

elaborated: 15

Every free group is torsion free.

success

theorem ∀ {α : Type u_1}, Monoidₓ.IsTorsionFree (FreeGroup α)

total : 22

elaborated: 16

Every natural number greater than `1` is divisible by a prime number. 

success

theorem ∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n

total : 23

elaborated: 17

A finite torsion-free group is trivial

success

theorem ∀ {α : Type u} [inst : Groupₓ α] [inst_1 : Fintype α], Monoidₓ.IsTorsionFree α → Fintype.card α ≤ 1

total : 24

elaborated: 18

Every finite division ring is a field.

success

theorem ∀ (K : Type u) [inst : Fintype K] [inst : DivisionRing K], IsField K

total : 25

elaborated: 19

Every finite topological space is compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α

total : 26

elaborated: 20

Every surjective homomorphism from a finitely generated free group to itself is injective.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Group  G ] ->  {  f :   FreeGroup  α →* G } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Groupₓ  G ] ->  {  f :   FreeGroup  α →* G } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  {  f :   FreeGroup  α →* G } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  (  f :   FreeGroup  α →*  FreeGroup  α ) ->  (  hf :  Function.Surjective   ⇑ f ) ->  [  Fintype  α ] ->  Function.Injective  f

 {  α :  Type  u_1 } ->  (  f :   FreeGroup  α →*  FreeGroup  α ) ->  (  hf :  Function.Surjective   ⇑ f ) ->  [  Fintypeₓ  α ] ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Group  α ] ->  [  Group  β ] ->  {  f :  α → β } ->  (  hfg :  group.is_finitely_generated  α ) ->  (  hf :  IsGroupHom  f ) ->  (  hf' :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Group  α ] ->  [  Groupₓ  β ] ->  {  f :  α → β } ->  (  hfg :  group.is_finitely_generated  α ) ->  (  hf :  IsGroupHom  f ) ->  (  hf' :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Group  α ] ->  [  Groupₓₓ  β ] ->  {  f :  α → β } ->  (  hfg :  group.is_finitely_generated  α ) ->  (  hf :  IsGroupHom  f ) ->  (  hf' :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Groupₓ  α ] ->  [  Group  β ] ->  {  f :  α → β } ->  (  hfg :  group.is_finitely_generated  α ) ->  (  hf :  IsGroupHom  f ) ->  (  hf' :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Groupₓ  α ] ->  [  Groupₓ  β ] ->  {  f :  α → β } ->  (  hfg :  group.is_finitely_generated  α ) ->  (  hf :  IsGroupHom  f ) ->  (  hf' :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Groupₓ  α ] ->  [  Groupₓₓ  β ] ->  {  f :  α → β } ->  (  hfg :  group.is_finitely_generated  α ) ->  (  hf :  IsGroupHom  f ) ->  (  hf' :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Groupₓₓ  α ] ->  [  Group  β ] ->  {  f :  α → β } ->  (  hfg :  group.is_finitely_generated  α ) ->  (  hf :  IsGroupHom  f ) ->  (  hf' :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Groupₓₓ  α ] ->  [  Groupₓ  β ] ->  {  f :  α → β } ->  (  hfg :  group.is_finitely_generated  α ) ->  (  hf :  IsGroupHom  f ) ->  (  hf' :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Groupₓₓ  α ] ->  [  Groupₓₓ  β ] ->  {  f :  α → β } ->  (  hfg :  group.is_finitely_generated  α ) ->  (  hf :  IsGroupHom  f ) ->  (  hf' :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Group  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Set  α ) ->  (  hn :  Fintype  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Group  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Set  α ) ->  (  hn :  Fintypeₓ  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Group  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Setₓ  α ) ->  (  hn :  Fintype  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Group  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Setₓ  α ) ->  (  hn :  Fintypeₓ  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Groupₓ  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Set  α ) ->  (  hn :  Fintype  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Groupₓ  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Set  α ) ->  (  hn :  Fintypeₓ  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Groupₓ  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Setₓ  α ) ->  (  hn :  Fintype  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Groupₓ  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Setₓ  α ) ->  (  hn :  Fintypeₓ  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Set  α ) ->  (  hn :  Fintype  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Set  α ) ->  (  hn :  Fintypeₓ  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Setₓ  α ) ->  (  hn :  Fintype  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  {  f :   FreeGroup  α → G } ->  (  gen :  Setₓ  α ) ->  (  hn :  Fintypeₓ  gen ) ->  (  h :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  n :  ℕ } ->  [  DecidableEq  α ] ->  [  Fintype  α ] ->  (  f :   FreeGroup  α n →+*  FreeGroup  α n ) ->  (  hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  n :  ℕ } ->  [  DecidableEq  α ] ->  [  Fintypeₓ  α ] ->  (  f :   FreeGroup  α n →+*  FreeGroup  α n ) ->  (  hf :  Function.Surjective  f ) ->  Function.Injective  f

{α : Type u_1} (n : ℕ) (H : n ≥ 0) {G : Type u_2} [group G] (f : free_group α ⟶* G) (hf : function.surjective (function.injective.eq_iff.mpr f.injective)) : function.injective f 

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  FreeGroup  α ] ->  [  FreeGroup  β ] ->  {  f :  α → β } ->  [  IsGroupHom  f ] ->  (  hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  η :  Type  u_1 } ->  [ h :  Nonempty  η ] ->  injective   (  FreeGroup.of   :  η →*  FreeGroup  η )

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  {  n :  ℕ } ->  [  Group  α ] ->  [  Group  G ] ->  (  H :   (  n   :  ℤ ) ≠  0 ) ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  {  n :  ℕ } ->  [  Group  α ] ->  [  Groupₓ  G ] ->  (  H :   (  n   :  ℤ ) ≠  0 ) ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  {  n :  ℕ } ->  [  Group  α ] ->  [  Groupₓₓ  G ] ->  (  H :   (  n   :  ℤ ) ≠  0 ) ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  {  n :  ℕ } ->  [  Groupₓ  α ] ->  [  Group  G ] ->  (  H :   (  n   :  ℤ ) ≠  0 ) ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  {  n :  ℕ } ->  [  Groupₓ  α ] ->  [  Groupₓ  G ] ->  (  H :   (  n   :  ℤ ) ≠  0 ) ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  {  n :  ℕ } ->  [  Groupₓ  α ] ->  [  Groupₓₓ  G ] ->  (  H :   (  n   :  ℤ ) ≠  0 ) ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  {  n :  ℕ } ->  [  Groupₓₓ  α ] ->  [  Group  G ] ->  (  H :   (  n   :  ℤ ) ≠  0 ) ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  {  n :  ℕ } ->  [  Groupₓₓ  α ] ->  [  Groupₓ  G ] ->  (  H :   (  n   :  ℤ ) ≠  0 ) ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  G :  Type  u_2 } ->  {  n :  ℕ } ->  [  Groupₓₓ  α ] ->  [  Groupₓₓ  G ] ->  (  H :   (  n   :  ℤ ) ≠  0 ) ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  f :   FreeGroup  α →*  FreeGroup  α } ->  (  hf :  Function.Surjective   ⇑ f ) ->  (  hfg :  fintype.countable  α ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  B :  Set  α } ->  [  DecidableEq  α ] ->  [  Fintype  B ] ->  [  Fintype   (   free_group.quotient  B  ) ] ->  {  f :   free_group.quotient  B →*  free_group.quotient  B } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  B :  Set  α } ->  [  DecidableEq  α ] ->  [  Fintype  B ] ->  [  Fintypeₓ   (   free_group.quotient  B  ) ] ->  {  f :   free_group.quotient  B →*  free_group.quotient  B } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  B :  Set  α } ->  [  DecidableEq  α ] ->  [  Fintypeₓ  B ] ->  [  Fintype   (   free_group.quotient  B  ) ] ->  {  f :   free_group.quotient  B →*  free_group.quotient  B } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  B :  Set  α } ->  [  DecidableEq  α ] ->  [  Fintypeₓ  B ] ->  [  Fintypeₓ   (   free_group.quotient  B  ) ] ->  {  f :   free_group.quotient  B →*  free_group.quotient  B } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  B :  Setₓ  α } ->  [  DecidableEq  α ] ->  [  Fintype  B ] ->  [  Fintype   (   free_group.quotient  B  ) ] ->  {  f :   free_group.quotient  B →*  free_group.quotient  B } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  B :  Setₓ  α } ->  [  DecidableEq  α ] ->  [  Fintype  B ] ->  [  Fintypeₓ   (   free_group.quotient  B  ) ] ->  {  f :   free_group.quotient  B →*  free_group.quotient  B } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  B :  Setₓ  α } ->  [  DecidableEq  α ] ->  [  Fintypeₓ  B ] ->  [  Fintype   (   free_group.quotient  B  ) ] ->  {  f :   free_group.quotient  B →*  free_group.quotient  B } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  B :  Setₓ  α } ->  [  DecidableEq  α ] ->  [  Fintypeₓ  B ] ->  [  Fintypeₓ   (   free_group.quotient  B  ) ] ->  {  f :   free_group.quotient  B →*  free_group.quotient  B } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  n :  ℕ } ->  (  h :  n >  0 ) ->  (  f :   FreeGroup  α n →*  FreeGroup  α n ) ->  (  hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  [  Fintype  α ] ->  {  G :  Type  v } ->  [  Group  G ] ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  [  Fintype  α ] ->  {  G :  Type  v } ->  [  Groupₓ  G ] ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  [  Fintype  α ] ->  {  G :  Type  v } ->  [  Groupₓₓ  G ] ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  [  Fintypeₓ  α ] ->  {  G :  Type  v } ->  [  Group  G ] ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  [  Fintypeₓ  α ] ->  {  G :  Type  v } ->  [  Groupₓ  G ] ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  [  Fintypeₓ  α ] ->  {  G :  Type  v } ->  [  Groupₓₓ  G ] ->  (  f :   FreeGroup  α →* G ) ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Group  α ] ->  [  Group  β ] ->  (  f :  α → β ) ->  [  IsGroupHom  f ] ->  [  IsGroupHom  f.symm ] ->  (  Hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Group  α ] ->  [  Groupₓ  β ] ->  (  f :  α → β ) ->  [  IsGroupHom  f ] ->  [  IsGroupHom  f.symm ] ->  (  Hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Group  α ] ->  [  Groupₓₓ  β ] ->  (  f :  α → β ) ->  [  IsGroupHom  f ] ->  [  IsGroupHom  f.symm ] ->  (  Hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓ  α ] ->  [  Group  β ] ->  (  f :  α → β ) ->  [  IsGroupHom  f ] ->  [  IsGroupHom  f.symm ] ->  (  Hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓ  α ] ->  [  Groupₓ  β ] ->  (  f :  α → β ) ->  [  IsGroupHom  f ] ->  [  IsGroupHom  f.symm ] ->  (  Hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓ  α ] ->  [  Groupₓₓ  β ] ->  (  f :  α → β ) ->  [  IsGroupHom  f ] ->  [  IsGroupHom  f.symm ] ->  (  Hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓₓ  α ] ->  [  Group  β ] ->  (  f :  α → β ) ->  [  IsGroupHom  f ] ->  [  IsGroupHom  f.symm ] ->  (  Hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓₓ  α ] ->  [  Groupₓ  β ] ->  (  f :  α → β ) ->  [  IsGroupHom  f ] ->  [  IsGroupHom  f.symm ] ->  (  Hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓₓ  α ] ->  [  Groupₓₓ  β ] ->  (  f :  α → β ) ->  [  IsGroupHom  f ] ->  [  IsGroupHom  f.symm ] ->  (  Hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  n :  ℕ } ->  (  f :   FreeGroup  α n →*  FreeGroup  α n ) ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective   ⇑ f

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  {  f :   FreeGroup  α →*  FreeGroup  α } ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective   (  f   :   FreeGroup  α →  FreeGroup  α )

 {  n :  ℕ } ->  {  G :  Type  u_1 } ->  [  Group  G ] ->  (  f :   FreeGroup.of   (   Fin  n  ) →* G ) ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective   (   f ∘ mk  )

 {  n :  ℕ } ->  {  G :  Type  u_1 } ->  [  Group  G ] ->  (  f :   FreeGroup.of   (   Finₓ  n  ) →* G ) ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective   (   f ∘ mk  )

 {  n :  ℕ } ->  {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  f :   FreeGroup.of   (   Fin  n  ) →* G ) ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective   (   f ∘ mk  )

 {  n :  ℕ } ->  {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  f :   FreeGroup.of   (   Finₓ  n  ) →* G ) ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective   (   f ∘ mk  )

 {  n :  ℕ } ->  {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  f :   FreeGroup.of   (   Fin  n  ) →* G ) ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective   (   f ∘ mk  )

 {  n :  ℕ } ->  {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  f :   FreeGroup.of   (   Finₓ  n  ) →* G ) ->  (  hf :  Function.Surjective   ⇑ f ) ->  Function.Injective   (   f ∘ mk  )

 {  α :  Type  u } ->  {  n :  ℕ } ->  [  DecidableEq  α ] ->  [  Fintype  α ] ->  (  f :   FreeGroup  α n →+*  FreeGroup  α n ) ->  (  hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u } ->  {  n :  ℕ } ->  [  DecidableEq  α ] ->  [  Fintypeₓ  α ] ->  (  f :   FreeGroup  α n →+*  FreeGroup  α n ) ->  (  hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  G :  Type  u_2 } ->  (  f :  G →* α ) ->  [  is_finset_fintype  G ] ->  [  is_finset_fintype  α ] ->  (  hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  G :  Type  u_2 } ->  (  f :  G →* α ) ->  [  is_finset_fintype  G ] ->  [  is_finset_fintype  α ] ->  (  hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  G :  Type  u_2 } ->  (  f :  G →* α ) ->  [  is_finset_fintype  G ] ->  [  is_finset_fintype  α ] ->  (  hf :  Function.Surjective  f ) ->  Function.Injective  f

 {  α :  Type  u_1 } ->  {  f :   FreeGroup  α →*  FreeGroup  α } ->  (  h :  Function.Surjective   ⇑ f ) ->  Function.Injective  f

failed to elaborate

outputs: #[{α : Type u_1} {G : Type u_2} [group G] {f : free_group α →* G} (hf : function.surjective ⇑f) : function.injective f , {α : Type u_1} (f : free_group α →* free_group α) (hf : function.surjective ⇑f) [fintype α] : function.injective f , {α : Type u_1} {β : Type u_2} [group α] [group β] {f : α → β} (hfg : group.is_finitely_generated α) (hf : is_group_hom f) (hf' : function.surjective f) : function.injective f , {α : Type u_1} {G : Type u_2} [group G] {f : free_group α → G} (gen : set α) (hn : fintype gen) (h : function.surjective f) : function.injective f , {α : Type u_1} {n : ℕ} [decidable_eq α] [fintype α] (f : free_group α n →+* free_group α n) (hf : function.surjective f) : function.injective f , {α : Type u_1} (n : ℕ) (H : n ≥ 0) {G : Type u_2} [group G] (f : free_group α ⟶* G) (hf : function.surjective (function.injective.eq_iff.mpr f.injective)) : function.injective f , {α : Type u} {β : Type v} [free_group α] [free_group β] {f : α → β} [is_group_hom f] (hf : function.surjective f) : function.injective f , {η : Type u_1} [h : nonempty η] : injective (free_group.of : η →* free_group η) , {α : Type u_1} {G : Type u_2} {n : ℕ} [group α] [group G] (H : (n : ℤ) ≠ 0) (f : free_group α →* G) (h : function.surjective ⇑f) : function.injective f , {α : Type u} {f : free_group α →* free_group α} (hf : function.surjective ⇑f) (hfg : fintype.countable α) : function.injective f , {α : Type u} {B : set α} [decidable_eq α] [fintype B] [fintype (free_group.quotient B)] {f : free_group.quotient B →* free_group.quotient B} (hf : function.surjective ⇑f) : function.injective f , {α : Type u} {n : ℕ} (h : n > 0) (f : free_group α n →* free_group α n) (hf : function.surjective f) : function.injective f , {α : Type u} [fintype α] {G : Type v} [group G] (f : free_group α →* G) (h : function.surjective ⇑f) : function.injective f , {α : Type u} {β : Type v} [group α] [group β] (f : α → β) [is_group_hom f] [is_group_hom f.symm] (Hf : function.surjective f) : function.injective f , {α : Type u} {n : ℕ} (f : free_group α n →* free_group α n) (hf : function.surjective ⇑f) : function.injective ⇑f , {α : Type u_1} [decidable_eq α] {f : free_group α →* free_group α} (hf : function.surjective ⇑f) : function.injective (f : free_group α → free_group α) , {n : ℕ} {G : Type u_1} [group G] (f : free_group.of (fin n) →* G) (hf : function.surjective ⇑f) : function.injective (f∘mk) , {α : Type u} {n : ℕ} [decidable_eq α] [fintype α] (f : free_group α n →+* free_group α n) (hf : function.surjective f) : function.injective f , {α : Type u_1} [group α] {G : Type u_2} (f : G →* α) [is_finset_fintype G] [is_finset_fintype α] (hf : function.surjective f) : function.injective f , {α : Type u_1} {f : free_group α →* free_group α} (h : function.surjective ⇑f) : function.injective f ]

total : 27

elaborated: 20

Every positive even integer can be written as the sum of two primes.

success

theorem ∀ (n : ℕ) (a : 0 < n) (a : Even n), ∃ a b, a ≠ b ∧ Nat.Prime a ∧ Nat.Prime b ∧ a + b = n

total : 28

elaborated: 21

Every matrix satisfies its own characteristic polynomial.

success

theorem ∀ {A : Type u} {n : Type v} [inst : CommRingₓ A] [inst_1 : Fintype n] [inst_2 : DecidableEq n] (M : Matrix n n A),
  AlgHom.toFun (Polynomial.aeval M) (Matrix.charpoly M) = 0

total : 29

elaborated: 22

The square root of an irrational number is irrational.

No valid output from Codex; outputs below

 {  a :   ℝ  ℝ } ->   Irrational  a →  Irrational   (   sqrt  a  )

 {  x :   ℝ  ℝ } ->   Irrational  x →  Irrational   (   sqrt  x  )

 {  x :   ℝ  ℝ } ->  (  hx :  Irrational  x ) ->  (  hx0 :  x ≠  0 ) ->  Irrational   (   x.root   2  )

 (  x :   ℝ  ℝ ) ->  (  irr :  Irrational  x ) ->  Irrational   (   Real.sqrt  x  )

 {  r :   ℝ  ℝ } ->   Irrational  r →  Irrational   (   Real.sqrt  r  )

 {  x :   ℝ  ℝ } ->  (  hx :  Irrational  x ) ->  Irrational   (   Real.sqrt  x  )

 {  x :   ℝ  ℝ } ->   Irrational   (   x * x  ) →  Irrational  x

 {  α :  Type  u_1 } ->  [  LinearOrderedField  α ] ->  {  x : α } ->  (  hx :   Irrational  x ∧   0 < x ) ->  Irrational   (   sqrt  x  )

 {  x :   ℝ  ℝ } ->  (  hx :  Irrational  x ) ->  (  hx0 :   0 ≤ x ) ->  Irrational   (   Real.sqrt  x  )

 {  x :   ℝ  ℝ } ->  (  h :  Irrational  x ) ->  (  hx0 :  x ≠  0 ) ->  Irrational   (   sqrt  x  )

 {  x :   ℝ  ℝ } ->  (  hx :  Irrational  x ) ->  Irrational   (   Real.sqrt   (   ↑ x  )  )

 {  x :   ℝ  ℝ } ->  (  hx :  Irrational  x ) ->  Irrational   (   sqrt  x  )

 {  x :   ℝ  ℝ } ->  (  hx :  Irrational  x ) ->  (  hxn0 :  x ≠  0 ) ->  Irrational   (   sqrt  x  )

 {  x :   ℝ  ℝ } ->  (  hx :  Irrational  x ) ->  Irrational  x

failed to elaborate

outputs: #[{a : ℝ} : irrational a → irrational (sqrt a) , {x : ℝ} : irrational x → irrational (sqrt x) , {x : ℝ} (hx : irrational x) (hx0 : x ≠ 0) : irrational (x.root 2) , (x : ℝ) (irr : irrational x) : irrational (real.sqrt x) , {r : ℝ} : irrational r → irrational (real.sqrt r) , {x : ℝ} (hx : irrational x) : irrational (real.sqrt x) , {x : ℝ} : irrational (x * x) → irrational x , {α : Type u_1} [linear_ordered_field α] {x : α} (hx : irrational x ∧ 0 < x) : irrational (sqrt x) , {x : ℝ} (hx : irrational x) (hx0 : 0 ≤ x) : irrational (real.sqrt x) , {x : ℝ} (h : irrational x) (hx0 : x ≠ 0) : irrational (sqrt x) , {x : ℝ} (hx : irrational x) : irrational (real.sqrt (↑x)) , {x : ℝ} (hx : irrational x) : irrational (sqrt x) , {x : ℝ} (hx : irrational x) (hxn0 : x ≠ 0) : irrational (sqrt x) , {x : ℝ} (hx : irrational x) : irrational x ]

total : 30

elaborated: 22

If the square of a number is even, the number itself is even.

success

theorem ∀ {m : ℕ}, Even (m * m) → Even m

total : 31

elaborated: 23

In a finite commutative ring, all prime ideals are maximal.

success

theorem ∀ {α : Type u} [inst : CommRing α] [inst_1 : Fintype α] {x y : α} (h : x ≠ 0),
  ∃ z, z * x = 1 ↔ ∃ z h, x ≠ 0 ∧ ∀ (w : α), z * w = 1 → y * w = y

total : 32

elaborated: 24

A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.

No valid output from Codex; outputs below

 {  X :  Type  u } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   {   p   :  X × X |   p .  1 =  p .  2 }

 {  X :  Type* } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   diag  X  )

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->   T2Space  α ↔  IsClosed   (   range   (   λ p :  α × α ,   p .  1 =  p .  2  )  )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   hausdorff_space  X ↔  IsClosed   (   {   x   :  X × X |   x .  1 =  x .  2 }   :  Set   (   X × X  ) )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   hausdorff_space  X ↔  IsClosed   (   {   x   :  X × X |   x .  1 =  x .  2 }   :  Setₓ   (   X × X  ) )

 {  X :  Type  u } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   λ x :  X × X ,  (   x .  1   ,   x .  2 )  )

 {  X :  Type  u } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   {   p   :  X × X |   p .  1 =  p .  2 }

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->   T2Space  α ↔  IsClosed   {   p   :  α × α |   p .  1 =  p .  2 }

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   set.prod.diag  X  )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   {   x   : X |  x = x }   :  Set   (   X × X  ) )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   {   x   : X |  x = x }   :  Setₓ   (   X × X  ) )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   {   p   :  X × X |   p .  1 =  p .  2 }  )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   diagonal  X  )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   diag  X  )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   set.diag  X  )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   hausdorff_space  X ↔  IsClosed   (  Δ   :  Set   (   X × X  ) )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   hausdorff_space  X ↔  IsClosed   (  Δ   :  Setₓ   (   X × X  ) )

 {  X :  Type  u } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   diagonal  X  )

 {  H :  Type  u_1 } ->  [  TopologicalSpace  H ] ->   T2Space  H ↔  IsClosed   (   Δ  H  )

 {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (   set.prod.diagonal  X  )

 {  X :  Type  u } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔   @ IsClosed   _  _  (    @ Prod.topologicalSpace  X X  )  ↑ diagonal

 {  X :  Type  u } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (  diagonal   :  Set   (   X × X  ) )

 {  X :  Type  u } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsClosed   (  diagonal   :  Setₓ   (   X × X  ) )

failed to elaborate

outputs: #[{X : Type u} [topological_space X] : t2_space X ↔ is_closed { p : X × X | p.1 = p.2 } , {X : Type*} [topological_space X] : t2_space X ↔ is_closed (diag X) , {α : Type u} [topological_space α] : t2_space α ↔ is_closed (range (λp : α × α, p.1 = p.2)) , {X : Type u_1} [topological_space X] : hausdorff_space X ↔ is_closed ({x : X × X | x.1 = x.2} : set (X × X)) , {X : Type u} [topological_space X] : t2_space X ↔ is_closed (λ x : X × X, (x.1, x.2)) , {X : Type u} [topological_space X] : t2_space X ↔ is_closed {p:X×X | p.1 = p.2} , {α : Type u} [topological_space α] : t2_space α ↔ is_closed {p : α × α | p.1 = p.2} , {X : Type u_1} [topological_space X] : t2_space X ↔ is_closed (set.prod.diag X) , {X : Type u_1} [topological_space X] : t2_space X ↔ is_closed ({x : X | x = x} : set (X × X)) , {X : Type u_1} [topological_space X] : t2_space X ↔ is_closed ({p : X × X | p.1 = p.2}) , {X : Type u_1} [topological_space X] : t2_space X ↔ is_closed (diagonal X) , {X : Type u_1} [topological_space X] : t2_space X ↔ is_closed (diag X) , {X : Type u_1} [topological_space X] : t2_space X ↔ is_closed (set.diag X) , {X : Type u_1} [topological_space X] : hausdorff_space X ↔ is_closed (Δ : set (X × X)) , {X : Type u} [topological_space X] : t2_space X ↔ is_closed (diagonal X) , {H : Type u_1} [topological_space H] : t2_space H ↔ is_closed (Δ H) , {X : Type u_1} [topological_space X] : t2_space X ↔ is_closed (set.prod.diagonal X) , {X : Type u} [topological_space X] : t2_space X ↔ @is_closed _ _ (@prod.topological_space X X) ↑diagonal , {X : Type u} [topological_space X] : t2_space X ↔ is_closed (diagonal : set (X × X)) ]

total : 33

elaborated: 24

If every point of a subset of a topological space is contained in some open set, the subset itself is open.

success

theorem ∀ {α : Type u} {s : Set α} [inst : TopologicalSpace α], (∀ (x : α), x ∈ s → ∃ t, IsOpen t ∧ x ∈ t) → IsOpen s

total : 34

elaborated: 25

Every non-identity element of a free group is of infinite order.

success

theorem ∀ {G : Type u}, FreeGroup G → ∀ {g : FreeGroup G}, g ≠ 1 → ¬IsOfFinOrder g

total : 35

elaborated: 26

An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.

No valid output from Codex; outputs below

 {  A :  Type  u_1 } ->  [  DiscreteValuationRing  A ] ->  (  x : A ) ->   IsUnit  x ↔     (   valuation.map  A  ) . to_fun  x =  0

 (  K :  Type  u_1 ) ->  [  DiscreteValuationRing  K ] ->  {  x : K } ->   IsUnit  x ↔  valuation_set  K  0 x

 (  R :  Type  u ) ->  [  DiscreteValuationRing  R ] ->  {  r : R } ->   IsUnit  r ↔   ⇑    (   discrete_valuation_ring.valuation  R  )  r =  0  ⇑    (   discrete_valuation_ring.valuation  R  )  rdiscrete_valuation_ring.valuation  R  )  r =  0  ⇑    (   discrete_valuation_ring.valuation  R  )  r =  0

 {  R :  Type  u } ->  [  CommRing  R ] ->  [  IsDomain  R ] ->  [  DiscreteValuationRing  R ] ->  (  r : R ) ->   IsUnit  r ↔   vr.valuation  r =  0

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  [  IsDomain  R ] ->  [  DiscreteValuationRing  R ] ->  (  r : R ) ->   IsUnit  r ↔   vr.valuation  r =  0

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  [  IsDomain  R ] ->  [  DiscreteValuationRing  R ] ->  (  r : R ) ->   IsUnit  r ↔   vr.valuation  r =  0

 (  R :  Type  u_1 ) ->  [  DiscreteValuationRing  R ] ->  (  a : R ) ->   IsUnit  a ↔  ∃    (   q :  ℕ ) ,   (   v_R  a  ) =  q •  V   ↑  (   nat.prime_factors  R  )

 {  R :  Type  u_1 } ->  [  DiscreteValuationRing  R ] ->  {  a : R } ->   IsUnit  a ↔   Valuation  a =  0

(R : Type u_1) [comm_ring R] [is_domain R] [discrete_valuation_ring R] {x : R} : is_unit x ↔ v(x) = 0 

 (  R :  Type  u ) ->  [  CommRing  R ] ->  [  DiscreteValuationRing  R ] ->  {  x : R } ->   IsUnit  x ↔    (   valuation_of_discrete_valuation_ring  R  )  x =  0

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  [  DiscreteValuationRing  R ] ->  {  x : R } ->   IsUnit  x ↔    (   valuation_of_discrete_valuation_ring  R  )  x =  0

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  [  DiscreteValuationRing  R ] ->  {  x : R } ->   IsUnit  x ↔    (   valuation_of_discrete_valuation_ring  R  )  x =  0

 {  R :  Type  u } ->  [  DiscreteValuationRing  R ] ->  {  x : R } ->   IsUnit  x ↔  Valuation   0 x

{R : Type u} [discrete_valuation_ring R] : ∀ ⦃x : R⦄, is_unit x ↔ x ≠ 0 ∧ v(x) = 0 

 (  R :  Type  u_1 ) ->  [  CommRing  R ] ->  [  DiscreteValuationRing  R ] ->  {  a : R } ->   IsUnit  a ↔   valuation.of  a =  0

 (  R :  Type  u_1 ) ->  [  CommRingₓ  R ] ->  [  DiscreteValuationRing  R ] ->  {  a : R } ->   IsUnit  a ↔   valuation.of  a =  0

 (  R :  Type  u_1 ) ->  [  CommRingₓₓ  R ] ->  [  DiscreteValuationRing  R ] ->  {  a : R } ->   IsUnit  a ↔   valuation.of  a =  0

 (  R :  Type  u ) ->  [  DiscreteValuationRing  R ] ->  {  a : R } ->   IsUnit  a ↔     (   Valuation  R a  ) . val  a =  0

 {  R :  Type  u } ->  [  DiscreteValuationRing  R ] ->  {  x : R } ->   IsUnit  x ↔   valuation_of  x =  0

 (  R :  Type  u ) ->  [  DiscreteValuationRing  R ] ->  (  a : R ) ->   IsUnit  a ↔   val  a =  0

 {  R :  Type  u } ->  [  DiscreteValuationRing  R ] ->  {  x : R } ->   IsUnit  x ↔   v  x =  0

 {  R :  Type  u } ->  [  DiscreteValuationRing  R ] ->  {  x : R } ->   IsUnit  x ↔  classical.prop_decidable   (    valuation_ring.valuation  R x =  0  )

 (  R :  Type  u ) ->  [  DiscreteValuationRing  R ] ->  {  a : R } ->   IsUnit  a ↔     (   valuation.map  R  ) . to_add_monoid_hom  a =  0

 (  R :  Type  u ) ->  [  DiscreteValuationRing  R ] ->  (  x : R ) ->   IsUnit  x ↔   (   valuation_of  x  ) =  0

 (  R :  Type  u_1 ) ->  [  DiscreteValuationRing  R ] ->  {  x : R } ->   IsUnit  x ↔   ↑  (   valuation_on_discrete_valuation_ring  R x  ) =  0

 {  R :  Type  u } ->  [  CommRing  R ] ->  [  DiscreteValuationRing  R ] ->  (  x : R ) ->   IsUnit  x ↔   v  x =  0

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  [  DiscreteValuationRing  R ] ->  (  x : R ) ->   IsUnit  x ↔   v  x =  0

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  [  DiscreteValuationRing  R ] ->  (  x : R ) ->   IsUnit  x ↔   v  x =  0

failed to elaborate

outputs: #[{A : Type u_1} [discrete_valuation_ring A] (x : A) : is_unit x ↔ (valuation.map A).to_fun x = 0 , (K : Type u_1) [discrete_valuation_ring K] {x : K} : is_unit x ↔ valuation_set K 0 x , (R : Type u) [discrete_valuation_ring R] {r : R} : is_unit r ↔ ⇑(discrete_valuation_ring.valuation R) r = 0 , {R : Type u} [comm_ring R] [is_domain R] [discrete_valuation_ring R] (r : R) : is_unit r ↔ vr.valuation r = 0 , (R : Type u_1) [discrete_valuation_ring R] (a : R) : is_unit a ↔ ∃ (q : ℕ), (v_R a) = q • V ↑(nat.prime_factors R) , {R : Type u_1} [discrete_valuation_ring R] {a : R} :
  is_unit a ↔ valuation a = 0 , (R : Type u_1) [comm_ring R] [is_domain R] [discrete_valuation_ring R] {x : R} : is_unit x ↔ v(x) = 0 , (R : Type u) [comm_ring R] [discrete_valuation_ring R] {x : R} : is_unit x ↔ (valuation_of_discrete_valuation_ring R) x = 0 , {R : Type u} [discrete_valuation_ring R] {x : R} : is_unit x ↔ has_valuation 0 x , {R : Type u} [discrete_valuation_ring R] : ∀ ⦃x : R⦄, is_unit x ↔ x ≠ 0 ∧ v(x) = 0 , (R : Type u_1) [comm_ring R] [discrete_valuation_ring R] {a : R} : is_unit a ↔ valuation.of a = 0 , (R : Type u) [discrete_valuation_ring R] {a : R} : is_unit a ↔ (valuation R a).val a = 0 , {R : Type u} [discrete_valuation_ring R] {x : R} : is_unit x ↔ valuation_of x = 0 , (R : Type u) [discrete_valuation_ring R] (a : R) : is_unit a ↔ val a = 0 , {R : Type u} [discrete_valuation_ring R] {x : R} : is_unit x ↔ v x = 0 , {R : Type u} [discrete_valuation_ring R] {x : R} : is_unit x ↔ classical.prop_decidable (valuation_ring.valuation R x = 0) , (R : Type u) [discrete_valuation_ring R] {a : R} : is_unit a ↔ (valuation.map R).to_add_monoid_hom a = 0 , (R : Type u) [discrete_valuation_ring R] (x : R) : is_unit x ↔ (valuation_of x) = 0 , (R : Type u_1) [discrete_valuation_ring R] {x : R} : is_unit x ↔ ↑(valuation_on_discrete_valuation_ring R x) = 0 , {R : Type u} [comm_ring R] [discrete_valuation_ring R] (x : R) : is_unit x ↔ v x = 0 ]

total : 36

elaborated: 26

For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.

success

theorem ∀ {a b : ℕ}, a = 1 ∨ b = 1 → 1 < a * b → ∃ n, ∀ (N : ℕ), n ≤ N → ∃ x y, a * x + b * y = N

total : 37

elaborated: 27

Every field is a ring.

success

theorem {α : Type u_1} → [inst : Field α] → NonAssocRing α

total : 38

elaborated: 28

The set of units in a ring forms a group.

success

theorem {R : Type u_1} → [inst : Ringₓ R] → Group (Units R)

total : 39

elaborated: 29

If the direct product of two groups is torsion free then each of the groups is torsion free.

success

theorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Groupₓ (Gs i)],
  Monoidₓ.IsTorsionFree ((i : η) → Gs i) → ∀ (i : η), Monoidₓ.IsTorsionFree (Gs i)

total : 40

elaborated: 30

No valid output from Codex; outputs below

"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1"

No valid output from Codex; outputs below

"∀ (p : ℕ)  p = 2 ∨ p % 2 = 1"

No valid output from Codex; outputs below

"∀ (p : ℕ)  p = 2 ∨ p % 2 = 1"

No valid output from Codex; outputs below

"∀ (p : ℕ),  p = 2 ∨ p % 2 = 1"

No valid output from Codex; outputs below

"Nat"

No valid output from Codex; outputs below

"Nat"

No valid output from Codex; outputs below

Nat

No valid output from Codex; outputs below

∀ (p : ℕ),  p = 2 ∨ p % 2 = 1

No valid output from Codex; outputs below

∀ (p : ℕ),  p = 2 ∨ p % 2 = 1

No valid output from Codex; outputs below

∀ (p : Nat),  p = 2 ∨ p % 2 = 1

No valid output from Codex; outputs below

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroup  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroup  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroup  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroup  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  Field  K ] ->  [  AddCommGroup  V ] ->  [  vector_space  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  Field  K ] ->  [  AddCommGroupₓ  V ] ->  [  vector_space  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  Field  K ] ->  [  AddCommGroupₓₓ  V ] ->  [  vector_space  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

No valid output from Codex; outputs below

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroup  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroup  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroup  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  Field  K ] ->  [  AddCommGroup  V ] ->  [  vector_space  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  Field  K ] ->  [  AddCommGroupₓ  V ] ->  [  vector_space  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  Field  K ] ->  [  AddCommGroupₓₓ  V ] ->  [  vector_space  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroup  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

 {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  module.finite_dimensional  K V

No valid output from Codex; outputs below

No valid output from Codex; outputs below

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

No valid output from Codex; outputs below

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

No valid output from Codex; outputs below

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ m % 2 = 1

Writing to file: silly-elab-10-false-5-2.json

Writing to file: silly-elab-10-false-5-2.json

success

theorem ∀ {p : ℕ}, Nat.Prime p ↔ p = 2 ∨ p % 2 = 1

total : 1

elaborated: 1

success

theorem ∀ (n : ℕ), ∃ m, m > n ∧ Odd m

total : 2

elaborated: 2

Writing to file: silly-elab-10-false-5-2.json

success

theorem ∀ {p : ℕ}, Nat.Prime p ↔ p = 2 ∨ p % 2 = 1

total : 1

elaborated: 1

success

theorem ∀ (n : ℕ), ∃ m, m > n ∧ Odd m

total : 2

elaborated: 2

success

theorem Nat.minFac 3 = 3

total : 3

elaborated: 3

success

theorem ∀ (n : ℕ), ∃ p, Nat.Prime p ∧ Odd p ∧ p > n

total : 4

elaborated: 4

No valid output from Codex; outputs below

∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 :  AddCommGroupCat V] [inst_2 :  ModuleCat K V]
  (h : FiniteDimensional.finrank K V = 2), FiniteDimensional K V

failed to elaborate

outputs: #[∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]
  (h : FiniteDimensional.finrank K V = 2), FiniteDimensional K V]

total : 5

elaborated: 4

