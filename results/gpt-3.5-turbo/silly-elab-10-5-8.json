{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 5,
 "prompt-examples":
 {"sequence":
  [{"embedSearch": {"penalty": 1, "n": 10, "descField": "docString"}},
   {"embedSearch": {"penalty": 1, "n": 2, "descField": "concise-description"}},
   {"embedSearch": {"penalty": 1, "n": 2, "descField": "description"}},
   {"moogle":
    {"preferDocs": true,
     "n": 2,
     "descFields": ["concise-description", "description"]}}]},
 "number-similar-sentences":
 "docString:10-concise-description:2-description:2-moogle:2",
 "failures":
 [[{"parsed":
    {"text":
     "âˆ€ {ğ•œ : Type u} {E : Type v} [inst : Field ğ•œ] [inst_1 : Module ğ•œ E] [inst_2 : FiniteDimensional ğ•œ E],\n  Dimension ğ•œ E = 2 â†’ FiniteDimensional ğ•œ E",
     "elabError":
     "failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [ğ•œ, u, E, v, inst, Field, ğ•œ, inst_1, Module, ğ•œ, E, inst_2, FiniteDimensional, ğ•œ, E, Dimension, ğ•œ, E, FiniteDimensional, ğ•œ, E] (during elaboration) for âˆ€ {ğ•œ : Type u} {E : Type v} [inst : Field ğ•œ] [inst_1 : Module ğ•œ E] [inst_2 : FiniteDimensional ğ•œ E],\n  Dimension ğ•œ E = 2 â†’ FiniteDimensional ğ•œ E",
     "context?": "If a space has dimension `2` then it is finite dimensional.",
     "cmdErrors":
     ["failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.",
      "unused universe parameter 'v'"]}},
   {"parsed":
    {"text":
     "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : Field ğ•œ] [inst_1 : Module ğ•œ E], Dim ğ•œ E = 2 â†’ FiniteDimensional ğ•œ E",
     "elabError":
     "failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [ğ•œ, u_1, E, u_2, inst, Field, ğ•œ, inst_1, Module, ğ•œ, E, Dim, ğ•œ, E, FiniteDimensional, ğ•œ, E] (during elaboration) for âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : Field ğ•œ] [inst_1 : Module ğ•œ E], Dim ğ•œ E = 2 â†’ FiniteDimensional ğ•œ E",
     "context?": "If a space has dimension `2` then it is finite dimensional.",
     "cmdErrors":
     ["failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.",
      "unused universe parameter 'u_2'"]}},
   {"parsed":
    {"text":
     "âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : VectorSpace K V], Dimension K V = 2 â†’ FiniteDimensional K V",
     "elabError":
     "unknown identifier 'VectorSpace' ; identifiers [K, u, V, v, inst, Field, K, inst_1, VectorSpace, K, V, Dimension, K, V, FiniteDimensional, K, V] (during elaboration) for âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : VectorSpace K V], Dimension K V = 2 â†’ FiniteDimensional K V",
     "context?": "If a space has dimension `2` then it is finite dimensional.",
     "cmdErrors":
     ["invalid binder annotation, type is not a class instance\n  ?m.22\nuse the command `set_option checkBinderAnnotations false` to disable the check",
      "function expected at\n  VectorSpace\nterm has type\n  ?m.11",
      "unused universe parameter 'v'"]}},
   {"parsed":
    {"text":
     "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E],\n  Dimension ğ•œ E = 2 â†’ FiniteDimensional ğ•œ E",
     "elabError":
     "unknown identifier 'Dimension' ; identifiers [ğ•œ, u_1, E, u_2, inst, Field, ğ•œ, inst_1, AddCommGroup, E, inst_2, Module, ğ•œ, E, Dimension, ğ•œ, E, FiniteDimensional, ğ•œ, E] (during elaboration) for âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : Field ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E],\n  Dimension ğ•œ E = 2 â†’ FiniteDimensional ğ•œ E",
     "context?": "If a space has dimension `2` then it is finite dimensional.",
     "cmdErrors":
     ["function expected at\n  Dimension\nterm has type\n  ?m.813"]}},
   {"parsed":
    {"text":
     "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : Field ğ•œ] [inst_1 : Module ğ•œ E], FiniteDimensional ğ•œ E â†’ FiniteDimensional.finrank ğ•œ E = 2",
     "elabError":
     "failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [ğ•œ, u_1, E, u_2, inst, Field, ğ•œ, inst_1, Module, ğ•œ, E, FiniteDimensional, ğ•œ, E, FiniteDimensional.finrank, ğ•œ, E] (during elaboration) for âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : Field ğ•œ] [inst_1 : Module ğ•œ E], FiniteDimensional ğ•œ E â†’ FiniteDimensional.finrank ğ•œ E = 2",
     "context?": "If a space has dimension `2` then it is finite dimensional.",
     "cmdErrors":
     ["failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.",
      "unused universe parameter 'u_2'"]}}],
  [{"parsed":
    {"text": "âˆ€ (m n : â„•), m + n âˆˆ â„•",
     "elabError":
     "failed to synthesize\n  Membership â„• Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [m, n, m, n] (during elaboration) for âˆ€ (m n : â„•), m + n âˆˆ â„•",
     "context?": "The sum of two natural numbers is a natural number.",
     "cmdErrors":
     ["failed to synthesize\n  Membership â„• Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text": "âˆ€ (m n : â„•), m + n âˆˆ â„•",
     "elabError":
     "failed to synthesize\n  Membership â„• Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [m, n, m, n] (during elaboration) for âˆ€ (m n : â„•), m + n âˆˆ â„•",
     "context?": "The sum of two natural numbers is a natural number.",
     "cmdErrors":
     ["failed to synthesize\n  Membership â„• Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text": "âˆ€ (a b : â„•), a + b âˆˆ â„•",
     "elabError":
     "failed to synthesize\n  Membership â„• Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [a, b, a, b] (during elaboration) for âˆ€ (a b : â„•), a + b âˆˆ â„•",
     "context?": "The sum of two natural numbers is a natural number.",
     "cmdErrors":
     ["failed to synthesize\n  Membership â„• Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text": "âˆ€ (m n : â„•), m + n âˆˆ â„•",
     "elabError":
     "failed to synthesize\n  Membership â„• Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [m, n, m, n] (during elaboration) for âˆ€ (m n : â„•), m + n âˆˆ â„•",
     "context?": "The sum of two natural numbers is a natural number.",
     "cmdErrors":
     ["failed to synthesize\n  Membership â„• Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text": "âˆ€ (m n : â„•), m + n âˆˆ â„•",
     "elabError":
     "failed to synthesize\n  Membership â„• Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [m, n, m, n] (during elaboration) for âˆ€ (m n : â„•), m + n âˆˆ â„•",
     "context?": "The sum of two natural numbers is a natural number.",
     "cmdErrors":
     ["failed to synthesize\n  Membership â„• Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}}],
  [{"unparsed":
    {"text": "(8.primesBelow).card = 3",
     "parseError": "<input>:1:3: expected ')', ',' or ':'",
     "context?": "There are `3` prime numbers below `8`."}},
   {"unparsed":
    {"text": "(8.primesBelow.card = 3)",
     "parseError": "<input>:1:3: expected ')', ',' or ':'",
     "context?": "There are `3` prime numbers below `8`."}},
   {"unparsed":
    {"text": "(8.primesBelow).card = 3",
     "parseError": "<input>:1:3: expected ')', ',' or ':'",
     "context?": "There are `3` prime numbers below `8`."}},
   {"unparsed":
    {"text": "(8.primesBelow).card = 3",
     "parseError": "<input>:1:3: expected ')', ',' or ':'",
     "context?": "There are `3` prime numbers below `8`."}},
   {"unparsed":
    {"text": "(8.primesBelow).card = 3",
     "parseError": "<input>:1:3: expected ')', ',' or ':'",
     "context?": "There are `3` prime numbers below `8`."}}],
  [{"parsed":
    {"text":
     "âˆ€ (F : Type u_1) [inst : Field F], Â¬IsFiniteField F âˆ§ F.card = 10",
     "elabError":
     "unknown identifier 'IsFiniteField' ; identifiers [F, u_1, inst, Field, F, IsFiniteField, F, F.card] (during elaboration) for âˆ€ (F : Type u_1) [inst : Field F], Â¬IsFiniteField F âˆ§ F.card = 10",
     "context?": "There is no field of order `10`.",
     "cmdErrors":
     ["invalid field notation, type is not of the form (C ...) where C is a constant\n  F\nhas type\n  Type u_1",
      "function expected at\n  IsFiniteField\nterm has type\n  ?m.9"]}},
   {"parsed":
    {"text": "âˆ€ (F : Type u_1) [inst : Field F], fintype.card F â‰  10",
     "elabError":
     "unknown identifier 'fintype.card' ; identifiers [F, u_1, inst, Field, F, fintype.card, F] (during elaboration) for âˆ€ (F : Type u_1) [inst : Field F], fintype.card F â‰  10",
     "context?": "There is no field of order `10`.",
     "cmdErrors": ["unknown identifier 'fintype.card'"]}},
   {"unparsed":
    {"text": "Â¬âˆƒ (F : Type u) [inst : Field F], Cardinal.mk F = 10",
     "parseError": "<input>:1:16: expected ','",
     "context?": "There is no field of order `10`."}},
   {"parsed":
    {"text":
     "âˆ€ (F : Type u) [inst : FiniteField F] (h : Cardinal.mk F = 10), False",
     "elabError":
     "unknown identifier 'FiniteField' ; identifiers [F, u, inst, FiniteField, F, h, Cardinal.mk, F, False] (during elaboration) for âˆ€ (F : Type u) [inst : FiniteField F] (h : Cardinal.mk F = 10), False",
     "context?": "There is no field of order `10`.",
     "cmdErrors":
     ["invalid binder annotation, type is not a class instance\n  ?m.12\nuse the command `set_option checkBinderAnnotations false` to disable the check",
      "function expected at\n  FiniteField\nterm has type\n  ?m.6",
      "unused universe parameter 'u'"]}},
   {"parsed":
    {"text": "âˆ€ (F : Type u_1) [inst : Field F], Â¬(fintype.card F = 10)",
     "elabError":
     "unknown identifier 'fintype.card' ; identifiers [F, u_1, inst, Field, F, fintype.card, F] (during elaboration) for âˆ€ (F : Type u_1) [inst : Field F], Â¬(fintype.card F = 10)",
     "context?": "There is no field of order `10`.",
     "cmdErrors": ["unknown identifier 'fintype.card'"]}}]],
 "elaborated-prompts":
 [{"theorem": "âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ Odd p",
     "âˆ€ (n : â„•), Nat.Prime n â†’ n = 2 âˆ¨ Odd n"],
    ["âˆ€ (p : â„•), Nat.Prime p â†” p = 2 âˆ¨ Odd p",
     "âˆ€ {p : â„•}, Nat.Prime p â†” p = 2 âˆ¨ Odd p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (p : â„•), Nat.Prime p â†” p = 2 âˆ¨ Odd p",
    "âˆ€ {p : â„•}, Nat.Prime p â†” p = 2 âˆ¨ Odd p",
    "âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ Odd p",
    "âˆ€ (n : â„•), Nat.Prime n â†’ n = 2 âˆ¨ Odd n"]},
  {"theorem": "Infinite { n // Odd n }",
   "some-correct": null,
   "prompt": "There are infinitely many odd natural numbers.",
   "groups":
   [["Infinite { n // Odd n }"],
    ["âˆƒá¶  (n : â„•) in Filter.atTop, Odd n"],
    ["Infinite { n // n % 2 = 1 }"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆƒá¶  (n : â„•) in Filter.atTop, Odd n",
    "Infinite {n : â„• // n % 2 = 1}",
    "Infinite {n : â„• // Odd n}"]},
  {"theorem": "Nat.Prime 3",
   "some-correct": null,
   "prompt": "The smallest odd prime is `3`.",
   "groups": [["Nat.Prime 3", "Nat.Prime 3", "Nat.Prime 3", "Nat.Prime 3"]],
   "correct": null,
   "comments": "",
   "all-elabs": ["Nat.Prime 3", "Nat.Prime 3", "Nat.Prime 3", "Nat.Prime 3"]},
  {"theorem": "{p | Nat.Prime p âˆ§ p % 2 = 1}.Infinite",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups":
   [["{p | Nat.Prime p âˆ§ p % 2 = 1}.Infinite",
     "{p | Nat.Prime p âˆ§ p % 2 = 1}.Infinite",
     "{p | Nat.Prime p âˆ§ p % 2 = 1}.Infinite",
     "{p | Nat.Prime p âˆ§ p % 2 = 1}.Infinite"],
    ["âˆƒ n â‰¥ 3, âˆƒ p, Nat.Prime p âˆ§ p % 2 = 1 âˆ§ p > n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p | p.Prime âˆ§ p % 2 = 1}",
    "{p | p.Prime âˆ§ p % 2 = 1}.Infinite",
    "{p | p.Prime âˆ§ p % 2 = 1}.Infinite",
    "âˆƒ (n : â„•), n â‰¥ 3 âˆ§ âˆƒ (p : â„•), p.Prime âˆ§ p % 2 = 1 âˆ§ p > n",
    "Set.Infinite {p | p.Prime âˆ§ p % 2 = 1}"]},
  {"theorem":
   "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V",
     "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V",
     "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V"],
    ["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 â†’ FiniteDimensional K V",
     "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 â†’ FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V",
    "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 â†’ FiniteDimensional K V",
    "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V",
    "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 â†’ FiniteDimensional K V",
    "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V"]},
  {"theorem": "(K : Type u) â†’ [inst : Field K] â†’ DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["(K : Type u) â†’ [inst : Field K] â†’ DivisionRing K",
     "(K : Type u) â†’ [inst : Field K] â†’ DivisionRing K",
     "(K : Type u) â†’ [inst : Field K] â†’ DivisionRing K",
     "(K : Type u) â†’ [inst : Field K] â†’ DivisionRing K",
     "(K : Type u) â†’ [inst : Field K] â†’ DivisionRing K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (K : Type u) [inst : Field K], DivisionRing K",
    "âˆ€ (K : Type u) [inst : Field K], DivisionRing K",
    "âˆ€ (K : Type u) [inst : Field K], DivisionRing K",
    "âˆ€ (K : Type u) [inst : Field K], DivisionRing K",
    "âˆ€ (K : Type u) [inst : Field K], DivisionRing K"]},
  {"theorem": "âˆ€ (n : â„•), âˆƒ m, m = n.succ",
   "some-correct": null,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["âˆ€ (n : â„•), âˆƒ m, m = n.succ",
     "âˆ€ (n : â„•), âˆƒ m, n.succ = m",
     "âˆ€ (n : â„•), âˆƒ m, n.succ = m",
     "âˆ€ (n : â„•), âˆƒ m, m = n + 1",
     "âˆ€ (n : â„•), âˆƒ m, n.succ = m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (n : â„•), âˆƒ (m : â„•), m = n.succ",
    "âˆ€ (n : â„•), âˆƒ m : â„•, n.succ = m",
    "âˆ€ (n : â„•), âˆƒ (m : â„•), n.succ = m",
    "âˆ€ (n : â„•), âˆƒ (m : â„•), m = n + 1",
    "âˆ€ (n : â„•), âˆƒ (m : â„•), n.succ = m"]},
  {"theorem": "âˆ€ (n : â„•), n < n.succ",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "groups":
   [["âˆ€ (n : â„•), n < n.succ",
     "âˆ€ (n : â„•), n < n.succ",
     "âˆ€ (n : â„•), n < n.succ",
     "âˆ€ (n : â„•), n < n.succ",
     "âˆ€ (n : â„•), n < n.succ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (n : â„•), n < n.succ",
    "âˆ€ (n : â„•), n < n.succ",
    "âˆ€ (n : â„•), n < n.succ",
    "âˆ€ (n : â„•), n < n.succ",
    "âˆ€ (n : â„•), n < n.succ"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set is Lebesgue measurable.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), MeasurableSet s"],
    ["âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} (s : Set Î±),\n  MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u_1} [inst : MetricSpace Î±] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} (s : Set Î±),\n  MeasurableSet s",
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), MeasurableSet s"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [h : MeasurableSpace Î±] [self : OpensMeasurableSpace Î±] (s : Set Î±),\n  ?m.257738 s = 0 â†’ MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set of Borel measure zero is Lebesgue measurable.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [h : MeasurableSpace Î±] [self : OpensMeasurableSpace Î±] (s : Set Î±),\n  ?m.257738 s = 0 â†’ MeasurableSet s"],
    ["âˆ€ {Î± : Type u_6} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [self : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±), ?m.257052 Î¼ s = 0 â†’ MeasurableSet s"],
    ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) [inst_1 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set Î±}, ?m.257224 Î¼ = 0 â†’ MeasurableSet s"],
    ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±), ?m.257396 Î¼ s = 0 â†’ MeasurableSet s"],
    ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set Î±}, ?m.257566 = 0 â†’ MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u_6} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [self : BorelSpace Î±] (Î¼ : MeasureTheory.Measure Î±),\n  (âˆ€ (s : Set Î±), â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s)",
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) [inst_1 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set Î±}, â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s",
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±),\n  â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s",
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set Î±}, â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s",
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [h : MeasurableSpace Î±] [self : OpensMeasurableSpace Î±],\n  âˆ€ (s : Set Î±), â†‘â†‘(borel Î±) s = 0 â†’ MeasurableSet s"]},
  {"theorem": "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬IsSquare p",
   "some-correct": null,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬IsSquare p",
     "âˆ€ {n : â„•}, Nat.Prime n â†’ Â¬IsSquare n",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬IsSquare p",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬IsSquare p",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬IsSquare p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬IsSquare p",
    "âˆ€ {n : â„•}, Nat.Prime n â†’ Â¬IsSquare n",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬IsSquare p",
    "âˆ€ {p : â„•}, p.Prime â†’ Â¬IsSquare p",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬IsSquare p"]},
  {"theorem": "âˆ€ (p : â„•), Nat.Prime p â†’ Odd p â†’ p > 2",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["âˆ€ (p : â„•), Nat.Prime p â†’ Odd p â†’ p > 2",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ p > 2",
     "âˆ€ {p : â„•}, Odd p â†’ Nat.Prime p â†’ p > 2",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ 2 < p",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ p > 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (p : â„•), Nat.Prime p â†’ Odd p â†’ p > 2",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ p > 2",
    "âˆ€ {p : â„•}, Odd p â†’ Nat.Prime p â†’ p > 2",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ 2 < p",
    "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ p > 2"]},
  {"theorem":
   "âˆ€ {a b c d x y z w : â„•},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’\n    b = c ^ 2 + d ^ 2 + z ^ 2 + w ^ 2 â†’ âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["âˆ€ {a b c d x y z w : â„•},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’\n    b = c ^ 2 + d ^ 2 + z ^ 2 + w ^ 2 â†’ âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],
    ["âˆ€ (a b : â„•),\n  â„• â†’\n    â„• â†’\n      âˆ€ (x y : â„•),\n        â„• â†’\n          â„• â†’\n            âˆƒ m n p q,\n              a = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 â†’\n                b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 â†’\n                  x = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 â†’ y = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2"],
    ["âˆ€ {a b : â„•} {c d x y z w : â„•},\n  (âˆƒ aâ‚ bâ‚ câ‚ dâ‚, a = aâ‚ ^ 2 + bâ‚ ^ 2 + câ‚ ^ 2 + dâ‚ ^ 2) â†’\n    (âˆƒ xâ‚ yâ‚ zâ‚ wâ‚, b = xâ‚ ^ 2 + yâ‚ ^ 2 + zâ‚ ^ 2 + wâ‚ ^ 2) â†’ âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],
    ["âˆ€ (a b c d w x : â„•),\n  â„• â†’\n    â„• â†’\n      (âˆƒ u v, a = u ^ 2 + v ^ 2) â†’\n        (âˆƒ m n, b = m ^ 2 + n ^ 2) â†’ âˆƒ r s, c = r ^ 2 + s ^ 2 âˆ§ d = w ^ 2 + x ^ 2 âˆ§ a * b = c ^ 2 + d ^ 2"],
    ["âˆ€ (a b c d x y z w : â„•),\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = âˆƒ r s t u, r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (a b c d x y z w : â„•),\n  âˆƒ (m n p q : â„•),\n    a = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 â†’ b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 â†’\n      x = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 â†’ y = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 â†’\n        âˆƒ (r s : â„•), a * b = r ^ 2 + s ^ 2",
    "âˆ€ {a b c d x y z w : â„•}, (âˆƒ aâ‚ bâ‚ câ‚ dâ‚, a = aâ‚ ^ 2 + bâ‚ ^ 2 + câ‚ ^ 2 + dâ‚ ^ 2) â†’ (âˆƒ xâ‚ yâ‚ zâ‚ wâ‚, b = xâ‚ ^ 2 + yâ‚ ^ 2 + zâ‚ ^ 2 + wâ‚ ^ 2) â†’ âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
    "âˆ€ (a b c d w x y z : â„•), (âˆƒ u v, a = u ^ 2 + v ^ 2) â†’ (âˆƒ m n, b = m ^ 2 + n ^ 2) â†’\n  âˆƒ r s, c = r ^ 2 + s ^ 2 âˆ§ d = w ^ 2 + x ^ 2 âˆ§ a * b = c ^ 2 + d ^ 2",
    "âˆ€ (a b c d x y z w : â„•),\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) =\n    âˆƒ (r s t u : â„•), r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
    "âˆ€ {a b c d x y z w : â„•}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = c ^ 2 + d ^ 2 + z ^ 2 + w ^ 2 â†’ âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]},
  {"theorem":
   "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]},
  {"theorem":
   "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
     "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
     "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f"],
    ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
     "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f"]},
  {"theorem": "âˆ€ (p q : â„•), Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ p + q â‰  6",
   "some-correct": null,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["âˆ€ (p q : â„•), Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ p + q â‰  6",
     "Â¬âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6",
     "âˆ€ {p q : â„•}, Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ p + q â‰  6"],
    ["âˆ€ (p q : â„•), Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ 6 â‰  p + q"],
    ["Â¬âˆƒ p q, Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ 6 = p + q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ p q : â„•, Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ p + q â‰  6",
    "Â¬âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6",
    "Â¬âˆƒ p q : â„•, Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ 6 = p + q",
    "âˆ€ {p q : â„•}, Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ p + q â‰  6",
    "âˆ€ p q : â„•, Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ 6 â‰  p + q"]},
  {"theorem": "âˆ€ (m : â„¤), Â¬Irrational â†‘m",
   "some-correct": null,
   "prompt": "No integer is irrational.",
   "groups":
   [["âˆ€ (m : â„¤), Â¬Irrational â†‘m",
     "âˆ€ (m : â„¤), Â¬Irrational â†‘m",
     "âˆ€ (m : â„¤), Â¬Irrational â†‘m",
     "âˆ€ (m : â„¤), Â¬Irrational â†‘m",
     "âˆ€ (n : â„¤), Â¬Irrational â†‘n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (m : â„¤), Â¬Irrational â†‘m",
    "âˆ€ (m : â„¤), Â¬Irrational â†‘m",
    "âˆ€ (m : â„¤), Â¬Irrational â†‘m",
    "âˆ€ (m : â„¤), Â¬ Irrational (m : â„)",
    "âˆ€ (n : â„¤), Â¬ Irrational â†‘n"]},
  {"theorem": "âˆ€ {R : Type u} [inst : Ring R], IsUnit 1",
   "some-correct": null,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["âˆ€ {R : Type u} [inst : Ring R], IsUnit 1",
     "âˆ€ {R : Type u} [inst : Ring R], IsUnit 1",
     "âˆ€ {R : Type u} [inst : Ring R], IsUnit 1",
     "âˆ€ {R : Type u} [inst : Ring R], IsUnit 1",
     "âˆ€ {R : Type u} [inst : Ring R], IsUnit 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R)"]},
  {"theorem": "{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H",
   "some-correct": null,
   "prompt": "Every subgroup of a group is a group.",
   "groups":
   [["{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H",
     "{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H",
     "{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H",
     "{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H",
     "{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group â†¥H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group â†¥H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group â†¥H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group â†¥H",
    "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group â†¥H"]},
  {"theorem": "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)"]},
  {"theorem": "Nat.Prime 7",
   "some-correct": null,
   "prompt": "`7` is a prime number.",
   "groups": [["Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7"]],
   "correct": null,
   "comments": "",
   "all-elabs": ["Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7"]},
  {"theorem": "âˆ€ {Î± : Type u} (s : Finset Î±), âˆ… âŠ† s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["âˆ€ {Î± : Type u} (s : Finset Î±), âˆ… âŠ† s",
     "âˆ€ {Î± : Type u} (s : Finset Î±), âˆ… âŠ† s",
     "âˆ€ {Î± : Type u} (s : Finset Î±), âˆ… âŠ† s",
     "âˆ€ {Î± : Type u} {s : Finset Î±}, âˆ… âŠ† s"],
    ["âˆ€ {Î± : Type u}, âˆ….Finite â†’ âˆ€ (s : Finset Î±), âˆ… âŠ† s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u}, âˆ€ (s : Finset Î±), âˆ… âŠ† s",
    "âˆ€ {Î± : Type u}, Set.Finite âˆ… â†’ âˆ€ (s : Finset Î±), âˆ… âŠ† s",
    "âˆ€ {Î± : Type u}, âˆ€ (s : Finset Î±), âˆ… âŠ† s",
    "âˆ€ {Î± : Type u}, âˆ€ (s : Finset Î±), âˆ… âŠ† s",
    "âˆ€ {Î± : Type u}, âˆ€ {s : Finset Î±}, âˆ… âŠ† s"]},
  {"theorem": "âˆ€ {Î± : Type u} {s : Set Î±} [inst : Infinite â†‘s], âˆƒ t, â†‘t âŠ† s",
   "some-correct": null,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["âˆ€ {Î± : Type u} {s : Set Î±} [inst : Infinite â†‘s], âˆƒ t, â†‘t âŠ† s",
     "âˆ€ {Î± : Type u} {s : Set Î±}, Infinite â†‘s â†’ âˆƒ t, â†‘t âŠ† s"],
    ["âˆ€ {Î± : Type u} {s : Set Î±}, s.Infinite â†’ âˆƒ t, â†‘t âŠ† s",
     "âˆ€ {Î± : Type u} {s : Set Î±}, s.Infinite â†’ âˆƒ t, â†‘t âŠ† s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} {s : Set Î±}, Set.Infinite s â†’ âˆƒ (t : Finset Î±), â†‘t âŠ† s",
    "âˆ€ {Î± : Type u} {s : Set Î±} [inst : Infinite s], âˆƒ (t : Finset Î±), â†‘t âŠ† s",
    "âˆ€ {Î± : Type u} {s : Set Î±}, Infinite s â†’ âˆƒ (t : Finset Î±), â†‘t âŠ† s",
    "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Infinite s â†’ âˆƒ (t : Finset Î±), â†‘t âŠ† s"]},
  {"theorem": "{R : Type u_1} â†’ [inst : CommRing R] â†’ Monoid R",
   "some-correct": null,
   "prompt": "Every commutative ring is a monoid.",
   "groups":
   [["{R : Type u_1} â†’ [inst : CommRing R] â†’ Monoid R",
     "{R : Type u_1} â†’ [inst : CommRing R] â†’ Monoid R"],
    ["(R : Type ?u.5349148) â†’ [inst : CommRing R] â†’ Monoid R",
     "(R : Type ?u.5349148) â†’ [inst : CommRing R] â†’ Monoid R"],
    ["{R : Type u_3} â†’ [inst : CommRing R] â†’ Monoid R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ R [inst : CommRing R], Monoid R",
    "âˆ€ {R : Type u_3} [inst : CommRing R], Monoid R",
    "âˆ€ R [inst : CommRing R], Monoid R",
    "âˆ€ {R : Type u_1} [inst : CommRing R], Monoid R",
    "âˆ€ {R : Type u_1} [inst : CommRing R], Monoid R"]},
  {"theorem": "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b, n = a + b âˆ§ a â‰  b",
   "some-correct": null,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["âˆ€ (n : â„•), Odd n â†’ âˆƒ a b, n = a + b âˆ§ a â‰  b",
     "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b, n = a + b âˆ§ a â‰  b",
     "âˆ€ {n : â„•}, Odd n â†’ âˆƒ x y, n = x + y âˆ§ x â‰  y",
     "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b, n = a + b âˆ§ a â‰  b"],
    ["âˆ€ (n : â„•), Odd n â†’ âˆƒ a b, a â‰  b âˆ§ n = a + b"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (n : â„•), Odd n â†’ âˆƒ (a b : â„•), n = a + b âˆ§ a â‰  b",
    "âˆ€ (n : â„•), Odd n â†’ âˆƒ (a b : â„•), n = a + b âˆ§ a â‰  b",
    "âˆ€ {n : â„•}, Odd n â†’ âˆƒ x y, n = x + y âˆ§ x â‰  y",
    "âˆ€ (n : â„•), Odd n â†’ âˆƒ (a b : â„•), a â‰  b âˆ§ n = a + b",
    "âˆ€ (n : â„•), Odd n â†’ âˆƒ (a b : â„•), n = a + b âˆ§ a â‰  b"]},
  {"theorem": "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1"],
    ["âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)",
    "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)",
    "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)"]},
  {"theorem": "âˆ€ {n : â„¤}, Even n â†’ Even (n ^ 2)",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups":
   [["âˆ€ {n : â„¤}, Even n â†’ Even (n ^ 2)",
     "âˆ€ {n : â„¤}, Even n â†’ Even (n ^ 2)",
     "âˆ€ {n : â„¤}, Even n â†’ Even (n ^ 2)"],
    ["âˆ€ {n : â„¤}, Even n â†’ Even (n * n)", "âˆ€ {n : â„¤}, Even n â†’ Even (n * n)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {n : â„¤}, Even n â†’ Even (n * n)",
    "âˆ€ {n : â„¤}, Even n â†’ Even (n ^ 2)",
    "âˆ€ {n : â„¤}, Even n â†’ Even (n * n)",
    "âˆ€ {n : â„¤}, Even n â†’ Even (n ^ 2)",
    "âˆ€ {n : â„¤}, Even n â†’ Even (n ^ 2)"]},
  {"theorem": "âˆ€ {R : Type u} [inst : CommRing R], IsDomain R â†’ IsField R",
   "some-correct": null,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["âˆ€ {R : Type u} [inst : CommRing R], IsDomain R â†’ IsField R",
     "âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R], IsField R"],
    ["âˆ€ {R : Type u} [inst : CommRing R] [inst : IsDomain R] [inst : DivisionRing R], IsField R"],
    ["âˆ€ {R : Type u} [inst : CommRing R] [inst : DivisionRing R], IsField R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u} [inst : CommRing R] [inst : DivisionRing R], IsField R",
    "âˆ€ {R : Type u} [inst : CommRing R] (inst_1 : IsDomain R), IsField R",
    "âˆ€ {R : Type u} [inst : CommRing R] [inst : IsDomain R] [inst : DivisionRing R], IsField R",
    "âˆ€ (R : Type u) [inst : CommRing R] [inst : IsDomain R], IsField R"]},
  {"theorem": "âˆ€ {R : Type u_1} [inst : MulOneClass R], id 1 = 1",
   "some-correct": null,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups":
   [["âˆ€ {R : Type u_1} [inst : MulOneClass R], id 1 = 1",
     "âˆ€ {Î± : Type u} [inst : MulOneClass Î±], id 1 = 1",
     "âˆ€ {M : Type u_1} [inst : MulOneClass M], id 1 = 1",
     "âˆ€ {A : Type u_1} [inst : MulOneClass A], id 1 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {R : Type u_1} [inst : MulOneClass R], id 1 = (1 : R)",
    "âˆ€ {Î± : Type u} [inst : MulOneClass Î±], id (1 : Î±) = 1",
    "âˆ€ {M : Type u_1} [inst : MulOneClass M], (id 1) = (1 : M)",
    "âˆ€ {A : Type u_1} [inst : MulOneClass A], id 1 = (1 : A)"]},
  {"theorem": "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
     "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
     "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
     "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x"],
    ["âˆ€ {Î± : Type u} (inst : TopologicalSpace Î±) (x : Î±), ContinuousAt id x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
    "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
    "âˆ€ {Î± : Type u}, âˆ€ (x : Î±), Function.IsFixedPt id x",
    "âˆ€ {Î± : Type u} (inst : TopologicalSpace Î±) (x : Î±), ContinuousAt id x",
    "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±}, EMetric.diam {x} = 0",
   "some-correct": null,
   "prompt": "The diameter of a singleton space is `0`.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±}, EMetric.diam {x} = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±}, EMetric.diam {x} = 0"]},
  {"theorem": "âˆ€ (G : Type u) [inst : Group G], Nonempty G",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["âˆ€ (G : Type u) [inst : Group G], Nonempty G",
     "âˆ€ {G : Type u} [inst : Group G], Nonempty G",
     "âˆ€ {G : Type u} [inst : Group G], Nonempty G",
     "âˆ€ {G : Type u} [inst : Group G], Nonempty G"],
    ["âˆ€ (G : Type), Nonempty (Group G)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ (G : Type u) [inst : Group G], Nonempty G",
    "âˆ€ {G : Type u} [inst : Group G], Nonempty G",
    "âˆ€ {G : Type u} [inst : Group G], Nonempty G",
    "âˆ€ {G : Type u} [inst : Group G], Nonempty G",
    "âˆ€ G : Type, Nonempty (Group G)"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x)",
   "some-correct": null,
   "prompt": "All connected components of a topological space are connected.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x)",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x)",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x)"],
    ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), ConnectedSpace â†‘(connectedComponent x)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], âˆ€ (x : Î±), IsConnected (connectedComponent x)",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], âˆ€ (x : Î±), ConnectedSpace (connectedComponent x)",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], âˆ€ (x : Î±), IsConnected (connectedComponent x)",
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], âˆ€ (x : Î±), IsConnected (connectedComponent x)"]},
  {"theorem": "âˆƒ M, M.IsMaximal",
   "some-correct": null,
   "prompt": "The ring of integers has a maximal ideal.",
   "groups": [["âˆƒ M, M.IsMaximal", "âˆƒ M, M.IsMaximal", "âˆƒ I, I.IsMaximal"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆƒ M, Ideal.IsMaximal M",
    "âˆƒ M, Ideal.IsMaximal M",
    "âˆƒ (I : Ideal â„¤), Ideal.IsMaximal I"]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "groups":
   [["PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5"]},
  {"theorem":
   "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Basis âˆ… K V â†’ V = âŠ¥",
   "some-correct": null,
   "prompt": "A vector space with the empty set as basis is trivial.",
   "groups":
   [["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Basis âˆ… K V â†’ V = âŠ¥"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (â†‘âˆ…) K V â†’ V = âŠ¥"]}],
 "elaborated": 36}