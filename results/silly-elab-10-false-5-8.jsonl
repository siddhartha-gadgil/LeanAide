{"theorem":"∀ (p : ℕ), Nat.Prime p → p = 2 ∨ p % 2 = 1","text":"Every prime number is `2` or odd.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\", \"content\": \"Every prime number is `2` or odd.\"}]","all_elaborations":["∀ (p : ℕ), Nat.Prime p → p = 2 ∨ p % 2 = 1","∀ (p : ℕ), Nat.Prime p → (p = 2 ∨ p % 2 = 1)"]}
{"theorem":"∀ (n : ℕ), ∃ m, m > n ∧ Odd m","text":"There are infinitely many odd natural numbers.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\": \"Odd Bernoulli numbers (greater than 1) are zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, Odd n → 1 < n → bernoulli' n = 0\"},\n {\"role\": \"user\", \"content\": \"The infinite pigeonhole principle \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {β α : Type u} (f : β → α),\\n  Cardinal.aleph0 ≤ Cardinal.mk β →\\n    Cardinal.mk α < Ordinal.cof (Cardinal.ord (Cardinal.mk β)) → ∃ a, Cardinal.mk ↑(f ⁻¹' {a}) = Cardinal.mk β\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (Finset.sum s fun x => f x) = ⊤ ↔ ∃ a, a ∈ s ∧ f a = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd natural numbers.\"}]","all_elaborations":["∀ (n : ℕ), ∃ (m : ℕ), m > n ∧ Odd m","∀ (n : ℕ), Odd (2 * n + 1)","∀ (n : ℕ), ∃ (k : ℕ), k > n ∧ Odd k"]}
{"theorem":"∀ {p : ℕ}, Nat.Prime p → 2 < p → 3 ≤ p","text":"The smallest odd prime is `3`.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\", \"content\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    Odd p →\\n      ∀ {x y : ℤ},\\n        ↑p ∣ x - y →\\n          ¬↑p ∣ x → ∀ (n : ℕ), multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\"},\n {\"role\": \"user\", \"content\": \"The smallest odd prime is `3`.\"}]","all_elaborations":["lemma smallest_odd_prime : ∀ (p : ℕ), Nat.Prime p → 1 < p → 3 ≤ p ","Fact (Nat.Prime 3)","∀ (p : ℕ), Nat.Prime p → p ≥ 3","∀ {p : ℕ}, Nat.Prime p → 2 < p → 3 ≤ p"]}
{"theorem":"∀ {n : ℕ}, ∃ p, Nat.Prime p ∧ p > n ∧ Odd p","text":"There are infinitely many odd prime numbers.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\"},\n {\"role\": \"user\", \"content\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    Odd p →\\n      ∀ {x y : ℤ},\\n        ↑p ∣ x - y →\\n          ¬↑p ∣ x → ∀ (n : ℕ), multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there exists an arbitrarily large prime `p` such that\\n`p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ} (n : ℕ), k ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≡ 1 [MOD k]\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd prime numbers.\"}]","all_elaborations":["∀ {n : ℕ}, ∃ p, Nat.Prime p ∧ p > n ∧ Odd p","∀ (n : ℕ), ∃ p, Nat.Prime p ∧ n < p ∧ Odd p","∀ (n : ℕ), ∃ p, Nat.Prime p ∧ p > n ∧ Odd p"]}
{"theorem":"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V","text":"If a vector space has dimension `2` then it is finite dimensional.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A vector space with a nonzero vector `v` has dimension 1 iff `v` spans.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v : V),\\n  v ≠ 0 → (FiniteDimensional.finrank K V = 1 ↔ Submodule.span K {v} = ⊤)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂],\\n  (M ≃ₗ[R] M₂) → FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has dimension `2` then it is finite dimensional.\"}]","all_elaborations":["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (FiniteDimensional.finrank K V = 2) → FiniteDimensional K V"]}
{"theorem":"{K : Type u} → [inst : Field K] → DivisionRing K","text":"Every field is a division ring.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type v} (s : S) {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] [inst_2 : SetLike S R]\\n  [inst_3 : SubringClass S R], IsDomain { x // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x // x ∈ s }\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x * y ∈ s\"},\n {\"role\": \"user\", \"content\": \"Every field is a division ring.\"}]","all_elaborations":["∀ {K : Type u} [inst : Field K], DivisionRing K"]}
{"theorem":"∀ (k : Type u_1) (V : Type u_2) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  FiniteDimensional.finrank k V = 2 → FiniteDimensional k V","text":"If a space has dimension `2` then it is finite dimensional.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂],\\n  (M ≃ₗ[R] M₂) → FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Adding a point to a finite-dimensional subspace increases the dimension by at most one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P) (p : P),\\n  FiniteDimensional.finrank k { x // x ∈ vectorSpan k (insert p ↑s) } ≤\\n    FiniteDimensional.finrank k { x // x ∈ AffineSubspace.direction s } + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Adding a point to a set with a finite-dimensional span increases the dimension by at most\\none. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : Set P) (p : P),\\n  FiniteDimensional.finrank k { x // x ∈ vectorSpan k (insert p s) } ≤\\n    FiniteDimensional.finrank k { x // x ∈ vectorSpan k s } + 1\"},\n {\"role\": \"user\",\n  \"content\": \"If a space has dimension `2` then it is finite dimensional.\"}]","all_elaborations":["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V","∀ (k : Type u_1) (V : Type u_2) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  FiniteDimensional.finrank k V = 2 → FiniteDimensional k V"]}
{"theorem":"∀ (n : ℕ), ∃ m, n = Nat.succ m","text":"Every natural number has a successor.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\", \"content\": \"Successor powers behave as expected \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddMonoid ι] [self : GradedMonoid.GMonoid A] (n : ℕ) (a : GradedMonoid A),\\n  GradedMonoid.mk (Nat.succ n • a.fst) (GradedMonoid.GMonoid.gnpow (Nat.succ n) a.snd) =\\n    a * { fst := n • a.fst, snd := GradedMonoid.GMonoid.gnpow n a.snd }\"},\n {\"role\": \"user\", \"content\": \"Successor powers behave as expected \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GSemiring A] (n : ℕ) (a : GradedMonoid A),\\n  GradedMonoid.mk (Nat.succ n • a.fst) (DirectSum.GSemiring.gnpow (Nat.succ n) a.snd) =\\n    a * { fst := n • a.fst, snd := DirectSum.GSemiring.gnpow n a.snd }\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\": \"`a ≤ b` as natural numbers if and only if `a ≤ b` in `Fin n`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ} {a b : Fin n}, ↑a ≤ ↑b ↔ a ≤ b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\", \"content\": \"Every ordinal has a fundamental sequence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a : Ordinal.{u}), ∃ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\"},\n {\"role\": \"user\", \"content\": \"Every natural number has a successor.\"}]","all_elaborations":["∀ (n : ℕ), ∃ (m : ℕ), n = m.succ","∀ (n : ℕ), ∃ (m : ℕ), n = m + 1","∀ (n : ℕ), ∃ (k : ℕ), n = k + 1"]}
{"theorem":"∀ (n : ℕ), n < Nat.succ n","text":"Every natural number is less than its successor.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"`a ≤ b` as natural numbers if and only if `a ≤ b` in `Fin n`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ} {a b : Fin n}, ↑a ≤ ↑b ↔ a ≤ b\"},\n {\"role\": \"user\",\n  \"content\": \"`a < b` as natural numbers if and only if `a < b` in `Fin n`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ} {a b : Fin n}, ↑a < ↑b ↔ a < b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1\"},\n {\"role\": \"user\", \"content\": \"The relation `≤` on a preorder is transitive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α), a ∈ s → sInf s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteLattice α] (s : Set α) (a : α), a ∈ s → sInf s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), a ∈ s → sInf s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is less than its successor.\"}]","all_elaborations":["∀ (n : ℕ), n < n.succ","∀ (n : nat), n < (n + 1)","∀ (n : ℕ), n < n + 1"]}
{"theorem":"∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s","text":"Every set is Lebesgue measurable.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : TopologicalSpace.SecondCountableTopology α] {s : Set α},\\n  (∀ (x : α), x ∈ s → s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s\"},\n {\"role\": \"user\",\n  \"content\": \"The graph of a measurable function is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {f : α → ℝ}, Measurable f → MeasurableSet {p | p.snd = f p.fst}\"},\n {\"role\": \"user\", \"content\": \"A singleton is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] [self : MeasurableSingletonClass α] (x : α), MeasurableSet {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A measurable set of negative measure has a negative subset of negative measure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {i : Set α},\\n  ↑s i < 0 →\\n    ∃ j,\\n      MeasurableSet j ∧\\n        j ⊆ i ∧ MeasureTheory.VectorMeasure.restrict s j ≤ MeasureTheory.VectorMeasure.restrict 0 j ∧ ↑s j < 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every set there exists a measurable superset of the same measure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\\n  ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a measurable set under a measurable embedding is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : α → β},\\n  MeasurableEmbedding f → ∀ ⦃s : Set α⦄, MeasurableSet s → MeasurableSet (f '' s)\"},\n {\"role\": \"user\", \"content\": \"A simple function is measurable \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\\n  (f : MeasureTheory.SimpleFunc α β), Measurable ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every set has a measurable superset. Declare this as local instance as needed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} (s : Set α), Nonempty { t // s ⊆ t ∧ MeasurableSet t }\"},\n {\"role\": \"user\", \"content\": \"Every set is Lebesgue measurable.\"}]","all_elaborations":["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s","∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s "]}
{"theorem":"∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p","text":"No prime number is a perfect square.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\", \"content\": \"No prime number is a perfect square.\"}]","all_elaborations":["∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p"]}
{"theorem":"∀ {p : ℕ}, Nat.Prime p → p > 2","text":"Every odd prime number is greater than `2`.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    Odd p →\\n      ∀ {x y : ℤ},\\n        ↑p ∣ x - y →\\n          ¬↑p ∣ x → ∀ (n : ℕ), multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\", \"content\": \"Every odd prime number is greater than `2`.\"}]","all_elaborations":["∀ {p : ℕ}, Nat.Prime p → p > 2","∀ {p : ℕ}, Nat.Prime p → 2 < p"]}
{"theorem":"∀ {a b : ℕ} {c d e f g h : ℕ},\n  (∃ x₁ y₁ z₁ w₁ x₂ y₂ z₂ w₂, a = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2 ∧ b = x₂ ^ 2 + y₂ ^ 2 + z₂ ^ 2 + w₂ ^ 2) →\n    ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2","text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\", \"content\": \"The square commutes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z},\\n  CategoryTheory.CommSq f g h i → CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.\"}]","all_elaborations":["∀ {a b c d e f g h : ℕ},\n  (∃ (x₁ y₁ z₁ w₁ x₂ y₂ z₂ w₂ : ℕ),\n    a = x₁^2 + y₁^2 + z₁^2 + w₁^2 ∧\n    b = x₂^2 + y₂^2 + z₂^2 + w₂^2) →\n  ∃ (x y z w : ℕ),\n    a * b = x^2 + y^2 + z^2 + w^2","∀ (a b c d x y z w : ℕ),\n  (∃ (a1 a2 a3 a4 : ℕ), a = a1 ^ 2 + a2 ^ 2 + a3 ^ 2 + a4 ^ 2) →\n  (∃ (b1 b2 b3 b4 : ℕ), b = b1 ^ 2 + b2 ^ 2 + b3 ^ 2 + b4 ^ 2) →\n  ∃ (c1 c2 c3 c4 : ℕ), a * b = c1 ^ 2 + c2 ^ 2 + c3 ^ 2 + c4 ^ 2"]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","text":"Every compact topological space is locally compact.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\"},\n {\"role\": \"user\", \"content\": \"A proper space is locally compact \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : ProperSpace α], LocallyCompactSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T₂ space, every point has an open neighborhood with compact closure \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α),\\n  ∃ U, IsOpen U ∧ x ∈ U ∧ IsCompact (closure U)\"},\n {\"role\": \"user\",\n  \"content\": \"Every compact topological space is locally compact.\"}]","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α"]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f","text":"Every continuous function is uniformly continuous.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Heine-Cantor: a continuous function on a compact uniform space is uniformly\\ncontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\\n  Continuous f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Heine-Cantor: a continuous function on a compact set of a uniform space is uniformly\\ncontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {s : Set α} {f : α → β},\\n  IsCompact s → ContinuousOn f s → UniformContinuousOn f s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},\\n  LipschitzWith K f → UniformContinuous f\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\",\n  \"content\": \"Every continuous function is uniformly continuous.\"}]","all_elaborations":["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]}
{"theorem":"∀ (a b : ℕ), a ≠ b → Nat.Prime a → Nat.Prime b → a + b ≠ 6","text":"`6` is not the sum of two distinct prime numbers.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\", \"content\": \"The sine of `π / 6` is `1 / 2`. \"},\n {\"role\": \"assistant\", \"content\": \"Real.sin (Real.pi / 6) = 1 / 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"`6` is not the sum of two distinct prime numbers.\"}]","all_elaborations":["∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → ¬(6 = p + q)","∀ (a b : ℕ), a + b = 6 → Nat.Prime a → Nat.Prime b → a = b","∀ (a b : ℕ), a ≠ b → Nat.Prime a → Nat.Prime b → a + b ≠ 6","∀ (a b : ℕ), Nat.Prime a → Nat.Prime b → a ≠ b → a + b ≠ 6","∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6"]}
{"theorem":"∀ (n : ℤ), ¬Irrational ↑n","text":"No integer is irrational.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenRatio\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x\"},\n {\"role\": \"user\", \"content\": \"**Irrationality of the Square Root of 2** \"},\n {\"role\": \"assistant\", \"content\": \"Irrational (Real.sqrt 2)\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\"},\n {\"role\": \"user\", \"content\": \"No integer is irrational.\"}]","all_elaborations":["∀ (n : ℤ), ¬Irrational (↑n)","∀ (n : ℤ), ¬Irrational ↑n"]}
{"theorem":"∀ {R : Type u} [inst : Semiring R], IsUnit 1","text":"The identity element in a ring is a unit.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ∈ I → ‖1 - x‖ < 1 → I = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two non-unital subrings are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] {S T : NonUnitalSubring R}, (∀ (x : R), x ∈ S ↔ x ∈ T) → S = T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime that does not divide the cardinality of a finite commutative ring `R`\\nis a unit in `R`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card R → ¬IsUnit ↑p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a\"},\n {\"role\": \"user\",\n  \"content\": \"Units of a monoid divide any element of the monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [inst : Monoid α] {a u : α}, IsUnit u → u ∣ a\"},\n {\"role\": \"user\", \"content\": \"Nonzero elements have multiplicative inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ {a : R}, a ≠ 0 → ∃ b, a * b = 1\"},\n {\"role\": \"user\", \"content\": \"The identity element in a ring is a unit.\"}]","all_elaborations":["∀ {R : Type u} [inst : Semiring R], IsUnit (1 : R)","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)"]}
{"theorem":"{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }","text":"Every subgroup of a group is a group.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1\"},\n {\"role\": \"user\",\n  \"content\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\": \"A subgroup is either the trivial subgroup or nontrivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is either the trivial subgroup or contains a nonzero element.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"The subgroup generated by a set includes the set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)\"},\n {\"role\": \"user\",\n  \"content\": \"Two subgroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G ⧸ H) → H = ⊤\"},\n {\"role\": \"user\", \"content\": \"A subgroup contains the group's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ∈ H → x⁻¹ ∈ H\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of a group is a group.\"}]","all_elaborations":["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group H ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group H"]}
{"theorem":"∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","text":"The identity element of a group has finite order.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → IsOfFinOrder x⁻¹\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"The identity element of a group has finite order.\"}]","all_elaborations":["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)"]}
{"theorem":"Fact (Nat.Prime 7)","text":"`7` is a prime number.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 1 < n → ¬Nat.Prime n → FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1)\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ}, Nat.Prime p → Nat.factorization p = Finsupp.single p 1\"},\n {\"role\": \"user\", \"content\": \"`7` is a prime number.\"}]","all_elaborations":["example : Nat.Prime 7 ","Fact (Nat.Prime 7)"]}
{"theorem":"∃ p, Nat.Prime p ∧ p < 8 ∧ ∃ q, Nat.Prime q ∧ q < p ∧ ∃ r, Nat.Prime r ∧ r < q","text":"There are `3` prime numbers below `8`.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any natural numbers n, a, and b, one of the following holds:\\n1. n < a\\n2. n ≥ b\\n3. n ∈ Ico a b\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n a b : ℕ), n < a ∨ b ≤ n ∨ n ∈ List.Ico a b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\", \"content\": \"There are `3` prime numbers below `8`.\"}]","all_elaborations":["∃ (n : ℕ), n = 3 ∧ Nat.Prime n ∧ ∀ (p : ℕ), Nat.Prime p → p < 8 → p ≤ n","∃ (p : ℕ), Nat.Prime p ∧ p < 8 ∧ ∃ (q : ℕ), Nat.Prime q ∧ q < p ∧ ∃ (r : ℕ), Nat.Prime r ∧ r < q"]}
{"theorem":"∀ {α : Type u} {a : Set α}, Set.Finite a → ∅ ⊆ a","text":"The empty set is contained in every finite set.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\"},\n {\"role\": \"user\",\n  \"content\": \"The (open) thickening of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] (δ : ℝ), Metric.thickening δ ∅ = ∅\"},\n {\"role\": \"user\", \"content\": \"The upper shadow of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α], Finset.upShadow ∅ = ∅\"},\n {\"role\": \"user\", \"content\": \"The shadow of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [inst : DecidableEq α], Finset.shadow ∅ = ∅\"},\n {\"role\": \"user\", \"content\": \"`⊥`, coerced to a set, is the empty set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P], ↑⊥ = ∅\"},\n {\"role\": \"user\", \"content\": \"The supremum of the empty set is `⊥` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : ConditionallyCompleteLinearOrderBot α], sSup ∅ = ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"The closed thickening of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] (δ : ℝ), Metric.cthickening δ ∅ = ∅\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all sets in a collection are either `∅` or `Set.univ`, then so is their union. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {S : Set (Set α)}, S ⊆ {∅, Set.univ} → ⋃₀ S ∈ {∅, Set.univ}\"},\n {\"role\": \"user\", \"content\": \"The empty set is contained in every finite set.\"}]","all_elaborations":["∀ {α : Type u} {a : Set α}, Set.Finite a → ∅ ⊆ a"]}
{"theorem":"(R : Type u_1) → [inst : CommRing R] → Monoid R","text":"Every commutative ring is a monoid.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural number powers of an element of a monoid is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {x y z : M}, y ∈ powers x → z ∈ powers x → y * z ∈ powers x\"},\n {\"role\": \"user\",\n  \"content\": \"Right multiplication in a ring is an additive monoid morphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => y * x\"},\n {\"role\": \"user\",\n  \"content\": \"Left multiplication in a ring is an additive monoid morphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => x * y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive monoid with one has characteristic zero if the canonical map `ℕ → R` is\\ninjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : AddMonoidWithOne R] [self : CharZero R], Function.Injective Nat.cast\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, either zero and one are nonequal, or zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 ≠ 1 ∨ ∀ (a : M₀), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 ↔ Subsingleton M₀\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a monoid is in the set of that element's natural number powers. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {M : Type u_1} [inst : Monoid M] {x : M}, x ∈ powers x\"},\n {\"role\": \"user\",\n  \"content\": \"If `R` is a monoid, an element in `Rˣ` is regular. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u_1} [inst : Monoid R] (a : Rˣ), IsRegular ↑a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Multiplication is monotone in an ordered cancellative commutative monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [self : OrderedCancelCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b\"},\n {\"role\": \"user\", \"content\": \"Every commutative ring is a monoid.\"}]","all_elaborations":["∀ {R : Type u_1} [inst : CommRing R], Monoid R","∀ (R : Type u_1) [inst : CommRing R], Monoid R"]}
{"theorem":"∀ {n : ℕ}, Odd n → ∃ x y, x ≠ y ∧ n = x + y","text":"Every odd natural number is the sum of two distinct natural numbers.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (Finset.sum s fun x => f x) = ⊤ ↔ ∃ a, a ∈ s ∧ f a = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every odd natural number is the sum of two distinct natural numbers.\"}]","all_elaborations":["∀ {n : ℕ}, Odd n → ∃ x y, x ≠ y ∧ n = x + y","∀ {n : ℕ}, Odd n → ∃ (x y : ℕ), n = x + y ∧ x ≠ y","∀ {n : ℕ}, Odd n → ∃ (x y : ℕ), x ≠ y ∧ n = x + y"]}
{"theorem":"∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x ↔ True","text":"Every element in the trivial group has finite order.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → IsOfFinOrder x⁻¹\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a direct product has finite order then so does each component. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Monoid (Gs i)] {x : (i : η) → Gs i},\\n  IsOfFinOrder x → ∀ (i : η), IsOfFinOrder (x i)\"},\n {\"role\": \"user\",\n  \"content\": \"Every element in the trivial group has finite order.\"}]","all_elaborations":["∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x ↔ True","∀ {G : Type u_1} [inst : Monoid G] (x : G), IsOfFinOrder x ↔ G = ⊤","∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x ↔ G = 1"]}
{"theorem":"∀ {n : ℕ}, Even n → Even (n ^ 2)","text":"The square of an even number is even.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is even and `a` is even, then `n % a` is even. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even n → Even a → Even (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is even, then `n` is even iff `n % a` is even. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even a → (Even (n % a) ↔ Even n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo `n` and `m` divides `n`, then `-1` is also a square modulo `m`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, m ∣ n → IsSquare (-1) → IsSquare (-1)\"},\n {\"role\": \"user\", \"content\": \"The square of an even number is even.\"}]","all_elaborations":["∀ {n : ℕ}, Even n → Even (n ^ 2)","∀ (n : ℕ), Even n → Even (n^2)"]}
{"theorem":"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], IsField R","text":"Every commutative division ring is a field.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x * y ∈ s\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type v} (s : S) {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] [inst_2 : SetLike S R]\\n  [inst_3 : SubringClass S R], IsDomain { x // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"Every commutative division ring is a field.\"}]","all_elaborations":["∀ {R : Type u} [inst : CommRing R] (x : R) (x_ne_zero : x ≠ 0), IsUnit x","∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], IsField R"]}
{"theorem":"∀ {α : Type u} [inst : MulOneClass α], id 1 = 1","text":"The image of the identity element under the identity map is the identity element.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The identity map is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : MulOneClass α], IsMonoidHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a ring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map preserves multiplication. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {α : Type u} [inst : Mul α], IsMulHom id\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\",\n  \"content\": \"The identity map is an additive monoid homomorphism.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : AddZeroClass α], IsAddMonoidHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map preserves addition\"},\n {\"role\": \"assistant\", \"content\": \"∀ {α : Type u} [inst : Add α], IsAddHom id\"},\n {\"role\": \"user\", \"content\": \"`map` of `f` preserves the identity morphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {f : Type u₀ → Type u₁} [self : EquivFunctor f] (α : Type u₀), EquivFunctor.map (Equiv.refl α) = id\"},\n {\"role\": \"user\", \"content\": \"The identity is an additive group homomorphism.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : AddGroup α], IsAddGroupHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a semiring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Semiring α], IsSemiringHom id\"},\n {\"role\": \"user\", \"content\": \"The identity affine map acts as the identity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_3) {V1 : Type u_2} {P1 : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\\n  [inst_3 : AddTorsor V1 P1] (p : P1), ↑(AffineMap.id k P1) p = p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of the identity element under the identity map is the identity element.\"}]","all_elaborations":["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1","∀ {α : Type u} [inst : MulOneClass α], id (1 : α) = 1"]}
{"theorem":"∀ {α : Type u_1} (x : α), Function.IsFixedPt id x","text":"Every point is a fixed point of the identity function on a space.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Every point is a fixed point of `id`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} (x : α), Function.IsFixedPt id x\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsFixedPt f^[n] x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt (f ∘ g) x → Function.IsFixedPt g x → Function.IsFixedPt f x\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any map `f` sends fixed points of `g ∘ f` to fixed points of `f ∘ g`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\\n  Set.MapsTo f (Function.fixedPoints (g ∘ f)) (Function.fixedPoints (f ∘ g))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt f x → Function.IsFixedPt g x → Function.IsFixedPt (f ∘ g) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\\npoint of `g`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt f x → Function.LeftInverse g f → Function.IsFixedPt g x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every point is a fixed point of the identity function on a space.\"}]","all_elaborations":["∀ {α : Type u}, ∀ (x : α), Function.IsFixedPt id x","∀ {α : Type u_1} (x : α), Function.IsFixedPt id x"]}
{"theorem":"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","text":"The diameter of a singleton space is `0`.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A singleton has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a singleton vanishes \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of the empty set vanishes \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α], EMetric.diam ∅ = 0\"},\n {\"role\": \"user\", \"content\": \"The empty set has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a subsingleton vanishes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, Set.Subsingleton s → EMetric.diam s = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a set is always nonnegative \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, 0 ≤ Metric.diam s\"},\n {\"role\": \"user\",\n  \"content\": \"The diameter is monotonous with respect to inclusion \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s t : Set α}, s ⊆ t → EMetric.diam s ≤ EMetric.diam t\"},\n {\"role\": \"user\",\n  \"content\": \"An isometry preserves the diameter in pseudometric spaces. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\\n  Isometry f → ∀ (s : Set α), Metric.diam (f '' s) = Metric.diam s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The minimal distance to a singleton is the distance to the unique point in this singleton \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {x y : α}, Metric.infDist x {y} = dist x y\"},\n {\"role\": \"user\", \"content\": \"The diameter of a singleton space is `0`.\"}]","all_elaborations":["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam ({x} : Set α) = 0"]}
{"theorem":"∀ {G : Type u_1} [inst : Group G], ¬(G → false = true)","text":"Every group is non-empty.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G₀ : Type u_1} [self : CommGroupWithZero G₀], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G₀ : Type u} [self : GroupWithZero G₀], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [self : Semifield α], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [self : LinearOrderedSemifield α], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [self : DivisionSemiring α], 0⁻¹ = 0\"},\n {\"role\": \"user\", \"content\": \"The category of groups has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} GroupCatMax\"},\n {\"role\": \"user\",\n  \"content\": \"Two subsemigroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T\"},\n {\"role\": \"user\",\n  \"content\": \"Two subgroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K\"},\n {\"role\": \"user\", \"content\": \"Every group is non-empty.\"}]","all_elaborations":["∀ {G : Type u_1} [inst : Group G], ¬(∀ (x : G), false)"]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] (j : Set α),\n  IsConnected j → ∀ (x : α), x ∈ j → IsConnected (connectedComponent x)","text":"All connected components of a topological space are connected.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\"},\n {\"role\": \"user\", \"content\": \"A connected space is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α],\\n  TotallyDisconnectedSpace α ↔ ∀ (x : α), Set.Subsingleton (connectedComponent x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of a connected set is connected as well. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α},\\n  IsConnected s → ∀ (f : α → β), ContinuousOn f s → IsConnected (f '' s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a connected component in a totally disconnected space is a singleton. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {β : Type u_1} [inst_1 : TopologicalSpace β]\\n  [inst_2 : TotallyDisconnectedSpace β] {f : α → β}, Continuous f → ∀ (a : α), f '' connectedComponent a = {f a}\"},\n {\"role\": \"user\",\n  \"content\": \"The closure of a connected set is connected as well. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsConnected s → IsConnected (closure s)\"},\n {\"role\": \"user\",\n  \"content\": \"A clopen set is the union of its connected components. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z : Set α}, IsClopen Z → ⋃ (x : α) (_ : x ∈ Z), connectedComponent x = Z\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\"},\n {\"role\": \"user\",\n  \"content\": \"All connected components of a topological space are connected.\"}]","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α],\n  ∀ (x : α), IsConnected (connectedComponent x)","∀ {α : Type u} [inst : TopologicalSpace α] (j : Set α),\n  IsConnected j → ∀ (x : α), x ∈ j → IsConnected (connectedComponent x)"]}
{"theorem":"∃ M, Ideal.IsMaximal M","text":"The ring of integers has a maximal ideal.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄,\\n  I < J → ↑J = Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R],\\n  IsField R → ∀ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ↑Polynomial.C x ∈ I → x = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\"},\n {\"role\": \"user\", \"content\": \"The ring of integers has a maximal ideal.\"}]","all_elaborations":["∃ (M : Ideal ℤ), Ideal.IsMaximal M"]}
{"theorem":"PythagoreanTriple 3 4 5","text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"**Formula for Pythagorean Triples** \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x y z : ℤ},\\n  PythagoreanTriple x y z →\\n    (PythagoreanTriple x y z ↔\\n      ∃ k m n,\\n        (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\\n          (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2)))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`(k*x, k*y, k*z)` is a Pythagorean triple if and only if\\n`(x, y, z)` is also a triple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x y z : ℤ} (k : ℤ), k ≠ 0 → (PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z)\"},\n {\"role\": \"user\", \"content\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"role\": \"assistant\", \"content\": \"PythagoreanTriple 0 0 0\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The numbers `3`, `4` and `5` form a Pythagorean triple.\"}]","all_elaborations":["PythagoreanTriple 3 4 5"]}
