{"theorem":"Â¬LocallyCompactSpace â„š","text":"Show that the rationals `â„š` are not locally compact.","result":true,"gps":[["Â¬LocallyCompactSpace â„š","Â¬LocallyCompactSpace â„š","Â¬LocallyCompactSpace â„š","Â¬LocallyCompactSpace â„š","Â¬LocallyCompactSpace â„š","Â¬LocallyCompactSpace â„š","Â¬LocallyCompactSpace â„š","Â¬LocallyCompactSpace â„š","Â¬LocallyCompactSpace â„š","Â¬LocallyCompactSpace â„š"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Â¬LocallyCompactSpace â„š ","Â¬LocallyCompactSpace â„š ","Â¬LocallyCompactSpace â„š ","Â¬LocallyCompactSpace â„š ","Â¬LocallyCompactSpace â„š ","Â¬LocallyCompactSpace â„š ","Â¬LocallyCompactSpace â„š ","Â¬LocallyCompactSpace â„š ","Â¬LocallyCompactSpace â„š ","Â¬LocallyCompactSpace â„š "]}
{"theorem":"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a","text":"Show that if `X` has a countable dense subset, every collection of disjoint open sets in `X` is countable.","result":true,"gps":[["âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a","âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a","âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a"],["âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ Set.Countable a","âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ Set.Countable a"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a ","âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ Set.Countable a ","forall {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a ","âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ (âˆ€ (i : Î¹), i âˆˆ a â†’ Set.Nonempty (s i)) â†’ Set.Countable a ","âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\n  {a : Set Î¹},\n  Set.PairwiseDisjoint a s â†’\n    (âˆ€ (i : Î¹), i âˆˆ a â†’ IsOpen (s i)) â†’ Set.Countable a "]}
{"theorem":"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v)","text":"Show that if `X` is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.","result":true,"gps":[["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’\n    IsClosed t â†’ Disjoint s t â†’ âˆƒ Uâ‚ Uâ‚‚, IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ s âŠ† Uâ‚ âˆ§ t âŠ† Uâ‚‚ âˆ§ Disjoint (closure Uâ‚) (closure Uâ‚‚)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (A B : Set Î±),\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ A âŠ† U âˆ§ B âŠ† V âˆ§ Disjoint (closure U) (closure V)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ s âŠ† U âˆ§ t âŠ† V âˆ§ Disjoint (closure U) (closure V)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v)","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ Uâ‚ Uâ‚‚, IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ s âŠ† Uâ‚ âˆ§ t âŠ† Uâ‚‚ âˆ§ Disjoint (closure Uâ‚) (closure Uâ‚‚) ","forall {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (A B : Set Î±),\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ A âŠ† U âˆ§ B âŠ† V âˆ§ Disjoint (closure U) (closure V) ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ U V, IsOpen U âˆ§ IsOpen V âˆ§ s âŠ† U âˆ§ t âŠ† V âˆ§ Disjoint (closure U) (closure V) ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] â¦ƒs t : Set Î±â¦„,\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint (closure u) (closure v) "]}
{"theorem":"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {s : Set Î±}, IsClosed s â†’ NormalSpace { x // x âˆˆ s }","text":"Show that a closed subspace of a normal space is normal.","result":true,"gps":[["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {s : Set Î±}, IsClosed s â†’ NormalSpace { x // x âˆˆ s }","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {S : Set Î±}, IsClosed S â†’ NormalSpace { x // x âˆˆ S }","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±), IsClosed s â†’ NormalSpace { x // x âˆˆ s }","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s : Set Î±}, IsClosed s â†’ NormalSpace { x // x âˆˆ s }","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] (A : Set Î±), IsClosed A â†’ NormalSpace { x // x âˆˆ A }","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±), IsClosed s â†’ NormalSpace { x // x âˆˆ s }","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±), IsClosed s â†’ NormalSpace { x // x âˆˆ s }"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {s : Set Î±},\n  IsClosed s â†’ NormalSpace {x // x âˆˆ s} ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] {S : Set Î±},\n  IsClosed S â†’ NormalSpace { x // x âˆˆ S } ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±),\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] {s : Set Î±},\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : NormalSpace Î±] (A : Set Î±),\n  IsClosed A â†’ NormalSpace {x // x âˆˆ A} ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±),\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s : Set Î±),\n  IsClosed s â†’ NormalSpace { x // x âˆˆ s } "]}
{"theorem":"âˆ€ {Î± : Type u_1} {X_Î± : Î± â†’ Type u_2} [inst : (a : Î±) â†’ TopologicalSpace (X_Î± a)] [inst_1 : âˆ€ (a : Î±), Nonempty (X_Î± a)]\n  [inst_2 : RegularSpace ((a : Î±) â†’ X_Î± a)] (a : Î±), RegularSpace (X_Î± a)","text":"Show that if `Î  X_Î±` is regular, then so is `X_Î±`. Assume that each `X_Î±` is nonempty.","result":true,"gps":[["âˆ€ {Î± : Type u_1} {X_Î± : Î± â†’ Type u_2} [inst : (a : Î±) â†’ TopologicalSpace (X_Î± a)] [inst_1 : âˆ€ (a : Î±), Nonempty (X_Î± a)]\n  [inst_2 : RegularSpace ((a : Î±) â†’ X_Î± a)] (a : Î±), RegularSpace (X_Î± a)","âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst_1 : âˆ€ (i : Î¹), Nonempty (X i)]\n  [inst_1 : RegularSpace ((i : Î¹) â†’ X i)] (i : Î¹), RegularSpace (X i)"],["âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst_1 : âˆ€ (i : Î¹), T2Space (X i)]\n  [inst_2 : Nonempty Î¹] [inst_3 : âˆ€ (i : Î¹), Nonempty (X i)] [inst_4 : RegularSpace ((i : Î¹) â†’ X i)] (i : Î¹),\n  RegularSpace (X i)"],["âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst_1 : âˆ€ (i : Î¹), Nonempty (X i)]\n  [inst_2 : âˆ€ (i : Î¹), RegularSpace (X i)], RegularSpace ((i : Î¹) â†’ X i)"],["âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst_1 : âˆ€ (i : Î¹), Nonempty (X i)]\n  [inst_1 : âˆ€ (i : Î¹), T2Space (X i)] [inst_2 : TopologicalSpace.SecondCountableTopology ((i : Î¹) â†’ X i)],\n  RegularSpace ((i : Î¹) â†’ X i) â†’ âˆ€ (i : Î¹), RegularSpace (X i)"],["âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst_1 : âˆ€ (i : Î¹), Nonempty (X i)]\n  [inst_1 : âˆ€ (i : Î¹), T2Space (X i)] [inst_2 : âˆ€ (i : Î¹), RegularSpace (X i)], RegularSpace ((i : Î¹) â†’ X i)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst : (i : Î¹) â†’ Nonempty (X i)] [inst_1 : (i : Î¹) â†’ T2Space (X i)] [inst_2 : (i : Î¹) â†’ RegularSpace (X i)],\n  RegularSpace ((i : Î¹) â†’ X i) ","âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)] [inst : (i : Î¹) â†’ Nonempty (X i)] [inst : (i : Î¹) â†’ RegularSpace (X i)],\n  RegularSpace ((i : Î¹) â†’ X i) ","âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : âˆ€ (i : Î¹), TopologicalSpace (X i)] [inst : âˆ€ (i : Î¹), Nonempty (X i)]\n  [inst_1 : âˆ€ (i : Î¹), T2Space (X i)] [inst_2 : TopologicalSpace.SecondCountableTopology (Î  i, X i)],\n  RegularSpace (Î  i, X i) â†’ âˆ€ (i : Î¹), RegularSpace (X i) ","âˆ€ {Î± : Type u_1} {X_Î± : Î± â†’ Type u_2} [inst : (a : Î±) â†’ TopologicalSpace (X_Î± a)] [inst_1 : (âˆ€ (a : Î±), Nonempty (X_Î± a))]\n  [inst_2 : RegularSpace ((a : Î±) â†’ X_Î± a)], (a : Î±) â†’ RegularSpace (X_Î± a) ","âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : âˆ€ (i : Î¹), TopologicalSpace (X i)] [inst_1 : âˆ€ (i : Î¹), T2Space (X i)]\n  [inst_2 : Nonempty Î¹] [inst_3 : âˆ€ (i : Î¹), Nonempty (X i)] [inst_4 : RegularSpace ((i : Î¹) â†’ X i)],\n  âˆ€ (i : Î¹), RegularSpace (X i) ","forall {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\n  [inst : (i : Î¹) â†’ Nonempty (X i)] [inst_1 : RegularSpace ((i : Î¹) â†’ X i)],\n  forall (i : Î¹), RegularSpace (X i) "]}
{"theorem":"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î±","text":"Show that every locally compact Hausdorff space is regular.","result":true,"gps":[["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î±","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î±","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î±","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î±","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î±","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î±","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î±","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], RegularSpace Î±","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î±","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î±"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±], RegularSpace Î± ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : LocallyCompactSpace Î±], RegularSpace Î± ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± ","âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±],\n  RegularSpace Î± "]}
{"theorem":"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {A B : Set X},\n  IsClosed A â†’\n    IsClosed B â†’\n      Disjoint A B â†’ IsCompact A â†’ âˆƒ f, Set.EqOn f 0 A âˆ§ Set.EqOn f 1 B âˆ§ âˆ€ (x : X), ?m.2980018 f x âˆˆ Set.Icc 0 1","text":"Let `X` be completely regular, let `A` and `B` be disjoint closed subsets of `X`. Show that if `A` is compact, there is a continuous function `f: X â†’ [0, 1]` such that `f(A) = {0}` and `f(B) = {1}`.","result":true,"gps":[["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {A B : Set X},\n  IsClosed A â†’\n    IsClosed B â†’\n      Disjoint A B â†’ IsCompact A â†’ âˆƒ f, Set.EqOn f 0 A âˆ§ Set.EqOn f 1 B âˆ§ âˆ€ (x : X), ?m.2980018 f x âˆˆ Set.Icc 0 1"],["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] [inst_2 : T1Space X] {A B : Set X},\n  IsCompact A â†’\n    IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn f 0 A âˆ§ Set.EqOn f 1 B âˆ§ âˆ€ (x : X), ?m.2963658 f x âˆˆ Set.Icc 0 1"],["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] [inst_2 : LocallyCompactSpace X] {A B : Set X},\n  IsCompact A â†’\n    IsClosed A â†’\n      IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn f 0 A âˆ§ Set.EqOn f 1 B âˆ§ âˆ€ (x : X), ?m.2971849 f x âˆˆ Set.Icc 0 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] [inst_2 : T1Space X] {A B : Set X},\n  IsCompact A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] [inst_2 : LocallyCompactSpace X] {A B : Set X},\n  IsCompact A â†’ IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 ","âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {A B : Set X},\n  IsClosed A â†’ IsClosed B â†’ Disjoint A B â†’ IsCompact A â†’\n    âˆƒ f, Set.EqOn (â†‘f) 0 A âˆ§ Set.EqOn (â†‘f) 1 B âˆ§ âˆ€ (x : X), â†‘f x âˆˆ Set.Icc 0 1 "]}
{"theorem":"âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","text":"Prove that `-(-v) = v` for every `v âˆˆ V`.","result":true,"gps":[["âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] (v : Î±), - -v = v","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","âˆ€ {V : Type u_2} [inst : AddGroup V] (v : V), - -v = v","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] (v : Î±), -(-v) = v ","forall {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","âˆ€ {V : Type u_2} [inst : AddGroup V] (v : V), -(-v) = v ","âˆ€ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v "]}
{"theorem":"âˆƒ U,\n  (âˆ€ (u v : â„ Ã— â„), u âˆˆ U â†’ v âˆˆ U â†’ u + v âˆˆ U) âˆ§\n    (âˆ€ (u : â„ Ã— â„), u âˆˆ U â†’ -u âˆˆ U) âˆ§ Â¬âˆ€ (a : â„) (u : â„ Ã— â„), u âˆˆ U â†’ (a * u.fst, a * u.snd) âˆˆ U","text":"Give an example of a nonempty subset `U` of `â„^2` such that `U` is closed under addition and under taking additive inverses (meaning `-u âˆˆ U` whenever `u âˆˆ U`), but `U` is not a subspace of `â„^2`.","result":true,"gps":[["âˆƒ U,\n  (âˆ€ (u v : â„ Ã— â„), u âˆˆ U â†’ v âˆˆ U â†’ u + v âˆˆ U) âˆ§\n    (âˆ€ (u : â„ Ã— â„), u âˆˆ U â†’ -u âˆˆ U) âˆ§ Â¬âˆ€ (a : â„) (u : â„ Ã— â„), u âˆˆ U â†’ (a * u.fst, a * u.snd) âˆˆ U"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["example : âˆƒ (U : Set (â„ Ã— â„)), (âˆ€ (u v : â„ Ã— â„), u âˆˆ U â†’ v âˆˆ U â†’ u + v âˆˆ U) âˆ§ (âˆ€ (u : â„ Ã— â„), u âˆˆ U â†’ -u âˆˆ U) âˆ§ Â¬(âˆ€ (a : â„) (u : â„ Ã— â„), u âˆˆ U â†’ (a * u.1, a * u.2) âˆˆ U) "]}
{"theorem":"{K : Type u} â†’\n  {V : Type v} â†’\n    [inst : Field K] â†’\n      [inst_1 : AddCommGroup V] â†’ [inst_2 : Module K V] â†’ {Î¹ : Sort u_1} â†’ (Î¹ â†’ Submodule K V) â†’ Submodule K V","text":"Prove that the intersection of any collection of subspaces of `V` is a subspace of `V`.","result":true,"gps":[["{K : Type u} â†’\n  {V : Type v} â†’\n    [inst : Field K] â†’\n      [inst_1 : AddCommGroup V] â†’ [inst_2 : Module K V] â†’ {Î¹ : Sort u_1} â†’ (Î¹ â†’ Submodule K V) â†’ Submodule K V"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Sort u_1}\n  (s : Î¹ â†’ Submodule K V), Submodule K V "]}
{"theorem":"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), â†‘T v = a â€¢ v","text":"Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if `dim V = 1` and `T âˆˆ L(V, V)`, then there exists `a âˆˆ F` such that `T v = a v` for all `v âˆˆ V`.","result":true,"gps":[["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), â†‘T v = a â€¢ v","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), â†‘T v = a â€¢ v","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), â†‘T v = a â€¢ v","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), â†‘T v = a â€¢ v","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), â†‘T v = a â€¢ v"],["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), â†‘T v = a â€¢ v"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V],\n  Module.rank K V = 1 â†’ âˆ€ (f : V â†’â‚—[K] V), âˆƒ (a : K), âˆ€ (v : V), â†‘f v = a â€¢ v ","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V â‰¤ 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a, âˆ€ (v : V), â†‘T v = a â€¢ v ","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ (v : V), T v = a â€¢ v ","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ (a : K), âˆ€ (v : V), T v = a â€¢ v ","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (f : V â†’â‚—[K] V), âˆƒ (a : K), âˆ€ (v : V), â†‘f v = a â€¢ v ","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ (v : V), T v = a â€¢ v ","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ (v : V), T v = a â€¢ v ","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ v : V, T v = a â€¢ v ","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Module.rank K V = 1 â†’ âˆƒ a, âˆ€ (v : V), â†‘f v = a â€¢ v ","âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 â†’ âˆ€ (T : V â†’â‚—[K] V), âˆƒ a : K, âˆ€ v : V, T v = a â€¢ v "]}
{"theorem":"âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = â†‘Multiset.card (Polynomial.roots p) â†” âˆ€ (a : R), Polynomial.rootMultiplicity a p â‰¤ 1","text":"Suppose `p âˆˆ P(â„‚)` has degree `m`. Prove that `p` has `m` distinct roots if and only if `p` and its derivative `p'` have no roots in common.","result":true,"gps":[["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = â†‘Multiset.card (Polynomial.roots p) â†” âˆ€ (a : R), Polynomial.rootMultiplicity a p â‰¤ 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = Multiset.card (Polynomial.roots p) â†”\n    âˆ€ (a : R), Polynomial.rootMultiplicity a p â‰¤ 1 ","âˆ€ {p : Polynomial â„‚} {m : â„•},\n  Polynomial.natDegree p = m â†’\n    (p â‰  0 â†’\n       (âˆ€ a, Polynomial.IsRoot p a â†” Polynomial.IsRoot (â†‘Polynomial.derivative p) a â†’ False) â†”\n         m = Multiset.card (Polynomial.roots p)) ","âˆ€ {p : Polynomial â„‚},\n  Polynomial.natDegree p = Finset.card (Multiset.toFinset (Polynomial.roots p)) â†”\n  Multiset.Disjoint (Polynomial.roots p) (Polynomial.roots (â†‘Polynomial.derivative p)) ","âˆ€ {m : â„•} {p : Polynomial â„‚},\n  Polynomial.natDegree p = m â†’\n    ((âˆ€ a : â„‚, Polynomial.rootMultiplicity a p â‰¤ 1) â†”\n     âˆ€ a : â„‚, Â¬Polynomial.IsRoot p a âˆ¨ Â¬Polynomial.IsRoot (â†‘Polynomial.derivative p) a) "]}
{"theorem":"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ c, â†‘T v = c â€¢ v) â†’ âˆƒ c, âˆ€ (v : V), â†‘T v = c â€¢ v","text":"Suppose `T âˆˆ L(V)` is such that every vector in `V` is an eigenvector of `T`. Prove that `T` is a scalar multiple of the identity operator.","result":true,"gps":[["âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ c, â†‘T v = c â€¢ v) â†’ âˆƒ c, âˆ€ (v : V), â†‘T v = c â€¢ v"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ (c : K), Module.End.HasEigenvector T c v) â†’ âˆƒ (c : K), T = c â€¢ LinearMap.id ","âˆ€ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V)\n  (h_eigvec : âˆ€ (v : V), v â‰  0 â†’ âˆƒ (Î¼ : K), T v = Î¼ â€¢ v),\n  âˆƒ (c : K), T = c â€¢ LinearMap.id ","âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), âˆƒ (c : K), T v = c â€¢ v) â†’ (âˆƒ (c : K), T = c â€¢ LinearMap.id) ","forall {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ c, T v = c â€¢ v) â†’ (âˆƒ c, T = c â€¢ (LinearMap.id : Module.End K V)) ","âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ (c : K), T v = c â€¢ v) â†’ (âˆƒ (c : K), âˆ€ (v : V), T v = c â€¢ v) ","âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : Module.End K V},\n  (âˆ€ (v : V), v â‰  0 â†’ âˆƒ c, T v = c â€¢ v) â†’ (âˆƒ c, T = c â€¢ 1) "]}
{"theorem":"âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V] {T S : V â†’â‚—[ğ•œ] V},\n  Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank ğ•œ V â†’\n    (âˆ€ (x : V) (Î¼ : ğ•œ), x âˆˆ Module.End.eigenspace S Î¼ â†” x âˆˆ Module.End.eigenspace T Î¼) â†’\n      LinearMap.comp S T = LinearMap.comp T S","text":"Suppose that `T âˆˆ L(V)` has `dim V` distinct eigenvalues and that `S âˆˆ L(V)` has the same eigenvectors as `T` (not necessarily with the same eigenvalues). Prove that `S T = T S`.","result":true,"gps":[["âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V]\n  [inst_3 : FiniteDimensional ğ•œ V] {T S : V â†’â‚—[ğ•œ] V},\n  Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank ğ•œ V â†’\n    (âˆ€ (x : V) (Î¼ : ğ•œ), x âˆˆ Module.End.eigenspace S Î¼ â†” x âˆˆ Module.End.eigenspace T Î¼) â†’\n      LinearMap.comp S T = LinearMap.comp T S"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V] [inst_3 : FiniteDimensional ğ•œ V]\n  {T S : V â†’â‚—[ğ•œ] V},\n  Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank ğ•œ V â†’\n    (âˆ€ (x : V) (Î¼ : ğ•œ), x âˆˆ Module.End.eigenspace S Î¼ â†” x âˆˆ Module.End.eigenspace T Î¼) â†’ S.comp T = T.comp S "]}
{"theorem":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V)","text":"Suppose `U` is a subspace of `V`. Prove that `UâŠ¥ = {0}` if and only if `U = V`.","result":true,"gps":[["âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V)","âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V)","âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V)"],["âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, Uá—® = âŠ¥ â†” U = V","âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, Uá—® = âŠ¥ â†” U = V"],["âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ Uá—® = âŠ¥ â†” U = V"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ","âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E} ,\n  Uá—® = âŠ¥ â†” U = V ","âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ Uá—® = âŠ¥ â†” U = V ","âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ","âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U â‰¤ V â†’ (Uá—® = âŠ¥ â†” U = V) ","âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E},\n  Uá—® = âŠ¥ â†” U = V "]}
{"theorem":"âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1","text":"For all odd `n` show that `8 | n^2 - 1`.","result":true,"gps":[["âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall_odd_n_eight_divides_pow_minus_one : âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) ","forall {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) ","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ","forall_odd_n_8_dvd_n_squared_minus_one : âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) ","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ","forall_odd_n_eight_divides_nsq_minus_one : âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ n ^ 2 - 1 ","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n^2 - 1) ","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) ","âˆ€ {n : â„•}, Odd n â†’ 8 âˆ£ (n ^ 2 - 1) "]}
{"theorem":"IsSquare 2","text":"Show that 2 is divisible by `(1 + i)^2` in `â„¤[i]`.","result":true,"gps":[["IsSquare 2"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["IsSquare 2 "]}
