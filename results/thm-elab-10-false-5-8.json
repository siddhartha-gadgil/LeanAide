{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures":
 ["If every proper closed set of a topological space is compact, then the space itself is compact.",
  "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
  "A group whose automorphism group is cyclic is Abelian.",
  "A finite torsion-free group is trivial",
  "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero."],
 "elaborated-prompts":
 [{"theorem":
   "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
   "some-correct": null,
   "prompt":
   "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p "]},
  {"theorem":
   "∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
    "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2 ",
    "∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ",
    "∀ (a₀ a₁ a₂ a₃ b₀ b₁ b₂ b₃ : ℕ),\n  ∃ c₀ c₁ c₂ c₃, a₀ ^ 2 + a₁ ^ 2 + a₂ ^ 2 + a₃ ^ 2 = (b₀ ^ 2 + b₁ ^ 2 + b₂ ^ 2 + b₃ ^ 2) * (c₀ ^ 2 + c₁ ^ 2 + c₂ ^ 2 + c₃ ^ 2) ",
    "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t p, a * b = r ^ 2 + s ^ 2 + t ^ 2 + p ^ 2 ",
    "∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n  b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 →\n  ∃ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 ",
    "∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ",
    "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n  ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 "]},
  {"theorem":
   "∀ {α : Type u_1} [self : MulZeroClass α], (∀ (a : α), a * a = a) → ∀ (a b : α), a * b = b * a",
   "some-correct": null,
   "prompt": "A ring with all elements idempotent is commutative.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [self : BooleanRing α] (a b : α), a * b = b * a ",
    "∀ {α : Type u_1} [self : CommRing α] (h : ∀ (a : α), a * a = a) (a b : α), a * b = b * a ",
    "∀ {α : Type u_1} [self : MulZeroClass α] (h : ∀ (a : α), a * a = a) (a b : α), a * b = b * a "]},
  {"theorem":
   "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], CharP F 2 → ∀ (a : F), IsSquare a",
   "some-correct": null,
   "prompt":
   "There are infinitely many pairs of primes that differ exactly by `2`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∃ (f : ℕ → ℕ × ℕ), (∀ (n : ℕ), Nat.Prime (f n).fst ∧ Nat.Prime (f n).snd ∧ (f n).snd - (f n).fst = 2) ∧ Function.Injective f ",
    "∃ f : ℕ → ℕ × ℕ, (∀ (n : ℕ), Nat.Prime (f n).fst ∧ Nat.Prime (f n).snd ∧ (f n).fst < (f n).snd ∧ (f n).snd - (f n).fst = 2) ∧ ∀ (m n : ℕ), m ≠ n → f m ≠ f n ",
    "∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a ",
    "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], CharP F 2 → ∀ (a : F), IsSquare a ",
    "Infinite (∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ q - p = 2) ",
    "∃ f : ℕ → ℕ, (∀ n, Nat.Prime (f n) ∧ Nat.Prime (f n + 2)) ∧ Set.Infinite {x : ℕ | Prime x ∧ Prime (x + 2)} "]},
  {"theorem":
   "(R : Type u) → [inst : DivisionRing R] → [inst_1 : Fintype R] → Field R",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ",
    "∀ (D : Type u) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ",
    "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R ",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ (R : Type u) [inst : DivisionRing R] [inst_1 : Fintype R], Field R "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)",
   "some-correct": null,
   "prompt":
   "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ",
    "∀ {α : Type u_1} {β : Type u_2} {e₁ : α → β} {e₂ : β → α},\n  Function.Injective e₁ → Function.Injective e₂ → ∃ (e : α ≃ β), True ",
    "∀ {X Y : Type u}, (∃ (f : X → Y), Function.Injective f) → (∃ (g : Y → X), Function.Injective g) → Nonempty (X ≃ Y) ",
    "∀ {α : Type u_1} {β : Type u_2} (e₁ : α → β) (e₂ : β → α),\n  Function.Injective e₁ → Function.Injective e₂ → ∃ (f : α ≃ β), True ",
    "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ",
    "∀ {α : Type u_1} {β : Type u_2} (f : α → β), Function.Injective f → (∃ (g : β → α), Function.Injective g) →\n  Nonempty (α ≃ β) ",
    "∀ {α : Type u_1} {β : Type u_2} {e₁ : α → β} {e₂ : β → α},\n  Function.Injective e₁ → Function.Injective e₂ → Nonempty (α ≃ β) ",
    "∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → (∃ (h : α ≃ β), ∀ (x : α), f x = h x) ",
    "∀ {α : Type u_1} {β : Type u_2} (e : α → β) (f : β → α),\n  Function.Injective e → Function.Injective f → Nonempty (α ≃ β) "]},
  {"theorem":
   "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w",
   "some-correct": null,
   "prompt":
   "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃ x, SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w ∧ ∀ (y : V), SimpleGraph.Adj G y v ∧ SimpleGraph.Adj G y w → y = x) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), ∃! u, SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), u ≠ v ∧ u ≠ w ∧ SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G u w) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), ∃! (x : V), SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) → ∃ (x : V), ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v "]},
  {"theorem":
   "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m",
   "some-correct": null,
   "prompt":
   "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ",
    "∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    ∃ m, ∀ (a : α), r m a → r a m ",
    "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain (fun a b => a ≤ b) c → ∃ ub, ∀ (a : α), a ∈ c → a ≤ ub) →\n    ∃ m, ∀ (a : α), m ≤ a → a ≤ m ",
    "forall {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ ∀ (x : α), x ∈ t → f x = 1",
   "some-correct": null,
   "prompt":
   "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t →\n  ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) ",
    "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t →\n  ∃ (f : α → ℝ), Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ (∀ (x : α), x ∈ t → f x = 1) ",
    "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ y ∈ t, f y = 1) ",
    "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, ContinuousOn f (s ∪ t) ∧ ∀ x ∈ s, f x = 0 ∧ ∀ x ∈ t, f x = 1 ",
    "forall {α : Type u} [t : TopologicalSpace α],\n  NormalSpace α ↔ ∀ {s t : Set α}, IsClosed s → IsClosed t → Disjoint s t → ∃f : α → ℝ, Continuous f ∧ ∀ x ∈ s, f x = 0 ∧ ∀ x ∈ t, f x = 1 ",
    "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, ContinuousOn f s ∧ ContinuousOn f t ∧ ∀ x, f x ∈ [0, 1] "]},
  {"theorem":
   "∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["forall {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] {f : α → α},\n  ContinuousOn f (Set.Icc 0 1) →\n  (∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) →\n  ∀ n, ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x ",
    "forall {α : Type u_1} (f : α → α) (x : α), \n  Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y "]},
  {"theorem":
   "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.17093583, u₁} C] →\n    {X Y : C} → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y)",
   "some-correct": null,
   "prompt":
   "A terminal object in a category is unique up to unique isomorphism.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C}\n  (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Unique (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C]\n  {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Unique (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X)\n  (hY : CategoryTheory.Limits.IsTerminal Y), Unique (X ≅ Y) "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets is the intersection of their complements.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ "]},
  {"theorem": "∀ {a b c : ℕ}, 0 < a → 0 < b → a ^ 3 + b ^ 3 ≠ c ^ 3",
   "some-correct": null,
   "prompt":
   "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b c : ℕ}, 0 < a → 0 < b → a ^ 3 + b ^ 3 ≠ c ^ 3 ",
    "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3 ",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
   "some-correct": null,
   "prompt":
   "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G], (∀ (a : G), a * a = 1) → ∀ (a b : G), Commute a b ",
    "∀ {G : Type u_1} [inst : Group G], (∀ g : G, g ^ 2 = 1) → ∀ a b : G, Commute a b ",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b "]},
  {"theorem": "∀ {m n : ℕ}, n = m + 1 → Even (m * n)",
   "some-correct": null,
   "prompt": "The product of two consecutive natural numbers is even.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), Even (n * (n + 1)) ",
    "∀ {n : ℕ}, Even (n * (n + 1)) ",
    "∀ {m : ℕ}, Even (m * (m + 1)) ",
    "∀ {m n : ℕ}, n = m + 1 → Even (m * n) "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
   "some-correct": null,
   "prompt": "Every index 2 subgroup of a group is normal.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "forall {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H "]},
  {"theorem":
   "∀ {α : Type u_1} {G : Type u_2} [inst : Group G], (α → G) → Monoid.IsTorsionFree (FreeGroup α)",
   "some-correct": null,
   "prompt": "Every free group is torsion free.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {ι : Type u_1} (M : ι → Type u_2) [inst : (i : ι) → Group (M i)], Monoid.IsTorsionFree (FreeGroup (((i : ι) → M i))) ",
    "forall {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype α], IsFreeGroup G → Monoid.IsTorsionFree G ",
    "∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Nonempty α], Monoid.IsTorsionFree (FreeGroup α) ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ",
    "∀ {α : Type u_1} {G : Type u_2} [inst : Group G] (f : α → G), Monoid.IsTorsionFree (FreeGroup α) "]},
  {"theorem": "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
   "some-correct": null,
   "prompt":
   "Every natural number greater than `1` is divisible by a prime number.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ {n : ℕ}, n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n "]},
  {"theorem":
   "(R : Type u) → [inst : DivisionRing R] → [inst_1 : Fintype R] → Field R",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ",
    "∀ (D : Type u) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ",
    "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R ",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ (R : Type u) [inst : DivisionRing R] [inst_1 : Fintype R], Field R "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
   "some-correct": null,
   "prompt": "Every finite topological space is compact.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "Finite.toCompactSpace : ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α ",
    "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α "]},
  {"theorem":
   "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α →* α}, Function.Surjective ↑f → Function.Injective ↑f",
   "some-correct": null,
   "prompt":
   "Every surjective homomorphism from a finitely generated free group to itself is injective.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] [inst_2 : Fintype α] (f : α →* α),\n  Function.Surjective ↑f → Function.Injective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] {F : FreeGroup α} {f : FreeGroup α →* FreeGroup α},\n  Function.Surjective ↑f → Function.Injective ↑f ",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α →* α},\n  Function.Surjective ↑f → Function.Injective ↑f "]},
  {"theorem":
   "∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
   "some-correct": null,
   "prompt":
   "Every positive even integer can be written as the sum of two primes.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), n > 2 → Even n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ {n : ℕ}, n > 0 → Even n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ n = a + b ",
    "∀ n : ℕ, 2 ≤ n → Even n → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "Goldbach's_conjecture : ∀ n : ℕ, 2 < n → n % 2 = 0 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ {n : ℕ}, n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "goldbach_conjecture : ∀ {n : ℕ}, 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q "]},
  {"theorem":
   "∀ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Matrix.charpoly M = 0",
   "some-correct": null,
   "prompt": "Every matrix satisfies its own characteristic polynomial.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["forall {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Matrix.charpoly M = 0 "]},
  {"theorem": "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
   "some-correct": null,
   "prompt": "The square root of an irrational number is irrational.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) "]},
  {"theorem": "∀ {n : ℕ}, n * n % 2 = 0 → n % 2 = 0",
   "some-correct": null,
   "prompt": "If the square of a number is even, the number itself is even.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 → x % 2 = 0 ",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {a : α}, a * a % 2 = 0 → a % 2 = 0 ",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ",
    "∀ {n : ℕ}, (n * n) % 2 = 0 → n % 2 = 0 "]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
   "some-correct": null,
   "prompt": "In a finite commutative ring, all prime ideals are maximal.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ",
    "∀ {R : Type u} [inst : CommRing R] [hR : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [hR : Fintype R], ∀ (I : Ideal R) [Ideal.IsPrime I], Ideal.IsMaximal I ",
    "∀ {R : Type u} [inst : CommRing R] [hR : Fintype R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [hR : Fintype R], \n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [F : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p | p.fst = p.snd}",
   "some-correct": null,
   "prompt":
   "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed {p : α × α | p.fst = p.snd} "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (U : Set α), IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s "]},
  {"theorem":
   "∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] {x : α}, x ≠ 1 → ¬IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every non-identity element of a free group is of infinite order.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] {x : α}, x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {α : Type u} [inst : Semigroup α] (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] (x : α), x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] (a : α), a ≠ 1 → ¬IsOfFinOrder a ",
    "∀ {α : Type u_1} (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x "]},
  {"theorem":
   "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
   "some-correct": null,
   "prompt":
   "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b N : ℕ}, Nat.coprime a b → a ≠ 0 → b ≠ 0 → ∃ (x y : ℕ), N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ (x y : ℕ), N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∃ N : ℕ, ∀ n : ℕ, N ≤ n → ∃ x y : ℕ, n = a * x + b * y ",
    "∀ {a b N : ℕ}, Nat.gcd a b = 1 → N ≥ a * b - a - b → ∃ x y : ℕ, N = a * x + b * y ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, a * x + b * y ≥ N "]},
  {"theorem": "(K : Type u) → [inst : Field K] → Ring K",
   "some-correct": null,
   "prompt": "Every field is a ring.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["forall (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K "]},
  {"theorem": "{R : Type u} → [inst : Ring R] → Group Rˣ",
   "some-correct": null,
   "prompt": "The set of units in a ring forms a group.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Group {R : Type u_1} [inst : Ring R] : Type u_1 ",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ ",
    "∀ {R : Type u} [inst : Ring R], Group Rˣ ",
    "∀ {R : Type u_1} [inst : Ring R], Group (Units R) ",
    "∀ {R : Type u_1} [inst : Monoid R], Group (Units R) ",
    "∀ {R : Type u} [inst : Monoid R], Group (Units R) ",
    "∀ {R : Type u} [inst : Ring R], Group (Units R) "]},
  {"theorem":
   "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
   "some-correct": null,
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  Monoid.IsTorsionFree ((i : η) → Gs i) → ∀ (i : η), Monoid.IsTorsionFree (Gs i) ",
    "forall {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ",
    "forall {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ",
    "forall {G : Type u_1} {H : Type u_2} [inst_1 : Group G] [inst_2 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ",
    "forall {A B : Type u_1} [inst : Group A] [inst_1 : Group B],\n  Monoid.IsTorsionFree (A × B) → Monoid.IsTorsionFree A ∧ Monoid.IsTorsionFree B ",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ",
    "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ",
    "∀ {G₁ G₂ : Type u_1} [inst : Group G₁] [inst_1 : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ "]}],
 "elaborated": 35}