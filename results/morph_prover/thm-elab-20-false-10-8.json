{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
  "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
  "A group whose automorphism group is cyclic is Abelian.",
  "Every matrix satisfies its own characteristic polynomial.",
  "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero."],
 "elaborated-prompts":
 [{"theorem":
   "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±),\n  IsClosed s â†’ s â‰  Set.univ â†’ IsCompact s â†’ IsCompact s",
   "some-correct": true,
   "prompt":
   "If every proper closed subset of a topological space is compact, then the space itself is compact.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±),\n  IsClosed s â†’ s â‰  Set.univ â†’ IsCompact s â†’ IsCompact s"],
    ["âˆ€ {X : Type u_1} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsClosed s â†’ s â‰  Set.univ â†’ IsCompact s) â†’ CompactSpace X"]],
   "correct": false,
   "comments": "Almost correct, also has unnecessary hypothesis.",
   "all-elabs":
   [" âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (h : âˆ€ s : Set X, IsClosed s â†’ s â‰  Set.univ â†’ IsCompact s), CompactSpace X",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsClosed s â†’ s â‰  Set.univ â†’ IsCompact s â†’ IsCompact â†‘s "]},
  {"theorem":
   "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = (2 * â†‘p - 1) / 4",
   "some-correct": false,
   "prompt":
   "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
   "groups":
   [["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = (2 * â†‘p - 1) / 4"]],
   "correct": false,
   "comments": "Hallucination",
   "all-elabs":
   [" âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b : â„¤, a ^ 2 + b ^ 2 = (2 * p - 1) / 4"]},
  {"theorem":
   "âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n  (âˆƒ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) â†’\n    (âˆƒ u v t w, b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2) â†’ âˆƒ u v t w, a * b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n  (âˆƒ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) â†’\n    (âˆƒ u v t w, b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2) â†’ âˆƒ u v t w, a * b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2",
     "âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n  (âˆƒ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) â†’\n    (âˆƒ u v p q, b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2) â†’ âˆƒ p p_1 q q_1, a * b = p ^ 2 + p_1 ^ 2 + q ^ 2 + q_1 ^ 2"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n  âˆƒ x y z u v, x ^ 2 + y ^ 2 = a âˆ§ z ^ 2 + u ^ 2 = b â†’ âˆƒ r s t n, a * b = r ^ 2 + s ^ 2 + t ^ 2 + n ^ 2"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n  âˆƒ x y z w u v,\n    a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 âˆ§ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 â†’\n      âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],
    ["âˆ€ (R : Type u_1) [inst : CommRing R] (a b : R),\n  IsSquare (a ^ 2 + b ^ 2) â†’ IsSquare (a ^ 2 - b ^ 2) â†’ âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n    (âˆƒ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) â†’\n      (âˆƒ u v t w, b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2) â†’\n        âˆƒ u v t w, a * b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2 ",
    " âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n   âˆƒ x y z w u v, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 âˆ§ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 â†’\n      âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ",
    " âˆ€ (R : Type u_1) [inst : CommRing R] (a b : R),\n  IsSquare (a ^ 2 + b ^ 2) â†’ IsSquare (a ^ 2 - b ^ 2) â†’ âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ",
    " âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n    (âˆƒ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) â†’\n      (âˆƒ u v p q, b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2) â†’\n        âˆƒ p p_1 q q_1, a * b = p ^ 2 + p_1 ^ 2 + q ^ 2 + q_1 ^ 2 ",
    " âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n     âˆƒ x y z u v : R, x ^ 2 + y ^ 2 = a âˆ§ z ^ 2 + u ^ 2 = b â†’ âˆƒ r s t n, a * b = r ^ 2 + s ^ 2 + t ^ 2 + n ^ 2 "]},
  {"theorem":
   "âˆ€ {Î± : Type u_2} [inst : NonUnitalNonAssocSemiring Î±] (a x y : Î±), a * a * (x * y) = x * y âˆ§ a * a * (y * x) = x * y",
   "some-correct": false,
   "prompt": "A ring with all elements idempotent is commutative.",
   "groups":
   [["âˆ€ {Î± : Type u_2} [inst : NonUnitalNonAssocSemiring Î±] (a x y : Î±), a * a * (x * y) = x * y âˆ§ a * a * (y * x) = x * y"],
    ["âˆ€ {Î± : Type u_3} [inst : CommRing Î±] (a b : Î±), IsIdempotentElem a â†’ IsIdempotentElem b â†’ Commute a b"],
    ["âˆ€ {Î± : Type u_5} [inst : CommRing Î±] (a : Î±), a * a = a â†’ Commute a a"],
    ["âˆ€ {Î± : Type u_2} [inst : CommRing Î±] (x y : Î±),\n  IsIdempotentElem x â†’\n    IsIdempotentElem y â†’ Commute x y âˆ§ IsIdempotentElem (x * y) âˆ§ IsIdempotentElem (y * x) âˆ§ x + y = 1 âˆ§ y + x = 1"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u_3} [inst : CommRing Î±] (a b : Î±), IsIdempotentElem a â†’ IsIdempotentElem b â†’ Commute a b",
    " âˆ€ {Î± : Type u_5} [inst : CommRing Î±] (a : Î±), a * a = a â†’ Commute a a",
    " âˆ€ {Î± : Type u_2} [inst : CommRing Î±] (x y : Î±), IsIdempotentElem x â†’ IsIdempotentElem y â†’ Commute x y âˆ§ IsIdempotentElem (x * y) âˆ§ IsIdempotentElem (y * x) âˆ§ x + y = 1 âˆ§ y + x = 1",
    " âˆ€ {Î± : Type u_2} [inst : NonUnitalNonAssocSemiring Î±] (a : Î±), âˆ€ x y : Î±, a * a * (x * y) = x * y âˆ§ a * a * (y * x) = x * y"]},
  {"theorem":
   "âˆ€ (n : â„•), n â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰  n âˆ§ p = n + 2}",
   "some-correct": false,
   "prompt":
   "There are infinitely many pairs of primes that differ exactly by `2`.",
   "groups":
   [["âˆ€ (n : â„•), n â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰  n âˆ§ p = n + 2}"],
    ["âˆ€ {n : â„•}, n â‰  0 â†’ âˆƒ p q, Nat.Prime p â†’ Nat.Prime q â†’ p % 2 = 0 â†’ q % 2 = 1 â†’ p + 2 = q"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p + 2 = q",
    " âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p + 2 = q âˆ§ p â‰  q",
    " âˆ€ {n : â„•}, n â‰  0 â†’ âˆƒ p q : â„•, Nat.Prime p â†’ Nat.Prime q â†’ p % 2 = 0 â†’ q % 2 = 1 â†’ p + 2 = q",
    " âˆ€ (n : â„•), n â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰  n âˆ§ p = n + 2} "]},
  {"theorem":
   "âˆ€ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["âˆ€ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
     "âˆ€ (R : Type u_1) [inst : Finite R] [inst_1 : DivisionRing R], IsField R"],
    ["âˆ€ {D : Type u_1} [inst : Finite D] [inst_1 : DivisionRing D], IsField D âˆ§ Finite D âˆ§ NoZeroDivisors D"],
    ["âˆ€ {D : Type u_1} [inst : Finite D] [inst_1 : CommRing D] [inst_2 : IsDomain D], IsField D"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ (D : Type u_1) [inst : Finite D] [inst : DivisionRing D], IsField D ",
    " âˆ€ (R : Type u_1) [inst : Finite R] [inst : DivisionRing R], IsField R ",
    " âˆ€ {D : Type u_1} [inst : Finite D] [inst_1 : CommRing D] [inst_2 : IsDomain D], IsField D ",
    " âˆ€ {D : Type u_1} [inst : Finite D] [inst : DivisionRing D], IsField D âˆ§ Finite (D) âˆ§ NoZeroDivisors D"]},
  {"theorem":
   "âˆ€ {X : Type u} {Y : Type v}, ((âˆƒ f, Function.Injective f) âˆ§ âˆƒ f, Function.Injective f) â†’ Nonempty (X â‰ƒ Y)",
   "some-correct": true,
   "prompt":
   "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
   "groups":
   [["âˆ€ {X : Type u} {Y : Type v}, ((âˆƒ f, Function.Injective f) âˆ§ âˆƒ f, Function.Injective f) â†’ Nonempty (X â‰ƒ Y)"],
    ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (g : Î² â†’ Î±), Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²)"],
    ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ âˆƒ h, â‡‘h = f âˆ§ â‡‘h.symm = g"]],
   "correct": false,
   "comments": "The types of f were not specified, otherwise could have been correct.",
   "all-elabs":
   [" âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²) ",
    " âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ âˆƒ h : Î± â‰ƒ Î², â‡‘h = f âˆ§ â‡‘h.symm = g ",
    " âˆ€ {X : Type u} {Y : Type v},\n  (âˆƒ f : X â†’ Y, Function.Injective f) âˆ§ (âˆƒ f : Y â†’ X, Function.Injective f) â†’ Nonempty (X â‰ƒ Y) "]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±] (s : Set Î±),\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ a âˆˆ c, r a ub) â†’\n    (âˆ€ a âˆˆ s, âˆ€ b âˆˆ s, r a b â†’ r b a) â†’\n      Nonempty (âˆ€ a âˆˆ s, âˆƒ ub, âˆ€ a âˆˆ s, r a ub) âˆ§ Set.Nonempty s â†’ Nonempty (âˆƒ m âˆˆ s, âˆ€ a âˆˆ s, r a m â†’ r m a)",
   "some-correct": true,
   "prompt":
   "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
   "groups":
   [["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±] (s : Set Î±),\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ a âˆˆ c, r a ub) â†’\n    (âˆ€ a âˆˆ s, âˆ€ b âˆˆ s, r a b â†’ r b a) â†’\n      Nonempty (âˆ€ a âˆˆ s, âˆƒ ub, âˆ€ a âˆˆ s, r a ub) âˆ§ Set.Nonempty s â†’ Nonempty (âˆƒ m âˆˆ s, âˆ€ a âˆˆ s, r a m â†’ r m a)"]],
   "correct": false,
   "comments": "Partial order hypothesis missing.",
   "all-elabs":
   [" âˆ€ {Î± : Type u_1} [Preorder Î±] [Nonempty Î±] (c : Set Î±),\n  (âˆ€ (a : Î±), IsChain (Â· â‰¤ Â·) c â†’ âˆƒ ub, âˆ€ a âˆˆ c, a â‰¤ ub) â†’ âˆƒ m âˆˆ c, âˆ€ a âˆˆ c, a â‰¤ m âˆ§ m â‰¤ a â†’ m = a âˆ§ m âˆˆ c",
    " âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] (h : âˆ€ c, IsChain (Â· â‰¤ Â·) c â†’ âˆƒ ub, âˆ€ a âˆˆ c, a â‰¤ ub) (c : Set Î±),\n  c â‰  âˆ… â†’ âˆƒ m, âˆ€ a âˆˆ c, a â‰¤ m âˆ§ âˆ€ b âˆˆ c, m â‰¤ b â†’ m = b",
    " âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±] (s : Set Î±)\n  (h : âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ a âˆˆ c, r a ub) (hs : âˆ€ a âˆˆ s, âˆ€ b âˆˆ s, r a b â†’ r b a),\n  Nonempty (âˆ€ a âˆˆ s, âˆƒ ub, âˆ€ a âˆˆ s, r a ub) âˆ§ s.Nonempty â†’ Nonempty (âˆƒ m âˆˆ s, âˆ€ a âˆˆ s, r a m â†’ r m a) "]},
  {"theorem":
   "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±}\n  [inst_2 : TopologicalSpace Î²], UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (f âˆ˜ g)",
   "some-correct": false,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±}\n  [inst_2 : TopologicalSpace Î²], UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (f âˆ˜ g)"],
    ["âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous â‡‘(UniformEquiv.symm self) â†’ UniformContinuous self.toFun"],
    ["âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun âˆ§ UniformContinuous self.invFun â†’\n    UniformContinuous self.toFun âˆ§ UniformContinuous self.invFun"]],
   "correct": false,
   "comments": "Statement is unclear to me.",
   "all-elabs":
   [" âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.symm â†’ UniformContinuous self.toFun ",
    " âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun âˆ§ UniformContinuous self.invFun â†’ UniformContinuous self.toFun âˆ§ UniformContinuous self.invFun ",
    " âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±}\n  [inst_2 : TopologicalSpace Î²],\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (f âˆ˜ g)"]},
  {"theorem":
   "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±}\n  [inst_2 : TopologicalSpace Î²], UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (f âˆ˜ g)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±}\n  [inst_2 : TopologicalSpace Î²], UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (f âˆ˜ g)"],
    ["âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun â†’ UniformContinuous self.invFun"],
    ["âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous â‡‘(UniformEquiv.symm self) â†’ UniformContinuous self.toFun"],
    ["âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun âˆ§ UniformContinuous self.invFun â†’\n    UniformContinuous self.toFun âˆ§ UniformContinuous self.invFun"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun â†’ UniformContinuous self.invFun ",
    " âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.symm â†’ UniformContinuous self.toFun ",
    " âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun âˆ§ UniformContinuous self.invFun â†’ UniformContinuous self.toFun âˆ§ UniformContinuous self.invFun ",
    " âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±}\n  [inst_2 : TopologicalSpace Î²],\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (f âˆ˜ g)"]},
  {"theorem":
   "âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ âˆ€ x âˆˆ t, f x = 1",
   "some-correct": null,
   "prompt":
   "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
   "groups":
   [["âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ âˆ€ x âˆˆ t, f x = 1",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ âˆ€ x âˆˆ t, f x = 1"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  NormalSpace X â†”\n    âˆ€ (s t : Set X),\n      IsClosed s â†’\n        IsClosed t â†’\n          Disjoint s t â†’ âˆƒ f a a', Disjoint a a' âˆ§ (âˆ€ x âˆˆ s, f x âˆˆ a) âˆ§ (âˆ€ x âˆˆ t, f x âˆˆ a') âˆ§ IsOpen a âˆ§ IsOpen a'"],
    ["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ Nonempty { f // Continuous f âˆ§ s âŠ† f â»Â¹' Set.Iic 0 âˆ§ t âŠ† f â»Â¹' Set.Ici 0 }"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X],\n  (s t : Set X) â†’ IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : X â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1)",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : X â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1)",
    " âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ Nonempty { f : X â†’ â„ // Continuous f âˆ§ s âŠ† f â»Â¹' Set.Iic 0 âˆ§ t âŠ† f â»Â¹' Set.Ici 0 } ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X], NormalSpace X â†”\n  âˆ€ (s t : Set X), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ (f : C(X, â„)) (a a' : Set â„),\n    Disjoint a a' âˆ§ (âˆ€ (x : X), x âˆˆ s â†’ f x âˆˆ a) âˆ§ (âˆ€ (x : X), x âˆˆ t â†’ f x âˆˆ a') âˆ§ IsOpen a âˆ§ IsOpen a'"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : Nonempty Î±] (f : Î± â†’ Î±) {x : Î±},\n  Function.IsPeriodicPt f 3 x â†’ âˆ€ (m : â„•), 0 < m â†’ âˆƒ y, Function.IsPeriodicPt f m y",
   "some-correct": false,
   "prompt":
   "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : Nonempty Î±] (f : Î± â†’ Î±) {x : Î±},\n  Function.IsPeriodicPt f 3 x â†’ âˆ€ (m : â„•), 0 < m â†’ âˆƒ y, Function.IsPeriodicPt f m y"],
    ["âˆ€ {Î± : Type u_1} [inst : Nontrivial Î±] (f : â„ â†’ â„) {x : â„},\n  Function.IsPeriodicPt f 3 x â†’ âˆ€ (n : â„•), âˆƒ y, Function.IsPeriodicPt f n y"]],
   "correct": false,
   "comments": "Chooses a more general type than the unit interval. Same for others. Otherwise correct.",
   "all-elabs":
   [" âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (f : â„ â†’ â„) (x : â„),\n  Function.IsPeriodicPt f 3 x â†’ âˆ€ (n : â„•), âˆƒ (y : â„), Function.IsPeriodicPt f (n * 3) y",
    " âˆ€ {Î± : Type u_1} [inst : Nontrivial Î±] (f : â„ â†’ â„) {x : â„} (_ : Function.IsPeriodicPt f 3 x), âˆ€ (n : â„•), âˆƒ (y : â„), Function.IsPeriodicPt f n y",
    " âˆ€ {Î± : Type u_1} [inst : Nonempty Î±] (f : Î± â†’ Î±) {x y : Î±},\n  Function.IsPeriodicPt f 3 x â†’ Function.IsPeriodicPt f 3 y â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f (n + 3) x âˆ§ Function.IsPeriodicPt f (n + 3) y ",
    " âˆ€ {Î± : Type u_1} [inst : Nonempty Î±] (f : Î± â†’ Î±) {x : Î±},\n  Function.IsPeriodicPt f 3 x â†’ âˆ€ (m : â„•), 0 < m â†’ âˆƒ y, Function.IsPeriodicPt f m y "]},
  {"theorem":
   "(C : Type u) â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] â†’ Unique (âˆ€ (X : C), Nonempty (X â‰… âŠ¤_ C))",
   "some-correct": false,
   "prompt":
   "A terminal object in a category is unique up to unique isomorphism.",
   "groups":
   [["(C : Type u) â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] â†’ Unique (âˆ€ (X : C), Nonempty (X â‰… âŠ¤_ C))"],
    ["(C : Type u) â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’ [inst_1 : CategoryTheory.Limits.HasTerminal C] â†’ Unique (C â‰Œ C)"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasTerminal C],\n  Unique (C â‰Œ C) ",
    " âˆ€ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasTerminal C],\n  Unique (âˆ€ (X : C), Nonempty (X â‰… âŠ¤_ C)) "]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
   "some-correct": false,
   "prompt":
   "The complement of the union of two sets is the intersection of their complements.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s âˆª tá¶œ = sá¶œ âˆ© tá¶œ",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s âˆª tá¶œ = sá¶œ âˆ© tá¶œ âˆ§ t âˆª sá¶œ = tá¶œ âˆ© sá¶œ"],
    ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ"]],
   "correct": false,
   "comments": "Union chosen instead of intersection.",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s âˆª tá¶œ = sá¶œ âˆ© tá¶œ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s âˆª tá¶œ = sá¶œ âˆ© tá¶œ âˆ§ t âˆª sá¶œ = tá¶œ âˆ© sá¶œ"]},
  {"theorem":
   "âˆ€ {m n k : â„•}, 0 < m â†’ 0 < n â†’ k * k * k â‰  m * m + n * n â†’ Â¬(0 < k â†’ 0 < k â†’ k * k = m * m + n * n)",
   "some-correct": true,
   "prompt":
   "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
   "groups":
   [["âˆ€ {m n k : â„•}, 0 < m â†’ 0 < n â†’ k * k * k â‰  m * m + n * n â†’ Â¬(0 < k â†’ 0 < k â†’ k * k = m * m + n * n)"],
    ["âˆ€ {n m k : â„•}, 0 < n â†’ 0 < m â†’ k â‰  n * n + m * m"],
    ["âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] [inst_1 : DivisionRing Î±] {x y z : Î±},\n  0 < x â†’ 0 < y â†’ 0 < z â†’ x * x + y * y â‰  z * z"]],
   "correct": false,
   "comments": "Dealing with squares instead of cubes.",
   "all-elabs":
   [" âˆ€ {n m k : â„•}, 0 < n â†’ 0 < m â†’ 0 < k â†’ n ^ 3 + m ^ 3 â‰  k ^ 3",
    " âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ 0 < z â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedCommRing Î±] {x y z : Î±}, 0 < x â†’ 0 < y â†’ 0 < z â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ",
    " âˆ€ {n m k : â„•}, 0 < n â†’ 0 < m â†’ k â‰  n * n + m * m",
    " âˆ€ {x y z : â„•}, x â‰  0 â†’ y â‰  0 â†’ z â‰  0 â†’ x ^ 3 + y ^ 3 â‰  z ^ 3",
    " âˆ€ {m n k : â„•}, 0 < m â†’ 0 < n â†’ k * k = m ^ 2 + n ^ 2 â†’ k = m âˆ§ k = n ",
    " âˆ€ {n : â„•}, 0 < n â†’ âˆ€ m p : â„•, m ^ 3 + p ^ 3 â‰  n ^ 3 âˆ§ 0 < m â†’ 0 < p âˆ§ p â‰  n",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] [inst_1 : DivisionRing Î±] {x y z : Î±}, 0 < x â†’ 0 < y â†’ 0 < z â†’ x * x + y * y â‰  z * z",
    " âˆ€ {m n k : â„•}, 0 < m â†’ 0 < n â†’ k * k * k â‰  m * m + n * n â†’ Â¬(0 < k â†’ 0 < k â†’ k * k = m * m + n * n)"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y",
   "some-correct": null,
   "prompt":
   "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y",
     "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y",
     "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y",
     "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y",
     "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y"],
    ["âˆ€ {G : Type u_1} [inst : Group G] (x y : G), orderOf x = 2 â†’ orderOf y = 2 â†’ Commute x y",
     "âˆ€ {G : Type u_1} [inst : Group G] (x y : G), orderOf x = 2 â†’ orderOf y = 2 â†’ Commute x y"],
    ["âˆ€ (G : Type u_1) [inst : Group G], (âˆ€ (x : G), IsOfFinOrder x â†’ orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {G : Type u_1} [inst : Group G], âˆ€ (x y : G), orderOf x = 2 â†’ orderOf y = 2 â†’ Commute x y",
    " âˆ€ {G : Type u_1} [inst : Group G], âˆ€ (x y : G), orderOf x = 2 â†’ orderOf y = 2 â†’ Commute x y",
    " âˆ€ {G : Type u_1} [inst : Group G] (h : âˆ€ x : G, orderOf x = 2), âˆ€ (x y : G), Commute x y ",
    " âˆ€ {G : Type u_1} [inst : Group G] (h : âˆ€ x : G, orderOf x = 2), âˆ€ (x y : G), Commute x y",
    " âˆ€ {G : Type u_1} [inst : Group G] (h : âˆ€ x : G, orderOf x = 2), âˆ€ x y : G, Commute x y ",
    " âˆ€ {G : Type u_1} [inst : Group G],\n  (âˆ€ (x : G), orderOf x = 2) â†’ âˆ€ (x y : G), Commute x y ",
    " âˆ€ {G : Type u_1} [inst : Group G] (H : âˆ€ x : G, orderOf x = 2), âˆ€ (x y : G), Commute x y ",
    " âˆ€ (G : Type u_1) [inst : Group G] (h : âˆ€ (x : G), IsOfFinOrder x â†’ orderOf x = 2), âˆ€ (x y : G), Commute x y "]},
  {"theorem": "âˆ€ {a b : â„•}, a + 1 â‰¤ b â†’ Even (a * b)",
   "some-correct": true,
   "prompt": "The product of two consecutive natural numbers is even.",
   "groups": [["âˆ€ {a b : â„•}, a + 1 â‰¤ b â†’ Even (a * b)"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ (n : â„•), Even (n * (n + 1))",
    " âˆ€ (n : â„•), Even (n * (n + 1))",
    " âˆ€ {n : â„•}, Even (n * (n + 1))",
    " âˆ€ n : â„•, Even (n * (n + 1)) ",
    " âˆ€ {a b : â„•}, a + 1 â‰¤ b â†’ Even (a * b)",
    " âˆ€ (n : â„•), Even (2 * n) â†’ Even (2 * (n + 1))",
    " âˆ€ {n : â„•}, Even n â†’ Even (n + 1) â†’ âˆƒ m, 2 * m = n âˆ¨ 2 * m + 1 = n",
    " âˆ€ {n : â„•}, Even (2 * n) â†” n â‰¤ 2 âˆ§ Even n âˆ§ Â¬n = 0 âˆ§ Â¬n = 1",
    " âˆ€ {n : â„•}, (âˆ€ (k : â„•), k â‰¤ n â†” k âˆˆ Finset.range (n + 1)) â†’ Even (Finset.prod Finset.univ fun k => k)"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
   "some-correct": null,
   "prompt": "Every index 2 subgroup of a group is normal.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
     "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H ",
    " âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H ",
    " âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 â†’ Subgroup.Normal H",
    " âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H "]},
  {"theorem":
   "âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt": "Every free group is torsion free.",
   "groups":
   [["âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G"],
    ["âˆ€ (G : Type u_1) [inst : Group G], Function.Injective â‡‘(MonoidHom.id G) â†’ Monoid.IsTorsionFree G"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ",
    " âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G",
    " âˆ€ (G : Type u_1) [inst : Group G], Function.Injective (MonoidHom.id G) â†’ Monoid.IsTorsionFree G"]},
  {"theorem": "âˆ€ (n : â„•), 1 < n â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
   "some-correct": null,
   "prompt":
   "Every natural number greater than `1` is divisible by a prime number.",
   "groups":
   [["âˆ€ (n : â„•), 1 < n â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
     "âˆ€ {n : â„•}, 1 < n â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
     "âˆ€ {n : â„•}, 1 < n â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
     "âˆ€ {n : â„•}, 1 < n â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ (n : â„•), 1 < n â†’ âˆƒ p : â„•, Nat.Prime p âˆ§ p âˆ£ n",
    " âˆ€ {n : â„•}, 1 < n â†’ âˆƒ p : â„•, Nat.Prime p âˆ§ p âˆ£ n",
    " Set.InjOn Nat.factorization {x | 1 < x} ",
    " âˆ€ {n : â„•}, 1 < n â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ",
    " âˆ€ {n : â„•}, 1 < n â†’ âˆƒ p, Nat.Prime p âˆ§ p âˆ£ n",
    " Set.InjOn (fun (p : â„•) => Nat.Prime p) {x | 1 < x}"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±",
   "some-correct": null,
   "prompt": "A finite torsion-free group is trivial",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±",
     "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±"]],
   "correct": false,
   "comments": "Forgot torsion-free hypothesis.",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± ",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±"]},
  {"theorem":
   "âˆ€ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["âˆ€ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
     "âˆ€ (R : Type u_1) [inst : Finite R] [inst_1 : DivisionRing R], IsField R"],
    ["âˆ€ {D : Type u_1} [inst : Finite D] [inst_1 : DivisionRing D], IsField D âˆ§ Finite D âˆ§ NoZeroDivisors D"],
    ["âˆ€ {D : Type u_1} [inst : Finite D] [inst_1 : CommRing D] [inst_2 : IsDomain D], IsField D"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ (D : Type u_1) [inst : Finite D] [inst : DivisionRing D], IsField D ",
    " âˆ€ (R : Type u_1) [inst : Finite R] [inst : DivisionRing R], IsField R ",
    " âˆ€ {D : Type u_1} [inst : Finite D] [inst_1 : CommRing D] [inst_2 : IsDomain D], IsField D ",
    " âˆ€ {D : Type u_1} [inst : Finite D] [inst : DivisionRing D], IsField D âˆ§ Finite (D) âˆ§ NoZeroDivisors D"]},
  {"theorem":
   "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
   "some-correct": null,
   "prompt": "Every finite topological space is compact.",
   "groups":
   [["âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
     "âˆ€ (X : Type u) [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X ",
    " âˆ€ (X : Type u) [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X "]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : Group Î²] (f : Î± â†’* Î²) [inst_2 : IsFreeGroup Î±]\n  [inst_3 : IsFreeGroup Î²], Function.Surjective â‡‘f â†’ Function.Injective â‡‘f",
   "some-correct": false,
   "prompt":
   "Every surjective homomorphism from a finitely generated free group to itself is injective.",
   "groups":
   [["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : Group Î²] (f : Î± â†’* Î²) [inst_2 : IsFreeGroup Î±]\n  [inst_3 : IsFreeGroup Î²], Function.Surjective â‡‘f â†’ Function.Injective â‡‘f"],
    ["âˆ€ {Î± : Type u} [inst : Group Î±] {Î² : Type v} [inst_1 : Group Î²] (f : Î± â†’* Î²),\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘f"],
    ["âˆ€ {Î± : Type u} [inst : Group Î±] (Î² : Type v) [inst_1 : Group Î²] (f : Î± â†’â‚™* Î²),\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘f"],
    ["âˆ€ (G : Type u_3) [inst : Group G] [inst_1 : Fintype G] (f : G â†’* G), Function.Surjective â‡‘f â†’ Function.Injective â‡‘f"]],
   "correct": false,
   "comments": "Forgot finitely generated hypothesis.",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : Group Î±] {Î² : Type v} [inst_1 : Group Î²] (f : Î± â†’* Î²),\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘f ",
    " âˆ€ {Î± : Type u} [inst : Group Î±] (Î² : Type v) [inst_1 : Group Î²] (f : Î± â†’â‚™* Î²),\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘f",
    " âˆ€ (G : Type u_3) [inst : Group G] [inst_1 : Fintype G] (f : G â†’* G),\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘f",
    " âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : Group Î²] (f : Î± â†’* Î²) [inst_2 : IsFreeGroup Î±] [inst_3 : IsFreeGroup Î²],\n    Function.Surjective â‡‘f â†’ Function.Injective â‡‘f"]},
  {"theorem":
   "âˆ€ {n : â„•}, 0 < n â†’ Even n â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q",
   "some-correct": null,
   "prompt":
   "Every positive even integer can be written as the sum of two primes.",
   "groups":
   [["âˆ€ {n : â„•}, 0 < n â†’ Even n â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q",
     "âˆ€ (n : â„•), 0 < n â†’ Even n â†’ âˆƒ a b, Nat.Prime a âˆ§ Nat.Prime b âˆ§ n = a + b",
     "âˆ€ {n : â„•}, 0 < n â†’ Even n â†’ âˆƒ a b, Nat.Prime a âˆ§ Nat.Prime b âˆ§ n = a + b"],
    ["âˆ€ (n : â„•), 0 < n â†’ n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q âˆ§ p < q"],
    ["âˆ€ {n : â„•}, 0 < n â†’ Even n â†’ âˆƒ p q, Prime p âˆ§ Prime q âˆ§ n = p + q âˆ§ p < q"],
    ["âˆ€ (n : â„•), n â‰  0 â†’ n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ 2 * p + 2 * q = n"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {n : â„•}, 0 < n â†’ Even n â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q",
    " âˆ€ (n : â„•) (_ : 0 < n), Even n â†’ âˆƒ a b, Nat.Prime a âˆ§ Nat.Prime b âˆ§ n = a + b",
    " âˆ€ {n : â„•}, 0 < n â†’ Even n â†’ âˆƒ a b : â„•, Nat.Prime a âˆ§ Nat.Prime b âˆ§ n = a + b",
    " âˆ€ (n : â„•) (_ : 0 < n) (_ : Even n), âˆƒ p q, Prime p âˆ§ Prime q âˆ§ n = p + q",
    " âˆ€ {n : â„•}, 0 < n â†’ Even n â†’ âˆƒ p q : â„•, Prime p âˆ§ Prime q âˆ§ n = p + q âˆ§ p < q",
    " âˆ€ (n : â„•), n â‰  0 â†’ n % 2 = 0 â†’ âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ 2 * p + 2 * q = n",
    " âˆ€ (n : â„•) (_ : 0 < n) (h : n % 2 = 0), âˆƒ p q, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q âˆ§ p < q"]},
  {"theorem": "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r)",
   "some-correct": null,
   "prompt": "The square root of an irrational number is irrational.",
   "groups":
   [["âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r)",
     "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r)",
     "âˆ€ {r : â„} {x : â„}, Irrational r â†’ Irrational (Real.sqrt r)"],
    ["âˆ€ {x : â„š}, Irrational â†‘x â†’ Irrational (Real.sqrt â†‘x)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {r : â„} (h : Irrational r), Irrational (Real.sqrt r) ",
    " âˆ€ {r : â„} (h : Irrational r), Irrational (Real.sqrt r) ",
    " âˆ€ {x : â„š}, Irrational x â†’ Irrational (Real.sqrt x) ",
    " âˆ€ {r x : â„}, Irrational r â†’ Irrational (Real.sqrt r)"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {n : Î±}, n * n = 0 â†’ n = 0",
   "some-correct": false,
   "prompt": "If the square of a number is even, the number itself is even.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {n : Î±}, n * n = 0 â†’ n = 0"],
    ["âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {n : Î±}, âˆƒ x, x * x = 2 * n â†’ Even n"],
    ["âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {a b : Î±}, a * a = 2 * b â†” Even b âˆ§ Even a"]],
   "correct": false,
   "comments": "Has replaced even with 0. Uses LinearOrderedRing assumption in others which leads to errors.",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x ^ 2 % 2 = 0 â†’ x % 2 = 0 ",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {n : Î±}, n * n % 2 = 0 â†’ n % 2 = 0 ",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] (x : Î±), x ^ 2 % 2 = 0 â†’ x % 2 = 0",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {n : Î±}, âˆƒ x, x * x = 2 * n â†’ Even n",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {a b : Î±}, a * a = 2 * b â†” Even b âˆ§ Even a",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {n : Î±}, n * n = 0 â†’ n = 0 ",
    " âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {n : Î±}, âˆƒ k : Î±, n ^ 2 = 2 * k â†’ n = 0 âˆ¨ n = 2 * k âˆ§ k = 0 ğ•œ"]},
  {"theorem":
   "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
   "some-correct": null,
   "prompt": "In a finite commutative ring, all prime ideals are maximal.",
   "groups":
   [["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
     "âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
     "âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
     "âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P"],
    ["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Finite R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
     "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Finite R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
     "âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : Finite R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Finite R] (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Finite R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P ",
    " âˆ€ {R : Type u} [inst : CommRing R] [Fintype R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ",
    " âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Finite R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
    " âˆ€ (R : Type u) [inst : CommRing R] [Fintype R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P",
    " âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Finite R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P ",
    " âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : Fintype R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P ",
    " âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : Finite R],\n  (P : Ideal R) â†’ Ideal.IsPrime P â†’ Ideal.IsMaximal P ",
    " âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : Fintype R], âˆ€ P : Ideal R, Ideal.IsPrime P â†’ Ideal.IsMaximal P"]},
  {"theorem":
   "âˆ€ (X : Type u) [inst : TopologicalSpace X], T2Space X â†” IsClosed {p | p.1 = p.2}",
   "some-correct": true,
   "prompt":
   "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$.",
   "groups":
   [["âˆ€ (X : Type u) [inst : TopologicalSpace X], T2Space X â†” IsClosed {p | p.1 = p.2}"],
    ["âˆ€ (X : Type u_3) [inst : TopologicalSpace X], T2Space X â†” IsClosed {p | p.1 = p.2}"]],
   "correct": false,
   "comments": "Type of p not specified.",
   "all-elabs":
   [" âˆ€ (X : Type u_3) [inst : TopologicalSpace X],\n  T2Space X â†” IsClosed { p : X Ã— X | p.1 = p.2 } ",
    " âˆ€ (X : Type u) [inst : TopologicalSpace X], T2Space X â†” IsClosed {p : X Ã— X | p.1 = p.2}",
    " âˆ€ (X : Type u_3) [inst : TopologicalSpace X], T2Space X â†” IsClosed {x | x.fst = x.snd}"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (U : Set Î±) (x : Î± â†’ Î±),\n  âˆ€ y âˆˆ U, âˆƒ V, IsOpen V âˆ§ y âˆˆ V âˆ§ x y âˆˆ V â†’ U âŠ† V âˆ§ IsOpen U",
   "some-correct": true,
   "prompt":
   "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (U : Set Î±) (x : Î± â†’ Î±),\n  âˆ€ y âˆˆ U, âˆƒ V, IsOpen V âˆ§ y âˆˆ V âˆ§ x y âˆˆ V â†’ U âŠ† V âˆ§ IsOpen U"],
    ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (U : Set Î±), (âˆ€ x âˆˆ U, âˆƒ V, IsOpen V âˆ§ x âˆˆ V âˆ§ V âŠ† U) â†’ IsOpen U"],
    ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (U : Set Î±), (âˆ€ x âˆˆ U, âˆƒ V, IsOpen V âˆ§ x âˆˆ V) â†’ IsOpen U"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (U : Set Î±),\n  (âˆ€ (x : Î±), x âˆˆ U â†’ âˆƒ (V : Set Î±), IsOpen V âˆ§ x âˆˆ V âˆ§ V âŠ† U) â†’ IsOpen U ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (U : Set Î±),\n  (âˆ€ (x : Î±), x âˆˆ U â†’ âˆƒ (V : Set Î±), IsOpen V âˆ§ x âˆˆ V) â†’ IsOpen U ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (âˆ€ x : X, x âˆˆ s â†’ âˆƒ u, IsOpen u âˆ§ x âˆˆ u) â†’ IsOpen s",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] (s t : Set X), âˆ€ (x : X), x âˆˆ s â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U â†’ x âˆˆ t â†’ U âŠ† t âˆ§ IsOpen s âˆ§ IsClosed t",
    " âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (U : Set Î±) (x : Î± â†’ Î±), âˆ€ y âˆˆ U, âˆƒ V : Set Î±, IsOpen V âˆ§ y âˆˆ V âˆ§ x y âˆˆ V â†’ U âŠ† V âˆ§ IsOpen U ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±) [inst_1 : T1Space Î±] (x : Î±) (hx : x âˆˆ s), âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s âˆ§ Set.Nonempty (U âˆ© s) â†’ IsOpen s"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every non-identity element of a free group is of infinite order.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x â‰  1 â†’ Â¬IsOfFinOrder x",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g â‰  1 â†’ Â¬IsOfFinOrder g",
     "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g â‰  1 â†’ Â¬IsOfFinOrder g"],
    ["âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x ",
    " âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x ",
    " âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x â‰  1 â†’ Â¬IsOfFinOrder x ",
    " âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x",
    " âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g â‰  1 â†’ Â¬IsOfFinOrder g ",
    " âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x ",
    " âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g â‰  1 â†’ Â¬IsOfFinOrder g"]},
  {"theorem":
   "âˆ€ {a b : â„•} {x y u v : â„•},\n  Nat.Coprime a b â†’\n    âˆ€ (N : â„•), âˆƒ r s, r * a + s * b = N âˆ§ âˆ€ (m : â„•), Nat.Coprime m a â†’ Nat.Coprime m b â†’ âˆƒ x y, m = a * x + b * y",
   "some-correct": false,
   "prompt":
   "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
   "groups":
   [["âˆ€ {a b : â„•} {x y u v : â„•},\n  Nat.Coprime a b â†’\n    âˆ€ (N : â„•), âˆƒ r s, r * a + s * b = N âˆ§ âˆ€ (m : â„•), Nat.Coprime m a â†’ Nat.Coprime m b â†’ âˆƒ x y, m = a * x + b * y"],
    ["âˆ€ {a b : â„•} {x y u v : â„•}, Nat.Coprime a b â†’ âˆ€ (N : â„•), âˆƒ r s, a * r + b * s = N"],
    ["âˆ€ {a b n : â„•} {x y : â„•}, Nat.Coprime a b â†’ 0 < a â†’ 0 < b â†’ âˆƒ x y, n = a * x + b * y"],
    ["âˆ€ {a b : â„•} {x y : â„•} {N : â„•},\n  a â‰  0 â†’ b â‰  0 â†’ Nat.Coprime a b â†’ âˆƒ x y, a * x + b * y = N âˆ§ y < N âˆ§ x < N âˆ§ (y + x) * (y + x) â‰¤ 2 * N"]],
   "correct": false,
   "comments": "Positive hypothesis missing. Statement a bit ambiguous, other statements in all-elabs almost correct.",
   "all-elabs":
   [" âˆ€ {a b x y u v : â„•}, Nat.Coprime a b â†’ âˆ€ N, âˆƒ r s, a * r + b * s = N",
    " âˆ€ {a b n x y : â„•}, Nat.Coprime a b â†’ 0 < a â†’ 0 < b â†’ âˆƒ (x y : â„•), â†‘n = a * x + b * y",
    " âˆ€ {a b x y u v : â„•}, Nat.Coprime a b â†’ âˆƒ r s, âˆ€ N > max u v, âˆƒ m n, N = a * m + b * n",
    " âˆ€ {a b x y u v n : â„•}, âˆƒ n, Nat.Coprime a b â†’ x â‰  0 â†’ y â‰  0 â†’ a * u ^ 2 + b * v ^ 2 = n * (a * x + b * y) ",
    " âˆ€ {a b x y u v N : â„•}, Nat.Coprime a b â†’ 0 < a â†’ 0 < b â†’ âˆƒ u v r s, N = u * a + v * b â†’ a * b * r = a * u * x + b * v * y ",
    " âˆ€ {a b x y u v : â„•}, Nat.Coprime a b â†’ âˆ€ (N : â„•) (_hp : 1 < N), âˆƒ r s, â†‘N = â†‘a * r + â†‘b * s",
    " âˆ€ {a b x y N : â„•}, a â‰  0 â†’ b â‰  0 â†’ Nat.Coprime a b â†’ âˆƒ x y, a * x + b * y = N âˆ§ y < N âˆ§ x < N âˆ§ (y + x) * (y + x) â‰¤ 2 * N",
    " âˆ€ {a b x y u v : â„•}, Nat.Coprime a b â†’ âˆ€ (N : â„•), âˆƒ r s, r * a + s * b = N âˆ§ âˆ€ m, Nat.Coprime m a â†’ Nat.Coprime m b â†’ âˆƒ x y, m = a * x + b * y",
    " âˆ€ {a b x y u v : â„•} [inst : DecidableEq â„•] {n : â„•},\n  a â‰  0 â†’ b â‰  0 â†’ Nat.Coprime a b â†’\n    âˆƒ N, âˆ€ n, N â‰¤ n â†’ âˆƒ x y u v,\n      a * x + b * y = n âˆ§ u * a + v * b = n âˆ§ x < u âˆ§ y < v âˆ§ (Â¬x.Prime âˆ¨ Â¬y.Prime) âˆ§ (Â¬u.Prime âˆ¨ Â¬v.Prime)"]},
  {"theorem": "{K : Type u_1} â†’ [inst : Field K] â†’ Ring K",
   "some-correct": null,
   "prompt": "Every field is a ring.",
   "groups":
   [["{K : Type u_1} â†’ [inst : Field K] â†’ Ring K",
     "{K : Type u_1} â†’ [inst : Field K] â†’ Ring K",
     "{K : Type u_1} â†’ [inst : Field K] â†’ Ring K"],
    ["âˆ€ {K : Type u_1} [inst : Field K] {R : Type u_2} [inst_1 : Ring R],\n  K â‰ƒ+* R â†’ IsDomain R âˆ§ âˆ€ (x : R), âˆƒ y, x * y = 1 âˆ¨ y * x = 1 âˆ§ y â‰  0"],
    ["{K : Type u} â†’ [inst : Field K] â†’ Ring K"],
    ["(K : Type u) â†’ [inst : Field K] â†’ Ring K"],
    ["(K : Type u_1) â†’ [inst : Field K] â†’ Ring K"],
    ["{F : Type u_2} â†’ [inst : Field F] â†’ Ring F"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {K : Type u_1} [inst : Field K], Ring K ",
    " âˆ€ {K : Type u_1} [inst : Field K], Ring K ",
    " âˆ€ {K : Type u_1} [inst : Field K], Ring K ",
    " âˆ€ {K : Type u} [inst : Field K], Ring K ",
    " âˆ€ (K : Type u) [inst : Field K], Ring K ",
    " âˆ€ (K : Type u_1) [inst : Field K], Ring K ",
    " âˆ€ {F : Type u_2} [inst : Field F], Ring F ",
    " âˆ€ {K : Type u_1} [inst : Field K] {R : Type u_2} [inst_1 : Ring R],\n  K â‰ƒ+* R â†’ IsDomain R âˆ§ âˆ€ (x : R), âˆƒ (y : R), x * y = 1 âˆ¨ y * x = 1 âˆ§ y â‰  0"]},
  {"theorem": "{R : Type u_1} â†’ [inst : Ring R] â†’ Group RË£",
   "some-correct": null,
   "prompt": "The set of units in a ring forms a group.",
   "groups":
   [["{R : Type u_1} â†’ [inst : Ring R] â†’ Group RË£",
     "{R : Type u_1} â†’ [inst : Ring R] â†’ Group RË£"],
    ["{R : Type u_1} â†’ [inst : GroupWithZero R] â†’ [inst_1 : Invertible 0] â†’ Group RË£"],
    ["{R : Type u_1} â†’ [inst : Ring R] â†’ Group RË£"],
    ["{R : Type u} â†’ [inst : Ring R] â†’ Group RË£"],
    ["{R : Type u_1} â†’ [inst : CommRing R] â†’ Group RË£"],
    ["{R : Type u} â†’ [inst : GroupWithZero R] â†’ GroupWithZero RË£"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {R : Type u_1} [inst : Ring R], Group RË£ ",
    " âˆ€ {R : Type u_1} [inst : Ring R], Group RË£ ",
    " âˆ€ {R : Type u_1} [inst : Ring R], Group RË£",
    " âˆ€ {R : Type u} [inst : Ring R], Group RË£ ",
    " âˆ€ {R : Type u_1} [inst : CommRing R], Group RË£ ",
    " âˆ€ {R : Type u} [inst : GroupWithZero R], GroupWithZero RË£",
    " âˆ€ {R : Type u_1} [inst : GroupWithZero R] [inst_1 : Invertible (0 : R)], Group RË£ "]},
  {"theorem":
   "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G â†’ Monoid.IsTorsionFree H",
   "some-correct": null,
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "groups":
   [["âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G â†’ Monoid.IsTorsionFree H",
     "âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G â†’ Monoid.IsTorsionFree H"],
    ["âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ",
    " âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G â†’ Monoid.IsTorsionFree H",
    " âˆ€ {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G â†’ Monoid.IsTorsionFree H"]}],
 "elaborated": 35}