{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["A finitely-presented group containing a torsion element is finite.",
  "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X Ã— X$.",
  "Every injective homomorphism from a finitely generated free group to itself is surjective.",
  "The characteristic polynomial of every matrix has real roots.",
  "Every uniformly continuous function is bounded above.",
  "The number of partitions of a finite set is a prime number.",
  "If a poset has a maximal element, then it has a unique minimal element.",
  "If the set of units of a ring forms a group then the ring is commutative.",
  "The initial object of a category is isomorphic to its terminal object.",
  "If the composition of two functions is continuous, then each of them is continuous."],
 "elaborated-prompts":
 [{"theorem": "âˆ€ {R : Type u} [inst : Semiring R], IsField R âˆ¨ Â¬IsField R",
   "some-correct": true,
   "prompt": "Every ring is a field.",
   "groups":
   [["âˆ€ {R : Type u} [inst : Semiring R], IsField R âˆ¨ Â¬IsField R",
     "âˆ€ {R : Type u} [inst : Semiring R], IsField R âˆ¨ Â¬IsField R"],
    ["âˆ€ {R : Type u} [inst : Semiring R], IsField R âˆ¨ Â¬IsField R âˆ¨ Â¬Nonempty R âˆ¨ Â¬Infinite R"],
    ["âˆ€ {R : Type u} [inst : Semiring R], IsField R"],
    ["{R : Type u} â†’ [inst : Semiring R] â†’ Field R"],
    ["(R : Type u) â†’ [inst : Ring R] â†’ Field R"],
    ["âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x : R), x â‰  0 â†’ âˆƒ y, x * y = 1"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ {R : Type u} [inst : Semiring R], IsField R âˆ¨ Â¬IsField R",
    " âˆ€ {R : Type u} [inst : Semiring R], IsField R âˆ¨ Â¬IsField R",
    " âˆ€ {R : Type u} [inst : Semiring R], IsField R",
    " âˆ€ {R : Type u} [inst : Semiring R], Field R",
    " âˆ€ (R : Type u) [inst : Ring R], Field R",
    " âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x : R), x â‰  0 â†’ âˆƒ y, x * y = 1 ",
    " âˆ€ {R : Type u} [inst : Semiring R], IsField R âˆ¨ Â¬IsField R âˆ¨ Â¬Nonempty R âˆ¨ Â¬Infinite R"]},
  {"theorem":
   "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
   "some-correct": null,
   "prompt": "Every vector space is finite dimensional.",
   "groups":
   [["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "âˆ€ {k : Type u} {V : Type v} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  FiniteDimensional k V"],
    ["âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V : FdRep k G), FiniteDimensional k (CoeSort.coe V)",
     "âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] {V : FdRep k G}, FiniteDimensional k (CoeSort.coe V)"],
    ["âˆ€ {ğ•œ : Type u} {V : Type v} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V], FiniteDimensional ğ•œ V"],
    ["âˆ€ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  FiniteDimensional k V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V ",
    " âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V ",
    " âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
    " âˆ€ {k : Type u} {V : Type v} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  FiniteDimensional k V",
    " âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V : FdRep k G), FiniteDimensional k V",
    " âˆ€ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n    FiniteDimensional k V",
    " âˆ€ {ğ•œ : Type u} {V : Type v} [inst : Field ğ•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ğ•œ V],\n  FiniteDimensional ğ•œ V ",
    " âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] {V : FdRep k G}, FiniteDimensional k V "]},
  {"theorem": "âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
   "some-correct": null,
   "prompt": "Every group is a torsion monoid.",
   "groups":
   [["âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G"],
    ["{G : Type u_1} â†’ [inst : Group G] â†’ Monoid G"],
    ["(G : Type u_1) â†’ [inst : Group G] â†’ Monoid G"],
    ["(G : Type u_1) â†’ [inst : Group G] â†’ Monoid G"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    " âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    " âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    " âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    " âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G ",
    " âˆ€ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G ",
    " âˆ€ (G : Type u_1) [inst : Group G], Monoid G",
    " âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    " âˆ€ (G : Type u_1) [inst : Group G], Monoid G ",
    " âˆ€ {G : Type u_1} [inst : Group G], Monoid G"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup Î± â†’ Fintype.card Î± = p âˆ¨ Fintype.card Î± = 0",
   "some-correct": null,
   "prompt": "Every finite simple group has prime order.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup Î± â†’ Fintype.card Î± = p âˆ¨ Fintype.card Î± = 0",
     "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] (p : â„•) [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup Î± â†’ Fintype.card Î± = p âˆ¨ Fintype.card Î± = 0"],
    ["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [inst_2 : IsSimpleGroup Î±],\n  Fintype.card Î± â‰  0 â†’ Nat.Prime (Fintype.card Î±)",
     "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [inst_2 : IsSimpleGroup Î±],\n  Fintype.card Î± â‰  0 â†’ Nat.Prime (Fintype.card Î±)"],
    ["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup Î± â†’ Fintype.card Î± = p âˆ§ IsCyclic Î± âˆ§ IsSimpleGroup Î± âˆ§ p â‰  2 âˆ§ p â‰  3"]],
   "correct": true,
   "comments": "It gives a more complete statement than the provided one",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [inst_2 : IsSimpleGroup Î±],\n  Fintype.card Î± â‰  0 â†’ Nat.Prime (Fintype.card Î±)",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [inst_2 : IsSimpleGroup Î±],\n  Fintype.card Î± â‰  0 â†’ Nat.Prime (Fintype.card Î±)",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup Î± â†’ Fintype.card Î± = p âˆ¨ Fintype.card Î± = 0",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] (p : â„•) [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup Î± â†’ Fintype.card Î± = p âˆ¨ Fintype.card Î± = 0",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup Î± â†’ Fintype.card Î± = p âˆ§ IsCyclic Î± âˆ§ IsSimpleGroup Î± âˆ§ p â‰  2 âˆ§ p â‰  3"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
   "some-correct": null,
   "prompt": "Every finite group is simple.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
     "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
     "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
     "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
     "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
     "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
     "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
     "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î±",
    " âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G "]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], Prime (Fintype.card Î±)",
   "some-correct": null,
   "prompt": "Every finite group has prime order.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], Prime (Fintype.card Î±)",
     "âˆ€ (Î± : Type u) [inst : Group Î±] [inst_1 : Fintype Î±], Prime (Fintype.card Î±)",
     "âˆ€ (Î± : Type u) [inst : Group Î±] [inst_1 : Fintype Î±], Prime (Fintype.card Î±)"],
    ["âˆ€ (Î± : Type u) [inst : Group Î±] [inst_1 : Fintype Î±], IsPrimePow (Fintype.card Î±) â†’ IsSimpleGroup Î±"],
    ["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î± â†’ IsPrimePow (Fintype.card Î±)"],
    ["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], Finite Î± â†’ IsPrimePow (Fintype.card Î±)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], Prime (Fintype.card Î±)",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î± â†’ IsPrimePow (Fintype.card Î±) ",
    " âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], Finite Î± â†’ IsPrimePow (Fintype.card Î±) ",
    " âˆ€ (Î± : Type u) [inst : Group Î±] [inst_1 : Fintype Î±], Prime (Fintype.card Î±) ",
    " âˆ€ (Î± : Type u) [inst : Group Î±] [inst_1 : Fintype Î±], Prime (Fintype.card Î±) ",
    " âˆ€ (Î± : Type u) [inst : Group Î±] [inst_1 : Fintype Î±],\n    IsPrimePow (Fintype.card Î±) â†’ IsSimpleGroup Î±"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), ?m.1801831 s = 0",
   "some-correct": true,
   "prompt": "Every set has Lebesgue measure zero.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), ?m.1801831 s = 0",
     "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), ?m.1801831 s = 0"],
    ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : Set Î±}, ?m.1801496 = 0",
     "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : Set Î±}, ?m.1801496 = 0"],
    ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : Set Î±}, ?m.1802006 = 0",
     "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : Set Î±}, ?m.1802006 = 0"],
    ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±] {s : Set Î±},\n  ?m.1802205 = 0"],
    ["âˆ€ (s : Set â„), ?m.1801666 s = 0"],
    ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±}, ?m.1802099 = 0"]],
   "correct": false,
   "comments": "Unidentified metavariable in the statement. In all elaborations, only the one on reals is true, and coercions need to be removed for it to be true.",
   "all-elabs":
   [" âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : Set Î±}, â†‘â†‘MeasureTheory.volume s = 0 ",
    " âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : Set Î±}, â†‘â†‘MeasureTheory.volume s = 0 ",
    " âˆ€ (s : Set â„), â†‘â†‘MeasureTheory.volume s = 0 ",
    " âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), â†‘â†‘MeasureTheory.volume s = 0 ",
    " âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), â†‘â†‘MeasureTheory.volume s = 0 ",
    " âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : Set Î±}, â†‘â†‘volume s = 0 ",
    " âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : Set Î±}, â†‘â†‘volume s = 0 ",
    " âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±}, â†‘â†‘Î¼ univ = 0 ",
    " âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  {s : Set Î±}, â†‘â†‘MeasureTheory.volume s = 0 "]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s",
   "some-correct": null,
   "prompt": "If a topological space is compact, then every subset is compact.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (s : Set X), IsCompact s",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±) [inst_1 : CompactSpace Î±], IsCompact s"],
    ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±}, IsCompact s â†’ IsCompact s",
     "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±}, IsCompact s â†” IsCompact s",
     "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±}, IsCompact s â†’ IsCompact s"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (s : Set X), IsCompact s",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s",
    " âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±}, IsCompact s â†’ IsCompact s",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±) [inst_1 : CompactSpace Î±], IsCompact s",
    " âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±}, IsCompact â†‘s â†” IsCompact s ",
    " âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±}, IsCompact s â†’ IsCompact â†‘s -------------"]},
  {"theorem":
   "{E : Type u_1} â†’\n  [inst : NormedAddCommGroup E] â†’\n    [inst_1 : NormedSpace â„ E] â†’\n      [inst_2 : MeasurableSpace E] â†’\n        [inst_3 : BorelSpace E] â†’\n          [inst_4 : FiniteDimensional â„ E] â†’\n            (Î¼ : MeasureTheory.Measure E) â†’ [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] â†’ Set E â†’ Prop â†’ Prop",
   "some-correct": true,
   "prompt":
   "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
   "groups":
   [["{E : Type u_1} â†’\n  [inst : NormedAddCommGroup E] â†’\n    [inst_1 : NormedSpace â„ E] â†’\n      [inst_2 : MeasurableSpace E] â†’\n        [inst_3 : BorelSpace E] â†’\n          [inst_4 : FiniteDimensional â„ E] â†’\n            (Î¼ : MeasureTheory.Measure E) â†’ [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] â†’ Set E â†’ Prop â†’ Prop"],
    ["âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set E} [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] (Î¼ : MeasureTheory.Measure E) [inst_4 : MeasureTheory.Measure.IsAddHaarMeasure Î¼],\n  MeasurableSet s â†’ Â¬BorelSpace â†‘s â†’ â†‘â†‘Î¼ s = 0"]],
   "correct": false,
   "comments": "The statement has been replaced with Prop. Ashvni thinks one statement in all-elabs is true, might be better if it is also checked by somebody else - there might be an extra unnecessary hypothesis.",
   "all-elabs":
   [" âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {s : Set E}\n  [inst_2 : MeasurableSpace E] [inst_3 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\n  [inst_4 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], MeasurableSet s â†’ Â¬BorelSpace s â†’ Î¼ s = 0 ",
    " âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], Set E â†’ Prop â†’ Prop "]},
  {"theorem":
   "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
   "groups":
   [["âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ a âˆˆ s, âˆƒ t, IsClosed t âˆ§ a âˆˆ t) â†’ IsClosed s"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t âˆ§ t âŠ† s) â†’ IsClosed s",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ a âˆˆ s, âˆƒ t, IsClosed t âˆ§ a âˆˆ t âˆ§ t âŠ† s) â†’ IsClosed s"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t, x âˆˆ t âˆ§ IsClosed t âˆ§ t âŠ† s) â†’ IsClosed s",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t, x âˆˆ t âˆ§ IsClosed t âˆ§ t âŠ† s) â†’ IsClosed s"],
    ["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t âˆ§ t âŠ† s) â†’ IsClosed s",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (âˆ€ x âˆˆ s, âˆƒ t, x âˆˆ t âˆ§ IsClosed t âˆ§ t âŠ† s) â†’ IsClosed s ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t, x âˆˆ t âˆ§ IsClosed t âˆ§ t âŠ† s) â†’ IsClosed s",
    " âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (âˆ€ a âˆˆ s, âˆƒ t, IsClosed t âˆ§ a âˆˆ t) â†’ IsClosed s ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (âˆ€ a âˆˆ s, âˆƒ t, IsClosed t âˆ§ a âˆˆ t âˆ§ t âŠ† s) â†’ IsClosed s"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1",
   "some-correct": null,
   "prompt": "Any finite order element in a group is equal to the identity.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1",
     "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ x = 1",
     "âˆ€ {Î± : Type u_1} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1",
     "âˆ€ {Î± : Type u_1} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1"],
    ["âˆ€ {Î± : Type u} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1",
     "âˆ€ {Î± : Type u} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1",
     "âˆ€ {Î± : Type u} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1"],
    ["âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x â†’ x = 1",
     "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x â†’ x = 1",
     "âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x â†’ x = 1 ",
    " âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x â†’ x = 1 ",
    " âˆ€ {Î± : Type u_1} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1 ",
    " âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ x = 1",
    " âˆ€ {Î± : Type u} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1 ",
    " âˆ€ {Î± : Type u} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1 ",
    " âˆ€ {Î± : Type u_1} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1",
    " âˆ€ {Î± : Type u_1} [inst : Group Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1",
    " âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {x : Î±}, IsOfFinOrder x â†’ x = 1",
    " âˆ€ {Î± : Type u} [inst : Group Î±] {x : Î±} (hx : IsOfFinOrder x), x = 1"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt":
   "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree â†¥H â†’ Monoid.IsTorsionFree G"]},
  {"theorem":
   "âˆ€ (D : Type u) [inst : DivisionRing D], IsField D âˆ¨ Nonempty (Finite D) âˆ§ Â¬Nonempty D",
   "some-correct": true,
   "prompt": "Every division ring is either a field or finite.",
   "groups":
   [["âˆ€ (D : Type u) [inst : DivisionRing D], IsField D âˆ¨ Nonempty (Finite D) âˆ§ Â¬Nonempty D"],
    ["âˆ€ (R : Type u) [inst : DivisionRing R], IsField R âˆ¨ Finite R"],
    ["âˆ€ (R : Type u) [inst : DivisionRing R], IsField R âˆ¨ IsDomain R"]],
   "correct": false,
   "comments": "Could not translate finiteness.",
   "all-elabs":
   [" âˆ€ (R : Type u) [inst : DivisionRing R], IsField R âˆ¨ Finite R ",
    " âˆ€ (R : Type u) [inst : DivisionRing R], IsField R âˆ¨ IsDomain R",
    " âˆ€ (D : Type u) [inst : DivisionRing D], IsField D âˆ¨ Nonempty (Finite D) âˆ§ Â¬(Nonempty D)"]},
  {"theorem":
   "âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ pâ‚ pâ‚‚, Nat.Prime pâ‚ âˆ§ Nat.Prime pâ‚‚ âˆ§ n = pâ‚ * pâ‚‚",
   "some-correct": null,
   "prompt": "Every natural number is the product of two primes.",
   "groups":
   [["âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ pâ‚ pâ‚‚, Nat.Prime pâ‚ âˆ§ Nat.Prime pâ‚‚ âˆ§ n = pâ‚ * pâ‚‚",
     "âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ pâ‚ pâ‚‚, Nat.Prime pâ‚ âˆ§ Nat.Prime pâ‚‚ âˆ§ n = pâ‚ * pâ‚‚"],
    ["âˆ€ (n : â„•), 0 < n â†’ âˆƒ pâ‚ pâ‚‚, Prime pâ‚ â†’ Prime pâ‚‚ â†’ n = pâ‚ * pâ‚‚ âˆ§ Nat.Prime (pâ‚ * pâ‚‚)"],
    ["âˆ€ (n : â„•), âˆƒ pâ‚ pâ‚‚, Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ pâ‚ * pâ‚‚ = n"],
    ["âˆ€ (n : â„•), âˆƒ p q, Nat.Prime p â†’ Nat.Prime q â†’ n = p * q"],
    ["âˆ€ {x : â„•}, x â‰  0 â†’ âˆƒ pâ‚ pâ‚‚, Nat.Prime pâ‚ âˆ§ Nat.Prime pâ‚‚ âˆ§ x = pâ‚ * pâ‚‚ âˆ§ pâ‚ â‰  pâ‚‚ âˆ§ pâ‚ â‰  x âˆ§ pâ‚‚ â‰  x"],
    ["âˆ€ (n : â„•), âˆƒ pâ‚ pâ‚‚, Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ n = pâ‚ * pâ‚‚ âˆ§ pâ‚ < pâ‚‚ âˆ§ Â¬pâ‚ âˆ£ pâ‚‚ âˆ§ Â¬pâ‚‚ âˆ£ pâ‚"]],
   "correct": true,
   "comments": "It also understood that natural number in math is separate from natural number in Lean.",
   "all-elabs":
   [" âˆ€ (n : â„•), âˆƒ (pâ‚ pâ‚‚ : â„•), Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ pâ‚ * pâ‚‚ = n ",
    " âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ pâ‚ pâ‚‚ : â„•, Nat.Prime pâ‚ âˆ§ Nat.Prime pâ‚‚ âˆ§ n = pâ‚ * pâ‚‚",
    " âˆ€ (n : â„•), âˆƒ p q : â„•, Nat.Prime p â†’ Nat.Prime q â†’ n = p * q",
    " âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ pâ‚ pâ‚‚, Nat.Prime pâ‚ âˆ§ Nat.Prime pâ‚‚ âˆ§ n = pâ‚ * pâ‚‚",
    " âˆ€ {x : â„•}, x â‰  0 â†’ âˆƒ pâ‚ pâ‚‚ : â„•, Nat.Prime pâ‚ âˆ§ Nat.Prime pâ‚‚ âˆ§ x = pâ‚ * pâ‚‚ âˆ§ pâ‚ â‰  pâ‚‚ âˆ§ pâ‚ â‰  x âˆ§ pâ‚‚ â‰  x",
    " âˆ€ n : â„•, âˆƒ (pâ‚ pâ‚‚ : â„•), Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ n = pâ‚ * pâ‚‚ âˆ§ pâ‚ < pâ‚‚ âˆ§ Â¬pâ‚ âˆ£ pâ‚‚ âˆ§ Â¬pâ‚‚ âˆ£ pâ‚",
    " âˆ€ (n : â„•), 0 < n â†’ âˆƒ pâ‚ pâ‚‚ : â„•, Prime pâ‚ â†’ Prime pâ‚‚ â†’ n = pâ‚ * pâ‚‚ âˆ§ Nat.Prime (pâ‚ * pâ‚‚)"]},
  {"theorem": "âˆ€ {a : â„•}, Even a â†’ âˆƒ b, a = b * b",
   "some-correct": null,
   "prompt": "Every even number is the square of a natural number.",
   "groups":
   [["âˆ€ {a : â„•}, Even a â†’ âˆƒ b, a = b * b"],
    ["âˆ€ {n : â„•}, n % 2 = 0 â†’ âˆƒ a, n = a * a"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {n : â„•}, Even n â†’ âˆƒ a, n = a ^ 2 ",
    " âˆ€ {n : â„•}, Even n â†’ âˆƒ a, n = a ^ 2 ",
    " âˆ€ {n : â„•}, Even n â†’ âˆƒ a, n = a ^ 2",
    " âˆ€ {n : â„•}, Even n â†’ âˆƒ m, n = m ^ 2",
    " âˆ€ {n : â„•}, n % 2 = 0 â†’ âˆƒ a, n = a * a ",
    " âˆ€ {n : â„•}, Even n â†’ âˆƒ x, n = x ^ 2",
    " âˆ€ {a : â„•}, Even a â†’ âˆƒ b, b ^ 2 = a ",
    " âˆ€ {a : â„•}, Even a â†’ âˆƒ b, a = b * b ",
    " âˆ€ {n : â„•}, Even n â†’ âˆƒ k, â†‘k ^ 2 = n ",
    " âˆ€ {n : â„•}, Even n â†’ âˆƒ m, n = m ^ 2 âˆ§ Odd m âˆ¨ n = 0"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
   "some-correct": null,
   "prompt": "Every normal subgroup of a group has finite index.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H"],
    ["âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N âˆ¨ N = âŠ¤"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H ",
    " âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H ",
    " âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
    " âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N âˆ¨ N = âŠ¤"]},
  {"theorem":
   "âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P M : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal M â†’ P â‰¤ M â†’ P = M) âˆ§\n    âˆ€ (P M : Ideal R), Ideal.IsPrime P â†’ Ideal.IsPrime M â†’ (P â‰¤ M â†” P = M)",
   "some-correct": false,
   "prompt":
   "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
   "groups":
   [["âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P M : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal M â†’ P â‰¤ M â†’ P = M) âˆ§\n    âˆ€ (P M : Ideal R), Ideal.IsPrime P â†’ Ideal.IsPrime M â†’ (P â‰¤ M â†” P = M)"],
    ["âˆ€ {R : Type u} [inst : CommRing R] (P M : Ideal R), Ideal.IsPrime P â†’ Ideal.IsPrime M â†’ P â‰¤ M â†’ M = P âˆ¨ P < M"],
    ["âˆ€ {R : Type u} [inst : CommRing R] (P M : Ideal R) [inst_1 : Ideal.IsPrime P] [inst_2 : Ideal.IsMaximal M],\n  P â‰¤ M âˆ§ âˆ€ (N : Ideal R) [inst_3 : Ideal.IsPrime N] [inst_4 : Ideal.IsMaximal N], P â‰¤ N â†’ N = M"],
    ["âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P Q : Ideal R), Ideal.IsPrime P â†’ Ideal.IsPrime Q â†’ P â‰¤ Q â†’ P = Q) â†’\n    âˆ€ (M P : Ideal R), Ideal.IsPrime P â†’ P â‰¤ M â†’ âˆƒ I, Ideal.IsMaximal I âˆ§ I = M âˆ§ P â‰¤ I"]],
   "correct": false,
   "comments": "The second statement in all-elabs comes close to being true but it assumes P le M for any maximal ideal M",
   "all-elabs":
   [" âˆ€ {R : Type u} [inst : CommRing R],\n  âˆ€ (P M : Ideal R), Ideal.IsPrime P â†’ Ideal.IsPrime M â†’ P â‰¤ M â†’ M = P âˆ¨ P < M",
    " âˆ€ {R : Type u} [inst : CommRing R] (P M : Ideal R) [inst_1 : Ideal.IsPrime P] [inst_2 : Ideal.IsMaximal M], P â‰¤ M âˆ§ âˆ€ (N : Ideal R) [inst_3 : Ideal.IsPrime N] [inst_4 : Ideal.IsMaximal N], P â‰¤ N â†’ N = M ",
    " âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P Q : Ideal R), Ideal.IsPrime P â†’ Ideal.IsPrime Q â†’ P â‰¤ Q â†’ P = Q) â†’ âˆ€ (M : Ideal R) (P : Ideal R),\n    Ideal.IsPrime P â†’ P â‰¤ M â†’ âˆƒ (I : Ideal R), Ideal.IsMaximal I âˆ§ I = M âˆ§ P â‰¤ I",
    " âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R) (M : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal M â†’ P â‰¤ M â†’ P = M) âˆ§ âˆ€ (P M : Ideal R), Ideal.IsPrime P â†’ Ideal.IsPrime M â†’ (P â‰¤ M â†” P = M)"]},
  {"theorem":
   "âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²), Continuous self.toFun",
   "some-correct": true,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²), Continuous self.toFun",
     "âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²), Continuous self.toFun"],
    ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f"],
    ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f"],
    ["âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f"],
    ["âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  Continuous self.toFun âˆ§ UniformContinuous self.toFun"]],
   "correct": false,
   "comments": "Given statement is a bit ambiguous, the chosen statement says the opposite of what is wanted.",
   "all-elabs":
   [" âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  Continuous self.toFun",
    " âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  Continuous self.toFun ",
    " âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ",
    " âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ",
    " âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  Continuous self.toFun âˆ§ UniformContinuous self.toFun ",
    " âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f"]},
  {"theorem":
   "âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
   "some-correct": null,
   "prompt":
   "If every compact subset of a topological space is closed, then the space is compact.",
   "groups":
   [["âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X] (s : Set X), IsCompact s â†’ IsClosed s â†’ CompactSpace X"],
    ["âˆ€ {X : Type u_1} [inst : TopologicalSpace X], (âˆ€ (s : Set X), IsCompact s â†’ IsClosed s) â†’ CompactSpace X"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {X : Type u} [inst : TopologicalSpace X], (âˆ€ s : Set X, IsCompact s â†’ IsClosed s) â†’ CompactSpace X ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] (h : âˆ€ s : Set X, IsCompact s â†’ IsClosed s), CompactSpace X ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  (âˆ€ s : Set X, IsCompact s â†’ IsClosed s) â†’ CompactSpace X ",
    " âˆ€ {X : Type u_1} [inst : TopologicalSpace X], (âˆ€ s : Set X, IsCompact s â†’ IsClosed s) â†’ CompactSpace X ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] (h : âˆ€ s : Set X, IsCompact s â†’ IsClosed s), CompactSpace X",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  (âˆ€ s : Set X, IsCompact s â†’ IsClosed s) â†’ CompactSpace X",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] (hX : âˆ€ s : Set X, IsCompact s â†’ IsClosed s), CompactSpace X ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X], âˆ€ s : Set X, IsCompact s â†’ IsClosed s â†’ CompactSpace X",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] (hX : âˆ€ (s : Set X), IsCompact s â†’ IsClosed s), CompactSpace X"]},
  {"theorem":
   "âˆ€ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)",
   "some-correct": null,
   "prompt":
   "In a commutative ring, the sum of idempotent elements is idempotent.",
   "groups":
   [["âˆ€ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)",
     "âˆ€ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)",
     "âˆ€ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)",
     "âˆ€ {Î± : Type u} [inst : CommRing Î±] {a b : Î±}, IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)",
     "âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)",
     "âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)",
     "âˆ€ {R : Type u_1} [inst : CommRing R] (e f : R), IsIdempotentElem e â†’ IsIdempotentElem f â†’ IsIdempotentElem (e + f)"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] (I J : Submodule R R),\n  IsIdempotentElem I â†’ IsIdempotentElem J â†’ IsIdempotentElem (I + J)"],
    ["âˆ€ {R : Type u_4} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)"]],
   "correct": false,
   "comments": "Statement is correct if sum is replaced by addition of 2 elements. Maybe somebody else should check it.",
   "all-elabs":
   [" âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) ",
    " âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) ",
    " âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)",
    " âˆ€ {R : Type u_4} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)",
    " âˆ€ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) ",
    " âˆ€ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) ",
    " âˆ€ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b)",
    " âˆ€ {R : Type u_1} [inst : CommRing R] (e f : R), IsIdempotentElem e â†’ IsIdempotentElem f â†’ IsIdempotentElem (e + f)",
    " âˆ€ {Î± : Type u} [inst : CommRing Î±] {a b : Î±}, IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) ",
    " âˆ€ {R : Type u_1} [inst : CommRing R] (I J : Submodule R R), IsIdempotentElem I â†’ IsIdempotentElem J â†’ IsIdempotentElem (I + J) "]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : CommGroup Î±], âˆƒ a, âˆ€ (g : ?m.44869332 a), IsOfFinOrder g â†” g = aâ»Â¹ * g * a",
   "some-correct": null,
   "prompt": "The automorphism group of an Abelian group is cyclic.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : CommGroup Î±], âˆƒ a, âˆ€ (g : ?m.44869332 a), IsOfFinOrder g â†” g = aâ»Â¹ * g * a"]],
   "correct": false,
   "comments": "Unidentified metavariable in the statement. There is a typeclass inference error in the all-elabs statement. It is also otherwise incorrect.",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : CommGroup Î±], âˆƒ a, âˆ€ g, IsOfFinOrder g â†” g = aâ»Â¹ * g * a "]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (f : â„ â†’ â„) {x : â„},\n  x âˆˆ Set.Icc 0 1 â†’ Function.IsFixedPt f x â†’ âˆ€ (n : â„•), âˆƒ y âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n y",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (f : â„ â†’ â„) {x : â„},\n  x âˆˆ Set.Icc 0 1 â†’ Function.IsFixedPt f x â†’ âˆ€ (n : â„•), âˆƒ y âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n y"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (f : â„ â†’ â„) {x : â„},\n  x âˆˆ Set.Icc 0 1 â†’ Function.IsFixedPt f x â†’ âˆ€ (n : â„•), âˆƒ y âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n y "]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, s âˆª t âŠ† sá¶œ âˆª tá¶œ",
   "some-correct": true,
   "prompt":
   "The complement of the union of two sets contains the union of their complements.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, s âˆª t âŠ† sá¶œ âˆª tá¶œ",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, s âˆª t âŠ† sá¶œ âˆª tá¶œ",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s âˆª t âŠ† sá¶œ âˆª tá¶œ",
     "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±},\n  s âˆª t âŠ† sá¶œ âˆª tá¶œ âˆ§\n    sá¶œ âˆª tá¶œ âŠ† sá¶œ âˆª tá¶œ âˆ§\n      sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n        sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n          sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n            sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n              sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                  sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                    sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                      sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                        sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                          sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                            sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                              sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                  sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                    sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                      sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                        sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                          sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                            sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                              sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                                sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                                  sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                                    sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                                      sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                                        sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§\n                                                          sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ"],
    ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±},\n  s âˆª t âŠ† sá¶œ âˆª tá¶œ âˆ¨ s âˆª t âŠ† sá¶œ âˆ§ t âŠ† tá¶œ âˆ¨ s âŠ† sá¶œ âˆ§ t âŠ† tá¶œ âˆ¨ s = sá¶œ âˆ¨ t = tá¶œ âˆ¨ sá¶œ = tá¶œ"],
    ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ âŠ† (s âˆª t)á¶œ"],
    ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ"]],
   "correct": false,
   "comments": "There is an unnecessary topological space hypothesis.",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, s âˆª t âŠ† sá¶œ âˆª tá¶œ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, s âˆª t âŠ† sá¶œ âˆª tá¶œ ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, sá¶œ âˆª tá¶œ âŠ† (s âˆª t)á¶œ ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s âˆª t âŠ† sá¶œ âˆª tá¶œ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±},\n  sá¶œ âˆª tá¶œ = (s âˆª t)á¶œ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, s âˆª t âŠ† sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ âŠ† sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ âˆ§ sá¶œ âˆª tá¶œ = sá¶œ âˆª tá¶œ ",
    " âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, s âˆª t âŠ† sá¶œ âˆª tá¶œ âˆ¨ s âˆª t âŠ† sá¶œ âˆ§ t âŠ† tá¶œ âˆ¨ s âŠ† sá¶œ âˆ§ t âŠ† tá¶œ âˆ¨ s = sá¶œ âˆ¨ t = tá¶œ âˆ¨ sá¶œ = tá¶œ"]},
  {"theorem": "âˆ€ (x : â„š), Real.sqrt â†‘x = â†‘(Rat.sqrt x)",
   "some-correct": null,
   "prompt": "The square root of an rational number is rational.",
   "groups": [["âˆ€ (x : â„š), Real.sqrt â†‘x = â†‘(Rat.sqrt x)"]],
   "correct": true,
   "comments": "Interesting way to prove it!",
   "all-elabs":
   [" âˆ€ {q : â„š}, Real.sqrt (â†‘q) âˆˆ Set.range Rat.cast ",
    " Rat.sqrt = Rat.sqrt âˆ˜ Rat.cast âˆ˜ Rat.sqrt âˆ˜ Rat.inv âˆ˜ Rat.sqrt âˆ˜ Rat.cast âˆ˜ Rat.inv âˆ˜ Rat.sqrt",
    " âˆ€ (q : â„š), Real.sqrt (q : â„) âˆˆ Set.range Rat.cast",
    " âˆ€ (x : â„š), Real.sqrt x = Rat.sqrt x",
    " âˆ€ {p : â„š}, âˆƒ q, Rat.sqrt p = â†‘q âˆ¨ Rat.sqrt p = -â†‘q ascript"]},
  {"theorem":
   "{R : Type u} â†’\n  {M : Type v} â†’\n    [inst : Ring R] â†’\n      [inst_1 : AddCommGroup M] â†’\n        [inst_2 : Module R M] â†’ [inst_3 : Module.Free R M] â†’ [inst : Module.Finite R M] â†’ CommRing R",
   "some-correct": null,
   "prompt": "If a module over a ring is free, then the ring is commutative.",
   "groups":
   [["{R : Type u} â†’\n  {M : Type v} â†’\n    [inst : Ring R] â†’\n      [inst_1 : AddCommGroup M] â†’\n        [inst_2 : Module R M] â†’ [inst_3 : Module.Free R M] â†’ [inst : Module.Finite R M] â†’ CommRing R"],
    ["(R : Type u_1) â†’\n  (M : Type u_2) â†’\n    [inst : Ring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst_2 : Module R M] â†’ [inst_3 : Module.Free R M] â†’ CommRing R"],
    ["{R : Type u} â†’\n  {M : Type v} â†’\n    [inst : Ring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst_2 : Module R M] â†’ [inst_3 : Module.Free R M] â†’ CommRing R"],
    ["{R : Type u_1} â†’\n  {M : Type u_2} â†’\n    [inst : Ring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst_2 : Module R M] â†’ [inst_3 : Module.Free R M] â†’ CommRing R"],
    ["(R : Type u_1) â†’\n  (M : Type u_2) â†’\n    [inst : Ring R] â†’ [inst_1 : AddCommMonoid M] â†’ [inst_2 : Module R M] â†’ [inst_3 : Module.Free R M] â†’ CommRing R"],
    ["{R : Type u} â†’\n  {M : Type v} â†’\n    [inst : Ring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst_2 : Module R M] â†’ [inst_3 : Module.Free R M] â†’ CommRing R"],
    ["(R : Type u_3) â†’\n  (M : Type u_4) â†’\n    [inst : Ring R] â†’ [inst_1 : AddCommMonoid M] â†’ [inst_2 : Module R M] â†’ [inst_3 : Module.Free R M] â†’ CommRing R"],
    ["{R : Type u_3} â†’\n  {M : Type u_4} â†’\n    [inst : Ring R] â†’\n      [inst_1 : StrongRankCondition R] â†’\n        [inst_2 : AddCommGroup M] â†’ [inst_3 : Module R M] â†’ [inst_4 : Module.Free R M] â†’ CommRing R"]],
   "correct": true,
   "comments": "There is an extra unwanted finiteness hypothesis.",
   "all-elabs":
   [" âˆ€ (R : Type u_1) (M : Type u_2) [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R ",
    " âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R ",
    " âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R",
    " âˆ€ (R : Type u_1) (M : Type u_2) [inst : Ring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R ",
    " âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R",
    " âˆ€ (R : Type u_3) (M : Type u_4) [inst : Ring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R ",
    " âˆ€ {R : Type u_3} {M : Type u_4} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M], CommRing R",
    " âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], âˆ€ [Module.Finite R M], CommRing R "]},
  {"theorem":
   "âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y z, y âˆˆ {x_1 | ?m.47318208 x y z x_1} âˆ§ n = x ^ 2 + y âˆ§ âˆƒ u v, Nat.Prime u âˆ§ n = x ^ 2 + y + u",
   "some-correct": false,
   "prompt":
   "Every natural number larger than `10` is the sum of a square and a prime.",
   "groups":
   [["âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y z, y âˆˆ {x_1 | ?m.47318208 x y z x_1} âˆ§ n = x ^ 2 + y âˆ§ âˆƒ u v, Nat.Prime u âˆ§ n = x ^ 2 + y + u"],
    ["âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y, n = x ^ 2 + y âˆ§ Nat.Prime y âˆ§ y â‰  2 âˆ§ y â‰  3 âˆ§ y â‰  5 âˆ§ y â‰  7 âˆ§ y â‰  11"],
    ["âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y, n = x ^ 2 + y âˆ§ Nat.Prime y âˆ§ 0 < y âˆ§ y â‰¤ n"],
    ["âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y z, n = x ^ 2 + z âˆ§ Nat.Prime z âˆ§ y ^ 2 + 1 = 0"],
    ["âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y z, y ^ 2 + z ^ 2 = n âˆ§ Nat.Prime z"],
    ["âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x p, n = x ^ 2 + p âˆ§ Nat.Prime p âˆ§ 0 < p âˆ§ Â¬p âˆ£ x"],
    ["âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y p, n = x ^ 2 + y ^ 2 âˆ§ Nat.Prime p âˆ§ 2 â‰¤ p âˆ§ p â‰¤ n âˆ§ Â¬(x = 0 âˆ§ y = 0)"],
    ["âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y p, n = x ^ 2 + y ^ 2 âˆ§ Nat.Prime p âˆ§ (y = 0 âˆ¨ Â¬Nat.Prime y) âˆ§ p âˆ£ n"]],
   "correct": false,
   "comments": "Unidentified metavariable in the statement. Other extra hallucinated goals added in other statements.",
   "all-elabs":
   [" âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y, n = x ^ 2 + y âˆ§ Nat.Prime y âˆ§ y â‰  2 âˆ§ y â‰  3 âˆ§ y â‰  5 âˆ§ y â‰  7 âˆ§ y â‰  11",
    " âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y, n = x ^ 2 + y âˆ§ Nat.Prime y âˆ§ 0 < y âˆ§ y â‰¤ n",
    " âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y z, n = x ^ 2 + z âˆ§ Nat.Prime z âˆ§ y ^ 2 + 1 = 0",
    " âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y z, y ^ 2 + z ^ 2 = n âˆ§ Nat.Prime z",
    " âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x p, n = x ^ 2 + p âˆ§ Nat.Prime p âˆ§ 0 < p âˆ§ Â¬(p âˆ£ x)",
    " âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y p, n = x ^ 2 + y ^ 2 âˆ§ Nat.Prime p âˆ§ 2 â‰¤ p âˆ§ p â‰¤ n âˆ§ Â¬(x = 0 âˆ§ y = 0)",
    " âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y p, n = x ^ 2 + y ^ 2 âˆ§ Nat.Prime p âˆ§ (y = 0 âˆ¨ Â¬Nat.Prime y) âˆ§ p âˆ£ n",
    " âˆ€ {n : â„•}, 10 < n â†’ âˆƒ x y z, y âˆˆ {Nat.prime _ | Nat.Prime _} âˆ§ n = x ^ 2 + y âˆ§ âˆƒ u v, Nat.Prime u âˆ§ n = x ^ 2 + y + u"]},
  {"theorem":
   "âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
   "some-correct": null,
   "prompt":
   "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
   "groups":
   [["âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
     "âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
     "âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
     "âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
     "âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c"],
    ["âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
     "âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c"]],
   "correct": true,
   "comments": "Extra assumptions in hypothesis, statement a bit ambiguous.",
   "all-elabs":
   [" âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ",
    " âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ",
    " âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ",
    " âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ",
    " âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    " âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c",
    " âˆ€ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ----"]},
  {"theorem":
   "âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R â†’+* S) {r : R}, f r = 0 â†’ r = 0",
   "some-correct": null,
   "prompt":
   "If an element maps to zero under a ring homomorphism, then it is zero.",
   "groups":
   [["âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R â†’+* S) {r : R}, f r = 0 â†’ r = 0",
     "âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S} {a : R}, f a = 0 â†’ a = 0"],
    ["âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S}, âˆ€ r âˆˆ RingHom.ker f, r = 0"],
    ["âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R â†’+* S} {r : R}, f r = 0 â†’ r = 0"],
    ["âˆ€ {R : Type u_1} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R â†’+* S) {a : R}, f a = 0 â†’ a = 0"]],
   "correct": true,
   "comments": "Generalized version",
   "all-elabs":
   [" âˆ€ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R â†’+* S} {r : R},\n  f r = 0 â†’ r = 0 ",
    " âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R â†’+* S) {r : R},\n  f r = 0 â†’ r = 0 ",
    " âˆ€ {R : Type u_1} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R â†’+* S) {a : R},\n  f a = 0 â†’ a = 0 ",
    " âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S} {a : R}, f a = 0 â†’ a = 0 ",
    " âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S}, âˆ€ (r : R), r âˆˆ RingHom.ker f â†’ r = 0"]},
  {"theorem": "âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
   "some-correct": null,
   "prompt": "Implication `â†’` is symmetric. If `P â†’ Q` then `Q â†’ P`.",
   "groups":
   [["âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
     "âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
     "âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
     "âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
     "âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
     "âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
     "âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
     "âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
     "âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
     "âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p ",
    " âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p ",
    " âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p ",
    " âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p ",
    " âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p ",
    " âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p ",
    " âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
    " âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
    " âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p",
    " âˆ€ {p q : Prop}, (p â†’ q) â†’ q â†’ p"]},
  {"theorem": "âˆ€ {m n : â„•}, (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ m â†” p âˆ£ n) â†” m = n",
   "some-correct": true,
   "prompt":
   "Two natural numbers are equal if and only if they are both divisible by some prime number.",
   "groups":
   [["âˆ€ {m n : â„•}, (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ m â†” p âˆ£ n) â†” m = n",
     "âˆ€ {m n : â„•}, (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ m â†” p âˆ£ n) â†” m = n"],
    ["âˆ€ {a b : â„•}, (âˆ€ (p : â„•), Nat.Prime p â†’ (p âˆ£ a â†” p âˆ£ b)) â†” a = b"],
    ["âˆ€ {m n : â„•}, (âˆƒ p, Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n"],
    ["âˆ€ {m n : â„•}, (âˆ€ (p : â„•), Irreducible p â†’ p âˆ£ m â†” p âˆ£ n) â†” m = n"],
    ["âˆ€ {m n : â„•}, (âˆƒ p, âˆƒ (_ : Nat.Prime p), p âˆ£ m âˆ§ p âˆ£ n) â†” m = n"]],
   "correct": false,
   "comments": "It gives the correct definition of equality of prime numbers.",
   "all-elabs":
   [" âˆ€ {m n : â„•}, (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ m â†” p âˆ£ n) â†” m = n ",
    " âˆ€ {m n : â„•}, (âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ m â†” p âˆ£ n) â†” m = n ",
    " âˆ€ {m n : â„•}, (âˆƒ p : â„•, Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n ",
    " âˆ€ {m n : â„•}, (âˆ€ (p : â„•), Irreducible p â†’ p âˆ£ m â†” p âˆ£ n) â†” m = n ",
    " âˆ€ {m n : â„•}, (âˆƒ (p : â„•) (hp : Nat.Prime p), p âˆ£ m âˆ§ p âˆ£ n) â†” m = n ",
    " âˆ€ {a b : â„•}, (âˆ€ (p : â„•) (hp : Nat.Prime p), p âˆ£ a â†” p âˆ£ b) â†” a = b",
    " âˆ€ {a b : â„•}, a = b â†” âˆƒ p, Prime p âˆ§ p âˆ£ a âˆ§ p âˆ£ b âˆ§ Â¬(p âˆ£ a âˆ§ Â¬p âˆ£ b) âˆ§ Â¬(Â¬p âˆ£ a âˆ§ p âˆ£ b) âˆ§ (Â¬p âˆ£ a â†’ p âˆ£ b) âˆ§ (p âˆ£ a â†’ Â¬p âˆ£ b)"]}],
 "elaborated": 30}