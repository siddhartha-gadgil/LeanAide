{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["Every set of Borel measure zero is Lebesgue measurable.",
  "There are `3` prime numbers below `8`.",
  "Every commutative ring is a monoid.",
  "The diameter of a singleton space is `0`."],
 "elaborated-prompts":
 [{"theorem": "âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p",
     "âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p",
     "âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ Odd p"],
    ["âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 âˆ¨ p % 2 = 3 âˆ¨ p % 2 = 5 âˆ¨ p % 2 = 7"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p",
    " âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p ",
    " âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p ----",
    " âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ Odd p ----",
    " âˆ€ {p : â„•}, Nat.Prime p â†’ p = 2 âˆ¨ p % 2 = 1 âˆ¨ p % 2 = 3 âˆ¨ p % 2 = 5 âˆ¨ p % 2 = 7"]},
  {"theorem": "âˆ€ {n : â„•}, n â‰  0 â†’ âˆƒ m, n < m âˆ§ Â¬Even m âˆ§ n â‰¤ m âˆ§ m â‰¤ n âˆ§ Odd m",
   "some-correct": true,
   "prompt": "There are infinitely many odd natural numbers.",
   "groups":
   [["âˆ€ {n : â„•}, n â‰  0 â†’ âˆƒ m, n < m âˆ§ Â¬Even m âˆ§ n â‰¤ m âˆ§ m â‰¤ n âˆ§ Odd m"],
    ["âˆ€ (n : â„•), Odd n â†’ âˆƒ m, n â‰¤ m âˆ§ Odd m âˆ§ Â¬m < n"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" Set.Infinite {n : â„• | n % 2 = 1} ",
    " Set.Infinite {m : â„• | Â¬ Even m} ",
    " âˆƒá¶  (n : â„•) in Filter.atTop, Odd n âˆ§ Odd (n + 1) âˆ§ Odd (n + 2)",
    " âˆ€ (n : â„•), Odd n â†’ âˆƒ m, n â‰¤ m âˆ§ Odd m âˆ§ Â¬m < n",
    " âˆ€ (a : â„•), 2 < a â†’ âˆƒ b, Odd b âˆ§ a < b âˆ§ Even (a + 1)",
    " âˆ€ {n : â„•}, n â‰  0 â†’ âˆƒ m, n < m âˆ§ Â¬Even m âˆ§ n â‰¤ m âˆ§ m â‰¤ n âˆ§ Odd m"]},
  {"theorem": "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬p = 2 â†’ p = 3 âˆ¨ p = 5 âˆ¨ p = 7",
   "some-correct": true,
   "prompt": "The smallest odd prime is `3`.",
   "groups":
   [["âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬p = 2 â†’ p = 3 âˆ¨ p = 5 âˆ¨ p = 7"],
    ["âˆ€ (p : â„•), Nat.Prime p â†’ p % 2 = 1 â†’ p = 3"],
    ["âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p < 3 â†’ Â¬p % 2 = 1"],
    ["âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p < 3 â†” p = 2"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ (p : â„•), Nat.Prime p â†’ p % 2 = 1 â†’ p = 3",
    " âˆƒ! (p : â„•), Nat.Prime p âˆ§ p % 2 = 1 âˆ§ p < 5",
    " âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p < 3 â†’ Â¬p % 2 = 1",
    " âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p < 3 â†” p = 2",
    " âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬(p = 2) â†’ p = 3 âˆ¨ p = 5 âˆ¨ p = 7"]},
  {"theorem": "âˆ€ {n : â„•}, Odd n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ Odd p",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups": [["âˆ€ {n : â„•}, Odd n â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ Odd p"]],
   "correct": true,
   "comments": "The odd hypothesis is not required but still true.",
   "all-elabs":
   [" Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ",
    " Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ",
    " Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ",
    " Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ",
    " Set.Infinite {p | Nat.Prime p âˆ§ Odd p}",
    " Set.Infinite {p | Nat.Prime p âˆ§ p % 2 = 1}",
    " âˆ€ {n : â„•}, Odd n â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ n < p âˆ§ Odd p",
    " âˆ€ {n : â„•}, Nat.Prime (2 * n + 1) â†’ n â‰  0 âˆ§ Nat.Prime (2 * n + 1)"]},
  {"theorem":
   "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V",
     "âˆ€ {ð•œ : Type u} {V : Type v} [inst : DivisionRing ð•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ð•œ V],\n  Module.rank ð•œ V = 2 â†’ FiniteDimensional ð•œ V",
     "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V",
     "âˆ€ {ð•œ : Type u} {V : Type v} [inst : DivisionRing ð•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ð•œ V] {n : â„•}\n  [inst_3 : AddTorsor V V], Module.rank ð•œ V = 2 â†’ FiniteDimensional ð•œ V"],
    ["âˆ€ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  Module.rank k V = 2 â†’ FiniteDimensional k V",
     "âˆ€ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  Module.rank k V = 2 â†’ FiniteDimensional k V"],
    ["âˆ€ {ð•œ : Type u_1} {V : Type u_2} [inst : Field ð•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ð•œ V],\n  Module.rank ð•œ V = 2 â†’ FiniteDimensional ð•œ V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ",
    " âˆ€ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  (h : Module.rank k V = 2), FiniteDimensional k V ",
    " âˆ€ {ð•œ : Type u} {V : Type v} [inst : DivisionRing ð•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ð•œ V],\n  Module.rank ð•œ V = 2 â†’ FiniteDimensional ð•œ V ",
    " âˆ€ {ð•œ : Type u_1} {V : Type u_2} [inst : Field ð•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ð•œ V],\n  Module.rank ð•œ V = 2 â†’ FiniteDimensional ð•œ V ",
    " âˆ€ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  Module.rank k V = 2 â†’ FiniteDimensional k V ",
    " âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (h : Module.rank K V = 2),\n  FiniteDimensional K V ",
    " âˆ€ {ð•œ : Type u} {V : Type v} [inst : DivisionRing ð•œ] [inst_1 : AddCommGroup V] [inst_2 : Module ð•œ V] {n : â„•} [inst_3 : AddTorsor V V],\n  Module.rank ð•œ V = 2 â†’ FiniteDimensional ð•œ V "]},
  {"theorem": "{K : Type u_1} â†’ [inst : Field K] â†’ DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["{K : Type u_1} â†’ [inst : Field K] â†’ DivisionRing K",
     "{K : Type u_1} â†’ [inst : Field K] â†’ DivisionRing K",
     "{K : Type u_1} â†’ [inst : Field K] â†’ DivisionRing K"],
    ["{K : Type u} â†’ [inst : Field K] â†’ DivisionRing K",
     "{K : Type u} â†’ [inst : Field K] â†’ DivisionRing K",
     "{K : Type u} â†’ [inst : Field K] â†’ DivisionRing K"],
    ["{R : Type u} â†’ [inst : Field R] â†’ DivisionRing R"],
    ["(K : Type u) â†’ [inst : Field K] â†’ DivisionRing K"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {K : Type u} [inst : Field K], DivisionRing K ",
    " âˆ€ {K : Type u} [inst : Field K], DivisionRing K ",
    " âˆ€ {K : Type u} [inst : Field K], DivisionRing K ",
    " âˆ€ {K : Type u_1} [inst : Field K], DivisionRing K ",
    " âˆ€ {K : Type u_1} [inst : Field K], DivisionRing K ",
    " âˆ€ {K : Type u_1} [inst : Field K], DivisionRing K ",
    " âˆ€ (K : Type u) [inst : Field K], DivisionRing K ",
    " âˆ€ {R : Type u} [inst : Field R], DivisionRing R"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : Bornology Î±] {Î¹ : Type v}, (Î¹ â†’ Î±) â†’ Cardinal.mk Î¹ = 2 â†’ BoundedSpace Î±",
   "some-correct": true,
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "groups":
   [["âˆ€ {Î± : Type u} [inst : Bornology Î±] {Î¹ : Type v}, (Î¹ â†’ Î±) â†’ Cardinal.mk Î¹ = 2 â†’ BoundedSpace Î±"],
    ["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V"]],
   "correct": false,
   "comments": "Statement is ambiguous.",
   "all-elabs":
   [" âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : Module.rank K V = 2), FiniteDimensional K V ",
    " âˆ€ {Î± : Type u} [inst : Bornology Î±] {Î¹ : Type v} (f : Î¹ â†’ Î±) (h : Cardinal.mk Î¹ = 2), BoundedSpace Î±"]},
  {"theorem": "âˆ€ (n : â„•), âˆƒ m, Nat.succ m = n",
   "some-correct": true,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["âˆ€ (n : â„•), âˆƒ m, Nat.succ m = n",
     "âˆ€ {n : â„•}, âˆƒ m, Nat.succ m = n",
     "âˆ€ (n : â„•), âˆƒ m, m + 1 = n"],
    ["âˆ€ {n : â„•}, âˆƒ m, m = n + 1"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ (n : â„•), âˆƒ m, Nat.succ m = n ",
    " âˆ€ {n : â„•}, âˆƒ m, Nat.succ m = n",
    " âˆ€ {n : â„•}, âˆƒ m, m = n + 1 ",
    " âˆ€ (n : â„•), âˆƒ m, m + 1 = n"]},
  {"theorem": "âˆ€ (n : â„•), n < Nat.succ n",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "groups":
   [["âˆ€ (n : â„•), n < Nat.succ n",
     "âˆ€ (n : â„•), n â‰¤ n + 1",
     "âˆ€ (n : â„•), n < Nat.succ n",
     "âˆ€ (n : â„•), n < n + 1",
     "âˆ€ (n : â„•), n < Nat.succ n",
     "âˆ€ {a : â„•}, a â‰¤ a + 1",
     "âˆ€ {Î± : Type u_9} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : LE Î±] [self : ZeroLEOneClass Î±] (n : â„•), n â‰¤ n + 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ (n : â„•), n < Nat.succ n ",
    " âˆ€ (n : â„•), n â‰¤ n + 1 ",
    " âˆ€ (n : â„•), n < Nat.succ n",
    " âˆ€ (n : â„•), n < n + 1 ",
    " âˆ€ (n : â„•), n < n.succ",
    " âˆ€ {a : â„•}, a â‰¤ a + 1",
    " âˆ€ {Î± : Type u_9} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : LE Î±] [self : ZeroLEOneClass Î±], âˆ€ n : â„•, n â‰¤ â†‘(n + 1) "]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±),\n  MeasurableSet s âˆ§ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ âˆƒ t, s âŠ† t âˆ§ MeasurableSet t âˆ§ â†‘â†‘Î¼ t = â†‘â†‘Î¼ s",
   "some-correct": false,
   "prompt": "Every set is Lebesgue measurable.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±),\n  MeasurableSet s âˆ§ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ âˆƒ t, s âŠ† t âˆ§ MeasurableSet t âˆ§ â†‘â†‘Î¼ t = â†‘â†‘Î¼ s"],
    ["âˆ€ {Î± : Type u_6} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±] (s : Set Î±),\n  MeasurableSet s"],
    ["âˆ€ {Î± : Type u_5} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\n  MeasureTheory.Measure Î± â†’ MeasurableSet Set.univ"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u_6} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±] (s : Set Î±),\n  MeasurableSet s",
    " âˆ€ {Î± : Type u_5} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±), MeasurableSet (Set.univ : Set Î±) ",
    " âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±),\n  MeasurableSet s âˆ§ Î¼ s â‰  âŠ¤ â†’ âˆƒ t, s âŠ† t âˆ§ MeasurableSet t âˆ§ Î¼ t = Î¼ s "]},
  {"theorem": "âˆ€ {n : â„•}, Nat.Prime n â†’ Â¬IsSquare n âˆ§ Â¬IsSquare (n ^ 2)",
   "some-correct": false,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["âˆ€ {n : â„•}, Nat.Prime n â†’ Â¬IsSquare n âˆ§ Â¬IsSquare (n ^ 2)",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬IsSquare p âˆ§ Â¬IsSquare (p ^ 2)"]],
   "correct": false,
   "comments": "Extra unnecessary goal",
   "all-elabs":
   [" âˆ€ {n : â„•}, Nat.Prime n â†’ Â¬IsSquare n âˆ§ Â¬IsSquare (n ^ 2)",
    " âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬IsSquare p âˆ§ Â¬IsSquare (p ^ 2)"]},
  {"theorem": "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Odd p â†’ 2 < p",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Odd p â†’ 2 < p",
     "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Odd p â†’ p > 2"],
    ["âˆ€ (p : â„•), Nat.Prime p â†’ Odd p â†’ 2 < p",
     "âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ 2 < p"],
    ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], 2 < p âˆ§ Odd p âˆ§ â†‘p â‰  0"],
    ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ 2 < p âˆ§ p â‰  3"],
    ["âˆ€ (p : â„•), Nat.Prime p â†’ Odd p â†’ 2 < p âˆ§ Nat.minFac p = 2"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ (p : â„•), Nat.Prime p â†’ Odd p â†’ 2 < p ",
    " âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] (h : Odd p), 2 < p",
    " âˆ€ {p : â„•}, Nat.Prime p â†’ Odd p â†’ 2 < p ",
    " âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ Odd p â†’ p > 2 ",
    " âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] (h : Odd p), 2 < p âˆ§ p â‰  3",
    " âˆ€ (p : â„•), Nat.Prime p â†’ Odd p â†’ 2 < p âˆ§ Nat.minFac p = 2",
    " âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], 2 < p âˆ§ Odd p âˆ§ (p : â„¤) â‰  0"]},
  {"theorem":
   "âˆ€ (a b x y u v r s : â„•), a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 âˆ§ b = r ^ 2 + s ^ 2 â†” âˆƒ q p, a * b = q ^ 2 + p ^ 2",
   "some-correct": true,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["âˆ€ (a b x y u v r s : â„•), a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 âˆ§ b = r ^ 2 + s ^ 2 â†” âˆƒ q p, a * b = q ^ 2 + p ^ 2"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n  âˆƒ x y z u v w,\n    a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 âˆ§ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 â†’\n      âˆƒ r s t u_1 v, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u_1 ^ 2"],
    ["âˆ€ {Î± : Type u} [inst : CommRing Î±] (a b : Î±),\n  (âˆƒ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) â†’\n    (âˆƒ u v w x, b = u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2) â†’ âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],
    ["âˆ€ (a b : â„•),\n  âˆƒ x y z w u v u_1 v_1,\n    a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 âˆ§ b = u ^ 2 + v ^ 2 + u_1 ^ 2 + v_1 ^ 2 âˆ§ âˆƒ r s, a * b = r ^ 2 + s ^ 2"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n  âˆƒ x y z w a' b',\n    a = (x + y) ^ 2 + (z + w) ^ 2 âˆ§ b = a' ^ 2 + b' ^ 2 âˆ§ a * b = (x * a' + y * b') ^ 2 + (z * a' + w * b') ^ 2"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), âˆƒ x y z u v w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 âˆ§ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 â†’ âˆƒ r s t u v, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ",
    " âˆ€ {Î± : Type u} [inst : CommRing Î±] (a b : Î±),\n    (âˆƒ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) â†’\n      (âˆƒ u v w x, b = u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2) â†’\n        âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ",
    " âˆ€ (a b : â„•), âˆƒ x y z w u v u_1 v_1,\n    a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 âˆ§ b = u ^ 2 + v ^ 2 + u_1 ^ 2 + v_1 ^ 2 âˆ§ âˆƒ r s, a * b = r ^ 2 + s ^ 2",
    " âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R),\n âˆƒ x y z w a' b' : R,\n    a = (x + y) ^ 2 + (z + w) ^ 2 âˆ§ b = a' ^ 2 + b' ^ 2 âˆ§ a * b = (x * a' + y * b') ^ 2 + (z * a' + w * b') ^ 2",
    " âˆ€ (a b x y u v r s : â„•),\n    a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 âˆ§ b = r ^ 2 + s ^ 2 â†” âˆƒ q p : â„•, a * b = q ^ 2 + p ^ 2 "]},
  {"theorem":
   "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"],
    ["âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f"],
    ["âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  Continuous self.toFun â†’ UniformContinuous self.toFun"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  Continuous self.toFun â†’ UniformContinuous self.toFun ",
    " âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f "]},
  {"theorem":
   "âˆ€ (pâ‚ pâ‚‚ pâ‚ƒ : â„•), Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ pâ‚ â‰  pâ‚‚ â†’ pâ‚ â‰  pâ‚ƒ â†’ pâ‚‚ â‰  pâ‚ƒ â†’ pâ‚ + pâ‚‚ = pâ‚ƒ â†’ false = true",
   "some-correct": true,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["âˆ€ (pâ‚ pâ‚‚ pâ‚ƒ : â„•), Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ pâ‚ â‰  pâ‚‚ â†’ pâ‚ â‰  pâ‚ƒ â†’ pâ‚‚ â‰  pâ‚ƒ â†’ pâ‚ + pâ‚‚ = pâ‚ƒ â†’ false = true"],
    ["âˆ€ {pâ‚ pâ‚‚ pâ‚ƒ : â„•}, Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ pâ‚ â‰  pâ‚‚ â†’ Nat.Prime pâ‚ƒ â†’ pâ‚ + pâ‚‚ = pâ‚ƒ â†’ False"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" Â¬(âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6) ",
    " Â¬âˆƒ pâ‚ pâ‚‚ : â„•, Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ pâ‚ â‰  pâ‚‚ â†’ 6 = pâ‚ + pâ‚‚",
    " Â¬âˆƒ pâ‚ pâ‚‚, Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ pâ‚ â‰  pâ‚‚ â†’ pâ‚ + pâ‚‚ = 6",
    " âˆ€ (p q : â„•), Nat.Prime p â†’ Nat.Prime q â†’ p + q = 6 â†’ p = 2 âˆ§ q = 3 âˆ¨ p = 3 âˆ§ q = 2 âˆ¨ p = q = 1 âˆ¨ p = q = 5",
    " âˆ€ {pâ‚ pâ‚‚ pâ‚ƒ : â„•}, Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ pâ‚ â‰  pâ‚‚ â†’ Nat.Prime pâ‚ƒ â†’ pâ‚ + pâ‚‚ = pâ‚ƒ â†’ False ",
    " âˆ€ (pâ‚ pâ‚‚ pâ‚ƒ : â„•), Nat.Prime pâ‚ â†’ Nat.Prime pâ‚‚ â†’ pâ‚ â‰  pâ‚‚ â†’ pâ‚ â‰  pâ‚ƒ â†’ pâ‚‚ â‰  pâ‚ƒ â†’ pâ‚ + pâ‚‚ = pâ‚ƒ â†’ false"]},
  {"theorem": "âˆ€ (a : â„¤), Â¬Irrational â†‘a âˆ§ (0 < Int.natAbs a âˆ¨ a = 0)",
   "some-correct": false,
   "prompt": "No integer is irrational.",
   "groups":
   [["âˆ€ (a : â„¤), Â¬Irrational â†‘a âˆ§ (0 < Int.natAbs a âˆ¨ a = 0)"],
    ["âˆ€ {x : â„¤}, Irrational â†‘x â†’ 0 = x âˆ¨ 1 = x âˆ¨ -1 = x"]],
   "correct": false,
   "comments": "Extra unnecessary goals",
   "all-elabs":
   [" âˆ€ {x : â„¤}, Irrational x â†’ 0 = x âˆ¨ 1 = x âˆ¨ -1 = x",
    " âˆ€ (a : â„¤), Â¬Irrational a âˆ§ (0 < a.natAbs âˆ¨ a = 0)"]},
  {"theorem": "âˆ€ {R : Type u} [inst : Ring R] {r : R}, IsUnit r â†” r = 1",
   "some-correct": true,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["âˆ€ {R : Type u} [inst : Ring R] {r : R}, IsUnit r â†” r = 1"],
    ["âˆ€ {R : Type u_1} [inst : CommRing R], IsUnit 1"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ {R : Type u} [inst : Ring R], IsUnit 1 ",
    " âˆ€ {R : Type u_1} [inst : CommRing R], IsUnit (1 : R) ",
    " âˆ€ {R : Type u} [inst : Ring R] {r : R}, IsUnit r â†” r = 1 "]},
  {"theorem": "{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H",
   "some-correct": null,
   "prompt": "Every subgroup of a group is a group.",
   "groups":
   [["{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H",
     "{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H",
     "{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H"],
    ["{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ Group â†¥H"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group â†¥H ",
    " âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group â†¥H ",
    " âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group â†¥H ",
    " âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group â†¥H"]},
  {"theorem": "âˆ€ {a b : â„•}, a + b âˆˆ Set.range id",
   "some-correct": null,
   "prompt": "The sum of two natural numbers is a natural number.",
   "groups":
   [["âˆ€ {a b : â„•}, a + b âˆˆ Set.range id", "âˆ€ {m n : â„•}, âˆƒ p, m + n = p"],
    ["âˆ€ {a b : â„•}, a âˆ£ b â†” âˆƒ c, a + c = b"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {a b : â„•}, a + b âˆˆ Set.range id",
    " âˆ€ {m n : â„•}, âˆƒ p : â„•, m + n = p ",
    " âˆ€ {a b : â„•}, a âˆ£ b â†” âˆƒ c, a + c = b ",
    " âˆ€ {m n : â„•}, m + n â‰¤ âŠ¤ â†’ âˆƒ k, m + n = k âˆ§ k â‰¤ âŠ¤ "]},
  {"theorem": "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder (id x)",
   "some-correct": true,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder (id x)"],
    ["âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder 1"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" IsOfFinOrder 1",
    " IsOfFinOrder 1",
    " âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1 ",
    " âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
    " âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder (1 : G) ",
    " âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder (id x) "]},
  {"theorem": "âˆ€ {q : â„•}, Nat.Prime q â†” q = 2 âˆ¨ q = 3 âˆ¨ q = 5 âˆ¨ q = 7",
   "some-correct": true,
   "prompt": "`7` is a prime number.",
   "groups": [["âˆ€ {q : â„•}, Nat.Prime q â†” q = 2 âˆ¨ q = 3 âˆ¨ q = 5 âˆ¨ q = 7"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" Nat.Prime 7",
    " Nat.Prime 7",
    " Nat.Prime 7",
    " Nat.Prime 7",
    " Nat.Prime 7",
    " Nat.Prime 7 ",
    " Nat.Prime 7 ",
    " Nat.Prime 7 ",
    " Nat.Prime 7 âˆ§ Nat.Prime 7",
    " âˆ€ {q : â„•}, Nat.Prime q â†” q = 2 âˆ¨ q = 3 âˆ¨ q = 5 âˆ¨ q = 7"]},
  {"theorem": "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s",
     "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s"],
    ["âˆ€ {Î± : Type u_1} [inst : Finite Î±], Set.Finite {x | x âˆˆ âˆ…} âˆ§ âˆ€ (s : Set Î±), Set.Finite s â†’ âˆƒ a âˆˆ s, a âˆˆ âˆ…"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ",
    " âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ",
    " âˆ€ {Î± : Type u_1} [inst : Finite Î±], Set.Finite {x | x âˆˆ âˆ…} âˆ§ âˆ€ (s : Set Î±), Set.Finite s â†’ âˆƒ a, a âˆˆ s âˆ§ a âˆˆ âˆ…"]},
  {"theorem":
   "âˆ€ {Î± : Type u} {s : Set Î±}, Infinite â†‘s â†’ Set.Finite s âˆ§ Nonempty â†‘s âˆ§ âˆƒ t âŠ† s, Set.Finite t",
   "some-correct": true,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["âˆ€ {Î± : Type u} {s : Set Î±}, Infinite â†‘s â†’ Set.Finite s âˆ§ Nonempty â†‘s âˆ§ âˆƒ t âŠ† s, Set.Finite t"],
    ["âˆ€ {Î± : Type u} (s : Set Î±), Infinite â†‘s â†’ âˆƒ t, Set.Finite t âˆ§ t âŠ† s"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u} (s : Set Î±), Infinite s â†’ âˆƒ t, Set.Finite t âˆ§ t âŠ† s",
    " âˆ€ {Î± : Type u} [inst : Infinite Î±], âˆƒ s, Set.Finite s âˆ§ s âŠ† Set.univ",
    " âˆ€ {Î± : Type u} {s : Set Î±}, Infinite s â†’ Set.Finite s âˆ§ Nonempty s âˆ§ âˆƒ t âŠ† s, Set.Finite t"]},
  {"theorem":
   "âˆ€ (ð•œ : Type u_1) [inst : DivisionRing ð•œ] (a : ð•œ), 10 = a ^ 2 âˆ¨ 10 = a ^ 3 â†’ Â¬IsField ð•œ",
   "some-correct": false,
   "prompt": "There is no field of order `10`.",
   "groups":
   [["âˆ€ (ð•œ : Type u_1) [inst : DivisionRing ð•œ] (a : ð•œ), 10 = a ^ 2 âˆ¨ 10 = a ^ 3 â†’ Â¬IsField ð•œ"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ (ð•œ : Type u_1) [inst : DivisionRing ð•œ] (a : ð•œ), 10 = a ^ 2 âˆ¨ 10 = a ^ 3 â†’ Â¬IsField ð•œ"]},
  {"theorem":
   "âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b, a â‰  b âˆ§ n = a + b âˆ§ Odd a âˆ§ Odd b âˆ§ âˆ€ (c : â„•), Odd c â†’ c â‰  a âˆ§ c â‰  b â†’ Odd (a + b + c)",
   "some-correct": true,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b, a â‰  b âˆ§ n = a + b âˆ§ Odd a âˆ§ Odd b âˆ§ âˆ€ (c : â„•), Odd c â†’ c â‰  a âˆ§ c â‰  b â†’ Odd (a + b + c)"],
    ["âˆ€ {n : â„•}, Odd n â†’ âˆƒ x y, n = x + y âˆ§ x â‰  y âˆ§ x â‰  y âˆ§ y â‰  0"],
    ["âˆ€ {n : â„•}, Odd n â†’ âˆƒ x y, Nat.Prime x â†’ Nat.Prime y â†’ x â‰  y â†’ n = x * y âˆ§ n â‰  x * x âˆ§ n â‰  y * y"],
    ["âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b, n = a + b âˆ§ a â‰  b âˆ§ Odd a âˆ§ Odd b"],
    ["âˆ€ {m : â„•}, Odd m â†’ âˆƒ a b, a â‰  b âˆ§ m = a + b âˆ§ Even a âˆ§ Even b"],
    ["âˆ€ {n : â„•}, Odd n â†’ âˆƒ x y z, x < y âˆ§ y < z âˆ§ n = x + y âˆ§ n = y + z âˆ§ x â‰  z âˆ§ x â‰  y"]],
   "correct": false,
   "comments": "Extra unnecessary goals. One statement in all-elabs is correct but only because Nat is abelian, it has one extra (equivalent) unnecessary goal.",
   "all-elabs":
   [" âˆ€ {n : â„•}, Odd n â†’ âˆƒ x y, n = x + y âˆ§ x â‰  y âˆ§ x â‰  y âˆ§ y â‰  0",
    " âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b, 0 < a âˆ§ 0 < b âˆ§ a â‰  b âˆ§ n = a + b âˆ§ n = b + a",
    " âˆ€ {n : â„•}, Odd n â†’ âˆƒ x y, Nat.Prime x â†’ Nat.Prime y â†’ x â‰  y â†’ n = x * y âˆ§ n â‰  x * x âˆ§ n â‰  y * y",
    " âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b : â„•, n = a + b âˆ§ a â‰  b âˆ§ Odd a âˆ§ Odd b",
    " âˆ€ (m : â„•), Odd m â†’ âˆƒ a b, Odd a â†’ Odd b â†’ m = a + b âˆ§ m â‰  a â†’ m â‰  b",
    " âˆ€ {m : â„•}, Odd m â†’ âˆƒ a b, a â‰  b âˆ§ m = a + b âˆ§ Even a âˆ§ Even b",
    " âˆ€ {n : â„•}, Odd n â†’ âˆƒ x y z : â„•, x < y âˆ§ y < z âˆ§ n = x + y âˆ§ n = y + z âˆ§ x â‰  z âˆ§ x â‰  y",
    " âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b, a â‰  b âˆ§ n = a + b âˆ§ Odd a âˆ§ Odd b âˆ§ (âˆ€ c, Odd c â†’ c â‰  a âˆ§ c â‰  b â†’ Odd (a + b + c))"]},
  {"theorem":
   "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†” x = 1",
   "some-correct": false,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†” x = 1",
     "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†” x = 1",
     "âˆ€ {G : Type u_1} [inst : Group G] (x : G), IsOfFinOrder x â†” x = 1"],
    ["âˆ€ {G : Type u_1} [inst : Group G] (x : G), IsOfFinOrder x"],
    ["âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 â†” x = 1"]],
   "correct": false,
   "comments": "Does not understand trivial group. Statement is a bit ambiguous as well.",
   "all-elabs":
   [" âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†” x = 1",
    " âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†” x = 1 ",
    " âˆ€ {G : Type u_1} [inst : Group G] (x : G), IsOfFinOrder x â†” x = 1",
    " âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 â†” x = 1",
    " âˆ€ {G : Type u_1} [inst : Group G], âˆ€ x : G, IsOfFinOrder x "]},
  {"theorem": "âˆ€ (n : â„•), Even n â†’ Even (n * n)",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups":
   [["âˆ€ (n : â„•), Even n â†’ Even (n * n)", "âˆ€ (n : â„•), Even n â†’ Even (n * n)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ (n : â„•), Even n â†’ Even (n ^ 2) ",
    " âˆ€ (n : â„•), Even n â†’ Even (n ^ 2) ",
    " âˆ€ (n : â„•), Even n â†’ Even (n ^ 2)",
    " âˆ€ (n : â„•), Even n â†’ Even (n * n) ",
    " âˆ€ (a : â„•), Even a â†’ Even (a ^ 2)",
    " âˆ€ n : â„•, Even n â†’ Even (n ^ 2) ",
    " âˆ€ n : â„•, Even n â†’ Even (n ^ 2) ",
    " âˆ€ n : â„•, Even n â†’ Even (n * n)"]},
  {"theorem":
   "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R",
   "some-correct": true,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R",
     "âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R",
     "âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R"],
    ["(R : Type u) â†’ [inst : CommRing R] â†’ [inst_1 : IsDomain R] â†’ [inst_2 : CommGroupWithZero R] â†’ Field R",
     "(R : Type u) â†’ [inst : CommRing R] â†’ [inst_1 : IsDomain R] â†’ [inst_2 : CommGroupWithZero R] â†’ Field R"],
    ["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DivInvMonoid R], IsField R"],
    ["âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R], IsField R"],
    ["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], Field R ",
    " âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], Field R ",
    " âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R ",
    " âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R ",
    " âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R ",
    " âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R], IsField R ",
    " âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R ",
    " âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DivInvMonoid R], IsField R "]},
  {"theorem": "âˆ€ {Î± : Type u} [inst : Group Î±], id 1 = 1",
   "some-correct": true,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups": [["âˆ€ {Î± : Type u} [inst : Group Î±], id 1 = 1"]],
   "correct": false,
   "comments": "The statement is a bit ambiguous, Lean infers 1 to have type Nat.",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : Monoid Î±], id 1 = 1",
    " âˆ€ {Î± : Type u} [inst : Group Î±], id (1 : Î±) = 1 ",
    " âˆ€ {Î± : Type u} [inst : MulOneClass Î±], 1 = id 1 "]},
  {"theorem": "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
     "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
     "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
     "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
     "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
     "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x",
     "âˆ€ {X : Type u} (x : X), Function.IsFixedPt id x",
     "âˆ€ {X : Type u} (x : X), Function.IsFixedPt id x",
     "âˆ€ {X : Type u} (x : X), Function.IsFixedPt id x"],
    ["âˆ€ {Î± : Type u}, Function.IsFixedPt id Î±"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ",
    " âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ",
    " âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ",
    " âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ",
    " âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ",
    " âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ",
    " âˆ€ {X : Type u} (x : X), Function.IsFixedPt id x ",
    " âˆ€ {X : Type u} (x : X), Function.IsFixedPt id x ",
    " âˆ€ {X : Type u} (x : X), Function.IsFixedPt id x ",
    " âˆ€ {Î± : Type u}, Function.IsFixedPt id Î± "]},
  {"theorem": "âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î±",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î±",
     "âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î±",
     "âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î±",
     "âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î±",
     "âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î±",
     "âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î±"],
    ["âˆ€ {Î± : Type u} [inst : Group Î±], Nonempty Î±",
     "âˆ€ {Î± : Type u} [inst : Group Î±], Nonempty Î±",
     "âˆ€ {Î± : Type u} [inst : Group Î±], Nonempty Î±",
     "âˆ€ {Î± : Type u} [inst : Group Î±], Nonempty Î±"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {Î± : Type u} [inst : Group Î±], Nonempty Î± ",
    " âˆ€ {Î± : Type u} [inst : Group Î±], Nonempty Î± ",
    " âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î± ",
    " âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î± ",
    " âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î± ",
    " âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î± ",
    " âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î± ",
    " âˆ€ {Î± : Type u} [inst : Group Î±], Nonempty Î±",
    " âˆ€ {Î± : Type u} [inst : Group Î±], Nonempty Î±",
    " âˆ€ {Î± : Type u_1} [inst : Group Î±], Nonempty Î±"]},
  {"theorem":
   "âˆ€ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)",
   "some-correct": false,
   "prompt": "All connected components of a topological space are connected.",
   "groups":
   [["âˆ€ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)",
     "âˆ€ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)"],
    ["âˆ€ (Î± : Type u) [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î±] (x : Î±),\n  IsConnected (connectedComponent x) âˆ§\n    âˆ€ (y : Î±),\n      âˆƒ z âˆˆ connectedComponent x,\n        z âˆˆ connectedComponent y âˆ§ y âˆˆ connectedComponent z âˆ§ x âˆˆ connectedComponent z âˆ§ y âˆˆ connectedComponent z"],
    ["âˆ€ {X : Type u_4} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)"],
    ["âˆ€ {X : Type u_3} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)"]],
   "correct": false,
   "comments": "The statement is not incorrect but it is not the correct interpretation.",
   "all-elabs":
   [" âˆ€ {X : Type u_4} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x) ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x) ",
    " âˆ€ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x) ",
    " âˆ€ {X : Type u_3} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x) ",
    " âˆ€ (Î± : Type u) [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î±],\n  (x : Î±) â†’ IsConnected (connectedComponent x) âˆ§ âˆ€ (y : Î±), âˆƒ (z : Î±), z âˆˆ connectedComponent x âˆ§ z âˆˆ connectedComponent y âˆ§ y âˆˆ connectedComponent z âˆ§ x âˆˆ connectedComponent z âˆ§ y âˆˆ connectedComponent z"]},
  {"theorem":
   "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥",
   "some-correct": false,
   "prompt": "The ring of integers has a maximal ideal.",
   "groups":
   [["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥"]],
   "correct": false,
   "comments": "Type of M is not specified for statements in all-elabs",
   "all-elabs":
   [" âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥ ",
    " âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], âˆƒ M, Ideal.IsMaximal M",
    " âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R],\n  âˆƒ M, Ideal.IsMaximal M âˆ§ M â‰  âŠ¥"]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "groups":
   [["PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5 ",
    " PythagoreanTriple 3 4 5 "]},
  {"theorem":
   "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : IsEmpty Î¹], Basis Î¹ K V â†’ Subsingleton V",
   "some-correct": null,
   "prompt": "A vector space with the empty set as basis is trivial.",
   "groups":
   [["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : IsEmpty Î¹], Basis Î¹ K V â†’ Subsingleton V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : IsEmpty Î¹], Basis Î¹ K V â†’ Subsingleton V "]}],
 "elaborated": 36}