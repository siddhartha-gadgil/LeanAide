/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real Topology Filter Set

variable {E F : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E] [CompleteSpace E]
variable [NormedAddCommGroup F] [NormedSpace ℝ F] [CompleteSpace F]

def newton_step (f : E → F) (T : F →L[ℝ] E) (x : E) : E :=
  x - T (f x)

def newton_sequence (f : E → F) (T : F →L[ℝ] E) (x₀ : E) : ℕ → E
  | 0 => x₀
  | n + 1 => newton_step f T (newton_sequence f T x₀ n)

theorem norm_sub_sub_deriv_le
  (f : E → F) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (x : E) (hx : x ∈ Metric.ball x₀ r) :
  ‖f x - f x₀ - fderiv ℝ f x₀ (x - x₀)‖ ≤ L / 2 * ‖x - x₀‖ ^ 2 :=
by
  -- Let $y(t) = f(x₀ + t(x - x₀))$ for $t \in [0, 1]$. Then $y(0) = f(x₀)$ and $y(1) = f(x)$.
  set y : ℝ → E := fun t => x₀ + t • (x - x₀);
  -- Then $y(0) = f(x₀)$ and $y(1) = f(x)$, and by the fundamental theorem of calculus, we have:
  have h_ftc : ∫ t in (0 : ℝ)..1, (fderiv ℝ f (y t) - fderiv ℝ f x₀) (x - x₀) = f x - f x₀ - (fderiv ℝ f x₀) (x - x₀) := by
    rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
    rotate_right;
    use fun t => f ( y t ) - f x₀ - ( fderiv ℝ f x₀ ) ( y t - x₀ );
    · aesop;
    · aesop;
      have h_deriv : HasDerivAt (fun t => f (x₀ + t • (x - x₀))) ((fderiv ℝ f (x₀ + x_1 • (x - x₀))) (x - x₀)) x_1 := by
        convert HasFDerivAt.hasDerivAt ( HasFDerivAt.comp x_1 ( h_diff ( x₀ + x_1 • ( x - x₀ ) ) ?_ |> DifferentiableAt.hasFDerivAt ) ( HasFDerivAt.add ( hasFDerivAt_const _ _ ) ( HasFDerivAt.smul ( hasFDerivAt_id x_1 ) ( hasFDerivAt_const _ _ ) ) ) ) using 1;
        · simp +decide [ fderiv_deriv ];
        · simp +decide [ norm_smul, left, right, hx ];
          exact lt_of_le_of_lt ( mul_le_of_le_one_left ( norm_nonneg _ ) ( abs_le.mpr ⟨ by linarith, by linarith ⟩ ) ) ( by simpa [ dist_eq_norm ] using hx );
      convert h_deriv.sub_const ( f x₀ ) |> HasDerivAt.sub <| HasDerivAt.smul ( hasDerivAt_id x_1 ) <| hasDerivAt_const _ _ using 1 ; aesop;
    · -- Since $f$ is differentiable on the ball, the derivative $fderiv ℝ f$ is continuous on the ball.
      have h_cont_diff : ContinuousOn (fun t => fderiv ℝ f (y t)) (Set.Icc 0 1) := by
        refine' ContinuousOn.comp ( show ContinuousOn ( fun x => fderiv ℝ f x ) ( Metric.ball x₀ r ) from _ ) ( show ContinuousOn y ( Set.Icc 0 1 ) from _ ) fun t ht => _;
        · rw [ Metric.continuousOn_iff ];
          intro x hx ε εpos;
          rcases exists_pos_mul_lt εpos L with ⟨ δ, δpos, hδ ⟩;
          exact ⟨ δ, δpos, fun y hy hyx => by rw [ dist_eq_norm ] at *; exact lt_of_le_of_lt ( h_lip _ hy _ hx ) ( by nlinarith [ norm_nonneg ( y - x ) ] ) ⟩;
        · fun_prop;
        · aesop;
          simpa [ norm_smul, abs_of_nonneg left ] using lt_of_le_of_lt ( mul_le_of_le_one_left ( norm_nonneg _ ) right ) ( by simpa [ dist_eq_norm ] using hx );
      apply_rules [ ContinuousOn.intervalIntegrable ];
      simpa only [ Set.uIcc_of_le zero_le_one ] using ContinuousOn.clm_apply ( h_cont_diff.sub continuousOn_const ) continuousOn_const;
  -- Applying the Lipschitz condition to the integrand, we get:
  have h_integrand_bound : ∀ t ∈ Set.Icc (0 : ℝ) 1, ‖(fderiv ℝ f (y t) - fderiv ℝ f x₀) (x - x₀)‖ ≤ L * t * ‖x - x₀‖ ^ 2 := by
    -- Applying the Lipschitz condition to the integrand, we get ‖fderiv ℝ f (y t) - fderiv ℝ f x₀‖ ≤ L * ‖y t - x₀‖.
    have h_integrand_bound : ∀ t ∈ Set.Icc (0 : ℝ) 1, ‖fderiv ℝ f (y t) - fderiv ℝ f x₀‖ ≤ L * t * ‖x - x₀‖ := by
      intros t ht; convert h_lip ( y t ) _ x₀ _ using 1 <;> aesop;
      · rw [ norm_smul, Real.norm_of_nonneg left, mul_assoc ];
      · rw [ norm_smul, Real.norm_of_nonneg left ];
        exact lt_of_le_of_lt ( mul_le_of_le_one_left ( norm_nonneg _ ) right ) ( by simpa [ dist_eq_norm ] using hx );
      · exact lt_of_le_of_lt ( dist_nonneg ) hx;
    exact fun t ht => le_trans ( ContinuousLinearMap.le_opNorm _ _ ) ( by simpa [ sq, mul_assoc ] using mul_le_mul_of_nonneg_right ( h_integrand_bound t ht ) ( norm_nonneg ( x - x₀ ) ) );
  rw [ ← h_ftc, intervalIntegral.integral_of_le zero_le_one ];
  refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
  refine' fun t => L * t * ‖x - x₀‖ ^ 2;
  · exact Filter.Eventually.of_forall fun t => norm_nonneg _;
  · exact Continuous.integrableOn_Ioc ( by continuity );
  · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using h_integrand_bound t <| Set.Ioc_subset_Icc_self ht;
  · rw [ ← intervalIntegral.integral_of_le zero_le_one ] ; norm_num [ mul_assoc ] ; ring ; norm_num


theorem newton_step_sub_newton_step_zero_le_on_subspace
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (x : E) (hx : x ∈ Metric.ball x₀ r)
  (h_subspace : ∃ u : F, x = x₀ + T u) :
  ‖newton_step f T x - newton_step f T x₀‖ ≤ M * (L / 2) * ‖x - x₀‖ ^ 2 :=
by
  -- Using the definition of the Newton step and the given conditions, we can express the difference as $-T(R(x))$.
  have h_diff_step : newton_step f T x - newton_step f T x₀ = -T (f x - f x₀ - fderiv ℝ f x₀ (x - x₀)) := by
    -- Using the fact that $T$ is a right inverse of the derivative at $x₀$, we can simplify the expression.
    have h_T_deriv : T (fderiv ℝ f x₀ (x - x₀)) = x - x₀ := by
      rcases h_subspace with ⟨ u, rfl ⟩ ; simp +decide [ ← ContinuousLinearMap.comp_apply, h_surj ] ;
    simp_all +decide [ sub_eq_iff_eq_add', newton_step ];
    abel1;
  rw [ h_diff_step, norm_neg ];
  refine' le_trans ( T.le_opNorm _ ) _;
  rw [ mul_assoc, hM ];
  exact mul_le_mul_of_nonneg_left ( norm_sub_sub_deriv_le f x₀ r L h_diff h_lip x hx ) ( hM ▸ norm_nonneg _ )


theorem newton_step_maps_subspace
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E)
  (x : E) (hx : ∃ u : F, x = x₀ + T u) :
  ∃ v : F, newton_step f T x = x₀ + T v :=
by
  aesop;
  use w - f ( x₀ + T w );
  unfold newton_step; simp +decide [ sub_eq_add_neg, add_assoc ] ;


theorem newton_step_maps_ball_into_ball
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (η : ℝ) (hη : ‖T (f x₀)‖ = η)
  (h : ℝ) (hh : h = M * L * η)
  (h_small : h ≤ 1 / 2)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_r : ρ ≤ r)
  (x : E) (hx : x ∈ Metric.ball x₀ ρ)
  (h_subspace : ∃ u : F, x = x₀ + T u) :
  newton_step f T x ∈ Metric.ball x₀ ρ :=
by
  -- Using the inequality from the provided solution, we have:
  have h_dist : ‖newton_step f T x - x₀‖ ≤ η + (M * L / 2) * ‖x - x₀‖ ^ 2 := by
    have h_dist : ‖newton_step f T x - x₀‖ ≤ ‖newton_step f T x - newton_step f T x₀‖ + ‖newton_step f T x₀ - x₀‖ := by
      simpa using norm_add_le ( newton_step f T x - newton_step f T x₀ ) ( newton_step f T x₀ - x₀ );
    have h_dist_sub : ‖newton_step f T x - newton_step f T x₀‖ ≤ M * (L / 2) * ‖x - x₀‖ ^ 2 := by
      apply newton_step_sub_newton_step_zero_le_on_subspace f T x₀ r L h_diff h_surj h_lip M hM x (Metric.ball_subset_ball h_r hx) h_subspace;
    convert h_dist.trans ( add_le_add h_dist_sub le_rfl ) using 1 ; norm_num [ newton_step ] ; ring;
    rw [ hη, add_comm ];
  -- Using the fact that η + (M * L / 2) * ρ^2 ≤ ρ, we can conclude that ‖newton_step f T x - x₀‖ ≤ ρ.
  have h_final : η + (M * L / 2) * ρ^2 ≤ ρ := by
    rw [ hρ, div_pow, mul_div ];
    -- Let's simplify the left-hand side by multiplying both sides by $2 * M * L$.
    have h_simplified : 2 * M * L * η + (1 - Real.sqrt (1 - 2 * h))^2 ≤ 2 * (1 - Real.sqrt (1 - 2 * h)) := by
      nlinarith [ Real.sqrt_nonneg ( 1 - 2 * h ), Real.mul_self_sqrt ( show 0 ≤ 1 - 2 * h by linarith ) ];
    rw [ add_div', div_le_div_iff₀ ] <;> nlinarith [ mul_pos h_ML_pos h_ML_pos ];
  -- Since $x \in \text{Metric.ball } x₀ \rho$, we have $\|x - x₀\| < \rho$. Therefore, $\|x - x₀\|^2 < \rho^2$.
  have h_x_sq : ‖x - x₀‖ ^ 2 < ρ ^ 2 := by
    exact pow_lt_pow_left₀ ( by simpa [ dist_eq_norm ] using hx ) ( norm_nonneg _ ) ( by norm_num );
  exact mem_ball_iff_norm.mpr ( lt_of_le_of_lt h_dist ( by nlinarith [ show 0 ≤ M * L by positivity ] ) )


theorem newton_step_fderiv
  (f : E → F) (T : F →L[ℝ] E) (x : E)
  (h_diff : DifferentiableAt ℝ f x) :
  fderiv ℝ (newton_step f T) x = ContinuousLinearMap.id ℝ E - T.comp (fderiv ℝ f x) :=
by
  -- The derivative of the Newton step function is the derivative of x minus the derivative of T(f(x)).
  have h_deriv : fderiv ℝ (fun x => x - T (f x)) x = fderiv ℝ (fun x => x) x - fderiv ℝ (fun x => T (f x)) x := by
    exact fderiv_sub ( differentiableAt_id ) ( T.differentiableAt.comp x h_diff );
  -- The derivative of the identity function is the identity map.
  have h_id : fderiv ℝ (fun x => x) x = ContinuousLinearMap.id ℝ E := by
    simp +zetaDelta at *;
  -- The derivative of $T(f(x))$ is $T \circ Df(x)$.
  have h_T_f : fderiv ℝ (fun x => T (f x)) x = T.comp (fderiv ℝ f x) := by
    exact HasFDerivAt.fderiv ( T.hasFDerivAt.comp x h_diff.hasFDerivAt );
  exact h_deriv.trans ( congr_arg₂ _ h_id h_T_f )


theorem newton_step_fderiv_apply_le_on_subspace
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (z : E) (hz : z ∈ Metric.ball x₀ r)
  (v : E) (hv : ∃ u : F, v = T u) :
  ‖fderiv ℝ (newton_step f T) z v‖ ≤ M * L * ‖z - x₀‖ * ‖v‖ :=
by
  -- Applying the derivative formula and the Lipschitz condition, we get:
  have h_deriv : ‖(fderiv ℝ (newton_step f T) z) v‖ = ‖T (fderiv ℝ f x₀ (T hv.choose)) - T (fderiv ℝ f z (T hv.choose))‖ := by
    -- By definition of $newton_step$, we have $newton_step f T z = z - T (f z)$.
    have h_newton_step : fderiv ℝ (newton_step f T) z = ContinuousLinearMap.id ℝ E - T.comp (fderiv ℝ f z) := by
      exact?;
    replace h_surj := congr_arg ( fun f => f ( hv.choose : F ) ) h_surj; simp_all +decide [ sub_eq_iff_eq_add' ] ;
    rw [ ← hv.choose_spec ];
  have h_deriv_bound : ‖T (fderiv ℝ f x₀ (T hv.choose)) - T (fderiv ℝ f z (T hv.choose))‖ ≤ ‖T‖ * ‖fderiv ℝ f x₀ - fderiv ℝ f z‖ * ‖T hv.choose‖ := by
    have h_deriv_bound : ‖T (fderiv ℝ f x₀ (T hv.choose)) - T (fderiv ℝ f z (T hv.choose))‖ ≤ ‖T‖ * ‖(fderiv ℝ f x₀ - fderiv ℝ f z) (T hv.choose)‖ := by
      simpa using T.le_opNorm ( ( fderiv ℝ f x₀ - fderiv ℝ f z ) ( T hv.choose ) );
    exact h_deriv_bound.trans ( by simpa only [ mul_assoc ] using mul_le_mul_of_nonneg_left ( ContinuousLinearMap.le_opNorm _ _ ) ( norm_nonneg _ ) );
  -- Substitute the bound from h_lip into h_deriv_bound.
  have h_subst : ‖T‖ * ‖fderiv ℝ f x₀ - fderiv ℝ f z‖ * ‖T hv.choose‖ ≤ ‖T‖ * (L * ‖z - x₀‖) * ‖T hv.choose‖ := by
    -- Apply the Lipschitz condition with $x = x₀$ and $y = z$.
    have h_lip_applied : ‖fderiv ℝ f x₀ - fderiv ℝ f z‖ ≤ L * ‖x₀ - z‖ := by
      exact h_lip x₀ ( Metric.mem_ball_self ( show 0 < r by exact lt_of_not_ge fun h => by { rw [ Metric.ball_eq_empty.mpr h ] at hz; simp_all +decide } ) ) z hz;
    simpa only [ norm_sub_rev ] using mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_left h_lip_applied ( norm_nonneg _ ) ) ( norm_nonneg _ );
  exact h_deriv.trans_le ( h_deriv_bound.trans ( h_subst.trans_eq ( by rw [ ← hv.choose_spec, hM ] ; ring ) ) )


theorem newton_step_contraction_on_subspace
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (η : ℝ) (hη : ‖T (f x₀)‖ = η)
  (h : ℝ) (hh : h = M * L * η)
  (h_small : h ≤ 1 / 2)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_r : ρ ≤ r)
  (x y : E) (hx : x ∈ Metric.ball x₀ ρ) (hy : y ∈ Metric.ball x₀ ρ)
  (hx_sub : ∃ u, x = x₀ + T u) (hy_sub : ∃ v, y = x₀ + T v) :
  ‖newton_step f T x - newton_step f T y‖ ≤ (M * L * ρ) * ‖x - y‖ :=
by
  -- Choose any $z$ on the segment connecting $x$ and $y$.
  have h_segment : ∀ z ∈ Metric.ball x₀ ρ, ∀ v : E, (∃ u : F, v = T u) → ‖(fderiv ℝ (newton_step f T) z) v‖ ≤ M * L * ρ * ‖v‖ := by
    aesop;
    refine' le_trans ( newton_step_fderiv_apply_le_on_subspace f T x₀ r L h_diff h_surj h_lip _ rfl z ( lt_of_lt_of_le a h_r ) _ ( by aesop ) ) _;
    exact mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_left ( le_trans ( le_of_eq ( by simp +decide [ dist_eq_norm ] ) ) a.le ) ( by positivity ) ) ( by positivity );
  -- By the fundamental theorem of calculus, the difference between the Newton steps can be expressed as the integral of the derivative of the Newton step along the segment from y to x.
  have h_ftc : newton_step f T x - newton_step f T y = ∫ t in (0 : ℝ)..1, (fderiv ℝ (newton_step f T) (y + t • (x - y))) (x - y) := by
    rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
    rotate_right;
    use fun t => newton_step f T ( y + t • ( x - y ) );
    · simp +decide;
    · -- Apply the chain rule to find the derivative.
      have h_chain : ∀ t ∈ Set.Icc (0 : ℝ) 1, HasDerivAt (fun t => newton_step f T (y + t • (x - y))) ((fderiv ℝ (newton_step f T) (y + t • (x - y))) (x - y)) t := by
        intro t ht
        have h_diff : DifferentiableAt ℝ (newton_step f T) (y + t • (x - y)) := by
          refine' DifferentiableAt.sub ( differentiableAt_id ) ( T.differentiableAt.comp _ ( h_diff _ _ ) );
          simp_all +decide [ dist_eq_norm ];
          refine' lt_of_le_of_lt _ ( lt_of_lt_of_le ( max_lt hy hx ) h_r );
          rw [ show y + t • ( x - y ) - x₀ = ( 1 - t ) • ( y - x₀ ) + t • ( x - x₀ ) by simp +decide [ sub_smul, smul_sub ] ; abel1 ];
          exact le_trans ( norm_add_le _ _ ) ( by rw [ norm_smul, norm_smul, Real.norm_of_nonneg ( by linarith : 0 ≤ 1 - t ), Real.norm_of_nonneg ( by linarith : 0 ≤ t ) ] ; nlinarith [ le_max_left ‖y - x₀‖ ‖x - x₀‖, le_max_right ‖y - x₀‖ ‖x - x₀‖ ] )
        convert HasFDerivAt.hasDerivAt ( h_diff.hasFDerivAt.comp t ( HasFDerivAt.add ( hasFDerivAt_const _ _ ) ( HasFDerivAt.smul ( hasFDerivAt_id t ) ( hasFDerivAt_const _ _ ) ) ) ) using 1 ; norm_num;
      simpa using h_chain;
    · apply_rules [ ContinuousOn.intervalIntegrable ];
      -- The derivative of the Newton step is continuous on the ball.
      have h_cont_deriv : ContinuousOn (fun z => fderiv ℝ (newton_step f T) z) (Metric.ball x₀ ρ) := by
        have h_cont_deriv : ContinuousOn (fun z => fderiv ℝ f z) (Metric.ball x₀ ρ) := by
          -- Since ρ ≤ r, the ball of radius ρ is contained within the ball of radius r. Therefore, the Lipschitz condition on the larger ball implies the same condition on the smaller ball.
          have h_lip_on_ball : ∀ x ∈ Metric.ball x₀ ρ, ∀ y ∈ Metric.ball x₀ ρ, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖ := by
            exact fun x hx y hy => h_lip x ( Metric.ball_subset_ball h_r hx ) y ( Metric.ball_subset_ball h_r hy );
          refine' Metric.continuousOn_iff.mpr _;
          intro x hx ε ε_pos;
          exact ⟨ ε / ( Max.max L 1 ), div_pos ε_pos ( by positivity ), fun y hy hyx => by rw [ dist_eq_norm ] at *; exact lt_of_le_of_lt ( h_lip_on_ball y hy x hx ) ( by rw [ lt_div_iff₀ ( by positivity ) ] at *; nlinarith [ norm_nonneg ( y - x ), le_max_left L 1, le_max_right L 1 ] ) ⟩;
        refine' ContinuousOn.congr _ fun z hz => _;
        use fun z => ContinuousLinearMap.id ℝ E - T.comp ( fderiv ℝ f z );
        · fun_prop (disch := solve_by_elim);
        · exact newton_step_fderiv f T z ( h_diff z ( Metric.ball_subset_ball h_r hz ) );
      refine' ContinuousOn.comp ( show ContinuousOn ( fun z => fderiv ℝ ( newton_step f T ) z ( x - y ) ) ( Metric.ball x₀ ρ ) from _ ) _ _;
      · exact?;
      · fun_prop;
      · intro t ht;
        simp +zetaDelta at *;
        rw [ dist_eq_norm ] at *;
        rw [ show y + t • ( x - y ) - x₀ = ( 1 - t ) • ( y - x₀ ) + t • ( x - x₀ ) by simp +decide [ sub_smul, smul_sub ] ; abel1 ];
        refine' lt_of_le_of_lt ( norm_add_le _ _ ) _;
        rw [ norm_smul, norm_smul, Real.norm_of_nonneg, Real.norm_of_nonneg ] <;> try linarith;
        cases lt_or_ge t ( 1 / 2 ) <;> nlinarith;
  -- Apply the bound from h_segment to each term in the integral.
  have h_integral_bound : ∀ t ∈ Set.Icc (0 : ℝ) 1, ‖(fderiv ℝ (newton_step f T) (y + t • (x - y))) (x - y)‖ ≤ M * L * ρ * ‖x - y‖ := by
    intro t ht
    have hz : y + t • (x - y) ∈ Metric.ball x₀ ρ := by
      rw [ Metric.mem_ball, dist_eq_norm ] at *;
      rw [ show y + t • ( x - y ) - x₀ = ( 1 - t ) • ( y - x₀ ) + t • ( x - x₀ ) by simpa only [ smul_sub, sub_smul, one_smul ] using by abel1 ];
      refine' lt_of_le_of_lt ( norm_add_le _ _ ) _;
      rw [ norm_smul, norm_smul, Real.norm_of_nonneg ( sub_nonneg.2 ht.2 ), Real.norm_of_nonneg ht.1 ];
      cases lt_or_ge t ( 1 / 2 ) <;> nlinarith [ ht.1, ht.2 ]
    have hv : ∃ u : F, x - y = T u := by
      rcases hx_sub with ⟨ u, rfl ⟩ ; rcases hy_sub with ⟨ v, rfl ⟩ ; exact ⟨ u - v, by simp +decide ⟩ ;
    exact h_segment (y + t • (x - y)) hz (x - y) hv;
  rw [ h_ftc, intervalIntegral.integral_of_le zero_le_one ];
  refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
  refine' fun t => M * L * ρ * ‖x - y‖;
  · exact Filter.Eventually.of_forall fun t => norm_nonneg _;
  · -- The constant function $M * L * ρ * ‖x - y‖$ is integrable over the interval $[0, 1]$.
    simp [MeasureTheory.integrable_const];
  · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using h_integral_bound t <| Set.Ioc_subset_Icc_self ht;
  · norm_num


theorem newton_sequence_in_ball_and_subspace_of_rho_pos
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (η : ℝ) (hη : ‖T (f x₀)‖ = η)
  (h : ℝ) (hh : h = M * L * η)
  (h_small : h ≤ 1 / 2)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_r : ρ ≤ r)
  (h_rho_pos : 0 < ρ)
  (n : ℕ) :
  newton_sequence f T x₀ n ∈ Metric.ball x₀ ρ ∧ ∃ u : F, newton_sequence f T x₀ n = x₀ + T u :=
by
  induction n;
  · -- The initial term of the Newton sequence is x₀, which is clearly in the ball of radius ρ around x₀ since ρ > 0.
    simp [newton_sequence];
    exact ⟨ h_rho_pos, 0, map_zero T ⟩;
  · -- Apply the newton_step_maps_ball_into_ball theorem to show that newton_step f T (newton_sequence f T x₀ n) is in the ball.
    have h_ball : newton_step f T (newton_sequence f T x₀ ‹_›) ∈ Metric.ball x₀ ρ := by
      apply_rules [ newton_step_maps_ball_into_ball ];
      · exact ‹newton_sequence f T x₀ _ ∈ Metric.ball x₀ ρ ∧ ∃ u : F, newton_sequence f T x₀ _ = x₀ + T u›.1;
      · -- By the induction hypothesis, we know that newton_sequence f T x₀ n is in the ball and there exists some u such that newton_sequence f T x₀ n equals x₀ plus T u.
        aesop;
    exact ⟨ h_ball, by rename_i n hn; exact newton_step_maps_subspace f T x₀ _ ⟨ _, hn.2.choose_spec ⟩ ⟩


theorem ML_rho_lt_one
  (M L η h : ℝ)
  (hh : h = M * L * η)
  (h_small : h < 1 / 2)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L)) :
  M * L * ρ < 1 :=
by
  bound;
  rw [ mul_div_cancel₀ _ h_ML_pos.ne' ] ; nlinarith [ Real.sqrt_nonneg ( 1 - 2 * ( M * L * η ) ), Real.mul_self_sqrt ( show 0 ≤ 1 - 2 * ( M * L * η ) by linarith ) ] ;


theorem rho_quadratic_eq
  (M L η h : ℝ)
  (hh : h = M * L * η)
  (h_small : h ≤ 1 / 2)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L)) :
  (M * L / 2) * ρ ^ 2 - ρ + η = 0 :=
by
  norm_num [ hρ ];
  -- Substitute h = M * L * η into the expression.
  rw [hh]
  field_simp
  ring;
  -- Substitute the simplified square root term back into the expression.
  have h_sqrt : Real.sqrt (1 - M * L * η * 2) ^ 2 = 1 - M * L * η * 2 := by
    exact Real.sq_sqrt <| by nlinarith;
  field_simp;
  rw [ add_div', div_eq_iff ] <;> ring_nf at * <;> nlinarith


def majorizing_seq (M L η : ℝ) : ℕ → ℝ
  | 0 => 0
  | n + 1 => η + (M * L / 2) * (majorizing_seq M L η n)^2

theorem majorizing_seq_nonneg
  (M L η : ℝ)
  (h_ML_pos : 0 < M * L)
  (h_eta_nonneg : 0 ≤ η)
  (n : ℕ) :
  0 ≤ majorizing_seq M L η n :=
by
  -- We proceed by induction on $n$.
  induction' n with n ih;
  · exact le_rfl;
  · exact add_nonneg h_eta_nonneg ( mul_nonneg ( by positivity ) ( sq_nonneg _ ) )


theorem rho_nonneg
  (M L h : ℝ)
  (h_small : h ≤ 1 / 2)
  (h_nonneg : 0 ≤ h)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L)) :
  0 ≤ ρ :=
by
  rw [hρ, div_nonneg_iff]
  left
  constructor
  · rw [sub_nonneg]
    apply Real.sqrt_le_one.mpr
    linarith
  · exact le_of_lt h_ML_pos

theorem majorizing_seq_le_rho
  (M L η h : ℝ)
  (hh : h = M * L * η)
  (h_small : h ≤ 1 / 2)
  (h_ML_pos : 0 < M * L)
  (h_eta_nonneg : 0 ≤ η)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (n : ℕ) :
  majorizing_seq M L η n ≤ ρ :=
by
  induction' n with n ih;
  · simp [majorizing_seq];
    have h_nonneg : 0 ≤ h := by nlinarith
    rw [hρ, div_nonneg_iff]
    left
    constructor
    · rw [sub_nonneg]
      apply Real.sqrt_le_one.mpr
      linarith
    · exact le_of_lt h_ML_pos
  · rw [ majorizing_seq ];
    have h_quad : (M * L / 2) * ρ ^ 2 - ρ + η = 0 := by
      exact rho_quadratic_eq M L η h hh h_small h_ML_pos ρ hρ;
    have h_le : η + (M * L / 2) * ρ ^ 2 ≤ ρ := by
      linarith [ h_quad ];
    refine' le_trans ( add_le_add_left ( mul_le_mul_of_nonneg_left _ ( by nlinarith ) ) η ) h_le;
    have h_nonneg_seq : 0 ≤ majorizing_seq M L η n := majorizing_seq_nonneg M L η h_ML_pos h_eta_nonneg n
    gcongr

theorem newton_sequence_cauchy
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (η : ℝ) (hη : ‖T (f x₀)‖ = η)
  (h : ℝ) (hh : h = M * L * η)
  (h_small : h ≤ 1 / 2)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_r : ρ ≤ r)
  (h_rho_pos : 0 < ρ)
  (h_contraction : M * L * ρ < 1) :
  CauchySeq (newton_sequence f T x₀) :=
by
  -- By induction, we can show that ‖x_{n+1} - x_n‖ ≤ k^n * η for some k < 1.
  have h_induction : ∀ n, ‖newton_sequence f T x₀ (n + 1) - newton_sequence f T x₀ n‖ ≤ (M * L * ρ)^n * η := by
    -- We proceed by induction on $n$.
    intro n
    induction' n with n ih;
    · -- The base case is when $n = 0$. We have $newton_sequence f T x₀ 1 = x₀ - T(f(x₀))$ and $newton_sequence f T x₀ 0 = x₀$, so their difference is $-T(f(x₀))$.
      have h_base : ‖newton_sequence f T x₀ 1 - newton_sequence f T x₀ 0‖ = ‖T (f x₀)‖ := by
        -- The difference between the first term of the Newton sequence and the initial term is -T(f(x₀)).
        have h_diff : newton_sequence f T x₀ 1 - newton_sequence f T x₀ 0 = -T (f x₀) := by
          exact sub_eq_iff_eq_add'.mpr ( by rw [ show newton_sequence f T x₀ 1 = x₀ - T ( f x₀ ) by rfl, show newton_sequence f T x₀ 0 = x₀ by rfl ] ; abel1 );
        rw [ h_diff, norm_neg ];
      aesop;
    · -- By the contraction condition, we have ‖newton_sequence f T x₀ (n + 2) - newton_sequence f T x₀ (n + 1)‖ ≤ M * L * ρ * ‖newton_sequence f T x₀ (n + 1) - newton_sequence f T x₀ n‖.
      have h_contraction_step : ‖newton_sequence f T x₀ (n + 2) - newton_sequence f T x₀ (n + 1)‖ ≤ M * L * ρ * ‖newton_sequence f T x₀ (n + 1) - newton_sequence f T x₀ n‖ := by
        convert newton_step_contraction_on_subspace f T x₀ r L h_diff h_surj h_lip M hM η hη h hh ( by linarith ) h_ML_pos ρ hρ h_r ( newton_sequence f T x₀ ( n + 1 ) ) ( newton_sequence f T x₀ n ) _ _ _ _ using 1;
        · exact ( newton_sequence_in_ball_and_subspace_of_rho_pos f T x₀ r L h_diff h_surj h_lip M hM η hη h hh ( by linarith ) h_ML_pos ρ hρ h_r h_rho_pos ) ( n + 1 ) |>.1;
        · exact newton_sequence_in_ball_and_subspace_of_rho_pos f T x₀ r L h_diff h_surj h_lip M hM η hη h hh ( by linarith ) h_ML_pos ρ hρ h_r h_rho_pos n |>.1;
        · have := newton_sequence_in_ball_and_subspace_of_rho_pos f T x₀ r L h_diff h_surj h_lip M hM η hη h hh ( by linarith ) h_ML_pos ρ hρ h_r h_rho_pos ( n + 1 );
          exact this.2;
        · induction' n with n ih;
          · exact ⟨ 0, by simp +decide [ newton_sequence ] ⟩;
          · induction' n + 1 with n ih <;> simp_all +decide [ pow_succ', mul_assoc ];
            · exact ⟨ 0, by simp +decide [ newton_sequence ] ⟩;
            · exact?;
      exact h_contraction_step.trans ( by convert mul_le_mul_of_nonneg_left ih ( show 0 ≤ M * L * ρ by positivity ) using 1 ; ring );
  -- Since the series of distances is summable, the sequence is Cauchy.
  have h_summable : Summable (fun n => ‖newton_sequence f T x₀ (n + 1) - newton_sequence f T x₀ n‖) := by
    exact Summable.of_nonneg_of_le ( fun n => norm_nonneg _ ) h_induction ( Summable.mul_right _ ( summable_geometric_of_lt_one ( by positivity ) h_contraction ) );
  exact Filter.Tendsto.cauchySeq ( by rw [ show newton_sequence f T x₀ = fun n => newton_sequence f T x₀ 0 + ∑ i ∈ Finset.range n, ( newton_sequence f T x₀ ( i + 1 ) - newton_sequence f T x₀ i ) by ext n; induction' n with n ih <;> simp +decide [ Finset.sum_range_succ, * ] ; abel1 ] ; exact tendsto_const_nhds.add ( h_summable.of_norm.hasSum.tendsto_sum_nat ) )


theorem majorizing_seq_increasing
  (M L η : ℝ)
  (h_ML_pos : 0 < M * L)
  (h_eta_nonneg : 0 ≤ η)
  (n : ℕ) :
  majorizing_seq M L η n ≤ majorizing_seq M L η (n + 1) :=
by
  induction' n with n ih;
  · simp [majorizing_seq];
    exact h_eta_nonneg;
  · simp [majorizing_seq];
    gcongr;
    exact majorizing_seq_nonneg M L η h_ML_pos h_eta_nonneg n;
    exact ih

theorem norm_newton_sequence_le_majorizing_seq
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (η : ℝ) (hη : ‖T (f x₀)‖ = η)
  (h : ℝ) (hh : h = M * L * η)
  (h_small : h < 1 / 2)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_r : ρ ≤ r)
  (n : ℕ) :
  ‖newton_sequence f T x₀ n - x₀‖ ≤ majorizing_seq M L η n :=
by
  -- By definition of newton_sequence, we have newton_sequence f T x₀ (n + 1) = newton_step f T (newton_sequence f T x₀ n).
  have h_newton_step : newton_sequence f T x₀ (n + 1) = newton_sequence f T x₀ n - T (f (newton_sequence f T x₀ n)) := by
    -- By definition of newton_sequence, we have newton_sequence f T x₀ (n + 1) = newton_step f T (newton_sequence f T x₀ n).
    -- And by definition of newton_step, we have newton_step f T x = x - T (f x).
    simp [newton_sequence, newton_step];
  -- By Lemma~\ref{lem:newton_step_maps_ball_into_ball} and induction hypothesis, we have:
  have h_induction_step : ∀ n, ‖newton_sequence f T x₀ n - x₀‖ ≤ majorizing_seq M L η n → ‖newton_sequence f T x₀ (n + 1) - x₀‖ ≤ η + (M * L / 2) * ‖newton_sequence f T x₀ n - x₀‖^2 := by
    intro n hn;
    by_cases h_case : ‖newton_sequence f T x₀ n - x₀‖ < ρ;
    · have h_induction_step : ∀ x ∈ Metric.ball x₀ ρ, ∀ u : F, x = x₀ + T u → ‖newton_step f T x - x₀‖ ≤ η + (M * L / 2) * ‖x - x₀‖^2 := by
        intro x hx u hu
        have h_induction_step : ‖newton_step f T x - newton_step f T x₀‖ ≤ M * (L / 2) * ‖x - x₀‖^2 := by
          convert newton_step_sub_newton_step_zero_le_on_subspace f T x₀ r L h_diff h_surj h_lip M hM x ( Metric.ball_subset_ball h_r hx ) ⟨ u, hu ⟩ using 1;
        have h_induction_step : ‖newton_step f T x - x₀‖ ≤ ‖newton_step f T x - newton_step f T x₀‖ + ‖newton_step f T x₀ - x₀‖ := by
          simpa using norm_add_le ( newton_step f T x - newton_step f T x₀ ) ( newton_step f T x₀ - x₀ );
        simp_all +decide [ newton_step ];
        linarith;
      -- By definition of newton_sequence, we have newton_sequence f T x₀ n = x₀ + T u for some u.
      obtain ⟨u, hu⟩ : ∃ u : F, newton_sequence f T x₀ n = x₀ + T u := by
        have h_induction_step : ∀ n, ∃ u : F, newton_sequence f T x₀ n = x₀ + T u := by
          intro n
          induction' n with n ih;
          · exact ⟨ 0, by simp +decide [ show newton_sequence f T x₀ 0 = x₀ from rfl ] ⟩;
          · exact?;
        exact h_induction_step n;
      convert h_induction_step ( newton_sequence f T x₀ n ) ( by simpa [ hu ] using h_case ) u hu using 1;
    · contrapose! h_case;
      refine' lt_of_le_of_lt hn _;
      refine' Nat.recOn n _ _ <;> aesop;
      · rw [ lt_div_iff₀ ];
        · norm_num [ show majorizing_seq ‖T‖ L ‖T ( f x₀ )‖ 0 = 0 by rfl ];
          -- Since $‖T‖ * L * ‖T (f x₀)‖$ is positive, we have $1 - 2 * (‖T‖ * L * ‖T (f x₀)‖) < 1$.
          have h_pos : 0 < ‖T‖ * L * ‖T (f x₀)‖ := by
            refine' mul_pos h_ML_pos ( norm_pos_iff.mpr _ );
            intro h; simp_all +decide [ ContinuousLinearMap.ext_iff ] ;
            -- Since $f x₀ = 0$, we have $newton_sequence f T x₀ n = x₀$ for all $n$.
            have h_newton_seq_zero : ∀ n, newton_sequence f T x₀ n = x₀ := by
              bound;
              induction' n_2 with n ih <;> simp_all +decide [ newton_sequence ];
              unfold newton_step; aesop;
            aesop;
          rw [ Real.sqrt_lt' ] <;> linarith;
        · positivity;
      · rw [ show majorizing_seq ‖T‖ L ‖T ( f x₀ )‖ ( n_2 + 1 ) = ‖T ( f x₀ )‖ + ( ‖T‖ * L / 2 ) * ( majorizing_seq ‖T‖ L ‖T ( f x₀ )‖ n_2 ) ^ 2 by rfl ];
        rw [ lt_div_iff₀ ( by positivity ) ] at *;
        nlinarith [ majorizing_seq_nonneg ‖T‖ L ‖(T : F → E) (f x₀)‖ h_ML_pos (norm_nonneg (T (f x₀))) n_2, mul_le_mul_of_nonneg_left ( majorizing_seq_nonneg ‖T‖ L ‖(T : F → E) (f x₀)‖ h_ML_pos (norm_nonneg (T (f x₀))) n_2 ) h_ML_pos.le, Real.sqrt_nonneg ( 1 - 2 * ( ‖T‖ * L * ‖(T : F → E) (f x₀)‖ ) ), Real.mul_self_sqrt ( show 0 ≤ 1 - 2 * ( ‖T‖ * L * ‖(T : F → E) (f x₀)‖ ) by norm_num at *; nlinarith ) ];
  induction' n with n ih;
  · exact show ‖x₀ - x₀‖ ≤ 0 from by simp +decide;
  · refine' le_trans ( h_induction_step n ( ih _ ) ) _;
    · exact?;
    · rw [ show majorizing_seq M L η ( n + 1 ) = η + ( M * L / 2 ) * ( majorizing_seq M L η n ) ^ 2 by rfl ];
      bound


theorem norm_newton_step_diff_le
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (x y : E) (hx : x ∈ Metric.ball x₀ r) (hy : y ∈ Metric.ball x₀ r)
  (h_subspace : ∃ u : F, x - y = T u) :
  ‖newton_step f T x - newton_step f T y‖ ≤ (M * L / 2) * (‖x - x₀‖ + ‖y - x₀‖) * ‖x - y‖ :=
by
  -- By definition of newton_step, we have:
  have h_newton_step_diff : newton_step f T x - newton_step f T y = T (fderiv ℝ f x₀ (x - y) - ∫ t in (0 : ℝ)..1, fderiv ℝ f (y + t • (x - y)) (x - y)) := by
    -- By the fundamental theorem of calculus for line integrals, we have $f(x) - f(y) = \int_0^1 f'(y + t(x - y)) (x - y) dt$.
    have h_ftc : f x - f y = ∫ t in (0 : ℝ)..1, fderiv ℝ f (y + t • (x - y)) (x - y) := by
      have h_ftc : ∀ a b : ℝ, 0 ≤ a → a ≤ b → b ≤ 1 → ∫ t in a..b, (fderiv ℝ f (y + t • (x - y))) (x - y) = f (y + b • (x - y)) - f (y + a • (x - y)) := by
        intros a b _ _ _; rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ] ; aesop;
        · have h_diff : DifferentiableAt ℝ f (y + x_1 • (T w)) := by
            refine' h_diff _ _;
            rw [ dist_eq_norm ] at *;
            rw [ show y + x_1 • ( T w ) - x₀ = ( 1 - x_1 ) • ( y - x₀ ) + x_1 • ( x - x₀ ) by rw [ show x - x₀ = ( T w ) + ( y - x₀ ) by rw [ ← h ] ; abel1 ] ; simp +decide [ add_smul, sub_smul ] ; abel1 ];
            refine' lt_of_le_of_lt ( norm_add_le _ _ ) _;
            rw [ norm_smul, norm_smul, Real.norm_of_nonneg ( by linarith : 0 ≤ 1 - x_1 ), Real.norm_of_nonneg ( by linarith : 0 ≤ x_1 ) ];
            cases lt_or_ge x_1 1 <;> nlinarith [ norm_nonneg ( y - x₀ ), norm_nonneg ( x - x₀ ) ];
          convert HasFDerivAt.hasDerivAt ( HasFDerivAt.comp x_1 ( h_diff.hasFDerivAt ) ( HasFDerivAt.add ( hasFDerivAt_const _ _ ) ( HasFDerivAt.smul ( hasFDerivAt_id x_1 ) ( hasFDerivAt_const _ _ ) ) ) ) using 1 ; aesop;
          rw [ ← map_sub ] ; aesop;
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          refine' ContinuousOn.clm_apply _ continuousOn_const;
          refine' ContinuousOn.comp ( show ContinuousOn ( fun z => fderiv ℝ f z ) ( Metric.ball x₀ r ) from _ ) _ _;
          · rw [ Metric.continuousOn_iff ] ; aesop;
            use ε / ( Max.max L 1 ) ; aesop;
            rw [ dist_eq_norm ] at *;
            exact lt_of_le_of_lt ( h_lip _ ( by simpa [ dist_eq_norm ] using a_7 ) _ ( by simpa [ dist_eq_norm ] using a_4 ) ) ( by rw [ lt_div_iff₀ ( by positivity ) ] at *; nlinarith [ norm_nonneg ( a_6 - b_1 ), le_max_left L 1, le_max_right L 1 ] );
          · fun_prop;
          · intro t ht; aesop;
            rw [ dist_eq_norm ] at *;
            rw [ ← h ];
            rw [ show y + t • ( x - y ) - x₀ = ( 1 - t ) • ( y - x₀ ) + t • ( x - x₀ ) by simpa only [ smul_sub, sub_smul, one_smul ] using by abel1 ];
            refine' lt_of_le_of_lt ( norm_add_le _ _ ) _;
            rw [ norm_smul, norm_smul, Real.norm_of_nonneg ( by linarith : 0 ≤ 1 - t ), Real.norm_of_nonneg ( by linarith : 0 ≤ t ) ];
            cases lt_or_ge t ( 1 / 2 ) <;> nlinarith [ norm_nonneg ( y - x₀ ), norm_nonneg ( x - x₀ ) ];
      rw [ h_ftc 0 1 ] <;> norm_num;
    simp +decide [ ← h_ftc, newton_step ];
    simp +decide [ ← h_ftc, ← map_sub ];
    rw [ show ( fderiv ℝ f x₀ ) ( x - y ) = ( fderiv ℝ f x₀ ) ( T ( h_subspace.choose ) ) by rw [ ← h_subspace.choose_spec ] ] ; simp +decide [ ← mul_assoc, ← ContinuousLinearMap.comp_apply, h_surj ];
    rw [ ← h_subspace.choose_spec ] ; abel1;
  -- Applying the Lipschitz condition to the integral, we get:
  have h_integral_bound : ‖∫ t in (0 : ℝ)..1, (fderiv ℝ f x₀ - fderiv ℝ f (y + t • (x - y))) (x - y)‖ ≤ L * ‖x - y‖ * ∫ t in (0 : ℝ)..1, (1 - t) * ‖y - x₀‖ + t * ‖x - x₀‖ := by
    -- Applying the Lipschitz condition to the integral, we get the bound.
    have h_integral_bound : ∀ t ∈ Set.Icc (0 : ℝ) 1, ‖(fderiv ℝ f x₀ - fderiv ℝ f (y + t • (x - y))) (x - y)‖ ≤ L * ‖x - y‖ * ((1 - t) * ‖y - x₀‖ + t * ‖x - x₀‖) := by
      intro t ht
      have h_integral_bound : ‖(fderiv ℝ f x₀ - fderiv ℝ f (y + t • (x - y))) (x - y)‖ ≤ L * ‖x₀ - (y + t • (x - y))‖ * ‖x - y‖ := by
        have h_integral_bound : ‖(fderiv ℝ f x₀ - fderiv ℝ f (y + t • (x - y)))‖ ≤ L * ‖x₀ - (y + t • (x - y))‖ := by
          apply h_lip;
          · exact Metric.mem_ball_self ( show 0 < r by linarith [ norm_nonneg ( x - x₀ ), norm_nonneg ( y - x₀ ), mem_ball_iff_norm.mp hx, mem_ball_iff_norm.mp hy ] );
          · simp_all +decide [ dist_eq_norm ];
            -- Apply the triangle inequality to the expression $y + t • (x - y) - x₀$.
            have h_triangle : ‖y + t • (x - y) - x₀‖ ≤ (1 - t) * ‖y - x₀‖ + t * ‖x - x₀‖ := by
              convert norm_add_le ( ( 1 - t ) • ( y - x₀ ) ) ( t • ( x - x₀ ) ) using 1;
              · exact congr_arg Norm.norm ( by simp +decide [ sub_smul, smul_sub ] ; abel1 );
              · rw [ norm_smul, norm_smul, Real.norm_of_nonneg ( by linarith ), Real.norm_of_nonneg ( by linarith ) ];
            cases lt_or_ge t ( 1 / 2 ) <;> nlinarith;
        exact le_trans ( ContinuousLinearMap.le_opNorm _ _ ) ( mul_le_mul_of_nonneg_right h_integral_bound ( norm_nonneg _ ) );
      -- Applying the triangle inequality to the expression inside the norm.
      have h_triangle : ‖x₀ - (y + t • (x - y))‖ ≤ (1 - t) * ‖y - x₀‖ + t * ‖x - x₀‖ := by
        convert norm_add_le ( ( 1 - t ) • ( y - x₀ ) ) ( t • ( x - x₀ ) ) using 1 ; ring;
        · rw [ ← norm_neg ] ; congr ; simp +decide [ sub_smul, smul_sub ] ; abel_nf;
        · rw [ norm_smul, norm_smul, Real.norm_of_nonneg ( sub_nonneg.2 ht.2 ), Real.norm_of_nonneg ht.1 ];
      refine' le_trans h_integral_bound _;
      rw [ mul_right_comm ];
      gcongr;
      exact le_trans ( norm_nonneg _ ) ( h_lip x hx y hy );
    rw [ intervalIntegral.integral_of_le zero_le_one, intervalIntegral.integral_of_le zero_le_one ];
    rw [ ← MeasureTheory.integral_const_mul ];
    refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
    · exact Filter.Eventually.of_forall fun t => norm_nonneg _;
    · exact Continuous.integrableOn_Ioc ( by continuity );
    · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using h_integral_bound t <| Set.Ioc_subset_Icc_self ht;
  -- Compute the integral $\int_0^1 (1 - t) \|y - x₀\| + t \|x - x₀\| \, dt$.
  have h_integral_computed : ∫ t in (0 : ℝ)..1, (1 - t) * ‖y - x₀‖ + t * ‖x - x₀‖ = (1 / 2) * ‖y - x₀‖ + (1 / 2) * ‖x - x₀‖ := by
    norm_num [ sub_mul ] ; ring;
  simp_all +decide [ sub_eq_iff_eq_add ];
  convert le_trans ( ContinuousLinearMap.le_opNorm T _ ) ( mul_le_mul_of_nonneg_left h_integral_bound ( norm_nonneg T ) ) using 1 ; ring_nf at * ; aesop;
  · rw [ intervalIntegral.integral_sub ] <;> norm_num;
    apply_rules [ ContinuousOn.intervalIntegrable ];
    refine' ContinuousOn.comp ( show ContinuousOn ( fun x => ( fderiv ℝ f x ) ( T w ) ) ( Metric.ball x₀ r ) from _ ) _ _;
    · refine' ContinuousOn.clm_apply _ _;
      · refine' Metric.continuousOn_iff.mpr _;
        intro x hx ε εpos;
        exact ⟨ ε / ( Max.max L 1 ), div_pos εpos ( by positivity ), fun y hy hyx => by rw [ dist_eq_norm ] at *; exact lt_of_le_of_lt ( h_lip y hy x hx ) ( by rw [ lt_div_iff₀ ( by positivity ) ] at *; nlinarith [ norm_nonneg ( y - x ), le_max_left L 1, le_max_right L 1 ] ) ⟩;
      · fun_prop;
    · fun_prop (disch := norm_num);
    · intro t ht; aesop;
      rw [ dist_eq_norm ] at *;
      rw [ show y + t • ( T w ) - x₀ = ( 1 - t ) • ( y - x₀ ) + t • ( T w + y - x₀ ) by simpa only [ smul_add, smul_sub, sub_smul, one_smul ] using by abel1 ];
      refine' lt_of_le_of_lt ( norm_add_le _ _ ) _;
      rw [ norm_smul, norm_smul, Real.norm_of_nonneg ( by linarith ), Real.norm_of_nonneg ( by linarith ) ];
      cases lt_or_ge t ( 1 / 2 ) <;> nlinarith [ norm_nonneg ( y - x₀ ), norm_nonneg ( T w + y - x₀ ) ];
  · rw [ hM ] ; ring


theorem norm_newton_step_sub_x0_le
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (η : ℝ) (hη : ‖T (f x₀)‖ = η)
  (x : E) (hx : x ∈ Metric.ball x₀ r)
  (h_subspace : ∃ u : F, x = x₀ + T u) :
  ‖newton_step f T x - x₀‖ ≤ η + (M * L / 2) * ‖x - x₀‖ ^ 2 :=
by
  -- By the triangle inequality, we have:
  have h_triangle : ‖newton_step f T x - x₀‖ ≤ ‖(newton_step f T x) - (newton_step f T x₀)‖ + ‖(newton_step f T x₀) - x₀‖ := by
    simpa using norm_add_le ( newton_step f T x - newton_step f T x₀ ) ( newton_step f T x₀ - x₀ );
  -- By the properties of the Newton step, we have:
  have h_newton_step : ‖(newton_step f T x) - (newton_step f T x₀)‖ ≤ (M * L / 2) * ‖x - x₀‖^2 := by
    convert newton_step_sub_newton_step_zero_le_on_subspace f T x₀ r L h_diff h_surj h_lip M hM x hx h_subspace using 1;
    ring;
  -- By the properties of the Newton step, we have that $‖(newton_step f T x₀) - x₀‖ = ‖T (f x₀)‖$.
  have h_newton_step_x₀ : ‖(newton_step f T x₀) - x₀‖ = ‖T (f x₀)‖ := by
    -- By definition of newton_step, we have newton_step f T x₀ = x₀ - T (f x₀).
    have h_newton_step_x₀_def : newton_step f T x₀ = x₀ - T (f x₀) := by
      rfl;
    simp [h_newton_step_x₀_def];
  linarith


theorem dist_newton_sequence_le_majorizing_diff
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (η : ℝ) (hη : ‖T (f x₀)‖ = η)
  (h : ℝ) (hh : h = M * L * η)
  (h_small : h < 1 / 2)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_r : ρ ≤ r)
  (n : ℕ) :
  ‖newton_sequence f T x₀ (n + 1) - newton_sequence f T x₀ n‖ ≤ majorizing_seq M L η (n + 1) - majorizing_seq M L η n :=
by
  -- We proceed by induction on $n$.
  induction' n with n ih;
  · -- For the base case $n = 0$, we have:
    -- $\|x_1 - x_0\| = \|- T f(x_0)\| = \eta$.
    -- $t_1 - t_0 = (\eta + 0) - 0 = \eta$.
    -- So $\|x_1 - x_0\| \le t_1 - t_0$.
    simp [newton_sequence, majorizing_seq];
    -- The first Newton step is $x₀ - T(f(x₀))$, so the difference is $-T(f(x₀))$. The norm of that is just the norm of $T(f(x₀))$, which is $\eta$ by definition.
    simp [newton_step, hη];
  · by_cases hρ_pos : 0 < ρ;
    · have h_in_ball : ∀ n, newton_sequence f T x₀ n ∈ Metric.ball x₀ ρ ∧ ∃ u : F, newton_sequence f T x₀ n = x₀ + T u := by
        intro n
        apply newton_sequence_in_ball_and_subspace_of_rho_pos f T x₀ r L h_diff h_surj h_lip M hM η hη h hh (by linarith) h_ML_pos ρ hρ h_r hρ_pos n;
      have h_diff_le : ‖newton_step f T (newton_sequence f T x₀ (n + 1)) - newton_step f T (newton_sequence f T x₀ n)‖ ≤ (M * L / 2) * (‖newton_sequence f T x₀ (n + 1) - x₀‖ + ‖newton_sequence f T x₀ n - x₀‖) * ‖newton_sequence f T x₀ (n + 1) - newton_sequence f T x₀ n‖ := by
        apply norm_newton_step_diff_le;
        exact fun x hx => h_diff x ( lt_of_lt_of_le hx h_r );
        any_goals tauto;
        · exact fun x hx y hy => h_lip x ( lt_of_lt_of_le hx h_r ) y ( lt_of_lt_of_le hy h_r );
        · exact h_in_ball _ |>.1;
        · exact h_in_ball n |>.1;
        · obtain ⟨ u, hu ⟩ := h_in_ball ( n + 1 ) |>.2
          obtain ⟨ v, hv ⟩ := h_in_ball n |>.2
          use u - v
          simp [hu, hv];
      have h_norm_le : ‖newton_sequence f T x₀ (n + 1) - x₀‖ ≤ majorizing_seq M L η (n + 1) ∧ ‖newton_sequence f T x₀ n - x₀‖ ≤ majorizing_seq M L η n := by
        apply And.intro;
        · apply norm_newton_sequence_le_majorizing_seq f T x₀ r L h_diff h_surj h_lip M hM η hη h hh h_small h_ML_pos ρ hρ h_r (n + 1);
        · apply norm_newton_sequence_le_majorizing_seq;
          exact fun x hx => h_diff x ( lt_of_lt_of_le hx h_r );
          exact?;
          exact fun x hx y hy => h_lip x ( lt_of_lt_of_le hx h_r ) y ( lt_of_lt_of_le hy h_r );
          exact hM;
          exact hη;
          exact hh;
          exact h_small;
          exact h_ML_pos;
          exact hρ;
          norm_num;
      have h_norm_le : ‖newton_step f T (newton_sequence f T x₀ (n + 1)) - newton_step f T (newton_sequence f T x₀ n)‖ ≤ (M * L / 2) * (majorizing_seq M L η (n + 1) + majorizing_seq M L η n) * (majorizing_seq M L η (n + 1) - majorizing_seq M L η n) := by
        exact h_diff_le.trans ( mul_le_mul ( mul_le_mul_of_nonneg_left ( add_le_add h_norm_le.1 h_norm_le.2 ) ( by positivity ) ) ih ( by exact norm_nonneg _ ) ( by exact mul_nonneg ( by positivity ) ( add_nonneg ( majorizing_seq_nonneg M L η ( by positivity ) ( by linarith [ norm_nonneg ( T ( f x₀ ) ) ] ) _ ) ( majorizing_seq_nonneg M L η ( by positivity ) ( by linarith [ norm_nonneg ( T ( f x₀ ) ) ] ) _ ) ) ) );
      convert h_norm_le using 1;
      rw [ show majorizing_seq M L η ( n + 2 ) = η + ( M * L / 2 ) * ( majorizing_seq M L η ( n + 1 ) ) ^ 2 by rfl, show majorizing_seq M L η ( n + 1 ) = η + ( M * L / 2 ) * ( majorizing_seq M L η n ) ^ 2 by rfl ] ; ring;
    · -- Since $\rho = 0$, we have $x_n = x_0$ for all $n$.
      have h_const : ∀ n, newton_sequence f T x₀ n = x₀ := by
        intro n; induction' n with n ih <;> simp_all +decide [ newton_sequence ] ;
        unfold newton_step; aesop;
        exact norm_le_zero_iff.mp ( by nlinarith [ show 0 ≤ ‖T‖ * L by linarith ] );
      aesop;
      exact majorizing_seq_increasing _ _ _ ( by positivity ) ( by positivity ) _


theorem integral_norm_deriv_sub_le
  (f : E → F) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (x y : E) (hx : x ∈ Metric.ball x₀ r) (hy : y ∈ Metric.ball x₀ r) :
  ‖∫ t in (0 : ℝ)..1, (fderiv ℝ f x₀ - fderiv ℝ f (y + t • (x - y))) (x - y)‖ ≤ (L / 2) * (‖x - x₀‖ + ‖y - x₀‖) * ‖x - y‖ :=
by
  -- Apply the triangle inequality to the integral.
  have h_triangle : ‖∫ t in (0 : ℝ)..1, (fderiv ℝ f x₀ - fderiv ℝ f (y + t • (x - y))) (x - y)‖ ≤ ∫ t in (0 : ℝ)..1, ‖(fderiv ℝ f x₀ - fderiv ℝ f (y + t • (x - y))) (x - y)‖ := by
    simpa only [ intervalIntegral.integral_of_le zero_le_one ] using MeasureTheory.norm_integral_le_integral_norm _;
  -- Apply the bound from h_lip to each term in the integral.
  have h_integral_bound : ∫ t in (0 : ℝ)..1, ‖(fderiv ℝ f x₀ - fderiv ℝ f (y + t • (x - y))) (x - y)‖ ≤ ∫ t in (0 : ℝ)..1, L * ‖x₀ - (y + t • (x - y))‖ * ‖x - y‖ := by
    refine' intervalIntegral.integral_mono_on _ _ _ _;
    · norm_num;
    · apply_rules [ ContinuousOn.intervalIntegrable ];
      refine' ContinuousOn.norm ( ContinuousOn.clm_apply _ continuousOn_const );
      refine' ContinuousOn.sub continuousOn_const _;
      refine' ContinuousOn.comp ( show ContinuousOn ( fun z => fderiv ℝ f z ) ( Metric.ball x₀ r ) from _ ) _ _;
      · refine' Metric.continuousOn_iff.2 fun z hz => _;
        intro ε εpos;
        exact ⟨ ε / ( Max.max L 1 + 1 ), div_pos εpos ( by positivity ), fun w hw hwz => by rw [ dist_eq_norm ] at *; exact lt_of_le_of_lt ( h_lip _ hw _ hz ) ( by rw [ lt_div_iff₀ ( by positivity ) ] at *; nlinarith [ norm_nonneg ( w - z ), le_max_left L 1, le_max_right L 1 ] ) ⟩;
      · fun_prop;
      · intro t ht;
        simp_all +decide [ dist_eq_norm ];
        rw [ show y + t • ( x - y ) - x₀ = ( 1 - t ) • ( y - x₀ ) + t • ( x - x₀ ) by simp +decide [ sub_smul, smul_sub ] ; abel1 ];
        refine' lt_of_le_of_lt ( norm_add_le _ _ ) _;
        rw [ norm_smul, norm_smul, Real.norm_of_nonneg, Real.norm_of_nonneg ] <;> try linarith;
        cases lt_or_ge t ( 1 / 2 ) <;> nlinarith;
    · exact Continuous.intervalIntegrable ( by continuity ) _ _;
    · intro t ht
      have h_bound : ‖(fderiv ℝ f x₀ - fderiv ℝ f (y + t • (x - y))) (x - y)‖ ≤ ‖fderiv ℝ f x₀ - fderiv ℝ f (y + t • (x - y))‖ * ‖x - y‖ := by
        exact ContinuousLinearMap.le_opNorm _ _;
      refine' le_trans h_bound ( mul_le_mul_of_nonneg_right ( h_lip _ _ _ _ ) ( norm_nonneg _ ) );
      · exact Metric.mem_ball_self ( show 0 < r by linarith [ norm_nonneg ( x - x₀ ), norm_nonneg ( y - x₀ ), mem_ball_iff_norm.mp hx, mem_ball_iff_norm.mp hy ] );
      · -- Since the ball is convex, the line segment between x and y is contained within the ball.
        have h_convex : Convex ℝ (Metric.ball x₀ r) := by
          exact convex_ball _ _;
        exact h_convex.add_smul_sub_mem hy hx ( by aesop );
  -- Apply the bound from h_lip to each term in the integral and simplify.
  have h_integral_bound_simplified : ∫ t in (0 : ℝ)..1, L * ‖x₀ - (y + t • (x - y))‖ * ‖x - y‖ ≤ L * ‖x - y‖ * ∫ t in (0 : ℝ)..1, ((1 - t) * ‖x₀ - y‖ + t * ‖x₀ - x‖) := by
    have h_integral_bound_simplified : ∀ t ∈ Set.Icc (0 : ℝ) 1, ‖x₀ - (y + t • (x - y))‖ ≤ (1 - t) * ‖x₀ - y‖ + t * ‖x₀ - x‖ := by
      intro t ht
      have : x₀ - (y + t • (x - y)) = (1 - t) • (x₀ - y) + t • (x₀ - x) := by
        simp +decide [ sub_smul, smul_sub ] ; abel_nf;
      exact this ▸ norm_add_le_of_le ( by rw [ norm_smul, Real.norm_of_nonneg ( sub_nonneg.2 ht.2 ) ] ) ( by rw [ norm_smul, Real.norm_of_nonneg ht.1 ] );
    rw [ ← intervalIntegral.integral_const_mul ];
    refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
    · exact Continuous.intervalIntegrable ( by exact Continuous.mul ( Continuous.mul continuous_const <| Continuous.norm <| continuous_const.sub <| continuous_const.add <| continuous_id'.smul continuous_const ) continuous_const ) _ _;
    · exact Continuous.intervalIntegrable ( by continuity ) _ _;
    · intro t ht₁ ht₂; rw [ mul_right_comm ] ; gcongr ; aesop;
      · specialize h_lip x hx y hy;
        exact le_trans ( norm_nonneg _ ) h_lip;
      · exact h_integral_bound_simplified t ⟨ ht₁, ht₂ ⟩;
  convert h_triangle.trans ( h_integral_bound.trans h_integral_bound_simplified ) using 1 ; norm_num [ sub_mul ] ; ring;
  simpa only [ norm_sub_rev ] using by ring;


theorem newton_sequence_const_of_rho_zero
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (M : ℝ) (hM : ‖T‖ = M)
  (η : ℝ) (hη : ‖T (f x₀)‖ = η)
  (h : ℝ) (hh : h = M * L * η)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_rho_zero : ρ = 0) :
  ∀ n, newton_sequence f T x₀ n = x₀ :=
by
  -- Since $\rho = 0$, we have $1 - \sqrt{1-2h} = 0$, so $h=0$.
  have h_h_zero : h = 0 := by
    grind;
  bound;
  induction' n with n ih;
  · -- The base case is when n = 0. By definition, newton_sequence f T x₀ 0 = x₀.
    simp [newton_sequence];
  · -- By definition of newton_sequence, we have newton_sequence f T x₀ (n + 1) = newton_step f T (newton_sequence f T x₀ n).
    have h_step : newton_sequence f T x₀ (n + 1) = newton_step f T (newton_sequence f T x₀ n) := by
      rfl;
    rw [ h_step, ih, newton_step ];
    rw [ eq_comm ] at hh ; aesop ( simp_config := { singlePass := true } )


theorem newton_sequence_converges
  (f : E → F) (T : F →L[ℝ] E) (x₀ : E) (r : ℝ) (L : ℝ)
  (h_diff : ∀ x ∈ Metric.ball x₀ r, DifferentiableAt ℝ f x)
  (h_surj : (fderiv ℝ f x₀).comp T = ContinuousLinearMap.id ℝ F)
  (h_lip : ∀ x ∈ Metric.ball x₀ r, ∀ y ∈ Metric.ball x₀ r, ‖fderiv ℝ f x - fderiv ℝ f y‖ ≤ L * ‖x - y‖)
  (M : ℝ) (hM : ‖T‖ = M)
  (η : ℝ) (hη : ‖T (f x₀)‖ = η)
  (h : ℝ) (hh : h = M * L * η)
  (h_small : h < 1 / 2)
  (h_ML_pos : 0 < M * L)
  (ρ : ℝ) (hρ : ρ = (1 - Real.sqrt (1 - 2 * h)) / (M * L))
  (h_r : ρ ≤ r) :
  ∃ x_star : E, Tendsto (newton_sequence f T x₀) atTop (𝓝 x_star) :=
by
  have h_nonneg : 0 ≤ h := by
    rw [hh]
    have : 0 ≤ η := hη ▸ norm_nonneg _
    nlinarith
  by_cases h_rho_pos : 0 < ρ
  · have h_contraction : M * L * ρ < 1 := ML_rho_lt_one M L η h hh h_small h_ML_pos ρ hρ
    have h_cauchy : CauchySeq (newton_sequence f T x₀) :=
      newton_sequence_cauchy f T x₀ r L h_diff h_surj h_lip M hM η hη h hh h_small.le h_ML_pos ρ hρ h_r h_rho_pos h_contraction
    exact cauchySeq_tendsto_of_complete h_cauchy
  · have h_rho_nonneg : 0 ≤ ρ := rho_nonneg M L h h_small.le h_nonneg h_ML_pos ρ hρ
    have h_rho_zero : ρ = 0 := le_antisymm (not_lt.mp h_rho_pos) h_rho_nonneg
    have h_const : ∀ n, newton_sequence f T x₀ n = x₀ :=
      newton_sequence_const_of_rho_zero f T x₀ r L M hM η hη h hh h_ML_pos ρ hρ h_rho_zero
    use x₀
    rw [tendsto_congr h_const]
    exact tendsto_const_nhds
