[{"stmt": "Every ring is a field.", "prompts": "[{\"theorem\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬¨IsField { x // x ‚àà NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u} [inst : Infinite Œ±], Nonempty (Field Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"Any infinite type can be endowed a field structure. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (‚Üëf (MulOpposite.unop (‚Üëf x))) = x\",\n  \"isProp\": true,\n  \"docString\": \"Every ring involution must be its own inverse \"}]\n"}, {"stmt": "Every vector space is finite dimensional.", "prompts": "[{\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\\n  [inst_3 : Finite Œπ], Basis Œπ K V ‚Üí FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ‚ü∂ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\\n  {s : Set Œπ}, Basis (‚Üës) K V ‚Üí Set.Finite s ‚Üí FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ‚àà S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ùïú E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ùïú F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ùïú F]\\n  [inst_10 : FiniteDimensional ùïú E] [inst_11 : FiniteDimensional ùïú F], FiniteDimensional ùïú (E ‚ÜíL[ùïú] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsComplete ‚Üës\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type w} [inst_4 : Fintype Œπ], Basis Œπ R M ‚Üí Module.rank R M = ‚Üë(Fintype.card Œπ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsClosed ‚Üës\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"‚àÄ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    ‚Üë(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget‚ÇÇ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s ‚Üí FiniteDimensional k { x // x ‚àà vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"}]\n"}, {"stmt": "Every group is a torsion monoid.", "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G ‚Üí CommMonoid.torsion G = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"The torsion submonoid of a torsion monoid is `‚ä§`. \"}]\n"}, {"stmt": "Every finite simple group has prime order.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p)],\\n  p ‚à£ Fintype.card G ‚Üí ‚àÉ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"}]\n"}, {"stmt": "Every finite group is simple.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ‚àà (Nat.factorization (Fintype.card G)).support }) ‚Üí (P : Sylow (‚Üëp) G) ‚Üí { x // x ‚àà ‚ÜëP }) ‚âÉ* G ‚Üí\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"}]\n"}, {"stmt": "Every finite group has prime order.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p)],\\n  p ‚à£ Fintype.card G ‚Üí ‚àÉ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} [inst : Group G] {G‚ÇÇ : Type u_1} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype { x // x ‚àà H‚ÇÅ }] [inst_3 : Fintype { x // x ‚àà H‚ÇÇ }],\\n      IsPGroup p‚ÇÅ { x // x ‚àà H‚ÇÅ } ‚Üí\\n        IsPGroup p‚ÇÇ { x // x ‚àà H‚ÇÇ } ‚Üí Nat.coprime (Fintype.card { x // x ‚àà H‚ÇÅ }) (Fintype.card { x // x ‚àà H‚ÇÇ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"}]\n"}, {"stmt": "Every set has Lebesgue measure zero.", "prompts": "[{\"theorem\": \"‚Üë‚ÜëMeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\\n  Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.SecondCountableTopology Œ±]\\n  (m : MeasureTheory.OuterMeasure Œ±) (s : Set Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ u, u ‚àà nhdsWithin x s ‚àß ‚Üëm u = 0) ‚Üí ‚Üëm s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : AffineSubspace ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : Submodule ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\\n  Metric.Bounded s ‚Üí\\n    Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} [inst_1 : MeasureTheory.SigmaFinite Œº]\\n  (s : Set Œ±), (‚àÄ (n : ‚Ñï), ‚Üë‚ÜëŒº (s ‚à© MeasureTheory.spanningSets Œº n) = 0) ‚Üî ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a œÉ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"‚àÄ {Œ© : Type u_2} [inst : MeasurableSpace Œ©] [inst_1 : TopologicalSpace Œ©] [inst_2 : OpensMeasurableSpace Œ©]\\n  {Œ≥ : Type u_1} {F : Filter Œ≥} {Œºs : Œ≥ ‚Üí MeasureTheory.FiniteMeasure Œ©},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Œºs i)) F (nhds 0) ‚Üí Filter.Tendsto Œºs F (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"theorem\":\n  \"‚Üë‚ÜëMeasureTheory.volume (‚ãÉ (p : ‚Ñù) (_ : 2 < p), {x | LiouvilleWith p x}) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\\nmeasure zero. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), Real.convergent 0 n = 0\",\n  \"isProp\": true,\n  \"docString\": \"All convergents of `0` are zero. \"}]\n"}, {"stmt": "If a topological space is compact, then every subset is compact.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±),\\n  n ‚àà nhds x ‚Üí ‚àÉ s, s ‚àà nhds x ‚àß s ‚äÜ n ‚àß IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.NonemptyCompacts Œ±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"}]\n"}, {"stmt": "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.", "prompts": "[{\"theorem\": \"‚Üë‚ÜëMeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\\n  Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.SecondCountableTopology Œ±]\\n  (m : MeasureTheory.OuterMeasure Œ±) (s : Set Œ±), (‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ u, u ‚àà nhdsWithin x s ‚àß ‚Üëm u = 0) ‚Üí ‚Üëm s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E} (u : ‚Ñï ‚Üí E),\\n  Metric.Bounded s ‚Üí\\n    Metric.Bounded (Set.range u) ‚Üí Pairwise (Disjoint on fun n => {u n} + s) ‚Üí MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type w} [inst : TopologicalSpace G] (Œº : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ‚â§ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Œº)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul‚ÇÇ G]\\n  (Œº ŒΩ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ŒΩ] [inst_4 : MeasureTheory.SigmaFinite Œº]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Œº]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ŒΩ],\\n  MeasurableSet s ‚Üí ‚Üë‚ÜëŒΩ s ‚â† 0 ‚Üí ‚Üë‚ÜëŒΩ s ‚â† ‚ä§ ‚Üí Œº = (‚Üë‚ÜëŒº s / ‚Üë‚ÜëŒΩ s) ‚Ä¢ ŒΩ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : BorelSpace Œ±],\\n  OpensMeasurableSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} [inst_1 : MeasureTheory.SigmaFinite Œº]\\n  (s : Set Œ±), (‚àÄ (n : ‚Ñï), ‚Üë‚ÜëŒº (s ‚à© MeasureTheory.spanningSets Œº n) = 0) ‚Üî ‚Üë‚ÜëŒº s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a œÉ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {s : Set E}\\n  {f : E ‚Üí E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº], DifferentiableOn ‚Ñù f s ‚Üí ‚Üë‚ÜëŒº s = 0 ‚Üí ‚Üë‚ÜëŒº (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd‚ÇÇ G]\\n  (Œº ŒΩ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ŒΩ] [inst_4 : MeasureTheory.SigmaFinite Œº]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ŒΩ],\\n  MeasurableSet s ‚Üí ‚Üë‚ÜëŒΩ s ‚â† 0 ‚Üí ‚Üë‚ÜëŒΩ s ‚â† ‚ä§ ‚Üí Œº = (‚Üë‚ÜëŒº s / ‚Üë‚ÜëŒΩ s) ‚Ä¢ ŒΩ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"}]\n"}, {"stmt": "A finitely-presented group containing a torsion element is finite.", "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A ‚Üí Algebra.FiniteType R A\",\n  \"isProp\": true,\n  \"docString\": \"A finitely presented algebra is of finite type. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => orderOf g) ‚Üí Monoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\": \"The group exponent exists for any bounded torsion group. \"}]\n"}, {"stmt": "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] {s : Set Œ±}, IsClosed s ‚Üí IsClosed {t | ‚Üët ‚äÜ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\\n  Convex ùïú s ‚Üí Convex ùïú (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsClosed ‚Üës\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"}]\n"}, {"stmt": "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Function.Surjective f ‚Üí Continuous f ‚Üí QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T2Space Œ±] (x y : Œ±),\\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí Function.Injective f ‚Üí ClosedEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"theorem\":\n  \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {Œ≥ : Type w} [inst_6 : MetricSpace Œ≥]\\n  {Œ¶ : X ‚Üí Œ≥} {Œ® : Y ‚Üí Œ≥},\\n  Isometry Œ¶ ‚Üí Isometry Œ® ‚Üí GromovHausdorff.ghDist X Y ‚â§ Metric.hausdorffDist (Set.range Œ¶) (Set.range Œ®)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\\nof isometric copies of the spaces, in any metric space. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H ‚Üî TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"}]\n"}, {"stmt": "Any finite order element in a group is equal to the identity.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"}]\n"}, {"stmt": "If a subgroup of a group is torsion-free, then the group itself is torsion free.", "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"}]\n"}, {"stmt": "Every injective homomorphism from a finitely generated free group to itself is surjective.", "prompts": "[{\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Œπ] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R ‚Üí\\n    ‚àÄ (ps : Œπ ‚Üí MvPolynomial Œπ R),\\n      (Function.Injective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)) ‚Üí\\n        Function.Surjective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"‚àÄ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ‚ä§ ‚Üíg G'), Function.Injective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsAddGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Bijective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ‚Üëf a‚Åª¬π = (‚Üëf a)‚Åª¬π\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"}]\n"}, {"stmt": "Every division ring is either a field or finite.", "prompts": "[{\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Œì‚ÇÄ]\\n  [inst_2 : Valued K Œì‚ÇÄ], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] [inst_1 : FloorSemiring Œ±] (m n : ‚Ñï), ‚åä‚Üëm / ‚Üën‚åã‚Çä = m / n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is the floor of field division. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"}]\n"}, {"stmt": "Every natural number is the product of two primes.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {Œπ : Type u_1} (s : Finset Œπ)\\n  (f : Œπ ‚Üí Ideal R) (e : Œπ ‚Üí ‚Ñï),\\n  (‚àÄ (i : Œπ), i ‚àà s ‚Üí Prime (f i)) ‚Üí\\n    (‚àÄ (i : Œπ), i ‚àà s ‚Üí ‚àÄ (j : Œπ), j ‚àà s ‚Üí i ‚â† j ‚Üí f i ‚â† f j) ‚Üí\\n      (Finset.inf s fun i => f i ^ e i) = Finset.prod s fun i => f i ^ e i\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of distinct prime powers in a Dedekind domain is the product of these\\nprime powers. \"}]\n"}, {"stmt": "Every even number is the square of a natural number.", "prompts": "[{\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"‚àÄ (a b c d x y z w : ‚Ñï),\\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x y : Œ±},\\n  1 ‚â§ x ‚Üí 1 < y ‚Üí ‚àÉ n, y ^ n ‚â§ x ‚àß x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"}]\n"}, {"stmt": "Every normal subgroup of a group has finite index.", "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ‚â† 0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ‚àà H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ‚Üî Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type u_1} {s : Set Œπ}, Basis (‚Üës) R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A ‚Üí FiniteDimensional K { x // x ‚àà Submodule.span K A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"{G : Type u_1} ‚Üí [inst : Group G] ‚Üí (H : Subgroup G) ‚Üí [inst_1 : Subgroup.FiniteIndex H] ‚Üí Fintype (G ‚ß∏ H)\",\n  \"isProp\": false,\n  \"docString\": \"A finite index subgroup has finite quotient. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G),\\n  Subgroup.Normal H‚ÇÅ ‚Üí Subgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n"}, {"stmt": "The characteristic polynomial of every matrix has real roots.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : IsROrC Œ±] {A : Matrix n n Œ±},\\n  Matrix.IsHermitian A ‚Üí (fun i => ‚Üë(‚ÜëIsROrC.re (Matrix.diag A i))) = Matrix.diag A\",\n  \"isProp\": true,\n  \"docString\":\n  \"The diagonal elements of a complex hermitian matrix are real. \"},\n {\"theorem\":\n  \"‚àÄ {f : Polynomial ‚ÑÇ}, 0 < Polynomial.degree f ‚Üí ‚àÉ z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\\n  {T : E ‚Üí‚Çó[ùïú] E}, LinearMap.IsSymmetric T ‚Üí ‚àÄ {Œº : ùïú}, Module.End.HasEigenvalue T Œº ‚Üí ‚Üë(starRingEnd ùïú) Œº = Œº\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"‚àÄ (p : Polynomial ‚Ñù),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ‚â§\\n    Finset.card (Multiset.toFinset (Polynomial.roots (‚ÜëPolynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí x ‚â† 0 ‚Üí Polynomial.coeff (minpoly A x) 0 ‚â† 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F ‚Ñù] (p : Polynomial F),\\n  Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) ‚â§ Fintype.card ‚Üë(Polynomial.rootSet (‚ÜëPolynomial.derivative p) ‚Ñù) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ‚ÑÇ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule ‚ÑÇ A] (a : { x // x ‚àà selfAdjoint A }) {z : ‚ÑÇ},\\n  z ‚àà spectrum ‚ÑÇ ‚Üëa ‚Üí z = ‚Üëz.re\",\n  \"isProp\": true,\n  \"docString\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"theorem\":\n  \"‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial œÉ R),\\n  ‚àÉ n f _hf q, p = ‚Üë(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x ‚Üí 0 < Polynomial.degree (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"The degree of a minimal polynomial is positive. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Œ±] [inst_2 : One Œ±], Matrix.IsDiag 1\",\n  \"isProp\": true,\n  \"docString\": \"Every identity matrix is diagonal. \"}]\n"}, {"stmt": "In a commutative ring, every prime ideal is contained in a unique maximal ideal.", "prompts": "[{\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R],\\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} ‚Üí ‚àÄ {I : Ideal R}, IsUnit ‚ÜëI ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"‚àÄ (Œ± : Type u) [inst : Semiring Œ±] [inst_1 : Nontrivial Œ±], ‚àÉ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ‚ÜëI\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S ‚â§ nonZeroDivisors R ‚Üí\\n    Set.Finite {I | Ideal.IsMaximal I} ‚Üí ‚àÄ (I I' : FractionalIdeal S A), I * I' = 1 ‚Üí Submodule.IsPrincipal ‚ÜëI\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"}]\n"}, {"stmt": "Every continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {Œπ : Type u_1} {F : Œπ ‚Üí Œ≤ ‚Üí Œ±}\\n  [inst_2 : CompactSpace Œ≤], Equicontinuous F ‚Üí UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"}]\n"}, {"stmt": "Every uniformly continuous function is bounded above.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Zero Œ±] {f : Œ≤ ‚Üí Œ±},\\n  Continuous f ‚Üí HasCompactSupport f ‚Üí BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} [inst : ConditionallyCompleteLattice Œ±] [inst_1 : Nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±},\\n  (‚àÄ (x : Œπ), f x ‚â§ c) ‚Üí iSup f ‚â§ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indexed supremum of a function is bounded above by a uniform bound\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {s : Set Œ±}, Set.Finite s ‚Üí BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded above.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Zero Œ±] {f : Œ≤ ‚Üí Œ±},\\n  Continuous f ‚Üí HasCompactSupport f ‚Üí BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"}]\n"}, {"stmt": "If every compact subset of a topological space is closed, then the space is compact.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"}]\n"}, {"stmt": "In a commutative ring, the sum of idempotent elements is idempotent.", "prompts": "[{\"theorem\": \"‚àÄ {Œ± : Type u_1} [self : BooleanRing Œ±] (a : Œ±), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x + y) = ‚Üëe x + ‚Üëe y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\":\n  \"‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I ‚Üí (IsIdempotentElem I ‚Üî ‚àÉ e, IsIdempotentElem e ‚àß I = Submodule.span R {e})\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} (f : Œ± ‚Üí Œ≤),\\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"theorem\":\n  \"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (s : Finset Œπ) (c : R)\\n  (x : (i : ‚Üë‚Üës) ‚Üí M ‚Üëi), ‚Üë(DirectSum.mk M s) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"}]\n"}, {"stmt": "The number of partitions of a finite set is a prime number.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p)],\\n  p ‚à£ ringChar R ‚Üî p ‚à£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {a : Set Œ±}, Set.Finite a ‚Üí Set.Finite {b | b ‚äÜ a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"}]\n"}, {"stmt": "If a poset has a maximal element, then it has a unique minimal element.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeSup Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí a ‚â§ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsGreatest s a ‚Üí sSup s = a\",\n  \"isProp\": true,\n  \"docString\": \"A greatest element of a set is the supremum of this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsLeast s a ‚Üí sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeAddGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ‚Ñ§) (I : { x // x ‚àà nonZeroDivisors (Ideal S) }),\\n  ‚àÉ b, b ‚àà ‚ÜëI ‚àß b ‚â† 0 ‚àß ‚àÄ (c : S), c ‚àà ‚ÜëI ‚Üí ‚Üëabv (‚Üë(Algebra.norm R) c) < ‚Üëabv (‚Üë(Algebra.norm R) b) ‚Üí c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ ‚Üí FreeGroup.mk L‚ÇÅ = FreeGroup.mk L‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words have a common maximal reduction, then they correspond to the same element in the\\nfree group. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeGroup.mk L‚ÇÅ = FreeGroup.mk L‚ÇÇ ‚Üí FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends\\nan element of the free group to its maximal reduction is well-defined. \"}]\n"}, {"stmt": "The automorphism group of an Abelian group is cyclic.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\\n  IsCyclic { x // x ‚àà S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\": \"‚àÄ (H : AddSubgroup ‚Ñ§), ‚àÉ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `‚Ñ§` is cyclic. \"},\n {\"theorem\":\n  \"‚àÄ {p : ‚Ñï} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 ‚Üí IsCyclic (G ‚ß∏ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\": \"‚àÄ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G·µÉ·µí·µñ G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"}]\n"}, {"stmt": "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\":\n  \"‚àÄ {f : Ordinal.{u} ‚Üí Ordinal.{u}}, Ordinal.IsNormal f ‚Üí Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The fixed point lemma for normal functions: any normal function has an unbounded set of\\nfixed points. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí IsCompact (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function has compact range. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x : Œ±), ‚àÉ y, y ‚àà Set.Ico 0 c ‚àß f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ‚àà Ico 0 c` such that `f x = f y`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\": \"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±],\\n  Function.Periodic f c ‚Üí 0 < c ‚Üí ‚àÄ (x a : Œ±), ‚àÉ y, y ‚àà Set.Ico a (a + c) ‚àß f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ‚àà Ico a (a + c)` such that `f x = f y`. \"}]\n"}, {"stmt": "The complement of the union of two sets contains the union of their complements.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (s : Set Œ±), frontier s·∂ú = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded s ‚Üí Metric.Bounded t ‚Üí Metric.Bounded (s ‚à™ t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} {p : ENNReal} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup E] {s t : Set Œ±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hŒºs : ‚Üë‚ÜëŒº s ‚â† ‚ä§)\\n  (hŒºt : ‚Üë‚ÜëŒº t ‚â† ‚ä§),\\n  s ‚à© t = ‚àÖ ‚Üí\\n    ‚àÄ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ‚à™ t)) (_ : ‚Üë‚ÜëŒº (s ‚à™ t) ‚â† ‚ä§) c =\\n        MeasureTheory.indicatorConstLp p hs hŒºs c + MeasureTheory.indicatorConstLp p ht hŒºt c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded (s ‚à™ t) ‚Üî Metric.Bounded s ‚àß Metric.Bounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± ‚äï Œ≤)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} (S T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {a : Set (Œ± √ó Œ±)},\\n  a ‚àà uniformity Œ± ‚Üí\\n    ‚àÄ {b : Set (Œ≤ √ó Œ≤)},\\n      b ‚àà uniformity Œ≤ ‚Üí\\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a ‚à™ (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b ‚àà\\n          UniformSpace.Core.sum.uniformity\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\\nof the diagonal. \"},\n {\"theorem\":\n  \"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ‚à™ t) = affineSpan k s ‚äî affineSpan k t\",\n  \"isProp\": true,\n  \"docString\": \"The span of a union of sets is the sup of their spans. \"},\n {\"theorem\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s t : Set Œ≥}, BddAbove (s ‚à™ t) ‚Üî BddAbove s ‚àß BddAbove t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"}]\n"}, {"stmt": "The square root of an rational number is rational.", "prompts": "[{\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) ‚Üí ‚àÉ q, v = ‚Üëq\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"‚àÄ (q : ‚Ñö), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\": \"‚àÄ (Œæ : ‚Ñö), Set.Finite {q | |Œæ - q| < 1 / ‚Üëq.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"‚àÄ {r : ‚Ñù}, Transcendental ‚Ñö r ‚Üí Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\": \"‚àÄ {x y : ‚Ñù}, x < y ‚Üí ‚àÉ r, Irrational r ‚àß x < r ‚àß r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚Äñ‚ÜëœÜ x‚Äñ = 1) ‚Üí ‚àÉ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"}]\n"}, {"stmt": "If a module over a ring is free, then the ring is commutative.", "prompts": "[{\"theorem\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ‚Üî Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} (R : Type u) [inst : Semiring R] (M : Œπ ‚Üí Type u_2) [inst_1 : Finite Œπ]\\n  [inst_2 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_3 : (i : Œπ) ‚Üí Module R (M i)]\\n  [inst_4 : ‚àÄ (i : Œπ), Module.Free R (M i)], Module.Free R ((i : Œπ) ‚Üí M i)\",\n  \"isProp\": true,\n  \"docString\": \"The product of finitely many free modules is free. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\",\n  \"isProp\": true,\n  \"docString\": \"Modules over the trivial ring are Noetherian. \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module with a finite ring of scalars is additively torsion. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  Nonempty (M ‚âÉ‚Çó[R] N) ‚Üî FiniteDimensional.finrank R M = FiniteDimensional.finrank R N\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.FG ‚ä§\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The category of modules has enough projectives, since every module is a quotient of a free\\nmodule. \"},\n {\"theorem\":\n  \"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Submodule K V), IsAtom W ‚Üî ‚àÉ v x, W = Submodule.span K {v}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The atoms of the lattice of submodules of a module over a division ring are the\\nsubmodules equal to the span of a nonzero element of the module. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"}]\n"}, {"stmt": "If the set of units of a ring forms a group then the ring is commutative.", "prompts": "[{\"theorem\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom fun a => (f a)‚Åª¬π\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [inst : NonUnitalNonAssocSemiring Œ±]\\n  [inst_1 : NonUnitalNonAssocSemiring Œ≤] [inst_2 : NonUnitalNonAssocSemiring Œ≥] {Œ¥ : Type u_1}\\n  {x : NonUnitalNonAssocSemiring Œ¥} (f : Œ± ‚Üí‚Çô+* Œ≤) (g : Œ≤ ‚Üí‚Çô+* Œ≥) (h : Œ≥ ‚Üí‚Çô+* Œ¥),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} [inst : CommRing R],\\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"}]\n"}, {"stmt": "Every natural number larger than `10` is the sum of a square and a prime.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ¬¨Nat.Prime n ‚Üí Nat.minFac n ^ 2 ‚â§ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â§ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"}]\n"}, {"stmt": "The initial object of a category is isomorphic to its terminal object.", "prompts": "[{\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (Y ‚ü∂ X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f g : Y ‚ü∂ X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (X ‚ü∂ Y)],\\n  CategoryTheory.Limits.HasInitial C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has an initial object by specifying the object,\\nand showing there is a unique morphism from it to any other object. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F ‚Üí CategoryTheory.Skeletal D\",\n  \"isProp\": true,\n  \"docString\": \"The category `D` has isomorphic objects equal \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is mono. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (‚ä§_ C)) ‚Üí CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\\n  CategoryTheory.Limits.IsTerminal T ‚Üí\\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) ‚Üí CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f g : X ‚ü∂ Y), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms from an initial object are equal. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"}]\n"}, {"stmt": "If the composition of two functions is continuous, then each of them is continuous.", "prompts": "[{\"theorem\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {f g : X ‚Üí Y},\\n  f =·∂†[MeasureTheory.Measure.ae Œº] g ‚Üí Continuous f ‚Üí Continuous g ‚Üí f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\\n  BddAbove (Set.range fun x => ‚Äñg x‚Äñ) ‚Üí MeasureTheory.Integrable f ‚Üí Continuous g ‚Üí Continuous (convolution f g L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The convolution is continuous if one function is integrable and the other is bounded and\\ncontinuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : Œ≤ ‚Üí Œ≥} {s : Set Œ≤},\\n  s ‚äÜ e.target ‚Üí (ContinuousOn f s ‚Üî ContinuousOn (f ‚àò ‚Üëe) (e.source ‚à© ‚Üëe ‚Åª¬π' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ±] {s : Set Œ≤},\\n  Dense s ‚Üí ‚àÄ {f g : Œ≤ ‚Üí Œ±}, Continuous f ‚Üí Continuous g ‚Üí Set.EqOn f g s ‚Üí f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : Œ≥ ‚Üí Œ±} {s : Set Œ≥},\\n  s ‚äÜ f ‚Åª¬π' e.source ‚Üí (ContinuousOn f s ‚Üî ContinuousOn (‚Üëe ‚àò f) s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the left is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {U : Set X}\\n  {f g : X ‚Üí Y},\\n  f =·∂†[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Œº U)] g ‚Üí\\n    IsOpen U ‚Üí ContinuousOn f U ‚Üí ContinuousOn g U ‚Üí Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : Œ≥ ‚Üí Œ±},\\n  f ‚Åª¬π' e.source = Set.univ ‚Üí (Continuous f ‚Üî Continuous (‚Üëe ‚àò f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous if and only if its composition with a local homeomorphism\\non the left is continuous and its image is contained in the source. \"}]\n"}, {"stmt": "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.", "prompts": "[{\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b ‚Üí AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute a c ‚Üí Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b ‚Üí AddCommute a c ‚Üí AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c ‚Üí Commute b c ‚Üí Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c ‚Üí AddCommute b c ‚Üí AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a b : M} {c : R}, c ‚Ä¢ a < c ‚Ä¢ b ‚Üí 0 < c ‚Üí a < b\",\n  \"isProp\": true,\n  \"docString\": \"If `c ‚Ä¢ a < c ‚Ä¢ b` for some positive `c`, then `a < b`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : IsDirected Œ± r] (a b : Œ±), ‚àÉ c, r a c ‚àß r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"}]\n"}, {"stmt": "If an element maps to zero under a ring homomorphism, then it is zero.", "prompts": "[{\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map zero to zero. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ‚âÉ+* S), ‚Üëf 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\\n  (‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0) ‚Üí\\n    CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤}, IsAddGroupHom f ‚Üí f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) ‚Üí\\n    ‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that is injective on pseudoelements only maps the zero element to zero. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r ‚àà RingHom.ker f ‚Üî ‚Üëf r = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0\",\n  \"isProp\": true,\n  \"docString\": \"The zero morphism maps every pseudoelement to 0. \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ‚àà s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Norm R‚ÇÅ] [inst_3 : Norm R‚ÇÇ]\\n  {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ} [self : RingHomIsometric œÉ] {x : R‚ÇÅ}, ‚Äñ‚ÜëœÉ x‚Äñ = ‚Äñx‚Äñ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"}]\n"}, {"stmt": "Implication `‚Üí` is symmetric. If `P ‚Üí Q` then `Q ‚Üí P`.", "prompts": "[{\"theorem\": \"‚àÄ {p q r : Prop}, (p ‚Üí q) ‚Üí (q ‚Üí r) ‚Üí p ‚Üí r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Implication `‚Üí` is transitive. If `P ‚Üí Q` and `Q ‚Üí R` then `P ‚Üí R`. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ {x y : Œ±}, r x y ‚Üí r y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"theorem\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category D]\\n  [inst_2 :\\n    ‚àÄ (P : CategoryTheory.Functor C·µí·µñ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : CategoryTheory.Functor C·µí·µñ D)\\n  [inst_3 : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\",\n  \"isProp\": true,\n  \"docString\": \"`(P ‚ü∂ P‚Å∫)‚Å∫ = P‚Å∫ ‚ü∂ P‚Å∫‚Å∫` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {p q : Œ±}, Irreducible p ‚Üí Irreducible q ‚Üí p ‚à£ q ‚Üí q ‚à£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ‚à£ q` implies `q ‚à£ p`. \"},\n {\"theorem\":\n  \"‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí CategoryTheory.MorphismProperty.RespectsIso P\",\n  \"isProp\": true,\n  \"docString\": \"`P` respects isomorphisms. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ {x y z : Œ±}, r x y ‚Üí r y z ‚Üí r x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ (x : Œ±), r x x\",\n  \"isProp\": true,\n  \"docString\": \"An equivalence relation is reflexive: `x ~ x` \"},\n {\"theorem\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : Submodule R M ‚Üí Prop},\\n  (‚àÄ (I : Submodule R M), (‚àÄ (J : Submodule R M), J > I ‚Üí P J) ‚Üí P I) ‚Üí ‚àÄ (I : Submodule R M), P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `‚àÄ I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u} {a b c d : Œ±} [inst : Preorder Œ±], c ‚â§ a ‚Üí b ‚â§ d ‚Üí a ‚â§ b ‚Üí c ‚â§ d\",\n  \"isProp\": true,\n  \"docString\": \"monotonicity of `‚â§` with respect to `‚Üí` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : Antisymm r] {a b : Œ±}, r a b ‚Üí r b a ‚Üí a = b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An antisymmetric relation `(¬∑‚â§¬∑)` satisfies `a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b`. \"}]\n"}, {"stmt": "Two natural numbers are equal if and only if they are both divisible by some prime number.", "prompts": "[{\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ m + n ‚Üî m ‚à£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ n + m ‚Üî m ‚à£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"theorem\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí Int.natAbs (a - c) < Int.natAbs b ‚Üí a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] {a b c : Œ±}, a ‚à£ c ‚Üí a ‚à£ b ‚Üí a ‚à£ gcd c b\",\n  \"isProp\": true,\n  \"docString\": \"Any common divisor of both elements is a divisor of the GCD. \"}]\n"}]