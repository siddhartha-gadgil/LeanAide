[{"stmt": "Every ring is a field.", "prompts": "[{\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Infinite Î±], Nonempty (Field Î±)\",\n  \"isProp\": true,\n  \"docString\": \"Any infinite type can be endowed a field structure. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (â†‘f (MulOpposite.unop (â†‘f x))) = x\",\n  \"isProp\": true,\n  \"docString\": \"Every ring involution must be its own inverse \"}]\n", "prompt_cons": "/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 âˆˆ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 âˆˆ S :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- Fields are commutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î± :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y :=\n\n/-- Any infinite type can be endowed a field structure. -/\ntheorem âˆ€ {Î± : Type u} [inst : Infinite Î±], Nonempty (Field Î±) :=\n\n/-- Every ring involution must be its own inverse -/\ntheorem âˆ€ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\n  MulOpposite.unop (â†‘f (MulOpposite.unop (â†‘f x))) = x :=\n\n/-- Every ring is a field. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ Field R ", "Sorry, the statement \"Every ring is a field\" is incorrect and cannot be proven as there are rings that are not fields. A field is a ring with additional properties such as having multiplicative inverses for all non-zero elements.", "âˆ€ (R : Type u) [inst : Semiring R], IsField R ", "âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ Field R ", "âˆ€ (R : Type u) [inst : Semiring R], IsField R ", "âˆ€ (R : Type u) [inst : Semiring R], IsField R ", "âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ Field R ", "âˆ€ (R : Type u) [inst : CommRing R], IsField R ", "âˆ€ (R : Type u) [inst : Semiring R], IsField R ", "This statement is false and cannot be proven in Lean. A ring is not necessarily a field."]}, {"stmt": "Every vector space is finite dimensional.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ğ•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ğ•œ F]\\n  [inst_10 : FiniteDimensional ğ•œ E] [inst_11 : FiniteDimensional ğ•œ F], FiniteDimensional ğ•œ (E â†’L[ğ•œ] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    â†‘(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forgetâ‚‚ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ğ•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ğ•œ F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ğ•œ F]\n  [inst_10 : FiniteDimensional ğ•œ E] [inst_11 : FiniteDimensional ğ•œ F], FiniteDimensional ğ•œ (E â†’L[ğ•œ] F) :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsComplete â†‘s :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- Finite limits of finite dimensional vectors spaces are finite dimensional,\nbecause we can realise them as subobjects of a finite product. -/\ntheorem âˆ€ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\n  FiniteDimensional k\n    â†‘(CategoryTheory.Limits.limit\n        (CategoryTheory.Functor.comp F (CategoryTheory.forgetâ‚‚ (FGModuleCat k) (ModuleCat k)))) :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s } :=\n\n/-- Every vector space is finite dimensional. -/\ntheorem", "choices": ["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V "]}, {"stmt": "Every group is a torsion monoid.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x âˆˆ CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G â†’ CommMonoid.torsion G = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The torsion submonoid of a torsion monoid is `âŠ¤`. \"}]\n", "prompt_cons": "/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x âˆˆ CommMonoid.torsion G } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- The torsion submonoid of a torsion monoid is `âŠ¤`. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G â†’ CommMonoid.torsion G = âŠ¤ :=\n\n/-- Every group is a torsion monoid. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "/-- Every group is a torsion monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "forall {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "theorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "forall {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G "]}, {"stmt": "Every finite simple group has prime order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"}]\n", "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x :=\n\n/-- Every finite simple group has prime order. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î± â†’ âˆƒ p, Nat.Prime p âˆ§ Fintype.card Î± = p ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], IsPrime (Fintype.card G) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G â†’ âˆƒ p [hp : Fact (Nat.Prime p)], Fintype.card G = p ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î± â†’ âˆƒ p, Fact (Nat.Prime p) âˆ§ Fintype.card Î± = p ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [is_simple : IsSimpleGroup Î±],\n  âˆƒ {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], IsSimpleGroup Î± â†’ IsPrime (Fintype.card Î±) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G â†’ âˆƒ p [hp : Fact (Nat.Prime p)], Fintype.card G = p ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G â†’ âˆƒ p, Fact (Nat.Prime p) âˆ§ Fintype.card G = p ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [is_simple : IsSimpleGroup Î±],\n  âˆƒ p : â„•, Nat.Prime p âˆ§ Fintype.card Î± = p ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G â†’ âˆƒ p [hp : Fact (Nat.Prime p)], Fintype.card G = p "]}, {"stmt": "Every finite group is simple.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"}]\n", "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Group.FG G â†” Monoid.FG G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x âˆˆ (Nat.factorization (Fintype.card G)).support }) â†’ (P : Sylow (â†‘p) G) â†’ { x // x âˆˆ â†‘P }) â‰ƒ* G â†’\n    Group.IsNilpotent G :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val :=\n\n/-- Every finite group is simple. -/\ntheorem", "choices": ["This statement is incorrect, as not every finite group is simple. Please provide a correct statement to be translated into Lean code.", "This statement is incorrect and cannot be translated to Lean Theorem Prover code. Not every finite group is simple. A simple group is a non-trivial group whose only normal subgroups are the trivial group and the group itself. There exist finite groups that are not simple, such as the symmetric group S4.", "This statement is incorrect and cannot be translated into Lean code. Not every finite group is simple. A simple group is a nontrivial group whose only normal subgroups are the trivial group and the group itself. There are many finite groups that are not simple, such as the symmetric group S_n for n â‰¥ 3 or any non-abelian finite group with a nontrivial center.", "This statement is incorrect, as not every finite group is simple. Please provide a correct statement to translate.", "This statement is incorrect, as not every finite group is simple. Please provide a correct statement for me to translate into Lean Theorem Prover code.", "This statement is incorrect, as not every finite group is simple. Please provide a correct statement to translate.", "This statement is incorrect and cannot be translated to Lean Theorem Prover code. Not every finite group is simple. Only finite groups of prime order are simple, as stated in the earlier examples.", "This statement is incorrect, as not every finite group is simple. A simple group is a nontrivial group whose only normal subgroups are the trivial group and the group itself. There are many examples of finite groups that are not simple, such as the symmetric group Sâ‚ƒ or the dihedral group Dâ‚„. Therefore, I cannot provide a theorem for this statement.", "This statement is incorrect and cannot be proven. Not every finite group is simple. A simple group is a non-trivial group whose only normal subgroups are the trivial group and the group itself. There are many examples of finite groups that are not simple, such as the symmetric group S4 or the dihedral group D4.", "This statement is incorrect and cannot be proven. Not every finite group is simple. For example, the symmetric group S3 is a finite group that is not simple."]}, {"stmt": "Every finite group has prime order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\\n  pâ‚ â‰  pâ‚‚ â†’\\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"}]\n", "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)],\n  p âˆ£ Fintype.card G â†’ âˆƒ x, orderOf x = p :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem âˆ€ {G : Type u_2} [inst : Group G] {Gâ‚‚ : Type u_1} [inst_1 : Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)]\n  [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)],\n  pâ‚ â‰  pâ‚‚ â†’\n    âˆ€ (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [inst_2 : Fintype { x // x âˆˆ Hâ‚ }] [inst_3 : Fintype { x // x âˆˆ Hâ‚‚ }],\n      IsPGroup pâ‚ { x // x âˆˆ Hâ‚ } â†’\n        IsPGroup pâ‚‚ { x // x âˆˆ Hâ‚‚ } â†’ Nat.coprime (Fintype.card { x // x âˆˆ Hâ‚ }) (Fintype.card { x // x âˆˆ Hâ‚‚ }) :=\n\n/-- Every finite group has prime order. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p : â„•, Fact (Nat.Prime p) âˆ§ Fintype.card G = p ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p : â„•, Fact (Nat.Prime p) âˆ§ Fintype.card G = p ", ": âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p [hp : Fact (Nat.Prime p)], Fintype.card G = p ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p : â„•, Fact (Nat.Prime p) âˆ§ Fintype.card G = p ", "This statement is incorrect and cannot be translated into Lean Theorem Prover code since there are finite groups that do not have prime order. For example, a group with four elements has order 4, which is not a prime number.", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p : â„•, Fact (Nat.Prime p) âˆ§ Fintype.card G = p ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p : â„•, Fact (Nat.Prime p) âˆ§ Fintype.card G = p ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±], âˆƒ p : â„•, Fact (Nat.Prime p) âˆ§ Fintype.card Î± = p ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p : â„•, Fact (Nat.Prime p) âˆ§ Fintype.card G = p ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], âˆƒ p : â„•, Fact (Nat.Prime p) âˆ§ Fintype.card G = p "]}, {"stmt": "Every set has Lebesgue measure zero.", "prompts": "[{\"theorem\": \"â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : AffineSubspace â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded s â†’\\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\\n  (s : Set Î±), (âˆ€ (n : â„•), â†‘â†‘Î¼ (s âˆ© MeasureTheory.spanningSets Î¼ n) = 0) â†” â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a Ïƒ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î© : Type u_2} [inst : MeasurableSpace Î©] [inst_1 : TopologicalSpace Î©] [inst_2 : OpensMeasurableSpace Î©]\\n  {Î³ : Type u_1} {F : Filter Î³} {Î¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Î¼s i)) F (nhds 0) â†’ Filter.Tendsto Î¼s F (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"theorem\":\n  \"â†‘â†‘MeasureTheory.volume (â‹ƒ (p : â„) (_ : 2 < p), {x | LiouvilleWith p x}) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\\nmeasure zero. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Real.convergent 0 n = 0\",\n  \"isProp\": true,\n  \"docString\": \"All convergents of `0` are zero. \"}]\n", "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0 :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : AffineSubspace â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded s â†’\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- A set in a Ïƒ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\n  (s : Set Î±), (âˆ€ (n : â„•), â†‘â†‘Î¼ (s âˆ© MeasureTheory.spanningSets Î¼ n) = 0) â†” â†‘â†‘Î¼ s = 0 :=\n\n/-- If the total masses of finite measures tend to zero, then the measures tend to zero. -/\ntheorem âˆ€ {Î© : Type u_2} [inst : MeasurableSpace Î©] [inst_1 : TopologicalSpace Î©] [inst_2 : OpensMeasurableSpace Î©]\n  {Î³ : Type u_1} {F : Filter Î³} {Î¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©},\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Î¼s i)) F (nhds 0) â†’ Filter.Tendsto Î¼s F (nhds 0) :=\n\n/-- The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\nmeasure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume (â‹ƒ (p : â„) (_ : 2 < p), {x | LiouvilleWith p x}) = 0 :=\n\n/-- All convergents of `0` are zero. -/\ntheorem âˆ€ (n : â„•), Real.convergent 0 n = 0 :=\n\n/-- Every set has Lebesgue measure zero. -/\ntheorem", "choices": ["I can't provide a theorem that states \"every set has Lebesgue measure zero\" as it is incorrect. Some sets, like the entire real line or an interval, do not have measure zero. Please provide a different statement or concept you'd like a theorem for.", "forall {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), â†‘â†‘MeasureTheory.volume s = 0 ", "I'm sorry, but that statement is not true.", "âˆ€ (s : Set â„), â†‘â†‘MeasureTheory.volume s = 0 ", "forall {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±), â†‘â†‘Î¼ s = 0 ", "âˆ€ (s : Set â„), â†‘â†‘MeasureTheory.volume s = 0 ", "I cannot produce a theorem stating that every set has Lebesgue measure zero, as this is not true. The Lebesgue measure of a set depends on its size and properties. Some sets may have Lebesgue measure zero, while others may have a positive measure.", "Sorry, I cannot prove that every set has Lebesgue measure zero as it is not a true statement. Lebesgue measure is a measure that assigns a non-negative \"size\" or \"volume\" to subsets of Euclidean space, and there exist sets with non-zero Lebesgue measure.", "We cannot prove this statement, as it contradicts the properties of the Lebesgue measure.", "âˆ€ (s : Set â„), â†‘â†‘MeasureTheory.volume s = 0 "]}, {"stmt": "If a topological space is compact, then every subset is compact.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.NonemptyCompacts Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.NonemptyCompacts Î±) :=\n\n/-- If a topological space is compact, then every subset is compact. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] (s : Set Î±), IsCompact s "]}, {"stmt": "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.", "prompts": "[{\"theorem\": \"â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded s â†’\\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½],\\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\\n  OpensMeasurableSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\\n  (s : Set Î±), (âˆ€ (n : â„•), â†‘â†‘Î¼ (s âˆ© MeasureTheory.spanningSets Î¼ n) = 0) â†” â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a Ïƒ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAddâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant Î½],\\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"}]\n", "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded s â†’\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼) :=\n\n/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½],\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½ :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\n  OpensMeasurableSpace Î± :=\n\n/-- A set in a Ïƒ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\n  (s : Set Î±), (âˆ€ (n : â„•), â†‘â†‘Î¼ (s âˆ© MeasureTheory.spanningSets Î¼ n) = 0) â†” â†‘â†‘Î¼ s = 0 :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : FiniteDimensional â„ E] {s : Set E}\n  {f : E â†’ E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼], DifferentiableOn â„ f s â†’ â†‘â†‘Î¼ s = 0 â†’ â†‘â†‘Î¼ (f '' s) = 0 :=\n\n/-- Left invariant Borel measures on an additive measurable group are unique (up to a scalar). -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAddâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant Î½],\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½ :=\n\n/-- Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  [inst_3 : MeasureTheory.Measure.IsLebesgueMeasure Î±] {s : Set Î±},\n  MeasurableSet s â†’ Â¬ BorelMeasurable s â†’ â†‘â†‘MeasureTheory.volume s = 0 ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : BorelSpace Î±] {s : Set Î±} (Î¼ : MeasureTheory.Measure Î±),\n  MeasurableSet s â†’ Â¬ BorelMeasurableSpace.MeasurableSet' Î± s â†’ â†‘â†‘Î¼ s = 0 ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : BorelSpace Î±] (Î¼ : MeasureTheory.Measure Î±) [inst_2 : MeasureTheory.Measure.IsLebesgueMeasure Î¼]\n  (s : Set Î±), MeasurableSet s â†’ BorelMeasurable s â†’ â†‘â†‘Î¼ s â‰  0 â†’ BorelMeasurable (sá¶œ) â†’ â†‘â†‘Î¼ s = 0 ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±] (s : Set Î±),\n  MeasureTheory.volume s â‰  0 â†’ BorelMeasurable s ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±] {s : Set Î±}\n  (Î¼ : MeasureTheory.Measure Î±), MeasurableSet s â†’ Â¬Borel.Set s â†’ â†‘â†‘Î¼ s = 0 ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\n  {s : Set Î±} (hs : MeasureTheory.LebesgueMeasurable s) (h : Â¬MeasurableSet s),\n  â†‘â†‘MeasureTheory.volume s = 0 ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] (s : Set Î±),\n  MeasureTheory.IsLebesgueMeasurable s âˆ§ Â¬MeasureTheory.IsBorelMeasurable s â†’ MeasureTheory.volume s = 0 ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±),\n  MeasurableSet s â†’ (Â¬ BorelMeasurable s) â†’ â†‘â†‘Î¼ s = 0 ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : OpensMeasurableSpace Î±] (h : BorelSpace Î±) (Î¼ : MeasureTheory.Measure Î±)\n  (s : Set Î±), MeasurableSet s â†’ Â¬ BorelSet s â†’ â†‘â†‘Î¼ s = 0 ", "forall {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Î±] (m : MeasureTheory.Measure Î±) (s : Set Î±),\n  MeasurableSet s â†’ Â¬BorelSpace.isBorel s â†’ â†‘â†‘m s = 0 "]}, {"stmt": "A finitely-presented group containing a torsion element is finite.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A â†’ Algebra.FiniteType R A\",\n  \"isProp\": true,\n  \"docString\": \"A finitely presented algebra is of finite type. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion { x // x âˆˆ N } â†’ AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G â†’ Set.Finite (Set.range fun g => orderOf g) â†’ Monoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\": \"The group exponent exists for any bounded torsion group. \"}]\n", "prompt_cons": "/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- A finitely presented algebra is of finite type. -/\ntheorem âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\n  Algebra.FinitePresentation R A â†’ Algebra.FiniteType R A :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion { x // x âˆˆ N } â†’ AddMonoid.IsTorsion G :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G â†’ Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- The group exponent exists for any bounded torsion group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G],\n  Monoid.IsTorsion G â†’ Set.Finite (Set.range fun g => orderOf g) â†’ Monoid.ExponentExists G :=\n\n/-- A finitely-presented group containing a torsion element is finite. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G], (âˆƒ x : G, x â‰  1 âˆ§ âˆ€ n : â„•, n > 0 â†’ x ^ n = 1 â†’ âˆƒ m : â„•, m < n âˆ§ x ^ m = 1) â†’ Group.FinitePresentation G â†’ Finite G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ Group.FinitePresentation G â†’ Finite G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsFinitelyPresented G â†’ âˆƒ g, orderOf g > 1 â†’ Finite G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ Group.FinitePresentation G â†’ âˆƒ (n : â„•), Fintype.card G = n ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆƒ g, g â‰  1 âˆ§ Monoid.IsTorsion G) â†’ Group.FinitelyPresented G â†’ Finite G ", "âˆ€ {G : Type u_1} [inst : Group G],\n  Group.FinitePresentation G â†’ (âˆƒ g, g â‰  1 âˆ§ âˆƒ n, n > 0 âˆ§ g ^ n = 1) â†’ Finite G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Group.FinitePresentation G],\n  (âˆƒ g, orderOf g â‰  0) â†’ Finite G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ Monoid.HasFiniteTorsionElement G â†’ Group.FinitelyPresented G â†’ Finite G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Group.FinitelyPresented G],\n  Exists (Î» x : G, orderOf x â‰  0 âˆ§ orderOf x â‰  1) â†’ Finite G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ (âˆƒ (x : G), x â‰  1 âˆ§ orderOf x â‰  0) â†’ Group.FinitePresentation G â†’ Finite G "]}, {"stmt": "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ğ•œ E] {s : Set E},\\n  Convex ğ•œ s â†’ Convex ğ•œ (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"}]\n", "prompt_cons": "/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a topological vector space, the closure of a convex set is convex. -/\ntheorem âˆ€ {ğ•œ : Type u_2} {E : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ğ•œ E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ğ•œ E] {s : Set E},\n  Convex ğ•œ s â†’ Convex ğ•œ (closure s) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤ :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : CompleteSpace ğ•œ] (s : Submodule ğ•œ E)\n  [inst_4 : FiniteDimensional ğ•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- If every point of a subset of a topological space is contained in some closed set, the subset itself is closed. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t : Set Î±, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t) â†’ IsClosed s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, (âˆ€ x âˆˆ t, âˆƒ u, IsClosed u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ t âŠ† s â†’ IsClosed t ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, (âˆ€ x âˆˆ t, âˆƒ u, IsClosed u âˆ§ x âˆˆ u âˆ§ u âŠ† s) â†’ t âŠ† s â†’ IsClosed t ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ t, IsClosed t âˆ§ x âˆˆ t âˆ§ t âŠ† s) â†’ IsClosed s "]}, {"stmt": "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X Ã— X$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ Function.Injective f â†’ ClosedEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"theorem\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {Î³ : Type w} [inst_6 : MetricSpace Î³]\\n  {Î¦ : X â†’ Î³} {Î¨ : Y â†’ Î³},\\n  Isometry Î¦ â†’ Isometry Î¨ â†’ GromovHausdorff.ghDist X Y â‰¤ Metric.hausdorffDist (Set.range Î¦) (Set.range Î¨)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\\nof isometric copies of the spaces, in any metric space. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"}]\n", "prompt_cons": "/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- A continuous injective map from a compact space to a Hausdorff space is a closed embedding. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ Function.Injective f â†’ ClosedEmbedding f :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â†‘f â†’ CategoryTheory.IsIso f :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\nof isometric copies of the spaces, in any metric space. -/\ntheorem âˆ€ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {Î³ : Type w} [inst_6 : MetricSpace Î³]\n  {Î¦ : X â†’ Î³} {Î¨ : Y â†’ Î³},\n  Isometry Î¦ â†’ Isometry Î¨ â†’ GromovHausdorff.ghDist X Y â‰¤ Metric.hausdorffDist (Set.range Î¦) (Set.range Î¨) :=\n\n/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- A locally compact Hausdorff space is totally disconnected\nif and only if it is totally separated. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X Ã— X$. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsOpenMap fun (x : Î±) => (x, x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsOpenMap (Î» x : Î±, (x, x)) ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X], T2Space X â†” IsOpenMap (@Prod.mk X X) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsOpenMap (Function.Diagonal Î±) ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X â†” IsOpenMap (prod.diag X) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±], IsOpenMap (Function.Diagonal Î±) â†” T2Space Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsOpenMap fun (x : Î±) => (x, x) ", "âˆ€ {X : Type u} [inst : TopologicalSpace X], T2Space X â†” IsOpenMap (Î» (x : X), (x, x)) ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X], T2Space X â†” IsOpenMap (Î» (x : X), (x, x)) ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X], T2Space X â†” IsOpenMap (Î» x : X, (x, x)) "]}, {"stmt": "Any finite order element in a group is equal to the identity.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"}]\n", "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x) :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- Any finite order element in a group is equal to the identity. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x â†’ orderOf x â‰  0 â†’ x ^ (orderOf x) = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ x ^ orderOf x = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {x : G}, IsOfFinOrder x â†’ x ^ Fintype.card G = 1 ", "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G} (n : â„•), n > 0 â†’ x ^ n = 1 â†’ x ^ orderOf x = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {x : G}, IsOfFinOrder x â†’ x ^ Fintype.card G = 1 ", "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x â†’ x ^ Fintype.card G = 1 ", "âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x â†’ x ^ orderOf x = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ x ^ orderOf x = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ x ^ orderOf x = 1 ", "âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x â†’ âˆƒ n : â„•, 0 < n âˆ§ x ^ n = 1 "]}, {"stmt": "If a subgroup of a group is torsion-free, then the group itself is torsion free.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"}]\n", "prompt_cons": "/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If a subgroup of a group is torsion-free, then the group itself is torsion free. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x âˆˆ H } â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x âˆˆ H } â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }) â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x âˆˆ H } â†’ H : Subgroup G â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x âˆˆ H } â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } â†’ Monoid.IsTorsionFree G ", "forall {G : Type u_1} [inst : Group G], (âˆƒ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }) -> Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x âˆˆ H } â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x âˆˆ H } â†’ Monoid.IsTorsionFree G "]}, {"stmt": "Every injective homomorphism from a finitely generated free group to itself is surjective.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Î¹] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R â†’\\n    âˆ€ (ps : Î¹ â†’ MvPolynomial Î¹ R),\\n      (Function.Injective fun v i => â†‘(MvPolynomial.eval v) (ps i)) â†’\\n        Function.Surjective fun v i => â†‘(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Bijective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"}]\n", "prompt_cons": "/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1) :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem âˆ€ {Î¹ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite Î¹] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R â†’\n    âˆ€ (ps : Î¹ â†’ MvPolynomial Î¹ R),\n      (Function.Injective fun v i => â†‘(MvPolynomial.eval v) (ps i)) â†’\n        Function.Surjective fun v i => â†‘(MvPolynomial.eval v) (ps i) :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f :=\n\n/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â†‘f :=\n\n/-- The ring homomorphism is surjective -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\n  [self : RingHomSurjective Ïƒ], Function.Surjective â†‘Ïƒ :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0) :=\n\n/-- Any injective endomorphism of an Artinian module is bijective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Bijective â†‘f :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Every injective homomorphism from a finitely generated free group to itself is surjective. -/\ntheorem", "choices": ["forall {Î± : Type u} [inst : Group Î±] {n : â„•} (G : FreeGroup Î±) (h : G â†’* G),\n  Fintype.card Î± = n â†’ Function.Injective h â†’ Function.Surjective h ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : FgFree Î±] {f : Î± â†’* Î±},\n  Function.Injective â†‘f â†’ Function.Surjective â†‘f ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : FgFree Î±] {f : Î± â†’* Î±},\n  Function.Injective â†‘f â†’ Function.Surjective â†‘f ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsFinitelyGeneratedFree G] (f : G â†’* G),\n  Function.Injective â†‘f â†’ Function.Surjective â†‘f ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : FgFree G],\n  âˆ€ (f : G â†’* G), Function.Injective â†‘f â†’ Function.Surjective â†‘f ", "âˆ€ {Î¹ : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype Î¹] {f : FreeGroup Î¹ â†’ G},\n  IsGroupHom f â†’ Function.Injective f â†’ Function.Surjective f ", "âˆ€ {Î¹ : Type u} {G : Type v} [inst : Group G] [inst_1 : Fintype Î¹] [inst_2 : FreeGroup G Î¹]\n  (f : G â†’ G) [IsGroupHom f], Function.Injective f â†’ Function.Surjective f ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFinitelyGenerated Î±] (f : Î± â†’* Î±),\n  Function.Injective â†‘f â†’ Function.Surjective â†‘f ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] [inst_2 : Fintype Î±] (f : Î± â†’* Î±),\n  Function.Injective â†‘f â†’ Function.Surjective â†‘f ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {f : G â†’* G}, Function.Injective â†‘f â†’ Function.Surjective â†‘f "]}, {"stmt": "Every division ring is either a field or finite.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€]\\n  [inst_2 : Valued K Î“â‚€], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] [inst_1 : FloorSemiring Î±] (m n : â„•), âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is the floor of field division. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"}]\n", "prompt_cons": "/-- A valued division ring is separated. -/\ntheorem âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€]\n  [inst_2 : Valued K Î“â‚€], SeparatedSpace K :=\n\n/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 âˆˆ S :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 âˆˆ S :=\n\n/-- Natural division is the floor of field division. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] [inst_1 : FloorSemiring Î±] (m n : â„•), âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n :=\n\n/-- The category of rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y :=\n\n/-- Every division ring is either a field or finite. -/\ntheorem", "choices": ["âˆ€ {K : Type u_1} [inst : DivisionRing K], IsField K âˆ¨ Finite K ", "âˆ€ (K : Type u) [inst : DivisionRing K], IsField K âˆ¨ FiniteDimensional K K ", "âˆ€ {K : Type u} [inst : DivisionRing K], IsField K âˆ¨ FiniteDimensional K K ", "âˆ€ {K : Type u} [inst : DivisionRing K], IsField K âˆ¨ Fintype K ", "âˆ€ (K : Type u_1) [inst : DivisionRing K], IsField K âˆ¨ Finite K ", "âˆ€ {K : Type u_1} [inst : DivisionRing K], IsField K âˆ¨ FiniteDimensional â„• K ", "âˆ€ {R : Type u} [inst : DivisionRing R], IsField R âˆ¨ Fintype R ", "âˆ€ {K : Type u_1} [inst : DivisionRing K], IsField K âˆ¨ IsFinite K ", "âˆ€ {K : Type u} [inst : DivisionRing K], IsField K âˆ¨ âˆƒ n : â„•, Fintype.card K = n ", "âˆ€ {K : Type u} [inst : DivisionRing K], IsField K âˆ¨ FiniteDimensional K K "]}, {"stmt": "Every natural number is the product of two primes.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {Î¹ : Type u_1} (s : Finset Î¹)\\n  (f : Î¹ â†’ Ideal R) (e : Î¹ â†’ â„•),\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ Prime (f i)) â†’\\n    (âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ i â‰  j â†’ f i â‰  f j) â†’\\n      (Finset.inf s fun i => f i ^ e i) = Finset.prod s fun i => f i ^ e i\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of distinct prime powers in a Dedekind domain is the product of these\\nprime powers. \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- The intersection of distinct prime powers in a Dedekind domain is the product of these\nprime powers. -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {Î¹ : Type u_1} (s : Finset Î¹)\n  (f : Î¹ â†’ Ideal R) (e : Î¹ â†’ â„•),\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ Prime (f i)) â†’\n    (âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ i â‰  j â†’ f i â‰  f j) â†’\n      (Finset.inf s fun i => f i ^ e i) = Finset.prod s fun i => f i ^ e i :=\n\n/-- Every natural number is the product of two primes. -/\ntheorem", "choices": ["âˆ€ (n : â„•), n > 0 â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q ", "âˆ€ (n : â„•), 2 â‰¤ n â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p * q = n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q ", "âˆ€ (n : â„•), 2 â‰¤ n â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q ", "âˆ€ (n : â„•), n > 0 â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q ", "âˆ€ (n : â„•), n > 0 â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q ", "âˆ€ (n : â„•), 1 < n â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q ", "âˆ€ (n : â„•), n > 0 â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p * q "]}, {"stmt": "Every even number is the square of a natural number.", "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"}]\n", "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- Every even number is the square of a natural number. -/\ntheorem", "choices": ["This statement is incorrect. There is no theorem that states every even number is the square of a natural number.", "This statement is incorrect. An even number can only be the square of a natural number if it is also a perfect square. For example, 6 is an even number but it is not the square of any natural number.", "This statement is incorrect and cannot be proven in Lean. An example that disproves the statement is the number 2, which is an even number but not the square of a natural number.", "âˆ€ {n : â„•}, Even n â†’ âˆƒ m, n = m ^ 2 ", "This statement is incorrect. Not every even number is the square of a natural number.", "âˆ€ {n : â„•}, Even n â†’ âˆƒ m, n = m ^ 2 ", "âˆ€ (n : â„•), Even n â†’ âˆƒ m, n = m ^ 2 ", "âˆ€ (n : â„•), Even n â†’ âˆƒ k, n = 2 * k ^ 2 ", "That statement is incorrect. An even number is not necessarily the square of a natural number. For example, 6 is an even number, but it is not the square of any natural number.", "âˆ€ {n : â„•}, Even n â†’ âˆƒ k : â„•, n = k ^ 2 "]}, {"stmt": "Every normal subgroup of a group has finite index.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type u_1} {s : Set Î¹}, Basis (â†‘s) R M â†’ Module.rank R M < Cardinal.aleph0 â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A â†’ FiniteDimensional K { x // x âˆˆ Submodule.span K A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"{G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ [inst_1 : Subgroup.FiniteIndex H] â†’ Fintype (G â§¸ H)\",\n  \"isProp\": false,\n  \"docString\": \"A finite index subgroup has finite quotient. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n", "prompt_cons": "/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- The additive subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H â‰  0 :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x âˆˆ H } :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- If a module has a finite dimension, all bases are indexed by a finite set. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type u_1} {s : Set Î¹}, Basis (â†‘s) R M â†’ Module.rank R M < Cardinal.aleph0 â†’ Set.Finite s :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- The submodule generated by a finite set is finite-dimensional. -/\ntheorem âˆ€ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\n  Set.Finite A â†’ FiniteDimensional K { x // x âˆˆ Submodule.span K A } :=\n\n/-- A finite index subgroup has finite quotient. -/\ntheorem {G : Type u_1} â†’ [inst : Group G] â†’ (H : Subgroup G) â†’ [inst_1 : Subgroup.FiniteIndex H] â†’ Fintype (G â§¸ H) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- Every normal subgroup of a group has finite index. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H â‰  0 ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H â‰  0 ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H â†’ Subgroup.FiniteIndex H â†’ Fintype.card (G â§¸ H) < Cardinal.aleph0 ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Fintype (G â§¸ H) ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.Normal H â†’ Subgroup.FiniteIndex H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H â‰  0 ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H â†’ Fintype (G â§¸ H) ", "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [self : Subgroup.Normal N], Subgroup.FiniteIndex N ", "âˆ€ {G : Type u_1} [inst : Group G] (N : Subgroup G) [self : Subgroup.Normal N], Subgroup.FiniteIndex N â†’ Fintype (G â§¸ N) "]}, {"stmt": "The characteristic polynomial of every matrix has real roots.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : IsROrC Î±] {A : Matrix n n Î±},\\n  Matrix.IsHermitian A â†’ (fun i => â†‘(â†‘IsROrC.re (Matrix.diag A i))) = Matrix.diag A\",\n  \"isProp\": true,\n  \"docString\":\n  \"The diagonal elements of a complex hermitian matrix are real. \"},\n {\"theorem\":\n  \"âˆ€ {f : Polynomial â„‚}, 0 < Polynomial.degree f â†’ âˆƒ z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"âˆ€ (p : Polynomial â„),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ x â‰  0 â†’ Polynomial.coeff (minpoly A x) 0 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] (a : { x // x âˆˆ selfAdjoint A }) {z : â„‚},\\n  z âˆˆ spectrum â„‚ â†‘a â†’ z = â†‘z.re\",\n  \"isProp\": true,\n  \"docString\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"theorem\":\n  \"âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\\n  âˆƒ n f _hf q, p = â†‘(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x â†’ 0 < Polynomial.degree (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"The degree of a minimal polynomial is positive. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Î±] [inst_2 : One Î±], Matrix.IsDiag 1\",\n  \"isProp\": true,\n  \"docString\": \"Every identity matrix is diagonal. \"}]\n", "prompt_cons": "/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : IsROrC Î±] {A : Matrix n n Î±},\n  Matrix.IsHermitian A â†’ (fun i => â†‘(â†‘IsROrC.re (Matrix.diag A i))) = Matrix.diag A :=\n\n/-- **Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root -/\ntheorem âˆ€ {f : Polynomial â„‚}, 0 < Polynomial.degree f â†’ âˆƒ z, Polynomial.IsRoot f z :=\n\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {T : E â†’â‚—[ğ•œ] E}, LinearMap.IsSymmetric T â†’ âˆ€ {Î¼ : ğ•œ}, Module.End.HasEigenvalue T Î¼ â†’ â†‘(starRingEnd ğ•œ) Î¼ = Î¼ :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ (p : Polynomial â„),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) â‰¤\n    Finset.card (Multiset.toFinset (Polynomial.roots (â†‘Polynomial.derivative p))) + 1 :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ x â‰  0 â†’ Polynomial.coeff (minpoly A x) 0 â‰  0 :=\n\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem âˆ€ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F â„] (p : Polynomial F),\n  Fintype.card â†‘(Polynomial.rootSet p â„) â‰¤ Fintype.card â†‘(Polynomial.rootSet (â†‘Polynomial.derivative p) â„) + 1 :=\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem âˆ€ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule â„‚ A] (a : { x // x âˆˆ selfAdjoint A }) {z : â„‚},\n  z âˆˆ spectrum â„‚ â†‘a â†’ z = â†‘z.re :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\n  âˆƒ n f _hf q, p = â†‘(MvPolynomial.rename f) q :=\n\n/-- The degree of a minimal polynomial is positive. -/\ntheorem âˆ€ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial B], IsIntegral A x â†’ 0 < Polynomial.degree (minpoly A x) :=\n\n/-- Every identity matrix is diagonal. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Î±] [inst_2 : One Î±], Matrix.IsDiag 1 :=\n\n/-- The characteristic polynomial of every matrix has real roots. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : CommRing Î±] [inst_1 : Algebra â„ Î±] [inst_2 : Fintype n] (A : Matrix n n Î±),\n  âˆƒ p : Polynomial â„, p â‰  0 âˆ§ Polynomial.map (algebraMap â„ Î±) p = A.charpoly ", "âˆ€ {n : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : Algebra R â„] (M : Matrix n n R),\n  âˆƒ r : â„, r âˆˆ Polynomial.roots (Matrix.charpoly M) ", "âˆ€ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {Î± : Type u_2} [inst_2 : CommRing Î±] [inst_3 : Algebra Î± â„] (M : Matrix n n Î±),\n  âˆƒ p : Polynomial â„, Polynomial.Monic p âˆ§ Polynomial.evalâ‚‚ (algebraMap Î± â„) M p = 0 ", "âˆ€ {Î± : Type u_1} {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Î±] {A : Matrix n n Î±},\n  âˆ€ {R : Type u_3} [inst_3 : CommRing R] [inst_4 : Algebra R Î±], Fintype.card â†‘(Polynomial.rootSet (Matrix.charpoly A) R) = Fintype.card n ", "âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra A â„] {n : Type u_2} [inst_2 : DecidableEq n] [inst_3 : Fintype n]\n  {M : Matrix n n A}, âˆƒ p : Polynomial A, p = Matrix.charpoly M âˆ§ âˆ€ a : A, Polynomial.IsRoot p a â†’ â†‘a âˆˆ â„ ", "âˆ€ {n : Type u_1} {R : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R] [inst_3 : Algebra R â„] (A : Matrix n n R),\n  Fintype.card (Matrix.rootSet (Matrix.charpoly A) â„) = Fintype.card n ", "âˆ€ {m : Type u_1} [inst : Fintype m] {R : Type u_2} [inst_1 : CommRing R] [inst_2 : Algebra R â„] (M : Matrix m m R),\n  Fintype.card â†‘(Polynomial.rootSet (Matrix.charpoly M) â„) = Fintype.card m ", "âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {n : Type u_2} [inst_1 : DecidableEq n] [inst_2 : Fintype n] {A : Matrix n n ğ•œ},\n  âˆƒ p : Polynomial â„, Polynomial.Monic p âˆ§ Polynomial.Evalâ‚‚ (algebraMap â„ ğ•œ) (Matrix.charpoly A) p = 0 ", "âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : CommRing Î±] [inst_1 : Algebra Î± â„] (A : Matrix n n â„),\n  âˆƒ p : Polynomial Î±, (â†‘p.map (algebraMap Î± â„) = A.charpoly) âˆ§ p.roots = (A.charpoly).roots ", "âˆ€ {Î± : Type u_1} {n : Type u_2} [inst : CommRing Î±] [inst_1 : IsDomain Î±] [inst_2 : ToMatrix Î±] {A : Matrix n n Î±},\n  âˆƒ p : Polynomial â„, Polynomial.map (algebraMap Î± â„) (Matrix.charPoly A) = p âˆ§ âˆ€ z, Polynomial.IsRoot p z â†’ z = z.re "]}, {"stmt": "In a commutative ring, every prime ideal is contained in a unique maximal ideal.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ {I : Ideal R}, IsUnit â†‘I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S â‰¤ nonZeroDivisors R â†’\\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"}]\n", "prompt_cons": "/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R],\n  Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ {I : Ideal R}, IsUnit â†‘I â†’ Submodule.IsPrincipal I :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M :=\n\n/-- The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I :=\n\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\n  [inst_3 : IsLocalization S A],\n  S â‰¤ nonZeroDivisors R â†’\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I :=\n\n/-- In a commutative ring, every prime ideal is contained in a unique maximal ideal. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P],\n  âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M ", "âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M ", "âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R) [hI : Ideal.IsPrime I], âˆƒ! M, Ideal.IsMaximal M âˆ§ I â‰¤ M ", "âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], âˆƒ! (M : Ideal R), Ideal.IsMaximal M âˆ§ P â‰¤ M ", "âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M ", "âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M ", "âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], âˆƒ! (M : Ideal R), Ideal.IsMaximal M âˆ§ P â‰¤ M ", "âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], âˆƒ! (M : Ideal R), Ideal.IsMaximal M âˆ§ P â‰¤ M ", "âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], âˆƒ! M, Ideal.IsMaximal M âˆ§ P â‰¤ M ", "âˆ€ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P],\n  âˆƒ! M : Ideal R, Ideal.IsMaximal M âˆ§ P â‰¤ M "]}, {"stmt": "Every continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"}]\n", "prompt_cons": "/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼ :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i) :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : CompactSpace Î±]\n  (f : Î± â†’ Î²), Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f "]}, {"stmt": "Every uniformly continuous function is bounded above.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î¹ : Sort u_1} [inst : ConditionallyCompleteLattice Î±] [inst_1 : Nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±},\\n  (âˆ€ (x : Î¹), f x â‰¤ c) â†’ iSup f â‰¤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indexed supremum of a function is bounded above by a uniform bound\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded above.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"}]\n", "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K) :=\n\n/-- A continuous function with compact support is bounded above. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddAbove (Set.range f) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\n  IsCompact K â†’ ContinuousOn f K â†’ BddBelow (f '' K) :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem âˆ€ {Î± : Type u_2} {Î¹ : Sort u_1} [inst : ConditionallyCompleteLattice Î±] [inst_1 : Nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±},\n  (âˆ€ (x : Î¹), f x â‰¤ c) â†’ iSup f â‰¤ c :=\n\n/-- A finite set is bounded above. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddAbove s :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderClosedTopology Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Zero Î±] {f : Î² â†’ Î±},\n  Continuous f â†’ HasCompactSupport f â†’ BddBelow (Set.range f) :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f) :=\n\n/-- Every uniformly continuous function is bounded above. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : LinearOrder Î²] [inst_3 : OrderClosedTopology Î²] \n  [inst_4 : TopologicalSpace Î²] [inst_5 : Nonempty Î±] {f : Î± â†’ Î²}, \n  UniformContinuous f â†’ BddAbove (Set.range f) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ BddAbove (Set.range f) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : SemilatticeSup Î²] [inst_2 : Nonempty Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ BddAbove (Set.range f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] [inst_2 : Nonempty Î±] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ BddAbove (Set.range f) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : Nonempty Î±] [inst_3 : BddAbove (Set.range Î²)] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ BddAbove (Set.range f) ", "âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ Metric.Bounded (Set.range f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : PseudoMetricSpace Î±] [inst_1 : LinearOrder Î²] [inst_2 : TopologicalSpace Î²] [inst_3 : OrderClosedTopology Î²]\n  {f : Î± â†’ Î²},\n  UniformContinuous f â†’ Metric.Bounded (Set.range f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : Nonempty Î±] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ BddAbove (Set.range f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : Nonempty Î±] [inst_2 : SemilatticeSup Î²] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ BddAbove (Set.range f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : PseudoMetricSpace Î²] [inst_2 : BoundedSpace Î±] {f : Î± â†’ Î²},\n  UniformContinuous f â†’ BddAbove (Set.range f) "]}, {"stmt": "If every compact subset of a topological space is closed, then the space is compact.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤ :=\n\n/-- If every compact subset of a topological space is closed, then the space is compact. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : âˆ€ (s : Set Î±), IsCompact s â†’ IsClosed s], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (s : Set Î±), IsCompact s â†’ IsClosed s) â†’ CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : âˆ€ K : Set Î±, IsCompact K â†’ IsClosed K], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : âˆ€ {K : Set Î±}, IsCompact K â†’ IsClosed K], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : âˆ€ (s : Set Î±), IsCompact s â†’ IsClosed s],\n  CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : âˆ€ (K : Set Î±), IsCompact K â†’ IsClosed K], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], (âˆ€ (s : Set Î±), IsCompact s â†’ IsClosed s) â†’ CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : âˆ€ {s : Set Î±}, IsCompact s â†’ IsClosed s], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : âˆ€ (K : Set Î±), IsCompact K â†’ IsClosed K], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [h : âˆ€ s : Set Î±, IsCompact s â†’ IsClosed s], CompactSpace Î± "]}, {"stmt": "In a commutative ring, the sum of idempotent elements is idempotent.", "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\":\n  \"âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I â†’ (IsIdempotentElem I â†” âˆƒ e, IsIdempotentElem e âˆ§ I = Submodule.span R {e})\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u} {Î± : Type v} [inst : AddCommMonoid Î²] {s : Finset Î±} (f : Î± â†’ Î²),\\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), â†‘f (a + b) = â†‘f a + â†‘f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] {Î¹ : Type v} [dec_Î¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w}\\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] (s : Finset Î¹) (c : R)\\n  (x : (i : â†‘â†‘s) â†’ M â†‘i), â†‘(DirectSum.mk M s) (c â€¢ x) = c â€¢ â†‘(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"}]\n", "prompt_cons": "/-- Multiplication in a boolean ring is idempotent. -/\ntheorem âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- A finitely generated idempotent ideal is generated by an idempotent element -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\n  Ideal.FG I â†’ (IsIdempotentElem I â†” âˆƒ e, IsIdempotentElem e âˆ§ I = Submodule.span R {e}) :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- Moving to the opposite additive commutative monoid commutes with summing. -/\ntheorem âˆ€ {Î² : Type u} {Î± : Type v} [inst : AddCommMonoid Î²] {s : Finset Î±} (f : Î± â†’ Î²),\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x) :=\n\n/-- By definition, a ring isomorphism preserves the additive structure. -/\ntheorem âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), â†‘f (a + b) = â†‘f a + â†‘f b :=\n\n/-- Scalar multiplication commutes with direct sums. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] {Î¹ : Type v} [dec_Î¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w}\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_2 : (i : Î¹) â†’ Module R (M i)] (s : Finset Î¹) (c : R)\n  (x : (i : â†‘â†‘s) â†’ M â†‘i), â†‘(DirectSum.mk M s) (c â€¢ x) = c â€¢ â†‘(DirectSum.mk M s) x :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- In a commutative ring, the sum of idempotent elements is idempotent. -/\ntheorem", "choices": ["âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) ", "âˆ€ {Î± : Type u_1} [self : CommRing Î±] (x y : Î±), IsIdempotentElem x â†’ IsIdempotentElem y â†’ IsIdempotentElem (x + y) ", "âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) ", "âˆ€ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x â†’ IsIdempotentElem y â†’ IsIdempotentElem (x + y) ", "âˆ€ {R : Type u_1} [inst : CommRing R] (eâ‚ eâ‚‚ : R), IsIdempotentElem eâ‚ â†’ IsIdempotentElem eâ‚‚ â†’ IsIdempotentElem (eâ‚ + eâ‚‚) ", "âˆ€ {R : Type u_1} [inst : CommRing R] (eâ‚ eâ‚‚ : R), IsIdempotentElem eâ‚ â†’ IsIdempotentElem eâ‚‚ â†’ IsIdempotentElem (eâ‚ + eâ‚‚) ", "âˆ€ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x â†’ IsIdempotentElem y â†’ IsIdempotentElem (x + y) ", "âˆ€ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x â†’ IsIdempotentElem y â†’ IsIdempotentElem (x + y) ", "âˆ€ {R : Type u_1} [self : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) ", "âˆ€ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a â†’ IsIdempotentElem b â†’ IsIdempotentElem (a + b) "]}, {"stmt": "The number of partitions of a finite set is a prime number.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"}]\n", "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The number of partitions of a finite set is a prime number. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card (Partition Î±) = p â†’ IsPrime p ", "âˆ€ {Î± : Type u} [inst : Fintype Î±] {p : â„•} [Fact (Nat.Prime p)], Fintype.card {s : Set Î±} â†’ IsPrimePow (Set.card s) ", "âˆ€ {Î± : Type u} [inst : Fintype Î±], Nat.Prime (Part.card (Set Î±)) ", "âˆ€ {Î± : Type u} [inst : Fintype Î±] {p : â„•}, (Set.Finite {a | a âŠ† (Set.univ : Set Î±)}) â†’ Nat.Prime (Fintype.card {a | a âŠ† (Set.univ : Set Î±)}) â†’ IsPrimePow (Fintype.card {a | a âŠ† (Set.univ : Set Î±)}) ", "âˆ€ {Î± : Type u} [inst : Fintype Î±], IsPrime (Partitions Î±).card ", "âˆ€ {Î± : Type u} [inst : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card (Partition Î±) = p ", "âˆ€ {Î± : Type u} [inst : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card (Set Î±) = p â†’ IsPrime (Fintype.card (Set (Set Î±))) ", "âˆ€ {Î± : Type u} [inst : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card (Partition Î±) = p â†’ Prime (Fintype.card (Partition Î±)) ", "âˆ€ {Î± : Type u} [inst : Fintype Î±], IsPrime (Fintype.card (SetPart Î±)) ", "âˆ€ {Î± : Type u} [inst : Fintype Î±], Nat.Prime (partitions Î±) "]}, {"stmt": "If a poset has a maximal element, then it has a unique minimal element.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {L : List (Î± Ã— Bool)} [inst : DecidableEq Î±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ a â‰¤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsGreatest s a â†’ sSup s = a\",\n  \"isProp\": true,\n  \"docString\": \"A greatest element of a set is the supremum of this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\\n  FreeAddGroup.Red Lâ‚ Lâ‚‚ â†’ FreeAddGroup.reduce Lâ‚ = FreeAddGroup.reduce Lâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : { x // x âˆˆ nonZeroDivisors (Ideal S) }),\\n  âˆƒ b, b âˆˆ â†‘I âˆ§ b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â†‘abv (â†‘(Algebra.norm R) c) < â†‘abv (â†‘(Algebra.norm R) b) â†’ c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\\n  FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚ â†’ FreeGroup.mk Lâ‚ = FreeGroup.mk Lâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words have a common maximal reduction, then they correspond to the same element in the\\nfree group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\\n  FreeGroup.Red Lâ‚ Lâ‚‚ â†’ FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\\n  FreeGroup.mk Lâ‚ = FreeGroup.mk Lâ‚‚ â†’ FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends\\nan element of the free group to its maximal reduction is well-defined. \"}]\n", "prompt_cons": "/-- A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem âˆ€ {Î± : Type u} {L : List (Î± Ã— Bool)} [inst : DecidableEq Î±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L :=\n\n/-- Any element of a set is less than the set supremum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ a â‰¤ sSup s :=\n\n/-- A greatest element of a set is the supremum of this set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsGreatest s a â†’ sSup s = a :=\n\n/-- A least element of a set is the infimum of this set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ sInf s = a :=\n\n/-- **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m :=\n\n/-- If a word reduces to another word, then they have a common maximal reduction. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\n  FreeAddGroup.Red Lâ‚ Lâ‚‚ â†’ FreeAddGroup.reduce Lâ‚ = FreeAddGroup.reduce Lâ‚‚ :=\n\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : { x // x âˆˆ nonZeroDivisors (Ideal S) }),\n  âˆƒ b, b âˆˆ â†‘I âˆ§ b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â†‘abv (â†‘(Algebra.norm R) c) < â†‘abv (â†‘(Algebra.norm R) b) â†’ c = 0 :=\n\n/-- If two words have a common maximal reduction, then they correspond to the same element in the\nfree group. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\n  FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚ â†’ FreeGroup.mk Lâ‚ = FreeGroup.mk Lâ‚‚ :=\n\n/-- If a word reduces to another word, then they have a common maximal reduction. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\n  FreeGroup.Red Lâ‚ Lâ‚‚ â†’ FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚ :=\n\n/-- If two words correspond to the same element in the free group, then they\nhave a common maximal reduction. This is the proof that the function that sends\nan element of the free group to its maximal reduction is well-defined. -/\ntheorem âˆ€ {Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [inst : DecidableEq Î±],\n  FreeGroup.mk Lâ‚ = FreeGroup.mk Lâ‚‚ â†’ FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚ :=\n\n/-- If a poset has a maximal element, then it has a unique minimal element. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] (a : Î±) (H : âˆ€ b, a â‰¤ b â†’ b â‰¤ a),\n  âˆƒ! c, (âˆ€ d, c â‰¤ d) âˆ§ (âˆ€ d, d â‰¤ c â†’ c = d) ", "âˆ€ {Î± : Type u_1} [self : PartialOrder Î±] (s : Set Î±),\n  (âˆƒ m, IsMaximal s m) â†’ âˆƒ! m, IsMinimal s m ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {a : Î±}, (âˆƒ m, âˆ€ (x : Î±), x â‰¤ m) â†’ (âˆ€ (x y : Î±), x â‰¤ y âˆ¨ y â‰¤ x) â†’ âˆƒ! a, âˆ€ (x : Î±), x â‰¤ a ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {a : Î±}, IsMaximal a â†’ âˆƒ! b, IsMinimal b ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (a b : Î±), r a b âˆ¨ r b a) â†’\n  (âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m) â†’\n    (âˆƒ! m, âˆ€ (a : Î±), r a m â†’ r m a) ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : IsStrictTotalOrder Î± r],\n  (âˆƒ max, âˆ€ a, r a max) â†’ âˆƒ! min, âˆ€ a, r min a ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {s : Set Î±},\n  (âˆƒ m, âˆ€ (x : Î±), x âˆˆ s â†’ x â‰¤ m) â†’\n  (âˆƒ! a, a âˆˆ s âˆ§ âˆ€ (x : Î±), x âˆˆ s â†’ a â‰¤ x) ", "âˆ€ {Î± : Type u_1} [self : PartialOrder Î±], (âˆƒ m, âˆ€ (a : Î±), a â‰¤ m) â†’ Unique {a : Î± // âˆ€ (b : Î±), b â‰¤ a} ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] (p : Î± â†’ Prop),\n  (âˆƒ m, p m âˆ§ âˆ€ (a : Î±), p a â†’ a â‰¤ m) â†’\n  (âˆƒ! m, p m âˆ§ âˆ€ (a : Î±), p a â†’ m â‰¤ a) ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {a : Î±},\n  (âˆ€ (b : Î±), a â‰¤ b â†’ b = a) â†’ (âˆƒ! m : Î±, âˆ€ (b : Î±), m â‰¤ b) "]}, {"stmt": "The automorphism group of an Abelian group is cyclic.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `â„¤` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive Gáµƒáµ’áµ– G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"}]\n", "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- Every subgroup of `â„¤` is cyclic. -/\ntheorem âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a} :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- The right regular action of an additive group on itself is transitive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive Gáµƒáµ’áµ– G :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- The automorphism group of an Abelian group is cyclic. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : CommGroup G], IsCyclic (Aut G) ", "âˆ€ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G], IsAddCyclic (AddAut G) ", "âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : Fintype (Aut G)], IsCyclic (Aut G) ", "âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : Fintype G], IsCyclic (Aut G) ", "âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : Fintype G], IsCyclic (Aut G) ", "âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : Fintype G], IsCyclic (Aut G) ", "âˆ€ {Î± : Type u} [inst : CommGroup Î±], IsCyclic (Aut Î±) ", "âˆ€ {G : Type u_1} [inst : CommGroup G], IsCyclic (Aut G) ", "âˆ€ {G : Type u_1} [inst : AddCommGroup G] [h : Fintype (Additive G)], IsAddCyclic (AddAut G) ", "âˆ€ {G : Type u_1} [inst : CommGroup G] [inst_1 : Fintype G], IsCyclic (Aut G) "]}, {"stmt": "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\":\n  \"âˆ€ {f : Ordinal.{u} â†’ Ordinal.{u}}, Ordinal.IsNormal f â†’ Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The fixed point lemma for normal functions: any normal function has an unbounded set of\\nfixed points. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\\n  Continuous f â†’ IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ IsCompact (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function has compact range. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x : Î±), âˆƒ y, y âˆˆ Set.Ico 0 c âˆ§ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y âˆˆ Ico 0 c` such that `f x = f y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x a : Î±), âˆƒ y, y âˆˆ Set.Ico a (a + c) âˆ§ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y âˆˆ Ico a (a + c)` such that `f x = f y`. \"}]\n", "prompt_cons": "/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x :=\n\n/-- The fixed point lemma for normal functions: any normal function has an unbounded set of\nfixed points. -/\ntheorem âˆ€ {f : Ordinal.{u} â†’ Ordinal.{u}}, Ordinal.IsNormal f â†’ Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f) :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\n  Continuous f â†’ IsClosed (Function.fixedPoints f) :=\n\n/-- A continuous, periodic function has compact range. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : â„ â†’ Î±} {c : â„},\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ IsCompact (Set.range f) :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y âˆˆ Ico 0 c` such that `f x = f y`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x : Î±), âˆƒ y, y âˆˆ Set.Ico 0 c âˆ§ f x = f y :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Metric.Bounded (Set.range f) :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y âˆˆ Ico a (a + c)` such that `f x = f y`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x a : Î±), âˆƒ y, y âˆˆ Set.Ico a (a + c) âˆ§ f x = f y :=\n\n/-- If a function from the unit interval to itself has a fixed point, then it has points of all positive periods. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : BoundedOrder Î±] {f : Î± â†’ Î±} {x : Î±},\n  x âˆˆ Set.Icc (BoundedOrder.min Î±) (BoundedOrder.max Î±) â†’ Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hf : 0 < Set.card (Function.fixedPoints f)),\n  Function.IsFixedPt f x â†’ âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ y, Function.IsPeriodicPt f n y ", "âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hf : Function.IsFixedPt f x) (n : â„•),\n  0 < n â†’ Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), 0 < n â†’ Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), 0 < n â†’ Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hx : Function.IsFixedPt f x) (n : â„•) (hn : 0 < n),\n  âˆƒ y, Function.IsPeriodicPt f n y ", "âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, (0 < Î± â†’ Function.IsFixedPt f x) â†’ âˆ€ (n : â„•), (0 < n) â†’ âˆƒ y, Function.IsPeriodicPt f n y ", "âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (h : Function.IsFixedPt f x) (n : â„•),\n  0 < n â†’ Function.IsPeriodicPt f n x "]}, {"stmt": "The complement of the union of two sets contains the union of their complements.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), frontier sá¶œ = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded s â†’ Metric.Bounded t â†’ Metric.Bounded (s âˆª t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Î±} {p : ENNReal} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup E] {s t : Set Î±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hÎ¼s : â†‘â†‘Î¼ s â‰  âŠ¤)\\n  (hÎ¼t : â†‘â†‘Î¼ t â‰  âŠ¤),\\n  s âˆ© t = âˆ… â†’\\n    âˆ€ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s âˆª t)) (_ : â†‘â†‘Î¼ (s âˆª t) â‰  âŠ¤) c =\\n        MeasureTheory.indicatorConstLp p hs hÎ¼s c + MeasureTheory.indicatorConstLp p ht hÎ¼t c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded (s âˆª t) â†” Metric.Bounded s âˆ§ Metric.Bounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} (S T : Set Î±), Cardinal.mk â†‘(S âˆª T) â‰¤ Cardinal.mk â†‘S + Cardinal.mk â†‘T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type ua} {Î² : Type ub} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {a : Set (Î± Ã— Î±)},\\n  a âˆˆ uniformity Î± â†’\\n    âˆ€ {b : Set (Î² Ã— Î²)},\\n      b âˆˆ uniformity Î² â†’\\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a âˆª (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b âˆˆ\\n          UniformSpace.Core.sum.uniformity\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\\nof the diagonal. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s âˆª t) = affineSpan k s âŠ” affineSpan k t\",\n  \"isProp\": true,\n  \"docString\": \"The span of a union of sets is the sup of their spans. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : SemilatticeSup Î³] {s t : Set Î³}, BddAbove (s âˆª t) â†” BddAbove s âˆ§ BddAbove t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"}]\n", "prompt_cons": "/-- The complement of a closed set is an open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ :=\n\n/-- The complement of a set has the same frontier as the original set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), frontier sá¶œ = frontier s :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded s â†’ Metric.Bounded t â†’ Metric.Bounded (s âˆª t) :=\n\n/-- The indicator of a disjoint union of two sets is the sum of the indicators of the sets. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Î±} {p : ENNReal} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup E] {s t : Set Î±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hÎ¼s : â†‘â†‘Î¼ s â‰  âŠ¤)\n  (hÎ¼t : â†‘â†‘Î¼ t â‰  âŠ¤),\n  s âˆ© t = âˆ… â†’\n    âˆ€ (c : E),\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s âˆª t)) (_ : â†‘â†‘Î¼ (s âˆª t) â‰  âŠ¤) c =\n        MeasureTheory.indicatorConstLp p hs hÎ¼s c + MeasureTheory.indicatorConstLp p ht hÎ¼t c :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded (s âˆª t) â†” Metric.Bounded s âˆ§ Metric.Bounded t :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± âŠ• Î²) :=\n\n/-- The cardinality of a union is at most the sum of the cardinalities\nof the two sets. -/\ntheorem âˆ€ {Î± : Type u} (S T : Set Î±), Cardinal.mk â†‘(S âˆª T) â‰¤ Cardinal.mk â†‘S + Cardinal.mk â†‘T :=\n\n/-- The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\nof the diagonal. -/\ntheorem âˆ€ {Î± : Type ua} {Î² : Type ub} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {a : Set (Î± Ã— Î±)},\n  a âˆˆ uniformity Î± â†’\n    âˆ€ {b : Set (Î² Ã— Î²)},\n      b âˆˆ uniformity Î² â†’\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a âˆª (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b âˆˆ\n          UniformSpace.Core.sum.uniformity :=\n\n/-- The span of a union of sets is the sup of their spans. -/\ntheorem âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s âˆª t) = affineSpan k s âŠ” affineSpan k t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem âˆ€ {Î³ : Type w} [inst : SemilatticeSup Î³] {s t : Set Î³}, BddAbove (s âˆª t) â†” BddAbove s âˆ§ BddAbove t :=\n\n/-- The complement of the union of two sets contains the union of their complements. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ‡ sá¶œ âˆª tá¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ‡ sá¶œ âˆª tá¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ âŠ† (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆª tá¶œ âŠ† (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ âŠ† sá¶œ âˆª tá¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆª tá¶œ âŠ† (s âˆª t)á¶œ "]}, {"stmt": "The square root of an rational number is rational.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\": \"âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"}]\n", "prompt_cons": "/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2} :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : LinearOrderedField ğ•œ] [inst_1 : TopologicalSpace ğ•œ] [inst_2 : OrderTopology ğ•œ]\n  [inst_3 : Archimedean ğ•œ], DenseRange Rat.cast :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–â†‘Ï† xâ€– = 1) â†’ âˆƒ n x_1, x ^ n = 1 :=\n\n/-- The square root of an rational number is rational. -/\ntheorem", "choices": ["âˆ€ (q : â„š), âˆƒ p : â„š, p * p = q â†’ Real.sqrt â†‘q = â†‘p ", "âˆ€ (x : â„š), âˆƒ y, Real.sqrt (x.cast â„) = y.cast â„ ", "âˆ€ (q : â„š), âˆƒ r, Real.sqrt q = â†‘r ", "âˆ€ (q : â„š), âˆƒ r, Real.sqrt q = â†‘r ", "âˆ€ (q : â„š), âˆƒ r : â„š, r * r = q ", "âˆ€ (q : â„š), âˆƒ r, Real.sqrt q = â†‘r ", "âˆ€ (q : â„š), âˆƒ r : â„š, r ^ 2 = q ", "âˆ€ (q : â„š), âˆƒ r, Real.sqrt q = â†‘r ", "âˆ€ (q : â„š), âˆƒ r : â„š, (q = 0 âˆ§ r = 0) âˆ¨ (0 â‰¤ q âˆ§ Real.sqrt (q : â„) = r) ", "âˆ€ (q : â„š), âˆƒ r, Real.sqrt (Rat.cast q) = Rat.cast r "]}, {"stmt": "If a module over a ring is free, then the ring is commutative.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V â†” Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} (R : Type u) [inst : Semiring R] (M : Î¹ â†’ Type u_2) [inst_1 : Finite Î¹]\\n  [inst_2 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_3 : (i : Î¹) â†’ Module R (M i)]\\n  [inst_4 : âˆ€ (i : Î¹), Module.Free R (M i)], Module.Free R ((i : Î¹) â†’ M i)\",\n  \"isProp\": true,\n  \"docString\": \"The product of finitely many free modules is free. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\",\n  \"isProp\": true,\n  \"docString\": \"Modules over the trivial ring are Noetherian. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module with a finite ring of scalars is additively torsion. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  Nonempty (M â‰ƒâ‚—[R] N) â†” FiniteDimensional.finrank R M = FiniteDimensional.finrank R N\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.FG âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The category of modules has enough projectives, since every module is a quotient of a free\\nmodule. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Submodule K V), IsAtom W â†” âˆƒ v x, W = Submodule.span K {v}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The atoms of the lattice of submodules of a module over a division ring are the\\nsubmodules equal to the span of a nonzero element of the module. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M â§¸ Submodule.torsion R M) = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"}]\n", "prompt_cons": "/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsNoetherian K V â†” Module.Finite K V :=\n\n/-- The product of finitely many free modules is free. -/\ntheorem âˆ€ {Î¹ : Type u_1} (R : Type u) [inst : Semiring R] (M : Î¹ â†’ Type u_2) [inst_1 : Finite Î¹]\n  [inst_2 : (i : Î¹) â†’ AddCommMonoid (M i)] [inst_3 : (i : Î¹) â†’ Module R (M i)]\n  [inst_4 : âˆ€ (i : Î¹), Module.Free R (M i)], Module.Free R ((i : Î¹) â†’ M i) :=\n\n/-- The lattice of submodules of a module over a division ring is atomistic. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsAtomistic (Submodule K V) :=\n\n/-- Modules over the trivial ring are Noetherian. -/\ntheorem âˆ€ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M], IsNoetherian R M :=\n\n/-- A module with a finite ring of scalars is additively torsion. -/\ntheorem âˆ€ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\n  AddMonoid.IsTorsion M :=\n\n/-- Two finite and free modules are isomorphic if and only if they have the same (finite) rank. -/\ntheorem âˆ€ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\n  Nonempty (M â‰ƒâ‚—[R] N) â†” FiniteDimensional.finrank R M = FiniteDimensional.finrank R N :=\n\n/-- A module over a semiring is `Finite` if it is finitely generated as a module. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [self : Module.Finite R M], Submodule.FG âŠ¤ :=\n\n/-- The category of modules has enough projectives, since every module is a quotient of a free\nmodule. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R) :=\n\n/-- The atoms of the lattice of submodules of a module over a division ring are the\nsubmodules equal to the span of a nonzero element of the module. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Submodule K V), IsAtom W â†” âˆƒ v x, W = Submodule.span K {v} :=\n\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Submodule.torsion R (M â§¸ Submodule.torsion R M) = âŠ¥ :=\n\n/-- If a module over a ring is free, then the ring is commutative. -/\ntheorem", "choices": ["âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R Add.add ", "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [self : Module.Free R M],\n  IsCommutative R (*) ", "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) "]}, {"stmt": "If the set of units of a ring forms a group then the ring is commutative.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom fun a => (f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [inst : NonUnitalNonAssocSemiring Î±]\\n  [inst_1 : NonUnitalNonAssocSemiring Î²] [inst_2 : NonUnitalNonAssocSemiring Î³] {Î´ : Type u_1}\\n  {x : NonUnitalNonAssocSemiring Î´} (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) (h : Î³ â†’â‚™+* Î´),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"}]\n", "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a :=\n\n/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom fun a => (f a)â»Â¹ :=\n\n/-- Fields are commutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x :=\n\n/-- Composition of non-unital ring homomorphisms is associative. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [inst : NonUnitalNonAssocSemiring Î±]\n  [inst_1 : NonUnitalNonAssocSemiring Î²] [inst_2 : NonUnitalNonAssocSemiring Î³] {Î´ : Type u_1}\n  {x : NonUnitalNonAssocSemiring Î´} (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) (h : Î³ â†’â‚™+* Î´),\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- If the set of units of a ring forms a group then the ring is commutative. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : Ring R],\n  (âˆ€ (x y : R), IsUnit x â†’ IsUnit y â†’ IsUnit (x * y)) â†’ (âˆ€ (x y : R), x * y = y * x) ", "âˆ€ {R : Type u} [inst : Ring R] [self : Group (Units R)], âˆ€ (x y : R), x * y = y * x ", "âˆ€ {R : Type u} [inst : Ring R] [inst_1 : Group (Unit R)], IsCommutative R (*) ", "âˆ€ {Î± : Type u_1} [inst : Ring Î±] [inst_1 : IsGroup (Î±)Ë£], (âˆ€ (x y : Î±), x * y = y * x) ", "âˆ€ {R : Type u} [inst : Ring R], IsGroup (Units R) â†’ âˆ€ (x y : R), x * y = y * x ", "âˆ€ {R : Type u} [inst : Semiring R] [inst_1 : Group (Units R)], IsCommutative R (*) ", "âˆ€ {R : Type u} [inst : Ring R] [inst_1 : IsGroup (Units R)], âˆ€ (x y : R), x * y = y * x ", "âˆ€ {R : Type u} [inst : Ring R], (âˆ€ (a b : R), IsUnit a â†’ IsUnit b â†’ a * b = b * a) â†’ âˆ€ (x y : R), x * y = y * x ", "âˆ€ {R : Type u} [inst : Ring R], IsGroup (Units R) â†’ âˆ€ (x y : R), x * y = y * x ", "âˆ€ {R : Type u} [inst : Ring R], (âˆ€ (x : R), IsGroupHom (Ring.units x)) â†’ âˆ€ (x y : R), x * y = y * x "]}, {"stmt": "Every natural number larger than `10` is the sum of a square and a prime.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1 :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem âˆ€ {n : â„•}, (âˆƒ x y, n = x ^ 2 + y ^ 2) â†” âˆ€ {q : â„•}, Nat.Prime q â†’ q % 4 = 3 â†’ Even (padicValNat q n) :=\n\n/-- Every natural number larger than `10` is the sum of a square and a prime. -/\ntheorem", "choices": ["âˆ€ (n : â„•), n > 10 â†’ âˆƒ x p, n = x ^ 2 + p âˆ§ Nat.Prime p ", "âˆ€ (n : â„•), 10 < n â†’ âˆƒ x y, n = x ^ 2 + y âˆ§ Nat.Prime y ", "âˆ€ (n : â„•), n > 10 â†’ âˆƒ x y p, n = x ^ 2 + p âˆ§ Nat.Prime p ", "âˆ€ (n : â„•), n > 10 â†’ âˆƒ x p, n = x ^ 2 + p âˆ§ Nat.Prime p ", "âˆ€ (n : â„•), n > 10 â†’ âˆƒ x p, n = x ^ 2 + p âˆ§ Nat.Prime p ", "âˆ€ (n : â„•), n > 10 â†’ âˆƒ x p, n = x ^ 2 + p âˆ§ Nat.Prime p ", "âˆ€ (n : â„•), n > 10 â†’ âˆƒ x p, n = x ^ 2 + p âˆ§ Nat.Prime p ", "âˆ€ (n : â„•), n > 10 â†’ âˆƒ x y, n = x ^ 2 + y âˆ§ Nat.Prime y ", "âˆ€ (n : â„•), n > 10 â†’ âˆƒ x y, n = x ^ 2 + y âˆ§ Nat.Prime y ", "âˆ€ (n : â„•), n > 10 â†’ âˆƒ x y, n = x ^ 2 + y âˆ§ Nat.Prime y "]}, {"stmt": "The initial object of a category is isomorphic to its terminal object.", "prompts": "[{\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (Y âŸ¶ X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f g : Y âŸ¶ X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (X âŸ¶ Y)],\\n  CategoryTheory.Limits.HasInitial C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has an initial object by specifying the object,\\nand showing there is a unique morphism from it to any other object. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F â†’ CategoryTheory.Skeletal D\",\n  \"isProp\": true,\n  \"docString\": \"The category `D` has isomorphic objects equal \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is mono. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (âŠ¤_ C)) â†’ CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\\n  CategoryTheory.Limits.IsTerminal T â†’\\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) â†’ CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X â†’ âˆ€ (f g : X âŸ¶ Y), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms from an initial object are equal. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"}]\n", "prompt_cons": "/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (Y âŸ¶ X)],\n  CategoryTheory.Limits.HasTerminal C :=\n\n/-- Any two morphisms to a terminal object are equal. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f g : Y âŸ¶ X), f = g :=\n\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (X âŸ¶ Y)],\n  CategoryTheory.Limits.HasInitial C :=\n\n/-- The subcategory of subterminal objects is an exponential ideal. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C) :=\n\n/-- The category `D` has isomorphic objects equal -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category D]\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F â†’ CategoryTheory.Skeletal D :=\n\n/-- Any morphism from a terminal object is mono. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.Mono f :=\n\n/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (âŠ¤_ C)) â†’ CategoryTheory.Limits.InitialMonoClass C :=\n\n/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\n  CategoryTheory.Limits.IsTerminal T â†’\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) â†’ CategoryTheory.Limits.InitialMonoClass C :=\n\n/-- Any two morphisms from an initial object are equal. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X â†’ âˆ€ (f g : X âŸ¶ Y), f = g :=\n\n/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- The initial object of a category is isomorphic to its terminal object. -/\ntheorem", "choices": ["âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], âŠ¥_ C â‰… âŠ¤_ C ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], (âŠ¥_ C) â‰… (âŠ¤_ C) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (âŠ¥_ C â‰… âŠ¤_ C) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (âŠ¥_ C) (âŠ¤_ C) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (âŠ¥_ C â‰… âŠ¤_ C) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (âŠ¥_ C â‰… âŠ¤_ C) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.Initial.obj â‰… CategoryTheory.Limits.Terminal.obj ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (âŠ¥_ C â‰… âŠ¤_ C) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], I â‰… âŠ¤_ C ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (âŠ¥_ C â‰… âŠ¤_ C) "]}, {"stmt": "If the composition of two functions is continuous, then each of them is continuous.", "prompts": "[{\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'}\\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\\n  BddAbove (Set.range fun x => â€–g xâ€–) â†’ MeasureTheory.Integrable f â†’ Continuous g â†’ Continuous (convolution f g L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The convolution is continuous if one function is integrable and the other is bounded and\\ncontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²},\\n  s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î³ â†’ Î±} {s : Set Î³},\\n  s âŠ† f â»Â¹' e.source â†’ (ContinuousOn f s â†” ContinuousOn (â†‘e âˆ˜ f) s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the left is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\\n  {f g : X â†’ Y},\\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î³ â†’ Î±},\\n  f â»Â¹' e.source = Set.univ â†’ (Continuous f â†” Continuous (â†‘e âˆ˜ f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous if and only if its composition with a local homeomorphism\\non the left is continuous and its image is contained in the source. \"}]\n", "prompt_cons": "/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae Î¼] g â†’ Continuous f â†’ Continuous g â†’ f = g :=\n\n/-- The convolution is continuous if one function is integrable and the other is bounded and\ncontinuous. -/\ntheorem âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'}\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\n  BddAbove (Set.range fun x => â€–g xâ€–) â†’ MeasureTheory.Integrable f â†’ Continuous g â†’ Continuous (convolution f g L) :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²},\n  s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s)) :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : T2Space Î±] {s : Set Î²},\n  Dense s â†’ âˆ€ {f g : Î² â†’ Î±}, Continuous f â†’ Continuous g â†’ Set.EqOn f g s â†’ f = g :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i) :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the left is continuous on the corresponding set. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î³ â†’ Î±} {s : Set Î³},\n  s âŠ† f â»Â¹' e.source â†’ (ContinuousOn f s â†” ContinuousOn (â†‘e âˆ˜ f) s) :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {Î¼ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Î¼] {U : Set X}\n  {f g : X â†’ Y},\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ U)] g â†’\n    IsOpen U â†’ ContinuousOn f U â†’ ContinuousOn g U â†’ Set.EqOn f g U :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A function is continuous if and only if its composition with a local homeomorphism\non the left is continuous and its image is contained in the source. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {f : Î³ â†’ Î±},\n  f â»Â¹' e.source = Set.univ â†’ (Continuous f â†” Continuous (â†‘e âˆ˜ f)) :=\n\n/-- If the composition of two functions is continuous, then each of them is continuous. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²},\n  Continuous (g âˆ˜ f) â†’ Continuous f â†’ Continuous g ", "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, Continuous (g âˆ˜ f) â†’ Continuous f â†’ Continuous g ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  Continuous (g âˆ˜ f) â†’ Continuous f â†’ Continuous g ", "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, Continuous (g âˆ˜ f) â†’ Continuous f â†’ Continuous g ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²},\n  Continuous (g âˆ˜ f) â†’ Continuous f âˆ§ Continuous g ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³}, Continuous (g âˆ˜ f) â†’ Continuous f âˆ§ Continuous g ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  Continuous (g âˆ˜ f) â†’ Continuous f â†’ Continuous g ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³}, Continuous (g âˆ˜ f) â†’ Continuous f â†’ Continuous g ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, Continuous (g âˆ˜ f) â†’ Continuous f â†’ Continuous g ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : TopologicalSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, Continuous (g âˆ˜ f) â†’ Continuous f â†’ Continuous g "]}, {"stmt": "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.", "prompts": "[{\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a b : M} {c : R}, c â€¢ a < c â€¢ b â†’ 0 < c â†’ a < b\",\n  \"isProp\": true,\n  \"docString\": \"If `c â€¢ a < c â€¢ b` for some positive `c`, then `a < b`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"}]\n", "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- If `c â€¢ a < c â€¢ b` for some positive `c`, then `a < b`. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\n  [self : OrderedSMul R M] {a b : M} {c : R}, c â€¢ a < c â€¢ b â†’ 0 < c â†’ a < b :=\n\n/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [self : IsDirected Î± r] (a b : Î±), âˆƒ c, r a c âˆ§ r b c :=\n\n/-- If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`. -/\ntheorem", "choices": ["âˆ€ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ", "âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ", "âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ", "âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ", "forall {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ", "âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ", "âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ", "âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ", "âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c ", "âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute b c â†’ Commute a c "]}, {"stmt": "If an element maps to zero under a ring homomorphism, then it is zero.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²), â†‘f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map zero to zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R â‰ƒ+* S), â†‘f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q),\\n  (âˆ€ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 â†’ a = 0) â†’\\n    CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²}, IsAddGroupHom f â†’ f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q),\\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) â†’\\n    âˆ€ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 â†’ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that is injective on pseudoelements only maps the zero element to zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r âˆˆ RingHom.ker f â†” â†‘f r = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0\",\n  \"isProp\": true,\n  \"docString\": \"The zero morphism maps every pseudoelement to 0. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] [inst_2 : Norm Râ‚] [inst_3 : Norm Râ‚‚]\\n  {Ïƒ : Râ‚ â†’+* Râ‚‚} [self : RingHomIsometric Ïƒ] {x : Râ‚}, â€–â†‘Ïƒ xâ€– = â€–xâ€–\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"}]\n", "prompt_cons": "/-- Ring homomorphisms map zero to zero. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²), â†‘f 0 = 0 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R â‰ƒ+* S), â†‘f 0 = 0 :=\n\n/-- A morphism that only maps the zero pseudoelement to zero is a monomorphism. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q),\n  (âˆ€ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 â†’ a = 0) â†’\n    CategoryTheory.Mono f :=\n\n/-- An additive group homomorphism sends 0 to 0. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²}, IsAddGroupHom f â†’ f 0 = 0 :=\n\n/-- A morphism that is injective on pseudoelements only maps the zero element to zero. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q),\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) â†’\n    âˆ€ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 â†’ a = 0 :=\n\n/-- An element is in the kernel if and only if it maps to zero. -/\ntheorem âˆ€ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, r âˆˆ RingHom.ker f â†” â†‘f r = 0 :=\n\n/-- The zero morphism maps every pseudoelement to 0. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x âˆˆ s } :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0 :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] [inst_2 : Norm Râ‚] [inst_3 : Norm Râ‚‚]\n  {Ïƒ : Râ‚ â†’+* Râ‚‚} [self : RingHomIsometric Ïƒ] {x : Râ‚}, â€–â†‘Ïƒ xâ€– = â€–xâ€– :=\n\n/-- If an element maps to zero under a ring homomorphism, then it is zero. -/\ntheorem", "choices": ["âˆ€ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S} {r : R},\n  â†‘f r = 0 â†’ r = 0 ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²),\n  (âˆ€ (a : Î±), â†‘f a = 0 â†’ a = 0) â†’ Function.Injective f ", "âˆ€ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R â†’+* S} (r : R),\n  â†‘f r = 0 â†’ r âˆˆ RingHom.ker f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Semiring Î±] [inst_1 : Semiring Î²] (f : Î± â†’+* Î²) (a : Î±), â†‘f a = 0 â†’ a = 0 ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Semiring Î±] [inst_1 : Semiring Î²] (f : Î± â†’+* Î²),\n  (âˆ€ (a : Î±), â†‘f a = 0 â†’ a = 0) â†’ Function.Injective â†‘f ", "âˆ€ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] (f : R â†’+* S) (r : R), â†‘f r = 0 â†’ r = 0 ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²),\n  (â†‘f 0 = 0) â†’ âˆ€ (a : Î±), â†‘f a = 0 â†’ a = 0 ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : NonAssocSemiring Î±} {x_1 : NonAssocSemiring Î²} (f : Î± â†’+* Î²),\n  (â†‘f 0 = 0) â†’ âˆ€ (a : Î±), â†‘f a = 0 â†’ a = 0 ", "âˆ€ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  [inst_2 : Function.Injective f] {r : R}, â†‘f r = 0 â†’ r = 0 ", "âˆ€ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] (f : R â†’+* S) (r : R), â†‘f r = 0 â†’ r âˆˆ RingHom.ker f "]}, {"stmt": "Implication `â†’` is symmetric. If `P â†’ Q` then `Q â†’ P`.", "prompts": "[{\"theorem\": \"âˆ€ {p q r : Prop}, (p â†’ q) â†’ (q â†’ r) â†’ p â†’ r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Implication `â†’` is transitive. If `P â†’ Q` and `Q â†’ R` then `P â†’ R`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y : Î±}, r x y â†’ r y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category D]\\n  [inst_2 :\\n    âˆ€ (P : CategoryTheory.Functor Cáµ’áµ– D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : CategoryTheory.Functor Cáµ’áµ– D)\\n  [inst_3 : âˆ€ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)áµ’áµ– D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\",\n  \"isProp\": true,\n  \"docString\": \"`(P âŸ¶ Pâº)âº = Pâº âŸ¶ Pâºâº` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. \"},\n {\"theorem\":\n  \"âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’ CategoryTheory.MorphismProperty.RespectsIso P\",\n  \"isProp\": true,\n  \"docString\": \"`P` respects isomorphisms. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y z : Î±}, r x y â†’ r y z â†’ r x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ (x : Î±), r x x\",\n  \"isProp\": true,\n  \"docString\": \"An equivalence relation is reflexive: `x ~ x` \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : Submodule R M â†’ Prop},\\n  (âˆ€ (I : Submodule R M), (âˆ€ (J : Submodule R M), J > I â†’ P J) â†’ P I) â†’ âˆ€ (I : Submodule R M), P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `âˆ€ I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a b c d : Î±} [inst : Preorder Î±], c â‰¤ a â†’ b â‰¤ d â†’ a â‰¤ b â†’ c â‰¤ d\",\n  \"isProp\": true,\n  \"docString\": \"monotonicity of `â‰¤` with respect to `â†’` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} [self : Antisymm r] {a b : Î±}, r a b â†’ r b a â†’ a = b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An antisymmetric relation `(Â·â‰¤Â·)` satisfies `a â‰¤ b â†’ b â‰¤ a â†’ a = b`. \"}]\n", "prompt_cons": "/-- Implication `â†’` is transitive. If `P â†’ Q` and `Q â†’ R` then `P â†’ R`. -/\ntheorem âˆ€ {p q r : Prop}, (p â†’ q) â†’ (q â†’ r) â†’ p â†’ r :=\n\n/-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\ntheorem âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y : Î±}, r x y â†’ r y x :=\n\n/-- `(P âŸ¶ Pâº)âº = Pâº âŸ¶ Pâºâº` -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\n  [inst_1 : CategoryTheory.Category D]\n  [inst_2 :\n    âˆ€ (P : CategoryTheory.Functor Cáµ’áµ– D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\n  (P : CategoryTheory.Functor Cáµ’áµ– D)\n  [inst_3 : âˆ€ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)áµ’áµ– D],\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P) :=\n\n/-- If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Monoid Î±] {p q : Î±}, Irreducible p â†’ Irreducible q â†’ p âˆ£ q â†’ q âˆ£ p :=\n\n/-- `P` respects isomorphisms. -/\ntheorem âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’ CategoryTheory.MorphismProperty.RespectsIso P :=\n\n/-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\ntheorem âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ {x y z : Î±}, r x y â†’ r y z â†’ r x z :=\n\n/-- An equivalence relation is reflexive: `x ~ x` -/\ntheorem âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ (x : Î±), r x x :=\n\n/-- If `âˆ€ I > J, P I` implies `P J`, then `P` holds for all submodules. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] {P : Submodule R M â†’ Prop},\n  (âˆ€ (I : Submodule R M), (âˆ€ (J : Submodule R M), J > I â†’ P J) â†’ P I) â†’ âˆ€ (I : Submodule R M), P I :=\n\n/-- monotonicity of `â‰¤` with respect to `â†’` -/\ntheorem âˆ€ {Î± : Type u} {a b c d : Î±} [inst : Preorder Î±], c â‰¤ a â†’ b â‰¤ d â†’ a â‰¤ b â†’ c â‰¤ d :=\n\n/-- An antisymmetric relation `(Â·â‰¤Â·)` satisfies `a â‰¤ b â†’ b â‰¤ a â†’ a = b`. -/\ntheorem âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} [self : Antisymm r] {a b : Î±}, r a b â†’ r b a â†’ a = b :=\n\n/-- Implication `â†’` is symmetric. If `P â†’ Q` then `Q â†’ P`. -/\ntheorem", "choices": ["This statement is incorrect. Implication `â†’` is NOT symmetric. Implication is only transitive, but not symmetric. So, I can't provide a theorem for this statement.", "This statement is incorrect, implication is not symmetric. So, there is no theorem for this statement.", "This statement is incorrect, as the implication `â†’` is NOT symmetric. Implication is only transitive and reflexive, but not symmetric. You might be confusing it with equivalence relations, which are symmetric, reflexive, and transitive.", "This statement is incorrect. Implication `â†’` is not symmetric. The correct statement is \"implication `â†’` is contrapositive. If `P â†’ Q`, then `Â¬Q â†’ Â¬P`.\" Here's the theorem for the correct statement:\n\n/-- Implication `â†’` is contrapositive. If `P â†’ Q`, then `Â¬Q â†’ Â¬P`. -/\ntheorem âˆ€ {p q : Prop}, (p â†’ q) â†’ (Â¬q â†’ Â¬p) ", "This statement is incorrect, as implication `â†’` is not symmetric. Implication is only transitive and reflexive, but not symmetric.", "This statement is incorrect. Implication `â†’` is not symmetric. It means that if `P â†’ Q` is true, it doesn't necessarily mean that `Q â†’ P` is also true.", "This statement is incorrect. Implication `â†’` is not symmetric.", "This statement is incorrect, as implication is not symmetric. Implication is only transitive and reflexive. You can have cases where P â†’ Q is true, but Q â†’ P is not true.", "This statement is incorrect. Implication `â†’` is not symmetric. If `P â†’ Q`, it does not imply `Q â†’ P`.", "This statement is incorrect, as implication `â†’` is not symmetric. A correct statement would be that implication `â†’` is transitive, which you provided at the beginning. \n\nHere is the Lean code for the transitive property of implication:\n\n```\n/-- Implication `â†’` is transitive. If `P â†’ Q` and `Q â†’ R` then `P â†’ R`. -/\ntheorem imp_trans {p q r : Prop} (hâ‚ : p â†’ q) (hâ‚‚ : q â†’ r) : p â†’ r "]}, {"stmt": "Two natural numbers are equal if and only if they are both divisible by some prime number.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, m âˆ£ n + m â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [self : GCDMonoid Î±] {a b c : Î±}, a âˆ£ c â†’ a âˆ£ b â†’ a âˆ£ gcd c b\",\n  \"isProp\": true,\n  \"docString\": \"Any common divisor of both elements is a divisor of the GCD. \"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0 :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem âˆ€ {m n : â„•}, m âˆ£ n + m â†” m âˆ£ n :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c :=\n\n/-- Any common divisor of both elements is a divisor of the GCD. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [self : GCDMonoid Î±] {a b c : Î±}, a âˆ£ c â†’ a âˆ£ b â†’ a âˆ£ gcd c b :=\n\n/-- Two natural numbers are equal if and only if they are both divisible by some prime number. -/\ntheorem", "choices": ["âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n ", "âˆ€ {m n : â„•}, (âˆƒ (p : â„•) [Fact (Nat.Prime p)], p âˆ£ m âˆ§ p âˆ£ n) â†” m = n ", "âˆ€ {m n : â„•}, (âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ m âˆ§ p âˆ£ n) â†” m = n ", "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n ", "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n ", "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n ", "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ (p âˆ£ m â†” p âˆ£ n)) â†” m = n ", "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ (p âˆ£ m â†” p âˆ£ n)) â†” m = n ", "âˆ€ {m n : â„•}, (âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ m âˆ§ p âˆ£ n) â†” m = n ", "âˆ€ {m n : â„•}, (âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n) â†” m = n "]}]