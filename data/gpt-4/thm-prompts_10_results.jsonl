{"docString": "If every proper closed set of a topological space is compact, then the space itself is compact.", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ s, IsClosed s â†’ s â‰  univ â†’ IsCompact s), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ s : Set Î±, IsClosed s â†’ s â‰  Set.Univ â†’ IsCompact s), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (F : Set Î±), IsClosed F â†’ F â‰  univ â†’ IsCompact F), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (s : Set Î±), IsClosed s â†’ s â‰  univ â†’ IsCompact s), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (s : Set Î±), IsClosed s â†’ s â‰  univ â†’ IsCompact s), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsProper K âˆ§ IsClosed K â†’ IsCompact K), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsClosed K â†’ K â‰  univ â†’ IsCompact K), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsClosed K â†’ K â‰  univ â†’ IsCompact K), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (s : Set Î±), IsClosed s â†’ (s â‰  univ) â†’ IsCompact s), IsCompact univ ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (s : Set Î±), IsClosed s â†’ s â‰  univ â†’ IsCompact s), CompactSpace Î± "]}
{"docString": "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.", "choices": ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p "]}
{"docString": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "choices": ["âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y z w u v : â„•}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 â†’ âˆƒ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2 ", "âˆ€ {a b x y u v r s : â„•}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 â†’ b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 â†’ âˆƒ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ (aâ‚€ aâ‚ aâ‚‚ aâ‚ƒ bâ‚€ bâ‚ bâ‚‚ bâ‚ƒ : â„•),\n  âˆƒ câ‚€ câ‚ câ‚‚ câ‚ƒ, aâ‚€ ^ 2 + aâ‚ ^ 2 + aâ‚‚ ^ 2 + aâ‚ƒ ^ 2 = (bâ‚€ ^ 2 + bâ‚ ^ 2 + bâ‚‚ ^ 2 + bâ‚ƒ ^ 2) * (câ‚€ ^ 2 + câ‚ ^ 2 + câ‚‚ ^ 2 + câ‚ƒ ^ 2) ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t p, a * b = r ^ 2 + s ^ 2 + t ^ 2 + p ^ 2 ", "âˆ€ {a b x y u v r s : â„•},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 â†’\n  b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 â†’\n  âˆƒ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 ", "âˆ€ {a b x y u v r s : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 â†’ âˆƒ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’\n  âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 "]}
{"docString": "A ring with all elements idempotent is commutative.", "choices": ["âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : CommRing Î±] (h : âˆ€ (a : Î±), a * a = a) (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : MulZeroClass Î±] (h : âˆ€ (a : Î±), a * a = a) (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : Mul Î±] [self_1 : Add Î±] [self_2 : Idempotent Î±], IsCommutative Î± Mul.mul ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a "]}
{"docString": "There are infinitely many pairs of primes that differ exactly by `2`.", "choices": ["âˆƒ (f : â„• â†’ â„• Ã— â„•), (âˆ€ (n : â„•), Nat.Prime (f n).fst âˆ§ Nat.Prime (f n).snd âˆ§ (f n).snd - (f n).fst = 2) âˆ§ Function.Injective f ", "âˆƒ f : â„• â†’ â„• Ã— â„•, (âˆ€ (n : â„•), Nat.Prime (f n).fst âˆ§ Nat.Prime (f n).snd âˆ§ (f n).fst < (f n).snd âˆ§ (f n).snd - (f n).fst = 2) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ f m â‰  f n ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], CharP F 2 â†’ âˆ€ (a : F), IsSquare a ", "Infinite (âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ q - p = 2) ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a ", "âˆƒ (f : â„• â†’ â„• Ã— â„•), âˆ€ (n : â„•), IsPrime (f n).1 âˆ§ IsPrime (f n).2 âˆ§ (f n).2 - (f n).1 = 2 ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a ", "âˆƒ f : â„• â†’ â„•, (âˆ€ n, Nat.Prime (f n) âˆ§ Nat.Prime (f n + 2)) âˆ§ Set.Infinite {x : â„• | Prime x âˆ§ Prime (x + 2)} ", "Exists (Î» n : â„•, âˆƒ (a b : â„•), Nat.Prime a âˆ§ Nat.Prime b âˆ§ a - b = 2 * n) "]}
{"docString": "Every finite division ring is a field.", "choices": ["âˆ€ (D : Type u) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ", "âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "âˆ€ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K ", "âˆ€ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ", "âˆ€ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K "]}
{"docString": "If each of two types can be mapped injectively into the other, then there is a bijection between them.", "choices": ["âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î² â†’ Î±},\n  Function.Injective eâ‚ â†’ Function.Injective eâ‚‚ â†’ âˆƒ (e : Î± â‰ƒ Î²), True ", "âˆ€ {X Y : Type u}, (âˆƒ (f : X â†’ Y), Function.Injective f) â†’ (âˆƒ (g : Y â†’ X), Function.Injective g) â†’ Nonempty (X â‰ƒ Y) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (eâ‚ : Î± â†’ Î²) (eâ‚‚ : Î² â†’ Î±),\n  Function.Injective eâ‚ â†’ Function.Injective eâ‚‚ â†’ âˆƒ (f : Î± â‰ƒ Î²), True ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²), Function.Injective f â†’ (âˆƒ (g : Î² â†’ Î±), Function.Injective g) â†’\n  Nonempty (Î± â‰ƒ Î²) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î² â†’ Î±},\n  Function.Injective eâ‚ â†’ Function.Injective eâ‚‚ â†’ Nonempty (Î± â‰ƒ Î²) ", "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²) ", "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ (âˆƒ (h : Î± â‰ƒ Î²), âˆ€ (x : Î±), f x = h x) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (e : Î± â†’ Î²) (f : Î² â†’ Î±),\n  Function.Injective e â†’ Function.Injective f â†’ Nonempty (Î± â‰ƒ Î²) "]}
{"docString": "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.", "choices": ["âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ x, SimpleGraph.Adj G x v âˆ§ SimpleGraph.Adj G x w âˆ§ âˆ€ (y : V), SimpleGraph.Adj G y v âˆ§ SimpleGraph.Adj G y w â†’ y = x) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! u, SimpleGraph.Adj G v u âˆ§ SimpleGraph.Adj G w u) â†’ âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), SimpleGraph.Adj G v u âˆ§ SimpleGraph.Adj G w u) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), âˆƒ! u, SimpleGraph.Adj G u v âˆ§ SimpleGraph.Adj G u w) â†’ âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), u â‰  v âˆ§ u â‰  w âˆ§ SimpleGraph.Adj G u v âˆ§ SimpleGraph.Adj G u w) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ v w, v â‰  w â†’ ExistsUnique (Î» x, SimpleGraph.Adj G v x âˆ§ SimpleGraph.Adj G x w)) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), SimpleGraph.Adj G v u âˆ§ SimpleGraph.Adj G u w) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), âˆƒ! (x : V), SimpleGraph.Adj G x v âˆ§ SimpleGraph.Adj G x w) â†’ âˆƒ (x : V), âˆ€ (v : V), v â‰  x â†’ SimpleGraph.Adj G x v ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), SimpleGraph.Adj G v u âˆ§ SimpleGraph.Adj G w u) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), SimpleGraph.Adj G v u âˆ§ SimpleGraph.Adj G w u) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w "]}
{"docString": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.", "choices": ["Nnreal.sum_partition_odd_eq_distinct : âˆ€ (n : â„•), (Finset.sum (Finset.ico 1 n) (fun k => odd_part_powers k)) = (Finset.sum (Finset.ico 1 n) (fun k => distinct_part_powers k)) ", "âˆ€ {n : â„•}, partition_odd n = partition_distinct n ", "âˆ€ {n : â„•}, Nat.partitions_with_odd_parts n = Nat.partitions_with_distinct_parts n ", "âˆ€ (n : â„•), partition_odd n = partition_distinct n ", "âˆ€ (n : â„•), odd_part_pn n = distinct_part_pn n ", "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {Ï€ : Partition Î±},\n  Finset.card (Finset.filter (Î» b : Finset (Finset Î±), Finset.card b = 1) Ï€.parts) =\n    Finset.card (Finset.filter (Î» b : Finset (Finset Î±), â†‘(Finset.card b) â‰  0 âˆ§ âˆ€ (a : Finset Î±), a âˆˆ b â†’ Finset.card a = 1) Ï€.parts) ", "âˆ€ {n : â„•}, partition_odd_part_count n = partition_distinct_part_count n ", "âˆ€ {n : â„•}, partitions_distinct n = partitions_odd n ", "âˆ€ (n : â„•), \n  Partition.distinct_parts_partition n = Partition.odd_parts_partition n ", "âˆ€ {n : â„•}, (Finset.card (Finset.filter (fun x => Finset.card x.parts = n) (oddPartitions Nat.odd))) =\n  (Finset.card (Finset.filter (fun x => Finset.card x.parts = n) (distinctPartitions Nat.distinct))) "]}
{"docString": "Every non-empty poset in which every chain has an upper bound contains a maximal element.", "choices": ["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : PartialOrder Î±] [inst_1 : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain (â‰¤) c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ a â‰¤ ub) â†’\n    âˆƒ m, âˆ€ (a : Î±), m â‰¤ a â†’ a â‰¤ m ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain (fun a b => a â‰¤ b) c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ a â‰¤ ub) â†’\n    âˆƒ m, âˆ€ (a : Î±), m â‰¤ a â†’ a â‰¤ m ", "forall {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "forall {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m "]}
{"docString": "A group whose automorphism group is cyclic is Abelian.", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], AddCommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ", "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (Aut G) â†’ IsAbelian G ", "âˆ€ {G : Type u_1} [inst : Group G] (hG : IsCyclic (Aut G)), CommGroup G ", "forall {Î± : Type u} [inst : Group Î±] (h : IsCyclic (Aut Î±)), IsAbelian Î± ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype (Aut Î±)], IsCyclic (Aut Î±) â†’ IsAbelian Î± ", "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype (End Î±)], IsCyclic (End Î±) â†’ IsAbelian Î± ", "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (Aut G) â†’ IsAbelian G ", "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (Aut G) â†’ AddCommGroup G "]}
{"docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’áµ¤ Î²) (g : Î² â†’áµ¤ Î³), UniformContinuous (g.toFun âˆ˜ f.toFun) "]}
{"docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "forall {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "forall {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) "]}
{"docString": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ f s âŠ† (0 : Set â„) âˆ§ f t âŠ† (1 : Set â„) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’\n  âˆƒ f : Î± â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’\n  âˆƒ (f : Î± â†’ â„), Continuous f âˆ§ (âˆ€ (x : Î±), x âˆˆ s â†’ f x = 0) âˆ§ (âˆ€ (x : Î±), x âˆˆ t â†’ f x = 1) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : Î± â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ y âˆˆ t, f y = 1) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†” âˆ€ (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, ContinuousOn f (s âˆª t) âˆ§ âˆ€ x âˆˆ s, f x = 0 âˆ§ âˆ€ x âˆˆ t, f x = 1 ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ (s t : Set Î±), Disjoint s t â†’ IsClosed s â†’ IsClosed t â†’\n  âˆƒ (f : Î± â†’ â„), Continuous f âˆ§ âˆ€ (x : Î±), HasMem.Mem x s â†’ f x = 0 âˆ§ âˆ€ (x : Î±), HasMem.Mem x t â†’ f x = 1 ", "forall {Î± : Type u} [t : TopologicalSpace Î±],\n  NormalSpace Î± â†” âˆ€ {s t : Set Î±}, IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒf : Î± â†’ â„, Continuous f âˆ§ âˆ€ x âˆˆ s, f x = 0 âˆ§ âˆ€ x âˆˆ t, f x = 1 ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, ContinuousOn f s âˆ§ ContinuousOn f t âˆ§ âˆ€ x, f x âˆˆ [0, 1] ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : Î± â†’ â„, Continuous f âˆ§ f '' s âŠ† (0:â„) âˆ§ f '' t âŠ† (1:â„) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ f =á¶ [ğ“Ÿ s] 0 âˆ§ f =á¶ [ğ“Ÿ t] 1 "]}
{"docString": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.", "choices": ["/-- Any point is a periodic point of period `0`. -/\ntheorem is_periodic_pt_zero {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : Function.IsPeriodicPt f 0 x ", "forall {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] {f : Î± â†’ Î±},\n  ContinuousOn f (Set.Icc 0 1) â†’\n  (âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) â†’\n  âˆ€ n, âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : MeasurableSpace Î±] [inst_4 : OpensMeasurableSpace Î±], IsUnitInterval Î± â†’\n    (âˆƒ x, Function.IsPeriodicPt f 3 x) â†’ âˆ€ (n : â„•), n > 0 â†’ âˆƒ x, Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±],\n  0 < Î± â†’ 1 < Î± â†’ (âˆƒ x, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n : â„•, 0 < n â†’ âˆƒ x, Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : ConditionallyCompleteLinearOrder Î±] [inst_2 : Archimedean Î±]\n  {f : â„ â†’ Î±} (hf : ContinuousOn f (Set.Icc 0 1)) (hâ‚€ : âˆ€ x, HasMem.Mem x (Set.Icc 0 1) â†’ HasMem.Mem (f x) (Set.Icc 0 1))\n  {x : â„} (hx : HasMem.Mem x (Set.Icc 0 1)) (h3 : Function.IsPeriodicPt f 3 x),\n  âˆ€ (n : â„•), n > 0 â†’ âˆƒ y, HasMem.Mem y (Set.Icc 0 1) âˆ§ Function.IsPeriodicPt f n y ", "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderConnectedTopology Î±]\n  [inst_3 : DenselyOrdered Î±] {f : Î± â†’ Î±} [inst_4 : HasForallOrdCont f],\n  Î± = Set.Icc (0 : Î±) 1 â†’ (âˆƒ x, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n, âˆƒ x, Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenseOrder Î±] {f : Î± â†’ Î±},\n  (âˆƒ x âˆˆ Set.Icc (0 : Î±) 1, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n, âˆƒ x âˆˆ Set.Icc (0 : Î±) 1, Function.IsPeriodicPt f n x ", "forall {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), \n  Function.IsPeriodicPt f 3 x â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ y, Function.IsPeriodicPt f n y ", "forall {Î± : Type u_1} {f : Î± â†’ Î±} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±],\n  Function.IsPeriodicPt f 3 (0 : Î±) â†’ âˆ€ n : â„•, 0 < n â†’ âˆƒ x, Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : FloorRing Î±],\n  0 â‰¤ Î± â†’ Î± â‰¤ 1 â†’\n    (âˆƒ x : Î±, Function.IsPeriodicPt (Î» x, 3 * x) 3 x) â†’\n      âˆ€ (n : â„•), n > 0 â†’ âˆƒ x, Function.IsPeriodicPt (Î» x, 3 * x) n x "]}
{"docString": "A terminal object in a category is unique up to unique isomorphism.", "choices": ["âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C}\n  (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Nonempty (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C]\n  {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Nonempty (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X)\n  (hY : CategoryTheory.Limits.IsTerminal Y), Unique (X â‰… Y) "]}
{"docString": "The complement of the union of two sets is the intersection of their complements.", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆª tá¶œ = (s âˆ© t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆª tá¶œ = (s âˆ© t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ "]}
{"docString": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.", "choices": ["âˆ€ {a b c : â„•}, 0 < a â†’ 0 < b â†’ a ^ 3 + b ^ 3 â‰  c ^ 3 ", "âˆ€ {x y z : â„•}, x > 0 â†’ y > 0 â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, x > 0 â†’ y > 0 â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, x > 0 â†’ y > 0 â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, x > 0 â†’ y > 0 â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 "]}
{"docString": "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.", "choices": ["âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (a : G), a * a = 1) â†’ âˆ€ (a b : G), Commute a b ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ g : G, g ^ 2 = 1) â†’ âˆ€ a b : G, Commute a b ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (a b : G), Commute a b ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (a b : G), Commute a b ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (a b : G), Commute a b ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (a b : G), Commute a b "]}
{"docString": "The product of two consecutive natural numbers is even.", "choices": ["âˆ€ (n : â„•), Even (n * (n + 1)) ", "âˆ€ {n : â„•}, Even (n * (n + 1)) ", "âˆ€ {n : â„•}, Even (n * (n + 1)) ", "âˆ€ {m : â„•}, Even (m * (m + 1)) ", "âˆ€ {m : â„•}, Even (m * (m + 1)) ", "âˆ€ {m : â„•}, Even (m * (m + 1)) ", "âˆ€ {n : â„•}, Even (n * (n + 1)) ", "âˆ€ (n : â„•), Even (n * (n + 1)) ", "âˆ€ {m n : â„•}, n = m + 1 â†’ Even (m * n) ", "âˆ€ {n : â„•}, Even (n * (n + 1)) "]}
{"docString": "Every index 2 subgroup of a group is normal.", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "forall {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H "]}
{"docString": "Every free group is torsion free.", "choices": ["âˆ€ {Î¹ : Type u_1} (M : Î¹ â†’ Type u_2) [inst : (i : Î¹) â†’ Group (M i)], Monoid.IsTorsionFree (FreeGroup (((i : Î¹) â†’ M i))) ", "forall {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype Î±], IsFreeGroup G â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G], Group.IsFree G â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G] [hF : FreeGroup G], Monoid.IsTorsionFree G ", "âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Nonempty Î±], Monoid.IsTorsionFree (FreeGroup Î±) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ", "forall {Î¹ : Type u_1} {G : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Group (G i)],\n  (âˆ€ (F : FreeGroup (Î¹, G)), Monoid.IsTorsionFree F) ", "forall {Î¹ : Type u_1} {G : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Group (G i)] (F : FreeGroup G),\n  Monoid.IsTorsionFree (FreeGroup G) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ", "âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] (f : Î± â†’ G), Monoid.IsTorsionFree (FreeGroup Î±) "]}
{"docString": "Every natural number greater than `1` is divisible by a prime number.", "choices": ["âˆ€ n : â„•, 1 < n â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ", "âˆ€ (n : â„•), 1 < n â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ {n : â„•}, n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n "]}
{"docString": "A finite torsion-free group is trivial", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G],\n  Monoid.IsTorsionFree G â†’ IsTrivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G "]}
{"docString": "Every finite division ring is a field.", "choices": ["âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (D : Type u) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "âˆ€ (R : Type u) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R "]}
{"docString": "Every finite topological space is compact.", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "Finite.toCompactSpace : âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Fintype Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± "]}
{"docString": "Every surjective homomorphism from a finitely generated free group to itself is injective.", "choices": ["âˆ€ {Î¹ : Type u_1} {F : Type u_2} [inst : Group F] [inst_1 : FreeGroup Î¹] [inst_2 : Fintype Î¹] (f : F â†’* F),\n  Function.Surjective â†‘f â†’ Function.Injective â†‘f ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [inst_2 : Group.IsFree Î±] {f : Î± â†’ Î±},\n  IsGroupHom f â†’ Function.Surjective f â†’ Function.Injective f ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] [inst_2 : Fintype Î±] (f : Î± â†’* Î±),\n  Function.Surjective â†‘f â†’ Function.Injective â†‘f ", "forall {Î± : Type u} [inst : Group Î±] [inst_1 : FinitelyGenerated Î±] [inst_2 : Free Î±],\n  âˆ€ (f : Î± â†’* Î±), Function.Surjective f â†’ Function.Injective f ", "âˆ€ {Î± : Type u} {G : Type v} [inst : Group G] [inst_1 : FreeGroup Î±] [inst_2 : FinitelyGenerated G]\n  (f : G â†’ G), Function.Surjective f â†’ Function.Injective f ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] [inst_2 : IsFinitelyGenerated G]\n  (f : G â†’* G), Function.Surjective â†‘f â†’ Function.Injective â†‘f ", "âˆ€ {Î± : Type u} (f : FreeGroup Î± â†’ FreeGroup Î±),\n  Function.Surjective f â†’ (âˆ€ (G H : Set Î±), Subgroup.Fg (Subgroup.mk G) â†’ Subgroup.Fg (Subgroup.mk H)) â†’ Function.Injective f ", "âˆ€ {Î± : Type u} [inst : Fintype Î±] {F : FreeGroup Î±} {f : FreeGroup Î± â†’* FreeGroup Î±},\n  Function.Surjective â†‘f â†’ Function.Injective â†‘f ", "âˆ€ {Î± : Type u} [inst_1 : Fintype Î±] {G : FreeGroup Î±} (f : G â†’* G), Function.Surjective â†‘f â†’ Function.Injective â†‘f ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {f : Î± â†’* Î±},\n  Function.Surjective â†‘f â†’ Function.Injective â†‘f "]}
{"docString": "Every positive even integer can be written as the sum of two primes.", "choices": ["Goldbach's_conjecture : âˆ€ (n : â„•), 2 â‰¤ n â†’ n.even â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ (n : â„•), n > 2 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ (n : â„•), n > 2 â†’ Even n â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ {n : â„•}, n > 0 â†’ Even n â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ (n : â„•), 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ (a b : â„•), Nat.Prime a âˆ§ Nat.Prime b âˆ§ n = a + b ", "âˆ€ n : â„•, 2 â‰¤ n â†’ Even n â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "Goldbach's_conjecture : âˆ€ n : â„•, 2 < n â†’ n % 2 = 0 â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ (n : â„•), n > 2 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ {n : â„•}, n > 2 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "goldbach_conjecture : âˆ€ {n : â„•}, 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q "]}
{"docString": "Every matrix satisfies its own characteristic polynomial.", "choices": ["âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "forall {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Matrix.charpoly M = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 "]}
{"docString": "The square root of an irrational number is irrational.", "choices": ["âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) ", "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ", "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ", "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) "]}
{"docString": "If the square of a number is even, the number itself is even.", "choices": ["âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {a : Î±}, a * a % 2 = 0 â†’ a % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†” x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†” x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†” x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†” x % 2 = 0 ", "âˆ€ {n : â„•}, (n * n) % 2 = 0 â†’ n % 2 = 0 "]}
{"docString": "In a finite commutative ring, all prime ideals are maximal.", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P ", "âˆ€ {R : Type u} [inst : CommRing R] [hR : Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P ", "âˆ€ {R : Type u} [inst : CommRing R] [hR : Fintype R], âˆ€ (I : Ideal R) [Ideal.IsPrime I], Ideal.IsMaximal I ", "âˆ€ {R : Type u} [inst : CommRing R] [hR : Fintype R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [hR : Fintype R], \n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [F : Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsFinite R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) "]}
{"docString": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$.", "choices": ["âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X â†” IsClosed (TopologicalSpace.Diagonal X) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed {p : Î± Ã— Î± | p.fst = p.snd} ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsClosed (Diagonal Î±) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X â†” IsClosed (Diagonal X) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsClosed (Set.Diagonal Î±) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsClosed (Diagonal Î±) "]}
{"docString": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ (U : Set Î±), IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s "]}
{"docString": "Every non-identity element of a free group is of infinite order.", "choices": ["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] {x : Î±}, x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] {x : Î±}, x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} [inst : Semigroup Î±] (x : FreeGroup Î±), x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u_1} [inst : FreeGroup Î±] (x : FreeGroup Î±), x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} [self : FreeGroup Î±] (x : Î±), x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} (x : FreeGroup Î±), x â‰  FreeGroup.of [] â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] (x : Î±), x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] (a : Î±), a â‰  1 â†’ Â¬IsOfFinOrder a ", "âˆ€ {Î± : Type u_1} (x : FreeGroup Î±), x â‰  1 â†’ Â¬IsOfFinOrder x "]}
{"docString": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (v : DiscreteValuationRing.Valuation R)\n  (u : R), IsUnit u â†” v u = 0 ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (u : R),\n  u âˆˆ DiscreteValuationRing.unitsOf R â†” DiscreteValuationRing.valuationOf u = 0 ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {u : R},\n  IsUnit u â†” DiscreteValuationRing.valuation u = 0 ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  x âˆˆ DiscreteValuationRing.unitsValuationZero R â†” IsUnit x ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (Ï– : R) (hÏ– : Irreducible Ï–) (x : R), IsUnit x â†” âˆ€ (v : DiscreteValuationRing.Aux R Ï– hÏ–), v x = 0 ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (u : R), IsUnit u â†” DiscreteValuationRing.has_valuation.zero R u ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (u : R), IsUnit u â†” DiscreteValuationRing.valuation u = 0 ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {x : R},\n  IsUnit x â†” DiscreteValuationRing.valuation x = 0 ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (Ï– : R) (hr : Irreducible Ï–), Ï– â‰  0 â†’ (âˆ€ (u : RË£), (DiscreteValuationRing.valuation R Ï– u).1 = 0 â†” â†‘u = 1) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (u : R),\n  IsUnit u â†” DiscreteValuationRing.hasUnit u = 0 "]}
{"docString": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.", "choices": ["âˆ€ {a b N : â„•}, Nat.coprime a b â†’ a â‰  0 â†’ b â‰  0 â†’ âˆƒ (x y : â„•), N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ (N : â„•), âˆƒ (x y : â„•), N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆƒ N : â„•, âˆ€ n : â„•, N â‰¤ n â†’ âˆƒ x y : â„•, n = a * x + b * y ", "âˆ€ {a b N : â„•}, Nat.gcd a b = 1 â†’ N â‰¥ a * b - a - b â†’ âˆƒ x y : â„•, N = a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, a * x + b * y â‰¥ N ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ (N : â„•), âˆƒ (x y : â„•), N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, a * x + b * y â‰¥ N "]}
{"docString": "Every field is a ring.", "choices": ["forall (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K "]}
{"docString": "The set of units in a ring forms a group.", "choices": ["âˆ€ {R : Type u_1} [inst : Ring R], IsGroup {x : R | IsUnit x} ", "Group {R : Type u_1} [inst : Ring R] : Type u_1 ", "âˆ€ {R : Type u_1} [inst : Ring R], Group RË£ ", "âˆ€ {R : Type u} [inst : Ring R], Group RË£ ", "âˆ€ {R : Type u_1} [inst : Ring R], Group (Units R) ", "âˆ€ {R : Type u_1} [inst : Ring R], Group RË£ ", "âˆ€ {R : Type u_1} [inst : Ring R], Group RË£ ", "âˆ€ {R : Type u_1} [inst : Monoid R], Group (Units R) ", "âˆ€ {R : Type u} [inst : Monoid R], Group (Units R) ", "âˆ€ {R : Type u} [inst : Ring R], Group (Units R) "]}
{"docString": "If the direct product of two groups is torsion free then each of the groups is torsion free.", "choices": ["âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) â†’ âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i) ", "forall {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ", "forall {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ", "forall {G : Type u_1} {H : Type u_2} [inst_1 : Group G] [inst_2 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ", "forall {A B : Type u_1} [inst : Group A] [inst_1 : Group B],\n  Monoid.IsTorsionFree (A Ã— B) â†’ Monoid.IsTorsionFree A âˆ§ Monoid.IsTorsionFree B ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ", "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ", "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ", "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ", "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ "]}
