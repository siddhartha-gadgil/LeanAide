[{"stmt": "If every proper closed set of a topological space is compact, then the space itself is compact.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally compact charts, then the space itself\\nis locally compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. -/\ntheorem âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±}, IsCompact s â†’ IsClosed s :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- If every proper closed set of a topological space is compact, then the space itself is compact. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ s, IsClosed s â†’ s â‰  univ â†’ IsCompact s), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ s : Set Î±, IsClosed s â†’ s â‰  Set.Univ â†’ IsCompact s), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (F : Set Î±), IsClosed F â†’ F â‰  univ â†’ IsCompact F), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (s : Set Î±), IsClosed s â†’ s â‰  univ â†’ IsCompact s), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (s : Set Î±), IsClosed s â†’ s â‰  univ â†’ IsCompact s), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsProper K âˆ§ IsClosed K â†’ IsCompact K), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsClosed K â†’ K â‰  univ â†’ IsCompact K), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (K : Set Î±), IsClosed K â†’ K â‰  univ â†’ IsCompact K), CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (s : Set Î±), IsClosed s â†’ (s â‰  univ) â†’ IsCompact s), IsCompact univ ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (h : âˆ€ (s : Set Î±), IsClosed s â†’ s â‰  univ â†’ IsCompact s), CompactSpace Î± "]}, {"stmt": "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.", "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\\nof two squares. Also known as **Fermat's Christmas theorem**. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"}]\n", "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 â‰  3 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p :=\n\n/-- **Four squares theorem** -/\ntheorem âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem âˆ€ {p q : â„•} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 â†’ q â‰  2 â†’ legendreSym q â†‘p = legendreSym p â†‘q :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares. -/\ntheorem", "choices": ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p "]}, {"stmt": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] (m k : â„•),\\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\\n  p * q =\\n    Finset.sum (Polynomial.support p) fun i =>\\n      Polynomial.sum q fun j a => â†‘(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)\",\n  \"isProp\": true,\n  \"docString\": \"Expressing the product of two polynomials as a double sum. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"}]\n", "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Euler's four-square identity**. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Four squares theorem** -/\ntheorem âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] (m k : â„•),\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k :=\n\n/-- Expressing the product of two polynomials as a double sum. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\n  p * q =\n    Finset.sum (Polynomial.support p) fun i =>\n      Polynomial.sum q fun j a => â†‘(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a) :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0 :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem", "choices": ["âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y z w u v : â„•}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 â†’ âˆƒ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2 ", "âˆ€ {a b x y u v r s : â„•}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 â†’ b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 â†’ âˆƒ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ (aâ‚€ aâ‚ aâ‚‚ aâ‚ƒ bâ‚€ bâ‚ bâ‚‚ bâ‚ƒ : â„•),\n  âˆƒ câ‚€ câ‚ câ‚‚ câ‚ƒ, aâ‚€ ^ 2 + aâ‚ ^ 2 + aâ‚‚ ^ 2 + aâ‚ƒ ^ 2 = (bâ‚€ ^ 2 + bâ‚ ^ 2 + bâ‚‚ ^ 2 + bâ‚ƒ ^ 2) * (câ‚€ ^ 2 + câ‚ ^ 2 + câ‚‚ ^ 2 + câ‚ƒ ^ 2) ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t p, a * b = r ^ 2 + s ^ 2 + t ^ 2 + p ^ 2 ", "âˆ€ {a b x y u v r s : â„•},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 â†’\n  b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 â†’\n  âˆƒ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 ", "âˆ€ {a b x y u v r s : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 â†’ âˆƒ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’\n  âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 "]}, {"stmt": "A ring with all elements idempotent is commutative.", "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R â‰ƒ+* S), â†‘f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends one to one. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R â‰ƒ+* S), â†‘f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r\",\n  \"isProp\": true,\n  \"docString\": \"Equivalence closure is idempotent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), â†‘f (a + b) = â†‘f a + â†‘f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"}]\n", "prompt_cons": "/-- Multiplication in a boolean ring is idempotent. -/\ntheorem âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a : Î±), a * a = a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x * y) = â†‘e x * â†‘e y :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem âˆ€ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\n  (x y : R), â†‘e (x + y) = â†‘e x + â†‘e y :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- A ring isomorphism sends one to one. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R â‰ƒ+* S), â†‘f 1 = 1 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R â‰ƒ+* S), â†‘f 0 = 0 :=\n\n/-- Equivalence closure is idempotent. -/\ntheorem âˆ€ {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem âˆ€ {Î± : Type u_1} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a :=\n\n/-- By definition, a ring isomorphism preserves the additive structure. -/\ntheorem âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), â†‘f (a + b) = â†‘f a + â†‘f b :=\n\n/-- A ring with all elements idempotent is commutative. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : CommRing Î±] (h : âˆ€ (a : Î±), a * a = a) (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : MulZeroClass Î±] (h : âˆ€ (a : Î±), a * a = a) (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : Mul Î±] [self_1 : Add Î±] [self_2 : Idempotent Î±], IsCommutative Î± Mul.mul ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a ", "âˆ€ {Î± : Type u_1} [self : BooleanRing Î±] (a b : Î±), a * b = b * a "]}, {"stmt": "There are infinitely many pairs of primes that differ exactly by `2`.", "prompts": "[{\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2\",\n  \"isProp\": true,\n  \"docString\": \"An inequality involving `2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"}]\n", "prompt_cons": "/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- An inequality involving `2`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- There are infinitely many pairs of primes that differ exactly by `2`. -/\ntheorem", "choices": ["âˆƒ (f : â„• â†’ â„• Ã— â„•), (âˆ€ (n : â„•), Nat.Prime (f n).fst âˆ§ Nat.Prime (f n).snd âˆ§ (f n).snd - (f n).fst = 2) âˆ§ Function.Injective f ", "âˆƒ f : â„• â†’ â„• Ã— â„•, (âˆ€ (n : â„•), Nat.Prime (f n).fst âˆ§ Nat.Prime (f n).snd âˆ§ (f n).fst < (f n).snd âˆ§ (f n).snd - (f n).fst = 2) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ f m â‰  f n ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], CharP F 2 â†’ âˆ€ (a : F), IsSquare a ", "Infinite (âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ q - p = 2) ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a ", "âˆƒ (f : â„• â†’ â„• Ã— â„•), âˆ€ (n : â„•), IsPrime (f n).1 âˆ§ IsPrime (f n).2 âˆ§ (f n).2 - (f n).1 = 2 ", "âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a ", "âˆƒ f : â„• â†’ â„•, (âˆ€ n, Nat.Prime (f n) âˆ§ Nat.Prime (f n + 2)) âˆ§ Set.Infinite {x : â„• | Prime x âˆ§ Prime (x + 2)} ", "Exists (Î» n : â„•, âˆƒ (a b : â„•), Nat.Prime a âˆ§ Nat.Prime b âˆ§ a - b = 2 * n) "]}, {"stmt": "Every finite division ring is a field.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V â†” Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is algebraic if it is finite. \"}]\n", "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- A subfield is closed under division. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î± :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsNoetherian K V â†” Module.Finite K V :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- A field extension is algebraic if it is finite. -/\ntheorem âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L :=\n\n/-- Every finite division ring is a field. -/\ntheorem", "choices": ["âˆ€ (D : Type u) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ", "âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "âˆ€ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K ", "âˆ€ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ", "âˆ€ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K "]}, {"stmt": "If each of two types can be mapped injectively into the other, then there is a bijection between them.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {Mâ‚ : Type v} {Mâ‚‚ : Type v'} [inst_1 : AddCommMonoid Mâ‚] [inst_2 : Module R Mâ‚]\\n  [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R Mâ‚‚] {f : Mâ‚ â†’â‚—[R] Mâ‚‚},\\n  Function.Surjective â†‘f â†’ Function.Injective â†‘(LinearMap.dualMap f)\",\n  \"isProp\": true,\n  \"docString\": \"If a linear map is surjective, then its dual is injective. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E â‰ƒâ‚—[ğ•œ] F),\\n  Continuous â†‘e â†’ Continuous â†‘(LinearEquiv.symm e)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a bounded linear map is a bijection, then its inverse is also a bounded linear map. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_3} {Mâ‚‚ : Type u_4} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\\n  {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\\n  (âˆ€ (u v : { x // x âˆˆ LinearMap.ker f } â†’â‚—[R] M), LinearMap.comp f u = LinearMap.comp f v â†’ u = v) â†’\\n    LinearMap.ker f = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"A monomorphism is injective. \"},\n {\"theorem\":\n  \"âˆ€ {X Y : Type u} (f : X âŸ¶ Y), CategoryTheory.IsIso f â†” Function.Bijective f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism in `Type u` is an isomorphism if and only if it is bijective. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c d : Con M}, c.toSetoid = d.toSetoid â†’ c = d\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map sending a congruence relation to its underlying equivalence relation is injective. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y : C} (f : X âŸ¶ Y),\\n  Function.Injective â†‘f â†’ CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In any concrete category, injective morphisms are monomorphisms. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†” Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, a linear map is injective if and only if it is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c d : Con M}, Setoid.r = Setoid.r â†’ c = d\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map sending a congruence relation to its underlying binary relation is injective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_4}\\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Î¹ : Type u_5} {Mâ‚‚ : Type u_2} [inst_5 : AddCommMonoid Mâ‚‚]\\n  [inst_6 : Module R Mâ‚‚] (f : Mâ‚‚ â†’â‚—[R] M),\\n  Function.Surjective â†‘f â†’ Function.Injective fun g => AlternatingMap.compLinearMap g f\",\n  \"isProp\": true,\n  \"docString\": \"Composing with a surjective linear map is injective. \"}]\n", "prompt_cons": "/-- If a linear map is surjective, then its dual is injective. -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] {Mâ‚ : Type v} {Mâ‚‚ : Type v'} [inst_1 : AddCommMonoid Mâ‚] [inst_2 : Module R Mâ‚]\n  [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R Mâ‚‚] {f : Mâ‚ â†’â‚—[R] Mâ‚‚},\n  Function.Surjective â†‘f â†’ Function.Injective â†‘(LinearMap.dualMap f) :=\n\n/-- If a bounded linear map is a bijection, then its inverse is also a bounded linear map. -/\ntheorem âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E â‰ƒâ‚—[ğ•œ] F),\n  Continuous â†‘e â†’ Continuous â†‘(LinearEquiv.symm e) :=\n\n/-- A monomorphism is injective. -/\ntheorem âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_3} {Mâ‚‚ : Type u_4} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\n  {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\n  (âˆ€ (u v : { x // x âˆˆ LinearMap.ker f } â†’â‚—[R] M), LinearMap.comp f u = LinearMap.comp f v â†’ u = v) â†’\n    LinearMap.ker f = âŠ¥ :=\n\n/-- A morphism in `Type u` is an isomorphism if and only if it is bijective. -/\ntheorem âˆ€ {X Y : Type u} (f : X âŸ¶ Y), CategoryTheory.IsIso f â†” Function.Bijective f :=\n\n/-- The map sending a congruence relation to its underlying equivalence relation is injective. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {c d : Con M}, c.toSetoid = d.toSetoid â†’ c = d :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- In any concrete category, injective morphisms are monomorphisms. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y : C} (f : X âŸ¶ Y),\n  Function.Injective â†‘f â†’ CategoryTheory.Mono f :=\n\n/-- On a finite-dimensional space, a linear map is injective if and only if it is surjective. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†” Function.Surjective â†‘f :=\n\n/-- The map sending a congruence relation to its underlying binary relation is injective. -/\ntheorem âˆ€ {M : Type u_1} [inst : Mul M] {c d : Con M}, Setoid.r = Setoid.r â†’ c = d :=\n\n/-- Composing with a surjective linear map is injective. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_4}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Î¹ : Type u_5} {Mâ‚‚ : Type u_2} [inst_5 : AddCommMonoid Mâ‚‚]\n  [inst_6 : Module R Mâ‚‚] (f : Mâ‚‚ â†’â‚—[R] M),\n  Function.Surjective â†‘f â†’ Function.Injective fun g => AlternatingMap.compLinearMap g f :=\n\n/-- If each of two types can be mapped injectively into the other, then there is a bijection between them. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î² â†’ Î±},\n  Function.Injective eâ‚ â†’ Function.Injective eâ‚‚ â†’ âˆƒ (e : Î± â‰ƒ Î²), True ", "âˆ€ {X Y : Type u}, (âˆƒ (f : X â†’ Y), Function.Injective f) â†’ (âˆƒ (g : Y â†’ X), Function.Injective g) â†’ Nonempty (X â‰ƒ Y) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (eâ‚ : Î± â†’ Î²) (eâ‚‚ : Î² â†’ Î±),\n  Function.Injective eâ‚ â†’ Function.Injective eâ‚‚ â†’ âˆƒ (f : Î± â‰ƒ Î²), True ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²), Function.Injective f â†’ (âˆƒ (g : Î² â†’ Î±), Function.Injective g) â†’\n  Nonempty (Î± â‰ƒ Î²) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î² â†’ Î±},\n  Function.Injective eâ‚ â†’ Function.Injective eâ‚‚ â†’ Nonempty (Î± â‰ƒ Î²) ", "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ Nonempty (Î± â‰ƒ Î²) ", "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±),\n  Function.Injective f â†’ Function.Injective g â†’ (âˆƒ (h : Î± â‰ƒ Î²), âˆ€ (x : Î±), f x = h x) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (e : Î± â†’ Î²) (f : Î² â†’ Î±),\n  Function.Injective e â†’ Function.Injective f â†’ Nonempty (Î± â‰ƒ Î²) "]}, {"stmt": "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.", "prompts": "[{\"theorem\":\n  \"âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\\n  SimpleGraph.minDegree G â‰¤ SimpleGraph.degree G v\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimum degree in the graph is at most the degree of any particular vertex. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (G : SimpleGraph Î±) {s : Set Î±}, SimpleGraph.IsClique G s â†” SimpleGraph.induce s G = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A clique is a set of vertices whose induced graph is complete. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\\n  SimpleGraph.degree G v â‰¤ SimpleGraph.maxDegree G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximum degree in the graph is at least the degree of any particular vertex. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) {v w : V},\\n  SimpleGraph.Adj G v w â†” v â‰  w âˆ§ âˆƒ e, e âˆˆ SimpleGraph.edgeSet G âˆ§ v âˆˆ e âˆ§ w âˆˆ e\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vertices are adjacent iff there is an edge between them. The\\ncondition `v â‰  w` ensures they are different endpoints of the edge,\\nwhich is necessary since when `v = w` the existential\\n`âˆƒ (e âˆˆ G.edgeSet), v âˆˆ e âˆ§ w âˆˆ e` is satisfied by every edge\\nincident to `v`. \"}]\n", "prompt_cons": "/-- A locally finite preconnected infinite graph has at least one end. -/\ntheorem âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G) :=\n\n/-- The minimum degree in the graph is at most the degree of any particular vertex. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\n  SimpleGraph.minDegree G â‰¤ SimpleGraph.degree G v :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K) :=\n\n/-- A clique is a set of vertices whose induced graph is complete. -/\ntheorem âˆ€ {Î± : Type u_1} (G : SimpleGraph Î±) {s : Set Î±}, SimpleGraph.IsClique G s â†” SimpleGraph.induce s G = âŠ¤ :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T1Space Î±] (x : Î±) {s : Set Î±},\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x} :=\n\n/-- The maximum degree in the graph is at least the degree of any particular vertex. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\n  SimpleGraph.degree G v â‰¤ SimpleGraph.maxDegree G :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val :=\n\n/-- Two vertices are adjacent iff there is an edge between them. The\ncondition `v â‰  w` ensures they are different endpoints of the edge,\nwhich is necessary since when `v = w` the existential\n`âˆƒ (e âˆˆ G.edgeSet), v âˆˆ e âˆ§ w âˆˆ e` is satisfied by every edge\nincident to `v`. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) {v w : V},\n  SimpleGraph.Adj G v w â†” v â‰  w âˆ§ âˆƒ e, e âˆˆ SimpleGraph.edgeSet G âˆ§ v âˆˆ e âˆ§ w âˆˆ e :=\n\n/-- A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices. -/\ntheorem", "choices": ["âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ x, SimpleGraph.Adj G x v âˆ§ SimpleGraph.Adj G x w âˆ§ âˆ€ (y : V), SimpleGraph.Adj G y v âˆ§ SimpleGraph.Adj G y w â†’ y = x) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! u, SimpleGraph.Adj G v u âˆ§ SimpleGraph.Adj G w u) â†’ âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), SimpleGraph.Adj G v u âˆ§ SimpleGraph.Adj G w u) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), âˆƒ! u, SimpleGraph.Adj G u v âˆ§ SimpleGraph.Adj G u w) â†’ âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), u â‰  v âˆ§ u â‰  w âˆ§ SimpleGraph.Adj G u v âˆ§ SimpleGraph.Adj G u w) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ v w, v â‰  w â†’ ExistsUnique (Î» x, SimpleGraph.Adj G v x âˆ§ SimpleGraph.Adj G x w)) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), SimpleGraph.Adj G v u âˆ§ SimpleGraph.Adj G u w) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), âˆƒ! (x : V), SimpleGraph.Adj G x v âˆ§ SimpleGraph.Adj G x w) â†’ âˆƒ (x : V), âˆ€ (v : V), v â‰  x â†’ SimpleGraph.Adj G x v ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), SimpleGraph.Adj G v u âˆ§ SimpleGraph.Adj G w u) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w ", "âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (âˆ€ (v w : V), v â‰  w â†’ âˆƒ! (u : V), SimpleGraph.Adj G v u âˆ§ SimpleGraph.Adj G w u) â†’\n  âˆƒ (v : V), âˆ€ (w : V), w â‰  v â†’ SimpleGraph.Adj G v w "]}, {"stmt": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\\n  {G : SimpleGraph Î±} {Îµ : â„},\\n  Finset.card P.parts * 16 ^ Finset.card P.parts â‰¤ Fintype.card Î± â†’\\n    Â¬Finpartition.IsUniform P G Îµ â†’\\n      Finset.card (SzemerediRegularity.increment hP G Îµ).parts = SzemerediRegularity.stepBound (Finset.card P.parts)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The increment partition has a prescribed (very big) size in terms of the original partition. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : OrderBot Î±] {a : Î±} (self : Finpartition a), Finset.SupIndep self.parts id\",\n  \"isProp\": true,\n  \"docString\": \"The partition is supremum-independent \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition â†‘f.parts\",\n  \"isProp\": true,\n  \"docString\": \"A finpartition gives rise to a setoid partition \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} {r : Setoid Î±} (a : Î±), âˆƒ! b x, a âˆˆ b\",\n  \"isProp\": true,\n  \"docString\": \"Equivalence classes partition the type. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {G : SimpleGraph Î±} {Îµ : â„} [inst_1 : Nonempty Î±]\\n  (hP : Finpartition.IsEquipartition P),\\n  7 â‰¤ Finset.card P.parts â†’\\n    100 < 4 ^ Finset.card P.parts * Îµ ^ 5 â†’\\n      Finset.card P.parts * 16 ^ Finset.card P.parts â‰¤ Fintype.card Î± â†’\\n        Â¬Finpartition.IsUniform P G Îµ â†’\\n          Îµ â‰¤ 1 â†’\\n            â†‘(Finpartition.energy P G) + Îµ ^ 5 / 4 â‰¤ â†‘(Finpartition.energy (SzemerediRegularity.increment hP G Îµ) G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The increment partition has energy greater than the original one by a known fixed amount. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [inst : AddCommMonoid Î²] (R : Setoid Î±)\\n  [inst_1 : DecidableRel Setoid.r],\\n  (Finset.sum s fun x => f x) =\\n    Finset.sum (Finset.image Quotient.mk'' s) fun xbar =>\\n      Finset.sum (Finset.filter (fun x => Quotient.mk R x = xbar) s) fun y => f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ Set Î±} (hs : IndexedPartition s) (x : IndexedPartition.Quotient hs),\\n  IndexedPartition.index hs (Quotient.out' x) = IndexedPartition.index hs (â†‘(IndexedPartition.out hs) x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indices of `Quotient.out'` and `IndexedPartition.out` are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [inst : AddCommMonoid Î²] (R : Setoid Î±)\\n  [inst_1 : DecidableRel Setoid.r],\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ (Finset.sum (Finset.filter (fun y => y â‰ˆ x) s) fun a => f a) = 0) â†’\\n    (Finset.sum s fun x => f x) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"}]\n", "prompt_cons": "/-- The increment partition has a prescribed (very big) size in terms of the original partition. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\n  {G : SimpleGraph Î±} {Îµ : â„},\n  Finset.card P.parts * 16 ^ Finset.card P.parts â‰¤ Fintype.card Î± â†’\n    Â¬Finpartition.IsUniform P G Îµ â†’\n      Finset.card (SzemerediRegularity.increment hP G Îµ).parts = SzemerediRegularity.stepBound (Finset.card P.parts) :=\n\n/-- The partition is supremum-independent -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : OrderBot Î±] {a : Î±} (self : Finpartition a), Finset.SupIndep self.parts id :=\n\n/-- A finpartition gives rise to a setoid partition -/\ntheorem âˆ€ {Î± : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition â†‘f.parts :=\n\n/-- Equivalence classes partition the type. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Setoid Î±} (a : Î±), âˆƒ! b x, a âˆˆ b :=\n\n/-- The increment partition has energy greater than the original one by a known fixed amount. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {G : SimpleGraph Î±} {Îµ : â„} [inst_1 : Nonempty Î±]\n  (hP : Finpartition.IsEquipartition P),\n  7 â‰¤ Finset.card P.parts â†’\n    100 < 4 ^ Finset.card P.parts * Îµ ^ 5 â†’\n      Finset.card P.parts * 16 ^ Finset.card P.parts â‰¤ Fintype.card Î± â†’\n        Â¬Finpartition.IsUniform P G Îµ â†’\n          Îµ â‰¤ 1 â†’\n            â†‘(Finpartition.energy P G) + Îµ ^ 5 / 4 â‰¤ â†‘(Finpartition.energy (SzemerediRegularity.increment hP G Îµ) G) :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- A sum can be partitioned into a sum of sums, each equivalent under a setoid. -/\ntheorem âˆ€ {Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [inst : AddCommMonoid Î²] (R : Setoid Î±)\n  [inst_1 : DecidableRel Setoid.r],\n  (Finset.sum s fun x => f x) =\n    Finset.sum (Finset.image Quotient.mk'' s) fun xbar =>\n      Finset.sum (Finset.filter (fun x => Quotient.mk R x = xbar) s) fun y => f y :=\n\n/-- The indices of `Quotient.out'` and `IndexedPartition.out` are equal. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ Set Î±} (hs : IndexedPartition s) (x : IndexedPartition.Quotient hs),\n  IndexedPartition.index hs (Quotient.out' x) = IndexedPartition.index hs (â†‘(IndexedPartition.out hs) x) :=\n\n/-- If we can partition a sum into subsets that cancel out, then the whole sum cancels. -/\ntheorem âˆ€ {Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [inst : AddCommMonoid Î²] (R : Setoid Î±)\n  [inst_1 : DecidableRel Setoid.r],\n  (âˆ€ (x : Î±), x âˆˆ s â†’ (Finset.sum (Finset.filter (fun y => y â‰ˆ x) s) fun a => f a) = 0) â†’\n    (Finset.sum s fun x => f x) = 0 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- The number of partitions with odd parts is equal to the number of partitions with distinct parts. -/\ntheorem", "choices": ["Nnreal.sum_partition_odd_eq_distinct : âˆ€ (n : â„•), (Finset.sum (Finset.ico 1 n) (fun k => odd_part_powers k)) = (Finset.sum (Finset.ico 1 n) (fun k => distinct_part_powers k)) ", "âˆ€ {n : â„•}, partition_odd n = partition_distinct n ", "âˆ€ {n : â„•}, Nat.partitions_with_odd_parts n = Nat.partitions_with_distinct_parts n ", "âˆ€ (n : â„•), partition_odd n = partition_distinct n ", "âˆ€ (n : â„•), odd_part_pn n = distinct_part_pn n ", "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {Ï€ : Partition Î±},\n  Finset.card (Finset.filter (Î» b : Finset (Finset Î±), Finset.card b = 1) Ï€.parts) =\n    Finset.card (Finset.filter (Î» b : Finset (Finset Î±), â†‘(Finset.card b) â‰  0 âˆ§ âˆ€ (a : Finset Î±), a âˆˆ b â†’ Finset.card a = 1) Ï€.parts) ", "âˆ€ {n : â„•}, partition_odd_part_count n = partition_distinct_part_count n ", "âˆ€ {n : â„•}, partitions_distinct n = partitions_odd n ", "âˆ€ (n : â„•), \n  Partition.distinct_parts_partition n = Partition.odd_parts_partition n ", "âˆ€ {n : â„•}, (Finset.card (Finset.filter (fun x => Finset.card x.parts = n) (oddPartitions Nat.odd))) =\n  (Finset.card (Finset.filter (fun x => Finset.card x.parts = n) (distinctPartitions Nat.distinct))) "]}, {"stmt": "Every non-empty poset in which every chain has an upper bound contains a maximal element.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\\nthere is a maximal element.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : Set Î±}, IsChain r c â†’ âˆƒ M, IsMaxChain r M âˆ§ c âŠ† M\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\\n\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (c : Set (Ideal R)),\\n  c âŠ† nonPrincipals R â†’\\n    IsChain (fun x x_1 => x â‰¤ x_1) c â†’\\n      âˆ€ {K : Ideal R}, K âˆˆ c â†’ âˆƒ I, I âˆˆ nonPrincipals R âˆ§ âˆ€ (J : Ideal R), J âˆˆ c â†’ J â‰¤ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any chain in the set of non-principal ideals has an upper bound which is non-principal.\\n(Namely, the union of the chain is such an upper bound.)\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteBooleanAlgebra Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ b â‰¤ a) â†’ sSup s â‰¤ a\",\n  \"isProp\": true,\n  \"docString\": \"Any upper bound is more than the set supremum. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : OrderTop Î±] (s : Set Î±), BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"When there is a global maximum, every set is bounded above. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {I : Set Î²} {S : Î² â†’ Set Î±},\\n  Set.Finite I â†’ (BddAbove (â‹ƒ (i : Î²) (_ : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ BddAbove (S i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded above.\"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type w} [inst : SemilatticeSup Î³] {s t : Set Î³}, BddAbove (s âˆª t) â†” BddAbove s âˆ§ BddAbove t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"}]\n", "prompt_cons": "/-- A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\nthere is a maximal element. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m :=\n\n/-- **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m :=\n\n/-- Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle. -/\ntheorem âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : Set Î±}, IsChain r c â†’ âˆƒ M, IsMaxChain r M âˆ§ c âŠ† M :=\n\n/-- Any chain in the set of non-principal ideals has an upper bound which is non-principal.\n(Namely, the union of the chain is such an upper bound.) -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (c : Set (Ideal R)),\n  c âŠ† nonPrincipals R â†’\n    IsChain (fun x x_1 => x â‰¤ x_1) c â†’\n      âˆ€ {K : Ideal R}, K âˆˆ c â†’ âˆƒ I, I âˆˆ nonPrincipals R âˆ§ âˆ€ (J : Ideal R), J âˆˆ c â†’ J â‰¤ I :=\n\n/-- Any upper bound is more than the set supremum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteBooleanAlgebra Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ b â‰¤ a) â†’ sSup s â‰¤ a :=\n\n/-- When there is a global maximum, every set is bounded above. -/\ntheorem âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : OrderTop Î±] (s : Set Î±), BddAbove s :=\n\n/-- A finite union of sets which are all bounded above is still bounded above. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {I : Set Î²} {S : Î² â†’ Set Î±},\n  Set.Finite I â†’ (BddAbove (â‹ƒ (i : Î²) (_ : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ BddAbove (S i)) :=\n\n/-- A finite set is bounded above. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddAbove s :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem âˆ€ {Î³ : Type w} [inst : SemilatticeSup Î³] {s t : Set Î³}, BddAbove (s âˆª t) â†” BddAbove s âˆ§ BddAbove t :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- Every non-empty poset in which every chain has an upper bound contains a maximal element. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : PartialOrder Î±] [inst_1 : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain (â‰¤) c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ a â‰¤ ub) â†’\n    âˆƒ m, âˆ€ (a : Î±), m â‰¤ a â†’ a â‰¤ m ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain (fun a b => a â‰¤ b) c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ a â‰¤ ub) â†’\n    âˆƒ m, âˆ€ (a : Î±), m â‰¤ a â†’ a â‰¤ m ", "forall {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m ", "forall {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [inst : Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain r c â†’ Set.Nonempty c â†’ âˆƒ ub, âˆ€ (a : Î±), a âˆˆ c â†’ r a ub) â†’\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m "]}, {"stmt": "A group whose automorphism group is cyclic is Abelian.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `â„¤` is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"}]\n", "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- Abelian groups are nilpotent -/\ntheorem âˆ€ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Every subgroup of `â„¤` is cyclic. -/\ntheorem âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a} :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- A group whose automorphism group is cyclic is Abelian. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], AddCommGroup G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ", "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (Aut G) â†’ IsAbelian G ", "âˆ€ {G : Type u_1} [inst : Group G] (hG : IsCyclic (Aut G)), CommGroup G ", "forall {Î± : Type u} [inst : Group Î±] (h : IsCyclic (Aut Î±)), IsAbelian Î± ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype (Aut Î±)], IsCyclic (Aut Î±) â†’ IsAbelian Î± ", "âˆ€ {Î± : Type u_1} [inst : Group Î±] [inst_1 : Fintype (End Î±)], IsCyclic (End Î±) â†’ IsAbelian Î± ", "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (Aut G) â†’ IsAbelian G ", "âˆ€ {G : Type u_1} [inst : Group G], IsCyclic (Aut G) â†’ AddCommGroup G "]}, {"stmt": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"}]\n", "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’áµ¤ Î²) (g : Î² â†’áµ¤ Î³), UniformContinuous (g.toFun âˆ˜ f.toFun) "]}, {"stmt": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±),\\n      x âˆˆ s â†’\\n        âˆ€ (u : Set (Î² Ã— Î²)),\\n          u âˆˆ uniformity Î² â†’\\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"}]\n", "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u) â†’ ContinuousOn f s :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±),\n      x âˆˆ s â†’\n        âˆ€ (u : Set (Î² Ã— Î²)),\n          u âˆˆ uniformity Î² â†’\n            âˆƒ t, t âˆˆ nhdsWithin x s âˆ§ âˆƒ F, ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    ContinuousOn f s :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "forall {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³),\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "forall {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  (f : Î± â†’ Î²) (g : Î² â†’ Î³), UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] [inst_2 : UniformSpace Î³]\n  {f : Î± â†’ Î²} {g : Î² â†’ Î³}, UniformContinuous f â†’ UniformContinuous g â†’ UniformContinuous (g âˆ˜ f) "]}, {"stmt": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\\n  IsSpectralMap f â†’ âˆ€ â¦ƒs : Set Î²â¦„, IsOpen s â†’ IsCompact s â†’ IsCompact (f â»Â¹' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function between topological spaces is spectral if it is continuous and the preimage of\\nevery compact open set is compact open. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any finer topology on the source space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\\n  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any coarser topology on the target space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {Î² : Type u_1} [inst : TopologicalSpace Î²]\\n  [inst_1 : TopologicalSpace.SeparableSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î²],\\n  TopologicalSpace.SeparableSpace (Î± Ã— Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two separable spaces is a separable space. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"}]\n", "prompt_cons": "/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î± :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î± :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : NormalSpace Î±] (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t :=\n\n/-- A function between topological spaces is spectral if it is continuous and the preimage of\nevery compact open set is compact open. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  IsSpectralMap f â†’ âˆ€ â¦ƒs : Set Î²â¦„, IsOpen s â†’ IsCompact s â†’ IsCompact (f â»Â¹' s) :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any finer topology on the source space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any coarser topology on the target space. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\n  tâ‚‚ â‰¤ tâ‚ƒ â†’ âˆ€ {s : Set Î±} {f : Î± â†’ Î²}, ContinuousOn f s â†’ ContinuousOn f s :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- The product of two separable spaces is a separable space. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {Î² : Type u_1} [inst : TopologicalSpace Î²]\n  [inst_1 : TopologicalSpace.SeparableSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î²],\n  TopologicalSpace.SeparableSpace (Î± Ã— Î²) :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ f s âŠ† (0 : Set â„) âˆ§ f t âŠ† (1 : Set â„) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’\n  âˆƒ f : Î± â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ x âˆˆ t, f x = 1) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’\n  âˆƒ (f : Î± â†’ â„), Continuous f âˆ§ (âˆ€ (x : Î±), x âˆˆ s â†’ f x = 0) âˆ§ (âˆ€ (x : Î±), x âˆˆ t â†’ f x = 1) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : Î± â†’ â„, Continuous f âˆ§ (âˆ€ x âˆˆ s, f x = 0) âˆ§ (âˆ€ y âˆˆ t, f y = 1) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†” âˆ€ (s t : Set Î±),\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, ContinuousOn f (s âˆª t) âˆ§ âˆ€ x âˆˆ s, f x = 0 âˆ§ âˆ€ x âˆˆ t, f x = 1 ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ (s t : Set Î±), Disjoint s t â†’ IsClosed s â†’ IsClosed t â†’\n  âˆƒ (f : Î± â†’ â„), Continuous f âˆ§ âˆ€ (x : Î±), HasMem.Mem x s â†’ f x = 0 âˆ§ âˆ€ (x : Î±), HasMem.Mem x t â†’ f x = 1 ", "forall {Î± : Type u} [t : TopologicalSpace Î±],\n  NormalSpace Î± â†” âˆ€ {s t : Set Î±}, IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒf : Î± â†’ â„, Continuous f âˆ§ âˆ€ x âˆˆ s, f x = 0 âˆ§ âˆ€ x âˆˆ t, f x = 1 ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†”\n  âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, ContinuousOn f s âˆ§ ContinuousOn f t âˆ§ âˆ€ x, f x âˆˆ [0, 1] ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f : Î± â†’ â„, Continuous f âˆ§ f '' s âŠ† (0:â„) âˆ§ f '' t âŠ† (1:â„) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], NormalSpace Î± â†” âˆ€ (s t : Set Î±), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ âˆƒ f, Continuous f âˆ§ f =á¶ [ğ“Ÿ s] 0 âˆ§ f =á¶ [ğ“Ÿ t] 1 "]}, {"stmt": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ pâ‚… : P},\\n  pâ‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚ƒ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ Collinear k {pâ‚, pâ‚‚, pâ‚ƒ}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If three points lie in the affine span of two points, the first three points are collinear. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\\n  EuclideanGeometry.Cospherical s â†’\\n    âˆ€ {pâ‚ pâ‚‚ pâ‚ƒ : P}, pâ‚ âˆˆ s â†’ pâ‚‚ âˆˆ s â†’ pâ‚ƒ âˆˆ s â†’ pâ‚ â‰  pâ‚‚ â†’ pâ‚ â‰  pâ‚ƒ â†’ pâ‚‚ â‰  pâ‚ƒ â†’ AffineIndependent â„ ![pâ‚, pâ‚‚, pâ‚ƒ]\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any three points in a cospherical set are affinely independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x : Î±), âˆƒ y, y âˆˆ Set.Ico 0 c âˆ§ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y âˆˆ Ico 0 c` such that `f x = f y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x a : Î±), âˆƒ y, y âˆˆ Set.Ico a (a + c) âˆ§ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y âˆˆ Ico a (a + c)` such that `f x = f y`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ IsCompact (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function has compact range. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (pâ‚ pâ‚‚ pâ‚ƒ : P), Coplanar k {pâ‚, pâ‚‚, pâ‚ƒ}\",\n  \"isProp\": true,\n  \"docString\": \"Three points are coplanar. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P},\\n  Â¬Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ} â†’ 0 < Real.sin (EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If three points are not collinear, the sine of the angle between them is positive. \"}]\n", "prompt_cons": "/-- Any point is a periodic point of period `0`. -/\ntheorem âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x :=\n\n/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x :=\n\n/-- If three points lie in the affine span of two points, the first three points are collinear. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ pâ‚… : P},\n  pâ‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚ƒ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ Collinear k {pâ‚, pâ‚‚, pâ‚ƒ} :=\n\n/-- Any three points in a cospherical set are affinely independent. -/\ntheorem âˆ€ {V : Type u_2} {P : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\n  EuclideanGeometry.Cospherical s â†’\n    âˆ€ {pâ‚ pâ‚‚ pâ‚ƒ : P}, pâ‚ âˆˆ s â†’ pâ‚‚ âˆˆ s â†’ pâ‚ƒ âˆˆ s â†’ pâ‚ â‰  pâ‚‚ â†’ pâ‚ â‰  pâ‚ƒ â†’ pâ‚‚ â‰  pâ‚ƒ â†’ AffineIndependent â„ ![pâ‚, pâ‚‚, pâ‚ƒ] :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y âˆˆ Ico 0 c` such that `f x = f y`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x : Î±), âˆƒ y, y âˆˆ Set.Ico 0 c âˆ§ f x = f y :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y âˆˆ Ico a (a + c)` such that `f x = f y`. -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [inst : LinearOrderedAddCommGroup Î±] [inst_1 : Archimedean Î±],\n  Function.Periodic f c â†’ 0 < c â†’ âˆ€ (x a : Î±), âˆƒ y, y âˆˆ Set.Ico a (a + c) âˆ§ f x = f y :=\n\n/-- A continuous, periodic function has compact range. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : â„ â†’ Î±} {c : â„},\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ IsCompact (Set.range f) :=\n\n/-- Three points are coplanar. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (pâ‚ pâ‚‚ pâ‚ƒ : P), Coplanar k {pâ‚, pâ‚‚, pâ‚ƒ} :=\n\n/-- If three points are not collinear, the sine of the angle between them is positive. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P},\n  Â¬Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ} â†’ 0 < Real.sin (EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ) :=\n\n/-- If a function from the unit interval to itself has a point of period three, then it has points of all positive periods. -/\ntheorem", "choices": ["/-- Any point is a periodic point of period `0`. -/\ntheorem is_periodic_pt_zero {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : Function.IsPeriodicPt f 0 x ", "forall {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] {f : Î± â†’ Î±},\n  ContinuousOn f (Set.Icc 0 1) â†’\n  (âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) â†’\n  âˆ€ n, âˆƒ x âˆˆ Set.Icc 0 1, Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±]\n  [inst_3 : MeasurableSpace Î±] [inst_4 : OpensMeasurableSpace Î±], IsUnitInterval Î± â†’\n    (âˆƒ x, Function.IsPeriodicPt f 3 x) â†’ âˆ€ (n : â„•), n > 0 â†’ âˆƒ x, Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) [inst : LinearOrderedField Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±],\n  0 < Î± â†’ 1 < Î± â†’ (âˆƒ x, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n : â„•, 0 < n â†’ âˆƒ x, Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : ConditionallyCompleteLinearOrder Î±] [inst_2 : Archimedean Î±]\n  {f : â„ â†’ Î±} (hf : ContinuousOn f (Set.Icc 0 1)) (hâ‚€ : âˆ€ x, HasMem.Mem x (Set.Icc 0 1) â†’ HasMem.Mem (f x) (Set.Icc 0 1))\n  {x : â„} (hx : HasMem.Mem x (Set.Icc 0 1)) (h3 : Function.IsPeriodicPt f 3 x),\n  âˆ€ (n : â„•), n > 0 â†’ âˆƒ y, HasMem.Mem y (Set.Icc 0 1) âˆ§ Function.IsPeriodicPt f n y ", "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderConnectedTopology Î±]\n  [inst_3 : DenselyOrdered Î±] {f : Î± â†’ Î±} [inst_4 : HasForallOrdCont f],\n  Î± = Set.Icc (0 : Î±) 1 â†’ (âˆƒ x, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n, âˆƒ x, Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenseOrder Î±] {f : Î± â†’ Î±},\n  (âˆƒ x âˆˆ Set.Icc (0 : Î±) 1, Function.IsPeriodicPt f 3 x) â†’ âˆ€ n, âˆƒ x âˆˆ Set.Icc (0 : Î±) 1, Function.IsPeriodicPt f n x ", "forall {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), \n  Function.IsPeriodicPt f 3 x â†’ âˆ€ (n : â„•), 0 < n â†’ âˆƒ y, Function.IsPeriodicPt f n y ", "forall {Î± : Type u_1} {f : Î± â†’ Î±} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : DenselyOrdered Î±],\n  Function.IsPeriodicPt f 3 (0 : Î±) â†’ âˆ€ n : â„•, 0 < n â†’ âˆƒ x, Function.IsPeriodicPt f n x ", "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : OrderTopology Î±] [inst_3 : FloorRing Î±],\n  0 â‰¤ Î± â†’ Î± â‰¤ 1 â†’\n    (âˆƒ x : Î±, Function.IsPeriodicPt (Î» x, 3 * x) 3 x) â†’\n      âˆ€ (n : â„•), n > 0 â†’ âˆƒ x, Function.IsPeriodicPt (Î» x, 3 * x) n x "]}, {"stmt": "A terminal object in a category is unique up to unique isomorphism.", "prompts": "[{\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (Y âŸ¶ X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f g : Y âŸ¶ X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is mono. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (X âŸ¶ Y)],\\n  CategoryTheory.Limits.HasInitial C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has an initial object by specifying the object,\\nand showing there is a unique morphism from it to any other object. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (I : C),\\n  (âˆ€ (A : C) (f : I âŸ¶ A), CategoryTheory.IsIso f) â†’ CategoryTheory.Limits.HasStrictTerminalObjects C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\\nhas strict terminal objects. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"theorem\":\n  \"âˆ€ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\": \"A category with finite biproducts has a zero object. \"},\n {\"theorem\":\n  \"âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.IsSplitMono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is split mono. \"}]\n", "prompt_cons": "/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (Y âŸ¶ X)],\n  CategoryTheory.Limits.HasTerminal C :=\n\n/-- Any two morphisms to a terminal object are equal. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f g : Y âŸ¶ X), f = g :=\n\n/-- The subcategory of subterminal objects is an exponential ideal. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C) :=\n\n/-- Any morphism from a terminal object is mono. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.Mono f :=\n\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) â†’ Unique (X âŸ¶ Y)],\n  CategoryTheory.Limits.HasInitial C :=\n\n/-- If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\nhas strict terminal objects. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] (I : C),\n  (âˆ€ (A : C) (f : I âŸ¶ A), CategoryTheory.IsIso f) â†’ CategoryTheory.Limits.HasStrictTerminalObjects C :=\n\n/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem âˆ€ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- A category with finite biproducts has a zero object. -/\ntheorem âˆ€ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem âˆ€ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- Any morphism from a terminal object is split mono. -/\ntheorem âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.IsSplitMono f :=\n\n/-- A terminal object in a category is unique up to unique isomorphism. -/\ntheorem", "choices": ["âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C}\n  (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Nonempty (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C]\n  {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Unique (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X â†’ CategoryTheory.Limits.IsTerminal Y â†’ Nonempty (X â‰… Y) ", "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category C] {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X)\n  (hY : CategoryTheory.Limits.IsTerminal Y), Unique (X â‰… Y) "]}, {"stmt": "The complement of the union of two sets is the intersection of their complements.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), frontier sá¶œ = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded s â†’ Metric.Bounded t â†’ Metric.Bounded (s âˆª t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded (s âˆª t) â†” Metric.Bounded s âˆ§ Metric.Bounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Î±} {p : ENNReal} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup E] {s t : Set Î±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hÎ¼s : â†‘â†‘Î¼ s â‰  âŠ¤)\\n  (hÎ¼t : â†‘â†‘Î¼ t â‰  âŠ¤),\\n  s âˆ© t = âˆ… â†’\\n    âˆ€ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s âˆª t)) (_ : â†‘â†‘Î¼ (s âˆª t) â‰  âŠ¤) c =\\n        MeasureTheory.indicatorConstLp p hs hÎ¼s c + MeasureTheory.indicatorConstLp p ht hÎ¼t c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} (self : Filter Î±) {x y : Set Î±}, x âˆˆ self.sets â†’ y âˆˆ self.sets â†’ x âˆ© y âˆˆ self.sets\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets belong to a filter, then their intersection belongs to the filter as well. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C U : Set Î±}, Preperfect C â†’ IsOpen U â†’ Preperfect (U âˆ© C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a preperfect set and an open set is preperfect. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} (S T : Set Î±), Cardinal.mk â†‘(S âˆª T) â‰¤ Cardinal.mk â†‘S + Cardinal.mk â†‘T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"}]\n", "prompt_cons": "/-- The complement of a closed set is an open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ :=\n\n/-- The complement of a set has the same frontier as the original set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), frontier sá¶œ = frontier s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t) :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded s â†’ Metric.Bounded t â†’ Metric.Bounded (s âˆª t) :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±}, Metric.Bounded (s âˆª t) â†” Metric.Bounded s âˆ§ Metric.Bounded t :=\n\n/-- The indicator of a disjoint union of two sets is the sum of the indicators of the sets. -/\ntheorem âˆ€ {Î± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Î±} {p : ENNReal} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup E] {s t : Set Î±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hÎ¼s : â†‘â†‘Î¼ s â‰  âŠ¤)\n  (hÎ¼t : â†‘â†‘Î¼ t â‰  âŠ¤),\n  s âˆ© t = âˆ… â†’\n    âˆ€ (c : E),\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s âˆª t)) (_ : â†‘â†‘Î¼ (s âˆª t) â‰  âŠ¤) c =\n        MeasureTheory.indicatorConstLp p hs hÎ¼s c + MeasureTheory.indicatorConstLp p ht hÎ¼t c :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t) :=\n\n/-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\ntheorem âˆ€ {Î± : Type u_1} (self : Filter Î±) {x y : Set Î±}, x âˆˆ self.sets â†’ y âˆˆ self.sets â†’ x âˆ© y âˆˆ self.sets :=\n\n/-- The intersection of a preperfect set and an open set is preperfect. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C U : Set Î±}, Preperfect C â†’ IsOpen U â†’ Preperfect (U âˆ© C) :=\n\n/-- The cardinality of a union is at most the sum of the cardinalities\nof the two sets. -/\ntheorem âˆ€ {Î± : Type u} (S T : Set Î±), Cardinal.mk â†‘(S âˆª T) â‰¤ Cardinal.mk â†‘S + Cardinal.mk â†‘T :=\n\n/-- The complement of the union of two sets is the intersection of their complements. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆª t)á¶œ = sá¶œ âˆ© tá¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆª tá¶œ = (s âˆ© t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆª tá¶œ = (s âˆ© t)á¶œ ", "âˆ€ {Î± : Type u} (s t : Set Î±), sá¶œ âˆ© tá¶œ = (s âˆª t)á¶œ "]}, {"stmt": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚ƒ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the first and third points are not\\nequal. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the first two points are not\\nequal. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, Pell.IsFundamental a â†’ âˆ€ {n n' : â„¤}, a ^ n â‰  -a ^ n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"A power of a fundamental solution is never equal to the negative of a power of this\\nfundamental solution. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚ƒ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€ / 2`, the first and third points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ â‰  0 â†’ pâ‚ â‰  pâ‚ƒ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is nonzero, the first and third points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€`, the first two points are not equal. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚ƒ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€`, the first and third points are not equal. \"}]\n", "prompt_cons": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- If the sign of the angle between three points is positive, the first and third points are not\nequal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚ƒ :=\n\n/-- If the sign of the angle between three points is positive, the first two points are not\nequal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚‚ :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- A power of a fundamental solution is never equal to the negative of a power of this\nfundamental solution. -/\ntheorem âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, Pell.IsFundamental a â†’ âˆ€ {n n' : â„¤}, a ^ n â‰  -a ^ n' :=\n\n/-- If the angle between three points is `Ï€ / 2`, the first and third points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚ƒ :=\n\n/-- If the angle between three points is nonzero, the first and third points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ â‰  0 â†’ pâ‚ â‰  pâ‚ƒ :=\n\n/-- If the angle between three points is `Ï€`, the first two points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚‚ :=\n\n/-- If the angle between three points is `Ï€`, the first and third points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚ƒ :=\n\n/-- The sum of the cubes of two positive integers is never equal to the cube of a third integer. -/\ntheorem", "choices": ["âˆ€ {a b c : â„•}, 0 < a â†’ 0 < b â†’ a ^ 3 + b ^ 3 â‰  c ^ 3 ", "âˆ€ {x y z : â„•}, x > 0 â†’ y > 0 â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, x > 0 â†’ y > 0 â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, x > 0 â†’ y > 0 â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, 0 < x â†’ 0 < y â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 ", "âˆ€ {x y z : â„•}, x > 0 â†’ y > 0 â†’ x ^ 3 + y ^ 3 â‰  z ^ 3 "]}, {"stmt": "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.", "prompts": "[{\"theorem\": \"âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\": \"âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"}]\n", "prompt_cons": "/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem âˆ€ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c) :=\n\n/-- If every element of a group `G` has order `2`, then every pair of elements of `G` commutes. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (a : G), a * a = 1) â†’ âˆ€ (a b : G), Commute a b ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ g : G, g ^ 2 = 1) â†’ âˆ€ a b : G, Commute a b ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (a b : G), Commute a b ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (a b : G), Commute a b ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (a b : G), Commute a b ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (x y : G), Commute x y ", "âˆ€ {G : Type u_1} [inst : Group G], (âˆ€ (x : G), x * x = 1) â†’ âˆ€ (a b : G), Commute a b "]}, {"stmt": "The product of two consecutive natural numbers is even.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±] (a b : Î±), 0 < a â†’ 0 < b â†’ 0 < a * b\",\n  \"isProp\": true,\n  \"docString\": \"The product of two positive elements is positive. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (âˆ€ (a : R), a âˆˆ l â†’ 0 < a) â†’ 0 < List.prod l\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a list of positive natural numbers is positive,\\nand likewise for any nontrivial ordered semiring. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Even (m ^ n) â†” Even m âˆ§ n â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m` and `n` are natural numbers, then the natural number `m^n` is even\\nif and only if `m` is even and `n` is positive. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- The product of two positive elements is positive. -/\ntheorem âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±] (a b : Î±), 0 < a â†’ 0 < b â†’ 0 < a * b :=\n\n/-- The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring. -/\ntheorem âˆ€ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (âˆ€ (a : R), a âˆˆ l â†’ 0 < a) â†’ 0 < List.prod l :=\n\n/-- If `m` and `n` are natural numbers, then the natural number `m^n` is even\nif and only if `m` is even and `n` is positive. -/\ntheorem âˆ€ {m n : â„•}, Even (m ^ n) â†” Even m âˆ§ n â‰  0 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- A product of finite numbers is still finite -/\ntheorem âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤ :=\n\n/-- The product of two consecutive natural numbers is even. -/\ntheorem", "choices": ["âˆ€ (n : â„•), Even (n * (n + 1)) ", "âˆ€ {n : â„•}, Even (n * (n + 1)) ", "âˆ€ {n : â„•}, Even (n * (n + 1)) ", "âˆ€ {m : â„•}, Even (m * (m + 1)) ", "âˆ€ {m : â„•}, Even (m * (m + 1)) ", "âˆ€ {m : â„•}, Even (m * (m + 1)) ", "âˆ€ {n : â„•}, Even (n * (n + 1)) ", "âˆ€ (n : â„•), Even (n * (n + 1)) ", "âˆ€ {m n : â„•}, n = m + 1 â†’ Even (m * n) ", "âˆ€ {n : â„•}, Even (n * (n + 1)) "]}, {"stmt": "Every index 2 subgroup of a group is normal.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\\nof `b * a` and `b` belong to `H`. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H â†’ H = âŠ¥ âˆ¨ H = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"Any normal subgroup is either `âŠ¥` or `âŠ¤` \"}]\n", "prompt_cons": "/-- The subgroup has finite index -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0 :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y :=\n\n/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†” âˆƒ a, âˆ€ (b : G), Xor' (b * a âˆˆ H) (b âˆˆ H) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- Any normal subgroup is either `âŠ¥` or `âŠ¤` -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H â†’ H = âŠ¥ âˆ¨ H = âŠ¤ :=\n\n/-- Every index 2 subgroup of a group is normal. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "forall {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H ", "âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 â†’ Subgroup.Normal H "]}, {"stmt": "Every free group is torsion free.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"}]\n", "prompt_cons": "/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G :=\n\n/-- Every free group is torsion free. -/\ntheorem", "choices": ["âˆ€ {Î¹ : Type u_1} (M : Î¹ â†’ Type u_2) [inst : (i : Î¹) â†’ Group (M i)], Monoid.IsTorsionFree (FreeGroup (((i : Î¹) â†’ M i))) ", "forall {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype Î±], IsFreeGroup G â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G], Group.IsFree G â†’ Monoid.IsTorsionFree G ", "âˆ€ {G : Type u_1} [inst : Group G] [hF : FreeGroup G], Monoid.IsTorsionFree G ", "âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Nonempty Î±], Monoid.IsTorsionFree (FreeGroup Î±) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ", "forall {Î¹ : Type u_1} {G : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Group (G i)],\n  (âˆ€ (F : FreeGroup (Î¹, G)), Monoid.IsTorsionFree F) ", "forall {Î¹ : Type u_1} {G : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Group (G i)] (F : FreeGroup G),\n  Monoid.IsTorsionFree (FreeGroup G) ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ", "âˆ€ {Î± : Type u_1} {G : Type u_2} [inst : Group G] (f : Î± â†’ G), Monoid.IsTorsionFree (FreeGroup Î±) "]}, {"stmt": "Every natural number greater than `1` is divisible by a prime number.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"âˆ€ (n p : â„•), Finset.card (Finset.filter (fun e => p âˆ£ e + 1) (Finset.range n)) = n / p\",\n  \"isProp\": true,\n  \"docString\": \"Exactly `n / p` naturals in `[1, n]` are multiples of `p`. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- Exactly `n / p` naturals in `[1, n]` are multiples of `p`. -/\ntheorem âˆ€ (n p : â„•), Finset.card (Finset.filter (fun e => p âˆ£ e + 1) (Finset.range n)) = n / p :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- Every natural number greater than `1` is divisible by a prime number. -/\ntheorem", "choices": ["âˆ€ n : â„•, 1 < n â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ", "âˆ€ (n : â„•), 1 < n â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•) [inst : Fact (Nat.Prime p)], p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ {n : â„•}, n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n ", "âˆ€ (n : â„•), n > 1 â†’ âˆƒ (p : â„•), Nat.Prime p âˆ§ p âˆ£ n "]}, {"stmt": "A finite torsion-free group is trivial", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"}]\n", "prompt_cons": "/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- A finite torsion-free group is trivial -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G],\n  Monoid.IsTorsionFree G â†’ IsTrivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G â†’ Trivial G "]}, {"stmt": "Every finite division ring is a field.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V â†” Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is algebraic if it is finite. \"}]\n", "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- A subfield is closed under division. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î± :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsNoetherian K V â†” Module.Finite K V :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- A field extension is algebraic if it is finite. -/\ntheorem âˆ€ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L :=\n\n/-- Every finite division ring is a field. -/\ntheorem", "choices": ["âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (D : Type u) [inst : DivisionRing D] [inst_1 : Fintype D], Field D ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ", "âˆ€ (R : Type u) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "âˆ€ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], Field R "]}, {"stmt": "Every finite topological space is compact.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î±\",\n  \"isProp\": true,\n  \"docString\": \"A compact discrete space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± Ã— Î²)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two compact spaces is compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’ â‹ƒ (a : Î±), s a = Set.univ â†’ âˆƒ Î² t x x, LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every open cover of a paracompact space assumes a locally finite refinement. \"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- A compact discrete space is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î± :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- The product of two compact spaces is compact. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : CompactSpace Î²], CompactSpace (Î± Ã— Î²) :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- Every open cover of a paracompact space assumes a locally finite refinement. -/\ntheorem âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’ â‹ƒ (a : Î±), s a = Set.univ â†’ âˆƒ Î² t x x, LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a :=\n\n/-- Every finite topological space is compact. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "Finite.toCompactSpace : âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Fintype Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "forall {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± "]}, {"stmt": "Every surjective homomorphism from a finitely generated free group to itself is injective.", "prompts": "[{\"theorem\":\n  \"âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Î¹] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R â†’\\n    âˆ€ (ps : Î¹ â†’ MvPolynomial Î¹ R),\\n      (Function.Injective fun v i => â†‘(MvPolynomial.eval v) (ps i)) â†’\\n        Function.Surjective fun v i => â†‘(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Bijective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Bijective â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"}]\n", "prompt_cons": "/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â†‘f :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1) :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Injective â†‘f :=\n\n/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0) :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â†‘f â†’ Function.Surjective â†‘f :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem âˆ€ {Î¹ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite Î¹] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R â†’\n    âˆ€ (ps : Î¹ â†’ MvPolynomial Î¹ R),\n      (Function.Injective fun v i => â†‘(MvPolynomial.eval v) (ps i)) â†’\n        Function.Surjective fun v i => â†‘(MvPolynomial.eval v) (ps i) :=\n\n/-- Any injective endomorphism of an Artinian module is bijective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â†‘f â†’ Function.Bijective â†‘f :=\n\n/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â†‘f â†’ Function.Bijective â†‘f :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), â†‘f aâ»Â¹ = (â†‘f a)â»Â¹ :=\n\n/-- Every surjective homomorphism from a finitely generated free group to itself is injective. -/\ntheorem", "choices": ["âˆ€ {Î¹ : Type u_1} {F : Type u_2} [inst : Group F] [inst_1 : FreeGroup Î¹] [inst_2 : Fintype Î¹] (f : F â†’* F),\n  Function.Surjective â†‘f â†’ Function.Injective â†‘f ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] [inst_2 : Group.IsFree Î±] {f : Î± â†’ Î±},\n  IsGroupHom f â†’ Function.Surjective f â†’ Function.Injective f ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] [inst_2 : Fintype Î±] (f : Î± â†’* Î±),\n  Function.Surjective â†‘f â†’ Function.Injective â†‘f ", "forall {Î± : Type u} [inst : Group Î±] [inst_1 : FinitelyGenerated Î±] [inst_2 : Free Î±],\n  âˆ€ (f : Î± â†’* Î±), Function.Surjective f â†’ Function.Injective f ", "âˆ€ {Î± : Type u} {G : Type v} [inst : Group G] [inst_1 : FreeGroup Î±] [inst_2 : FinitelyGenerated G]\n  (f : G â†’ G), Function.Surjective f â†’ Function.Injective f ", "âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] [inst_2 : IsFinitelyGenerated G]\n  (f : G â†’* G), Function.Surjective â†‘f â†’ Function.Injective â†‘f ", "âˆ€ {Î± : Type u} (f : FreeGroup Î± â†’ FreeGroup Î±),\n  Function.Surjective f â†’ (âˆ€ (G H : Set Î±), Subgroup.Fg (Subgroup.mk G) â†’ Subgroup.Fg (Subgroup.mk H)) â†’ Function.Injective f ", "âˆ€ {Î± : Type u} [inst : Fintype Î±] {F : FreeGroup Î±} {f : FreeGroup Î± â†’* FreeGroup Î±},\n  Function.Surjective â†‘f â†’ Function.Injective â†‘f ", "âˆ€ {Î± : Type u} [inst_1 : Fintype Î±] {G : FreeGroup Î±} (f : G â†’* G), Function.Surjective â†‘f â†’ Function.Injective â†‘f ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {f : Î± â†’* Î±},\n  Function.Surjective â†‘f â†’ Function.Injective â†‘f "]}, {"stmt": "Every positive even integer can be written as the sum of two primes.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•},\\n  a â‰  0 â†’ b â‰  0 â†’ List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) âˆª List.toFinset (Nat.factors b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±] (a b : Î±), 0 < a â†’ 0 < b â†’ 0 < a * b\",\n  \"isProp\": true,\n  \"docString\": \"The product of two positive elements is positive. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\": \"âˆ€ (self : â„š), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b) :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` -/\ntheorem âˆ€ {a b : â„•},\n  a â‰  0 â†’ b â‰  0 â†’ List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) âˆª List.toFinset (Nat.factors b) :=\n\n/-- The product of two positive elements is positive. -/\ntheorem âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±] (a b : Î±), 0 < a â†’ 0 < b â†’ 0 < a * b :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem âˆ€ (self : â„š), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- Every positive even integer can be written as the sum of two primes. -/\ntheorem", "choices": ["Goldbach's_conjecture : âˆ€ (n : â„•), 2 â‰¤ n â†’ n.even â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ (n : â„•), n > 2 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ (n : â„•), n > 2 â†’ Even n â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ {n : â„•}, n > 0 â†’ Even n â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ (n : â„•), 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ (a b : â„•), Nat.Prime a âˆ§ Nat.Prime b âˆ§ n = a + b ", "âˆ€ n : â„•, 2 â‰¤ n â†’ Even n â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "Goldbach's_conjecture : âˆ€ n : â„•, 2 < n â†’ n % 2 = 0 â†’ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ (n : â„•), n > 2 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "âˆ€ {n : â„•}, n > 2 â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q ", "goldbach_conjecture : âˆ€ {n : â„•}, 2 â‰¤ n â†’ n % 2 = 0 â†’ âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ n = p + q "]}, {"stmt": "Every matrix satisfies its own characteristic polynomial.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Î±] [inst_2 : One Î±], Matrix.IsDiag 1\",\n  \"isProp\": true,\n  \"docString\": \"Every identity matrix is diagonal. \"},\n {\"theorem\":\n  \"âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\\n  âˆƒ n f _hf q, p = â†‘(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ x â‰  0 â†’ Polynomial.coeff (minpoly A x) 0 â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M) {Î¹ : Type w} [inst_6 : Fintype Î¹]\\n  (b : Basis Î¹ R M), Matrix.charpoly (â†‘(LinearMap.toMatrix b b) f) = LinearMap.charpoly f\",\n  \"isProp\": true,\n  \"docString\":\n  \"`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\\n  (p : Polynomial R), â†‘(Polynomial.aeval M) p = â†‘(Polynomial.aeval M) (p %â‚˜ Matrix.charpoly M)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any matrix polynomial `p` is equivalent under evaluation to `p %â‚˜ M.charpoly`; that is, `p`\\nis equivalent to a polynomial with degree less than the dimension of the matrix. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {M : Type u_3} [inst : CommSemiring R] {Ïƒ : Type u_2} [inst_1 : AddCommMonoid M] (w : Ïƒ â†’ M)\\n  (Ï† : MvPolynomial Ïƒ R), âˆ‘á¶  (m : M), â†‘(MvPolynomial.weightedHomogeneousComponent w m) Ï† = Ï†\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every polynomial is the sum of its weighted homogeneous components. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} {n : Type u_2} [inst : Zero Î±], Matrix.IsDiag 0\",\n  \"isProp\": true,\n  \"docString\": \"Every zero matrix is diagonal. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Polynomial.Monic (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is monic. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"}]\n", "prompt_cons": "/-- Every identity matrix is diagonal. -/\ntheorem âˆ€ {Î± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Î±] [inst_2 : One Î±], Matrix.IsDiag 1 :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\n  âˆƒ n f _hf q, p = â†‘(MvPolynomial.rename f) q :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ x â‰  0 â†’ Polynomial.coeff (minpoly A x) 0 â‰  0 :=\n\n/-- `charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. -/\ntheorem âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M) {Î¹ : Type w} [inst_6 : Fintype Î¹]\n  (b : Basis Î¹ R M), Matrix.charpoly (â†‘(LinearMap.toMatrix b b) f) = LinearMap.charpoly f :=\n\n/-- Any matrix polynomial `p` is equivalent under evaluation to `p %â‚˜ M.charpoly`; that is, `p`\nis equivalent to a polynomial with degree less than the dimension of the matrix. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (p : Polynomial R), â†‘(Polynomial.aeval M) p = â†‘(Polynomial.aeval M) (p %â‚˜ Matrix.charpoly M) :=\n\n/-- Every polynomial is the sum of its weighted homogeneous components. -/\ntheorem âˆ€ {R : Type u_1} {M : Type u_3} [inst : CommSemiring R] {Ïƒ : Type u_2} [inst_1 : AddCommMonoid M] (w : Ïƒ â†’ M)\n  (Ï† : MvPolynomial Ïƒ R), âˆ‘á¶  (m : M), â†‘(MvPolynomial.weightedHomogeneousComponent w m) Ï† = Ï† :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I :=\n\n/-- Every zero matrix is diagonal. -/\ntheorem âˆ€ {Î± : Type u_1} {n : Type u_2} [inst : Zero Î±], Matrix.IsDiag 0 :=\n\n/-- A minimal polynomial is monic. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Polynomial.Monic (minpoly A x) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x) :=\n\n/-- Every matrix satisfies its own characteristic polynomial. -/\ntheorem", "choices": ["âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "forall {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Matrix.charpoly M = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 ", "âˆ€ {R : Type u} {n : Type v} [inst : CommRing R] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  Polynomial.aeval M (Matrix.charpoly M) = 0 "]}, {"stmt": "The square root of an irrational number is irrational.", "prompts": "[{\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\": \"Irrational goldenRatio\",\n  \"isProp\": true,\n  \"docString\": \"The golden ratio is irrational. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"âˆ€ {p x : â„}, LiouvilleWith p x â†’ 1 < p â†’ Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"}]\n", "prompt_cons": "/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- The golden ratio is irrational. -/\ntheorem Irrational goldenRatio :=\n\n/-- The natural square root is at most the real square root -/\ntheorem âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. -/\ntheorem âˆ€ {p x : â„}, LiouvilleWith p x â†’ 1 < p â†’ Irrational x :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y :=\n\n/-- The square root of an irrational number is irrational. -/\ntheorem", "choices": ["âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) ", "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ", "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ", "âˆ€ {r : â„}, Irrational r â†’ Irrational (Real.sqrt r) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) ", "âˆ€ {x : â„}, Irrational x â†’ Irrational (Real.sqrt x) "]}, {"stmt": "If the square of a number is even, the number itself is even.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {Ï‡ : MulChar R R'},\\n  MulChar.IsQuadratic Ï‡ â†’ âˆ€ {n : â„•}, Odd n â†’ Ï‡ ^ n = Ï‡\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"}]\n", "prompt_cons": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ğ•œ : Type uğ•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ğ•œ] [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œ E'] [inst_6 : NormedSpace ğ•œ F]\n  (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a â‰  0 â†’ â†‘(quadraticChar F) a ^ 2 = 1 :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- The `n`th power of a quadratic character is itself, when `n` is odd. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {Ï‡ : MulChar R R'},\n  MulChar.IsQuadratic Ï‡ â†’ âˆ€ {n : â„•}, Odd n â†’ Ï‡ ^ n = Ï‡ :=\n\n/-- If the square of a number is even, the number itself is even. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {a : Î±}, a * a % 2 = 0 â†’ a % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†” x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†” x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†’ x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†” x % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x * x % 2 = 0 â†” x % 2 = 0 ", "âˆ€ {n : â„•}, (n * n) % 2 = 0 â†’ n % 2 = 0 "]}, {"stmt": "In a finite commutative ring, all prime ideals are maximal.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ {I : Ideal R}, IsUnit â†‘I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S â‰¤ nonZeroDivisors R â†’\\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R â†” âˆ€ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"}]\n", "prompt_cons": "/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I :=\n\n/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R],\n  Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ {I : Ideal R}, IsUnit â†‘I â†’ Submodule.IsPrincipal I :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I :=\n\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem âˆ€ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\n  [inst_3 : IsLocalization S A],\n  S â‰¤ nonZeroDivisors R â†’\n    Set.Finite {I | Ideal.IsMaximal I} â†’ âˆ€ (I I' : FractionalIdeal S A), I * I' = 1 â†’ Submodule.IsPrincipal â†‘I :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem âˆ€ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R â†” âˆ€ (I : Ideal R), Ideal.FG I :=\n\n/-- In a finite commutative ring, all prime ideals are maximal. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P ", "âˆ€ {R : Type u} [inst : CommRing R] [hR : Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P ", "âˆ€ {R : Type u} [inst : CommRing R] [hR : Fintype R], âˆ€ (I : Ideal R) [Ideal.IsPrime I], Ideal.IsMaximal I ", "âˆ€ {R : Type u} [inst : CommRing R] [hR : Fintype R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [hR : Fintype R], \n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [F : Fintype R], (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsFinite R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Ideal.IsMaximal P) "]}, {"stmt": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heineâ€“Borel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompleteSpace Î±], CompleteSpace (TopologicalSpace.Closeds Î±)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  IsClosed s â†’ IsClosed t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” s = t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two closed sets are at zero Hausdorff distance if and only if they coincide \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"theorem\":\n  \"âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±},\\n  IsClosed s â†’ IsClosed t â†’ (EMetric.hausdorffEdist s t = 0 â†” s = t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two closed sets are at zero Hausdorff edistance if and only if they coincide \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"}]\n", "prompt_cons": "/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] [inst_2 : CompactSpace Î±]\n  [inst_3 : T2Space Î²] {f : Î± â†’ Î²}, Continuous f â†’ IsClosedMap f :=\n\n/-- The **Heineâ€“Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} [inst_1 : T2Space Î±] [inst_2 : ProperSpace Î±],\n  IsCompact s â†” IsClosed s âˆ§ Metric.Bounded s :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T2Space Î±] (x y : Î±),\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v :=\n\n/-- In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompleteSpace Î±], CompleteSpace (TopologicalSpace.Closeds Î±) :=\n\n/-- Two closed sets are at zero Hausdorff distance if and only if they coincide -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” s = t) :=\n\n/-- A locally compact Hausdorff space is totally disconnected\nif and only if it is totally separated. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem âˆ€ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â†‘f :=\n\n/-- Two closed sets are at zero Hausdorff edistance if and only if they coincide -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±},\n  IsClosed s â†’ IsClosed t â†’ (EMetric.hausdorffEdist s t = 0 â†” s = t) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$. -/\ntheorem", "choices": ["âˆ€ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X â†” IsClosed (TopologicalSpace.Diagonal X) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed {p : Î± Ã— Î± | p.fst = p.snd} ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsClosed (Diagonal Î±) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  T2Space Î± â†” IsClosed (Set.Diagonal Î±) ", "âˆ€ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X â†” IsClosed (Diagonal X) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsClosed (Set.Diagonal Î±) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], T2Space Î± â†” IsClosed (Diagonal Î±) "]}, {"stmt": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±], t = âŠ¤ â†’ âˆ€ (U : TopologicalSpace.Opens Î±), U = âŠ¥ âˆ¨ U = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open set in the indiscrete topology is either empty or the whole space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"}]\n", "prompt_cons": "/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : CompactSpace Î±]\n  [inst_3 : TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±}, IsOpen U â†’ x âˆˆ U â†’ âˆƒ V, IsClopen V âˆ§ x âˆˆ V âˆ§ V âŠ† U :=\n\n/-- An open set in the indiscrete topology is either empty or the whole space. -/\ntheorem âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±], t = âŠ¤ â†’ âˆ€ (U : TopologicalSpace.Opens Î±), U = âŠ¥ âˆ¨ U = âŠ¤ :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : PreirreducibleSpace Î±] {s : Set Î±},\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1}\n  (s : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), IsOpen (s i)) â†’ âˆƒ T, Set.Countable T âˆ§ â‹ƒ (i : Î¹) (_ : i âˆˆ T), s i = â‹ƒ (i : Î¹), s i :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s} :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {s : Set Î±},\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {S U : Set Î±},\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- If every point of a subset of a topological space is contained in some open set, the subset itself is open. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ (U : Set Î±), IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ x âˆˆ s, âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ U, IsOpen U âˆ§ x âˆˆ U âˆ§ U âŠ† s) â†’ IsOpen s "]}, {"stmt": "Every non-identity element of a free group is of infinite order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid is not a torsion monoid if it has an element of infinite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"}]\n", "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinOrder g :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x â†’ IsOfFinAddOrder (-x) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x) :=\n\n/-- Every non-identity element of a free group is of infinite order. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] {x : Î±}, x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] {x : Î±}, x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} [inst : Semigroup Î±] (x : FreeGroup Î±), x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u_1} [inst : FreeGroup Î±] (x : FreeGroup Î±), x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} [self : FreeGroup Î±] (x : Î±), x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} (x : FreeGroup Î±), x â‰  FreeGroup.of [] â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] (x : Î±), x â‰  1 â†’ Â¬IsOfFinOrder x ", "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : IsFreeGroup Î±] (a : Î±), a â‰  1 â†’ Â¬IsOfFinOrder a ", "âˆ€ {Î± : Type u_1} (x : FreeGroup Î±), x â‰  1 â†’ Â¬IsOfFinOrder x "]}, {"stmt": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Î“â‚€]\\n  [inst_2 : Nontrivial Î“â‚€] (v : Valuation K Î“â‚€) {x : K}, â†‘v x = 0 â†” x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R],\\n  (âˆƒ p, Irreducible p) â†’ (âˆ€ â¦ƒp q : Râ¦„, Irreducible p â†’ Irreducible q â†’ Associated p q) â†’ DiscreteValuationRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unique factorization domain with at least one irreducible element\\nin which all irreducible elements are associated\\nis a discrete valuation ring.\\n\"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `â„š`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : { x // x âˆˆ nonZeroDivisors (Ideal S) }),\\n  âˆƒ b, b âˆˆ â†‘I âˆ§ b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â†‘abv (â†‘(Algebra.norm R) c) < â†‘abv (â†‘(Algebra.norm R) b) â†’ c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] [inst_1 : Nontrivial Mâ‚€] (u : Mâ‚€Ë£), â†‘u â‰  0\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of the unit group of a nonzero monoid with zero represented as an element\\nof the monoid is nonzero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"The `v`-adic valuation of `0 : R` equals 0. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r âˆˆ RingHom.ker f â†” â†‘f r = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is in the kernel if and only if it maps to zero.\"}]\n", "prompt_cons": "/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem âˆ€ {K : Type u_2} [inst : DivisionRing K] {Î“â‚€ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Î“â‚€]\n  [inst_2 : Nontrivial Î“â‚€] (v : Valuation K Î“â‚€) {x : K}, â†‘v x = 0 â†” x = 0 :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = âŠ¥ â†” âˆƒ I, I âˆˆ s âˆ§ I = âŠ¥ :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0 :=\n\n/-- A unique factorization domain with at least one irreducible element\nin which all irreducible elements are associated\nis a discrete valuation ring. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R],\n  (âˆƒ p, Irreducible p) â†’ (âˆ€ â¦ƒp q : Râ¦„, Irreducible p â†’ Irreducible q â†’ Associated p q) â†’ DiscreteValuationRing R :=\n\n/-- A ring is a `â„š`-algebra iff it has equal characteristic zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I) :=\n\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : { x // x âˆˆ nonZeroDivisors (Ideal S) }),\n  âˆƒ b, b âˆˆ â†‘I âˆ§ b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â†‘abv (â†‘(Algebra.norm R) c) < â†‘abv (â†‘(Algebra.norm R) b) â†’ c = 0 :=\n\n/-- A non-unital subring contains the ring's 0. -/\ntheorem âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 âˆˆ s :=\n\n/-- An element of the unit group of a nonzero monoid with zero represented as an element\nof the monoid is nonzero. -/\ntheorem âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] [inst_1 : Nontrivial Mâ‚€] (u : Mâ‚€Ë£), â†‘u â‰  0 :=\n\n/-- The `v`-adic valuation of `0 : R` equals 0. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0 :=\n\n/-- An element is in the kernel if and only if it maps to zero. -/\ntheorem âˆ€ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, r âˆˆ RingHom.ker f â†” â†‘f r = 0 :=\n\n/-- An element of a discrete valuation ring is a unit if and only if it has a valuation of zero. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (v : DiscreteValuationRing.Valuation R)\n  (u : R), IsUnit u â†” v u = 0 ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (u : R),\n  u âˆˆ DiscreteValuationRing.unitsOf R â†” DiscreteValuationRing.valuationOf u = 0 ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {u : R},\n  IsUnit u â†” DiscreteValuationRing.valuation u = 0 ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  x âˆˆ DiscreteValuationRing.unitsValuationZero R â†” IsUnit x ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (Ï– : R) (hÏ– : Irreducible Ï–) (x : R), IsUnit x â†” âˆ€ (v : DiscreteValuationRing.Aux R Ï– hÏ–), v x = 0 ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (u : R), IsUnit u â†” DiscreteValuationRing.has_valuation.zero R u ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (u : R), IsUnit u â†” DiscreteValuationRing.valuation u = 0 ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {x : R},\n  IsUnit x â†” DiscreteValuationRing.valuation x = 0 ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (Ï– : R) (hr : Irreducible Ï–), Ï– â‰  0 â†’ (âˆ€ (u : RË£), (DiscreteValuationRing.valuation R Ï– u).1 = 0 â†” â†‘u = 1) ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (u : R),\n  IsUnit u â†” DiscreteValuationRing.hasUnit u = 0 "]}, {"stmt": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.", "prompts": "[{\"theorem\":\n  \"âˆ€ {a b : â„¤}, a â‰  0 â†’ IsLeast {n | 0 < n âˆ§ âˆƒ x y, â†‘n = a * x + b * y} (Int.gcd a b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•},\\n  a â‰  0 â†’ b â‰  0 â†’ List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) âˆª List.toFinset (Nat.factors b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•}, a â‰  0 â†’ b â‰  0 â†’ Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b\",\n  \"isProp\": true,\n  \"docString\":\n  \"For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : OrderedAddCommMonoid Î±] [self : Archimedean Î±] (x : Î±) {y : Î±}, 0 < y â†’ âˆƒ n, x â‰¤ n â€¢ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any two elements `x`, `y` such that `0 < y`, there exists a natural number `n`\\nsuch that `x â‰¤ n â€¢ y`. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•}, Nat.coprime a b â†’ Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b\",\n  \"isProp\": true,\n  \"docString\":\n  \"For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` \"},\n {\"theorem\":\n  \"âˆ€ {a b : â„•},\\n  Nat.coprime a b â†’ (Nat.factorization (a * b)).support = (Nat.factorization a).support âˆª (Nat.factorization b).support\",\n  \"isProp\": true,\n  \"docString\":\n  \"For coprime `a` and `b` the prime factorization `a * b` is the union of those of `a` and `b` \"}]\n", "prompt_cons": "/-- For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` -/\ntheorem âˆ€ {a b : â„¤}, a â‰  0 â†’ IsLeast {n | 0 < n âˆ§ âˆƒ x y, â†‘n = a * x + b * y} (Int.gcd a b) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` -/\ntheorem âˆ€ {a b : â„•},\n  a â‰  0 â†’ b â‰  0 â†’ List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) âˆª List.toFinset (Nat.factors b) :=\n\n/-- For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` -/\ntheorem âˆ€ {a b : â„•}, a â‰  0 â†’ b â‰  0 â†’ Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b :=\n\n/-- For any two elements `x`, `y` such that `0 < y`, there exists a natural number `n`\nsuch that `x â‰¤ n â€¢ y`. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : OrderedAddCommMonoid Î±] [self : Archimedean Î±] (x : Î±) {y : Î±}, 0 < y â†’ âˆƒ n, x â‰¤ n â€¢ y :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` -/\ntheorem âˆ€ {a b : â„•}, Nat.coprime a b â†’ Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b :=\n\n/-- For coprime `a` and `b` the prime factorization `a * b` is the union of those of `a` and `b` -/\ntheorem âˆ€ {a b : â„•},\n  Nat.coprime a b â†’ (Nat.factorization (a * b)).support = (Nat.factorization a).support âˆª (Nat.factorization b).support :=\n\n/-- For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers. -/\ntheorem", "choices": ["âˆ€ {a b N : â„•}, Nat.coprime a b â†’ a â‰  0 â†’ b â‰  0 â†’ âˆƒ (x y : â„•), N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ (N : â„•), âˆƒ (x y : â„•), N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆƒ N : â„•, âˆ€ n : â„•, N â‰¤ n â†’ âˆƒ x y : â„•, n = a * x + b * y ", "âˆ€ {a b N : â„•}, Nat.gcd a b = 1 â†’ N â‰¥ a * b - a - b â†’ âˆƒ x y : â„•, N = a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, a * x + b * y â‰¥ N ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ (N : â„•), âˆƒ (x y : â„•), N â‰¤ a * x + b * y ", "âˆ€ {a b : â„•}, Nat.coprime a b â†’ âˆ€ N, âˆƒ x y : â„•, a * x + b * y â‰¥ N "]}, {"stmt": "Every field is a ring.", "prompts": "[{\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"âˆ€ (self : AlgebraicGeometry.LocallyRingedSpace) (x : â†‘â†‘self.toPresheafedSpace),\\n  LocalRing â†‘(TopCat.Presheaf.stalk self.presheaf x)\",\n  \"isProp\": true,\n  \"docString\": \"Stalks of a locally ringed space are local rings. \"}]\n", "prompt_cons": "/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 âˆˆ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 âˆˆ S :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î± :=\n\n/-- Fields are commutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x :=\n\n/-- The category of rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- Stalks of a locally ringed space are local rings. -/\ntheorem âˆ€ (self : AlgebraicGeometry.LocallyRingedSpace) (x : â†‘â†‘self.toPresheafedSpace),\n  LocalRing â†‘(TopCat.Presheaf.stalk self.presheaf x) :=\n\n/-- Every field is a ring. -/\ntheorem", "choices": ["forall (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K ", "âˆ€ (K : Type u) [inst : Field K], Ring K "]}, {"stmt": "The set of units in a ring forms a group.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\\n  IsCyclic { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {k : Set G}, k âŠ† â†‘(Subgroup.closure k)\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup generated by a set includes the set. \"},\n {\"theorem\":\n  \"LieGroup (modelWithCornersSelf â„ (EuclideanSpace â„ (Fin 1))) { x // x âˆˆ circle }\",\n  \"isProp\": true,\n  \"docString\": \"The unit circle in `â„‚` is a Lie group. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : NormedDivisionRing Î±], TopologicalDivisionRing Î±\",\n  \"isProp\": true,\n  \"docString\": \"A normed division ring is a topological division ring. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 1 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 1. \"}]\n", "prompt_cons": "/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite { x // x âˆˆ S }],\n  IsCyclic { x // x âˆˆ S } :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem âˆ€ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G â†’* R), Function.Injective â†‘f â†’ IsCyclic G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- The center of a group acts commutatively on that group. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x âˆˆ Subgroup.center G } G :=\n\n/-- The subgroup generated by a set includes the set. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {k : Set G}, k âŠ† â†‘(Subgroup.closure k) :=\n\n/-- The unit circle in `â„‚` is a Lie group. -/\ntheorem LieGroup (modelWithCornersSelf â„ (EuclideanSpace â„ (Fin 1))) { x // x âˆˆ circle } :=\n\n/-- A subring contains the ring's 0. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s :=\n\n/-- A normed division ring is a topological division ring. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : NormedDivisionRing Î±], TopologicalDivisionRing Î± :=\n\n/-- A subring contains the ring's 1. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 1 âˆˆ s :=\n\n/-- The set of units in a ring forms a group. -/\ntheorem", "choices": ["âˆ€ {R : Type u_1} [inst : Ring R], IsGroup {x : R | IsUnit x} ", "Group {R : Type u_1} [inst : Ring R] : Type u_1 ", "âˆ€ {R : Type u_1} [inst : Ring R], Group RË£ ", "âˆ€ {R : Type u} [inst : Ring R], Group RË£ ", "âˆ€ {R : Type u_1} [inst : Ring R], Group (Units R) ", "âˆ€ {R : Type u_1} [inst : Ring R], Group RË£ ", "âˆ€ {R : Type u_1} [inst : Ring R], Group RË£ ", "âˆ€ {R : Type u_1} [inst : Monoid R], Group (Units R) ", "âˆ€ {R : Type u} [inst : Monoid R], Group (Units R) ", "âˆ€ {R : Type u} [inst : Ring R], Group (Units R) "]}, {"stmt": "If the direct product of two groups is torsion free then each of the groups is torsion free.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"}]\n", "prompt_cons": "/-- Direct products of torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ AddGroup (Gs i)],\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i) :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x âˆˆ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G) :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion { x // x âˆˆ N } â†’ Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If the direct product of two groups is torsion free then each of the groups is torsion free. -/\ntheorem", "choices": ["âˆ€ {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [inst : (i : Î·) â†’ Group (Gs i)],\n  Monoid.IsTorsionFree ((i : Î·) â†’ Gs i) â†’ âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i) ", "forall {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ", "forall {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ", "forall {G : Type u_1} {H : Type u_2} [inst_1 : Group G] [inst_2 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ", "forall {A B : Type u_1} [inst : Group A] [inst_1 : Group B],\n  Monoid.IsTorsionFree (A Ã— B) â†’ Monoid.IsTorsionFree A âˆ§ Monoid.IsTorsionFree B ", "âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G Ã— H) â†’ Monoid.IsTorsionFree G âˆ§ Monoid.IsTorsionFree H ", "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ", "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [instâ‚ : Group Gâ‚] [instâ‚‚ : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ", "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ ", "âˆ€ {Gâ‚ Gâ‚‚ : Type u_1} [inst : Group Gâ‚] [inst_1 : Group Gâ‚‚],\n  Monoid.IsTorsionFree (Gâ‚ Ã— Gâ‚‚) â†’ Monoid.IsTorsionFree Gâ‚ âˆ§ Monoid.IsTorsionFree Gâ‚‚ "]}]