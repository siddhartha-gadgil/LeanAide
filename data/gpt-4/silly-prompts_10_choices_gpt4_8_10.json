[{"stmt": "Every prime number is `2` or odd.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"}]\n", "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- Every prime number is `2` or odd. -/\ntheorem", "choices": ["âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p = 2 âˆ¨ Odd p ", "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p = 2 âˆ¨ Odd p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p = 2 âˆ¨ Odd p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p = 2 âˆ¨ Odd p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p = 2 âˆ¨ Odd p ", "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p = 2 âˆ¨ Odd p ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p = 2 âˆ¨ Odd p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ (p = 2 âˆ¨ Odd p) ", "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p = 2 âˆ¨ Odd p ", "âˆ€ (p : â„•), Nat.Prime p â†’ p = 2 âˆ¨ Odd p "]}, {"stmt": "There are infinitely many odd natural numbers.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b âˆ§ Ordinal.omega â‰¤ b}\",\n  \"isProp\": true,\n  \"docString\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤ :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n] :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤ :=\n\n/-- A product of finite numbers is still finite -/\ntheorem âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤ :=\n\n/-- Infinite ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b âˆ§ Ordinal.omega â‰¤ b} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R :=\n\n/-- There are infinitely many odd natural numbers. -/\ntheorem", "choices": ["Filter.frequently (fun m => m % 2 = 1) Filter.atTop ", "Filter.frequently (fun n => n % 2 = 1) Filter.atTop ", "âˆƒá¶  (m : â„•) in Filter.atTop, m % 2 = 1 ", "Filter.frequently (fun x => x % 2 = 1) Filter.atTop ", "âˆƒá¶  (m : â„•) in Filter.atTop, m % 2 = 1 ", "Filter.frequently_of_forall (fun n : â„• => Nat.odd (2 * n + 1)) ", "Filter.frequently (fun m => m % 2 = 1) Filter.atTop ", "âˆƒá¶  (n : â„•) in Filter.atTop, n % 2 = 1 ", "âˆƒá¶  (m : â„•) in Filter.atTop, m % 2 = 1 ", "âˆƒá¶  (n : â„•) in Filter.atTop, n % 2 = 1 "]}, {"stmt": "The smallest odd prime is `3`.", "prompts": "[{\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\": \"âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"}]\n", "prompt_cons": "/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q :=\n\n/-- The smallest odd prime is `3`. -/\ntheorem", "choices": ["Nat.min_odd_prime : Nat.minFac 2 + 1 = 3 ", "Nat.min_odd_prime_is_3 : Nat.minFac 9 = 3 ", "Nat.min_odd_prime_is_3 : Nat.min_fac 9 = 3 ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime_is_3 : Nat.minFac 9 = 3 ", "Nat.min_odd_prime_is_3 : Nat.min_odd_prime = 3 ", "Nat.min_odd_prime : â„• ", "Nat.min_odd_prime = 3 ", "Nat.min_odd_prime_is_three : Fact (Nat.min_fac 9 = 3) "]}, {"stmt": "There are infinitely many odd prime numbers.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. -/\ntheorem âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]} :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem âˆ€ (n : â„•), âˆƒ p, n â‰¤ p âˆ§ Nat.Prime p :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1 :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤ :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A product of finite numbers is still finite -/\ntheorem âˆ€ {Î¹ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\n  (âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤ :=\n\n/-- There are infinitely many odd prime numbers. -/\ntheorem", "choices": ["Set.Infinite {p | Nat.Prime p âˆ§ p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p | Nat.Prime p âˆ§ p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p âˆ§ p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p âˆ§ p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p | Nat.Prime p âˆ§ p % 2 = 1} ", "Set.Infinite {p | Nat.Prime p âˆ§ Odd p} ", "Set.Infinite {p | Nat.Prime p âˆ§ Odd p} "]}, {"stmt": "If a vector space has dimension `2` then it is finite dimensional.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : StrongRankCondition K] {Î¹ : Type w} [inst_4 : Fintype Î¹],\\n  Basis Î¹ K V â†’ FiniteDimensional.finrank K V = Fintype.card Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsComplete â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A vector space has dimension at most `1` if and only if there is a\\nsingle vector of which all vectors are multiples. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹) :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem âˆ€ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s â†’ FiniteDimensional k { x // x âˆˆ vectorSpan k s } :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {Î¹ : Type w} [inst_4 : Fintype Î¹],\n  Basis Î¹ K V â†’ FiniteDimensional.finrank K V = Fintype.card Î¹ :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsComplete â†‘s :=\n\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V â‰¤ 1 â†” âˆƒ vâ‚€, âˆ€ (v : V), âˆƒ r, r â€¢ vâ‚€ = v :=\n\n/-- If a vector space has dimension `2` then it is finite dimensional. -/\ntheorem", "choices": ["forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V "]}, {"stmt": "Every field is a division ring.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€]\\n  [inst_2 : Valued K Î“â‚€], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] [inst_1 : FloorSemiring Î±] (m n : â„•), âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is the floor of field division. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : NormedDivisionRing Î±], TopologicalDivisionRing Î±\",\n  \"isProp\": true,\n  \"docString\": \"A normed division ring is a topological division ring. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"}]\n", "prompt_cons": "/-- A valued division ring is separated. -/\ntheorem âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Î“â‚€]\n  [inst_2 : Valued K Î“â‚€], SeparatedSpace K :=\n\n/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 âˆˆ S :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 âˆˆ S :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- Natural division is the floor of field division. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] [inst_1 : FloorSemiring Î±] (m n : â„•), âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n :=\n\n/-- A normed division ring is a topological division ring. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : NormedDivisionRing Î±], TopologicalDivisionRing Î± :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y :=\n\n/-- A subfield is closed under division. -/\ntheorem âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s :=\n\n/-- Every field is a division ring. -/\ntheorem", "choices": ["âˆ€ (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ {K : Type u_1} [inst : Field K], DivisionRing K ", "âˆ€ (K : Type u) [inst : Field K], DivisionRing K ", "âˆ€ {K : Type u} [inst : Field K], DivisionRing K "]}, {"stmt": "If a space has dimension `2` then it is finite dimensional.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsClosed â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} [inst : AddCommGroup M] {ð•œ : Type u_1} [inst_1 : Field ð•œ] [inst_2 : Module ð•œ M] (f : M â†’â‚—[ð•œ] M),\\n  â†‘LinearMap.det f â‰  1 â†’ FiniteDimensional ð•œ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a linear map has determinant different from `1`, then the space is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î±\",\n  \"isProp\": true,\n  \"docString\": \"A compact discrete space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsComplete â†‘s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ð•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ð•œ F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ð•œ F]\\n  [inst_10 : FiniteDimensional ð•œ E] [inst_11 : FiniteDimensional ð•œ F], FiniteDimensional ð•œ (E â†’L[ð•œ] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsClosed â†‘s :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x âˆˆ S } :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V â§¸ S) :=\n\n/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem âˆ€ {M : Type u_2} [inst : AddCommGroup M] {ð•œ : Type u_1} [inst_1 : Field ð•œ] [inst_2 : Module ð•œ M] (f : M â†’â‚—[ð•œ] M),\n  â†‘LinearMap.det f â‰  1 â†’ FiniteDimensional ð•œ M :=\n\n/-- A compact discrete space is finite. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±] [inst : DiscreteTopology Î±], Finite Î± :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem âˆ€ {ð•œ : Type u} [inst : NontriviallyNormedField ð•œ] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] [inst_3 : CompleteSpace ð•œ] (s : Submodule ð•œ E)\n  [inst_4 : FiniteDimensional ð•œ { x // x âˆˆ s }], IsComplete â†‘s :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem âˆ€ {ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ð•œ E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ð•œ F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ð•œ F]\n  [inst_10 : FiniteDimensional ð•œ E] [inst_11 : FiniteDimensional ð•œ F], FiniteDimensional ð•œ (E â†’L[ð•œ] F) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V :=\n\n/-- If a space has dimension `2` then it is finite dimensional. -/\ntheorem", "choices": ["âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : Module.rank K V = 2), FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], \n  findim K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (Module.rank K V = 2) â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (findim K V = 2) â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : HasDimension (fin 2) V], FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], dim K V = 2 â†’ FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Fintype Î¹] (h_dim : Fintype.card Î¹ = 2), FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : Findim K V = 2], FiniteDimensional K V ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], findim K V = 2 â†’ FiniteDimensional K V "]}, {"stmt": "Every natural number has a successor.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ (a : Ordinal.{u}), âˆƒ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\",\n  \"isProp\": true,\n  \"docString\": \"Every ordinal has a fundamental sequence. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {A : Î¹ â†’ Type u_2} [inst : AddMonoid Î¹] [inst_1 : (i : Î¹) â†’ AddCommMonoid (A i)]\\n  [self : DirectSum.GSemiring A] (n : â„•),\\n  DirectSum.GSemiring.natCast (n + 1) = DirectSum.GSemiring.natCast n + GradedMonoid.GOne.one\",\n  \"isProp\": true,\n  \"docString\":\n  \"The canonical map from â„• to a graded semiring respects successors.\"},\n {\"theorem\": \"âˆ€ {n : â„•+}, n â‰  1 â†’ âˆƒ k, n = k + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n : â„•+` is different from `1`, then it is the successor of some `k : â„•+`. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- Every ordinal has a fundamental sequence. -/\ntheorem âˆ€ (a : Ordinal.{u}), âˆƒ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- The canonical map from â„• to a graded semiring respects successors. -/\ntheorem âˆ€ {Î¹ : Type u_1} {A : Î¹ â†’ Type u_2} [inst : AddMonoid Î¹] [inst_1 : (i : Î¹) â†’ AddCommMonoid (A i)]\n  [self : DirectSum.GSemiring A] (n : â„•),\n  DirectSum.GSemiring.natCast (n + 1) = DirectSum.GSemiring.natCast n + GradedMonoid.GOne.one :=\n\n/-- If `n : â„•+` is different from `1`, then it is the successor of some `k : â„•+`. -/\ntheorem âˆ€ {n : â„•+}, n â‰  1 â†’ âˆƒ k, n = k + 1 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Every natural number has a successor. -/\ntheorem", "choices": ["âˆ€ (n : â„•), âˆƒ k, n + 1 = k ", "âˆ€ (n : â„•), âˆƒ k, n + 1 = k ", "âˆ€ (n : â„•), âˆƒ k, n + 1 = k ", "âˆ€ (n : â„•), âˆƒ m, n + 1 = m ", "âˆ€ (n : â„•), âˆƒ m, m = n + 1 ", "âˆ€ (n : â„•), âˆƒ m, m = n + 1 ", "âˆ€ (n : â„•), âˆƒ (k : â„•), k = n + 1 ", "âˆ€ (n : â„•), âˆƒ m, m = n + 1 ", "âˆ€ (n : â„•), âˆƒ k, n + 1 = k ", "âˆ€ (n : â„•), âˆƒ m, m = n + 1 "]}, {"stmt": "Every natural number is less than its successor.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ a â‰¤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [self : CompleteLattice Î±] (x : Î±), x â‰¤ âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"Any element is less than the top one. \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, 1 < b â†’ d âˆˆ Nat.digits b m â†’ d < b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b expansion of n are all less than b, if b â‰¥ 2 \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] {m n : â„•}, â†‘(m / n) â‰¤ â†‘m / â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is always less than division in the field. \"},\n {\"theorem\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : LE Î±] [self : ZeroLEOneClass Î±], 0 â‰¤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Zero is less than or equal to one. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded below.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"}]\n", "prompt_cons": "/-- Any element of a set is less than the set supremum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), a âˆˆ s â†’ a â‰¤ sSup s :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ (b : Î±), b âˆˆ s â†’ a â‰¤ b) â†’ a â‰¤ sInf s :=\n\n/-- Any element is less than the top one. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CompleteLattice Î±] (x : Î±), x â‰¤ âŠ¤ :=\n\n/-- The digits in the base b expansion of n are all less than b, if b â‰¥ 2 -/\ntheorem âˆ€ {b m d : â„•}, 1 < b â†’ d âˆˆ Nat.digits b m â†’ d < b :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedSemifield Î±] {m n : â„•}, â†‘(m / n) â‰¤ â†‘m / â†‘n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0 :=\n\n/-- Zero is less than or equal to one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : LE Î±] [self : ZeroLEOneClass Î±], 0 â‰¤ 1 :=\n\n/-- A finite set is bounded below. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddBelow s :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {u : â„• â†’ Î±}, CauchySeq u â†’ âˆƒ R, R > 0 âˆ§ âˆ€ (m n : â„•), dist (u m) (u n) < R :=\n\n/-- Every natural number is less than its successor. -/\ntheorem", "choices": ["âˆ€ {n : â„•}, n < Nat.succ n ", "âˆ€ (n : â„•), n < n.succ ", "âˆ€ {n : â„•}, n < n.succ ", "âˆ€ {n : â„•}, n < n.succ ", "âˆ€ (n : â„•), n < n.succ ", "âˆ€ (n : â„•), n < n.succ ", "âˆ€ {n : â„•}, n < n.succ ", "âˆ€ (n : â„•), n < n + 1 ", "âˆ€ (n : â„•), n < n + 1 ", "âˆ€ (n : â„•), n < n.succ "]}, {"stmt": "Every set is Lebesgue measurable.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\": \"â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±),\\n  âˆƒ t, s âŠ† t âˆ§ MeasurableSet t âˆ§ â†‘â†‘Î¼ t = â†‘â†‘Î¼ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every set there exists a measurable superset of the same measure. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\\n  OpensMeasurableSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\\n  [inst_3 : LinearOrder Î±] [inst_4 : OrderTopology Î±] [inst_5 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\\n  (âˆ€ (x : Î±), x âˆˆ s â†’ s âˆˆ nhdsWithin x (Set.Ioi x)) â†’ MeasurableSet s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {f : Î± â†’ â„}, Measurable f â†’ MeasurableSet {p | p.snd = f p.fst}\",\n  \"isProp\": true,\n  \"docString\": \"The graph of a measurable function is a measurable set. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {Î³ : Type u_1} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] [inst : MeasurableSpace Î³]\\n  {Î² : Type u_3} [inst_1 : MeasurableSpace Î²] [hÎ³ : OpensMeasurableSpace Î³] [inst_2 : Countable Î¹] {l : Filter Î¹}\\n  [inst_3 : Filter.IsCountablyGenerated l] {f : Î¹ â†’ Î² â†’ Î³},\\n  (âˆ€ (i : Î¹), Measurable (f i)) â†’ MeasurableSet {x | âˆƒ c, Filter.Tendsto (fun n => f n x) l (nhds c)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of points for which a measurable sequence of functions converges is measurable. \"},\n {\"theorem\":\n  \"âˆ€ (ð•œ : Type u_2) [inst : NontriviallyNormedField ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableAt ð•œ f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) [inst_2 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ (ð•œ : Type u_3) [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E â†’L[ð•œ] F)},\\n  IsComplete K â†’ MeasurableSet {x | DifferentiableAt ð•œ f x âˆ§ fderiv ð•œ f x âˆˆ K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function, with derivative in a given complete set,\\nis Borel-measurable. \"}]\n", "prompt_cons": "/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼) :=\n\n/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- For every set there exists a measurable superset of the same measure. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±),\n  âˆƒ t, s âŠ† t âˆ§ MeasurableSet t âˆ§ â†‘â†‘Î¼ t = â†‘â†‘Î¼ s :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\n  OpensMeasurableSpace Î± :=\n\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  [inst_3 : LinearOrder Î±] [inst_4 : OrderTopology Î±] [inst_5 : TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±},\n  (âˆ€ (x : Î±), x âˆˆ s â†’ s âˆˆ nhdsWithin x (Set.Ioi x)) â†’ MeasurableSet s :=\n\n/-- The graph of a measurable function is a measurable set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {f : Î± â†’ â„}, Measurable f â†’ MeasurableSet {p | p.snd = f p.fst} :=\n\n/-- The set of points for which a measurable sequence of functions converges is measurable. -/\ntheorem âˆ€ {Î¹ : Type u_2} {Î³ : Type u_1} [tÎ³ : TopologicalSpace Î³] [inst : PolishSpace Î³] [inst : MeasurableSpace Î³]\n  {Î² : Type u_3} [inst_1 : MeasurableSpace Î²] [hÎ³ : OpensMeasurableSpace Î³] [inst_2 : Countable Î¹] {l : Filter Î¹}\n  [inst_3 : Filter.IsCountablyGenerated l] {f : Î¹ â†’ Î² â†’ Î³},\n  (âˆ€ (i : Î¹), Measurable (f i)) â†’ MeasurableSet {x | âˆƒ c, Filter.Tendsto (fun n => f n x) l (nhds c)} :=\n\n/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem âˆ€ (ð•œ : Type u_2) [inst : NontriviallyNormedField ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableAt ð•œ f x} :=\n\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) [inst_2 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x} :=\n\n/-- The set of differentiability points of a function, with derivative in a given complete set,\nis Borel-measurable. -/\ntheorem âˆ€ (ð•œ : Type u_3) [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E â†’L[ð•œ] F)},\n  IsComplete K â†’ MeasurableSet {x | DifferentiableAt ð•œ f x âˆ§ fderiv ð•œ f x âˆˆ K} :=\n\n/-- Every set is Lebesgue measurable. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±] [inst_3 : LebesgueMeasurableSpace Î±],\n  âˆ€ (s : Set Î±), MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : MeasureTheory.Measure.subsingleton Î±], âˆ€ (s : Set Î±), MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±] [inst_3 : OpensMeasurableSpace Î±], \n  âˆ€ (s : Set Î±), MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±], LebesgueMeasurable Î± ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±], OpensMeasurableSpace Î± ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±],\n  LebesgueMeasurableSpace Î± ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (s : Set Î±), MeasurableSet s "]}, {"stmt": "Every set of Borel measure zero is Lebesgue measurable.", "prompts": "[{\"theorem\": \"â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½],\\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\\n  OpensMeasurableSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAddâ‚‚ G]\\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant Î½],\\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\\n  Metric.Bounded s â†’\\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) [inst_2 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"âˆ€ (ð•œ : Type u_2) [inst : NontriviallyNormedField ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableAt ð•œ f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"}]\n", "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem â†‘â†‘MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] (Î¼ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S â‰¤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Î¼) :=\n\n/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMulâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant Î½],\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½ :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\n  OpensMeasurableSpace Î± :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ âˆƒ u, u âˆˆ nhdsWithin x s âˆ§ â†‘m u = 0) â†’ â†‘m s = 0 :=\n\n/-- Left invariant Borel measures on an additive measurable group are unique (up to a scalar). -/\ntheorem âˆ€ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAddâ‚‚ G]\n  (Î¼ Î½ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite Î½] [inst_4 : MeasureTheory.SigmaFinite Î¼]\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant Î½],\n  MeasurableSet s â†’ â†‘â†‘Î½ s â‰  0 â†’ â†‘â†‘Î½ s â‰  âŠ¤ â†’ Î¼ = (â†‘â†‘Î¼ s / â†‘â†‘Î½ s) â€¢ Î½ :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] {s : Set E} (u : â„• â†’ E),\n  Metric.Bounded s â†’\n    Metric.Bounded (Set.range u) â†’ Pairwise (Disjoint on fun n => {u n} + s) â†’ MeasurableSet s â†’ â†‘â†‘Î¼ s = 0 :=\n\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] (f : â„ â†’ F) [inst_2 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableWithinAt â„ f (Set.Ici x) x} :=\n\n/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem âˆ€ (ð•œ : Type u_2) [inst : NontriviallyNormedField ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] (f : E â†’ F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableAt ð•œ f x} :=\n\n/-- Every set of Borel measure zero is Lebesgue measurable. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) {s : Set Î±}, â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±), â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) {s : Set Î±}, â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "forall {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) {s : Set Î±},\n  MeasureTheory.volume s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) {s : Set Î±}, â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace.SecondCountableTopology Î±]\n  (Î¼ : MeasureTheory.Measure Î±) {s : Set Î±}, â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasureTheory.MeasureSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±],\n  MeasureTheory.Measure.ZeroLebesgueMeasurableSpace Î± ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : BorelSpace Î±] (Î¼ : MeasureTheory.Measure Î±)\n  {s : Set Î±}, â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : MeasurableSpace Î±] [inst_2 : BorelSpace Î±]\n  (Î¼ : MeasureTheory.Measure Î±) (s : Set Î±), â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s ", "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (Î¼ : MeasureTheory.Measure Î±) {s : Set Î±},\n  â†‘â†‘Î¼ s = 0 â†’ MeasurableSet s "]}, {"stmt": "No prime number is a perfect square.", "prompts": "[{\"theorem\": \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I], I â‰  âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The prime ideal is not the entire ring. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"}]\n", "prompt_cons": "/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- The prime ideal is not the entire ring. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I], I â‰  âŠ¤ :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1 :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n :=\n\n/-- No prime number is a perfect square. -/\ntheorem", "choices": ["âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ t, t * t = p ", "âˆ€ {p : â„•}, Nat.Prime p â†’ Â¬âˆƒ n, n * n = p "]}, {"stmt": "Every odd prime number is greater than `2`.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\": \"âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"}]\n", "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem âˆ€ (p' : â„•), 2 < LucasLehmer.q (p' + 2) :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem âˆ€ (n : â„•), n â‰  0 â†’ âˆƒ p, Nat.Prime p âˆ§ n < p âˆ§ p â‰¤ 2 * n :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- Every odd prime number is greater than `2`. -/\ntheorem", "choices": ["âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p % 2 = 1 â†’ p > 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 ", "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Odd p â†’ p > 2 "]}, {"stmt": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "prompts": "[{\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"},\n {\"theorem\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"},\n {\"theorem\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] (m k : â„•),\\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\\n  p * q =\\n    Finset.sum (Polynomial.support p) fun i =>\\n      Polynomial.sum q fun j a => â†‘(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)\",\n  \"isProp\": true,\n  \"docString\": \"Expressing the product of two polynomials as a double sum. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"}]\n", "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem âˆ€ (a b c d x y z w : â„•),\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Euler's four-square identity**. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Four squares theorem** -/\ntheorem âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. -/\ntheorem âˆ€ (R : Type u_1) [inst : CommRing R] (m k : â„•),\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k :=\n\n/-- Expressing the product of two polynomials as a double sum. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\n  p * q =\n    Finset.sum (Polynomial.support p) fun i =>\n      Polynomial.sum q fun j a => â†‘(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a) :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0 :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem", "choices": ["âˆ€ {a b x y z w u v : â„•},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†’ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 â†’\n  âˆƒ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y u v r s : â„•},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’\n  b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 â†’\n  âˆƒ p q t z, a * b = p ^ 2 + q ^ 2 + t ^ 2 + z ^ 2 ", "âˆ€ {a b x y u v r s : â„•}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 â†’ b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 â†’ âˆƒ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ", "âˆ€ {a b x y u v r s : â„•}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 â†’ b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 â†’ âˆƒ p q m n, a * b = p ^ 2 + q ^ 2 + m ^ 2 + n ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y u v r s : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 â†’ âˆƒ p q l m, a * b = p ^ 2 + q ^ 2 + l ^ 2 + m ^ 2 ", "âˆ€ {a b x y u v r s t w : â„•},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 â†’\n  b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2 â†’\n  âˆƒ m n o p, a * b = m ^ 2 + n ^ 2 + o ^ 2 + p ^ 2 ", "âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ âˆƒ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "âˆ€ {a b x y u v r s : â„•}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 â†’ b = r ^ 2 + s ^ 2 + x ^ 2 + y ^ 2 â†’ âˆƒ w t z p, a * b = w ^ 2 + t ^ 2 + z ^ 2 + p ^ 2 "]}, {"stmt": "Every compact topological space is locally compact.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally compact charts, then the space itself\\nis locally compact. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty\\ninterior is locally compact.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty interior\\nis locally compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure.\\n\"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] (x : Î±), âˆƒ K, IsCompact K âˆ§ K âˆˆ nhds x :=\n\n/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ K', IsCompact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : LocallyCompactSpace Î±] (x : Î±) (n : Set Î±),\n  n âˆˆ nhds x â†’ âˆƒ s, s âˆˆ nhds x âˆ§ s âŠ† n âˆ§ IsCompact s :=\n\n/-- If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. -/\ntheorem âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty interior\nis locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±],\n  (âˆ€ (x : Î±), âˆƒ s, s âˆˆ nhds x âˆ§ IsCompact s) â†’ LocallyCompactSpace Î± :=\n\n/-- In a locally compact Tâ‚‚ space, every compact set has an open neighborhood with compact closure. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : LocallyCompactSpace Î±] [inst_2 : T2Space Î±] {K : Set Î±},\n  IsCompact K â†’ âˆƒ V, IsOpen V âˆ§ K âŠ† V âˆ§ IsCompact (closure V) :=\n\n/-- Every compact topological space is locally compact. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : CompactSpace Î±], LocallyCompactSpace Î± "]}, {"stmt": "Every continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"}]\n", "prompt_cons": "/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼ :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\n  [inst_1 : TopologicalSpace Î±],\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\n  (âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)),\n      u âˆˆ uniformity Î² â†’ âˆƒ t, t âˆˆ nhds x âˆ§ âˆƒ F, ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u) â†’\n    Continuous f :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼ :=\n\n/-- Uniform continuity of the function -/\ntheorem âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.toFun :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem âˆ€ {Î¹ : Type u_1} {X : Type u_2} {Î± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i) :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem âˆ€ {Î± : Type u_3} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±}\n  [inst_2 : CompactSpace Î²], Equicontinuous F â†’ UniformEquicontinuous F :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (f : Î± â†’ Î²),\n  Continuous f â†’ UniformContinuous f ", "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f "]}, {"stmt": "`6` is not the sum of two distinct prime numbers.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Monoid (M i)] (self : FreeProduct.Word M),\\n  List.Chain' (fun l l' => l.fst â‰  l'.fst) self.toList\",\n  \"isProp\": true,\n  \"docString\": \"Adjacent letters are not from the same summand. \"},\n {\"theorem\":\n  \"âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x â‰  1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n R` is different from `0`. \"},\n {\"theorem\": \"Â¬Summable fun n => 1 / â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Harmonic series is not unconditionally summable. \"},\n {\"theorem\":\n  \"âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic' n R` is different from `0`. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `Ï€ / 2`, the first two points are not equal. \"}]\n", "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- Adjacent letters are not from the same summand. -/\ntheorem âˆ€ {Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Monoid (M i)] (self : FreeProduct.Word M),\n  List.Chain' (fun l l' => l.fst â‰  l'.fst) self.toList :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem âˆ€ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x â‰  1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. -/\ntheorem âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3 :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- `cyclotomic n R` is different from `0`. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R â‰  0 :=\n\n/-- Harmonic series is not unconditionally summable. -/\ntheorem Â¬Summable fun n => 1 / â†‘n :=\n\n/-- `cyclotomic' n R` is different from `0`. -/\ntheorem âˆ€ (n : â„•) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R â‰  0 :=\n\n/-- If the angle between three points is `Ï€ / 2`, the first two points are not equal. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚ :=\n\n/-- `6` is not the sum of two distinct prime numbers. -/\ntheorem", "choices": ["Â¬âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6 ", "Â¬âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6 ", "Â¬âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6 ", "Â¬âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6 ", "Â¬âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6 ", "Â¬âˆƒ (p q : â„•), Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6 ", "Â¬ âˆƒ p q : â„•, Nat.Prime p âˆ§ Nat.Prime q âˆ§ p â‰  q âˆ§ p + q = 6 ", "âˆ€ {a b : â„•}, Nat.Prime a â†’ Nat.Prime b â†’ a â‰  b â†’ a + b â‰  6 ", "Â¬âˆƒ (a b : â„•), Nat.Prime a âˆ§ Nat.Prime b âˆ§ a â‰  b âˆ§ a + b = 6 ", "Â¬âˆƒ (p q : â„•), Nat.Prime p â†’ Nat.Prime q â†’ p â‰  q â†’ p + q = 6 "]}, {"stmt": "No integer is irrational.", "prompts": "[{\"theorem\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"theorem\": \"âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\": \"âˆ€ {a b : â„¤}, a âˆ£ b â†’ Int.natAbs b < Int.natAbs a â†’ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} [inst : LinearOrderedField ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : OrderTopology ð•œ]\\n  [inst_3 : Archimedean ð•œ], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"}]\n", "prompt_cons": "/-- A transcendental real number is irrational. -/\ntheorem âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I â‰  0 â†’ âˆƒ x x_1, â†‘(algebraMap R K) x âˆˆ I :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2} :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q :=\n\n/-- No zero divisors. -/\ntheorem âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0 :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- If an integer with larger absolute value divides an integer, it is\nzero. -/\ntheorem âˆ€ {a b : â„¤}, a âˆ£ b â†’ Int.natAbs b < Int.natAbs a â†’ b = 0 :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem âˆ€ {ð•œ : Type u_1} [inst : LinearOrderedField ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : OrderTopology ð•œ]\n  [inst_3 : Archimedean ð•œ], DenseRange Rat.cast :=\n\n/-- No integer is irrational. -/\ntheorem", "choices": ["âˆ€ (z : â„¤), Â¬Irrational (â†‘z) ", "âˆ€ (n : â„¤), Â¬Irrational (â†‘n : â„) ", "âˆ€ (n : â„¤), Â¬Irrational (â†‘n : â„) ", "âˆ€ (n : â„¤), Â¬Irrational (â†‘n : â„) ", "âˆ€ (n : â„¤), Â¬Irrational (â†‘n : â„) ", "âˆ€ (n : â„¤), Â¬Irrational (â†‘n) ", "âˆ€ (n : â„¤), Â¬Irrational â†‘n ", "âˆ€ (z : â„¤), Â¬Irrational (â†‘z) ", "âˆ€ (n : â„¤), Â¬Irrational (â†‘n : â„) ", "âˆ€ (n : â„¤), Â¬Irrational (â†‘n : â„) "]}, {"stmt": "The identity element in a ring is a unit.", "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u} [inst : Ring Î±], IsRingHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a ring homomorphism. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 1 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 1. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : MulOneClass Î±] [inst_1 : HasDistribNeg Î±] (a : Î±), a * -1 = -a\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R â‰ƒ+* S), â†‘f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends one to one. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is a group homomorphism. \"},\n {\"theorem\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 0. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x âˆˆ I â†’ â€–1 - xâ€– < 1 â†’ I = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"},\n {\"theorem\": \"âˆ€ {M : Type u_1} [inst : Monoid M] {x : M}, x âˆˆ powers x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of a monoid is in the set of that element's natural number powers. \"}]\n", "prompt_cons": "/-- The identity map is a ring homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Ring Î±], IsRingHom id :=\n\n/-- A subring contains the ring's 1. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 1 âˆˆ s :=\n\n/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive\ninverse. -/\ntheorem âˆ€ {Î± : Type u} [inst : MulOneClass Î±] [inst_1 : HasDistribNeg Î±] (a : Î±), a * -1 = -a :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0 :=\n\n/-- A ring isomorphism sends one to one. -/\ntheorem âˆ€ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R â‰ƒ+* S), â†‘f 1 = 1 :=\n\n/-- The identity is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id :=\n\n/-- A subring contains the ring's 0. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s :=\n\n/-- An ideal which contains an element within `1` of `1 : R` is the unit ideal. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x âˆˆ I â†’ â€–1 - xâ€– < 1 â†’ I = âŠ¤ :=\n\n/-- An element of a monoid is in the set of that element's natural number powers. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M] {x : M}, x âˆˆ powers x :=\n\n/-- The identity element in a ring is a unit. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) ", "âˆ€ {R : Type u} [inst : Ring R], IsUnit (1 : R) "]}, {"stmt": "Every subgroup of a group is a group.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {k : Set G}, k âŠ† â†‘(Subgroup.closure k)\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup generated by a set includes the set. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup contains the group's 1. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x âˆˆ H â†’ xâ»Â¹ âˆˆ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under inverse. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K\",\n  \"isProp\": true,\n  \"docString\": \"Two subgroups are equal if they have the same elements. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x y : G}, y âˆˆ Subgroup.closure {x} â†” âˆƒ n, x ^ n = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subgroup generated by an element of a group equals the set of integer number powers of\\nthe element. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"}]\n", "prompt_cons": "/-- A subgroup is closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H :=\n\n/-- A subgroup is closed under division. -/\ntheorem âˆ€ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H :=\n\n/-- The subgroup generated by a set includes the set. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {k : Set G}, k âŠ† â†‘(Subgroup.closure k) :=\n\n/-- A subgroup contains the group's 1. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 âˆˆ H :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion { x // x âˆˆ H } :=\n\n/-- A subgroup is closed under inverse. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x âˆˆ H â†’ xâ»Â¹ âˆˆ H :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P â†” Submonoid.FG P.toSubmonoid :=\n\n/-- Two subgroups are equal if they have the same elements. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K :=\n\n/-- The subgroup generated by an element of a group equals the set of integer number powers of\nthe element. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x y : G}, y âˆˆ Subgroup.closure {x} â†” âˆƒ n, x ^ n = y :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = âŠ¥ âˆ¨ Nontrivial { x // x âˆˆ H } :=\n\n/-- Every subgroup of a group is a group. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group {x // x âˆˆ H} ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } ", "âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x âˆˆ H } "]}, {"stmt": "The sum of two natural numbers is a natural number.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two finite adÃ¨les is a finite adÃ¨le. \"},\n {\"theorem\": \"âˆ€ (n : â„•), PGame.Numeric â†‘n\",\n  \"isProp\": true,\n  \"docString\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"theorem\":\n  \"âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] {n : â„•âˆž}\\n  {f g : E â†’ F}, ContDiff ð•œ n f â†’ ContDiff ð•œ n g â†’ ContDiff ð•œ n fun x => f x + g x\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two `C^n`functions is `C^n`. \"},\n {\"theorem\":\n  \"âˆ€ (a b : Ordinal.{u}), Ordinal.toPGame a + Ordinal.toPGame b â‰ˆ Ordinal.toPGame (Ordinal.nadd a b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of ordinals as games corresponds to natural addition of ordinals. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤ :=\n\n/-- The sum of two finite adÃ¨les is a finite adÃ¨le. -/\ntheorem âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  {x y : DedekindDomain.ProdAdicCompletions R K},\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y) :=\n\n/-- Pre-games defined by natural numbers are numeric. -/\ntheorem âˆ€ (n : â„•), PGame.Numeric â†‘n :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem âˆ€ {Î¹ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M},\n  (Finset.sum s fun i => f i) = âŠ¤ â†” âˆƒ i, i âˆˆ s âˆ§ f i = âŠ¤ :=\n\n/-- The sum of two `C^n`functions is `C^n`. -/\ntheorem âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F] {n : â„•âˆž}\n  {f g : E â†’ F}, ContDiff ð•œ n f â†’ ContDiff ð•œ n g â†’ ContDiff ð•œ n fun x => f x + g x :=\n\n/-- The sum of ordinals as games corresponds to natural addition of ordinals. -/\ntheorem âˆ€ (a b : Ordinal.{u}), Ordinal.toPGame a + Ordinal.toPGame b â‰ˆ Ordinal.toPGame (Ordinal.nadd a b) :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- The sum of two natural numbers is a natural number. -/\ntheorem", "choices": ["âˆ€ (m n : â„•), âˆƒ k, m + n = k ", "âˆ€ (m n : â„•), âˆƒ k, m + n = k ", "âˆ€ (m n : â„•), âˆƒ (k : â„•), m + n = k ", "âˆ€ (m n : â„•), âˆƒ k, m + n = k ", "âˆ€ (m n : â„•), âˆƒ k, m + n = k ", "âˆ€ (m n : â„•), âˆƒ r, m + n = r ", "âˆ€ (m n : â„•), âˆƒ (k : â„•), m + n = k ", "âˆ€ (m n : â„•), âˆƒ (k : â„•), m + n = k ", "âˆ€ (a b : â„•), âˆƒ (c : â„•), a + b = c ", "âˆ€ (m n : â„•), âˆƒ (k : â„•), m + n = k "]}, {"stmt": "The identity element of a group has finite order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is a group homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"}]\n", "prompt_cons": "/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (â†‘f x) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x :=\n\n/-- The identity is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- The identity element of a group has finite order. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "forall {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) "]}, {"stmt": "`7` is a prime number.", "prompts": "[{\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\": \"âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"}]\n", "prompt_cons": "/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem âˆ€ (R : Type u) [inst : Semiring R] (q : â„•) [hq : ExpChar R q], Nat.Prime q âˆ¨ q = 1 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem âˆ€ {p q : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) q â‰  0 â†’ p = q :=\n\n/-- A minimal polynomial is prime. -/\ntheorem âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x â†’ Prime (minpoly A x) :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem âˆ€ {p : â„•}, Nat.Prime p â†’ â†‘(Nat.factorization p) p = 1 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- `7` is a prime number. -/\ntheorem", "choices": ["Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) ", "Fact (Nat.Prime 7) "]}, {"stmt": "There are `3` prime numbers below `8`.", "prompts": "[{\"theorem\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\":\n  \"âˆ€ (n : â„•), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n)\",\n  \"isProp\": true,\n  \"docString\": \"The factors of `n` are the prime divisors \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"}]\n", "prompt_cons": "/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare (-2) â†” p % 8 = 1 âˆ¨ p % 8 = 3) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem âˆ€ {n : â„•}, 0 < n â†’ Â¬Nat.Prime n â†’ Nat.minFac n ^ 2 â‰¤ n :=\n\n/-- The factors of `n` are the prime divisors -/\ntheorem âˆ€ (n : â„•), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n) :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\n  Irreducible p â†’\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n) :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem âˆ€ {p n : â„•}, 2 < n â†’ p â‰¤ n â†’ 2 * n < 3 * p â†’ â†‘(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem âˆ€ {b m d : â„•}, d âˆˆ Nat.digits (b + 2) m â†’ d < b + 2 :=\n\n/-- There are `3` prime numbers below `8`. -/\ntheorem", "choices": ["prime_counting_function 8 = 3 ", "Nat.count_primes_below_8 : Nat.count 8 Nat.Prime = 3 ", "Nat.prime_counting_function 8 = 3 ", "Nat.card_prime_lt 8 = 3 ", "Nat.card_prime_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Nat.card_primes_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Fact (âˆƒ (primes_below_eight : List â„•), primes_below_eight = [2, 3, 5, 7] âˆ§ List.length primes_below_eight = 3) ", "Nat.prime_counting_function 8 = 3 ", "Nat.card_primes_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ", "Prime.card (Finset.filter (Î» p, p < 8) (Finset.range 8)) = 3 "]}, {"stmt": "The empty set is contained in every finite set.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is concyclic. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\\n  TendstoUniformlyOn F f p âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±], Finset.shadow âˆ… = âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The shadow of the empty set is empty. \"}]\n", "prompt_cons": "/-- The set of finite subsets of a countable set is countable. -/\ntheorem âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s} :=\n\n/-- The empty set is concyclic. -/\ntheorem âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic âˆ… :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : TopologicalSpace.SecondCountableTopology Î±],\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C :=\n\n/-- A finite union of finsets is finite. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a)) :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- Uniform convergence on the empty set is vacuously true -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹},\n  TendstoUniformlyOn F f p âˆ… :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K) :=\n\n/-- The shadow of the empty set is empty. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±], Finset.shadow âˆ… = âˆ… :=\n\n/-- The empty set is contained in every finite set. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ âˆ… âŠ† a ", "âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ âˆ… âŠ† a ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ HasSubset.Subset âˆ… s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆ… âŠ† s "]}, {"stmt": "Every infinite set contains a finite set.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Set.Finite s â†’ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î´ : Type u_1} [inst : Finite Î´] {Îº : Î´ â†’ Type u_2} {t : (d : Î´) â†’ Set (Îº d)},\\n  (âˆ€ (d : Î´), Set.Finite (t d)) â†’ Set.Finite (Set.pi Set.univ t)\",\n  \"isProp\": true,\n  \"docString\": \"Finite product of finite sets is finite \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded below.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\\n  IsCompact s â†’\\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"}]\n", "prompt_cons": "/-- The set of finite subsets of a countable set is countable. -/\ntheorem âˆ€ {Î± : Type u} {s : Set Î±}, Set.Countable s â†’ Set.Countable {t | Set.Finite t âˆ§ t âŠ† s} :=\n\n/-- A finite union of finsets is finite. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ (a : Î±), â†‘(f a)) :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem âˆ€ {Î± : Type u} {a : Set Î±}, Set.Finite a â†’ Set.Finite {b | b âŠ† a} :=\n\n/-- A finite set is bounded -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±}, Set.Finite s â†’ Metric.Bounded s :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K) :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem âˆ€ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val :=\n\n/-- Finite product of finite sets is finite -/\ntheorem âˆ€ {Î´ : Type u_1} [inst : Finite Î´] {Îº : Î´ â†’ Type u_2} {t : (d : Î´) â†’ Set (Îº d)},\n  (âˆ€ (d : Î´), Set.Finite (t d)) â†’ Set.Finite (Set.pi Set.univ t) :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem âˆ€ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val :=\n\n/-- A finite set is bounded below. -/\ntheorem âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : Nonempty Î±] {s : Set Î±}, Set.Finite s â†’ BddBelow s :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem âˆ€ {Î± : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±},\n  IsCompact s â†’\n    (âˆ€ (i : Î¹), i âˆˆ b â†’ IsOpen (c i)) â†’\n      s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b), c i â†’ âˆƒ b', b' âŠ† b âˆ§ Set.Finite b' âˆ§ s âŠ† â‹ƒ (i : Î¹) (_ : i âˆˆ b'), c i :=\n\n/-- Every infinite set contains a finite set. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} {s : Set Î±}, Â¬Set.Finite s â†’ âˆƒ t : Set Î±, Set.Finite t âˆ§ t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±} [inst : Infinite Î±], âˆƒ t : Finset Î±, t âŠ† s âˆ§ Set.Finite t ", "âˆ€ {Î± : Type u} {s : Set Î±} [inst : Infinite Î±], âˆƒ (t : Finset Î±), t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Infinite s â†’ âˆ€ (n : â„•), âˆƒ t : Finset Î±, â†‘t âŠ† s âˆ§ Finset.card t = n ", "âˆ€ {Î± : Type u} {s : Set Î±} [inst : Infinite Î±], âˆƒ t : Set Î±, Set.Finite t âˆ§ t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±}, Â¬Set.Finite s â†’ âˆƒ t : Set Î±, Set.Finite t âˆ§ t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±} [inst : Infinite Î±], âˆƒ t : Set Î±, Set.Finite t âˆ§ t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±} [inst : Infinite Î±], âˆƒ t : Set Î±, Set.Finite t âˆ§ t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±} [inst : Infinite Î±], âˆƒ t : Set Î±, Set.Finite t âˆ§ t âŠ† s ", "âˆ€ {Î± : Type u} {s : Set Î±} [inst : Infinite Î±], âˆƒ t : Set Î±, Set.Finite t âˆ§ t âŠ† s "]}, {"stmt": "Every commutative ring is a monoid.", "prompts": "[{\"theorem\":\n  \"âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\": \"âˆ€ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"A monoid is a submonoid of itself. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : MulOneClass Î±] [inst_1 : MulOneClass Î²] {f : Î± â†’ Î²},\\n  IsMonoidHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : MulOneClass Î³] {g : Î² â†’ Î³}, IsMonoidHom g â†’ IsMonoidHom (g âˆ˜ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composite of two monoid homomorphisms is a monoid homomorphism. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommMonCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative monoids has all limits. \"},\n {\"theorem\":\n  \"âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of monoid homomorphisms is associative. \"},\n {\"theorem\": \"âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\",\n  \"isProp\": true,\n  \"docString\": \"1 is of finite order in any monoid. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative rings has all limits. \"},\n {\"theorem\":\n  \"âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => x * y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left multiplication in a ring is an additive monoid morphism. \"}]\n", "prompt_cons": "/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x âˆˆ Submonoid.center M } M :=\n\n/-- A monoid is a submonoid of itself. -/\ntheorem âˆ€ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ :=\n\n/-- The composite of two monoid homomorphisms is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : MulOneClass Î±] [inst_1 : MulOneClass Î²] {f : Î± â†’ Î²},\n  IsMonoidHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : MulOneClass Î³] {g : Î² â†’ Î³}, IsMonoidHom g â†’ IsMonoidHom (g âˆ˜ f) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f :=\n\n/-- The category of commutative monoids has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommMonCatMax :=\n\n/-- Composition of monoid homomorphisms is associative. -/\ntheorem âˆ€ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f) :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1 :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- The category of commutative rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem âˆ€ {Î³ : Type u_1} [inst : NonUnitalNonAssocSemiring Î³] (x : Î³), IsAddMonoidHom fun y => x * y :=\n\n/-- Every commutative ring is a monoid. -/\ntheorem", "choices": ["âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R ", "âˆ€ {R : Type u} [inst : CommRing R], Monoid R "]}, {"stmt": "There is no field of order `10`.", "prompts": "[{\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b}\",\n  \"isProp\": true,\n  \"docString\": \"Ordinals that are cardinals are unbounded. \"},\n {\"theorem\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b âˆ§ Ordinal.omega â‰¤ b}\",\n  \"isProp\": true,\n  \"docString\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"theorem\": \"Â¬IsField â„¤\",\n  \"isProp\": true,\n  \"docString\": \"`â„¤` with its usual ring structure is not a field. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (p : P), Â¬p âˆˆ âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"No points are in `âŠ¥`. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\": \"âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"The order of the `0` power series is infinite.\"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LT Î±] {a b : Î±} [inst_1 : DenselyOrdered Î±], Â¬a â‹– b\",\n  \"isProp\": true,\n  \"docString\": \"In a dense order, nothing covers anything. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] [inst_1 : Nontrivial R], PowerSeries.order 1 = 0\",\n  \"isProp\": true,\n  \"docString\": \"The order of the formal power series `1` is `0`.\"}]\n", "prompt_cons": "/-- Ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b} :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- Fields are commutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x :=\n\n/-- Infinite ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b âˆ§ Ordinal.omega â‰¤ b} :=\n\n/-- `â„¤` with its usual ring structure is not a field. -/\ntheorem Â¬IsField â„¤ :=\n\n/-- No points are in `âŠ¥`. -/\ntheorem âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (p : P), Â¬p âˆˆ âŠ¥ :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 âˆˆ S :=\n\n/-- The order of the `0` power series is infinite. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = âŠ¤ :=\n\n/-- In a dense order, nothing covers anything. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LT Î±] {a b : Î±} [inst_1 : DenselyOrdered Î±], Â¬a â‹– b :=\n\n/-- The order of the formal power series `1` is `0`. -/\ntheorem âˆ€ {R : Type u_1} [inst : Semiring R] [inst_1 : Nontrivial R], PowerSeries.order 1 = 0 :=\n\n/-- There is no field of order `10`. -/\ntheorem", "choices": ["Â¬âˆƒ (F : Type u_1) [inst : Field F], Fintype.card F = 10 ", "Â¬âˆƒ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "Â¬âˆƒ (F : Type u_1) [inst : Field F], Fintype.card F = 10 ", "Â¬âˆƒ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "Â¬âˆƒ (K : Type u) [inst : Field K], Fintype.card K = 10 ", "Â¬âˆƒ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "Â¬âˆƒ (K : Type) [inst : Field K], Fintype.card K = 10 ", "Â¬âˆƒ {F : Type u_1} [inst : Field F], Fintype.card F = 10 ", "Â¬âˆƒ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ", "Â¬âˆƒ (F : Type u) [inst : Field F], Fintype.card F = 10 "]}, {"stmt": "Every odd natural number is the sum of two distinct natural numbers.", "prompts": "[{\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x â‰  0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two finite adÃ¨les is a finite adÃ¨le. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x â‰  0} :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : LinearOrderedRing Î±] [inst_1 : Archimedean Î±] {x y : Î±},\n  1 â‰¤ x â†’ 1 < y â†’ âˆƒ n, y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2 :=\n\n/-- The sum of two finite adÃ¨les is a finite adÃ¨le. -/\ntheorem âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\n  {x y : DedekindDomain.ProdAdicCompletions R K},\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y) :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem âˆ€ {Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ ENNReal}, (âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) â†’ (Finset.sum s fun a => f a) < âŠ¤ :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- Every odd natural number is the sum of two distinct natural numbers. -/\ntheorem", "choices": ["âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ {n : â„•}, Odd n â†’ âˆƒ m k : â„•, m â‰  k âˆ§ n = m + k ", "âˆ€ (n : â„•), Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b : â„•, n = a + b âˆ§ a â‰  b ", "âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ {n : â„•}, Odd n â†’ âˆƒ (a b : â„•), a â‰  b âˆ§ n = a + b ", "âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b ", "âˆ€ {n : â„•}, Odd n â†’ âˆƒ x y : â„•, x â‰  y âˆ§ n = x + y ", "âˆ€ {n : â„•}, Odd n â†’ âˆƒ a b : â„•, a â‰  b âˆ§ n = a + b "]}, {"stmt": "Every element in the trivial group has finite order.", "prompts": "[{\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"}]\n", "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleGroup Î± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î± :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem âˆ€ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\n  IsOfFinOrder x â†’ IsOfFinOrder (â†‘f x) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\n  Fintype.card Î± = p â†’ IsAddCyclic Î± :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x âˆˆ H }), IsOfFinAddOrder x â†” IsOfFinAddOrder â†‘x :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x :=\n\n/-- Every element in the trivial group has finite order. -/\ntheorem", "choices": ["âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ", "âˆ€ {G : Type u_1} [inst : GroupWithZero G], IsOfFinOrder (0 : G) ", "âˆ€ {G : Type u_1} [inst : One G] (x : G), IsOfFinOrder x ", "forall {G : Type u_1} [inst : GroupWithZero G] (x : G), IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : GroupWithZero G], IsOfFinOrder (0 : G) ", "âˆ€ {G : Type u_1} [inst : GroupWithZero G], IsOfFinOrder (0 : G) ", "âˆ€ {G : Type u_1} [inst : Group G] [Subsingleton G] (x : G), IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : Monoid G] [inst_1 : Unique G], âˆ€ (x : G), IsOfFinOrder x ", "âˆ€ {G : Type u_1} [inst : GroupWithZero G] {x : G}, IsOfFinOrder x "]}, {"stmt": "The square of an even number is even.", "prompts": "[{\"theorem\":\n  \"âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z},\\n  CategoryTheory.CommSq f g h i â†’ CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i\",\n  \"isProp\": true,\n  \"docString\": \"The square commutes. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"}]\n", "prompt_cons": "/-- The convolution of two even functions is also even. -/\ntheorem âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F â‰  2 â†’ âˆƒ a, Â¬IsSquare a :=\n\n/-- The square commutes. -/\ntheorem âˆ€ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z},\n  CategoryTheory.CommSq f g h i â†’ CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7) :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0 :=\n\n/-- `2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. -/\ntheorem âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5 :=\n\n/-- The square of an even number is even. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : CommRing Î±] {x : Î±}, x % 2 = 0 â†’ (x * x) % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : CommSemiring Î±] {x : Î±}, IsEven x â†’ IsEven (x * x) ", "âˆ€ {Î± : Type u} [inst : CommRing Î±] {x : Î±}, x % 2 = 0 â†’ (x * x) % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, Even x â†’ Even (x * x) ", "âˆ€ {n : â„•}, Even (n ^ 2) â†” Even n ", "âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x : Î±}, x % 2 = 0 â†’ (x * x) % 2 = 0 ", "âˆ€ {Î± : Type u} [inst : Semiring Î±] {x : Î±}, Even x â†’ Even (x * x) ", "âˆ€ {n : â„•}, Even (n ^ 2) â†” Even n ", "âˆ€ {n : â„•}, Even (n ^ 2) â†” Even n ", "âˆ€ {Î± : Type u} [inst : Semiring Î±] {a : Î±}, Even a â†’ Even (a * a) "]}, {"stmt": "Every commutative division ring is a field.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative rings has all limits. \"},\n {\"theorem\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} {Ïƒ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial Ïƒ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"theorem\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"}]\n", "prompt_cons": "/-- Fields are commutative. -/\ntheorem âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- The category of commutative rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax :=\n\n/-- A field is a valuation ring. -/\ntheorem âˆ€ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- An intermediate field is closed under division. -/\ntheorem âˆ€ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S :=\n\n/-- The multivariate polynomial ring over an integral domain is an integral domain. -/\ntheorem âˆ€ {R : Type u} {Ïƒ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial Ïƒ R) :=\n\n/-- Every nonarchimedean ring is naturally a nonarchimedean additive group. -/\ntheorem âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R],\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : â„•) [inst_2 : Fact (Nat.Prime p)],\n  p âˆ£ ringChar R â†” p âˆ£ Fintype.card R :=\n\n/-- Every commutative division ring is a field. -/\ntheorem", "choices": ["âˆ€ (A : Type u) [inst : CommRing A] [inst_1 : Nontrivial A] [inst_2 : DivisionRing A], IsField A ", "âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "âˆ€ (R : Type u) [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "âˆ€ {K : Type u} [inst : CommRing K] [inst_1 : IsDivisionRing K], IsField K ", "âˆ€ {R : Type u} [inst : CommRing R] [IsDivisionRing R], IsField R ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDivisionRing R], IsField R ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DivisionRing R], IsField R "]}, {"stmt": "The image of the identity element under the identity map is the identity element.", "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u} [inst : Ring Î±], IsRingHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a ring homomorphism. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : MulOneClass Î±], IsMonoidHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a monoid homomorphism. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Mul Î±], IsMulHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map preserves multiplication. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Semiring Î±], IsSemiringHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a semiring homomorphism. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : AddZeroClass Î±], IsAddMonoidHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is an additive monoid homomorphism.\"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_3) {V1 : Type u_2} (P1 : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\\n  [inst_3 : AddTorsor V1 P1], â†‘(AffineMap.id k P1) = id\",\n  \"isProp\": true,\n  \"docString\": \"The identity affine map acts as the identity. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±], Isometry id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is an isometry \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is a group homomorphism. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : Add Î±], IsAddHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map preserves addition\"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : AddGroup Î±], IsAddGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is an additive group homomorphism.\"}]\n", "prompt_cons": "/-- The identity map is a ring homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Ring Î±], IsRingHom id :=\n\n/-- The identity map is a monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : MulOneClass Î±], IsMonoidHom id :=\n\n/-- The identity map preserves multiplication. -/\ntheorem âˆ€ {Î± : Type u} [inst : Mul Î±], IsMulHom id :=\n\n/-- The identity map is a semiring homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±], IsSemiringHom id :=\n\n/-- The identity map is an additive monoid homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddZeroClass Î±], IsAddMonoidHom id :=\n\n/-- The identity affine map acts as the identity. -/\ntheorem âˆ€ (k : Type u_3) {V1 : Type u_2} (P1 : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\n  [inst_3 : AddTorsor V1 P1], â†‘(AffineMap.id k P1) = id :=\n\n/-- The identity is an isometry -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±], Isometry id :=\n\n/-- The identity is a group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : Group Î±], IsGroupHom id :=\n\n/-- The identity map preserves addition -/\ntheorem âˆ€ {Î± : Type u} [inst : Add Î±], IsAddHom id :=\n\n/-- The identity is an additive group homomorphism. -/\ntheorem âˆ€ {Î± : Type u} [inst : AddGroup Î±], IsAddGroupHom id :=\n\n/-- The image of the identity element under the identity map is the identity element. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : HasOne Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : HasOne Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : HasOne Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : HasOne Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : HasOne Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : HasOne Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : HasOne Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : HasOne Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : HasOne Î±], id 1 = 1 ", "âˆ€ {Î± : Type u} [inst : HasOne Î±], id 1 = 1 "]}, {"stmt": "Every point is a fixed point of the identity function on a space.", "prompts": "[{\"theorem\": \"âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x\",\n  \"isProp\": true,\n  \"docString\": \"Every point is a fixed point of `id`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\\n  Continuous f â†’ IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : Î¹ â†’ P},\\n  AffineIndependent k p â†’ Finite Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent family of points in a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {pâ‚ pâ‚‚ : P}, pâ‚ âˆˆ affineSpan k {pâ‚‚} â†” pâ‚ = pâ‚‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point is in the affine span of a single point if and only if they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T0Space Î±] â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y\",\n  \"isProp\": true,\n  \"docString\": \"Two inseparable points in a Tâ‚€ space are equal. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\\n  AffineIndependent k f â†’ Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (u v : â„™ K V),\\n  Projectivization.Dependent ![u, v] â†” u = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two points in a projective space are dependent if and only if they are equal. \"},\n {\"theorem\":\n  \"âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  (AffineIndependent k fun p => â†‘p) â†’ âˆƒ t, s âŠ† t âˆ§ (AffineIndependent k fun p => â†‘p) âˆ§ affineSpan k t = âŠ¤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affinely independent set of points can be extended to such a\\nset that spans the whole space. \"}]\n", "prompt_cons": "/-- Every point is a fixed point of `id`. -/\ntheorem âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] {f : Î± â†’ Î±},\n  Continuous f â†’ IsClosed (Function.fixedPoints f) :=\n\n/-- An affine-independent family of points in a finite-dimensional affine space is finite. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : Î¹ â†’ P},\n  AffineIndependent k p â†’ Finite Î¹ :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W) :=\n\n/-- A point is in the affine span of a single point if and only if they are equal. -/\ntheorem âˆ€ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {pâ‚ pâ‚‚ : P}, pâ‚ âˆˆ affineSpan k {pâ‚‚} â†” pâ‚ = pâ‚‚ :=\n\n/-- Two inseparable points in a Tâ‚€ space are equal. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T0Space Î±] â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Î¹ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Î¹} {f : â†‘s â†’ P},\n  AffineIndependent k f â†’ Set.Finite s :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x :=\n\n/-- Two points in a projective space are dependent if and only if they are equal. -/\ntheorem âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (u v : â„™ K V),\n  Projectivization.Dependent ![u, v] â†” u = v :=\n\n/-- An affinely independent set of points can be extended to such a\nset that spans the whole space. -/\ntheorem âˆ€ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P},\n  (AffineIndependent k fun p => â†‘p) â†’ âˆƒ t, s âŠ† t âˆ§ (AffineIndependent k fun p => â†‘p) âˆ§ affineSpan k t = âŠ¤ :=\n\n/-- Every point is a fixed point of the identity function on a space. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x ", "âˆ€ {Î± : Type u} (x : Î±), Function.IsFixedPt id x "]}, {"stmt": "The diameter of a singleton space is `0`.", "prompts": "[{\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"A singleton has zero diameter \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±}, EMetric.diam {x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The diameter of a singleton vanishes \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±], Metric.diam âˆ… = 0\",\n  \"isProp\": true,\n  \"docString\": \"The empty set has zero diameter \"},\n {\"theorem\": \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±], EMetric.diam âˆ… = 0\",\n  \"isProp\": true,\n  \"docString\": \"The diameter of the empty set vanishes \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\\n  [inst_4 : NoZeroSMulDivisors K V] [h : Subsingleton V], FiniteDimensional.finrank K V = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (finite dimensional) space that is a subsingleton has zero `finrank`. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î² : Type u_1} [inst_1 : TopologicalSpace Î²]\\n  [inst_2 : TotallyDisconnectedSpace Î²] {f : Î± â†’ Î²}, Continuous f â†’ âˆ€ (a : Î±), f '' connectedComponent a = {f a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a connected component in a totally disconnected space is a singleton. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), connectedComponent x = {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Zero Î±] [inst_1 : Zero Î²] [inst_2 : SMulWithZero Î± Î²] [inst_3 : DecidableEq Î²]\\n  {s : Finset Î²}, Finset.Nonempty s â†’ 0 â€¢ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T1Space Î±] (x : Î±), IsClosed {x}\",\n  \"isProp\": true,\n  \"docString\": \"A singleton in a Tâ‚ space is a closed set. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X], T0Space (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a `T0Space` space is a `T0Space`. \"}]\n", "prompt_cons": "/-- A singleton has zero diameter -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 :=\n\n/-- The diameter of a singleton vanishes -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {x : Î±}, EMetric.diam {x} = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±], Metric.diam âˆ… = 0 :=\n\n/-- The diameter of the empty set vanishes -/\ntheorem âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±], EMetric.diam âˆ… = 0 :=\n\n/-- A (finite dimensional) space that is a subsingleton has zero `finrank`. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\n  [inst_4 : NoZeroSMulDivisors K V] [h : Subsingleton V], FiniteDimensional.finrank K V = 0 :=\n\n/-- The image of a connected component in a totally disconnected space is a singleton. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Î² : Type u_1} [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TotallyDisconnectedSpace Î²] {f : Î± â†’ Î²}, Continuous f â†’ âˆ€ (a : Î±), f '' connectedComponent a = {f a} :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), connectedComponent x = {x} :=\n\n/-- A nonempty set is scaled by zero to the singleton set containing 0. -/\ntheorem âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Zero Î±] [inst_1 : Zero Î²] [inst_2 : SMulWithZero Î± Î²] [inst_3 : DecidableEq Î²]\n  {s : Finset Î²}, Finset.Nonempty s â†’ 0 â€¢ s = 0 :=\n\n/-- A singleton in a Tâ‚ space is a closed set. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : T1Space Î±] (x : Î±), IsClosed {x} :=\n\n/-- The one point compactification of a `T0Space` space is a `T0Space`. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X], T0Space (OnePoint X) :=\n\n/-- The diameter of a singleton space is `0`. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 ", "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±}, Metric.diam {x} = 0 "]}, {"stmt": "Every group is non-empty.", "prompts": "[{\"theorem\":\n  \"âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"The ideal is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {a b : Ordinal.{u_1}}, b â‰  0 â†’ Set.Nonempty {o | a < b * Order.succ o}\",\n  \"isProp\": true,\n  \"docString\": \"The set in the definition of division is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty â†‘s], Nonempty { x // x âˆˆ affineSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : FiniteDimensional â„ V] {s : Set V},\\n  Convex â„ s â†’ Set.Nonempty s â†’ Set.Nonempty (intrinsicInterior â„ s)\",\n  \"isProp\": true,\n  \"docString\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty interior\\nis locally compact. \"},\n {\"theorem\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\": \"âˆ€ {Î± : Type u_1} (self : FilterBasis Î±), Set.Nonempty self.sets\",\n  \"isProp\": true,\n  \"docString\": \"The set of filter basis sets is nonempty. \"}]\n", "prompt_cons": "/-- Each connected component of the category is nonempty. -/\ntheorem âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  Nonempty (CategoryTheory.Component j) :=\n\n/-- The ideal is nonempty. -/\ntheorem âˆ€ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier :=\n\n/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- The set in the definition of division is nonempty. -/\ntheorem âˆ€ {a b : Ordinal.{u_1}}, b â‰  0 â†’ Set.Nonempty {o | a < b * Order.succ o} :=\n\n/-- The affine span of a nonempty set is nonempty. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty â†‘s], Nonempty { x // x âˆˆ affineSpan k s } :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1 :=\n\n/-- The intrinsic interior of a nonempty convex set is nonempty. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : FiniteDimensional â„ V] {s : Set V},\n  Convex â„ s â†’ Set.Nonempty s â†’ Set.Nonempty (intrinsicInterior â„ s) :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty interior\nis locally compact. -/\ntheorem âˆ€ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G â†’ LocallyCompactSpace G :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G Ã— K) :=\n\n/-- The set of filter basis sets is nonempty. -/\ntheorem âˆ€ {Î± : Type u_1} (self : FilterBasis Î±), Set.Nonempty self.sets :=\n\n/-- Every group is non-empty. -/\ntheorem", "choices": ["âˆ€ {G : Type u} [inst : Group G], Nonempty G ", "âˆ€ {G : Type u} [inst : Group G], Nonempty G ", "âˆ€ {G : Type u} [inst : Group G], Nonempty G ", "âˆ€ {G : Type u} [inst : Group G], Nonempty G ", "âˆ€ {G : Type u} [inst : Group G], Nonempty G ", "âˆ€ {G : Type u} [inst : Group G], Nonempty G ", "âˆ€ (G : Type u_1) [inst : Group G], Nonempty G ", "âˆ€ {G : Type u} [inst : Group G], Nonempty G ", "âˆ€ {G : Type u} [inst : Group G], Nonempty G ", "âˆ€ {G : Type u} [inst : Group G], Nonempty G "]}, {"stmt": "All connected components of a topological space are connected.", "prompts": "[{\"theorem\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is connected. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î±\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î±\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), connectedComponent x = {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\\n  TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), Set.Subsingleton (connectedComponent x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"},\n {\"theorem\":\n  \"âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally connected charts, then the space itself is\\nlocally connected. \"},\n {\"theorem\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"theorem\":\n  \"âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is nonempty. \"}]\n", "prompt_cons": "/-- The underlying topological space is compact. -/\ntheorem âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop :=\n\n/-- Each connected component of the category is connected. -/\ntheorem âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  CategoryTheory.IsConnected (CategoryTheory.Component j) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Finite Î±], CompactSpace Î± :=\n\n/-- A connected space is nonempty. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [self : ConnectedSpace Î±], Nonempty Î± :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î± :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), connectedComponent x = {x} :=\n\n/-- A space is totally disconnected iff its connected components are subsingletons. -/\ntheorem âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±],\n  TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), Set.Subsingleton (connectedComponent x) :=\n\n/-- If a topological space admits an atlas with locally connected charts, then the space itself is\nlocally connected. -/\ntheorem âˆ€ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M :=\n\n/-- Any two points in a path-connected space must be joined by a continuous path. -/\ntheorem âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y :=\n\n/-- Each connected component of the category is nonempty. -/\ntheorem âˆ€ {J : Type uâ‚} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  Nonempty (CategoryTheory.Component j) :=\n\n/-- All connected components of a topological space are connected. -/\ntheorem", "choices": ["âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±),\n  ConnectedSpace.connected (ConnectedComponents.connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), Connected (ConnectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), ConnectedSpace (connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±),\n  IsConnected (connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±),\n  ConnectedSpace (coe (connectedComponent x)) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), ConnectedSpace (connectedComponent x) ", "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), Connected (connectedComponent x) ", "forall {Î± : Type u} [inst : TopologicalSpace Î±] (x : Î±), IsConnected (connectedComponent x) "]}, {"stmt": "The ring of integers has a maximal ideal.", "prompts": "[{\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"âˆ€ {p : â„•+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime â†‘p)]\\n  [inst_2 : IsCyclotomicExtension {p} â„š K], IsCyclotomicExtension {p} â„¤ { x // x âˆˆ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ring of integers of a `p`-th cyclotomic extension of `â„š` is a cyclotomic extension. \"},\n {\"theorem\":\n  \"âˆ€ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] â¦ƒJ : Order.Ideal Pâ¦„,\\n  I < J â†’ â†‘J = Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"theorem\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 â†” IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The class number is `1` iff the ring of integers is a principal ideal domain. \"}]\n", "prompt_cons": "/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I) :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥ :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem âˆ€ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free â„¤ S]\n  [inst_4 : Module.Finite â„¤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I :=\n\n/-- The ring of integers of a `p`-th cyclotomic extension of `â„š` is a cyclotomic extension. -/\ntheorem âˆ€ {p : â„•+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime â†‘p)]\n  [inst_2 : IsCyclotomicExtension {p} â„š K], IsCyclotomicExtension {p} â„¤ { x // x âˆˆ NumberField.ringOfIntegers K } :=\n\n/-- This ideal is maximal in the collection of proper ideals. -/\ntheorem âˆ€ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] â¦ƒJ : Order.Ideal Pâ¦„,\n  I < J â†’ â†‘J = Set.univ :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/\ntheorem âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 â†” IsPrincipalIdealRing R :=\n\n/-- The ring of integers has a maximal ideal. -/\ntheorem", "choices": ["âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {K : Type u} [inst : Field K] [inst_1 : NumberField K], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ (K : Type u) [inst : Field K] [inst_1 : CharZero K], âˆƒ M, @Ideal.IsMaximal (@NumberField.ringOfIntegers K inst_1) M ", "âˆ€ {O : Type u_1} [inst : CommRing O] [inst_1 : IsDomain O] [inst_2 : IsDedekindDomain O], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], âˆƒ M, Ideal.IsMaximal M ", "forall {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], âˆƒ M, Ideal.IsMaximal M ", "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], âˆƒ M, Ideal.IsMaximal M "]}, {"stmt": "The numbers `3`, `4` and `5` form a Pythagorean triple.", "prompts": "[{\"theorem\":\n  \"âˆ€ {x y z : â„¤},\\n  PythagoreanTriple x y z â†’\\n    (PythagoreanTriple x y z â†”\\n      âˆƒ k m n,\\n        (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§\\n          (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2)))\",\n  \"isProp\": true,\n  \"docString\": \"**Formula for Pythagorean Triples** \"},\n {\"theorem\": \"PythagoreanTriple 0 0 0\",\n  \"isProp\": true,\n  \"docString\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"theorem\": \"âˆ€ {x y z : â„¤}, PythagoreanTriple x y z â†” PythagoreanTriple y x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean triples are interchangeable, i.e `x * x + y * y = y * y + x * x = z * z`.\\nThis comes from additive commutativity. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector angle form. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_1} {E : Type u_2} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector inner product form. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” InnerProductGeometry.angle x y = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, if-and-only-if vector angle form. \"},\n {\"theorem\":\n  \"âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 â†’ â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, subtracting vectors, vector angle form. \"},\n {\"theorem\":\n  \"âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-only-if vector inner product form. \"},\n {\"theorem\":\n  \"âˆ€ {x y z : â„¤} (k : â„¤), k â‰  0 â†’ (PythagoreanTriple (k * x) (k * y) (k * z) â†” PythagoreanTriple x y z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`(k*x, k*y, k*z)` is a Pythagorean triple if and only if\\n`(x, y, z)` is also a triple. \"}]\n", "prompt_cons": "/-- **Formula for Pythagorean Triples** -/\ntheorem âˆ€ {x y z : â„¤},\n  PythagoreanTriple x y z â†’\n    (PythagoreanTriple x y z â†”\n      âˆƒ k m n,\n        (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§\n          (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2))) :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem PythagoreanTriple 0 0 0 :=\n\n/-- Pythagorean triples are interchangeable, i.e `x * x + y * y = y * y + x * x = z * z`.\nThis comes from additive commutativity. -/\ntheorem âˆ€ {x y z : â„¤}, PythagoreanTriple x y z â†” PythagoreanTriple y x z :=\n\n/-- Pythagorean theorem, vector angle form. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\n  InnerProductGeometry.angle x y = Real.pi / 2 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- Pythagorean theorem, vector inner product form. -/\ntheorem âˆ€ {ð•œ : Type u_1} {E : Type u_2} [inst : IsROrC ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\n  (x y : E), inner x y = 0 â†’ â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0 :=\n\n/-- Pythagorean theorem, if-and-only-if vector angle form. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” InnerProductGeometry.angle x y = Real.pi / 2 :=\n\n/-- Pythagorean theorem, subtracting vectors, vector angle form. -/\ntheorem âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] (x y : V),\n  InnerProductGeometry.angle x y = Real.pi / 2 â†’ â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n\n/-- Pythagorean theorem, if-and-only-if vector inner product form. -/\ntheorem âˆ€ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] (x y : F),\n  â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” inner x y = 0 :=\n\n/-- `(k*x, k*y, k*z)` is a Pythagorean triple if and only if\n`(x, y, z)` is also a triple. -/\ntheorem âˆ€ {x y z : â„¤} (k : â„¤), k â‰  0 â†’ (PythagoreanTriple (k * x) (k * y) (k * z) â†” PythagoreanTriple x y z) :=\n\n/-- The numbers `3`, `4` and `5` form a Pythagorean triple. -/\ntheorem", "choices": ["PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 ", "PythagoreanTriple 3 4 5 "]}, {"stmt": "A vector space with the empty set as basis is trivial.", "prompts": "[{\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : StrongRankCondition K] {Î¹ : Type w} [inst_4 : Fintype Î¹],\\n  Basis Î¹ K V â†’ FiniteDimensional.finrank K V = Fintype.card Î¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"âˆ€ {ð•œ : Type u_2} [inst : IsROrC ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\\n  {T : E â†’â‚—[ð•œ] E},\\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ð•œ E], (â¨† (Î¼ : ð•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\\nfinite-dimensional inner product space is trivial. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k âˆ…\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is collinear. \"},\n {\"theorem\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"theorem\":\n  \"âˆ€ (k : Type u_2) {V : Type u_1} (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], vectorSpan k âˆ… = âŠ¥\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of the empty set is `âŠ¥`. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : Finite Î¹], Basis Î¹ K V â†’ FiniteDimensional K V :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Î¹ : Type w} [inst_4 : Fintype Î¹], Basis Î¹ R M â†’ Module.rank R M = â†‘(Fintype.card Î¹) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  {s : Set Î¹}, Basis (â†‘s) K V â†’ Set.Finite s â†’ FiniteDimensional K V :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional â„ E] (Î¼ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Î¼] (s : Submodule â„ E), s â‰  âŠ¤ â†’ â†‘â†‘Î¼ â†‘s = 0 :=\n\n/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {Î¹ : Type w} [inst_4 : Fintype Î¹],\n  Basis Î¹ K V â†’ FiniteDimensional.finrank K V = Fintype.card Î¹ :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem âˆ€ {ð•œ : Type u_2} [inst : IsROrC ð•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\n  {T : E â†’â‚—[ð•œ] E},\n  LinearMap.IsSymmetric T â†’ âˆ€ [inst_3 : FiniteDimensional ð•œ E], (â¨† (Î¼ : ð•œ), Module.End.eigenspace T Î¼)á—® = âŠ¥ :=\n\n/-- The empty set is collinear. -/\ntheorem âˆ€ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Collinear k âˆ… :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem âˆ€ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Mâ‚ : Type v}\n  [inst_3 : AddCommGroup Mâ‚] [inst_4 : Module R Mâ‚], (M â‰ƒâ‚—[R] Mâ‚) â†’ Module.rank R M = Module.rank R Mâ‚ :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 â†’ Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- The `vectorSpan` of the empty set is `âŠ¥`. -/\ntheorem âˆ€ (k : Type u_2) {V : Type u_1} (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], vectorSpan k âˆ… = âŠ¥ :=\n\n/-- A vector space with the empty set as basis is trivial. -/\ntheorem", "choices": ["forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis âˆ… K V â†’ V = 0 ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis âˆ… K V â†’ V â‰ƒâ‚—[K] â†¥âŠ¥ ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis âˆ… K V â†’ V â‰ƒâ‚—[K] âŠ¥ ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis âˆ… K V â†’ V â‰…â‚[K] Module.Pi K âˆ… ", "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (finset âˆ…) K V â†’ V â‰ƒâ‚—[K] K ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Î¹ : Type w}\n  [inst_3 : IsEmpty Î¹], Basis Î¹ K V â†’ V = Trivialâ‚“ ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis âˆ… K V â†’ V â‰ƒâ‚—[K] â†¥âŠ¥ ", "forall {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {Î¹ : Type w}\n  [inst_3 : IsEmpty Î¹], Basis Î¹ R M â†’ M = âŠ¥ ", "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (âˆ… : Set V) K V â†’ V â‰ƒâ‚—[K] 0 ", "âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis âˆ… K V â†’ V = {0} "]}]