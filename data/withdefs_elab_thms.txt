{Î± : Type u_2} [add_zero_class Î±] : add_zero_class (set Î±)
{Î± : Type u} [pseudo_metric_space Î±] (x y z : Î±) : has_nndist.nndist x z â‰¤ has_nndist.nndist x y + has_nndist.nndist y z
{Î± : Type u} [pseudo_emetric_space Î±] (s t : set Î±) : ennreal
(G : Type u_1) [topological_space G] [group G] : Prop
(Î± : Type u) : Type u
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
{Î± : Type u_1} (Î¹ : Type u_3) {m : measurable_space Î±} [preorder Î¹] (m' : measurable_space Î±) (hm' : m' â‰¤ m) : measure_theory.filtration Î¹ m
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†” a < b
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (a0 : 0 < a) : a * b â‰¤ 1
{Sâ‚ : Type u_1} {Sâ‚‚ : Type u_2} {Sâ‚ƒ : Type u_3} [shelf Sâ‚] [shelf Sâ‚‚] [shelf Sâ‚ƒ] (g : shelf_hom Sâ‚‚ Sâ‚ƒ) (f : shelf_hom Sâ‚ Sâ‚‚) : shelf_hom Sâ‚ Sâ‚ƒ
{R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular â†‘a
{R : Type u_1} {A : Type u_2} [has_zero R] : has_coe_t A (unitization R A)
(C : Type u) [category_theory.category C] : Prop
(Î± : Type u) [has_add Î±] : Î± â†’ Î± â†’ Prop
{R : Type u_2} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] : mul_action_with_zero R M
 : Type
(P : Type u_2) [preorder P] : Type u_2
{K : Type u} [hring : comm_ring K] : ratfunc K â†’ ratfunc K â†’ ratfunc K
{Î± : Type u} (g : set (set Î±)) : set Î± â†’ Prop
(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (n : â„•) : multilinear_map R (Î» (i : fin n), M) (tensor_algebra R M)
(arg_name : name) : name
(n : â„•) : equiv.perm (fin n)
{G : Type u_1} [add_group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), add_order_of x = p
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (s : alist Î²) : option (Î² a) Ã— alist Î²
 : setoid (Type u)
{M : Type u_1} [has_add M] (r : M â†’ M â†’ Prop) : add_con M
{Î± : Type} [random Î±] : io (stream Î±)
(V : Type u) [quiver V] (L : Sort u_2) : Sort (imax (u+1) (u+1) u_1 u_2)
{Î± : Type u_1} : ordnode Î± â†’ Î± â†’ ordnode Î± â†’ Î± â†’ ordnode Î± â†’ ordnode Î±
(Î± : Type u) [t : topological_space Î±] : Prop
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (l : list Î±) : ordnode Î±
(c : cardinal) : cardinal
{Î± : Sort u_1} [h : nonempty Î±] : inhabited Î±
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] (r : ratfunc Fq) : with_zero (multiplicative â„¤)
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a - c < b â†’ a < b + c
{Fq : Type u_1} [field Fq] [fintype Fq] : absolute_value (polynomial Fq) â„¤
{R : Type u_1} {Î¹ : Type u_4} [linear_ordered_field R] [fintype Î¹] {f : Î¹ â†’ R} (hf : f âˆˆ std_simplex R Î¹) (x : Î¹) : f x âˆˆ set.Icc 0 1
{R : Type u_1} [comm_ring R] (S : submonoid R) (P : Type u_2) [comm_ring P] [algebra R P] : Type u_2
(C : Type u) [category_theory.category C] : Prop
(Î± : Type u) [topological_space Î±] : Prop
{Î± : Type u_1} [add_monoid Î±] (s : multiset Î±) (comm : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ add_commute x y) : Î±
(E : Sort u_1) (Î± : out_param (Sort u_2)) (Î² : out_param (Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3) (imax u_1 u_3 u_2))
{Î± : Type u_1} {Î´ : Î± â†’ Type u_2} [decidable_eq Î±] (s : finset Î±) (t : Î  (a : Î±), finset (Î´ a)) : finset (Î  (a : Î±), a âˆˆ s â†’ Î´ a)
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] : wseq Î± â†’ wseq Î±
{Î± : Type u_1} [linear_order Î±] (pred : Î± â†’ Î±) (hle_pred_iff : âˆ€ {a b : Î±}, a â‰¤ pred b â†” a < b) : pred_order Î±
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (a : Î±) : option Î±
(R : Type u) (X : Type v) [comm_ring R] : free_non_unital_non_assoc_algebra R X â†’ free_non_unital_non_assoc_algebra R X â†’ Prop
{G : Type w} [topological_space G] [has_neg G] [has_continuous_neg G] {Î¹ : Type u_1} : has_continuous_neg (Î¹ â†’ G)
{m n : â„•} (f : fin2 m â†’ fin2 n) (k : â„•) : fin2 (m + k) â†’ fin2 (n + k)
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.fst)
(Î“â‚€ : Type u_1) [linear_ordered_comm_group_with_zero Î“â‚€] : directed ge (Î» (Î³â‚€ : Î“â‚€Ë£), filter.principal {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
{R : Type u_1} [ring R] : R â†’ power_series R â†’ power_series R
{Î± : Type u} : computation Î± â†’ Î±
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type (max u v)
(n : â„•) : surreal
{G : Type u_1} [has_mul G] : G â†’ G â†’ G
{n : â„•} (x y : bitvec n) : bitvec n
{Î± : Type} {dsâ‚ dsâ‚‚ : list â„•} [s : has_mul Î±] (x : holor Î± dsâ‚) (y : holor Î± dsâ‚‚) : holor Î± (dsâ‚ ++ dsâ‚‚)
{Î± : Type u} [monoid Î±] {r : Î±} (hr : invertible r) (s : Î±) (hs : s = r) : invertible s
(p : â„•) [fact (nat.prime p)] (a : â„¤) : zmod.legendre_sym p a = 0 â†” â†‘a = 0
(Î± : Type u) [has_le Î±] : Type u
{Î± : Type u} : computation Î± â†’ â„• â†’ option Î±
(Î± : Type u) : Type u
{Î± : Type u_3} {Î² : Type u_4} [has_inf Î±] [has_top Î±] [has_inf Î²] [has_top Î²] (f : inf_top_hom Î± Î²) : top_hom Î± Î²
(R : Type u_1) {Î± : Type u_2} (G : simple_graph Î±) [has_zero R] [has_one R] : matrix Î± (sym2 Î±) R
(Fq F : Type) [field Fq] [field F] [algebra (ratfunc Fq) F] : Prop
{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : 0 â‰¤ metric.Hausdorff_dist s t
{K : Type u} [field K] (s : subfield K) {l : list K} : (âˆ€ (x : K), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop
{R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a â†” a â‰  0
{G : Type u_1} [add_group G] : has_bot (add_subgroup G)
{m : Type u_1 â†’ Type u_2} [monad m] {Î± : Sort u_3} {Î² Î³ : Type u_1} (f : Î± â†’ m Î²) (g : Î² â†’ m Î³) (x : Î±) : m Î³
{Î± : Type u} (x : Î±) : free_comm_ring Î±
{a b : â„•} (h : a = b) : bitvec a â†’ bitvec b
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : Type u_2
{Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] (s : finset Î±) (f : Î± â†’ Î²) : Î²
(Î± : Type u_1) (Î¹ : Type u_2) : Type (max u_1 u_2)
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (s : subsemigroup M) (t : subsemigroup N) : subsemigroup (M Ã— N)
(t : Type u â†’ Type u â†’ Type u) : Type (u+1)
{Î± : Type u_1} {Î² : Type u_2} (t : Î±) (ts : list Î±) (r : list Î²) : list Î± â†’ (list Î± â†’ Î²) â†’ list Î± Ã— list Î²
(Î± : Type u_1) [partial_order Î±] : PartialOrder
{m : Type u_2} {n : Type u_3} {Î± : Type v} (M : matrix m n Î±) : matrix n m Î±
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [uniform_space Î±] [uniform_space Î²] [uniform_space Î³] (f : Î± â†’ Î² â†’ Î³) : Prop
{Î± : Type u_2} [add_zero_class Î±] : add_zero_class (filter Î±)
{Î“ : Type u_1} {R : Type u_2} [partial_order Î“] [has_zero R] (a : Î“) : zero_hom R (hahn_series Î“ R)
(ð•œ : Type u_1) (A : Type u_2) [comm_semiring ð•œ] [topological_space ð•œ] [has_continuous_add ð•œ] [has_continuous_const_smul ð•œ ð•œ] [non_unital_non_assoc_semiring A] [topological_space A] [module ð•œ A] : set (weak_dual ð•œ A)
{Î± : Type u_1} [has_mul Î±] [has_one Î±] : list Î± â†’ Î±
 : Type
(C : Type u) [category_theory.category C] : Prop
{r p : nnreal} : â†‘(r - p) = â†‘r - â†‘p
{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_descending_central_series H) (n : â„•) : lower_central_series G n â‰¤ H n
{R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A] : comm_semiring (submodule R A)
{Î± : Type u_1} {Î² : Type u_2} [preorder Î²] (f : Î± â†’ Î²) : preorder Î±
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : regular_expression Î± â†’ regular_expression Î²
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) : Prop
(M : Type u_1) [mul_one_class M] (c : con M) : submonoid (M Ã— M)
(L : Type v) (M : Type w) [lie_ring L] [add_comm_group M] : Type (max v w)
(l : list â„•) (n : â„•) : finset â„•
{Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : antitone f) (n : â„¤) {x : Î±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : â„¤) : f a â‰  x
{Î± : Type u_1} [Î² : semi_normed_ring Î±] : non_unital_semi_normed_ring Î±
{Î± : Type u_1} [measurable_space Î±] {f : â„• â†’ Î± â†’ ennreal} {g : Î± â†’ ennreal} (hf : âˆ€ (i : â„•), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J â†’ C} (B : category_theory.limits.bicone F) : Type (max u v)
{Î± : Type u} (f : filter (filter Î±)) : filter Î±
(R : Type u_1) [comm_ring R] [local_ring R] (q : â„•) [char_R_q : char_p R q] : q = 0 âˆ¨ is_prime_pow q
{F : Type} [comm_semiring F] (q : â„•) (f g : polynomial F) : Prop
 : Type (u+1)
{Î± : Type u} {Î² : Type v} (f : Î² â†’ Î± âŠ• Î²) (b : Î²) : computation Î±
(Î± : Type u_1) : computation Î±
{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop
(R : Type u_1) (M : Type u_2) [ordered_semiring R] [ordered_add_comm_monoid M] [smul_with_zero R M] : Prop
{Î± : Type u_1} [decidable_eq Î±] (l : list Î±) (x : Î±) (h : x âˆˆ l) : Î±
{G : Type u_1} [has_add G] : G â†’ G â†’ G
(n : â„•) (t : Type u_1) : typevec n
{G : Type u_1} [group G] (H : subgroup G) {x : G} : x âˆˆ H â†’ xâ»Â¹ âˆˆ H
(c : cardinal) : Prop
 : Type
(C : Type u) [category_theory.category C] [category_theory.limits.has_images C] : Prop
(Î± : Type u_1) [preorder Î±] (f : closure_operator Î±) : Î± â†’ Î±
(M : Type u_1) [add_zero_class M] (c : add_con M) : add_submonoid (M Ã— M)
(R : Type u_1) [comm_semiring R] (X : Type u_2) : Type (max u_1 u_2)
(M : Type u_1) [has_add M] : galois_insertion add_subsemigroup.closure coe
 : real.cos (real.pi / 6) ^ 2 = 3 / 4
{G : Type u_1} [group G] : has_bot (subgroup G)
{G : Type u_1} [add_group G] (k : set G) : add_subgroup G
(X : Top) : algebraic_geometry.SheafedSpace (category_theory.discrete punit)
{R : Type u_1} [comm_ring R] {A : Type u_2} [comm_ring A] [algebra R A] : has_bracket (derivation R A A) (derivation R A A)
{Î± : Type u_1} [preorder Î±] [decidable_rel has_lt.lt] (l : list Î±) : with_top Î±
(p : char â†’ Prop) [decidable_pred p] : parser char
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
{R : Type uâ‚} [semiring R] (r : R â†’ R â†’ Prop) : Type uâ‚
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [normalization_monoid Î±] : associates Î± â†’ Î±
(Mâ‚€ : Type u_4) : Type u_4
{C : Type uâ‚} [category_theory.category C] : category_theory.faithful category_theory.yoneda
{F : Type} [comm_semiring F] {q : â„•} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : â„•
 : Type (u_1+1)
(Î± : Type u_1) [preorder Î±] : lower_adjoint id
 : Type (max (u+1) u (v+1))
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (b : Î²) : function.injective (Î» (a : Î±), f a b)
{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.is_periodic_pt f 0 x
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] : list (sigma Î²) â†’ list (sigma Î²) â†’ list (sigma Î²)
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (s : finmap Î²) : finmap Î²
{C : Type u} [category_theory.category C] (X : C) : Type (max u v)
{Î± : Type u} (t : ordnode Î±) : list Î±
 : parser unit
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (s : set L) (hs : s = â†‘S) : intermediate_field K L
{n : â„•} (F : typevec (n + 1) â†’ Type u_1) (Î± : Type u) (Î² : typevec n) : Type u_1
{R : Type u_1} [has_add R] (c : R) : Prop
(Sâ‚€ : Type u_4) : Type u_4
{F : Type u â†’ Type u} [functor F] {Î± : Type u} (x : F Î±) : set Î±
{E : Type u_2} [non_unital_normed_ring E] [star_ring E] [cstar_ring E] : normed_star_group E
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {f : Î± â†’ Î²} : isometry f â†” âˆ€ (x y : Î±), has_dist.dist (f x) (f y) = has_dist.dist x y
{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) (y : Î²) : âˆƒ (x : Î±), f x â‰  y
 : unit
(R : Type u) (A : Type w) [comm_semiring R] [semiring A] [algebra R A] (n : â„•) [inv : invertible â†‘n] : invertible â†‘n
(n : â„•) : â„•
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) (x : X) (hsat : jordan_holder_lattice.is_maximal s.top x) : composition_series X
{Î± : Type u} : ordnode Î± â†’ â„• â†’ ordnode Î±
{M : Type u_5} [nontrivial M] [hM : comm_monoid_with_zero M] (h : âˆ€ (a : M), is_unit a âˆ¨ a = 0) : comm_group_with_zero M
{M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)
(Î± : Type u_6) [topological_space Î±] [h : measurable_space Î±] : Prop
(X : algebraic_geometry.LocallyRingedSpace) : algebraic_geometry.RingedSpace
 : â„• â†’ option â„•
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : Type v
(Î± : Type u) [group Î±] : category_theory.groupoid (category_theory.single_obj Î±)
{M : Type u_1} [has_mul M] (S : subsemigroup M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{Î± : Type u_1} [has_zero Î±] [has_one Î±] [has_add Î±] [has_neg Î±] : â„¤ â†’ Î±
{n : â„•} (P : mvpfunctor n) (Î± : typevec n) : Type u
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (a : Î±) : principal_seg (subrel r {b : Î± | r b a}) r
 : list bool â†’ bool
 : â„• â†’ enat
 : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}
{R : Type u_1} [comm_ring R] [topological_space R] {M : submonoid R} : ring_topology (localization M)
(M : Type u_9) (N : Type u_10) [has_one M] [has_one N] : Type (max u_10 u_9)
{p : â„•} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : â„•} (hn : n â‰  0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)
(J : Type uâ‚) [category_theory.category J] : Prop
 : nat.arithmetic_function â„•
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (b : Î² a) (s : finmap Î²) : finmap Î²
{n : â„•} : fin2 n â†’ fin2 n â†’ fin2 n
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
{b : â„•} {l : list â„•} (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length
 : â„• â†’ â„¤
(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C
{Î± : Type u_1} {p : Î± â†’ Prop} [encodable Î±] [decidable_pred p] (h : âˆƒ (x : Î±), p x) : {a // p a}
{K : Type u} [field K] (s : subfield K) {x : K} : x âˆˆ s â†’ -x âˆˆ s
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] (a b : Î±) : multiset Î±
(Î± : Type u_1) [uniform_space Î±] : has_coe_t Î± (uniform_space.completion Î±)
{Î± : Type u_1} {Î² : Type u_2} [encodable Î±] [inhabited Î±] {r : Î² â†’ Î² â†’ Prop} (f : Î± â†’ Î²) (hf : directed r f) : â„• â†’ Î±
(S : Type u_4) (M : out_param (Type u_5)) [add_zero_class M] [set_like S M] : Type
(R : Type u_1) [ring R] : algebra_map â„¤ R = int.cast_ring_hom R
 : Type
{n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3
(ð•œ : Type u_1) (E : Type u_2) [is_R_or_C ð•œ] [inner_product_space ð•œ E] : galois_connection submodule.orthogonal submodule.orthogonal
(L : first_order.language) {M : Type w} [L.Structure M] (A : set M) (Î± : Type u_1) : Type (max u_1 w)
(p : Set â†’ Prop) (A : Class) : Prop
(Fq F : Type) [field Fq] [field F] [algebra (polynomial Fq) F] : subalgebra (polynomial Fq) F
(Î± : Type u_3) [has_inf Î±] : inf_hom Î± Î±
 : ennreal â†’ nnreal
{C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_colimits (algebraic_geometry.PresheafedSpace C)
(C : Type u) : Type u
{C : Type u} [category_theory.category C] (J : C) : Prop
{X : Type u} [topological_space X] (xâ‚€ xâ‚ : X) : setoid (path xâ‚€ xâ‚)
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : â„•) : lie_ideal R L â†’ lie_ideal R L
(C : Type u) : Type u
{Î± : Type u} {Î² : Type v} : Î± âŠ• Î² â†’ option Î²
{Î± : Type u_1} {Î² : Type u_2} [mul_one_class Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_monoid_hom f) : is_monoid_hom (Î» (a : Î±), (f a)â»Â¹)
{Î± : Type u_1} [primcodable Î±] (p : Î± â†’ Prop) : Prop
{C : Sort u_1} : pempty â†’ C
{Î± : Type u_1} {p : multiset Î± â†’ Sort u_2} (s : multiset Î±) : (Î  (s : multiset Î±), (Î  (t : multiset Î±), t < s â†’ p t) â†’ p s) â†’ p s
{Î± : Type u_1} : has_le (subtype setoid.is_partition)
(R : Type u) [semiring R] (q : â„•) [hp : char_p R 0] [hq : exp_char R q] : q = 1
 : Type
{X : Type u_1} [topological_space X] (s : set X) : set X
{R : Type u} [semiring R] (p : polynomial R) : R
{R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P) : fractional_ideal S P
{Î¹ : Type u_1} (A : Î¹ â†’ Type u_2) [add_monoid Î¹] [graded_monoid.gmonoid A] : monoid (A 0)
{R : Type u} [comm_ring R] : has_quotient R (ideal R)
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : a / c â‰¤ b / d â†’ (a * d - b * c) / (c * d) â‰¤ 0
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] [fact (even (fintype.card n))] : has_neg (matrix.special_linear_group n R)
{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : canonically_ordered_add_monoid (submodule R M)
{Î± : Type u} {Î² : Type v} (l : lazy_list Î±) (f : Î± â†’ Î²) : lazy_list Î²
(S : Type u_3) (G : Type u_4) [sub_neg_monoid G] [set_like S G] : Type
(L : first_order.language) (M : Type w) [L.Structure M] : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : Type
(M : Type u) [topological_space M] [has_mul M] : Prop
(Î± : Type u) [topological_space Î±] : Type u
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} (Î³ : Type u_3) (fÎ³ : (Î£ (a : Î±), Î² a â†’ Î³) â†’ Î³) : W_type Î² â†’ Î³
{A : Type v} [ring A] : lie_ring A
{Î± : Type u_1} {Î² : Type u_2} (f : part Î±) (g : Î± â†’ part Î²) : part Î²
(T : Type u) [category_theory.category T] : Type (max u v)
(Î± : Type u_2) : Type u_2
{M : Type u_1} [has_mul M] (p : M) : Prop
(L : first_order.language) : Prop
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
 : Type
(Î± : Type u) [add_group Î±] : Prop
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : generalized_continued_fraction.int_fract_pair K
{Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ a + b â†” a âˆ£ b
{p : Prop} (a : erased p) : p
{R : Type u_1} [comm_monoid R] : star_semigroup R
{K : Type u_1} [division_ring K] (s : seq (generalized_continued_fraction.pair K)) (n : â„•) : seq (generalized_continued_fraction.pair K)
{K : Type u} [field K] (S : subfield K) (s : set K) (hs : s = â†‘S) : subfield K
 : Type
(Î± : Type u) : Type u
{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹
{E : Type u_1} (c : E) : Type
{Î± : Type u_1} [partial_order Î±] : subsingleton (pred_order Î±)
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (Ï : representation k G V) (g : G) : k
(x : â„¤) : â†‘(x.nat_abs) ^ 2 = x ^ 2
{Î± : Type u_1} [decidable_eq Î±] (s : finset Î±) : finset (equiv.perm Î±)
(E : Type u_6) [add_comm_group E] [has_norm E] : Prop
 : Type
{Î± : Type u} {Î² : Type v} (m : Î± â†’ Î²) (f : filter Î±) : filter Î²
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : set M
{L : first_order.language} (T : L.Theory) : Type (max u v (w+1))
(R : Type u_1) [comm_ring R] [is_domain R] [decidable_eq R] [fintype R] : field R
{J : Type uâ‚} [category_theory.category J] (jâ‚ jâ‚‚ : J) : Prop
 : cardinal â†’ ordinal
 : real.sin (real.pi / 6) = 1 / 2
{M : Type u_4} [topological_space M] [monoid M] [has_continuous_mul M] (s : submonoid M) : submonoid M
{Î± : Type u_1} [topological_space Î±] (B : set (topological_space.opens Î±)) : Prop
{Î± : Type u} [topological_space Î±] (s : set Î±) : Prop
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (x y : M) : Prop
(Î± : Type u_3) [uniform_space Î±] [add_group Î±] : Prop
(M : Type u) [has_mul M] : Magma
{Î± : Type u_1} {Î³ : Type u_3} [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î³] [measurable_space Î³] [borel_space Î³] {f : Î± â†’ Î³} (hf : continuous f) : measurable f
(Î± : Type u_2) [preorder Î±] : Type u_2
(N : Type u_2) [add_monoid N] : Prop
(C : Type u) : Type u
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.maps_to f (function.fixed_points (g âˆ˜ f)) (function.fixed_points (f âˆ˜ g))
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C
{R : Type u} {Î“â‚€ : Type v} [ring R] [linear_ordered_comm_group_with_zero Î“â‚€] (v : valuation R Î“â‚€) : subring R
{Î± : Type u_6} : mul_action (function.End Î±) Î±
(n : â„•) [has_zero (fin n)] : Type
{Î± : Type u_1} [add_semigroup Î±] [partial_order Î±] [contravariant_class Î± Î± (function.swap has_add.add) has_le.le] : add_right_cancel_semigroup Î±
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < -a + c â†’ a + b < c
 : num â†’ num â†’ num
{L : first_order.language} {M : Type w} [nonempty M] [L.Structure M] : L.skolemâ‚.Structure M
(G : Type u_1) [add_group G] : set G
{M : Type u_1} [add_monoid M] (S : add_submonoid M) : add_submonoid M
(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : intermediate_field F E
 : two_pointing Prop
{Î± : Type u_1} {p : Î± â†’ Prop} [encodable Î±] [decidable_pred p] (h : âˆƒ (x : Î±), p x) : Î±
{Î± : Type u_1} [normed_division_ring Î±] {a : Î±} (ha : a â‰  0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
{Î± : Type u_1} [has_mul Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {b c : Î±} (bc : b < c) (a : Î±) : a * b < a * c
(Î± : Sort u_1) [h : nonempty Î±] : Î±
(G : pgame) : Prop
{Î± : Type u} [uniform_space Î±] {f : filter Î±} (hf : cauchy f) {U : â„• â†’ set (Î± Ã— Î±)} (U_mem : âˆ€ (n : â„•), U n âˆˆ uniformity Î±) (n : â„•) : set Î±
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (s : finmap Î²) : option (Î² a) Ã— finmap Î²
{Î± : Type u} [preorder Î±] (a : Î±) : a â‰¤ a
{G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G
{Î± : Type u} {Î² : Type v} (f : ultrafilter Î±) (m : Î± â†’ ultrafilter Î²) : ultrafilter Î²
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Î± : Type u_1} (l : ordnode Î±) (x : Î±) (r : ordnode Î±) : ordnode Î±
 : pos_num â†’ pos_num
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î² â†’ Î²) (H : left_commutative f) (b : Î²) (s : multiset Î±) : Î²
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] : ordnode Î± â†’ ordnode Î±
{n : Type u_3} {Î± : Type v} [add_monoid Î±] [star_add_monoid Î±] : star_add_monoid (matrix n n Î±)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.split_mono category_theory.limits.coprod.inl
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X â†” is_simple_order (category_theory.subobject X)
(Î² : Type w) (C : Type u) : Type (max w u)
(Î± : Type u_1) [partial_order Î±] : circular_partial_order Î±
(Î± : Type u) : Type u
{R : Type u} [non_assoc_semiring R] (S : subsemiring R) (s : set R) (hs : s = â†‘S) : subsemiring R
(attr_name : name) : name
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} : monotone (set.image f)
(V : Type u_1) [quiver V] : prefunctor V V
(L : first_order.language) : Type v
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] (X : C) : Type (max u v)
{Î¹ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_one R] [has_zero Î¹] (A : Î¹ â†’ S) : Prop
{k : Type u_1} [ring k] {V : Type u_2} {P : Type u_3} [add_comm_group V] [module k V] [add_torsor V P] : add_action V (affine_subspace k P)
(R : Type u_1) [ring R] : algebra â„¤ R
(Î± : Type u) : Type u
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) (s : set Î±) : Prop
{Mâ‚€ : Type u_1} [monoid_with_zero Mâ‚€] : Mâ‚€ â†’ Mâ‚€
 : filter.tendsto (Î» (x : â„), real.exp (-x)) filter.at_top (nhds 0)
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom A B
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) : graded_algebra (clifford_algebra.even_odd Q)
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f g : add_hom M N) : add_subsemigroup M
{Î± : Type u_1} [decidable_eq Î±] (xs : list Î±) (x default : Î±) : Î±
(Î± : Type u) [pseudo_metric_space Î±] : Type u
{Î± : Type u} [preorder Î±] {x y : Î±} (h : x = y) : y â‰¤ x
{n : â„•} {F : typevec n â†’ Type v} [mvfunctor F] {Î± : typevec n} (x : F Î±) (i : fin2 n) : set (Î± i)
(G : Type u) [add_monoid G] : Prop
(Î± : Type u_1) {Î¹ : Type u_2} (i : Î¹) : Type u_1
{ð•œ : Type u_1} {E : Type u_3} [normed_field ð•œ] [add_comm_group E] [module ð•œ E] {A : set E} (hA : balanced ð•œ A) : absorbs ð•œ A A
{Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} (hf : function.bijective f) (b : Î²) : âˆƒ! (a : Î±), f a = b
(Î± : Type u) : Type u
{G : Type u_1} [group G] {s : set G} (h : is_subgroup s) : subgroup G
{Î± : Type u} [preorder Î±] {a b : Î±} : a = b â†’ a â‰¤ b
 : Type v
{x y z : â„¤} (h : pythagorean_triple x y z) (k : â„¤) : pythagorean_triple (k * x) (k * y) (k * z)
{Î± : Type} (a : Î±) (v : â„• â†’ Î±) : â„• â†’ Î±
{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {f : Î¹ â†’ Î±} (H : bdd_above (set.range f)) (c : Î¹) : f c â‰¤ supr f
{Î± : Type u_1} [has_one Î±] [has_add Î±] : pos_num â†’ Î±
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} (f : (Î  (a : Î±), part (Î² a)) â†’ Î  (a : Î±), part (Î² a)) : stream (Î  (a : Î±), part (Î² a))
(R : Type u) [non_unital_semiring R] : Type u
{V : Type u} (G : simple_graph V) : Type u
{B : Type u} [quiver B] {a b : B} : quiver.path a b â†’ category_theory.free_bicategory.hom a b
{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a : Î±} : is_max a â†’ order.succ a = a
 : Type
 : Type
{Î± : Type u_1} [linear_ordered_field Î±] (f : cau_seq Î± has_abs.abs) : Prop
(H : Type u) [topological_space H] : Type u
{n : â„•} {Î± : Type u_1} : vector Î± n â†’ array n Î±
{Î± : Type u_1} [linear_ordered_ring Î±] [floor_ring Î±] (a : Î±) : Î±
 : category_theory.reflective CompHaus_to_Top
(n d : pos_num) : num
(G : Type u) [monoid G] : â„•
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (s : finset Î±) : finset (subtype p)
 : Type
 : Type
(R : Type u_1) (Î· : Type u_2) [semiring R] [fintype Î·] : basis Î· R (Î· â†’ R)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : â†‘a = 0 â†” a.hom = 0
{Î± : Type u} [pseudo_metric_space Î±] : has_nndist Î±
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î±] [preorder Î²] [bounded_order Î²] (gi : galois_coinsertion l u) : bounded_order Î±
{Î± : Type u} : complete_lattice (topological_space Î±)
(G : Type u_1) [add_comm_group G] : add_subgroup G
{a b c : Prop} : a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c
{Î± : Type u_1} (s : cycle Î±) : Prop
{Î± : Type u_1} {P : Î± â†’ Prop} : antitone (Î» (s : set Î±), âˆ€ (x : Î±), x âˆˆ s â†’ P x)
{Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a < b â†’ a < c
{M : Type u_1} [monoid M] (a : M) : Prop
{n : â„•} (i : fin (2 ^ n)) : bitvec n
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] : list (sigma Î²) â†’ list (sigma Î²)
{a b c : Prop} : (a âˆ¨ b) âˆ§ c â†” a âˆ§ c âˆ¨ b âˆ§ c
{R : Type u_1} [has_mul R] (c : R) : Prop
{G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a < b + c â†’ a - c < b
(R : Type u_1) [comm_ring R] [is_domain R] : Prop
{Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±) (H : âˆ€ (x : Î±), x âˆˆ s) : fintype Î±
{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) (n : â„•) : K
{Î± : Type u_1} {Î² : Type u_2} (f : â„• â†’ Î± â†’ Î² â†’ Î²) : â„• â†’ Î² â†’ list Î± â†’ Î²
(n m : â„•) : â„•
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space (Î± Ã— Î²)] : continuous continuous_map.curry
(Î± : Type u) : Type u
{Î± : Type u_2} {Î² : Type u_3} [decidable_eq Î²] [add_monoid Î±] [add_action Î± Î²] : add_action Î± (finset Î²)
{Î± : Type u_1} [fintype Î±] (p : Î± â†’ Prop) [decidable_pred p] (hp : âˆƒ! (a : Î±), p a) : Î±
{Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±) : finset Î±
{M : Type u_1} [mul_one_class M] : has_top (submonoid M)
{V : Type u} (G : simple_graph V) (v : V) : set (sym2 V)
{M : Type u_1} [mul_one_class M] (s : set M) : submonoid M
(R : Type u) [comm_ring R] : Type u
{Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.mul_pos_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b â‰¤ 1
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ option Î²) (s : multiset Î±) : multiset Î²
{Î± : Type u} (s : wseq Î±) (p : Î± â†’ bool) : computation bool
{Î± : Type u} {Î² : Type v} (f : â„• â†’ Î± â†’ Î² â†’ Î²) (start : â„•) (b : Î²) (as : list Î±) : Î²
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : has_zero (lie_subalgebra R L)
{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above t) : bdd_above (s âˆ© t)
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [is_well_order Î± r] (a : Î±) : ordinal
{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K
 : pos_num â†’ num
 : Type (u+1)
{Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_preconnected s) : is_preconnected (closure s)
{Î± : Type u_1} (t : Î±) : list Î± â†’ list (list Î±)
(n : â„•) (a : zmod n) : zmod n â†’ zmod n
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) [is_symm Î± r] : is_symm_op Î± Prop r
{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ a = b
(Î² : Type u_2) [pseudo_metric_space Î²] [add_monoid Î²] [has_lipschitz_add Î²] : nnreal
{R : Type u} [ring R] (s : set R) : set R
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M) : add_submonoid M
{m : Type u_2} {n : Type u_3} {Î± : Type v} [decidable_eq m] (M : matrix m n Î±) (i : m) (b : n â†’ Î±) : matrix m n Î±
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [fintype K] [finite_dimensional K V] : fintype V
{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : C
{Î± : Type u} : dense_embedding has_pure.pure
{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K
{k : Type u_1} [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) (h : â†‘(s.card) â‰  0) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
(Î± : Type u_8) (Î² : Type u_9) [has_Sup Î±] [has_Sup Î²] : Type (max u_8 u_9)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : complete_lattice (lie_subalgebra R L)
{Î± : Type u_1} [decidable_eq Î±] {Î´ : Î± â†’ Type u_2} (m : multiset Î±) (t : Î  (a : Î±), multiset (Î´ a)) : multiset (Î  (a : Î±), a âˆˆ m â†’ Î´ a)
{n : â„•} (c : composition n) (j : fin n) : fin c.length
(x y : ereal) : ereal
 : bool â†’ bool
(G : Type u_1) [add_group G] [topological_space G] : Type u_1
(Î± : Type u_1) : Type u_1
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (f : Î± â†’ Î±) (x : Î±) : ordnode Î± â†’ ordnode Î±
(K : Type v) (L : Type w) [field K] [field L] [algebra K L] (f : polynomial K) : Prop
(n : â„•) (s : set â„•) : Prop
{Î± : Type u_1} {Î² : Type u_2} : option Î± â†’ Î² â†’ (Î± â†’ Î²) â†’ Î²
 : matrix (fin 2) (fin 2) â„¤
(Î± : Type u_4) : Type u_4
{G : Type u} [add_group G] (B : add_group_filter_basis G) : G â†’ filter G
{Î± : Type u_1} [topological_space Î±] (s : topological_space.positive_compacts Î±) : topological_space.nonempty_compacts Î±
(Î± : Type u_3) [topological_space Î±] : Prop
(F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] : Prop
{Î± : Type u} {Î² : Type v} [semigroup Î²] (f : Î± â†’ Î²) : Î± â†’ list Î± â†’ Î²
{Î± : Type u_1} [encodable Î±] : list Î± â†’ â„•
{n : â„•} {Î± : fin n â†’ Type u} (a : d_array n Î±) (i : fin n) : Î± i
{Î± : Type u_1} : lists Î± â†’ list (lists Î±)
(C : Type u) [category_theory.category C] : Prop
{Î± : Type u} {Î² : Type v} {p : Î± â†’ Prop} (f : Î  (a : Î±), p a â†’ Î²) (l : list Î±) : (âˆ€ (a : Î±), a âˆˆ l â†’ p a) â†’ list Î²
{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b â‰¤ a
{M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (â†‘u + a) â†” is_add_unit a
{Î± : Sort u} (f : Î± â†’ Î±) (h : function.involutive f) : equiv.perm Î±
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
 : pgame â†’ pgame
(a b : simplex_category) : Type
(X Y : Type u) : category_theory.limits.binary_fan X Y
{Î± : Type u_1} (l : filter Î±) (Î² : Type u_2) : setoid (Î± â†’ Î²)
(R : Type u_1) [comm_ring R] [with_ideal R] (M : Type u_2) [add_comm_group M] [module R M] : topological_space M
{R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) â†” is_regular a âˆ§ is_regular b
{Î± : Type u_1} [has_sub Î±] [has_zero Î±] (a b : with_top Î±) : with_top Î±
{Î± : Type u} : lazy_list Î± â†’ lazy_list Î±
(Î± : Type u) [uniform_space Î±] : Prop
{Î± : Type u_1} {p : Prop} {q : Î± â†’ Prop} : p â†’ âˆ€ (x : Î±), q x â†” âˆ€ (x : Î±), p â†’ q x
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A B : matrix n n Î±) (h : B.mul A = 1) : invertible A.det
(Î± : Type u) [s : lattice Î±] [add_comm_group Î±] [covariant_class Î± Î± has_add.add has_le.le] : distrib_lattice Î±
(k : Type uâ‚) (G : Type uâ‚‚) [semiring k] : Type (max uâ‚ uâ‚‚)
(R : Type u) [ring R] : Prop
{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} (hab : a â‰  b) : closure (set.Ico a b) = set.Icc a b
(a b : num) : num
{Î±â‚ : Type u_1} {Î²â‚ : Type u_2} [decidable_eq Î±â‚] (a : Î±â‚) (e : equiv.perm Î²â‚) : equiv.perm (Î±â‚ Ã— Î²â‚)
{Î± : Type u_2} [add_monoid Î±] (s : set Î±) : Prop
{G : Type u_3} [add_group G] (P : add_subgroup G) : Prop
{Î± : Type u} [topological_space Î±] {s : set Î±} : is_closed (frontier s)
(G : pgame) : Prop
{m : Type u â†’ Type u} [applicative m] {Î± Î² : Type u} (F : Î± â†’ m Î²) (x : free_add_semigroup Î±) : m (free_add_semigroup Î²)
{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) (r : R) : A
{Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±) : dite P (Î» (h : P), a) (Î» (h : Â¬P), b) = ite P a b
{Î± : Type u_2} [decidable_eq Î±] [has_sub Î±] : has_sub (finset Î±)
{Î± : Type u} {line col : â„•} (f : thunk Î±) : Î±
(Î± : Type u_5) (Î² : Type u_6) [non_unital_non_assoc_semiring Î±] [non_unital_non_assoc_semiring Î²] : Type (max u_5 u_6)
(Î± : Type u_1) : Type u_1
(C : Type uâ‚) [category_theory.category C] (D : Type uâ‚) [category_theory.category D] : category_theory.category (C âŠ• D)
{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.bij_on f (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
{R : Type u} [semiring R] (p : polynomial R) : polynomial R
{Î± : Type u} (a : Î±) : seq Î± â†’ seq Î±
 : Type (u+1)
{Î± : Type u} [uniform_space Î±] {f : filter Î±} (hf : cauchy f) {U : â„• â†’ set (Î± Ã— Î±)} (U_mem : âˆ€ (n : â„•), U n âˆˆ uniformity Î±) (n : â„•) : Î±
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Î± : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b â‰  0) : function.injective (Î» (a : Î±), finsupp.single a b)
{Î± : Type u} (P : Î± â†’ Prop) : ordnode Î± â†’ Prop
{Î± : Type u_1} {Î² : Type u_2} [semilattice_sup Î±] [order_bot Î±] (s : finset Î²) (f : Î² â†’ Î±) : Î±
{Î± : Type u_1} {Î² : Type u_2} [encodable Î±] (f : Î² â†’ Î±) (finv : Î± â†’ option Î²) (linv : âˆ€ (b : Î²), finv (f b) = option.some b) : encodable Î²
{Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î² â†’ Prop) (s : finset Î±) (b : Î²) [Î  (a : Î±), decidable (r a b)] : finset Î±
{Î± : Type u_1} {ð’œ : finset (finset Î±)} {r : â„•} : ð’œ.slice r âŠ† ð’œ
{Î± : Type u} [t : topological_space Î±] (s : set Î±) : Prop
{Î± : Type u_2} {Î² : Type u_3} {r : Î± â†’ Î² â†’ Prop} (c : concept Î± Î² r) : concept Î² Î± (function.swap r)
(Î± : Type u_1) : Type u_1
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
(E : Type u_6) : Type u_6
(R : Type u) [semiring R] : â„• â†’ Prop
{R : Type u} [ring R] (self : subring R) : add_subgroup R
(V : Type u) [quiver V] : Type u
{Î± : Type u_1} (l : ordnode Î±) (x : Î±) (m : ordnode Î±) (y : Î±) (r : ordnode Î±) : ordnode Î±
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) â†’ same_ray R x y
{Î± : Type u_1} (g : generalized_continued_fraction Î±) [has_one Î±] : Prop
{Î± : Type u_1} {Î² : Type u_2} [add_comm_group Î±] [uniform_space Î±] [complete_space Î±] {f : Î² â†’ Î±} : summable f â†” cauchy_seq (Î» (s : finset Î²), s.sum (Î» (b : Î²), f b))
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Type v
 : Type
{Î± : Type u} [linear_order Î±] (x y : Î±) {P : Sort u_1} (hâ‚ : x < y â†’ P) (hâ‚‚ : x = y â†’ P) (hâ‚ƒ : y < x â†’ P) : P
{a b c : Prop} : a âˆ¨ b âˆ§ c â†” (a âˆ¨ b) âˆ§ (a âˆ¨ c)
(n : â„•) : â„•
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_well_order Î± r] : linear_order Î±
{Î± : Type u_1} [preorder Î±] (s : ordset Î±) : â„•
{Î± : Type u_1} : list (option Î±) â†’ option (list Î±)
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Î± : Type u_1} [add_group Î±] : has_quotient Î± (add_subgroup Î±)
{Î± : Type u_1} [topological_space Î±] (s : set Î±) : filter Î±
{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] : category_theory.preadditive C
(Î± : Type u_4) : Type u_4
(Î± : Type u_1) [fin_enum Î±] : list Î±
{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a
{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : has_involutive_neg (submodule R M)
{M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {câ‚ câ‚‚ : Î± Ã— Î²} (p : path.homotopic.quotient câ‚ câ‚‚) : path.homotopic.quotient câ‚.fst câ‚‚.fst
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} : metric.inf_dist x s â‰¤ metric.inf_dist y s + has_dist.dist x y
{R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b
(R : Type u_1) [semiring R] : Type u_1
{Î± : Type u_2} [topological_space Î±] {g : Î± â†’ Î±} (h : continuous g) : flow â„• Î±
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V â†” module.finite K V
(C : Type u) [category_theory.category C] : Type (max u v)
{Gâ‚ : Type u_2} {Gâ‚‚ : Type u_3} [group Gâ‚] [group Gâ‚‚] [group.is_nilpotent Gâ‚] [group.is_nilpotent Gâ‚‚] : group.is_nilpotent (Gâ‚ Ã— Gâ‚‚)
{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a â‰  b â†’ a < b
{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” b * a â‰  0
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (s : multiset Î±) : â„•
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.is_terminal 0
{Î± : Type u_2} {Î² : Type u_3} [decidable_eq Î²] [has_vadd Î± Î²] : has_vadd Î± (finset Î²)
 : nnreal
(Î± : Type u_1) (Î² : Type u_2) : Type u_1
{Î± : Type u_1} (n : â„•) : list Î± â†’ â„• â†’ list Î± Ã— list (list Î±)
{M : Type u_1} [has_mul M] : complete_lattice (con M)
(Î± : Type u) : category_theory.single_obj Î±
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
{X : Type v} [topological_space X] [compact_space X] : paracompact_space X
{Î± : Type u} : list Î± â†’ stream Î± â†’ stream Î±
{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop
{M : Type u_1} [mul_action ennreal M] : mul_action nnreal M
{H : Type u_5} [topological_space H] (M : Type u_6) [topological_space M] [charted_space H M] (G : structure_groupoid H) : Prop
(R : Type u_1) [semiring R] : Type u_1
{R : Type u_1} {A : Type u_2} (x : unitization R A) : R
(n : â„•) : comm_ring (fin (n + 1))
{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a - b â‰¤ c â†’ a â‰¤ b + c
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist s s = 0
{Î± : Type u_1} [monoid Î±] (x y : Î±) : Prop
(P : â„• â†’ Prop) [decidable_pred P] : â„• â†’ â„•
(Î± : Type u_1) (Î² : Type u_2) [uniform_space Î²] : uniform_space (Î± â†’ Î²)
{F : Type u â†’ Type u} [functor F] {Î± : Type u} (p : Î± â†’ Prop) (x : F Î±) : Prop
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
(L : first_order.language) (Î± : Type w) : first_order.language
{Î± : Type u_1} [linear_order Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), x < y
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : A.mul B = 1) : Aâ»Â¹ = B
(Î± : Type u_3) [preorder Î±] [topological_space Î±] : Prop
{Î± : Type u} {Î² : Type v} (f' : Î² â†’ Î±) (f : Î± â†’ Î²) (s : set Î±) : Prop
(n : â„•) : â„•
 : category_theory.ess_surj Compactum_to_CompHaus
 : â„• â†’ â„• â†’ option â„•
{Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq Î¹] [add_monoid Î¹] [comm_semiring R] [semiring A] [algebra R A] (ð’œ : Î¹ â†’ submodule R A) : Type (max u_1 u_3)
{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} : x âˆˆ H â†’ y âˆˆ H â†’ x + y âˆˆ H
{Î± : Type u_2} [subtraction_monoid Î±] : subtraction_monoid (set Î±)
(M : Type u) : Type u
{M : Type u_1} [mul_one_class M] {c : con M} : â†‘1 = 1
{R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R
(Î± : Type u) [t : topological_space Î±] [topological_space.second_countable_topology Î±] : set (set Î±)
{F : Type u â†’ Type u} [functor F] (q : qpf F) : Prop
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
(k n : â„•) : finset (fin k â†’ â„•)
(M : Type u) [has_add M] : AddMagma
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
 : num â†’ num â†’ num
 : multiset.nat.antidiagonal 0 = {(0, 0)}
 : Type
(X : Type u_1) [topological_space X] : Type u_1
(n : â„•) : Type
(C : Type u) [category_theory.category C] : setoid C
 : Type (u+1)
{Î± : Type u} (t : ordnode Î±) : list Î±
(R : Type u) [comm_ring R] [local_ring R] : Type u
(n a b : â„•) : Prop
{Î± : Type u_1} {Î² : Type u_2} (e : local_equiv Î± Î²) : local_equiv Î² Î±
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)
 : num â†’ num â†’ num
{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] : ordnode Î± â†’ ordnode Î± Ã— ordnode Î±
{B : Type u} [quiver B] : B â†’ B â†’ Type (max u v)
 : pos_num â†’ pos_num
 : pSet â†’ pSet
(R : Type u) [comm_ring R] [is_domain R] : Prop
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist s âˆ… = 0
(Î± : Type u_1) [decidable_eq Î±] [fintype Î±] : trunc (encodable Î±)
{M : Type u} [has_one M] [has_mul M] : â„• â†’ M â†’ M
{X : Type u_1} [topological_space X] {x y z : X} (Î³ : path x y) (Î³' : path y z) : path x z
{n : Type u_4} {Î± : Type u_5} [fintype n] [non_unital_semi_normed_ring Î±] : non_unital_semi_normed_ring (matrix n n Î±)
(X : Type u) [lattice X] [jordan_holder_lattice X] : Type u
(R : Type u) [comm_ring R] : Type u
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B F : bilin_form R M) (f : module.End R M) : Prop
{Î± : Type u_1} [U : uniform_space Î±] (m : pseudo_metric_space Î±) (H : uniformity Î± = uniformity Î±) : pseudo_metric_space Î±
{Î± : Type u} (s : set Î±) : Prop
{Î± : Type u_1} (a : lists Î±) : lists Î± â†’ Prop
{Î± : Type u_1} {Î² : Type u_2} [has_coe Î± Î²] : has_coe (generalized_continued_fraction.pair Î±) (generalized_continued_fraction.pair Î²)
{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 1 / a â‰¤ 1 / b â†” b â‰¤ a
{Î± : Type u} (max : â„•) (f : thunk Î±) : option Î±
(R : Type u_1) [ring R] [topological_space R] [t : nonarchimedean_ring R] : nonarchimedean_add_group R
{Î± : Type u} (s : set Î±) : is_closed {u : ultrafilter Î± | s âˆˆ u}
{Î¹ : Type u_1} [encodable Î¹] {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), topological_space (E i)] [âˆ€ (i : Î¹), polish_space (E i)] : polish_space (Î  (i : Î¹), E i)
{n : â„•} : bitvec n â†’ bitvec n â†’ bitvec n
{F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a
(Î± : Type u) [s : lattice Î±] [comm_group Î±] [covariant_class Î± Î± has_mul.mul has_le.le] : distrib_lattice Î±
{p : â„•} [fact (nat.prime p)] (f : padic_seq p) : â„¤
{M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s âŠ† t) : monoid.closure s âŠ† t
{f : Type â†’ Type v} [alternative f] (p : Prop) [decidable p] : f unit
(a : â„¤) : â†‘(a.nat_abs) â‰¤ a ^ 2
{Î± : Type u_2} {Î² : Type u_3} [complete_lattice Î±] [complete_lattice Î²] (f : complete_lattice_hom Î± Î²) : Sup_hom Î± Î²
(R : Type u_1) [rack R] : Prop
{Î± : Type u_1} (l : list Î±) : list (multiset Î±)
 : onote â†’ ordinal
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (câ‚€ : omega_complete_partial_order.chain Î±) (câ‚ : omega_complete_partial_order.chain Î²) : omega_complete_partial_order.chain (Î± Ã— Î²)
 : Type
 : onote â†’ ordinal â†’ Prop
 : Type
{Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] (h : bounded_continuous_function Î± Î²) : Î± â†’ Î²
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î±] [semilattice_sup Î²] (gi : galois_coinsertion l u) : semilattice_sup Î±
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : Prop
{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length
 : turing.to_partrec.code
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {mÎ± : measurable_space Î±} [measurable_space Î²] [topological_space Î²] [topological_space.metrizable_space Î²] [borel_space Î²] [topological_space.second_countable_topology Î²] : measure_theory.strongly_measurable f â†” measurable f
(Î± : Type u) : Type u
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (s : set Î±) : set Î±
{Î± : Type u_1} [linear_ordered_field Î±] {Î² : Type u_2} [ring Î²] {abv : Î² â†’ Î±} (f : cau_seq Î² abv) : Prop
(G : Type u_1) [category_theory.groupoid G] : Type (max u_1 (v+1))
(R : Type u) : Type u
(Î± : Sort u) : Sort u
(Î± : Type u_5) : Type u_5
{Î± : Type u} [non_unital_ring Î±] {a b c : Î±} (h : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (P : category_theory.idempotents.karoubi C) : category_theory.idempotents.karoubi C
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J â†’ C} {t : category_theory.limits.cone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_limit t) : category_theory.limits.bicone f
(Î± : Type u_3) [preorder Î±] [topological_space Î±] : Prop
{Î± : Type u} (c : computation Î±) : Î± âŠ• computation Î±
{Î± : Type u} [topological_space Î±] (x : Î±) : stone_cech Î±
(t s : omega.nat.preterm) (k : â„•) : omega.nat.preterm â†’ omega.nat.preterm
(X : Twop) : Bipointed
{R : Type u_1} [ring R] (s : subring R) (m : multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
(Î± : Type u) {Î² : Type v} [group Î±] [mul_action Î± Î²] (b : Î²) : subgroup Î±
(L : Type v) [has_bracket L L] [has_zero L] : Prop
{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R) : polynomial R
 : has_pure ultrafilter
(R : Type u_1) (Râ‚˜ : Type u_2) [comm_semiring R] [comm_semiring Râ‚˜] (M : submonoid R) [subsingleton R] [algebra R Râ‚˜] [is_localization M Râ‚˜] : unique Râ‚˜
(n d : pos_num) : num
{Î± : Type u} {Î² : Type v} [mul_one_class Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_monoid_hom f
(Î² : Type u_2) [pseudo_metric_space Î²] [monoid Î²] : Prop
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ -b + a < c
{X : Type u_1} [topological_space X] (F : set X) : Prop
{E : â„• â†’ Type u_1} : has_dist (Î  (n : â„•), E n)
(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : dense_range (topological_space.dense_seq Î±)
{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : lipschitz_with 1 (Î» (x : Î±), metric.inf_nndist x s)
{t : Type u_1 â†’ Type u_1 â†’ Type u_1} {m : Type u_1 â†’ Type u_1} [bitraversable t] [applicative m] {Î± Î² : Type u_1} : t (m Î±) (m Î²) â†’ m (t Î± Î²)
{Î± : Type u_1} (a : Î±) (n : â„•) : sym Î± n
{Î± : Type u_1} (s : multiset Î±) : Prop
{Mâ‚ : Type u_1} {Mâ‚‚ : Type u_2} [has_inv Mâ‚‚] [has_involutive_inv Mâ‚] (f : Mâ‚ â†’ Mâ‚‚) (hf : function.surjective f) (inv : âˆ€ (x : Mâ‚), f xâ»Â¹ = (f x)â»Â¹) : has_involutive_inv Mâ‚‚
{G : Type u_1} [group G] (S : set G) : subgroup G
{Î± : Sort u} (a : Î±) {Î² : Sort u} : Î² â†’ Prop
(R : Type u) [semiring R] [nontrivial R] [hq : exp_char R 1] : char_zero R
{Î± : Type u_1} {Î² : Type u_2} [encodable Î±] [encodable Î²] (n : â„•) : option (Î± âŠ• Î²)
 : Type
{Î± : Type u_1} [comm_semiring Î±] (a x : Î±) (n : â„•) (b : Î±) : Î±
(Î± : Type u_1) [distrib_lattice Î±] [bounded_order Î±] : BoundedDistribLattice
(p : â„•) (z : â„¤) : â„•
{X : Type u_2} [emetric_space X] (s : set X) : ennreal
{Î± : Sort u} (a : Î±) : Î±
(Î± : Type u_1) [boolean_ring Î±] : BoolRing
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (i j : Î¹) : local_homeomorph (B Ã— F) (B Ã— F)
{M : Type u_3} [monoid M] (L : list M) (h : L.prod â‰  1) : 0 < L.length
{a : â„•} (a1 : 1 < a) (n : â„•) : â„•
{Î± : Type u_1} {ð’œ : finset (finset Î±)} {Aâ‚ Aâ‚‚ : finset Î±} {râ‚ râ‚‚ : â„•} (hâ‚ : Aâ‚ âˆˆ ð’œ.slice râ‚) (hâ‚‚ : Aâ‚‚ âˆˆ ð’œ.slice râ‚‚) : râ‚ â‰  râ‚‚ â†’ Aâ‚ â‰  Aâ‚‚
{k : Type u_2} [field k] : power_series k â†’ power_series k
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (S : intermediate_field F E) : Prop
{K : Type u_1} [division_ring K] (g : generalized_continued_fraction K) : â„• â†’ generalized_continued_fraction K
(p : â„•) [hp : fact (nat.prime p)] (n : â„•) : mv_polynomial â„• â„¤
(M : Type u_1) {Î± : Type u_2} [add_monoid M] [add_action M Î±] (s : set Î±) : add_submonoid M
{R : Type u_1} [comm_semiring R] {M : submonoid R} (z w : localization M) : localization M
{Î± : Type u} [topological_space Î±] [t2_space Î±] [compact_space Î±] : totally_disconnected_space Î± â†” totally_separated_space Î±
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} [topological_space Î²] {m : measurable_space Î±} (hf : measure_theory.strongly_measurable f) : â„• â†’ measure_theory.simple_func Î± Î²
(R : Type u_1) [rack R] : Type u_1
(n : â„•) (a : fin n) (b : â„•) : Prop
{Î± : Type u_2} {Î² : Type u_3} [preorder Î±] [preorder Î²] [bounded_order Î±] [bounded_order Î²] (f : bounded_order_hom Î± Î²) : bot_hom Î± Î²
{Î² : Type u_2} {f g : Î² â†’ nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b) : summable f â†’ summable g
(F : Type u_7) (Î± : out_param (Type u_8)) (Î² : out_param (Type u_9)) [lattice Î±] [lattice Î²] [bounded_order Î±] [bounded_order Î²] : Type (max u_7 u_8 u_9)
{Î± : Type u_1} [lattice Î±] [order_bot Î±] {a : Î±} : has_le (finpartition a)
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} (h : function.injective f) (s : set Î±) : set.inj_on f s
{Î± : Type u} [decidable_eq Î±] (a : Î±) : wseq Î± â†’ computation â„•
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : Type (max u (v+1))
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det
{p n : â„•} {R : Type u_1} [comm_ring R] (x : truncated_witt_vector p n R) : witt_vector p R
(Î± : Type u) : Type u
{R : Type u_1} [monoid_with_zero R] (f : nat.arithmetic_function R) : Prop
(G : Type u_1) [monoid G] : Prop
{Î± : Type u_1} {Î² : Type u_2} [t : topological_space Î±] [add_group Î²] (f : Î± â†’ Î²) : add_group_topology Î²
{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ < bâ»Â¹ â†” b < a
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : submodule R M
{Î± : Type u_1} {r s : Î± â†’ Î± â†’ Prop} (h : âˆ€ (x y : Î±), r x y â†’ s x y) : eqv_gen.setoid r â‰¤ eqv_gen.setoid s
 : category_theory.limits.has_limits_of_size AddGroup
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
(C : Type u) [category_theory.category C] : Prop
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (d : con N) : con (M Ã— N)
 : Type
{Î± : Type u} (x : Î±) : free_semigroup Î±
(a b : â„•) {c : â„•} (hc : 0 < c) : c * a / (c * b) = a / b
{Î± : Type u_1} [preorder Î±] {Î² : Type u_2} [preorder Î²] (f : Î± â†’ Î²) (f_strict_mono : strict_mono f) (s : ordset Î±) : ordset Î²
{Î± : Type u} : ordnode Î± â†’ â„• â†’ option Î±
{Î± : Type u_1} [primcodable Î±] (p : Î± â†’ Prop) : Prop
{Î± : Type u_1} {p : Î± â†’ Prop} [emetric_space Î±] : emetric_space (subtype p)
 : pos_num â†’ pos_num â†’ num
{M : Type u_1} [has_add M] (S : add_subsemigroup M) : set M
{R : Type u_2} {Î“â‚€ : Type u_3} [linear_ordered_add_comm_monoid_with_top Î“â‚€] [ring R] (v : add_valuation R Î“â‚€) : preorder R
{Î± : Type u_1} {b : bool} : lists' Î± b â†’ list (lists Î±)
 : pos_num â†’ â„• â†’ bool
{a : â„•} (a1 : 1 < a) (n : â„•) : â„¤
 : â„¤ â†’ â„¤ â†’ â„¤
{Î± : Type u_1} [preorder Î±] [fintype Î±] : locally_finite_order Î±
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst
{Î± : Type u} (s : set Î±) : Prop
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] : list Î± â†’ ordnode Î±
{Î± : Type u_3} {Î² : Type u_4} [lattice Î±] [lattice Î²] [bounded_order Î±] [bounded_order Î²] (f : bounded_lattice_hom Î± Î²) : bounded_order_hom Î± Î²
{C : Type u} [category_theory.category C] : category_theory.grothendieck_topology C
{Î± : Type u} (s : stream Î±) : stream Î±
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} [decidable_eq Î³] (f : Î± â†’ Î² â†’ Î³) (s : finset Î±) (t : finset Î²) : finset Î³
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : X
(Î± : Type u) (Î² : Type v) [topological_space Î±] [has_zero Î²] [topological_space Î²] : Type (max u v)
 : Type
(Î± : Type u_2) [topological_space Î±] : spectral_map Î± Î±
(Î¹ : Type v) (Î² : Î¹ â†’ Type w) [Î  (i : Î¹), add_comm_monoid (Î² i)] : Type (max v w)
(Ï : out_param (Type u)) (m : Type u â†’ Type v) : Type v
(R : Type u) [semiring R] : Prop
{Î± : Type u_2} [has_mul Î±] (a : Î±) (s t : set Î±) : set Î±
(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_add M] [has_add N] : Type (max u_10 u_11 u_9)
{M : Type u} [monoid M] (F : Type v) [field F] [mul_semiring_action M F] (m : M) : subfield F
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hf : function.injective f) (hg : function.injective g) : âˆƒ (h : Î± â†’ Î²), function.bijective h
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1
{G : Type u_1} [group G] (H : subgroup G) : Prop
{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] : galois_insertion (intermediate_field.adjoin F) coe
{Î± : Type v} {d u l r : â„•} (A : matrix (fin (u + d)) (fin (l + r)) Î±) : matrix (fin u) (fin r) Î±
{Î± : Type u_1} (s : set Î±) : local_equiv Î± Î±
{A : Type u_2} [add_monoid A] (s : set A) : A â†’ Prop
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} : free_group.red.step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length
(Î± : Type u_1) [partial_order Î±] [order_top Î±] : Prop
{Î± : Type u_1} {Î¹ : Type u_3} {m : measurable_space Î±} [preorder Î¹] {f : measure_theory.filtration Î¹ m} {Ï„ : Î± â†’ Î¹} (hÏ„ : measure_theory.is_stopping_time f Ï„) : measurable_space Î±
(C : Type u_1) [category_theory.category C] : Type
{n : â„•} {Î± : fin n â†’ Type u} [Î  (i : fin n), decidable_eq (Î± i)] (a b : d_array n Î±) : bool
{Î± : Type u} : lazy_list Î± â†’ list Î±
{Î± : Type u_1} [complete_lattice Î±] : Inf_hom Î± (lower_set Î±)
{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) â†” is_left_regular b
{E : â„• â†’ Type u_1} (x : Î  (n : â„•), E n) (n : â„•) : set (Î  (n : â„•), E n)
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : a * b â‰¤ c â†’ b â‰¤ aâ»Â¹ * c
(x y : â„•) : â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y
(n : â„•) : bitvec n
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : free_add_magma Î± â†’ free_add_magma Î²
(k : â„•) : nat.arithmetic_function â„•
(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : add_valuation R enat
{Î± : Type u_1} {Î² : Type u_2} (s : finset Î±) (t : finset Î²) : finset (Î± âŠ• Î²)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
(Î± : Type u) : Type u
{a b : ereal} (h : -a â‰¤ b) : -b â‰¤ a
{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s â†” is_closed s
{R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)
(n : â„•) : composition n
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : 1 â‰¤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
(M : Type u_1) (Î± : Type u_2) [has_vadd M Î±] [measurable_space M] [measurable_space Î±] : Prop
 : Type
{Î± : fin 0 â†’ Type u_1} : d_array 0 Î±
{Î± : Type u} (P : Î± â†’ Prop) [decidable_pred P] : list Î± â†’ (list Î± â†’ list Î±) â†’ list (list Î±)
{Î± : Type u_1} [measurable_space Î±] {f : â„• â†’ Î± â†’ nnreal} {g : Î± â†’ nnreal} (hf : âˆ€ (i : â„•), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
(Î± : Type u_1) : Type u_1
{Î± : Type u} [ring Î±] [no_zero_divisors Î±] : cancel_monoid_with_zero Î±
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : 1 < a) (hb : 1 â‰¤ b) (a0 : 0 < a) : 1 < a * b
{Î± : Type u} [primcodable Î±] [inhabited Î±] (p : set Î±) : set â„•
{Î± : Type u_1} [fintype Î±] : finset Î±
{Î± : Type u} {Î² : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space.second_countable_topology Î±] [topological_space.second_countable_topology Î²] : topological_space.second_countable_topology (Î± âŠ• Î²)
{Î± : Type u_1} [preorder Î±] [decidable_rel has_le.le] (x : Î±) (s : ordset Î±) : ordset Î±
(Ï Ï' : out_param (Type u)) (m m' : Type u â†’ Type v) : Type (max (u+1) v)
 : Type
(Î± : Type u_4) : Type u_4
{H : Type u} [topological_space H] : closed_under_restriction (continuous_groupoid H)
(n : â„•) : finset â„•
{Î± : Type u_1} [preorder Î±] [is_total Î± has_le.le] [decidable_rel has_le.le] (x : Î±) (s : ordset Î±) : ordset Î±
(S : Type u_1) (R : out_param (Type u)) [ring R] [set_like S R] : Type
{Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.surjective g) : function.surjective (function.comp g)
{Î± : Type u_1} [topological_space Î±] {R : Type u_2} [comm_semiring R] {A : Type u_3} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] : subalgebra R (Î± â†’ A)
(C : Type u) [category_theory.category C] : Prop
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(Î± : Type u_1) (n : â„•) : Type u_1
{Î± : Type u} [group_with_zero Î±] (a b : Î±) [invertible a] [invertible b] : invertible (a / b)
{Î± : Type u} [semilattice_inf Î±] [order_bot Î±] (a b : Î±) : Prop
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Î¹} [category_theory.limits.has_zero_object V] : homological_complex V c
{L : first_order.language} (Îº : cardinal) (T : L.Theory) : Prop
(a b c : â„¤) : Prop
{Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²) : Prop
{Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} (f : Îº â†’ Î²) : Prop
(M : Type u_1) [add_monoid M] : add_submonoid M
{Î± : Type u_1} [conditionally_complete_lattice Î±] : conditionally_complete_lattice (with_bot Î±)
{Î± : Type u} {Î² : Type v} : wseq Î± â†’ wseq Î² â†’ wseq (Î± Ã— Î²)
{Î¹ : Type u_1} (M : Î¹ â†’ Type u_2) [Î  (i : Î¹), monoid (M i)] : Î¹ â†’ Î¹ â†’ Type (max u_1 u_2)
(R : Type u) [semiring R] {m : Type u_1} {n : Type u_2} [fintype m] [fintype n] : module.free R (matrix m n R)
(Î± : Type u) : Type u
{Î± : Type u} {Î² : Type v} (f : ulift (Î± â†’ Î²)) (x : ulift Î±) : ulift Î²
(Î± : Type u_3) : Type u_3
(Î± : Type u) (lt : Î± â†’ Î± â†’ Prop) : Prop
{C : Type u_1} [category_theory.category C] (X : C) : Prop
(R : Type u_1) (M : Type u_3) [monoid_with_zero R] [has_zero M] : Type (max u_1 u_3)
 : Type (u_1+1)
{Î± : Type u} : rbnode Î± â†’ tree Î±
(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : setoid {v // v â‰  0}
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (v : n â†’ Î±) [invertible (matrix.diagonal v)] : invertible v
{Î± : Type u_1} {Î² : Type u_2} : list (option Î±) â†’ list Î² â†’ list (option Î²)
(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) (a : A) (m : matrix n n R) : matrix n n A
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (K : add_subgroup N) : add_subgroup (G Ã— N)
(M : Type u) [add_semigroup M] : AddSemigroup
{Î± : Type u} [preorder Î±] (s : set Î±) : Î± â†’ Prop
 : sSet
{X : Type u_1} [topological_space X] (x y : X) : Type u_1
{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0
 : Type (u_1+1)
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Î± : Type u_1} {Î¹ : Type u_4} (l : filter Î±) (p : Î¹ â†’ Prop) (s : Î¹ â†’ set Î±) : Prop
{n : â„•} (i : fin2 n) (k : â„•) : fin2 (n + k)
{Î± : Type u_1} {n : â„•} (v : vector3 Î± n.succ) : vector3 Î± n
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (X : category_theory.simplicial_object C) : chain_complex C â„•
{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : Prop
(r : â„•) (b : bool) : â„•
(G : Type u) : Type u
{Î± : Type u_1} (n : â„•) (s : finset Î±) : finset (finset Î±)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : valuation R (with_zero (multiplicative â„¤))
{G : Type u_1} [group G] (g : G) : subgroup G
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] (f : measure_theory.simple_func Î± Î²) (g : measure_theory.simple_func Î± Î³) : measure_theory.simple_func Î± (Î² Ã— Î³)
{Î² : Type w} {C : Type u} [category_theory.category C] (f : Î² â†’ C) : Prop
{Î² : Type w} [add_comm_group Î²] (s : Î²) (C : Type u) : Type (max w u)
{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b
 : category_theory.limits.has_limits_of_size Ring
{R : Type u_1} [semiring R] (N : â„•) : polynomial R â†’ polynomial R
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} (a : topological_fiber_prebundle F proj) : topological_space Z
(C : Type u_1) [category_theory.category C] [category_theory.is_idempotent_complete C] : category_theory.is_equivalence (category_theory.idempotents.to_karoubi C)
{R : Type u} [semiring R] (f : polynomial R) : polynomial R
{Î± : Type u_1} [measurable_space Î±] : measure_theory.measure Î±
{Î± : Type} (p : parser Î±) : Prop
{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : lipschitz_with 1 (Î» (x : Î±), metric.inf_dist x s)
{Î± : Type u} (a : Î±) (s : stream Î±) : stream Î±
 : Type (u+1)
{G : Type u_1} [group G] [fintype G] : monoid.is_torsion G
(C : Type u) [category_theory.category C] : Prop
 : Type
{Î± : Type u} [infinite Î±] : nonempty (field Î±)
{Î± : Type u_1} {Î² : Type u_2} [can_lift Î± Î²] : can_lift (multiset Î±) (multiset Î²)
(J : Type uâ‚) [category_theory.category J] : Prop
(k : Type u) [field k] : Prop
{n : Type u_4} {Î± : Type u_5} [fintype n] [non_unital_normed_ring Î±] : non_unital_normed_ring (matrix n n Î±)
(Î± : Type u_1) [partial_order Î±] [fintype Î±] : FinPartialOrder
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
(T : Type u) [topological_space T] : category_theory.pretopology.of_grothendieck (topological_space.opens T) (opens.grothendieck_topology T) = opens.pretopology T
{R : Type u_1} [nontrivial R] [hR : ring R] (h : âˆ€ (a : R), is_unit a âˆ¨ a = 0) : division_ring R
(R : Type u) [semiring R] [strong_rank_condition R] : rank_condition R
{Î± Î² : Type u_1} {m : Type u_1 â†’ Type u_2} [monad m] (y : m Î²) (z : Î± â†’ m Î²) (x : m (option Î±)) : m Î²
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] : category_theory.limits.has_coequalizers C
(Î± : Type u) (ds : list â„•) : Type u
{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : has_neg (submodule R M)
{Î± : Type u} : seq (seq1 Î±) â†’ seq Î±
{Î± : Type u_2} [has_one Î±] [has_mul Î±] [has_inv Î±] : has_pow (filter Î±) â„¤
{Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a = b â†’ a < c
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) (h : open_embedding f) [nonempty Î±] : local_homeomorph Î± Î²
{Î± : Type u} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) : f x = x
{R : Type u_2} {Î“â‚€ : Type u_3} {Î“'â‚€ : Type u_4} [ring R] [linear_ordered_comm_monoid_with_zero Î“â‚€] [linear_ordered_comm_monoid_with_zero Î“'â‚€] (vâ‚ : valuation R Î“â‚€) (vâ‚‚ : valuation R Î“'â‚€) : Prop
(G : Type u_1) [topological_space G] [has_sub G] : Prop
 : Type
{Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [preorder Î²] (f : Î± â†’ Î²) (x : Î±) : Prop
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [preorder Î±] [preorder Î²] [preorder Î³] (g : pseudo_epimorphism Î² Î³) (f : pseudo_epimorphism Î± Î²) : pseudo_epimorphism Î± Î³
(A B : CommRing) : category_theory.limits.binary_fan A B
 : golden_ratioâ»Â¹ = -golden_conj
{Râ‚ƒ : Type u_7} [comm_ring Râ‚ƒ] {n : Type u_11} [fintype n] (J Jâ‚ƒ A A' : matrix n n Râ‚ƒ) : Prop
{Î¹ : Type u} (f : Î¹ â†’ ordinal) : ordinal
(l : Type u_4) (R : Type uâ‚‚) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (l âŠ• l) (l âŠ• l) R)
{M : Type u_1} [comm_monoid M] (S : submonoid M) : localization S
{n : â„•} (c : composition n) (i : â„•) : â„•
{Î± : Type u} : â„• â†’ seq Î± â†’ list Î±
{Î± : Type u_2} [has_neg Î±] : has_neg (set Î±)
{Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a * a / a = a
{n : â„•} : (vector â„• n â†’ â„•) â†’ Prop
{Î± : Type u} (f : Î± â†’ Î±) : Î± â†’ lazy_list Î±
{Î± : Type u_2} [has_mul Î±] (a : Î±) : Prop
 : â„• â†’ â„¤ â†’ â„¤ â†’ â„• â†’ â„¤ â†’ â„¤ â†’ â„• Ã— â„¤ Ã— â„¤
{R : Type u} [semiring R] (p : polynomial R) : with_top â„•
(R : Type u) [semiring R] : Type u
(M : Type u_1) [has_mul M] : galois_insertion con_gen coe_fn
{Î± : Type u} [pseudo_emetric_space Î±] : setoid Î±
(B : Type u) [category_theory.bicategory B] : Prop
{C : Type uâ‚} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_images C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject A
(l : Type u_4) (R : Type uâ‚‚) [decidable_eq l] [comm_ring R] : matrix (l âŠ• l) (l âŠ• l) R
{m : Type u â†’ Type v} [monad m] {Î± : Type u} (p : Î± â†’ m (ulift bool)) : list Î± â†’ m (option Î±)
(n : â„•) (Î± : Type u) : Type u
{Î± : Type u_2} {Î² : Type u_3} (r : Î± â†’ Î² â†’ Prop) (s : set Î±) : set Î²
{Î± : Type u_1} [monoid Î±] {p q : Î±} (hp : irreducible p) (hq : irreducible q) : p âˆ£ q â†’ q âˆ£ p
{R : Type u} [ring R] (s : subring R) {x y : R} (hx : x âˆˆ s) (hy : y âˆˆ s) : x - y âˆˆ s
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream (generalized_continued_fraction.pair K)
(a b : snum) : snum
(Î¹ : Sort u_1) (Î± : Î¹ â†’ Sort u_2) (Î² : Î¹ â†’ Sort u_3) [Î  (i : Î¹), can_lift (Î± i) (Î² i)] : can_lift (Î  (i : Î¹), Î± i) (Î  (i : Î¹), Î² i)
(R : Type u_1) [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] (a : S) : Prop
{Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_cyclic Î±
{M : Type u_1} [add_zero_class M] {S T : add_submonoid M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
 : Type (u+1)
{Mâ‚€ : Type u_1} [cancel_monoid_with_zero Mâ‚€] {a b : Mâ‚€} (hâ‚ : b â‰  1) (hâ‚‚ : a * b = a) : a = 0
(G : Type u) : Type u
(Î“ : Type u_1) [inhabited Î“] : Type u_1
{k : Type u_1} {G : Type u_2} [comm_semiring k] [monoid G] : representation k G k
{ð•œ : Type u_1} {E : Type u_2} [ordered_ring ð•œ] [add_comm_group E] [module ð•œ E] (Q : affine_subspace ð•œ E) : convex ð•œ â†‘Q
{a b c : â„•} (h : a % c = b % c) : (a - b) % c = 0
(J : Type uâ‚‚) [category_theory.category J] : setoid J
{R : Type u} {M : Type v} [ring R] [add_comm_group M] [module R M] (S : submodule R M) : Prop
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Sort u_3} (f : Î± â†’ Î³) (g : Î² â†’ Î³) : Î± âŠ• Î² â†’ Î³
{Î± : Type u_1} [encodable Î±] {n : â„•} : encodable (array n Î±)
(A : Type u_1) (B : out_param (Type u_2)) : Type (max u_1 u_2)
(G : Type u_1) : Type u_1
{n : â„•} {Î± : Type u_1} {v w : vector Î± n} (h : âˆ€ (m : fin n), v.nth m = w.nth m) : v = w
{Î± : Type u} : free_magma Î± â†’ â„•
{R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) : list (Î£ (a : Î±), Î² a) â†’ list (Î£ (a : Î±), Î² a)
(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) : finset.centroid_weights_indicator k s = â†‘s.indicator (finset.centroid_weights k s)
{Î± : Type u} {Î² : Î± â†’ Type v} (l : list (sigma Î²)) : Prop
{V : Type u} (G : simple_graph V) (Î± : Type v) : Type (max u v)
{Î± : Type u} (s : wseq Î±) : Prop
(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] [totally_disconnected_space X] : Profinite
{Î± : Type u} (f : Î± â†’ Î±) (x : Î±) : Prop
{x y z : â„¤} (h : pythagorean_triple x y z) : Prop
(n : â„•) : finset (â„• Ã— â„•)
(R : Type u_1) [ordered_semiring R] [nontrivial R] : submonoid R
{Î± : Type u} {p : Î± â†’ Prop} {a : Î±} (h : a âˆˆ {x : Î± | p x}) : p a
{n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) (z : Î± 0) : fin.tail (function.update q 0 z) = fin.tail q
{Î± : Type u_1} [decidable_eq Î±] : monotone finset.shadow
(R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A â†’ R)
{M : Type u_1} (S : set M) [has_mul M] : set M
{m : Type â†’ Type v} [monad m] {Î± : Type u} (p : Î± â†’ m bool) (as : list Î±) : m bool
 : has_div ordinal
(H : Type u) [topological_space H] : structure_groupoid H
(Î± : Type u_2) : Type u_2
{R : Type u_1} {S : Type u_3} [comm_semiring R] [comm_semiring S] : comm_semiring (R Ã— S)
 : Type
{R : Type u} [semiring R] (p : polynomial R) : â„•
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (l : multiset Î±) (hp : âˆƒ! (a : Î±), a âˆˆ l âˆ§ p a) : {a // a âˆˆ l âˆ§ p a}
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) : add_subsemigroup N
(A : out_param (Type u)) (B : Type v) : Type (max (u+1) (v+1))
(R : CommRing) : algebraic_geometry.LocallyRingedSpace
(Î± : Type u_1) [ht : topological_space Î±] [h : polish_space Î±] : upgraded_polish_space Î±
(k : Type u) [field k] : Type u
(n : â„•) : â†‘(n.totient) = â†‘n * n.factors.to_finset.prod (Î» (p : â„•), 1 - (â†‘p)â»Â¹)
(Î± : Type u) [cancel_comm_monoid_with_zero Î±] : Type u
(Î± : Type u_1) : Type u_1
{G : Type u_1} [group G] (H : â„• â†’ subgroup G) : Prop
(f : ordinal â†’ ordinal) : ordinal â†’ ordinal
{Î± : Type u} [preorder Î±] [no_max_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_mono f âˆ§ f 0 = a
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} : sym Î± 0
(Î± : Type u_1) : Type u_1
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type v
(Î± : Type u_1) {Î² : Type u_2} (q : two_pointing Î²) [nonempty Î±] : two_pointing (Î± â†’ Î²)
(L : Type u_1) [topological_space L] [has_inf L] : Prop
{k : Type uâ‚‚} [ring k] : inhabited (affine_basis punit k punit)
{ð•œ : Type u_3} [field ð•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ð•œ) : list (matrix (fin r âŠ• unit) (fin r âŠ• unit) ð•œ)
{Î± : Type u_1} {M : Type u_4} [has_one M] (s : set Î±) (f : Î± â†’ M) : Î± â†’ M
(Î± : Type u_3) [has_le Î±] : Type u_3
{Î± : Type u} [partial_order Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : a = b
{Î± : Type u} {Î² : Type v} {s : set Î±} {f : Î± â†’ Î²} : set.inj_on f s â†’ function.injective (s.restrict f)
{A : Type u_1} {B : Type u_2} [i : set_like A B] {p q : A} (h : âˆ€ (x : B), x âˆˆ p â†” x âˆˆ q) : p = q
(X Y : Pointed) : Type u
{Î± : Type u_1} [semilattice_inf Î±] : inf_hom Î± (lower_set Î±)
{X : Type u_1} (to_prod : X Ã— X) : Bipointed
(R : Type uâ‚) (L : Type uâ‚‚) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max uâ‚ uâ‚‚)
{Î± : Type u_1} [has_compl Î±] [has_sup Î±] (a b : Î±) : Î±
 : has_sub nonote
 : Type
(k : â„•) (v : â„• â†’ â„¤) (as : list â„¤) : â„¤
 : list â„• â†’ â„• â†’ list â„•
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : affine.simplex k P 0
(p : â„•) : Type
(A B : Class) : Prop
(R : Type u_1) [comm_semiring R] {X : Type u_2} : X â†’ free_algebra R X
(Î± : Type u) : Type u
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} [Î  (a : Î±), fintype (Î² a)] : W_type Î² â†’ â„•
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} (m : Î± â†’ Î² â†’ Î³) (f : filter Î±) (g : filter Î²) : filter Î³
{R : Type u_1} [nontrivial R] [hR : comm_ring R] (h : âˆ€ (a : R), is_unit a âˆ¨ a = 0) : field R
(Î± : Sort u) : Sort (max 1 u)
(M : Type u_9) (N : Type u_10) [mul_one_class M] [mul_one_class N] : Type (max u_10 u_9)
{n : â„•} (P : mvpfunctor (n + 1)) : mvpfunctor n
 : Type (u+1)
 : Type
{X : Type u_1} {Y : Type u_2} [topological_space X] (f : X â†’ Y) : Prop
{Î± : Type u_2} [decidable_eq Î±] [add_zero_class Î±] : add_zero_class (finset Î±)
{m n : â„•} : m âˆ£ m + n â†” m âˆ£ n
{Î± : Type u_1} : list Î± â†’ Î± â†’ list Î±
 : Type (u+1)
{K : Type u_1} [field K] {Î“ : Type u_2} [linear_ordered_comm_group_with_zero Î“] (v : valuation K Î“) : valuation_subring K
{Î± : Type u} : wseq Î± â†’ computation (option (Î± Ã— wseq Î±))
{Î± : Type u_1} [group Î±] (s : subgroup Î±) : setoid Î±
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K
{R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a
 : Type
(Î± : Sort u_1) : Sort (max 1 (imax 1 u_1) u_1)
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (Î¹ : Type u_4) [decidable_eq Î¹] : Type (max u_1 u_2 u_4)
(p : â„•) [fact (nat.prime p)] : â†‘((p - 1).factorial) = -1
(Î² : Type u_2) [pseudo_metric_space Î²] [add_monoid Î²] : Prop
(n : â„•) : add_comm_group (fin (n + 1))
{Î± : Type u_1} [normed_division_ring Î±] {a : Î±} (ha : a â‰  0) : filter.tendsto (Î» (x : Î±), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
{R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a
(a : â„¤) : â„¤
(x y c : bool) : bool
{S : Type u_1} [ordered_semiring S] {R : Type u_2} [semiring R] (abv : R â†’ S) [is_absolute_value abv] : absolute_value R S
{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X â†’ Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X
(Î± : Type u_1) : Type u_1
 : category_theory.limits.limit_cone (category_theory.functor.empty (Type u))
{Î± : Type u} [pseudo_emetric_space Î±] (s : set Î±) : ennreal
(G : Type u_10) [has_involutive_neg G] : equiv.perm G
(R : Type u) [rack R] : rack.pre_envel_group R â†’ rack.pre_envel_group R â†’ Type u
(X : algebraic_geometry.LocallyRingedSpace) : Top
 : snum â†’ snum
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) [decidable_eq Î±] [fin_enum Î²] (h : function.injective f) : fin_enum Î±
 : Type (max (u+1) (v+1))
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [has_mul Î±] [has_add Î±] [has_le Î±] [has_mul Î²] [has_add Î²] [has_le Î²] : Type (max u_6 u_7 u_8)
{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G â†’ Â¬monoid.is_torsion_free G
(p : Type u_2) (q : Type u_3) (R : Type uâ‚‚) [decidable_eq p] [decidable_eq q] [comm_ring R] : matrix (p âŠ• q) (p âŠ• q) R
{Î± : Type u_1} : sym2.map (Î» (x : Î±), x) = id
(V : Type u) [quiver V] : Type (max u v)
 : nat.partrec.code â†’ â„•
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [has_top Î±] [has_top Î²] : Type (max u_6 u_7 u_8)
{a : Sort u} {b : Sort v} [has_coe_t a b] : has_lift_t a b
{Î± : Type u_1} [topological_space Î±] (s : set Î±) : Prop
{R : Type u_1} [mul_zero_class R] : is_left_regular 0 â†” subsingleton R
{Î± : Type u_2} [decidable_eq Î±] [has_one Î±] [has_mul Î±] : has_pow (finset Î±) â„•
{Î± : Type u_1} [linear_order Î±] {r s : Î±} : {r}.to_colex â‰¤ {s}.to_colex â†” r â‰¤ s
(Î± : Type u_1) [topological_space Î±] [non_unital_non_assoc_ring Î±] : Prop
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) (a : Î±) : f (-a) = -f a
{G : Type u_1} [group G] (H K : set G) : Type u_1
(Î± : Type u_5) : Type u_5
{Î± : Type u_1} (o : part Î±) : {dom := o.dom, get := Î» (h : o.dom), o.get h} = o
(Î± : Type u_4) [has_le Î±] : Type u_4
{Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²) : Prop
(R : Type u) (X : Type v) [comm_ring R] : Type (max u v)
(Î± : Type u_5) : Type u_5
 : Type
(R : Type u) [ring R] : Type u
{Î± : Type u_1} {Î² : Type u_2} [t : topological_space Î±] [ring Î²] (f : Î± â†’ Î²) : ring_topology Î²
{A : Type u_2} [add_monoid A] (x : A) : add_submonoid A
{P : Type u_1} [preorder P] (F : order.pfilter P) : Prop
 : Type (u+1)
(G : Type u_1) [group G] [hG : group.is_nilpotent G] : â„•
{Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a + b - a â‰¤ b
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
{n : â„•} : bitvec n â†’ bitvec n â†’ bitvec n
{Î± Î² : Type} (f : Î± â†’ Î² â†’ Î±) (a : Î±) (p : parser Î²) : parser Î±
{Î± : Type u_1} {Î² : Type u_2} (s : multiset Î±) (t : multiset Î²) : multiset (Î± âŠ• Î²)
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Î¹} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (i : Î¹) : V
 : ring_hom.localization_preserves ring_hom.finite
 : category_theory.concrete_category CpltSepUniformSpace
{P : Type u_1} [preorder P] (p : P) : order.ideal P
 : Type
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚) : free_group.red Lâ‚‚ (free_group.reduce Lâ‚)
{G : Type u_1} [add_group G] (s : set G) : set G
{Î± : Type u_3} {Î² : Type u_4} [lattice Î±] [lattice Î²] (f : lattice_hom Î± Î²) : inf_hom Î± Î²
(Î± : Type u_1) [ring Î±] : Type u_1
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (s s' : finmap Î²) : finmap Î²
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î²] [semilattice_sup Î±] (gi : galois_insertion l u) : semilattice_sup Î²
(Î± : Type u_2) [fintype Î±] [nonempty Î±] [lattice Î±] : bounded_order Î±
{Î± : Type u_1} [has_add Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {b c : Î±} (bc : b < c) (a : Î±) : a + b < a + c
{Î± : Sort u_1} {Î² : Sort u_2} [nonempty Î±] (f : Î± â†’ Î²) : Î² â†’ Î±
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X â†’ Y} (h : lipschitz_with K f) : dimH (set.range f) â‰¤ dimH set.univ
{Î± : Type u_1} (s : set (set Î±)) : set Î± â†’ Prop
{X : Type u_1} [topological_space X] {x y : X} (h : joined x y) : path x y
{Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] : has_dist (bounded_continuous_function Î± Î²)
{Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x + x) âˆ˜ Î» (_x : Î±), _x + y) = Î» (_x : Î±), _x + (y + x)
{Î± : Type u_1} [h : encodable Î±] : encodable (option Î±)
(R : Type u) [semiring R] (n : â„•) : submodule R (polynomial R)
 : Type (u+1)
{Î± : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul Î±] [add_comm_monoid Î±] (A : matrix m n Î±) [fintype m] : Prop
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] (a b : Î±) : multiset Î±
{Î± : Type u_1} {Î² : Type u_2} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {K : nnreal} {f : Î± â†’ Î²} (hf : antilipschitz_with K f) : nnreal
{Î± : Type u_2} [division_comm_monoid Î±] : division_comm_monoid (filter Î±)
{Î± : Sort u_1} (a : Î±) : trunc Î±
{Î± : Type u_1} : list Î± â†’ list (list Î±)
{K : Type u} [hring : comm_ring K] : ratfunc K â†’ ratfunc K â†’ ratfunc K
{G : Type u_1} [group G] [topological_space G] {H : Type u_2} [group H] [topological_space H] (U : open_subgroup G) (V : open_subgroup H) : open_subgroup (G Ã— H)
(Î± : Type u) : Type u
{P : Type u_1} [preorder P] : partial_order (order.pfilter P)
(R : Type u_1) : Type u_1
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Type v
(Î± : Type u_8) : Type u_8
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst
{R : Type u} [non_assoc_semiring R] (s : set R) : subsemiring R
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L
 : Type
{Î± : Type u} (s1 s2 : wseq Î±) : wseq Î±
(p : â„•) [hp : fact (nat.prime p)] : â„• â†’ mv_polynomial (fin 2 Ã— â„•) â„¤
(Î± : Sort u_1) : Sort (max 1 u_1)
(k n : â„•) : multiset (fin k â†’ â„•)
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î±] : function.injective (Î» (b : Î²) (a : Î±), f a b)
(Î± : Type) : Type
{Î± : Type uu} : list Î± â†’ list Î± Ã— list Î±
(Î¹ : Type u_1) : complex_shape Î¹
(R : Type u) [ring R] : Prop
{Î± : Type u_1} {Î¹ : Type u_2} (f : Î¹ â†’ measure_theory.outer_measure Î±) : measure_theory.outer_measure Î±
{Î± : Type u} (s : stream Î±) : Î±
{L : first_order.language} : setoid (category_theory.bundled L.Structure)
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_zero_one_class M] [mul_zero_one_class N] : Type (max u_10 u_11 u_9)
(Î± : Type u) [topological_space Î±] [sigma_compact_space Î±] : â„• â†’ set Î±
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {K : nnreal} (f : Î± â†’ Î²) (hf : lipschitz_with K f) : locally_bounded_map Î± Î²
{Î± : Type u_1} {M : Type u_3} [monoid M] [monoid Î±] [mul_distrib_mul_action Î± M] : mul_action Î± (submonoid M)
 : Type
{Î± : Type u} (a : Î±) : computation Î±
{Î± : Type u_2} [decidable_eq Î±] [semigroup Î±] : semigroup (finset Î±)
(G : Type u) [topological_space G] [add_group G] : Prop
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [add_zero_class M] [add_zero_class N] : Type (max u_10 u_11 u_9)
{Î± : Type u_1} [decidable_eq Î±] (s t : multiset Î±) : multiset Î±
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_antisymm Î± r] {a b : Î±} : r a b â†’ r b a â†’ b = a
{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] : list Î± â†’ list Î±
 : Type
{f : â„• â†’ nnreal} {r : nnreal} : has_sum f r â†” filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i)) filter.at_top (nhds r)
(a : erased (Sort u)) : Sort u
{Î± : Type u_1} [encodable Î±] (a : ulower Î±) : Î±
{Î± : Type v} {d u l r : â„•} (A : matrix (fin (u + d)) (fin (l + r)) Î±) : matrix (fin u) (fin l) Î±
{Î± : Type u} [comm_semiring Î±] {p p' : Î±} {ps ps' : â„•} : p = p' â†’ ps = ps' â†’ p ^ ps = p' ^ ps'
(p : â„•) [fact (nat.prime p)] (hp : p â‰  2) (a : â„¤) : â†‘({x : zmod p | x ^ 2 = â†‘a}.to_finset.card) = zmod.legendre_sym p a + 1
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [unique_factorization_monoid Î±] [normalization_monoid Î±] [decidable_eq Î±] {a b : Î±} (ha : a â‰  0) (hb : b â‰  0) : factorization (a * b) = factorization a + factorization b
{Î± : Type u} [preorder Î±] {a : Î±} : a â‰¤ a
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] (a b : Î±) : finset Î±
(C : Type u) [category_theory.category C] : Type (max u (v+1))
(L : Type u_1) [topological_space L] [has_sup L] : Prop
(J : Type uâ‚) [category_theory.category J] : Type uâ‚
{n : â„•} (c : composition n) : â„•
(C : Type uâ‚) : Type uâ‚
{Î¹ : Type u_1} {Z : Î¹ â†’ Type u_2} [Î  (i : Î¹), canonically_ordered_monoid (Z i)] : canonically_ordered_monoid (Î  (i : Î¹), Z i)
(F : Type u â†’ Type v) [applicative F] [is_lawful_applicative F] (G : Type u â†’ Type w) [applicative G] [is_lawful_applicative G] : Type (max (u+1) v w)
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (b : Î² a) (s : alist Î²) : alist Î²
(Î± : Type u_1) (r : Î± â†’ Î± â†’ Prop) [is_preorder Î± r] : setoid Î±
 : io std_gen
{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a â‰¤ b + c â†’ a - b â‰¤ c
(p : â„•) [hp : fact (nat.prime p)] : is_domain (zmod p)
(Î± : Type u_1) [topological_space Î±] [t0_space Î±] : partial_order Î±
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_products C] : Type (max u v)
{Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s : set Î±} {r : ennreal} : emetric.inf_edist x s < r â†” âˆƒ (y : Î±) (H : y âˆˆ s), has_edist.edist x y < r
{Î± : Type u_1} [generalized_boolean_algebra Î±] : non_unital_comm_ring Î±
{Î± : Type u_1} [monoid Î±] (s t : set Î±) (a : Î±) : set (Î± Ã— Î±)
(A : Type u) [comm_ring A] [is_domain A] : Prop
{n : â„•} {Î± : Type u_1} (a : Î±) (i : fin (n + 1)) (v : vector Î± n) : vector Î± (n + 1)
(Î± : Type u_1) [monoid_with_zero Î±] [decidable_eq Î±] [decidable_pred is_square] (a : Î±) : â„¤
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] (f : equiv.perm Î±) : finset (equiv.perm Î±)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (r : Î± â†’ Î² â†’ Prop) (p : Î² â†’ Î³ â†’ Prop) (a : Î±) (c : Î³) : Prop
(Î± : Type u) [topological_space Î±] [t1_space Î±] : bornology Î±
{Î± : Type} (p : parser Î±) : parser unit
{Î± : Type u_2} [has_one Î±] : has_one (finset Î±)
{R : Type u_1} [ring R] (a b c : R) : R
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (self : subalgebra R A) : subsemiring A
{Î± : Type u_1} {P : Î± â†’ Prop} (m : Î  (s : Î±), P s â†’ ennreal) (s : Î±) : ennreal
{C : Type u} [category_theory.category C] (P : C) (f g : category_theory.over P) : Prop
{R : Type u_1} [distrib R] (r : R) : add_hom R R
(Î± : Type u_1) [complete_lattice Î±] : complete_lattice.is_Sup_finite_compact Î± â†’ well_founded gt
{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : Â¬is_right_regular 0
{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) (a : Î±) : f aâ»Â¹ = (f a)â»Â¹
(Î± : Type u_1) (Î² : Type u_2) [topological_space Î±] [topological_space Î²] [monoid Î²] [has_continuous_mul Î²] : submonoid (Î± â†’ Î²)
{Î± : Type u_1} [B : bornology Î±] (m : pseudo_metric_space Î±) (H : âˆ€ (s : set Î±), bornology.is_bounded s â†” bornology.is_bounded s) : pseudo_metric_space Î±
(X Y : Type u) : category_theory.limits.limit_cone (category_theory.limits.pair X Y)
(Î± : Type u) : Type u
(d : pos_num) : pos_num â†’ num Ã— num
(R : Type u) (A : Type v) [comm_ring R] [ring A] [algebra R A] : Prop
(Î± : Type u_6) (Î² : Type u_7) [preorder Î±] [preorder Î²] [mul_one_class Î±] [mul_one_class Î²] : Type (max u_6 u_7)
{Î± : Type u_1} (f : Î± â†’ nnreal) (s : finset Î±) (h : s.sum (Î» (a : Î±), f a) = 1) (h' : âˆ€ (a : Î±), a âˆ‰ s â†’ f a = 0) : pmf Î±
{Î± : Type u} (S : wseq (computation Î±)) : computation Î±
{K : Type u_2} [division_ring K] (a b ppredA predA : K) : K
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J â†’ C) : Prop
(Î± : Type u) : Type u
{Î± : Type u} [non_unital_non_assoc_ring Î±] {a b c d e : Î±} : a * e + c = b * e + d â†” (a - b) * e + c = d
 : Type
{Î± : Type u_1} {Î² : Type u_2} (r : setoid Î±) (f : Î± â†’ Î²) (h : setoid.ker f â‰¤ r) (hf : function.surjective f) : setoid Î²
{f : ordinal â†’ ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)
{Î¹ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape Î¹) : hom_rel (homological_complex V c)
{Î± : Type u} [t : topological_space Î±] (s : set (set Î±)) : Prop
{Î± : Type u_1} [monoid Î±] (a : Î±) : associates Î±
{Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} {s : set Î±} : emetric.inf_edist x s â‰¤ emetric.inf_edist y s + has_edist.edist x y
{Î± : Type u} [decidable_eq Î±] : list Î± â†’ list Î± â†’ bool
(M : Type u_9) (N : Type u_10) [has_zero M] [has_zero N] : Type (max u_10 u_9)
(i : â„•) : lazy_list â„•
{Î¹ : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] (BR : ring_filter_basis R) (B : Î¹ â†’ submodule R M) : Prop
{Î² : Type v} [pseudo_emetric_space Î²] {Î± : Type u} [emetric_space Î±] {f : Î± â†’ Î²} (h : isometry f) : function.injective f
{Î± : Type u_2} [has_inv Î±] : has_inv (filter Î±)
(n : â„•) : fin (n + 1)
(R : Type u) [comm_ring R] [local_ring R] : prime_spectrum R
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] : ordnode Î± â†’ ordnode Î± Ã— ordnode Î±
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [normalization_monoid Î±] [decidable_eq Î±] (h : âˆ€ (a b : Î±), âˆƒ (c : Î±), âˆ€ (d : Î±), a âˆ£ d âˆ§ b âˆ£ d â†” c âˆ£ d) : normalized_gcd_monoid Î±
{Î± : Type u} [topological_space Î±] {s : set Î±} {x : Î±} : x âˆˆ closure s â†” âˆƒ (u : ultrafilter Î±), s âˆˆ u âˆ§ â†‘u â‰¤ nhds x
{Î± : Type u_1} [Î² : normed_ring Î±] : semi_normed_ring Î±
{R : Type u_1} {X : Type u_2} [comm_semiring R] (p : â„•) [char_p R p] : char_p (free_algebra R X) p
{H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H
{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a
{k : Type uâ‚} {G : Type uâ‚‚} [semiring k] [has_one G] : has_one (monoid_algebra k G)
{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_least s a) : bdd_below s
{M : Type u_1} [mul_one_class M] (S : submonoid M) : set M
(p : â„•) [fact (nat.prime p)] (R : Type uâ‚) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple â†‘Y â†” is_atom Y
{Î± : Type u} [preorder Î±] (s : set Î±) : set Î±
{Î± : Type u} [canonically_ordered_comm_semiring Î±] [nontrivial Î±] : 0 < 1
 : â„• â†’ nat.partrec.code
{G : Type u_2} [add_group G] {a b : {R : Type u_1} {R' : Type u_2} (M : Type u_3) [has_zero R] [has_zero M] [smul_with_zero R M] [has_zero R'] (f : zero_hom R' R) : smul_with_zero R' M
{Î± : Type u_1} {Î² : Type u_2} (r : rel Î± Î²) (s : set Î±) : set Î²
{p : â„•} : padic_val_int p 1 = 0
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : set Î±
{Î± : Type u} [topological_space Î±] : set Î± â†’ set Î± â†’ Prop
(K : Type u_1) [field K] (L : Type u_2) [field L] [algebra K L] : set (intermediate_field K L)
(C : Type u) [category_theory.category C] : Type (max u v)
(n : â„•) : list (fin n)
(H : Type u_1) [topological_space H] : pregroupoid H
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
 : list pgame â†’ Type (u+1)
{Î± : Type u} (s : wseq Î±) (n : â„•) : list Î±
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (ga : Î± â†’ Î±) (gb : Î² â†’ Î²) : Prop
{Râ‚ƒ : Type u_7} [comm_ring Râ‚ƒ] {n : Type u_11} [fintype n] (J : matrix n n Râ‚ƒ) [decidable_eq n] : submodule Râ‚ƒ (matrix n n Râ‚ƒ)
{Î± : Type u} [preorder Î±] (s : set Î±) : Prop
(Î± : Type u_1) [topological_space Î±] : local_homeomorph Î± Î±
{Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a : Î±} : is_min a â†’ order.pred a = a
{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] [discrete_topology R] : inhabited (module_filter_basis R M)
{R : Type u_2} {Î“â‚€ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Î“â‚€] (v : valuation R Î“â‚€) : ideal R
(a b : pos_num) : pos_num
{Î± : Type u_2} [division_monoid Î±] : division_monoid (filter Î±)
{Î± : Type u_1} (lâ‚ lâ‚‚ : list Î±) : Prop
{K : Type u} [hring : comm_ring K] : ratfunc K â†’ ratfunc K
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.mk Lâ‚ = free_group.mk Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚
{Î± : Type u} [pseudo_emetric_space Î±] {p : Î± â†’ Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist â†‘x â†‘y
{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} (hab : a â‰  b) : closure (set.Ioc a b) = set.Icc a b
{Î¹ : Type u_1} [decidable_eq Î¹] (A : Î¹ â†’ Type u_2) [add_monoid Î¹] [Î  (i : Î¹), add_comm_monoid (A i)] : Type (max u_1 u_2)
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : 1 â‰¤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
(C : Type v) (D : Type v') [category_theory.category C] [category_theory.concrete_category C] [category_theory.category D] [category_theory.concrete_category D] : Type (max u_1 u_2 v v')
 : Type
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (Î¦ : submodule R (module.dual R M)) : submodule R M
{m : Type u_1 â†’ Type u_2} [alternative m] {Î± : Type u_3} {Î² : Type u_1} (f : Î± â†’ m Î²) : lazy_list Î± â†’ m Î²
(Î± : Type u_1) [complete_lattice Î±] : Prop
 : Type (u_1+1)
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : finset V
 : category_theory.category algebraic_geometry.Scheme
(Î± : Type u_2) [has_le Î±] : Prop
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : with_top Î± â†’ with_top Î²
{Î± : Type u_1} [semigroup Î±] : has_dvd Î±
{Î± : Type u} [topological_space Î±] (s : set Î±) : Prop
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : 0 â‰¤ metric.diam s
{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 âˆˆ interior â†‘H) : is_open â†‘H
(x y : Set) : Set
{Î± : Type u_1} [has_le Î±] [decidable_rel has_le.le] (x y : Î±) : ordering
{R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
{M : Type u_1} [comm_monoid M] (S : submonoid M) : localization S â†’ localization S â†’ localization S
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0
{Î± : Type u_1} (G : simple_graph Î±) (n : â„•) : Prop
{Î± : Type u_1} {Î² : Type u_2} [tÎ± : topological_space Î±] [tÎ² : topological_space Î²] (f : Î± â†’ Î²) : Prop
(Mâ‚€ : Type u_4) : Type u_4
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd
{Î± : Type u_1} [has_one Î±] [has_add Î±] [z : has_zero Î±] : num â†’ Î±
(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : Prop
 : Type
(R : Type u) [semiring R] [nontrivial R] (p : â„•) [hp : char_p R p] [hq : exp_char R 1] : p = 0
{M : Type u_1} [monoid M] {x : M} : 1 âˆˆ powers x
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) : Prop
(Î± : Type u_1) [t : topological_space Î±] : Prop
(Î± : Type u_2) : Type u_2
{Î± : Type u_2} [division_comm_monoid Î±] : division_comm_monoid (set Î±)
{X : Type u_1} [topological_space X] (S : discrete_quotient X) : setoid X
{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (Ï : representation k G V) : submodule k V
{Î± : Type u_1} {Î¹ : Type u_2} [semilattice_inf Î±] [order_bot Î±] (s : set Î¹) (f : Î¹ â†’ Î±) : Prop
{Î± : Type u_1} (a : Î±) : pmf Î±
{Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a â‰¤ b â†’ a â‰¤ c
{Î± : Type u_1} {Î² : Type u_2} [fintype (Î± âŠ• Î²)] : fintype Î±
(Î± : Type u) : Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C
(m : Type â†’ Type u) [monad m] : Type (max 1 u)
(R : Type u) (Î¹ : Type u') [decidable_eq Î¹] [comm_semiring R] (A : Type u_1) [comm_semiring A] [algebra R A] [fintype Î¹] : multilinear_map R (Î» (i : Î¹), A) A
{G : Type u_1} [add_group G] (H K : add_subgroup G) : Prop
(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] : Compactum
{Ï„ : Type u_1} {Î± : Type u_2} [canonically_ordered_add_monoid Ï„] {Ï• : Ï„ â†’ Î± â†’ Î±} {s : set Î±} : is_fw_invariant Ï• s â†” is_invariant Ï• s
{Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} : emetric.Hausdorff_edist s s = 0
{Î± : Type u_1} [denumerable Î±] : denumerable (finset Î±)
(Î± : Type u_1) : Type u_1
(R : Type u) [comm_ring R] : Type u
(Î± : Type u_1) (n : â„•) : Type u_1
 : turing.to_partrec.code
{Î± : Type u} : seq Î± â†’ â„• â†’ option Î±
{A : Type u_1} {B : Type u_2} [fintype B] [set_like A B] : fintype A
(c : Type u â†’ Type v) : Type (max (u+1) v)
{Î“ : Type u_1} [inhabited Î“] (f : Î“ â†’ Î“) : â„• â†’ turing.list_blank Î“ â†’ turing.list_blank Î“
(X : Top) : CompHaus
(n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) (s : set Î±) : local_homeomorph Î± Î²
{Î± : Type u} [mul_zero_class Î±] [has_distrib_neg Î±] : -0 = 0
(R : Type u) [comm_semiring R] (A : Type v) [comm_semiring A] [algebra R A] : module (set_semiring A) (submodule R A)
(n : â„•) : â„•
(Î± : Type u_1) [topological_space Î±] [quasi_sober Î±] [irreducible_space Î±] : Î±
{Î± : Type u_1} [ordered_semiring Î±] [floor_semiring Î±] : Î± â†’ â„•
{X : Type u_1} [topological_space X] [topological_space.first_countable_topology X] : sequential_space X
{F : Type} [comm_semiring F] (q : â„•) (f : polynomial F) : Prop
(C : Type u) [category_theory.category C] : Prop
(Î± : Type u_8) : Type u_8
{Î¹ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape Î¹) : Type (max u u_1 v)
{Î± : Type u} : lazy_list (lazy_list Î±) â†’ lazy_list Î±
 : category_theory.limits.has_colimits_of_size (Type (max v u))
{S : Type u_1} [has_add S] (a : S) : add_commute a a
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (l : Î± â†’ Î²) (u : Î² â†’ Î±) : Type (max u v)
{Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²) : Prop
(n : â„•) : Type
 : monad filter
{G : Type u_1} [add_group G] (S : set G) : add_subgroup G
{Î± : Type u} [has_neg Î±] (as : list Î±) : list Î±
{X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] (f : Y â†’ Z) : locally_constant X Y â†’ locally_constant X Z
(m n : â„•) : Type
{M : Type u_1} [monoid M] {Î³ : Type u_2} [monoid Î³] {f : M â†’ Î³} (hf : is_monoid_hom f) : is_submonoid (set.range f)
{Î± : Type u_1} (V : set (Î± Ã— Î±)) : Prop
{Î± : Type u_1} (a : Î±) : generalized_continued_fraction Î±
{n : â„•} (x y : bitvec n) : bool
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : b â‰¤ -a + c â†’ a + b â‰¤ c
{R : Type u} [non_assoc_semiring R] : has_inf (subsemiring R)
(Î± : Type u_1) [bornology Î±] : Born
{Î³ : Type u_1} {Î² : Type u_2} (f : Î³ â†’ Î²) (hf : function.injective f) (m : metric_space Î²) : metric_space Î³
(Î± : Type u) : Type u
{Î± : Type u_1} [decidable_eq Î±] {a : Î±} {z : sym2 Î±} (h : a âˆˆ z) : Î±
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : Â¬is_smul_regular M 0
 : Type 1
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] : pseudo_emetric_space (Î± Ã— Î²)
 : nzsnum â†’ snum
{J : Type uâ‚} [category_theory.category J] [nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), category_theory.zigzag jâ‚ jâ‚‚) : category_theory.is_connected J
(R : Type u) [non_assoc_ring R] (p : â„•) [hc : char_p R p] [fintype R] : p â‰  0
{M : Type u_1} [comm_monoid M] (S : submonoid M) : Type u_1
(R : Type u) [semiring R] : SemiRing
(R : Type u) {A : Type w} [comm_ring R] [semiring A] [algebra R A] : ring A
{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), n â‰¤ m â†’ P n â†’ P (n - 1)) (n : â„¤) : n â‰¤ m â†’ P n
(B : Type u) : Type u
(M : Type u_1) [cancel_monoid_with_zero M] [decidable_eq M] [fintype M] [nontrivial M] : group_with_zero M
{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] : has_one (one_hom M N)
{Î± : Type u} (a : Î±) : ordnode Î±
 : parser char
(Î“ : Type u_1) (R : Type u_2) [linear_ordered_add_comm_group Î“] [ring R] [is_domain R] : add_valuation (hahn_series Î“ R) (with_top Î“)
{Î¹ : Type u_1} {Z : Î¹ â†’ Type u_2} [Î  (i : Î¹), ordered_comm_monoid (Z i)] : ordered_comm_monoid (Î  (i : Î¹), Z i)
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : âˆ€ (x y : Î±), f (x + y) = f x + f y) : is_add_group_hom f
 : path {down := 0} {down := 1}
{Ïƒâ‚ : Type u_1} {Ïƒâ‚‚ : Type u_2} (fâ‚‚ : Ïƒâ‚‚ â†’ option Ïƒâ‚‚) (tr : Ïƒâ‚ â†’ Ïƒâ‚‚) (aâ‚‚ : Ïƒâ‚‚) : option Ïƒâ‚ â†’ Prop
(P : Type u_2) [preorder P] : Type u_2
(Î± : Type u_2) : Type u_2
(R : Type u) : Type u
{Î± : Type u_1} [topological_space Î±] [polish_space Î±] [measurable_space Î±] [borel_space Î±] {s : set Î±} (hs : measurable_set s) : polish_space.is_clopenable s
{Î± : Type u} {Î² : Type v} : Î± âŠ• Î² â†’ option Î±
{n m : â„•} (i : fin m) (h : i.val < n) : fin n
{Î± : Type u_1} : ordnode Î± â†’ Î± â†’ ordnode Î± â†’ ordnode Î±
(ð•œ : Type u_5) (ð•œ' : Type u_6) [normed_field ð•œ] [semi_normed_ring ð•œ'] : Type (max u_5 u_6)
(Î± : Type u_1) : Type u_1
{Î± : Type u_1} [topological_space Î±] : inhabited (topological_space.compacts Î±)
{R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) : lie_subalgebra R L
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [topological_space Î²] [preorder Î¹] [measurable_space Î¹] (f : measure_theory.filtration Î¹ m) (u : Î¹ â†’ Î± â†’ Î²) : Prop
{G : Type u_1} [hG : group G] [hf : fintype G] {p : â„•} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G
{Î± : Type u} {n m : â„•} [has_repr Î±] : has_repr (matrix (fin m) (fin n) Î±)
{C : Type uâ‚} [category_theory.category C] {X : C} (S : category_theory.presieve X) : category_theory.limits.cocone S.diagram
{M : Type u_1} [add_monoid M] (s : set M) : set M
{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a
 : Type
 : set upper_half_plane
 : znum â†’ znum
{Î± : Type u_1} (r : setoid Î±) : set (set Î±)
{Î± : Type u_1} [iâ‚ : linear_order Î±] [iâ‚‚ : order_bot Î±] (h : well_founded has_lt.lt) : conditionally_complete_linear_order_bot Î±
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : function.injective (quotient.lift f _)
{Î± : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space Î±] [has_neg E] (f : measure_theory.simple_func Î± E) : measure_theory.simple_func Î± E
(Î± : Type u_1) (Î² : Type u_2) [has_le Î±] [has_le Î²] : Type (max u_1 u_2)
{R : Type u_1} [ring R] (p q : polynomial R) : polynomial R
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] (f : Î² â†’ Î±) (l : filter Î²) : filter.tendsto (Î» (x : Î²), (f x, f x)) l (uniformity Î±)
{Î± : Type u_1} : list (poly Î±) â†’ poly Î±
{C : Type u} [category_theory.category C] {Jâ‚ Jâ‚‚ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf Jâ‚ (category_theory.functor.closed_sieves Jâ‚‚)) : Jâ‚ â‰¤ Jâ‚‚
(R : Type u_1) [comm_ring R] (K : Type u_5) [comm_ring K] [algebra R K] : Prop
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K
{P : â„¤ â†’ Prop} [decidable_pred P] (b : â„¤) (Hb : âˆ€ (z : â„¤), P z â†’ b â‰¤ z) (Hinh : âˆƒ (z : â„¤), P z) : {lb // P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z}
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) : chain_complex C â„•
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (m : pseudo_metric_space Î²) : pseudo_metric_space Î±
{m : Type u â†’ Type v} [monad m] {Î± : Type u} : option (m Î±) â†’ m (option Î±)
(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] : CompHaus
{M : Type u_2} [add_comm_monoid M] {G : Type u_5} [group G] [distrib_mul_action G M] {R : Type u_1} : mul_action G (ray_vector R M)
(k : Type u_1) (G : Type u_2) (V : Type u_3) [comm_semiring k] [monoid G] [add_comm_monoid V] [module k V] : Type (max u_3 u_2)
{M : Type u_1} [add_zero_class M] : has_inf (add_submonoid M)
{Î± : Type u_1} [has_one Î±] [has_zero Î±] [has_lt Î±] (s : simple_continued_fraction Î±) : Prop
{m : Type u â†’ Type u} [applicative m] {Î± Î² : Type u} (f : Î± â†’ m Î²) : lazy_list Î± â†’ m (lazy_list Î²)
(n : â„•) : finset â„•
{M : Type u_1} [monoid M] (s : set M) : M â†’ Prop
(n : â„•) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 â‰¤ x) : 0 â‰¤ polynomial.eval x (polynomial.cyclotomic n R)
{Mâ‚‚ : Type u_2} {Mâ‚ : Type u_1} [has_inv Mâ‚] [has_involutive_inv Mâ‚‚] (f : Mâ‚ â†’ Mâ‚‚) (hf : function.injective f) (inv : âˆ€ (x : Mâ‚), f xâ»Â¹ = (f x)â»Â¹) : has_involutive_inv Mâ‚
(Î± : Type u) : set (set (ultrafilter Î±))
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop
{Î± : Type u_1} (s : cycle Î±) : â„•
{M : Type u_1} [add_comm_monoid M] [module ennreal M] : module nnreal M
(L : first_order.language) : L.Theory
{Î± : Type u} {Î² : Type v} [preorder Î²] (f : Î± â†’ Î²) (l : filter Î±) (a : Î±) : Prop
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A Ã— B) B
 : num â†’ num â†’ num
(l : Type u_4) (R : Type uâ‚‚) [decidable_eq l] [comm_ring R] : matrix (unit âŠ• l âŠ• l) (unit âŠ• l âŠ• l) R
{A : Type u_1} {Î¹ : Type u_2} [ring A] (B : Î¹ â†’ add_subgroup A) : Prop
{Î± : Type u_1} {Î² : Type u_2} [non_unital_semi_normed_ring Î±] [non_unital_semi_normed_ring Î²] : non_unital_semi_normed_ring (Î± Ã— Î²)
{Î± : Type u_1} [comm_semiring Î±] (E : linear_recurrence Î±) (init : fin E.order â†’ Î±) : â„• â†’ Î±
{p : â„•} {R : Type u_1} [comm_ring R] (n : â„•) : witt_vector p R â†’ witt_vector p R
{Î± : Type u_1} {Î² : Type u_2} (q : semiquot Î±) (f : Î± â†’ semiquot Î²) : semiquot Î²
(p : Set â†’ Prop) : Class
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (s : set Î±) : Prop
(Î± : Type u_1) : Type u_1
(Î± : Type u_2) [has_lt Î±] : Prop
{Î± : Type u} [has_zero Î±] [has_sub Î±] : list Î± â†’ list Î± â†’ list Î±
(n : â„•) : Prop
{Î± : Type u} (sâ‚ sâ‚‚ : stream Î±) : stream Î±
{Î± : Type u_1} (s : cycle Î±) : cycle Î±
{Î± : Type u_1} {n : â„•} (f : fin n â†’ Î±) : list Î±
{C : Type uâ‚} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject A
(Î± : Type u_2) [fintype Î±] [nonempty Î±] [semilattice_sup Î±] : order_top Î±
{X : Type u_1} [topological_space X] {x y : X} (Î³ : path x y) : path y x
{Î± : Type u} [emetric_space Î±] : continuous (Î» (p : Î± Ã— topological_space.closeds Î±), emetric.inf_edist p.fst â†‘(p.snd))
 : Type
 : â„• â†’ â„• â†’ â„•
{R : Type u} [ring R] (s : set R) (sm : submonoid R) (sa : add_subgroup R) (hm : â†‘sm = s) (ha : â†‘sa = s) : subring R
{Î± : Type u_1} [decidable_eq Î±] : âˆ….shadow = âˆ…
{Î± : Type u} [preorder Î±] (s : set Î±) (a : Î±) : Prop
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (p : pmf Î±) : pmf Î²
(Î± : Type u) : Type u
 : Type
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A Ã— B) (B Ã— A)
{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length
{Î± : Type u_1} [topological_space Î±] {s t : set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t) : is_GÎ´ (s âˆª t)
(p : â„•) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] (m : â„¤) : Type u_1
 : Type
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] [topological_space Î±] (F : Î¹ â†’ Î± â†’ Î²) (f : Î± â†’ Î²) (p : filter Î¹) : Prop
{Î± : Type u} [topological_space Î±] [nonempty Î±] (f : filter Î±) : Î±
(Î± : Type u_1) [lattice Î±] [bounded_order Î±] : BoundedLattice
{Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] (a : Î±) : equiv.perm Î²
{S : Type u_1} [has_add S] (a b : S) : Prop
{Î± : Sort u} {Î² : Î± â†’ Sort v} [decidable_eq Î±] (f : Î  (a : Î±), Î² a) (a' : Î±) (v : Î² a') (a : Î±) : Î² a
(J : Type v) [category_theory.small_category J] : Type v
 : pos_num â†’ pos_num â†’ num
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) : Prop
 : Â¬summable (Î» (n : â„•), 1 / â†‘n)
{Î± : Type u_1} [measurable_space Î±] (s : measure_theory.signed_measure Î±) : measure_theory.measure Î±
(oâ‚ oâ‚‚ : onote) : onote
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : Type v
(Î± : Type u_7) (Î² : Type u_8) [has_sup Î±] [has_sup Î²] [has_bot Î±] [has_bot Î²] : Type (max u_7 u_8)
 : pSet â†’ pSet
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ -b â†’ b â‰¤ -a
{Î± : Type u} [partial_order Î±] {a b : Î±} (h : a â‰¤ b) : b = a âˆ¨ a < b
{Î± : Type u_1} (x : Î±) : free_monoid Î±
{S : set â„•} (hb : 0 âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) (n : â„•) : n âˆˆ S
{R : Type u} [comm_semiring R] (p : â„•) (f : polynomial R) : polynomial R
(Î± : Type u) : Type u
(M : Type u_1) [sub_neg_monoid M] [measurable_space M] [has_measurable_addâ‚‚ M] [has_measurable_neg M] : has_measurable_smulâ‚‚ â„¤ M
 : Type
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : -a â‰¤ -b â†’ b â‰¤ a
{F : Type u_1} (Î± : Type u_3) (Î² : Type u_4) [linear_order Î±] [lattice Î²] [order_hom_class F Î± Î²] (f : F) : lattice_hom Î± Î²
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : option Î± â†’ Î² â†’ Î³) (as : list Î±) (bs : list Î²) : list Î³ Ã— list Î±
(G : Type u_1) [group G] : â„• â†’ subgroup G
{Î± : Type u_1} {Î² : Type u_2} [denumerable Î±] [denumerable Î²] : denumerable (Î± Ã— Î²)
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ð’œ : â„• â†’ submodule R A) [graded_algebra ð’œ] : algebraic_geometry.LocallyRingedSpace
(V : Type u) [quiver V] [quiver.arborescence V] : V
{n : â„•} {F : typevec n â†’ Type u_1} [mvfunctor F] (q : mvqpf F) : Prop
{Î± : Type u} [topological_space Î±] : ultrafilter Î± â†’ Î±
(Î± : Type u_1) : Type u_1
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] (Kâ‚€ : topological_space.positive_compacts G) : measure_theory.measure G
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : a â‰¤ b * c â†’ bâ»Â¹ * a â‰¤ c
(Î± : Type u_1) [measurable_space Î±] : Type u_1
(Î± : Type u) : Type u
{R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R â‰  2) {a : R} : -a = a â†” a = 0
 : Type
{V : Type u} (G : simple_graph V) (u v : V) : Prop
{K : Type u_1} [is_R_or_C K] : char_zero K
(G : Type u_2) [group G] (n : â„•) : set (vector G n)
{M : Type u_3} {N : Type u_4} [has_add M] [add_comm_semigroup N] : has_add (add_hom M N)
{Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} : continuous (Î» (x : Î±), emetric.inf_edist x s)
 : pgame â†’ pgame â†’ Prop
 : complex_shape â„•
{Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : (a * d - b * c) / (c * d) â‰¤ 0 â†’ a / c â‰¤ b / d
{Î± : Type u_1} [topological_space Î±] {U : set Î±} {hU : is_open U} : â†‘âŸ¨U, hUâŸ© = U
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î²] [measurable_space Î±] (f : Î± â†’ Î²) : Prop
{R : Type u} {M : Type v} (x : triv_sq_zero_ext R M) : R
 : â„¤
{n : â„•} (a : fin (n + 1)) : â†‘(a.val) = a
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_open_map Z.proj
{n : â„•} {A : Type u} (F : A â†’ typevec n â†’ Type u) [Î  (Î± : A), mvfunctor (F Î±)] [Î  (Î± : A), mvqpf (F Î±)] : mvpfunctor n
{Î± : Type u_3} {Î² : Type u_4} [lattice Î±] [lattice Î²] [bounded_order Î±] [bounded_order Î²] (f : bounded_lattice_hom Î± Î²) : inf_top_hom Î± Î²
{R : Type u_2} {Î“â‚€ : Type u_3} {Î“'â‚€ : Type u_4} [linear_ordered_add_comm_monoid_with_top Î“â‚€] [linear_ordered_add_comm_monoid_with_top Î“'â‚€] [ring R] (vâ‚ : add_valuation R Î“â‚€) (vâ‚‚ : add_valuation R Î“'â‚€) : Prop
{X : Type u} [topological_space X] {xâ‚€ xâ‚ : X} (pâ‚€ pâ‚ : path xâ‚€ xâ‚) : Type u
(Î± : Type u) [uniform_space Î±] : Type (u+1)
{C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X) : category_theory.limits.is_terminal X
(Î± : Type u_1) : set (equiv.perm Î±)
(Î± : Type u_2) [ordered_add_comm_monoid Î±] : Prop
(K : Type u_4) (V : Type u) [division_ring K] [add_comm_group V] [module K V] : set V
(Î± : Type u_1) : Type u_1
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) : list (sigma Î²) â†’ option (Î² a)
{Î± : Type u_1} {M : Type u_5} [has_one M] (f : Î± â†’ M) : set Î±
(Î± : Type u_1) [topological_space Î±] : cocompact_map Î± Î±
{G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order xâ»Â¹
{Î± : Type u} [linear_order Î±] {x y : Î±} : x < y âˆ¨ y < x â†” x â‰  y
(n : â„•) : âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n
{V : Type u} (G : simple_graph V) : V â†’ V â†’ Type u
{Î± : Type u_1} {Î² : Type u_2} (s : multiset Î±) (t : multiset Î²) : multiset (Î± Ã— Î²)
{R : Type u} : R â†’ tropical R
{Î± : Type u} [topological_space Î±] (K : compact_exhaustion Î±) (x : Î±) : â„•
{Î¹ : Type u_1} {Î± : Type u_3} {Î² : Type u_4} [preorder Î±] [preorder Î²] (f : Î¹ â†’ Î±) (g : Î¹ â†’ Î²) (s : set Î¹) : Prop
{C : Type uâ‚} (D : Type uâ‚‚) [category_theory.category D] (F : C â†’ D) : Type uâ‚
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [compact_space Î±] [separated_space Î±] {f : Î± â†’ Î²} (h : continuous f) : uniform_continuous f
(Î± : Type u) [topological_space Î±] : Prop
{Î± : Type u} [non_unital_ring Î±] {a b c : Î±} (h : a âˆ£ c) : a âˆ£ b + c â†” a âˆ£ b
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : set Î±) (t : set Î²) : Prop
{Î¹ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Î¹ â†’ set X} {s : set X} (c : set (shrinking_lemma.partial_refinement u s)) : set Î¹
(Î± : Type u) [preorder Î±] : Type (max 1 u)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.split_mono category_theory.limits.coprod.inr
 : list â„• â†’ â„• â†’ list â„•
{Î± : Type u_1} [denumerable Î±] : denumerable (ulift Î±)
{Î± : Type u_1} : subsingleton (vector Î± 0)
{Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f) : filter.tendsto f filter.cofinite filter.cofinite
{Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] {x : Î±} : continuous (Î» (f : bounded_continuous_function Î± Î²), â‡‘f x)
{Î³ : Type w} [metric_space Î³] {x y : Î³} : has_nndist.nndist x y = 0 â†’ x = y
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] (K : submodule ð•œ E) : submodule ð•œ E
{Î± : Type u_1} [add_comm_monoid Î±] [topological_space Î±] {Î² : Type u_2} (f : Î² â†’ Î±) : Î±
 : â„•
(C : Type u) [category_theory.category C] : Prop
{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} (C : homological_complex V c) : homotopy_equiv C C
(Î± : Type u) (Î² : Type v) [topological_space Î±] [pseudo_metric_space Î²] : Type (max u v)
{Î± : Type u} [uniform_space Î±] (f : filter Î±) : Prop
(Î± : Type u_1) [monoid Î±] : Type u_1
 : Type
{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : set.Iio a âŠ† set.Iic b
(M : Type u) : Type u
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {n : â„•} (hn : finite_dimensional.finrank K V = n.succ) : nontrivial V
{R : Type u} [semiring R] (p : polynomial R) (a : R) : Prop
{Î± : Type u_1} {Î² : Type u_2} (b : Î²) (f : Î± â†’ Î²) : option Î± â†’ Î²
{Î± : Type u} {Î² : Type v} [omega_complete_partial_order Î±] [omega_complete_partial_order Î²] (f : Î± â†’ Î²) : Prop
(k : â„•) {n : â„•} : fin2 n â†’ fin2 (k + n)
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (o : option Î±) : option Î±
{n : â„•} (i : bitvec n) : fin (2 ^ n)
(n : â„•) : filter.tendsto (Î» (x : â„), x ^ n * real.exp (-x)) filter.at_top (nhds 0)
{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] {s : set Î±} (hs : is_compact s) : bdd_below s
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : continuous proj
{Î± : Type u_1} [topological_space Î±] [non_assoc_ring Î±] [has_continuous_mul Î±] : has_continuous_neg Î±
{Î± : Type u_4} {Î² : Type u_5} (r : Î± â†’ Î± â†’ Prop) (s : Î² â†’ Î² â†’ Prop) : Type (max u_4 u_5)
{Î± : Type u_1} : partial_order (part Î±)
(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] : category_theory.limits.has_binary_coproducts C
{Î“ : Type u_1} [inhabited Î“] : list Î“ â†’ turing.list_blank Î“ â†’ turing.list_blank Î“
{Î± : Type u_1} (s : seq Î±) : computation (list Î±)
{Î± : Type u_1} (c : set (set Î±)) : Prop
{C : Type u} [category_theory.category C] (ð’¢ : set C) : Prop
{R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (N P : submodule R M) : ideal R
{R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R) : is_coprime (â†‘g 1 0) (â†‘g 1 1)
(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_anti f
(G : Type u) [add_comm_group G] : AddCommGroup
(Î± : Type u) : Type u
{Î± : Type u} : ordnode Î± â†’ option (Î± Ã— ordnode Î±)
{C : Type u} [category_theory.category C] (X Y : C) : Prop
{Î± : Type u_1} (op : Î± â†’ Î± â†’ Î±) [hc : is_commutative Î± op] [ha : is_associative Î± op] : Î± â†’ multiset Î± â†’ Î±
{Î± : Sort u} : Î± â†’ plift Î±
{C : Type uâ‚} [category_theory.category C] {A : Type uâ‚‚} [category_theory.category A] {J : category_theory.grothendieck_topology C} (â„± : category_theory.Sheaf J A) (E : A) : category_theory.SheafOfTypes J
(Mâ‚€ : Type u_4) : Type u_4
{Î± : Type u_1} {Î² : Type u_2} (r : rel Î± Î²) : set Î²
(S : Type u) : Type u
 : turing.to_partrec.code
{R : Type u} [non_assoc_semiring R] (s : set R) : â†‘(subsemiring.closure s) = â†‘(add_submonoid.closure â†‘(submonoid.closure s))
 : snum â†’ snum
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} [topological_space Î³] (di : dense_inducing i) (f : Î± â†’ Î³) (b : Î²) : Î³
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] [measurable_space Î²] (f : measure_theory.simple_func Î² Î³) (g : Î± â†’ Î²) (hgm : measurable g) : measure_theory.simple_func Î± Î³
(R : Type u) [ring R] (E : Type v) [add_comm_group E] [module R E] (F : Type w) [add_comm_group F] [module R F] : Type (max v w)
{R : Type u_1} [comm_semiring R] {A : Type u} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] (s : subalgebra R A) : subalgebra R A
 : onote â†’ onote â†’ onote
 : bounded_order Prop
{b m d : â„•} (hb : 2 â‰¤ b) (hd : d âˆˆ b.digits m) : d < b
{G : Type u} [monoid G] (x : G) : â„•
{Î¹ : Type u_1} {Î± : Type u_2} [add_monoid Î¹] (l : list Î±) (fÎ¹ : Î± â†’ Î¹) : Î¹
{Î± : Sort u} [is_empty Î±] (Î² : Î± â†’ Sort v) : unique (Î  (a : Î±), Î² a)
(R : Type uâ‚) (L : Type uâ‚‚) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
(R : Type u_2) [ring R] (Î“â‚€ : Type u_3) [linear_ordered_add_comm_monoid_with_top Î“â‚€] : Type (max u_2 u_3)
{Î± : Type u_1} [has_zero Î±] [has_one Î±] [has_add Î±] [has_neg Î±] : znum â†’ Î±
{Î¹ : Type u_1} (A : Î¹ â†’ Type u_2) [add_monoid Î¹] [graded_monoid.gmonoid A] {i : Î¹} : mul_action (A 0) (A i)
(C : Type u) [category_theory.category C] : Type (max v u)
{Î± : Type u_1} [ring Î±] : complete_semilattice_Inf (ring_topology Î±)
(V : Type u) : Type u
(p : â„•) [hp : fact (nat.prime p)] : â„• â†’ mv_polynomial â„• â„¤
{m : Type â†’ Type u_1} [monad m] {Î± : Type u_2} (f : Î± â†’ Î± â†’ m unit) : list Î± â†’ m unit
{Î± : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul Î±] [add_comm_monoid Î±] (A : matrix m n Î±) [fintype n] : Prop
(V : Type u) : simple_graph V
{G : Type u_1} [group G] (K V : set G) : â„•
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [has_le Î±] [has_le Î²] [bounded_order Î±] [bounded_order Î²] : Type (max u_6 u_7 u_8)
{p : â„•} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : witt_vector p R
{Î¹ : Type u_1} (A : Î¹ â†’ Type u_2) [has_add Î¹] : Type (max u_1 u_2)
{Î± : Type u} : lazy_list Î± â†’ â„• â†’ option Î±
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_equalizers C
{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a < b â†’ order.succ a < order.succ b
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [wo : is_well_order Î± r] : ordinal
{n : â„•} (i : fin (n + 2)) : fin (n + 1)
(Î± : Type u) [has_mul Î±] [has_le Î±] : Prop
{Î± : Type u} {Ïƒ' : Type v} (M : DFA Î± Ïƒ') : NFA Î± Ïƒ'
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [non_unital_non_assoc_ring Î±] [non_unital_non_assoc_ring Î²] [topological_ring Î±] [topological_ring Î²] : topological_ring (Î± Ã— Î²)
{Î± : Type u_2} {Î² : Type u_3} [decidable_eq Î±] [has_vsub Î± Î²] : has_vsub (finset Î±) (finset Î²)
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : setoid (ray_vector R M)
{Î± : Type u_1} [has_add Î±] [has_le Î±] (a : Î±) : Prop
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [preorder Î±] [preorder Î²] : Type (max u_6 u_7 u_8)
{n : â„•} (c : composition_as_set n) (i : fin c.length) : â„•
{S : Type u} [has_mul S] {a x y : S} (h : semiconj_by a x y) : a * x = y * a
{Î± : Sort u_1} [is_empty Î±] {p : Î± â†’ Sort u_2} (a : Î±) : p a
{n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) : fin.cons (q 0) (fin.tail q) = q
 : Type
(Î± : Type u) : Type u
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [comm_semiring R] (s : subsemiring R) (m : multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
(Gâ‚€ : Type u_4) [has_zero Gâ‚€] [has_inv Gâ‚€] [topological_space Gâ‚€] : Prop
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] : Prop
{Î±  : Type (u+1)
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
{Î± : Type u_2} [division_monoid Î±] : division_monoid (set Î±)
{Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : has_add.add x âˆ˜ has_add.add y = has_add.add (x + y)
{b : â„•} {S : set â„•} (hb : b âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) {n : â„•} (hbn : b â‰¤ n) : n âˆˆ S
 : list name
{Î¹ : Type u_1} [encodable Î¹] {E : Î¹ â†’ Type u_2} [Î  (n : Î¹), topological_space (E n)] [âˆ€ (n : Î¹), polish_space (E n)] : polish_space (Î£ (n : Î¹), E n)
{n : â„•} : 0 < n â†’ 0 < szemeredi_regularity.step_bound n
{M : Type u_1} [add_monoid M] {x : M} : x âˆˆ multiples x
 : Type
{R : Type u} [non_assoc_semiring R] (self : subsemiring R) : add_submonoid R
 : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)
{G : Type u_1} [has_mul G] : G â†’ G â†’ G
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn
{m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] (M : matrix m m R) : Prop
{Î¹ : Type u_1} {Î² : Î¹ â†’ Type u_2} [linear_order Î¹] [is_well_order Î¹ has_lt.lt] [Î  (a : Î¹), linear_order (Î² a)] : linear_order (lex (Î  (i : Î¹), Î² i))
(f : ordinal â†’ ordinal) : ordinal â†’ ordinal
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C
{R : Type u} [semiring R] (p : polynomial R) : finset R
 : pnat.xgcd_type â†’ pnat.xgcd_type
{G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x â†” is_of_fin_add_order x
{X : Type u_1} : alexandroff X
{X : Type u_1} [topological_space X] [preconnected_space X] [noncompact_space X] : connected_space (alexandroff X)
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ option Î±
(T : Type u) [topological_space T] : category_theory.pretopology (topological_space.opens T)
 : parser â„•
{n : Type u_3} {Î± : Type v} [fintype n] [semiring Î±] [star_ring Î±] : star_ring (matrix n n Î±)
(Î± : Type u_7) (Î² : Type u_8) [lattice Î±] [lattice Î²] : Type (max u_7 u_8)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A Ã— B) A
{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (Î» (g : G Ã— G), g.fst * g.snd * (g.fst)â»Â¹)
 : lattice circle_deg1_lift
{G : Type u_1} [group G] : has_inf (subgroup G)
{Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±] : has_sum (Î» (b : Î²), 0) 0
 : Type
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [polish_space Î²] {f : Î± â†’ Î²} (hf : closed_embedding f) : polish_space Î±
{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : âˆƒ (a : Î“) (l' : turing.list_blank Î“), l = turing.list_blank.cons a l'
{Î± : Sort u_1} {p : Î± â†’ Prop} (P : âˆƒ (a : Î±), p a) : p P.some
(X : Type u) [add_group X] : AddGroup
(n : â„•) : â„•
{Î± : Type u_1} (sâ‚ sâ‚‚ : multiset Î±) : multiset Î±
{R : Type u} [field R] (p q : polynomial R) : polynomial R
{Î± : Type u} (x : Î±) : dlist Î± â†’ dlist Î±
(Î± : Type u_1) [has_one Î±] [has_zero Î±] [has_lt Î±] : Type u_1
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (N : submodule R M) : submodule R M
{Î± : Type u_2} [decidable_eq Î±] [monoid Î±] : monoid (finset Î±)
 : Type
{Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : Î±) : uv.compress u v (uv.compress u v a) = uv.compress u v a
{Î± : Type} (sep : parser unit) (p : parser Î±) : parser (list Î±)
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} : x â‰  y â†’ r x y â†” r x y
{Î± : Type u_1} [topological_space Î±] [ring Î±] [topological_ring Î±] (S : subring Î±) : subring Î±
{R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (t : finset Î¹) (w : Î¹ â†’ R) (z : Î¹ â†’ E) : E
(n : â„•) : â„• â†’ â„•
(G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)
{Î± : Type u_1} {Î² : Type u_2} [encodable Î±] [encodable Î²] : encodable (Î± âŠ• Î²)
{p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2
(c d : â„•) : â„¤ â†’ â„¤ â†’ Prop
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (g : Î² â†’ Î³) (f : Î± â†’ Î²) : list.map g âˆ˜ list.map f = list.map (g âˆ˜ f)
{X : Type u_1} {Î± : Type u_2} [has_zero Î±] [topological_space X] (f : X â†’ Î±) : set X
{R : Type u_1} [mul_zero_class R] : Â¬is_right_regular 0 â†” nontrivial R
 : Type
(F : Type u_1) (K : Type u_2) [field F] [comm_ring K] [is_domain K] [algebra F K] [finite_dimensional F K] : field K
{G : Type w} [topological_space G] [group G] [topological_group G] (s : subgroup G) : subgroup G
{C : Type u} [category_theory.category C] {Î¹ : Type u_1} (s : Î¹ â†’ C) : Prop
{Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²) : Prop
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} (h : y âˆˆ s) : metric.inf_dist x s â‰¤ has_dist.dist x y
(L : first_order.language) {M : Type u_3} (s : setoid M) : Type (max u_1 u_2 u_3)
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (sâ‚ sâ‚‚ : alist Î²) : alist Î²
{X : Type u_2} [emetric_space X] (m : ennreal â†’ ennreal) : measure_theory.outer_measure X
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : has_coe (matrix.special_linear_group n â„¤) (matrix.special_linear_group n R)
{Î± : Type u_1} [is_empty Î±] (s : finset Î±) : s = âˆ…
 : list name
(Î± : Type u) : Type (max u (v+1))
(Î± : Type u_1) [preorder Î±] : Type u_1
{Î± : Type u_1} [topological_space Î±] [comm_ring Î±] [topological_ring Î±] (S : ideal Î±) : ideal Î±
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : basis (module.free.choose_basis_index R M) R M
(C : Type u_1) [category_theory.category C] : Type
{Î± : Type u} (c : computation Î±) : option Î±
(R : Type u_1) [comm_ring R] : ring_invo R
{K : Type u_1} [linear_ordered_field K] (pconts conts : generalized_continued_fraction.pair K) (fr : K) : K
{Î± : Type u} (x : Î±) : ordnode Î± â†’ Prop
{R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : âˆƒ (V : open_add_subgroup R), â†‘V * â†‘V âŠ† â†‘U
 : â„• â†’ â„•
(G : Type u_3) [group G] : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{Î± : Type u} {Î² : Î± â†’ Type v} (sâ‚ sâ‚‚ : alist Î²) : Prop
(n : num) : num
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A Ã— B) B
{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] (a : Î±) : list Î± â†’ list Î±
{Î± : Type u_2} (A : set Î±) (Î² : Type u_7) [add_comm_monoid Î±] [add_comm_monoid Î²] (n : â„•) : Type (max u_2 u_7)
{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_lub s a) : bdd_above s
{Î± : Type u} (s : seq Î±) : list Î±
{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (c : âˆ€ (a b : Î±), f a = f b) : trunc Î± â†’ Î²
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î²] : function.injective f
 : â„• â†’ â„• â†’ list â„•
{Î± : Type u_1} [linear_order Î±] [topological_space Î±] [compact_Icc_space Î±] {a b : Î±} : is_compact (set.interval a b)
{Î± : Type u} [topological_space Î±] (x : Î±) : set Î±
{Râ‚ƒ : Type u_7} {Mâ‚ƒ : Type u_8} [comm_ring Râ‚ƒ] [add_comm_group Mâ‚ƒ] [module Râ‚ƒ Mâ‚ƒ] (Bâ‚ƒ : bilin_form Râ‚ƒ Mâ‚ƒ) : submodule Râ‚ƒ (module.End Râ‚ƒ Mâ‚ƒ)
{Î± : Type u_1} [preorder Î±] [decidable_rel has_le.le] (x : Î±) (s : ordset Î±) : option Î±
(x : set Class) : Class
{V : Type u} (G : simple_graph V) : Type u
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (q : semiquot Î±) : semiquot Î²
(cs : list omega.clause) : Prop
(b : onote) : onote â†’ Prop
{Î± : Type u} [ordered_add_comm_monoid Î±] : ordered_add_comm_group (add_units Î±)
(m n : â„•) : option â„•
(X : Top) (T : Type v) : Top.presheaf (Type v) X
(Î± : Type u_7) (Î² : Type u_8) [has_inf Î±] [has_inf Î²] : Type (max u_7 u_8)
(K : Type u_1) [field K] : Type u_1
{o : ordinal} : ordinal.principal has_add.add o â†” o = 0 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ a
{M : Type u_1} [monoid M] : mul_distrib_mul_action (mul_aut M) M
(Î± : Type u_1) (Î² : Type u_2) [topological_space Î±] [topological_space Î²] [group Î²] [topological_group Î²] : subgroup (Î± â†’ Î²)
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : aâ»Â¹ < b â†’ bâ»Â¹ < a
{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
 : gcd_monoid â„•
{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
 : pgame â†’ Prop
 : name â†’ name
 : Type
{Î± : Type u} [inhabited Î±] (a : Î±) : list Î± â†’ â„• â†’ list Î±
{Î± : Type u_1} (s : set (set Î±)) : measurable_space Î±
 : nat.arithmetic_function â„•
(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [char_zero k] (h : s.card â‰  0) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_action Î± Î²] (a : Î±) : equiv.perm Î²
{R : Type u_1} {S : Type u_2} [ring R] [topological_space R] [nonarchimedean_ring R] [ring S] [topological_space S] [nonarchimedean_ring S] : nonarchimedean_ring (R Ã— S)
{R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R) : Â¬is_unit â†‘p
{Î± : Type u} [topological_space Î±] (s : set Î±) : Prop
(a : pos_num) : pos_num
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î² â†’ Î²) (b : Î²) : list Î± â†’ Î² Ã— list Î²
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (s : set Î±) : Prop
{n : â„•} [fact (0 < n)] : fintype (quaternion_group n)
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†” 0 â‰¤ a
(C : Type u) [category_theory.category C] : Prop
{n p k : â„•} (hn : n â‰  0) (h : n.factorization = finsupp.single p k) : n = p ^ k
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (f : M â†’ N) : add_con N
(p n : â„•) : mv_polynomial (fin 2 Ã— â„•) â„¤
{Î± : Type u} (s : wseq Î±) : wseq (list Î±)
{Î± : Type u} {Î² : Type v} [semiring Î±] [semiring Î²] {f : Î± â†’ Î²} (hf : is_semiring_hom f) : is_add_monoid_hom f
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] : list Î± â†’ option Î±
{Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} (h : s âŠ† t) : emetric.inf_edist x t â‰¤ emetric.inf_edist x s
(Î± : Type u_5) (Î² : Type u_6) [non_assoc_semiring Î±] [non_assoc_semiring Î²] : Type (max u_5 u_6)
{R : Type u_1} [comm_ring R] (câ‚ câ‚‚ : R) : quadratic_form R (R Ã— R)
(X : Type u) [topological_space X] : Top
{R : Type u_1} {S : Type u_3} [non_unital_comm_semiring R] [non_unital_comm_semiring S] : non_unital_comm_semiring (R Ã— S)
(Î± : Type u) : Type u
{Î± : Type u_1} (R : Î± â†’ Î± â†’ Prop) : list Î± â†’ Prop
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) : Prop
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (lâ‚ : filter Î±) (lâ‚‚ : filter Î²) : Prop
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ finset.Icc a b = âˆ…
 : well_founded nat.lt
{n : â„•} (i : â„•) (h : i < n) : fin n
 : Type
{Î± : Type u} : has_inf (filter Î±)
{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum â‰  0) : 0 < L.length
{Î± : Type u_1} (g : generalized_continued_fraction Î±) (n : â„•) : Prop
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
 : Type (u_1+1)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
{Î± : Type u} [decidable_eq Î±] : list Î± â†’ list (finset Î±)
(G : pgame) : ordinal
{Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] : pseudo_metric_space (bounded_continuous_function Î± Î²)
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : Type (max u v)
{M : Type u_1} [has_add M] : has_Inf (add_con M)
 : matrix.special_linear_group (fin 2) â„¤
 : name â†’ â„• â†’ name
{k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)â»Â¹ = set.Ioi aâ»Â¹
(A : Type u) [comm_ring A] (K : Type v) [field K] [algebra A K] : Type v
{R : Type u} [comm_ring R] (x y : R) (i : â„•) : {z // x ^ i - y ^ i = z * (x - y)}
{Î± : Type u_1} {s t : set Î±} : s = t â†’ s âŠ† t
{Î± : Type u_1} (q : semiquot Î±) : trunc Î±
{ð•œ : Type u_1} {E : Type u_2} [ordered_ring ð•œ] [add_comm_group E] [module ð•œ E] (K : geometry.simplicial_complex ð•œ E) : set (finset E)
{Î± : Type u_1} : â„• â†’ list Î± â†’ list Î± Ã— list Î±
{Î³ : Type w} [emetric_space Î³] {x y : Î³} : has_edist.edist x y = 0 â†” x = y
 : seq â„•
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} : (Î£ (a : Î±), Î² a â†’ W_type Î²) â†’ W_type Î²
{n : â„•} (P : mvpfunctor (n + 1)) : P.last.M â†’ fin2 n â†’ Type u
{Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±) : s - 0 = s
(R : Type u) [field R] : is_field R
(Î² : Type v) (C : Type u_1) [category_theory.category C] : Prop
(Î± : Type u_2) [fintype Î±] [nonempty Î±] [semilattice_inf Î±] : order_bot Î±
{Î± : Type u} {Î² : Î± â†’ Type v} (s : multiset (sigma Î²)) : multiset Î±
{Î± : Type u_1} {Î² : Type u_2} (q : semiquot Î±) (f : Î± â†’ Î²) (h : âˆ€ (a : Î±), a âˆˆ q â†’ âˆ€ (b : Î±), b âˆˆ q â†’ f a = f b) : Î²
(A : Type) [metric_space A] : Type 1
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : Aâ»Â¹ = ring.inverse A
{Î± : Type u} [topological_space Î±] (a : Î±) (s : set Î±) : filter Î±
{Î± : Type u} [inhabited Î±] (as1 as2 : list Î±) : Prop
{Î± : Type u_1} {Î² : Type u_4} [preorder Î±] [preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : galois_connection l u) : lower_adjoint u
{Î± : Type u} (s : stream Î±) : stream (stream Î±)
{Mâ‚€ : Type u_1} [monoid_with_zero Mâ‚€] (x : Mâ‚€) (h : Â¬is_unit x) : ring.inverse x = 0
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] [subsingleton Î¹] (p : Î¹ â†’ E) : convex_independent ð•œ p
{Î± : Type u} (s : seq Î±) : option Î±
(m M N : â„•) : finset (Î£ (n : â„•), fin n â†’ â„•)
{Î± : Type u} {Î² : Type u_1} (tâ‚ : ordnode Î±) (tâ‚‚ : ordnode Î²) : ordnode (Î± Ã— Î²)
(R : Type u_1) [comm_ring R] {A : Type u} [topological_space A] [ring A] [algebra R A] [topological_ring A] (x : A) : subalgebra R A
{Î± : Type u} (s : set Î±) : Prop
{Î± : Type u} {Î² : Type u_1} (tâ‚ : ordnode Î±) (tâ‚‚ : ordnode Î²) : ordnode (Î± âŠ• Î²)
(R : Type u_2) [comm_ring R] : Type u_2
{Î± : Type u} {Î² : Î± â†’ Type v} : list (sigma Î²) â†’ list Î±
{Î± : Type u_2} [monoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = c ^ 2) â†’ is_square m
{Î± : Type u} [uniform_space Î±] (s : set Î±) : Prop
{Î± : Sort u_1} {r : Î± â†’ Î± â†’ Prop} (q : quot r) : Î±
(C : Type u) [category_theory.category C] : Prop
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f
{Î± : Type u_1} {n : â„•} (a : Î±) (v : vector3 Î± n) : vector3 Î± n.succ
 : golden_conjâ»Â¹ = -golden_ratio
 : Type
(F : Type u_8) (Î± : out_param (Type u_9)) (Î² : out_param (Type u_10)) [has_Sup Î±] [has_Sup Î²] : Type (max u_10 u_8 u_9)
(X Y : Top) : category_theory.limits.binary_fan X Y
{Î± : Type u} [topological_space Î±] (a : Î±) : filter Î±
(Î± : Type u) [has_one Î±] [has_mul Î±] : category_theory.category_struct (category_theory.single_obj Î±)
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ ordnode Î±
 : num â†’ znum
{Î± : Type u} [preorder Î±] [no_min_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_anti f âˆ§ f 0 = a
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†” a < 0
{Î± : Type u_1} (p : two_pointing Î±) : two_pointing Î±
{C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)
(Î± : Type u) {Î² : Type v} [monoid Î±] [mul_action Î± Î²] (b : Î²) : submonoid Î±
(Î± : Type u_3) [topological_space Î±] : Prop
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K
{Î± : Type u} [topological_space Î±] (s : set Î±) : set Î±
{M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.prod âˆˆ s
{Î¹ : Type u_1} {Î± : Type u_3} {Î² : Type u_4} [preorder Î±] [preorder Î²] (f : Î¹ â†’ Î±) (g : Î¹ â†’ Î²) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Type (max u v)
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b
(Î± : Type u_3) [measurable_space Î±] : Type u_3
{Î± Î² : ordinal} (h : Î± < Î²) : principal_seg has_lt.lt has_lt.lt
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (b : B) : continuous (bundle.total_space_mk b)
(R : Type u_1) [comm_ring R] : Type u_1
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) : Prop
{G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] : mul_action G (A â†’ B)
(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_mono f
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) : list (Î£ (a : Î±), Î² a) â†’ option (Î² a)
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] : ordnode Î± â†’ ordnode Î± â†’ ordnode Î±
(C : Type uâ‚) [category_theory.category C] [category_theory.monoidal_category C] : Mon_ C
{Î± : Type u_1} {Î² : Type u_2} [tÎ± : topological_space Î±] [tÎ² : topological_space Î²] (f : Î± â†’ Î²) : Prop
{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) : nonempty Î± â†’ nonempty Î²
(C : Type u) [category_theory.category C] : Prop
{H : Type u} [topological_space H] : closed_under_restriction id_restr_groupoid
{Î± : Type u} (i : â„•) (t : ordnode Î±) : ordnode Î± Ã— ordnode Î±
{Î± : Type u_1} [semigroup Î±] [partial_order Î±] [contravariant_class Î± Î± has_mul.mul has_le.le] : left_cancel_semigroup Î±
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) : list (sigma Î²) â†’ list (Î² a)
{Î± : Type u} {Î² : Î± â†’ Type v} (s : multiset (sigma Î²)) : Prop
{Î± : Type u_1} [conditionally_complete_lattice Î±] (f : filter Î±) : Î±
{b : â„•} {l : list â„•} (hb : 2 â‰¤ b) (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b) : nat.of_digits b l < b ^ l.length
 : Type (u_1+1)
{R : Type u} [ring R] : has_inf (subring R)
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (f : Î² â†’ Î³) : option (Î± Ã— Î²) â†’ option (Î± Ã— Î³)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom A (A Ã— B)
(Î± : Type u_1) [complete_lattice Î±] : Prop
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_coproducts C] : category_theory.monad C
{Î± : Type u_1} [unique Î±] : encodable Î±
(R : Type u_1) [has_mul R] [has_add R] : group (ring_aut R)
 : â„•
{Î± : Type u} (l : list Î±) : seq Î±
(Î± : Sort u) : Sort u
(Î± : Type u_2) [preorder Î±] [topological_space Î±] : Type
(Î¹ : Type u_1) (ð•œ : Type u_3) [is_R_or_C ð•œ] (E : Type u_4) [inner_product_space ð•œ E] [fintype Î¹] : Type (max u_1 u_3 u_4)
 : Type
{Î± : Type} (p : parser Î±) : parser (list Î±)
{G : Type u} [group G] (B : group_filter_basis G) : topological_space G
{G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)
{F : Type u_1} [field F] (S : set F) : Prop
(M : Type u_1) [measurable_space M] [has_inf M] : Prop
(k : â„•) (R : Type u_1) [comm_ring R] [is_domain R] : finset R
{R : Type u_1} [rack R] {G : Type u_2} [group G] (f : shelf_hom R (quandle.conj G)) : rack.pre_envel_group R â†’ G
{Î¹ : Type u_1} {E : Î¹ â†’ Type : Type
{Î± : Type u_2} {Î² : Type u_3} [has_vadd Î± Î²] : has_vadd (set Î±) (set Î²)
 : turing.to_partrec.code
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0
{G : Type u_1} [group G] (S T : set G) : Prop
(a b : nonote) : ordering
(c : cardinal) : Prop
 : primrec (Î» (a : (â„• Ã— nat.partrec.code) Ã— â„•), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)
{Î± : Type u_1} {Î² : Type u_2} [preorder Î±] [order_bot Î±] [partial_order Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : galois_connection l u) : order_bot Î²
 : â„•
 : ordinal â†’ pgame
{G : Type u_1} [comm_group G] : group.is_nilpotent G
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : â†‘â†‘â†‘g = â†‘g
(Î± : Type u_1) : Type u_1
(G : Type u_1) [group G] (n : â„•) : subgroup G
{Î± : Type u} [monoid Î±] {a : Î±} (h : is_unit a) : invertible a
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] (f : equiv.perm Î±) : finset Î±
{Î± : Type u} {Î² : Type u_1} (f : Î± â†’ Î²) : tree Î± â†’ tree Î²
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
(Î± : Type u_5) (Î² : Type u_6) [topological_space Î±] [topological_space Î²] : Type (max u_5 u_6)
{K : Type u} [field K] (s : subfield K) : add_subgroup K
(R : Type u) [comm_ring R] : Type u
{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] {Î± : Type u_1} (s : set (Î± â†’ M)) : Prop
{Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [decidable_rel R] {l : list Î±} : list.pairwise R l â†’ list.pw_filter R l = l
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (h : Î² â†’ Î³) (g : Î± â†’ Î²) (l : list Î±) : list.map (h âˆ˜ g) l = list.map h (list.map g l)
(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (Î¹ : Type u_4) [decidable_eq Î¹] : Type (max u_2 u_1 u_4)
(x y : {x // x.numeric}) : Prop
(J : Type uâ‚) [category_theory.category J] (C : Type u) [category_theory.category C] : Prop
(F : pfunctor) : Type u
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) (s : set Î±) : Prop
(R : Type u_1) [semiring R] : Type u_1
{R : Type u_1} [has_zero R] [has_one R] : dual_number R
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_one_class M] [mul_one_class N] : Type (max u_10 u_11 u_9)
{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_zero M] [has_zero N] [has_zero P] (hnp : zero_hom N P) (hmn : zero_hom M N) : zero_hom M P
{Î± : Type u_1} (x : Î±) : lazy_list Î± â†’ Prop
(Mâ‚€ : Type u_4) [has_mul Mâ‚€] [has_zero Mâ‚€] : Prop
(G : Type u) [add_monoid G] : â„•
{Î± : Type u_1} (q : semiquot Î±) : Prop
{Î± : Type u} [monoid Î±] (a : Î±) : set Î±
(Î± : Type u) (Î² : Type v) [add_monoid Î±] [add_action Î± Î²] : set Î²
(Î± : Type u_2) [preorder Î±] : Type u_2
{Î± : Type u_1} [lattice Î±] [order_bot Î±] {a : Î±} (ha : is_atom a) : unique (finpartition a)
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] : opens_measurable_space Î±
(Î± : Type u_3) [topological_space Î±] : Type u_3
{Î± : Type u_2} [add_comm_monoid Î±] : multiset Î± â†’ Î±
{Î± : Type u_1} [preorder Î±] (b : Î±) : set Î±
{ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] : E â†’ Prop
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : monotone finset.up_shadow
{Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : (-1) * a = -a
{Î± : Type u} {Î² : Type w} : buffer Î± â†’ (Î± â†’ Î²) â†’ buffer Î²
{X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X) : Prop
{Î± : Type u} [preorder Î±] (s : set Î±) : set Î±
{Î± : Type u_1} [semigroup_with_zero Î±] {a : Î±} : 0 âˆ£ a â†” a = 0
 : Type (u+1)
{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K Ã— polynomial K
(G : pgame) : Prop
 : Type
{Î± : Sort u} {Î² : Sort v} (a : Î±) : Î²
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurable_space Î±} [topological_space Î²] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)
{Î± : Type u} [group_with_zero Î±] {a : Î±} [invertible a] : invertible aâ»Â¹
{S : Type u_1} [has_mul S] (a b : S) : Prop
{m : Type u_2} {Î± : Type v} [fintype m] [has_mul Î±] [add_comm_monoid Î±] (v w : m â†’ Î±) : Î±
{Î± : Type u} (S : wseq (wseq Î±)) : wseq Î±
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : affine_subspace k P) : submodule k V
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c
{Î± : Type u} {a b : Î±} [mul_zero_class Î±] [partial_order Î±] [zero_lt.mul_pos_mono Î±] (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a * b
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : Type (max u_2 u_3)
{Î± : Type u_1} [comm_monoid_with_zero Î±] (p : Î±) : Prop
{Î± : Type u} {Î² : Type v} : Î± âŠ• Î² â†’ Î² âŠ• Î±
(R : Type u_1) [monoid_with_zero R] : submonoid R
(Î± : Type u_3) [h : topological_space Î±] : Prop
{Î± : Type u} {Î² : Type v} [mul_one_class Î±] [mul_one_class Î²] (f : Î± â†’ Î²) : Prop
(F : Type u_7) (Î± : out_param (Type u_8)) (Î² : out_param (Type u_9)) [has_sup Î±] [has_sup Î²] [has_bot Î±] [has_bot Î²] : Type (max u_7 u_8 u_9)
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) (s : set Î±) : Prop
{k : Type uâ‚} {G : Type uâ‚‚} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G] : algebra k (monoid_algebra A G)
{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) (n : â„•) : category_theory.subobject (X.obj (opposite.op (simplex_category.mk n)))
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_btw.btw c b a
(R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [comm_semiring R] [algebra R S] [module S M] : module R (restrict_scalars R S M)
 : znum â†’ znum
{m : Type u_3} {Î± : Type u_5} [fintype m] [is_R_or_C Î±] [decidable_eq m] : normed_ring (matrix m m Î±)
{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] [decidable_eq (module.End R M)] [is_simple_module R M] : division_ring (module.End R M)
(F : Type u_7) (R : out_param (Type u_8)) (S : out_param (Type u_9)) [has_mul R] [has_add R] [has_mul S] [has_add S] : Type (max u_7 u_8 u_9)
{R : Type u} [comm_ring R] (a : R) (p : polynomial R) : â„•
(Î± : Type u_5) [topological_space Î±] : Prop
 : â„• â†’ pgame
{G : Type u_1} [group G] (s : set G) : set G
 : Type
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [decidable_eq Î±] (h : âˆ€ (a b : Î±), âˆƒ (c : Î±), âˆ€ (d : Î±), a âˆ£ d âˆ§ b âˆ£ d â†” c âˆ£ d) : gcd_monoid Î±
{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop
(K : Type u_1) [field K] : subalgebra â„¤ K
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ ordnode Î±
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (sâ‚ sâ‚‚ : finmap Î²) : finmap Î²
 : bool â†’ snum â†’ snum
{R : Type u_1} [comm_ring R] {n : â„•} (v : fin n â†’ R) : matrix (fin n) (fin n) R
{R : Type u_1} {A : Type u_2} [has_zero A] (r : R) : unitization R A
{n : â„•} (x y : bitvec n) : Prop
(G : Type u) [div_inv_monoid G] [measurable_space G] [has_measurable_mulâ‚‚ G] [has_measurable_inv G] : has_measurable_pow G â„¤
(X : Type u_5) [t : topological_space X] : Prop
{Î± : Type u_1} [has_add Î±] [has_le Î±] [contravariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} (bc : a + b â‰¤ a + c) : b â‰¤ c
{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L
{k : Type uâ‚} {G : Type uâ‚‚} [semiring k] [has_add G] : has_mul (add_monoid_algebra k G)
(L : first_order.language) (L' : first_order.language) : Type (max u u' v v')
(ð•œ : Type u_4) (E : Type u_5) [is_R_or_C ð•œ] : Type (max u_4 u_5)
{Î± Î² : Type} (f : Î± â†’ Î² â†’ Î²) (p : parser Î±) (b : Î²) : parser Î²
 : Type
 : Type
{X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s
(A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A A
(x y : Set) : Set
(n : â„•) : â„• Ã— â„•
(R : Type u_1) [euclidean_domain R] : gcd_monoid R
{m : Type u â†’ Type v} [applicative m] {Î± : Type u_1} {Î² : Type u} (f : â„• â†’ Î± â†’ m Î²) (start : â„•) (as : list Î±) : m (list Î²)
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (f : Î± â†’ Î² â†’ Î³) : seq Î± â†’ seq Î² â†’ seq Î³
(M : Type u_10) (A : Type u_11) [monoid M] [add_monoid A] : Type (max u_10 u_11)
{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : Î“
{R : Type u_1} [comm_monoid_with_zero R] (n : R) : Prop
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : has_involutive_neg (module.ray R M)
(x : Class) : set Class
(R : Type u) [ring R] : subring R
{p : â„•} : padic_val_nat p 1 = 0
{Î± : Sort u_1} {p : Î± â†’ Prop} (x : subtype p) : p â†‘x
 : Type
{Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), topological_space (E i)] [encodable Î¹] [âˆ€ (i : Î¹), topological_space.second_countable_topology (E i)] : topological_space.second_countable_topology (Î£ (i : Î¹), E i)
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream (generalized_continued_fraction.pair K)
{G : Type u_1} [group G] : complete_lattice (subgroup G)
(C : Type u) [category_theory.category C] : Prop
(C : Type u) [category_theory.category C] : Type u
{M : Type u_1} [has_mul M] : has_le (con M)
{G : Type u_1} [group G] (H : subgroup G) : Prop
 : distrib_lattice Prop
(Î± : Type u) : Type u
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : add_submonoid A
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (s : set Î±) : continuous (Î» (F : C(Î±, Î²)), continuous_map.restrict s F)
(C : Type u) : Type u
{C : Type u} [category_theory.category C] (X : C) : Type (max u v)
{Î± : Type u_1} {n : â„•} (v : vector3 Î± n.succ) : Î±
{Î± : Type u} (s : computation Î±) (a : Î±) (n : â„•) : Prop
{m : Type u_2} {n : Type u_3} {Î± : Type v} (M : matrix m n Î±) (i : m) (j : n) : M.transpose j i = M i j
(Gâ‚€ : Type u_4) : Type u_4
{Î± : Type u_1} (P : Î± â†’ Prop) : Type u_1
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (Î» (h : G), g + h + -g)
(C : Type u) [category_theory.category C] : Prop
(Î± : Type u_1) [comm_semiring Î±] : Type u_1
(X : Type u_1) [fintype X] : Fintype
{Î± : Type u_1} {Î³ : Î± â†’ Type u_3} [encodable Î±] [Î  (a : Î±), encodable (Î³ a)] (n : â„•) : option (sigma Î³)
{Î± : Type u_1} {M : Type u_5} [comm_monoid M] (s : set Î±) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), 1)) = 1
{M : Type u_1} [add_monoid M] {x : M} : 0 âˆˆ multiples x
{Î± : Type u_1} [semigroup Î±] (x y : Î±) : has_mul.mul x âˆ˜ has_mul.mul y = has_mul.mul (x * y)
{X : Type u_1} [topological_space X] : compact_space (alexandroff X)
{ð•œ : Type u_1} {F : Type u_3} [is_R_or_C ð•œ] [add_comm_group F] [module ð•œ F] (c : inner_product_space.core ð•œ F) : inner_product_space ð•œ F
{Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a / (a / a) = a
{X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : path x y
 : Type (u+1)
{Î± : Type u} {Î² : Î± â†’ Type v} (sâ‚ sâ‚‚ : finmap Î²) : Prop
(X : Type u_2) [topological_space X] : Type u_2
{G : Type u_1} [add_group G] (s : set G) : set G
{Î± : Type u} (t : ordnode Î±) : ordnode (ordnode Î±)
{Î± : Sort u_1} {Î² : Sort u_2} [nonempty Î²] (f : Î± â†’ Î²) : Î²
(Î± : Type u_1) : Type u_1
{M : Type u_1} [add_monoid M] (P : add_submonoid M) : Prop
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact Î±) (filter.cocompact Î²)
{Î± : Type u_1} (G : simple_graph Î±) (n : â„•) (s : finset Î±) : Prop
 : Type
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (m : hash_map Î± Î²) (a : Î±) : option (Î² a)
{Î± : Type u} [topological_space Î±] (s : set Î±) : Prop
 : category_theory.monad Meas
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (f : module.End R M) : Prop
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ option Î±
{R : Type u} [semiring R] : R â†’ polynomial R â†’ R
{Î± : Type u} {Î² : Type w} {m : Type w â†’ Type u_1} [monad m] (b : buffer Î±) (f : Î± â†’ m Î²) : m (buffer Î²)
(Î± : Type u_1) (r : Î± â†’ Î± â†’ Prop) [is_preorder Î± r] : Type u_1
{A : Type u_3} [add_group A] (s : set A) : A â†’ Prop
(Î± : Type u_3) [lattice Î±] : lattice_hom Î± Î±
{Î± : Type u_1} [linear_ordered_field Î±] {Î² : Type u_2} [ring Î²] (abv : Î² â†’ Î±) (f : â„• â†’ Î²) : Prop
{F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) : âˆƒ (a : F), Â¬is_square a
{Î± : Type u_1} {o p : part Î±} (H : âˆ€ (a : Î±), a âˆˆ o â†” a âˆˆ p) : o = p
{m : Type v â†’ Type w} [monad m] {Î± : Type u_1} {Î² : Type v} (f : â„• â†’ Î² â†’ Î± â†’ m Î²) (b : Î²) (as : list Î±) : m Î²
{G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (Î» (h : G), h / g)
{Î± : Type u_1} [linear_ordered_ring Î±] [floor_ring Î±] : Î± â†’ â„¤
(R : Type u) (M : Type v) : Type (max u v)
{Î± : Type u_1} [boolean_ring Î±] : has_inf Î±
 : Type
(l : Type u_4) (R : Type uâ‚‚) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (l âŠ• l) (l âŠ• l) R)
(M : Type u_1) [has_add M] : galois_insertion add_con_gen coe_fn
{Î± : Type u} [pseudo_emetric_space Î±] : emetric.diam âˆ… = 0
{Î± : Type u_1} [encodable Î±] : encodable (list Î±)
 : matrix.special_linear_group (fin 2) â„¤
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [has_bot Î±] [has_bot Î²] [has_bot Î³] (f : bot_hom Î² Î³) (g : bot_hom Î± Î²) : bot_hom Î± Î³
(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : Type (max u_1 u_2)
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn
(R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) : set R
{Î± : Type u} (a : Î±) (n : â„•) : arity Î± n
{Î± : Type u} [has_add Î±] : is_add_hom id
(p : â„• â†’ Prop) [decidable_pred p] (n : â„•) : fintype {i // i < n âˆ§ p i}
 : â„• â†’ pSet
 : Type
(p : â„•) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : â„•) (aâ‚ aâ‚‚ : witt_vector p k) (bs : fin (n + 1) â†’ k) : polynomial k
(F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] [finite_dimensional F K] [char_zero F] : is_separable F K
(F : pfunctor) : Type u
 : name â†’ name
(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : Type u_2
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.sheaf C X) : category_theory.limits.is_terminal (F.val.obj (opposite.op âˆ…))
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [topological_space Î±] [topological_space Î²] : Type (max u_6 u_7 u_8)
{Î± : Type u_1} {Î² : Type u_2} : list Î± â†’ list Î² â†’ list (option Î± Ã— Î²)
(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : â„•} [hp : char_p R p] (p_ne_zero : p â‰  0) : nat.prime p
{Î± : Type u_1} (a : Î±) [decidable_pred (Î» (_x : Î±), _x = a)] (h : fintype {b // b â‰  a}) : fintype Î±
(C : Type u) [category_theory.category C] : Prop
{G : Type u_1} [group G] (H : subgroup G) {x y : G} : x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H
{Î± : Type u} (s : set Î±) : Prop
{Î± : Type u} (n : â„•) (s : stream Î±) : stream Î±
(x : onote) : onote â†’ onote
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (m : hash_map Î± Î²) (a : Î±) : hash_map Î± Î²
{Î± : Type u_1} (f : Î± â†’ Î±) : â„• â†’ list Î± â†’ list Î±
{Î± : Type u} [decidable_eq Î±] [mul_zero_one_class Î±] [nontrivial Î±] : mul_zero_one_class (with_top Î±)
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : semiring (submodule R A)
(ð•œ : Type u_1) (E : Type u_2) [ordered_semiring ð•œ] [ordered_add_comm_group E] [module ð•œ E] [ordered_smul ð•œ E] : convex_cone ð•œ E
{Î± : Type u} {Î² : Type u_1} (f : Î± â†’ Î²) : ordnode Î± â†’ ordnode Î²
{Î¹ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_mul R] [has_add Î¹] (A : Î¹ â†’ S) : Prop
(Î± : Type u) [measurable_space Î±] : Meas
{Î± : Type u_1} [semigroup Î±] {a b c : Î±} : a âˆ£ b â†’ b âˆ£ c â†’ a âˆ£ c
 : subsingleton (fin 1)
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) (hf : continuous f) (K : topological_space.compacts Î±) : topological_space.compacts Î²
(X : CpltSepUniformSpace) : UniformSpace
{Î± : Type u} (s : seq Î±) : option (seq1 Î±)
{Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), monoid (M i)] {i j : Î¹} (w : free_product.neword M i j) : list (Î£ (i : Î¹), M i)
(Î± : Type u_1) : Type u_1
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (N : submodule R M) : ideal R
{R : Type u} [ring R] : Â¬is_field (polynomial R)
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : has_one (submodule R A)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : Type (max u_4 u_5)
{Î± : Type u} [add_monoid Î±] (u : add_units Î±) : Î±
{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] [is_total Î± r] [is_trans Î± r] (l : list Î±) : list.sorted r (list.insertion_sort r l)
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (l : list Î±) (hp : âˆƒ (a : Î±), a âˆˆ l âˆ§ p a) : {a // a âˆˆ l âˆ§ p a}
{Î² : â„• â†’ Type u_1} : inhabited (hash_map â„• Î²)
(J : Type uâ‚) [category_theory.category J] {C : Type uâ‚‚} [category_theory.category C] [nonempty J] : category_theory.faithful (category_theory.functor.const J)
{G : Type u_1} [group G] (K : subgroup G) (s : set G) (hs : s = â†‘K) : subgroup G
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [decidable_eq Î±] (h : âˆ€ (a b : Î±), âˆƒ (c : Î±), âˆ€ (d : Î±), d âˆ£ a âˆ§ d âˆ£ b â†” d âˆ£ c) : gcd_monoid Î±
{Î± : Type u_1} [comm_semiring Î±] (E : linear_recurrence Î±) : submodule Î± (â„• â†’ Î±)
{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set (M Ã— M)) : Prop
(u : pnat.xgcd_type) : Prop
(Î± : Type u) [uniform_space Î±] : filter (Î± Ã— Î±)
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))
{Î± : Type u_1} {Î² : Type u_2} [has_le Î²] [has_add Î²] [has_one Î²] (s : set Î±) (f : Î± â†’ Î²) : Prop
{a b c : â„¤} (h : a % b = c) : b âˆ£ a - c
{R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L â‰¤ cardinal.mk R
{Î± : Type u} {Î² : Type v} [add_zero_class Î±] [add_zero_class Î²] (f : Î± â†’ Î²) : Prop
{c c' : Î£ (n : â„•), composition n} : c = c' â†” c.snd.blocks = c'.snd.blocks
{Î± : Type u_1} {Î¹ : Type u_3} {m : measurable_space Î±} [preorder Î¹] (f : measure_theory.filtration Î¹ m) (Ï„ : Î± â†’ Î¹) : Prop
{Î± : Type u_1} [semiring Î±] {m n : â„•} (h : m âˆ£ n) : â†‘m âˆ£ â†‘n
{Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u : Î±) (s : finset Î±) : uv.is_compressed u u s
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
 : znum â†’ znum â†’ znum
{C : Type u} [category_theory.category C] (i p : category_theory.arrow C) : Prop
(V : Type u) [quiver V] (H : wide_subquiver V) : Type u
{Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±] (f : Î² â†’ Î±) (a : Î±) : Prop
{A : Type u_1} [add_monoid A] : distrib_mul_action (add_aut A) A
(K : Type u_1) (V : Type u_2) [division_ring K] [add_comm_group V] [module K V] : Prop
(Î± : Sort u_1) (Î² : Sort u_2) : Sort (max 1 (imax u_2 u_1) u_1)
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : R
{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (incl : s âŠ† t) : metric.bounded t â†’ metric.bounded s
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter Î±) (f : Î± â†’ E) (g : Î± â†’ F) : Prop
{Î± : Type u'} {Î² : Type v'} {n : â„•} (g : Î± â†’ Î² âŠ• fin n) (k : â„•) : Î± âŠ• fin k â†’ Î² âŠ• fin (n + k)
{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)
(Î± : Type u) : Type u
{Î± : Type u_1} [metric_space Î±] {Î² : Type u} [nonempty Î²] (p : besicovitch.tau_package Î² Î±) : ordinal â†’ â„•
{Î± : Type u} (l : thunk (list Î±)) : dlist Î±
{M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.prod âˆˆ S
 : Type
(J : Type v) : Type v
{R : Type u} [semiring R] (p : polynomial R) : Prop
{Î± : Type u} [canonically_ordered_add_monoid Î±] : canonically_ordered_add_monoid (with_zero Î±)
(b : bool) : â„•
 : Type
(Î± : Type u_1) : basis Î± â„¤ (free_abelian_group Î±)
{Î± : Type u} [group Î±] : group_with_zero (with_zero Î±)
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
{Î± : Type u} {Î² : Type v} : Î± âŠ• Î² â†’ bool
{Î± : Type u_1} [has_add Î±] (a : Î±) (s : set Î±) : set Î±
(p : â„•) [hp : fact (nat.prime p)] : prime â†‘p â†” p % 4 = 3
{Î± : Type} (rels : set (free_group Î±)) : Type
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop
(C : Type u) [category_theory.category C] (n : â„•) : Type (max v u)
 : Type (u_1+1)
(R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : is_unit â†‘p â†” Â¬p âˆ£ ring_char R
{Î± : Type u} [topological_space Î±] {Î³ : Type u} [topological_space Î³] [t2_space Î³] [compact_space Î³] {f : Î± â†’ Î³} (hf : continuous f) : stone_cech Î± â†’ Î³
{Î± : Type u} [topological_space Î±] {s : set Î±} : dense (closure s) â†’ dense s
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A B : matrix n n Î±) (h : A.mul B = 1) : invertible A
(G : Type u_1) (P : Type u_2) : Type (max u_1 u_2)
{Î± : Type u_1} : bool Ã— Î± â†’ option Î±
{C : Type uâ‚} [category_theory.category C] (Z : C â†’ Prop) : category_theory.category {X // Z X}
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : Î± â†’ option Î² â†’ Î³) : list Î± â†’ list Î² â†’ list Î³
{R : Type u} [ring R] (s : subring R) : submonoid R
{Î± : Type u_1} {Î² : Type u_2} (x : option Î±) : (Î  (a : Î±), a âˆˆ x â†’ option Î²) â†’ option Î²
{X : Type u_1} [topological_space X] {Î± : Type u_2} {Î² : Type u_3} (f : X â†’ Î±) (g : Î± â†’ Î²) (h : is_locally_constant (g âˆ˜ f)) (inj : function.injective g) : is_locally_constant f
{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] [nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), f x â‰¤ c) : supr f â‰¤ c
{Î± : Type u} (s : stream Î±) : seq Î±
{Î± : Type u_1} (k : â„•) : (vector3 Î± k â†’ Prop) â†’ Prop
(wâ‚ wâ‚‚ pâ‚ pâ‚‚ : nnreal) : wâ‚ + wâ‚‚ = 1 â†’ pâ‚ ^ â†‘wâ‚ * pâ‚‚ ^ â†‘wâ‚‚ â‰¤ wâ‚ * pâ‚ + wâ‚‚ * pâ‚‚
(p : nat.primes) : prime_multiset
{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd b = 1) : a âˆ£ c
 : real.sin (real.pi / 3) ^ 2 = 3 / 4
{V : Type u} : has_sup (simple_graph V)
{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R â‰  2) : set.inj_on coe {0, 1, -1}
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : set Î²) : set Î±
{Î± : Type u} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] : filter.tendsto (Î» (r : Î±), râ»Â¹) filter.at_top (nhds_within 0 (set.Ioi 0))
 : is_cyclic (quaternion_group 1)
{Î± : Type u_1} [preorder Î±] (a b : Î±) : set Î±
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.non_preadditive_abelian C
{n m : â„•} (F : typevec n â†’ Type u_1) (G : fin2 n â†’ typevec m â†’ Type u) (v : typevec m) : Type u_1
{Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), monoid (M i)] {i j : Î¹} (w : free_product.neword M i j) : free_product.word M
{C : Type u} [category_theory.category C] (G : C) : Prop
(Î± : Type u) [measurable_space Î±] (Î² : Type v) : Type (max u v)
{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R
 : Type (max (u+1) u (v+1))
{Î± : Type u} {Î² : Î± â†’ Type v} (f : Î  (x : Î±), Î² x â†’ bool) (s : finmap Î²) : bool
(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : â„•) [hq : exp_char R q] : nat.prime q âˆ¨ q = 1
{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c
{Î± : Type u_1} (l : list Î±) (n : â„•) : list Î±
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] (f : measure_theory.simple_func Î± Î²) : finset Î²
(Î± : Type u) {g : Type} [random_gen g] [random Î±] : rand_g g Î±
{R : Type u_1} [semiring R] (f : polynomial R) : polynomial R
{M : Type u_1} [mul_one_class M] (S : submonoid M) (s : set M) (hs : s = â†‘S) : submonoid M
{B : Type u_1} (E : B â†’ Type u_2) : Type (max u_1 u_2)
{Î± : Type u} [preorder Î±] (c : omega_complete_partial_order.chain Î±) (x : Î±) : Prop
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} (f : Î³ â†’ Î´) (g : Î± â†’ Î² â†’ Î³) (a : Î±) (b : Î²) : Î´
{X : Type u_1} [topological_space X] (s : set X) : Prop
(p : â„•) : â„• â†’ zmod (2 ^ p - 1)
{Î± : Type u_1} : has_one (language Î±)
{Î± : Type u} {Î² : Type v} [nonempty Î±] (f : Î± â†’ Î²) (s : set Î±) (b : Î²) : Î±
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
{Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} [contravariant_class Î± Î± has_add.add has_le.le] (h : a â‰¤ b) : b - (b - a) = a
{P : Type u_2} [metric_space P] {psâ‚ psâ‚‚ : set P} (hs : psâ‚ âŠ† psâ‚‚) (hc : euclidean_geometry.cospherical psâ‚‚) : euclidean_geometry.cospherical psâ‚
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (gp : generalized_continued_fraction.pair Î±) : generalized_continued_fraction.pair Î²
(Î± : Type u) (Î² : Type v) [topological_space Î±] [topological_space Î²] : Type (max u v)
{Î± : Type u} {Î² : Type v} (f : Î± â†’ option Î²) : wseq Î± â†’ wseq Î²
{Î± : Type u_1} [measurable_space Î±] (m : measure_theory.outer_measure Î±) : measure_theory.outer_measure Î±
{a b : ennreal} (h : a < b) : add_le_cancellable a
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [decidable_eq Î±] [unique_factorization_monoid Î±] (a : Î±) : multiset Î±
{Î± : Sort u_1} (r : Î± â†’ Î± â†’ Prop) : function.surjective (quot.mk r)
(Î± : Type u_1) [has_lt Î±] : has_sbtw Î±
(R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : â„•} (hb : 1 < b) : galois_coinsertion (Î» (z : â„¤), âŸ¨â†‘b ^ z, _âŸ©) (Î» (r : â†¥(set.Ioi 0)), int.log b â†‘r)
{Î± : Type u} [group Î±] (a : Î±) : invertible a
(X T : Top) : Top.presheaf (Type v) X
 : Type
{G : Type u_2} [add_group G] : has_neg (add_submonoid G)
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : Type (max u_4 u_5)
(aâ‚€ aâ‚ aâ‚‚ : Type u) : â„• â†’ Type u
{n : â„•} : bitvec n â†’ bitvec n â†’ bitvec n
(R : Type u) [comm_ring R] : Top
{Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), x * y)
{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] (a : Î±) [no_min_order Î±] : closure (set.Iio a) = set.Iic a
{V : Type u} (x y : simple_graph V) : Prop
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
{Î± : Type u} [topological_space Î±] {s : set Î±} : is_clopen s â†’ frontier s = âˆ…
{n : â„•} (Î± : typevec n) (Î² : Type u_1) : typevec (n + 1)
{Î± : Type u} (i : â„•) (t : ordnode Î±) : ordnode Î±
{R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R â†” is_integral_closure R R K
(C : Type u) [category_theory.category C] : Type (max u v)
{S : Type u_2} [comm_ring S] {A : Type u_4} [comm_ring A] [algebra A S] (pb : power_basis A S) : polynomial A
(C : Type uâ‚) [category_theory.category C] : hom_rel (category_theory.paths C)
{R : Type uâ‚} {L : Type uâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L
{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} (f : Î± â†’ Î² â†’ Î³) : Prop
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A â†” algebra.finite_presentation R A
{Î± : Type u_1} [topological_space Î±] [polish_space Î±] {s : set Î±} (hs : is_closed s) : polish_space.is_clopenable s
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : set Î±) : set Î²
{R : Type u_1} [comm_ring R] (k : â„•) (a : R) : â„• â†’ polynomial R
(Î² : Type u_1) (Î± : Type u_2) : Type (max u_1 u_2)
{G : Type u_1} [group G] (S : subgroup G) : set G
 : strict_mono real.sinh
{Î± : Type u} {Î² : Type u_1} (f : Î² â†’ Î±) [decidable_eq Î±] [fin_enum Î²] (h : function.surjective f) : fin_enum Î±
{m : Type u_2} {n : Type u_3} {Î± : Type u_5} [decidable_eq m] [decidable_eq n] [semiring Î±] (i : m) (j : n) (a : Î±) : matrix m n Î±
{Î± : Type u_1} [preorder Î±] (s : ordset Î±) : Prop
{G : Type u_1} [add_group G] (S : add_subgroup G) : set G
(C : Type u) [category_theory.category C] : Type (max v u)
(Î± : Type u) : Type u
(G : Type u) [group G] : Type (u+1)
(R : Type u_1) (M : Type u_3) [has_zero R] [has_zero M] : Type (max u_1 u_3)
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ list Î± â†’ Î²) : list Î± â†’ list Î²
(Î± : Type u_5) : Type u_5
(Î± : Type u_1) : Type u_1
{Î± : Type u_1} [circular_preorder Î±] (a b : Î±) : set Î±
{Î± : Sort u_1} : erased Î± â†’ Î±
 : snum â†’ snum
(a : pos_num) : pos_num â†’ pos_num
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Î» (_x : G), _x +áµ¥ p)
{Î± : Type u} [decidable_eq Î±] (i j : Î±) : function.involutive (has_mul.mul (equiv.swap i j))
{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.red L (free_group.reduce L)
{Î± : Type u_2} {Î² : Type u_3} [preorder Î±] [preorder Î²] [bounded_order Î±] [bounded_order Î²] (f : bounded_order_hom Î± Î²) : top_hom Î± Î²
{n : Type u} [decidable_eq n] [fintype n] (Î² : Type v) [comm_ring Î²] : submonoid (matrix n n Î²)
{Î± : Type u_1} {m m' : metric_space Î±} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'
{Î± : Type u} (L : list (Î± Ã— bool)) : free_group Î±
(C : Type uâ‚) [category_theory.category C] : Type uâ‚
(Î± : Type u_1) [topological_space Î±] [preorder Î±] : Prop
{n : â„•} (a : fin (n + 1)) : â†‘â†‘a = a
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} (hr : x â‰  y â†’ r x y) : r x y
{R : Type u} [ring R] (s : subring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
{Î± : Sort u_1} (p : Î± â†’ Î± â†’ Prop) : decidable_rel p
(p n : â„•) (R : Type u_1) : Type u_1
(H : Type u_1) [topological_space H] : structure_groupoid H
{E : â„• â†’ Type u_1} (x y : Î  (n : â„•), E n) : â„•
(X : Type u_3) [topological_space X] : Prop
(Î± : Type u_1) (Î² : Type u_2) [order.frame Î±] [order.frame Î²] : Type (max u_1 u_2)
(Î± : Type u) [has_lt Î±] : Prop
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ ordnode Î±
(Î± : Type u_1) : Type u_1
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î±] [semilattice_inf Î²] (gi : galois_coinsertion l u) : semilattice_inf Î±
(n : â„•) : zmod n â†’ zmod n
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] (B : bilin_form R M) : quadratic_form R M
{Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î²] (s : finset Î±) (t : Î± â†’ finset Î²) : finset Î²
{Î± : Type u_2} [decidable_eq Î±] [has_div Î±] : has_div (finset Î±)
(n k : â„•) : Prop
 : Type (u+1)
{G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x / y âˆˆ H
{M : Type u_1} [has_zero M] [has_add M] [has_neg M] : â„¤ â†’ M â†’ M
 : irrational golden_ratio
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î²] (f : Î± â†’ Î²) (inj : function.injective f) : linear_order Î±
(R : Type u) : Type (u+1)
{M : Type u_1} [monoid M] {x y z : M} : y âˆˆ powers x â†’ z âˆˆ powers x â†’ y * z âˆˆ powers x
(n : â„•) : arity Set n â†’ Type (u+1)
{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r âˆˆ resolvent_set R a â†” is_unit (resolvent a r)
{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b < c) : a < c
(a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b â‰¤ a ^ â†‘p / p + b ^ â†‘q / q
(C : Type u) [category_theory.category C] : Type (max (max v u) u v)
 : pos_num â†’ â„•
(p : â„•) [hp : fact (nat.prime p)] (n : â„•) : â„• â†’ mv_polynomial (fin 1 Ã— â„•) â„¤
(Î± : Type u_1) : Type u_1
(L : list â„•) (h : âˆ€ (i : â„•), i âˆˆ L â†’ 1 â‰¤ i) : L.length â‰¤ L.sum
{R : Type u} [ring R] (s : subring R) {l : list R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
(n : â„•) : multiset â„•
(Î± : Type u) : Type u
{V : Type u} (G : simple_graph V) : Type u
{Î± : Type u_1} [decidable_eq Î±] [partial_order Î±] [bounded_order Î±] [is_simple_order Î±] : lattice Î±
(X : Type u) [uniform_space X] [complete_space X] [separated_space X] : CpltSepUniformSpace
{Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [preorder Î²] (f : Î± â†’ Î²) : Prop
(Î± : Type u_6) (Î² : Type u_7) [preorder Î±] [preorder Î²] [mul_zero_one_class Î±] [mul_zero_one_class Î²] : Type (max u_6 u_7)
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] (a b : Î±) : multiset Î±
{Î± : Type u_1} (s : finset Î±) : Prop
(Î± : Type u_1) [encodable Î±] : decidable_eq Î±
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} : a â‰¤ bâ»Â¹ â†’ b â‰¤ aâ»Â¹
{Î± : Type u} (p : Î± â†’ Prop) (s : stream Î±) : Prop
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (N : submodule R M) : Prop
(C : Type uâ‚) [category_theory.category C] : Type uâ‚
{R : Type u_1} {Î¹ : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype Î¹] [is_noetherian R M] : is_noetherian R (Î¹ â†’ M)
{n : â„•} (f : equiv.perm (fin n)) (a : Î£ (a : fin n), fin n) : Î£ (a : fin n), fin n
{Î± : Type u_2} [comm_monoid Î±] : comm_monoid (filter Î±)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {n : â„•} (f : Î± â†’ Î² â†’ Î³) : vector Î± n â†’ vector Î² n â†’ vector Î³ n
 : Type (u_1+1)
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 0 âˆˆ s
{m : Type â†’ Type v} [monad m] {Î± : Type u_1} {Î² : Type} (f : Î± â†’ m (option Î²)) : list Î± â†’ m (list Î²)
{Î± : Type u} (s : stream (option Î±)) : Prop
(Gâ‚€ : Type u_1) [measurable_space Gâ‚€] [has_div Gâ‚€] : Prop
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] : list Î± â†’ option Î± Ã— list Î±
{Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_group_hom (Î» (a : Î±), -f a)
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
(Î± : Type u_2) [complete_lattice Î±] : Prop
(p : â„•) [fact (nat.prime p)] {a : â„¤} : zmod.legendre_sym p a = -1 â†” Â¬is_square â†‘a
{Î± : Type u_1} (m : set (measure_theory.outer_measure Î±)) (s : set Î±) : ennreal
{Î± : Type u_1} [encodable Î±] (a : Î±) : ulower Î±
{Î± : Type u_1} {Î² : Type u_2} (mâ‚ : measurable_space Î±) (mâ‚‚ : measurable_space Î²) : measurable_space (Î± Ã— Î²)
(X : Type u_4) [topological_space X] : Prop
(Î± : Type u) : Type u
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) [invertible A] : invertible A.det
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : Â¬has_sbtw.sbtw c b a
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : fintype (equiv.perm Î±)
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (g : poly Î±) : poly Î²
{Î± : Type u_1} [topological_space Î±] (s : set Î±) (hs : is_open s) : local_homeomorph Î± Î±
{Î± : Type u_1} [emetric_space Î±] (K : nnreal) (f : Î± â†’ Î±) : Prop
(p : â„•) [hp : fact (nat.prime p)] : â„• â†’ â„• â†’ mv_polynomial â„• â„¤
{F : Type u â†’ Type u} [functor F] (q : qpf F) : Prop
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [compact_space Î±] [metric_space Î²] : continuous coe_fn
{a : Prop} (b : Prop) (h : a â†” b) [D : decidable b] : decidable a
{R : Type u} [ring R] (h : is_field R) : field R
{Î± : Type u_1} [has_mul Î±] (s : set Î±) (a b : Î±) : Prop
 : Type
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C
{n : â„•} (p : fin n â†’ Prop) [decidable_pred p] {i : fin n} (hi : i âˆˆ fin.find p) : p i
(x y : pgame) : Prop Ã— Prop
(Î¹ : Type u_1) {R : Type u_2} [add_monoid Î¹] [monoid R] : graded_monoid.gmonoid (Î» (i : Î¹), R)
{n : â„•} (P : mvpfunctor (n + 1)) : mvpfunctor n
 : pos_num â†’ pos_num
{R : Type u_1} {S : Type u_3} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] : non_unital_non_assoc_semiring (R Ã— S)
{Î± : Type u} [decidable_eq Î±] [mul_zero_one_class Î±] [nontrivial Î±] : mul_zero_one_class (with_bot Î±)
(F : Type u_7) (Î± : out_param (Type u_8)) (Î² : out_param (Type u_9)) [has_sup Î±] [has_sup Î²] : Type (max u_7 u_8 u_9)
{Î± : Type u_1} (R : Î± â†’ Î± â†’ Prop) : list Î± â†’ Prop
{F : pfunctor} (R : F.M â†’ F.M â†’ Prop) : Prop
{Î± : Type u} [is_empty Î±] : unique (list Î±)
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (A : set X) (f : X â†’ Y) : X â†’ Y
{Î± : Type u} (f : thunk Î±) : Î±
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î²] [complete_lattice Î±] (gi : galois_insertion l u) : complete_lattice Î²
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : set Î±) (t : set Î²) : Prop
{p : â„•} {Î± : Type u_4} {Î² : Type u_5} (f : Î± â†’ Î²) : witt_vector p Î± â†’ witt_vector p Î²
{Î± : Type u} [ring Î±] : is_ring_hom id
(G : Type u_1) [topological_space G] [group G] [topological_group G] : subgroup G
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 1 âˆˆ S
{Î± : Type u_1} [add_monoid Î±] (s t : set Î±) (a : Î±) : set (Î± Ã— Î±)
{R : Type u} [ring R] (p q : polynomial R) : polynomial R
{G : Type u_1} [group G] (H : â„• â†’ subgroup G) : Prop
{Î± : Type u_1} [decidable_eq Î±] (l : list Î±) (H : âˆ€ (x : Î±), x âˆˆ l) : encodable Î±
(R : Type u_1) [monoid R] [star_semigroup R] : submonoid R
{M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
{R : Type u} {n : Type w} [comm_ring R] [decidable_eq n] [fintype n] (J : matrix n n R) : lie_subalgebra R (matrix n n R)
(Î± : Type u_2) [preorder Î±] : pseudo_epimorphism Î± Î±
{Î± : Type u_1} (y : Î±) : fintype {x // x = y}
 : name â†’ name
{Î± : Type u_1} : multiset Î±
(M : Type u_1) [has_mul M] : set M
{Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.bijective g) : function.bijective (function.comp g)
{Î¹ : Type u_1} (f : Î¹ â†’ cardinal) : cardinal
{Î± : Type u_2} [monoid Î±] : monoid (set Î±)
 : succ_order cardinal
 : Type (u_1+1)
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (s : set Î±) : Prop
{Î¹ : Type u_1} {M : Type u_4} [topological_space M] [has_mul M] [has_continuous_mul M] : has_continuous_mul (Î¹ â†’ M)
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} : W_type Î² â†’ (Î£ (a : Î±), Î² a â†’ W_type Î²)
(Î± : Type u_1) [metric_space Î±] : Prop
{Î± : Type u_1} [preorder Î±] (a b : Î±) : set Î±
(b : â„¤) : b â‰¤ b ^ 2
{Î± : Type} (p : parser Î±) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C
{Î± : Type u} (x : Î±) : dlist Î± â†’ dlist Î±
(n : â„•) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)
(C : Type u) [category_theory.category C] : category_theory.category (algebraic_geometry.PresheafedSpace C)
(Î± : Sort u) : Type
{Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} [contravariant_class Î± Î± has_add.add has_le.le] (h : a + c < b) : a < b - c
{Î± : Type u_1} {Î² : Type u_2} [primcodable Î±] [primcodable Î²] (f : Î± â†’ Î²) : Prop
{Î¹ : Type u_1} {f : Î¹ â†’ Type u_2} [Î  (i : Î¹), has_mul (f i)] (C : Î  (i : Î¹), con (f i)) : con (Î  (i : Î¹), f i)
(Î± : Type u) : Type u
(K : Type u) : Type u
(M : Type u_1) [monoid M] : submonoid M
{R : Type u} [semiring R] (p : polynomial R) : R
{M : Type u_1} [monoid M] (s : set M) : Prop
{m : Type u â†’ Type u_1} [monad m] {Î± Î² : Type u} (f : Î± â†’ Î± â†’ m Î²) : list Î± â†’ m (list Î²)
{M : Type u_1} [monoid M] {s t : set M} (h : s âŠ† t) : monoid.closure s âŠ† monoid.closure t
(Î± : Type uâ‚) : category_theory.small_category (category_theory.discrete Î±)
(Î± : Type u_6) : Type u_6
{Î± : Type u_1} : list Î± â†’ Prop
{X : Type u_1} [topological_space X] (x y : X) : Prop
(M : Type u_9) (N : Type u_10) [add_zero_class M] [add_zero_class N] : Type (max u_10 u_9)
(M : Type u_1) [has_add M] : set M
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (m : measurable_space Î²) : measurable_space Î±
{Î± : Type u_1} {Î¹ : Sort u_4} (p : Î¹ â†’ Prop) (s : Î¹ â†’ set Î±) : Prop
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type u
(Î± : Type) [has_zero Î±] [has_one Î±] [has_add Î±] [fintype Î±] : parser Î±
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C
{Î± : Type u_1} : has_zero (language Î±)
{Î± : Type u} : seq Î±
(C : Type u) [category_theory.category C] : Type (max v u)
 : Type
{X : Type u} [topological_space X] {xâ‚€ xâ‚ : X} (pâ‚€ pâ‚ : path xâ‚€ xâ‚) : Prop
(Î± : Type u_1) [omega_complete_partial_order Î±] : Ï‰CPO
(k : â„•) : â„• â†’ list (fin k â†’ â„•)
{Î± : Type u_2} [decidable_eq Î±] [has_inv Î±] : has_inv (finset Î±)
(b : bool) : num â†’ num
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_category (category_theory.skeleton C)
(R : Type u_1) [has_zero R] : Type u_1
{Î± : Type u_1} [decidable_eq Î±] (s : finset Î±) (F : finset (finset Î±)) : finpartition s
 : set surreal
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A B : matrix n n Î±) (h : B.mul A = 1) : invertible A
(n : â„•) : Type (u+1)
(G : Type u_2) : Type u_2
{Î± : Type u_1} [fintype Î±] : nonempty (field Î±) â†” is_prime_pow (fintype.card Î±)
{n : â„•} [fact (0 < n)] : fintype (dihedral_group n)
(m : Type u â†’ Type v) : Type (u+1)
{Î³ : Type w} [preorder Î³] [order_top Î³] (s : set Î³) : bdd_above s
{M : Type u_1} [mul_one_class M] : complete_lattice (submonoid M)
{Î¹ : Type u_1} {Î± : Type u_2} (s : Î¹ â†’ set Î±) : Type (max u_1 u_2)
{Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s
(o : ordinal) : cardinal
{Î± : Type u} {Î² : Type v} (r : rel Î± Î²) (f : filter Î²) : filter Î±
{R : Type u} [comm_ring R] (f : polynomial R) : adjoin_root f
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J â†’ C} (B : category_theory.limits.bicone F) : category_theory.limits.cocone (category_theory.discrete.functor F)
{R : Type u} [comm_semiring R] [star_ring R] : ring_aut R
{Î± : Type u_1} {Î² : Type u_2} (r : rel Î± Î²) (s : set Î²) : set Î±
 : Type (u_1+1)
(M : Type u_1) {Î± : Type u_2} [group M] [mul_action M Î±] (s : set Î±) : subgroup M
(a c b d : â„•) : Prop
{Î± : Type u} {Î² : Î± â†’ Type v} {Î´ : Type w} (f : Î´ â†’ Î  (a : Î±), Î² a â†’ Î´) (d : Î´) (m : alist Î²) : Î´
(Î± : Type u_1) : Type u_1
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
(Î± : Type u_1) [subsingleton Î±] : fintype Î±
{n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) (z : Î± (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q
{Î± : Type u} [decidable_eq Î±] (a : Î±) (as : list Î±) : list (list Î±)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] (f : measure_theory.simple_func Î± (Î² â†’ Î³)) (g : measure_theory.simple_func Î± Î²) : measure_theory.simple_func Î± Î³
{G : Type u_1} [group G] {H K : subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K
(G : out_param (Type u_1)) (P : Type u_2) [out_param (add_group G)] : Type (max u_1 u_2)
 : pgame
{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : a â‰  b
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (f : filter Î±) : Prop
{Î± : Type u} (l : ordnode Î±) : ordnode Î± â†’ ordnode Î±
(M : Type u_9) (N : Type u_10) [has_add M] [has_add N] : Type (max u_10 u_9)
(C : Type uâ‚) [category_theory.category C] : Prop
(M : Type u_1) [has_add M] : Type u_1
 : Type (u+1)
 : Type (u_1+1)
(R : Type u) (X : Type v) [comm_ring R] : basis (free_monoid X) R (free_algebra R X)
(Î± : Type u) [topological_space Î±] : Prop
(Î± : Type u_1) (Î² : Type u_2) : Type (max u_1 u_2)
{Î± : Type u_1} [uniform_space Î±] {Î² : Type u_2} [uniform_space Î²] (f : Î± â†’ Î²) : uniform_space.completion Î± â†’ Î²
 : Type
 : Type
(d : â„¤) : Type
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E
{Î¹ : Type u} (f : Î¹ â†’ cardinal) : bdd_above (set.range f)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} (u : Î¹ â†’ Î± â†’ Î²) (Ï„ : Î± â†’ Î¹) : Î± â†’ Î²
{Î± : Type u_1} {m : Type u_4} {n : Type u_5} [has_mul Î±] (A B : matrix m n Î±) : matrix m n Î±
{Î± : Type u_1} (f : Î± â†’ Î±) : set Î±
{Î± : Type u} : ordnode Î± â†’ option Î±
(R : Type u_1) [comm_ring R] : Type u_1
{Î± : Type u} {Î² : Sort u_1} (f : Î± â†’ Î² â†’ Î²) : ordnode Î± â†’ Î² â†’ Î²
{Î± : Type v} {d u n : â„•} (A : matrix (fin (u + d)) (fin n) Î±) : matrix (fin d) (fin n) Î±
{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a
{R : Type u} {Î“â‚€ : Type v} [comm_ring R] [linear_ordered_comm_group_with_zero Î“â‚€] (v : valuation R Î“â‚€) (O : Type w) [comm_ring O] [algebra O R] : Prop
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
{Î± : Type u} {u : ultrafilter (ultrafilter Î±)} {x : ultrafilter Î±} : â†‘u â‰¤ nhds x â†” x = mjoin u
(c : nat.partrec.code) (n : â„•) : nat.partrec.code
{Î“ : Type u_4} [group Î“] {T : Type u_5} [topological_space T] [mul_action Î“ T] [has_continuous_const_smul Î“ T] : is_open_map quotient.mk
{R : Type u} [ring R] (B : ring_filter_basis R) : topological_space R
{Î± : Type u_1} [encodable Î±] {n : â„•} : encodable (fin n â†’ Î±)
(Î“â‚€ : Type u_1) [linear_ordered_comm_group_with_zero Î“â‚€] (x : Î“â‚€) : filter Î“â‚€
{x y z : â„¤} (k : â„¤) (hk : k â‰  0) : pythagorean_triple (k * x) (k * y) (k * z) â†” pythagorean_triple x y z
(R : Type u) [comm_ring R] : CommRing
(X : Type u_1) [topological_space X] : Type u_1
{Î¹ : Type u_1} {M : Type u_4} [topological_space M] [has_add M] [has_continuous_add M] : has_continuous_add (Î¹ â†’ M)
{Î± : Type u_1} {Î² : Type u_2} (e : local_equiv Î± Î²) : Î² â†’ Î±
{Î± : Type u_1} [has_le Î±] (a : Î±) : Prop
{n a : â„•} (h : a < n + 1) : â†‘a.val = a
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [preorder Î±] [preorder Î²] [mul_one_class Î±] [mul_one_class Î²] : Type (max u_6 u_7 u_8)
(Î± : Type u) : Type (max 1 u)
{Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} (h : x âˆˆ s) : emetric.inf_edist x t â‰¤ emetric.Hausdorff_edist s t
{Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) (x : Î±) : Prop
{Î± : Type u_1} [metric_space Î±] {Î² : Type u} [nonempty Î²] (p : besicovitch.tau_package Î² Î±) : ordinal
{Î± : Type u_1} (k : â„•) : (vector3 Î± k â†’ Prop) â†’ Prop
 : cardinal.ord âˆ˜ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}
{Î± : Type u_1} [fintype (option Î±)] : fintype Î±
 : pos_num â†’ pos_num â†’ ordering
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter Î±) (f : Î± â†’ E) (g : Î± â†’ F) : Prop
(Î± : Type u_1) (Î² : Type u_2) [topological_space Î±] [topological_space Î²] [add_monoid Î²] [has_continuous_add Î²] : add_submonoid (Î± â†’ Î²)
{E : â„• â†’ Type u_1} [Î  (n : â„•), topological_space (E n)] [âˆ€ (n : â„•), discrete_topology (E n)] : metric_space (Î  (n : â„•), E n)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C
{R : Type u} [semiring R] (p q : polynomial R) : polynomial R
 : sign_type â†’ sign_type â†’ sign_type
{Î± : Type u_1} (f : Î± â†’ nnreal) : filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
(Î± : Type u) : Type u
(G : Type u_1) [measurable_space G] [has_sub G] : Prop
{Î± : Type u_1} {m : multiset Î±} {p : Î± â†’ Prop} [decidable_pred p] : decidable (âˆƒ (x : Î±) (H : x âˆˆ m), p x)
(p : nnreal) (h : p â‰¤ 1) : pmf bool
(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] : Type (max u v)
{Î± : Type u} [right_cancel_monoid Î±] : has_faithful_smul Î± Î±
{n : â„•} (a : zmod n) : â†‘â†‘a = a
{R : Type u} [non_assoc_semiring R] : has_top (subsemiring R)
{Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : a / c < b / d â†’ (a * d - b * c) / (c * d) < 0
(G : Type u_3) [group G] [h : group.fg G] [decidable_pred (Î» (n : â„•), âˆƒ (S : finset G), S.card = n âˆ§ subgroup.closure â†‘S = âŠ¤)] : â„•
 : has_sub ordinal
(M : Type u_1) [monoid M] [measurable_space M] [has_measurable_mulâ‚‚ M] : has_measurable_pow M â„•
(F : Type u_1) (Î± : out_param (Type u_2)) (Î² : out_param (Type u_3)) [has_le Î±] [has_le Î²] : Type (max u_1 u_2 u_3)
(K : Type u) (V : Type v) [semiring K] [add_comm_monoid V] [module K V] : cardinal
{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a â‰  0
(B : Type u_1) (F : Type u_2) : B â†’ Type u_2
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : initial_seg r r
 : Type (u+1)
 : Type
(R : Type u) [ring R] (hf : is_field R) (x : R) : x â‰  0 â†’ (âˆƒ! (y : R), x * y = 1)
 : â„•
{Î± : Type u_1} [encodable Î±] : encodable (plift Î±)
{Î± : Type} (p : parser Î±) : parser (list Î±)
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (Î» (g : G), g + h + -g)
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} (hf : âˆ€ (x y : Î²), f x = f y) : measurable f
{Î± : Type u} (l : list Î±) : l â‰  list.nil â†’ stream Î±
{Î² : Type u_2} (f : equiv.perm Î²) : Prop
{X : Type u} (m : X â†’ X â†’ X) (e : X) : Prop
(F : Sort u_1) (Î± : out_param (Sort u_2)) (Î² : out_param (Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3))
 : has_zero onote
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.fst
(p : â„•) (R : Type u_1) [comm_ring R] [invertible â†‘p] : â„• â†’ mv_polynomial â„• R
 : pSet â†’ pSet
{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s â†’ is_closed s
(Î“ : Type u_1) (R : Type u_2) [partial_order Î“] [add_comm_monoid R] (Î± : Type u_3) : Type (max u_1 u_2 u_3)
(Gâ‚€ : Type u_1) [measurable_space Gâ‚€] [has_div Gâ‚€] : Prop
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (s : subsemiring R) (t : subsemiring S) : subsemiring (R Ã— S)
(o : ordinal) : cardinal
(Î± : Type u) (Î² : Type v) : Type (max u v)
{C : Type uâ‚} [category_theory.category C] (A : C) : Prop
(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [char_zero k] {n : â„•} (h : s.card = n + 1) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
{Î± : Type u_1} [decidable_eq Î±] (x y : Î± Ã— Î±) : bool
{Î± : Type u_3} [linear_ordered_add_comm_group Î±] : filter.tendsto has_abs.abs filter.at_bot filter.at_top
(Î± : Type u) {Î² : Type v} [monoid Î±] [mul_action Î± Î²] (b : Î²) : set Î²
{Î± : Type u_1} (r : setoid Î±) : Î± â†’ Î± â†’ Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C
(Î± : Type u_1) (Î² : Type u_2) [uniform_space Î²] : topological_space (Î± â†’ Î²)
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : Type u_1
(V : Type u) [quiver V] : Type (max u v)
{R : Type u_1} [cancel_monoid R] (g : R) : is_regular g
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} {Î² : Type u_2} [add_zero_class Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_monoid_hom f) : is_add_monoid_hom (Î» (a : Î±), -f a)
 : Type
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} (di : dense_inducing i) [topological_space.separable_space Î±] : topological_space.separable_space Î²
(Î± : Type u_1) [ring Î±] : Type u_1
(o : nonote) : ordinal
(K : Type u_1) : Type u_1
(K : Type u_1) [division_ring K] [topological_space K] : Prop
{Î± : Type u_1} {Î² : Type u_2} (s : finset Î±) (t : finset Î²) : finset (Î± Ã— Î²)
 : Type (max (u+1) u (v+1))
{H : Type u_1} [topological_space H] (G : structure_groupoid H) (f : H â†’ H) (s : set H) (x : H) : Prop
(R : Type u_1) {V : Type u_2} {P : Type u_4} [ring R] [invertible 2] [add_comm_group V] [module R V] [add_torsor V P] (x y : P) : P
 : num â†’ num â†’ num
(Î± : Type u_3) : Type u_3
(G : Type u) : Type u
(Î± : Type u) : Type u
{Î± : Sort u} {Î² : Î± â†’ Sort v} {fâ‚ fâ‚‚ : Î  (x : Î±), Î² x} (h : âˆ€ (x : Î±), fâ‚ x = fâ‚‚ x) : fâ‚ = fâ‚‚
(v : list bool) : â„•
{A : Type u_1} [semiring A] [algebra ennreal A] : algebra nnreal A
(Î± : Type u_3) [topological_space Î±] : Type u_3
(p : â„•) (a : â„¤) [hp : fact (nat.prime p)] : â†‘(zmod.legendre_sym p a) = â†‘a ^ (p / 2)
(Î± : Type u) : â„• â†’ Type u
{M : Type u_1} [add_monoid M] (x : M) : set M
{Î± : Type u_1} (s t : multiset Î±) : Prop
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_5} [normed_field ð•œ] [add_comm_group E] [module ð•œ E] (p : seminorm_family ð•œ E Î¹) : set (set E)
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
{Î± : Type u} [add_group Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} (h : 0 â‰¤ a) : -a â‰¤ a
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_injectives C] (Z : C) : cochain_complex C â„•
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] (m : Î  (i : Î¹), measure_theory.outer_measure (Î± i)) (s : set (Î  (i : Î¹), Î± i)) : ennreal
{p : â„•} : padic_val_nat p 0 = 0
 : Type (u_1+1)
{ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst
{Î± : Type u} {Î² : Î± â†’ Type v} (s : alist Î²) : list Î±
(X : Type u) [comm_ring X] [topological_space X] [topological_ring X] : TopCommRing
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} (F : Î  (a : Î±), equiv.perm (Î² a)) : equiv.perm (Î£ (a : Î±), Î² a)
(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M
{Î± : Type u_1} {Î² : Type u_2} [encodable Î±] [encodable Î²] : Î± âŠ• Î² â†’ â„•
{Î“â‚€ : Type u_1} [linear_ordered_comm_group_with_zero Î“â‚€] (Î³ : Î“â‚€) (h : Î³ â‰  0) : {x : Î“â‚€ | x < Î³} âˆˆ nhds 0
{Î± : Type u_1} [has_Inf Î±] {Î¹ : Sort u_2} (s : Î¹ â†’ Î±) : Î±
 : num â†’ num â†’ num
(M : Type u_1) [monoid M] : mul_action M M
{Î± : Type u} (Î² : Î± â†’ Type v) : Type (max u v)
{Î± : Type u} (s : computation Î±) : Prop
{R : Type u_1} {S : Type u_3} [semiring R] [semiring S] : semiring (R Ã— S)
(c : omega.clause) : Prop
{m : Type u_2} {n : Type u_3} {Î± : Type v} [non_unital_non_assoc_semiring Î±] [fintype m] (v : m â†’ Î±) (M : matrix m n Î±) : n â†’ Î±
{G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G
{M : Type u_1} [monoid M] (n : M) : submonoid M
(p : â„•) (R : Type u_1) [comm_ring R] (n : â„•) : mv_polynomial â„• R
{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M) : sub_mul_action R M
{Î± : Type u_1} : list Î± â†’ â„• â†’ list Î±
{K : Type w} [field K] {f : polynomial K} (hf : f â‰  0) : power_basis K (adjoin_root f)
(n : â„•) : multiset (â„• Ã— â„•)
{Î± : Type u} [topological_space Î±] (x : Î±) (F : filter Î±) : Prop
{n : Type u_3} {Î± : Type v} [has_star Î±] : has_star (matrix n n Î±)
{Î± : Type u_1} [preorder Î±] [order_bot Î±] [locally_finite_order Î±] (b : Î±) : finset Î±
(n : â„•) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R â‰  0
{Î± : Type u_1} (c : set (set Î±)) (H : âˆ€ (a : Î±), âˆƒ! (b : set Î±) (H : b âˆˆ c), a âˆˆ b) : setoid Î±
{n : â„•} {Î± : Type u_1} (v : vector Î± (n + 1)) : Î±
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b
 : category_theory.grothendieck_topology (Type u)
(n : â„•) : option â„• â†’ Prop
(V : Type v) [category_theory.category V] [category_theory.monoidal_category V] (C : Type uâ‚) : Type (max uâ‚ v w)
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [normalization_monoid Î±] [decidable_eq Î±] (h : âˆ€ (a b : Î±), âˆƒ (c : Î±), âˆ€ (d : Î±), d âˆ£ a âˆ§ d âˆ£ b â†” d âˆ£ c) : normalized_gcd_monoid Î±
{R : Type u} [ring R] (s : subring R) : 1 âˆˆ s
(R : Type u) [ring R] : Type u
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (a : ulift Î±) : ulift Î²
{Î¹ : Type u} (f : Î¹ â†’ cardinal) : cardinal
{Î± : Type u_1} [has_mul Î±] (a : Î±) (s : set Î±) : set Î±
{n : Type u_3} {Î± : Type v} (A : matrix n n Î±) (i : n) : Î±
{Î± : Type u} (sâ‚ sâ‚‚ : seq Î±) : seq Î±
{Î± : Type u_1} (ð’œ : finset (finset Î±)) (r : â„•) : finset (finset Î±)
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (P : C â†’ Prop) : Type
(n : â„•) : Type (u_1+1)
(K : Type u) [field K] (V : FinVect K) : FinVect K
{Î± : Type u_1} (l : list Î±) : list (list Î±)
(n m : â„•) : list â„•
{a : â„•} : â„¤
(L : first_order.language) : Type (max u v)
(l : list â„•) (h : âˆ€ (p : â„•), p âˆˆ l â†’ nat.prime p) : prime_multiset
{Î± : Type u} (f : filter Î±) : Prop
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ option Î±
{Î± : Type u} : Î± Ã— list Î± Ã— Î± Ã— list Î± â†’ Î±
(Î± : Type u) [uniform_space Î±] : setoid Î±
(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_anti f
(Î± : Type u_1) : Type u_1
{Î± : Type u} {Î³ : Type u_1} [topological_space Î³] (f : Î± â†’ Î³) : ultrafilter Î± â†’ Î³
 : num â†’ num â†’ num
 : Type
{Î± : Type u_1} [comm_monoid Î±] [decidable_rel has_dvd.dvd] (a b : Î±) : enat
{Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} [preorder Î±] [decidable_rel has_le.le] (x : Î±) (s : ordset Î±) : bool
(Î± : Sort u_1) : decidable_eq Î±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Type (max u v)
(K : Type u_1) [field K] [uniform_space K] : Prop
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A Ã— B) A
(V : Type u_1) [quiver V] : Type (max u_1 v)
{Î± : Type u} {Î² : Î± â†’ Type v} (f : Î  (x : Î±), Î² x â†’ bool) (s : finmap Î²) : bool
{Î± : Type u_1} [linear_order Î±] : finset Î± â†’ option Î±
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{Î± : Type u} {Lâ‚ Lâ‚‚ Lâ‚ƒ : list (Î± Ã— bool)} : free_group.red Lâ‚ Lâ‚‚ â†’ free_group.red Lâ‚ Lâ‚ƒ â†’ relation.join free_group.red Lâ‚‚ Lâ‚ƒ
{n : Type u'} [fintype n] [decidable_eq n] {Î± : Type u_1} [non_assoc_semiring Î±] (v : n â†’ Î±) [invertible v] : invertible (matrix.diagonal v)
{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : â†‘âŠ¤ = set.univ
 : category_theory.limits.has_limits_of_size AddCommGroup
 : list â„• â†’ â„• â†’ list â„•
{Î± : Type u_1} [monoid Î±] (p : Î±) : Prop
(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C
(X : Type u) : category_theory.projective X
(L : first_order.language) (L' : first_order.language) : first_order.language
{C : Type u} [category_theory.category C] (X : Top) (Z : C) : algebraic_geometry.PresheafedSpace C
{C : Type u} [category_theory.category C] (G : C) : Prop
(R : Type u_1) [add_comm_group R] [star_add_monoid R] : add_subgroup R
{Î± : Type u_1} {Î² : Type u_2} [has_add Î±] (f : Î± â†’ Î²) (c : Î±) : Prop
{Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î² â†’ Prop) (t : finset Î²) (a : Î±) [decidable_pred (r a)] : finset Î²
{R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) (b : o â†’ â„•) : Prop
{R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj
(k : â„•) : nat.partrec.code â†’ â„• â†’ option â„•
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C
{Î± : Type u_1} {m : Type u_1 â†’ Type u_2} [monad m] (x : m (option Î±)) (y : m Î±) : m Î±
{Î± : Type u_1} : list Î± â†’ list (list Î±)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (f : Î± â†’ Î² â†’ Î³) (s1 : wseq Î±) (s2 : wseq Î²) : wseq Î³
{Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_edist.edist x y = â†‘(has_nndist.nndist x y)
{Î± : Type u_1} [preorder Î±] [order_top Î±] [locally_finite_order Î±] (a : Î±) : multiset Î±
{Î± : Type u_1} (f : Î± â†’ Î± â†’ Î±) : option Î± â†’ option Î± â†’ option Î±
(p : â„•) [hp : fact (nat.prime p)] : â„• â†’ mv_polynomial (fin 2 Ã— â„•) â„¤
{Î³ : Type u_1} [U : uniform_space Î³] (m : metric_space Î³) (H : uniformity Î³ = uniformity Î³) : metric_space Î³
{G : Type u} [group G] : inhabited (group_filter_basis G)
{C : Type u} [category_theory.category C] : partial_order (category_theory.grothendieck_topology C)
{Î± : Type u_1} : has_inf (setoid Î±)
(x y : Set) : Prop
{Î± : Type u_1} (l : list Î±) : list (list Î±)
{G : Type u_1} [group G] [is_free_group G] : is_free_group.generators G â†’ G
{Î¹ : Type u_1} (M : Î¹ â†’ Type u_2) [Î  (i : Î¹), monoid (M i)] : free_monoid (Î£ (i : Î¹), M i) â†’ free_monoid (Î£ (i : Î¹), M i) â†’ Prop
{Î± : Type u_1} [dec : decidable_eq Î±] : regular_expression Î± â†’ Î± â†’ regular_expression Î±
{X : Type u_1} [topological_space X] (s : set X) (hâ‚ : is_closed s) (hâ‚‚ : is_compact s) : topological_space.opens (alexandroff X)
(k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible â†‘(fintype.card G)] : monoid_algebra k G
 : category_theory.limits.has_limits_of_size CommGroup
(L R : list pgame) : pgame
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C
(n : â„•) : simplex_category
{Î¹ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] (u : Î¹ â†’ set X) (s : set X) : Type (max u_1 u_2)
{Î± : Type u_1} [topological_space Î±] {s : set Î±} : measure_theory.analytic_set s â†” âˆƒ (Î² : Type) (h : topological_space Î²) (h' : polish_space Î²) (f : Î² â†’ Î±), continuous f âˆ§ set.range f = s
{Î± : Type u_1} (g : generalized_continued_fraction Î±) : seq Î±
{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a âˆˆ s) : powers a âŠ† s
{Î¹ : Type u_1} (Î± : Î¹ â†’ Type u_2) (l : list Î¹) : Type (max u_2 u_3)
{Î± : Type u} [preorder Î±] {a b c : Î±} : a < b â†’ b < c â†’ a < c
(Î± : Type u_1) [lattice Î±] [bounded_order Î±] : Prop
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [decidable_eq Î±] [normalization_monoid Î±] [unique_factorization_monoid Î±] (a : Î±) : multiset Î±
{Î± : Type u} {Î¹ : Sort w} (r : Î± â†’ Î± â†’ Prop) (f : Î¹ â†’ Î±) : Prop
 : pgame â†’ pgame â†’ Type (u+1)
{n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) (i : fin n) : Î± i.succ
{Î¹ : Type u_1} (H : Î¹ â†’ Type u_2) : Type (max u_1 u_2)
 : â„• â†’ â„• â†’ â„• â†’ â„•
(R : Type u_1) (M : Type u_2) [comm_ring R] [topological_space R] [add_comm_group M] [module R M] : Type u_2
{Î¹ : Type u_1} (R : Type u_3) {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] (x : Î¹ â†’ A) : Prop
 : Type
{Î± : Type u_2} [subtraction_monoid Î±] {a : Î±} : even a â†’ even (-a)
 : Set â†’ Set
{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.reduce (free_group.reduce L) = free_group.reduce L
(X : Type u_3) [topological_space X] : Type u_3
(Î± : Type u) : Type u
 : Type
(H : Type u_5) [topological_space H] : Type u_5
{Î± : Type u} {Î² : Type v} (R : Î± â†’ Î² â†’ Prop) (s : wseq Î±) (t : wseq Î²) : Prop
{Î± : Type u_2} [comm_monoid Î±] : comm_monoid (set Î±)
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] (ð’œ : finset (finset Î±)) : finset (finset Î±)
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (tâ‚ tâ‚‚ : ordnode Î±) : bool
{m : Type â†’ Type v} [monad m] {Î± : Type} (p : Î± â†’ m bool) (xs : list Î±) : m (option Î±)
{R : Type u_1} [comm_ring R] : lie_ring (fin 3 â†’ R)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} [metric_space Î²] [preorder Î¹] (f : Î¹ â†’ Î± â†’ Î²) (g : Î± â†’ Î²) (n : â„•) (j : Î¹) : set Î±
 : num â†’ â„•
{R : Type u} [semiring R] (p : polynomial R) : R
{Î± : Sort u_1} {p : Î± â†’ Prop} {C : Sort u} (H0 : C) (H : Î  (a : Î±), p a â†’ C) : C
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (N : Type u_2) [add_comm_monoid N] : Type (max u_1 u_2)
(P : â„• â†’ Prop) (n : â„•) : mv_polynomial â„• â„¤
(Î± : Type u_1) [complete_semilattice_Inf Î±] : complete_lattice Î±
{Î± : Type u} (s : wseq Î±) : computation bool
 : Type (u_1+1)
{Î± : Type u} {Î² : Type v} [semiring Î±] [semiring Î²] (f : Î± â†’ Î²) : Prop
(Î± : Type u) (Î² : Type v) [add_monoid Î±] [add_action Î± Î²] (g : Î±) : set Î²
{Î± : Type u} : nonempty (field Î±) â†” is_prime_pow (cardinal.mk Î±)
{Î¹ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [add_monoid Î¹] [monoid R] (A : Î¹ â†’ S) [set_like.graded_monoid A] : submonoid R
 : Type (u_1+1)
(p : â„•) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : â„•) : (fin (n + 1) â†’ k) â†’ (fin (n + 1) â†’ k) â†’ k
{S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c
 : Type (u+1)
{Î± : Type u_2} [has_add Î±] {a : Î±} : even a â†’ (âˆƒ (b : Î±), a = bit0 b)
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (s : multiset Î±) : multiset Î±
 : has_add surreal
{Î± : Type u} [pseudo_emetric_space Î±] {s t u : set Î±} : emetric.Hausdorff_edist s u â‰¤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : continuous Z.proj
{Î± : Type u_1} [preorder Î±] (a : Î±) : ordset Î±
{Î± : Type u_1} [encodable Î±] : encodable (multiset Î±)
{V : Type u} [quiver V] (r : V) : Prop
{Î± : Type u_1} : ordnode Î± â†’ â„•
{a : nnreal} : add_le_cancellable â†‘a
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L
{Î± : Type u_1} {Î² : Type u_2} (rÎ± : Î± â†’ Î± â†’ Prop) (rÎ² : Î² â†’ Î² â†’ Prop) (f : Î± â†’ Î²) : Prop
(Î± : Type u_1) : Type u_1
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type u_1} [is_noetherian K V] (b : basis Î¹ K V) : fintype Î¹
{Î³ : Type w} [metric_space Î³] : emetric_space Î³
{R : Type u_1} [has_mul R] (c : R) : Prop
{Î± : Type u_1} {s : finset Î±} {Î² : Î± â†’ Type u_2} [h : Î  (a : Î±), decidable_eq (Î² a)] : decidable_eq (Î  (a : Î±), a âˆˆ s â†’ Î² a)
{p : â„•} (hp : 1 < p) : padic_val_nat p p = 1
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j j' : C) : C
{R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R
{Î± : Type u} {Î² : Type v} [has_le Î²] (l : filter Î±) (f g : Î± â†’ Î²) : Prop
{Î± : Type u_1} (n : â„•) (l : list Î±) : list (multiset Î±)
(M : Type u) [add_monoid M] : AddMon
{Î± : Type u_1} {A : Type u_5} [add_monoid A] [monoid Î±] [distrib_mul_action Î± A] : mul_action Î± (add_submonoid A)
 : Type
{Î± : Type u} : list Î± â†’ ordnode Î± â†’ â„• â†’ ordnode Î±
(Î± : Type u_1) [preorder Î±] : Type u_1
{Î± : Type u} {Î² : Type v} [has_add Î²] (f : Î± â†’ Î²) : free_add_magma Î± â†’ Î²
(Î± : Type u_3) [uniform_space Î±] [group Î±] : Prop
{Î± : Type u_1} [has_mul Î±] (s : set Î±) (a : Î±) : set Î±
(M : Type u_1) [has_zero M] : zero_hom M M
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : Type u_2
{Î± : Type u} {Î² : Type v} (f : Î² â†’ option (Î± Ã— Î²)) (b : Î²) : seq Î±
{Î± : Type u_1} (G : simple_graph Î±) (s : set Î±) : Prop
{Î± : Type u} [topological_space Î±] (s : set Î±) : Prop
 : â„• â†’ Type
{k : Type uâ‚} {G : Type uâ‚‚} [semiring k] [has_zero G] : has_one (add_monoid_algebra k G)
(R : Type u) [non_assoc_semiring R] : galois_insertion subsemiring.closure coe
{H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e âˆˆ charted_space.atlas H H â†” e = local_homeomorph.refl H
{n : â„•} (Î± : typevec (n + 1)) : Type u
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C
{Î± : Type u_1} {Î² : Type u_2} [encodable Î±] [fintype Î±] [encodable Î²] : encodable (Î± â†’ Î²)
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ finset.nat.antidiagonal n â†” x.fst + x.snd = n
{Î± : Type u_1} [decidable_eq Î±] (a : Î±) : list Î± â†’ list â„•
{Î± : Type u_1} {Î² : Type u_2} (r : rel Î± Î²) : rel Î² Î±
{Î± : Type u_1} {Î² : Type u_2} [partial_order Î²] (f : Î± â†’ Î²) (inj : function.injective f) : partial_order Î±
(o : ordinal) : ordinal
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] (F : Î¹ â†’ Î± â†’ Î²) (f : Î± â†’ Î²) (p : filter Î¹) : Prop
(Î± : Sort u_1) (Î² : Sort u_2) : Sort (max 1 (imax u_1 u_2))
{Î± : Type u_1} [conditionally_complete_lattice Î±] (a : Î±) : has_Inf.Inf {a} = a
{X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X) : Prop
(C : Type u) [category_theory.category C] [category_theory.non_preadditive_abelian C] : category_theory.abelian C
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] : ordnode Î± â†’ ordnode Î± â†’ ordnode Î±
{R : Type u} [semiring R] (p : polynomial R) (n : â„•) (a : R) : polynomial R
{ð•œ : Type u} {A : Type v} [field ð•œ] [ring A] [algebra ð•œ A] [nontrivial A] : spectrum ð•œ 0 = {0}
{R : Type u_1} [mul_zero_class R] : is_regular 0 â†” subsingleton R
{Î± : Type u_1} (C : set (set Î±)) : Prop
(G : Type u_1) [measurable_space G] [has_sub G] : Prop
(p : â„•) (R : Type u_1) [hp : fact (nat.prime p)] [comm_ring R] : comm_ring (witt_vector p R)
{Î¹ : Type u_1} {Î± : Type u_3} {Î² : Type u_4} [preorder Î±] [preorder Î²] (f : Î¹ â†’ Î±) (g : Î¹ â†’ Î²) (s : set Î¹) : Prop
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (h : 0 âˆˆ M) : unique S
{Î± : Type u_1} {Î¹ : Type u_2} {Îº : Type u_3} (C : (Î¹ â†’ option Î±) â†’ Îº) : Type (max u_1 u_2 u_3)
{Î± : Type u_1} (lâ‚ lâ‚‚ : list Î±) : Prop
(R : Type u) [ring R] (Î“â‚€ : out_param (Type v)) [linear_ordered_comm_group_with_zero Î“â‚€] : Type (max u v)
{Î¹ : Type u_1} (c : complex_shape Î¹) : complex_shape Î¹
{M : Type u_5} [add_comm_group M] : unique (module â„¤ M)
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C
{Î± : Type u_1} [measurable_space Î±] (s : set Î±) : measure_theory.measure Î±
{Î± : Type u_2} [has_sub Î±] : has_sub (filter Î±)
{Î± : Type u_1} [has_mul Î±] [has_le Î±] [contravariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} (bc : a * b â‰¤ a * c) : b â‰¤ c
(a b c : â„¤) : Prop
 : Type
 : Type
{Î± : Type u} [pseudo_metric_space Î±] : metric.diam âˆ… = 0
{R : Type u_1} [has_add R] (c : R) : Prop
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space.separable_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (h : dense_range f) (h' : continuous f) : topological_space.separable_space Î²
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (Î» (g : G Ã— G), g.fst + g.snd + -g.fst)
(M : Type u_1) [add_monoid M] [measurable_space M] [has_measurable_addâ‚‚ M] : has_measurable_smulâ‚‚ â„• M
{Î± : Type u} (s : seq Î±) (n : â„•) : Prop
(Î± : Type) [has_zero Î±] [has_one Î±] [has_add Î±] (fromc toc : char) : parser Î±
{K : Type u} [field K] (s : subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom B (A Ã— B)
{n : â„•} : zmod n â†’ â„¤
(x : Class) : Class
{Î± : Type u_1} {A : Type u_3} [has_zero A] (f : Î± â†’ A) : set Î±
(R : Type u) [semiring R] (P : Type (max u v)) [add_comm_monoid P] [module R P] : Prop
(Î± : Sort u) : Sort (max 1 u)
{Î± Î² : Type u} {F : Type u â†’ Type u} [applicative F] [is_comm_applicative F] [decidable_eq Î²] (f : Î± â†’ F Î²) (s : finset Î±) : F (finset Î²)
{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (P : Prop) [decidable P] (a b : Î±) : f (ite P a b) = ite P (f a) (f b)
(C : Type uâ‚) [category_theory.category C] : Prop
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Prop
{Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : Î±) (s : finset Î±) : Prop
 : onote â†’ onote Ã— â„•
(S : Type u_4) (M : out_param (Type u_5)) [has_add M] [set_like S M] : Type
{Î± : Type u_1} [conditionally_complete_lattice Î±] : conditionally_complete_lattice (with_top Î±)
{Î± : Type u_1} : list Î± â†’ Prop
(p : Set â†’ Prop) : Class.iota p âˆˆ Class.univ
{p : â„•} {R : Type u_1} (x : witt_vector p R) (n : â„•) : witt_vector p R
(Î± : Type u_1) : Type u_1
{ð•œ : Type u_1} {E : Type u_2} [ordered_ring ð•œ] [add_comm_group E] [module ð•œ E] (K : geometry.simplicial_complex ð•œ E) : set E
(Î± : Type u) : Type u
{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a
{Î± : Type u} : dense_range has_pure.pure
{V : Type u} : has_inf (simple_graph V)
{n : Type u} [decidable_eq n] [fintype n] {Î± : Type v} [comm_ring Î±] (A : matrix n n Î±) : matrix n n Î±
{n : â„•} {C : fin n.succ â†’ Sort u_1} (H0 : C 0) (Hs : Î  (i : fin n), C i.succ) (i : fin n.succ) : C i
{X : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [fintype Î±] [topological_space X] (f : Î± â†’ locally_constant X Î²) : locally_constant X (Î± â†’ Î²)
{R : Type uâ‚} [non_unital_non_assoc_semiring R] : is_scalar_tower â„• R R
{Î± : Type u_1} {Î² : Type u_2} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] (K : nnreal) (f : Î± â†’ Î²) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_products C
{P : pfunctor} : P.W â†’ P.A
 : has_pow ordinal ordinal
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) : submonoid R
{G : Type u_1} [group G] (H : subgroup G) : â„•
 : Type
{Î± : Type u_1} {Î² : Type u_2} (ea : equiv.perm Î±) (eb : equiv.perm Î²) : equiv.perm (Î± âŠ• Î²)
(V : Type u) : simple_graph V
{Î± : Sort u_1} : trunc Î± â†’ Î±
 : category_theory.is_equivalence Compactum_to_CompHaus
{M : Type u_1} [has_add M] : has_top (add_subsemigroup M)
{Î± : Sort u} [decidable_eq Î±] (a b r : Î±) : Î±
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : Prop
{R : Type u_1} {S : Type u_3} [ring R] [ring S] : ring (R Ã— S)
{Î± : Type u_1} {Î² : Type u_2} : list Î± â†’ list Î² â†’ list (Î± Ã— option Î²) Ã— list Î²
{Î¹ : Type u_1} {ð•œ : Type u_3} [is_R_or_C ð•œ] [fintype Î¹] [decidable_eq Î¹] (i : Î¹) (a : ð•œ) : euclidean_space ð•œ Î¹
{Î± : Type u_1} (l : ordnode Î±) (x : Î±) (r : ordnode Î±) : ordnode Î±
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (l : list Î±) : list (â„• Ã— Î±)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] (F : Î¹ â†’ Î± â†’ Î²) (p : filter Î¹) (s : set Î±) : Prop
(p : Type u_2) (q : Type u_3) (R : Type uâ‚‚) [decidable_eq p] [decidable_eq q] [comm_ring R] [fintype p] [fintype q] : lie_subalgebra R (matrix (p âŠ• q) (p âŠ• q) R)
(X : Type u_1) [topological_space X] : Prop
{n : â„•} (P : mvpfunctor (n + 1)) : pfunctor
{X : Top} (F : Top.presheaf (Type v) X) : Top.sheaf (Type v) X
{Î¹ : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering Î¹ X s) (U : Î¹ â†’ set X) : Prop
{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : continuous (Î» (x : Î±), metric.inf_nndist x s)
{Î± : Type u} {Î² : Type v} [uniform_space Î±] [semilattice_sup Î²] (u : Î² â†’ Î±) : Prop
{Î± : Type u_1} (s : finset Î±) [decidable_eq Î±] : finset (Î± Ã— Î±)
(Î± : Type u) (Î² : Type v) : Type (max u v)
{k : â„•} {A : finset â„•} (hâ‚ : âˆ€ {x : â„•}, x âˆˆ A â†’ x < k) : A.sum (has_pow.pow 2) < 2 ^ k
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_sbtw.sbtw c b a
 : omega.nat.preterm â†’ option (omega.nat.preterm Ã— omega.nat.preterm)
(n : â„•) : filter.tendsto (Î» (x : â„), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-xâ»Â¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
(Î± : Type u_1) [preorder Î±] : circular_preorder Î±
{H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] : has_groupoid M (continuous_groupoid H)
(n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1
{Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [preorder Î²] (f : Î± â†’ Î²) (x : Î±) : Prop
{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a â‰  b â†’ order.succ a â‰  order.succ b
{Î± : Type u_1} (o : option Î±) : finset Î±
{Î± : Type u_1} {Î² : Type u_2} [fintype Î±] [decidable_eq Î²] {f : Î± â†’ Î²} (f_bij : function.bijective f) (b : Î²) : Î±
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (sym : symmetric r) : set (sym2 Î±)
{Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : b - (b - a) â‰¤ a
{M : Type u_1} [has_add M] (r : M â†’ M â†’ Prop) : M â†’ M â†’ Prop
(a b : nonote) : Prop
{P : Type u_1} [has_le P] : partial_order (order.ideal P)
{Î± : Type u_1} [has_lt Î±] : ordering â†’ Î± â†’ Î± â†’ Prop
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} (r : Î± â†’ Î² â†’ Prop) (f : Î± â†’ Î³) (g : Î² â†’ Î´) : Î³ â†’ Î´ â†’ Prop
{Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£ (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚
(M : Type u_1) [add_zero_class M] : galois_insertion add_submonoid.closure coe
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [semilattice_sup Î²] [order_bot Î²] [has_zero Î²] (i : â„• â†’ Î²) (f : Î± â†’ Î²) (n : â„•) : measure_theory.simple_func Î± Î²
 : list bool â†’ â„•
(x : â„•) : Prop
{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) [comm_ring K] [algebra A K] [is_fraction_ring A K] (hS : S â‰¤ non_zero_divisors A) : subalgebra A K
{B : Type u_3} (Eâ‚ : B â†’ Type u_6) (Eâ‚‚ : B â†’ Type u_7) [topological_space (bundle.total_space Eâ‚)] [topological_space (bundle.total_space Eâ‚‚)] : topological_space (bundle.total_space (Î» (x : B), Eâ‚ x Ã— Eâ‚‚ x))
(Î¹ : Type u_1) (R : Type u_3) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_3 u_5)
{Î± : Type u_1} [generalized_boolean_algebra Î±] (f : â„• â†’ Î±) : â„• â†’ Î±
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] : Prop
(Î± : Type u_1) (Î² : Type u_2) [uniform_space Î²] (ð”– : set (set Î±)) : uniform_space (Î± â†’ Î²)
(Î± : Type u_2) [preorder Î±] [bounded_order Î±] : bounded_order_hom Î± Î±
(M : Type u_1) [measurable_space M] [has_add M] : Prop
{Î± : Type u_1} [bornology Î±] {p : Î± â†’ Prop} : bornology.is_bounded {x : Î± | p x} â†’ bounded_space (subtype p)
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 â‰  1 âˆ¨ âˆ€ (a : Mâ‚€), a = 0
 : â„¤ â†’ option â„•
{Î± : Type u_1} (g : generalized_continued_fraction Î±) : Prop
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : Î± â†’ Î²} (de : dense_embedding e) [topological_space.separable_space Î±] : topological_space.separable_space Î²
{Î± : Type u} [topological_space Î±] [t2_space Î±] {s : set Î±} (hs : is_compact s) : is_closed s
(S : Type u_1) [ring S] (a : â„•) : â†‘(a.desc_factorial 2) = â†‘a * (â†‘a - 1)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [normed_lattice_add_comm_group Î²] : semilattice_inf (bounded_continuous_function Î± Î²)
{n : â„•} : bitvec n â†’ bitvec n
{C : Type u} [category_theory.category C] {X : C} : monoid (category_theory.End X)
 : Type
(Î± : Sort u_1) : Prop
{Î± : Type u_1} [circular_preorder Î±] {a b c d : Î±} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d
{G : Type u_1} [add_group G] (K V : set G) : â„•
{Î± : Type u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (b : Î²) : option Î±
(a b : znum) : num
(p : Set â†’ Set â†’ Prop) (x y : Set) : Set
{Î± : Type u_1} [has_lt Î±] (s : set Î±) : Prop
{V : Type u} (G : simple_graph V) : set (sym2 V)
{Î± : Type u_1} (l : list Î±) : list (Î± Ã— Î±)
(ð•œ : Type u_1) [is_R_or_C ð•œ] (n : Type u_2) [fintype n] : Type (max u_2 u_1)
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (b : Î² a) (s : alist Î²) : alist Î²
(G : Type u) [topological_space G] [has_neg G] : Prop
{Î± : Type u_1} {Î² : Type u_2} (f : filter Î±) (h : set Î± â†’ set Î²) : filter Î²
 : Type (u_1+1)
(Î± : Type u_6) (Î² : Type u_7) [preorder Î±] [preorder Î²] [topological_space Î±] [topological_space Î²] : Type (max u_6 u_7)
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_well_order Î± r] : principal_seg r has_lt.lt
{Î± : Type u} (s : wseq Î±) : Prop
 : nat.arithmetic_function â„¤
{R : Type uâ‚} [non_unital_non_assoc_ring R] : smul_comm_class â„¤ R R
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : a * b < c â†’ b < aâ»Â¹ * c
 : Type (u+1)
{M : Type u_1} [has_add M] (c : add_con M) : Type u_1
{Î± : Type u_1} (n : â„•) (x : Î±) : function.is_periodic_pt id n x
 : category_theory.limits.has_limits_of_size SemiRing
{Î± : Sort u_1} (p : Î± â†’ Prop) : decidable_pred p
(p : â„•) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (m : â„¤) : witt_vector.isocrystal p k (witt_vector.standard_one_dim_isocrystal p k m)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
 : nzsnum â†’ bool
{Î± : Type u_2} [has_one Î±] : has_one (set Î±)
{C : Type u_1} [category_theory.category C] : has_coe_t C (category_theory.idempotents.karoubi C)
{Î± : Type u_1} [preorder Î±] {a : Î±} : order_bot {x // a â‰¤ x}
{Î± : Type u} [topological_space Î±] (s : set Î±) : Prop
{L : first_order.language} (T : L.Theory) : Prop
{Î± : Type u} {m n : â„•} (hm : m = n + n) (v : fin m â†’ Î±) (k : fin n) : Î±
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (J : category_theory.grothendieck_topology C) : category_theory.pretopology C
{Î± : Type u} [pseudo_metric_space Î±] : uniform_continuous (Î» (p : uniform_space.completion Î± Ã— uniform_space.completion Î±), has_dist.dist p.fst p.snd)
 : list â„• â†’ â„• â†’ list â„•
(n a b : â„•) : Prop
(Î“ : Type u_1) [inhabited Î“] : Type u_1
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.sum âˆˆ S
{Î± : Type u_1} {n : â„•} (p : Î± â†’ Prop) (v : vector3 Î± n) : Prop
{M : Type u_1} [has_mul M] : complete_lattice (subsemigroup M)
(Î± : Type u_1) (n : â„•) : setoid (vector Î± n)
{Î± : Type u_1} (l : ordnode Î±) (x : Î±) (r : ordnode Î±) : ordnode Î±
(C : Type u) [category_theory.category C] : category_theory.bicategory (category_theory.locally_discrete C)
{Î± : Type u_1} [uniform_space Î±] (pkg : abstract_completion Î±) {Î² : Type u_2} [uniform_space Î²] (pkg' : abstract_completion Î²) : abstract_completion (Î± Ã— Î²)
 : irrational golden_conj
 : category_theory.limits.has_limits_of_size CommRing
 : category_theory.limits.colimit_cocone (category_theory.functor.empty (Type u))
(Î± : Type u) : Type u
{a b : â„•} (hab : a.coprime b) : a.factors.disjoint b.factors
{Î± : Type u_1} (a : Î±) : semiquot Î±
{Î± : Type u_1} {M : Type u_2} [has_zero M] (s : set Î±) (f : Î± â†’ M) : Î± â†’ M
(Î¹ : Type u_3) : well_founded has_lt.lt
(A : Type u_1) [has_add A] : group (add_aut A)
{Î± : Type u} [monoid Î±] (a b : Î±) : Prop
(S : Type u_3) (G : Type u_4) [has_inv G] [set_like S G] : Type
{a b : â„¤} (ha : a â‰  0) : is_least {n : â„• | 0 < n âˆ§ âˆƒ (x y : â„¤), â†‘n = a * x + b * y} (a.gcd b)
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : 1 < a) (hb : 1 â‰¤ b) (b0 : 0 < b) : 1 < a * b
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] [is_antisymm Î± r] {a b : Î±} : antisymm_rel r a b â†’ a = b
{Î± : Type u_1} [add_group Î±] (s : add_subgroup Î±) : setoid Î±
{n : â„•} {a b : fin n} : â†‘a â‰¤ â†‘b â†” a â‰¤ b
{Î± : Type u_1} [measurable_space Î±] (p : pmf Î±) : measure_theory.measure Î±
{R : Type u} [comm_semiring R] (f : polynomial R) : Prop
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : subfield L
{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a < b â†’ order.pred a < order.pred b
{Î± : Type u_1} : list (option Î±) â†’ list Î± â†’ list Î±
{V : Type u} (G : simple_graph V) : Prop
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ
{G : Type u} [add_monoid G] : is_of_fin_add_order 0
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)
{Î± : Type u_1} [denumerable Î±] {Î³ : Î± â†’ Type u_3} [Î  (a : Î±), denumerable (Î³ a)] : denumerable (sigma Î³)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] : has_zero C
 : Type
{Î± : Type u_1} {Î² : Type u_4} [preorder Î±] [preorder Î²] {u : Î² â†’ Î±} (l : lower_adjoint u) : set Î±
(n : â„•) (R : Type u_1) [comm_ring R] [is_domain R] : finset R
(Î¹ : Type u) (Î² : Î¹ â†’ Type v) [Î  (i : Î¹), has_zero (Î² i)] : Type (max u v)
(M : Type u_9) (N : Type u_10) [has_mul M] [has_mul N] : Type (max u_10 u_9)
{Î± : Type u_1} [has_mul Î±] [has_lt Î±] [contravariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} (bc : a * b < a * c) : b < c
{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : turing.list_blank Î“
 : matrix (fin 4) (fin 4) â„¤
(L : first_order.language) (M : Type w) [L.Structure M] : set (category_theory.bundled L.Structure)
{p : ordinal â†’ Prop} (i : ordinal) (h : âˆ€ (j : ordinal), (âˆ€ (k : ordinal), k < j â†’ p k) â†’ p j) : p i
 : function.injective real.sinh
(c : omega.clause) : Prop
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : 0 < -a â†” a < 0
{Î¹ : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape Î¹) : Type (max u u_1 v)
 : name â†’ â„•
{Î± : Type u} [topological_space Î±] {s : set Î±} : is_preirreducible s â†” âˆ€ (zâ‚ zâ‚‚ : set Î±), is_closed zâ‚ â†’ is_closed zâ‚‚ â†’ s âŠ† zâ‚ âˆª zâ‚‚ â†’ s âŠ† zâ‚ âˆ¨ s âŠ† zâ‚‚
(obj : Type u) : Type (max u (v+1))
(Î± : Sort u_1) [s : setoid Î±] : function.surjective quotient.mk
(M : Type u_4) [mul_one_class M] : Type u_4
{R : Type u} [comm_ring R] (t : set (prime_spectrum R)) : ideal R
(X : Profinite) : category_theory.limits.cone X.diagram
{M : Type u_1} {N : Type u_2} (Î± : Type u_6) [has_vadd M Î±] (g : N â†’ M) : has_vadd N Î±
{R : Type uâ‚} [non_unital_non_assoc_ring R] : is_scalar_tower â„¤ R R
{G : Type u} [add_group G] (B : add_group_filter_basis G) : topological_space G
{G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s âŠ† t) : group.normal_closure s âŠ† t
{Î² : Type u_2} {Î¹ : Sort u_4} (s : Î¹ â†’ set Î²) : set Î²
{Î± : Type u} [add_monoid Î±] (u : add_units Î±) : Î±
{Î± : Type u_1} {Î² : Type u_2} [nonempty Î±] (f : Î± â†’ Î²) (s : set Î±) (hf : set.inj_on f s) : local_equiv Î± Î²
{Î± : Type u_1} [linear_ordered_semiring Î±] : subsingleton (floor_semiring Î±)
{X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] [topological_space Y] (f : X â†’ Y) : locally_constant Y Z â†’ locally_constant X Z
{r : nnreal} (hr : r < 1) : has_sum (Î» (n : â„•), r ^ n) (1 - r)â»Â¹
(G : Type u_1) [add_group G] : galois_insertion add_subgroup.closure coe
{Î± : Type u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (g : Î² â†’ option Î±) : Prop
(R : Type u) [comm_ring R] : Top.presheaf CommRing (algebraic_geometry.prime_spectrum.Top R)
{Î± : Type u_2} [decidable_eq Î±] (k : â„•) (ð’œ : finset (finset Î±)) : finset (finset Î±)
(J : Type uâ‚) [category_theory.category J] : Type uâ‚
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [linear_order Î²] : order.partial_iso Î± Î² â†’ order.partial_iso Î² Î±
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} [measurable_space Î±] : (Î± â†’ ennreal) â†’ â„• â†’ measure_theory.simple_func Î± ennreal
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] : ordnode Î± â†’ ordnode Î± â†’ bool
{M : Type u_1} [has_mul M] : has_Inf (con M)
{Î± : Type u} (s : wseq Î±) (n : â„•) : wseq Î±
{R : Type u_1} [distrib R] (r : R) : add_hom R R
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_lattice Î±] (f : filter Î²) (u : Î² â†’ Î±) : Î±
{S : Type u_1} [has_mul S] (a : S) : commute a a
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a
{R : Type u_1} [semiring R] : power_series R
{Î± : Type u} {Î² : Type v} (f : â„• â†’ Î± â†’ Î²) (as : list Î±) : list Î²
(G : Type u_3) [add_group G] : Type u_3
(R : Type u) {X : Type v} [semiring R] : X â†’ free_non_unital_non_assoc_algebra R X
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z â†’ B) : Prop
{M : Type u_1} {N : Type u_2} [has_one M] [has_one N] (f : one_hom M N) : one_hom (with_top M) (with_top N)
{Î± : Type u} [semigroup Î±] [has_distrib_neg Î±] (a b : Î±) : a âˆ£ -b â†” a âˆ£ b
{C : Type u} [category_theory.category C] (ð’¢ : set C) : Prop
{Î± : Type u_6} : has_faithful_smul (function.End Î±) Î±
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
{Î± : Type u_1} (Î¹ : Type u_2) [preorder Î¹] (m : measurable_space Î±) : Type (max u_1 u_2)
{M : Type u_1} [add_comm_monoid M] (x : M) : Type u_1
{L : first_order.language} (T : L.Theory) : Prop
{C : Type u_1} [category_theory.bicategory C] (X : C) : Type u_3
{Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Prop} (f : Î  (a : Î±), p a â†’ Î²) (s : multiset Î±) : (âˆ€ (a : Î±), a âˆˆ s â†’ p a) â†’ multiset Î²
{Î± : Type u_1} [decidable_eq Î±] (a : Î±) (s : multiset Î±) : multiset Î±
{Î± : Type u} {m n : â„•} (hm : m = n + n) (v : fin m â†’ Î±) (k : fin n) : Î±
(X : Type u_1) [topological_space X] : preorder X
(Î± : Type u_1) [fintype Î±] : trunc {f // function.bijective f}
{Î± : Type u_1} [topological_space Î±] [quasi_sober Î±] {S : set Î±} (hS : is_irreducible S) : Î±
{Î± : Type u} : ordnode Î± â†’ Î± â†’ ordnode Î± â†’ ordnode Î± Ã— Î±
{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (Î» (g : G), g * h * gâ»Â¹)
{M : Type u_2} {Î± : Sort u_4} [comm_monoid M] (f : Î± â†’ M) : M
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] (f : equiv.perm Î±) (x : Î±) : equiv.perm Î±
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : aâ»Â¹ < bâ»Â¹ â†’ b < a
(M : Type u_1) [measurable_space M] [has_sup M] : Prop
{Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] {f g : bounded_continuous_function Î± Î²} [is_empty Î±] : has_dist.dist f g = 0
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±} (h : isometry f) (hg : function.right_inverse g f) : isometry g
{R : Type u} [has_add R] : has_mul (tropical R)
{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : b â‰¤ c - a â†’ a + b â‰¤ c
{R : Type u} [non_assoc_semiring R] (M : submonoid R) : subsemiring R
{Î± : Type u} (s : set Î±) : filter Î±
{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) â†” monoid.fg M
(Î± : Type u) : Type u
{Î± : Type u} (s : seq Î±) : â„• â†’ seq Î±
{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) (n : â„•) : Î“
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valuation (ratfunc Fq) (with_zero (multiplicative â„¤))
{Î± : Type u_1} [decidable_eq Î±] {s : finset Î±} {a b : Î±} (hs : b âˆˆ s) (hsa : b âˆ‰ s.erase a) : b = a
{Î± : Type u} (x : Î±) : free_group Î±
{Î± : Type u_1} {n : â„•} (f : fin2 n â†’ Î±) : vector3 Î± n
 : Type
(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x â†’ is_algebraic R x
{Î± : Type u_2} [decidable_eq Î±] [has_add Î±] : has_add (finset Î±)
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] (K : nnreal) (f : Î± â†’ Î²) : Prop
{Mâ‚‚ : Type u_2} {Mâ‚ : Type u_1} [has_neg Mâ‚] [has_involutive_neg Mâ‚‚] (f : Mâ‚ â†’ Mâ‚‚) (hf : function.injective f) (inv : âˆ€ (x : Mâ‚), f (-x) = -f x) : has_involutive_neg Mâ‚
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_projectives C] (Z : C) : chain_complex C â„•
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
(a b : Prop) : Prop
{B : Type u} [quiver B] {a b : B} : category_theory.free_bicategory.hom a b â†’ category_theory.free_bicategory.hom a b â†’ Type (max u v)
 : ennreal â†’ ereal
{Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [preorder Î²] (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} (s : multiset Î±) : list Î±
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c : Î±} : a â‰¤ c - b â†’ a + b â‰¤ c
 : bool â†’ bool â†’ snum â†’ snum
{p : â„•} (hp : 1 < p) : padic_val_int p â†‘p = 1
{M : Type u_1} [comm_monoid M] (x : M) (N' : Type u_2) [comm_monoid N'] : Type (max u_1 u_2)
(Î± : Type u) [uniform_space Î±] : Prop
 : category_theory.category algebraic_geometry.LocallyRingedSpace
(G : Type u_1) [monoid G] : Â¬monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ is_of_fin_order g
(Î± : Type u_1) [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] : compact_Icc_space Î±
 : has_add nonote
{M : Type u_1} [has_mul M] (r : M â†’ M â†’ Prop) : con M
(n : â„•) (A : Type u_1) (v : typevec n) : Type u_1
{m : Type u_2} {n : Type u_3} {Î± : Type v} [non_unital_non_assoc_semiring Î±] [fintype n] (M : matrix m n Î±) (v : n â†’ Î±) : m â†’ Î±
{Î± : Type u} [ordered_add_comm_monoid Î±] (zero_le : âˆ€ (a : Î±), 0 â‰¤ a) : ordered_add_comm_monoid (with_zero Î±)
(Î± : Type u) : Type u
 : Type
 : Type (u+1)
 : cardinal
(F : Type u_8) (Î± : out_param (Type u_9)) (Î² : out_param (Type u_10)) [complete_lattice Î±] [complete_lattice Î²] : Type (max u_10 u_8 u_9)
(M : Type u) [add_comm_monoid M] : AddCommMon
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (s : submonoid M) (t : submonoid N) : submonoid (M Ã— N)
{Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_max_order Î±] : infinite Î±
 : list name
{Î± : Type u} [non_unital_non_assoc_ring Î±] (a b c : Î±) : a * (b - c) = a * b - a * c
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ multiset.Ioc a b = 0
 : Type
(Î“ : Type u) (Î“' : Type v) [inhabited Î“] [inhabited Î“'] : Type (max u v)
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] (s : wseq Î±) : computation â„•
{X : Type u_1} [topological_space X] [t1_space X] : t1_space (alexandroff X)
{Î± : Type u_2} [subtraction_comm_monoid Î±] : subtraction_comm_monoid (set Î±)
{M : Type u_1} [monoid M] : is_submonoid set.univ
 : Type (u+1)
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] (s : set Î±) (hs : measurable_set s) (f g : measure_theory.simple_func Î± Î²) : measure_theory.simple_func Î± Î²
{Î± : Type u_2} : bornology Î±
{Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), monoid (M i)] {i j : Î¹} (w : free_product.neword M i j) : M i
(v : â„• â†’ â„¤) (as : list â„¤) (l : â„•) : â„• â†’ â„¤
(u : pnat.xgcd_type) : pnat.xgcd_type
{Î± : Type u} (Î² : Type v) [group Î±] [monoid Î²] [mul_action Î² Î±] (H : subgroup Î±) : Prop
{Î± : Type u_1} (x : Î±) : thunk Î±
{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] : a < b - c â†” c + a < b
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} (a : Î±) : Î± âŠ• Î² âŠ• Î³
{Î± : Type u_1} : complete_lattice (setoid Î±)
(sub : name) : name â†’ name
{L R : Type v} (fst snd : L â†’ R) : Type v
{Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [has_neg Î²] (f : Î± â†’ Î²) (c : Î±) : Prop
(n : â„•) : finset (Î£ (a : fin n), fin n)
{Î± : Type u_1} : list (dlist Î±) â†’ dlist Î±
 : Type
(R : Type u) [semiring R] : Prop
{Î± : Type u} [preorder Î±] {a b c : Î±} : a < b â†’ b â‰¤ c â†’ a < c
{Î± : Type u_1} {Î² : Type u_2} [encodable Î±] (f : Î² â†’ Î±) (finv : Î± â†’ Î²) (linv : âˆ€ (b : Î²), finv (f b) = b) : encodable Î²
(Î± : Type u_1) [lattice Î±] : Lattice
 : Type
{Î± : Type u_1} [semilattice_sup Î±] [order_bot Î±] (s : multiset Î±) : Î±
(C : Type u) [category_theory.category C] : Prop
{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below s) : bdd_below (s âˆ© t)
(p' : â„•) : 2 < lucas_lehmer.q (p' + 2)
 : matrix (fin 8) (fin 8) â„¤
{n : Type u_4} {Î± : Type u_5} [fintype n] [semi_normed_ring Î±] [decidable_eq n] : semi_normed_ring (matrix n n Î±)
(L : first_order.language) (L' : first_order.language) : Type (max u_1 u_2 u_3 u_4)
{X : Type u_1} [topological_space X] [discrete_topology X] : order_bot (discrete_quotient X)
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} [subsingleton Î±] : isometry f
{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] (a : Î±) [no_max_order Î±] : closure (set.Ioi a) = set.Ici a
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : Type (max u v)
 : omega.nat.preterm â†’ Prop
{n : â„•} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n â„¤)
{Î± : Type u} [decidable_eq Î±] (L : list (Î± Ã— bool)) : list (Î± Ã— bool)
{M : Type u_1} [has_mul M] : has_mul (ultrafilter M)
(ð•œ : Type u_1) (V : Type u_2) [normed_field ð•œ] [add_comm_group V] [module ð•œ V] : Type u_2
{Î± : Type u} : partial_order (topological_space Î±)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (e : local_homeomorph Î± Î²) (e' : local_homeomorph Î² Î³) : local_homeomorph Î± Î³
(G : Type u) : Type u
(R : Type u) [rack R] : rack.pre_envel_group R â†’ rack.pre_envel_group R â†’ Prop
{Î± : Type u_1} [measurable_space Î±] (a : Î±) : measure_theory.measure Î±
(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] : Type
 : â„• â†’ pos_num
{Î± : Type u} {Î² : Type v} : seq Î± â†’ seq Î² â†’ seq (Î± Ã— Î²)
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x â‰  -x
 : Type
(n : â„•) : finset â„•
 : first_order.language
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} (m : Î± â†’ Î² â†’ Î³ â†’ Î´) (f : filter Î±) (g : filter Î²) (h : filter Î³) : filter Î´
 : Type v
(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) : Î¹ â†’ k
{Î± : Type u_1} [linear_order Î±] (a : Î±) : {a}.min' _ = a
(Mâ‚€ : Type u_4) : Type u_4
{Î± : Type u} [has_neg Î±] [has_sup Î±] : has_abs Î±
{Î± : Type u_1} [preorder Î±] [order_top Î±] (a : Î±) : Prop
(Î± : Type u_4) : Type u_4
{M : Type u_1} [mul_one_class M] {S T : submonoid M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
{Î± : Type u_1} (a : Î±) : lists Î±
{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) (s : set M) (hs : s = â†‘p) : submodule R M
 : Type
{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length
(Î± : Type u_3) [topological_space Î±] : Type u_3
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î±] [lattice Î²] (gi : galois_coinsertion l u) : lattice Î±
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : has_mul (submodule R A)
(Î± : Type u_3) [has_le Î±] [has_add Î±] [has_sub Î±] : Type
{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_greatest s a) : bdd_above s
{G : Type u_1} [group G] (k : set G) : subgroup G
{p n : â„•} {R : Type u_1} (i : fin n) (x : truncated_witt_vector p n R) : R
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{G : Type u_1} [has_zero G] [has_add G] [has_neg G] : list G â†’ G
{Î± : Type u} {Î² : Type v} [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) (a : Î±) : Prop
{M : Type u_1} [add_monoid M] : is_add_submonoid set.univ
{Î± : Type u_1} {Î² : Type u_2} [fintype (Î± âŠ• Î²)] : fintype Î²
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} (Hf : function.injective f) : function.injective (option.map f)
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [complete_lattice Î±] [complete_lattice Î²] [complete_lattice Î³] (f : frame_hom Î² Î³) (g : frame_hom Î± Î²) : frame_hom Î± Î³
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [non_assoc_semiring Î±] [preorder Î±] [non_assoc_semiring Î²] [preorder Î²] : Type (max u_6 u_7 u_8)
{n : â„•} (v : bitvec n) : â„•
(Î¹ : Type u_2) : Type u_2
 : snum â†’ snum
{G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = â†‘(subgroup.center G)
{M : Type u_5} [nontrivial M] [hM : monoid_with_zero M] (h : âˆ€ (a : M), is_unit a âˆ¨ a = 0) : group_with_zero M
{Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] {s : finset Î±} (f : Î± â†’ Î²) : mul_opposite.op (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), mul_opposite.op (f x))
{n : â„•} (k : â„•) : option (fin2 n)
{Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a = b â†’ a â‰¤ c
{Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [has_mul Î²] (f : Î± â†’ Î²) : Prop
{R : Type u} [ring R] (S : subring R) (s : set R) (hs : s = â†‘S) : subring R
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : Prop
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) [invertible A.det] : invertible A
(Î± : Type u_2) [fintype Î±] [nonempty Î±] [linear_order Î±] : complete_linear_order Î±
(Ï„ : Type u_1) [topological_space Ï„] [add_monoid Ï„] [has_continuous_add Ï„] (Î± : Type u_2) [topological_space Î±] : Type (max u_1 u_2)
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†’ a â‰¤ 1
(R : Type u_1) [semiring R] : Prop
(G : Type u) : Type u
{Î± : Type u_1} {M : Type u_4} [has_zero M] {s : set Î±} {f : Î± â†’ M} {a : Î±} (h : s.indicator f a â‰  0) : a âˆˆ s
{n : â„•} {F : typevec n â†’ Type u_1} [mvfunctor F] (q : mvqpf F) : Prop
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ Î± â†’ Î±
{K {C : Type u_1} [category_theory.category C] (X : C) : Prop
(Î± : Type u_6) (Î² : Type u_7) [has_bot Î±] [has_bot Î²] : Type (max u_6 u_7)
(R : Type u_1) (A : Type u_3) [comm_ring R] [ring A] [algebra R A] : Prop
{Î± : Type u_2} [has_add Î±] : has_add (filter Î±)
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (s : set Î±) : set Î±
(Î± : Type u_1) : Type u_1
(p : Prop) : Type
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ finset.Ioc a b = âˆ…
(obj : Type u) : Type (max u (v+1))
{Î± : Type u} {Î² : Type v} (l : filter Î±) (f g : Î± â†’ Î²) : Prop
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : b < aâ»Â¹ * c â†’ a * b < c
{Î± : Type u_1} {s t : set Î±} : disjoint s t â†’ disjoint (filter.principal s) (filter.principal t)
{Î± : Type u_1} [preorder Î±] [succ_order Î±] : Î± â†’ Î±
{Î± : Type u} : lazy_list Î± â†’ thunk (lazy_list Î±) â†’ lazy_list Î±
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] (f : Î± â†’ Î²) : Prop
(Î± : Type u) [topological_space Î±] : measurable_space Î±
{R : Type u_1} [mul_one_class R] : is_regular 1
{Î± : Type u_1} {n : Type u_3} (A : matrix n n Î±) : Prop
(Î± : Type u) : Type u
{M : Type u_1} [add_zero_class M] (s : set M) : add_submonoid M
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (j j' : C) : C
{M : Type u_1} {P : Type u_3} [has_add M] [has_add P] (f : M â†’ P) (h : âˆ€ (x y : M), f (x + y) = f x + f y) : add_con M
(n : name) : bool
{Î± : Type u_1} {a : Î±} {z : sym2 Î±} (h : a âˆˆ z) : Î±
{Î± : Type u} {Î² : Type v} (g : Î² â†’ Î±) (f : Î± â†’ Î²) (s : set Î±) (t : set Î²) : Prop
{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_one M] [has_one N] [has_one P] (hnp : one_hom N P) (hmn : one_hom M N) : one_hom M P
{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P
{Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] [add_monoid Î²] [has_lipschitz_add Î²] : has_add (bounded_continuous_function Î± Î²)
 : Type (u+1)
{Î± : Type u} : fin 0 â†’ Î±
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} (g : Î± â†’ Î² â†’ Î³ â†’ Î´) (s : set Î±) (t : set Î²) (u : set Î³) : set Î´
{Î± : Type u_1} {m n : â„•} (v : vector3 Î± m) (w : vector3 Î± n) : vector3 Î± (n + m)
 : Type
 : num â†’ num
{X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd
{Î± : Type u} {Î² : Type v} (f : â„• â†’ Î± â†’ Î² â†’ Î±) (start : â„•) (a : Î±) (bs : list Î²) : Î±
{n : â„•} : is_prime_pow n â†” âˆƒ! (p : â„•), nat.prime p âˆ§ p âˆ£ n
{Î± : Type u} (x : Î±) : function.is_fixed_pt id x
{Î± : Type u_3} {Î² : Type u_4} [lattice Î±] [lattice Î²] [bounded_order Î±] [bounded_order Î²] (f : bounded_lattice_hom Î± Î²) : sup_bot_hom Î± Î²
 : â„• â†’ snum â†’ bool
{Î± : Type u_1} (f : Î± â†’ Î±) (n : â„•) (x : Î±) : Prop
{Î³ : Type w} [metric_space Î³] {x y : Î³} : has_nndist.nndist x y = 0 â†” x = y
{K : Type u} [field K] (s : subfield K) (m : multiset K) : (âˆ€ (a : K), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
{Î± : Type u_1} (m : Î± â†’ Î± â†’ Î±) : list Î± â†’ list Î± â†’ list Î±
{R : Type u_1} [semiring R] : algebra â„• R
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : 0 < a - b â†’ b < a
(p : â„•) [fact (nat.prime p)] (a : â„¤) (ha : â†‘a â‰  0) : zmod.legendre_sym p (a ^ 2) = 1
(Î± : Type u_2) [cancel_comm_monoid_with_zero Î±] : Prop
(o : ordinal) : Well_order
{Î± : Type u_1} (l : list Î±) : list (list Î±)
(G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (Î» (f : G â†’* L), â‡‘f)
{Î± : Type u_1} [decidable_eq Î±] (s t : multiset Î±) : multiset Î±
(p : â„•) {R : Type u_1} [comm_ring R] (r : R) : witt_vector p R
(C : Type u) [category_theory.category C] : Type (max u (v+1))
{R : Type u} [euclidean_domain R] [decidable_eq R] : R â†’ R â†’ R
(Î± : Type u_1) : local_equiv Î± Î±
{Î± : Type} (p : parser Î±) : Prop
{Î± : Type u_1} [nontrivial Î±] : nonempty Î±
(S : Type u_4) (M : out_param (Type u_5)) [has_zero M] [set_like S M] : Type
{n : â„•} (x : bitvec n) (i : â„•) (fill : bool) : bitvec n
{Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ âˆ…), f i)) = 1
{Î¹ : Type u_1} (G : Î¹ â†’ Type u_2) [Î  (i : Î¹), group (G i)] [hG : Î  (i : Î¹), is_free_group (G i)] : is_free_group (free_product G)
{M : Type u_1} [add_monoid M] {s : set M} (h : is_add_submonoid s) : add_submonoid M
{Î± : Type u} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] : filter.tendsto (Î» (x : Î±), xâ»Â¹) (nhds_within 0 (set.Ioi 0)) filter.at_top
(R : Type u) (n : â„•) [comm_semiring R] (A : Type u_1) [semiring A] [algebra R A] : multilinear_map R (Î» (i : fin n), A) A
(Î± : Type u) : Type u
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {g : Î² â†’ Î³} (hg : function.injective g) : function.injective (function.comp g)
{Î± : Type u_1} [inhabited Î±] : option Î± â†’ Î±
 : has_sizeof â„¤
{Î± : Sort u} {Î² : Sort v} {f : Î± â†’ Î²} (hf : function.injective f) [subsingleton Î²] : subsingleton Î±
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Î» (_x : P), _x -áµ¥ p)
{Î± : Type u} {Î² : Type v} (a : ulift Î±) (f : Î± â†’ ulift Î²) : ulift Î²
{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a < b) : Â¬is_max a
{Î± : Type u} : Î± â†’ lazy_list Î±
(p : Prop) : Type
{Î± : Type u} (S : set (Î± â†’ â„•)) : Prop
{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) (hS : S â‰¤ non_zero_divisors A) [field K] [algebra A K] [is_fraction_ring A K] : subalgebra A K
{Î± : Type u} (s : stream Î±) : stream Î±
(Î± : Type u_1) [distrib_lattice Î±] : DistribLattice
(G : Type u) [topological_space G] [has_inv G] : Prop
(Î± : Type u_1) : Type u_1
{n : â„•} : order_of (quaternion_group.a 1) = 2 * n
{Î± : Type u_1} [monoid Î±] (s : multiset Î±) (comm : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ commute x y) : Î±
(F : Type u_8) (Î± : out_param (Type u_9)) (Î² : out_param (Type u_10)) [complete_lattice Î±] [complete_lattice Î²] : Type (max u_10 u_8 u_9)
{Î± : Sort u_1} {a : Î±} : Î±
 : Type (u+1)
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (o : part Î±) : part Î²
{n : â„•} (x y : bitvec n) : Prop
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_pushouts C
{n : Type u_3} {Î± : Type v} [decidable_eq n] [has_zero Î±] (d : n â†’ Î±) : matrix n n Î±
{Î± : Type u_1} : set (Î± Ã— Î±)
{Î± : Type u} : pos_num â†’ tree Î± â†’ option Î±
{Î± : Type u} [semilattice_sup Î±] [nonempty Î±] (s : finset Î±) : bdd_above â†‘s
{X : Type u_1} (point : X) : Pointed
{Î± : Type u_1} : vector3 Î± 0
{Î± : Type u_1} : list Î± â†’ list â„• â†’ list (list Î±) Ã— list Î±
{G : Type u_1} [group G] (S : set G) : set (set G)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J â†’ C) : Type (max u v)
(F : Type u_7) (Î± : out_param (Type u_8)) (Î² : out_param (Type u_9)) [lattice Î±] [lattice Î²] : Type (max u_7 u_8 u_9)
 : Type
(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop
{R : Type u} [ring R] (S : set R) : Prop
 : path 0 1
{Î± : Sort u_1} (x : Î±) (h : âˆ€ (y : Î±), y = x) : subsingleton Î±
{G : Type u_1} [group G] (H K : subgroup G) : â„•
{S : Type u_2} [linear_ordered_ring S] : absolute_value S S
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x âˆˆ S â†’ xâ»Â¹ âˆˆ S
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
(R : Type u) [has_star R] : Prop
{K : Type v} [field K] (f : polynomial K) : polynomial (adjoin_root f.factor)
(A : Type u) : Type u
(Î± : Type u) : Type u
 : Type
{R : Type u} [comm_ring R] (x : prime_spectrum R) : ideal R
{Î± : Type u} {Î² : Type v} : Î± âŠ• Î² â†’ bool
{M : Type u_1} [add_monoid M] {sâ‚ sâ‚‚ : set M} (isâ‚ : is_add_submonoid sâ‚) (isâ‚‚ : is_add_submon{Î± : Sort u_1} {sâ‚ : setoid Î±} (a : quotient sâ‚) : Î±
(f : â„• â†’ nnreal) : filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)
(F : Type u â†’ Type w) (G : Type v â†’ Type u) (Î± : Type v) : Type w
(Î± : Type u) [ring Î±] : Type u
{Î± : Sort u} (r : Î± â†’ Î± â†’ Prop) : Prop
(Î± : Type u) [has_le Î±] : Type u
(g : Type) (Î± : Type u) : Type u
{R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g
{M : Type u_1} [has_mul M] (s : set M) : subsemigroup M
{Î± : Type u_1} {Î² : Type u_2} (f : list Î± â†’ Î± â†’ list Î± â†’ Î²) (l : list Î±) : list Î²
(u : Set) : set Set
{X : Top} (T : Top) : Top.sheaf (Type v) X
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
 : znum â†’ znum â†’ ordering
{Î± : Type u} (a : Î±) : stream Î±
(Î“ : Type u_1) [inhabited Î“] : setoid (list Î“)
(Î± : Type u_1) [nonempty Î±] [fintype Î±] : trunc Î±
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (l : list Î±) (hp : âˆƒ (a : Î±), a âˆˆ l âˆ§ p a) : Î±
{C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C) : setoid (category_theory.over P)
 : Type â†’ Type
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] {Î´ : Type w} (m : hash_map Î± Î²) (d : Î´) (f : Î´ â†’ Î  (a : Î±), Î² a â†’ Î´) : Î´
{Î± : Type u} [linear_order Î±] {a b c : Î±} : set.interval a c âŠ† set.interval a b âˆª set.interval b c
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Î± : Type u_1} [fintype Î±] [field Î±] : is_prime_pow (fintype.card Î±)
 : pSet
 : â„• â†’ list â„•
{Î± : Type u_2} [subtraction_comm_monoid Î±] : subtraction_comm_monoid (filter Î±)
 : Type
{G : Type u_3} [group G] : group.fg G â†” monoid.fg G
(R : Type u) (M : Type v) (Mâ‚‚ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module R Mâ‚‚] : submodule R (M Ã— Mâ‚‚)
 : Type
(R : Type u_8) (S : Type u_9) [comm_ring R] [ring S] [algebra R S] : Type (max u_8 u_9)
(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : free_add_monoid (M Ã— N) â†’ free_add_monoid (M Ã— N) â†’ Prop
{Î± : Type u_1} [preorder Î±] [order_bot Î±] (a : Î±) : Prop
 : Type
{Î± : Type u} : wseq Î±
(Î± : Type u_1) [has_one Î±] : Type u_1
(R : Type u) (K : Type v) [comm_ring R] [field K] [algebra R K] [no_zero_smul_divisors R K] : Prop
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†’ a < 0
{m : Type v â†’ Type w} [applicative m] {Î± : Type u_1} {Î² : Type v} (f : â„• â†’ Î± â†’ m Î²) (as : list Î±) : m (list Î²)
{n : â„•} : bitvec n â†’ â„¤
{Î± : Type} (m : â„•) (a : Î±) (v : â„• â†’ Î±) : â„• â†’ Î±
{p : â„• â†’ Prop} [decidable_pred p] (H : âˆƒ (n : â„•), p n) : â„•
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd
(ð•œ : Type u_1) (Î¹ : Type u_5) [ordered_semiring ð•œ] [fintype Î¹] : set (Î¹ â†’ ð•œ)
{Î± : Type u_2} [has_zero Î±] : has_zero (set Î±)
 : filter.tendsto (Î» (x : â„), x ^ (1 / x)) filter.at_top (nhds 1)
 : turing.to_partrec.cont â†’ list (list â„•)
(A : Type u) [add_group A] : Type u
{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : polynomial R
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop
 : parser unit
{ð•œ : Type u_1} [linear_ordered_field ð•œ] [topological_space ð•œ] [order_topology ð•œ] {s : set ð•œ} : strict_convex ð•œ s â†” convex ð•œ s
(Î± : Type u) : Type u
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C
 : category_theory.limits.has_limits_of_size AddCommMon
{R : Type u_1} [comm_ring R] {M : submonoid R} (z : localization M) : localization M
{Î± : Type u_1} [semiring Î±] (b : Î±) : list â„• â†’ Î±
(G : Type u_1) [comm_monoid G] : submonoid G
 : Type
(op : ordinal â†’ ordinal â†’ ordinal) (o : ordinal) : Prop
{Î± : Type u} (s : wseq Î±) : wseq Î±
{Î± : Type u} [preorder Î±] {a b : Î±} : a â‰¤ b â†’ Â¬b â‰¤ a â†’ a < b
{Î± : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space Î±] (f : measure_theory.simple_func Î± E) : measure_theory.simple_func Î± E
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A B : matrix n n Î±) (h : A.mul B = 1) : invertible A.det
(M : Type u_1) (Î± : Type u_2) [add_monoid M] [topological_space Î±] [add_action M Î±] : Prop
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (c : cycle Î±) : Prop
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom B (A Ã— B)
{Î² : Type v} {Î³ : Type w} [emetric_space Î³] [emetric_space Î²] : emetric_space (Î³ Ã— Î²)
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
{Î± : Type u} [decidable_eq Î±] (i j : Î±) : function.involutive (Î» (_x : equiv.perm Î±), _x * equiv.swap i j)
 : Type
(Î± : Type u) [pseudo_metric_space Î±] : setoid Î±
 : Type
 : Type
{G : Type u_1} [has_one G] [has_mul G] [has_inv G] : list G â†’ G
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Prop
(A : Type u_2) [add_group A] : Prop
 : has_le many_one_degree
{Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot
{Î± : Type u} (a : Î±) : stream Î±
{R : Type u} [comm_semiring R] (x y : R) : Prop
{Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : Î±) : Î±
{Î± : Type u} [non_unital_non_assoc_ring Î±] (k : Î±) (h : âˆ€ (x : Î±), x * k = 0 â†’ x = 0) : is_right_regular k
{Î± : Type u_2} [has_zero Î±] : has_zero (filter Î±)
{Î± : Type u_1} [preorder Î±] [order_bot Î±] [locally_finite_order Î±] (b : Î±) : finset Î±
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : has_btw.btw c a b
 : category_theory.limits.has_limits_of_size CommSemiRing
{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] (h : a - c < b - c) : a < b
{n : â„•} (i : fin n) : equiv.perm (fin n)
(F : pfunctor) : Type u
{V : Type u} (G : simple_graph V) : setoid V
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (X : algebraic_geometry.SheafedSpace C) : Top.sheaf C â†‘X
{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] [t2_space Î±] (x : Î±) : âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ is_compact (closure U)
{n : â„•} : arity pSet n â†’ arity pSet n â†’ Prop
{C : Type u} [category_theory.category C] (ð’¢ : set C) : Prop
(Î± : Type u) [group Î±] : Type u
{L : first_order.language} (M : Type w) [L.Structure M] (T : L.Theory) : Prop
{Î± : Type u_1} [has_one Î±] : has_coe (simple_continued_fraction Î±) (generalized_continued_fraction Î±)
{K : Type u_2} [division_ring K] (aâ‚™ bâ‚™ ppredB predB : K) : K
{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] (x : P) : equiv.perm P
(C : Type u) [category_theory.category C] : Type (max u (v+1))
 : filter.tendsto real.log filter.at_top filter.at_top
(Î± : Sort u) : Type u
{Î± : Type u_1} [topological_space Î±] (x : Î±) (S : set Î±) : Prop
{R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R
 : ereal â†’ ereal
{Î± : Type u_1} {Î² : Type u_2} (s : multiset Î±) (f : Î± â†’ multiset Î²) : multiset Î²
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] : Type (max u v)
{m : Type u â†’ Type u_1} [monad m] {Î± : Type u} {n : â„•} : (fin n â†’ m Î±) â†’ m (vector Î± n)
(R : Type u_1) : Type u_1
(a b : snum) : snum
{M : Type u_3} {N : Type u_4} [has_add M] [add_zero_class N] : has_zero (add_hom M N)
{Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : Â¬p a) : a âˆ‰ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s
{p : â„•} [p_prime : fact (nat.prime p)] {b : â„•} (dvd : p âˆ£ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1
(a b : â„•) : â„•
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [semiring Î±] [add_group Î²] (h : function.antiperiodic f c) : function.periodic f (2 * c)
 : â„•
(n : â„•) : Type (u+1)
{G : Type u_1} [group G] (s : set G) : set G
{Î± : Type u_1} [Î² : normed_division_ring Î±] : normed_ring Î±
{n : â„•} (x y : bitvec n) : Prop
(S : Type u_4) (M : out_param (Type u_5)) [has_one M] [set_like S M] : Type
{M : Type u_1} [monoid M] {Î¹ : Sort u_2} {s : Î¹ â†’ set M} (h : âˆ€ (y : Î¹), is_submonoid (s y)) : is_submonoid (set.Inter s)
{Î± : Type u_1} {Î² : Type u_2} [cancel_comm_monoid_with_zero Î±] [normalized_gcd_monoid Î±] (s : finset Î²) (f : Î² â†’ Î±) : Î±
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (s : add_subsemigroup M) (t : add_subsemigroup N) : add_subsemigroup (M Ã— N)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x
{Î± : Type u} : Î± Ã— list Î± Ã— Î± Ã— list Î± â†’ Î± Ã— list Î± Ã— Î± Ã— list Î±
{Î± : Type u_1} : subsingleton (option Î±) â†” is_empty Î±
{G : Type u_1} [add_group G] (T : set G) : set (set G)
{Î¹ : Type u_1} (f g : Î¹ â†’ cardinal) (H : âˆ€ (i : Î¹), f i < g i) : cardinal.sum f < cardinal.prod g
(Î± : Type u_1) [encodable Î±] (n : â„•) : option Î±
(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] : submodule R A
{Î± : Type u_1} [topological_space Î±] [semiring Î±] [topological_semiring Î±] (s : subsemiring Î±) : subsemiring Î±
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
(Î± : Type u_6) : Type u_6
(M : Type u_1) [add_monoid M] : add_action M M
 : snum â†’ Î  (n : â„•), vector bool n
{n : â„•} (p : fin n â†’ Prop) [decidable_pred p] : option (fin n)
{Î± : Type u} (i : â„•) (t : ordnode Î±) : ordnode Î±
{R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z â†” shelf.act x z = z
{Î± : Sort u_1} {Î² : Sort u_2} (a : erased Î±) (f : Î± â†’ erased Î²) : erased Î²
 : fact (1 â‰¤ 2)
(R : Type u) [comm_ring R] : Type u
{A : Type u_2} [add_monoid A] (s : set A) : Prop
{n : â„•} (x y : bitvec n) : Prop
{R : Type u} [comm_semiring R] [star_ring R] : ring_hom_inv_pair (star_ring_end R) (star_ring_end R)
{a : Prop} : Â¬Â¬a â†” a
(Î± : Type u) : Type u
{Î± : Type u_1} [boolean_ring Î±] : has_sup Î±
(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : âˆƒ (u : â„• â†’ Î±), dense_range u
(Î± : Type u_1) [topological_space Î±] : Type u_1
{Î± : Type u} [pseudo_metric_space Î±] : pseudo_emetric_space Î±
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : setoid Î±
{Î± : Type u_2} [decidable_eq Î±] [division_monoid Î±] : division_monoid (finset Î±)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [preorder Î²] (f : Î± â†’ Î²) (a : Î±) : Prop
{Î± : Type u_1} [measurable_space Î±] (f : Î± â†’ ennreal) (n : â„•) : measure_theory.simple_func Î± nnreal
{G : Type u} [group G] {x : G} : is_of_fin_order xâ»Â¹ â†” is_of_fin_order x
(M : Type u_10) (Î± : Type u_11) [has_vadd M Î±] : Prop
(ð•† : Type u_5) (Î± : Type u_6) [preorder ð•†] [preorder Î±] : Type (max u_5 u_6)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_initial C
{Î± : Type u_1} {M : Type u_5} [has_zero M] (a : Î±) : function.injective (finsupp.single a)
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] : unique_factorization_monoid R
{Î± : Type u_1} [linear_ordered_field Î±] [floor_ring Î±] (x : Î±) : â„¤
{Î± : Type u_2} [decidable_eq Î±] [add_comm_semigroup Î±] : add_comm_semigroup (finset Î±)
(Î± : Type u_2) [has_bot Î±] : bot_hom Î± Î±
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K â†’ ratfunc K
(R : Type u) [comm_ring R] : Type u
(R : Type u_1) {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (s : set M) : submodule R M
{n m : â„•} (P : mvpfunctor n) (Q : fin2 n â†’ mvpfunctor m) : mvpfunctor m
(ð•œ : Type u_1) {A : Type u_2} [normed_field ð•œ] [ring A] [algebra ð•œ A] (a : A) : ennreal
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (m : hash_map Î± Î²) : list (Î£ (a : Î±), Î² a)
{Î± : Type u_1} {Î² : Type u_2} (r : setoid Î±) (s : setoid Î²) : setoid (Î± Ã— Î²)
(R : Type u_3) [comm_ring R] : Prop
(Î² : Type u_1) (Î³ : Type u_2) [measurable_space Î²] [measurable_space Î³] [has_pow Î² Î³] : Type
(f : turing.to_partrec.code) : turing.to_partrec.code
(n : â„•) : â„•
(M : Type u) : Type u
{n : â„•} {Î± : fin n â†’ Type u} (a : d_array n Î±) (i : fin n) (v : Î± i) : d_array n Î±
 : Type
{Î± : Type u} {Î² : Type v} [has_mul Î²] (f : Î± â†’ Î²) : free_magma Î± â†’ Î²
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) (x : Î±) : Prop
 : onote â†’ onote Ã— â„•
{Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î²] [fintype (Î± Ã— Î²)] [nonempty Î±] : fintype Î²
{Î± : Type u} [preorder Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬y â‰¤ x
(J : Type uâ‚) [category_theory.category J] (C : Type u) [category_theory.category C] : Prop
(M : Type u_9) (N : Type u_10) [mul_zero_one_class M] [mul_zero_one_class N] : Type (max u_10 u_9)
{x y z : â„¤} : pythagorean_triple x y z â†” pythagorean_triple y x z
{R : Type u} [semiring R] : polynomial R â†’ finset â„•
(Î± : Type u_6) : Type u_6
(Î± : Type u_6) [measurable_space Î±] : Type u_6
(C : Type u_1) [category_theory.category C] : Prop
{Î± : Type u} [topological_space Î±] [compact_space Î±] [discrete_topology Î±] : fintype Î±
 : comm_ring (clifford_algebra clifford_algebra_complex.Q)
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (m : pseudo_emetric_space Î²) : pseudo_emetric_space Î±
{Î± : Type u} (t s s' : set Î±) : set Î±
(n : â„•) : list (â„• Ã— â„•)
{Î± : Type u_1} (f : filter Î±) : Type (max u_1 (u_5+1))
{m : Type u_1} {n : Type u_2} {K : Type u_4} [fintype n] [decidable_eq n] [field K] (A : matrix m n K) : â„•
 : Type
{P : â„• â†’ Prop} {m : â„•} (h0 : P m) (h1 : âˆ€ (n : â„•), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„•) : m â‰¤ n â†’ P n
{Î± : Type u_1} [complete_lattice Î±] (s : set Î±) : Prop
(Î± : Type u_3) [topological_space Î±] : Prop
{M : Type u_1} {N : Type u_2} {Î± : Type u_6} [has_vadd M Î±] (g : N â†’ M) (n : N) (a : Î±) : Î±
(C : Type u) [category_theory.category C] : Prop
{G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) â†” is_of_fin_add_order x
(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] [module.free R M] [nontrivial R] [module.finite R M] : fintype (module.free.choose_basis_index R M)
{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : continuous (Î» (x : Î±), metric.inf_dist x s)
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : measurable_space.comap f mâ‚‚ â‰¤ mâ‚ â†’ measurable f
{Î± : Type u} {a b : Î±} [mul_zero_class Î±] [partial_order Î±] [zero_lt.pos_mul_mono Î±] (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a * b
{G : Type u_1} [add_group G] (S : set G) : set (set G)
 : Type (u_1+1)
{Î± : Type u} (s : wseq Î±) (p : Î± â†’ bool) : computation bool
(Î± : Type u_1) [monoid Î±] : Type u_1
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : module (module.End R M) M
 : filter.tendsto (Î» (N : â„•), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A â†’ algebra.finite_type R A
{Î± : Type u_1} {Î² : Type u_2} [semilattice_inf Î±] [order_top Î±] (s : finset Î²) (f : Î² â†’ Î±) : Î±
{n : â„•} {a b : fin n} : â†‘a < â†‘b â†” a < b
(Î± : Type u_1) [fintype Î±] : encodable Î±
(M : Type u_1) {Î± : Type u_2} [add_group M] [add_action M Î±] (s : set Î±) : add_subgroup M
{Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), y * x)
 : pSet â†’ pSet â†’ pSet
{Râ‚ƒ : Type u_7} [comm_ring Râ‚ƒ] {n : Type u_11} [fintype n] (J Jâ‚ƒ : matrix n n Râ‚ƒ) [decidable_eq n] : submodule Râ‚ƒ (matrix n n Râ‚ƒ)
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (a : Î±) : Î± â†’ Prop
{C : Type uâ‚} [category_theory.category C] {X : C} : complete_lattice (category_theory.sieve X)
{R : Type u} [ring R] (s : subring R) {x : R} : x âˆˆ s â†’ -x âˆˆ s
(n : â„•) : nonote
{Î± : Type u_1} {Î² : Type u_2} {n : â„•} (f : Î± â†’ Î²) (x : sym Î± n) : sym Î² n
 : Type
(Î± : Type u_1) [fintype Î±] [category_theory.small_category Î±] [category_theory.fin_category Î±] : Type
{F : pfunctor} (x : F.M) : F.A
{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a < b âˆ¨ a = b
{H : Type u} [topological_space H] : order_bot (structure_groupoid H)
(Î± : Type u_1) : Type u_1
{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : urysohns.CU X
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] (a : Î±) : continuous (Î» (f : C(Î±, Î²)), â‡‘f a)
{n : â„•} {A : Type u} (F : A â†’ typevec n â†’ Type u) (v : typevec n) : Type u
(K : Type u) [comm_ring K] (p : â„•) [fact (nat.prime p)] [char_p K p] : â„• Ã— K â†’ â„• Ã— K â†’ Prop
{n : â„•} (x y : bitvec n) : Prop
(X : algebraic_geometry.Scheme) : Prop
(R : Type u_1) [has_mul R] [has_add R] : Type
{R : Type u} [ring R] {Î“â‚€ : Type v} [linear_ordered_comm_group_with_zero Î“â‚€] (v : valuation R Î“â‚€) : valued R Î“â‚€
(G : Type u_1) [add_monoid G] : Prop
{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : order.pred a < order.pred b â†’ a < b
{Î± : Type u_1} [cancel_monoid_with_zero Î±] {a b c : Î±} (ha : a â‰  0) : a * b âˆ£ a * c â†” b âˆ£ c
(cs : list char) : parser char
{Î± : Type u_2} [semigroup Î±] : semigroup (filter Î±)
(M : Type u_1) (N : Type u_2) (Î± : Type u_3) [has_vadd M Î±] [has_vadd N Î±] [vadd_comm_class M N Î±] : vadd_comm_class N M Î±
{C : Type u} [category_theory.category C] [category_theory.enough_projectives C] (X : C) : C
{Î± : Type u} : ordnode Î± â†’ â„•
 : has_mul pgame
(Î± : Type u_2) (Î² : Type u_3) (r : Î± â†’ Î² â†’ Prop) : Type (max u_2 u_3)
{Î± : Type u} [cancel_monoid_with_zero Î±] [nontrivial Î±] : has_faithful_smul Î± Î±
{Î± : Type u} [has_le Î±] (x : Î±) : ordnode Î± â†’ Prop
(obj : Type u) : Type (max u (v+1))
(Î± : Type u) : Type u
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) : add_hom (with_top M) (with_top N)
{Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : a âˆˆ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s) : p a
{Î± : Type u_2} [decidable_eq Î±] [comm_semigroup Î±] : comm_semigroup (finset Î±)
(Î± : Type u_1) [complete_lattice Î±] : CompleteLattice
{Î± : Type u_1} {Î² : Type u_2} (f : â„• â†’ Î± â†’ Î² â†’ Î±) (a : Î±) (l : list Î²) : Î±
{M : Type u_1} {R : Type u_2} [monoid M] [ring R] [mul_semiring_action M R] : mul_action M (subring R)
{Î± : Type u} {Î² : Sort u_1} (z : Î²) (f : Î² â†’ Î± â†’ Î² â†’ Î²) : ordnode Î± â†’ Î²
(Î± : Type u_3) [has_inf Î±] [has_top Î±] : inf_top_hom Î± Î±
{R : Type u_1} (f : â„• â†’ R) : power_series R
{Î± : Type u} (a : Î±) : seq1 Î±
 : Type
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ ordnode Î± Ã— option Î± Ã— ordnode Î±
{M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
{Î± : Type u_1} {Î² : Type u_2} (rÎ± : Î± â†’ Î± â†’ Prop) (rÎ² : Î² â†’ Î² â†’ Prop) : Î± Ã— Î² â†’ Î± Ã— Î² â†’ Prop
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î²] [preorder Î±] [bounded_order Î±] (gi : galois_insertion l u) : bounded_order Î²
{Î“ : Type u_1} [inhabited Î“] : list Î“ â†’ turing.list_blank Î“
(Î± : Type u_1) : Type u_1
{Î± : Type u_1} [comm_monoid Î±] (a b u : Î±) (hu : is_unit u) : a âˆ£ u * b â†” a âˆ£ b
(x y : nonote) : nonote
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (a0 : 0 < a) : 1 â‰¤ a * b
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (l : list (Î£ (a : Î±), Î² a)) (m : hash_map Î± Î²) : hash_map Î± Î²
(n : â„•) : pos_num
{R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) {n : â„•} (b : o â†’ fin n) : Prop
(Î± : Type u_1) (r s : Î± â†’ Î± â†’ Prop) : Type
{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s âˆ© t)
(Î± : Type u_2) [fintype Î±] [linear_order Î±] [bounded_order Î±] : complete_linear_order Î±
{H : Type u} [topological_space H] {Î± : Type u_5} [topological_space Î±] [nonempty Î±] {f : Î± â†’ H} (h : open_embedding f) : charted_space H Î±
(X : Type u) : Type u
{X : Type u_1} (to_two_pointing : two_pointing X) : Twop
 : has_one onote
{Î± : Type u_1} {n : â„•} : has_lift (vector Î± n) (sym Î± n)
(V : Type u) [quiver V] : Sort (max (u+1) v)
{M : Type u} [has_add M] (a x y : M) : Prop
(Î± : Type u) : category_theory.sieve Î±
{n : â„•} (c : composition n) : fin c.length â†’ â„•
{Î± : Type u_1} {Î² : Type u_2} [preorder Î²] [decidable_rel has_lt.lt] (f : Î± â†’ Î²) (l : list Î±) : option Î±
{G : Type u_1} [group G] (H K : set G) : setoid G
(o : ordinal) : Prop
{M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0
{Î± : Type u} (P : Î± â†’ Prop) [decidable_pred P] : list Î± â†’ list Î± â†’ list (list Î±)
{Î± : Type u} (f : Î± â†’ Î±) : set Î±
(Î± : Sort u) : Sort u
(R : Type u_1) : Type u_1
{b : Prop} (a : Prop) (h : a â†” b) [D : decidable a] : decidable b
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : submodule R M
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] (g : Î² â†’ Î³) (f : measure_theory.simple_func Î± Î²) : measure_theory.simple_func Î± Î³
{Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.pos_mul_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (a0 : 0 â‰¤ a) : 1 â‰¤ a * b
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) : Prop
{C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) (X : C) : closure_operator (category_theory.sieve X)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
(Î± : Type u) : Type u
{Î± : Type u} : list Î± â†’ list (list Î±)
(M : Type u_10) (A : Type u_11) [monoid M] [monoid A] : Type (max u_10 u_11)
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X â†’ Y) : Prop
{M : Type u_1} [mul_one_class M] (S : submonoid M) : 1 âˆˆ S
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) (s : set M) (hs : s = â†‘S) : add_submonoid M
{Î± : Type u_1} [comm_semiring Î±] (t : tree Î±) (râ‚ râ‚‚ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr râ‚ = tactic.ring2.horner_expr.of_csexpr râ‚‚) : tactic.ring2.csring_expr.eval t râ‚ = tactic.ring2.csring_expr.eval t râ‚‚
{G : Type u_1} [group G] (H : subgroup G) : subgroup (conj_act G)
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (f : Î± â†’ Î²) : Î± âŠ• Î³ â†’ Î² âŠ• Î³
{Î· : Type u_2} [fintype Î·] {Gs : Î· â†’ Type u_3} [Î  (i : Î·), group (Gs i)] [âˆ€ (i : Î·), group.is_nilpotent (Gs i)] : group.is_nilpotent (Î  (i : Î·), Gs i)
(M : Type u) : Type u
{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R
(G : Type u_1) [monoid G] : Prop
(Î± : Type u_1) [order.frame Î±] : Locale
{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R â‰  2) : 2 â‰  0
(C : Type u) [category_theory.category C] : Prop
(Î± : Type u) : Type u
{R : Type u_1} [has_zero R] (n : R) : Prop
(Î± : Type u_2) : Type u_2
{n : â„•} (x y : bitvec n) : Prop
{Î± : Type u_1} {n : â„•} (f : fin n â†’ Î±) (i : â„•) : option Î±
(S : Type u) [semiring S] : â„• â†’ polynomial S
{n : â„•} (x y : bitvec n) : bitvec n
{Î± : Type u_1} : Î± â†’ list Î± â†’ Î±
(A : Type u_2) : Type u_2
{Î± : Type u} (f : fin 0 â†’ Î±) : list.of_fn f = list.nil
{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set M) : Prop
(Î± : Type u_5) : Type u_5
{Î± : Type u_1} [comm_monoid Î±] (a b u : Î±) (hu : is_unit u) : u * a âˆ£ b â†” a âˆ£ b
(Î± : Sort u) [has_variable_names Î±] {Î² : Sort v} : has_variable_names Î²
{Î± : Type} (seed : â„•) (cmd : rand Î±) : io Î±
 : Type
 : bool â†’ bool â†’ bool
{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K
 : Â¬summable (Î» (n : â„•), (â†‘n)â»Â¹)
{C : Type uâ‚} [category_theory.category C] {X : C} (t : category_theory.limits.is_initial X) : category_theory.limits.is_terminal (opposite.op X)
{F : pfunctor} : â„• â†’ F.M â†’ F.M â†’ Prop
(R : Type u) [semiring R] (p q : â„•) [hp : char_p R p] [hq : exp_char R q] : p = q â†” nat.prime p
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X
 : game â†’ game â†’ Prop
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : has_faithful_smul (module.End R M) M
{Î± : Type u_2} [add_monoid Î±] : add_monoid (set Î±)
(R : Type u_1) (K : Type u_2) [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] : Type u_2
{A : Type u_2} [add_group A] (a : A) : add_subgroup A
(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : field K
(p : â„•) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (V : Type u_2) [add_comm_group V] : Type (max u_1 u_2)
{Î± : Type u} (l : ordnode Î±) (x : Î±) (r : ordnode Î±) : ordnode Î±
(C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C
{Î± : Type u_1} {Î² : Type u_2} [group Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_group_hom (Î» (a : Î±), (f a)â»Â¹)
{R : Type u_1} [ring R] {M : Type u_2} [topological_space M] [add_comm_group M] [module R M] (p : submodule R M) : Prop
{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : â„•
(Î± : Type u) : Type u
{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : âˆ€ (a : R), a âˆˆ l â†’ 0 < a) : 0 < l.prod
{A : Type v} [ring A] {M : Type w} [add_comm_group M] [module A M] : lie_ring_module A M
{Î± : Type u_1} [ring Î±] : partial_order (ring_topology Î±)
{Î± : Type u} {Î² : Type v} [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) (a : Î±) : Prop
(F : Type u_8) (Î± : out_param (Type u_9)) (Î² : out_param (Type u_10)) [has_Inf Î±] [has_Inf Î²] : Type (max u_10 u_8 u_9)
{Î± : Type u} [primcodable Î±] [inhabited Î±] (p : Î± â†’ Prop) : many_one_degree
{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 âˆˆ interior â†‘H) : is_open â†‘H
(E : Type u_8) [comm_group E] [topological_space E] [topological_group E] : continuous_monoid_hom (E Ã— E) E
(n : snum) : snum
(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom (E Ã— E) E
{X : Type u_1} {Î± : Type u_2} [has_one Î±] [topological_space X] (f : X â†’ Î±) : set X
{R : Type u} [linear_order R] : has_add (tropical R)
(x : Set) : Class
(C : Type u) [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_finite_limits C
{Î± : Type u} : ordnode Î± â†’ ordnode Î±
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [inhabited Î±] [inhabited Î²] (f : Î± â†’ Î² â†’ Î³) : list Î± â†’ list Î² â†’ list Î³
{Î± : Type u} [topological_space Î±] {s : set Î±} : is_compact s â†’ âˆ€ (f : ultrafilter Î±), â†‘f â‰¤ filter.principal s â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), â†‘f â‰¤ nhds a)
(n : â„•) : Type
{Î± : Type u_1} [comm_semiring Î±] : linear_recurrence Î±
{Î± : Type u} (f : Î± â†’ Type (max u v)) : Â¬function.surjective f
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] (m : Î  (i : Î¹), measure_theory.outer_measure (Î± i)) : measure_theory.outer_measure (Î  (i : Î¹), Î± i)
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ option Î±
{R : Type u_1} {S : Type u_3} [comm_ring R] [comm_ring S] : comm_ring (R Ã— S)
{Î± : Type u_1} {Î² : Type u_2} : lazy_list Î± â†’ (Î± â†’ lazy_list Î²) â†’ lazy_list Î²
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (t : topological_space Î²) : topological_space Î±
{Î± : Type u} (c : computation Î±) : â„• â†’ computation Î±
{Î± : Type u_1} [linear_order Î±] (succ : Î± â†’ Î±) (hsucc_le_iff : âˆ€ {a b : Î±}, succ a â‰¤ b â†” a < b) : succ_order Î±
{R : Type u} [semiring R] {S : Type u_1} [add_comm_monoid S] (p : polynomial R) (f : â„• â†’ R â†’ S) : S
 : stream â„•
{Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_mul_hom (Î» (a : Î±), (f a)â»Â¹)
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : Prop
{M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)
{M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x
{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G
{Î± : Type u_1} {Î² : Type u_2} [primcodable Î±] [primcodable Î²] (p : Î± â†’ Prop) (q : Î² â†’ Prop) : Prop
(Î± : Type u_6) (Î² : Type u_7) [non_assoc_semiring Î±] [preorder Î±] [non_assoc_semiring Î²] [preorder Î²] : Type (max u_6 u_7)
{R : Type u_1} [euclidean_domain R] (abv : absolute_value R â„¤) : Type
{Î± : Type u_1} (l : lazy_list Î±) : lazy_list {x // x âˆˆ l}
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [has_Inf Î±] [has_Inf Î²] [has_Inf Î³] (f : Inf_hom Î² Î³) (g : Inf_hom Î± Î²) : Inf_hom Î± Î³
{Î± : Type u_1} [Î² : normed_ring Î±] : non_unital_normed_ring Î±
 : pgame â†’ Type (u+1)
{Î“ : Type u_1} [inhabited Î“] (a : Î“) (l : turing.list_blank Î“) : turing.list_blank Î“
{Î± : Type u_1} (s t : finset Î±) (h : âˆ€ (a : Î±), a âˆˆ s â†’ a âˆ‰ t) : finset Î±
{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below t) : bdd_below (s âˆ© t)
 : Type
{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
(t : Type u â†’ Type u â†’ Type u) [bitraversable t] : Type
(m : Type u â†’ Type u) (Î± : Type u) : Type u
(X : Type u_1) [topological_space X] [h : topological_space.metrizable_space X] : metric_space X
{T : Type w} [comm_ring T] (p : polynomial T) (S : Type u_1) [comm_ring S] [is_domain S] [algebra T S] : set S
{Î± : Type u_1} [denumerable Î±] : denumerable (list Î±)
{C : Type u} [category_theory.category C] (G : C) : Prop
(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (vâ‚ vâ‚‚ : M) : Prop
{Râ‚ : Type u_4} [comm_ring Râ‚] : quadratic_form Râ‚ Râ‚
(G : Type u_1) [add_comm_monoid G] : add_submonoid G
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : rel Î± Î²
{Î± : Type u_2} [has_one Î±] [has_mul Î±] : has_pow (filter Î±) â„•
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (a : Î±) : Î± â†’ Prop
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] (s : set Î±) (t : set Î²) : Prop
{Î± : Type u} {Î² : Type v} [topological_space Î±] [nonempty Î±] (f : filter Î²) (g : Î² â†’ Î±) : Î±
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (l : list Î±) : list â„•
{K : Type u_1} {Î² : Type u_2} [has_coe K Î²] : has_coe (generalized_continued_fraction.int_fract_pair K) (generalized_continued_fraction.int_fract_pair Î²)
{Î± : Type u_1} {Î¹ : Type u_3} [lattice Î±] [order_bot Î±] (s : finset Î¹) (f : Î¹ â†’ Î±) : Prop
{K : Type u} [field K] : has_inf (subfield K)
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (t : topological_space Î±) : topological_space Î²
(u : pSet) : set pSet
{Î² : Type u_2} (x : Î²) (V : set (Î² Ã— Î²)) : set Î²
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J â†’ C} {t : category_theory.limits.cocone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_colimit t) : category_theory.limits.bicone f
{Î± : Type u} [has_lt Î±] [hwo : is_well_order Î± has_lt.lt] : has_well_founded Î±
(R : Type u) : Type u
{M : Type u_1} [add_monoid M] {Î³ : Type u_2} [add_monoid Î³] {f : M â†’ Î³} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)
(M : Type u_1) [has_mul M] : Type u_1
{Î± : Type u} [topological_space Î±] (s : set Î±) : Prop
{R : Type u_1} [semiring R] : has_mul (nat.arithmetic_function R)
{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topological_space Î²] (f : filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : set Î±) : set Î²
(p : â„•) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] : module (fraction_ring (witt_vector p k)) (fraction_ring (witt_vector p k))
(Î± : Type u) [has_le Î±] : Type u
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î²] [comm_semiring Î²] (l : filter Î±) (k f : Î± â†’ Î²) : Prop
{M : Type u_5} [add_comm_monoid M] : unique (module â„• M)
(ð•† : Type u_5) (Î± : Type u_6) [preorder ð•†] [preorder Î±] : Type (max u_5 u_6)
{Î¹ : Type u} (f : Î¹ â†’ ordinal â†’ ordinal) (a : ordinal) : ordinal
(Î± : Type u_3) [has_sup Î±] : sup_hom Î± Î±
 : num â†’ num â†’ ordering
{Î± : Type u_4} {Î² : Type u_5} (r : Î± â†’ Î± â†’ Prop) (s : Î² â†’ Î² â†’ Prop) : Type (max u_4 u_5)
(G : Type u) : Type u
{n : â„•} : group (dihedral_group n)
 : function.injective has_dvd.dvd
{Î± : Sort u} : Î± â†’ Type
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (a b : Î±) : Prop
{Î± : Type u} [decidable_eq Î±] {Î² : Î± â†’ Type v} (l : list (sigma Î²)) : alist Î²
(m : Type u â†’ Type u) [monad m] [is_lawful_monad m] : category_theory.monad (Type u)
{X : Type u_1} [topological_space X] (s : set X) : seq_closure s âŠ† closure s
{Î“ : Type u_4} [group Î“] {T : Type u_5} [topological_space T] [mul_action Î“ T] [fintype Î“] : properly_discontinuous_smul Î“ T
{Î± : Type u_1} {Î² : Type u_2} (R : Î± â†’ Î² â†’ Prop) : list Î± â†’ list Î² â†’ Prop
(Î± : Type u) : Type u
{Î± : Type u} {Î² : Type v} [setoid Î±] [topological_space Î±] {f : Î² â†’ Î±} (hf : dense_range f) : dense_range (quotient.mk âˆ˜ f)
{Î± : Sort u_1} [subsingleton Î±] (a : Î±) : unique Î±
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
{Î± : Type u_1} [decidable_eq Î±] (s : cycle Î±) : finset Î±
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] (a : option Î±) (b : Î±) : option Î±
{M : Type u_1} [add_monoid M] {a : M} (h : is_add_unit a) : add_units M
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} : is_max_chain r (max_chain r)
{n : â„•} (x : bitvec n) (i : â„•) : bitvec n
{Î± : Type u_1} {Î² : Type u_2} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) (g : Î² â†’ Î±) : Prop
(Î± : Type u_2) [lattice Î±] : Prop
 : Type
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} (h : metric.bounded s) (hx : x âˆˆ s) (hy : y âˆˆ s) : has_dist.dist x y â‰¤ metric.diam s
{V : Type u} [quiver V] {a b : V} : quiver.path a b â†’ â„•
(c : cardinal) : Prop
{C : Type u} [category_theory.category C] (ð’¢ : set C) : Prop
(Î± : Type u) : Type u
(v : â„• â†’ â„¤) : omega.clause â†’ Prop
(a b : num) : option num
{C : Type uâ‚} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : C
{Î± : Type u_2} {Î² : Type u_3} [has_vadd Î± Î²] : has_vadd Î± (set Î²)
{H : Type u} [topological_space H] {G : structure_groupoid H} (M : Type u_1) [topological_space M] [charted_space H M] [has_groupoid M G] : structomorph G M M
{Î± : Type u_1} (s : cycle Î±) : Prop
{Î± : Type u} : list Î± â†’ lazy_list Î±
{n m : â„•} (f : vector â„• n â†’ vector â„• m) : Prop
{C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : category_theory.sieve X
{Î± : Type u_2} [has_mul Î±] : has_mul (filter Î±)
{Î± : Type u_2} [bornology Î±] (s : set Î±) : Prop
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : a < 1) (hb : b â‰¤ 1) (a0 : 0 < a) : a * b < 1
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [has_zero Î²] (f : measure_theory.simple_func Î± Î²) (s : set Î±) : measure_theory.simple_func Î± Î²
(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B â„¤) : Type (max u v)
 : Type
{Î± : Type u} (g : set (set Î±)) : topological_space Î±
{Î± : Type u_1} [topological_space Î±] (s : set Î±) : Prop
{Î¹ : Type u_1} (R : Type u_3) {M : Type u_5} (v : Î¹ â†’ M) [semiring R] [add_comm_monoid M] [module R M] : Prop
(X : Top) (T : TopCommRing) : Top.presheaf CommRing X
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ð’œ : â„• â†’ submodule R A) [graded_algebra ð’œ] : Type u_2
(C : Type u) [category_theory.category C] : Prop
(Î± : Type u_7) (Î² : Type u_8) [has_sup Î±] [has_sup Î²] : Type (max u_7 u_8)
{Î± : Type u_1} (m : set Î± â†’ ennreal) (m_empty : m âˆ… = 0) : measure_theory.outer_measure Î±
(Î± : Type u_1) (Î² : Type u_2) [topological_space Î±] [topological_space Î²] [add_group Î²] [topological_add_group Î²] : add_subgroup (Î± â†’ Î²)
{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_linear_order Î±] {b : Î±} [nonempty Î¹] {f : Î¹ â†’ Î±} (h : b < supr f) : âˆƒ (i : Î¹), b < f i
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X Y : C) : category_theory.limits.mono_factorisation 0
(L : first_order.language) (M : Type w) [L.Structure M] : L.Theory
{Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} : is_preconnected (set.Icc a b)
 : game â†’ game â†’ Prop
{Î± : Type u_1} (r s : Î± â†’ Î± â†’ Prop) (h : âˆ€ (x y : Î±), r x y â†’ s x y) : quot r â†’ quot s
(n : â„•) (R : Type u_1) [ring R] : polynomial R
{Î± : Type u_1} (R : Î± â†’ Î± â†’ Prop) [decidable_rel R] : Î± â†’ list Î± â†’ list Î±
{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : â†‘s = â†‘t) : s = t
{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a
(Î± : Type u_1) : Type u_1
{X : Type u_1} [topological_space X] {R : Type u_5} [has_zero R] {U : set X} (f : locally_constant X R) (hU : is_clopen U) : locally_constant X R
(R : Type u_1) {A : Type u_3} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop
(Î± : Type u_1) [partial_order Î±] [order_bot Î±] : Prop
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} (e : local_equiv Î± Î²) (e' : local_equiv Î³ Î´) : local_equiv (Î± Ã— Î³) (Î² Ã— Î´)
{Î± : Type u_1} [has_mul Î±] (s : set Î±) (a b : Î±) : Prop
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] (h : 0 = 1) : unique Mâ‚€
{Î¹ : Type u_1} {Î± : Type u_3} {Î² : Type u_4} [preorder Î±] [preorder Î²] (f : Î¹ â†’ Î±) (g : Î¹ â†’ Î²) : Prop
(M : Type u) (R : Type v) [monoid M] [semiring R] : Type (max u v)
(Î± : Type u_2) [has_Sup Î±] : Sup_hom Î± Î±
(L : first_order.language) (M : Type u_3) (N : Type u_4) [L.Structure M] [L.Structure N] : Type (max u_3 u_4)
{Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±) (a : Î±) : multiset Î±
{Î± : Type u_2} {Î² : Type u_4} [topological_space Î±] [has_zero Î²] (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
{Î± : Type u} (m : measure_theory.outer_measure Î±) : measurable_space Î±
{Î± : Type u} (l : stream Î±) : wseq Î±
{R : Type u} [ring R] (s : subsemiring R) (hneg : -1 âˆˆ s) : subring R
(Î± : Type u_1) [encodable Î±] : Type
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V â†” nontrivial V
{R : Type u_1} [ring R] (S : subring R) : subalgebra â„¤ R
{m : Type u_1 â†’ Type u_2} {n : Type u_1 â†’ Type u_3} [has_monad_lift_t m n] {Î± : Type u_1} : has_coe (m Î±) (n Î±)
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ multiset.nat.antidiagonal n â†” x.fst + x.snd = n
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (l : list (Î£ (a : Î±), Î² a)) : bool
(n : â„•) : has_neg (fin n)
{Î± : Type u} [has_inv Î±] [has_sup Î±] : has_abs Î±
(X : algebraic_geometry.Scheme) : Prop
{Î¹ : Type u} (f : Î¹ â†’ ordinal) : bdd_above (set.range f)
{Î± : Type u} {Î² : Type v} {Î´ : Type w} (f : Î± â†’ Î² â†’ Î´) (sâ‚ : stream Î±) (sâ‚‚ : stream Î²) : stream Î´
(C : Type u) [category_theory.category C] : Prop
{Î² : Type u_6} {Î³ : Type u_7} {m m0 : measurable_space Î²} (hm : m â‰¤ m0) (f : measure_theory.simple_func Î² Î³) : measure_theory.simple_func Î² Î³
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] {a b c : Î±} (hc : c â‰  0) : a * c âˆ£ b * c â†” a âˆ£ b
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_partial_order Î± r] : âˆƒ (s : Î± â†’ Î± â†’ Prop) (_x : is_linear_order Î± s), r â‰¤ s
{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ Î± â†’ Î±
{Î± : Type u_1} (S : set (set Î±)) : set (set Î±)
(Î± : Type u) : Type u
{X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] : paracompact_space X
{Î± : Type u_1} [encodable Î±] : encodable (ulift Î±)
{Î± : Type u_1} (f : Î± â†’ Î±) : list Î± â†’ list Î±
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) : local_homeomorph Î² Î±
{Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ âˆ…), f i)) = 0
{Î± : Type u_2} [decidable_eq Î±] [subtraction_monoid Î±] : subtraction_monoid (finset Î±)
{m : â„•} : bitvec m â†’ â„• â†’ bitvec m
{Î± : Type u_1} {Î² : Type u_2} (e e' : local_equiv Î± Î²) : Prop
 : pythagorean_triple 0 0 0
{R : Type u} [semiring R] (p : polynomial R) : Prop
{Î± : Type u_1} [decidable_eq Î±] (ð’œ : finset (finset Î±)) : finset (finset Î±)
{Î¹ : Type u_1} {A : Î¹ â†’ Type u_2} (i : Î¹) : A i â†’ graded_monoid A
(n : â„•) : Type (u+1)
{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 â†’ R} (h : is_coprime (p 0) (p 1)) : p â‰  0
{Î± : Type u_1} : sym2 Î± â†’ Prop
(X Y : algebraic_geometry.LocallyRingedSpace) : Type u_1
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) : Î± â†’ Î²
(n : Type u) (R : Type v) [decidable_eq n] [fintype n] [comm_ring R] : Type (max u v)
(Î± : Type u_6) (Î² : Type u_7) [has_top Î±] [has_top Î²] : Type (max u_6 u_7)
(M : Type u_1) (X : Type u_2) [has_vadd M X] [topological_space M] [topological_space X] : Prop
{Î± : Type u_1} {Î² : Type u_2} : Î± Ã— Î² â†’ (Î£ (_x : Î±), Î²)
{Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_simple_group Î±
{X : Type u_1} (a : free_abelian_group X) : finset X
{Î± : Type u_1} : ordnode Î± â†’ Prop
(X : Type u) (Y : Type v) [topological_space X] [topological_space Y] : Type (max u v)
(f : bool â†’ bool) (x : bool) : f (f (f x)) = f x
{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ b = a
{Ï„ : Type u_1} {Î± : Type u_2} (Ï• : Ï„ â†’ Î± â†’ Î±) (s : set Î±) : Prop
{Î± : Type u_1} {Î² : Type u_2} (p : pmf Î±) (f : Î± â†’ pmf Î²) : pmf Î²
{n : â„•} : zmod n â†’ â„•
{Î± : Type u_1} (p : pmf Î±) : set Î±
{Î± : Type u_2} [add_comm_monoid Î±] : add_comm_monoid (filter Î±)
(R : Type u) [ring R] : galois_insertion subring.closure coe
{n : Type u_3} {Î± : Type v} (v : n â†’ Î±) : matrix unit n Î±
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] [decidable_eq R] (s : finset S) : finset R
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
(Î± : Type) [has_zero Î±] [has_one Î±] [has_add Î±] [fintype Î±] (fromc : char) : parser Î±
 : has_le cardinal
(k : Type u) [field k] (n : â„•) : Type u
{R : Type u_2} [has_add R] (c : R) : Prop
{Î± : Type u_1} [has_one Î±] [has_zero Î±] [has_lt Î±] (a : Î±) : continued_fraction Î±
{V : Type u} (G : simple_graph V) (u v : V) : Type u
{V : Type u} (G : simple_graph V) (v w : V) : set V
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M
{Î± : Type u_1} : option (option Î±) â†’ option Î±
{Î± : Type u_1} (x : Î±) : free_add_monoid Î±
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : free_semigroup Î± â†’ free_semigroup Î²
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : Type u_2
{R : Type uâ‚} [semiring R] (r : R â†’ R â†’ Prop) : R â†’ R â†’ Prop
(n : â„•) : option â„•
{Î± Î² : ordinal} (h : Î± â‰¤ Î²) : initial_seg has_lt.lt has_lt.lt
(n : â„•) : Type
{Î± : Type u_1} (s : set Î±) (r : Î± â†’ Î± â†’ Prop) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (Î¹ : Type u_1) [unique Î¹] : finite_dimensional.finrank K V = 1 â†” nonempty (basis Î¹ K V)
(Î± : Type u_1) : Type u_1
(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] : submodule R A
{Râ‚ : Type u_4} [comm_ring Râ‚] {n : Type w} [fintype n] [decidable_eq n] (M : matrix n n Râ‚) : quadratic_form Râ‚ (n â†’ Râ‚)
{G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
{K : Type u} [hring : comm_ring K] : ratfunc K
{Î± : Type u} [t : topological_space Î±] (s : set Î±) : Prop
{Î± : Type u_2} [decidable_eq Î±] [has_neg Î±] : has_neg (finset Î±)
(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : has_neg (module.ray R M)
{Î± : Type u_1} [decidable_eq Î±] {ð’œ : finset (finset Î±)} {s : finset Î±} (hs : s âˆˆ ð’œ.shadow) : âˆƒ (t : finset Î±) (H : t âˆˆ ð’œ), s âŠ† t
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop
{Î± : Type u_1} [lattice Î±] [bounded_order Î±] [is_simple_order Î±] : complete_boolean_algebra Î±
(ð•œ : Type u_1) (E : Type u_2) [ordered_ring ð•œ] [add_comm_group E] [module ð•œ E] : Type u_2
{A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M â‰¤ non_zero_divisors A) : is_domain (localization M)
{Î± : Type u} [non_unital_non_assoc_ring Î±] (a b c : Î±) : (a - b) * c = a * c - b * c
 : Type
{Î± : Type u} (râ‚ râ‚‚ : set (Î± Ã— Î±)) : set (Î± Ã— Î±)
{Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} (H : is_semiring_hom f) : is_ring_hom f
{Î± : Type u_1} [preorder Î±] [add_comm_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y
(F : Type u_1) (Î± : out_param (Type u_2)) (Î² : out_param (Type u_3)) [topological_space Î±] [topological_space Î²] : Type (max u_1 u_2 u_3)
{J : Type u} (F : J â†’ Type u) : category_theory.limits.colimit_cocone (category_theory.discrete.functor F)
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V
 : Type
 : Type
{Î± : Type u_1} [preorder Î±] [decidable_rel has_lt.lt] (l : list Î±) : with_bot Î±
{Î± : Type} {ds : list â„•} [ring Î±] (x : holor Î± ds) : â„•
 : Type
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.snd
(a : â„¤) : â„¤
(n m : â„•) : Prop
{Î¹ : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] [fintype Î¹] (b : Î¹ â†’ B) : A
{V : Type u} (G : simple_graph V) : set V
(ð•† : Type u_5) (Î± : Type u_6) [preorder ð•†] [preorder Î±] : Type (max u_5 u_6)
(Î± : Type u_2) [has_Inf Î±] : Inf_hom Î± Î±
{R : Type u_1} [semiring R] (p : polynomial R) : polynomial R
{Î± : Sort u_1} (f : Î± â†’ Î±) : Prop
 : Type
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : stream Î±) : stream Î²
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : monoid (category_theory.skeleton C)
{C : Type uâ‚} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.reflects_isomorphisms (Mon_.forget C)
{Î± : Type u} {Î² : Î± â†’ Type (max u v)} [decidable_eq Î±] (xs : list Î±) : (Î  (a : Î±), list (Î² a)) â†’ list (Î  (a : Î±), a âˆˆ xs â†’ Î² a)
(Î± : Type u_1) [topological_space Î±] : setoid Î±
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (tfGs : âˆ€ (i : Î·), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Î  (i : Î·), Gs i)
 : nzsnum â†’ nzsnum
(p : Type u_2) (q : Type u_3) (R : Type uâ‚‚) [decidable_eq p] [decidable_eq q] [comm_ring R] (i : R) : matrix (p âŠ• q) (p âŠ• q) R
{K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : â†‘c.convergents = â†‘c.convergents'
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : a < 1 â†’ 1 < aâ»Â¹
{Î± : Type u_1} {Î² : Type u_2} [fintype Î±] (f : Î± â†’ Î²) (H : function.bijective f) : fintype Î²
(K : Type u_1) [field K] [number_field K] : â„•
{Î± : Type u_1} [decidable_eq Î±] (a : Î±) : multiset Î± â†’ â„•
{x y z : â„¤} (h : pythagorean_triple x y z) : Prop
(Î± : Type u) [t : topological_space Î±] : Prop
{Î¹ : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering Î¹ X s) : partition_of_unity Î¹ X s
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î² â†’ Î²) (b : Î²) (l : list Î±) : list Î²
 : nzsnum â†’ bool
{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] {B : C} [category_theory.is_connected J] [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J (category_theory.over B)
(L : first_order.language) : Type u
{n : â„•} {Î± : fin n â†’ Type u} {Î² : Type w} (a : d_array n Î±) (b : Î²) (f : Î  (i : fin n), Î± i â†’ Î² â†’ Î²) : Î²
{m : Type â†’ Type v} [monad m] {Î± : Type u} (p : Î± â†’ m bool) : list Î± â†’ m bool
{Î± : Type u_2} [semiring Î±] (a : Î±) : Prop
{C : Type u} [category_theory.category_struct C] (X : C) : has_mul (category_theory.End X)
{R : Type uâ‚} [semiring R] [star_ring R] (r : R â†’ R â†’ Prop) (hr : âˆ€ (a b : R), r a b â†’ r (has_star.star a) (has_star.star b)) : star_ring (ring_quot r)
(m M N : â„•) : finset (Î£ (n : â„•), composition n)
{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s âˆª t)
{Î± : Type u_1} [preorder Î±] (a b : Î±) : set Î±
(M : Type u) : Type u
{n : â„•} (x y : bitvec n) : bitvec n
{X : Type u_2} [emetric_space X] (m : set X â†’ ennreal) : measure_theory.outer_measure X
 : Â¬bdd_above {p : â„• | nat.prime p}
{Î± : Type} (sep : parser unit) (p : parser Î±) : parser (list Î±)
{Î± : Type u_1} (n : â„¤) : poly Î±
 : Type
(p : pos) (n : â„•) : pos
{Î± : Type u} {Î² : Type v} (f : filter Î±) (m : Î± â†’ filter Î²) : filter Î²
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†’ 1 < a
{Î± : Type u} [has_inv Î±] : has_inv (with_zero Î±)
{n : â„•} (x y : bitvec n) (c : bool) : bitvec (n + 1)
{p : â„•} [fact (nat.prime p)] : padic_norm_e 1 = 1
(cs : list omega.clause) : Prop
{Î± : Type u_1} {n : â„•} (f : fin n â†’ Î±) (m : â„•) : m â‰¤ n â†’ list Î± â†’ list Î±
(Î± : Type u_1) [ht : topological_space Î±] [h : polish_space Î±] : metric_space Î±
{Î“ : Type u_1} {R : Type u_2} [partial_order Î“] [has_zero R] (x : hahn_series Î“ R) : set Î“
 : Type â†’ Type
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_symm Î± r] {a b : Î±} : r a b â†” r b a
{Î± : Type u} {Î² : Type v} (f : filter (Î± â†’ Î²)) (g : filter Î±) : filter Î²
(m m' : Type u â†’ Type v) (n n' : Type u â†’ Type w) : Type (max (u+1) v w)
(K : Type u) [field K] : Type (u+1)
 : Type (u+1)
 : filter.cofinite = filter.at_top
(Î± : Type u_3) [topological_space Î±] : Type u_3
{Î± : Type u_1} {P : Î± â†’ Prop} [encA : encodable Î±] [decP : decidable_pred P] : encodable {a // P a}
 : bool â†’ list bool
(Î± : Type u_6) (Î² : Type u_7) [topological_space Î±] [topological_space Î²] : Type (max u_6 u_7)
(R : Type u) (A : Type v) [comm_semiring R] [star_ring R] [semiring A] [star_ring A] [algebra R A] [star_module R A] : Type v
{R : Type u_3} [comm_ring R] (p : polynomial R) (s : R) : polynomial R
{Î± : Type u_2} [monoid Î±] (m : Î±) : is_square m â†’ (âˆƒ (c : Î±), m = c ^ 2)
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
{Î± : Type u_1} [boolean_algebra Î±] : boolean_ring Î±
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (u : uniform_space Î²) : uniform_space Î±
{Î± : Type u_1} [has_le Î±] (a : Î±) : Prop
(Î± : Type u_1) (Î² : Type u_2) [has_add Î±] [add_comm_semigroup Î²] : add_hom (add_hom Î± Î²) (Î± â†’ Î²)
{R : Type u_1} {S : Type u_3} [non_unital_semiring R] [non_unital_semiring S] : non_unital_semiring (R Ã— S)
{G : Type u_1} [add_group G] (H K : add_subgroup G) : â„•
{R : Type u_1} (câ‚ câ‚‚ : R) : cardinal.mk (quaternion_algebra R câ‚ câ‚‚) = cardinal.mk R ^ 4
 : znum â†’ znum
(n : Type u) [decidable_eq n] [fintype n] (Î± : Type v) [comm_ring Î±] [star_ring Î±] : submonoid (matrix n n Î±)
(Î± : Type u) [t : topological_space Î±] : Prop
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurable_space Î±} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] (hf : measure_theory.strongly_measurable f) : measurable f
{Î± : Type u_1} {s : multiset Î±} {x : multiset Î± Ã— multiset Î±} : x âˆˆ s.antidiagonal â†” x.fst + x.snd = s
(Î± : Type uâ‚) : Type uâ‚
(ð•œ : Type u_1) {E : Type u_2} [ordered_semiring ð•œ] [add_comm_monoid E] [module ð•œ E] : closure_operator (set E)
{R : Type u} [comm_semiring R] (S : Type u_1) [semiring S] [algebra R S] (M : submonoid R) : submonoid S
{P : Type u_1} [preorder P] [order_top P] : order_bot (order.pfilter P)
 : Type (u+1)
{f : â„• â†’ nnreal} (hf : âˆ€ â¦ƒm n : â„•â¦„, 0 < m â†’ m â‰¤ n â†’ f n â‰¤ f m) : summable (Î» (k : â„•), 2 ^ k * f (2 ^ k)) â†” summable f
{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : set.Iio a âŠ† set.Iio b
{Î± : Type u_3} {Î² : Type u_4} [has_sup Î±] [has_bot Î±] [has_sup Î²] [has_bot Î²] (f : sup_bot_hom Î± Î²) : bot_hom Î± Î²
{Î± : Type u} {n : â„•} (v : fin n.succ â†’ Î±) : Î±
(p : â„• â†’ Prop) : Type
(R : Type u_1) [rack R] : Prop
(Î± : Type u_1) : Type u_1
{X : Type u_1} [topological_space X] {R : Type u_5} [has_one R] {U : set X} (f : locally_constant X R) (hU : is_clopen U) : locally_constant X R
 : Type
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : seq Î± â†’ seq Î²
(p : â„•) (G : Type u_1) [group G] : Prop
{Î± : Type u} [add_group Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} (h : 0 < a) : -a < a
{M : Type u_1} [mul_one_class M] (S : submonoid M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{R : Type u_1} [has_mul R] [has_star R] (x : R) : Prop
(x : pSet) (y : pSet) : Prop
{M : Type u_1} [mul_one_class M] : has_coe (con M) (submonoid (M Ã— M))
{Î± : Type u_1} [preorder Î±] [order_top Î±] [locally_finite_order Î±] (a : Î±) : finset Î±
 : Type
{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (has_vsub.vsub p)
(t : Type u â†’ Type u) [traversable t] : Type (u+1)
(i j : â„¤) : â„•
(Î± : Type u_2) [cancel_comm_monoid_with_zero Î±] : Type u_2
{n : â„•} : nat.fib (n + 2) = nat.fib n + nat.fib (n + 1)
{Î± : Type u} {Î² : Type v} [semiring Î±] [semiring Î²] {f : Î± â†’ Î²} (hf : is_semiring_hom f) : is_monoid_hom f
{M : Type u_1} [add_zero_class M] : complete_lattice (add_submonoid M)
{Î± : Type u_1} (l : filter Î±) : filter (set Î±)
{Î± : Type u} [pseudo_emetric_space Î±] (x : Î±) (s : set Î±) : ennreal
{Î± : Sort u_1} {p : Î± â†’ Prop} (hp : âˆ€ (a : Î±), Â¬p a) : is_empty (subtype p)
{m : Type v â†’ Type w} [applicative m] {Î± : Type u_1} (f : â„• â†’ Î± â†’ m punit) (as : list Î±) : m punit
{Î± : Type u_1} [decidable_eq Î±] (s : finset Î±) : finset (sym2 Î±)
{V : Type u} [quiver V] (H : wide_subquiver (quiver.symmetrify V)) : wide_subquiver V
{Î± : Type u} [semiring Î±] (s : set Î±) : ideal Î±
{n : â„•} (c : composition n) : composition_as_set n
{Râ‚‚ : Type u_5} {Mâ‚‚ : Type u_6} [comm_semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] (Bâ‚‚ : bilin_form Râ‚‚ Mâ‚‚) : submodule Râ‚‚ (module.End Râ‚‚ Mâ‚‚)
(a b : Prop) : Prop
{Î± : Type u_1} {Î² : Type u_4} [partial_order Î±] [preorder Î²] {u : Î² â†’ Î±} (l : lower_adjoint u) : closure_operator Î±
(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) : Î¹ â†’ k
{G : Type u_1} [group G] (h : monoid.exponent_exists G) : monoid.is_torsion G
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Type (max u v)
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : 0 âˆˆ S
{R : Type u} [semiring R] (x : laurent_series R) : power_series R
(C : Type uâ‚) [category_theory.category C] : category_theory.monad C
(Î± : Type) : Type
{Î± : Type u_1} {n : Type u_4} [has_sub n] (v : n â†’ Î±) : matrix n n Î±
 : Type
(Î± : Type u_1) [measurable_space Î±] : Type u_1
(G : Type u_1) [category_theory.groupoid G] : Type u_1
(K : Type u_1) [field K] : Prop
(F : Type u_7) (Î± : out_param (Type u_8)) (Î² : out_param (Type u_9)) [has_inf Î±] [has_inf Î²] [has_top Î±] [has_top Î²] : Type (max u_7 u_8 u_9)
{Î± : Type u} [comm_semiring Î±] {p p' ps ps' : Î±} : p = p' â†’ ps = ps' â†’ p + ps = p' + ps'
{Î± : Sort u_1} {p : Î± â†’ Prop} (P : âˆƒ (a : Î±), p a) : Î±
{a b k : â„•} (h_ab_coprime : a.coprime b) (hka : k âˆ£ a) (hkb : k âˆ£ b) : k = 1
{Î¹ : Type u_1} {Î± : Type u_2} [unique Î¹] [inhabited Î±] : inhabited (indexed_partition (Î» (i : Î¹), set.univ))
{Î± : Type u_1} {ð’œ : finset (finset Î±)} {A : finset Î±} {r : â„•} : A âˆˆ ð’œ.slice r â†” A âˆˆ ð’œ âˆ§ A.card = r
{R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A] : has_div (submodule R A)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [S : Î  (i : Î¹), setoid (Î± i)] (f : Î  (i : Î¹), quotient (S i)) : quotient pi_setoid
{R : Type u} {M : Type v} [has_zero R] (m : M) : triv_sq_zero_ext R M
(Î± : Type u) : Type u
{Î± : Type uu} (lâ‚ lâ‚‚ : list Î±) : Prop
(u : pnat.xgcd_type) : Prop
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} (f : Î± â†’ Î² â†’ Î³ â†’ Î´) : list Î± â†’ list Î² â†’ list Î³ â†’ list Î´
(Î± : Type u_1) : Type u_1
{R : Type u_1} {G : Type u_4} [group G] [mul_action G R] (g : G) : is_smul_regular R g
(Î± : Type u_2) [topological_space Î±] [preorder Î±] : esakia_hom Î± Î±
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X â†’ Y} : lipschitz_with C f â†’ holder_with C 1 f
{C : Type u} [category_theory.category C] (X Y : C) : Type v
(p : pos_num) : â„• â†’ pos_num
(m M N : â„•) : set (Î£ (n : â„•), composition n)
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [complete_lattice Î±] [complete_lattice Î²] [complete_lattice Î³] (f : complete_lattice_hom Î² Î³) (g : complete_lattice_hom Î± Î²) : complete_lattice_hom Î± Î³
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1
(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] (p : â„•) [char_p R p] : char_p K p
{Î± : Type u_1} {Î² : Type u_2} (r : rel Î± Î²) (s : set Î²) : set Î±
{Î± : Type u_1} [h : normed_lattice_add_comm_group Î±] : ordered_add_comm_group Î±
{Î± : Type u} (p : Î± â†’ Prop) (f : filter Î±) : Prop
{Î± : Type u} : ordnode Î± â†’ option Î±
(Î± : Type u_6) (Î² : Type u_7) [preorder Î±] [preorder Î²] [bounded_order Î±] [bounded_order Î²] : Type (max u_6 u_7)
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K â†’ ratfunc K â†’ ratfunc K
{M : Type u_1} [has_add M] : has_add (ultrafilter M)
(L : first_order.language) : L.Structure unit
(C : Type u) [category_theory.category C] : Prop
{Î± : Type u} (lt : Î± â†’ Î± â†’ Prop) [decidable_rel lt] (x : Î±) : tree Î± â†’ option pos_num
(p : â„•) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [is_alg_closed k] {aâ‚ aâ‚‚ : witt_vector p k} (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) : â„• â†’ k
{Î¹ : Sort u_1} {Î± : Type u_2} [complete_lattice Î±] (t : Î¹ â†’ Î±) : Prop
{Î± : Type u_1} (p : Prop) (f : p â†’ part Î±) : part Î±
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) : Prop
(m : Type u) (n : Type u') (Î± : Type v) : Type (max u u' v)
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
(M : Type u_1) [measurable_space M] [has_add M] : Prop
{R : Type u_2} {Î“â‚€ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Î“â‚€] (v : valuation R Î“â‚€) : preorder R
(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] (a b : Î±) : multiset Î±
{R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype Î¹] (b : basis Î¹ R M) : module.finite R M
(X : Type u_1) [topological_space X] [locally_compact_space X] [sigma_compact_space X] : compact_exhaustion X
{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b
{b : â„•} (hb : 1 < b) {x y : â„•} (hy : 0 < y) : b ^ x â‰¤ y â†” x â‰¤ nat.log b y
(A : Type u_9) [add_zero_class A] : Type u_9
(Î± : Type) [has_zero Î±] [has_one Î±] [has_add Î±] [fintype Î±] : parser Î±
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.full (category_theory.shift_functor C i)
(Î± : Type u_10) (Î² : Type u_11) [monoid Î±] : Type (max u_10 u_11)
(G : Type u) : Type u
 : Type
{Î± : Type u_1} : list (list Î±) â†’ list (list Î±)
(R : Type u_1) [has_zero R] [has_pow R â„•] : Prop
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} (B : filter_basis Î±) : filter Î±
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup M) : add_subsemigroup N
{n : â„•} (P : mvpfunctor (n + 1)) {Î² : Type u} (gâ‚€ : Î² â†’ P.A) (gâ‚‚ : Î  (b : Î²), P.last.B (gâ‚€ b) â†’ Î²) : Î² â†’ P.last.M
(Î± : Type u_1) [topological_space Î±] : filter Î±
{Î± : Type u} {a b c d : Î±} [preorder Î±] (hca : c â‰¤ a) (hbd : b â‰¤ d) : a â‰¤ b â†’ c â‰¤ d
(n : â„•) (h : 0 < n) : composition n
(C : Type u) [category_theory.category C] : Type (max u v)
{Î± : Type u_1} [dec : decidable_eq Î±] : regular_expression Î± â†’ list Î± â†’ bool
 : Type
{Î¹ : Type u_1} (câ‚ câ‚‚ : complex_shape Î¹) : complex_shape Î¹
{Î± : Type u} : dlist Î±
(Î± : Type u) (Î² : Type v) [partial_order Î±] [partial_order Î²] : partial_order (Î± Ã— Î²)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : continuous f) : filter.comap f (filter.cocompact Î²) â‰¤ filter.cocompact Î±
{V : Type u_1} {Î± : Type u_2} [has_zero Î±] [has_one Î±] (A : matrix V V Î±) : Prop
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : generalized_continued_fraction K
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (f : cocompact_map Î² Î³) (g : cocompact_map Î± Î²) : cocompact_map Î± Î³
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [has_bot Î±] [has_bot Î²] : Type (max u_6 u_7 u_8)
{Î± : Type u} {Î² : Type v} (s : seq1 Î±) (f : Î± â†’ seq1 Î²) : seq1 Î²
{P : Type u_1} [has_le P] [is_directed P has_le.le] [nonempty P] : order_top (order.ideal P)
{Î± : Type u} (s : wseq Î±) (n : â„•) : computation (option Î±)
(Î± : Type u) : Type u
{R : Type u_1} [monoid R] [star_semigroup R] (Aâ‚€ Aâ‚ Bâ‚€ Bâ‚ : R) : Type
{Î± : Type u_1} [preorder Î±] (a : Î±) : upper_set Î±
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (habc : has_btw.btw a b c) (hcba : Â¬has_btw.btw c b a) : has_sbtw.sbtw a b c
 : znum â†’ znum â†’ znum
{Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Prop} (f : Î  (a : Î±), p a â†’ Î²) (l : lazy_list Î±) : (âˆ€ (a : Î±), a âˆˆ l â†’ p a) â†’ lazy_list Î²
{J : Type u} (F : J â†’ Type u) : category_theory.limits.limit_cone (category_theory.discrete.functor F)
(C : Type u) (A : Type u_1) [category_theory.category C] [add_monoid A] : Type (max u u_1 v)
{P : Type u_1} [preorder P] (F : set P) : Prop
(X : Type u_1) {Y : Type u_2} [topological_space X] (y : Y) : locally_constant X Y
(R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : Type (max v w)
{Î± : Type u_2} [comm_semigroup Î±] : comm_semigroup (filter Î±)
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (b0 : 0 < b) : 1 â‰¤ a * b
 : list â„¤ â†’ â„•
{n : â„•} (p : fin n) (i : fin (n + 1)) : fin n
{Î± : Type u} : free_add_magma Î± â†’ â„•
{Î± : Type u_1} {s : finset Î±} {p : Î± â†’ Prop} [decidable_pred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : finset.map (function.embedding.subtype p) (finset.subtype p s) = s
(x y : Set) : Set
{Ï„ : Type u_1} {Î± : Type u_2} [preorder Ï„] [has_zero Ï„] (Ï• : Ï„ â†’ Î± â†’ Î±) (s : set Î±) : Prop
(C : Type u) [category_theory.category C] : Prop
(Î± : Type u_1) [preorder Î±] : Type u_1
(Î± : Type u_1) (Î² : Type u_2) [uniform_space Î²] : filter_basis ((Î± â†’ Î²) Ã— (Î± â†’ Î²))
{Î± : Type u_2} [add_semigroup Î±] : add_semigroup (filter Î±)
(p : â„•) [fact (nat.prime p)] (a : â„¤) (ha : â†‘a â‰  0) : zmod.legendre_sym p a = 1 âˆ¨ zmod.legendre_sym p a = -1
{X : Type u_1} [topological_space X] [locally_compact_space X] [t2_space X] : normal_space (alexandroff X)
(Î± : Type u_6) (Î² : Type u_7) [preorder Î±] [preorder Î²] : Type (max u_6 u_7)
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : Î± â†’ Î± â†’ Prop
{X : Type u_1} [emetric_space X] (s t : set X) : Prop
{Î± : Type u} [semiring Î±] (r : Î± â†’ Î± â†’ Prop) : ideal Î±
(Î± : Type u_1) [topological_space Î±] [non_unital_non_assoc_semiring Î±] : Prop
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} [decidable_eq Î±] [fintype Î±] [Î  (a : Î±), fintype (Î² a)] : fintype (Î  (a : Î±), Î² a)
{Î± : Type u_1} {P : Î± â†’ Prop} [encA : encodable Î±] : {a // P a} â†’ â„•
{K : Type u} [field K] (x : ratfunc K) : â„¤
{Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î² â†’ Prop) : list Î± â†’ list Î² â†’ Prop
 : Type
(V : Type u) : Type u
{P : Type u_1} [preorder P] (p : P) : order.pfilter P
 : Type
{X : Type u_1} [topological_space X] [path_connected_space X] (x y : X) : path x y
 : Type
{S : Type u_3} {R : Type u_4} [comm_semiring S] [semiring R] [algebra S R] (p : submodule S R) : set_like.graded_monoid (Î» (i : â„•), p ^ i)
(F : Type u_4) {Î± : out_param (Type u_5)} {Î² : out_param (Type u_6)} (r : out_param (Î± â†’ Î± â†’ Prop)) (s : out_param (Î² â†’ Î² â†’ Prop)) : Type (max u_4 u_5 u_6)
{Î± : Type u_2} [semiring Î±] {a : Î±} : odd a â†’ (âˆƒ (b : Î±), a = bit1 b)
(p : â„•) [p_prime : fact (nat.prime p)] {q r : â„•} (hq : q â‰  0) (hr : r â‰  0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_finite_biproducts C
{Î± : Type u_1} {Î² : Type u_2} [t : topological_space Î±] [group Î²] (f : Î± â†’ Î²) : group_topology Î²
 : Type (u+1)
{G : Type u_1} [group G] (s : set G) : Prop
{p : â„• â†’ Sort u} (H : Î  (n : â„•), (Î  (m : â„•), m < n â†’ p m) â†’ p n) (n : â„•) : p n
{Î± : Type u} (s : stream Î±) : stream Î±
{G : Type u_1} [add_group G] (H : add_subgroup G) {x : G} : x âˆˆ H â†’ -x âˆˆ H
(Î± : Type u_5) : Type u_5
(X : Type u_1) [topological_space X] : setoid X
{C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_initial C] (h : âˆ€ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C
(l : list Prop) : Prop
(G : Type u_1) [group G] : Prop
{Î± : Type u_1} (s : finset Î±) : list Î±
{K : Type u_1} [field K] [is_alg_closed K] : infinite K
{H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H âˆˆ structure_groupoid.maximal_atlas H G
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (s : set Î±) : set Î±
{Î± : Type u_1} [preorder Î±] [is_total Î± has_le.le] [decidable_rel has_le.le] (x : Î±) (s : ordset Î±) : ordset Î±
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {l : list R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
(P : name â†’ bool) : name â†’ bool
 : Class
{Î± : Type {G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (Î» (h : G), h - g)
 : Type
{Î± : Type u} {m : Type u â†’ Type v} [monad m] [alternative m] (tac : Î± â†’ m punit) : list Î± â†’ m Î±
{Î± : Type u} [uniform_space Î±] (a : Î±) : Cauchy Î±
(G : Type u) : Type u
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) (t : ordnode Î±) : option â„•
(Î± : Type u_2) : Type u_2
(R : Type u) (M : Type v) (Mâ‚‚ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module R Mâ‚‚] : submodule R (M Ã— Mâ‚‚)
(Î± : Type u_1) : Type u_1
(Î± : Type u_1) [finite Î±] : fintype Î±
(Î± : Type u_1) [topological_space Î±] : filter Î±
(M : Type u_1) (N : Type u_2) [add_monoid M] [add_monoid N] : Type (max u_2 u_1)
{Î± : Type u_1} : list (option Î±) â†’ list Î±
{X : Type u} [topological_space X] (xâ‚€ xâ‚ : X) : Type u
{R : Type u_4} [linear_ordered_ring R] (a : R) : 0 â‰¤ a ^ 2
{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 â‰¤ ifp_succ_n.b
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : set Î±) : Prop
{n : â„•} (F : typevec n â†’ Type u_2) [mvfunctor F] : Prop
{n : Type u_1} {R : Type uâ‚‚} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct n R
{Î± : Type u} {Î² : Type v} [h : can_lift Î± Î²] : can_lift (list Î±) (list Î²)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) : Type v
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] [fintype R] : fintype S
(X : Type u_3) [topological_space X] : Prop
(C : Type u) [category_theory.category C] : Prop
(Î“â‚€ : Type u_1) [linear_ordered_comm_group_with_zero Î“â‚€] : topological_space Î“â‚€
{n : â„•} (i j : Î£ (a : composition n), composition a.length) : i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.snd.blocks = j.snd.blocks
 : pgame â†’ pgame â†’ Prop
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
{Î± : Type u_1} [topological_space Î±] [polish_space Î±] : polish_space (â„• â†’ Î±)
(Î± : Type v) [small Î±] : Type w
{Î± : Type v} {m l r : â„•} (A : matrix (fin m) (fin (l + r)) Î±) : matrix (fin m) (fin r) Î±
 : pos_num â†’ pos_num â†’ pos_num
{Î± : Type u_1} (a : Î±) (n : â„•) : multiset Î±
{C : Sort u_1} : empty â†’ C
(Î± : Type u) : Type u
{Î³ : Type u_3} [topological_space Î³] [compact_space Î³] [t2_space Î³] : uniform_space Î³
{Î± : Type u_1} (Î² : Î± â†’ Type u_2) (a : Î±) (h : a âˆˆ âˆ…) : Î² a
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (b : Î² a) (s : finmap Î²) : finmap Î²
{Î± : Type u} [linear_order Î±] (a b : Î±) : set Î±
{Î± : Type u_1} (S : set (set Î±)) : set Î±
(M : Type u_1) (N : Type u_2) [semiring M] [semiring N] : Type (max u_1 u_2)
{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)
(Î± : Type u_1) : Type u_1
(G : pgame) : Prop
{Î± : Type u_1} (p : pmf Î±) : measure_theory.outer_measure Î±
{X : Type u_1} [topological_space X] (x y : X) : Prop
(G : Type u) [add_group G] : add_monoid G
(F : Type u_9) (Î± : Type u_10) (Î² : Type u_11) [add_monoid Î±] [add_monoid Î²] [topological_space Î±] [topological_space Î²] : Type (max u_10 u_11 u_9)
{Î± : Type u_1} [has_compl Î±] [has_sup Î±] [has_inf Î±] (a b : Î±) : Î±
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup N) : add_subsemigroup M
(G : Type u) [group G] : monoid G
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.ess_surj (category_theory.shift_functor C i)
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_sbtw.sbtw a b c â†” has_sbtw.sbtw c a b
(p : â„•) [fact (nat.prime p)] : field (zmod p)
{Î± : Type u} {Î² : Type v} [preorder Î²] (f : Î± â†’ Î²) (l : filter Î±) (a : Î±) : Prop
(R : Type u) (n : â„•) (A : Type u_1) [comm_semiring R] [semiring A] [algebra R A] [topological_space A] [has_continuous_mul A] : continuous_multilinear_map R (Î» (i : fin n), A) A
{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype (class_group R K)
(Î± : Type u) [group Î±] : Prop
{Î¹ : Type u} {X : Type v} [topological_space X] (i : Î¹) (s : set X) : bump_covering Î¹ X s
{Î± : Type u_2} [decidable_eq Î±] [add_monoid Î±] : add_monoid (finset Î±)
{m : Type u_2} {n : Type u_3} {Î± : Type v} [decidable_eq n] (M : matrix m n Î±) (j : n) (b : m â†’ Î±) : matrix m n Î±
{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (Î» (n : â„•), polynomial.cyclotomic n R)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_limit t) : category_theory.limits.binary_bicone X Y
{Î± : Type u} {Î² : Î± â†’ Type v} (a : Î±) (b : Î² a) : finmap Î²
 : sign_type â†’ sign_type â†’ Prop
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X : C} [category_theory.simple X] : division_ring (category_theory.End X)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : canonically_ordered_add_monoid (lie_subalgebra R L)
{Î± : Type u} : complete_lattice (topological_space Î±)
 : subsingleton (fin 0)
(J : Type v) (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(Î± : Type u) {Î² : Type v} [add_group Î±] [add_action Î± Î²] (b : Î²) : add_subgroup Î±
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [nontrivial Î±] [unique_factorization_monoid Î±] : normalization_monoid Î±
(Î² : Type u_2) [pseudo_metric_space Î²] [monoid Î²] [has_lipschitz_mul Î²] : nnreal
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : âˆ….up_shadow = âˆ…
{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) : is_compact (s âˆ© t)
(p : â„•) : decidable (nat.prime p)
(Î± : Type u_7) (Î² : Type u_8) [lattice Î±] [lattice Î²] [bounded_order Î±] [bounded_order Î²] : Type (max u_7 u_8)
{p : â„•} : padic_val_int p 0 = 0
(Î± : Sort u) [hâ‚ : inhabited Î±] [subsingleton Î±] : unique Î±
(Î± : Type u) : Type u
(p : â„•) [hp : fact (nat.prime p)] (n : â„•) : â„• â†’ mv_polynomial (fin 1 Ã— â„•) â„¤
{M : Type u_1} [add_zero_class M] {c : add_con M} : â†‘0 = 0
(G : Type u) : Type u
(n : â„•) : mv_polynomial â„• â„¤
{F : Type u} [decidable_eq F] [field F] (s : finset F) (x : F) : polynomial F
{Î± : Type u_1} (r : â„•) (A : set (finset Î±)) : Prop
{M : Type u_1} [add_comm_monoid M] (x : M) (N' : Type u_2) [add_comm_monoid N'] : Type (max u_1 u_2)
{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd c = 1) : a âˆ£ b
{Î± : Type u} [pseudo_metric_space Î±] (a : Î±) : has_nndist.nndist a a = 0
 : Type
(Î± : Type u_1) [monoid Î±] : setoid Î±
 : nat.arithmetic_function â„•
(G : Type u_1) [add_comm_group G] [topological_space G] [topological_add_group G] : uniform_space G
 : Type u
 : Type
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) [has_lt Î²] (h : well_founded has_lt.lt) [nonempty Î±] : Î±
{Î± : Type u_1} [U : uniform_space Î±] (m : pseudo_emetric_space Î±) (H : uniformity Î± = uniformity Î±) : pseudo_emetric_space Î±
{M : Type u_1} [has_mul M] (r : M â†’ M â†’ Prop) : M â†’ M â†’ Prop
{F : pfunctor} [inhabited F.M] [decidable_eq F.A] (i : F.Idx) (x : F.M) : F.M
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] (h : 0 = 1) (a : Mâ‚€) : a = 0
 : Type
 : set algebraic_geometry.Scheme
{M : Type u_1} [semigroup M] : semigroup (ultrafilter M)
{M : Type u_1} [comm_monoid M] (x : M) : Type u_1
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype Î¹] (b : basis Î¹ R M) [fintype R] : fintype M
{Î± : Type u_1} [preorder Î±] [order_bot Î±] [locally_finite_order Î±] (b : Î±) : multiset Î±
(Î± : Type u_6) (Î² : Type u_7) [has_mul Î±] [has_add Î±] [has_le Î±] [has_mul Î²] [has_add Î²] [has_le Î²] : Type (max u_6 u_7)
(Î± : Type u) : Type u
{R : Type u} [ring R] (self : subring R) : subsemiring R
 : has_le pgame
{Î± : Type u} [topological_space Î±] (K : compact_exhaustion Î±) : compact_exhaustion Î±
(C : Type u) [category_theory.category C] (X : Top) : Type (max v u)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : â„•) : lie_ideal R L
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î² â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.snd)
{Î± : Type u} [decidable_eq Î±] [canonically_ordered_comm_semiring Î±] [nontrivial Î±] : comm_semiring (with_top Î±)
 : category_theory.faithful Compactum_to_CompHaus
{Î± : Type u} [group Î±] : complete_semilattice_Inf (group_topology Î±)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] [totally_disconnected_space Î²] {f : Î± â†’ Î²} (h : continuous f) : connected_components Î± â†’ Î²
{a b c : Prop} : a âˆ§ b âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)
(A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A (A Ã— A)
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (f : M â†’ N) : con N
{Râ‚ƒ : Type u_7} [comm_ring Râ‚ƒ] {n : Type u_11} [fintype n] (J A : matrix n n Râ‚ƒ) : Prop
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : b â‰¤ aâ»Â¹ * c â†’ a * b â‰¤ c
{Î± : Type} (p : parser Î±) : Prop
{M : Type u_1} [monoid M] {x : M} : x âˆˆ powers x
 : Type (u+1)
{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1
{Î± : Type u_1} {Î² : Type u_2} [denumerable Î±] [denumerable Î²] : denumerable (Î± âŠ• Î²)
{Î± : Sort u} (p : Î± â†’ Prop) : Prop
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
{Î± : Type u_1} (a : Î±) (s : finset Î±) (h : a âˆ‰ s) : finset Î±
{a b : ereal} : -a â‰¤ b â†” -b â‰¤ a
{Î± : Type u_2} [has_mul Î±] [fintype Î±] [decidable_eq Î±] : decidable_pred is_square
{K : Type u_2} [division_ring K] : seq (generalized_continued_fraction.pair K) â†’ â„• â†’ K
(ð•œ : Type u_1) (E : Type u_2) [ordered_semiring ð•œ] [add_comm_monoid E] [module ð•œ E] [topological_space E] : Prop
{M : Type u_1} [has_one M] [has_mul M] [has_inv M] : â„¤ â†’ M â†’ M
{Î± : Type u_2} [topological_space Î±] [add_monoid Î±] [has_continuous_add Î±] : has_continuous_add (add_units Î±)
(A : Type u_9) (B : Type u_10) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : Type (max u_10 u_9)
{C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)
{Î± : Type u} (x : Î±) : dlist Î±
{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + â†‘u) â†” is_add_unit a
{Î± : Type u_1} [preorder Î±] (a : Î±) : upper_set Î±
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [topological_space Î²] [preorder Î¹] (f : measure_theory.filtration Î¹ m) (u : Î¹ â†’ Î± â†’ Î²) : Prop
 : Type
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_zero_morphisms C
(C : Type u) [category_theory.category C] : Type (max u u_1)
 : â„• â†’ num
(R : Type u_1) [comm_ring R] : Prop
(G : Type u) : Type u
(a : cardinal) : a < 2 ^ a
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_5} [normed_field ð•œ] [add_comm_group E] [module ð•œ E] (p : seminorm_family ð•œ E Î¹) [nonempty Î¹] : add_group_filter_basis E
{Î¹ : Type u_1} {Z : Î¹ â†’ Type u_2} [Î  (i : Î¹), ordered_add_comm_monoid (Z i)] : ordered_add_comm_monoid (Î  (i : Î¹), Z i)
{Î± : Type u_1} (s t : multiset Î±) : Prop
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), add_monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : is_of_fin_add_order x) (i : Î·) : is_of_fin_add_order (x i)
(G : Type w) [topological_space G] : Type w
(R : Type u) : Type u
(C : Type u) [category_theory.category C] : Prop
 : pos_num â†’ pos_num â†’ pos_num
{Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top
{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ a - b < c
(R : Type u) : Type u
(X : Type u_1) [topological_space X] [h : topological_space.pseudo_metrizable_space X] : pseudo_metric_space X
{p n : â„•} : padic_val_int p â†‘n = padic_val_nat p n
(Î± : Type u_1) : Type u_1
{H : Type u_1} [topological_space H] {H' : Type u_3} [topological_space H'] (G : structure_groupoid H) (G' : structure_groupoid H') (P : (H â†’ H') â†’ set H â†’ H â†’ Prop) : Prop
(R : Type u) [semiring R] : Prop
{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a
(C : Type (u+1)) : Type (u+1)
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G
(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)
{Î± : Type u} [comm_group Î±] : is_group_hom has_inv.inv
 : num â†’ num
{Î± : Type u} [uniform_space Î±] {s : set Î±} (h : totally_bounded s) : totally_bounded (closure s)
 : filter.tendsto (Î» (x : â„), x ^ ((-1) / x)) filter.at_top (nhds 1)
{ð•œ : Type u_3} [field ð•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ð•œ) : list (matrix (fin r âŠ• unit) (fin r âŠ• unit) ð•œ)
{Î± : Type u} [topological_space Î±] {f : filter Î±} : is_closed {x : Î± | cluster_pt x f}
{Î± : Type u} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : Â¬b < a
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J â†’ C) [category_theory.limits.has_biproduct F] : category_theory.limits.bicone F
(Î± : Type u) : Type u
{Î± : Type u_1} {Î² : Type u_2} [cancel_comm_monoid_with_zero Î±] [normalized_gcd_monoid Î±] (s : finset Î²) (f : Î² â†’ Î±) : Î±
{Î± : Type u_1} [encodable Î±] : â„• â†’ option (list Î±)
{Î± : Type u_2} [add_comm_semigroup Î±] : add_comm_semigroup (set Î±)
{Î± : Type u_3} [preorder Î±] : filter Î±
{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f âˆ˜ g) x
(Î± : Type u) [add_monoid Î±] : Type u
(p : â„•) [fact (nat.prime p)] (a : â„¤) : â„¤
 : ordinal
{V : Type u} (G : simple_graph V) (n : â„•) : Prop
 : list bool â†’ â„•
 : nzsnum â†’ nzsnum
(R : Type u_1) [comm_ring R] : â„• â†’ polynomial R
{Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] (B : Î¹ â†’ submodule R A) : Prop
{M : Type u_1} [add_monoid M] {Î¹ : Sort u_2} {s : Î¹ â†’ set M} (h : âˆ€ (y : Î¹), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)
{Î± : Type u} [decidable_eq Î±] (lâ‚ lâ‚‚ : list Î±) : bool
(Î± : Sort u) (Î² : Sort v) : Sort (max 1 u v)
(C : Type u) [category_theory.category C] : Prop
(Î“ : Type u_1) (T : Type u_2) [topological_space T] [has_vadd Î“ T] : Prop
(f : pSet â†’ pSet) : pSet â†’ pSet
{Î¹ : Sort u_1} {Î¹' : Sort u_2} {Î± : Type u_3} [complete_lattice Î±] {s : Î¹ â†’ Î±} (hs : complete_lattice.independent s) (f : Î¹' â†’ Î¹) (hf : function.injective f) : complete_lattice.independent (s âˆ˜ f)
(Î± : Type u) [u : uniform_space Î±] : set (Î± Ã— Î±)
(ð•‚ : Type u_1) {ð”¸ : Type u_2} [field ð•‚] [ring ð”¸] [algebra ð•‚ ð”¸] [topological_space ð”¸] [topological_ring ð”¸] (x : ð”¸) : ð”¸
(C : Type uâ‚) : Type uâ‚
{P : â„¤ â†’ Prop} [decidable_pred P] (b : â„¤) (Hb : âˆ€ (z : â„¤), P z â†’ z â‰¤ b) (Hinh : âˆƒ (z : â„¤), P z) : {ub // P ub âˆ§ âˆ€ (z : â„¤), P z â†’ z â‰¤ ub}
(S : Type u_1) (R : out_param (Type u)) [non_assoc_semiring R] [set_like S R] : Type
 : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}
{Î¹ : Type u} (f : Î¹ â†’ ordinal â†’ ordinal) (o : ordinal) : ordinal
 : pos_num â†’ â„• â†’ num
(k : Type uâ‚) (G : Type uâ‚‚) [semiring k] : Type (max uâ‚‚ uâ‚)
{Î± : Type u_1} (q : trunc Î±) : semiquot Î±
 : znum â†’ pos_num
{Î± : Sort u_1} (a : erased (erased Î±)) : erased Î±
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
{Î± : Sort u_1} [is_empty Î±] (p : Î± â†’ Prop) : is_empty (subtype p)
{Î± : Type u} [topological_space Î±] {s : set Î±} : dense (closure s) â†” dense s
(Mâ‚€ : Type u_4) : Type u_4
{Î± : Type u_1} (l : list (lists Î±)) : lists Î±
{ð•œ : Type u_1} {V : Type u_2} [normed_field ð•œ] [add_comm_group V] [module ð•œ V] (e : enorm ð•œ V) : emetric_space V
(Î± : Type u) (lt : Î± â†’ Î± â†’ Prop) : Prop
{Î± : Type} [random Î±] : io Î±
{Î± : Type u_1} [decidable_eq Î±] (a : Î±) : list Î± â†’ â„•
{K : Type u} [division_ring K] : group_with_zero K
{R : Type u_1} [has_mul R] (c : R) : Prop
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : a < 0 â†’ 0 < -a
{Î± : Sort u} : Î± â†’ id Î±
(C : Type u) [category_theory.category C] : Prop
(p : â„•) [fact (nat.prime p)] {a : â„¤} (ha0 : â†‘a â‰  0) : zmod.legendre_sym p a = 1 â†” is_square â†‘a
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X â†’ Y} [sequential_space X] : continuous f â†” seq_continuous f
{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b â‰¤ c) : a â‰¤ c
(ð•œ : Type u_1) (E : Type u_2) [comm_semiring ð•œ] [topological_space ð•œ] [has_continuous_add ð•œ] [has_continuous_const_smul ð•œ ð•œ] [add_comm_monoid E] [module ð•œ E] [topological_space E] : Type (max u_2 u_1)
{R : Type u_1} [comm_ring R] : comm_ring (clifford_algebra 0)
{Î± : Type u_1} [measurable_space Î±] (m : measure_theory.measure (measure_theory.measure Î±)) : measure_theory.measure Î±
{Î± : Type u} (s : wseq Î±) : computation (option Î±)
{Î± : Type u_1} {Î² : Type u_2} (s : set (Î± â†’ Î²)) (t : set Î±) : set Î²
(F : Type u_2) (Î± : Type u_3) (Î² : Type u_4) [topological_space Î±] [pseudo_metric_space Î²] : Type (max u_2 u_3 u_4)
{Î± : Type u_1} : regular_expression Î± â†’ language Î±
{R : Type u} [non_assoc_semiring R] : complete_lattice (subsemiring R)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max v u)
{Î± : Type u_1} [measurable_space Î±] (f : filter Î±) : Prop
{Î± : Type u_1} [conditionally_complete_linear_order Î±] {a : Î±} : conditionally_complete_linear_order {x // a â‰¤ x}
{X : Type u_1} (to_prod : X Ã— X) : Bipointed
 : Type
{H : Type u} (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) : set (local_homeomorph M H)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : M
{F : Type u_1} (Î± : Type u_3) (Î² : Type u_4) [linear_order Î±] [lattice Î²] [order_hom_class F Î± Î²] : lattice_hom_class F Î± Î²
(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom E E
{G : Type u_1} (P : Type u_2) [add_group G] [add_torsor G P] (v : G) : equiv.perm P
{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„¤) : m â‰¤ n â†’ P n
(M : Type u) : Type u
{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] (f : Î± â†’ Î²) : Prop
{X : Type u} [lattice X] [jordan_holder_lattice X] (sâ‚ sâ‚‚ : composition_series X) (h : sâ‚.top = sâ‚‚.bot) : composition_series X
 : Type
{M : Type u_4} [add_zero_class M] (self : add_submonoid M) : add_subsemigroup M
{X : Type u_1} (Y : Type u_2) [topological_space X] [mul_zero_one_class Y] {U : set X} (hU : is_clopen U) : locally_constant X Y
(G : pgame) : Prop
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : Â¬is_smul_regular M 0 â†” nontrivial M
{n : â„•} (c : composition n) : finset (fin (n + 1))
(C : Type uâ‚) [category_theory.category C] (D : Type uâ‚) [category_theory.category D] : category_theory.category (C Ã— D)
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [topological_space Î±] [preorder Î±] [topological_space Î²] [preorder Î²] : Type (max u_6 u_7 u_8)
{Î± : Type u_1} (n : â„•) (s : multiset Î±) : multiset (multiset Î±)
{Î± : Type u} [topological_space Î±] : totally_disconnected_space Î± â†” âˆ€ (x : Î±), connected_component x = {x}
{Î± : Type u} : dlist Î± â†’ list Î±
{Î± : Type u_1} : ordnode Î± â†’ Î± â†’ ordnode Î± â†’ Î± â†’ ordnode Î± â†’ ordnode Î±
{H : Type u} [topological_space H] (PG : pregroupoid H) : structure_groupoid H
{X : Type u_1} [topological_space X] (s : set X) : Prop
 : Type
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : f 0 = 0
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : seq1 Î± â†’ seq1 Î²
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X â†’ Y) : Prop
{Î± : Type u_1} [has_zero Î±] [linear_order Î±] (a : Î±) : {x // 0 â‰¤ x}
{Î± : Type u_1} (a : Î±) [subsingleton Î±] : fintype Î±
{Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} (h : s âŠ† t) : emetric.diam s â‰¤ emetric.diam t
(Î± : Type u_2) [complete_lattice Î±] : frame_hom Î± Î±
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚) : free_group.mk Lâ‚ = free_group.mk Lâ‚‚
{Î± : Type u} [preorder Î±] {f : â„• â†’ Î±} (hf : monotone f) (n : â„•) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„•) : f a â‰  x
{Î± : Type u_1} [decidable_eq Î±] (l : list Î±) (H : âˆ€ (x : Î±), x âˆˆ l) : fintype Î±
{M : Type u_1} [add_semigroup M] : add_semigroup (ultrafilter M)
 : Type
{ð•‚ : Type u_1} [is_R_or_C ð•‚] : has_strict_deriv_at (exp ð•‚) 1 0
{Î± : Type u_1} {Î² : Type u_2} [tÎ± : topological_space Î±] [tÎ² : topological_space Î²] (f : Î± â†’ Î²) : Prop
{V : Type u_1} (G : simple_graph V) (u v : V) : â„•
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : â†‘(finite_dimensional.finrank K V) = module.rank K V
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {r : setoid Î²} : setoid.comap f r = setoid.ker (quotient.mk âˆ˜ f)
 : znum â†’ znum â†’ znum
(C : Type u) [category_theory.category C] [category_theory.essentially_small C] : Type w
(ds : list â„•) : Type
{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_nndist x s)
{Î± : Type u} (c : omega_complete_partial_order.chain (part Î±)) : part Î±
{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
{M : Type u} [has_zero M] [has_add M] : â„• â†’ M â†’ M
(A : out_param (Type u)) {B : Type v} [has_quotient A B] (b : B) : Type (max u v)
{A : Type u_1} [add_monoid A] : has_faithful_smul (add_aut A) A
{m : Type u â†’ Type u} [applicative m] {Î± Î² : Type u} (F : Î± â†’ m Î²) : free_add_magma Î± â†’ m (free_add_magma Î²)
(Î± : Type u) : Type u
{Î± : Type u_1} {Î² : Type u_2} (r : rel Î± Î²) : set Î±
{Î± : Sort u} {Î² : Î± â†’ Sort v} (fâ‚ fâ‚‚ : Î  (x : Î±), Î² x) : Prop
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_antisymm Î± r] {a b : Î±} : r a b â†’ r b a â†’ a = b
{Î± : Type u_1} (s : multiset Î±) : multiset {x // x âˆˆ s}
 : â„•
(a o : ordinal) (f : Î  (b : ordinal), b < o â†’ ordinal) : Prop
{Î± : Type u_1} [decidable_eq Î±] [lattice Î±] [bounded_order Î±] [is_simple_order Î±] : boolean_algebra Î±
(R : Type u) [comm_semiring R] [local_ring R] : ideal R
(m m' : Type u â†’ Type v) (n n' : Type u â†’ Type w) : Type (max (u+1) v w)
(p : â„•) [fact (nat.prime p)] (a : â„¤) : zmod.legendre_sym p a = zmod.legendre_sym p (a % â†‘p)
{Î± : Type u_1} : list (list Î±) â†’ list (list Î±)
 : â„¤ â†’ â„¤ â†’ â„¤
{Î± : Type u} {Î² : Î± â†’ Sort v} (s : set Î±) (f g : Î  (i : Î±), Î² i) [Î  (j : Î±), decidable (j âˆˆ s)] (i : Î±) : Î² i
(K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1
(Î± : Sort u) : Sort (max u 1)
{G :{G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (Î» (h : G), h - g)
 : Type
{Î± : Type u} {m : Type u â†’ Type v} [monad m] [alternative m] (tac : Î± â†’ m punit) : list Î± â†’ m Î±
{Î± : Type u} [uniform_space Î±] (a : Î±) : Cauchy Î±
(G : Type u) : Type u
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) (t : ordnode Î±) : option â„•
(Î± : Type u_2) : Type u_2
(R : Type u) (M : Type v) (Mâ‚‚ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module R Mâ‚‚] : submodule R (M Ã— Mâ‚‚)
(Î± : Type u_1) : Type u_1
(Î± : Type u_1) [finite Î±] : fintype Î±
(Î± : Type u_1) [topological_space Î±] : filter Î±
(M : Type u_1) (N : Type u_2) [add_monoid M] [add_monoid N] : Type (max u_2 u_1)
{Î± : Type u_1} : list (option Î±) â†’ list Î±
{X : Type u} [topological_space X] (xâ‚€ xâ‚ : X) : Type u
{R : Type u_4} [linear_ordered_ring R] (a : R) : 0 â‰¤ a ^ 2
{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 â‰¤ ifp_succ_n.b
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : set Î±) : Prop
{n : â„•} (F : typevec n â†’ Type u_2) [mvfunctor F] : Prop
{n : Type u_1} {R : Type uâ‚‚} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct n R
{Î± : Type u} {Î² : Type v} [h : can_lift Î± Î²] : can_lift (list Î±) (list Î²)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) : Type v
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] [fintype R] : fintype S
(X : Type u_3) [topological_space X] : Prop
(C : Type u) [category_theory.category C] : Prop
(Î“â‚€ : Type u_1) [linear_ordered_comm_group_with_zero Î“â‚€] : topological_space Î“â‚€
{n : â„•} (i j : Î£ (a : composition n), composition a.length) : i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.snd.blocks = j.snd.blocks
 : pgame â†’ pgame â†’ Prop
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
{Î± : Type u_1} [topological_space Î±] [polish_space Î±] : polish_space (â„• â†’ Î±)
(Î± : Type v) [small Î±] : Type w
{Î± : Type v} {m l r : â„•} (A : matrix (fin m) (fin (l + r)) Î±) : matrix (fin m) (fin r) Î±
 : pos_num â†’ pos_num â†’ pos_num
{Î± : Type u_1} (a : Î±) (n : â„•) : multiset Î±
{C : Sort u_1} : empty â†’ C
(Î± : Type u) : Type u
{Î³ : Type u_3} [topological_space Î³] [compact_space Î³] [t2_space Î³] : uniform_space Î³
{Î± : Type u_1} (Î² : Î± â†’ Type u_2) (a : Î±) (h : a âˆˆ âˆ…) : Î² a
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (b : Î² a) (s : finmap Î²) : finmap Î²
{Î± : Type u} [linear_order Î±] (a b : Î±) : set Î±
{Î± : Type u_1} (S : set (set Î±)) : set Î±
(M : Type u_1) (N : Type u_2) [semiring M] [semiring N] : Type (max u_1 u_2)
{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)
(Î± : Type u_1) : Type u_1
(G : pgame) : Prop
{Î± : Type u_1} (p : pmf Î±) : measure_theory.outer_measure Î±
{X : Type u_1} [topological_space X] (x y : X) : Prop
(G : Type u) [add_group G] : add_monoid G
(F : Type u_9) (Î± : Type u_10) (Î² : Type u_11) [add_monoid Î±] [add_monoid Î²] [topological_space Î±] [topological_space Î²] : Type (max u_10 u_11 u_9)
{Î± : Type u_1} [has_compl Î±] [has_sup Î±] [has_inf Î±] (a b : Î±) : Î±
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup N) : add_subsemigroup M
(G : Type u) [group G] : monoid G
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.ess_surj (category_theory.shift_functor C i)
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_sbtw.sbtw a b c â†” has_sbtw.sbtw c a b
(p : â„•) [fact (nat.prime p)] : field (zmod p)
{Î± : Type u} {Î² : Type v} [preorder Î²] (f : Î± â†’ Î²) (l : filter Î±) (a : Î±) : Prop
(R : Type u) (n : â„•) (A : Type u_1) [comm_semiring R] [semiring A] [algebra R A] [topological_space A] [has_continuous_mul A] : continuous_multilinear_map R (Î» (i : fin n), A) A
{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype (class_group R K)
(Î± : Type u) [group Î±] : Prop
{Î¹ : Type u} {X : Type v} [topological_space X] (i : Î¹) (s : set X) : bump_covering Î¹ X s
{Î± : Type u_2} [decidable_eq Î±] [add_monoid Î±] : add_monoid (finset Î±)
{m : Type u_2} {n : Type u_3} {Î± : Type v} [decidable_eq n] (M : matrix m n Î±) (j : n) (b : m â†’ Î±) : matrix m n Î±
{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (Î» (n : â„•), polynomial.cyclotomic n R)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_limit t) : category_theory.limits.binary_bicone X Y
{Î± : Type u} {Î² : Î± â†’ Type v} (a : Î±) (b : Î² a) : finmap Î²
 : sign_type â†’ sign_type â†’ Prop
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X : C} [category_theory.simple X] : division_ring (category_theory.End X)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : canonically_ordered_add_monoid (lie_subalgebra R L)
{Î± : Type u} : complete_lattice (topological_space Î±)
 : subsingleton (fin 0)
(J : Type v) (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(Î± : Type u) {Î² : Type v} [add_group Î±] [add_action Î± Î²] (b : Î²) : add_subgroup Î±
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [nontrivial Î±] [unique_factorization_monoid Î±] : normalization_monoid Î±
(Î² : Type u_2) [pseudo_metric_space Î²] [monoid Î²] [has_lipschitz_mul Î²] : nnreal
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : âˆ….up_shadow = âˆ…
{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) : is_compact (s âˆ© t)
(p : â„•) : decidable (nat.prime p)
(Î± : Type u_7) (Î² : Type u_8) [lattice Î±] [lattice Î²] [bounded_order Î±] [bounded_order Î²] : Type (max u_7 u_8)
{p : â„•} : padic_val_int p 0 = 0
(Î± : Sort u) [hâ‚ : inhabited Î±] [subsingleton Î±] : unique Î±
(Î± : Type u) : Type u
(p : â„•) [hp : fact (nat.prime p)] (n : â„•) : â„• â†’ mv_polynomial (fin 1 Ã— â„•) â„¤
{M : Type u_1} [add_zero_class M] {c : add_con M} : â†‘0 = 0
(G : Type u) : Type u
(n : â„•) : mv_polynomial â„• â„¤
{F : Type u} [decidable_eq F] [field F] (s : finset F) (x : F) : polynomial F
{Î± : Type u_1} (r : â„•) (A : set (finset Î±)) : Prop
{M : Type u_1} [add_comm_monoid M] (x : M) (N' : Type u_2) [add_comm_monoid N'] : Type (max u_1 u_2)
{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd c = 1) : a âˆ£ b
{Î± : Type u} [pseudo_metric_space Î±] (a : Î±) : has_nndist.nndist a a = 0
 : Type
(Î± : Type u_1) [monoid Î±] : setoid Î±
 : nat.arithmetic_function â„•
(G : Type u_1) [add_comm_group G] [topological_space G] [topological_add_group G] : uniform_space G
 : Type u
 : Type
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) [has_lt Î²] (h : well_founded has_lt.lt) [nonempty Î±] : Î±
{Î± : Type u_1} [U : uniform_space Î±] (m : pseudo_emetric_space Î±) (H : uniformity Î± = uniformity Î±) : pseudo_emetric_space Î±
{M : Type u_1} [has_mul M] (r : M â†’ M â†’ Prop) : M â†’ M â†’ Prop
{F : pfunctor} [inhabited F.M] [decidable_eq F.A] (i : F.Idx) (x : F.M) : F.M
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] (h : 0 = 1) (a : Mâ‚€) : a = 0
 : Type
 : set algebraic_geometry.Scheme
{M : Type u_1} [semigroup M] : semigroup (ultrafilter M)
{M : Type u_1} [comm_monoid M] (x : M) : Type u_1
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype Î¹] (b : basis Î¹ R M) [fintype R] : fintype M
{Î± : Type u_1} [preorder Î±] [order_bot Î±] [locally_finite_order Î±] (b : Î±) : multiset Î±
(Î± : Type u_6) (Î² : Type u_7) [has_mul Î±] [has_add Î±] [has_le Î±] [has_mul Î²] [has_add Î²] [has_le Î²] : Type (max u_6 u_7)
(Î± : Type u) : Type u
{R : Type u} [ring R] (self : subring R) : subsemiring R
 : has_le pgame
{Î± : Type u} [topological_space Î±] (K : compact_exhaustion Î±) : compact_exhaustion Î±
(C : Type u) [category_theory.category C] (X : Top) : Type (max v u)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : â„•) : lie_ideal R L
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î² â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.snd)
{Î± : Type u} [decidable_eq Î±] [canonically_ordered_comm_semiring Î±] [nontrivial Î±] : comm_semiring (with_top Î±)
 : category_theory.faithful Compactum_to_CompHaus
{Î± : Type u} [group Î±] : complete_semilattice_Inf (group_topology Î±)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] [totally_disconnected_space Î²] {f : Î± â†’ Î²} (h : continuous f) : connected_components Î± â†’ Î²
{a b c : Prop} : a âˆ§ b âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)
(A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A (A Ã— A)
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (f : M â†’ N) : con N
{Râ‚ƒ : Type u_7} [comm_ring Râ‚ƒ] {n : Type u_11} [fintype n] (J A : matrix n n Râ‚ƒ) : Prop
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : b â‰¤ aâ»Â¹ * c â†’ a * b â‰¤ c
{Î± : Type} (p : parser Î±) : Prop
{M : Type u_1} [monoid M] {x : M} : x âˆˆ powers x
 : Type (u+1)
{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1
{Î± : Type u_1} {Î² : Type u_2} [denumerable Î±] [denumerable Î²] : denumerable (Î± âŠ• Î²)
{Î± : Sort u} (p : Î± â†’ Prop) : Prop
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
{Î± : Type u_1} (a : Î±) (s : finset Î±) (h : a âˆ‰ s) : finset Î±
{a b : ereal} : -a â‰¤ b â†” -b â‰¤ a
{Î± : Type u_2} [has_mul Î±] [fintype Î±] [decidable_eq Î±] : decidable_pred is_square
{K : Type u_2} [division_ring K] : seq (generalized_continued_fraction.pair K) â†’ â„• â†’ K
(ð•œ : Type u_1) (E : Type u_2) [ordered_semiring ð•œ] [add_comm_monoid E] [module ð•œ E] [topological_space E] : Prop
{M : Type u_1} [has_one M] [has_mul M] [has_inv M] : â„¤ â†’ M â†’ M
{Î± : Type u_2} [topological_space Î±] [add_monoid Î±] [has_continuous_add Î±] : has_continuous_add (add_units Î±)
(A : Type u_9) (B : Type u_10) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : Type (max u_10 u_9)
{C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)
{Î± : Type u} (x : Î±) : dlist Î±
{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + â†‘u) â†” is_add_unit a
{Î± : Type u_1} [preorder Î±] (a : Î±) : upper_set Î±
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [topological_space Î²] [preorder Î¹] (f : measure_theory.filtration Î¹ m) (u : Î¹ â†’ Î± â†’ Î²) : Prop
 : Type
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_zero_morphisms C
(C : Type u) [category_theory.category C] : Type (max u u_1)
 : â„• â†’ num
(R : Type u_1) [comm_ring R] : Prop
(G : Type u) : Type u
(a : cardinal) : a < 2 ^ a
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_5} [normed_field ð•œ] [add_comm_group E] [module ð•œ E] (p : seminorm_family ð•œ E Î¹) [nonempty Î¹] : add_group_filter_basis E
{Î¹ : Type u_1} {Z : Î¹ â†’ Type u_2} [Î  (i : Î¹), ordered_add_comm_monoid (Z i)] : ordered_add_comm_monoid (Î  (i : Î¹), Z i)
{Î± : Type u_1} (s t : multiset Î±) : Prop
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), add_monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : is_of_fin_add_order x) (i : Î·) : is_of_fin_add_order (x i)
(G : Type w) [topological_space G] : Type w
(R : Type u) : Type u
(C : Type u) [category_theory.category C] : Prop
 : pos_num â†’ pos_num â†’ pos_num
{Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top
{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ a - b < c
(R : Type u) : Type u
(X : Type u_1) [topological_space X] [h : topological_space.pseudo_metrizable_space X] : pseudo_metric_space X
{p n : â„•} : padic_val_int p â†‘n = padic_val_nat p n
(Î± : Type u_1) : Type u_1
{H : Type u_1} [topological_space H] {H' : Type u_3} [topological_space H'] (G : structure_groupoid H) (G' : structure_groupoid H') (P : (H â†’ H') â†’ set H â†’ H â†’ Prop) : Prop
(R : Type u) [semiring R] : Prop
{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a
(C : Type (u+1)) : Type (u+1)
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G
(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)
{Î± : Type u} [comm_group Î±] : is_group_hom has_inv.inv
 : num â†’ num
{Î± : Type u} [uniform_space Î±] {s : set Î±} (h : totally_bounded s) : totally_bounded (closure s)
 : filter.tendsto (Î» (x : â„), x ^ ((-1) / x)) filter.at_top (nhds 1)
{ð•œ : Type u_3} [field ð•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ð•œ) : list (matrix (fin r âŠ• unit) (fin r âŠ• unit) ð•œ)
{Î± : Type u} [topological_space Î±] {f : filter Î±} : is_closed {x : Î± | cluster_pt x f}
{Î± : Type u} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : Â¬b < a
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J â†’ C) [category_theory.limits.has_biproduct F] : category_theory.limits.bicone F
(Î± : Type u) : Type u
{Î± : Type u_1} {Î² : Type u_2} [cancel_comm_monoid_with_zero Î±] [normalized_gcd_monoid Î±] (s : finset Î²) (f : Î² â†’ Î±) : Î±
{Î± : Type u_1} [encodable Î±] : â„• â†’ option (list Î±)
{Î± : Type u_2} [add_comm_semigroup Î±] : add_comm_semigroup (set Î±)
{Î± : Type u_3} [preorder Î±] : filter Î±
{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f âˆ˜ g) x
(Î± : Type u) [add_monoid Î±] : Type u
(p : â„•) [fact (nat.prime p)] (a : â„¤) : â„¤
 : ordinal
{V : Type u} (G : simple_graph V) (n : â„•) : Prop
 : list bool â†’ â„•
 : nzsnum â†’ nzsnum
(R : Type u_1) [comm_ring R] : â„• â†’ polynomial R
{Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] (B : Î¹ â†’ submodule R A) : Prop
{M : Type u_1} [add_monoid M] {Î¹ : Sort u_2} {s : Î¹ â†’ set M} (h : âˆ€ (y : Î¹), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)
{Î± : Type u} [decidable_eq Î±] (lâ‚ lâ‚‚ : list Î±) : bool
(Î± : Sort u) (Î² : Sort v) : Sort (max 1 u v)
(C : Type u) [category_theory.category C] : Prop
(Î“ : Type u_1) (T : Type u_2) [topological_space T] [has_vadd Î“ T] : Prop
(f : pSet â†’ pSet) : pSet â†’ pSet
{Î¹ : Sort u_1} {Î¹' : Sort u_2} {Î± : Type u_3} [complete_lattice Î±] {s : Î¹ â†’ Î±} (hs : complete_lattice.independent s) (f : Î¹' â†’ Î¹) (hf : function.injective f) : complete_lattice.independent (s âˆ˜ f)
(Î± : Type u) [u : uniform_space Î±] : set (Î± Ã— Î±)
(ð•‚ : Type u_1) {ð”¸ : Type u_2} [field ð•‚] [ring ð”¸] [algebra ð•‚ ð”¸] [topological_space ð”¸] [topological_ring ð”¸] (x : ð”¸) : ð”¸
(C : Type uâ‚) : Type uâ‚
{P : â„¤ â†’ Prop} [decidable_pred P] (b : â„¤) (Hb : âˆ€ (z : â„¤), P z â†’ z â‰¤ b) (Hinh : âˆƒ (z : â„¤), P z) : {ub // P ub âˆ§ âˆ€ (z : â„¤), P z â†’ z â‰¤ ub}
(S : Type u_1) (R : out_param (Type u)) [non_assoc_semiring R] [set_like S R] : Type
 : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}
{Î¹ : Type u} (f : Î¹ â†’ ordinal â†’ ordinal) (o : ordinal) : ordinal
 : pos_num â†’ â„• â†’ num
(k : Type uâ‚) (G : Type uâ‚‚) [semiring k] : Type (max uâ‚‚ uâ‚)
{Î± : Type u_1} (q : trunc Î±) : semiquot Î±
 : znum â†’ pos_num
{Î± : Sort u_1} (a : erased (erased Î±)) : erased Î±
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
{Î± : Sort u_1} [is_empty Î±] (p : Î± â†’ Prop) : is_empty (subtype p)
{Î± : Type u} [topological_space Î±] {s : set Î±} : dense (closure s) â†” dense s
(Mâ‚€ : Type u_4) : Type u_4
{Î± : Type u_1} (l : list (lists Î±)) : lists Î±
{ð•œ : Type u_1} {V : Type u_2} [normed_field ð•œ] [add_comm_group V] [module ð•œ V] (e : enorm ð•œ V) : emetric_space V
(Î± : Type u) (lt : Î± â†’ Î± â†’ Prop) : Prop
{Î± : Type} [random Î±] : io Î±
{Î± : Type u_1} [decidable_eq Î±] (a : Î±) : list Î± â†’ â„•
{K : Type u} [division_ring K] : group_with_zero K
{R : Type u_1} [has_mul R] (c : R) : Prop
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : a < 0 â†’ 0 < -a
{Î± : Sort u} : Î± â†’ id Î±
(C : Type u) [category_theory.category C] : Prop
(p : â„•) [fact (nat.prime p)] {a : â„¤} (ha0 : â†‘a â‰  0) : zmod.legendre_sym p a = 1 â†” is_square â†‘a
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X â†’ Y} [sequential_space X] : continuous f â†” seq_continuous f
{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b â‰¤ c) : a â‰¤ c
(ð•œ : Type u_1) (E : Type u_2) [comm_semiring ð•œ] [topological_space ð•œ] [has_continuous_add ð•œ] [has_continuous_const_smul ð•œ ð•œ] [add_comm_monoid E] [module ð•œ E] [topological_space E] : Type (max u_2 u_1)
{R : Type u_1} [comm_ring R] : comm_ring (clifford_algebra 0)
{Î± : Type u_1} [measurable_space Î±] (m : measure_theory.measure (measure_theory.measure Î±)) : measure_theory.measure Î±
{Î± : Type u} (s : wseq Î±) : computation (option Î±)
{Î± : Type u_1} {Î² : Type u_2} (s : set (Î± â†’ Î²)) (t : set Î±) : set Î²
(F : Type u_2) (Î± : Type u_3) (Î² : Type u_4) [topological_space Î±] [pseudo_metric_space Î²] : Type (max u_2 u_3 u_4)
{Î± : Type u_1} : regular_expression Î± â†’ language Î±
{R : Type u} [non_assoc_semiring R] : complete_lattice (subsemiring R)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max v u)
{Î± : Type u_1} [measurable_space Î±] (f : filter Î±) : Prop
{Î± : Type u_1} [conditionally_complete_linear_order Î±] {a : Î±} : conditionally_complete_linear_order {x // a â‰¤ x}
{X : Type u_1} (to_prod : X Ã— X) : Bipointed
 : Type
{H : Type u} (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) : set (local_homeomorph M H)
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : M
{F : Type u_1} (Î± : Type u_3) (Î² : Type u_4) [linear_order Î±] [lattice Î²] [order_hom_class F Î± Î²] : lattice_hom_class F Î± Î²
(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom E E
{G : Type u_1} (P : Type u_2) [add_group G] [add_torsor G P] (v : G) : equiv.perm P
{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„¤) : m â‰¤ n â†’ P n
(M : Type u) : Type u
{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] (f : Î± â†’ Î²) : Prop
{X : Type u} [lattice X] [jordan_holder_lattice X] (sâ‚ sâ‚‚ : composition_series X) (h : sâ‚.top = sâ‚‚.bot) : composition_series X
 : Type
{M : Type u_4} [add_zero_class M] (self : add_submonoid M) : add_subsemigroup M
{X : Type u_1} (Y : Type u_2) [topological_space X] [mul_zero_one_class Y] {U : set X} (hU : is_clopen U) : locally_constant X Y
(G : pgame) : Prop
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : Â¬is_smul_regular M 0 â†” nontrivial M
{n : â„•} (c : composition n) : finset (fin (n + 1))
(C : Type uâ‚) [category_theory.category C] (D : Type uâ‚) [category_theory.category D] : category_theory.category (C Ã— D)
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [topological_space Î±] [preorder Î±] [topological_space Î²] [preorder Î²] : Type (max u_6 u_7 u_8)
{Î± : Type u_1} (n : â„•) (s : multiset Î±) : multiset (multiset Î±)
{Î± : Type u} [topological_space Î±] : totally_disconnected_space Î± â†” âˆ€ (x : Î±), connected_component x = {x}
{Î± : Type u} : dlist Î± â†’ list Î±
{Î± : Type u_1} : ordnode Î± â†’ Î± â†’ ordnode Î± â†’ Î± â†’ ordnode Î± â†’ ordnode Î±
{H : Type u} [topological_space H] (PG : pregroupoid H) : structure_groupoid H
{X : Type u_1} [topological_space X] (s : set X) : Prop
 : Type
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : f 0 = 0
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : seq1 Î± â†’ seq1 Î²
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X â†’ Y) : Prop
{Î± : Type u_1} [has_zero Î±] [linear_order Î±] (a : Î±) : {x // 0 â‰¤ x}
{Î± : Type u_1} (a : Î±) [subsingleton Î±] : fintype Î±
{Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} (h : s âŠ† t) : emetric.diam s â‰¤ emetric.diam t
(Î± : Type u_2) [complete_lattice Î±] : frame_hom Î± Î±
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚) : free_group.mk Lâ‚ = free_group.mk Lâ‚‚
{Î± : Type u} [preorder Î±] {f : â„• â†’ Î±} (hf : monotone f) (n : â„•) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„•) : f a â‰  x
{Î± : Type u_1} [decidable_eq Î±] (l : list Î±) (H : âˆ€ (x : Î±), x âˆˆ l) : fintype Î±
{M : Type u_1} [add_semigroup M] : add_semigroup (ultrafilter M)
 : Type
{ð•‚ : Type u_1} [is_R_or_C ð•‚] : has_strict_deriv_at (exp ð•‚) 1 0
{Î± : Type u_1} {Î² : Type u_2} [tÎ± : topological_space Î±] [tÎ² : topological_space Î²] (f : Î± â†’ Î²) : Prop
{V : Type u_1} (G : simple_graph V) (u v : V) : â„•
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : â†‘(finite_dimensional.finrank K V) = module.rank K V
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {r : setoid Î²} : setoid.comap f r = setoid.ker (quotient.mk âˆ˜ f)
 : znum â†’ znum â†’ znum
(C : Type u) [category_theory.category C] [category_theory.essentially_small C] : Type w
(ds : list â„•) : Type
{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_nndist x s)
{Î± : Type u} (c : omega_complete_partial_order.chain (part Î±)) : part Î±
{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
{M : Type u} [has_zero M] [has_add M] : â„• â†’ M â†’ M
(A : out_param (Type u)) {B : Type v} [has_quotient A B] (b : B) : Type (max u v)
{A : Type u_1} [add_monoid A] : has_faithful_smul (add_aut A) A
{m : Type u â†’ Type u} [applicative m] {Î± Î² : Type u} (F : Î± â†’ m Î²) : free_add_magma Î± â†’ m (free_add_magma Î²)
(Î± : Type u) : Type u
{Î± : Type u_1} {Î² : Type u_2} (r : rel Î± Î²) : set Î±
{Î± : Sort u} {Î² : Î± â†’ Sort v} (fâ‚ fâ‚‚ : Î  (x : Î±), Î² x) : Prop
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_antisymm Î± r] {a b : Î±} : r a b â†’ r b a â†’ a = b
{Î± : Type u_1} (s : multiset Î±) : multiset {x // x âˆˆ s}
 : â„•
(a o : ordinal) (f : Î  (b : ordinal), b < o â†’ ordinal) : Prop
{Î± : Type u_1} [decidable_eq Î±] [lattice Î±] [bounded_order Î±] [is_simple_order Î±] : boolean_algebra Î±
(R : Type u) [comm_semiring R] [local_ring R] : ideal R
(m m' : Type u â†’ Type v) (n n' : Type u â†’ Type w) : Type (max (u+1) v w)
(p : â„•) [fact (nat.prime p)] (a : â„¤) : zmod.legendre_sym p a = zmod.legendre_sym p (a % â†‘p)
{Î± : Type u_1} : list (list Î±) â†’ list (list Î±)
 : â„¤ â†’ â„¤ â†’ â„¤
{Î± : Type u} {Î² : Î± â†’ Sort v} (s : set Î±) (f g : Î  (i : Î±), Î² i) [Î  (j : Î±), decidable (j âˆˆ s)] (i : Î±) : Î² i
(K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1
(Î± : Sort u) : Sort (max u 1)
{G :{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] [nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), c â‰¤ f x) : c â‰¤ infi f
{M : Type u_1} [monoid M] (x : M) : set M
(Î± : Type u) [topological_space Î±] : Prop
{M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] (s : add_submonoid M) : add_submonoid M
(K : Type u) [hring : comm_ring K] : Type u
{K : Type u} [field K] (s : subfield K) : submonoid K
(k G : Type u) [ring k] [monoid G] : Type (u+1)
(v : multiset â„•) (h : âˆ€ (p : â„•), p âˆˆ v â†’ nat.prime p) : prime_multiset
{Î± : Type u_1} : has_star.star 1 = 1
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule R M
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) : Prop
(Î± : Type u_2) [linear_ordered_ring Î±] : Type u_2
{M : Type u_1} [has_mul M] : has_top (subsemigroup M)
 : onote â†’ â„• â†’ onote
 : Set â†’ Set
(n p : â„•) (l : list â„•) : Prop
{n : â„•} (P : mvpfunctor (n + 1)) (Î± : typevec n) : Type u
(Î± : Type u_1) [partial_order Î±] : closure_operator Î±
(Î± : Type u_1) [has_le Î±] : has_btw Î±
 : filter.tendsto real.exp filter.at_top filter.at_top
{Î± : Type u_1} (l : list Î±) : list (multiset Î±)
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S : set E) : intermediate_field F E
{Î± : Type u} [monoid Î±] (a b : Î±) [invertible a] [invertible b] : invertible (a * b)
{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (s : Î² â†’ Î² â†’ Prop) (x y : Î±) : Prop
{Î± : Sort u_1} (x : fin 0) : Î±
(Î± : Type u_1) : Type u_1
(R : Type u) (S : Type v) [semiring R] [semiring S] (p : â„•) [char_p R p] [char_p S p] : char_p (R Ã— S) p
 : Type 1
{Î± : Type u_2} [add_semigroup Î±] : add_semigroup (set Î±)
{Î± : Type u_1} [topological_space Î±] [locally_compact_space Î±] [nonempty Î±] : nonempty (topological_space.positive_compacts Î±)
{Mâ‚€ : Type u_1} {Mâ‚€' : Type u_3} [mul_zero_one_class Mâ‚€] [nontrivial Mâ‚€] [has_zero Mâ‚€'] [has_one Mâ‚€'] (f : Mâ‚€' â†’ Mâ‚€) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial Mâ‚€'
{Î± : Type u_2} {Gâ‚€ : Type u_4} [topological_space Î±] [group_with_zero Gâ‚€] [mul_action Gâ‚€ Î±] [has_continuous_const_smul Gâ‚€ Î±] {c : Gâ‚€} (hc : c â‰  0) : is_closed_map (Î» (x : Î±), c â€¢ x)
 : Type
{C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X) : category_theory.limits.is_initial X
{Î± : Type u_2} [comm_monoid Î±] : multiset Î± â†’ Î±
{Î± : Type u} {Î² : Type v} (xs : list (Î± Ã— Î²)) : list (Î£ (_x : Î±), Î²)
{R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : â„•) (r : R) : â„¤
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Î  (i : Î¹), has_lt (Î± i)] (a b : Î£ (i : Î¹), Î± i) : Prop
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Type (max u_2 u_1)
(Î± : Type u_1) (Î² : Type u_2) (V : set (Î² Ã— Î²)) : set ((Î± â†’ Î²) Ã— (Î± â†’ Î²))
{Î³ : Type u_1} {Î² : Type u_2} (f : Î³ â†’ Î²) (hf : function.injective f) (m : emetric_space Î²) : emetric_space Î³
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c
{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : set.Ioi b âŠ† set.Ici a
{Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set Î±) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), 0)) = 0
(G : Type u) : Type u
{R : Type u} [euclidean_domain R] [decidable_eq R] : R â†’ R â†’ R â†’ R â†’ R â†’ R â†’ R Ã— R Ã— R
{Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [has_add Î²] (f : Î± â†’ Î²) : Prop
 : algebraic_geometry.Scheme
{Î± : Type u_1} [decidable_eq Î±] (s t : multiset Î±) : multiset Î±
{G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (Î» (i : â„•), x ^ i) (finset.range (order_of x)) = â†‘(subgroup.zpowers x).to_finset
{Î± : Type uu} : list Î± â†’ list Î± â†’ Prop
(Î± : Type u_1) [complete_lattice Î±] : complete_lattice.is_sup_closed_compact Î± â†’ complete_lattice.is_Sup_finite_compact Î±
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] : list Î± â†’ â„•
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : ray_vector R M
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red (free_group.reduce Lâ‚) Lâ‚‚) : free_group.reduce Lâ‚ = Lâ‚‚
{Î± : Type u_1} [has_lt Î±] (a b : Î±) : Prop
{n : â„•} {Î± : Type u} {Î² : Type v} {m : Type v â†’ Type u_1} [monad m] (a : array n Î±) (f : Î± â†’ m Î²) : m (array n Î²)
{G : Type u_10} [group G] (a : G) : equiv.perm G
{R : Type u} [comm_ring R] (r : R) : topological_space.opens (prime_spectrum R)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s âŠ† â†‘(affine_span k s)
{Î± : Type u_1} {Î¹ : Type u_5} {m0 : measurable_space Î±} (f : Î¹ â†’ measure_theory.measure Î±) : measure_theory.measure Î±
(Î“ : Type u_4) (T : Type u_5) [topological_space T] [has_vadd Î“ T] : Prop
{Î± : Type u_1} [semigroup Î±] [partial_order Î±] [contravariant_class Î± Î± (function.swap has_mul.mul) has_le.le] : right_cancel_semigroup Î±
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (b : category_theory.limits.binary_bicone P Q) : Type (max u v)
{k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G] : algebra R (add_monoid_algebra k G)
{Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} {s : set Î±} (h : y âˆˆ s) : emetric.inf_edist x s â‰¤ has_edist.edist x y
(C : Type uâ‚) [category_theory.category C] [category_theory.limits.has_terminal C] : C
(R : Type u) (M : Type v) [comm_ring R] [add_comm_group M] [module R M] : Prop
(Î± : Type u_1) : besicovitch.ball_package Î± Î±
{C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)
{Î± : Type u_1} (f g : equiv.perm Î±) : Prop
(R : Type u_1) [ring R] [is_domain R] [decidable_eq R] [fintype R] : division_ring R
{Î± : Type u_1} (l : filter Î±) (Î² : Type u_2) : Type (max u_1 u_2)
{M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) (N : Type u_2) [comm_monoid_with_zero N] : Type (max u_1 u_2)
{Î± : Type u} : list (Î± Ã— bool) â†’ list (Î± Ã— bool) â†’ Prop
{C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : Â¬category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)
(M : Type u_4) [add_zero_class M] : Type u_4
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (i : Î¹) : topological_fiber_bundle.trivialization F Z.proj
{Î± : Type u_1} {G : Type u_2} [group G] [monoid Î±] [mul_distrib_mul_action Î± G] : mul_action Î± (subgroup G)
{Î± : Type u_1} : ordnode Î± â†’ Prop
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : Type u_3
{Î± : Type u_1} [linear_ordered_ring Î±] [floor_ring Î±] : Î± â†’ â„¤
{Î± : Sort u_1} {Î² : Î± â†’ Sort u_2} (x : Î±) (f : Î  (x : Î±), Î² x) : Î² x
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] (s : wseq Î±) : computation (option Î±)
{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ z â‰¤ b) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (ub : â„¤), P ub âˆ§ âˆ€ (z : â„¤), P z â†’ z â‰¤ ub
(R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1
{Î± : Type u} (l : list Î±) : list {x // x âˆˆ l}
{K : Type u} [field K] (s : subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s
 : Type
{Î± : Type u} [hg : add_group Î±] [is_add_cyclic Î±] : add_comm_group Î±
{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹
{Î± : Type u_1} {s t : multiset Î±} : s â‰¤ t â†’ s âŠ† t
 : num â†’ pos_num
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C
{Î± : Type u} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {n : â„•} (hn : 1 â‰¤ n) : filter.tendsto (Î» (x : Î±), x ^ -â†‘n) filter.at_top (nhds 0)
(C : Type uâ‚) [category_theory.category C] : Prop
(C : Type u) [category_theory.category C] : Type (max u w v)
{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : Â¬is_left_regular 0
{Î± : Type u_1} (n : â„•) (l : list Î±) : list (list Î±)
{Î± : Type u} (tâ‚ tâ‚‚ : ordnode Î±) : Prop
{G : Type u_1} [group G] (H K : subgroup G) : Prop
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (f : Î± â†’ option Î±) (x : Î±) : ordnode Î± â†’ ordnode Î±
{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : urysohns.CU X
{C : Type u} [category_theory.category C] (X : C) : Type v
{C : Type uâ‚} [category_theory.category C] {X : C} (S R : category_theory.sieve X) : category_theory.sieve X
{Î± : Type u} : seq Î± â†’ lazy_list Î±
(Î± : Type u_1) : Type u_1
{G : Type u_1} [comm_group G] (K : subgroup G) (g : multiset G) : (âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.prod âˆˆ K
(C : Type u) [category_theory.category C] : Type (max u v)
{Î± : Type u} (g : set (set Î±)) : filter Î±
(K : Type u) [field K] (V : Type u) [add_comm_group V] [module K V] [finite_dimensional K V] : FinVect K
{Î± : Type u} {Î² : Type v} [semigroup Î²] (f : Î± â†’ Î²) (x : free_semigroup Î±) : Î²
(G : out_param (Type u_1)) (P : Type u_2) : Type (max u_1 u_2)
{Î± : Type u_1} {Î² : Type u_2} (e : local_equiv Î± Î²) (s : set Î±) (t : set Î²) : Prop
(p q n : â„•) [fact (nat.prime p)] (hq : q â‰  0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q
{Î± : Type u_1} : partial_order (subtype setoid.is_partition)
{Î± : Type u} [add_comm_monoid Î±] (a b : Î±) (hab : a + b = 0) : add_units Î±
{Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) (x : Î±) : Prop
 : Type
 : Type
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] [topological_space Î±] (F : Î¹ â†’ Î± â†’ Î²) (f : Î± â†’ Î²) (p : filter Î¹) (s : set Î±) : Prop
{Î± : Type u_1} : list Î± â†’ option Î±
(R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) : set R
(Î± : Type u_6) [topological_space Î±] [measurable_space Î±] : Prop
{Î± : Type u} {t : Type u â†’ Type u} [traversable t] : t Î± â†’ list Î±
(M : Type u) : Type u
{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : has_coe (fractional_ideal S P) (submodule R P)
(X : algebraic_geometry.Scheme) : Prop
(Î± : Type u_1) (Î² : Type u_2) [has_add Î²] : add_hom Î² (Î± â†’ Î²)
{Î± : Type u} [add_group Î±] : has_Inf (add_group_topology Î±)
{n : â„•} (P : mvpfunctor (n + 1)) : mvpfunctor n
{Î± : Type u_1} [comm_semiring Î±] (E : linear_recurrence Î±) (u : â„• â†’ Î±) : Prop
(k G : Type u) [field k] [monoid G] : Type (u+1)
(Î± : Type u) {Î² : Type v} [add_monoid Î±] [add_action Î± Î²] (b : Î²) : set Î²
(n : â„•) : ring_char (zmod n) = n
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] (f : M â†’ R) (x y : M) : R
(R : Type u_1) (M : Type u_2) [subsingleton R] [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (m : measurable_space Î±) : measurable_space Î²
(R : Type u_1) [comm_ring R] (p : â„•) [is_domain R] [char_p R p] : char_p (fraction_ring R) p
 : â„• â†’ â„• Ã— â„•
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (a : Î±) : Î± â†’ Prop
{P : pfunctor} (x : P.W) : P.B x.head â†’ P.W
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.split_epi category_theory.limits.prod.snd
{Î± : Type u_1} : ordnode Î± â†’ Î± â†’ ordnode Î± â†’ ordnode Î±
(Î¹ : Type u_1) : Type u_1
{M : Type u_1} [comm_monoid M] (S : submonoid M) : â„• â†’ localization S â†’ localization S
{K : Type u} [field K] (self : subfield K) : subring K
(Î¹ : Type u_1) (ð•œ : Type u_2) [is_R_or_C ð•œ] (E : Type u_3) [inner_product_space ð•œ E] : Type (max u_1 u_2 u_3)
{Î± : Type u_1} [add_semigroup Î±] [partial_order Î±] [contravariant_class Î± Î± has_add.add has_le.le] : add_left_cancel_semigroup Î±
{Î± : Type u_1} [preorder Î±] (a : Î±) : lower_set Î±
(M : Type u_1) [measurable_space M] [has_sup M] : Prop
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (f : option Î± â†’ option Î±) (x : Î±) : ordnode Î± â†’ ordnode Î±
{Î± : Sort u_1} {Î² : Sort u_2} (q : trunc Î±) (f : Î± â†’ trunc Î²) : trunc Î²
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] [finite_dimensional ð•œ E] {n : â„•} (hn : finite_dimensional.finrank ð•œ E = n) : basis (fin n) ð•œ E
{Î± : Type u} [uniform_space Î±] (s : set Î±) : Prop
(Î± : Type u) : Type u
(A : Type u_1) (R : Type u_2) (B : Type u_3) [comm_ring R] [comm_semiring A] [comm_ring B] [algebra R B] [algebra A B] : Prop
(n b : â„•) : (n + 1) / (b + 2) < n + 1
{Î± : Type u} {n : â„•} (h : Î±) (t : fin n â†’ Î±) : fin n.succ â†’ Î±
{P : Type u_1} [semilattice_sup P] [is_directed P ge] : has_inf (order.ideal P)
{Î± : Sort u_1} {C : trunc Î± â†’ Sort u_3} [âˆ€ (a : Î±), subsingleton (C (trunc.mk a))] (q : trunc Î±) (f : Î  (a : Î±), C (trunc.mk a)) : C q
{Î± : Type u_1} {Î² : Type u_2} [emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} (h : antilipschitz_with 0 f) : subsingleton Î±
{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) â†” is_right_regular b
{Î± : Type u} [group Î±] : partial_order (group_topology Î±)
(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_binary_coproducts C] : category_theory.monoidal_category C
{Î± : Type u_1} [decidable_eq Î±] : multiset Î± â†’ finset (list Î±)
{M : Type u_1} [has_mul M] (S : subsemigroup M) (s : set M) (hs : s = â†‘S) : subsemigroup M
(C : Type u) [category_theory.category C] : Prop
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom A (A Ã— B)
(Î± : Type u_1) [topological_space Î±] [preorder Î±] : Prop
{R : Type u} {M : Type v} [has_zero M] (r : R) : triv_sq_zero_ext R M
{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R) : R
{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a : Î±} : Â¬is_min a â†’ order.pred a < a
{R : Type u} [non_assoc_semiring R] (self : subsemiring R) : submonoid R
(L : first_order.language) : Prop
{Î± : Type u_2} {Î² : Type u_3} [decidable_eq Î²] [has_vadd Î± Î²] : has_vadd (finset Î±) (finset Î²)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (s : set L) : lie_subalgebra R L
(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop
{Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s : set Î±} (h : x âˆˆ s) : emetric.inf_edist x s = 0
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 â†” subsingleton M
(x y : pgame) : Prop
{Î± : Type u_2} [decidable_eq Î±] [subtraction_comm_monoid Î±] : subtraction_comm_monoid (finset Î±)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) : Prop
(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] : Sort u_3
 : matrix (fin 7) (fin 7) â„¤
{G : Type u} {x : G} [monoid G] : 0 < order_of x â†” is_of_fin_order x
(Î± : Type u_1) (Î² : Type u_2) [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] : Type (max u_1 u_2)
(p : â„•) [fact (nat.prime p)] (a : â„¤) (ha : â†‘a â‰  0) : zmod.legendre_sym p a ^ 2 = 1
(ð•œ : Type u_1) (E : Type u_2) (Î¹ : Type u_5) [normed_field ð•œ] [add_comm_group E] [module ð•œ E] : Type (max u_5 u_2)
{C : Type u} [category_theory.category C] (X Y : algebraic_geometry.PresheafedSpace C) : Type v
(Î³ : Type) : Type
{R : Type u_1} [comm_ring R] [is_domain R] (P : cubic R) : multiset R
{Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a â‰¤ b â†’ a < c
{R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R
{Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), monoid (M i)] (w : free_product.word M) : option Î¹
{R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) â†” group.fg G
(Î± : Type u_2) [cancel_comm_monoid_with_zero Î±] : Type u_2
{n : â„•} (Î± Î² : typevec n) : typevec n
{Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ set Î±} (hs : indexed_partition s) : Type u_2
{Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} (h : a â‰¤ b) : a - b = 0
(G : Type u_1) [group G] : galois_insertion subgroup.closure coe
(Î± : Sort u_4) : Prop
{Î± : Type u} {Î² : Type v} [add_semigroup Î²] (f : Î± â†’ Î²) (x : free_add_semigroup Î±) : Î²
(Î± : Type u_1) (Î² : Type u_2) : Type u_1
{H : Type u} [topological_space H] (G : structure_groupoid H) (M : Type u_5) (M' : Type u_6) [topological_space M] [topological_space M'] [charted_space H M] [charted_space H M'] : Type (max u_5 u_6)
 : Type v
(cache_ty : Type) : Type
(A : Type u_2) [comm_ring A] [is_domain A] : Prop
{Î± : Type u} : wseq Î± â†’ wseq Î± â†’ wseq Î±
(Î± : Type u_4) : Prop
{n : â„•} {Î± : Type u_1} (v : vector Î± n) (i : fin n) (a : Î±) : vector Î± n
{a : â„•} (a1 : 1 < a) (n : â„•) : â„¤
(p : â„• â†’ Prop) : â„• â†’ â„•
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : C
(G : Type u_1) [monoid G] : Â¬monoid.is_torsion G â†” âˆƒ (g : G), Â¬is_of_fin_order g
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : lazy_list Î± â†’ lazy_list Î²
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C
{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰  a â†’ a < b
(p : Prop) : Type
(Î± : Type u_2) [ordered_semiring Î±] : Type u_2
{n a : â„•} (h : a < n + 1) : â†‘â†‘a = a
{a b : ereal} (h : a â‰¤ -b) : b â‰¤ -a
{Î± : Type u} (s : wseq Î±) (n : â„•) : computation (list Î± Ã— wseq Î±)
{Î± : Type u_1} [decidable_eq Î±] (a : option Î±) : set (equiv.perm Î±)
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] : list Î± â†’ list Î±
(Î± : Type u_8) : Type u_8
(Î± : Type u_1) [preorder Î±] : Preorder
(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : galois_insertion (submodule.span R) coe
{Î¹ : Type u_1} {ð•œ : Type u_3} [is_R_or_C ð•œ] {E : Type u_4} [inner_product_space ð•œ E] [fintype Î¹] (b : orthonormal_basis Î¹ ð•œ E) : basis Î¹ ð•œ E
{Î± : Type u_1} (h : Â¬infinite Î±) : fintype Î±
{Î± : Type u} : ordnode Î± â†’ â„• â†’ ordnode Î± Ã— ordnode Î±
{n : Type u_4} {Î± : Type u_5} [fintype n] [normed_ring Î±] [decidable_eq n] : normed_ring (matrix n n Î±)
 : Type
 : Type v
{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : order.pred a â‰¤ order.pred b â†’ a â‰¤ b
{Î± : Type} {rels : set (free_group Î±)} (x : Î±) : presented_group rels
{Î± : Type u_2} (l : filter Î±) : Prop
{Î± : Type u} [add_group Î±] (x : free_group Î±) : Î±
{Î± : Sort u_1} {ra ra' : Î± â†’ Î± â†’ Prop} (h : âˆ€ (aâ‚ aâ‚‚ : Î±), ra aâ‚ aâ‚‚ â†’ ra' aâ‚ aâ‚‚) : quot ra â†’ quot ra'
(H : Type u_1) [topological_space H] (G : structure_groupoid H) : has_groupoid H G
{n : â„•} (x y : bitvec n) (b : bool) : bool Ã— bitvec n
(Î± : Type u) [omega_complete_partial_order Î±] (s : set Î±) : Prop
{M : Type u_1} [add_semigroup M] : stream M â†’ set M
{K : Type u} [field K] (s : set K) : subfield K
{Î± : Type u} [decidable_eq Î±] (Lâ‚ : list (Î± Ã— bool)) : list (list (Î± Ã— bool))
(c : char) : parser unit
{C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S â‰¤ Jâ‚.close S
(x y : â„•) : â„¤
{Î± : Sort u_1} (h : nonempty Î±) : Î±
(x y : â„•) : â„¤
{R : Type u_1} {Î¹ : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype Î¹] [is_artinian R M] : is_artinian R (Î¹ â†’ M)
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a < -b â†’ b < -a
(G : Type u_10) [has_involutive_inv G] : equiv.perm G
(n : Type u_1) (R : Type uâ‚‚) [decidable_eq n] [comm_ring R] [fintype n] : lie_subalgebra R (matrix n n R)
(C : Type uâ‚) [category_theory.category C] [category_theory.limits.has_initial C] : C
(R : Type u_1) [add_group R] [star_add_monoid R] : add_subgroup R
{Î¹ : Type u_1} [decidable_eq Î¹] (A : Î¹ â†’ Type u_2) [add_comm_monoid Î¹] [Î  (i : Î¹), add_comm_monoid (A i)] : Type (max u_1 u_2)
{Î± : Type u_1} [topological_space Î±] [non_assoc_ring Î±] (h : topological_semiring Î±) : topological_ring Î±
{Î± : Type u} [partial_order Î±] {a b : Î±} (h : a â‰¤ b) : a = b âˆ¨ a < b
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Î¹} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (j : Î¹) : V
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (h : is_unit A.det) : invertible A
(F : Type u â†’ Type u) [functor F] [q : qpf F] : Type u
{Î± : Type u_1} [measurable_space Î±] : function.injective measure_theory.jordan_decomposition.to_signed_measure
(N i : â„•) : â„•
{M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a âˆˆ s) : multiples a âŠ† s
{R : Type u} [comm_ring R] (s : set R) : set (prime_spectrum R)
(L : first_order.language) (Î± : Type u') : â„• â†’ Type (max u v u')
(p : â„•) [hp : fact (nat.prime p)] : â„• â†’ mv_polynomial (fin 0 Ã— â„•) â„¤
{Î± : Type u} (Î² : Î± â†’ Type v) : Type (max u v)
{M : Type u_1} [monoid M] {s : set M} {a : M} (h : a âˆˆ monoid.closure s) : âˆƒ (l : list M), (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) âˆ§ l.prod = a
{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a < b) (hbc : b = c) : a < c
(v : â„• â†’ â„•) : omega.nat.preterm â†’ â„•
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (wf : well_founded r) (x : Î±) : Î±
(n : â„•) : list bool
(Î± : Type u_1) [boolean_algebra Î±] : BoolAlg
{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {f : Î¹ â†’ Î±} (H : bdd_below (set.range f)) (c : Î¹) : infi f â‰¤ f c
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : Type u_1
{Î± : Type u} (l : list Î±) (s : stream Î±) : stream (list Î±)
{A : Type u_3} [add_group A] (s : set A) : Prop
 : parser â„•
{Î± : fin 0 â†’ Sort u} (x : fin 0) : Î± x
(s : finset â„•) {n : â„•} (h : âˆ€ (m : â„•), m âˆˆ s â†’ m < n) : finset (fin n)
{n : â„•} {p : fin n â†’ Prop} [decidable_pred p] {i : fin n} (hi : i âˆˆ fin.find p) {j : fin n} (hj : j < i) : Â¬p j
(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : free_algebra R M â†’ free_algebra R M â†’ Prop
{Î± : Type u_1} {Î² : Type u_2} (A : set (Î± â†’ Î²)) : Prop
 : has_add ordinal
(p : â„•) [fact (nat.prime p)] : Type
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ a â‰¤ c - b
 : Type
{Î¹ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] (A : Î¹ â†’ S) (a : R) : Prop
(a : Prop) : Prop
{R : Type u_1} [ring R] (P : cubic R) : R
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
(n : â„•) : Type
{Î± : Type u} : list (Î± Ã— bool) â†’ list (Î± Ã— bool) â†’ Prop
{gen : Type u} [random_gen gen] (g : gen) (lo hi : â„•) : â„• Ã— gen
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 1 âˆˆ s
{Î± : Type u} : ordnode Î± â†’ option (ordnode Î± Ã— Î±)
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î²] [preorder Î±] [order_top Î±] (gi : galois_insertion l u) : order_top Î²
{Î± : Type u_2} [has_involutive_neg Î±] : has_involutive_neg (filter Î±)
{Î± : Sort u_1} (z : bool â†’ Î±) (s : bool â†’ snum â†’ Î± â†’ Î±) : snum â†’ Î±
{Î± : Sort u_1} (h : is_empty Î±) {p : Î± â†’ Sort u_2} (a : Î±) : p a
 : initial_seg has_lt.lt has_lt.lt
{R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b
{Î± : Type u} (max : â„•) (f : thunk Î±) : option Î±
{Î± : Type u} [has_mul Î±] : is_mul_hom id
{Î± : Type u} {Î² : Type v} (f : filter Î±) (g : filter Î²) : filter (Î± Ã— Î²)
{Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), monoid (M i)] (w : free_product.word M) : free_product M
{H : Type u} [topological_space H] (G : structure_groupoid H) : Prop
(Î± : Type u_3) {Î² : Type u_4} [has_inf Î±] [semilattice_inf Î²] (b : Î²) : inf_hom Î± Î²
{Î± : Type u_1} : list Î± â†’ list â„• â†’ list (list Î±)
{Î± : Type u} [semiring Î±] : is_semiring_hom id
(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : basis (fin (finite_dimensional.finrank K V)) K V
(X : Type u_5) (Y : Type u_6) [topological_space X] : Type (max u_5 u_6)
{Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î²] [fintype Î±] (f : Î± â†’ Î²) (H : function.surjective f) : fintype Î²
(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x â‰  1
{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [has_add P] (f : add_hom M N) (g : add_hom M P) : add_hom M (N Ã— P)
{Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hf : function.surjective f) : dense_range f
{R : Type u_1} [ring R] [strong_rank_condition R] (n : â„•) {m : â„•} (v : fin m â†’ fin n â†’ R) : linear_independent R v â†’ m â‰¤ n
 : Type
{Î± : Type u_1} [add_comm_group Î±] [topological_space Î±] [topological_add_group Î±] [t2_space Î±] (f : â„• â†’ Î±) : filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)
 : num â†’ num
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
 : list bool â†’ num
{m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : matrix m n Î±) (f : Î± â†’ Î²) : matrix m n Î²
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} [Î  (a : Î±), fintype (Î² a)] [Î  (a : Î±), encodable (Î² a)] [encodable Î±] : encodable (W_type Î²)
 : set upper_half_plane
 : pgame â†’ pgame
(Î± : Type u_1) [t : topological_space Î±] [preorder Î±] : Prop
{Î± : Type u_1} [linear_order Î±] {r s : Î±} : {r}.to_colex < {s}.to_colex â†” r < s
(Î± : Type u_1) [has_mul Î±] : Type u_1
{Î± : Type u} [topological_space Î±] {s t : set Î±} (ht : is_compact t) (hs : is_closed s) : is_compact (s âˆ© t)
{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K'
 : â„¤ â†’ znum
{C : Type uâ‚} [category_theory.category C] [category_theory.monoidal_category C] (A : Mon_ C) : Mod A
{Î± : Type u_1} (f : Î± â†’ option Î±) : list Î± â†’ list Î±
{Î± : Type u_1} [decidable_eq Î±] {s : finset Î±} (P : finpartition s) : Prop
{Î± : Type u} [linear_ordered_ring Î±] (a b c : Î±) : 0 â‰¤ a * b âˆ¨ 0 â‰¤ b * c âˆ¨ 0 â‰¤ c * a
{X : Type u_1} [topological_space X] (x : X) : path x x
{Î³ : Type w} [semilattice_sup Î³] {s t : set Î³} : bdd_above s â†’ bdd_above t â†’ bdd_above (s âˆª t)
{Î³ : Type w} [semilattice_inf Î³] {s t : set Î³} : bdd_below (s âˆª t) â†” bdd_below s âˆ§ bdd_below t
{Î± : Type u_1} (l : language Î±) : language Î±
{R : Type u_1} [comm_ring R] (f : polynomial R) : set (prime_spectrum R)
{R : Type u_1} [monoid R] (r : R) : Prop
(R : Type u) [ring R] [strong_rank_condition R] {Î¹ : Type v} [fintype Î¹] : finite_dimensional.finrank R (Î¹ â†’ R) = fintype.card Î¹
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C
(C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_products C
{Î± : Type u_1} [has_mul Î±] [has_le Î±] (a : Î±) : Prop
{C : Type uâ‚} [category_theory.category C] {T : category_theory.monad C} : category_theory.creates_limits_of_size T.forget
(R : Type u) [ring R] : Ring
 : Type
{Î± : Type u_2} [decidable_eq Î±] [mul_one_class Î±] : mul_one_class (finset Î±)
{Î± : Type u_1} {p : Î± â†’ Prop} [decidable_pred p] {s : finset Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ Â¬p x) : finset.filter p s = âˆ…
(Î± : Type u_1) : Type u_1
{A : Type v} [add_monoid A] (a : A) : Prop
{a b : â„•} (w : a âˆ£ b) (h : b < a) : b = 0
{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : a + b = b + a
(Î± : Type u_6) (Î² : Type u_7) [preorder Î±] [preorder Î²] : Type (max u_6 u_7)
(M : Type u_4) [has_mul M] : Type u_4
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) : Prop
(G : Type u_10) (P : Type u_11) [add_monoid G] : Type (max u_10 u_11)
{Î± : Type u_1} [h : inhabited Î±] (l : list Î±) (n : â„•) : Î±
{Î± : Type u_1} : â„• â†’ list Î± â†’ list (list Î±)
{Î± : Type u} [lattice Î±] [add_comm_group Î±] : has_neg_part Î±
(R : Type u) (M : Type v) [field R] [add_comm_group M] [module R M] : Type v
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] : lazy_list Î± â†’ lazy_list Î±
(R : Type u_1) (n : â„•) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_2)
{C : Type uâ‚} [category_theory.category C] {X : C} (ð’® : set (category_theory.sieve X)) : category_theory.sieve X
(L : Type u_1) [topological_space L] [lattice L] : Type
{Î± : Type u_3} [preorder Î±] : filter Î±
(X : Type u) [group X] : Group
{Î± : Type u} : ordnode Î± â†’ Î± â†’ Î±
 : Type
(F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] [is_separable F E] : power_basis F E
{L : first_order.language} (T : L.Theory) : Prop
{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : set.Ioi b âŠ† set.Ioi a
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw b c a
(o : ordinal) (f : Î  (b : ordinal), b < o â†’ ordinal â†’ ordinal) : ordinal â†’ ordinal
 : num â†’ znum
 : num â†’ list â„•
 : Type (u_1+1)
(Î± : Type u_1) : Type u_1
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] (a : R) : multiset R
{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} [nontrivial A] (hx : is_integral A x) : minpoly A x â‰  0
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : X
(M : Type u_1) [add_monoid M] : add_submonoid M
(Î± : Type u_3) [lattice Î±] [bounded_order Î±] : bounded_lattice_hom Î± Î±
{Î± : Type u_1} (Î´ : Î± â†’ Type u_2) (a : Î±) (H : a âˆˆ 0) : Î´ a
(x : Class) : Class
(b : â„•) : â„• â†’ â„•
{Î± : Type u} {Î² : Type v} (r : rel Î± Î²) (lâ‚ : filter Î±) (lâ‚‚ : filter Î²) : Prop
(X : CompHaus) : Profinite
{G : Type u_1} [add_group G] : has_inf (add_subgroup G)
{G : Type u_1} [comm_group G] : group.nilpotency_class G â‰¤ 1
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : -a < b â†’ -b < a
{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : submonoid A
(X : BoundedDistribLattice) : BoundedLattice
(C : Type u) [category_theory.category C] : Prop
(Î± : Type u) (Î² : Type v) [monoid Î±] [mul_action Î± Î²] : set Î²
{Î± : Type u_1} [circular_preorder Î±] (a b : Î±) : set Î±
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : composition_series X
{n : â„•} {Î± : fin (n + 1) â†’ Type u} (x : Î± 0) (p : Î  (i : fin n), Î± i.succ) (z : Î± 0) : function.update (fin.cons x p) 0 z = fin.cons z p
{M : Type u_1} [has_add M] (s : set M) : add_subsemigroup M
{Î± : Type u_1} {Î¹ : Sort u_4} (l : filter Î±) (p : Î¹ â†’ Prop) (s : Î¹ â†’ set Î±) : Prop
(Î± : Type u) : Type u
(f : name â†’ option name) : name â†’ name
(Î± : Type u_2) [fintype Î±] [lattice Î±] [bounded_order Î±] : complete_lattice Î±
 : Type
{Î± : Type u_1} {Î² : Type u_2} [partial_order Î±] [preorder Î²] [order_top Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : galois_connection l u) : order_top Î±
{Î± : Type u} {Î² : Type v} [topological_space Î±] [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) (a : Î±) : Prop
{M : Type u_1} [has_add M] : has_le (add_con M)
(R : Type u_1) (C : Type u) : Type u
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†” subsingleton Mâ‚€
(Î± : Type u_5) [T : topological_space Î±] : Type (max u_5 (u_6+1))
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : computation Î± â†’ computation Î²
(C : Type u) [category_theory.category C] : Prop
(K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : set V) : â„•
{C : Type u} (X Y : C) : category_theory.limits.walking_pair â†’ C
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : sym2 Î± â†’ sym2 Î²
(R : Type u) (A : Type v) (B : Type w) [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] : Type (max v w)
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (r : setoid Î²) : setoid Î±
(Î± : Sort u) (default : Î±) : Sort u
(n : â„•) : â„¤ â†’ bitvec n.succ
(Î± : Type u_1) [complete_lattice Î±] : Prop
(p : â„•) [hp : fact (nat.prime p)] : is_absolute_value (padic_norm p)
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (f : Î² â†’ Î³) : Î± âŠ• Î² â†’ Î± âŠ• Î³
(R : Type u_1) [rack R] : shelf_hom R (quandle.conj (rack.envel_group R))
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} (r : Î¹ â†’ Î¹ â†’ Prop) (s : Î  (i : Î¹), Î± i â†’ Î± i â†’ Prop) (a b : Î£ (i : Î¹), Î± i) : Prop
{Î± : Type u_1} [has_le Î±] (a : Î±) : Prop
{Î± : Type u_1} [measurable_space Î±] : partial_order (measure_theory.measure Î±)
(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)
{Î± : Type u_3} [linear_ordered_add_comm_group Î±] : filter.tendsto has_abs.abs filter.at_top filter.at_top
{n : â„•} (F : typevec (n + 1) â†’ Type u) [mvfunctor F] [q : mvqpf F] (Î± : typevec n) : Type u
(Î± : Type u_3) : Type u_3
(R : CommRing) : Top
 : Type
(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : âˆƒ (Ï– : R), prime Ï–
{Î± : Type u} (a : Î±) (f : filter Î±) : topological_space Î±
(L : first_order.language) (M : Type u_3) [L.Structure M] : Prop
(F : Type u_1) (R : Type u_2) (Î“â‚€ : Type u_3) [linear_ordered_comm_monoid_with_zero Î“â‚€] [ring R] : Type (max u_1 u_2 u_3)
{Î± : Type u_1} [decidable_eq Î±] {ð’œ : finset (finset Î±)} {s : finset Î±} : s âˆˆ ð’œ.shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ð’œ), s âŠ† t âˆ§ t.card = s.card + 1
{n : â„•} (i : fin2 n) : mvpfunctor n
{G : Type u_1} [group G] (H : subgroup G) : subgroup G
(Î± : Type u_2) [has_top Î±] : top_hom Î± Î±
{Î± : Type u_1} : regular_expression Î± â†’ bool
{Î± : Type u_1} {Î² : Type u_2} [has_coe Î± Î²] : has_coe (generalized_continued_fraction Î±) (generalized_continued_fraction Î²)
{n : â„•} (P : mvpfunctor (n + 1)) : P.last.W â†’ fin2 n â†’ Type u
 : Type
(R : Type u_1) [comm_ring R] [is_domain R] [char_zero R] : char_zero (fraction_ring R)
{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R Ã— R
{X : Type u_2} [emetric_space X] (s : finset X) : dimH â†‘s = 0
(R : Type u_1) [has_one R] [has_neg R] : Type u_1
{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f) : function.is_fixed_pt g x
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [gcd_monoid R] (a b : R) : âˆƒ (x y : R), gcd_monoid.gcd a b = a * x + b * y
{Î± : Type u_1} (a : Î±) : measure_theory.outer_measure Î±
 : bool â†’ bool â†’ bool
{R : Type u} [has_zero R] [has_pow R â„•] (x : R) : Prop
{Î± : Type u_1} [encodable Î±] (n : â„•) : option (multiset Î±)
{Î± : Type u} [topological_space Î±] [fintype Î±] : compact_space Î±
{G : Type u_1} [add_group G] (K : add_subgroup G) (s : set G) (hs : s = â†‘K) : add_subgroup G
{Î± : Type u_1} [fintype Î±] (p : Î± â†’ Prop) [decidable_pred p] (hp : âˆƒ! (a : Î±), p a) : {a // p a}
{R : Type u_2} [comm_ring R] [is_domain R] {p : R} [decidable_rel has_dvd.dvd] (hp : prime p) : add_valuation R enat
{n : â„•} : fin2 n â†’ â„•
(F : Type u_1) (K : Type u_2) [field F] [ring K] [is_domain K] [algebra F K] [finite_dimensional F K] : division_ring K
(Î± : Type u) [topological_space Î±] : Type u
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) (s : set A) (hs : s = â†‘S) : subalgebra R A
{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : subring A
{Î± : Type u_1} {Î² : Type u_2} [encodable Î±] [encodable Î²] : encodable (Î± Ã— Î²)
{Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : {a // p a}), q â†‘x _
{G : Type u} [monoid G] : is_of_fin_order 1
{Î± : Type u_2} [subtraction_monoid Î±] : subtraction_monoid (filter Î±)
(Î± : Type u_3) [topological_space Î±] : Prop
(b : bool) : pos_num â†’ pos_num
{Râ‚ : Type u_4} [comm_ring Râ‚] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form Râ‚ (n â†’ Râ‚)) : matrix n n Râ‚
{Î± : Type u_1} (i : Î±) : poly Î±
 : binder_info â†’ â„•
{F : Type u â†’ Type u} [functor F] (q : qpf F) : Prop
(S : Type u_4) (M : out_param (Type u_5)) [mul_one_class M] [set_like S M] : Type
{Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î² â†’ Prop) : option Î± â†’ option Î² â†’ Prop
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : B.mul A = 1) : Aâ»Â¹ = B
{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] : has_mul.mul 0 = function.const Mâ‚€ 0
{Î± : Type u_1} [metric_space Î±] {Î² : Type u} [nonempty Î²] (p : besicovitch.tau_package Î² Î±) : ordinal â†’ Î²
{Î± : Type u_1} {Î² : Type u_2} [fintype Î²] (f : Î± â†’ Î²) (H : function.injective f) : fintype Î±
{Î± : Type u_1} (a : Î±) (o : part Î±) : Prop
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [is_empty Î±] : measure_theory.simple_func Î± Î²
{Î± : Type u_1} {Î² : Type u_2} : setoid (local_equiv Î± Î²)
{Î± : Type u} (s : set Î±) : is_open {u : ultrafilter Î± | s âˆˆ u}
 : Type
{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 1
 : â„• â†’ â„•
(b : â„•) (h : 2 â‰¤ b) : â„• â†’ list â„•
{k : Type uâ‚} {G : Type uâ‚‚} [semiring k] [has_mul G] : has_mul (monoid_algebra k G)
(Î± : Type u_2) : Type u_2
{Î¹ : Type u_1} (M : Î¹ â†’ Type u_2) [Î  (i : Î¹), monoid (M i)] : Type (max u_1 u_2)
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : vector Î± n) : vector Î² (n + 1)
(m : Type u) (n : Type u') [fintype m] [fintype n] (Î± : m â†’ n â†’ Type v) : Type (max u u' v)
(C : Type u) [ð’ž : category_theory.category C] : Type (max u v)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : affine_subspace k P
{Î± : Type u_1} [generalized_boolean_algebra Î±] {f d : â„• â†’ Î±} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f
(Î± : Type u_1) [cancel_comm_monoid_with_zero Î±] [unique_factorization_monoid Î±] [normalization_monoid Î±] [decidable_eq (associates Î±)] [decidable_eq Î±] : normalized_gcd_monoid Î±
{Î± : Type u_2} [decidable_eq Î±] [add_semigroup Î±] : add_semigroup (finset Î±)
 : finset.nat.antidiagonal 0 = {(0, 0)}
 : Type
{Î± : Type u} {Î² : Type v} (f' : Î² â†’ Î±) (f : Î± â†’ Î²) (t : set Î²) : Prop
 : Type (u+1)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X : C) : Prop
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 0 âˆˆ S
{Î± : Type u} [preorder Î±] (s : set Î±) : Î± â†’ Prop
(R : Type u_1) [comm_ring R] (n Î½ : â„•) : polynomial R
{Î± : Type u_1} : list Î± â†’ list Î± â†’ list (list Î±)
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
 : Type
{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K
{Î± : Type u_1} (lâ‚ lâ‚‚ : list Î±) : Prop
{G : Type u_3} [group G] (self : subgroup G) : submonoid G
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a
{Î± : Type u} [topological_space Î±] (s : set Î±) : Prop
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [compact_space Î±] [metric_space Î²] (x : Î±) : continuous (Î» (f : C(Î±, Î²)), â‡‘f x)
{Î± : Type u} [non_unital_non_assoc_ring Î±] (k : Î±) (h : âˆ€ (x : Î±), k * x = 0 â†’ x = 0) : is_left_regular k
{p : bool â†’ Prop} [Î  (b : bool), decidable (p b)] : decidable (âˆ€ (b : bool), p b)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} (f : Î  (i : Î¹), filter (Î± i)) : filter (Î  (i : Î¹), Î± i)
{Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] [has_faithful_smul Î± Î²] : function.injective mul_action.to_perm
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {lâ‚ : filter Î±} {lâ‚‚ : filter Î²} : filter.tendsto f lâ‚ lâ‚‚ â†’ lâ‚ â‰¤ filter.comap f lâ‚‚
(n : simplex_category) : â„•
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : galois_insertion (category_theory.pretopology.to_grothendieck C) (category_theory.pretopology.of_grothendieck C)
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : a < b * c â†’ bâ»Â¹ * a < c
(K : Type u) [division_ring K] {Î¹ : Type v} [fintype Î¹] : finite_dimensional.finrank K (Î¹ â†’ K) = fintype.card Î¹
 : Type
{Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} : emetric.inf_edist x t â‰¤ emetric.inf_edist x s + emetric.Hausdorff_edist s t
{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 â‰¤ ifp_n.fr
{G : Type u_1} [group G] (K : subgroup G) {l : list G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.prod âˆˆ K
{G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] [monoid B] : mul_distrib_mul_action G (A â†’ B)
(Î± : Type u) : Type u
(L : Type u_1) (M : Type u_2) : Type (max u_1 u_2)
 : has_pure filter
 : name â†’ name
{Î± : Type u_1} [uniform_space Î±] {Î² : Type u_2} [uniform_space Î²] (f : Î± â†’ Î²) : uniform_space.completion Î± â†’ uniform_space.completion Î²
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
{Î± : Type u_1} : option Î± â†’ part Î±
(n a b : â„¤) : Prop
(n : â„•) : â„• â†’ bitvec n
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] : Type (max u v)
(X Y : Type u) : category_theory.limits.colimit_cocone (category_theory.limits.pair X Y)
(t : Type u â†’ Type u) : Type (u+1)
(M : Type u) : Type u
 : Type
{R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a â‰  0) : is_regular a
{Î± : Type u_2} {Î² : Type u_3} [add_monoid Î±] [add_action Î± Î²] : add_action Î± (set Î²)
{m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n
{Î± : Type u_1} [decidable_eq Î±] (s : finset Î±) (n : â„•) : finset (sym Î± n)
(Î± : Type u_1) (Î² : Type u_2) (Î³ : out_param (Type u_3)) : Type (max u_1 u_2 u_3)
(o : ordinal) (f : Î  (a : ordinal), a < o â†’ ordinal) : ordinal
(Î“ : Type u_1) (R : Type u_2) [partial_order Î“] [has_zero R] : Type (max u_1 u_2)
(R : Type u) [semiring R] (n : with_bot â„•) : submodule R (polynomial R)
 : has_neg surreal
(Î± : Type u_1) [add_comm_group Î±] : Type u_1
(G : Type u) : Type u
{G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {K : Type u_3} [group K] [topological_space K] [nonarchimedean_group K] : nonarchimedean_group (G Ã— K)
{Î± : Type u} [group Î±] : is_group_hom id
{Î± : Type u_1} : lazy_list Î± â†’ lazy_list Î±
(X : algebraic_geometry.Scheme) : Type (max (u+1) (v+1))
{A : Type u_1} {Î¹ : Type u_2} [ring A] [nonempty Î¹] {B : Î¹ â†’ add_subgroup A} (hB : ring_subgroups_basis B) : topological_space A
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X â†’ Y) (s : set X) : Prop
{Î± : Type u_1} {Î¹ : Type u_2} {f : Î¹ â†’ Î±} : function.injective f â†’ pairwise (ne on f)
(Î± : Type u_1) (enum : Î± â†’ â„•) (n : â„•) : Type u_1
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] : subsingleton (category_theory.preadditive C)
(p : â„•) {idx : Type u_2} [hp : fact (nat.prime p)] (Î¦ : mv_polynomial idx â„¤) (n : â„•) : mv_polynomial (idx Ã— â„•) â„¤
(R : Type u_1) [ring R] [topological_space R] : Prop
{Î± : Type u} [semigroup Î±] [has_distrib_neg Î±] (a b : Î±) : -a âˆ£ b â†” a âˆ£ b
{ð•œ : Type u_1} {F : Type u_3} [is_R_or_C ð•œ] [add_comm_group F] [module ð•œ F] [c : inner_product_space.core ð•œ F] : has_inner ð•œ F
{Î± : Type u_1} [preorder Î±] : ordset Î±
 : Type
{M : Type u_6} [add_monoid M] (u : add_units M) : equiv.perm M
(a b : num) : num
(p : â„•) [hp : fact (nat.prime p)] (n : â„•) : mv_polynomial (fin 2 Ã— â„•) â„¤
 : Type (u_1+1)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) (a : Î±) : Prop
{Î± : Type u} : ordnode Î± â†’ ordnode Î±
{Î± : Type u} [preorder Î±] {a b c : Î±} : b = c â†’ a â‰¤ b â†’ a â‰¤ c
{X : Type u_2} [emetric_space X] (m : set X â†’ ennreal) (r : ennreal) : measure_theory.outer_measure X
(Î± : Type u_1) [fintype Î±] [category_theory.small_category Î±] [category_theory.fin_category Î±] : Type
(o : ordinal) : cardinal
(Î± : Type u_8) : Type u_8
{K : Type u} [field K] (s : subfield K) : 0 âˆˆ s
(Î± : Type) : Type
{Î± : Type u_1} [has_Sup Î±] {Î¹ : Sort u_2} (s : Î¹ â†’ Î±) : Î±
(A : Type u_4) [monoid A] [topological_space A] : continuous_monoid_hom A (A Ã— A)
{n : â„•} {Î± : Type u} (a : array (n + 1) Î±) : array n Î±
{Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] [inhabited Î²] : inhabited (bounded_continuous_function Î± Î²)
 : Type
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {v : n â†’ Î±} : is_unit (matrix.diagonal v) â†” is_unit v
{Î± : Type u} : partial_order (topological_space Î±)
{Î± : Type u_1} [has_add Î±] [has_lt Î±] [contravariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} (bc : a + b < a + c) : b < c
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} (f : (Î  (a : Î±), part (Î² a)) â†’ Î  (a : Î±), part (Î² a)) (x : Î±) : part (Î² x)
{B : Type u} [quiver B] {a b c : B} : quiver.path a b â†’ category_theory.free_bicategory.hom b c â†’ quiver.path a c
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} (f : Î± â†’ Î²) (g : Î± â†’ Î³) (e' : Î² â†’ Î³) : Î² â†’ Î³
(F : Sort u_1) (Î± : out_param (Sort u_2)) (Î² : out_param (Î± â†’ Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3))
(n : â„•) (R : Type u_1) [comm_ring R] [is_domain R] : polynomial R
(R : Type uâ‚) [comm_ring R] (p : â„•) [hp : fact (nat.prime p)] [char_p R p] : subring (â„• â†’ R)
{R : Type u} [has_involutive_star R] : equiv.perm R
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z â†’ B) : Type (max u_2 u_3 u_4)
{Î± : Type u_2} {Î² : Type u_3} [has_vadd Î± Î²] : has_vadd Î± (filter Î²)
{Î± : Type u} [topological_space Î±] (s : set Î±) : Prop
{Î± : Type u_1} {Î¹ : Type u_3} [complete_lattice Î±] {t : Î¹ â†’ Î±} (ht : complete_lattice.independent t) : pairwise (disjoint on t)
{Î± : Type u} : â„• â†’ lazy_list Î± â†’ list Î±
{Î± : Type u_1} [preorder Î±] (a : Î±) : set Î±
(R : Type u_1) (S : Type u_2) [semiring R] [ordered_semiring S] : Type (max u_1 u_2)
(Î± : Type u_2) [has_le Î±] : Prop
{R : Type u_1} [comm_semiring R] {M : Type u_2} {N : Type u_3} [add_comm_group M] [add_comm_group N] [module R M] [module R N] : tensor_product.compatible_smul R â„¤ M N
(G : Type u_1) [monoid G] [topological_space G] : Type u_1
{Î± : Type u_1} (s : set (set Î±)) : filter_basis Î±
{C : Type u} [category_theory.category_struct C] (X : C) : Type v
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z â†’ B) : Type (max u_2 u_3 u_4)
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
 : znum â†’ num
(Î± : Type u) : Type u
(n : â„•) : Type
{Î± : Type u_1} {m : measurable_space Î±} (s : set Î±) : nonempty {t // s âŠ† t âˆ§ measurable_set t}
{Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ b + a â†” a âˆ£ b
 : matrix (fin 6) (fin 6) â„¤
(Î± : Type u_2) : Type u_2
(n : â„•) : is_well_order (fin n) has_lt.lt
{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s âˆ© t)
(H : Type u_4) [add_group H] : Prop
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
{Ï„ : Type u_1} {Î± : Type u_2} [canonically_ordered_add_monoid Ï„] {Ï• : Ï„ â†’ Î± â†’ Î±} {s : set Î±} (h : is_fw_invariant Ï• s) : is_invariant Ï• s
(R : Type u) (X : Type v) [comm_ring R] : lie_ring (free_lie_algebra R X)
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î² â†’ Î±) (a : Î±) (s : wseq Î²) : wseq Î±
(Î± : Type u) : Type u
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Î  (i : Î¹), has_le (Î± i)] (a b : Î£ (i : Î¹), Î± i) : Prop
(x : Set) : Set
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î±] [preorder Î²] [order_bot Î²] (gi : galois_coinsertion l u) : order_bot Î±
{Î± : Sort u} {Î² : Sort v} {f : Î± â†’ Î²} (hf : function.surjective f) [unique Î±] : unique Î²
(R : Type u) [comm_ring R] : Top.sheaf CommRing (algebraic_geometry.prime_spectrum.Top R)
(Î“â‚€ Î“â‚ : Type) : Type 1
{Î± : Type u_1} (f : Î± â†’ set Î±) : Â¬function.surjective f
{G : Type u_1} [group G] [h : group.is_nilpotent G] : is_solvable G
 : category_theory.full Compactum_to_CompHaus
(Î± : Type u) [lattice Î±] [decidable_eq Î±] [decidable_rel has_le.le] [decidable_rel has_lt.lt] [is_total Î± has_le.le] : linear_order Î±
{R : Type u} [ring R] (s : subring R) {l : list R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (p : polynomial S) : polynomial R
{Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±] (f : Î² â†’ Î±) : Prop
{Î± : Type u_7} {Î² : Type u_8} [measurable_space Î±] [measurable_space Î²] (f : Î± â†’ Î²) : Prop
{G : Type u_3} [add_group G] (self : add_subgroup G) : add_submonoid G
{Î± : Type u_1} [topological_space Î±] {s : set Î±} (h : is_open s) : is_GÎ´ s
(M : Type u_1) [mul_one_class M] : galois_insertion submonoid.closure coe
{Î± : Type u_1} (s : set Î±) (r : Î± â†’ Î± â†’ Prop) : Prop
{G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (K : subgroup N) : subgroup (G Ã— N)
(C : Type uâ‚) [category_theory.category C] : Prop
(R : Type u_1) [ring R] {n : â„•} (m : â„•) [char_p R m] (h : m âˆ£ n) : algebra (zmod n) R
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {b : Î²} {l : list Î±} : b âˆˆ list.map f l â†’ (âˆƒ (a : Î±), a âˆˆ l âˆ§ f a = b)
{M : Type u_1} [has_add M] : complete_lattice (add_subsemigroup M)
{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)
{k : Type uâ‚} {G : Type uâ‚‚} [group G] [semiring k] : distrib_mul_action G (monoid_algebra k G)
(D : Type u_1) [category_theory.category D] [category_theory.abelian D] : category_theory.is_idempotent_complete D
{Î± : Type u_1} (S : set (set Î±)) : set (set Î±)
{Î± : Type u_1} (R : Î± â†’ Î± â†’ Prop) [decidable_rel R] : list Î± â†’ list Î±
(p : â„•) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [is_alg_closed k] (aâ‚ aâ‚‚ : witt_vector p k) : k
{Î¹ : Type u_2} [encodable Î¹] {F : Î¹ â†’ Type u_3} [Î  (i : Î¹), metric_space (F i)] : metric_space (Î  (i : Î¹), F i)
 : Type (u+1)
{Î± : Type u_1} : has_mul (language Î±)
{R : Type u} [comm_ring R] [is_domain R] (p : polynomial R) : multiset R
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{Î± : Type u_1} {Î² : Type u_2} {l : filter Î±} {f : Î± â†’ Î²} {lb : filter Î²} : filter.tendsto f l lb â†’ â†‘f.tendsto lb
(Î± : Type u_1) [order.frame Î±] : Frame
{Î± : Type u_1} [preorder Î±] [has_add Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a + b - b â‰¤ a
{M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) : localization S
{Î± : Sort u} {f : Î± â†’ Î±} (h : function.involutive f) (P : Prop) [decidable P] (x : Î±) : f (ite P x (f x)) = ite (Â¬P) x (f x)
{Î± : Type u_1} : list (lazy_list Î±) â†’ lazy_list Î±
 : Set â†’ Set â†’ Prop
{R : Type u} [comm_semigroup R] [star_semigroup R] : mul_aut R
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] (a b : Î±) : finset Î±
{n : â„•} (Î± : typevec n) (Î² : typevec n) : Type (max u_1 u_2)
{V : Type u} (G : simple_graph V) (s : set (sym2 V)) : simple_graph V
{R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X
(Î± : Type u_1) [complete_semilattice_Sup Î±] : complete_lattice Î±
(M : Type u_1) [measurable_space M] [has_mul M] : Prop
(C : Type u) [category_theory.category C] : Prop
{G : Type u_1} [group G] : has_bracket (subgroup G) (subgroup G)
{G : Type u_1} [group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), order_of x = p
(F : Type u_1) (Î± : out_param (Type u_2)) (Î² : out_param (Type u_3)) [topological_space Î±] [topological_space Î²] : Type (max u_1 u_2 u_3)
{Î± : Type u_2} [semigroup Î±] : semigroup (set Î±)
(Î± : Type u) (Î² : Type v) [group Î±] [mul_action Î± Î²] : setoid Î²
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (ð’œ : â„• â†’ submodule R A) [graded_algebra ð’œ] : algebraic_geometry.SheafedSpace CommRing
{Î± : Type u_1} {n : â„•} (a : Î±) (v : vector3 Î± n) (i : fin2 n.succ) : vector3 Î± n.succ
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type u_1} [is_empty Î¹] (hV : module.rank K V = 0) : basis Î¹ K V
{Î± : Type} (F : parser Î± â†’ parser Î±) : parser Î±
{R : Type u} [comm_ring R] [is_domain R] (n : â„•) (a : R) : multiset R
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a + b < c â†’ a < c - b
(n : â„•) : â„•
{Î± : Type u_2} [has_one Î±] : has_one (filter Î±)
{K : Type u_1} [field K] {t : â„•} (not_dvd : Â¬ring_char K âˆ£ t) : invertible â†‘t
(p : Prop) : Type
{Î± : Type u_2} {Î² : Type u_3} [monoid Î±] [mul_action Î± Î²] : mul_action Î± (filter Î²)
(R : Type u) [add_monoid R] [has_one R] (p : â„•) : Prop
{Î± : Sort u_1} {p : Î± â†’ Prop} (h : âˆƒ (a : Î±), p a) {C : Sort u} (H : Î  (a : Î±), p a â†’ C) : C
 : bool â†’ bool â†’ bool
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] {X : Top} (F : Top.presheaf C X) : Prop
{Î± : Type u} {n : â„•} (v : fin n.succ â†’ Î±) : fin n â†’ Î±
{S : set ordinal} (f : ordinal â†’ ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f âˆ§ set.range f = S â†” f = ordinal.enum_ord S
{Î± : Type u} [monoid Î±] : conj_classes Î± â†’ set Î±
(A : Type u_4) [comm_ring A] [is_domain A] [unique_factorization_monoid A] {K : Type u_5} [field K] [algebra A K] [is_fraction_ring A K] (x : K) : A
{Î± : Type u_2} {Î² : Type u_3} (f : Î± â†’ Î²) : complete_lattice_hom (set Î²) (set Î±)
{R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) âˆ§ is_regular (b * a) â†” is_regular a âˆ§ is_regular b
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (a b : Î±) : Î±
{Î± : Type u_2} : filter Î±
{Î± : Type u} (l : list Î±) : â„• â†’ ordnode Î± Ã— {l' // l'.length â‰¤ l.length}
{Î± : Type u_1} [has_one Î±] (a : Î±) : simple_continued_fraction Î±
{Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Prop} (f : Î  (a : Î±), p a â†’ Î²) (x : option Î±) : (âˆ€ (a : Î±), a âˆˆ x â†’ p a) â†’ option Î²
 : first_order.language
(Î± : Type u_1) [boolean_algebra Î±] [fintype Î±] : FinBoolAlg
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : bâ»Â¹ * a < c â†’ a < b * c
 : Type u_1 â†’ PartialFun
{Î± : Type u_1} [ms : measurable_space Î±] (m : measure_theory.outer_measure Î±) (h : ms â‰¤ m.caratheodory) : measure_theory.measure Î±
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (s : finset Î±) : finset Î±
(F : Type u_1) (K : Type u_2) [comm_ring F] [ring K] [algebra F K] : Prop
(Î± : Type) : Type
{Î± : Type u_1} [has_add Î±] (s : set Î±) (a b : Î±) : Prop
(C : Type u) [category_theory.category C] : Prop
(p : â„•) [hp : fact (nat.prime p)] : â„• â†’ mv_polynomial (fin 2 Ã— â„•) â„¤
{Î± : Type u} : ordnode Î± â†’ Î± â†’ ordnode Î±
{Î± : Type u_1} (n : â„•) (v : Î±) : array n Î±
(Î± : Type u_2) : Type u_2
(l r : â„•) : Prop
{Î± : Type u} [add_right_cancel_monoid Î±] : has_faithful_vadd Î± Î±
{Î± : Type u_1} (s : finset Î±) : finset (finset Î±)
{Î± : Type u_1} (f : Î± â†’ Î±) (n : â„•) : set Î±
{Î± : Type u_1} [linear_order Î±] (s : finset Î±) (hâ‚‚ : 1 < s.card) : s.min' _ < s.max' _
{X : Type u_1} [topological_space X] (hX : âˆ€ {x y : X}, x â‰  y â†’ (âˆƒ (U : set X) (h_clopen : is_clopen U), x âˆˆ U âˆ§ y âˆ‰ U)) : is_totally_disconnected set.univ
(Î± : Type u_4) : Type u_4
{R : Type u} [ring R] : has_top (subring R)
{M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p âˆ£ L.prod â†” âˆƒ (a : M) (H : a âˆˆ L), p âˆ£ a
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
{Râ‚ƒ : Type u_7} [comm_ring Râ‚ƒ] {n : Type u_11} [fintype n] (J : matrix n n Râ‚ƒ) [decidable_eq n] : submodule Râ‚ƒ (matrix n n Râ‚ƒ)
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : with_bot Î± â†’ with_bot Î²
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] : ordnode Î± â†’ ordnode Î± â†’ bool
{Î± : Type u_1} (s : cycle Î±) : multiset Î±
{Î± : Type u} {Î² : Type v} (r : rel Î± Î²) (l : filter Î±) : filter Î²
{R : Type u_1} [comm_ring R] {câ‚ câ‚‚ : R} : has_mul (quaternion_algebra R câ‚ câ‚‚)
{K : Type u_1} [field K] (R : subring K) (hR : âˆ€ (x : K), x âˆˆ R âˆ¨ xâ»Â¹ âˆˆ R) : valuation_subring K
(Î± : Type u_2) : Type u_2
{Î± : Type u_2} [subtraction_monoid Î±] {a : Î±} (h : is_add_unit a) : add_units Î±
{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] (b : V) : quiver.path r b
{Î± : Type u} [pseudo_metric_space Î±] (x : Î±) (s : set Î±) : nnreal
(P : Type u) : Type u
(ð•œ : Type u_1) {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] {Î¹ : Type u_4} (v : Î¹ â†’ E) : Prop
{Î± : Type u_1} (Î² : Î± â†’ Type u_2) : Type (max u_1 u_2)
{Î± : Type u} [lattice Î±] [comm_group Î±] : has_pos_part Î±
{Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (H : right_commutative f) (b : Î²) (s : multiset Î±) : Î²
{Î± : Type u} [decidable_eq Î±] (a : Î±) : wseq Î± â†’ wseq â„•
 : pgame â†’ Type u
{Î± : Type u_2} [has_div Î±] : has_div (set Î±)
{Î± : Type u_2} {Î² : Type u_3} [add_monoid Î±] [add_action Î± Î²] : add_action Î± (filter Î²)
{C : Type u} [category_theory.category C] (P : C) : Prop
{F : Type u_3} [field F] [fintype F] : ring_char F = 2 â†” fintype.card F % 2 = 0
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_coproducts C
(p : Prop) [decidable p] : p âˆ¨ Â¬p
{Î± : Type u} : can_lift (set Î±) (finset Î±)
{Î± : Sort u_1} {Î² : Sort u_2} {p : Î± â†’ Prop} {q : Î² â†’ Prop} (f : Î± â†’ Î²) (h : âˆ€ (a : Î±), p a â†’ q (f a)) : subtype p â†’ subtype q
{M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.sum âˆˆ s
{G : Type u_1} [group G] (H : subgroup G) : 1 âˆˆ H
(Î± : Type u_1) : Type u_1
{Î± : Type u_1} [semilattice_sup Î±] : galois_insertion partial_sups coe_fn
{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_linear_order Î±] {a : Î±} [nonempty Î¹] {f : Î¹ â†’ Î±} (h : infi f < a) : âˆƒ (i : Î¹), f i < a
(C : Type u_1) [category_theory.category C] : Type (max u_1 u_2)
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (s : set Î±) (f : â„• â†’ Î±) : Prop
{Î± : Type u} : lazy_list Î± â†’ seq Î±
 : Type (u_1+1)
{Î± : Type u_1} {Î² : Type u_2} (e : local_equiv Î± Î²) (s : set Î±) : local_equiv Î± Î²
 : (â„• â†’ â„•) â†’ Prop
{Î± : Type u_1} : finset Î±
(K : Type u) : Type u
(Î² : Type v) (C : Type u_1) [category_theory.category C] : Prop
{p : â„•} (n : â„•) {R : Type u_1} (x : witt_vector p R) : truncated_witt_vector p n R
{Î± : Type u} (x : Î±) : free_abelian_group Î±
(R : Type u_1) [comm_ring R] : Prop
{Î± : Type u} [pseudo_emetric_space Î±] (x y z : Î±) : has_edist.edist x y â‰¤ has_edist.edist z x + has_edist.edist z y
(Î± : Type u_1) : Type u_1
(S : Type u_1) [shelf S] : shelf_hom S S
{n : Type u} [decidable_eq n] [fintype n] {Î± : Type v} [comm_ring Î±] (A : matrix n n Î±) (b : n â†’ Î±) (i : n) : Î±
{Î± : Type u_1} : â„• â†’ â„• â†’ list Î± â†’ list Î±
{p : â„•} {R : Type u_1} [comm_ring R] (x : witt_vector p R) : witt_vector p R
(ð•œ : Type u_1) (E : Type u_2) [is_R_or_C ð•œ] [inner_product_space ð•œ E] [finite_dimensional ð•œ E] : set E
(n : â„•) : sSet
{Î± : Type u_1} [preorder Î±] (a b : Î±) : set Î±
(L : first_order.language) : Prop
{C : fin2 0 â†’ Sort u} (i : fin2 0) : C i
{Î± : Type u} [linear_ordered_ring Î±] {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Î± : Type u_1} (s : multiset Î±) : multiset (multiset Î± Ã— multiset Î±)
{Î± : Type u_1} [subsingleton Î±] (s : finset Î±) : s.card â‰¤ 1
{Î± : Type u_1} {Î¹'' : Type u_6} [preorder Î¹''] (s'' : Î¹'' â†’ set Î±) : Prop
 : num â†’ option num
{Î± : Type u_1} [measurable_space Î±] : measurable_space (measure_theory.measure Î±)
{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (l : Î± â†’ Î²) (u : Î² â†’ Î±) : Prop
{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G â†’ Â¬monoid.is_torsion G
(k : Type u) [field k] : Type u
{n : â„•} {Î± : fin n â†’ Type u} {Î±' : fin n â†’ Type v} (a : d_array n Î±) (f : Î  (i : fin n), Î± i â†’ Î±' i) : d_array n Î±'
{Î± : Type u_1} {g g' : generalized_continued_fraction Î±} : g = g' â†” g.h = g'.h âˆ§ g.s = g'.s
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Prop
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] [is_trans Î± r] [is_antisymm Î± r] [is_total Î± r] (s : multiset Î±) : list Î±
{C : Type uâ‚} [category_theory.category C] {X : C} (ð’® : set (category_theory.sieve X)) : category_theory.sieve X
{R : Type u} [comm_monoid R] [star_semigroup R] : star_module R R
 : simps_cfg
{n : â„•} (x y : bitvec n) : Prop
(R : Type u_1) (A : Type u_2) [comm_semiring R] [comm_semiring A] [algebra R A] (M : Type u_3) [add_comm_monoid M] [module A M] [module R M] : Type (max u_2 u_3)
 : Type
{t : Type u â†’ Type u} {Î± : Type u} {f : Type u â†’ Type u} [applicative f] [traversable t] : t (f Î±) â†’ f (t Î±)
{Î± : Type u_2} [add_comm_monoid Î±] : add_comm_monoid (set Î±)
(Î± : Type u_2) [complete_lattice Î±] : complete_lattice_hom Î± Î±
 : has_one pgame
{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (h : s âŠ† t) (ht : metric.bounded t) : metric.diam s â‰¤ metric.diam t
{Î± : Type u_1} (s : finset Î±) : finset {x // x âˆˆ s}
(C : Type uâ‚) [category_theory.category C] : category_theory.comonad C
{Î± : Type u_2} [add_comm_semigroup Î±] : add_comm_semigroup (filter Î±)
{Î± : Type u_1} {Î² : Type u_2} (f : â„• â†’ Î± â†’ Î² â†’ Î±) : â„• â†’ Î± â†’ list Î² â†’ Î±
(C : Type u) [category_theory.category C] (n : â„•) : Type (max v u)
{n : â„•} : group (quaternion_group n)
{R : Type u} [ring R] {S T : subring R} (h : âˆ€ (x : R), x âˆˆ S â†” x âˆˆ T) : S = T
 : pgame â†’ ordinal
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {câ‚ câ‚‚ : Î± Ã— Î²} (p : path.homotopic.quotient câ‚ câ‚‚) : path.homotopic.quotient câ‚.snd câ‚‚.snd
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (X : C) : Type (max u v)
{Î± : Sort u} : well_founded empty_relation
{n : â„•} {F : Type u â†’ Type u} [applicative F] {Î± Î² : Type u} (f : Î± â†’ F Î²) : vector Î± n â†’ F (vector Î² n)
{Î± : Type u_1} {n : â„•} [decidable_eq Î±] (s : sym Î± (n + 1)) (a : Î±) (h : a âˆˆ s) : sym Î± n
(Î± : Type u_1) [group_with_zero Î±] : GroupWithZero
{Î± : Type u_2} {Î² : Type u_3} [complete_lattice Î±] [complete_lattice Î²] (f : complete_lattice_hom Î± Î²) : bounded_lattice_hom Î± Î²
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop
 : Type
{Î± : Type u_1} [topological_space Î±] : inhabited (topological_space.closeds Î±)
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) : Prop
{Î± : Type u} (P : Î± â†’ Prop) : ordnode Î± â†’ Prop
{Î± : Type u_2} [decidable_eq Î±] [comm_monoid Î±] : comm_monoid (finset Î±)
{Î± : Type u_1} (s : cycle Î±) : Prop
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) : Î² â†’ Î±
(u : pnat.xgcd_type) (hr : u.r â‰  0) : u.step.v = u.v.swap
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s âŠ† span_points k s
{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a < order.succ b â†’ a < b
{Î± : Type u_1} [linear_ordered_field Î±] {a : Î±} (a2 : 2 â‰¤ a) : (1 - 1 / a)â»Â¹ â‰¤ 2
(B : Type u) : Type (max u (v+1) (w+1))
{n : â„•} (F : typevec (n + 1) â†’ Type u_1) [mvfunctor F] [q : mvqpf F] (Î± : typevec n) : Type u_1
{Î± : Type u_1} (f : list Î± â†’ list Î±) : â„• â†’ list Î± â†’ list Î±
(M : Type u_2) [has_mul M] : group (mul_aut M)
(X : Type v) [topological_space X] : Prop
(Î± : Type u) [ring Î±] : Prop
{Î± : Type u_1} [Î² : normed_comm_ring Î±] : semi_normed_comm_ring Î±
 : Type (u_1+1)
{Î± : Type u_1} [preorder Î±] (a b : Î±) : Prop
{Î± : Sort u_1} {Î² : Sort u_2} (h : is_empty Î±) (a : Î±) : Î²
{Î± : Type u_1} [decidable_eq Î±] (l : list Î±) : finset Î±
{Î± : Type u_1} [lattice Î±] [order_bot Î±] {a b : Î±} (P : finpartition a) (h : a = b) : finpartition b
(Î± : Type u_1) : Type u_1
{Î± : Type u_3} [preorder Î±] (n : â„•) [grade_min_order (fin n) Î±] : grade_min_order â„• Î±
{Î± : Type u} (s : wseq Î±) (n : â„•) : wseq Î±
{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : turing.list_blank.cons l.head l.tail = l
(Î± : Type u_1) [uniform_space Î±] : Type u_1
(R : Type u) [non_assoc_semiring R] : Type u
{R : Type u} [semiring R] (n : â„•) (a : R) : polynomial R
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (b : B) : topological_fiber_bundle.trivialization F Z.proj
{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] : list Î± â†’ list Î±
 : list omega.ee â†’ omega.clause â†’ omega.clause
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (r : rel Î± Î²) (s : rel Î² Î³) : rel Î± Î³
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
(u v : binder_info) : bool
{M : Type u_1} [monoid M] {s : set M} (h : is_submonoid s) : submonoid M
(b x : ordinal) : ordinal
{Î± : Type u} [preorder Î±] (s : set Î±) : Prop
{E : â„• â†’ Type u_1} (x : Î  (n : â„•), E n) (s : set (Î  (n : â„•), E n)) : â„•
(a b : Prop) : Prop
{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c â‰¤ x â†” c â‰¤ ordinal.log b x
{A : Type u_3} [add_group A] (s : set A) : Prop
 : function.injective fin
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (d : add_con N) : add_con (M Ã— N)
{Î± : Type u_1} [inhabited Î±] (n : â„•) : list Î± â†’ list Î±
{M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : submodule k V
(Î± : Type u) : Type u
{n : Type u_3} {R : Type u_6} [fintype n] [add_comm_monoid R] (A : matrix n n R) : R
{Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} (x : Î±) (F : filter Î¹) (u : Î¹ â†’ Î±) : Prop
(T : Type u) [topological_space T] : category_theory.grothendieck_topology (topological_space.opens T)
 : Type
{R : Type u} {M : Type v} [ring R] [add_comm_group M] {module_M : module R M} (p : submodule R M) : add_subgroup M
(Î± : Type u_1) [fintype Î±] [nonempty Î±] : pmf Î±
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X â†’ Y) : Prop
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} [linear_order Î¹] (u : Î¹ â†’ Î± â†’ Î²) (Ï„ : Î± â†’ Î¹) : Î¹ â†’ Î± â†’ Î²
(G : Type u_1) [group G] : subgroup G
{G : Type w} [topological_space G] [has_inv G] [has_continuous_inv G] {Î¹ : Type u_1} : has_continuous_inv (Î¹ â†’ G)
 : parser â„•
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ list.nat.antidiagonal n â†” x.fst + x.snd = n
{Î± : Type u_1} [complete_lattice Î±] (k : Î±) : Prop
(Î¹ : Type v) : Type v
(Î± : Type u_1) [has_zero Î±] [has_one Î±] (n : â„•) : matrix.circulant (Î» (i : fin n), ite (â†‘i = 0) 1 0) = 1
 : Type
{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
(Î± : Type u) : Type u
{M : Type u_1} (S : set M) [semigroup M] : subsemigroup M
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (a : R) : Prop
{P : Type u_1} [preorder P] [order_bot P] : order_bot (order.ideal P)
{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] : category_theory.limits.has_equalizers C
{Î± : Type u} {Î² : Sort u_1} (f : Î² â†’ Î± â†’ Î²) : Î² â†’ ordnode Î± â†’ Î²
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) : Prop
{Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (g : Î² â†’ Î±) (f : Î± â†’ Î²) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C
(Î± : Type u) [topological_space Î±] : Prop
{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] : list Î± â†’ list Î± â†’ list Î±
{Î± : Type u_1} [denumerable Î±] : denumerable (plift Î±)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
(Î± : Type u_1) : enat
(ð•œ : Type u_5) [normed_field ð•œ] {E : Type u_1} {F : Type u_2} [semi_normed_ring E] [semi_normed_ring F] [normed_algebra ð•œ E] [normed_algebra ð•œ F] : normed_algebra ð•œ (E Ã— F)
(o : onote) : Prop
{Î± : Type u} : seq Î± â†’ wseq Î±
{F : Type u_1} [field F] (S : set F) : set F
(R : Type u) : Type u
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : 0 â‰¤ -a â†’ a â‰¤ 0
{Î± : Type u_1} [t : topological_space Î±] (s : set Î±) : Prop
(Î± : Type u_7) (Î² : Type u_8) [has_inf Î±] [has_inf Î²] [has_top Î±] [has_top Î²] : Type (max u_7 u_8)
{R : Type u} [ring R] (s : subring R) : 0 âˆˆ s
{K : Type u} [hring : comm_ring K] : ratfunc K
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : â†‘âŠ¥ = âˆ…
{Î± : Type u_1} [comm_semigroup Î±] {a b : Î±} (c : Î±) (h : c * a = b) : a âˆ£ b
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} : Type (max u_1 u_2)
(Î± : Type u_5) (Î² : Type u_6) [topological_space Î±] [topological_space Î²] : Type (max u_5 u_6)
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] : lazy_list Î± â†’ option Î±
{M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : a â‰¤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{Î± : Type u_2} {Î² : Type u_3} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) : Prop
(Î± : Type u_1) (Î² : Type u_2) [has_le Î±] [has_le Î²] : Type (max u_1 u_2)
{R : Type u} [ring R] {Î“â‚€ : Type v} [linear_ordered_comm_group_with_zero Î“â‚€] (v : valuation R Î“â‚€) : ring_subgroups_basis (Î» (Î³ : Î“â‚€Ë£), v.lt_add_subgroup Î³)
{X : Type u_1} [topological_space X] {x y : X} : inseparable x y â†’ nhds x = nhds y
(n : â„•) (Î± : fin n â†’ Type u) : Type u
(nm : name) (n : â„•) : name
{n : â„•} {Î± : Type u} {Î² : Type v} (a : array n Î±) (f : fin n â†’ Î± â†’ Î²) : array n Î²
{M : Type u_1} {Î± : Sort u_2} [add_comm_monoid M] (f : Î± â†’ M) : M
{Î± : Type u} {Î² : Type v} (R : Î± â†’ Î² â†’ Prop) (ca : computation Î±) (cb : computation Î²) : Prop
(G : Type u_1) [group G] : â„• â†’ subgroup G
{Î± : Type u} [partial_order Î±] [decidable_rel has_le.le] {a b : Î±} (hab : a â‰¤ b) : a = b âˆ¨ a < b
{Î± : Type u} {a b : Î±} [mul_zero_class Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ð•œ v) : linear_independent ð•œ v
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
(Î± : Type u) : Type (max 1 u)
(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C â„¤] : Type (max u v)
{Î± : Type u_1} (o : part Î±) : Î±
(M : Type u_1) [add_semigroup M] : add_subsemigroup M
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : alternating_map R (n â†’ R) R n
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) : Prop
{Î± : Type u_1} [decidable_eq Î±] (f : equiv.perm Î±) : Prop
 : Type
(Î± : Type u) : Type u
(l : Type u_4) (R : Type uâ‚‚) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (unit âŠ• l âŠ• l) (unit âŠ• l âŠ• l) R)
{Î± : Type u_1} : has_coe_t (finset Î±) (set Î±)
{Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_dist.dist x y = â†‘(has_nndist.nndist x y)
(R : Type u_1) (A : Type u_2) [comm_ring R] [comm_ring A] [algebra R A] : subalgebra R A
{Î± : Type u_1} [preorder Î±] (s : set Î±) : Prop
{Î± : Type u_1} [partial_order Î±] : subsingleton (succ_order Î±)
(M : Type u_1) [has_mul M] : galois_insertion subsemigroup.closure coe
(Î± : Type u_1) (Î² : Type u_2) [decidable_eq Î±] [fintype Î±] [encodable Î²] : trunc (encodable (Î± â†’ Î²))
{G : Type u_1} [group G] (T : set G) : set (set G)
{Î± : Sort u_1} {sâ‚ : setoid Î±} (a : Î±) : quotient sâ‚
{Î± : Type u} [topological_space Î±] (s : set Î±) : set Î±
(A : Type u) [comm_ring A] [is_domain A] [discrete_valuation_ring A] : valuation_ring A
 : setoid Well_order
 : Type
{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 2
 : Type
{R : Type u_2} [comm_semiring R] : has_coe (polynomial R) (power_series R)
{M : Type u_1} [monoid M] {sâ‚ sâ‚‚ : set M} (isâ‚ : is_submonoid sâ‚) (isâ‚‚ : is_submonoid sâ‚‚) : is_submonoid (sâ‚ âˆ© sâ‚‚)
{Î± : Type u} {Î² : Type v} (f : stream (Î± â†’ Î²)) (s : stream Î±) : stream Î²
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : set Î± â†’ Prop
(Î± : Type) : Type
{Mâ‚€ : Type u_1} [cancel_monoid_with_zero Mâ‚€] {a b : Mâ‚€} (hâ‚ : b â‰  1) (hâ‚‚ : b * a = a) : a = 0
{ð•œ : Type u_1} [is_R_or_C ð•œ] : inner_product_space ð•œ ð•œ
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 â†” subsingleton V
{Î± : Type u_1} (f g : Î± â†’ Î±) : Prop
{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M
{Î± : Type u_1} [partial_order Î±] [bounded_order Î±] [is_simple_order Î±] [decidable_eq Î±] : linear_order Î±
{Î± : Type u_1} {Î² : Type u_2} (p : two_pointing Î±) (q : two_pointing Î²) : two_pointing (Î± âŠ• Î²)
{Î± : Type u} : Î± â†’ ulift Î±
{Î± : Type u} (x : Î±) : ordnode Î± â†’ ordnode Î±
{Î± : Type u_4} {Î² : Type u_5} (r : Î± â†’ Î± â†’ Prop) (s : Î² â†’ Î² â†’ Prop) : Type (max u_4 u_5)
(c : cardinal) : Prop
(M : Type u_1) (Î± : Type u_2) : Type (max u_1 u_2)
{Î± : Type u_1} {Î² : Type u_2} [primcodable Î±] [primcodable Î²] (p : Î± â†’ Prop) (q : Î² â†’ Prop) : Prop
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
(J : Type uâ‚) : Type uâ‚
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} (h : x âˆˆ s) : metric.inf_dist x s = 0
{Îº : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] (b : Îº â†’ B) : matrix Îº Îº A
 : Type (u_1+1)
 : Type (u_1+1)
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a âˆ§ is_add_regular b
(Î± : Type u) [topological_space Î±] : Prop
{Î¹ : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] [topological_space R] (B : Î¹ â†’ submodule R M) : Prop
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J â†’ C) [category_theory.limits.has_biproduct f] : C
{R : Type u} [semiring R] : polynomial R â†’ â„• â†’ R
(d : pos_num) (q r : num) : num Ã— num
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : -a : Type
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (s : finmap Î²) : option (Î² a)
{n m : â„•} (i : fin (m * n)) : fin n
{ð•œ : Type u_1} {E : Type u_2} [ordered_ring ð•œ] [add_comm_group E] [module ð•œ E] (K : geometry.simplicial_complex ð•œ E) : set E
{Î± : Type u_1} {Î² : Type u_2} (p : two_pointing Î±) (q : two_pointing Î²) : two_pointing (Î± Ã— Î²)
{K : Type u_1} [field K] : ideal.is_jacobson K
{C : Type uâ‚} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A
{n : Type u_1} (p : Type u_2) {R : Type uâ‚‚} [decidable_eq n] [decidable_eq p] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct (n âŠ• p) R
{m n : â„•} {Î± : Type u_1} {o : â„•} (ho : o = m + n) (u : fin m â†’ Î±) (v : fin n â†’ Î±) : fin o â†’ Î±
 : fact (1 â‰¤ 1)
(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] : category_theory.limits.has_finite_colimits C
{Î± : Type u_1} : multiset (multiset Î±) â†’ multiset Î±
{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] (x : Î±) : âˆƒ (K : set Î±), is_compact K âˆ§ K âˆˆ nhds x
 : Type u â†’ cardinal
(l r : Type u) : bool â†’ Type u
{Î± : Type u_2} {Î² : Type u_3} [decidable_eq Î²] [monoid Î±] [mul_action Î± Î²] : mul_action Î± (finset Î²)
{X : Type u} [lattice X] [jordan_holder_lattice X] {sâ‚ sâ‚‚ : composition_series X} (h : âˆ€ (x : X), x âˆˆ sâ‚ â†” x âˆˆ sâ‚‚) : sâ‚ = sâ‚‚
{Î± : Type u_1} [decidable_eq Î±] (s : finset Î±) (a : Î±) : finset Î±
{p : bool â†’ Prop} [Î  (b : bool), decidable (p b)] : decidable (âˆƒ (b : bool), p b)
{Î± : Type u_1} {Î´ : Î± â†’ Sort u_2} (s : finset Î±) (f g : Î  (i : Î±), Î´ i) [Î  (j : Î±), decidable (j âˆˆ s)] (i : Î±) : Î´ i
{Î± : Sort u} [decidable_eq Î±] (a b : Î±) : equiv.perm Î±
{Î¹ : Type u_1} (M : Î¹ â†’ Type u_2) [Î  (i : Î¹), monoid (M i)] (i : Î¹) : Type (max u_1 u_2)
{Î± : Type u} (s : wseq Î±) (n : â„•) (a : Î±) : wseq Î±
{n : â„•} {F : typevec n â†’ Type u_1} [mvfunctor F] (q : mvqpf F) : Prop
(R : Type u) (X : Type v) [semiring R] : Type (max u v)
(Î± : Type u) {g : Type} [random_gen g] [random Î±] : rand_g g (stream Î±)
{Î± : Type u_1} (R : Î± â†’ Î± â†’ Prop) [decidable_rel R] : list Î± â†’ list Î±
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
{Î“ : Type u_1} [inhabited Î“] (lâ‚ lâ‚‚ : list Î“) : Prop
{G : Type u_3} [group G] (P : subgroup G) : Prop
{n : â„•} {Î± : Type u_1} {v : vector Î± (n + 1)} : v.last = v.nth (fin.last n)
{X : Type u} [topological_space X] {xâ‚€ xâ‚ xâ‚‚ : X} (Pâ‚€ : path.homotopic.quotient xâ‚€ xâ‚) (Pâ‚ : path.homotopic.quotient xâ‚ xâ‚‚) : path.homotopic.quotient xâ‚€ xâ‚‚
(n a b : â„•) : n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b
{Î± : Type u_1} {m m' : pseudo_metric_space Î±} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'
(Î± : Type u) [topological_space Î±] : Prop
{M : Type u_1} [add_monoid M] (a : M) : Prop
(Î± : Type u) {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] (b : Î²) : bounded_continuous_function Î± Î²
{Î± : Type u_1} (s : set (set Î±)) : set Î± â†’ Prop
{M : Type u_1} [hM : comm_monoid M] (h : âˆ€ (a : M), is_unit a) : comm_group M
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)
 : snum â†’ bool
{X : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topological_space X] (f : locally_constant X (Î± â†’ Î²)) (a : Î±) : locally_constant X Î²
{R : Type u} [ring R] : complete_lattice (subring R)
(n : â„•) (a : fin n) (b : â„•) : Prop
{X : Type u_1} [topological_space X] (x y : X) : Prop
(x y : pgame) : Prop
{Î± : Type u} [add_monoid Î±] : add_group (add_units Î±)
{M : Type u_1} (S : set M) [monoid M] : submonoid M
{M : Type u_1} [has_add M] (S : add_subsemigroup M) (s : set M) (hs : s = â†‘S) : add_subsemigroup M
(Î± : Type u_2) [comm_monoid_with_zero Î±] : Prop
{Î± : Type u} [mul_one_class Î±] : is_monoid_hom id
 : Type (u_1+1)
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ â„• â†’ option â„•
{n : â„•} (c : composition_as_set n) : list â„•
{Î± : Type u_2} {Î² : Type u_3} [complete_lattice Î±] [complete_lattice Î²] (f : frame_hom Î± Î²) : lattice_hom Î± Î²
{n : â„•} {F : typevec n â†’ Type v} [mvfunctor F] {Î± : typevec n} (p : Î  (i : fin2 n), Î± i â†’ Prop) (x : F Î±) : Prop
{R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : â„•) (r : R) : â„¤
 : â„• â†’ Type
{Î± : Type u_1} (y : Î±) : fintype {x // y = x}
{Î± : Type u} [hg : group Î±] [is_cyclic Î±] : comm_group Î±
(Î± : Type u_1) : set (Î± Ã— Î±)
{R : Type u} [semiring R] : polynomial R
(p : â„•) (G : Type u_1) [group G] : Type u_1
(C : Type u) [category_theory.category C] : Prop
{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : matrix n n (polynomial R)
{n : Type u_1} {R : Type uâ‚‚} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix n n R
 : Set
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.is_equivalence (category_theory.shift_functor C i)
(u : pnat.xgcd_type) : â„• Ã— â„•
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1
 : Type (u_1+1)
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : Prop
 : ordinal
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) : list (sigma Î²) â†’ list (sigma Î²)
{p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p
{G : Type u_1} [has_add G] : G â†’ G â†’ G
(Î± : Type u) : Type u
{R : Type u_1} {S : Type u_3} [distrib R] [distrib S] : distrib (R Ã— S)
{F : Type u â†’ Type u} [functor F] {Î± : Type u} (r : Î± â†’ Î± â†’ Prop) (x y : F Î±) : Prop
 : Type
(Î± : Type u_5) (Î² : Type u_6) [uniform_space Î±] [uniform_space Î²] : Type (max u_5 u_6)
{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a
{Î± : Type u_1} [measurable_space Î±] : set Î± â†’ Prop
{Î² : Type w} {C : Type u} [category_theory.category C] [unique Î²] (f : Î² â†’ C) : category_theory.limits.colimit_cocone (category_theory.discrete.functor f)
{Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] [measurable_space Î³] [borel_space Î³] {s : set Î³} : polish_space.is_clopenable s â†” measurable_set s
(Î± : Type u) : Type u
{G : Type u_1} [add_group G] : has_top (add_subgroup G)
{Î± : Type u} [inhabited Î±] : â„• â†’ list Î± â†’ Î±
{Î¹ : Type u_1} {Z : Î¹ â†’ Type u_2} [Î  (i : Î¹), canonically_ordered_add_monoid (Z i)] : canonically_ordered_add_monoid (Î  (i : Î¹), Z i)
{Î± : Sort uâ‚} (Î² : Sort uâ‚‚) (a : Î±) : Î² â†’ Î±
{G : Type u_1} [group G] (H : subgroup G) : Prop
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†’ 0 < a
{M : Type u_1} [monoid M] {s : set M} : s âŠ† monoid.closure s
{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Prop
{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : has_top (submodule R M)
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [topological_space Î±] [topological_space Î²] : Type (max u_6 u_7 u_8)
(M : Type u_1) {Î± : Type u_2} [monoid M] [mul_action M Î±] (s : set Î±) : submonoid M
{n : â„•} (x : bitvec n) : bitvec n
{M : Type u_1} (S : set M) [has_add M] : set M
{Î± : Type u_1} : has_add (language Î±)
(X : Type u_4) [topological_space X] : Prop
{Î³ : Type w} [semilattice_sup Î³] {s t : set Î³} : bdd_above (s âˆª t) â†” bdd_above s âˆ§ bdd_above t
(Î± : Type u) : Type u
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†’ 1 â‰¤ a
(p : â„•) [hp : fact (nat.prime p)] : â„• â†’ mv_polynomial (fin 0 Ã— â„•) â„¤
{Î“ : Type u_1} {R : Type u_2} [partial_order Î“] [has_zero R] [has_zero Î“] (x : hahn_series Î“ R) : Î“
 : has_zero pgame
{Î± : Type u} : seq Î± â†’ seq Î±
(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)
 : Type
{Î± : Type u} [has_add Î±] : add_hom Î± (with_zero Î±)
{Î± : Type u_1} (L L' : list (list Î±)) : L = L' â†” L.join = L'.join âˆ§ list.map list.length L = list.map list.length L'
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (l : finset Î±) (hp : âˆƒ! (a : Î±), a âˆˆ l âˆ§ p a) : {a // a âˆˆ l âˆ§ p a}
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [preorder Î±] [preorder Î²] [mul_zero_one_class Î±] [mul_zero_one_class Î²] : Type (max u_6 u_7 u_8)
(C : Type u) [category_theory.category C] : Prop
 : Type
 : Type
{ð•œ : Type u_1} {F : Type u_3} [is_R_or_C ð•œ] [add_comm_group F] [module ð•œ F] [c : inner_product_space.core ð•œ F] : has_norm F
 : Type (u+1)
{C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C) : Type (max u v)
 : Type (u+1)
{M : Type u} [has_mul M] (a x y : M) : Prop
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_one M] [has_one N] : Type (max u_10 u_11 u_9)
(F : pfunctor) : â„• â†’ Type u
{Î± : Type u_1} [comm_ring Î±] (E : linear_recurrence Î±) : polynomial Î±
{V : Type u} (G : simple_graph V) (n : â„•) : Prop
(b o : ordinal) : list (ordinal Ã— ordinal)
(Î± : Type u) [has_add Î±] : Type u
 : nzsnum â†’ nzsnum
{R : Type u_1} [comm_ring R] [H : topological_space R] (J : ideal R) : Prop
{a : Type u} : bool â†’ a â†’ a â†’ a
(n : â„•) : â„•
(L : first_order.language) (Î± : Type u') : Type (max u u')
(Î± : Type u_1) : Type u_1
{Î± : Type u} (x : free_comm_ring Î±) (s : set Î±) : Prop
(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A) : subalgebra R A
{Î± : Type u_1} : part Î±
(X : Top) (T : Type u) : Top.sheaf (Type u) X
(R : Type u_1) [has_mul R] [has_add R] : Type u_1
(G H : AddCommGroup) : category_theory.limits.limit_cone (category_theory.limits.pair G H)
 : num â†’ num
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (Î± : Type u_1) [add_right_cancel_semigroup Î±] [has_one Î±] : Type (max u u_1 v)
{Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_dist.dist â†‘x â†‘y = has_dist.dist x y
{Î± : Sort u} {Î² : Sort v} (a : plift Î±) (f : Î± â†’ plift Î²) : plift Î²
{n : â„•} {Î² : Type u_1} (q : fin (n + 2) â†’ Î²) : fin.tail (fin.init q) = fin.init (fin.tail q)
(K : Type u) [field K] : galois_insertion subfield.closure coe
{ð•‚ : Type u_1} [is_R_or_C ð•‚] : has_deriv_at (exp ð•‚) 1 0
{Î± : Type u} {Î² : Type v} [uniform_space Î±] [semilattice_sup Î²] [complete_space Î±] {u : Î² â†’ Î±} (H : cauchy_seq u) : âˆƒ (x : Î±), filter.tendsto u filter.at_top (nhds x)
(Î± : Type u_3) [topological_space Î±] [has_le Î±] : Type u_3
{Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ set Î±} (hs : indexed_partition s) : setoid Î±
{Î± : Sort u} {Î² : Sort v} (f : plift (Î± â†’ Î²)) (x : plift Î±) : plift Î²
{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)
(Î± : Type u_1) : Type u_1
 : Type
(Î“ : Type u_1) [inhabited Î“] : Type u_1
 : function.surjective real.sinh
(Î± : Type u_4) [bornology Î±] : Prop
 : category_theory.limits.has_limits_of_size AddMon
{n : â„•} {Î± : Type u} (a : array n Î±) (v : Î±) : array (n + 1) Î±
{Î± : Type u_1} [topological_space Î±] [baire_space Î±] {s : set Î±} : s âˆˆ residual Î± â†” âˆƒ (t : set Î±) (H : t âŠ† s), is_GÎ´ t âˆ§ dense t
(C : Type (u+1)) : Type (u+1)
{Î± : Type u} [topological_space Î±] {f : filter Î±} {a : Î±} : f â‰¤ nhds a â†” âˆ€ (s : set Î±), a âˆˆ s â†’ is_open s â†’ s âˆˆ f
(Î± : Type u_1) [measurable_space Î±] : Type u_1
{Î± : Type u} [comm_semiring Î±] {p p' ps ps' : Î±} : p = p' â†’ ps = ps' â†’ p * ps = p' * ps'
(Î± : Type u_8) (Î² : Type u_9) [complete_lattice Î±] [complete_lattice Î²] : Type (max u_8 u_9)
(Î± : Type u_3) [topological_space Î±] : Prop
{R : Type u} [comm_semiring R] {A : Type u_1} [ring A] [algebra R A] : has_distrib_neg (submodule R A)
(b : â„•) : â„• â†’ â„•
{m : Type u â†’ Type u_1} [monad m] {Î± : Type u_2} {Î² : Type u} (f : Î± â†’ m Î²) {n : â„•} : vector Î± n â†’ m (vector Î² n)
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0
{C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : Prop
{Î± : Type u_4} {Î² : Type u_5} (r : Î± â†’ Î± â†’ Prop) (s : Î² â†’ Î² â†’ Prop) : Type (max u_4 u_5)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.is_initial 0
{Î± : Type u_1} {Î² : Type u_2} [has_le Î±] (s : Î± â†’ set Î²) (x : Î±) : set Î²
{C : Type uâ‚} [category_theory.category C] : category_theory.full category_theory.yoneda
(Î± : Type u) (Î² : Type v) [monoid Î±] [mul_action Î± Î²] (g : Î±) : set Î²
{Î± : Type u} : Î± â†’ ordnode Î± â†’ Î±
(T : Type u_1) : Type u_1
(n k : â„•) : Prop
(Î± : Type u) [preorder Î±] : Type u
{Î± : Type u_1} [is_empty Î±] : fintype.card Î± = 0
(Î± : Type u) : Type u
{n : â„•} (i : fin2 n) (v : typevec n) : Type u
(G : Type u_1) [has_neg G] [measurable_space G] : Prop
(R : Type u_1) (S : Type u_2) (A : Type u_4) [semiring A] [comm_semiring S] [algebra S A] [comm_semiring R] [algebra R S] : algebra R (restrict_scalars R S A)
{Î± : Type u_1} (g : generalized_continued_fraction Î±) : seq Î±
{Î± : Type u_1} {m : multiset Î±} {p : Î± â†’ Prop} [hp : Î  (a : Î±), decidable (p a)] : decidable (âˆ€ (a : Î±), a âˆˆ m â†’ p a)
{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1
{Î± : Type u_1} {Î² : Type u_2} : â„• â†’ list Î± â†’ (list Î± â†’ Î²) â†’ list Î² â†’ list Î²
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} (s : finset Î¹) (t : Î  (i : Î¹), finset (Î± i)) : finset (Î£ (i : Î¹), Î± i)
 : Type
{K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K] : continued_fraction K
(z : â„¤) : â„¤
(R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M] : Prop
(n : â„•) : bitvec n
(Î± Î² : cardinal) : cardinal
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} (f : Î± â†’ Î² â†’ Î³) (s : set Î±) (t : set Î²) : set Î³
{Î± : Type u} (a : Î±) : wseq Î±
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} (B : bilin_form R M) (v : n â†’ M) : Prop
{C : Type uâ‚} [category_theory.category C] (X : C) : category_theory.limits.cone (category_theory.functor.empty C)
(Î± : Type u_3) {Î² : Type u_4} [has_sup Î±] [semilattice_sup Î²] (b : Î²) : sup_hom Î± Î²
{R : Type u_1} [semiring R] (n : â„¤) : laurent_polynomial R
 : num â†’ list bool
 : Type (u+1)
{Î± : Type u_3} (s : set Î±) : Type u_3
(R : Type u) [comm_ring R] : Type (max u (v+1))
(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v â‰  0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _
{K : Type u} [field K] (s : subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s
{Î¹ : Type u_1} {f : Î¹ â†’ Type u_2} [Î  (i : Î¹), has_add (f i)] (C : Î  (i : Î¹), add_con (f i)) : add_con (Î  (i : Î¹), f i)
{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a
{Î± : Type u_1} {Î² : Type u_2} (lâ‚ : list Î±) (lâ‚‚ : list Î²) : list (Î± Ã— Î²)
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : wseq Î± â†’ wseq Î²
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [preorder Î±] [preorder Î²] [topological_space Î±] [topological_space Î²] : Type (max u_6 u_7 u_8)
 : ordinal â†’ cardinal
{n m : â„•} (i : fin (m * n)) : fin m
{Râ‚ : Type u_4} [comm_ring Râ‚] {n : Type u_5} (i j : n) : quadratic_form Râ‚ (n â†’ Râ‚)
{Î± : Type u} : ordnode Î± â†’ â„• â†’ ordnode Î±
{Î± : Type u_1} (s : multiset Î±) : multiset (multiset Î±)
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} {Î´ : Type u_2} (r : Î± â†’ Î³ â†’ Prop) (s : Î² â†’ Î´ â†’ Prop) : Î± âŠ• Î² â†’ Î³ âŠ• Î´ â†’ Prop
{Î± : Type u_1} [decidable_eq Î±] (s t : multiset Î±) : multiset Î±
{Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} (hf : is_ring_hom f) : f 0 = 0
(R : Type u_1) (a b : R) : Type u_1
{Î± : Type u} {m : â„•} (x : Î±) (u : fin m.succ â†’ Î±) : matrix.vec_cons x u 1 = matrix.vec_head u
{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) : nontrivial Î²
(Î± : Type u_6) (Î² : Type u_7) [bornology Î±] [bornology Î²] : Type (max u_6 u_7)
(Î± : Sort u) : Sort (max (imax (v+1) u) (v+2))
(Î± : Type u_1) [preorder Î±] : simple_graph Î±
(r n : â„•) : n.choose r â‰¤ n.choose (n / 2)
{R : Type u} [comm_semiring R] [nontrivial R] (h : âˆ€ (a b : R), a âˆˆ nonunits R â†’ b âˆˆ nonunits R â†’ a + b âˆˆ nonunits R) : local_ring R
{C : Type u_1} [category_theory.category C] : category_theory.category (category_theory.idempotents.karoubi C)
{Î± : Type u} [add_zero_class Î±] : is_add_monoid_hom id
(Î± : Sort u) (Î² : Î± â†’ Sort v) : Sort (imax u v)
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : cardinal
{f : â„• â†’ â„•} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top
{Î¹ : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering Î¹ X s) (x : X) (hx : x âˆˆ s) : Î¹
(R : Type u_1) : Type u_1
(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)
{Î± : Type u_1} (sel : set Î± â†’ option Î±) : set Î± â†’ â„• â†’ option Î±
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (s' s : multiset Î±) : Prop
{R : Type u_1} [comm_ring R] {Î¹ : Type u_2} [fintype Î¹] [ideal.is_jacobson R] : ideal.is_jacobson (mv_polynomial Î¹ R)
{Î± : Type u_1} {Î² : Type u_2} : Î± Ã— Î² â†’ Î² Ã— Î±
(Î± : Type u) : Type u
{Î± : Type u} : â„• â†’ stream Î± â†’ list Î±
 : pSet â†’ pSet â†’ Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_zero_object C
(Î± : Type u_3) : Prop
(Î± : Type u_1) [fintype Î±] [encodable Î±] : list Î±
{Î± : Type u_1} {A B : finset Î±} (i : â„•) (hâ‚ : i + B.card â‰¤ A.card) (hâ‚‚ : B âŠ† A) : âˆƒ (C : finset Î±), B âŠ† C âˆ§ C âŠ† A âˆ§ C.card = i + B.card
(Pâ‚‚ Pâ‚ : pfunctor) : pfunctor
(M : Type u_1) [monoid M] : submonoid M
{C : Type u} [category_theory.category C] : C â†’ C â†’ Prop
 : lattice â„•
(M : Type u_4) [has_add M] : Type u_4
(Î± : Type u) [uniform_space Î±] : Type u
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop
{Î± : Type u} : ordnode Î± â†’ â„• â†’ ordnode Î±
 : Type
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (m : hash_map Î± Î²) : list Î±
{Î± : Type u} [topological_space Î±] {Î² : Type u_1} [topological_space Î²] {f : Î± â†’ Î²} (h : continuous f) : connected_components Î± â†’ connected_components Î²
{Î± : Type u_1} {p : Î± â†’ Prop} (s : finset Î±) (H : âˆ€ (x : Î±), x âˆˆ s â†” p x) : fintype {x // p x}
{M : Type u_1} {Î¹ : Type u_2} (R : Type u_3) [decidable_eq M] [comm_semiring R] (f : M â†’ Î¹) (i : Î¹) : submodule R (add_monoid_algebra R M)
(Î± : Type u) (r : Î± â†’ Î± â†’ Prop) : Prop
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {Î´ : Î± â†’ Type u_4} (t : Î  (a : Î±), finset (Î´ a)) : finset (Î  (a : Î±), Î´ a)
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [preorder Î±] [preorder Î²] [add_zero_class Î±] [add_zero_class Î²] : Type (max u_6 u_7 u_8)
(C : Type u) [category_theory.category C] : Prop
{R : Type u_1} [add_zero_class R] : is_add_regular 0
{Î± : Type u_1} (s : finset Î±) : â„•
{X : Type u_1} [has_repr X] : has_repr (alexandroff X)
{Î± : Sort u} {Î² : Sort v} (f : Î± â†’ Î²) (a : plift Î±) : plift Î²
{V : Type u} (G : simple_graph V) : Type u
{R : Type u_1} [mul_zero_class R] [nontrivial R] : Â¬is_regular 0
{m : Type â†’ Type v} [monad m] : list (m bool) â†’ m bool
{G : Type u_1} [add_comm_group G] (B : add_group_filter_basis G) : uniform_space G
{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] [t2_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (V : set Î±), is_open V âˆ§ K âŠ† V âˆ§ is_compact (closure V)
 : pSet
{Î± : Type u_1} (s : finset Î±) [decidable_eq Î±] : finset (Î± Ã— Î±)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
{p q r : Prop} (hâ‚ : implies p q) (hâ‚‚ : implies q r) : implies p r
{Î± : Type u_2} [has_involutive_inv Î±] : has_involutive_inv (filter Î±)
{Î± : Type u_1} [linear_ordered_field Î±] {Î² : Type u_2} [ring Î²] (abv : Î² â†’ Î±) [is_absolute_value abv] (x : Î²) : cau_seq Î² abv
{Î± : Type u} [partial_order Î±] [decidable_rel has_le.le] {a b : Î±} (hab : a â‰¤ b) : a < b âˆ¨ a = b
{Î± : Type u_1} (a : Î±) (s : multiset Î±) : Prop
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†’ a < b
(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) (i : Î¹) : finset.centroid_weights k s i = (â†‘(s.card))â»Â¹
{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a â‰¤ b) (hbc : b = c) : a â‰¤ c
{B : Type u_1} {B' : Type u_3} (f : B' â†’ B) (E : B â†’ Type u_2) (x : B') : Type u_2
 : pSet â†’ Type u
(m : â„¤) {n : â„¤} (hn : 0 < n) : (âˆƒ (k : â„¤), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m
 : has_pow cardinal cardinal
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_module R L L
 : Type
(l : Type u_4) (R : Type uâ‚‚) [decidable_eq l] [comm_ring R] : matrix (l âŠ• l) (l âŠ• l) R
(o : ordinal) (f : Î  (b : ordinal), b < o â†’ ordinal â†’ ordinal) : ordinal â†’ ordinal
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y
(Î± : Type u_2) [preorder Î±] [pred_order Î±] : Prop
 : Type (u_1+1)
{m : Type u_2} {n : Type u_3} {Î± : Type v} [has_star Î±] (M : matrix m n Î±) : matrix n m Î±
(X Y : Bipointed) : Type u
(C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C
{n : â„•} {p q : â„• Ã— â„•} (hp : p âˆˆ finset.nat.antidiagonal n) (hq : q âˆˆ finset.nat.antidiagonal n) : p = q â†” p.fst = q.fst
{n : â„•} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4
(Î± : Type u) [pseudo_metric_space Î±] : Prop
(Î± : Type u) [has_mul Î±] : Î± â†’ Î± â†’ Prop
{R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) â†” is_add_regular a âˆ§ is_add_regular b
(G : Type u_10) (P : Type u_11) [has_vadd G P] : Prop
{Î± : Type u_2} [has_one Î±] [has_mul Î±] [has_inv Î±] : has_pow (set Î±) â„¤
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] : list Î± â†’ list Î±
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hfg : function.is_fixed_pt (f âˆ˜ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x
(E : Type u_6) : Type u_6
(G : Type u) : Type u
 : has_mul nonote
(P : â„• â†’ Prop) [decidable_pred P] : enat
{Î± : Type u_1} [has_star Î±] : has_star (set Î±)
{Î¹ : Type u_1} (A : Î¹ â†’ Type u_2) [has_zero Î¹] : Type u_2
(R : Type u_1) [has_mul R] [has_add R] : Type
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Prop
{Î± : Type u} [is_empty Î±] : unique (set Î±)
(K : Type u) [comm_ring K] (p : â„•) [fact (nat.prime p)] [char_p K p] : Type u
(Î± : Type u_5) [has_norm Î±] [has_one Î±] : Prop
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) : Prop
{Î± : Type u_1} [has_zero Î±] [has_one Î±] [has_neg Î±] : sign_type â†’ Î±
(s : char_buffer) : parser unit
{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] : has_zero (zero_hom M N)
{C : Type u} [category_theory.category C] : complete_lattice (category_theory.grothendieck_topology C)
 : â„• â†’ num â†’ num â†’ num
{C : Type u_1} [category_theory.category C] (P Q : category_theory.idempotents.karoubi C) : Type u_2
(R : Type u) {X : Type v} [comm_ring R] : X â†’ free_lie_algebra R X
 : pgame â†’ pgame â†’ Type (u+1)
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : a < bâ»Â¹ â†’ b < aâ»Â¹
(c1 c2 : omega.clause) : omega.clause
{m n : â„•} : (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (l : multiset Î±) (hp : âˆƒ! (a : Î±), a âˆˆ l âˆ§ p a) : Î±
 : num â†’ num
{Î± : Type u} : list Î± â†’ ordnode Î±
{Î± : Type u_1} [decidable_eq Î±] (s t : multiset Î±) : multiset Î±
(C : Type u_1) [quiver C] : Sort (max (u_1+1) u_2 1)
{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X â†’ Y} (hf : embedding f) : topological_space.metrizable_space X
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [metric_space Î²] : metric_space (bounded_continuous_function Î± Î²)
{Î± : Type u_1} : ((Î± â†’ â„•) â†’ â„¤) â†’ Prop
{Î± : Type u_1} [preorder Î±] (a : Î±) : set Î±
{n : â„•} {Î± : Type u_1} {v : vector Î± (n + 1)} : v.reverse.head = v.last
{n : â„•} {Î± : Type u_1} (v : vector Î± n) : vector Î± n
{H : Type u} [topological_space H] : order_top (structure_groupoid H)
{R : Type u_1} [semiring R] (f : polynomial R) : polynomial R
{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c
{Î± : Type u} [add_group Î±] : is_add_group_hom id
{M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
{Î± : Type u_1} (s : set (sym2 Î±)) (x y : Î±) : Prop
{Î± : Type u_1} [preorder Î±] (a : Î±) : set Î±
(p : â„•) : zmod (2 ^ p - 1)
(G : Type u_1) [group G] [topological_space G] : Type u_1
{F : Type u â†’ Type v} [applicative F] [is_lawful_applicative F] : applicative_transformation F F
(C : Type u) (A : Type u_2) [category_theory.category C] [add_monoid A] : Type (max u u_2 v)
{R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R
{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : category_theory.comonad C
{Î± : Type u_1} [add_group Î±] (s : add_subgroup Î±) : setoid Î±
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) (s : set Î±) : Prop
{Î± : Type u_1} [preorder Î±] [order_top Î±] [locally_finite_order Î±] (a : Î±) : finset Î±
 : two_pointing bool
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] : ordnode Î± â†’ ordnode Î±
(L : first_order.language) : cardinal
{G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G
(H : Type u_1) (H' : Type u_2) : Type (max u_1 u_2)
{Î² : Type u_2} {Î¹ : Sort u_4} (s : Î¹ â†’ set Î²) : set Î²
{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : 0 = a * b â†” a = 0 âˆ¨ b = 0
(R : Type u) [semiring R] : Prop
{Î± : Type u} : dense_inducing has_pure.pure
 : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : Type u_3
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q) : category_theory.limits.cocone (category_theory.limits.pair P Q)
{G : Type u_1} [group G] : has_top (subgroup G)
{X : Type u_1} [topological_space X] {Î± : Type u_2} (f : locally_constant X Î±) : discrete_quotient X
{Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} {x : Î±} (hf : is_ring_hom f) : f (-x) = -f x
{Î± : Type u_1} {Î² : Type u_4} [partial_order Î±] [preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : galois_connection l u) : closure_operator Î±
{Î± : Type u_1} {A B : set (finset Î±)} {r : â„•} : set.sized r A âˆ§ set.sized r B â†’ set.sized r (A âˆª B)
 : num â†’ â„• â†’ num
{G : Type u_10} [add_group G] (a : G) : equiv.perm G
{n : â„•} (i : zmod n) : order_of (dihedral_group.sr i) = 2
(M : Type u) [topological_space M] [has_add M] : Prop
(Î± : Type u) : Type u
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} (s : set Î¹) (t : Î  (i : Î¹), set (Î± i)) : set (Î  (i : Î¹), Î± i)
 : Type (u_1+1)
{Î± : Type u_1} [primcodable Î±] (p : Î± â†’ Prop) [decidable_pred p] : Prop
{Î± : Type u_1} [has_zero Î±] [has_one Î±] [has_add Î±] : â„• â†’ Î±
{Î± : Sort u} {Î² : Sort v} : function.injective coe_fn
{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a â‰¤ order.succ b â†’ a â‰¤ b
(x y : Set) : Set
{Î± : Type u} {n : â„•} [has_repr Î±] : has_repr (fin n â†’ Î±)
{Î± : Type u_1} {Î² : Type u_2} [encodable Î²] (f : Î± â†’ Î²) (hf : function.injective f) : encodable Î±
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [is_preorder Î± r] : Î± â†’ antisymmetrization Î± r
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] : galois_insertion (algebra.adjoin R) coe
{m n : â„•} : m âˆ£ n + m â†” m âˆ£ n
(V : Type u) : Type (max u v)
{Î± : Type u_1} [comm_semiring Î±] (t : tree Î±) : tactic.ring2.csring_expr â†’ Î±
{Î± : Type u} (f : Î± â†’ Î±) (a : Î±) : stream Î±
(Î± : Type) : Type
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) (s : set Î±) (x : Î±) : Prop
{M : Type u_1} [add_zero_class M] : has_bot (add_submonoid M)
{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)
{G : Type u_2} [group G] : has_inv (submonoid G)
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : â„• â†’ add_localization S â†’ add_localization S
{Î± : Type u_2} [has_sub Î±] : has_sub (set Î±)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J â†’ C} (B : category_theory.limits.bicone F) : category_theory.limits.cone (category_theory.discrete.functor F)
{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] : wide_subquiver V
{Î± : Type u_1} [conditionally_complete_lattice Î±] (f : filter Î±) : Î±
{H : Type u} [topological_space H] : partial_order (structure_groupoid H)
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : 0 â‰¤ a - b â†’ b â‰¤ a
{B : Type u_1} {E : B â†’ Type u_2} (b : B) (a : E b) : bundle.total_space E
{p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : p n â†’ nat.count p (n + 1) = nat.count p n + 1
 : Type
{n : â„•} {Î± : Type u} {Î² : Type v} (a : array n Î±) (b : Î²) (f : fin n â†’ Î± â†’ Î² â†’ Î²) : Î²
(a b : â„•) : a - b.succ = a - b - 1
(P : Type u_2) [preorder P] : Type u_2
{Î± : Type u} (l : ordnode Î±) (x : Î±) : ordnode Î± â†’ ordnode Î±
{M : Type u_1} [has_mul M] (c : con M) : Type u_1
{n : â„•} [h : fact (0 < n)] (i : â„•) : fin n
{Î± : Type u_1} [preorder Î±] (a : Î±) : lower_set Î±
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (hC : category_theory.skeletal C) : monoid C
 : Type (u+1)
{Î± : Type u_1} {Î² : Type u_2} [primcodable Î±] [primcodable Î²] (p : Î± â†’ Prop) (q : Î² â†’ Prop) : Prop
{Î² : Type u_2} (f : equiv.perm Î²) (x y : Î²) : Prop
{Î± : Type u_2} [decidable_eq Î±] [division_comm_monoid Î±] : division_comm_monoid (finset Î±)
{Î± : Type u_1} {Î² : Type u_4} [preorder Î±] [preorder Î²] {u : Î² â†’ Î±} (l : lower_adjoint u) : Î± â†’ Î²
(X Y : Type u) : category_theory.limits.cocone (category_theory.limits.pair X Y)
{Î± : Type u} (p : Î± â†’ Prop) (f : filter Î±) : Prop
{Î± : Type u_1} {n : Type u_4} [non_unital_semiring Î±] [star_ring Î±] (A : matrix n n Î±) : Prop
(G : Type u) [comm_group G] : CommGroup
(C : Type u) [category_theory.category C] : Type (max u (v+1))
{Î± : Type u_1} [preorder Î±] (Ixx : Î± â†’ Î± â†’ set Î±) (lâ‚ : filter Î±) (lâ‚‚ : out_param (filter Î±)) : Prop
{Î± : Type} (p : parser Î±) : Prop
 : first_order.language
 : Type (u_1+1)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop
{Î± : Sort u} {f : Î± â†’ Î±} (h : function.involutive f) {x y : Î±} : f x = y â†” x = f y
{n : â„•} [fact (0 < n)] (a : zmod n) : â†‘(a.val) = a
{M : Type u_1} [hM : monoid M] (h : âˆ€ (a : M), is_unit a) : group M
{Î± : Type u_1} [metric_space Î±] {Î² : Type u} [nonempty Î²] (p : besicovitch.tau_package Î² Î±) (i : ordinal) : set Î±
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_ideal R L
 : principal_seg has_lt.lt has_lt.lt
{Î± : Type u} : ordnode Î± â†’ ordnode Î±
 : nat.arithmetic_function â„•
(p : â„•) : Prop
{Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] [nontrivial Mâ‚€] [no_zero_divisors Mâ‚€] {L : list Mâ‚€} : L.prod = 0 â†” 0 âˆˆ L
{M : Type u_1} [add_monoid M] [distrib_mul_action ennreal M] : distrib_mul_action nnreal M
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
(M : Type u_1) [monoid M] : Prop
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] : ordnode Î± â†’ ordnode Î± â†’ ordnode Î±
{R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g
{C : Type uâ‚} [category_theory.category C] {X : C} (t : category_theory.limits.is_terminal X) : category_theory.limits.is_initial (opposite.op X)
(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))
(R : Type u) [ring R] [nontrivial R] [is_noetherian_ring R] : strong_rank_condition R
{Î± : Type u_1} : complete_lattice (subtype setoid.is_partition)
{Î± : Type u_1} : lazy_list Î± â†’ lazy_list Î± â†’ lazy_list Î±
{Î± : Type u} [uniform_space Î±] {f : filter Î±} {x : Î±} (hf : cauchy f) (adhs : cluster_pt x f) : f â‰¤ nhds x
(F : Type u_5) (Î± : out_param (Type u_6)) (Î² : out_param (Type u_7)) [non_assoc_semiring Î±] [non_assoc_semiring Î²] : Type (max u_5 u_6 u_7)
{Î± : Type u} [decidable_eq Î±] (xs : list Î±) (h : âˆ€ (x : Î±), x âˆˆ xs) : fin_enum Î±
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : function.injective equiv.perm.cycle_factors_finset
{p : â„•} : summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p
 : Type
{Râ‚ : Type u_4} [comm_ring Râ‚] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form Râ‚ (n â†’ Râ‚)) : Râ‚
{Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_min_order Î±] : infinite Î±
(Î± : Type u_1) (r : Î± â†’ Î± â†’ Prop) : Prop
(e a0 a : onote) : â„• â†’ â„• â†’ onote
{p : â„•} {R : Type u_1} [comm_ring R] (P : â„• â†’ Prop) (x : witt_vector p R) : witt_vector p R
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [bornology Î±] [bornology Î²] [bornology Î³] (f : locally_bounded_map Î² Î³) (g : locally_bounded_map Î± Î²) : locally_bounded_map Î± Î³
{M : Type u_1} (S : set M) [add_monoid M] : add_submonoid M
(p : â„•) : â„•
{Î± : Type u_1} [preorder Î±] (lo : with_bot Î±) (t : ordnode Î±) (hi : with_top Î±) : Prop
{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x
(E : Type u_4) [non_unital_normed_ring E] [star_ring E] : Prop
(G : Type u_1) [add_group G] [topological_space G] : Prop
(Î± : Type u_2) [bornology Î±] : locally_bounded_map Î± Î±
(Î± : Type u_3) [measurable_space Î±] (M : Type u_4) [add_comm_monoid M] [topological_space M] : Type (max u_3 u_4)
{Î± : Type u} : â„• â†’ seq Î± â†’ list Î± Ã— seq Î±
{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b â†” b < a
{n : â„•} (c : composition_as_set n) : â„•
{Î± : Type u_1} (s : set Î±) (r : Î± â†’ Î± â†’ Prop) : Prop
 : onote
{Î± : Type u_2} [preorder Î±] [no_max_order Î±] : filter.at_top â‰¤ filter.cofinite
{Î± : Type u_1} [linear_ordered_field Î±] {Î² : Type u_2} [comm_ring Î²] {abv : Î² â†’ Î±} [is_absolute_value abv] : Type u_2
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_ideal R L
{Î± : Type u} [group_with_zero Î±] {a : Î±} (h : a â‰  0) : invertible a
(G : Type u_1) [topological_space G] [has_div G] : Prop
{Î± : Type u} : ordnode Î± â†’ bool
{Î± : Type u} [decidable_eq Î±] (xs : list (Î± Ã— Î±)) (x : Î±) : Î±
{p : â„• â†’ Prop} : (âˆƒ (x : â„•), p x) â†’ well_founded (nat.upto.gt p)
(R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M] : Prop
{Î± : Type u_1} : cycle Î±
{X : Type u_1} [topological_space X] (x : X) (F : set X) : set X
{Î± : Type u} (s : computation Î±) (a : Î±) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type w} [fintype Î¹] (h : basis Î¹ K V) : finite_dimensional K V
{Î± : Type u} [topological_space Î±] (s : set Î±) : set Î±
{G : Type u} [monoid G] (x : G) : Prop
{gen : Type u} [random_gen gen] (g : gen) : bool Ã— gen
{Î± : Type u_1} {P : Î± â†’ Prop} (h : âˆƒ (x : Î±), P x) : {x // P x}
(Î± : Type u_1) [add_right_cancel_semigroup Î±] [has_one Î±] : complex_shape Î±
{Î± : Type u} (s : seq Î±) : Prop
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} (f : Î  (i : Î¹), filter (Î± i)) : filter (Î  (i : Î¹), Î± i)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : Type u_2
{Î± : Sort u_1} (h : nonempty Î±) : erased Î±
{C : Type u} [category_theory.category C] {P Q : C} (t : category_theory.limits.binary_fan P Q) : category_theory.limits.binary_fan Q P
{Î± : Type u} (p : Î± â†’ Prop) (s : stream Î±) : Prop
(R : Type u_2) (M : Type u_5) [semiring R] [add_comm_group M] : Type (max u_2 u_5)
{p : â„•} {G : Type u_1} [group G] {Î± : Type u_2} [group Î±] [mul_distrib_mul_action Î± G] : mul_action Î± (sylow p G)
{Î± : Type u} (s : stream Î±) (n : â„•) : Î±
{Î± : Type u} {Î² : Type v} [group Î²] (f : Î± â†’ Î²) : list (Î± Ã— bool) â†’ Î²
{Î± : Type u_1} [Î² : non_unital_normed_ring Î±] : non_unital_semi_normed_ring Î±
{G : Type u_1} [add_group G] (H : add_subgroup G) : 0 âˆˆ H
{Î± : Type u_1} (A : finset Î±) (i : â„•) (hâ‚ : i â‰¤ A.card) : âˆƒ (B : finset Î±), B âŠ† A âˆ§ B.card = i
(key data : Type) : Type
(Î± : Type u_8) (Î² : Type u_9) [has_Inf Î±] [has_Inf Î²] : Type (max u_8 u_9)
(c fâ‚ fâ‚‚ : Type u) (râ‚ râ‚‚ : Type v) : first_order.language
{Î± : Type u} [topological_space Î±] : dense_range stone_cech_unit
{Î± : Type} : parse_result Î± â†’ â„•
(n : Type u) [decidable_eq n] [fintype n] (R : Type v) [comm_ring R] : Type (max u v)
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (b : Î² a) (l : list (sigma Î²)) : list (sigma Î²)
 : bounded_random â„¤
(l : Type u_4) (R : Type uâ‚‚) [decidable_eq l] [comm_ring R] : matrix (l âŠ• l) (l âŠ• l) R
 : Type
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â†’ Î²) : Prop
(R : Type u) [comm_ring R] [is_domain R] (n : â„•) : is_domain (mv_polynomial (fin n) R)
{Î± : Type u} : ordnode Î± â†’ ordnode Î± â†’ ordnode Î±
{Î± : Type u_1} [decidable_eq Î±] (l : list Î±) (x : Î±) (h : x âˆˆ l) : Î±
(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_zero M] [has_zero N] : Type (max u_10 u_11 u_9)
{Î± : Type u_1} [add_right_cancel_semigroup Î±] (a : Î±) : complex_shape Î±
{J : Type uâ‚} [category_theory.category J] [category_theory.is_connected J] (jâ‚ jâ‚‚ : J) : category_theory.zigzag jâ‚ jâ‚‚
(Î± : Type u) {Î² : Type v} [add_monoid Î±] [add_action Î± Î²] (b : Î²) : add_submonoid Î±
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (Î¹ : Type u_1) [unique Î¹] (h : finite_dimensional.finrank K V = 1) : basis Î¹ K V
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
{Î± : Type u_1} [linear_ordered_ring Î±] : subsingleton (floor_ring Î±)
(M : Type u) : Type u
(R : Type u) [non_assoc_semiring R] : â„•
{Î± : Type u_1} [boolean_ring Î±] : boolean_algebra Î±
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (h : is_unit A.det) : A.mul Aâ»Â¹ = 1
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ Î± â†’ Î±
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] {J : Type v} [fintype J] (F : J â†’ category_theory.idempotents.karoubi C) : category_theory.limits.bicone F
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [has_top Î±] [has_top Î²] [has_top Î³] (f : top_hom Î² Î³) (g : top_hom Î± Î²) : top_hom Î± Î³
(H : Type u_5) [topological_space H] (M : Type u_6) [topological_space M] : Type (max u_5 u_6)
{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R â†‘S)
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : cycle Î± â†’ cycle Î²
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_glb s a) : bdd_below s
 : Type
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (b : Î² a) : list (Î£ (a : Î±), Î² a) â†’ list (Î£ (a : Î±), Î² a)
(p : â„•) : padic_norm p 1 = 1
{G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b
(R : Type u) [comm_semiring R] (p : â„•) [fact (nat.prime p)] [char_p R p] : Type u
{Î± : Type u_1} [preorder Î±] [pred_order Î±] : Î± â†’ Î±
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : seq1 (generalized_continued_fraction.int_fract_pair K)
{Î± : Type u_1} {Î² : Type u_2} (r : rel Î± Î²) (s : set Î±) : rel {x // x âˆˆ s} Î²
{Î± : Sort u_1} {Î² : Sort u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£' (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚
{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)
{R : Type u} [non_assoc_semiring R] (s : set R) (sm : submonoid R) (hm : â†‘sm = s) (sa : add_submonoid R) (ha : â†‘sa = s) : subsemiring R
{M : Type u_1} [has_mul M] : has_bot (subsemigroup M)
{Î± : Type u_1} (p : Î± â†’ bool) : list Î± â†’ list Î± Ã— option Î± Ã— list Î±
(G : Type u) : Type u
{Î± : Type u} [group Î±] (g : group_topology Î±) : continuous has_inv.inv
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
 : Type (u_1+1)
{Î± : Type u} (l : list Î±) : wseq Î±
(Î± : Type u_1) {Î² : Type u_2} [measurable_space Î±] (b : Î²) : measure_theory.simple_func Î± Î²
{Î² : Type w} {C : Type u} [category_theory.category C] (f : Î² â†’ C) [category_theory.limits.has_product f] : C
{R : Type u_1} [comm_semiring R] (x : R) (S : Type u_2) [comm_semiring S] [algebra R S] : Prop
 : znum â†’ znum
{a p k : â„•} (pp : nat.prime p) (hâ‚ : Â¬a âˆ£ p ^ k) (hâ‚‚ : a âˆ£ p ^ (k + 1)) : a = p ^ (k + 1)
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (m : multiset Î±) : Prop
{p : Prop} (h : p) : unique p
(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C
(S : Type u_3) (G : Type u_4) [has_neg G] [set_like S G] : Type
{Î± : Sort u_1} {Î² : Î± â†’ Type u_2} (p : Î± â†’ Prop) (f : Î  (x : Î±), Î² x) (x : subtype p) : Î² x.val
{Î² : Type w} {C : Type u} [category_theory.category C] (f : Î² â†’ C) : Type (max w u v)
{Î± : Type u_1} [preorder Î±] : ordnode Î± â†’ with_bot Î± â†’ with_top Î± â†’ Prop
{Î± : Type u_6} : add_action (additive (function.End Î±)) Î±
{M : Type u_1} {N : Type u_2} [has_zero M] [has_zero N] (f : zero_hom M N) : zero_hom (with_top M) (with_top N)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : Î± â†’ option Î² â†’ Î³) : list Î± â†’ list Î² â†’ list Î³ Ã— list Î²
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_2)
{Î± : Type u_1} (S : set (set Î±)) : Type
(L : Type v) (M : Type w) [has_bracket L M] [has_zero M] : Prop
(G : Type u_1) [group G] [topological_space G] : Prop
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] [nontrivial Mâ‚€] : 0 â‰  1
{C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)
(Î± : Type u) : Type u
{n : â„•} (F : typevec n â†’ Type u_1) [mvfunctor F] : Type (max (u+1) u_1)
 : Type (u_1+1)
{Î± : Type u_1} [has_le Î±] (a : Î±) : Prop
(o : ordinal) (f : Î  (a : ordinal), a < o â†’ ordinal) : ordinal
{R : Type u_1} (A : Type u_2) [comm_ring R] [ring A] [algebra R A] (câ‚ câ‚‚ : R) : Type u_2
{G : Type u_1} [add_group G] (H : add_subgroup G) : â„•
{Ïƒâ‚ : Type u_1} {Ïƒâ‚‚ : Type u_2} (fâ‚ : Ïƒâ‚ â†’ option Ïƒâ‚) (fâ‚‚ : Ïƒâ‚‚ â†’ option Ïƒâ‚‚) (tr : Ïƒâ‚ â†’ Ïƒâ‚‚ â†’ Prop) : Prop
{Î± : Type u_1} [preorder Î±] (s : set Î±) : Prop
(data : Type) : Type
{R : Type u_1} [comm_ring R] (p : polynomial R) : polynomial R
{Î± : Type u_1} {s : finset Î±} (p : Î± â†’ Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s
{m : Type u â†’ Type v} [monad m] {Î± : Type w} {Î² : Type u} (f : Î± â†’ m Î²) (o : option Î±) : m (option Î²)
{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [monoid.fg M] : algebra.finite_type R (monoid_algebra R M)
{m : Type u_2} {n : Type u_3} {Î± : Type v} [has_mul Î±] (w : m â†’ Î±) (v : n â†’ Î±) : matrix m n Î±
(o : ordinal) (f : Î  (a : ordinal), a < o â†’ ordinal) : ordinal
{Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±) : multiset Î±
(C : Type u) [category_theory.category C] : Prop
{b : â„•} (hb : 1 < b) {x y : â„•} : x â‰¤ b ^ y â†” nat.clog b x â‰¤ y
{K : Type u} [field K] (s : subring K) (hinv : âˆ€ (x : K), x âˆˆ s â†’ xâ»Â¹ âˆˆ s) : subfield K
{X : Type u_1} [topological_space X] : discrete_topology X â†” nhds = has_pure.pure
{Î± : Type u_1} [preorder Î±] [order_top Î±] [locally_finite_order Î±] (a : Î±) : multiset Î±
(n : â„•) : list â„•
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [has_le Î±] [has_le Î²] : Type (max u_6 u_7 u_8)
(Î± : Type u_5) : Type u_5
(Î± : Type u) (Î² : Type v) [omega_complete_partial_order Î±] [omega_complete_partial_order Î²] : Type (max u v)
(G : Type u) [group G] : subgroup G
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {f : Î± â†’ Î²} (hf : uniform_inducing f) : uniform_embedding f
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) : setoid M
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] : has_inv (matrix n n Î±)
{Î± : Type u_1} (x : Î±) (z : sym2 Î±) : Prop
{G : Type w} [topological_space G] [group G] [topological_group G] [topological_space.separable_space G] [locally_compact_space G] : sigma_compact_space G
(x y : pgame) : Prop
{Î± : Type u_1} {Î² : Type u_2} (f : filter Î±) (g : set Î± â†’ filter Î²) : filter Î²
{Î± : Type u_1} [has_add Î±] (s : set Î±) (a : Î±) : set Î±
(R : Type u_1) [comm_ring R] : algebra.finite_presentation R R
(Î± : Type u_5) (Î² : Type u_6) : Type (max u_5 u_6)
(Î± : Type u) [preorder Î±] [nonempty Î±] [no_max_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_mono f
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (jâ‚ jâ‚‚ jâ‚ƒ : C) : C
{Î± : Type u_1} {p : Î± â†’ Prop} [pseudo_emetric_space Î±] : pseudo_emetric_space (subtype p)
 : Type (u_1+1)
(R : Type u_1) [semiring R] (N : Type u_3) [add_comm_monoid N] [module R N] {Î¹ : Type u_6} [decidable_eq Î¹] [subsingleton Î¹] (i : Î¹) : alternating_map R N N Î¹
 : pos_num â†’ pos_num â†’ znum
{Râ‚ : Type u_3} {Mâ‚ : Type u_4} [ring Râ‚] [add_comm_group Mâ‚] [module Râ‚ Mâ‚] (Bâ‚ : bilin_form Râ‚ Mâ‚) (f : module.End Râ‚ Mâ‚) : Prop
{Î± : Type u_2} [division_monoid Î±] {a : Î±} : is_square a â†’ is_square aâ»Â¹
 : â„• â†’ â„• â†’ list â„•
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (l : list (Î£ (a : Î±), Î² a)) (hash_fn : Î± â†’ â„•) : hash_map Î± Î²
(R : Type u) [comm_ring R] (A : Type v) [ring A] [algebra R A] (A' : subalgebra R A) : lie_subalgebra R A
{Î± : Type u_1} : list Î± â†’ option Î±
{Î± : Type u_1} [decidable_eq Î±] (l : list Î±) : equiv.perm Î±
{Î± : Type u_2} {Î² : Type u_4} [topological_space Î±] [has_one Î²] (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} : has_le (setoid Î±)
{G : Type u_1} {H : Type u_2} [add_group H] (f : G â†’ H) : set G
{g : Type} [random_gen g] {n : â„•} [fact (0 < n)] : rand_g g (fin n)
(p : â„•) : padic_norm p 0 = 0
{Î± : Type u} (x : Î±) : free_add_semigroup Î±
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} [is_trans Î² s] : has_coe (principal_seg r s) (initial_seg r s)
{n : â„•} {A : Type u} (F : A â†’ typevec n â†’ Type u) (v : typevec n) : Type u
{Î± : Type u_1} (s : set Î±) (q : semiquot Î±) : semiquot Î±
 : unit
{R : Type u_1} [semiring R] (P : cubic R) : polynomial R
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : cardinal
(P : pfunctor) : Type u_1
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : Î± â†’ Î² âŠ• Î³) : list Î± â†’ list Î² Ã— list Î³
{n : â„•} : function.injective fin.succ_above
{Î± : Type u_2} [has_one Î±] [has_mul Î±] : has_pow (set Î±) â„•
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b
(Î± : Sort u) (tac_name : name) : Sort u
{Î² : Type w} {C : Type u} [category_theory.category C] [unique Î²] (f : Î² â†’ C) : category_theory.limits.limit_cone (category_theory.discrete.functor f)
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} [topological_space Î²] {f : Î± â†’ Î²} (hf : âˆ€ (x y : Î±), f x = f y) : measure_theory.strongly_measurable f
{Î± : Type u_1} : has_Inf (setoid Î±)
(C : Type u) [category_theory.category C] : Type u
{R : Type u_1} {S : Type u_3} [non_assoc_semiring R] [non_assoc_semiring S] : non_assoc_semiring (R Ã— S)
{Î± : Type u} {Î² : Type v} (s : wseq Î±) (f : Î± â†’ wseq Î²) : wseq Î²
 : Type
{Î± : Type u_1} {R : Type u_2} [comm_semiring R] (a b : R) (s : finset Î±) : s.powerset.sum (Î» (t : finset Î±), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card
{K : Type u} [field K] (s : subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
(M : Type u_1) (Î± : Type u_2) [has_vadd M Î±] [measurable_space M] [measurable_space Î±] : Prop
{R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a
{G : Type u_10} [group_with_zero G] (a : G) (ha : a â‰  0) : equiv.perm G
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : measurable f â†’ mâ‚‚ â‰¤ measurable_space.map f mâ‚
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] (m : measure_theory.measure Î±) (f : Î± â†’ measure_theory.measure Î²) : measure_theory.measure Î²
{Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î±] [fintype (Î± Ã— Î²)] [nonempty Î²] : fintype Î±
{V : Type u} (G : simple_graph V) : Prop
{R : Type u_1} [has_mul R] {a : R} : is_right_regular a â†” is_smul_regular R (mul_opposite.op a)
{G : Type u_1} [add_group G] {s : set G} (h : is_add_subgroup s) : add_subgroup G
(p : â„•) (R : Type u_1) : Type u_1
{Î± : Type u_1} (s t : multiset Î±) : Prop
{Î¹ : Type u} (f : Î¹ â†’ ordinal) : ordinal
{G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x
{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ b â‰¤ z) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (lb : â„¤), P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z
(Î± : Type u_1) (Î² : Type u_2) [uniform_space Î²] (ð”– : set (set Î±)) : topological_space (Î± â†’ Î²)
 : list bool â†’ pos_num
{Î± : Type u} (c : computation Î±) : computation Î±
{Î± : Type u} {Î² : Type v} [topological_space Î±] [preorder Î²] (f : Î± â†’ Î²) (a : Î±) : Prop
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) : tensor_algebra R M â†’ tensor_algebra R M â†’ Prop
(Î± : Type u_1) [complete_lattice Î±] : Prop
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : set P
(G : Type u_3) [group G] : Type u_3
{Î± : Type u} [semilattice_inf Î±] [nonempty Î±] (s : finset Î±) : bdd_below â†‘s
{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (a : erased Î±) : erased Î²
{Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} {x y : Î±} (hf : is_ring_hom f) : f (x - y) = f x - f y
(E : Type u_8) [comm_group E] [topological_space E] [topological_group E] : continuous_monoid_hom E E
{J : Type v} : category_theory.limits.wide_pullback_shape J â†’ category_theory.limits.wide_pullback_shape J â†’ Type v
(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : â„• â†’ Î±
{Î± : Type u_1} : option Î± â†’ list Î±
{Î± : Type u} {Î² : Type v} (s : seq (Î± Ã— Î²)) : seq Î± Ã— seq Î²
{Î± : Type u} [comm_ring Î±] [no_zero_divisors Î±] : cancel_comm_monoid_with_zero Î±
(M : Type u) [semigroup M] : Semigroup
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{Î± : Type u_1} {Î² : Type u_2} [infinite Î±] [fintype Î²] (f : Î± â†’ Î²) : âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y
(Î± : Type v) : Prop
{R : Type u_1} [semiring R] (s : subsemiring R) {l : list R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
(p : â„•) [hp : fact (nat.prime p)] (n : â„¤) : â„• â†’ mv_polynomial (fin 1 Ã— â„•) â„¤
(R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : Type (max v w)
{Î¹ : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [monoid R] [add_monoid Î¹] (A : Î¹ â†’ S) : Prop
(ð•œ : Type u_4) (F : Type u_5) [is_R_or_C ð•œ] [add_comm_group F] [module ð•œ F] : Type (max u_4 u_5)
{Î± : Type u_1} {M : Type u_5} [has_zero M] : function.injective coe_fn
(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (Î± : Type u_1) [add_right_cancel_semigroup Î±] [has_one Î±] : Type (max u u_1 v)
 : zero_hom cardinal â„•
 : turing.to_partrec.cont â†’ turing.to_partrec.cont â†’ turing.to_partrec.cont
{Î± : Type u_1} [lattice Î±] [order_bot Î±] (a : Î±) : Type u_1
{Î± : Type u} [monoid Î±] : invertible 1
{R : Type u_1} [comm_ring R] (a1 a2 a3 a4 a6 : R) : R
{n : â„•} {Î± : Type u} {Î² : Type v} (a : array n Î±) (f : Î± â†’ Î²) : array n Î²
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} (b : Î²) : Î± âŠ• Î² âŠ• Î³
(G : Type u) : Type u
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : has_coe_t (ideal R) (fractional_ideal S P)
 : Type
{n : â„•} {Î± : Type u_1} [preorder Î±] {f g : fin n â†’ Î±} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g) : f = g
{R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R) : is_square a
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.split_epi category_theory.limits.prod.fst
(Î± : Type u) : Type u
{Î± : Type u} {Î² : Î± â†’ Type v} (s : alist Î²) : finmap Î²
{V : Type u} [quiver V] (a : V) : V â†’ Sort (max (u+1) v)
{Î± : Type u_1} [measurable_space Î±] : has_sub (measure_theory.measure Î±)
 : pSet
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cocone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_colimit t) : category_theory.limits.binary_bicone X Y
{Î± : Type u_2} [mul_one_class Î±] : mul_one_class (filter Î±)
{Râ‚ƒ : Type u_7} [comm_ring Râ‚ƒ] {n : Type u_11} [fintype n] (J A : matrix n n Râ‚ƒ) : Prop
 : ordinal â†’ ordinal â†’ ordinal
{P : Type u_1} [preorder P] : has_coe (order.pfilter P) (set P)
{M : Type u_1} [has_add M] : complete_lattice (add_con M)
(L : first_order.language) (M : Type u_3) [L.Structure M] : Prop
{Î± : Type u_1} [topological_space Î±] [t2_space Î±] {f : Î± â†’ Î±} (hf : continuous f) : is_closed (function.fixed_points f)
{Î± : Type u} (n : pos_num) (t : tree Î±) (v : Î±) : Î±
{M : Type u_1} [add_zero_class M] : has_top (add_submonoid M)
(n : â„•) : bool
(Î± : Type u_1) [encodable Î±] [infinite Î±] : denumerable Î±
 : pgame â†’ Prop
(M : Type u_5) [monoid M] (A : Type u_6) [add_monoid A] [distrib_mul_action M A] (B : Type u_8) [add_monoid B] [distrib_mul_action M B] : Type (max u_6 u_8)
(Î± : Type u_1) : Type u_1
 : initial_seg has_lt.lt has_lt.lt
 : znum â†’ option pos_num
(n : â„•) (i : fin (n + 1)) : sSet
 : filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), 1 / (â†‘i + 1))) filter.at_top filter.at_top
(Î² : Type u_1) (Î± : Type u_2) : Type (max u_1 u_2)
{Î± : Type u_1} {n : Type u_4} [has_zero Î±] (A : matrix n n Î±) : Prop
{R : Type u} [semiring R] (p : polynomial R) : with_bot â„•
{Î± : Type u} {Î² : Type v} : lazy_list Î± â†’ lazy_list Î² â†’ lazy_list (Î± Ã— Î²)
{n : â„•} (x : bitvec n) (i : â„•) : bitvec n
(Î± : Type u_1) [f : denumerable Î±] (n : â„•) : Î±
{R : Type u} [non_assoc_semiring R] {S T : subsemiring R} (h : âˆ€ (x : R), x âˆˆ S â†” x âˆˆ T) : S = T
{Î± : Type u} {Î² : Î± â†’ Type v} (s : finmap Î²) : finset Î±
{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : submodule R A
{F : Type} [comm_semiring F] {q : â„•} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : polynomial F
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (s : alist Î²) : option (Î² a)
{Î± : Type u_1} (a : Î±) (s : cycle Î±) : Prop
(Î± : Type u) : Type u
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_5} [normed_field ð•œ] [add_comm_group E] [module ð•œ E] [nonempty Î¹] (p : seminorm_family ð•œ E Î¹) [t : topological_space E] : Prop
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_topological_fiber_bundle F Z.proj
(R : Type u_1) [comm_ring R] : â„• â†’ polynomial R
{Î± : Type u_1} [distrib_lattice Î±] [order_bot Î±] [decidable_eq Î±] {a : Î±} (P : finpartition a) (Q : Î  (i : Î±), i âˆˆ P.parts â†’ finpartition i) : finpartition a
{R : Type u_1} [semiring R] (f : nat.arithmetic_function R) (k : â„•) : nat.arithmetic_function R
(C : Type uâ‚) [category_theory.category C] : Type uâ‚
(R : Type u_1) [semiring R] : subsemiring R
{X : Type u_1} [topological_space X] (S : discrete_quotient X) {Y : Type u_2} [topological_space Y] {f : Y â†’ X} (cont : continuous f) : discrete_quotient Y
(H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H] : locally_compact_space M
{Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) : Prop
{a b : Prop} : Â¬(a âˆ¨ b) â†” Â¬a âˆ§ Â¬b
 : Type
{m : Type â†’ Type v} [monad m] : list (m bool) â†’ m bool
(R : Type u_1) [add_monoid R] [has_one R] : Prop
(n : â„•) : â„• â†’ â„•
{Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) : Prop
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] : Type (max u v)
(Î³ : Type u) : Type u
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] (f : Î± â†’ Î²) : Prop
{M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
{H : Type u} [topological_space H] : structure_groupoid H
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [ordered_semiring S] (abv : absolute_value R S) : Prop
{Î± : Type u_1} {Î² : Type u_2} [nonempty Î±] (f : Î± â†’ Î²) (s : set Î±) (t : set Î²) (hf : set.bij_on f s t) : local_equiv Î± Î²
{Î± : Type u_1} [decidable_eq Î±] : list Î± â†’ list Î± â†’ option (list Î±)
(R : Type u_1) (A : Type u_2) : Type (max u_1 u_2)
(Î± : Type u_1) : Type u_1
{Râ‚‚ : Type u_5} {Mâ‚‚ : Type u_6} [comm_semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] (Bâ‚‚ Fâ‚‚ : bilin_form Râ‚‚ Mâ‚‚) : submodule Râ‚‚ (module.End Râ‚‚ Mâ‚‚)
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [non_unital_non_assoc_semiring Î±] [non_unital_non_assoc_semiring Î²] [topological_semiring Î±] [topological_semiring Î²] : topological_semiring (Î± Ã— Î²)
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : Type (max u v)
(Î± : Type u_4) : Type u_4
 : Type
(m : Type u_1) (n : Type u_2) (R : Type u_3) [comm_semiring R] : matrix m n (mv_polynomial (m Ã— n) R)
{Î± : Sort u_1} (a : Î±) : erased Î±
{C : Type u} [category_theory.category C] : has_Inf (category_theory.grothendieck_topology C)
(p : â„•) [fact (nat.prime p)] : Type
(C : Type u) [category_theory.category C] : sSet
{Î± : Type u_1} [topological_space Î±] [inhabited Î±] : inhabited (topological_space.nonempty_compacts Î±)
 : Type
(H : Type u_1) [topological_space H] : charted_space H H
{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a) : a â‰  0
{C : Type u_1} [category_theory.category C] (r : hom_rel C) : Type u_1
(Î± : Type u_2) : Type u_2
(G : Type u_1) [comm_group G] : subgroup G
(Î± : Type u_1) : subsingleton Î± âˆ¨ nontrivial Î±
(R : Type u) [comm_semiring R] : CommSemiRing
(V : Type u) : Type u
(K : Type u) [comm_ring K] (p : â„•) [fact (nat.prime p)] [char_p K p] (x : â„• Ã— K) : perfect_closure K p
(ð•† : Type u_1) {Î± : Type u_3} [preorder ð•†] [preorder Î±] [grade_order ð•† Î±] : Î± â†’ ð•†
(R : Type u) [ring R] : Type (max u (v+1))
(R : Type u_2) {M : Type u_5} [ring R] [add_comm_monoid M] [module R M] : add_comm_group M
{R : Type u_1} [mul_zero_class R] (f g : nat.arithmetic_function R) : nat.arithmetic_function R
{Î± : Type u_1} {Î² : Type u_2} [primcodable Î±] [primcodable Î²] (p : Î± â†’ Prop) (q : Î² â†’ Prop) : Prop
{Î± : Type u} : seq1 (seq1 Î±) â†’ seq1 Î±
(Î± : Type u_1) : option Î±
(Î± : Type u) : Type u
(p : Prop) : decidable p
(ð•œ : Type u_4) (E : Type u_5) : Type (max u_4 u_5)
{M : Type u_6} [add_monoid M] (u : add_units M) : equiv.perm M
(M : Type u) : Type u
(C : Type u) [category_theory.category C] : Prop
{Î¹ : Type u_1} {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), group (G i)] {i j : Î¹} (w : free_product.neword G i j) : free_product.neword G j i
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (h : Â¬metric.bounded s) : metric.diam s = 0
(M : Type u_1) [has_mul M] : Type u_1
{Î± : Type u_2} (A : set Î±) (Î² : Type u_7) [comm_monoid Î±] [comm_monoid Î²] (n : â„•) : Type (max u_2 u_7)
{Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), monoid (M i)] {i j : Î¹} (w : free_product.neword M i j) : free_product M
(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A Ã— B) (B Ã— A)
{Î± : Type u_1} [measurable_space Î±] (s t : set Î±) : Prop
 : â„• â†’ â„•
{Î± : Type u_1} {Î² : Type u_2} (r : setoid Î±) (f : Î± â†’ Î²) : setoid Î²
(Î± : Type u_1) [uniform_space Î±] : Type u_1
(v : â„• â†’ â„¤) (as : list â„¤) : â„¤
(p : Prop) : Prop
{Î± : Type u_1} {n : â„•} (a : Î±) (s : sym Î± n) : sym Î± n.succ
(G : Type u_2) [group G] : Prop
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : free_add_semigroup Î± â†’ free_add_semigroup Î²
(V : Type uâ‚) : Type uâ‚
(R : Type u) [topological_space R] [has_star R] : Prop
{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] (B : module_filter_basis R M) : topological_space M
(Î± : Type u_2) [fintype Î±] [boolean_algebra Î±] : complete_boolean_algebra Î±
(Î± : Type u_2) [has_zero Î±] [has_one Î±] [has_le Î±] : Type
{K : Type v} [field K] (f : polynomial K) : Type v
{Î± : Type u} {Î² : Type v} {m : Î± â†’ Î²} (u : ultrafilter Î²) (inj : function.injective m) (large : set.range m âˆˆ u) : ultrafilter Î±
{Î± : Type u} {Î² : Type v} {t : set Î²} {f : Î± â†’ Î²} (h : âˆ€ (x : Î±), f x âˆˆ t) : function.injective f â†’ function.injective (set.cod_restrict f t h)
(u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1
{Î± : Type u} (m : measure_theory.outer_measure Î±) (s : set Î±) : Prop
 : Type
(Î± : Type u_6) (Î² : Type u_7) [topological_space Î±] [topological_space Î²] : Type (max u_6 u_7)
{Î± : Type u_1} [fintype Î±] [decidable_eq Î±] (p : equiv.perm Î±) (x : Î±) : list Î±
(L : first_order.language) : L.Theory
(Î± : Type v) : Type u
{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1
{V : Type uâ‚} [quiver V] : prefunctor V (category_theory.paths V)
 : Type
 : pos_num â†’ list bool
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q) : category_theory.limits.cone (category_theory.limits.pair P Q)
(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : Prop
(Î± : Type u_2) : Type u_2
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] {x y : Î±} : x â‰  y â†’ r x y â†” r x y
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : has_quotient M (submodule R M)
{n : â„•} {Î± : fin (n + 1) â†’ Type u} : function.injective2 fin.cons
(F : Type u_2) (Î± : out_param (Type u_3)) (Î² : out_param (Type u_4)) [topological_space Î±] [has_zero Î²] [topological_space Î²] : Type (max u_2 u_3 u_4)
{G : Type u_2} [group G] {a b : G} : a = b â†’ a / b = 1
{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b < c â†’ a < c
 : stieltjes_function
{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a - b < c â†’ a < b + c
(Gâ‚€ : Type u) : Type u
 : pgame
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : Type (max u v)
(Î¹ : Type u_1) (R : Type u_2) [unique Î¹] [semiring R] : basis Î¹ R R
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), has_zero (Î² i)] : function.injective coe_fn
(C : Type u) : Type u
{Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] {L : list Mâ‚€} (h : 0 âˆˆ L) : L.prod = 0
(Î± : Type u_1) : Type u_1
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))
(Î± : Type u_8) : Type u_8
(Î± : Type u_1) : Type u_1
{Î± : Type u_1} [topological_space Î±] [has_le Î±] (s : clopen_upper_set Î±) : upper_set Î±
(C : Type u_1) (D : Type u_2) [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] : Type (max u_3 u_4 u_1 u_2)
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) : free_magma Î± â†’ free_magma Î²
{G : Type u} [add_group G] : inhabited (add_group_filter_basis G)
{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : has_bot (submodule R M)
{Î± : Type u_1} [linear_order Î±] : finset Î± â†’ option Î±
{K : Type u} [field K] (s : subfield K) {l : list K} : (âˆ€ (x : K), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
{R : Type u} [ring R] (p q : polynomial R) : polynomial R
 : Set â†’ Set â†’ Set
 : Set
{Î± : Type u} (s : stream Î±) : stream (list Î±)
{M : Type u_1} [monoid M] : has_faithful_smul (mul_aut M) M
{G : Type w} [topological_space G] [add_group G] [topological_add_group G] (s : add_subgroup G) : add_subgroup G
(B : Type v) [decidable_eq B] [fintype B] : Type v
{Î± : Type u} : function.injective free_group.of
{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b = 0 â†” b * a = 0
{Î± : Type u_1} [monoid Î±] {a b u : Î±} (hu : is_unit u) : a * u âˆ£ b â†” a âˆ£ b
 : Type
(Î± : Type u_1) : Type u_1
{Î± : Type u_2} [monoid Î±] : monoid (filter Î±)
{M : Type u_2} [add_comm_group M] {R : Type u_1} : has_involutive_neg (ray_vector R M)
(Î± : Type u) : Type
(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valued (ratfunc Fq) (with_zero (multiplicative â„¤))
(R : Type u) [semiring R] [nontrivial R] (p q : â„•) [char_p R p] [exp_char R q] : q = 1 â†” p = 0
(Î± : Type u) : Type u
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : set Î±} (hc : is_chain r c) : âˆƒ (M : set Î±), is_max_chain r M âˆ§ c âŠ† M
(K : Type u_1) : Type u_1
{B : Type u_1} {E : B â†’ Type u_2} : bundle.total_space E â†’ B
{Î± : Type u} [topological_space Î±] {s : set Î±} (h : is_closed s) : interior (frontier s) = âˆ…
{R : Type u_1} [comm_ring R] (s : subring R) (m : multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
{Î± : Type u} (s : wseq Î±) : computation (list Î±)
(Î± : Type u_8) : Type u_8
{Î¹ : Type u_1} (R : Type u_3) {A : Type u_5} (x : Î¹ â†’ A) [comm_ring R] [comm_ring A] [algebra R A] : Prop
{Î± : Type u_2} [bornology Î±] (s : set Î±) : Prop
{G : Type u_1} [group G] : has_bracket G G
{Î¹ : Type u_1} (A : Î¹ â†’ Type u_2) [add_monoid Î¹] : Type (max u_1 u_2)
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î²] [lattice Î±] (gi : galois_insertion l u) : lattice Î²
{Î± : Type u} [has_zero Î±] [has_add Î±] : list Î± â†’ list Î± â†’ list Î±
{M : Type u_1} [monoid M] (P : submonoid M) : Prop
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Î¹} (A B : homological_complex V c) : Type (max u_1 v)
{n : Type u_1} {R : Type uâ‚‚} [decidable_eq n] [comm_ring R] (i j : n) (c : R) : matrix n n R
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (m : hash_map Î± Î²) (a : Î±) : bool
{Î± : Type u_1} (xs : lazy_list Î±) : lazy_list Î±
(C : Type u) [category_theory.category C] : Type (max u v)
{Î¹ : Type u_1} (A : Î¹ â†’ Type u_2) [add_monoid Î¹] [graded_monoid.gmonoid A] : monoid (graded_monoid A)
(C : Type u) : Type (u+1)
{Î± : Type u_1} (m : set Î± â†’ ennreal) : measure_theory.outer_measure Î±
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) (s : set Î±) (hs : is_open s) : local_homeomorph Î± Î²
{Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î²] (f : Î± â†’ Î²) (s : finset Î±) : finset Î²
{P : Type u_1} [preorder P] [order_bot P] : order_top (order.pfilter P)
(R : Type uâ‚) [comm_semiring R] (p : â„•) : Type uâ‚
{Î± : Type u_1} [has_repr Î±] : has_repr (generalized_continued_fraction.pair Î±)
(M : Type u) [monoid M] {R : Type v} [ring R] [mul_semiring_action M R] (S : subring R) : Prop
{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_dist x s)
{Î± : Type u} [inhabited Î±] : lazy_list Î± â†’ Î±
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] [is_trans Î± r] [is_antisymm Î± r] [is_total Î± r] (s : finset Î±) : list Î±
{o : ordinal} : ordinal.principal has_mul.mul o â†” o â‰¤ 2 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a
{K : Type u_1} [field K] [uniform_space K] : uniform_space.completion K â†’ uniform_space.completion K
{R : Type u} [ring R] (s : set R) : subring R
(F : Type u_7) (Î± : out_param (Type u_8)) (Î² : out_param (Type u_9)) [has_inf Î±] [has_inf Î²] : Type (max u_7 u_8 u_9)
(R : Type u_1) [comm_semiring R] (X : Type u_2) : Type (max u_1 u_2)
{Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {g : Î± â†’ Î²} (h : function.semiconj g fa fb) : set.maps_to g (function.fixed_points fa) (function.fixed_points fb)
(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : âˆƒ (Ï– : R), irreducible Ï–
(Î± : Type u_1) [add_right_cancel_semigroup Î±] [has_one Î±] : complex_shape Î±
(R : Type u) {M : Type v} {Mâ‚‚ : Type w} [semiring R] [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module R Mâ‚‚] (f : M â†’ Mâ‚‚) : Prop
(R : Type u_1) [comm_semiring R] : ideal R
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} : aâ»Â¹ â‰¤ b â†’ bâ»Â¹ â‰¤ a
(F : Type u_6) (Î± : out_param (Type u_7)) (Î² : out_param (Type u_8)) [bornology Î±] [bornology Î²] : Type (max u_6 u_7 u_8)
{M : Type u_2} [add_comm_group M] {R : Type u_1} : has_neg (ray_vector R M)
 : â„• â†’ list bool
{Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.pos_mul_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (a0 : 0 â‰¤ a) : a * b â‰¤ 1
(R : Type u_1) [comm_ring R] [is_domain R] [is_dedekind_domain R] : Type u_1
{Î¹ : Type u_1} (A : Î¹ â†’ Type u_2) : Type (max u_1 u_2)
{Î± : Type u_1} {Î² : Type u_2} (f : list Î± â†’ Î± â†’ list Î± â†’ Î²) : list Î± â†’ list Î± â†’ list Î²
(Î± : Type u_2) : Type u_2
{Î¹ : Type u} (Î² : Î¹ â†’ Type v) [Î  (i : Î¹), has_zero (Î² i)] : Type (max u v)
 : â„• â†’ name Ã— â„•
(C : Type u) [category_theory.category C] : Prop
{Î± : Type u} (l l' : list Î±) : Prop
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (i : zmod 2) : submodule R (clifford_algebra Q)
{m : Type u â†’ Type u} [applicative m] {Î± Î² : Type u} (F : Î± â†’ m Î²) : free_magma Î± â†’ m (free_magma Î²)
{Î± : Type u_1} {Î² : Type u_2} [preorder Î²] [decidable_rel has_lt.lt] (f : Î± â†’ Î²) (l : list Î±) : option Î±
{Î± : Type u_3} {Î² : Type u_4} (r : Î± â†’ Î² â†’ Prop) [Î  (a : Î±), decidable_pred (r a)] (s : finset Î±) (t : finset Î²) : finset (Î± Ã— Î²)
{ð•œ : Type u_1} {V : Type u_2} [normed_field ð•œ] [add_comm_group V] [module ð•œ V] (e : enorm ð•œ V) : subspace ð•œ V
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive (category_theory.idempotents.karoubi C)
{V : Type u} (G : simple_graph V) : Type u
{Î± : Type u_2} [monoid Î±] (s : set Î±) : Prop
(Î± : Type u) [uniform_space Î±] : UniformSpace
{Î± : Type u} : dlist Î± â†’ dlist Î± â†’ dlist Î±
(G : Type u_1) [add_group G] : add_torsor G G
{Î± : Type u_1} {n : â„•} (v : vector Î± n) : vector.map id v = v
{m n k : â„•} (H : k âˆ£ m * n) : {d // k = â†‘(d.fst) * â†‘(d.snd)}
[Î  (P : Prop), decidable P] : functor finset
(M : Type u_3) [mul_one_class M] : Type u_3
(R : Type u_1) [comm_ring R] [nontrivial R] : strong_rank_condition R
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z â†’ B) : Prop
{a : Type u} : has_coe_t a (option a)
(Î± : Type u) [monoid Î±] : category_theory.category (category_theory.single_obj Î±)
(K : Type u) [field K] : Type u
{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
{Î¹ : Type u_1} (M : Î¹ â†’ Type u_2) [Î  (i : Î¹), monoid (M i)] : Type (max u_1 u_2)
{Î± : Type u} {Î² : Type v} [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) (a : Î±) : Prop
{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_product X Y] : C
{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : f 1 = 1
(M : Type u_1) [has_one M] : one_hom M M
(Ï : Type u) (m : Type u â†’ Type v) (Î± : Type u) : Type (max u v)
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†’ 0 â‰¤ a
{G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.sum âˆˆ K
(Mâ‚€ : Type u_4) : Type u_4
(Î± : Type u_1) [encodable Î±] : decidable_pred (Î» (_x : â„•), _x âˆˆ set.range encodable.encode)
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [wf_dvd_monoid Î±] [gcd_monoid Î±] : unique_factorization_monoid Î±
(C : Type u) [category_theory.category C] : category_theory.essentially_small C â†” small (category_theory.skeleton C) âˆ§ category_theory.locally_small C
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [lattice Î±] [lattice Î²] [lattice Î³] (f : lattice_hom Î² Î³) (g : lattice_hom Î± Î²) : lattice_hom Î± Î³
{X : Type u_1} [topological_space X] (F : set X) (x y : X) : Prop
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] (K : nnreal) (f : Î± â†’ Î²) (s : set Î±) : Prop
(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] (n : â„•) : Type u_3
{Î± : Type u_1} {Î² : Type u_2} : list Î± â†’ list Î² â†’ list (Î± Ã— option Î²)
{C : Type u} [category_theory.category C] {O : C} (hO : category_theory.limits.is_zero O) : category_theory.limits.has_zero_morphisms C
(Î± : Type u) [decidable_eq Î±] (Î² : Î± â†’ Type v) : Type (max u v)
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < -a + c
(R : Type uâ‚) [comm_semiring R] (p : â„•) [hp : fact (nat.prime p)] [char_p R p] : subsemiring (â„• â†’ R)
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ Î± â†’ Î±
{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z â†’ B) : Type (max u_2 u_3 u_4)
(Î± : Type u_1) (R : Type u_2) [topological_space Î±] [topological_space R] [semiring R] [topological_semiring R] : subsemiring (Î± â†’ R)
{n : â„•} {A : Type u} (F : A â†’ typevec n â†’ Type u) [Î  (Î± : A), mvfunctor (F Î±)] [Î  (Î± : A), mvqpf (F Î±)] : mvpfunctor n
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_btw.btw a b c â†” has_btw.btw c a b
{n : â„•} : order_of (dihedral_group.r 1) = n
{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î²] {f : Î± â†’ Î²} (hf : function.surjective f) : nontrivial Î±
{Î± : Type u} [topological_space Î±] {s : set Î±} : dense s â†’ dense (closure s)
(C : Type uâ‚) [category_theory.category C] (D : Type uâ‚‚) [category_theory.category D] : category_theory.category (C Ã— D)
{Î± : Type u_1} (s : finset Î±) : s.powerset.card = 2 ^ s.card
(x y c : bool) : bool
{Î± : Type u_1} [monoid Î±] {a u : Î±} (hu : is_unit u) : u âˆ£ a
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0
{Î± : Type u_1} {Î¹ : Type u_4} (p : Î¹ â†’ Prop) (s : Î¹ â†’ set Î±) : Prop
{Î² : Type w} {C : Type u} [category_theory.category C] (f : Î² â†’ C) : Prop
 : Type (u_1+1)
(M : Type u_1) [monoid_with_zero M] : is_square 0
(R : Type uâ‚) (L : Type uâ‚‚) [comm_ring R] [lie_ring L] [lie_algebra R L] : tensor_algebra R L â†’ tensor_algebra R L â†’ Prop
{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A
 : Set â†’ Set â†’ Set
{G : Type u_1} [group G] (s : set G) : set G
(R : Type u_1) (V : Type u_2) [semiring R] [add_comm_group V] [module R V] : â„•
{m : Type u â†’ Type u} [applicative m] {Î± Î² : Type u} (F : Î± â†’ m Î²) (x : free_semigroup Î±) : m (free_semigroup Î²)
{Î± : Type u_1} [B : bornology Î±] (m : metric_space Î±) (H : âˆ€ (s : set Î±), bornology.is_bounded s â†” bornology.is_bounded s) : metric_space Î±
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ ordnode Î± Ã— ordnode Î±
{G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)
{K : Type u_1} [field K] (A : valuation_subring K) : Type u_1
(F : Type u â†’ Type v) [functor F] : Type (max (u+1) v)
(C : Type u) [category_theory.category C] : Prop
{Î± : Type u_1} : list Î± â†’ rbmap â„• Î± has_lt.lt
(R : Type u_1) (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] : Type u_9
{Î² : Type w} {C : Type u} [category_theory.category C] (f : Î² â†’ C) : Type (max w u v)
{Î± : Type u_1} (f : Î± â†’ Î±) : list Î± â†’ list Î±
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] (s : wseq Î±) : wseq â„•
(Î± : Type u_1) : â„•
(Î± : Type u) [topological_space Î±] : Prop
 : real.cos (real.pi / 3) = 1 / 2
{Î± : Type u_1} (R : Î± â†’ Î± â†’ Prop) : list Î± â†’ Prop
(a b : â„•) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
{a : Prop} {b : Sort v} (hâ‚ : a) (hâ‚‚ : Â¬a) : b
{Î± : Type u_1} (C : set (set Î±)) : Prop
 : snum â†’ snum
{Î± : Type u} {Î² : Type v} [topological_space Î±] [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) (a : Î±) : Prop
(X : Type u) [topological_space X] (x : X) : Type u
 : snum â†’ bool
{Î± : Type u_1} [inhabited Î±] : semiquot Î±
{Mâ‚ : Type u_1} {Mâ‚‚ : Type u_2} [has_neg Mâ‚‚] [has_involutive_neg Mâ‚] (f : Mâ‚ â†’ Mâ‚‚) (hf : function.surjective f) (inv : âˆ€ (x : Mâ‚), f (-x) = -f x) : has_involutive_neg Mâ‚‚
(C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C
{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}
{V : Type u} [quiver V] {a b c : V} : quiver.path a b â†’ quiver.path b c â†’ quiver.path a c
{Î± : Type u} {Î² : Type v} (f : filter Î±) (g : filter Î²) : filter (Î± Ã— Î²)
(M : Type u_1) (N : Type u_2) [monoid M] [monoid N] : Type (max u_2 u_1)
(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C
{G : Type u} [group G] (B : group_filter_basis G) : G â†’ filter G
(R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : â„•} (hb : 1 < b) : galois_insertion (Î» (r : â†¥(set.Ioi 0)), int.clog b â†‘r) (Î» (z : â„¤), âŸ¨â†‘b ^ z, _âŸ©)
(Î± : Type u) : category_theory.presieve Î±
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [topological_space Î±] [topological_space Î²] [topological_space Î³] (f : spectral_map Î² Î³) (g : spectral_map Î± Î²) : spectral_map Î± Î³
{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] : a < b - c â†” a + c < b
{Î± : Type u} (Î² : Î± â†’ Type (max u v)) [fin_enum Î±] [Î  (a : Î±), fin_enum (Î² a)] : list (Î  (a : Î±), Î² a)
 : Type
(M : Type u) [monoid M] (F : Type v) [field F] [mul_semiring_action M F] : subfield F
(L : first_order.language) (M : Type w) [L.Structure M] : Type w
{R : Type u_2} {Î“â‚€ : Type u_3} [linear_ordered_add_comm_monoid_with_top Î“â‚€] [comm_ring R] (v : add_valuation R Î“â‚€) : ideal R
(Î± : Type u_2) : Type u_2
(m : Type u â†’ Type v) (n : Type u â†’ Type w) : Type (max (u+1) v w)
{R : Type u} [ring R] {S : set R} (hs : is_subring S) : subring R
{C : Type u} [category_theory.category C] (X : C) : Prop
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (e : local_equiv Î± Î²) (e' : local_equiv Î² Î³) : local_equiv Î± Î³
(T : Type u) [topological_space T] : category_theory.pretopology.to_grothendieck (topological_space.opens T) (opens.pretopology T) = opens.grothendieck_topology T
(Î± : Sort u_1) (Î² : Sort u_2) : Sort (max 1 (imax u_1 u_2) (imax u_2 u_1))
{K : Type u_1} [has_repr K] : has_repr (generalized_continued_fraction.int_fract_pair K)
(n : Type u_1) (R : Type uâ‚‚) [decidable_eq n] [comm_ring R] [fintype n] : lie_subalgebra R (matrix n n R)
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : category_theory.pretopology C
(n : â„•) : ennreal
(Î± : Type u_6) (Î² : Type u_7) [preorder Î±] [preorder Î²] [add_zero_class Î±] [add_zero_class Î²] : Type (max u_6 u_7)
 : num â†’ â„• â†’ num
(Î± : Type u_1) {Î² : Type u_2} (b : Î²) (h : function.surjective (function.const Î± b)) : unique Î²
(P : pfunctor) (Î± : Type u_2) : Type (max u_1 u_2)
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : â„•) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V
{Î± : Type u} [preorder Î±] {a b : Î±} : a < b â†’ a â‰¤ b
{Î± : Type u_2} [has_div Î±] : has_div (filter Î±)
(Î± : Type u) [complete_lattice Î±] : omega_complete_partial_order Î±
 : Type
(Î± : Type u) [topological_space Î±] : Prop
{Î± : Type u_1} (o : ordinal) (f : Î  (a : ordinal), a < o â†’ Î±) : set Î±
{Î± : Type u} (n : Î± â†’ filter Î±) : topological_space Î±
{R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g
(n : pos_num) : Prop
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
{Î± : Type u} {Î² : Type v} [topological_space Î±] [preorder Î²] (f : Î± â†’ Î²) (a : Î±) : Prop
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : galois_insertion (affine_span k) coe
{Î± : Type u_1} [linear_ordered_add_comm_group Î±] {n : â„¤} (hn : n â‰  0) : function.injective (Î» (_x : Î±), n â€¢ _x)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†’ a < 1
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} : directed_on r s â†’ directed r coe
{X : Type u_1} [topological_space X] {x y : X} (Î³ : path x y) {x' y' : X} (hx : x' = x) (hy : y' = y) : path x' y'
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} (f : homotopy_equiv C D) : homotopy_equiv D C
 : Type (u+1)
{R : Type u_1} [mul_zero_class R] : is_right_regular 0 â†” subsingleton R
(M : Type u) : Type u
(E : Type u_6) [add_comm_group E] [has_norm E] : Prop
{Î± : Type u_1} (f : filter Î±) : Prop
{R : Type u} [non_assoc_semiring R] (s : subsemiring R) (m : multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Î±  : Type
{G : Type u_1} [monoid G] (tG : monoid.is_torsion G) : group G
(k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k âˆ…
{n : â„•} {Î± : fin (n + 1) â†’ Type u} (x : Î± 0) (p : Î  (i : fin n), Î± i.succ) (i : fin (n + 1)) : Î± i
 : has_inv pgame
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [normalized_gcd_monoid Î±] (s : multiset Î±) : Î±
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{Î± : Type u_1} [encodable Î±] {n : â„•} : encodable (vector Î± n)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
(R : Type u) [non_unital_semiring R] [partial_order R] : Type u
{Î± : Type u} [is_empty Î±] : unique (filter Î±)
(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_binary_products C] : category_theory.monoidal_category C
{Î± : Type u} [topological_space Î±] (x : Î±) : set Î±
{C : Type u} [category_theory.category C] (X Y : C) : Prop
{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A
 : Type (u+1)
{C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)
(p : â„•) [fact (nat.prime p)] (R : Type uâ‚) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)
(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K
{V : Type u} (G : simple_graph V) (v : V) : set V
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
(Î± : Type u) [infinite Î±] : ultrafilter Î±
(n : â„•) : finset (â„• Ã— â„•)
{V : Type u_1} {Î± : Type u_2} [has_zero Î±] [has_one Î±] [decidable_eq Î±] [decidable_eq V] (A : matrix V V Î±) : matrix V V Î±
 : num â†’ â„• â†’ bool
(c : cardinal) : ordinal
 : onote â†’ onote â†’ onote
{Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] : ordnode Î± â†’ ordnode Î±
{A : Type v} [ring A] : has_bracket A A
{Î± : Type u_1} {A : Type u_3} [add_group A] [monoid Î±] [distrib_mul_action Î± A] : mul_action Î± (add_subgroup A)
{Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : monotone f) (n : â„¤) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„¤) : f a â‰  x
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k â†’ PE) (a b : k) : E
(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) (h : v â‰  0) : module.ray R M
 : turing.to_partrec.code
{Î± : Type u} (c : computation Î±) : computation Î±
{M : Type u_1} [has_mul M] (S : subsemigroup M) : set M
 : Type
 : Type (u+1)
{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b â†” b < a
(G : Type u_1) [comm_group G] [topological_space G] [topological_group G] : uniform_space G
(G : Type u_1) [add_group G] : set G
(Î± : Type u) : Type u
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] [compact_space Î±] [compact_space Î²] : compact_space (Î± Ã— Î²)
{K : Type u_1} [field K] {p : â„•} [char_p K p] {t : â„•} (not_dvd : Â¬p âˆ£ t) : invertible â†‘t
{n : â„•} : bitvec n â†’ bitvec n â†’ bool
{R : Type u_1} {S : Type u_3} [non_unital_comm_ring R] [non_unital_comm_ring S] : non_unital_comm_ring (R Ã— S)
(L : first_order.language) : Prop
(o : ordinal) : ordinal
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] {p : Î¹ â†’ E} (hc : convex_independent ð•œ p) : function.injective p
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{Î± : Type u_1} (x : Î±) : list Î± â†’ Prop
{Î± : Type u} [lattice Î±] [bounded_order Î±] (x y : Î±) : Prop
{Î± : Type u_1} [ring Î±] (t : ring_topology Î±) : add_group_topology Î±
(Î± : Type u_1) [fintype Î±] : finite Î±
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : a â‰¤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
(M : Type u_1) [has_add M] : add_hom M M
{Î± : Type} (p : parser Î±) : Prop
{Î± : Type u_1} [has_le Î±] (s : set Î±) : Prop
 : nat.partrec.code
{Î¹ : Type u_1} (A : Î¹ â†’ Type u_2) [add_comm_monoid Î¹] : Type (max u_1 u_2)
(R : Type u_1) (m : Type u_2) (n : Type u_3) [fintype m] [fintype n] [semiring R] : basis (m Ã— n) R (matrix m n R)
{Î± : Type u_1} [monoid Î±] (a : Î±) : conj_classes Î±
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : with_zero (multiplicative â„¤)
{Î± : Type u_1} {n : â„•} (i : fin2 n) (v : vector3 Î± n) : Î±
(G : Type u) : Type u
{Î± : Type u_1} [fintype Î±] (h : 0 < fintype.card Î±) : trunc Î±
{Î± : Type u_1} (p : Î± â†’ Prop) : list Î± â†’ Prop
{Î± : Type u_1} [semilattice_inf Î±] [order_top Î±] (s : multiset Î±) : Î±
{Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î² â†’ Prop) : multiset Î± â†’ multiset Î² â†’ Prop
{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] (Kâ‚€ : topological_space.positive_compacts G) : measure_theory.measure G
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] (F : Î¹ â†’ Î± â†’ Î²) (f : Î± â†’ Î²) (p : filter Î¹) (s : set Î±) : Prop
{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
(n : â„•) : finset (fin n)
{Î± : Type u_2} [has_mul Î±] : has_mul (set Î±)
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_localization S
(k : â„•) : nat.arithmetic_function â„•
{Î² : Type u} {Î± : Type v} [comm_monoid Î²] (s : finset Î±) (f : Î± â†’ Î²) : Î²
{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [add_comm_semigroup P] (f : add_hom M P) (g : add_hom N P) : add_hom (M Ã— N) P
 : has_add pgame
(Î± : Type u_1) (Î² : Type u_2) : Type (max u_1 u_2)
{Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : a * -1 = -a
{R : Type u_1} [comm_semiring R] {S : Type u_2} [comm_semiring S] [algebra R S] (x : R) [is_localization.away x S] : S
{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 3
{A : Type u_1} {Î¹ : Type u_2} [ring A] [nonempty Î¹] {B : Î¹ â†’ add_subgroup A} (hB : ring_subgroups_basis B) : ring_filter_basis A
{Î± : Type u_1} [linear_order Î±] (a : Î±) : {a}.max' _ = a
{Î± : Type u} (a : Î±) : wseq Î± â†’ wseq Î±
{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) â†” is_add_left_regular b
{n : â„•} (P : mvpfunctor (n + 1)) (Î± : typevec n) : Type u
{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] : can_lift (bilin_form R M) (quadratic_form R M)
{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (Î» (h : G), g * h * gâ»Â¹)
(Î± : Type u_1) [measurable_space Î±] : Type u_1
 : num â†’ num â†’ znum
(Î± : Sort u) [has_variable_names Î±] {Î² : Sort v} : has_variable_names Î²
(C : Type u) [category_theory.category C] : Prop
(M : Type u_1) (Î± : Type u_2) [monoid M] [topological_space Î±] [mul_action M Î±] : Prop
{R : Type uâ‚} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2
(R : CommRing) : algebraic_geometry.Scheme
 : simps_cfg
(Î± : Type u) : Type u
(n : â„•) : Type
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space Î±] [locally_compact_space Î²] : continuous continuous_map.uncurry
(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A) : subalgebra R A
{V : Type u} (G : simple_graph V) : â„•
(X : Type u) [lattice X] : Type u
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î±] [complete_lattice Î²] (gi : galois_coinsertion l u) : complete_lattice Î±
(G : Type u_1) [topological_space G] [add_group G] [topological_add_group G] : add_subgroup G
{ð•œ : Type u_1} {E : Type u_2} [linear_ordered_field ð•œ] [ordered_add_comm_group E] [module ð•œ E] (s : set E) (hs : convex ð•œ s) : convex_cone ð•œ E
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] (f : Î± â†’ Î²) (s : set Î±) : Prop
(K : Type u) [division_ring K] {n : â„•} : finite_dimensional.finrank K (fin n â†’ K) = n
{R : Type u} [semiring R] (n : â„•) : polynomial R â†’ polynomial R
 : Type
{Î± : Type u} (g : set (set Î±)) : set Î± â†’ Prop
{Î± : Type u} [preorder Î±] (s : set Î±) (a : Î±) : Prop
{Î± : Type u_1} {P : set Î± â†’ Prop} (m : Î  (s : set Î±), P s â†’ ennreal) (P0 : P âˆ…) (m0 : m âˆ… P0 = 0) : measure_theory.outer_measure Î±
{Î± : Type v} {m l r : â„•} (A : matrix (fin m) (fin (l + r)) Î±) : matrix (fin m) (fin l) Î±
{Î± : Sort u_1} {Î² : Sort u_2} (q : trunc Î±) (f : Î± â†’ Î²) (c : âˆ€ (a b : Î±), f a = f b) : Î²
(Î± : Type u) [monoid Î±] : Type u
 : snum â†’ snum
{M : Type u_1} [add_monoid M] {x y z : M} : y âˆˆ multiples x â†’ z âˆˆ multiples x â†’ y + z âˆˆ multiples x
{C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : Prop
(T : Type u_1) : Type u_1
{Î± : Type u} (x : Î±) : free_ring Î±
{K : Type u} [field K] : has_top (subfield K)
(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : Prop
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist âˆ… s = 0
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace
{Î± : Type u} [topological_space Î±] [t2_space Î±] [compact_space Î±] : t2_space (connected_components Î±)
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
{Î¹ : Type u_1} [decidable_eq Î¹] [fintype Î¹] {Î± : Î¹ â†’ Type u_2} [S : Î  (i : Î¹), setoid (Î± i)] (f : Î  (i : Î¹), quotient (S i)) : quotient pi_setoid
{R : Type u_1} [comm_ring R] (E : EllipticCurve R) : R
(G : Type u_1) [has_inv G] [measurable_space G] : Prop
(Î± : Type u_2) : Type u_2
 : omega.nat.preterm â†’ â„•
(Î± : Type u_4) [has_le Î±] : Type u_4
{Î± : Type u_1} (f : Î± â†’ nnreal) (hf0 : tsum f â‰  0) : pmf Î±
{Î¹ : Type u_2} [encodable Î¹] {F : Î¹ â†’ Type u_3} [Î  (i : Î¹), metric_space (F i)] : has_dist (Î  (i : Î¹), F i)
(R : Type u) [semigroup R] : Type u
{C : Type u} [category_theory.category C] (T : category_theory.monad C) : Type u
{n : â„•} {Î² : Type u_1} (a : Î²) (q : fin n â†’ Î²) (b : Î²) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b
{R : Type u_1} [semiring R] (S : subsemiring R) : subalgebra â„• R
 : category_theory.reflective Profinite_to_CompHaus
(J : Type v) : Type v
{m n : â„•} (hmn : m.coprime n) : squarefree (m * n) â†” squarefree m âˆ§ squarefree n
(Î± : Type u) [preorder Î±] : category_theory.small_category Î±
{Î± : Type u_1} [has_add Î±] (s : set Î±) (a b : Î±) : Prop
(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (f : Î± â†’ Î²) : Prop
{Î± : Type u} (s : seq Î±) {aâ‚™ : Î±} {n m : â„•} (m_le_n : m â‰¤ n) (s_nth_eq_some : s.nth n = option.some aâ‚™) : âˆƒ (aâ‚˜ : Î±), s.nth m = option.some aâ‚˜
{n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n
{n : â„•} {Î± : Type u_1} (l : list Î±) (c : composition n) : list (list Î±)
{Î± : Type u} [uniform_space Î±] (h : is_complete set.univ) : complete_space Î±
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ multiset.Ico a b = 0
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V â†” âˆƒ (x : V), x â‰  0
{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_add M] [has_add N] [has_add P] (hnp : add_hom N P) (hmn : add_hom M N) : add_hom M P
{m : Type u_2} {Î± : Type v} (w : m â†’ Î±) : matrix m unit Î±
{Î± : Type u} {Î² : Type v} (c : computation Î±) (f : Î± â†’ computation Î²) : computation Î²
(X : BoolAlg) : BoundedDistribLattice
{p : â„•} [p_prime : fact (nat.prime p)] {a : â„¤} : multiplicity.finite â†‘p a â†” a â‰  0
{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 â‰¤ ifp_n.fr âˆ§ ifp_n.fr < 1
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : is_unit A â†” is_unit A.det
{Î± : Type u_1} (f : set Î± â†’ Î±) : Â¬function.injective f
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) : list (sigma Î²) â†’ option (Î² a) Ã— list (sigma Î²)
(C : Type u) [category_theory.category C] : Prop
(Î± : Type u_1) : Type u_1
{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a : Î±} : Â¬is_max a â†’ a < order.succ a
(M : Type u_1) [has_add M] : Type u_1
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X â†’ Y} [sequential_space X] : seq_continuous f â†’ continuous f
{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x
{E : â„• â†’ Type u_1} (x : Î  (n : â„•), E n) (s : set (Î  (n : â„•), E n)) : â„•
{M : Type u_1} [has_mul M] : has_inf (subsemigroup M)
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (s : add_submonoid M) (t : add_submonoid N) : add_submonoid (M Ã— N)
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) : list Î± â†’ list Î± â†’ Prop
{Î± : Type u_2} [mul_one_class Î±] : mul_one_class (set Î±)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
(m : â„•) : padic_val_rat m 0 = 0
{M : Type u_1} [has_add M] {c : add_con M} (x y : M) : â†‘(x + y) = â†‘x + â†‘y
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (ga : Î± â†’ Î± â†’ Î±) (gb : Î² â†’ Î² â†’ Î²) : Prop
(A : Type u_4) [monoid A] [topological_space A] : continuous_monoid_hom A A
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) [category_theory.limits.has_binary_biproduct P Q] : category_theory.limits.binary_bicone P Q
{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] (U : submodule R M) (x y : M) : Prop
{Î± : Type u_2} [has_add Î±] : has_add (set Î±)
(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E) : â†‘(intermediate_field.adjoin â†¥(intermediate_field.adjoin F S) T) = intermediate_field.adjoin F (S âˆª T)
(k : Type uâ‚) (G : Type uâ‚‚) [semiring k] : G â†’ add_monoid_algebra k G
(n : â„•) : â„• â†’ â„•
{R : Type u_1} [comm_ring R] (E : EllipticCurve R) : R
{Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆƒ (x : Î±) (h : p x), q x h) â†” âˆƒ (x : {a // p a}), q â†‘x _
(R : Type u_2) (Î“â‚€ : Type u_3) [linear_ordered_comm_monoid_with_zero Î“â‚€] [ring R] : Type (max u_2 u_3)
 : pgame
(Î± : Type u) : Type u
{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : cycle Î±
{Î± : Type u_1} (a : Î±) : part Î±
{X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : metric_space (X âŠ• Y)
{M : Type u_1} [comm_monoid M] (S : submonoid M) (N : Type u_2) [comm_monoid N] : Type (max u_1 u_2)
{Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} (h : c â‰¤ b) (h2 : a - c < b - c) : a < b
(p : Set â†’ Prop) : Set â†’ Set
{Î± : Type u} [topological_space Î±] {s t : set Î±} (H : is_preconnected s) (Kst : s âŠ† t) (Ktcs : t âŠ† closure s) : is_preconnected t
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_monoid_hom f
{Î± : Type u_8} [add_comm_semigroup Î±] : add_hom (Î± Ã— Î±) Î±
(H : Type u_5) [topological_space H] (M : Type u_6) : Type (max u_5 u_6)
(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom A B
{Î± : Type u} (s : wseq Î±) : computation â„•
(Î± : Type u_5) : Type u_5
{Î± : Type u_1} {a : Î±} {s : set Î±} (h : a âˆˆ s) : semiquot Î±
 : Type
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)
{Î± : Type u} {Î² : Î± â†’ Type v} [decidable_eq Î±] (a : Î±) (b : Î² a) : list (sigma Î²) â†’ list (sigma Î²)
{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [unique_factorization_monoid Î±] [dec : decidable_eq Î±] (a : Î±) : multiset {a // irreducible a}
{R : Type u} : tropical R â†’ R
{Î± : Type u_1} [complete_lattice Î±] : conditionally_complete_lattice Î±
{a : â„•} (a1 : 1 < a) : â„• â†’ â„• Ã— â„•
(g : Type) [random_gen g] : rand_g g g
(L : Type v) [lie_ring L] : non_unital_non_assoc_semiring L
{Î± : Type u_1} (n : â„•) (a : Î±) : list Î± â†’ list Î±
(Î± : Type u_7) (Î² : Type u_8) [measurable_space Î±] [measurable_space Î²] : Type (max u_7 u_8)
{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : stream (option (generalized_continued_fraction.int_fract_pair K))
(F : Type u â†’ Type v â†’ Type w) [bifunctor F] : Type (max (u+1) (v+1) w)
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ bool
{n : â„•} (c : composition_as_set n) : composition n
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : mâ‚‚ â‰¤ measurable_space.map f mâ‚ â†’ measurable f
 : category_theory.limits.has_limits_of_size (Type (max v u))
(Î± : Type u_2) : Type u_2
(tag : unit) {p : Prop} (h : p) : p
(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.grothendieck_topology C
{G : Type u} [add_monoid G] (x : G) : â„•
{k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] (p : submodule k V) : affine_subspace k V
(l : Type u_4) (R : Type uâ‚‚) [decidable_eq l] [comm_ring R] : matrix (l âŠ• l) (l âŠ• l) R
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a - b â‰¤ 0 â†’ a â‰¤ b
 : Type
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [polish_space Î±] [topological_space Î²] [polish_space Î²] : polish_space (Î± âŠ• Î²)
(l : Type u_4) (R : Type uâ‚‚) [decidable_eq l] [comm_ring R] : matrix (unit âŠ• l âŠ• l) (unit âŠ• l âŠ• l) R
 : Type
(Î± : Type u_1) [linear_order Î±] : circular_order Î±
 : monoid ordinal
 : Type (u_1+1)
{X : Type u_1} [topological_space X] {U : set X} [Î  (x : X), decidable (x âˆˆ U)] (hU : is_clopen U) : locally_constant X (fin 2)
{p : â„•} : padic_val_rat p 1 = 0
(a : snum) : snum â†’ snum
{Î± : Type u} : ordnode Î± â†’ Î± â†’ ordnode Î± â†’ Î± Ã— ordnode Î±
(p n : â„•) : â„•
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (a : Î±) : function.injective (f a)
{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_monoid_hom f
{Î¹ : Type u_1} [decidable_eq Î¹] (A : Î¹ â†’ Type u_2) [has_add Î¹] [Î  (i : Î¹), add_comm_monoid (A i)] : Type (max u_1 u_2)
{Î± : Type u_2} {Î² : Type u_3} (r : Î± â†’ Î² â†’ Prop) (t : set Î²) : set Î±
{R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)
(X : Profinite) : category_theory.limits.limit_cone X.diagram
(Î± : Type u_7) : Type u_7
{a : â„•} (a1 : 1 < a) (n : â„•) : â„•
{Î± : Type u_2} [has_inv Î±] : has_inv (set Î±)
{Î± : Type u} {Î² : Type v} [topological_space Î±] (f : Î² â†’ set Î±) : Prop
(R : Type u) (S : Type v) [semiring R] [semiring S] (p q : â„•) [char_p R p] [char_p S q] : char_p (R Ã— S) (p.lcm q)
{Î± : Type u} (câ‚ câ‚‚ : computation Î±) : computation Î±
{Î± : Type u_2} {Î² : Type u_3} [preorder Î±] [preorder Î²] (l : Î± â†’ Î²) (u : Î² â†’ Î±) : Type (max u_2 u_3)
{R : Type u} {M : Type v} (x : triv_sq_zero_ext R M) : M
{R : Type u_1} [has_mul R] {a : R} : is_left_regular a â†” is_smul_regular R a
{A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A
{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 4
(n : â„•) : n.choose 2 = n * (n - 1) / 2
{Î± : Type u} [preorder Î±] {a b c : Î±} : b = c â†’ a < b â†’ a < c
(X : Type u_1) : Type u_1
(G : Type u_2) [group G] [fintype G] (R : Type u_3) [comm_ring R] [mul_semiring_action G R] (x : R) : polynomial R
(Î± : Type u_1) [add_comm_group Î±] : Type u_1
{n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) : fin.snoc (fin.init q) (q (fin.last n)) = q
 : Â¬small ordinal
(R : Type u_1) (S : Type u_2) (M : Type u_3) : Type u_3
 : metric_space (â„• â†’ â„•)
{Î± : Type u_1} {Î² : Type u_2} (q : pmf (Î± â†’ Î²)) (p : pmf Î±) : pmf Î²
{Î± : Type u_2} {Î² : Type u_3} [monoid Î±] [mul_action Î± Î²] : mul_action Î± (set Î²)
{Î± : Type u_3} [preorder Î±] (n : â„•) [grade_order (fin n) Î±] : grade_order â„• Î±
{Î± : Type u_1} [decidable_eq Î±] : list Î± â†’ list (equiv.perm Î±)
{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) â†” is_add_right_regular b
{Î± : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : Î± â†’ G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (rk : Î± â†’ â„•) (s : set Î±) (n : â„•) (f : â„• â†’ Î±) : Prop
(m : â„•) {n : â„•} (hn : 0 < n) : (âˆƒ (k : â„•), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m
(x y : Set) : Set
 : Type (u+1)
(Î± : Type u_6) : Type u_6
{Î± : Type} (p : parser Î±) : Prop
(F : Type u â†’ Type u) [functor F] [q : qpf F] : Type u
{Î± : Type u} [has_mul Î±] [has_one Î±] [has_distrib_neg Î±] (a : Î±) [invertible a] : invertible (-a)
{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ð’œ : â„• â†’ submodule R A) [graded_algebra ð’œ] : Top
(n : â„•) (A : Type u) : mvpfunctor n
{M : Type u_1} [has_add M] : has_bot (add_subsemigroup M)
 : (Î» (n : â„•), â†‘(nat.fib n)) = Î» (n : â„•), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
{G : Type u_1} [group G] [group.is_nilpotent G] (h : group.nilpotency_class G â‰¤ 1) : comm_group G
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f
(n : â„•) : comm_semigroup (fin (n + 1))
(n : â„•) : Type
 : strict_mono (Î» (n : â„•), nat.fib (n + 2))
{Î± : Type u_1} {n : â„•} {s t : finset Î±} : s âˆˆ finset.powerset_len n t â†” s âŠ† t âˆ§ s.card = n
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) (s : set Î±) (t : set Î²) : Prop
{Î± : Type u_1} [comm_monoid_with_zero Î±] (a b : Î±) : Prop
 : â„• â†’ list â„•
(F : Type u_9) (Î± : Type u_10) (Î² : Type u_11) [monoid Î±] [monoid Î²] [topological_space Î±] [topological_space Î²] : Type (max u_10 u_11 u_9)
 : Sort u
{Î± : Type u_1} (s : multiset Î±) (hs : s â‰  0) : pmf Î±
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop
 : Type
{Î± : Type u} (s : set Î±) : Prop
{n : â„•} (h : 0 < n) : random (fin n)
{Î± : Type} [has_mul Î±] {ds : list â„•} : holor Î± ds â†’ Prop
(p : â„• â†’ Prop) [decidable_pred p] (n : â„•) : â„•
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : set Î±) (t : set Î²) : Prop
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} [has_coe Î± Î²] [has_coe_t Î² Î³] (a : Î±) : â†‘a = â†‘â†‘a
{Î± : Type u} [pseudo_metric_space Î±] {x : Î±} : metric.inf_dist x âˆ… = 0
{Î± : Type u_1} [linear_ordered_field Î±] (Î² : Type u_2) [ring Î²] (abv : Î² â†’ Î±) [is_absolute_value abv] : Prop
(Î± : Type u) (Î² : Type v) [add_group Î±] [add_action Î± Î²] : setoid Î²
 : topological_space ennreal
(n : pos_num) : â„• â†’ pos_num â†’ pos_num
(Î± : Type u_1) (Î² : Type u_2) [topological_space Î±] [topological_space Î²] : Type (max u_1 u_2)
(M : Type u_5) (N : Type u_6) [has_add M] [has_add N] : add_hom (M Ã— N) M
{V : Type u} (r : V â†’ V â†’ Prop) : simple_graph V
(F : Type u_1) (E : Type u_2) (K : Type u_3) [field F] [field E] [field K] [algebra F E] [algebra F K] : Type (max u_2 u_3)
{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x - y âˆˆ H
{R : Type u_1} [comm_semiring R] {X : Type u_2} : star_ring (free_algebra R X)
(R : Type u) [add_monoid R] : Type u
{Î³ : Type w} [preorder Î³] [order_bot Î³] (s : set Î³) : bdd_below s
{Î± : Type u_1} (l : ordnode Î±) (x : Î±) (m : ordnode Î±) (y : Î±) (r : ordnode Î±) : ordnode Î±
(R : Type w) [semiring R] (C : Type u) [category_theory.category C] [category_theory.preadditive C] : Type (max u v w)
 : â„•
(n : name) : bool
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] (x : M) : ideal R
{Î± Î² Î³ : Type} (l : list Î±) (p : Î± â†’ Î² Ã— Î³) [decidable_eq Î²] : list (Î² Ã— list Î³)
(M : Type u) : Type u
{m : Type v â†’ Type w} [applicative m] {Î± : Type u_1} {Î² : Type v} (f : â„• â†’ Î± â†’ m Î²) : â„• â†’ list Î± â†’ m (list Î²)
 : Type
(Î± : Type u_5) (Î² : out_param (Type u_6)) (Î³ : out_param (Type u_7)) : Type (max u_5 u_6 u_7)
(Î± : Type u_1) [topological_space Î±] : filter Î±
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†’ subsingleton Mâ‚€
{Î± : Type u} : wseq Î± â†’ wseq Î± â†’ Prop
 : Type
(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (x : B) : Type u_3
{Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (g : Î² â†’ Î±) (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} [has_le Î±] (s : set Î±) : Prop
{K : Type u_1} {Î² : Type u_2} (f : K â†’ Î²) (gp : generalized_continued_fraction.int_fract_pair K) : generalized_continued_fraction.int_fract_pair Î²
{m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0
{Î± : Type u_1} (s : multiset Î±) : (âˆƒ (x : Î±), x âˆˆ s) â†’ trunc Î±
{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R â‰  2) : -1 â‰  1
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
{Î± : Type u_2} [has_add Î±] (a : Î±) : Prop
{Î± : Type u_1} [preorder Î±] (t : ordnode Î±) : Prop
(p : set pSet) : pSet â†’ pSet
{C : Type uâ‚} [category_theory.category C] {X : C} (S R : category_theory.sieve X) : category_theory.sieve X
(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] (p : polynomial A) : tensor_product R A (polynomial R)
(C : Type u) : Type (u+1)
{Î± : Type u_1} [has_le Î±] [bounded_order Î±] [is_simple_order Î±] : preorder Î±
{Î± : Type u} {a b : Î±} [mul_zero_class Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
{Î± : Type u_1} [conditionally_complete_lattice Î±] (a : Î±) : has_Sup.Sup {a} = a
 : Type
(G : Type u) [group G] : Type u
{Î± : Type u_2} [has_neg Î±] : has_neg (filter Î±)
{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default
{M : Type u_1} [mul_one_class M] : has_bot (submonoid M)
(X : Type u_5) [t : topological_space X] : Prop
(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Prop
{K : Type u} [hring : comm_ring K] : ratfunc K â†’ ratfunc K â†’ ratfunc K
(m M N : â„•) (i : Î£ (n : â„•), fin n â†’ â„•) (hi : i âˆˆ formal_multilinear_series.comp_partial_sum_source m M N) : Î£ (n : â„•), composition n
{Î± : Type u} [has_mul Î±] [has_one Î±] (a : Î±) : Type u
{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_ascending_central_series H) (n : â„•) : H n â‰¤ upper_central_series G n
{Î± : Type u_1} [preorder Î±] [order_bot Î±] [locally_finite_order Î±] (b : Î±) : multiset Î±
(Î± : Type u_1) : Type u_1
{Î± : Type u_1} {Î² : Type u_2} : list Î± â†’ list Î² â†’ list (option Î± Ã— Î²) Ã— list Î±
 : Type
{Î± : Type u} {Î² : Type v} (fâ‚ fâ‚‚ : Î± â†’ Î²) (s : set Î±) : Prop
(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.faithful (category_theory.shift_functor C i)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)
(Î± : Sort u) (Î² : Î± â†’ Sort v) : setoid (Î  (x : Î±), Î² x)
{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_pullbacks C
(Î± : Type u_1) : Type u_1
(Î± : Type u) [add_group Î±] : Type u
(Î± : Type u_5) : Type u_5
{A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A â†” is_dedekind_domain_inv A
{M : Type u_1} [has_mul M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : con_gen r â‰¤ con_gen s
{Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [partial_order Î²] [semilattice_inf Î±] (gi : galois_insertion l u) : semilattice_inf Î²
{Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.mul_pos_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (b0 : 0 â‰¤ b) : 1 â‰¤ a * b
{Î± : Type u} [has_le Î±] [decidable_rel has_le.le] (x : Î±) : ordnode Î± â†’ option Î±
{Î± : Type u_1} [decidable_eq Î±] {s t u : multiset Î±} : s - t â‰¤ u â†” s â‰¤ u + t
{Î± : Type u_1} (R : Î± â†’ Î± â†’ Prop) : Î± â†’ list Î± â†’ Prop
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] : continuous coe_fn
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop
{Î± : Type u_1} [comm_semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ c * b
{p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : Â¬p n â†’ nat.count p (n + 1) = nat.count p n
(ð•œ : Type u_1) (E : Type u_2) [comm_semiring ð•œ] [topological_space ð•œ] [has_continuous_add ð•œ] [has_continuous_const_smul ð•œ ð•œ] [add_comm_monoid E] [module ð•œ E] [topological_space E] : Type u_2
{Î± : Type u} [add_comm_group Î±] : is_add_group_hom has_neg.neg
{K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K] : simple_continued_fraction K
{Î± : Type u_2} {Î² : Type u_3} [topological_space Î±] [preorder Î±] [topological_space Î²] [preorder Î²] (f : esakia_hom Î± Î²) : pseudo_epimorphism Î± Î²
{K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x â†” is_integral K x
 : onote â†’ onote â†’ ordering
{Î± : Type u_1} [semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ b * c
{Î± : Type u} [linear_order Î±] : Î± â†’ Î± â†’ set Î±
{Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), metric_space (E i)] : has_dist (Î£ (i : Î¹), E i)
{C : Type u_1} [category_theory.category C] (r : hom_rel C) : Prop
(n : â„•) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n â„¤) = polynomial.cyclotomic n R
(m n : â„¤) : list â„¤
 : Type u â†’ Type u
 : category_theory.limits.has_limits_of_size Group
{M : Type u_3} [add_comm_group M] {Râ‚‚ : Type u} [ordered_ring Râ‚‚] [module Râ‚‚ M] (Qâ‚‚ : quadratic_form Râ‚‚ M) : Prop
(Î± : Type u_3) [has_sup Î±] [has_bot Î±] : sup_bot_hom Î± Î±
 : snum â†’ â„¤
 : onote â†’ onote â†’ onote
{Î± : Type u_1} [group Î±] : has_quotient Î± (subgroup Î±)
 : Type (u_1+1)
(Î± : Type u) : Type u
{R : Type u} [semiring R] {a b : add_monoid_algebra R â„•} : {to_finsupp := a} = {to_finsupp := b} â†” a = b
 : â„• â†’ â„•
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_terminal C
{Î± : Type v} {d u l r : â„•} (A : matrix (fin (u + d)) (fin (l + r)) Î±) : matrix (fin d) (fin r) Î±
{M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
(G : Type u_1) [group G] : set G
{G : Type u_10} [group_with_zero G] (a : G) (ha : a â‰  0) : equiv.perm G
 : set.inj_on nat.factorization {x : â„• | x â‰  0}
{Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), monoid (M i)] : free_product.word M
{Î± : Type uu} {r : Î± â†’ Î± â†’ Prop} [decidable_rel r] {l : list Î±} (h : list.sorted r l) : list.insertion_sort r l = l
{x k l : â„•} (w : 1 < x) : x ^ k âˆ£ x ^ l â†” k â‰¤ l
{Î± : Type u_1} [is_empty Î±] : finset.univ = âˆ…
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj
(J : Type v) : Type v
{Î± : Sort u_1} [s : setoid Î±] : quotient s â†’ Î±
(L : first_order.language) (M : Type u_3) [L.Structure M] : Type u_3
{M : Type u_1} [monoid M] (S : submonoid M) : submonoid M
(R : Type u_1) (S : Type u_2) [comm_ring R] [comm_ring S] [algebra R S] : bilin_form R S
{K : Type u} [field K] {S T : subfield K} (h : âˆ€ (x : K), x âˆˆ S â†” x âˆˆ T) : S = T
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) (s t : set Î±) : Prop
{Î± : Type u_2} [decidable_eq Î±] [has_one Î±] [has_mul Î±] [has_inv Î±] : has_pow (finset Î±) â„¤
{J : Type uâ‚} [category_theory.category J] : J â†’ J â†’ Prop
{M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} (C D : homological_complex V c) : Type (max u_1 v)
{Î± : Type u_1} [group Î±] (s : subgroup Î±) : setoid Î±
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj
 : â„• â†’ onote
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e e' : local_homeomorph Î± Î²) : Prop
{R : Type u} [comm_ring R] (f : polynomial R) (x y : R) : {z // polynomial.eval x f - polynomial.eval y f = z * (x - y)}
(Î± : Type u_2) [has_lt Î±] : Prop
(Î± : Type u_1) : Type u_1
{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} (hab : a â‰  b) : closure (set.Ioo a b) = set.Icc a b
(Î± : Type u) [topological_space Î±] : Prop
(Î± : Type u_1) : setoid (list Î±)
{Î± : Type u} [group Î±] (g : group_topology Î±) : continuous (Î» (p : Î± Ã— Î±), p.fst * p.snd)
{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.bounded (s âˆª t) â†” metric.bounded s âˆ§ metric.bounded t
{Î± : Sort u} {Î² : Sort v} {f : Î± â†’ Î²} [inhabited Î±] [subsingleton Î²] (hf : function.injective f) : unique Î±
{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a âˆ§ is_regular b
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
(L : Type v) : Type v
(L : first_order.language) : Type (max u v)
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a < b â†’ a - b < 0
(R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4
 : Type
(Î± : Type u) : Type u
(Î± : Type u_1) (Î² : Type u_2) : Type (max u_1 u_2)
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x âˆˆ S â†’ -x âˆˆ S
{Î± : Type u_1} {Î² : Type u_2} [has_le Î²] [decidable_rel has_le.le] (f : Î± â†’ Î²) (t : ordnode Î±) : ordnode Î²
{a b : Prop} (hâ‚ : a â†’ b) (hâ‚‚ : Â¬b) : Â¬a
(Î± : Type u) [has_add Î±] [has_le Î±] : Prop
 : Type
 : category_theory.abelian AddCommGroup
{M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1
{Î± : Type u} {Î² : Type v} {Î´ : Type w} (f : Î± â†’ Î² â†’ Î´) : lazy_list Î± â†’ lazy_list Î² â†’ lazy_list Î´
(Î± : Type) [has_zero Î±] [has_one Î±] [has_add Î±] : parser Î±
{K : Type u} [field K] (s : subfield K) : 1 âˆˆ s
{Î± : Type u_2} [decidable_eq Î±] [add_comm_monoid Î±] : add_comm_monoid (finset Î±)
{X : Type u_1} (to_two_(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : â„•
(F : Type u â†’ Type u) [applicative F] [is_lawful_applicative F] : applicative_transformation id F
{Î± : Type u} [decidable_eq Î±] (i j : Î±) : setoid (equiv.perm Î±)
 : Type
(Î± : Type u) : bool â†’ Type u
{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b = 0 â†” a = 0 âˆ¨ b = 0
{G : Type u_1} [group G] (s : set G) : Prop
(n : â„•) : Type
(p : â„•) [hp : fact (nat.prime p)] (n : â„•) : mv_polynomial (fin 2 Ã— â„•) â„¤
{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length
(p : â„•) : â„• â†’ â„¤
(G : Type u_1) [group G] : Prop
{Î± : Type u_1} [add_right_cancel_semigroup Î±] (a : Î±) : complex_shape Î±
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X â†’ Y} {s : set X} : lipschitz_on_with C f s â†’ holder_on_with C 1 f s
{Î± : Type u_1} [decidable_eq Î±] : list Î± â†’ list Î±
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b â‰¤ 1
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] : setoid (local_homeomorph Î± Î²)
(f : ordinal â†’ ordinal) : Prop
(Î± : Type u_1) (Î² : Type u_2) [linear_order Î±] [linear_order Î²] : Type (max u_1 u_2)
{Î± : Type u_1} [omega_complete_partial_order Î±] (y : Scott Î±) : set (Scott Î±)
(n : name) : name
{R : Type uâ‚} [non_unital_non_assoc_semiring R] : smul_comm_class â„• R R
{Î± : Type u_1} [semigroup Î±] {a b : Î±} (c : Î±) (h : a * c = b) : a âˆ£ b
{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) (h : t âŠ† s) : is_compact t
{Î± : Type u} {Î² : Î± â†’ Type v} (a : Î±) (b : Î² a) : alist Î²
{R : Type u_1} [semiring R] (s : set R) : subsemiring R
(x y f : Set) : Prop
 : Type (u+1)
 : Type (u_1+1)
{Î± : Type u_1} (a : Î±) (s : multiset Î±) : multiset Î±
(k : Type u) [field k] : Type u
 : Type
{n : â„•} (a : composition n) (b : composition a.length) : composition n
{M : Type u_1} (S : set M) [add_semigroup M] : add_subsemigroup M
{R : Type u} [comm_ring R] [nontrivial R] : invariant_basis_number R
{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)
 : Type
{Î± : Type u} (l : list Î±) : dlist Î±
{R : Type u_1} [has_zero R] [has_one R] [has_add R] [has_neg R] {n : â„•} : zmod n â†’ R
{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
{Râ‚‚ : Type u_5} [comm_semiring Râ‚‚] {n : Type u_11} [fintype n] (M : matrix n n Râ‚‚) : bilin_form Râ‚‚ (n â†’ Râ‚‚)
{Î± : Sort u_1} {p : Î± â†’ Prop} (x : subtype p) : Î±
(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : Â¬is_unit (minpoly A x)
{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : b < a) : Â¬is_min a
{Î± : Type u_1} [has_zero Î±] [has_one Î±] [has_add Î±] (n : â„•) : Î±
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : b â‰¤ a â†’ 0 â‰¤ a - b
{Î± : Type u_2} [comm_semigroup Î±] : comm_semigroup (set Î±)
{Î³ : Type u_1} [U : uniform_space Î³] (m : emetric_space Î³) (H : uniformity Î³ = uniformity Î³) : emetric_space Î³
(Î± : Type u) : Type u
(out : out_param (Type u â†’ Type v)) (m : Type u â†’ Type v) : Type (max (u+1) v)
{C : Type uâ‚} [category_theory.category C] {J : category_theory.grothendieck_topology C} (X Y : category_theory.SheafOfTypes J) : Type (max u_1 uâ‚)
{Î± : Type u_1} {Î² : Type u_2} [omega_complete_partial_order Î±] [omega_complete_partial_order Î²] (c : omega_complete_partial_order.chain (Î± Ã— Î²)) : Î± Ã— Î²
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ multiset.Icc a b = 0
{Î± : Type u_1} : list Î± â†’ list (list Î±)
(o : ordinal) : pgame
(F A : Class) : Class
(Î± : Type u_7) [measurable_space Î±] : Prop
{M : Type u_1} (R : Type u_3) [decidable_eq M] [comm_semiring R] (m : M) : submodule R (add_monoid_algebra R M)
(p : nat.primes) : â†‘p.factor_multiset = prime_multiset.of_prime p
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} (c : Î³) : Î± âŠ• Î² âŠ• Î³
 : Type
(Î³ : Type) : Type
{Î± : Type u} : wseq Î± â†’ wseq Î±
{S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S
(op : ordinal â†’ ordinal â†’ ordinal) (o : ordinal) : ordinal
{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < c - a â†’ a + b < c
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_strict_order Î± r] : partial_order Î±
{Î± : Type u_1} [denumerable Î±] : denumerable (option Î±)
{n : â„•} : has_well_founded (fin n)
 : Type (u+1)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J â†’ C) : Type (max u v)
{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ < b â†” bâ»Â¹ < a
{M : Type u_1} [monoid M] (s : set M) : set M
{G : Type u_1} [group G] (s : set G) : subgroup G
{Î± : Type u} [decidable_eq Î±] : free_group Î± â†’ list (Î± Ã— bool)
{A : Type v} [ring A] {R : Type u} [comm_ring R] [algebra R A] : lie_algebra R A
(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] (z : K) : K
(Î± : Type u_2) [has_le Î±] [bounded_order Î±] : Prop
{Î± : Type v} {d u n : â„•} (A : matrix (fin (u + d)) (fin n) Î±) : matrix (fin u) (fin n) Î±
(Î± : Type u_2) : Type u_2
{R : Type u_1} [mul_zero_class R] : Â¬is_left_regular 0 â†” nontrivial R
 : Type
{F : Type u} [decidable_eq F] [field F] (s : finset F) (f : F â†’ F) : polynomial F
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] (f : measure_theory.simple_func Î± Î²) (g : Î² â†’ measure_theory.simple_func Î± Î³) : measure_theory.simple_func Î± Î³
(Î¹ : Type u_4) (B : Type u_5) [topological_space B] (F : Type u_6) [topological_space F] : Type (max u_4 u_5 u_6)
{G : Type u_10} [group G] (a : G) : equiv.perm G
 : has_mod ordinal
{M : Type u_4} [mul_one_class M] (self : submonoid M) : subsemigroup M
{Î± : Sort u_1} (P : Prop) [decidable P] (x : Â¬P â†’ Î±) (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (Î» (h : P), y _) x
{Î± : Type u_1} {Î² : Type u_2} [normed_ring Î±] [normed_ring Î²] : normed_ring (Î± Ã— Î²)
{Î± : Type u} [lattice Î±] [comm_group Î±] : has_neg_part Î±
{X : Type u_1} [topological_space X] {Y : Type u_2} [topological_space Y] {f : Y â†’ X} (cont : continuous f) (A : discrete_quotient Y) (B : discrete_quotient X) : Prop
(R' : Type u) (S' : Type v) (T' : Type w) [comm_semiring R'] [comm_semiring S'] [comm_semiring T'] [algebra R' S'] [algebra S' T'] : algebra (polynomial R') (S' â†’ T')
{C : Type u} [category_theory.category C] : has_le (category_theory.grothendieck_topology C)
(C : Type u) [category_theory.category C] : Prop
 : Type
(Î± : Type u_4) : Type u_4
 : Type
(P : Type u_2) [has_le P] : Type u_2
(n : â„•) : mv_polynomial â„• â„¤
{Î± : Type u_1} (l : list Î±) : array l.length Î±
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type v
{Î± : Type u_1} [decidable_eq Î±] [monoid Î±] {s : finset Î±} : decidable (mul_salem_spencer â†‘s)
(S : Type u_4) (M : out_param (Type u_5)) [has_mul M] [set_like S M] : Type
(p : â„•) [hp : fact (nat.prime p)] : â„• â†’ mv_polynomial (fin 1 Ã— â„•) â„¤
(Î± : Type u_1) [complete_lattice Î±] : well_founded gt â†’ complete_lattice.is_sup_closed_compact Î±
{G : Type u_1} [group G] (H K : subgroup G) : Prop
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V
(Î± : Type u_1) [nonempty_fin_lin_ord Î±] : NonemptyFinLinOrd
{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] : submonoid S
{R : Type u} [semiring R] (p : polynomial R) : â„•
(Î± : Type u) : Type u
{Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±) : ite (Â¬P) a b = ite P b a
{C : Type uâ‚} [category_theory.category C] {X : C} : inhabited (category_theory.sieve X)
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} (h : is_chain r s) : is_chain (flip r) s
(Î± : Type u_3) [omega_complete_partial_order Î±] : Type u_3
{X : Type u_1} [topological_space X] {A : set X} (h : is_clopen A) : discrete_quotient X
{Î¹ : Type u_1} {R : Type u_3} (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] [subsingleton M] [is_empty Î¹] : basis Î¹ R M
(Î± : Type u_1) [linear_ordered_ring Î±] [archimedean Î±] : floor_ring Î±
(S : Type u_3) (G : Type u_4) [div_inv_monoid G] [set_like S G] : Type
{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) {p : Î² â†’ Prop} (h : âˆ€ (a : Î±), p (f a)) : Î± â†’ subtype p
{ð•œ : Type u_5} [normed_field ð•œ] {ð•œ' : Type u_1} [normed_ring ð•œ'] [normed_algebra ð•œ ð•œ'] : normed_space ð•œ ð•œ'
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : bâ»Â¹ * a < c â†’ a < b * c
(Î± : Type u) : Type u
(Î± : Type u_6) (Î² : Type u_7) [topological_space Î±] [preorder Î±] [topological_space Î²] [preorder Î²] : Type (max u_6 u_7)
{K : Type u} [field K] (s : subfield K) (m : multiset K) : (âˆ€ (a : K), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
{R : Type u} [comm_ring R] (f : polynomial R) : Type u
{Î± : Type u_1} (f : filter Î±) : filter_basis Î±
(Î± : Type u_1) [preorder Î±] : topological_space Î±
(n : num) : Prop
 : pSet â†’ Set
(Î± : Type u) : Type u
{M : Type u_1} [add_zero_class M] : has_coe (add_con M) (add_submonoid (M Ã— M))
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] (a b : Î±) : finset Î±
 : num â†’ pos_num
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : a < 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b < 1
{Î± : Type u_1} {P : Î± â†’ Prop} [encA : encodable Î±] [decP : decidable_pred P] (v : â„•) : option {a // P a}
{C : Type u} [category_theory.groupoid C] (X : C) : group (category_theory.End X)
{Î± : Type u_1} [has_one Î±] [has_zero Î±] [has_lt Î±] : has_coe (continued_fraction Î±) (simple_continued_fraction Î±)
{n : â„•} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Type (max u v)
{g : Type} [random_gen g] : rand_g g â„•
{Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : (a * d - b * c) / (c * d) < 0 â†’ a / c < b / d
(R : Type u_1) [has_zero R] : Type u_1
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C
{P : â„• â†’ Sort u_1} (h : Î  (n : â„•), P (n + 1) â†’ P n) {m n : â„•} (mn : m â‰¤ n) (hP : P n) : P m
(R : Type u_1) [monoid_with_zero R] : mul_action_with_zero R R
(G : Type u_2) : Type u_2
(Î± : Type u) : Type u
{Î± : Type u_1} [has_le Î±] (s : lower_set Î±) : upper_set Î±
{R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : p âˆ£ ring_char R â†” p âˆ£ fintype.card R
{ð•œ : Type u_1} [linear_ordered_field ð•œ] {R : Type u_2} [comm_ring R] (abv : R â†’ ð•œ) [is_absolute_value abv] : uniform_space R
(Î± : Type u_1) (Î² : Type u_2) [topological_space Î±] [topological_space Î²] : Prop
(Î± : Type u_1) : Type u_1
(n : â„•) : Type
(ð•œ : Type u_1) (E : Type u_2) [ordered_ring ð•œ] [add_comm_group E] [module ð•œ E] : has_inf (geometry.simplicial_complex ð•œ E)
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y â†’ same_ray R (-x) (-y)
(M : Type u) [monoid M] {F : Type v} [field F] [mul_semiring_action M F] (S : subfield F) : Prop
{Î± : Type u_1} {Î³ : Î± â†’ Type u_3} [encodable Î±] [Î  (a : Î±), encodable (Î³ a)] : sigma Î³ â†’ â„•
{Î± : Type u_1} [decidable_eq Î±] (s : finset Î±) : has_bot (finpartition s)
{ð•œ : Type u_1} {V : Type u_2} [normed_field ð•œ] [add_comm_group V] [module ð•œ V] : has_top (enorm ð•œ V)
{Î± : Type u_1} (s : multiset (multiset Î±)) : multiset (multiset Î±)
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : 0 â‰¤ -a â†” a â‰¤ 0
{Î± : Type u} {Î² : Type v} (m : Î± â†’ Î²) (f : filter Î²) : filter Î±
{Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_hom f) : is_add_hom (Î» (a : Î±), -f a)
(G : Type u) [group G] : Type u
{Î± : Type u_1} [encodable Î±] (s : multiset Î±) : â„•
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] (p q : polynomial K) : ratfunc K
{Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a â‰  b â†’ order.pred a â‰  order.pred b
{X : Type u_1} [topological_space X] [t0_space X] : t0_space (alexandroff X)
{Î² : Type w} {C : Type u} [category_theory.category C] (f : Î² â†’ C) [category_theory.limits.has_coproduct f] : C
{Î± : Type u} (r s : Î± â†’ Î± â†’ Prop) [is_nonstrict_strict_order Î± r s] {a b : Î±} : s a b â†” r a b âˆ§ Â¬r b a
 : Type
{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < c - a
{R : Type u} [comm_ring R] : compact_space (prime_spectrum R)
{R : Type u} [ring R] (s : subring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
{L R : Type v} (fst snd : R â†’ L) : Type v
(G : Type u) : Type u
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : -a â‰¤ b â†’ -b â‰¤ a
{Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : Î±) (s : finset Î±) : finset Î±
(G : Type u_1) [add_monoid G] : Prop
(Î± : Type u_8) (Î² : Type u_9) [complete_lattice Î±] [complete_lattice Î²] : Type (max u_8 u_9)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X
{Î± : Type} (cmd : rand Î±) : io Î±
{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : list X
(x y z : â„¤) : Prop
{R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g
{Î± : Type u} (c : computation (computation Î±)) : computation Î±
{Î± : Type u_1} {Î² : Type u_2} [bornology Î²] (f : Î± â†’ Î²) : bornology Î±
{Î± : Type u} [lattice Î±] [add_comm_group Î±] : has_pos_part Î±
{Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hf : dense_range f) (b : Î²) : Îº
{Î± : Type u_1} {m : multiset Î±} {Î² : Î± â†’ Type u_2} [h : Î  (a : Î±), decidable_eq (Î² a)] : decidable_eq (Î  (a : Î±), a âˆˆ m â†’ Î² a)
{Î± Î² Î³ : Type} (p : Î± â†’ Î² Ã— Î³) [decidable_eq Î²] (b' : Î²) : list Î± â†’ list Î³ Ã— list Î±
{Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î± â†’ Prop) (f : filter Î²) (u : Î² â†’ Î±) : Prop
{Î± : Type u_1} [linear_ordered_field Î±] {a b c : Î±} (hb : 0 â‰¤ b) (hc : 0 â‰¤ c) (h : a â‰¤ c * b) : a / b â‰¤ c
(Î± : Type u_2) [fintype Î±] [nonempty Î±] [lattice Î±] : complete_lattice Î±
{Î± : Type u_1} {Î¹ : Type u_2} {Îº : Type u_3} (C : (Î¹ â†’ option Î±) â†’ Îº) : Type (max u_1 u_2 u_3)
{n : â„•} (m : â„•) (i : fin (n + m)) (h : m â‰¤ â†‘i) : fin n
(K : Type u) [field K] : valuation_ring K
(Î± : Type u_1) : Type u_1
{P : Type u_1} [semilattice_sup P] [is_directed P ge] : has_sup (order.ideal P)
{Î± : Type u_1} [linear_ordered_field Î±] {m n : â„•} : â†‘(m / n) â‰¤ â†‘m / â†‘n
{Ï„ : Type u_1} [add_comm_group Ï„] [topological_space Ï„] [topological_add_group Ï„] {Î± : Type u_2} [topological_space Î±] (Ï• : flow Ï„ Î±) : flow Ï„ Î±
{Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²) : Prop
{Î± : Type u_1} (p : Î± â†’ Prop) [decidable_pred p] (l : finset Î±) (hp : âˆƒ! (a : Î±), a âˆˆ l âˆ§ p a) : Î±
(R : Type u_1) [comm_ring R] : Prop
(P : pfunctor) : Type u_1
(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : subalgebra R A
(p : â„•) : decidable (nat.prime p)
{R : Type u} [semiring R] (f : polynomial R) (n : â„•) : polynomial R
{F : Type u_1} [field F] (p : polynomial F) : Type u_1
{G : Type u_1} [add_group G] : complete_lattice (add_subgroup G)
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ finset.Ico a b = âˆ…
(S : Type u_1) (K : out_param (Type u_2)) [field K] [set_like S K] : Type
 : cardinal
