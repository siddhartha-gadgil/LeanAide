cont_mdiff I I' n f â†” continuous f âˆ§ âˆ€ (x : M) (y : M'), cont_diff_on ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (f â»Â¹' (ext_chart_at I' y).source))
has_nndist.nndist x z â‰¤ has_nndist.nndist x y + has_nndist.nndist y z
is_noetherian K V â†” module.rank K V < cardinal.aleph_0
B.sum (Î» (t : finset Î±), (s âˆ© t).card) â‰¤ s.card * n
f = g
is_open_map (tangent_bundle.proj I M)
s = t
(list.drop (i + 1) L).sum = -L.nth_le i p + (list.drop i L).sum
a - b < 0 â†” a < b
a â€¢ s âŠ† b â€¢ s
category_theory.has_lifting_property i p â†” âˆ€ {e : i.right âŸ¶ p.right}, âˆƒ (l : i.right âŸ¶ p.left), l â‰« p.hom = e
a * b â‰¤ 1
polynomial.X ^ m - 1 âˆ£ n.proper_divisors.prod (Î» (i : â„•), polynomial.cyclotomic i R)
â‡‘e (â‡‘(e.symm) y) = y
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), witt_vector.verschiebung_fun)
cont_diff ğ•œ n (Î» (x : E), â‡‘g (f x))
is_add_regular â†‘a
quasi_sober Î±
A.is_diag
tendsto_locally_uniformly F f p â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆ€ (x : Î²), âˆƒ (t : set Î²) (H : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_dist.dist (f y) (F n y) < Îµ
deriv_within (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s b = c
â‡‘S (ğŸ™ X) â†” S = âŠ¤
has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 â†” euclidean_geometry.angle p1 p2 p3 = real.pi / 2
âŠ¥ < f.ker
matrix.dot_product v (A.mul_vec w) = matrix.dot_product (matrix.vec_mul v A) w
category_theory.limits.has_kernels C
â‡‘f =áµ[Î¼] â‡‘g
G.adj v w â†” v â‰  w âˆ§ âˆƒ (e : sym2 V) (H : e âˆˆ G.edge_set), v âˆˆ e âˆ§ w âˆˆ e
s.nonempty â†’ (â‡‘(convex_hull ğ•œ) s).nonempty
âˆƒ (x : G), add_order_of x = p
a âŠ‚ c
continuous (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼)
function.injective â‡‘(f.ker_lift)
(finset.range n).sum (Î» (i : â„•), f (i + 1) - f i) = f n - f 0
submodule.span R (â‡‘(algebra_map R S) '' a) = submodule.map (algebra.linear_map R S) (submodule.span R a)
â‡‘(linear_map.det_aux (trunc.mk b)) f = (â‡‘(linear_map.to_matrix b b) f).det
l <+ l' â†” âˆƒ (f : â„• â†ªo â„•), âˆ€ (ix : â„•), l.nth ix = l'.nth (â‡‘f ix)
â‡‘Î¼ (f '' s) = 0
category_theory.has_lifting_property i (category_theory.arrow.mk (f â‰« g))
b < a â†’ â‡‘order_dual.of_dual a < â‡‘order_dual.of_dual b
e.to_local_equiv.target = e'.to_local_equiv.target
â‡‘(star_ring_end ğ•œ) Î¼ = Î¼
âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), f x
set.eq_on f g (complex.im â»Â¹' set.Icc a b)
finset.univ.sum (Î» (g : G), â‡‘f g) = ite (f = 1) â†‘(fintype.card G) 0
category_theory.limits.colimit.Î¹ (category_theory.curry.obj (category_theory.prod.swap K J â‹™ F) â‹™ category_theory.limits.lim) k â‰« category_theory.limits.colimit_limit_to_limit_colimit F â‰« category_theory.limits.limit.Ï€ (category_theory.curry.obj F â‹™ category_theory.limits.colim) j = category_theory.limits.limit.Ï€ ((category_theory.curry.obj (category_theory.prod.swap K J â‹™ F)).obj k) j â‰« category_theory.limits.colimit.Î¹ ((category_theory.curry.obj F).obj j) k
âˆ« (x : â„) in a..X, real.exp (-b * x) â‰¤ real.exp (-b * a) / b
(âˆ€ (x : K), x âˆˆ s â†’ is_integral F x âˆ§ polynomial.splits (algebra_map F L) (minpoly F x)) â†’ nonempty (â†¥(algebra.adjoin F â†‘s) â†’â‚[F] L)
s.pairwise r â†’ pairwise (Î» (x y : â†¥s), r â†‘x â†‘y)
a - c < b â†’ a < b + c
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t  s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
(x * y).snd = triv_sq_zero_ext.fst x * triv_sq_zero_ext.snd y + triv_sq_zero_ext.fst y * triv_sq_zero_ext.snd x
s âˆˆ nhds_within a (set.Ioi a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ioo a u âŠ† s
âˆƒá¶  (n : â„•) in filter.at_top, âˆ€ (k : â„•), k < n â†’ u k < u n
{x : Î“â‚€ | x < â†‘Î³} âˆˆ nhds 0
âˆƒ (p : nnreal) (H : p â‰¤ r), has_sum g p
turing.to_partrec.step_normal c (k.then k') v = (turing.to_partrec.step_normal c k v).then k'
category_theory.limits.has_colimit D
f x âˆˆ set.Icc 0 1
ring_hom_inv_pair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚
f = g
emetric.ball x âŠ¤ = set.univ
finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary (f âˆ˜ â‡‘Ïƒ) g
â‡‘(p.to_outer_measure) s â‰¤ â‡‘(p.to_outer_measure) t
0 â‰¤ (generalized_continued_fraction.of v).denominators n
has_strict_deriv_at f (deriv f x) x
liouville_with q x
p âˆˆ s â†’ p âˆˆ span_points k s
âˆƒ (j : Î¹) (hij : i â‰¤ j), â‡‘(f' i j hij) x = 0
let PR : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), pr a (cf, cg, hf, hg), CO : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), co a (cf, cg, hf, hg), PC : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), pc a (cf, cg, hf, hg), RF : Î± â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf : nat.partrec.code) (hf : Ïƒ), rf a (cf, hf), F : Î± â†’ nat.partrec.code â†’ Ïƒ := Î» (a : Î±) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a) in computable (Î» (a : Î±), F a (c a))
a âŠ“ has_Sup.Sup s = â¨† (t : finset Î±) (H : â†‘t âŠ† s), a âŠ“ t.sup id
category_theory.cover_lifting J J (ğŸ­ C)
path.homotopic.proj i (path.homotopic.pi paths) = paths i
t.orthocenter = 3 â€¢ (finset.centroid â„ finset.univ t.points -áµ¥ affine.simplex.circumcenter t) +áµ¥ affine.simplex.circumcenter t
Â¬a â‹– b â†’ (âˆƒ (c : Î±), a < c âˆ§ c < b)
continuous (Î» (x : Î± Ã— Î²), f x.fst)
(h.comp g).comp f = h.comp (g.comp f)
directed ge (Î» (Î³â‚€ : Î“â‚€Ë£), filter.principal {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
a < real.pi
(ğŸ™ X - p) â‰« (ğŸ™ X - p) = ğŸ™ X - p
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t  s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
l.closed = set.range (u âˆ˜ â‡‘l)
filter.tendsto (Î» (n : â„•), Î¼.test_against_nn (fs n)) filter.at_top (nhds (Î¼.test_against_nn f))
p ^ (n + 1) âˆ£ fintype.card â†¥(H.normalizer)
is_max_on f s a
iterated_fderiv ğ•œ (n + 1) f x = (â‡‘(continuous_multilinear_curry_right_equiv' ğ•œ n E F) âˆ˜ iterated_fderiv ğ•œ n (Î» (y : E), fderiv ğ•œ f y)) x
s.prod (Î» (i : Î¹), f i - g i) = s.prod (Î» (i : Î¹), f i) - s.sum (Î» (i : Î¹), g i * (finset.filter (Î» (_x : Î¹), _x < i) s).prod (Î» (j : Î¹), f j - g j) * (finset.filter (Î» (j : Î¹), i < j) s).prod (Î» (j : Î¹), f j))
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real
zmod.legendre_sym p a = 0 â†” â†‘a = 0
algebraic_topology.dold_kan.c.rel i j
0.lf x â†” âˆƒ (i : x.left_moves), 0 â‰¤ x.move_left i
function.is_fixed_pt f (contracting_with.fixed_point f hf)
a * c < b * d
finprod (Î» (i : Î±), f i * g i) = finprod (Î» (i : Î±), f i) * finprod (Î» (i : Î±), g i)
0 â‰¤ metric.Hausdorff_dist s t
(âˆ€ (x : K), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
has_inner.inner u v = 0
is_regular a â†” a â‰  0
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ has_insert.insert a s), f i)) = f a + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
matrix.diagonal A.diag = A
group.is_nilpotent G
irreducible f
(â‡‘witt_vector.verschiebung^[i] x * â‡‘witt_vector.verschiebung^[j] y).coeff (i + j) = x.coeff 0 ^ p ^ j * y.coeff 0 ^ p ^ i
emetric.inf_edist x s â‰  âŠ¤
2 â€¢ o.oangle (y - xâ‚) (z - xâ‚) = 2 â€¢ o.oangle (y - xâ‚‚) (z - xâ‚‚)
has_dist.dist p3 p2 â‰  0
strict_concave_on ğ•œ s f
p x
âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = 0
measure_theory.integrable F' Î¼ âˆ§ has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
strict_convex_on â„ D f
â†‘(r - p) = â†‘r - â†‘p
lower_central_series G n â‰¤ H n
g =áµ[Î¼] measure_theory.condexp m Î¼ f
P f
padic_val_rat p qâ»Â¹ = -padic_val_rat p q
â‡‘(s.affine_combination p) w = s.sum (Î» (i : Î¹), w i â€¢ p i)
âˆ¥âŸ¨continuous_map.to_ae_eq_fun Î¼ f.to_continuous_map, _âŸ©âˆ¥ â‰¤ â†‘(measure_theory.measure_univ_nnreal Î¼) ^ (p.to_real)â»Â¹ * âˆ¥fâˆ¥
f a â‰  x
âˆ¥âˆ® (z : â„‚) in C(c, R), f zâˆ¥ < 2 * real.pi * R * C
measurable g
âˆƒ (C : nnreal), C â‰¤ A * B âˆ§ has_sum (Î» (i : Î¹), f i * g i) C
filter.tendsto f la lb.small_sets â†” âˆ€ (t : set Î²), t âˆˆ lb â†’ (âˆ€á¶  (x : Î±) in la, f x âŠ† t)
q = 0 âˆ¨ is_prime_pow q
x < y âˆ¨ x.equiv y âˆ¨ y < x âˆ¨ x.fuzzy y
S = âŠ¥ âˆ¨ nontrivial â†¥S
is_left_regular (a ^ n)
cont_mdiff_on I I' n f s â†” continuous_on f s âˆ§ âˆ€ (x : M) (y : M'), cont_diff_on ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source))
x âˆˆ H â†’ xâ»Â¹ âˆˆ H
(convex_cone.positive_cone ğ•œ E).salient
iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x
category_theory.presieve.is_sheaf_for P â‡‘S â†” nonempty (category_theory.limits.is_limit (category_theory.limits.fork.of_Î¹ (category_theory.equalizer.fork_map P â‡‘S) _))
monotone f.obj
vector_span â„ (s.points '' â†‘(finset.univ.erase i)) â‰¤ ((s.altitude i).direction)á—®
(submodule.map â†‘f s).topological_closure = âŠ¤
(â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) âŠ† â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
finprod (Î» (i : Î±), g (e i)) = finprod (Î» (j : Î²), g j)
â‡‘f x i âˆˆ I
real.cos (real.pi / 6) ^ 2 = 3 / 4
continuous_at (Î» (x : Î± Ã— Î²), f x.snd) x
|a| = a âˆ§ 0 â‰¤ a âˆ¨ |a| = -a âˆ§ a < 0
is_integral R (â‡‘(â‡‘(B.basis.repr) (B.gen ^ n)) i)
âˆƒ (x : Î²), âˆ€ (y : Î²), f y â‰¤ f x
âˆƒ (a : â„•) (H : a > 0) (b : M) (c : Îº), âˆ€ (s : M), s âˆˆ S â†’ C (a â€¢ s + b) = c
is_right_regular (a ^ n) â†” is_right_regular a
reflexive (Î» (a b : M), âˆƒ (c : M), semiconj_by c a b)
f =O[nhds b] g â†” (f âˆ˜ â‡‘e) =O[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
âˆƒ (s : finset L) (b : basis â†¥s K L), âˆ€ (x : â†¥s), is_integral A (â‡‘b x)
â‡‘(con.ker_lift f) â†‘x = â‡‘f x
measurable_space.generate_from s = (measurable_space.dynkin_system.generate s).to_measurable_space _
affine_independent k (â‡‘e âˆ˜ p) â†” affine_independent k p
(â¨† (n : Î²), f n) âˆˆ â‹‚ (n : Î²), set.Icc (f n) (g n)
S.normed_mk.is_quotient
category_theory.is_reflexive_pair f g
spectrum â„‚ a = coe âˆ˜ complex.re '' spectrum â„‚ a
has_edist.edist (f m) (f n) â‰¤ (finset.Ico m n).sum (Î» (i : â„•), has_edist.edist (f i) (f (i + 1)))
function.injective (Î» (a : Î±), f a b)
function.is_periodic_pt f 0 x
has_Sup.Sup S = con_gen (Î» (x y : M), âˆƒ (c : con M), c âˆˆ S âˆ§ â‡‘c x y)
filter.tendsto (Î» (x : Î²), f x / r) l filter.at_top
Ï€â‚.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol) = Ï€â‚‚.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)
s.sum (Î» (i : Î¹), f i * g i) < s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â†” Â¬antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
(add_valuation.comap f vâ‚).is_equiv (add_valuation.comap f vâ‚‚)
unique_diff_on â„ s
finset.univ.sum (Î» (j : J), category_theory.limits.biproduct.Ï€ f j â‰« category_theory.limits.biproduct.Î¹ f j) = ğŸ™ (â¨ f)
is_coatom a â†’ is_atom (â‡‘order_dual.to_dual a)
isometry f â†” âˆ€ (x y : Î±), has_dist.dist (f x) (f y) = has_dist.dist x y
orthonormal ğ•œ â‡‘(v.map f.to_linear_equiv)
â‡‘g x = â‡‘g y
âˆƒ (x : Î±), f x â‰  y
âˆ¥a ^ nâˆ¥ â‰¤ âˆ¥aâˆ¥ ^ n
s âˆˆ nhds_within a (set.Ici a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ico a u âŠ† s
âˆƒ (z : E) (H : z âˆˆ segment â„ x y), f y - f x = â‡‘(f' z) (y - x)
padic_norm p (q + r) â‰¤ linear_order.max (padic_norm p q) (padic_norm p r)
T.morâ‚‚ â‰« T.morâ‚ƒ = 0
is_open_map â‡‘(prime_spectrum.comap polynomial.C)
f = g
f â‰¤ nhds a
cont_diff_on ğ•œ n (f âˆ˜ â‡‘g) (â‡‘g â»Â¹' s)
is_add_submonoid (multiples x)
interval_integrable (Î» (x : â„), (x - c)â»Â¹) measure_theory.measure_space.volume a b â†” a = b âˆ¨ c âˆ‰ set.interval a b
â‡‘(measure_theory.outer_measure.bounded_by m) (s âˆª t) = â‡‘(measure_theory.outer_measure.bounded_by m) s + â‡‘(measure_theory.outer_measure.bounded_by m) t
strict_anti_on f D
filter.tendsto g f (nhds (lim f g))
linear_independent R v
cont_diff_on ğ•œ n (Î» (x : E), f x * g x) s
quotient_map f
x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
âˆƒ (Q : ideal S), Q.is_prime âˆ§ ideal.comap (algebra_map R S) Q = P
D.diagram_over_open_Ï€ U i â‰« D.Î¹_inv_app_Ï€_eq_map U â‰« D.Î¹_inv_app U = ğŸ™ (category_theory.limits.limit (D.diagram_over_open U))
filter.tendsto (Îµ â€¢ f) l (nhds 0)
âˆ¥â‡‘(fr.to_linear_map.extend_to_ğ•œ') xâˆ¥ â‰¤ âˆ¥frâˆ¥ * âˆ¥xâˆ¥
âˆƒ (f : bump_covering Î¹ X s), f.is_subordinate U
(matrix.from_blocks A B C D).is_diag â†” A.is_diag âˆ§ B = 0 âˆ§ C = 0 âˆ§ D.is_diag
set.unbounded has_lt.lt {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}
fderiv â„ f a = 0
m âˆˆ f' '' set.Icc a b
âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ U Ã—Ë¢ U âŠ† s
f = g
(category_theory.nat_trans.right_derived Î± n).app X = (F.right_derived_obj_iso n P).hom â‰« (homology_functor D (complex_shape.up â„•) n).map ((category_theory.nat_trans.map_homological_complex Î± (complex_shape.up â„•)).app P.cocomplex) â‰« (G.right_derived_obj_iso n P).inv
â‡‘(prime_spectrum.comap polynomial.C) I âˆˆ algebraic_geometry.polynomial.image_of_Df f
P (â‡‘f' âˆ˜ g âˆ˜ â‡‘(e'.symm)) (e'.to_local_equiv.target âˆ© â‡‘(e'.symm) â»Â¹' (s âˆ© g â»Â¹' f'.to_local_equiv.source)) (â‡‘e' x)
irreducible (polynomial.cyclotomic p R)
(finset.subtype p s).prod (Î» (x : subtype p), f â†‘x) = s.prod (Î» (x : Î±), f x)
filter.tendsto (Î» (x : Î²), f x * r) l filter.at_bot
â‡‘f x = â‡‘g x
(s.sigma t).prod (Î» (x : Î£ (i : Î±), Ïƒ i), f x) = s.prod (Î» (a : Î±), (t a).prod (Î» (s : Ïƒ a), f âŸ¨a, sâŸ©))
function.involutive â‡‘(reflection K)
is_localization (is_localization.localization_localization_submodule M N) T
x â‰  e.orientation â†” x = -e.orientation
â‡‘Î¼ s = 0
measure_theory.indicator_const_Lp p _ _ c = measure_theory.indicator_const_Lp p hs hÎ¼s c + measure_theory.indicator_const_Lp p ht hÎ¼t c
nat.of_digits (b + 2) l < (b + 2) ^ l.length
filter.tendsto (â‡‘Î¼ âˆ˜ s) (nhds_within a (set.Ioi a)) (nhds (â‡‘Î¼ (â‹‚ (r : Î¹) (H : r > a), s r)))
category_theory.mono f
âˆƒ (K : subgroup G), fintype.card â†¥K = p ^ n
â‡‘(f.map hy k) z * â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) = â‡‘(k.to_map) (â‡‘g (f.sec z).fst)
a = p ^ p.count a.factors
p < â‡‘(p.succ_above) i â†” p â‰¤ â‡‘fin.cast_succ i
(formal_multilinear_series.comp_partial_sum_source m M N).sum (Î» (e : Î£ (n : â„•), fin n â†’ â„•), f e) = (formal_multilinear_series.comp_partial_sum_target m M N).sum (Î» (e : Î£ (n : â„•), composition n), g e)
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
tendsto_uniformly F f p â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), has_edist.edist (f x) (F n x) < Îµ)
x âˆˆ s â†’ -x âˆˆ s
â‡‘(k.map hl j) (â‡‘(f.map hy k) x) = â‡‘(f.map _ j) x
measurable (Î» (x : Î´), u.liminf (Î» (i : Î¹), f i x))
Î¼.outer_regular
hb.oangle (-x) y + hb.oangle (-y) x = 0
closure E âŠ† metric.cthickening Î´ E
algebra_map â„¤ R = int.cast_ring_hom R
âˆƒ (f : partition_of_unity Î¹ X s), f.is_subordinate U
n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3
a * aâ»Â¹ * a = a
galois_connection submodule.orthogonal submodule.orthogonal
s âŠ† â†‘(add_subsemigroup.closure s)
dense {x : â„ | liouville x}
âˆƒ (y : Î²) (H : y âˆˆ t), â†‘((finset.filter (Î» (x : Î±), f x = y) s).card) â‰¤ b
âŠ¥ = âŠ¤
quotient.mk' x = quotient.mk' y â†” r.rel x y
f =o[l] g' â†’ (f =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
filter.tendsto (Î» (n : â„•), (â†‘n)â»Â¹ â€¢ (finset.range n).sum (Î» (i : â„•), u i)) filter.at_top (nhds l)
ae_measurable f Î¼
s âˆˆ nhds_within a (set.Ici a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ico a u âŠ† s
hb.oangle x y + hb.oangle y z + hb.oangle z x = 0
euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p3 p2 p1
ideal.is_jacobson S
finset.centroid k s p âˆˆ affine_span k (set.range p)
measurable g â†’ âˆ«â» (a : Î±), g a âˆ‚Î¼.with_density f = âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼
â‡‘(s.weighted_vsub_of_point p bâ‚) w = â‡‘(s.weighted_vsub_of_point p bâ‚‚) w
â‡‘(linear_map.trace R M) 1 = â†‘(finite_dimensional.finrank R M)
is_monoid_hom (Î» (a : Î±), (f a)â»Â¹)
(p.change_origin x).sum y = p.sum (x + y)
nonempty (a âŸ¶ b) â†’ nonempty (quiver.path (symgen a) (symgen b))
âˆƒ (g : V â†’â‚—[K] V'), g.comp p.subtype = f
q = 1
has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s 1) f = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
filter.tendsto (Î» (x : Î²), r * f x) l filter.at_top
tendsto_uniformly_on (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ f) p s
has_mfderiv_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x f' â†’ has_fderiv_within_at f f' s x
simplex_category.Ïƒ (â‡‘fin.cast_succ i) â‰« simplex_category.Ïƒ j = simplex_category.Ïƒ j.succ â‰« simplex_category.Ïƒ i
f.is_integral_elem (â‡‘f p.leading_coeff * x)
has_continuous_add G
has_fderiv_at g â†‘(f'.symm) a
a / c â‰¤ b / d â†’ (a * d - b * c) / (c * d) â‰¤ 0
Â¬s1 â‰¤ s2 â†” âˆƒ (p : P) (H : p âˆˆ s1), p âˆ‰ s2
v.int_valuation_def 1 = 1
filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
â†‘u * a âˆ£ b â†” a âˆ£ b
a * b âˆˆ add_submonoid.closure â†‘S
t.Î¹.app j â‰« k = t.Î¹.app j â‰« l
â†‘(z.re) = (z + â‡‘(star_ring_end â„‚) z) / 2
(c â€¢ M).conj_transpose = has_star.star c â€¢ M.conj_transpose
simplex_category.Î´ (â‡‘fin.cast_succ i) â‰« simplex_category.Ïƒ j.succ = simplex_category.Ïƒ j â‰« simplex_category.Î´ i
category_theory.limits.has_biproduct f
continuous â‡‘g
â‹ƒâ‚€set_of (bornology.is_vonN_bounded ğ•œ) = set.univ
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ {a}), f i)) = f a
is_open {x : R | is_unit x}
set.eq_on â‡‘f â‡‘g â†‘(submonoid.closure s)
exp ğ•‚ (x + y) = exp ğ•‚ x * exp ğ•‚ y
â‡‘f x = â‡‘g x
âˆƒ (Z : multiset (prime_spectrum A)), (multiset.map coe Z).prod â‰¤ I âˆ§ (multiset.map coe Z).prod â‰  âŠ¥
fintype.card (class_group R K) = 1 â†” is_principal_ideal_ring R
1 < aâ»Â¹ â†” a < 1
a âˆ£ a + b â†” a âˆ£ b
cardinal.mk â†¥(set.range â‡‘v) â‰¤ cardinal.mk â†¥J
p x
p
p s
is_add_submonoid (â‹ƒ (i : Î¹), s i)
(â‹ƒ (i : Î¹') (H : i âˆˆ s), â†‘(g i)).pairwise_disjoint f
a / b = a * bâ»Â¹
metric.ball x r = set.univ.pi (Î» (b : Î²), metric.ball (x b) r)
â†‘(x.nat_abs) ^ 2 = x ^ 2
module.rank R (tensor_product R M N) = module.rank R M * module.rank R N
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
same_ray R (r â€¢ x) y
category_theory.inv (category_theory.limits.coprod_comparison F A B) â‰« category_theory.limits.coprod.map (F.map f) (F.map g) = F.map (category_theory.limits.coprod.map f g) â‰« category_theory.inv (category_theory.limits.coprod_comparison F A' B')
category_theory.limits.has_limit (category_theory.limits.cospan a b)
filter.tendsto u f (nhds a)
f = g
n â€¢ x = n â€¢ x
star_convex ğ•œ x s â†’ s.ord_connected
bornology.is_vonN_bounded ğ•œ s
has_dist.dist (f x) (f y) = has_dist.dist x y
is_open_map â‡‘f
algebra.adjoin R (add_monoid_algebra.of' R M '' â‹ƒ (f : add_monoid_algebra R M) (H : f âˆˆ S), â†‘(f.support)) = âŠ¤
real.sin (real.pi / 6) = 1 / 2
S.functor_inclusion â‰« h.extend f = f
(generalized_continued_fraction.of q).terminates
A.det = B.det
I.is_prime â†” (âˆƒ (p : ideal R), p.is_prime âˆ§ I = p.prod âŠ¤) âˆ¨ âˆƒ (p : ideal S), p.is_prime âˆ§ I = âŠ¤.prod p
â‡‘s v = 0
âˆ« (x : â„ Ã— â„) in set.Icc a b, â‡‘(f' x) (1, 0) + â‡‘(g' x) (0, 1) = (((âˆ« (x : â„) in a.fst..b.fst, g (x, b.snd)) - âˆ« (x : â„) in a.fst..b.fst, g (x, a.snd)) + âˆ« (y : â„) in a.snd..b.snd, f (b.fst, y)) - âˆ« (y : â„) in a.snd..b.snd, f (a.fst, y)
cont_diff_at ğ•œ n (prod.map f g) p
uniform_embedding f â†’ ((âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a b : Î±}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : ennreal), Î´ > 0 â†’ (âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î±}, has_edist.edist (f a) (f b) < Îµ â†’ has_edist.edist a b < Î´))
x + t â€¢ y âˆˆ interior s
s.countable â†” âˆƒ (f : Î± â†’ â„•), set.inj_on f s
measurable f
is_primitive_root (Î¶ ^ a) b
polynomial.nth_roots_finset n R = n.divisors.bUnion (Î» (i : â„•), primitive_roots i R)
f.app (opposite.op (simplex_category.mk n)) â‰« algebraic_topology.dold_kan.hÏƒ' q n m hnm = algebraic_topology.dold_kan.hÏƒ' q n m hnm â‰« f.app (opposite.op (simplex_category.mk m))
cardinal.mk L â‰¤ linear_order.max (cardinal.mk R) cardinal.aleph_0
set.maps_to f (function.fixed_points (g âˆ˜ f)) (function.fixed_points (f âˆ˜ g))
category_theory.limits.has_binary_biproducts C
uniformity (uniform_space.completion Î±) = â¨… (Îµ : {Îµ // 0 < Îµ}), filter.principal {p : uniform_space.completion Î± Ã— uniform_space.completion Î± | has_dist.dist p.fst p.snd < Îµ.val}
continuous_at f a
â‡‘(euclidean_geometry.reflection sâ‚) p âˆˆ sâ‚‚
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆƒ (c : ennreal), filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds c)
b < -a + c â†’ a + b < c
continuous (Î» (p : E Ã— E), â‡‘(fderiv ğ•œ f p.fst) p.snd)
continuous (function.uncurry f)
mul_action.fixed_points â†¥(supr P) Î± = â‹‚ (i : Î¹), mul_action.fixed_points â†¥(P i) Î±
(generalized_continued_fraction.squash_seq s n).nth m = s.nth m
continuous_within_at f (set.Ici a) a
pâ‚ = pâ‚‚
finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â†” Â¬antivary (f âˆ˜ â‡‘Ïƒ) g
1 < ADE_inequality.sum_inv {p, q, r} â†” ADE_inequality.admissible {p, q, r}
â‡‘(Î¼.prod Î½) (s Ã—Ë¢ t) = â‡‘Î¼ s * â‡‘Î½ t
filter.tendsto f filter.at_bot filter.at_bot
cont_diff_at ğ•œ n (Î» (x : E Ã— F), f x.snd) (x, y)
hb.oangle x (â‡‘(hb.rotation Î¸) y) = hb.oangle x y + Î¸
category_theory.epi (c.Î¹.app category_theory.limits.walking_parallel_family.one)
finite_dimensional.finrank â„ â†¥((s.altitude i).direction) = 1
(x * y).equiv (y * x)
set.surj_on f s set.univ
cont_mdiff (model_with_corners_self â„ (euclidean_space â„ (fin n))) (model_with_corners_self â„ E) âŠ¤ coe
has_strict_fderiv_at (Î» (x : â„ Ã— â„), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) â€¢ continuous_linear_map.fst â„ â„ â„ + (p.fst ^ p.snd * real.log p.fst) â€¢ continuous_linear_map.snd â„ â„ â„) p
filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
measure_theory.measure.pi Î¼ = Î¼'
âˆƒ (s : finset Ïƒ) (qâ‚ qâ‚‚ : mv_polynomial â†¥s R), pâ‚ = â‡‘(mv_polynomial.rename coe) qâ‚ âˆ§ pâ‚‚ = â‡‘(mv_polynomial.rename coe) qâ‚‚
a * b < a * c
hb.oangle x z - hb.oangle y z = hb.oangle x y
is_fraction_ring C L
a â‰¤ a
has_inner.inner x y â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
â‡‘f (midpoint â„ x y) = midpoint â„ (â‡‘f x) (â‡‘f y)
[measure_theory.smul_invariant_measure G Î± Î¼, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (has_scalar.smul c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (c â€¢ s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (has_scalar.smul c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (c â€¢ s) = â‡‘Î¼ s, âˆ€ (c : G), measure_theory.measure.map (has_scalar.smul c) Î¼ = Î¼, âˆ€ (c : G), measure_theory.measure_preserving (has_scalar.smul c) Î¼ Î¼].tfae
(â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x
a * b < 1
Î¼ = Î½
finsupp.single g 1 * group_algebra.average k G = group_algebra.average k G
category_theory.simple X â†” is_simple_order (category_theory.subobject X)
finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i))
âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼ â‰¤ âˆ«â» (a : Î±), f a + g a âˆ‚Î¼
0 < n â†’ âˆ¥a ^ nâˆ¥â‚Š â‰¤ âˆ¥aâˆ¥â‚Š ^ n
f + g = category_theory.limits.biprod.lift (ğŸ™ X) (ğŸ™ X) â‰« category_theory.limits.biprod.desc f g
function.injective f â†” setoid.ker f = âŠ¥
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i / g i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) / finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), g i))
has_edist.edist x y < âŠ¤
â‡‘polynomial.C (â‡‘f r) âˆˆ polynomial.lifts f
monotone (set.image f)
polynomial.splits f p
finset.univ.sup_indep f â†’ complete_lattice.independent f
s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) < s.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
E / E âˆˆ nhds 1
lâ‚ <+: lâ‚‚ â†’ lâ‚.reverse <:+ lâ‚‚.reverse
filter.tendsto (Î» (x : â„), real.exp (-x)) filter.at_top (nhds 0)
has_inner.inner (â‡‘(finsupp.total Î¹ E ğ•œ v) l) (v i) = â‡‘(star_ring_end ğ•œ) (â‡‘l i)
âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (y : E), y âˆˆ metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥f (x + y) - p.partial_sum n yâˆ¥ â‰¤ C * (a * (âˆ¥yâˆ¥ / â†‘r')) ^ n
is_open_map coe
has_strict_deriv_at (exp ğ•‚) (exp ğ•‚ x) x
l ~ n.factors
y â‰¤ x
Â¬set.univ.countable
differentiable ğ•œ f
semiconj_by (a * b) x z
â‡‘Î¼ {x : Î± | âˆƒá¶  (n : â„•) in filter.at_top, p n x} = 0
bornology.is_vonN_bounded ğ•œ (sâ‚ âˆª sâ‚‚)
set.eq_on f g (closure U)
polynomial.X ^ n * â‡‘polynomial.C r = â‡‘polynomial.C r * polynomial.X ^ n
absorbs ğ•œ A A
(B.restrict (B.orthogonal (submodule.span K {x}))).nondegenerate
âˆƒ! (a : Î±), f a = b
a = b â†’ a â‰¤ b
euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p3 p2
pythagorean_triple (k * x) (k * y) (k * z)
f c â‰¤ supr f
f = g
has_fderiv_within_at f f' (closure s) x
âˆƒ! (cccr : P Ã— â„), cccr.fst âˆˆ affine_span â„ (set.range p) âˆ§ âˆ€ (i : Î¹), has_dist.dist (p i) cccr.fst = cccr.snd
is_max a â†’ order.succ a = a
affine_independent k p â†” linear_independent k (Î» (i : {x // x â‰  i1}), p â†‘i -áµ¥ p i1)
has_sum f a
â‡‘f a = â‡‘g a
filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
Î±.app j = Î±.app j'
âˆƒ (a : Î±), Î¸ â‰¤ cardinal.mk â†¥(f â»Â¹' {a})
function.injective â‡‘(polynomial.gal.restrict_prod p q)
direct_sum.is_internal V â†” (supr V)á—® = âŠ¥
âˆƒ (C : nnreal) (H : C > 0), âˆ€ {u : E â†’L[ğ•œ] F} (M : nnreal), (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥â‚Š â‰¤ M) â†’ âˆ¥uâˆ¥â‚Š â‰¤ C * M
âˆƒ (t : composition_series X), t.bot = s.bot âˆ§ t.length + 1 = s.length âˆ§ âˆƒ (htx : t.top = x), s.equivalent (t.snoc s.top _)
finite_dimensional.finrank F K * finite_dimensional.finrank K A = finite_dimensional.finrank F A
has_fderiv_at (exp ğ•‚) 1 0
b * (generalized_continued_fraction.of v).denominators n â‰¤ (generalized_continued_fraction.of v).denominators (n + 1)
p âˆ£ fintype.card (â†¥(H.normalizer) â§¸ subgroup.comap H.normalizer.subtype H)
function.injective (projectivization.map f hf)
is_square a â†” a ^ (fintype.card F / 2) = 1
âˆƒ (iâ‚€ iâ‚ : fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š).succ), iâ‚€ â‰  iâ‚ âˆ§ â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
Î¼ = Î½
finset.centroid_weights k s = function.const Î¹ (â†‘(s.card))â»Â¹
category_theory.mono f â†’ x.len â‰¤ y.len
(I.quotient_map g' le_rfl).comp ((ideal.comap g' I).quotient_map f le_rfl) = (I.quotient_map f' le_rfl).comp ((ideal.comap f' I).quotient_map g _)
(1 + n).pred = n
S.is_pwo
is_preconnected (â‹ƒ (n : Î²), s n)
witt_polynomial p (zmod (p ^ (n + 1))) (n + 1) = â‡‘(mv_polynomial.expand p) (witt_polynomial p (zmod (p ^ (n + 1))) n)
cauchy_seq s â†” âˆƒ (b : â„• â†’ â„), (âˆ€ (n : â„•), 0 â‰¤ b n) âˆ§ (âˆ€ (n m N : â„•), N â‰¤ n â†’ N â‰¤ m â†’ has_dist.dist (s n) (s m) â‰¤ b N) âˆ§ filter.tendsto b filter.at_top (nhds 0)
Mon.filtered_colimits.colimit_mul_aux F x y = Mon.filtered_colimits.colimit_mul_aux F x y'
is_compact s â†” is_closed s âˆ§ metric.bounded s
has_deriv_at complex.sin (complex.cos x) x
âˆƒ (Îµ : â„) (H : Îµ > 0), metric.closed_ball x Îµ âˆ© s = {x}
continuous_at (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.snd) p
char.quadratic_char F (-1) = â‡‘zmod.Ï‡â‚„ â†‘(fintype.card F)
fin.cons x (function.update p i y) = function.update (fin.cons x p) i.succ y
has_Sup.Sup s = eqv_gen.setoid (has_Sup.Sup (setoid.rel '' s))
nonempty (category_theory.limits.cocone F)
â†‘a = 0 â†” a.hom = 0
(ideal.map polynomial.C P).is_prime
cauchy f â†” f â‰  âŠ¥ âˆ§ âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (t : set Î±) (H : t âˆˆ f), âˆ€ (x : Î±), x âˆˆ t â†’ âˆ€ (y : Î±), y âˆˆ t â†’ has_edist.edist x y < Îµ)
â‡‘Î¼ ((Î» (h : G), g + h) â»Â¹' A) = â‡‘Î¼ A
âˆƒ (u : â„• â†’ Î³), âˆ€ (n : â„•), P (u n) (u '' set.Iio n)
is_add_group_hom (Î» (a : Î±), f a - g a)
a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c
âˆ® (z : â„‚) in C(c, R), f z / (z - w) = 2 * â†‘real.pi * complex.I * f w
antitone (Î» (s : set Î±), âˆ€ (x : Î±), x âˆˆ s â†’ P x)
b < c â†’ a < b â†’ a < c
is_preconnected (â‹ƒâ‚€c)
uniform_continuous_on f s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a : Î±} {H : a âˆˆ s} {b : Î±} {H : b âˆˆ s}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)
submonoid.closure â†‘S = S
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ interior s
âˆ¥xâˆ¥ â‰¤ M
(a âˆ¨ b) âˆ§ c â†” a âˆ§ c âˆ¨ b âˆ§ c
(filter.cocompact Î±).coprod (filter.cocompact Î²) = filter.cocompact (Î± Ã— Î²)
is_normal_subgroup (group.normal_closure s)
cont_diff ğ•œ n id
a < b + c â†’ a - c < b
has_dist.dist (f 0) (f n) â‰¤ (finset.range n).sum (Î» (i : â„•), has_dist.dist (f i) (f (i + 1)))
box_integral.has_integral I l f vol y â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (r : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)), (âˆ€ (c : nnreal), l.r_cond (r c)) âˆ§ âˆ€ (c : nnreal) (Ï€ : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) Ï€ â†’ Ï€.is_partition â†’ has_dist.dist (box_integral.integral_sum f vol Ï€) y â‰¤ Îµ)
a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c
continuous (Î» (f : (Î  (j : Î¹), Ï€ j) Ã— Ï€ i), function.update f.fst i f.snd)
category_theory.is_iso f
continuous continuous_map.curry
has_sum (Î» (n : Î¹), âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)
âˆƒ (m n : â„¤), x = m ^ 2 - n ^ 2 âˆ§ y = 2 * m * n âˆ§ z = m ^ 2 + n ^ 2 âˆ§ m.gcd n = 1 âˆ§ (m % 2 = 0 âˆ§ n % 2 = 1 âˆ¨ m % 2 = 1 âˆ§ n % 2 = 0) âˆ§ 0 â‰¤ m
K âŠ” Ká—® = âŠ¤
is_localization N S
â‡‘f (fin.snoc m (x + y)) = â‡‘f (fin.snoc m x) + â‡‘f (fin.snoc m y)
a * b â‰¤ 1
(minpoly A x).degree â‰¤ p.degree
s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â‰¤ s.sum (Î» (i : Î¹), f i â€¢ g i)
padic_norm p (â‡‘f (padic_seq.stationary_point hf)) = padic_norm p (â‡‘f (linear_order.max (padic_seq.stationary_point hf) (linear_order.max v2 v3)))
â‡‘f x = â‡‘f y
finset.centroid k finset.univ sâ‚.points = finset.centroid k finset.univ sâ‚‚.points
(regular_expression.map f P).matches = â‡‘(language.map f) P.matches
0 â‰¤ has_Inf.Inf S
âˆƒ (f : Î± â†’ â†¥(lp (Î» (n : â„•), â„) âŠ¤)), isometry f
p x hx
f.liminf u = â¨† (s : set Î²) (H : s âˆˆ f), â¨… (a : Î²) (H : a âˆˆ s), u a
â‡‘Î¼ s = 0
â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
bdd_above (s âˆ© t)
p x
finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â†” Â¬antivary f (g âˆ˜ â‡‘Ïƒ)
âˆƒ (g : â†¥A), âˆ¥â†‘g - fâˆ¥ < Îµ
âˆƒ (g : bounded_continuous_function Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ g.restrict s = f
f = g
is_preconnected (closure s)
A.sum (Î» (i : â„•), 2 ^ i) < B.sum (Î» (i : â„•), 2 ^ i) â†” A.to_colex < B.to_colex
P I
inner_product_space.is_self_adjoint (â‡‘linear_map.adjoint T * T)
linear_order.min (f x) (f y) < f (a â€¢ x + b â€¢ y)
asymptotics.is_O_with c l f g â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
tropical.untrop (s.sum (Î» (i : S), f i)) = â¨… (i : â†¥s), tropical.untrop (f â†‘i)
((v.map f.to_linear_equiv).to_orthonormal_basis _).repr = f.symm.trans (v.to_orthonormal_basis hv).repr
(b â€¢ g).sum (Î» (a : Î±), â‡‘(h a)) = g.sum (Î» (i : Î±) (c : M), â‡‘(h i) (b â€¢ c))
collinear k s â†” âˆƒ (v : V), âˆ€ (p : P), p âˆˆ s â†’ (âˆƒ (r : k), p = r â€¢ v +áµ¥ pâ‚€)
âˆƒ (M : â„), 0 â‰¤ M âˆ§ âˆ«â» (x : Î±), â†‘âˆ¥{x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f xâˆ¥â‚Š âˆ‚Î¼ â‰¤ ennreal.of_real Îµ
(multiset.map (Î» (a : R), polynomial.X - â‡‘polynomial.C a) p.roots).prod âˆ£ p
set.Icc a b âŠ† s
filter.tendsto (Î» (n : â„•), ennreal.of_real (âˆ¥a ^ nâˆ¥ ^ (1 / â†‘n))) filter.at_top (nhds (spectral_radius â„‚ a))
â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L - 1) = â†‘p
(polynomial.X ^ n - 1).separable â†” â†‘n â‰  0
x < y â†” (âˆƒ (i : y.left_moves), x â‰¤ y.move_left i) âˆ¨ âˆƒ (j : x.right_moves), x.move_right j â‰¤ y
has_deriv_within_at f f' (set.Ioi x) x â†’ has_deriv_within_at f f' (set.Ioo x y) x
a â‰¤ b â†’ b â‰¤ a â†’ a = b
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), (lgb - lga) * f' c = (lfb - lfa) * g' c
box_integral.integral I l â‡‘f Î¼.to_box_additive.to_smul = measure_theory.simple_func.integral (Î¼.restrict â†‘I) f
dense s â†’ âˆ€ (U : set Î±), is_open U â†’ U.nonempty â†’ (U âˆ© s).nonempty
â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y = z
(Î±â‚ â‰« Î±â‚‚).right = (Î²â‚ â‰« Î²â‚‚).left
0 â‰¤ x â†” âˆ€ (j : x.right_moves), âˆƒ (i : (x.move_right j).left_moves), 0 â‰¤ (x.move_right j).move_left i
filter.map (Î» (s : finset Î²), s.prod (Î» (b : Î²), f b)) filter.at_top â‰¤ filter.map (Î» (s : finset Î³), s.prod (Î» (x : Î³), g x)) filter.at_top
0 < a â†’ 0 < c â€¢ a
(S âˆ© set.Ici a).nonempty
xâ‚ â‰  xâ‚‚ â†” xâ‚ = -xâ‚‚
add_semiconj_by (a + b) x z
dense_embedding has_pure.pure
is_bounded_linear_map ğ•œ â‡‘f
s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
p.factorization = finsupp.single p 1
I.jacobson = I â†” âŠ¥.jacobson = âŠ¥
s1 = s2
-L.sum = (list.map (Î» (x : G), -x) L).sum
o.oangle (-x) y = o.oangle x (-y)
A.det â€¢ Aâ»Â¹.mul_vec b = â‡‘(A.cramer) b
â‡‘Î¼ s = â‡‘Î¼ t
(Î» (t : Î¹), (âˆ« (x : â„) in u t..v t, f x) - (v t - u t) â€¢ c) =o[lt] (v - u)
bdd_below (â‹ƒ (i : Î²) (H : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ bdd_below (S i)
âˆ¥xâˆ¥ â‰¤ r â†” âˆ€ (i : Î¹), âˆ¥x iâˆ¥ â‰¤ r
âˆ¥f.mk_continuous C hâˆ¥ â‰¤ C
add_subsemigroup.closure â†‘S = S
âˆƒ (Q : ideal S) (H : Q â‰¥ I), Q.is_prime âˆ§ ideal.comap (algebra_map R S) Q = P
convex_independent ğ•œ (Î» (x : â†¥(set.range p)), â†‘x) â†” convex_independent ğ•œ p
g '' set.image2 f s t = set.image2 f' (g' '' t) s
(set.extreme_points â„ s).nonempty
has_dist.dist a b ^ 2 + has_dist.dist a c ^ 2 = 2 * (has_dist.dist a (midpoint â„ b c) ^ 2 + (has_dist.dist b c / 2) ^ 2)
con.comap â‡‘f _ c = con.ker (c.mk'.comp f)
is_artinian S M
cont_diff ğ•œ âŠ¤ â‡‘((equiv.prod_assoc E F G).symm)
disjoint (tensor_algebra.Î¹ R).range 1
cont_diff_at â„ n (Î» (p : â„ Ã— â„), p.fst ^ p.snd) p
continuous â‡‘f
â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘K ^ d * â‡‘(measure_theory.measure.hausdorff_measure d) s
Â¬b â‰¤ a
is_add_unit (â†‘u + a) â†” is_add_unit a
a + b < 0
metric.thickening Î´ âˆ… = âˆ…
let F : Î± â†’ nat.partrec.code â†’ Ïƒ := Î» (a : Î±) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a) in primrec (Î» (a : Î±), F a (c a))
measure_theory.measure.map â‡‘(quotient_add_group.mk' Î“) (Î¼.restrict ğ“•) = â‡‘Î¼ (ğ“• âˆ© â‡‘(quotient_add_group.mk' Î“) â»Â¹' â†‘K) â€¢ measure_theory.measure.add_haar_measure K
(â‹‚ (i : Î²) (H : i âˆˆ is), s i) âˆˆ f â†” âˆ€ (i : Î²), i âˆˆ is â†’ s i âˆˆ f
_.mpr p = p â‰« category_theory.eq_to_hom _
hb.oangle (â‡‘(hb.rotation (hb.oangle x y)) x) y = 0
s âŠ† add_monoid.closure s
finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) < finset.univ.sum (Î» (i : Î¹), f i * g i) â†” Â¬monovary (f âˆ˜ â‡‘Ïƒ) g
galois_connection â‡‘oi â‡‘(oi.symm)
s âˆˆ finset.up_shadow^[k] ğ’œ â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), t âŠ† s âˆ§ t.card + k = s.card
âˆ« (x : â„) in set.interval_oc a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1)
s = âŠ¤
filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_bot filter.at_bot
convex_on ğ•œ s f â†’ concave_on ğ•œ s (-f)
T.morâ‚ƒ â‰« (category_theory.shift_equiv C 1).functor.map T.morâ‚ = 0
(â‹‚ (i : â„•), Z i).nonempty
â‡‘(algebra_map R S) (is_localization.sec M z).fst = â‡‘(algebra_map R S) â†‘((is_localization.sec M z).snd) * z
is_regular (a * b) â†” is_regular a âˆ§ is_regular b
subgroup.pi set.univ H â‰¤ J â†” âˆ€ (i : Î·), subgroup.map (monoid_hom.single f i) (H i) â‰¤ J
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) = 1
strongly_measurable_at_filter f (nhds x) Î¼
p âˆˆ â†‘s â†” p âˆˆ s
{â†‘Î³} âˆˆ nhds â†‘Î³
metric.Hausdorff_dist s t â‰¤ r
S.is_elementary
B.separating_left â†” B.ker = âŠ¥
sxâ‚.circumcenter = sxâ‚‚.circumcenter
â‡‘Î¼ U = â¨† (F : set Î±) (H : F âŠ† U) (h : is_closed F), â‡‘Î¼ F
p â†’ âˆ€ (x : Î±), q x â†” âˆ€ (x : Î±), p â†’ q x
measure_theory.tendsto_in_measure Î¼ f filter.at_top g
â‡‘c w x â†’ â‡‘c (n â€¢ w) (n â€¢ x)
module.free R N
closure (set.Ico a b) = set.Icc a b
category_theory.is_cofiltered.inf_to O H mX â‰« f = category_theory.is_cofiltered.inf_to O H mY
filter.tendsto (Î» (s : finset Î²), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
char_p A p
p1 = p2
add_monoid.is_torsion G â†’ Â¬add_monoid.is_torsion_free G
uniform_continuous (bounded_continuous_function.comp G H)
â‡‘(clifford_algebra.Î¹ Q) a * â‡‘(clifford_algebra.Î¹ Q) b + â‡‘(clifford_algebra.Î¹ Q) b * â‡‘(clifford_algebra.Î¹ Q) a = â‡‘(algebra_map R (clifford_algebra Q)) (quadratic_form.polar â‡‘Q a b)
function.injective â‡‘(con.ker_lift f)
S = T
lie_ideal.map f â…Iâ‚,Iâ‚‚â† â‰¤ â…lie_ideal.map f Iâ‚,lie_ideal.map f Iâ‚‚â†
is_closed (frontier s)
H = âŠ¥ âˆ¨ âˆƒ (x : G) (H : x âˆˆ H), x â‰  1
continuous f
has_dist.dist (f m) (f n) â‰¤ (finset.Ico m n).sum (Î» (i : â„•), d i)
is_fraction_ring â†¥(integral_closure A L) L
q.partial_sum N ((finset.Ico 1 N).sum (Î» (i : â„•), â‡‘(p i) (Î» (j : fin i), z))) = (formal_multilinear_series.comp_partial_sum_target 0 N N).sum (Î» (i : Î£ (n : â„•), composition n), â‡‘(q.comp_along_composition p i.snd) (Î» (j : fin i.fst), z))
dite P (Î» (h : P), a) (Î» (h : Â¬P), b) = ite P a b
(âˆ€ (i : Î¹), is_compact (s i)) â†’ is_compact {x : Î  (i : Î¹), Ï€ i | âˆ€ (i : Î¹), x i âˆˆ s i}
tendsto_uniformly (Î» (n : Î¹), F n âˆ˜ g) (f âˆ˜ g) p
F = F'
measure_theory.uniform_integrable f p Î¼
s.circumcenter = s.points i
âˆƒ (m : M), m * m = m
is_smul_regular M â†‘a
'0' â‰¤ buffer.read cb âŸ¨n', hnâŸ© â†’ '9' < buffer.read cb âŸ¨n', hnâŸ©
set.bij_on f (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
(âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : F), w âˆˆ K â†’ has_inner.inner (u - v) w = 0
is_max_filter (â‡‘order_dual.to_dual âˆ˜ f) l a â†’ is_min_filter f l a
finite_dimensional.finrank R (matrix m n R) = fintype.card m * fintype.card n
probability_theory.variance (X + Y) measure_theory.measure_space.volume = probability_theory.variance X measure_theory.measure_space.volume + probability_theory.variance Y measure_theory.measure_space.volume
âˆƒ (s : set E) (H : s âˆˆ nhds x), lipschitz_on_with K f s
n.factor_multiset.prod = n
a * b < 1
category_theory.is_pullback 0 0 0 (ğŸ™ X)
â‡‘c w x â†’ â‡‘c (w ^ n) (x ^ n)
function.injective (Î» (a : Î±), finsupp.single a b)
category_theory.is_iso f
Ï†.order = â†‘n â†” â‡‘(power_series.coeff R n) Ï† â‰  0 âˆ§ âˆ€ (i : â„•), i < n â†’ â‡‘(power_series.coeff R i) Ï† = 0
dfinsupp.single i xi = dfinsupp.single j xj
M.det = 0
âˆ‘' (n : â„•), r ^ n = (1 - r)â»Â¹
witt_vector.is_polyâ‚‚ p (Î» (_x : Type u_1) (_x_1 : comm_ring _x), has_mul.mul)
vâ‚ = vâ‚‚ â†” âˆ€ (r : R), â‡‘vâ‚ r = â‡‘vâ‚‚ r
H.is_cartan_subalgebra
ğ’œ.slice r âŠ† ğ’œ
a + b â‰¤ 0
o.oangle (â‡‘(o.rotation Î¸) x) x = -Î¸
âˆ« (x : Î±), g (f x) âˆ‚Î¼ â‰¤ g (âˆ« (x : Î±), f x âˆ‚Î¼)
add_group.fg G â†” âˆƒ (S : set G), add_subgroup.closure S = âŠ¤ âˆ§ S.finite
âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable âˆ§ t âŠ† s âˆ§ (âˆ€ (x : Î±), x âˆˆ t â†’ r x âˆˆ f x) âˆ§ (s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) âˆ§ âˆ‘' (x : â†¥t), â‡‘Î¼ (metric.closed_ball â†‘x (r â†‘x)) â‰¤ â‡‘Î¼ s + Îµ
filter.tendsto (Î» (x : â„), x ^ (a / (b * x + c))) filter.at_top (nhds 1)
same_ray R (-x) (-y) â†’ same_ray R x y
has_inner.inner (câ‚‚ -áµ¥ câ‚) (pâ‚‚ -áµ¥ pâ‚) = 0
affine_span k â†‘(finset.image p s) = sp
summable f â†” cauchy_seq (Î» (s : finset Î²), s.sum (Î» (b : Î²), f b))
(Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
(âˆƒ (fs : finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = 0), v = â‡‘(fs.weighted_vsub p) w) â†” âˆƒ (fs : finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = 0), v = â‡‘(fs.weighted_vsub (Î» (i : â†¥s), p â†‘i)) w
(f â»Â¹' s).subsingleton
measure_theory.ae_strongly_measurable' m â‡‘f Î¼ â†’ P f
is_noetherian R M â†” âˆ€ (s : submodule R M), s.fg
set.Ioo (has_Inf.Inf s) (has_Sup.Sup s) âŠ† s
algebraic_independent R x
has_strict_fderiv_at f (fderiv ğ•‚ f x) x
a âˆ¨ b âˆ§ c â†” (a âˆ¨ b) âˆ§ (a âˆ¨ c)
cont_mdiff_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s â†’ cont_diff_on ğ•œ n f s
multilinear_map.dom_dom_congr Ïƒ f = multilinear_map.dom_dom_congr Ïƒ g â†” f = g
â‡‘Î¼ A = â¨… (U : set Î±) (h : A âŠ† U) (h2 : is_open U), â‡‘Î¼ U
filter.tendsto (Î» (n : â„•), âˆ« (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ« (a : Î±), f a âˆ‚Î¼))
finset.univ.prod (Î» (x : Î±), f x) = finset.univ.prod (Î» (x : Î²), g x)
a * b < 1
lâ‚ <+~ lâ‚‚ â†” âˆ€ (x : Î±), x âˆˆ lâ‚ â†’ list.count x lâ‚ â‰¤ list.count x lâ‚‚
s.sum (Î» (i : Î¹), f i) < âŠ¤ â†” âˆ€ (i : Î¹), i âˆˆ s â†’ f i < âŠ¤
2 â€¢ hb.oangle (y - xâ‚) (z - xâ‚) = 2 â€¢ hb.oangle (y - xâ‚‚) (z - xâ‚‚)
measure_theory.integrable_at_filter f l Î¼
is_domain A
cont_diff_on ğ•œ n (Î» (x : E), f x â€¢ g x) s
s.direction = vector_span k â†‘s
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, complex.I â€¢ â‡‘(f' (â†‘x + â†‘y * complex.I)) 1 - â‡‘(f' (â†‘x + â†‘y * complex.I)) complex.I
a = 1
âˆƒ (y : Î²), â†‘((finset.filter (Î» (x : Î±), f x = y) finset.univ).card) < b
Â¬b < a
has_sum (Î» (i : Î±), lp.single p i (â‡‘f i)) f
is_of_fin_add_order (x + y)
polynomial.eval (complex.cos Î¸) (polynomial.chebyshev.T â„‚ n) = complex.cos (â†‘n * Î¸)
(e.map f).orientation = e.orientation â†” 0 < â‡‘linear_map.det â†‘f
power_series.mk (Î» (n : â„•), â‡‘(polynomial.aeval t) ((1 / â†‘(n.factorial)) â€¢ polynomial.bernoulli n)) * (power_series.exp A - 1) = power_series.X * â‡‘(power_series.rescale t) (power_series.exp A)
is_integral_closure (cyclotomic_ring (p ^ k) â„¤ â„š) â„¤ (cyclotomic_field (p ^ k) â„š)
derangements.equiv.remove_none.fiber (option.some a) = {f : equiv.perm Î± | function.fixed_points â‡‘f âŠ† {a}}
âˆƒ (i : Î¹) (x : G i), â‡‘(ring.direct_limit.of G f i) x = z
S = T
x âˆ£ y ^ n
antilipschitz_with K f â†’ âˆ€ (x y : Î±), has_dist.dist x y â‰¤ â†‘K * has_dist.dist (f x) (f y)
âˆƒ (r' : Î¹ â†’ â„), (â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) = set.univ âˆ§ âˆ€ (i : Î¹), r' i âˆˆ set.Ioo 0 (r i)
has_mfderiv_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x f' â†’ has_fderiv_at f f' x
add_monoid.is_torsion_free â†¥H
metric.inf_dist x s â‰¤ metric.inf_dist y s + has_dist.dist x y
(k.map hl j).comp (f.map hy k) = f.map _ j
b = âŠ¤
f (â‡‘(affine_map.line_map a b) r) < â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a (â‡‘(affine_map.line_map a b) r) < slope f (â‡‘(affine_map.line_map a b) r) b
minpoly K x = polynomial.map (algebra_map A K) (minpoly A x)
is_smul_regular M b
cont_diff_at ğ•œ n (Î» (x : E Ã— F), f x.fst) (x, y)
cont_diff ğ•œ n (Î» (x : E), f x - g x)
âˆƒ (i : set Î±), measurable_set i âˆ§ 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i âˆ§ measure_theory.vector_measure.restrict s iá¶œ â‰¤ 0.restrict iá¶œ
metric.diam s â‰¤ C
cont_diff_at ğ•œ n (Î» (x : E), (f x, g x)) x
is_noetherian K V â†” module.finite K V
module.rank R (matrix m n R) = cardinal.mk m * cardinal.mk n
a â‰¤ b â†’ a â‰  b â†’ a < b
a * b â‰  0 â†” b * a â‰  0
relation.trans_gen r n m
is_noetherian_ring R â†” âˆ€ (I : ideal R), I.fg
is_localization.is_integer A r
â†‘(â‡‘(orthogonal_projection (submodule.span ğ•œ {v})) w) = (has_inner.inner v w / â†‘âˆ¥vâˆ¥ ^ 2) â€¢ v
continuous f
s.finite âˆ¨ s.infinite
is_complete â†‘s
0 < a + b
âˆƒ (i j : Î¹) (h : i â‰  j), (s i âˆ© s j).nonempty
(metric.sphere x r).nonempty â†” 0 â‰¤ r
s.sum (Î» (i : Î¹), f i) â‰¤ s.sum (Î» (i : Î¹), g i)
has_inner.inner (s.sum (Î» (i : Î¹), lâ‚ i â€¢ v i)) (s.sum (Î» (i : Î¹), lâ‚‚ i â€¢ v i)) = s.sum (Î» (i : Î¹), â‡‘(star_ring_end ğ•œ) (lâ‚ i) * lâ‚‚ i)
g1 -áµ¥ g2 = g1 - g2
euclidean_geometry.cospherical ps â†” âˆƒ (center : P) (radius : â„), âˆ€ (p : P), p âˆˆ ps â†’ has_dist.dist p center = radius
(nhds_within (â‡‘(ext_chart_at I c) c) (set.range â‡‘I)).has_basis (Î» (f : smooth_bump_function I c), true) (Î» (f : smooth_bump_function I c), euclidean.closed_ball (â‡‘(ext_chart_at I c) c) f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R âˆ© set.range â‡‘I)
lower_semicontinuous_on (Î» (z : Î±), f z + g z) s
(minpoly A x).degree â‰¤ p.degree
continuous f
f = g
s.finite
f = g
e âˆˆ G.edge_set
Î¼ = Î½
(polynomial.nth_roots n 1).nodup
summable f
a - b â‰¤ c â†’ a â‰¤ b + c
metric.Hausdorff_dist s s = 0
direct_sum.is_internal (Î» (i : â†¥S), submodule.torsion_by_set R M â†‘(p â†‘i))
s âŠ† â†‘(subfield.closure s)
â‡‘(direct_sum.coe_ring_hom A) (â‡‘(direct_sum.of (Î» (i : Î¹), â†¥(A i)) i) x) = â†‘x
âˆƒ (x : Î²), set.unbounded r (s x)
(nhds c).has_basis (Î» (f : smooth_bump_function I c), true) (Î» (f : smooth_bump_function I c), tsupport â‡‘f)
category_theory.limits.has_limit G
â‡‘(euclidean_geometry.reflection s) p = â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) -áµ¥ p +áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p)
â‡‘(p.succ_above) i = â‡‘fin.cast_succ i
â†‘(H âŠ” N) = â†‘H + â†‘N
finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒâ‚€t), f a)) = finsum (Î» (s : set Î±), finsum (Î» (H : s âˆˆ t), finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ s), f a))))
summable f â†’ summable (Î» (x : Î±), |f x|)
(o.rotation Î¸â‚).trans (o.rotation Î¸â‚‚) = o.rotation (Î¸â‚‚ + Î¸â‚)
f =O[l] g' â†” âˆ€á¶  (c : â„) in filter.at_top, asymptotics.is_O_with c l f g'
Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), x < y
Aâ»Â¹ = B
âˆƒ! (s : â†¥(F.val.obj (opposite.op V))), âˆ€ (i : Î¹), â‡‘(F.val.map (iUV i).op) s = sf i
n.factorial * n.asc_factorial k = (n + k).factorial
measurable_embedding â‡‘e
has_inner.inner x (r â€¢ x) = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
hb.oangle (â‡‘(hb.rotation Î¸) x) y = hb.oangle x y - Î¸
category_theory.ess_surj Compactum_to_CompHaus
concave_on â„ D f
polynomial.splits f p
vector_span k (set.range p) = âŠ¤
â‡‘0 a = 0
(â¨† (i : Î¹), â†‘âˆ¥g iâˆ¥â‚Š) < âŠ¤
y âˆˆ add_subgroup.closure {x} â†” âˆƒ (n : â„¤), n â€¢ x = y
x âˆˆ H â†’ y âˆˆ H â†’ x + y âˆˆ H
(Î» (t : Î¹), âˆ« (x : â„) in a..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in a..u t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
â†‘1 = 1
subsingleton R
category_theory.limits.has_limit F
group.nilpotency_class (Î  (i : Î·), Gs i) = finset.univ.sup (Î» (i : Î·), group.nilpotency_class (Gs i))
aâ»Â¹ < 1 â†” 1 < a
(p ^ (n + 1)).totient = p ^ n * (p - 1)
has_edist.edist (f m) (f n) â‰¤ (finset.Ico m n).sum (Î» (i : â„•), d i)
â‡‘f 1 = 1
sxâ‚.circumradius = sxâ‚‚.circumradius
list.nat.antidiagonal 0 = [(0, 0)]
a * b < 1
ideal.map â†‘f I = ideal.comap â†‘(f.symm) I
(category_theory.adjunction.of_right_adjoint i).unit.app (i.obj ((category_theory.left_adjoint i).obj X)) = i.map ((category_theory.left_adjoint i).map ((category_theory.adjunction.of_right_adjoint i).unit.app X))
multiset.nat.antidiagonal 0 = {(0, 0)}
âˆƒ (Kâ‚ Kâ‚‚ : set Î±), is_compact Kâ‚ âˆ§ is_compact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚
is_integral R x
x < y â†” (âˆƒ (i : y.left_moves), (âˆ€ (i' : x.left_moves), x.move_left i' < y.move_left i) âˆ§ âˆ€ (j : (y.move_left i).right_moves), x < (y.move_left i).move_right j) âˆ¨ âˆƒ (j : x.right_moves), (âˆ€ (i : (x.move_right j).left_moves), (x.move_right j).move_left i < y) âˆ§ âˆ€ (j' : y.right_moves), x.move_right j < y.move_right j'
strict_concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
uniform_continuous â‡‘f â†” is_open â†‘(â†‘f.ker)
p q
âˆ¥f zâˆ¥ â‰¤ C
category_theory.ess_surj F
v - â†‘(â‡‘(orthogonal_projection K) v) âˆˆ Ká—®
âˆƒ (x : â„• â†’ Î¹'), (âˆ€ (i : â„•), p (x i)) âˆ§ f.has_antitone_basis (Î» (i : â„•), s (x i))
convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
unique_diff_within_at ğ•œ s x â†’ unique_mdiff_within_at (model_with_corners_self ğ•œ E) s x
(âˆ€ {Z : C} (g : Z âŸ¶ X), â‡‘S g â†’ J.covers R g) â†’ J.covers R f
continuous_on f s â†” âˆ€ (y : E), continuous_on (Î» (x : X), â‡‘(f x) y) s
metric.bounded (metric.closed_ball x r)
âˆƒ (n : â„•), x = pell.xn a1 n âˆ§ y = pell.yn a1 n
well_founded (relation.cut_expand r)
convex â„ (f' '' s)
âˆ¥0âˆ¥ = 0
function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1
(matrix.from_blocks A B 0 D).det = A.det * D.det
â…subgroup.pi set.univ H,subgroup.pi set.univ Kâ† â‰¤ subgroup.pi set.univ (Î» (i : Î·), â…H i,K iâ†)
âˆƒ! (b : set Î±) (H : b âˆˆ r.classes), a âˆˆ b
is_open (â‡‘e '' (e.to_local_equiv.source âˆ© s))
strict_mono (Î» (n : â„•), f^[n] x)
polynomial.root_multiplicity a ((polynomial.X - â‡‘polynomial.C a) ^ n) = n
f x = f y
metric.Hausdorff_dist s âˆ… = 0
f.limsup u = â¨… (s : set Î²) (H : s âˆˆ f), â¨† (a : Î²) (H : a âˆˆ s), u a
âˆƒ (x : Î±) (H : x âˆˆ s) (m : â„•) (H : m âˆˆ set.Ioo 0 n), f^[m] x âˆˆ s
val = nat.of_digits 10 (list.map (Î» (c : char), c.to_nat - '0'.to_nat) (list.take (n' - n) (list.drop n (buffer.to_list cb))).reverse)
has_fderiv_within_at f f' s x â†” has_deriv_within_at f (â‡‘f' 1) s x
(s âˆ© â‹‚ (i : Î¹), Z i).nonempty
v âˆˆ Ká—® â†” âˆ€ (u : E), u âˆˆ K â†’ has_inner.inner v u = 0
((ideal.quotient.mk P).comp polynomial.C).is_integral
measure_theory.integrable_on g' (set.Ioc a b) measure_theory.measure_space.volume
â‡‘(f.comp g) = â‡‘f âˆ˜ â‡‘g
â‡‘s (u  v) = 0 âˆ§ â‡‘s (v  u) = 0
âˆƒ (f : E â†’L[â„] â„) (u v : â„), (âˆ€ (a : E), a âˆˆ s â†’ â‡‘f a < u) âˆ§ u < v âˆ§ âˆ€ (b : E), b âˆˆ t â†’ v < â‡‘f b
filter.tendsto f filter.at_top filter.at_top
1 / a â‰¤ 1 / b â†” b â‰¤ a
list.drop (list.take i (list.map list.length L)).sum L.join = (list.drop i L).join
p x y
is_closed {u : ultrafilter Î± | s âˆˆ u}
set.univ.countable
â‡‘Î¼ K < âŠ¤
is_square a
âˆƒ (s : finset Î¹) (w : Î¹ â†’ k) (hw : s.sum (Î» (i : Î¹), w i) = 1), p1 = â‡‘(s.affine_combination p) w
M.nondegenerate â†’ M.det â‰  0
â‡‘measure_theory.measure_space.volume {x : â„ | liouville x} = 0
Ï†â‚ = Ï†â‚‚
p x
âˆƒ (L L' : list (matrix.transvection_struct (fin r âŠ• unit) ğ•œ)), (((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod).is_two_block_diagonal
monoid.closure s âŠ† t
â†‘(a.nat_abs) â‰¤ a ^ 2
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€á¶  (n : â„•) in filter.at_top, x âˆ‰ s n
cont_diff_on ğ•œ n prod.fst s
relation.refl_trans_gen r n m
galois_connection (â‡‘order_dual.to_dual âˆ˜ B.polar) (B.flip.polar âˆ˜ â‡‘order_dual.of_dual)
bornology.is_bounded sá¶œ â†’ bornology.is_cobounded s
has_star.star (M.mul N) = (has_star.star N).mul (has_star.star M)
category_theory.limits.has_wide_equalizers C
is_domain Î±
strict_convex_on â„ (set.Ioi 0) (Î» (x : â„), x ^ m)
filter.tendsto (Î» (x : â„), f x / g x) filter.at_top l
fixing_submonoid M (s âˆª t) = fixing_submonoid M s âŠ“ fixing_submonoid M t
ordered_smul R M
Â¬a âŠ‚ a
Gromov_Hausdorff.GH_dist X Y â‰¤ metric.Hausdorff_dist (set.range Î¦) (set.range Î¨)
witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x) y)
âˆ€á¶  (r : â„) in nhds 0, metric.closed_ball x r âŠ† u
0 < L.length
(list.drop (i + 1) L).prod = (L.nth_le i p)â»Â¹ * (list.drop i L).prod
measure_theory.strongly_measurable f â†” measurable f
cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_mdiff_within_at I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' (f x)) âˆ˜ f) (s âˆ© f â»Â¹' (ext_chart_at I' (f x)).source) x
â‡‘(affine_map.line_map (f a) (f b)) r â‰¤ f (â‡‘(affine_map.line_map a b) r) â†” slope f a b â‰¤ slope f a (â‡‘(affine_map.line_map a b) r)
a * b < 1
differentiable_within_at ğ•œ f s x â†’ mdifferentiable_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x
o.oangle x y = Î¸ â†” (x â‰  0 âˆ§ y â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(o.rotation Î¸) x) âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
has_fpower_series_on_ball (â‡‘g âˆ˜ f) (g.comp_formal_multilinear_series p) x r
nhds a â‰¤ f
âˆ€á¶  (x : E) in nhds a, has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker (f x) (â‡‘(has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented f f' hf hf' hker) x).snd = x
âˆ¯ (x : fin (n + 1) â†’ â„‚) in T(c, R), f x = âˆ® (x : â„‚) in C(c 0, R 0), âˆ¯ (y : fin n â†’ â„‚) in T(c âˆ˜ fin.succ, R âˆ˜ fin.succ), f (fin.cons x y)
g b - g a â‰¤ âˆ« (y : â„) in a..b, Ï† y
Ï† = Ïˆ
âˆ¥f zâˆ¥ â‰¤ C
lâ‚ <:+: lâ‚‚ â†’ lâ‚.reverse <:+: lâ‚‚.reverse
a âˆ£ b + c â†” a âˆ£ c
âˆƒ (f : C(X, â„)), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc 0 1
â‡‘Ïƒ '' s = s
(span_points k s).nonempty â†” s.nonempty
l.sublists'.nodup â†’ l.nodup
(âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
category_theory.epi f
balanced ğ•œ (0 âˆª interior A)
is_bounded_bilinear_map â„ (Î» (p : E Ã— E), has_inner.inner p.fst p.snd)
aâº = a
emetric.inf_edist x {y} = has_edist.edist x y
polynomial.map f (polynomial.cyclotomic n R) = polynomial.cyclotomic n S
s.prod (Î» (i : Î¹), f i) â‰¤ s.prod (Î» (i : Î¹), g i)
category_theory.limits.has_coequalizer f g
(âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : E), w âˆˆ K â†’ has_inner.inner (u - v) w = 0
measure_theory.ae_fin_strongly_measurable f Î¼ â†” ae_measurable f Î¼
is_monoid_hom f
{i : Î¹ | (f i âˆ© s).nonempty}.finite
emetric.diam s = ennreal.of_real (has_Sup.Sup s - has_Inf.Inf s)
a < b + c â†’ -b + a < c
dense_range (topological_space.dense_seq Î±)
lipschitz_with 1 (Î» (x : Î±), metric.inf_nndist x s)
((category_theory.equalizer.first_obj_eq_family P R).hom x).compatible â†” category_theory.equalizer.presieve.first_map P R x = category_theory.equalizer.presieve.second_map P R x
â†‘(âŸ¨p1, hp1âŸ© -áµ¥ â‡‘(euclidean_geometry.orthogonal_projection s) p2) âˆˆ s.direction
(âˆ€ (n : â„•), 0 < n â†’ n.divisors.sum (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.sum (Î» (x : â„• Ã— â„•), â†‘(â‡‘nat.arithmetic_function.moebius x.fst) * g x.snd) = f n
is_open (â‡‘e '' s)
is_open_map Z.proj
is_smul_regular M (a â€¢ b) â†” is_smul_regular M b
finset.univ.prod (Î» (i : fin (n + 1)), f i) = f 0 * finset.univ.prod (Î» (i : fin n), f i.succ)
add_monoid.is_torsion â†¥(add_comm_monoid.add_torsion G)
measurable_set {x : E | differentiable_at ğ•œ f x}
absorbent ğ•œ (metric.ball x r)
totally_disconnected_space Î± â†” âˆ€ (x : Î±), (connected_component x).subsingleton
Î¼.absolutely_continuous Î½
(matrix.pivot.list_transvec_col M).prod.mul M (sum.inr ()) i = M (sum.inr ()) i
s.nonempty
â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |â‡‘linear_map.det â†‘(f.symm)| * â‡‘Î¼ s
(âˆ€ (i : Î¹), i âˆˆ t â†’ (s i).coprime x) â†’ (t.prod (Î» (i : Î¹), s i)).coprime x
Â¬set.univ.countable
finset.univ.sum (Î» (x : Î±), f x) = finset.univ.sum (Î» (x : Î²), g x)
category_theory.is_iso g
is_greatest (f '' t) (f a)
0 < L.length
s.altitude i = affine_subspace.mk' (s.points i) ((affine_span â„ (s.points '' â†‘(finset.univ.erase i))).direction)á—® âŠ“ affine_span â„ (set.range s.points)
inner_product_geometry.angle x (r â€¢ y) = inner_product_geometry.angle x y
râ‚ â‰  râ‚‚ â†’ Aâ‚ â‰  Aâ‚‚
âˆƒ (l : E â†’L[ğ•œ] ğ•œ) (a : ğ•œ), B = {x âˆˆ A | a â‰¤ â‡‘l x}
finset.univ.sum (Î» (x : KË£), â†‘x ^ i) = ite (fintype.card K - 1 âˆ£ i) (-1) 0
(finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s).sum (Î» (x : Î±), g x) = s.sum (Î» (x : {x // p x}), f x)
subgroup.closure â†‘K = K
totally_disconnected_space Î± â†” totally_separated_space Î±
f' = 0
measurable_set {x : â„ | differentiable_within_at â„ f (set.Ioi x) x}
summable f â†’ summable g
â‡‘(â‡‘f'' w) v = â‡‘(â‡‘f'' v) w
has_deriv_at (Î» (x : ğ•œ), polynomial.eval x p) (polynomial.eval x (â‡‘polynomial.derivative p)) x
x â‰¤ â‡‘c x
(valuation.comap f vâ‚).is_equiv (valuation.comap f vâ‚‚)
uniform_continuous f â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a b : Î±}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)
polynomial.splits (algebra_map K L) (polynomial.X ^ â†‘n - 1)
g = h
â‡‘(s.weighted_vsub (Î» (_x : Î¹), p)) w = 0
is_integral â„¤ Î¼
bdd_below (set.range f)
set.inj_on f s
M.transpose.det = M.det
f.of_mul_equiv_of_dom _ = f
f = g
topological_space.second_countable_topology Î±
â‡‘(linear_map.trace R M) linear_map.id = â†‘(finite_dimensional.finrank R M)
aâ»Â¹ < bâ»Â¹ â†” b < a
eqv_gen.setoid r â‰¤ eqv_gen.setoid s
padic_norm p (â‡‘f (padic_seq.stationary_point hf)) = padic_norm p (â‡‘f (linear_order.max v1 (linear_order.max v2 (padic_seq.stationary_point hf))))
a * b < 1
is_upper_set s â†’ is_lower_set (â‡‘order_dual.of_dual â»Â¹' s)
f a + (s.erase a).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
category_theory.presheaf.is_sheaf J (G.op â‹™ â„±.val)
upper_semicontinuous (Î» (z : Î±), f z + g z)
A.transpose.has_orthogonal_rows â†” A.has_orthogonal_cols
f = g
âˆƒ (t : set E) (H : t âˆˆ nhds_within x s), lipschitz_on_with K f t
c * a / (c * b) = a / b
âˆƒ (m : â„•) (H : m âˆˆ s) (n : â„•) (H : n âˆˆ s), m < n âˆ§ m â‰¡ n [MOD k]
â‡‘((category_theory.tensor_left_hom_equiv (X âŠ— X') Y Y' (Z âŠ— Z')).symm) ((f âŠ— g) â‰« (Î±_ Y Z Z').hom) = (Î±_ Y' X X').inv â‰« (â‡‘((category_theory.tensor_left_hom_equiv X Y Y' Z).symm) f âŠ— g)
category_theory.presieve.is_sheaf_for P â‡‘S â†” category_theory.presieve.yoneda_sheaf_condition P S
padic_norm p (q - r) â‰¤ linear_order.max (padic_norm p q) (padic_norm p r)
finset.univ.sum (Î» (a : Î±), fintype.card â†¥(add_action.fixed_by Î± Î² a)) = fintype.card (quotient (add_action.orbit_rel Î± Î²)) * fintype.card Î±
Ï† = Ïˆ
s1 < s2 â†” â†‘s1 âŠ‚ â†‘s2
measure_theory.tendsto_in_measure Î¼ f l g
âˆ¥orthogonal_projection Kâˆ¥ â‰¤ 1
f âˆˆ algebra.adjoin R (add_monoid_algebra.of' R M '' â†‘(f.support))
s.prod (Î» (i : Î¹), g i) + s.prod (Î» (i : Î¹), h i) â‰¤ s.prod (Î» (i : Î¹), f i)
has_dist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ * has_dist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ = has_inner.inner v v * r * r + 2 * has_inner.inner v (pâ‚ -áµ¥ pâ‚‚) * r + has_inner.inner (pâ‚ -áµ¥ pâ‚‚) (pâ‚ -áµ¥ pâ‚‚)
âˆƒá¶  (m : â„•) in filter.at_top, â‡‘Î¼ (s âˆ© f^[m] â»Â¹' s) â‰  0
âˆƒ (m : M), m + m = m
is_trivial_topological_fiber_bundle â„ complex.re
âˆƒ (p : â„•), nat.prime p âˆ§ n â‰¤ p âˆ§ p â‰¡ 1 [MOD k]
â‡‘(s.orthogonal_projection_span) (r â€¢ (p2 -áµ¥ â†‘(â‡‘(s.orthogonal_projection_span) p2)) +áµ¥ p1) = âŸ¨p1, hpâŸ©
is_trivial_topological_fiber_bundle â„ complex.im
s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) < s.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
c = d
lie_module.is_weight âŠ¤ M 0
is_topological_fiber_bundle F prod.fst
f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
galois_connection L.obj R.obj
Ï† = power_series.X * power_series.mk (Î» (p : â„•), â‡‘(power_series.coeff R (p + 1)) Ï†) + â‡‘(power_series.C R) (â‡‘(power_series.constant_coeff R) Ï†)
dense (â‹ƒ (s : set Î±) (H : s âˆˆ S), interior s)
semiconj_by a (x * x') (y * y')
Ï† = power_series.mk (Î» (p : â„•), â‡‘(power_series.coeff R (p + 1)) Ï†) * power_series.X + â‡‘(power_series.C R) (â‡‘(power_series.constant_coeff R) Ï†)
s.sum (Î» (i : Î¹), |f i + g i| ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), |f i| ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), |g i| ^ p) ^ (1 / p)
2 â€¢ o.oangle x (-y) = 2 â€¢ o.oangle x y
s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) â‰¤ s.sum (Î» (i : Î¹), f i * g i)
has_sum (Î» (i : Î¹), â‡‘(V i) (â‡‘w i)) (â‡‘((hV.linear_isometry_equiv hV').symm) w)
antitone (Î» (n : N), f (Î¼ n m))
M p
has_inner.inner (s.sum (Î» (i : Î¹), l i â€¢ v i)) (v i) = â‡‘(star_ring_end ğ•œ) (l i)
(x âˆˆ â¨† (i : Î¹), S i) â†” âˆƒ (i : Î¹), x âˆˆ S i
has_dist.dist p1 p3 = has_dist.dist p1 p2 + has_dist.dist p3 p2 â†” euclidean_geometry.angle p1 p2 p3 = real.pi
nontrivial R
antitone (Î» (x : Î±), linear_order.max (f x) (g x))
p.left_inv i = p.right_inv i
âˆƒ (h : Î± â†’ Î²), function.bijective h
a * b â‰¤ 1
finite_dimensional.finrank K â†¥(s âŠ” t) + finite_dimensional.finrank K â†¥(s âŠ“ t) = finite_dimensional.finrank K â†¥s + finite_dimensional.finrank K â†¥t
âŠ¥.jacobson = âŠ¥
âˆƒ (t u : finset Î±) (b c : R), t âˆª u = s âˆ§ disjoint t u âˆ§ a = b * c âˆ§ x = b * t.prod (Î» (i : Î±), p i) âˆ§ y = c * u.prod (Î» (i : Î±), p i)
âˆƒ (t : finset G), K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g + h) â»Â¹' V
multiplicity p (n.choose k) = â†‘((finset.filter (Î» (i : â„•), p ^ i â‰¤ k % p ^ i + (n - k) % p ^ i) (finset.Ico 1 b)).card)
subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S
s.prod (Î» (x : Î±), f x) = 1
b = b'
eq.rec y h = y
free_group.red.step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length
concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
strict_convex ğ•œ (â‡‘f â»Â¹' s)
âˆƒ (Î¹ : Type u) [_inst_9 : fintype Î¹] [_inst_10 : decidable_eq Î¹] (p : Î¹ â†’ R) [_inst_11 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), direct_sum.is_internal (Î» (i : Î¹), submodule.torsion_by R M (p i ^ e i))
char.quadratic_char F a = 1 âˆ¨ char.quadratic_char F a = -1
orthogonal_projection âŠ¥ = 0
is_left_regular (a * b) â†” is_left_regular b
a * b â‰¤ c â†’ b â‰¤ aâ»Â¹ * c
â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y
has_inner.inner (gram_schmidt ğ•œ f a) (gram_schmidt ğ•œ f b) = 0
âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0
vector_span k sâ‚ â‰¤ vector_span k sâ‚‚
â‡‘(f.lift hg) z * â‡‘g â†‘((f.sec z).snd) = â‡‘g (f.sec z).fst
-b â‰¤ a
is_seq_closed s â†” is_closed s
âˆ¥f'âˆ¥ â‰¤ â†‘C
a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)
(â…Ÿ A).mul A = 1
t.prod (Î» (i : Î¹), f i) âˆˆ s
â‡‘f x = â‡‘f y
1 < a * b
has_inner.inner (â‡‘(â‡‘continuous_linear_map.adjoint A) y) x = has_inner.inner y (â‡‘A x)
â†‘(lie_module.lower_central_series R â†¥I â†¥I k) â‰¤ â†‘(lie_module.lower_central_series R L â†¥I k)
finite_dimensional.finrank K V = b.card
â‡‘(fin.nat_add m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.nat_add m) i)
â‡‘f x = â‡‘f y
measurable g
x.lf 0 â†” âˆƒ (j : x.right_moves), x.move_right j â‰¤ 0
f' =O[l] g â†’ (Î» (x : Î±), -f' x) =O[l] g
k = l
monotone f â†’ antitone (f âˆ˜ â‡‘order_dual.of_dual)
âˆ« (y : â„) in a..b, Ï† y â‰¤ g b - g a
(exp_series ğ•‚ ğ”¸).radius = âŠ¤
set.eq_on â‡‘f â‡‘g â†‘(subfield.closure s)
sâ‚ = sâ‚‚ â†” sâ‚.direction = sâ‚‚.direction
category_theory.limits.has_strict_terminal_objects C
a âˆ£ b * c â†’ a âˆ£ c
affine_span k s = âŠ¤ â†” vector_span k s = âŠ¤
category_theory.presieve.is_sheaf J P
dense s â†” âˆ€ (U : set Î±), is_open U â†’ U.nonempty â†’ (U âˆ© s).nonempty
â†‘u âŠ† s +áµ¥ t â†’ (âˆƒ (s' : finset Î±) (t' : finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' +áµ¥ t')
â†‘(â‡‘(orthogonal_projection (submodule.span ğ•œ {v})) w) = has_inner.inner v w â€¢ v
1 < a * b
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t  s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
|has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)| = 1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), r â‰  0 âˆ§ y = r â€¢ x
âˆƒ (u : set E) (H : u âŠ‡ v) (b : basis â†¥u ğ•œ E), orthonormal ğ•œ â‡‘b âˆ§ â‡‘b = coe
has_Inf.Inf S â‰¤ 0
âˆ€á¶  (Î´ : nnreal) in nhds_within 0 (set.Ioi 0), âˆ€ (s : set E) (f : E â†’ E), approximates_linear_on f A s Î´ â†’ â†‘m * â‡‘Î¼ s â‰¤ â‡‘Î¼ (f '' s)
Kâ‚ âŠ” Kâ‚á—® âŠ“ Kâ‚‚ = Kâ‚‚
sxâ‚.circumradius = sxâ‚‚.circumradius
function.surjective (function.comp g)
has_deriv_within_at f f' (set.Ici x) x â†’ has_deriv_within_at f f' (set.Ioi x) x
euclidean_geometry.cospherical âˆ…
yâ‚ = xâ‚‚
(ideal.span {power_series.X}).is_prime
function.injective â‡‘(polynomial.gal.gal_action_hom p E)
s.to_jordan_decomposition.to_signed_measure = s
category_theory.limits.has_coequalizers C
p2 -áµ¥ p âˆˆ s.direction â†” p2 âˆˆ s
(Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
(matrix.pivot.list_transvec_col M).prod.mul M (sum.inl i) (sum.inr ()) = 0
has_deriv_at f f' x â†’ has_fderiv_at f (1.smul_right f') x
â‡‘(n.central_binom.factorization) p = 0
semiconj_by a x (a * x * aâ»Â¹)
has_deriv_within_at f e (set.Iic a) a
Q f
â‡‘(Ï.average_map) v = v
P.fg â†” P.to_submonoid.fg
has_fderiv_at (convolution f g L Î¼) (convolution f (fderiv ğ•œ g) (continuous_linear_map.precompR G L) Î¼ xâ‚€) xâ‚€
â‡‘(convex_hull ğ•œ) â†‘s âŠ† â‡‘(convex_hull ğ•œ) â†‘t â†” s âŠ† t
F.obj j = F.obj j'
box_integral.has_integral I l f Î¼.to_box_additive.to_smul 0
measure_theory.tendsto_in_measure Î¼ f l g
set.surj_on f s (set.Icc (f a) (f b))
f â‰¤ nhds a
á˜(f â‰« g) = á˜g â‰« á˜f
is_lub (s âˆª t) (a âŠ” b)
is_compact (coe_fn '' s)
â‡‘polynomial.C ((q / gcd_monoid.gcd p q).leading_coeff)â»Â¹ * (p / gcd_monoid.gcd p q) âˆ£ p
affine_independent k p â†” âˆ€ (s1 s2 : finset Î¹) (w1 w2 : Î¹ â†’ k), s1.sum (Î» (i : Î¹), w1 i) = 1 â†’ s2.sum (Î» (i : Î¹), w2 i) = 1 â†’ â‡‘(s1.affine_combination p) w1 = â‡‘(s2.affine_combination p) w2 â†’ â†‘s1.indicator w1 = â†‘s2.indicator w2
(g.comp f).ker.fg
o.oangle (â‡‘(o.rotation Î¸) x) y = o.oangle x y - Î¸
cont_diff ğ•œ n (Î» (x : E), c)
âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ dense t âˆ§ (âˆ€ (x : Î±), is_bot x â†’ x âˆ‰ t) âˆ§ âˆ€ (x : Î±), is_top x â†’ x âˆ‰ t
q.comp p 0 = q 0
a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0
orthonormal ğ•œ coe â†” âˆ€ (v : E), v âˆˆ s â†’ âˆ€ (w : E), w âˆˆ s â†’ has_inner.inner v w = ite (v = w) 1 0
p x
â‡‘f (n â€¢ g) = n â€¢ â‡‘f g
a * b < 1
measure_theory.sigma_finite Î¼
âˆƒ (t : set Î±), measurable_set t âˆ§ â‡‘Î¼ t â‰¤ ennreal.of_real Îµ âˆ§ tendsto_uniformly_on f g filter.at_top tá¶œ
finsupp.map_domain â‡‘f (x * y) = finsupp.map_domain â‡‘f x * finsupp.map_domain â‡‘f y
â†‘u âŠ† s * t â†’ (âˆƒ (s' t' : finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' * t')
affine_independent k p â†” âˆ€ (w1 w2 : Î¹ â†’ k), finset.univ.sum (Î» (i : Î¹), w1 i) = 1 â†’ finset.univ.sum (Î» (i : Î¹), w2 i) = 1 â†’ â‡‘(finset.univ.affine_combination p) w1 = â‡‘(finset.univ.affine_combination p) w2 â†’ w1 = w2
g.comp (â‡‘dfinsupp.lift_add_hom f) = â‡‘dfinsupp.lift_add_hom (Î» (a : Î¹), g.comp (f a))
âˆƒ (ns : â„• â†’ â„•), strict_mono ns âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (i : â„•), f (ns i) x) filter.at_top (nhds (g x))
has_fpower_series_on_ball f p x âŠ¤
C a
asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ asymptotics.is_O_with c l f' g'
filter.tendsto (Î» (n : â„•), measure_theory.set_to_fun Î¼ T hT (fs n)) filter.at_top (nhds (measure_theory.set_to_fun Î¼ T hT f))
is_topological_fiber_bundle F (Î» (x : â†¥{p : B' Ã— Z | f p.fst = proj p.snd}), â†‘x.fst)
has_dist.dist (f 0) (f n) â‰¤ (finset.range n).sum (Î» (i : â„•), d i)
cont_diff_at ğ•œ n (Î» (x : E), f x * g x) x
âˆƒ (m : Î±), (âˆ€ (x : Î±), x âˆˆ lo â†’ x < m) âˆ§ âˆ€ (y : Î±), y âˆˆ hi â†’ m < y
((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod (sum.inr ()) (sum.inl i) = 0
âˆƒ (x : K), a * x * x + b * x + c = 0
A.det = finset.univ.sum (Î» (i : fin n.succ), (-1) ^ (â†‘i + â†‘j) * A i j * (A.minor â‡‘(i.succ_above) â‡‘(j.succ_above)).det)
finset.imageâ‚‚ f s (finset.imageâ‚‚ g t u) âŠ† finset.imageâ‚‚ g' (finset.imageâ‚‚ fâ‚ s t) (finset.imageâ‚‚ fâ‚‚ s u)
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ {a, b}), f i)) = f a * f b
_.maximal
is_left_regular b
{r : â„ | 0 < r âˆ§ x âˆˆ r â€¢ s}.nonempty
a * b < 1
function.bijective â‡‘f
â‡‘(x.succ_above) a = â‡‘(x.succ_above) b â†” a = b
has_strict_fderiv_at (Î» (x : E), g (f x)) (g'.comp f') x
âˆ€á¶  (y : E) in nhds c, âˆ¥f yâˆ¥ = âˆ¥f câˆ¥
â†‘r â‰¤ p.radius
p a b
has_deriv_within_at f f' (set.Iio x) x â†’ has_deriv_within_at f f' (set.Iic x) x
asymptotics.is_O_with c l f g' â†’ asymptotics.is_O_with c l f (Î» (x : Î±), âˆ¥g' xâˆ¥)
(cardinal.mk Î¹).lift â‰¤ (cardinal.mk Îº).lift
âˆƒ (m : M) (H : m âˆˆ s), m + m = m
â†‘1 = is_localization.coe_submodule P âŠ¤
s = set.univ
lipschitz_with 1 (Î» (x : Î±), metric.inf_dist x s)
monoid.is_torsion G
âˆƒ (w : set E) (H : w âŠ‡ s), orthonormal ğ•œ coe âˆ§ âˆ€ (u : set E), u âŠ‡ w â†’ orthonormal ğ•œ coe â†’ u = w
has_fderiv_within_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p x 1)) s x
a âˆˆ t.sum (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ {i : Î¹}, i âˆˆ t â†’ g i âˆˆ f i), t.sum (Î» (i : Î¹), g i) = a
nonempty (field Î±)
s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i))
cont_mdiff_on I I' n f s â†” continuous_on f s âˆ§ âˆ€ (y : M'), cont_mdiff_on I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' y) âˆ˜ f) (s âˆ© f â»Â¹' (ext_chart_at I' y).source)
â‡‘(f.generalized_eigenspace Î¼) k = â‡‘(f.generalized_eigenspace Î¼) (finite_dimensional.finrank K V)
finset.image (Î» (_x : â„•), _x % a) (finset.Ico n (n + a)) = finset.range a
a â‹– b â†’ â†‘a â‹– â†‘b
mâ‚ = mâ‚‚
group.is_nilpotent G â†” âˆƒ (n : â„•), lower_central_series G n = âŠ¥
aâ»Â¹ < 1 â†” 1 < a
category_theory.pretopology.of_grothendieck (topological_space.opens T) (opens.grothendieck_topology T) = opens.pretopology T
relation.trans_gen r n m
A.mul_vec (â‡‘(A.cramer) b) = A.det â€¢ b
balanced ğ•œ (p.ball 0 r)
metric.Hausdorff_dist (closure s) (closure t) = metric.Hausdorff_dist s t
asymptotics.is_O_with c l (Î» (x : Î±), -f' x) g â†’ asymptotics.is_O_with c l f' g
s.sum (Î» (i : Î¹), f i â€¢ g i) < s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â†” Â¬antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
monotone_on f s â†’ antitone_on (f âˆ˜ â‡‘order_dual.of_dual) s
0 < a + b
has_faithful_smul Î± (Î  (i : I), f i)
cont_diff_groupoid 0 I = continuous_groupoid H
â†‘(z.im) = (z - â‡‘(star_ring_end â„‚) z) / (2 * complex.I)
s.prod (Î» (i : Î¹), z i ^ w i) â‰¤ s.sum (Î» (i : Î¹), w i * z i)
finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” antivary (f âˆ˜ â‡‘Ïƒ) g
p S
b < c â†’ a = b â†’ a < c
(finset.Ico 2 (n + 1)).sum (Î» (k : â„•), a ^ k * {c : composition k | 1 < c.length}.to_finset.sum (Î» (c : composition k), r ^ c.length * finset.univ.prod (Î» (j : fin c.length), p (c.blocks_fun j)))) â‰¤ (finset.Ico 2 (n + 1)).sum (Î» (j : â„•), r ^ j * (finset.Ico 1 n).sum (Î» (k : â„•), a ^ k * p k) ^ j)
list.sorted has_lt.lt (denumerable.raise' l n)
category_theory.limits.has_limit F
(âˆ€ (A : finset Î±), A.card â‰¤ (finset.filter (Î» (b : Î²), âˆƒ (a : Î±) (H : a âˆˆ A), r a b) finset.univ).card) â†” âˆƒ (f : Î± â†’ Î²), function.injective f âˆ§ âˆ€ (x : Î±), r x (f x)
f x = x
â‡‘f p = â‡‘g q â†’ (âˆƒ (s : â†¥(category_theory.limits.pullback f g)), â‡‘category_theory.limits.pullback.fst s = p âˆ§ â‡‘category_theory.limits.pullback.snd s = q)
A = B
l.sublists.nodup â†’ l.nodup
same_ray R (r â€¢ v) v
finprod (Î» (i : Î±), f i) = finprod (Î» (j : Î²), g j)
nonempty (V â‰ƒâ‚—[K] Vâ‚)
âˆ€á¶  (t : R) in nhds 0, ring.inverse (â†‘x + t) = ring.inverse (1 + â†‘xâ»Â¹ * t) * â†‘xâ»Â¹
convex_on â„ set.univ has_norm.norm
golden_ratioâ»Â¹ = -golden_conj
filter.tendsto f filter.at_top filter.at_top
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = 0
measure_theory.strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½)
continuous (set.Icc_extend h f)
galois_connection (Î» (I : ideal A), projective_spectrum.zero_locus ğ’œ â†‘I) (Î» (t : (set (projective_spectrum ğ’œ))áµ’áµˆ), (projective_spectrum.vanishing_ideal t).to_ideal)
has_Inf.Inf s = a
function.injective â‡‘f
(â‡‘(linear_map.to_matrix b b) f).charpoly = f.charpoly
â‡‘(polynomial.monomial n) s âˆˆ polynomial.lifts f
a * a / a = a
balanced ğ•œ (interior A)
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * has_inner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
l.head + l.tail.sum = l.sum
(p ^ k).factorization = finsupp.single p k
tâ‚‚.orthocenter = tâ‚.points iâ‚
summable (Î» (i : Î¹), (f i + g i) ^ p) âˆ§ (âˆ‘' (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) + (âˆ‘' (i : Î¹), g i ^ p) ^ (1 / p)
filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
is_smul_regular M (a * b) â†” is_smul_regular M a âˆ§ is_smul_regular M b
filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
p âˆ£ q â†’ q âˆ£ p
is_field R
(â¨… (i : Î¹), s i) = â¨… (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
x - y âˆˆ s
S = T
â‡‘((n.choose k).factorization) p â‰¤ 1
â‡‘(category_theory.limits.cokernel.Ï€ g) x = â‡‘(category_theory.limits.cokernel.Ï€ g) y
has_edist.edist (f 0) (f n) â‰¤ (finset.range n).sum (Î» (i : â„•), has_edist.edist (f i) (f (i + 1)))
cont_diff_within_at ğ•œ n (Î» (x : E), f x - g x) s x
t2_space (L â‰ƒâ‚[K] L)
âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥
open_embedding â‡‘e
âˆƒ (Î± Î² : Type) (IÎ± : topological_space Î±) (IÎ² : topological_space Î²), compact_space Î± âˆ§ t1_space Î² âˆ§ âˆƒ (f : Î± â‰ƒ Î²), continuous â‡‘f âˆ§ Â¬continuous â‡‘(f.symm)
monoid.is_torsion H
add_monoid.is_torsion H
is_cyclic Î±
S = T
S âŠ† closure (S âˆ© U)
(matrix.diagonal d).minor e e = matrix.diagonal (d âˆ˜ e)
a = 0
a * b = linear_order.max a b
f x â‰¤ f a
(Î» (x : â„), x ^ s) =o[filter.at_top] Î» (x : â„), real.exp (b * x)
(category_theory.limits.image.mono_factorisation f).e = category_theory.limits.factor_thru_image f
âŠ¥.fixing_subgroup = âŠ¤
F = G
âˆƒ (g : bounded_continuous_function Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ â‡‘g âˆ˜ e = â‡‘f
â‡‘g âˆ˜ â‡‘f = â‡‘(f â‰« g)
(a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2
(path.homotopic.pi Î³â‚€).comp (path.homotopic.pi Î³â‚) = path.homotopic.pi (Î» (i : Î¹), (Î³â‚€ i).comp (Î³â‚ i))
(mul_action.fixed_points G Î±).nonempty
convex ğ•œ â†‘Q
measure_theory.mem_â„’p â‡‘(measure_theory.Lp.simple_func.to_simple_func f) p Î¼
âˆƒ (b : â†¥M), is_localization.is_integer R (â†‘b â€¢ a)
(a - b) % c = 0
measure_theory.mem_â„’p.to_Lp â‡‘(c â€¢ f) _ = c â€¢ measure_theory.mem_â„’p.to_Lp â‡‘f _
fact (finite_dimensional.finrank â„ â„‚ = 2)
is_open â†‘(E.fixing_subgroup)
(finset.nat.antidiagonal n).sum (Î» (ij : â„• Ã— â„•), f ij.fst ij.snd) = (finset.range n.succ).sum (Î» (k : â„•), f k (n - k))
âˆ«â» (a : Î±), (â¨… (n : â„•), f n a) âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
k â‰¤ G.min_degree
filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(thickened_indicator _ F) a) âˆ‚â†‘Î¼) filter.at_top (nhds (â‡‘â†‘Î¼ F))
AddMon.filtered_colimits.colimit_add_aux F x y = AddMon.filtered_colimits.colimit_add_aux F x y'
âˆƒ (f : Î  (a : Î±), Î² a), âˆ€ (x : Î±), R x (f x)
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = 0
â‡‘(f â‰« g) a = â‡‘g (â‡‘f a)
v = w
has_star.star (x / y) = has_star.star x / has_star.star y
is_of_fin_add_order (â‡‘f x)
finset.centroid_weights_indicator k s = â†‘s.indicator (finset.centroid_weights k s)
a âŠ” has_Inf.Inf s â‰¤ â¨… (b : Î±) (H : b âˆˆ s), a âŠ” b
âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
âˆƒ! (s : â†¥(F.val.obj (opposite.op (supr U)))), F.val.is_gluing U sf s
continuous_at (Î» (x : Î± Ã— Î²), f x.snd) (x, y)
(âˆ€á¶  (s : set Î±) in l.small_sets, âˆ€ (x : Î±), x âˆˆ s â†’ p x) â†’ (âˆ€á¶  (x : Î±) in l, p x)
vector_span k â†‘(finset.image p s) = sm
metric.bounded s â†” emetric.diam s â‰  âŠ¤
mdifferentiable_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x â†” differentiable_at ğ•œ f x
l <+ l'
A.topological_closure = âŠ¤
|has_inner.inner x (r â€¢ x)| / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
o.oangle x z - o.oangle x y = o.oangle y z
Î¼ = Î½
affine_span k set.univ = âŠ¤
(f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)
(polynomial_functions (set.Icc a b)).topological_closure = âŠ¤
bdd_above s â†’ bdd_above (f '' s)
f âˆˆ (polynomial_functions (set.Icc a b)).topological_closure
â‡‘(convex_hull R) (set.range b.points) = {x : E | âˆ€ (i : Î¹), 0 â‰¤ â‡‘(b.coord i) x}
p a
fin.tail (function.update q 0 z) = fin.tail q
monotone finset.shadow
pi.const_ring_hom A R = algebra_map R (A â†’ R)
category_theory.presieve.is_sheaf_for P R â†’ category_theory.presieve.is_separated_for P R
P n
â‡‘f (n â€¢ g) = n â€¢ â‡‘f g
â†‘(n.totient) = â†‘n * n.factors.to_finset.prod (Î» (p : â„•), 1 - (â†‘p)â»Â¹)
g = Hausdorffification.lift I f
gauge (p.ball 0 1) = â‡‘p
has_inner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = -1
simple_graph.inc_matrix R G a e = ite (e âˆˆ G.incidence_set a) 1 0
cont_mdiff_within_at I I'' n (g âˆ˜ f) s x
(â…Ÿ A).mul (A.mul B) = B
filter.tendsto u filter.at_top (nhds a) â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), n > N â†’ has_dist.dist (u n) a < Îµ)
q = 0
algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = (-1) ^ ((â†‘p ^ (k + 1)).totient / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
o.oangle (-x) (-y) = o.oangle x y
âˆƒ (f : â„• â†’ Î±), strict_mono f âˆ§ f 0 = a
âˆƒ (t : finset Î±), â†‘t âŠ† s âˆ§ â‡‘Î¼ (s  â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) â‰¤ â†‘N / (â†‘N + 1) * â‡‘Î¼ s âˆ§ â†‘t.pairwise_disjoint (Î» (x : Î±), metric.closed_ball x (r x))
has_Sup.Sup s = b
(p.root_set â„‚).to_finset.card = (p.root_set â„).to_finset.card + (â‡‘(polynomial.gal.gal_action_hom p â„‚) (â‡‘(polynomial.gal.restrict p â„‚) (alg_equiv.restrict_scalars â„š complex.conj_ae))).support.card
filter.tendsto (Î» (p : fin 2 â†’ â„¤), â‡‘complex.norm_sq (â†‘(p 0) * â†‘z + â†‘(p 1))) filter.cofinite filter.at_top
0 < â‡‘Î¼ U
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), â‡‘witt_vector.verschiebung)
âˆƒ (f : bump_covering Î¹ X s), f.is_subordinate U
(category_theory.subobject.map g).obj (fâ‚ âŠ“ fâ‚‚) = (category_theory.subobject.map g).obj fâ‚ âŠ“ (category_theory.subobject.map g).obj fâ‚‚
0 = AddMon.filtered_colimits.M.mk F âŸ¨j, 0âŸ©
x âˆˆ s â†” metric.inf_dist x s = 0
((subalgebra.restrict_scalars â„ A).comap' (alg_hom.comp_left_continuous â„ is_R_or_C.of_real_am is_R_or_C.continuous_of_real)).separates_points
isometry sum.inl
filter.tendsto (Î» (x : â„), x ^ s * real.exp (-b * x)) filter.at_top (nhds 0)
is_compact (closure s)
has_sum (Î» (n : â„•), â†‘n * r ^ n) (r / (1 - r) ^ 2)
âˆƒ (Î› : module.dual â„ F) (Î›â‚€ : â„), (Î›, Î›â‚€) â‰  0 âˆ§ âˆ€ (x : E), â‡‘Î› (â‡‘f' x) + Î›â‚€ â€¢ â‡‘Ï†' x = 0
â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 4
a = b
set.inj_on f s â†’ function.injective (s.restrict f)
monotone (Î» (x : Î±), linear_order.max (f x) (g x))
strict_concave_on â„ set.univ f
p = q
2 â€¢ o.oangle (-x) x = 0
âˆ€á¶  (t : Î¹) in lt, interval_integrable f Î¼ (u t) (v t)
Î¼.ae â‰¤ Î½.ae â†’ Î¼.absolutely_continuous Î½
tendsto_locally_uniformly F f p â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ âˆ€ (x : Î²), âˆƒ (t : set Î²) (H : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_edist.edist (f y) (F n y) < Îµ
polynomial.X âˆˆ polynomial.lifts f
âˆƒ (y : E) (H : y âˆˆ s), f x â‰¤ f y
f.limsup u = a
Q f
metric.diam (metric.closed_ball x r) â‰¤ 2 * r
â‡‘(ideal.quotient.mk I) â»Â¹' (â‡‘(ideal.quotient.mk I) '' s) = â‹ƒ (x : â†¥I), (Î» (y : R), x.val + y) '' s
nonempty (Î± â‰ƒo Î²)
â‡‘f (bit1 a) = bit1 (â‡‘f a)
(âˆ€ (x : Î± â†’ â„•), â‡‘f x = â‡‘g x) â†’ f = g
â‡‘f (x - y) = â‡‘f x - â‡‘f y
â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (fintype.pi_finset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
((Î» (z : Î±), f z x) âˆ˜ Î» (z : Î±), f z y) = Î» (z : Î±), f z (f y x)
category_theory.limits.has_equalizer f g
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ g '' s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ s), f (g j)))
is_seq_closed s
m âˆ£ m + n â†” m âˆ£ n
convex_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
finsupp.map_domain â‡‘f 1 = 1
(category_theory.nat_trans.left_derived Î± n).app X = (F.left_derived_obj_iso n P).hom â‰« (homology_functor D (complex_shape.down â„•) n).map ((category_theory.nat_trans.map_homological_complex Î± (complex_shape.down â„•)).app P.complex) â‰« (G.left_derived_obj_iso n P).inv
inner_product_geometry.angle x y â‰¤ real.pi
(B.dom_restrictâ‚â‚‚ W W).nondegenerate
set.sized (r + 1) â†‘(ğ’œ.up_shadow)
e âˆˆ structure_groupoid.maximal_atlas M G
is_left_regular a
P.coeff 0 = (-1) ^ P.nat_degree * P.roots.prod
(â†‘g.comp (tensor_product.map_incl (lie_module.pre_weight_space Mâ‚ Ï‡â‚) (lie_module.pre_weight_space Mâ‚‚ Ï‡â‚‚))).range â‰¤ lie_module.pre_weight_space Mâ‚ƒ (Ï‡â‚ + Ï‡â‚‚)
â†‘((p - 1).factorial) = -1
is_min_on (â‡‘order_dual.to_dual âˆ˜ f) s a â†’ is_max_on f s a
filter.tendsto (Î» (x : Î±), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
is_regular a
filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.univ  {a})) l
f.mk' (f.sec z).fst (f.sec z).snd = z
pairwise (disjoint on Î» (n : Î±), set.Ioc (f n) (f (order.pred n)))
dfinsupp.single i xi = dfinsupp.single j xj â†” i = j âˆ§ xi == xj âˆ¨ xi = 0 âˆ§ xj = 0
is_mul_hom (Î» (a : Î±), f a * g a)
continuous_on f s
topological_space.pseudo_metrizable_space X
function.right_inverse coe â‡‘cardinal.to_nat
commute (â‡‘quaternion.conj a) (â‡‘quaternion.conj b)
measure_theory.uniform_integrable f p Î¼
(hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.binary_biproduct.is_limit X Y)).hom = category_theory.limits.biprod.lift b.fst b.snd
âˆ¥box_integral.integral I l f Î¼.to_box_additive.to_smulâˆ¥ â‰¤ box_integral.integral I l g Î¼.to_box_additive.to_smul
â‡‘h 0 = 0
pi.mul_single i x i' = 1
f = g
is_greatest (f '' s) (f a)
monoid.is_torsion G â†’ Â¬monoid.is_torsion_free G
o.swap.compares a b â†’ o.compares b a
sym2.map (Î» (x : Î±), x) = id
âˆƒ (f : E â†’L[â„] â„), â‡‘f x < â‡‘f y
add_le_cancellable a
category_theory.epi f â†’ y.len â‰¤ x.len
is_left_regular 0 â†” subsingleton R
{r}.to_colex â‰¤ {s}.to_colex â†” r â‰¤ s
f (-a) = -f a
âˆƒ (f : â„• â†’ Î±), s = set.range f
{dom := o.dom, get := Î» (h : o.dom), o.get h} = o
f' = fâ‚'
X.Î´ i.succ â‰« X.Ïƒ (â‡‘fin.cast_succ j) = X.Ïƒ j â‰« X.Î´ i
(B.restrict W).nondegenerate
âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable âˆ§ t âŠ† s âˆ§ (âˆ€ (x : Î±), x âˆˆ t â†’ r x âˆˆ f x âˆ© set.Ioo 0 (R x)) âˆ§ â‡‘Î¼ (s  â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) = 0 âˆ§ t.pairwise_disjoint (Î» (x : Î±), metric.closed_ball x (r x))
|real.log x * x| < 1
Î¼.inner_content âŸ¨U, hUâŸ© â‰¤ Î¼.inner_content âŸ¨V, hVâŸ©
orthogonal_projection_fn K u = v
quotient.mk â»Â¹' (quotient.mk '' U) = â‹ƒ (a : Î±), has_scalar.smul a '' U
âˆ€á¶  (p : F Ã— â†¥(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker p.fst p.snd) = p.fst
finset.centroid k finset.univ (s.face h).points = finset.centroid k fs s.points
s.sup_indep f â†” âˆ€ (i : Î¹), i âˆˆ s â†’ disjoint (f i) ((s.erase i).sup f)
has_deriv_at complex.cos (-complex.sin x) x
has_deriv_at_filter f f' x L â†” filter.tendsto (slope f x) (L âŠ“ filter.principal {x}á¶œ) (nhds f')
âˆ® (z : â„‚) in C(c, R), f' z = 0
(h.comp g).comp f = h.comp (g.comp f)
âˆ«â» (a : Î²), f a âˆ‚measure_theory.measure.map â‡‘g Î¼ = âˆ«â» (a : Î±), f (â‡‘g a) âˆ‚Î¼
metric.bounded (â‡‘(convex_hull â„) s) â†” metric.bounded s
a + b - a â‰¤ b
1 < aâ»Â¹ â†” a < 1
absolute_value.abs.is_euclidean
f y - f x â‰¤ C * (y - x)
box_integral.has_integral I l (s.indicator (Î» (_x : Î¹ â†’ â„), y)) Î¼.to_box_additive.to_smul ((â‡‘Î¼ (s âˆ© â†‘I)).to_real â€¢ y)
â‡‘f (fin.cons (x + y) m) = â‡‘f (fin.cons x m) + â‡‘f (fin.cons y m)
G.clique_free n â†’ G.clique_finset n = âˆ…
ring_hom.localization_preserves ring_hom.finite
free_group.red Lâ‚‚ (free_group.reduce Lâ‚)
v âˆˆ s.direction â†” âˆƒ (p2 : P) (H : p2 âˆˆ s), v = p -áµ¥ p2
J.plus_map (J.to_plus P) = J.to_plus (J.plus_obj P)
âˆƒ (y : Î²) (H : y âˆˆ t), b < (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
filter.map mâ‚ f = filter.map mâ‚‚ f
iterated_fderiv_within ğ•œ n f s = â‡‘(continuous_multilinear_map.pi_field_equiv ğ•œ (fin n) F) âˆ˜ iterated_deriv_within n f s
is_free_groupoid.spanning_tree.tree_hom T a = is_free_groupoid.spanning_tree.hom_of_path T p
A.to_colex < B.to_colex
a + b < a + c
f.is_subordinate U â†’ f.to_bump_covering.is_subordinate (Î» (i : Î¹), U (f.c i))
dimH (set.range f) â‰¤ dimH set.univ
g (âˆ« (x : Î±), f x âˆ‚Î¼) â‰¤ âˆ« (x : Î±), g (f x) âˆ‚Î¼
interval_integrable f Î¼ a b
is_integral_closure â†¥(algebra.adjoin â„¤ {Î¶}) â„¤ K
x < y â†’ C * (y - x) < f y - f x
((Î» (_x : Î±), _x + x) âˆ˜ Î» (_x : Î±), _x + y) = Î» (_x : Î±), _x + (y + x)
|y - x| â‰¤ |b - a|
minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p)
category_theory.limits.pi.Ï€ f b (category_theory.limits.pi.lift s x) = s b x
has_strict_fderiv_at (has_strict_fderiv_at.local_inverse f f' a hf) â†‘(f'.symm) (f a)
âˆƒ (f : Î± â†’ set Î±), â†‘s.pairwise_disjoint f âˆ§ âˆ€ (x : Î±), x âˆˆ s â†’ x âˆˆ f x âˆ§ is_open (f x)
âˆ¥fderiv ğ•œ f xâ‚€âˆ¥ â‰¤ â†‘C
âˆ€á¶  (x : Î±) in nhds xâ‚€, âˆ€ (y : Î²), y âˆˆ K â†’ P x y
cardinal.mk â†¥{t : set Î± | measurable_space.generate_measurable s t} â‰¤ cardinal.continuum
cont_diff_on ğ•œ n (â‡‘g âˆ˜ f) s
N.topological_closure.normal
Î¼ = Î½ â†” âˆ€ (s : set Î±), s âˆˆ S â†’ Î¼.restrict s = Î½.restrict s
(finset.range (k + 1)).sum (Î» (r : â„•), â†‘((ğ’œ.slice (fintype.card Î± - r)).card) / â†‘((fintype.card Î±).choose (fintype.card Î± - r))) â‰¤ â†‘((finset.falling (fintype.card Î± - k) ğ’œ).card) / â†‘((fintype.card Î±).choose (fintype.card Î± - k))
â…subgroup.pi set.univ H,subgroup.pi set.univ Kâ† = subgroup.pi set.univ (Î» (i : Î·), â…H i,K iâ†)
cont_diff_at ğ•œ n continuous_linear_map.inverse â†‘e
âˆƒ (t : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), measurable_set (t i)) âˆ§ (âˆ€ (i : Î¹), â‡‘Î¼ (t i) = 0) âˆ§ pairwise (disjoint on Î» (i : Î¹), s i  t i)
(finset.filter (Î» (e : â„•), p âˆ£ e + 1) (finset.range n)).card = n / p
is_trivial_topological_fiber_bundle F prod.fst
p.sum f = (finset.range (p.nat_degree + 1)).sum (Î» (a : â„•), f a (p.coeff a))
function.surjective (category_theory.limits.colimit_limit_to_limit_colimit F)
emetric.Hausdorff_edist (closure s) t = emetric.Hausdorff_edist s t
x = y â†” o.oangle x y = 0
upper_semicontinuous_at (Î» (z : Î±), f z + g z) x
algebra.is_integral K L
s.sum (Î» (x : Î±), f x) = (finset.image quotient.mk s).sum (Î» (xbar : quotient R), (finset.filter (Î» (y : Î±), âŸ¦yâŸ§ = xbar) s).sum (Î» (y : Î±), f y))
f â‰« g = f â‹™ g
cont_diff_within_at ğ•œ n (Î» (x : E), -f x) s x
â‡‘f x = â‡‘g x
âˆƒ (V : set G) (H : V âˆˆ nhds 0), V + K âŠ† U
x.some_vector â‰  0
Î¼.is_open_pos_measure
â‡‘(affine_map.id k P1) p = p
r x y â†’ x = y
âˆƒ (M : â„), âˆ«â» (x : Î±), â†‘âˆ¥{x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f xâˆ¥â‚Š âˆ‚Î¼ â‰¤ ennreal.of_real Îµ
s.points i âˆˆ s.altitude i
{s : set Î± | is_preconnected s} = set.range (function.uncurry set.Icc) âˆª set.range (function.uncurry set.Ico) âˆª set.range (function.uncurry set.Ioc) âˆª set.range (function.uncurry set.Ioo) âˆª (set.range set.Ici âˆª set.range set.Ioi âˆª set.range set.Iic âˆª set.range set.Iio âˆª {set.univ, âˆ…})
proper_space Î±
n.factorization.prod (Î» (p k : â„•), f p) = n.factors.to_finset.prod (Î» (p : â„•), f p)
function.injective (Î» (b : Î²) (a : Î±), f a b)
âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
âˆƒ (j : Î¹) (hij : i â‰¤ j), â‡‘(f i j hij) x = 0
interval_integrable F' Î¼ a b âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' t âˆ‚Î¼) xâ‚€
(fintype.card â†¥Hâ‚).coprime (fintype.card â†¥Hâ‚‚)
measure_theory.ae_strongly_measurable' m â‡‘f Î¼ â†’ P f
f âˆˆ metric.closed_ball fâ‚€ r
(x â¨¿ y) = x âŠ” y
galois_connection (Î» (s : set R), prime_spectrum.zero_locus s) (Î» (t : (set (prime_spectrum R))áµ’áµˆ), â†‘(prime_spectrum.vanishing_ideal t))
category_theory.is_pushout hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚
subgroup.map f H.normalizer = (subgroup.map f H).normalizer
âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
category_theory.limits.has_limit G
Â¬linear_independent R (v âˆ˜ coe) â†” âˆƒ (f : Î¹ â†’â‚€ R), f âˆˆ finsupp.supported R R s âˆ§ f.support.sum (Î» (i : Î¹), â‡‘f i â€¢ v i) = 0 âˆ§ f â‰  0
f = g
x = finset.univ.sum (Î» (i : Î¹), x i â€¢ Î» (j : Î¹), ite (i = j) 1 0)
âŠ¥.is_SRG_with (fintype.card V) 0 â„“ 0
filter.tendsto F p (nhds f) â†” tendsto_uniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
is_min_on f s a
â‡‘f v = 0
is_countably_spanning (set.univ.pi '' set.univ.pi C)
is_closed (coe_fn '' metric.closed_ball fâ‚€ r)
s.powerset.nodup â†’ s.nodup
v inhabited.default â‰  0 â†’ linear_independent R v
smooth I (model_with_corners_self â„ â„) â‡‘f
(uniformity Î±).has_basis (Î» (Îµ : â„), 0 < Îµ) (Î» (Îµ : â„), {p : Î± Ã— Î± | has_dist.dist p.fst p.snd â‰¤ Îµ})
lipschitz_on_with C f s
P X U
(quandle.conj.map (â‡‘rack.to_envel_group.map f)).comp (rack.to_envel_group R) = f
(â‡‘Ï† p).nat_degree = fu p.nat_degree
list.drop (lâ‚.length + i) (lâ‚ ++ lâ‚‚) = list.drop i lâ‚‚
r a b â†’ r b a â†’ b = a
commute (pi.mul_single i (x i)) (pi.mul_single j (x j))
has_sum f r â†” filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i)) filter.at_top (nhds r)
uniform_continuous f
cardinal.mk â†¥(set.Icc a b) = cardinal.continuum
(â‡‘(bâ‚.repr) x).sum (Î» (i : Î¹â‚) (xi : R), (â‡‘(bâ‚‚.repr) y).sum (Î» (j : Î¹â‚‚) (yj : S), â‡‘Ïâ‚â‚‚ xi â€¢ â‡‘Ïƒâ‚â‚‚ yj â€¢ â‡‘(â‡‘B (â‡‘bâ‚ i)) (â‡‘bâ‚‚ j))) = â‡‘(â‡‘B x) y
âˆ€áµ (x : Î²) âˆ‚Î¼, filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (s.indicator 1 x))
is_least s a â†’ is_greatest (f '' s) (f a)
âˆƒ (a : X) (H : a âˆˆ closure s) (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ filter.tendsto (x âˆ˜ Ï†) filter.at_top (nhds a)
âˆƒ (r : â„), irrational r âˆ§ x < r âˆ§ r < y
p = p' â†’ ps = ps' â†’ p ^ ps = p' ^ ps'
F = G
[is_galois F E, intermediate_field.fixed_field âŠ¤ = âŠ¥, fintype.card (E â‰ƒâ‚[F] E) = finite_dimensional.finrank F E, âˆƒ (p : polynomial F), p.separable âˆ§ polynomial.is_splitting_field F E p].tfae
âˆƒ (K : nnreal) (t : set E) (H : t âˆˆ nhds_within x s), lipschitz_on_with K f t
dense (â‹‚ (s : Î²), f s)
âˆƒ (v : V), G.max_degree = G.degree v
category_theory.limits.image.Î¹ f = (category_theory.limits.image.eq_to_iso h).hom â‰« category_theory.limits.image.Î¹ f'
differentiable_on ğ•œ f s
â†‘({x : zmod p | x ^ 2 = â†‘a}.to_finset.card) = zmod.legendre_sym p a + 1
X = Y
factorization (a * b) = factorization a + factorization b
a â‰¤ a
dense_embedding (Î» (p : Î± Ã— Î³), (eâ‚ p.fst, eâ‚‚ p.snd))
[s âˆˆ nhds_within b (set.Iic b), s âˆˆ nhds_within b (set.Icc a b), s âˆˆ nhds_within b (set.Ioc a b), âˆƒ (l : Î±) (H : l âˆˆ set.Ico a b), set.Ioc l b âŠ† s, âˆƒ (l : Î±) (H : l âˆˆ set.Iio b), set.Ioc l b âŠ† s].tfae
âˆ€áµ (x : E) âˆ‚Î¼.restrict s, âˆ¥f' x - Aâˆ¥â‚Š â‰¤ Î´
star_convex ğ•œ (â‡‘f x) (â‡‘f '' s)
(s.sum (Î» (a : Î±), f a)).to_real = s.sum (Î» (a : Î±), (f a).to_real)
has_dist.dist f g â‰¤ C â†” âˆ€ (x : Î±), has_dist.dist (â‡‘f x) (â‡‘g x) â‰¤ C
â†‘(affine_span k s).nonempty â†” s.nonempty
continuous g.comp
fintype.card L â‰¤ fintype.card P
set.eq_on f 0 (complex.im â»Â¹' set.Icc a b)
is_left_regular (a ^ n) â†” is_left_regular a
(generalized_continued_fraction.squash_seq s (n + 1)).tail = generalized_continued_fraction.squash_seq s.tail n
category_theory.non_preadditive_abelian.Ïƒ â‰« f = category_theory.limits.prod.map f f â‰« category_theory.non_preadditive_abelian.Ïƒ
P x
âˆƒ (y : O) (H : y âˆˆ M) (a : R) (hay : a â€¢ y âˆˆ N) (M' : submodule R O) (H : M' â‰¤ M) (N' : submodule R O) (H : N' â‰¤ N) (N'_le_M' : N' â‰¤ M') (y_ortho_M' : âˆ€ (c : R) (z : O), z âˆˆ M' â†’ c â€¢ y + z = 0 â†’ c = 0) (ay_ortho_N' : âˆ€ (c : R) (z : O), z âˆˆ N' â†’ c â€¢ a â€¢ y + z = 0 â†’ c = 0), âˆ€ (n' : â„•) (bN' : basis (fin n') R â†¥N'), âˆƒ (bN : basis (fin (n' + 1)) R â†¥N), âˆ€ (m' : â„•) (hn'm' : n' â‰¤ m') (bM' : basis (fin m') R â†¥M'), âˆƒ (hnm : n' + 1 â‰¤ m' + 1) (bM : basis (fin (m' + 1)) R â†¥M), âˆ€ (as : fin n' â†’ R), (âˆ€ (i : fin n'), â†‘(â‡‘bN' i) = as i â€¢ â†‘(â‡‘bM' (â‡‘(fin.cast_le hn'm') i))) â†’ (âˆƒ (as' : fin (n' + 1) â†’ R), âˆ€ (i : fin (n' + 1)), â†‘(â‡‘bN i) = as' i â€¢ â†‘(â‡‘bM (â‡‘(fin.cast_le hnm) i)))
add_subgroup.closure â†‘K = K
âˆƒ (f : (Î  (n : â„•), E n) â†’ Î  (n : â„•), E n), (âˆ€ (x : Î  (n : â„•), E n), x âˆˆ s â†’ f x = x) âˆ§ set.range f = s âˆ§ lipschitz_with 1 f
f = g
nontrivial Î±
â‡‘(mâ‚.trim) s = op (â‡‘(mâ‚‚.trim) s) (â‡‘(mâ‚ƒ.trim) s)
a â‰¤ b + c â†’ a - b â‰¤ c
A = â‡‘linear_map.adjoint B â†” âˆ€ (iâ‚ : Î¹â‚) (iâ‚‚ : Î¹â‚‚), has_inner.inner (â‡‘A (â‡‘bâ‚ iâ‚)) (â‡‘bâ‚‚ iâ‚‚) = has_inner.inner (â‡‘bâ‚ iâ‚) (â‡‘B (â‡‘bâ‚‚ iâ‚‚))
t.prod (Î» (i : Î¹), f i) âˆˆ S
filter.tendsto f (nhds_within c {c}á¶œ) (nhds (lim (nhds_within c {c}á¶œ) f))
s.topological_closure.comap' f = (s.comap' f).topological_closure
C s
â‡‘(hb.rotation Î¸) x = x â†” Î¸ = 0
irrational (x + y) â†’ irrational x âˆ¨ irrational y
âˆƒ (x : X) (H : x âˆˆ s), âˆ€ (t : set X), t âˆˆ nhds_within x s â†’ r < dimH t
(finset.range n).sum (Î» (k : â„•), power_series.exp A ^ k) = power_series.mk (Î» (p : â„•), (finset.range n).sum (Î» (k : â„•), â†‘k ^ p * â‡‘(algebra_map â„š A) (â†‘(p.factorial))â»Â¹))
monoid.is_torsion â†¥(comm_monoid.torsion G)
emetric.inf_edist x s < r â†” âˆƒ (y : Î±) (H : y âˆˆ s), has_edist.edist x y < r
âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * â†‘(fintype.card Î¹) * linear_order.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
âˆƒ (F : circle_deg1_lift), function.semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
sâ‚.equivalent sâ‚‚
has_Sup.Sup s = b
finset.univ.sum (Î» (x : K), x ^ i) = 0
finite_dimensional.finrank R M = finite_dimensional.finrank R Mâ‚‚
is_pi_system (set.univ.pi '' set.univ.pi C)
measure_theory.tendsto_in_measure Î¼ f l g
p.sum f = (finset.range n).sum (Î» (a : â„•), f a (p.coeff a))
â‡‘(v.valuation) (is_localization.mk' K r s) = â‡‘(v.int_valuation) r / â‡‘(v.int_valuation) â†‘s
â†‘r â‰¤ p.radius
monotone (Î¼ m)
âˆƒ (n : â„¤), x âˆˆ set.Ioc (y ^ n) (y ^ (n + 1))
z = w * â†‘(â‡‘(is_unit.lift_right (f.restrict S) h) y)â»Â¹ â†” z * â‡‘f â†‘y = w
is_add_monoid_hom (g âˆ˜ f)
complete_lattice.is_Sup_finite_compact Î± â†’ well_founded gt
Â¬is_right_regular 0
p s
f aâ»Â¹ = (f a)â»Â¹
a â‰ˆ b â†’ category_theory.abelian.app f a â‰ˆ category_theory.abelian.app f b
cont_mdiff_within_at I I' â†‘n f s x â†” âˆƒ (u : set M) (H_1 : u âˆˆ nhds_within x (has_insert.insert x s)), cont_mdiff_on I I' â†‘n f u
measurable_space.generate_from (set.image2 has_set_prod.prod {s : set Î± | measurable_set s} {t : set Î² | measurable_set t}) = prod.measurable_space
has_fpower_series_on_ball f pâ‚ x râ‚‚
âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ â‡‘f x) âˆ§ upper_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ
p.nat_degree â‰¤ n â†’ p.degree â‰¤ â†‘n
âˆƒ (y : Î²), (finset.filter (Î» (x : Î±), f x = y) finset.univ).card â‰¤ n
(Top.subpresheaf_to_Types P.to_prelocal_predicate).is_sheaf
âˆƒ (w : set E) (b : hilbert_basis â†¥w ğ•œ E), s âŠ† w âˆ§ â‡‘b = coe
âˆƒ (g : F â†’L[ğ•œ] ğ•œ), (âˆ€ (x : â†¥p), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥
finset.univ.prod (Î» (i : Ïƒ), â‡‘polynomial.C (mv_polynomial.X i) + polynomial.X) = (finset.range (fintype.card Ïƒ + 1)).sum (Î» (j : â„•), â‡‘polynomial.C (mv_polynomial.esymm Ïƒ R j) * polynomial.X ^ (fintype.card Ïƒ - j))
category_theory.is_pushout (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)
continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)
C x
fintype.card â†¥P = p ^ â‡‘((fintype.card G).factorization) p
has_deriv_at (exp_neg_inv_glue.f_aux n) 0 0
a * e + c = b * e + d â†” (a - b) * e + c = d
witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g x (f y))
set.unbounded has_lt.lt (function.fixed_points f)
measurable g
continuous_at f a
metric.bounded (â‹ƒ (i : Î²) (H : i âˆˆ I), s i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ metric.bounded (s i)
â‡‘Î¼ s < âŠ¤
x.lf y
âˆƒ (m : Î±), âˆ€ (a : Î±), r m a â†’ r a m
set.eq_on f g (closure s)
emetric.inf_edist x s â‰¤ emetric.inf_edist y s + has_edist.edist x y
â‡‘c w x â†’ â‡‘c (-w) (-x)
f = g
is_right_regular (a ^ n)
convex ğ•œ (interior s)
âˆƒ (i : Î¹), nonempty (Î  (j : Î¹), Î² i â†ª Î² j)
function.injective f
âˆƒ (Î› : Î¹ â†’ â„) (Î›â‚€ : â„), (Î›, Î›â‚€) â‰  0 âˆ§ finset.univ.sum (Î» (i : Î¹), Î› i â€¢ f' i) + Î›â‚€ â€¢ Ï†' = 0
Î½.with_density f = Î½.with_density (Î¼.rn_deriv Î½)
hb.oangle (-x) y = hb.oangle x (-y)
cont_diff_on ğ•œ n prod.snd s
x âˆˆ closure s â†” âˆƒ (u : ultrafilter Î±), s âˆˆ u âˆ§ â†‘u â‰¤ nhds x
filter.tendsto (Î» (k : â„•), (finset.range k).sum (Î» (i : â„•), (-1) ^ i / (2 * â†‘i + 1))) filter.at_top (nhds (real.pi / 4))
finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary (f âˆ˜ â‡‘Ïƒ) g
charted_space.chart_at H x = local_homeomorph.refl H
(xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ) ^ 2 + (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚) ^ 2
is_add_left_regular a
add_monoid.exponent_exists G
bdd_below s
perfection_map p (perfection.coeff R p 0)
category_theory.simple â†‘Y â†” is_atom Y
(Î» (t : Î¹), ((âˆ« (x : â„) in a..v t, f x) - âˆ« (x : â„) in a..u t, f x) - (v t - u t) â€¢ c) =o[lt] (v - u)
0 < 1
is_closed â†‘s
(hb.rotation Î¸).symm = hb.rotation (-Î¸)
affine_span â„ (set.range p) = affine_span â„ s
a = b â†’ a - b = 0
orthonormal ğ•œ w
function.bijective real.sinh
orthogonal_family ğ•œ (Î» (Î¼ : ğ•œ), (module.End.eigenspace T Î¼).subtypeâ‚—áµ¢)
a âŠ‚ b
is_square a â†” a ^ (p / 2) = 1
is_pi_system (set.univ.pi '' set.univ.pi (Î» (i : Î¹), {s : set (Î± i) | measurable_set s}))
bdd_above (has_insert.insert a s) â†” bdd_above s
s.card * n â‰¤ B.sum (Î» (t : finset Î±), (s âˆ© t).card)
continuous_within_at f (set.Ici a) a
â‡‘(euclidean_geometry.reflection s) (v +áµ¥ p) = -v +áµ¥ p
f.ker.is_maximal
finite_dimensional K Vâ‚‚
analytic_on ğ•œ (deriv^[n] f) s
âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ C
absorbent ğ•œ (p.ball 0 r)
(-1) ^ 2 = 1
has_inner.inner x y = 1 â†” x = y
{p : Î± Ã— Î± | has_edist.edist p.fst p.snd < Îµ} âˆˆ uniformity Î±
b â‰¤ c â†’ a < b â†’ a < c
hb.oangle x (r â€¢ y) = hb.oangle x y
â‡‘(k.lift _) (â‡‘(f.lift _) z) = z
âˆ€áµ (Ï‰ : Î©), filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), X i Ï‰) / â†‘n) filter.at_top (nhds (âˆ« (a : Î©), X 0 a))
measure_theory.prog_measurable f u
â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) âˆˆ affine_subspace.mk' p (s.direction)á—®
asymptotics.is_O_with C (nhds b) f g â†” asymptotics.is_O_with C (nhds (â‡‘(e.symm) b)) (f âˆ˜ â‡‘e) (g âˆ˜ â‡‘e)
measure_theory.simple_func.integral Î¼ f = s.sum (Î» (x : F), (â‡‘Î¼ (â‡‘f â»Â¹' {x})).to_real â€¢ x)
same_ray R x (r â€¢ y)
p x
(âˆ€ (a : L), a âˆˆ m â†’ a âˆˆ S) â†’ m.sum âˆˆ S
convex_on ğ•œ s f â†” convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)
hb.oangle x (â‡‘(hb.rotation Î¸) x) = Î¸
disjoint s t âˆ¨ s âŠ† t
has_ftaylor_series_up_to_on n (f âˆ˜ â‡‘g) (Î» (x : G) (k : â„•), (p (â‡‘g x) k).comp_continuous_linear_map (Î» (_x : fin k), g)) (â‡‘g â»Â¹' s)
function.injective â‡‘(algebra_map Râ‚˜ Sâ‚˜)
measure_theory.vadd_invariant_measure G (G â§¸ Î“) (measure_theory.measure.map quotient_add_group.mk (Î¼.restrict ğ“•))
module.is_torsion' â†¥(submodule.torsion' R M S) S
â‡‘f' y = 0
s.prod (Î» (x : Î±), f x) = (finset.image quotient.mk s).prod (Î» (xbar : quotient R), (finset.filter (Î» (y : Î±), âŸ¦yâŸ§ = xbar) s).prod (Î» (y : Î±), f y))
f.srange = âŠ¤
âˆ« (x : E) in f '' s, g x âˆ‚Î¼ = âˆ« (x : E) in s, |(f' x).det| â€¢ g (f x) âˆ‚Î¼
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), deriv f c = 0
category_theory.limits.has_binary_products C
polynomial.cyclotomic' n R â‰  0
bdd_above (s âˆ© t)
nhds (x, x) â‰¤ uniformity Î±
â‡‘(is_localization.map W l hl) (â‡‘(is_localization.map Q g hy) x) = â‡‘(is_localization.map W (l.comp g) _) x
â‡‘Î¼ {x : Î± | v.lim_ratio_meas hÏ x = âŠ¤} = 0
a âˆˆ t.prod (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ {i : Î¹}, i âˆˆ t â†’ g i âˆˆ f i), t.prod (Î» (i : Î¹), g i) = a
exp ğ•œ z âˆˆ spectrum ğ•œ (exp ğ•œ a)
irreducible f
â†‘n.numeric
â‡‘f xâ‚ + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) yâ‚ = â‡‘f xâ‚‚ + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) yâ‚‚ â†” â‡‘f (xâ‚ + â†‘yâ‚‚) = â‡‘f (xâ‚‚ + â†‘yâ‚)
â‡‘Î¼ â†‘s = 0
has_ftaylor_series_up_to_on (â†‘n + 1) f p s â†” has_ftaylor_series_up_to_on â†‘n f p s âˆ§ (âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at (Î» (y : E), p y n) (p x n.succ).curry_left s x) âˆ§ continuous_on (Î» (x : E), p x (n + 1)) s
cont_diff â„ n exp_neg_inv_glue
I.jacobson = I â†” âˆ€ (x : R), x âˆ‰ I â†’ (âˆƒ (M : ideal R), (I â‰¤ M âˆ§ M.is_maximal) âˆ§ x âˆ‰ M)
o.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x
(setoid.ker f).rel x y â†” x âˆˆ f â»Â¹' {f y}
padic_val_int p 1 = 0
â‡‘(algebra_map K F) (â‡‘(algebra.norm K) pb.gen) = (polynomial.map (algebra_map K F) (minpoly K pb.gen)).roots.prod
{o : ordinal | a â‰¤ b + o}.nonempty
r â€¢ metric.closed_ball 0 1 = metric.closed_ball 0 r
âˆ€áµ (Ï‰ : Î©), filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), X i Ï‰) / â†‘n) filter.at_top (nhds (âˆ« (a : Î©), X 0 a))
â‡‘(euclidean_geometry.orthogonal_projection s) (r â€¢ (p2 -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2)) +áµ¥ p1) = âŸ¨p1, hpâŸ©
(measure_theory.measure.map f Î¼).restrict s = measure_theory.measure.map f (Î¼.restrict (f â»Â¹' s))
â‡‘(affine_map.id k P1) = id
G.max_degree â‰¤ k
e.symm â‰ˆ e'.symm
finite_dimensional K â†¥(E1 âŠ” E2)
has_inner.inner v u = 0
polynomial.cyclotomic 2 R = polynomial.X + 1
(Ï† * Ïˆ).order = Ï†.order + Ïˆ.order
a * b < 1
concave_on ğ•œ s (-f) â†” convex_on ğ•œ s f
add_comm_monoid.add_torsion G = (add_torsion G).to_add_submonoid
isometry coe
measurable_embedding f
j = k
is_preconnected (â‹ƒâ‚€S)
well_founded has_lt.lt
is_min a â†’ order.pred a = a
t.prod.degree â‰¤ (multiset.map polynomial.degree t).sum
(âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) â†” c = d
module.rank F K * module.rank K A = module.rank F A
(finset.range n).prod (Î» (k : â„•), f k) = s n
â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds_within (â‡‘(ext_chart_at I x) x) (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I)
free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚
has_edist.edist x y = has_edist.edist â†‘x â†‘y
closure (set.Ioc a b) = set.Icc a b
fin.find p = option.none â†” âˆ€ (i : fin n), Â¬p i
âˆƒ (a : K), (âˆ€ (i : Î¹), i âˆˆ s â†’ is_localization.is_integer A (a * f i)) âˆ§ âˆƒ (i : Î¹) (H : i âˆˆ s), a * f i âˆ‰ â†‘J
1 < a * b
o.oangle x (-x) = â†‘real.pi
cont_diff_at ğ•œ n f x â†’ cont_mdiff_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f x
g.squash_gcf n = g
filter.tendsto (Î» (i : Î¹), convolution (Ï† i) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) l (nhds (g xâ‚€))
finset.centroid k {i} p = p i
f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
closed_embedding â‡‘f
pairwise (disjoint on Î» (n : Î±), set.Ioc (f n) (f (order.succ n)))
p.pred_above (â‡‘((â‡‘fin.cast_succ p).succ_above) i) = i
function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 0 â†” a = 0
{x : Î± | (setoid.mk_classes c H).rel x y} âˆˆ c
(Z.local_triv_as_local_equiv i).symm.trans (Z.local_triv_as_local_equiv j) â‰ˆ (Z.triv_change i j).to_local_equiv
âˆ¥f zâˆ¥ â‰¤ C
âˆ¥a â€¢ x + b â€¢ yâˆ¥ < r
y âˆˆ submonoid.closure {x} â†” âˆƒ (n : â„•), x ^ n = y
0 â‰¤ metric.diam s
(equiv.to_pequiv Ïƒ).to_matrix.det = â†‘(â‡‘equiv.perm.sign Ïƒ)
is_open â†‘H
bornology.is_bounded s â†’ bounded_space â†¥s
affine_span k (has_insert.insert p ps) = affine_span k ps
has_star.star (x / y) = has_star.star x / has_star.star y
same_ray R (r â€¢ v) v â†” 0 < r
is_smul_regular M 0
âˆƒ (m : â„•), g.nat_degree * q ^ m = f.nat_degree
Jâ‚.is_closed S â†” Jâ‚.close S = S
f '' s âŠ† t â†” s âŠ† f â»Â¹' t
category_theory.exact f g â†” category_theory.limits.image_subobject f = category_theory.limits.kernel_subobject g
direct_sum.is_internal (add_monoid_algebra.grade R)
add_subgroup.map f H.normalizer = (add_subgroup.map f H).normalizer
â†‘u âŠ† s + t â†’ (âˆƒ (s' t' : finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' + t')
category_theory.epi f
is_trivial_topological_fiber_bundle F prod.snd
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ has_insert.insert a s), f i)) = f a + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
p = 0
(Î» (t : R), ring.inverse (â†‘x + t) - â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥
1 âˆˆ powers x
filter.map (Î» (s : finset Î³), s.sum (Î» (i : Î³), f (g i))) filter.at_top = filter.map (Î» (s : finset Î²), s.sum (Î» (i : Î²), f i)) filter.at_top
âˆ€á¶  (t : set (Î± Ã— Î±)) in (uniformity Î±).small_sets, comp_rel t^[n] t âŠ† s
euclidean_geometry.angle p3 (midpoint â„ p1 p2) p1 = real.pi / 2
â‡‘Î¼ (r â€¢ s) = ennreal.of_real |r ^ finite_dimensional.finrank â„ E| * â‡‘Î¼ s
(âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) â†’ 0 < t.sum (Î» (i : Î¹), w i) â†’ (âˆ€ (i : Î¹), i âˆˆ t â†’ z i âˆˆ s) â†’ t.center_mass w z âˆˆ s
function.injective (Î» (g : multilinear_map R Mâ‚' Mâ‚‚), g.comp_linear_map f)
âŠ¥.direction = âŠ¥
âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
topological_space.second_countable_topology Î±
has_deriv_at (exp ğ•‚) (exp ğ•‚ x) x
has_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) a
lie_module.is_nilpotent R L M
x = â‡‘(hb.rotation Î¸) x â†” Î¸ = 0
antitone (Î» (n : N), f (Î¼ m n))
has_sum g a
x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
b â‰¤ c â†’ a â‰¤ b â†’ a â‰¤ c
category_theory.preadditive_coyoneda â‹™ (category_theory.whiskering_right C AddCommGroup (Type v)).obj (category_theory.forget AddCommGroup) = category_theory.coyoneda
is_poly â‡‘f
cardinal.mk (W_type Î²) â‰¤ Îº
category_theory.limits.has_zero_object C
cont_diff ğ•œ n (Î» (x : E), f x + g x)
multiset.map (Î» (x : â„•), (a * â†‘x).val_min_abs.nat_abs) (finset.Ico 1 (p / 2).succ).val = multiset.map (Î» (a : â„•), a) (finset.Ico 1 (p / 2).succ).val
dimH (f '' s) â‰¤ dimH s / â†‘r
â†‘s.separates_points_strongly
M p
f.lintegral Î¼ = g.lintegral Î¼
is_localization (submonoid.comap (algebra_map R S).to_monoid_hom N) T
is_fw_invariant Ï• s â†” is_invariant Ï• s
emetric.Hausdorff_edist s s = 0
is_compact (coe_fn '' metric.closed_ball fâ‚€ r)
A = â‡‘linear_map.adjoint B â†” âˆ€ (x : E) (y : F), has_inner.inner (â‡‘A x) y = has_inner.inner x (â‡‘B y)
âˆƒ (y : Î²), (finset.filter (Î» (x : Î±), f x = y) finset.univ).sum (Î» (x : Î±), w x) < b
o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = â†‘real.pi
â‡‘Î¼ U = â¨† (K : set Î±) (h : K âŠ† U) (h2 : is_compact K), â‡‘Î¼ K
â‡‘e (x + y) = â‡‘e x + â‡‘e y
â‡‘Ïˆ f = â‡‘(direct_sum.to_module R Î¹ N (Î» (i : Î¹), Ïˆ.comp (direct_sum.lof R Î¹ M i))) f
(has_Inf.Inf s).rel = has_Inf.Inf (setoid.rel '' s)
x âˆˆ set.Icc a b â†’ f x â‰¤ B x
â‡‘f (-x) = â‡‘g (-x)
filter.tendsto (Î» (x : Î²), (fâ‚ x, fâ‚ƒ x)) l (uniformity Î±)
category_theory.limits.biprod.fst â‰« category_theory.limits.biprod.inl + category_theory.limits.biprod.snd â‰« category_theory.limits.biprod.inr = ğŸ™ (X âŠ Y)
âŠ¥ = âŠ¤
âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p
f âˆˆ submodule.span k (add_monoid_algebra.of' k G '' â†‘(f.support))
-0 = 0
â‡‘(algebra_map R A) r * x = x * â‡‘(algebra_map R A) r
s.nonempty
âˆƒ (C : â„) (H : C > 0), âˆ€ {u : E â†’L[ğ•œ] F} {M : â„}, 0 â‰¤ M â†’ (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥ â‰¤ M) â†’ âˆ¥uâˆ¥ â‰¤ C * M
f = g
G.max_degree < fintype.card V
category_theory.limits.is_limit.of_nat_iso.cone_of_hom h f = (category_theory.limits.is_limit.of_nat_iso.limit_cone h).extend f
uniform_continuous_on f s
âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0
â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) + â‡‘(f.map hy k) z = â‡‘(k.to_map) (â‡‘g (f.sec z).fst)
finset.univ.prod (Î» (i : fin (n + 1)), f i) = f x * finset.univ.prod (Î» (i : fin n), f (â‡‘(x.succ_above) i))
n â€¢ a < cardinal.aleph_0 â†” n = 0 âˆ¨ a < cardinal.aleph_0
(infi f).ne_bot
filter.tendsto (Î» (x : Î²), r * f x) l filter.at_bot
â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© t) âˆ© set.range â‡‘I = â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' t
same_ray R v (r â€¢ v)
(primitive_roots k R).card = k.totient
Â¬filter.tendsto f a bâ‚‚
subring.map f (subring.closure s) = subring.closure (â‡‘f '' s)
add_commute a a
prime P â†” P.is_prime
âˆƒ (y : Î²) (H : y âˆˆ t), b < â†‘((finset.filter (Î» (x : Î±), f x = y) s).card)
â‡‘linear_map.det â†‘((hb.rotation Î¸).to_linear_equiv) = 1
a ^ (p - 1) = 1
l.nodup â†’ l.sublists.nodup
category_theory.is_iso (algebraic_geometry.PresheafedSpace.stalk_map (algebraic_geometry.Spec.to_PresheafedSpace.map (CommRing.of_hom (algebra_map â†¥R (localization M))).op) x)
filter.tendsto real.exp (nhds 0) (nhds 1)
filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) filter.at_top (nhds (â‡‘â†‘Î¼ E))
is_submonoid (set.range f)
âˆƒ (Î¹ : Type uâ‚) [_inst_3 : fintype Î¹] (C : Î¹ â†’ set Î±) (hC : âˆ€ (i : Î¹), is_compact (C i)) (U : Î¹ â†’ set Î²) (hU : âˆ€ (i : Î¹), is_open (U i)), (f âˆˆ â‹‚ (i : Î¹), continuous_map.compact_open.gen (C i) (U i)) âˆ§ (â‹‚ (i : Î¹), continuous_map.compact_open.gen (C i) (U i)) âŠ† continuous_map.compact_conv_nhd K V f
b â‰¤ -a + c â†’ a + b â‰¤ c
âˆƒ (c : nat.partrec.code), (f c).eval = c.eval
cont_diff ğ•œ n (Î» (x : E), f x â€¢ g x)
âˆƒ (Î¹ : Type uM) (f : smooth_bump_covering Î¹ I M s), f.is_subordinate U
(upper_bounds s âˆ© lower_bounds t).nonempty
âŠ¤ - â†‘r = âŠ¤
Â¬is_smul_regular M 0
(a âŠ” u)  v âˆˆ s
Ï†â‚ = Ï†â‚‚
a = b
p1 -áµ¥ p2 âˆˆ s.direction
o.oangle y x = -o.oangle x y
p âˆ£ fintype.card {x // â‡‘(mv_polynomial.eval x) f = 0}
category_theory.is_connected J
âˆƒ (b : Î±), b âˆˆ mul_action.fixed_points G Î± âˆ§ a â‰  b
o.oangle (-x) y = o.oangle x y + â†‘real.pi
Î¼ = Î½
affine_independent k p
category_theory.limits.cokernel.map f f' p q hâ‚ â‰« category_theory.limits.cokernel.desc f' g' w' = category_theory.limits.cokernel.desc f g w â‰« r
even m â†’ (âˆƒ (c : Î±), m = 2 â€¢ c)
p â‰  0
â‡‘Î¼ s = â‡‘Î¼ (s âˆ© f â»Â¹' {0}) + â‡‘Î¼ (s âˆ© f â»Â¹' {âŠ¤}) + âˆ‘' (n : â„¤), â‡‘Î¼ (s âˆ© f â»Â¹' set.Ico (â†‘t ^ n) (â†‘t ^ (n + 1)))
module.rank R (direct_sum Î¹ (Î» (i : Î¹), M i)) = cardinal.sum (Î» (i : Î¹), module.rank R (M i))
vector_span k â†‘s = submodule.span k â†‘(finset.image (Î» (_x : P), _x -áµ¥ p) (s.erase p))
module.rank R (M Ã— N) = module.rank R M + module.rank R N
f.is_multiplicative â†” â‡‘f 1 = 1 âˆ§ âˆ€ {m n : â„•}, m â‰  0 â†’ n â‰  0 â†’ m.coprime n â†’ â‡‘f (m * n) = â‡‘f m * â‡‘f n
con.ker f = c
âˆ¯ (x : fin (n + 1) â†’ â„‚) in T(c, R), f x = âˆ® (x : â„‚) in C(c i, R i), âˆ¯ (y : fin n â†’ â„‚) in T(c âˆ˜ â‡‘(i.succ_above), R âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth x y)
n â‰¤ m â†’ P n
Â¬b âŠ† a
(Î» (x : â„), x ^ s) =o[filter.at_top] real.exp
tendsto_uniformly_on F f p s â†” filter.tendsto (Î» (q : Î¹ Ã— Î±), (f q.snd, F q.fst q.snd)) (p.prod (filter.principal s)) (uniformity Î²)
z * â‡‘(algebra_map R S) â†‘((is_localization.sec M z).snd) = â‡‘(algebra_map R S) (is_localization.sec M z).fst
(â¨† (x : X) (H : x âˆˆ s), (nhds_within x s).small_sets.limsup dimH) = dimH s
(â‡‘polynomial.C a * p).nat_degree = p.nat_degree
(f.cycle_of x).is_cycle â†” â‡‘f x â‰  x
filter.tendsto (Î» (x : Î²), f x + g x) l filter.at_bot
linear_order.min (f x) (f y) â‰¤ f (a â€¢ x + b â€¢ y)
g = â‡‘rack.to_envel_group.map f
â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta (2 ^ k) K L - 1) = 2
is_add_group_hom f
cont_diff ğ•œ n (g âˆ˜ f)
â‡‘(affine_map.line_map (f a) (f b)) r â‰¤ f (â‡‘(affine_map.line_map a b) r) â†” slope f (â‡‘(affine_map.line_map a b) r) b â‰¤ slope f a (â‡‘(affine_map.line_map a b) r)
F.is_sheaf
has_inner.inner (A i) (B j) = B.mul A.conj_transpose j i
coe '' mul_action.orbit R m = mul_action.orbit R â†‘m
p x y
âˆƒ (i : Î¹), s âŠ† U i
(uniformity Î±).has_basis (Î» (s : set (Î± Ã— Î±)), s âˆˆ uniformity Î± âˆ§ symmetric_rel s) id
is_least (f '' t) (f a)
strict_convex ğ•œ (x +áµ¥ s)
P f
has_dist.dist a b * has_dist.dist c d + has_dist.dist b c * has_dist.dist d a = has_dist.dist a c * has_dist.dist b d
r < â†‘b ^ x â†” int.log b r < x
polish_space.is_clopenable s
â‡‘((basis.mk hli hsp).coord i) (v j) = ite (j = i) 1 0
p â‰¤ 2 * n
(2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = f w
measure_theory.ae_strongly_measurable' mâ‚‚ f Î¼
is_connected (â‹ƒ (n : Î²) (H : n âˆˆ t), s n)
A.det = A 0 0 * A 1 1 - A 0 1 * A 1 0
ae_measurable f Î¼
f' = fâ‚'
add_monoid.is_torsion M
p a
group.is_nilpotent G
finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i * g i)
is_submonoid (f '' s)
finite_dimensional.finrank K (V â†’â‚—[K] W) = finite_dimensional.finrank K V * finite_dimensional.finrank K W
group.is_nilpotent G
euclidean_geometry.cospherical {p}
(generalized_continued_fraction.of v).terminates â†” âˆƒ (q : â„š), v = â†‘q
â‡‘e x = x â†’ â‡‘e y = y â†’ â‡‘e (midpoint â„ x y) = midpoint â„ x y
is_cyclotomic_extension S A â†¥(algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1})
is_smul_regular M a
(âˆƒ (iâ‚ iâ‚‚ iâ‚ƒ jâ‚‚ jâ‚ƒ : fin 3), iâ‚ â‰  iâ‚‚ âˆ§ iâ‚ â‰  iâ‚ƒ âˆ§ iâ‚‚ â‰  iâ‚ƒ âˆ§ (âˆ€ (i : fin 3), i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ) âˆ§ p iâ‚ = t.orthocenter âˆ§ jâ‚‚ â‰  jâ‚ƒ âˆ§ t.points jâ‚‚ = p iâ‚‚ âˆ§ t.points jâ‚ƒ = p iâ‚ƒ) âˆ¨ set.range p = set.range t.points
complete_lattice.is_compact_element (submodule.span R S)
n â‰  0 â†’ â‡‘f n = n.factorization.prod (Î» (p k : â„•), â‡‘f (p ^ k))
(uniformity Î±).has_basis p (Î» (x : Î²), {p : Î± Ã— Î± | has_dist.dist p.fst p.snd â‰¤ f x})
s.nonempty â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), âˆ€ (x : Î±), x âˆˆ s â†’ Â¬r x a)
orthonormal â„ â‡‘(e.adjust_to_orientation x)
(Î» (x : Î±), c) =O[l] f' â†” âˆƒ (b : â„), 0 < b âˆ§ âˆ€á¶  (x : Î±) in l, b â‰¤ âˆ¥f' xâˆ¥
add_order_of (n â€¢ x) = add_order_of x / (add_order_of x).gcd n
Î¼ = Î½
is_open_map f
ideal.comap (algebra_map R S) P = p
â‡‘(k.lift _) (â‡‘(f.lift _) z) = z
(finset.filter (Î» (J : box_integral.box Î¹), x âˆˆ â‡‘box_integral.box.Icc J) Ï€.boxes).card â‰¤ 2 ^ fintype.card Î¹
continuous_at f x
âˆ€á¶  (r : â„) in nhds_within 0 (set.Ioi 0), (s âˆ© ({x} + r â€¢ t)).nonempty
function.injective (quotient.lift f _)
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
f.range < âŠ¤
cauchy_seq s â†” âˆƒ (b : Î² â†’ ennreal), (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ has_edist.edist (s n) (s m) â‰¤ b N) âˆ§ filter.tendsto b filter.at_top (nhds 0)
filter.tendsto (Î» (x : Î²), (f x, f x)) l (uniformity Î±)
(set.univ.pi t).finite
â‡‘(con.ker f) x y â†” â‡‘f x = â‡‘f y
Jâ‚ â‰¤ Jâ‚‚
subsingleton (module â„š E)
x = â‡‘(hb.rotation Î¸) x â†” x = 0 âˆ¨ Î¸ = 0
Î¼.inner_regular is_compact is_closed
is_connected s â†” âˆ€ (U : finset (set Î±)), (âˆ€ (u v : set Î±), u âˆˆ U â†’ v âˆˆ U â†’ (s âˆ© (u âˆ© v)).nonempty â†’ u = v) â†’ (âˆ€ (u : set Î±), u âˆˆ U â†’ is_open u) â†’ s âŠ† â‹ƒâ‚€â†‘U â†’ (âˆƒ (u : set Î±) (H : u âˆˆ U), s âŠ† u)
t.sum (Î» (c : Î¹), f c) âˆˆ K
gram_schmidt ğ•œ f n = f n - (finset.Iio n).sum (Î» (i : Î¹), â†‘(â‡‘(orthogonal_projection (submodule.span ğ•œ {gram_schmidt ğ•œ f i})) (f n)))
category_theory.limits.image.pre_comp f (g â‰« h) â‰« category_theory.limits.image.pre_comp g h = category_theory.limits.image.eq_to_hom _ â‰« category_theory.limits.image.pre_comp (f â‰« g) h
(list.nat.antidiagonal n).nodup
continuous_on p.sum (emetric.ball 0 p.radius)
category_theory.limits.limit F = finset.univ.inf F.obj
âˆ¥f - gâˆ¥ = (âˆ«â» (x : Î±), â†‘âˆ¥â‡‘f x - â‡‘g xâˆ¥â‚Š âˆ‚Î¼).to_real
âˆ¥a ^ nâˆ¥â‚Š â‰¤ âˆ¥aâˆ¥â‚Š ^ n
f = g
0 â‰¤ polynomial.eval x (polynomial.cyclotomic n R)
(l.prod)â»Â¹ = (list.map has_inv.inv l.reverse).prod
J = âŠ¤
category_theory.presheaf.is_sheaf (category_theory.pretopology.to_grothendieck C K) P â†” âˆ€ â¦ƒX : Câ¦„ (R : category_theory.presieve X), R âˆˆ â‡‘K X â†’ nonempty (category_theory.limits.is_limit (P.map_cone (category_theory.sieve.generate R).arrows.cocone.op))
âˆ« (x : fin (n + 1) â†’ â„) in â‡‘box_integral.box.Icc I, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
|â†‘g 1 0| â‰¤ 1
â‡‘(direct_sum.to_module R Î¹ N Ï†) (â‡‘(direct_sum.lof R Î¹ M i) x) = â‡‘(Ï† i) x
I â€¢ N' â‰¤ N
f x = 0
(â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x
continuous â‡‘f
(âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated s (t i)) â†’ is_metric_separated s (â‹ƒ (i : Î¹) (H : i âˆˆ I), t i)
metric.cthickening Î´â‚ E âŠ† metric.thickening Î´â‚‚ E
continuous f
âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K' âˆ§ K' âŠ† U
x âˆˆ roots_of_unity n â„‚ â†” âˆƒ (i : â„•) (H : i < â†‘n), complex.exp (2 * â†‘real.pi * complex.I * (â†‘i / â†‘n)) = â†‘x
collinear k (set.range p) â†” Â¬affine_independent k p
continuous_on f s
cont_mdiff_within_at I I'' n (g âˆ˜ f) (s âˆ© f â»Â¹' t) x
continuous_within_at f (set.Ici a) a
(Î± â‰« Î²).c.app U = Î².c.app U â‰« Î±.c.app (opposite.op ((topological_space.opens.map Î².base).obj (opposite.unop U)))
k â‰¤ n â†’ (n - k).factorial * n.desc_factorial k = n.factorial
cardinal.mk â†¥(set.Ioo a b) = cardinal.continuum
continuous_at (Î» (x : Î± Ã— Î²), f x.fst) (x, y)
(has_Inf.Inf m).restrict t = has_Inf.Inf ((Î» (Î¼ : measure_theory.measure Î±), Î¼.restrict t) '' m)
iterated_deriv_within (n + 1) f s x = deriv_within (iterated_deriv_within n f s) s x
orthonormal ğ•œ â‡‘(direct_sum.is_internal.subordinate_orthonormal_basis hn hV)
tendsto_locally_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n y) (Î» (y : E), f (x + y)) filter.at_top (emetric.ball 0 r)
continuous (Î» (p : Î± Ã— topological_space.closeds Î±), emetric.inf_edist p.fst â†‘(p.snd))
â‡‘(direct_sum.mk M s) (c â€¢ x) = c â€¢ â‡‘(direct_sum.mk M s) x
has_edist.edist (f n) a â‰¤ C * r ^ n / (1 - r)
collinear k {pâ‚, pâ‚‚}
âˆ….shadow = âˆ…
âˆƒ (I : lie_ideal R â†¥K), â†‘I = lie_subalgebra.of_le hâ‚
is_smul_regular M s
âˆ¥(finset.range n).sum (Î» (x : â„•), f x) - aâˆ¥ â‰¤ C * r ^ n / (1 - r)
AddMon.filtered_colimits.colimit_add_aux F x y = AddMon.filtered_colimits.colimit_add_aux F x' y
0 < L.length
is_GÎ´ (s âˆª t)
s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = s.sum (Î» (i : Î¹), f i * g i) â†” antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
first_order.language.Structure.cg L (first_order.language.direct_limit G f)
o.oangle 0 x = 0
n.totient = n / n.factors.to_finset.prod (Î» (p : â„•), p) * n.factors.to_finset.prod (Î» (p : â„•), p - 1)
o.oangle x (r â€¢ x) = 0
category_theory.is_coreflexive_pair g f
is_integral R x
finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” antivary f (g âˆ˜ â‡‘Ïƒ)
category_theory.limits.has_limits_of_size C
Â¬summable (Î» (n : â„•), 1 / â†‘n)
â‡‘Ï s â‰¤ â†‘t * â‡‘(Î¼.with_density (v.lim_ratio_meas hÏ)) s
category_theory.epi f
Ï† = Ïˆ
submodule.map â†‘f s.topological_closure â‰¤ (submodule.map â†‘f s).topological_closure
convex ğ•œ s â†” âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ s + b â€¢ s âŠ† s
âˆ« (x : G), f x âˆ‚Î¼ = 0
f.srange = âŠ¤
isometry (sigma.mk i)
real.cosh x = (real.exp x + real.exp (-x)) / 2
measure_theory.ae_strongly_measurable f (Î¼.restrict s)
a â‰¤ -b â†’ b â‰¤ -a
b = a âˆ¨ a < b
â†‘(nat.fib n) = (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
measure_theory.strongly_measurable (Î» (y : Î²), âˆ« (x : Î±), f x y âˆ‚Î¼)
n âˆˆ S
0 â‰¤ â‡‘f x
filter.tendsto f (nhds_within x A) (nhds (extend_from A f x))
finite_dimensional.finrank R M = fintype.card (module.free.choose_basis_index R M)
â‡‘(first_order.language.substructure.closure L) s â‰¤ â‡‘(first_order.language.substructure.closure L) t
-a â‰¤ -b â†’ b â‰¤ a
p = minpoly A x
(list.drop k (matrix.pivot.list_transvec_col M)).prod.mul M (sum.inr ()) i = M (sum.inr ()) i
(measure_theory.measure.map â‡‘(quotient_add_group.mk' Î“) (Î¼.restrict ğ“•)).is_add_left_invariant
cont_diff_on ğ•œ âŠ¤ fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ âŠ¤ (deriv fâ‚‚) sâ‚‚
(s.erase a).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
x âˆˆ group.conjugates_of_set s â†’ c * x * câ»Â¹ âˆˆ group.conjugates_of_set s
a â‰¤ b * c â†’ bâ»Â¹ * a â‰¤ c
-a = a â†” a = 0
C x
P M
ite P f g a = ite P (f a) (g a)
is_integral R (â‡‘(â‡‘(B.basis.repr) (x ^ n)) i)
â‡‘f (Î» (i : Î¹), c i â€¢ m i) = finset.univ.prod (Î» (i : Î¹), c i) â€¢ â‡‘f m
filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I (box_integral.prepartition.single I J hJ)) (nhds (box_integral.integral J l f vol))
char.quadratic_char F (a ^ 2) = 1
nhds_within x s = has_pure.pure x
a - b < a - c â†” c < b
â‡‘(is_fraction_ring.lift hg) (â‡‘(algebra_map A K) x) = â‡‘g x
o.oangle x y + o.oangle y x = 0
sâ‚ = sâ‚‚
s = t
o = p
vector.scanl f b vector.nil = b::áµ¥vector.nil
(finset.image f A).to_colex â‰¤ (finset.image f B).to_colex â†” A.to_colex â‰¤ B.to_colex
continuous (Î» (x : Î±), emetric.inf_edist x s)
(a * d - b * c) / (c * d) â‰¤ 0 â†’ a / c â‰¤ b / d
â†‘âŸ¨U, hUâŸ© = U
finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) < finset.univ.sum (Î» (i : Î¹), f i * g i) â†” Â¬monovary f (g âˆ˜ â‡‘Ïƒ)
continuous_at f x
Â¬continuous â‡‘(cofinite_topology.of.symm)
has_strict_deriv_at f (f' x) x
â†‘(a.val) = a
is_conj (equiv.swap 0 4 * equiv.swap 1 3) g
is_open_map Z.proj
lipschitz_on_with K f s â†’ âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ has_dist.dist (f x) (f y) â‰¤ â†‘K * has_dist.dist x y
con.lift_on â†‘x f h = f x
âˆ€áµ (Ï‰ : Î©), (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), probability_theory.truncation (X i) â†‘i Ï‰) - (finset.range n).sum (Î» (i : â„•), X i Ï‰)) =o[filter.at_top] Î» (n : â„•), â†‘n
â‡‘clifford_algebra_quaternion.of_quaternion (â‡‘quaternion_algebra.conj q) = â‡‘clifford_algebra.involute (â‡‘clifford_algebra.reverse (â‡‘clifford_algebra_quaternion.of_quaternion q))
âˆƒ (K : set Î±) (H : K âŠ† A), is_closed K âˆ§ r < â‡‘Î¼ K
strict_concave_on ğ•œ s f
t âˆˆ l â†” âˆƒ (i : Î¹) (hi : p i), s i âŠ† t
s.sum (Î» (c : Î³), g c) = Î» (a : Î±), s.sum (Î» (c : Î³), g c a)
(Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
measure_theory.tendsto_in_measure Î¼ f filter.at_top g âˆ§ measure_theory.unif_integrable f p Î¼ â†” filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
finset.imageâ‚‚ f (finset.imageâ‚‚ g s t) u âŠ† finset.imageâ‚‚ g' (finset.imageâ‚‚ fâ‚ s u) (finset.imageâ‚‚ fâ‚‚ t u)
dual_pair.lc e (h.coeffs m) = m
fin.snoc (function.update p i y) x = function.update (fin.snoc p x) (â‡‘fin.cast_succ i) y
category_theory.comm_sq (F.map f) (F.map g) (F.map h) (F.map i)
metric.Hausdorff_dist (set.range (Gromov_Hausdorff.optimal_GH_injl X Y)) (set.range (Gromov_Hausdorff.optimal_GH_injr X Y)) = Gromov_Hausdorff.GH_dist X Y
a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d
o.oangle x 0 = 0
metric.thickening Î´ E = (Î» (x : Î±), emetric.inf_edist x E) â»Â¹' set.Iio (ennreal.of_real Î´)
x / y âˆˆ H
p i âˆ‰ affine_span k (p '' (s  {i}))
(f y - f x) / (y - x) < (f z - f y) / (z - y)
âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (z : Î² Ã— Î±), f z.snd z.fst âˆ‚Î½.prod Î¼
affine_independent k (Î» (p : â†¥s), â†‘p) â†” linear_independent k (Î» (v : â†¥((Î» (p : P), p -áµ¥ pâ‚) '' (s  {pâ‚}))), â†‘v)
is_algebraic R (â‡‘(algebra_map R A) x)
is_of_fin_order xâ»Â¹
x < y âˆ¨ y < x â†” x â‰  y
âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n
reflection K * reflection K = 1
â‡‘(algebra_map K E) (algebra.discr K â‡‘(pb.basis)) = finset.univ.prod (Î» (i : fin pb.dim), (finset.filter (Î» (j : fin pb.dim), i < j) finset.univ).prod (Î» (j : fin pb.dim), (â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) ^ 2))
a + b = linear_order.max a b
is_integral R (â‡‘(â‡‘(B.basis.repr) (x * y)) i)
g.comp_linear_map (Î» (i : Î¹), linear_map.id) = g
add_le_cancellable a
measure_theory.ae_strongly_measurable (Î» (x : Î±), g (f x)) Î¼
uniform_continuous f
nonempty (Î± â†ªo Î²)
Js â‰¤ J
a âˆ£ b + c â†” a âˆ£ b
category_theory.presieve.family_of_elements.restrict _ xâ‚ = category_theory.presieve.family_of_elements.restrict _ xâ‚‚ â†’ xâ‚ = xâ‚‚
cont_diff_on ğ•œ n (Î» (x : E), -f x) s
measure_theory.integrable (F' xâ‚€) Î¼ âˆ§ has_deriv_at (Î» (n : ğ•œ), âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€
[s âˆˆ nhds_within b (set.Iio b), s âˆˆ nhds_within b (set.Ico a b), s âˆˆ nhds_within b (set.Ioo a b), âˆƒ (l : Î±) (H : l âˆˆ set.Ico a b), set.Ioo l b âŠ† s, âˆƒ (l : Î±) (H : l âˆˆ set.Iio b), set.Ioo l b âŠ† s].tfae
filter.tendsto f filter.cofinite filter.cofinite
continuous (Î» (f : bounded_continuous_function Î± Î²), â‡‘f x)
has_nndist.nndist x y = 0 â†’ x = y
add_monoid.fg M
interior {x} = âˆ…
(matrix.mv_polynomial_X m n R).map (mv_polynomial.evalâ‚‚ f (Î» (p : m Ã— n), A p.fst p.snd)) = A
â‡‘(f.lift hg) (f.mk' x y) = â‡‘g x * â†‘(â‡‘(is_unit.lift_right (g.restrict S) hg) y)â»Â¹
add_submonoid.closure s â‰¤ add_submonoid.closure t
lâ‚ ++ lâ‚‚.diff lâ‚ ~ lâ‚‚
set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
euclidean_geometry.angle p1 p2 p2 = real.pi / 2
2 â€¢ hb.oangle x (-y) = 2 â€¢ hb.oangle x y
âˆ€á¶  (y : Î±) in l, f y â‰  x
set.Iio a âŠ† set.Iic b
is_regular (a ^ n)
is_domain Î²
f (â¨… (i : Î³), g i) = â¨… (i : Î³), f (g i)
âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y
nontrivial V
deriv (Î» (u : â„), âˆ« (x : â„) in a..u, f x) b = f b
(p * q).coeff n = (finset.nat.antidiagonal n).sum (Î» (x : â„• Ã— â„•), p.coeff x.fst * q.coeff x.snd)
is_compact A
j = k
(f _* F).is_sheaf
filter.tendsto (Î» (x : â„), x ^ n * real.exp (-x)) filter.at_top (nhds 0)
â‡‘(s.affine_combination (Î» (_x : Î¹), p)) w = p
bdd_below s
Î¼.is_open_pos_measure
continuous proj
has_continuous_neg Î±
E âŠ† metric.cthickening Î´ E
p âˆˆ affine_span k s
S.is_algebraic â†” algebra.is_algebraic R â†¥S
bdd_above t â†’ bdd_above s
category_theory.limits.has_binary_coproducts C
convolution f g (continuous_linear_map.lsmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f t â€¢ g (x - t) âˆ‚Î¼
C a
aâ‚ â‰¤ aâ‚‚
p s
is_coprime (â†‘g 1 0) (â†‘g 1 1)
âˆƒ (f : â„¤ â†’ Î±), strict_anti f
tendsto_uniformly f (f x) (nhds x)
(Î» (p : Î± Ã— Î±), (sum.inl p.fst, sum.inl p.snd)) '' a âˆª (Î» (p : Î² Ã— Î²), (sum.inr p.fst, sum.inr p.snd)) '' b âˆˆ uniform_space.core.sum.uniformity
number_field.class_number K = 1 â†” is_principal_ideal_ring â†¥(number_field.ring_of_integers K)
âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi
continuous â‡‘(Î¾.equiv_fun)
filter.tendsto f filter.at_top (nhds g)
has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) s a
â‡‘(o.rotation Î¸) x = x â†” x = 0 âˆ¨ Î¸ = 0
â†‘(subsemiring.closure s) = â†‘(add_submonoid.closure â†‘(submonoid.closure s))
s.sum (Î» (i : Î¹), s.sum (Î» (j : Î¹), a i j â€¢ has_inner.inner (v j) (v i))) = s.sum (Î» (k : Î¹), a k k)
f '' monoid.closure s = monoid.closure (f '' s)
nonempty (V â‰ƒâ‚—[K] Vâ‚) â†” module.rank K V = module.rank K Vâ‚
is_closed (coe_fn '' s)
set.eq_on â‡‘e â‡‘e' e.to_local_equiv.source
âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n
K â‰ƒ+* L
discrete_topology Î±
d < b
âˆƒ (f : cont_mdiff_map I (model_with_corners_self â„ â„) M â„ âŠ¤), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : M), â‡‘f x âˆˆ set.Icc 0 1
o.oangle x (â‡‘(o.rotation Î¸) y) = o.oangle x y + Î¸
f =O[nhds b] g â†” (f âˆ˜ â‡‘e) =O[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
dense â†‘G âˆ¨ âˆƒ (a : â„), G = add_subgroup.closure {a}
strict_mono f â†” âˆ€ (i : fin n), f (â‡‘fin.cast_succ i) < f i.succ
(is_localization.map Sâ‚˜ (algebra_map R S) _).is_integral
category_theory.limits.has_initial C
x.lf y â†” (âˆƒ (i : y.left_moves), x â‰¤ y.move_left i) âˆ¨ âˆƒ (j : x.right_moves), x.move_right j â‰¤ y
o.oangle x (â‡‘(o.rotation Î¸) x) = Î¸
monoid.is_torsion G
e.symm.trans e â‰ˆ local_equiv.of_set e.target
P Î±
function.semiconj g' â‡‘fb â‡‘fa
_.to_graph = G
set.eq_on â‡‘(e.symm) â‡‘(e'.symm) e.target
P f
category_theory.limits.has_equalizers C
module.is_torsion' M S â†” submodule.torsion' R M S = âŠ¤
(double_quot.quot_left_to_quot_sup I J).ker = ideal.map (ideal.quotient.mk I) J
is_closed (std_simplex â„ Î¹)
a < b â†’ order.succ a < order.succ b
inner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi
continuous (tangent_map I I' f)
o.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
(has_insert.insert a s).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
(â¨… (i : {i // f i â‰  âŠ¤}), f â†‘i) = â¨… (i : Î¹), f i
âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ g '' s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ s), f (g j)))
metric.Hausdorff_dist s (closure s) = 0
âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
r x y â†’ x = y
category_theory.limits.biprod.map f g â‰« (category_theory.limits.biprod.braiding Y W).hom = (category_theory.limits.biprod.braiding X Z).hom â‰« category_theory.limits.biprod.map g f
âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) < b
f â‰¤ nhds a â†’ f.Limsup = a
a * x = y * a
âˆƒ (V : set (Î² Ã— Î²)) (H : V âˆˆ uniformity Î²), is_open V âˆ§ continuous_map.compact_conv_nhd K V f âŠ† continuous_map.compact_open.gen K U
X.Ïƒ i â‰« X.Î´ (â‡‘fin.cast_succ i) = ğŸ™ (X.obj (opposite.op (simplex_category.mk n)))
fin.cons (q 0) (fin.tail q) = q
module.rank K â†¥s â‰¤ 1 â†” âˆƒ (vâ‚€ : V) (H : vâ‚€ âˆˆ s), s â‰¤ submodule.span K {vâ‚€}
has_inner.inner (v - orthogonal_projection_fn K v) w = 0
[s âˆˆ nhds_within a (set.Ici a), s âˆˆ nhds_within a (set.Icc a b), s âˆˆ nhds_within a (set.Ico a b), âˆƒ (u : Î±) (H : u âˆˆ set.Ioc a b), set.Ico a u âŠ† s, âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ico a u âŠ† s].tfae
category_theory.strong_epi (f â‰« g)
(f.comp_linear_map gâ‚).comp_linear_map gâ‚‚ = f.comp_linear_map (gâ‚.comp gâ‚‚)
1 < a * b
(âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
â‡‘(f i i h) x = x
has_dist.dist (convolution f g L Î¼ xâ‚€) (âˆ« (t : G), â‡‘(â‡‘L (f t)) (g xâ‚€) âˆ‚Î¼) â‰¤ âˆ¥Lâˆ¥ * âˆ« (x : G), âˆ¥f xâˆ¥ âˆ‚Î¼ * Îµ
â‡‘(fin.cast_add m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.cast_add m) i)
g.nat_degree = g'.nat_degree
(matrix.circulant v).mul (matrix.circulant w) = (matrix.circulant w).mul (matrix.circulant v)
âˆ«â» (a : Î±), f a + g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼
has_nndist.nndist x y = (has_dist.dist x y).to_nnreal
well_founded gt â†” âˆ€ (a : â„• â†’o Î±), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘a n = â‡‘a m
âˆƒ (U : set Î±) (H : U âŠ‡ s), is_open U âˆ§ â‡‘Î¼ U < âŠ¤
has_inner.inner (x + y) (x + y) = has_inner.inner x x + 2 * has_inner.inner x y + has_inner.inner y y
finite_dimensional.finrank ğ•œ â†¥(submodule.span ğ•œ {v})á—® = n
has_inner.inner (â‡‘T y) x = (has_inner.inner (â‡‘T (x + y)) (x + y) - has_inner.inner (â‡‘T (x - y)) (x - y) + complex.I * has_inner.inner (â‡‘T (x + complex.I â€¢ y)) (x + complex.I â€¢ y) - complex.I * has_inner.inner (â‡‘T (x - complex.I â€¢ y)) (x - complex.I â€¢ y)) / 4
B = B'
summable (Î» (n : â„•), (â†‘n ^ p)â»Â¹) â†” 1 < p
f.liminf (Î» (x : Î²), âŠ¤) = âŠ¤
has_dist.dist (Kuratowski_embedding.embedding_of_subset x a) (Kuratowski_embedding.embedding_of_subset x b) â‰¤ has_dist.dist a b
finset.univ.sup f = supr f
(uv.compression u v s).card = s.card
(s.prod (Î» (i : Î¹), f i)).degree = s.sum (Î» (i : Î¹), (f i).degree)
cauchy (filter.map (box_integral.integral_sum f vol) (l.to_filter_Union I Ï€â‚€))
â‡‘linear_map.det complex.conj_ae.to_linear_map = -1
âˆƒ (a b : R), 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ vâ‚ = a â€¢ (vâ‚ + vâ‚‚) âˆ§ vâ‚‚ = b â€¢ (vâ‚ + vâ‚‚)
âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ s âŠ† closure t
mv_polynomial.evalâ‚‚ c (â‡‘f âˆ˜ mv_polynomial.X) x = â‡‘f x
measure_theory.ae_strongly_measurable g Î½
has_add.add x âˆ˜ has_add.add y = has_add.add (x + y)
algebra.discr A (matrix.vec_mul b (P.map â‡‘(algebra_map A B))) = P.det ^ 2 * algebra.discr A b
n âˆˆ S
H = âŠ¤
â‡‘f = â‡‘g â†” f = g
measure_theory.submartingale f ğ’¢ Î¼
category_theory.limits.has_cokernels (Module R)
list.map f (list.permutations_aux2 t ts list.nil ys id).snd = (list.permutations_aux2 t ts list.nil ys f).snd
strict_concave_on â„ set.univ f
metric.diam {x} = 0
0 < n â†’ 0 < szemeredi_regularity.step_bound n
convex ğ•œ ((Î» (x : E), z + x) â»Â¹' s)
e.is_image s t â†’ e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s = e.to_local_equiv.target âˆ© t
âˆƒ (g : â„• â†ªo â„•), (âˆ€ (m n : â„•), m < n â†’ r (f (â‡‘g m)) (f (â‡‘g n))) âˆ¨ âˆ€ (m n : â„•), m < n â†’ Â¬r (f (â‡‘g m)) (f (â‡‘g n))
x âˆˆ multiples x
filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)
function.injective coe_fn
âˆƒ (t : â†¥M), t â€¢ x âˆˆ algebra.adjoin R s
category_theory.limits.has_finite_colimits C
p x
pairwise (disjoint on Î» (n : Î±), set.Ioc (f (order.succ n)) (f n))
0 < add_order_of x â†” is_of_fin_add_order x
1 â‰¤ bernstein_approximation.Î´ f Îµ h ^ -2 * (â†‘x - â†‘(bernstein.z k)) ^ 2
â‡‘(star_ring_end R) x = has_star.star x
finite_dimensional.finrank K V = 1 â†” âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w
continuous (Î» (g : G Ã— G), g.fst * g.snd * (g.fst)â»Â¹)
âˆ¥vâˆ¥â‚Š â‰¤ âˆ¥uâˆ¥â‚Š + âˆ¥u - vâˆ¥â‚Š
has_sum (Î» (b : Î²), 0) 0
â‡‘g (finprod (Î» (j : Î±), finprod (Î» (H : j âˆˆ s), f j))) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), â‡‘g (f i)))
is_integral A x
measure_theory.measurably_separable (set.range f) (set.range g)
â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta n K L - 1) = â†‘(â†‘n.min_fac)
is_group_hom (Î» (a : Î±), f a * g a)
â‡‘f (fin.cons (c â€¢ x) m) = c â€¢ â‡‘f (fin.cons x m)
order_of (x ^ n) = order_of x / (order_of x).gcd n
polish_space Î±
âˆƒ (a : Î“) (l' : turing.list_blank Î“), l = turing.list_blank.cons a l'
âˆƒ (f : E â†’L[â„] â„), â‡‘f xâ‚€ = 1 âˆ§ âˆ€ (x : E), x âˆˆ s â†’ â‡‘f x < 1
d âˆˆ (b + 2).digits m â†’ d < b + 2
p P.some
emetric.inf_edist x s â‰¤ emetric.inf_edist x (metric.cthickening Î´ s) + ennreal.of_real Î´
convolution f g (continuous_linear_map.lsmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f (x - t) â€¢ g t âˆ‚Î¼
s.sum (Î» (i : Î¹), f i * g i) < s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) â†” Â¬antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
(matrix.from_blocks A 0 C D).det = A.det * D.det
a < b - c â†” a + c < b
2 * a * b â‰¤ a ^ 2 + b ^ 2
is_dedekind_domain A â†” is_noetherian_ring A âˆ§ ring.dimension_le_one A âˆ§ âˆ€ {x : K}, is_integral A x â†’ (âˆƒ (y : A), â‡‘(algebra_map A K) y = x)
a â‰¡ b [MOD m]
â†‘(â‡‘(category_theory.limits.cofork.is_colimit.hom_iso ht Z') (k â‰« q)) = â†‘(â‡‘(category_theory.limits.cofork.is_colimit.hom_iso ht Z) k) â‰« q
s âˆˆ nhds_within a (set.Iio a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Ico l a âŠ† s
module.End.eigenspace (T.restrict _) Î¼ = âŠ¥
(nhds a).has_basis (Î» (Îµ : Î±), 0 < Îµ âˆ§ Îµ â‰¤ a) (Î» (Îµ : Î±), set.Ioo (a - Îµ) (a + Îµ))
â¨ (x : Î±) in t, f x âˆ‚Î¼ âˆˆ closure s
isometry (metric.to_inductive_limit I n)
direct_sum.is_internal (Î» (i : â†¥S), submodule.torsion_by R M (q â†‘i))
vector_span k s = submodule.span k (s -áµ¥ s)
(module.rank F K).lift * (module.rank K A).lift = (module.rank F A).lift
âˆƒ (b : S) (H : b âˆˆ â†‘I), b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â‡‘abv (â‡‘(algebra.norm R) c) < â‡‘abv (â‡‘(algebra.norm R) b) â†’ c = 0
uv.compress u v (uv.compress u v a) = uv.compress u v a
||a|| = |a|
x â‰  y â†’ r x y â†” r x y
lipschitz_on_with K f s
â†‘(â‡‘(orthogonal_projection (submodule.map â†‘(f.to_linear_equiv) p)) x) = â‡‘f â†‘(â‡‘(orthogonal_projection p) (â‡‘(f.symm) x))
filter.tendsto f lâ‚ lâ‚‚ â†” âˆ€ (g : ultrafilter Î±), â†‘g â‰¤ lâ‚ â†’ filter.tendsto f â†‘g lâ‚‚
âˆ® (z : â„‚) in C(c, R), f z = âˆ® (z : â„‚) in C(c, r), f z
â‡‘(is_fraction_ring.lift hg) (is_localization.mk' K x y) = â‡‘g x / â‡‘g â†‘y
filter.tendsto v filter.at_top filter.at_top
â‡‘(algebra.norm K) (Î¶ ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
p1 -áµ¥ p2 âˆˆ vector_span k s
is_ascending_central_series (upper_central_series G)
group.nilpotency_class G = group.nilpotency_class (G â§¸ subgroup.center G) + 1
a * b â‰¤ a ^ p / p.to_nnreal + b ^ q / q.to_nnreal
â‡‘s (u  v) = 0 âˆ§ â‡‘s (v  u) = 0
p % 2 = 1 â†” p â‰  2
âˆƒ (iâ‚€ iâ‚ : fin (h.card Îµ ^ n).succ), iâ‚€ â‰  iâ‚ âˆ§ âˆ€ (k : fin n), â†‘(â‡‘abv (A iâ‚ k % b - A iâ‚€ k % b)) < â‡‘abv b â€¢ Îµ
â‡‘fourier_series = fourier_Lp 2
list.map g âˆ˜ list.map f = list.map (g âˆ˜ f)
â‡‘abv (â‡‘(algebra.norm R) a) â‰¤ class_group.norm_bound abv bS * y ^ fintype.card Î¹
Â¬is_right_regular 0 â†” nontrivial R
â†‘(x.gcd y) = x * x.gcd_a y + y * x.gcd_b y
has_strict_fderiv_at (exp ğ•‚) (exp ğ•‚ x â€¢ 1) x
matrix.vec_mul (â‡‘(bâ‚‚.coords) x) (b.to_matrix bâ‚‚.points) = â‡‘(b.coords) x
â‡‘is_R_or_C.re is_R_or_C.I = 0
s1 = s2 â†” âˆ€ (i : fin (n + 1)), s1.points i = s2.points i
f + g = category_theory.limits.biprod.lift f g â‰« category_theory.limits.biprod.desc (ğŸ™ Y) (ğŸ™ Y)
filter.tendsto f (nhds_within x (set.Ioi x)) (nhds (has_Inf.Inf (f '' set.Ioi x)))
âˆ¥deriv f câˆ¥ â‰¤ Râ‚‚ / Râ‚
metric.inf_dist x s â‰¤ has_dist.dist x y
measure_theory.analytic_set (f '' s)
add_con_gen â‡‘c = c
star_convex ğ•œ x ((Î» (x : E), z + x) â»Â¹' s)
s = âˆ…
filter.tendsto Î¼s F (nhds Î¼) â†” âˆ€ (f : bounded_continuous_function Î± nnreal), filter.tendsto (Î» (i : Î³), âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚â†‘(Î¼s i)) F (nhds (âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚â†‘Î¼))
â‡‘(reflection (submodule.span ğ•œ {v})á—®) v = -v
has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s c) f = has_inner.inner c (âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼)
finset.imageâ‚‚ f s (finset.image g t) = finset.image g' (finset.imageâ‚‚ f' t s)
s.prod (Î» (i : Î¹), f i) â‰¤ s.prod (Î» (i : Î¹), g i)
measure_theory.measure.map (Î» (z : G Ã— G), (z.fst, z.fst + z.snd)) (Î¼.prod Î½) = Î¼.prod Î½
0 â€¢ s = 0
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€ (s : set Î±), s âˆˆ nhds x â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
âˆƒ (V : open_add_subgroup R), â†‘V * â†‘V âŠ† â†‘U
filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_bot
is_bot a â†’ is_top (â‡‘order_dual.to_dual a)
embedding (Î» (x : weak_bilin B) (y : F), â‡‘(â‡‘B x) y)
{p : â„• | nat.prime p}.infinite
measure_theory.L1.simple_func.set_to_L1s T f = measure_theory.L1.simple_func.set_to_L1s T f'
nonempty (Î± â†ª Î²) âˆ¨ nonempty (Î² â†ª Î±)
simplex_category.Î´ i â‰« simplex_category.Î´ j.succ = simplex_category.Î´ j â‰« simplex_category.Î´ (â‡‘fin.cast_succ i)
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), witt_vector.frobenius_fun)
â‡‘f (x + y) = â‡‘f x + â‡‘f y
âˆƒ (v : Î¹ â†’ set X), (âˆ€ (i : Î¹), is_open (v i)) âˆ§ (s âŠ† â‹ƒ (i : Î¹), v i) âˆ§ locally_finite v âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
C.d i j' â‰« category_theory.eq_to_hom _ = C.d i j
â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼ / Îµ
bdd_above s
function.injective f
âˆƒ (d : â„•) (k : fin d â†’ â„•), nonempty (N â‰ƒâ‚—[R] direct_sum (fin d) (Î» (i : fin d), R â§¸ submodule.span R {p ^ k i}))
box_integral.has_integral I âŠ¥ (Î» (x : fin (n + 1) â†’ â„), â‡‘(f' x) (pi.single i 1)) box_integral.box_additive_map.volume (box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.upper i) x)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.lower i) x)) box_integral.box_additive_map.volume)
(âˆ«â» (a : Î±), (f + g) a ^ p âˆ‚Î¼) ^ (1 / p) â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) + (âˆ«â» (a : Î±), g a ^ p âˆ‚Î¼) ^ (1 / p)
algebra.is_integral A B
solvable_by_rad.P Î³
turing.to_partrec.step_ret (k.then k') v = (turing.to_partrec.step_ret k v).then k'
is_compact (set.interval a b)
finset.univ.sum (Î» (i : Î¹), finset.centroid_weights_indicator k s i) = s.sum (Î» (i : Î¹), finset.centroid_weights k s i)
convolution f g (continuous_linear_map.lmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f t * g (x - t) âˆ‚Î¼
(a * b).factors ~ a.factors ++ b.factors
c â‰¤ d â†” âˆ€ {x y : M}, â‡‘c x y â†’ â‡‘d x y
s âˆˆ nhds_within a (set.Iio a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Ioo l a âŠ† s
cont_diff_within_at ğ•œ n (Î» (x : E), f x â€¢ g x) s x
Aâ‚€ * Bâ‚€ + Aâ‚€ * Bâ‚ + Aâ‚ * Bâ‚€ - Aâ‚ * Bâ‚ â‰¤ real.sqrt 2 ^ 3 â€¢ 1
f (dite P x y) = dite P (Î» (h : P), f (x h)) (Î» (h : Â¬P), f (y h))
filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
âˆƒ (s : fin N â†’ set Î²), (âˆ€ (i : fin N), (s i).pairwise_disjoint (Î» (j : Î²), metric.closed_ball (q.c j) (q.r j))) âˆ§ set.range q.c âŠ† â‹ƒ (i : fin N) (j : Î²) (H : j âˆˆ s i), metric.ball (q.c j) (q.r j)
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ {a}), f i)) = f a
s.prod (Î» (i : Î±), g i (f i)) = t.prod (Î» (i : Î±), g i (â†‘s.mul_indicator f i))
(polynomial.map (int.cast_ring_hom K) (minpoly â„¤ Î¼)).is_root (Î¼ ^ m)
k = l
âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
s.sum (Î» (i : Î¹), w i * z i) ^ p â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ p)
filter.tendsto (Î» (r : â„), â‡‘Î¼ (metric.cthickening r s)) (nhds 0) (nhds (â‡‘Î¼ s))
e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' (e.to_local_equiv.source âˆ© s) = e.to_local_equiv.target âˆ© t â†’ e.is_image s t
totally_bounded (f '' s)
ordinal.principal has_add.add o â†” o = 0 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ a
x â‰¤ u (l z)
function.injective â‡‘(is_primitive_root.aut_to_pow K hÎ¼)
subgroup.map f H.normalizer â‰¤ (subgroup.map f H).normalizer
aâ»Â¹ < b â†’ bâ»Â¹ < a
category_theory.limits.has_biproduct f
topological_space.is_topological_basis ((Î» (f : set (set Î±)), â‹‚â‚€ f) '' {f : set (set Î±) | f.finite âˆ§ f âŠ† s âˆ§ (â‹‚â‚€ f).nonempty})
cardinal.mk â†¥set.univ = cardinal.mk R ^ 4
â‡‘fin.cast_succ i < p âˆ¨ p < i.succ
has_dist.dist (f t) (g t) â‰¤ gronwall_bound Î´ â†‘K (Îµf + Îµg) (t - a)
âˆƒ (K : nnreal) (s : set E) (H : s âˆˆ nhds x), lipschitz_on_with K f s
prod.measurable_space = measurable_space.generate_from (set.image2 has_set_prod.prod C D)
uv.compression u v (uv.compression u v s) = uv.compression u v s
e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s = e.to_local_equiv.target âˆ© t â†’ e.is_image s t
a â‰¡ b [MOD n] â†” n âˆ£ b - a
ifp_n.fr < 1
â‡‘(polynomial.aeval y) (minpoly R x) = 0
C x
Ï† = Ïˆ
(ideal.map f I).fg
â‡‘(s.weighted_vsub p) w = â‡‘(s.weighted_vsub_of_point p b) w
K â‰¤ Ká—®á—®
mdifferentiable_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x â†’ differentiable_at ğ•œ f x
â†‘(N âŠ” H) = â†‘N + â†‘H
cont_diff_within_at ğ•œ n (Î» (x : E), f x * g x) s x
L.nth_le i hi = L'.nth_le i _
is_lower_set s â†’ is_upper_set (â‡‘order_dual.of_dual â»Â¹' s)
a ^ 2 = a * a
hb.oangle x (-y) = hb.oangle x y + â†‘real.pi
subsemigroup.closure â†‘S = S
f^[n] â‰¤ (g^[n])
A.det = finset.univ.sum (Î» (j : fin n.succ), (-1) ^ (â†‘i + â†‘j) * A i j * (A.minor â‡‘(i.succ_above) â‡‘(j.succ_above)).det)
â‡‘(k.to_map) (â‡‘g x) = â‡‘(k.to_map) (â‡‘g y)
âˆƒ (x : â„• â†’ set Î±), f.has_antitone_basis x
algebra.discr K â‡‘(pb.basis) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * â‡‘(algebra.norm K) (â‡‘(polynomial.aeval pb.gen) (â‡‘polynomial.derivative (minpoly K pb.gen)))
f = g
subsemiring.closure s â‰¤ subsemiring.closure t
s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
x âˆˆ set.Icc a b â†’ f x â‰¤ B x
s.sum (Î» (a : Î±), f a) < âŠ¤
â‡‘(hT.diagonalization) (â‡‘T v) Î¼ = â†‘Î¼ â€¢ â‡‘(hT.diagonalization) v Î¼
f '' s = g '' s
Â¬is_unit â†‘p
((Mâ»Â¹.mul N).mul M).det = N.det
upper_semicontinuous_within_at (Î» (z : Î±), f z + g z) s x
filter.tendsto (Î» (n : â„•), (â†‘n)â»Â¹ * (finset.range n).sum (Î» (i : â„•), u i)) filter.at_top (nhds l)
affine_independent k p â†” âˆ€ (s : finset Î¹) (w : Î¹ â†’ k), s.sum w = 0 â†’ s.sum (Î» (e : Î¹), w e â€¢ p e) = 0 â†’ âˆ€ (e : Î¹), e âˆˆ s â†’ w e = 0
fintype.card p.gal = finite_dimensional.finrank F p.splitting_field
is_cyclotomic_extension T â†¥(algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1}) B
-a â‰¤ 0 â†” 0 â‰¤ a
function.injective â‡‘((ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P).quotient_map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) ideal.le_comap_map)
lipschitz_on_with c (f - â‡‘f') s â†’ approximates_linear_on f f' s c
n = p ^ k
(finset.Ico 1 (p / 2).succ).sum (Î» (a : â„•), a * q / p) + (finset.Ico 1 (q / 2).succ).sum (Î» (a : â„•), a * p / q) = p / 2 * (q / 2)
is_add_monoid_hom f
âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ = 2 * â†‘real.pi * complex.I
(â¨† (o : option Î²), option.elim a f o) = a âŠ” â¨† (b : Î²), f b
emetric.inf_edist x t â‰¤ emetric.inf_edist x s
(âˆ€ (x y : Î±), has_dist.dist x y â‰¤ â†‘K * has_dist.dist (f x) (f y)) â†’ antilipschitz_with K f
module.projective R P
category_theory.well_powered C â†” category_theory.well_powered D
E.is_solution (Î» (n : â„•), q ^ n) â†” E.char_poly.is_root q
âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f c
s.prod (Î» (i : Î±), f i) = t.prod (Î» (i : Î±), â†‘s.mul_indicator f i)
cardinal.mk â†¥(set.Ioc a b) = cardinal.continuum
fintype.card (lucas_lehmer.X q) = â†‘q ^ 2
has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) b
omega_limit f â‡‘Ï• (â‡‘Ï• t '' s) = omega_limit f â‡‘Ï• s
Â¬a â‰¤ b â†’ finset.Icc a b = âˆ…
well_founded nat.lt
(âˆ€ (x y : Î±), has_dist.dist (f x) (f y) â‰¤ â†‘K * has_dist.dist x y) â†’ lipschitz_with K f
(minpoly A x).monic
(â¨† (n : Î²), f n) âˆˆ â‹‚ (n : Î²), set.Icc (f n) (g n)
0 < L.length
s.sum (Î» (i : Î¹), f i) = âŠ¤ â†” âˆƒ (i : Î¹) (H : i âˆˆ s), f i = âŠ¤
1 < a * b
polynomial.cyclotomic (p ^ (n + 1)) R = (finset.range p).sum (Î» (i : â„•), (polynomial.X ^ p ^ n) ^ i)
parser.nat cb n = parse_result.done n' val â†” âˆƒ (hn : n < n'), val = nat.of_digits 10 (list.map (Î» (c : char), c.to_nat - '0'.to_nat) (list.take (n' - n) (list.drop n (buffer.to_list cb))).reverse) âˆ§ (âˆ€ (hn' : n' < buffer.size cb), '0' â‰¤ buffer.read cb âŸ¨n', hn'âŸ© â†’ '9' < buffer.read cb âŸ¨n', hn'âŸ©) âˆ§ âˆƒ (hn'' : n' â‰¤ buffer.size cb), âˆ€ (k : â„•) (hk : k < n'), n â‰¤ k â†’ '0' â‰¤ buffer.read cb âŸ¨k, _âŸ© âˆ§ buffer.read cb âŸ¨k, _âŸ© â‰¤ '9'
G.min_degree â‰¤ G.degree v
âˆ¥(â†‘r * (â†‘âˆ¥xâˆ¥)â»Â¹) â€¢ xâˆ¥ = r
continuous_at (f / g) a
(v.on_quot hJ).supp = ideal.map (ideal.quotient.mk J) v.supp
finite_dimensional.finrank K V = fintype.card Î¹
has_dist.dist p1 p2 * has_dist.dist p1 p2 = has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2) * has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2) + has_dist.dist p2 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2) * has_dist.dist p2 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2)
emetric.Hausdorff_edist s (closure s) = 0
relation.refl_trans_gen r n m
deriv f a = 0
(s.prod (Î» (i : Î¹), f i)).nat_degree = s.sum (Î» (i : Î¹), (f i).nat_degree)
(affine.simplex.mk_of_point k p).points i = p
(set.Ioo 0 a)â»Â¹ = set.Ioi aâ»Â¹
e = e'
lipschitz_with C f
strict_anti f
continuous â‡‘(affine_map.line_map p v)
s = t â†’ s âŠ† t
â‡‘f x = â‡‘f y
is_frobenius_number (m * n - m - n) {m, n}
has_edist.edist x y = 0 â†” x = y
â‡‘Î¼ s = â‡‘Î¼ t
padic_int.lift f_compat = g
s - 0 = s
has_Sup.Sup S = eqv_gen.setoid (Î» (x y : Î±), âˆƒ (r : setoid Î±), r âˆˆ S âˆ§ r.rel x y)
â‡‘(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R * polynomial.cyclotomic n R
convex ğ•œ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ s + b â€¢ s âŠ† s
is_field R
(finset.nat.antidiagonal n).prod (Î» (ij : â„• Ã— â„•), f ij.fst ij.snd) = (finset.range n.succ).prod (Î» (k : â„•), f k (n - k))
â‡‘c x y â†’ â‡‘c y x
finset.univ.sum (Î» (i : Î¹), â‡‘(b.coord i) v â€¢ b.points i) = v
(homology_functor V c i).map f = (homology_functor V c i).map g
measure_theory.ae_strongly_measurable g Î¼
measure_theory.measure.quasi_measure_preserving X Â«â„™Â» Î¼
f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
has_inner.inner (â‡‘f x) (â‡‘f y) = has_inner.inner x y
finset.filter (Î» (y : Î²), y âˆˆ set.range f) finset.univ = finset.image f finset.univ
n â‰¤ Ï†.order
is_compl W (B.orthogonal W)
set.unbounded has_lt.lt (â‹‚ (i : Î¹), function.fixed_points (f i))
Aâ»Â¹ = ring.inverse A
module.rank K â†¥(f.range) + module.rank K â†¥(f.ker) = module.rank K V
dimH s = 0
x â‰¤ u (â‡‘l x)
dite P f g a = dite P (Î» (h : P), f h a) (Î» (h : Â¬P), g h a)
âˆƒ (y : Î±) (H : y âˆˆ s), function.is_fixed_pt f y âˆ§ filter.tendsto (Î» (n : â„•), f^[n] x) filter.at_top (nhds y) âˆ§ âˆ€ (n : â„•), has_edist.edist (f^[n] x) y â‰¤ has_edist.edist x (f x) * â†‘K ^ n / (1 - â†‘K)
ring.inverse x = 0
g y (â‡‘f y) * (finsupp.erase y f).prod g = f.prod g
((x + y) * z).equiv (x * z + y * z)
Â¬b âŠ‚ a
convex_independent ğ•œ p
Î²
measurable_set {x : â„ | differentiable_within_at â„ f (set.Ici x) x}
mul_action.fixed_points â†¥(P âŠ” Q) Î± = mul_action.fixed_points â†¥P Î± âˆ© mul_action.fixed_points â†¥Q Î±
p x
has_dist.dist (f^[n] x) (contracting_with.fixed_point f hf) â‰¤ has_dist.dist (f^[n] x) (f^[n + 1] x) / (1 - â†‘K)
(âˆƒ (c : Î±), m = c ^ 2) â†’ is_square m
function.injective â‡‘(is_localization.map Q g _)
finsupp.map_domain f (finsupp.map_range g h0 v) = finsupp.map_range g h0 (finsupp.map_domain f v)
category_theory.limits.has_biproduct f
âˆƒ (y : Î²), b â‰¤ (finset.filter (Î» (x : Î±), f x = y) finset.univ).sum (Î» (x : Î±), w x)
euclidean_geometry.cospherical {pâ‚, pâ‚‚}
golden_conjâ»Â¹ = -golden_ratio
(nhds a).has_basis (Î» (s : set Î±), s âˆˆ nhds a âˆ§ is_open s) (Î» (x : set Î±), x)
dimH s = â¨† (d : nnreal) (hd : â‡‘(measure_theory.measure.hausdorff_measure â†‘d) s = âŠ¤), â†‘d
add_monoid.closure s âŠ† t
category_theory.cover_lifting Hld.induced_topology K G
xâ‚ = xâ‚‚ âˆ¨ xâ‚ = -xâ‚‚
(â‹‚ (x : Î±) (H : x âˆˆ s), t x) âŠ† t x
s =áµ[Î¼] t
(s âˆ© t).nonempty â†’ Â¬disjoint s t
â‡‘f a âˆˆ s
âˆƒ (t : set E) (H : t âˆˆ nhds_within x s), lipschitz_on_with K f t
âˆ« (x : â„) in t..t + n â€¢ T, f x = n â€¢ âˆ« (x : â„) in t..t + T, f x
âˆƒ (f : â„• â†’ Î±), strict_anti f âˆ§ f 0 = a
0 < -a â†” a < 0
âˆƒ (Î¸ : real.angle), f = hb.rotation Î¸
category_theory.mono (hT.from A)
s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i * g i) â†” antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
â‡‘m (â‹ƒ (n : Î¹), s n) = â¨† (n : Î¹), â‡‘m (s n)
f =áµ[Î¼.restrict t] function.const Î± (â¨ (x : Î±) in t, f x âˆ‚Î¼) âˆ¨ âˆ¥âˆ« (x : Î±) in t, f x âˆ‚Î¼âˆ¥ < (â‡‘Î¼ t).to_real * C
C x hx
l.prod âˆˆ s
s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), |f i| ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), |g i| ^ q) ^ (1 / q)
s.nonempty â†’ â†‘s.nonempty
(x * y * z).equiv (x * (y * z))
cauchy_seq u â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ has_edist.edist (u m) (u n) < Îµ)
â‡‘x = â‡‘â†‘x
hb.oangle y x = â†‘real.pi - 2 â€¢ hb.oangle (y - x) y
finite_dimensional.finrank R (M â†’â‚—[R] N) = finite_dimensional.finrank R M * finite_dimensional.finrank R N
closed_under_restriction G â†” id_restr_groupoid â‰¤ G
f.range = âŠ¤
Qâ‚.equivalent Qâ‚‚
nonempty â†¥((Top.limit_cone F).X)
is_add_right_regular b
dense (s Ã—Ë¢ t)
(âˆ€ (a : set (submodule R M)), a.nonempty â†’ (âˆƒ (M' : submodule R M) (H : M' âˆˆ a), âˆ€ (I : submodule R M), I âˆˆ a â†’ I â‰¤ M' â†’ I = M')) â†” is_artinian R M
(measure_theory.measure.map â‡‘f Î¼).is_haar_measure
irreducible p â†” irreducible (polynomial.map (algebra_map R K) p)
continuous (bundle.total_space_mk b)
âˆƒ (t : set Î±) (H : t âŠ† s), t.finite âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), metric.ball x e
C x
smooth I (model_with_corners_self â„ G) (Î» (x : M), â‡‘f x â€¢ g x)
function.surjective â‡‘(f.app (opposite.op U))
f = g
âˆƒ (f : â„¤ â†’ Î±), strict_mono f
function.commute â‡‘clifford_algebra.reverse â‡‘clifford_algebra.involute
emetric.Hausdorff_edist (Î¦ '' s) (Î¦ '' t) = emetric.Hausdorff_edist s t
â‡‘(e.det) â‡‘(e.is_unit_smul hw) = finset.univ.prod (Î» (i : Î¹), w i)
âˆ« (x : G), f (g + x) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
âˆƒ (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C
â‡‘(f.generalized_eigenspace Î¼) k â‰¤ â‡‘(f.generalized_eigenspace Î¼) (finite_dimensional.finrank K V)
â‡‘f (g / h) = â‡‘f g / â‡‘f h
is_least (f '' s) (f a)
nonempty Î± â†’ nonempty Î²
measure_theory.measure.map (Î» (z : G Ã— G), (z.snd, (z.snd)â»Â¹ * z.fst)) (Î¼.prod Î½) = Î½.prod Î¼
category_theory.limits.has_colimits_of_shape J' C
algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p ^ k).totient / 2) * â†‘p ^ (â†‘p ^ (k - 1) * ((â†‘p - 1) * k - 1))
cardinal.cantor_function c f < cardinal.cantor_function c g
right_deriv_measurable_aux.D f K âŠ† {x : â„ | differentiable_within_at â„ f (set.Ici x) x âˆ§ deriv_within f (set.Ici x) x âˆˆ K}
nat.of_digits b l < b ^ l.length
â‡‘(â‡‘f'' v) w = â‡‘(â‡‘f'' w) v
is_group_hom f
X.Î´ i â‰« X.Î´ j.succ = X.Î´ j â‰« X.Î´ (â‡‘fin.cast_succ i)
f (â‡‘(affine_map.line_map a b) r) â‰¤ â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a (â‡‘(affine_map.line_map a b) r) â‰¤ slope f a b
strict_anti f
âˆ« (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
measure_theory.strongly_measurable f
strict_mono f
C x
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ t), g j))
F.ess_image = F'.ess_image
cont_diff_within_at ğ•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t) x
has_edist.edist (f 0) a â‰¤ C / (1 - r)
(âˆ€ (i : Î¹), i âˆˆ S â†’ Î¼.restrict (s i) = Î½.restrict (s i)) â†’ Î¼ = Î½
summable (â‡‘g âˆ˜ f) â†” summable f
add_semiconj_by a x (a + x + -a)
finset.univ.sum (Î» (i : fin 0), f i) = 0
vector_span k s = submodule.span k (has_vsub.vsub p '' s)
continuous (function.uncurry (Î» (x : Î±) (y : Î²), â‡‘(â‡‘f x) y))
(Î» (t : Î¹), âˆ« (x : â„) in v t..b, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..b, f x âˆ‚Î¼ + âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
turing.TM2.supports turing.partrec_to_TM2.tr (turing.partrec_to_TM2.code_supp c k)
P x hx
f (dite P a b) (dite P c d) = dite P (Î» (h : P), f (a h) (c h)) (Î» (h : Â¬P), f (b h) (d h))
b â‹– a â†’ â‡‘order_dual.of_dual a â‹– â‡‘order_dual.of_dual b
s âˆˆ nhds a â†” âˆƒ (l u : Î±), a âˆˆ set.Ioo l u âˆ§ set.Ioo l u âŠ† s
add_semiconj_by a (x + x') (y + y')
isometry (g âˆ˜ f)
a âŠ“ has_Sup.Sup s = â¨† (b : Î±) (H : b âˆˆ s), a âŠ“ b
continuous_on (Î» (b : â„), âˆ« (x : â„) in a..b, f x âˆ‚Î¼) (set.interval bâ‚ bâ‚‚)
connected_component x âŠ† â‹‚ (Z : {Z // is_clopen Z âˆ§ x âˆˆ Z}), â†‘Z
function.injective coe_fn
totally_disconnected_space H â†” totally_separated_space H
â‡‘(equiv.point_reflection x) y = y â†” y = x
orthonormal ğ•œ (â‡‘f âˆ˜ v)
â‡‘(Î¼.restrict s) t = â‡‘Î¼ (t âˆ© s)
Jâ‚ = Jâ‚‚
Î¼ = Î½ â†” âˆ€ (i : Î¹), Î¼.restrict (s i) = Î½.restrict (s i)
is_semiring_hom f
b â‰¤ a â†’ â‡‘order_dual.of_dual a â‰¤ â‡‘order_dual.of_dual b
âˆƒ (Î¸ : real.angle), f = o.rotation Î¸
0 â‰¤ x â†” âˆ€ (j : x.right_moves), 0.lf (x.move_right j)
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
discrete_valuation_ring R â†” is_principal_ideal_ring R âˆ§ âˆƒ! (P : ideal R), P â‰  âŠ¥ âˆ§ P.is_prime
is_glb (s âˆª t) (aâ‚ âŠ“ aâ‚‚)
has_fderiv_at (g âˆ˜ f) (g'.comp f') x
(h.comp g).comp f = h.comp (g.comp f)
f = g
âˆƒ (v : Î¹ â†’ set X), s âŠ† set.Union v âˆ§ (âˆ€ (i : Î¹), is_closed (v i)) âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
Î½â‚ â‰¤ Î½â‚‚
is_absolute_value.uniform_space has_abs.abs = pseudo_metric_space.to_uniform_space
âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ dense t âˆ§ (âˆ€ (x : Î±), is_bot x â†’ x âˆˆ s â†’ x âˆˆ t) âˆ§ âˆ€ (x : Î±), is_top x â†’ x âˆˆ s â†’ x âˆˆ t
(measure_theory.simple_func.map g f).lintegral Î¼ = f.range.sum (Î» (x : Î²), g x * â‡‘Î¼ (â‡‘f â»Â¹' {x}))
a âŠ† b
category_theory.is_iso f
convex_on â„ (set.Ici 0) (Î» (x : â„), x ^ n)
âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥
is_open_map f
k â‰« t.Ï€.app j = l â‰« t.Ï€.app j
J.Î¹ â‰« category_theory.InjectiveResolution.desc f I J = (cochain_complex.singleâ‚€ C).map f â‰« I.Î¹
âˆƒ (r : â„), âˆ€ (sx : affine.simplex â„ P n), set.range sx.points âŠ† ps â†’ sx.circumradius = r
â‡‘(polynomial.aeval x) a â‰  0
C a
p i
2 â€¢ o.oangle x (r â€¢ y) = 2 â€¢ o.oangle x y
metric.bounded {x}
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
(xâ‚ ^ 2 + xâ‚‚ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2
lipschitz_with K.to_nnreal f
âˆ«â» (a : Î±), (â¨… (n : â„•), f n a) âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
tendsto_uniformly_on F f p s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), x âˆˆ s â†’ has_dist.dist (f x) (F n x) < Îµ)
â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘K ^ d * â‡‘(measure_theory.measure.hausdorff_measure d) s
â‡‘multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a
((Î» (_x : Î±), _x * x) âˆ˜ Î» (_x : Î±), _x * y) = Î» (_x : Î±), _x * (y * x)
category_theory.whisker_left G.op (H.sheaf_hom Î±) = Î±
group.is_nilpotent G'
isometry g
s.prod (Î» (i : Î¹), f i) â‰¤ 1
x âˆˆ set.extreme_points ğ•œ A â†” is_extreme ğ•œ A {x}
hb.oangle y (â‡‘(hb.rotation (hb.oangle x y)) x) = 0
Îµ * â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼
âˆƒ (g : bounded_continuous_function Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ set.Icc a b) âˆ§ â‡‘g âˆ˜ e = â‡‘f
âˆƒ (m : â†¥M), m â€¢ x âˆˆ submodule.span R â†‘(is_localization.finset_integer_multiple (submonoid.map â†‘(algebra_map R S) M) s)
unique_diff_on ğ•œ (set.univ.pi s)
has_deriv_at complex.exp (complex.exp x) x
F.obj Y âˆˆ F.ess_image
hb.oangle x 0 = 0
(fintype.card â†¥P).coprime â†‘P.index
has_Sup.Sup S = add_con_gen (has_Sup.Sup (coe_fn '' S))
finite_dimensional.finrank K V = 0
(X.presheaf_to_Types T).is_sheaf
â‡‘f (bit0 a) = bit0 (â‡‘f a)
topological_space.second_countable_topology Î±
module.finite A B
primrec (Î» (a : (â„• Ã— nat.partrec.code) Ã— â„•), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€ (k : â„•), f^[k] x âˆˆ s â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
complete_space Î±
e.trans e.symm â‰ˆ local_homeomorph.of_set e.to_local_equiv.source _
â†‘â†‘â†‘g = â†‘g
inducing (Î» (p : bundle.total_space (Î» (x : B), Eâ‚ x Ã— Eâ‚‚ x)), (âŸ¨p.fst, p.snd.fstâŸ©, âŸ¨p.fst, p.snd.sndâŸ©))
n.totient * n.factors.to_finset.prod (Î» (p : â„•), p) = n * n.factors.to_finset.prod (Î» (p : â„•), p - 1)
a âˆˆ s
algebraic_topology.dold_kan.hÏƒ' q n m hnm = G.map (algebraic_topology.dold_kan.hÏƒ' q n m hnm)
reflexive (Î» (a b : M), âˆƒ (c : M), add_semiconj_by c a b)
0 < a + b
X.Ïƒ j â‰« X.Ïƒ (â‡‘fin.cast_succ i) = X.Ïƒ i â‰« X.Ïƒ j.succ
âˆƒ (f : Î  (b : ordinal), b < a.cof.ord â†’ ordinal), a.is_fundamental_sequence a.cof.ord f
filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
finsum (Î» (i : Î±), f i + g i) = finsum (Î» (i : Î±), f i) + finsum (Î» (i : Î±), g i)
(Î» (x : â„), x ^ k) =o[filter.at_top] Î» (x : â„), real.exp (b * x)
list.pairwise R l â†’ list.pw_filter R l = l
list.map (h âˆ˜ g) l = list.map h (list.map g l)
c âŠ” d = add_con_gen (Î» (x y : M), â‡‘c x y âˆ¨ â‡‘d x y)
category_theory.presieve.is_sheaf (category_theory.sheaf.finest_topology Ps) P
exp_neg_inv_glue x = 0
category_theory.limits.has_products_of_shape X Cáµ’áµ–
(âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.range (n + 1)).sum (Î» (k : â„•), f k * g (n - k))
cont_diff ğ•œ âŠ¤ fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ âŠ¤ (deriv fâ‚‚)
group.fg â†¥H
metric.closed_ball x r = set.univ.pi (Î» (b : Î²), metric.closed_ball (x b) r)
filter.tendsto (Î» (k : â„•), (finset.range k).prod (Î» (i : â„•), (2 * â†‘i + 2) / (2 * â†‘i + 1) * ((2 * â†‘i + 2) / (2 * â†‘i + 3)))) filter.at_top (nhds (real.pi / 2))
cont_diff ğ•œ n (f âˆ˜ â‡‘g)
metric.cthickening 0 E = closure E
ordinal.enum_ord S o = has_Inf.Inf (S âˆ© set.Ici (o.blsub (Î» (a : ordinal) (_x : a < o), ordinal.enum_ord S a)))
âˆƒ (w : fin (finite_dimensional.finrank â„ M) â†’ â„), (âˆ€ (i : fin (finite_dimensional.finrank â„ M)), w i = -1 âˆ¨ w i = 0 âˆ¨ w i = 1) âˆ§ Q.equivalent (quadratic_form.weighted_sum_squares â„ w)
â‡‘(has_Inf.Inf m) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (Î¼ : measure_theory.outer_measure Î±) (h3 : Î¼ âˆˆ m), â‡‘Î¼ (t n)
dense â†‘G
M â‰  âŠ¥
â‡‘multilinear_map.alternatization (â†‘a.dom_coprod â†‘b) = ((fintype.card Î¹a).factorial * (fintype.card Î¹b).factorial) â€¢ a.dom_coprod b
category_theory.limits.biproduct.Î¹ f j â‰« category_theory.limits.biproduct.Ï€ f j' = dite (j = j') (Î» (h : j = j'), category_theory.eq_to_hom _) (Î» (h : Â¬j = j'), 0)
complex.cos (â†‘n * Î¸) = polynomial.eval (complex.cos Î¸) (polynomial.chebyshev.T â„‚ n)
o.oangle (-x) y + o.oangle (-y) x = 0
complex.abs (f z) â‰¤ complex.abs z
f = g
(cardinal.sup f).lift â‰¤ (cardinal.sup f').lift
a * â†‘u âˆ£ b â†” a âˆ£ b
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ t), f i j)))) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ t), finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i j))))
x.lf z
â‡‘(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
nonempty M
âˆ¯ (x : fin 1 â†’ â„‚) in T(c, R), f x = âˆ® (z : â„‚) in C(c 0, R 0), f (Î» (_x : fin 1), z)
(c â€¢ m).trim = c â€¢ m.trim
âˆƒ (iâ‚€ iâ‚ : fin m.succ), iâ‚€ â‰  iâ‚ âˆ§ A iâ‚ = A iâ‚€
|has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)| â‰¤ 1
f = g
c + c = c
category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd
interval_integrable u Î¼ a b
monotone finset.up_shadow
(-1) * a = -a
â‡‘f (â‡‘(s.affine_combination p) w) = â‡‘(s.affine_combination (â‡‘f âˆ˜ p)) w
convolution_exists_at f g xâ‚€ L Î¼
finite_dimensional.finrank R (M Ã— N) = finite_dimensional.finrank R M + finite_dimensional.finrank R N
algebra.is_algebraic R S â†” algebra.is_algebraic R K
measure_theory.measure.map (s.restrict f) (â‡‘(measure_theory.measure.comap coe) (Î¼.with_density (Î» (x : E), ennreal.of_real |(f' x).det|))) = Î¼.restrict (f '' s)
0 âˆ£ a â†” a = 0
(finset.Icc s t).card = 2 ^ (t.card - s.card)
topological_space.is_separable (set.range f)
zmod.legendre_sym p a = (-1) ^ (finset.filter (Î» (x : â„•), p / 2 < (â†‘a * â†‘x).val) (finset.Ico 1 (p / 2).succ)).card
multiplicity p (p * n).factorial = multiplicity p n.factorial + â†‘n
P (â‡‘linear_map.det f)
âˆƒ (Î´ : â„) (hÎ´ : 0 < Î´), âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰¤ ennreal.of_real Î´ â†’ measure_theory.snorm (s.indicator f) p Î¼ â‰¤ ennreal.of_real Îµ
c = f.cycle_of a
measurable_set s
has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), h (f x) (g y))
strict_mono_on f s â†’ strict_anti_on (â‡‘order_dual.to_dual âˆ˜ f) s
-b + a < c â†’ a < b + c
Â¬interval_integrable g measure_theory.measure_space.volume a b
0 â‰¤ a * b
â†‘(finset.map (function.embedding.subtype (Î» (x : Î±), x âˆˆ t)) s) âŠ† t
c.lift (f.comp c.mk') _ = f
âˆƒ (y : Î²) (H : y âˆˆ t), b â‰¤ â†‘((finset.filter (Î» (x : Î±), f x = y) s).card)
measure_theory.tendsto_in_measure Î¼ f l g
measure_theory.vector_measure.absolutely_continuous s Î¼.to_ennreal_vector_measure â†” Î¼.with_densityáµ¥ (s.rn_deriv Î¼) = s
(orientation.fin_orthonormal_basis hn h x).orientation = x
algebra.finite_presentation R B
smul_comm_class N Î² Î±
âˆ« (y : â„) in a..b, f' y = f b - f a
P.W_rec g (P.W_mk a f' f) = g a f' f (Î» (i : P.last.B a), P.W_rec g (f i))
âˆƒ (t : set Î±), s âŠ† t âˆ§ measurable_set t âˆ§ â‡‘Î¼ t = â‡‘Î¼ s
a - c < b - c â†” a < b
analytic_on ğ•œ (deriv f) s
u / v * v =á¶ [l] u
Â¬has_btw.btw c b a
0 < (minpoly A x).nat_degree
â‡‘(measure_theory.measure.hausdorff_measure d) s â‰¤ l.liminf (Î» (n : Î²), finset.univ.sum (Î» (i : Î¹ n), emetric.diam (t n i) ^ d))
|real.log x * x ^ t| < 1 / t
t â‰¤ 1
(s.erase a).card = ite (a âˆˆ s) (s.card - 1) s.card
irreducible f
category_theory.is_iso f
filter.tendsto (Î» (x : â„), f x / g x) filter.at_bot l
qâ‚ = qâ‚‚
has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
has_deriv_at f f' a â†’ f' = 0
filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© ({x} + r â€¢ t)) / â‡‘Î¼ ({x} + r â€¢ t)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
linear_independent R (â‡‘f âˆ˜ v) â†” linear_independent R v
âˆ€á¶  (x : E) in nhds a, has_strict_fderiv_at.implicit_function f f' hf hf' (f x) (â‡‘(has_strict_fderiv_at.implicit_to_local_homeomorph f f' hf hf') x).snd = x
inner_product_space.is_self_adjoint T â†” bilin_form_of_real_inner.is_self_adjoint T
(c.lift f H).mrange = f.mrange
Ká—®á—® = K
(b + 2) ^ ((b + 2).digits m).length â‰¤ (b + 2) * m
hb.oangle y z = 2 â€¢ hb.oangle (y - x) (z - x)
b â‰¤ c
free_group.mk (free_group.reduce L) = free_group.mk L
â‡‘((a * b).factorization) p = â‡‘(a.factorization) p + â‡‘(b.factorization) p
differentiable_on â„‚ (function.update f c (lim (nhds_within c {c}á¶œ) f)) (has_insert.insert c s)
category_theory.limits.has_terminal C
âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
strict_mono (Î» (x : Î²), f x * g x)
f (â‡‘(affine_map.line_map a b) r) < â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a (â‡‘(affine_map.line_map a b) r) < slope f a b
â‡‘f (a * bâ»Â¹) = â‡‘f a * (â‡‘f b)â»Â¹
âˆƒ (y : Î±), s = {x : Î± | (setoid.mk_classes c _).rel x y}
(reflection K)â»Â¹ = reflection K
f.to_linear_map.comp (clifford_algebra.Î¹ Q) = g.to_linear_map.comp (clifford_algebra.Î¹ Q) â†’ f = g
absorbent ğ•œ (metric.ball 0 r)
(â‡‘â¨… (i : Î¹) (H : i âˆˆ I), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹) (H : i âˆˆ I), â‡‘(m i) (t n)
polynomial.splits (algebra_map F (p.comp q).splitting_field) p
f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
P p
Jâ‚.close S = âŠ¤ â†” S âˆˆ â‡‘Jâ‚ X
affine.simplex.altitude t iâ‚ = affine.simplex.monge_plane t iâ‚‚ iâ‚ƒ
filter.tendsto (Î» (x : Î±), (f x)â»Â¹) l (nhds aâ»Â¹)
is_seq_closed s
(âˆ€á¶  (x : Î±) in l, âˆ€ (i : Î¹), i âˆˆ I â†’ p i x) â†” âˆ€ (i : Î¹), i âˆˆ I â†’ (âˆ€á¶  (x : Î±) in l, p i x)
a âˆˆ finset.univ.prod (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), g i âˆˆ f i), finset.univ.prod (Î» (i : Î¹), g i) = a
âˆƒ (a' b' c' : R), (âˆ€ {d : R}, d âˆ£ a' â†’ d âˆ£ b' â†’ is_unit d) âˆ§ c' * a' = a âˆ§ c' * b' = b
solvable_by_rad.P Î²
c.boundaries.order_emb_of_fin _ = c.boundary
measure_theory.measure.hausdorff_measure â†‘(fintype.card Î¹) = measure_theory.measure_space.volume
is_closed â†‘Ká—®
â‡‘f (fin.cons (x + y) m) = â‡‘f (fin.cons x m) + â‡‘f (fin.cons y m)
â¨ (x : Î±) in t, f x âˆ‚Î¼ âˆˆ s
âˆ¥f 1 - f 0âˆ¥ â‰¤ C
p = s.monge_point
c < b
â‡‘linear_map.det (â‡‘(algebra.lmul K L) x) = 0 â†” x = 0
is_compact (coe_fn '' s)
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), g âˆ˜ f)
Jâ‚ = Jâ‚‚ â†” âˆ€ (P : Cáµ’áµ– â¥¤ Type (max v u)), category_theory.presieve.is_sheaf Jâ‚ P â†” category_theory.presieve.is_sheaf Jâ‚‚ P
padic_val_nat p 1 = 0
upper_semicontinuous_on (Î» (z : Î±), f z + g z) s
real.cos (inner_product_geometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = has_inner.inner x y
p â†‘x
filter.tendsto (Î» (x : Î²), f x * r) l filter.at_top
metric.bounded s â†’ (âˆƒ (R : â„), âˆ€ (x : E), x âˆˆ s â†’ âˆ¥xâˆ¥ â‰¤ R)
âˆƒ (f : bounded_continuous_function X â„), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc 0 1
is_preconnected s
x â‰¤ 0 â†” âˆ€ (i : x.left_moves), âˆƒ (j : (x.move_left i).right_moves), (x.move_left i).move_right j â‰¤ 0
o.oangle x (r â€¢ y) = o.oangle x y
lipschitz_with K f
s.monge_point âˆˆ s.monge_plane iâ‚ iâ‚‚
uniform_embedding f
ray_of_ne_zero R x.some_vector _ = x
âˆƒ (T : set Î¹), T.countable âˆ§ (â‹ƒ (i : Î¹) (H : i âˆˆ T), s i) = â‹ƒ (i : Î¹), s i
(truncated_witt_vector.truncate hm).comp (truncated_witt_vector.zmod_equiv_trunc p m).to_ring_hom = (truncated_witt_vector.zmod_equiv_trunc p n).to_ring_hom.comp (zmod.cast_hom _ (zmod (p ^ n)))
continuous (Î» (F : C(Î±, Î²)), continuous_map.restrict s F)
âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
tangent_map I I â‡‘(charted_space.chart_at H p.fst) q = â‡‘((equiv.sigma_equiv_prod H E).symm) (â‡‘(charted_space.chart_at (model_prod H E) p) q)
âˆƒ (L L' : list (matrix.transvection_struct n ğ•œ)) (D : n â†’ ğ•œ), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
M.transpose j i = M i j
continuous (Î» (h : G), g + h + -g)
âˆ¥fâˆ¥ = has_Inf.Inf {C : â„ | âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C}
(finset.Ico a b).sum (Î» (i : â„•), (finset.Ico i b).sum (Î» (j : â„•), f i j)) = (finset.Ico a b).sum (Î» (j : â„•), (finset.Ico a (j + 1)).sum (Î» (i : â„•), f i j))
â‡‘(euclidean_geometry.orthogonal_projection s) â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = â‡‘(euclidean_geometry.orthogonal_projection s) p
finite_dimensional.finrank K (V â§¸ s) â‰¤ finite_dimensional.finrank K V
filter.map prod.snd (nhds_within x (prod.fst â»Â¹' {x.fst})) = nhds x.snd
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
g.denominators (n + 2) = gp.b * predB + gp.a * ppredB
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), 1)) = 1
0 âˆˆ multiples x
has_mul.mul x âˆ˜ has_mul.mul y = has_mul.mul (x * y)
âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds (Ï.rn_deriv Î¼ x))
set.range â‡‘(p.succ_above) = {p}á¶œ
f.surjective_on_with j.range.topological_closure (C + Îµ)
a / (a / a) = a
polynomial.cyclotomic' n K = (polynomial.X ^ n - 1) /â‚˜ n.proper_divisors.prod (Î» (i : â„•), polynomial.cyclotomic' i K)
âˆ« (a : Î±), f a âˆ‚Î¼ = (âˆ«â» (a : Î±), ennreal.of_real (f a) âˆ‚Î¼).to_real - (âˆ«â» (a : Î±), ennreal.of_real (-f a) âˆ‚Î¼).to_real
measurable f
measure_theory.submartingale f ğ’¢ Î¼ â†” âˆ€ (Ï„ Ï€ : Î± â†’ â„•), measure_theory.is_stopping_time ğ’¢ Ï„ â†’ measure_theory.is_stopping_time ğ’¢ Ï€ â†’ Ï„ â‰¤ Ï€ â†’ (âˆƒ (N : â„•), âˆ€ (x : Î±), Ï€ x â‰¤ N) â†’ âˆ« (x : Î±), measure_theory.stopped_value f Ï„ x âˆ‚Î¼ â‰¤ âˆ« (x : Î±), measure_theory.stopped_value f Ï€ x âˆ‚Î¼
filter.tendsto f (filter.cocompact Î±) (filter.cocompact Î²)
function.injective (Î» (h : diffeomorph I I' M M' n) (x : M), â‡‘h x)
s âˆˆ finset.shadow^[k] ğ’œ â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), s âŠ† t âˆ§ t.card = s.card + k
concave_on ğ•œ s f â†” convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x)
summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p
(f + g).sum h = f.sum h + g.sum h
filter.map prod.fst (nhds_within x (prod.snd â»Â¹' {x.snd})) = nhds x.fst
subgroup.comap f H.normalizer â‰¤ (subgroup.comap f H).normalizer
disjoint (set.range â‡‘(c.embedding iâ‚)) (set.range â‡‘(c.embedding iâ‚‚))
f z < linear_order.max (f x) (f y)
is_countably_spanning (set.image2 has_set_prod.prod C D)
f = g
dimH (f '' s) â‰¤ dimH s / â†‘r
â‡‘f â†‘y = â‡‘f â†‘z
module.rank R (Î  (i : Î¹), M i) = cardinal.sum (Î» (i : Î¹), module.rank R (M i))
âˆ‘' (i : â„•), ite (n â‰¤ i) (2â»Â¹ ^ i) 0 = 2 * 2â»Â¹ ^ n
â‡‘(probability_theory.cond Î¼ s) t = (â‡‘Î¼ s)â»Â¹ * â‡‘(probability_theory.cond Î¼ t) s * â‡‘Î¼ t
c.closed = set.range â‡‘c
x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S
a â‰¡ b [MOD m / m.gcd c]
category_theory.is_pullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚
â†‘(â‡‘(category_theory.limits.cotrident.is_colimit.hom_iso ht Z') (k â‰« q)) = â†‘(â‡‘(category_theory.limits.cotrident.is_colimit.hom_iso ht Z) k) â‰« q
continuous â‡‘f
C r hr
â†‘e.inverse = â†‘(e.symm)
âˆƒ (C r : â„) (hC : 0 < C) (hr : 0 < r), âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C * r ^ n
finset.univ.sum (Î» (j : affine.simplex.points_with_circumcenter_index n), affine.simplex.point_weights_with_circumcenter i j) = 1
f.has_generalized_eigenvalue Î¼ k
Ï†â‚ = Ï†â‚‚
âˆƒ (a : F), Â¬is_square a
o = p
hb.oangle x (-x) = â†‘real.pi
conformal_at f x â†” âˆƒ (c : â„), 0 < c âˆ§ âˆ€ (u v : E), has_inner.inner (â‡‘f' u) (â‡‘f' v) = c * has_inner.inner u v
âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) -áµ¥ p âˆˆ (s.direction)á—®
is_extr_on f s a â†’ is_extr_on (â‡‘order_dual.to_dual âˆ˜ f) s a
âˆƒ (f : Î¹ â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
cont_diff_at ğ•œ n (prod.map f g) (x, y)
measurable (Î» (h : G), h / g)
f == g â†” âˆ€ (i : fin k), f i = g âŸ¨â†‘i, _âŸ©
â‡‘(linear_map.to_matrix vâ‚ vâ‚) linear_map.id = 1
x âˆˆ M'
is_top a â†’ a = âŠ¤
direct_sum.is_internal A â†” complete_lattice.independent A âˆ§ supr A = âŠ¤
uâ»Â¹ = u â†” u = 1 âˆ¨ u = -1
algebraic_independent R coe
category_theory.is_iso c.Î¹
has_dist.dist (convolution f g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) (g xâ‚€) â‰¤ Îµ
s.sum (Î» (x : Î±), f x) = t.sum (Î» (x : Î³), g x)
emetric.diam âˆ… = 0
â†‘s1 âŠ“ â†‘s2 = â†‘s1 âˆ© â†‘s2
âˆ¥â‡‘f mâˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
cardinal.mk â†¥set.univ = cardinal.continuum
m âˆˆ f' '' set.Icc a b
measure_theory.prog_measurable f u
filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.univ  {a})) l
p âˆ£ Q.coeff 0
filter.tendsto (Î» (x : Î²), r * f x) l filter.at_bot
orthogonal_family ğ•œ (Î» (g : Î³), V (f g))
finsupp.map_domain â‡‘f 1 = 1
âˆƒ (S : C), âˆ€ {X : C}, X âˆˆ O â†’ nonempty (X âŸ¶ S)
function.injective coe_fn
padic_norm p q = â†‘p ^ -padic_val_rat p q
s.nonempty â†’ sâ»Â¹.nonempty
f = g
is_add_hom id
S.to_submodule * S.to_submodule = S.to_submodule
(â†‘âŒŠaâŒ‹ * b + c) / int.fract a + b = (b * a + c) / int.fract a
x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x
â…x,yâ† âˆˆ H
function.surjective â‡‘(mv_polynomial.aeval (Î» (s : â†¥S), add_monoid_algebra.of' R M â†‘s))
âˆƒ (t : set Î±), measurable_set t âˆ§ t âŠ† s âˆ§ r < â‡‘Î¼ t âˆ§ â‡‘Î¼ t < âŠ¤
n.min_fac ^ 2 â‰¤ n
filter.tendsto f tâ‚€ (nhds 0)
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ â¨ (x : Î±), g (f x) âˆ‚Î¼ < g (â¨ (x : Î±), f x âˆ‚Î¼)
box_integral.has_integral I l â‡‘f Î¼.to_box_additive.to_smul (measure_theory.simple_func.integral (Î¼.restrict â†‘I) f)
J.covers S f
(f z - f y) / (z - y) < (f y - f x) / (y - x)
category_theory.limits.has_colimits_of_size D
measure_theory.measure.map (Î» (z : G Ã— G), (z.fst, z.fst * z.snd)) (Î¼.prod Î½) = Î¼.prod Î½
add_monoid.is_torsion G
finsum (Î» (ab : Î± Ã— Î²), finsum (Î» (h : ab âˆˆ s), f ab)) = finsum (Î» (a : Î±), finsum (Î» (b : Î²), finsum (Î» (h : (a, b) âˆˆ s), f (a, b))))
1.is_diag
nat.prime p
(pgame.pow_half n).numeric
has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 - 2 * has_dist.dist p1 p2 * has_dist.dist p3 p2 * real.cos (euclidean_geometry.angle p1 p2 p3)
â†‘(f.map p).nonempty
x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H
filter.tendsto F p (nhds f) â†” tendsto_locally_uniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
(âˆ‘' (x : Î¹), f x) * âˆ‘' (y : Î¹'), g y = âˆ‘' (z : Î¹ Ã— Î¹'), f z.fst * g z.snd
P p
â‡‘Î¼ s = â‡‘Î½ s
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), x * â†‘n)
summable (Î» (i : Î¹), f i * g i) âˆ§ âˆ‘' (i : Î¹), f i * g i â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) * (âˆ‘' (i : Î¹), g i ^ q) ^ (1 / q)
category_theory.limits.has_limit (category_theory.limits.cospan f g)
is_greatest (s âˆª t) (linear_order.max a b)
polynomial.eval (complex.cos Î¸) (polynomial.chebyshev.U â„‚ n) * complex.sin Î¸ = complex.sin ((â†‘n + 1) * Î¸)
algebra.finite_presentation R B
strict_concave_on ğ•œ s f â†” convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x)
a âˆ£ b â†’ b âˆ£ c â†’ a âˆ£ c
category_theory.limits.has_initial C
add_semiconj_by â†‘u x (â†‘u + x + â†‘-u)
has_dist.dist (â‡‘f x) (â‡‘f y) â‰¤ 2 * âˆ¥fâˆ¥
x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ hb.oangle x y = 0
âˆ«â» (a : Î±), filter.at_top.liminf (Î» (n : â„•), f n a) âˆ‚Î¼ â‰¤ filter.at_top.liminf (Î» (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼)
âˆƒ! (cccrâ‚‚ : P Ã— â„), cccrâ‚‚.fst âˆˆ affine_span â„ (has_insert.insert p â†‘s) âˆ§ âˆ€ (p1 : P), p1 âˆˆ has_insert.insert p ps â†’ has_dist.dist p1 cccrâ‚‚.fst = cccrâ‚‚.snd
â‡‘(module.End.generalized_eigenspace (linear_map.restrict f hfp) Î¼) k = submodule.comap p.subtype (â‡‘(f.generalized_eigenspace Î¼) k)
âˆƒ (g : matrix.special_linear_group (fin 2) â„¤), âˆ€ (g' : matrix.special_linear_group (fin 2) â„¤), (g' â€¢ z).im â‰¤ (g â€¢ z).im
â‡‘(q.comp p 0) v = â‡‘(q 0) v'
has_dist.dist (box_integral.integral_sum f vol Ï€â‚) (box_integral.integral_sum f vol Ï€â‚‚) â‰¤ Îµâ‚ + Îµâ‚‚
Â¬is_field (polynomial R)
measure_theory.ae_strongly_measurable f Î¼
â†‘(ideal.span {â‡‘(algebra_map S L) a}) âŠ† â†‘(submodule.span K (â‡‘(algebra_map S L) '' b))
filter.tendsto (Î» (g : {g // â†‘g 1 = cd}), â‡‘(modular_group.lc_row0 cd) â†‘â†‘g) filter.cofinite (filter.cocompact â„)
measure_theory.analytic_set (â‹‚ (n : Î¹), s n)
measurable (Î» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼)
â‡‘(equiv.perm_congr e) p = e * p * eâ»Â¹
continuous f
list.sorted r (list.insertion_sort r l)
p âˆˆ âŠ¤
midpoint R x y = midpoint R' x y
cont_diff_at ğ•œ n (g âˆ˜ f) x
has_deriv_at (Î» (x : â„), (e â†‘x).re) e'.re z
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆ© t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
0 = 1 â†” set.range â‡‘f = {0}
â†‘(s.direction) = (Î» (_x : P), _x -áµ¥ p) '' â†‘s
Â¬same_ray â„ x y â†” âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
o.oangle x (r â€¢ y) = o.oangle x (-y)
âˆ¥âˆ‘' (i : Î¹), f iâˆ¥ â‰¤ âˆ‘' (i : Î¹), âˆ¥f iâˆ¥
simplex_category.Î´ i â‰« simplex_category.Î´ (â‡‘fin.cast_succ i) = simplex_category.Î´ i â‰« simplex_category.Î´ i.succ
continuous (Î» (x : Î²), has_dist.dist (f x) (g x))
p x hx
set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))
Î¼ = (â‡‘Î¼ E / â‡‘Î½ E) â€¢ Î½
g.nat_degree = g'.nat_degree
b âˆ£ a - c
metric.inf_dist x t â‰¤ metric.Hausdorff_dist s t
cardinal.mk L â‰¤ cardinal.mk R
tendsto_locally_uniformly_on F f p s â†” tendsto_uniformly_on F f p s
F.is_compatible U ((F.pi_opens_iso_sections_family U).hom sf) â†” Top.presheaf.sheaf_condition_equalizer_products.left_res F U sf = Top.presheaf.sheaf_condition_equalizer_products.right_res F U sf
finset.univ = finset.cons (fin.last n) (finset.map fin.cast_succ.to_embedding finset.univ) _
((b - a) / (c - a)) â€¢ slope f a b + ((c - b) / (c - a)) â€¢ slope f b c = slope f a c
vector_span k âˆ… = âŠ¥
is_closed (coe_fn '' s)
c = c' â†” c.snd.blocks = c'.snd.blocks
â†‘m âˆ£ â†‘n
(A.mul B).adjugate = B.adjugate.mul A.adjugate
f = g
fib_rec.char_poly = polynomial.X ^ 2 - (polynomial.X + 1)
f â‰ˆ â†‘0 â†” f.hom = 0
p.bind_on_support (Î» (a : Î±) (_x : a âˆˆ p.support), f a) = p.bind f
uv.is_compressed u u s
filter.tendsto (Î» (x : Î²), r * f x) l filter.at_top
x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
(minpoly A x).coeff 0 â‰  0
monotone (Î» (x : Î±), f x Ã—Ë¢ g x)
x âˆˆ s â†” emetric.inf_edist x s = 0
nonempty â†¥(hall_matchings_on t Î¹')
p = t.orthocenter
has_inner.inner x y = (â†‘âˆ¥x + yâˆ¥ ^ 2 - â†‘âˆ¥x - yâˆ¥ ^ 2 + (â†‘âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ ^ 2 - â†‘âˆ¥x + is_R_or_C.I â€¢ yâˆ¥ ^ 2) * is_R_or_C.I) / 4
âˆƒ (z : â„¤), padic_norm p q = â†‘p ^ -z
has_inner.inner x y = 0 â†” inner_product_geometry.angle x y = real.pi / 2
convex_on ğ•œ s f
affine_span k (set.range p) = sp
âˆƒ! (k : â„¤), k â€¢ a â‰¤ g âˆ§ g < (k + 1) â€¢ a
[is_local_ring_hom f, â‡‘f '' (local_ring.maximal_ideal R).carrier âŠ† â†‘(local_ring.maximal_ideal S), ideal.map f (local_ring.maximal_ideal R) â‰¤ local_ring.maximal_ideal S, local_ring.maximal_ideal R â‰¤ ideal.comap f (local_ring.maximal_ideal S), ideal.comap f (local_ring.maximal_ideal S) = local_ring.maximal_ideal R].tfae
âˆ€á¶  (t : finset (Î¹ Ã— â„)) in filter.at_top, âˆ€ (I J : box_integral.box Î¹), J âˆˆ s â†’ âˆ€ (J' : box_integral.box Î¹), J' âˆˆ box_integral.prepartition.split_many I t â†’ Â¬disjoint â†‘J â†‘J' â†’ J' â‰¤ J
function.injective â‡‘f â†” function.surjective â‡‘f
(âˆ€ (a : â†¥P), â‡‘g (â‡‘f a) = 0) âˆ§ âˆ€ (b : â†¥Q), â‡‘g b = 0 â†’ (âˆƒ (a : â†¥P), â‡‘f a = b)
metric.bounded t â†’ metric.bounded s
âˆƒ (K : set Î±) (H : K âŠ† A), is_compact K âˆ§ r < â‡‘Î¼ K
f x = b
â‡‘(p.succ_above) i â‰  p
âˆƒ (v : Î¹ â†’ set X), s âŠ† set.Union v âˆ§ (âˆ€ (i : Î¹), is_open (v i)) âˆ§ âˆ€ (i : Î¹), closure (v i) âŠ† u i
is_of_fin_add_order (-x)
Jâ‚.is_closed (Jâ‚.close S)
concave_on ğ•œ s f
â‡‘(measure_theory.induced_outer_measure m P0 m0) (s âˆª t) = â‡‘(measure_theory.induced_outer_measure m P0 m0) s + â‡‘(measure_theory.induced_outer_measure m P0 m0) t
(finset.image (Î» (i : fin n), â†‘i) A).to_colex < (finset.image (Î» (i : fin n), â†‘i) B).to_colex â†” A.to_colex < B.to_colex
âˆ« (x : Î±), âˆ« (y : Î²), (f - g) (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
â‡‘Î¼ (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), â‡‘Î¼ (s i)
(matrix.from_blocks A B C D).det = A.det * (D - (C.mul (â…Ÿ A)).mul B).det
âˆ« (x : Î±), measure_theory.stopped_value f Ï„ x âˆ‚Î¼ â‰¤ âˆ« (x : Î±), measure_theory.stopped_value f Ï€ x âˆ‚Î¼
m.prod âˆˆ S
vector_span k (p '' s) = submodule.span k ((Î» (_x : P), _x -áµ¥ p i) '' (p '' (s  {i})))
F.map_triangle.obj T âˆˆ dist_triang D
(a * b).factorization.support = a.factorization.support âˆª b.factorization.support
f.has_generalized_eigenvalue Î¼ k â†” f.has_eigenvalue Î¼
euclidean_geometry.angle p3 (midpoint â„ p1 p2) p2 = real.pi / 2
affine_span k (set.range (Î» (q : â†¥s), â‡‘(affine_map.line_map p â†‘q) â†‘(w q))) = affine_span k s
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” has_inner.inner x y = 0
pairwise (disjoint on Î» (n : Î±), set.Ico (f n) (f (order.pred n)))
prime â†‘p â†” p % 4 = 3
inner_product_geometry.angle x (r â€¢ y) = inner_product_geometry.angle x (-y)
(âˆ€á¶  (x : Î±) in nhds a, p x) â†” âˆƒ (t : set Î±), (âˆ€ (x : Î±), x âˆˆ t â†’ p x) âˆ§ is_open t âˆ§ a âˆˆ t
â…â…Hâ‚,Hâ‚‚â†,Hâ‚ƒâ† = âŠ¥
âˆ€á¶  (y : Î±) in nhds a, âˆ€á¶  (x : Î±) in nhds y, p x
has_edist.edist (f n) a â‰¤ 2 * C / 2 ^ n
minpoly A 1 = polynomial.X - 1
cont_diff ğ•œ n (Î» (x : E), (f x).fst)
is_unit â†‘p â†” Â¬p âˆ£ ring_char R
category_theory.is_idempotent_complete C â†” âˆ€ (X : C) (p : X âŸ¶ X), p â‰« p = p â†’ category_theory.limits.has_kernel p
âˆ« (x : G), f x âˆ‚Î¼ = 0
filter.map coe filter.at_bot = filter.at_bot
is_associative X mâ‚‚
dense (closure s) â†’ dense s
is_integrally_closed R â†” âˆ€ {x : K}, is_integral R x â†’ (âˆƒ (y : R), â‡‘(algebra_map R K) y = x)
category_theory.is_pullback (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)
âˆ¥fâˆ¥ = 0 â†” f = 0
linear_independent R (v âˆ˜ f)
is_locally_constant f
submodule.span R (r â€¢ s) = submodule.span R s
supr f â‰¤ c
is_preconnected s â†” âˆ€ (u v : set Î±), is_open u â†’ is_open v â†’ s âŠ† u âˆª v â†’ s âˆ© (u âˆ© v) = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v
âˆ¥continuous_map.to_Lp p Î¼ ğ•œâˆ¥ â‰¤ â†‘(measure_theory.measure_univ_nnreal Î¼) ^ (p.to_real)â»Â¹
fderiv â„ f a = 0
âˆ¥0âˆ¥ = 0
convex_on â„ set.univ â‡‘p
wâ‚ + wâ‚‚ = 1 â†’ pâ‚ ^ â†‘wâ‚ * pâ‚‚ ^ â†‘wâ‚‚ â‰¤ wâ‚ * pâ‚ + wâ‚‚ * pâ‚‚
âˆƒ (s : set Î±), s.countable âˆ§ (â‹ƒ (x : Î±) (H : x âˆˆ s), f x) = set.univ
a âˆ£ c
real.sin (real.pi / 3) ^ 2 = 3 / 4
râ‚ = râ‚‚ â†” râ‚.classes = râ‚‚.classes
subgroup.normal_closure {âŸ¨fin_rotate 5, _âŸ©} = âŠ¤
â‡‘(polynomial.aeval f) f.charpoly = 0
â‡‘linear_equiv.det ((e.symm.trans f).trans e) = â‡‘linear_equiv.det f
b = b'
x < y
set.inj_on coe {0, 1, -1}
function.injective â‡‘(dfinsupp.sum_add_hom (Î» (i : Î¹), (p i).subtype))
filter.tendsto (Î» (r : Î±), râ»Â¹) filter.at_top (nhds_within 0 (set.Ioi 0))
is_cyclic (quaternion_group 1)
(r â€¢ A).map f = f r â€¢ A.map f
group.is_nilpotent (Î  (i : Î·), Gs i)
ring.inverse â†‘u = â†‘uâ»Â¹
â†‘r â‰¤ p.radius
tangent_cone_at ğ•œ s x = tangent_cone_at ğ•œ t x
(f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x)
âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (z : Î± Ã— Î²), f z.fst z.snd âˆ‚Î¼.prod Î½
frontier (metric.thickening Î´ E) âŠ† {x : Î± | emetric.inf_edist x E = ennreal.of_real Î´}
unique_diff_on ğ•œ (s Ã—Ë¢ t)
strict_mono (Î» (x : Î²), f x * g x)
filter.at_bot = filter.comap coe filter.at_bot
nat.prime q âˆ¨ q = 1
commute (a * b) c
emetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t
add_semiconj_by a (â†‘-x) (â†‘-y)
âˆƒ (Ï€' : box_integral.tagged_prepartition I), Ï€'.to_prepartition â‰¤ Ï€ âˆ§ Ï€'.is_Henstock âˆ§ Ï€'.is_subordinate r âˆ§ Ï€'.distortion = Ï€.distortion âˆ§ Ï€'.Union = Ï€.Union
liouville_with 1 x
âˆ« (x : Î±) in s, âˆ¥g xâˆ¥ âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, âˆ¥f xâˆ¥ âˆ‚Î¼
group.nilpotency_class G' â‰¤ group.nilpotency_class G
measurable (Î» (x : Î´), filter.at_top.limsup (Î» (i : â„•), f i x))
s âˆˆ uniformity (uniform_space.completion Î±) â†” âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ {a b : uniform_space.completion Î±}, has_dist.dist a b < Îµ â†’ (a, b) âˆˆ s
2 â€¢ hb.oangle x (r â€¢ x) = 0
âˆƒ (K : nnreal) (t : set E) (H : t âˆˆ nhds_within x s), lipschitz_on_with K f t
â‡‘(e.symm) (â‡‘e x) = x
câ»Â¹ â€¢ x' âˆˆ normed_space.polar ğ•œ s
0 < a + b
b - (b - a) = a
lie_algebra.is_nilpotent R â†¥((lie_algebra.ad R L).range) â†” lie_algebra.is_nilpotent R L
euclidean_geometry.cospherical psâ‚
real.cos (real.pi / 6) = real.sqrt 3 / 2
lipschitz_on_with C f s
x â‰¤ 0 â†” âˆ€ (i : x.left_moves), (x.move_left i).lf 0
cont_diff ğ•œ âŠ¤ f â†” differentiable ğ•œ f âˆ§ cont_diff ğ•œ âŠ¤ (Î» (y : E), fderiv ğ•œ f y)
m âˆˆ submonoid.closure S
f â‰« category_theory.is_filtered.to_sup O H mY = category_theory.is_filtered.to_sup O H mX
torus_integrable (-f) c R
â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta n K L) = 1
(polynomial.cyclotomic' n R).degree = â†‘(n.totient)
function.surjective â‡‘(c.mk')
v.int_valuation_def â†‘x â‰  0
cont_diff_on ğ•œ n (Î» (x : E), (f x, g x)) s
cardinal.mk Îº = cardinal.mk Î¹
monotone (Î» (n : â„•), f^[n] x)
add_le_cancellable a
âˆ«â» (a : Î±), f a * T.indicator (Î» (_x : Î±), c) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), T.indicator (Î» (_x : Î±), c) a âˆ‚Î¼
function.surjective (quot.mk r)
âˆƒ (y : Î²) (H : y âˆˆ t), â†‘((finset.filter (Î» (x : Î±), f x = y) s).card) < b
(g.to_continuous_map_on (set.Icc (-âˆ¥fâˆ¥) âˆ¥fâˆ¥)).comp â†‘f.attach_bound âˆˆ A
metric.diam (â‡‘(convex_hull â„) s) = metric.diam s
group.nilpotency_class (G â§¸ subgroup.center G) = group.nilpotency_class G - 1
o.oangle x y + o.oangle y z + o.oangle z x = 0
â‡‘(hb.rotation (hb.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
â‡‘zmod.Ï‡â‚„ â†‘n = ite (n % 2 = 0) 0 (ite (n % 4 = 1) 1 (-1))
has_mfderiv_at I I'' (g âˆ˜ f) x (g'.comp f')
discrete_topology â†¥t
x ^ m = x ^ (m % n)
âˆƒ (f : partition_of_unity Î¹ X s), f.is_subordinate U
â‡‘polynomial.card_pow_degree (x - z) < a
complete_lattice.independent A
x.equiv y
finite_dimensional.finrank K â†¥(f.range) = finite_dimensional.finrank K V
is_add_monoid_hom (Î» (y : Î³), x * y)
continuous â‡‘f â†” continuous â‡‘(f.linear)
closure (set.Iio a) = set.Iic a
âˆƒ (C : nnreal) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥â‚Š * r ^ n â‰¤ C
a + b < 0
topological_space.second_countable_topology Î±
x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
is_clopen s â†’ frontier s = âˆ…
has_Sup.Sup s = b
measurable g
set.univ.finite
is_integrally_closed R â†” is_integral_closure R R K
âˆƒ (x : R) (H : x â‰  0), â‡‘(algebra_map R K) x âˆˆ I
(G.neighbor_finset v âˆª G.neighbor_finset w).card = 2 * k - Î¼
continuous (convolution f g L Î¼)
cont_diff ğ•œ n (Î» (x : E), (f x).snd)
lie_algebra.is_engelian R L
pi.single i x i' = ite (i' = i) x 0
A.det = A 0 0
list.drop (list.take i (list.map list.length L)).sum (list.take (list.take (i + 1) (list.map list.length L)).sum L.join) = L.nth_le i hi
âˆƒ (V : set M), is_open V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U
(finset.Ico 1 (n + 1)).sum (Î» (k : â„•), â†‘k ^ p) = (finset.range (p + 1)).sum (Î» (i : â„•), bernoulli' i * â†‘((p + 1).choose i) * â†‘n ^ (p + 1 - i) / (â†‘p + 1))
algebra.finite_type R A â†” algebra.finite_presentation R A
polish_space.is_clopenable s
|v - (generalized_continued_fraction.of v).convergents n| â‰¤ 1 / (b * (generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators n)
cont_mdiff_within_at (I.prod J) (I'.prod J') n (prod.map f g) (s Ã—Ë¢ r) p
(âˆ f) = (fintype.elems Î¹).inf f
uniform_inducing f
1.factor_multiset = 0
is_atom a â†’ is_coatom (â‡‘order_dual.to_dual a)
Â¬b âŠ‚ a
âˆƒ (Q : sylow p G), P â‰¤ â†‘Q
monoid.fg M â†” âˆƒ (S : set M), submonoid.closure S = âŠ¤ âˆ§ S.finite
has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) s b
category_theory.has_lifting_property i (category_theory.arrow.mk p.hom)
nonempty (V â‰ƒâ‚—[K] V')
strict_mono real.sinh
tendsto_uniformly (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ f) p
âˆ« (x : â„) in a..b, real.sin x * real.cos x = (real.sin b ^ 2 - real.sin a ^ 2) / 2
âˆƒ (v' : shrinking_lemma.partial_refinement u s), v < v'
linear_independent Kâ‚ v
function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 1 â†” a = 1
âˆƒ (i : â„•), j < c.size_up_to i.succ âˆ§ i < c.length
true
finite_dimensional K V
has_sum (Î» (n : â„•), âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z) (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)
âˆ« (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ« (y : Î²), âˆ« (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
hb.oangle 0 x = 0
category_theory.cover_preserving Hld.induced_topology K G
f = g â†” âˆ€ (i : Î¹), â‡‘f i = â‡‘g i
analytic_at â„‚ f c
X.Ïƒ i â‰« X.Î´ i.succ = ğŸ™ (X.obj (opposite.op (simplex_category.mk n)))
function.injective (Î» (_x : G), _x +áµ¥ p)
function.involutive (has_mul.mul (equiv.swap i j))
tendsto_locally_uniformly F f p â†” tendsto_uniformly F f p
f' =o[l] g â†’ (Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] g
âˆƒ (i : Î¹), i âˆˆ s1 âˆ© s2
a * d + b * c < a * c + b * d
free_group.red L (free_group.reduce L)
subring.closure s â‰¤ subring.closure t
âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ linear_order.max C 0
filter.tendsto (Î» (x : â„), f x / g x) filter.at_top l
uniformity Î³ = â¨… (Îµ : ennreal) (H : Îµ > 0), filter.principal {p : Î³ Ã— Î³ | has_edist.edist p.fst p.snd < Îµ}
â‡‘witt_vector.verschiebung (x * â‡‘witt_vector.frobenius y) = â‡‘witt_vector.verschiebung x * y
m = m'
cauchy_seq s
padic_norm_e q â‰  padic_norm_e r â†’ padic_norm_e (q + r) = linear_order.max (padic_norm_e q) (padic_norm_e r)
â†‘(is_fraction_ring.denom A r) âˆ£ p.leading_coeff
â‡‘f (a * b) = â‡‘f a * â‡‘f b
is_preconnected s â†” âˆ€ (u v : set Î±), is_closed u â†’ is_closed v â†’ s âŠ† u âˆª v â†’ u âˆ© v = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v
â‡‘(â‡‘(hV.linear_isometry_equiv hV') (Wâ‚€.sum (Î» (i : Î¹), â‡‘(V i)))) = â‡‘Wâ‚€
a * b â‰¤ a ^ p / ennreal.of_real p + b ^ q / ennreal.of_real q
â†‘â†‘a = a
category_theory.epi f
r x y
x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
r â€¢ 0 = 0
continuous (tangent_bundle.proj I M)
disjoint (â‡‘f a) (â‡‘f b)
antitone (f âŠ“ g)
(ideal.map (algebra_map R S) I).is_prime
algebraic_geometry.structure_sheaf.to_stalk â†¥(opposite.unop (opposite.op (algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X)))) (â‡‘(X.to_Î“_Spec_SheafedSpace.base) x) â‰« algebraic_geometry.PresheafedSpace.stalk_map X.to_Î“_Spec_SheafedSpace x = X.Î“_to_stalk x
has_dist.dist (f z) (f c) â‰¤ Râ‚‚ / Râ‚ * has_dist.dist z c
(category_theory.limits.is_colimit.of_nat_iso.colimit_cocone h).extend (category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone h s) = s
filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© ({x} + r â€¢ t)) / â‡‘Î¼ ({x} + r â€¢ t)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
(linear_map.trace R M).comp (dual_tensor_hom R M M) = contract_left R M
has_inner.inner (x + y) (x - y) = 0 â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
âˆƒ (x : Î±) (H : x âˆˆ s), âˆ€ (t : set Î±), t âˆˆ nhds_within x s â†’ 0 < â‡‘m t
x / y âˆˆ H
s.noncomm_sum (f + g) _ = s.noncomm_sum f comm_ff + s.noncomm_sum g comm_gg
group_algebra.average k G * finsupp.single g 1 = group_algebra.average k G
â‡‘linear_map.det â†‘(hb.conj_lie.to_linear_equiv) = -1
irrational golden_ratio
even n â†’ even n.nat_abs
â‡‘f '' S = â‡‘(f.symm) â»Â¹' S
y âˆˆ powers x â†’ z âˆˆ powers x â†’ y * z âˆˆ powers x
c = d
has_strict_fderiv_at f f' x
(âˆ€ (x : L), x âˆˆ l â†’ x âˆˆ S) â†’ l.prod âˆˆ S
r âˆˆ resolvent_set R a â†” is_unit (resolvent a r)
Â¬a â‹– b â†” âˆƒ (c : Î±), a < c âˆ§ c < b
âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) + g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ + âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
f = g
a < c
a * b â‰¤ a ^ â†‘p / p + b ^ â†‘q / q
cardinal.mk â„ = cardinal.continuum
w + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y = z â†” w = â‡‘f â†‘y + z
box_integral.has_integral I l f vol y
finite_dimensional K â†¥(submodule.span K A)
âˆƒ (g : Î± â†’ E'), lipschitz_with (lipschitz_extension_constant E' * K) g âˆ§ set.eq_on f g s
e.trans f â‰ˆ e'.trans f'
(â¨† (i : Î¹), f i) = b
â‡‘(euclidean_geometry.orthogonal_projection s) (v +áµ¥ p) = âŸ¨p, hpâŸ©
âˆƒ (n : â„•) (f : fin n â†’ Ïƒ) (hf : function.injective f) (q : mv_polynomial (fin n) R), p = â‡‘(mv_polynomial.rename f) q
âˆ¥Uâˆ¥ â‰¤ 1
f = g
Î¼.weakly_regular
exp ğ•‚ = exp ğ•‚'
has_deriv_within_at f f' (set.Ioo x y) x â†’ has_deriv_within_at f f' (set.Ioi x) x
âˆƒ (b' : set Î¹) (H : b' âŠ† b), b'.finite âˆ§ s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ b'), c i
â‡‘(f.lift hg) z * w = v â†” â‡‘g (f.sec z).fst * w = â‡‘g â†‘((f.sec z).snd) * v
x.sieve_extend f _ = x f hf
L.length â‰¤ L.sum
filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
(âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
g * f = 1
(Î» (y : E Ã— E), f y.fst - f y.snd - â‡‘(p 1) (Î» (_x : fin 1), y.fst - y.snd)) =O[nhds (x, x)] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.sndâˆ¥
u n = E.mk_sol init n
âˆ« (x : G), f (x + g) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
cont_diff ğ•œ â†‘(n + 1) f â†” differentiable ğ•œ f âˆ§ cont_diff ğ•œ â†‘n (Î» (y : E), fderiv ğ•œ f y)
âˆƒ (g : Î± â†’ ennreal), measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼
âˆƒ (n : â„•), nonempty (basis (fin n) R â†¥N)
s.sum (Î» (x : Î±), f x) = 0
P x hx
smul_comm_class Î² N Î±
M.nondegenerate
e.symm â‰ˆ e'.symm
emetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t
mul_action.stabilizer.submonoid R m = mul_action.stabilizer.submonoid R â†‘m
B.sum (Î» (s : finset Î±), s.card) â‰¤ fintype.card Î± * n
group.is_nilpotent G
a â‰¤ bâ»Â¹ â†’ b â‰¤ aâ»Â¹
proper_space Î²
has_edist.edist s t = emetric.Hausdorff_edist â†‘s â†‘t
0 âˆˆ s
(measure_theory.outer_measure.mk_metric'.pre m r).trim = measure_theory.outer_measure.mk_metric'.pre m r
âˆƒ (n o : â„•) (hno : n â‰¤ o) (bO : basis (fin o) R â†¥O) (bN : basis (fin n) R â†¥N) (a : fin n â†’ R), âˆ€ (i : fin n), â†‘(â‡‘bN i) = a i â€¢ â†‘(â‡‘bO (â‡‘(fin.cast_le hno) i))
âˆƒ (V : set Î±) (hV : is_clopen V), x âˆˆ V âˆ§ V âŠ† U
A.transpose.has_orthogonal_cols â†” A.has_orthogonal_rows
cont_diff_within_at ğ•œ n (prod.map f g) (s Ã—Ë¢ t) p
â‡‘(reflection (submodule.map â†‘(f.to_linear_equiv) K)) x = â‡‘f (â‡‘(reflection K) (â‡‘(f.symm) x))
has_inner.inner (x + y) (x + y) = has_inner.inner x x + has_inner.inner x y + has_inner.inner y x + has_inner.inner y y
is_add_group_hom (Î» (a : Î±), -f a)
affine.simplex.altitude tâ‚‚ jâ‚‚ = affine_span â„ {tâ‚.points iâ‚, tâ‚.points iâ‚‚}
function.semiconj (Î» (x : Î±), â¨† (g' : G), â‡‘(â‡‘fâ‚ g')â»Â¹ (â‡‘(â‡‘fâ‚‚ g') x)) â‡‘(â‡‘fâ‚‚ g) â‡‘(â‡‘fâ‚ g)
1 â‰¤ a * b
âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (y : E), y âˆˆ metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥f (x + y) - p.partial_sum n yâˆ¥ â‰¤ C * a ^ n
zmod.legendre_sym p a = -1 â†” Â¬is_square â†‘a
di.extend f (i a) = f a
polynomial.eval x (s.prod (Î» (j : Î¹), p j)) = s.prod (Î» (j : Î¹), polynomial.eval x (p j))
is_min a â†’ a = âŠ¥
category_theory.is_iso f â†” âˆ€ (x : â†¥X), category_theory.is_iso ((Top.presheaf.stalk_functor C x).map f)
metric.thickening Îµ (metric.cthickening Î´ s) âŠ† metric.thickening (Îµ + Î´) s
category_theory.is_pushout hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚
â‡‘f (a + b) = â‡‘f a + â‡‘f b
Î¼ = Î½
s.sum (Î» (x : Î²), â‡‘(A.cramer) (Î» (j : n), f j x) i) = â‡‘(A.cramer) (Î» (j : n), s.sum (Î» (x : Î²), f j x)) i
(list.take j L).nth_le i hi = L.nth_le i _
Â¬has_sbtw.sbtw c b a
â‡‘(o.rotation (o.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
summable (Î» (x : Î±), âˆ¥f xâˆ¥) â†” summable f
semiconj_by a â†‘xâ»Â¹ â†‘yâ»Â¹
â‡‘linear_map.det (â†‘e.comp (f.comp â†‘(e.symm))) = â‡‘linear_map.det f
minpoly â„¤ Î¼ âˆ£ polynomial.cyclotomic n â„¤
isometry has_star.star
measure_theory.measure_preserving â‡‘(â‡‘matrix.to_lin' t.to_matrix) measure_theory.measure_space.volume measure_theory.measure_space.volume
continuous coe_fn
category_theory.mono k
function.injective â‡‘f
(Î» (y : E Ã— E), f y.fst - f y.snd - â‡‘(p 1) (Î» (_x : fin 1), y.fst - y.snd)) =O[filter.principal (emetric.ball (x, x) r')] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.sndâˆ¥
0 < a + b
same_ray R vâ‚ vâ‚‚
category_theory.limits.has_finite_wide_pushouts C
p.apply_composition c (function.update v j z) = function.update (p.apply_composition c v) (c.index j) (â‡‘(p (c.blocks_fun (c.index j))) (function.update (v âˆ˜ â‡‘(c.embedding (c.index j))) (c.inv_embedding j) z))
(closure s).nonempty â†’ s.nonempty
x â‰¤ y
p i
f a = b
âˆƒ (b : â†¥M), âˆ€ (i : Î¹), is_localization.is_integer R (â†‘b â€¢ f i)
(Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s)) =áµ[Î¼] 0
l.nodup â†’ l.sublists'.nodup
E - E âˆˆ nhds 0
â…I,Nâ† = ((lie_module.to_module_hom R L M).comp (tensor_product.lie_module.map_incl I N)).range
is_integral R (B.basis.to_matrix â‡‘(B'.basis) i j)
measure_theory.unif_integrable f p Î¼
r âˆˆ f.ker â†” â‡‘f r = 0
t.sum (Î» (i : Î¹), f i) âˆˆ s
x â‰¤ y
Ï† = Ïˆ
has_strict_fderiv_at f (fderiv ğ•‚ f x) x
submodule.span R (â‡‘f â»Â¹' s) â‰¤ submodule.comap f (submodule.span Râ‚‚ s)
is_add_submonoid (f '' s)
convex_on â„ D f
âˆ® (z : â„‚) in C(c, R), f z = 0
s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i)
is_ring_hom id
strict_convex_on ğ•œ s (f âŠ” g)
1 âˆˆ S
a * a * aâ»Â¹ = a
algebra.discr â„š â‡‘b = algebra.discr â„š â‡‘b'
linear_order.min p.radius q.radius â‰¤ (p + q).radius
setoid.ker quotient.mk = r
Î¼.inner_regular is_closed is_open
â‡‘clifford_algebra_complex.to_complex (â‡‘clifford_algebra.involute c) = â‡‘(star_ring_end â„‚) (â‡‘clifford_algebra_complex.to_complex c)
p.remove_zero.right_inv i = p.right_inv i
ae_measurable f' (Î¼.restrict s)
n.totient = n.factorization.prod (Î» (p k : â„•), p ^ (k - 1) * (p - 1))
X.Ïƒ (â‡‘fin.cast_succ i) â‰« X.Ïƒ j = X.Ïƒ j.succ â‰« X.Ïƒ i
a * d + b * c â‰¤ a * c + b * d
strict_anti (Î» (n : â„•), f^[n] x)
unique_mdiff_on I' (e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s)
strict_concave_on â„ D f
measure_theory.measure.map (Î» (z : G Ã— G), (z.snd * z.fst, (z.fst)â»Â¹)) (Î¼.prod Î½) = Î¼.prod Î½
continuous_at has_inv.inv A
x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
monotone (Î» (x : Î²), f x * g x)
(finset.range n).sum (Î» (i : â„•), f (i + 1) - f i) = f n - f 0
a * x * x + b * x + c â‰  0
affine_independent â„ p
(vector.scanl f b v).to_list = list.scanl f b v.to_list
âˆƒ (f : (â„• â†’ â„•) â†’ Î±), continuous f âˆ§ function.surjective f
(âˆƒ (g : Gâ‚€) (hg : g â‰  0), p g hg) â†” âˆƒ (g : Gâ‚€Ë£), p â†‘g _
x = â‡‘(o.rotation Î¸) x â†” Î¸ = 0
â‡‘(affine_equiv.point_reflection k x) y = y â†” y = x
e.restr s â‰ˆ e'.restr s
function.bijective (function.comp g)
measurable (Î» (x : Î±), âˆ‘' (i : Î¹), f i x)
Â¬linear_independent â„ (option.elim Ï†' f')
u â€¢ v = -v
{h := â†‘((generalized_continued_fraction.of q).h), s := seq.map (generalized_continued_fraction.pair.map coe) (generalized_continued_fraction.of q).s} = generalized_continued_fraction.of v
r â€¢ x * s â€¢ y = (r * s) â€¢ (x * y)
add_submonoid.closure {p : polynomial R | âˆƒ (n : â„•) (a : R), p = â‡‘(polynomial.monomial n) a} = âŠ¤
v.int_valuation_def r â‰¤ â†‘(â‡‘multiplicative.of_add (-â†‘n)) â†” v.as_ideal ^ n âˆ£ ideal.span {r}
(vector.scanl f b v).val = list.scanl f b v.val
category_theory.limits.has_limits_of_shape J' C
Î· â‰« Î¸ â‰« Î¹ = (Î· â‰« Î¸) â‰« Î¹
e.is_image s t â†’ e.to_local_equiv.source âˆ© â‡‘e â»Â¹' t = e.to_local_equiv.source âˆ© s
filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I âŠ¤) (nhds y)
has_fderiv_within_at f f' s x
con_gen r â‰¤ c
y = category_theory.Ran_is_sheaf_of_cover_lifting.glued_section hu â„± hS hx
b â‰¤ b ^ 2
a âˆˆ s
1 < â‡‘complex.norm_sq â†‘(modular_group.T ^ n â€¢ z)
(âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.nat.antidiagonal n).sum (Î» (kl : â„• Ã— â„•), f kl.fst * g kl.snd)
a = b
(g * g).is_three_cycle
category_theory.limits.initial_mono_class C
is_domain S
âˆƒ (Î¸ : real.angle), bâ‚‚ = b.map (hb.conj_lie.trans (hb.rotation Î¸)).to_linear_equiv
ennreal.of_real âˆ¥f - gâˆ¥ = âˆ«â» (x : Î±), â†‘âˆ¥â‡‘f x - â‡‘g xâˆ¥â‚Š âˆ‚Î¼
0 < polynomial.eval x (polynomial.cyclotomic n R)
has_deriv_at f (g y) y
x < t
p âˆˆ polynomial.lifts f â†” p âˆˆ polynomial.lifts_ring f
a < b - c
s.prod (Î» (a : Î±), f (g a)) = (finset.image g s).prod (Î» (b : Î³), f b ^ (finset.filter (Î» (a : Î±), g a = b) s).card)
subfield.closure s â‰¤ t â†” s âŠ† â†‘t
filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_bot
s.circumcenter = finset.centroid â„ finset.univ s.points
âˆƒ (i : Î¹) (H : i âˆˆ s) (j : Î¹) (H : j âˆˆ s) (h : i â‰  j), (t i âˆ© t j).nonempty
summable g
finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary f (g âˆ˜ â‡‘Ïƒ)
âˆƒ (Î¹ : Type u) (c : Î¹ â†’ Î±) (r r' : Î¹ â†’ â„), (âˆ€ (i : Î¹), c i âˆˆ s âˆ§ 0 < r i âˆ§ r i < r' i âˆ§ r' i < R (c i)) âˆ§ locally_finite (Î» (i : Î¹), metric.ball (c i) (r' i)) âˆ§ s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r i)
monoid.closure s âŠ† monoid.closure t
â‡‘(affine_map.line_map (f a) (f b)) r < f (â‡‘(affine_map.line_map a b) r) â†” slope f (â‡‘(affine_map.line_map a b) r) b < slope f a (â‡‘(affine_map.line_map a b) r)
f =o[nhds_within a {a}á¶œ] Î» (x : ğ•œ), (x - a)â»Â¹
â‡‘(f j k hjk) (â‡‘(f i j hij) x) = â‡‘(f i k _) x
âˆƒ (is : finset Î¹) {n : set X} (hnâ‚ : n âˆˆ nhds x) (hnâ‚‚ : n âŠ† â‹‚ (i : Î¹) (H : i âˆˆ is), U i), âˆ€ (z : X), z âˆˆ n â†’ function.mul_support (Î» (i : Î¹), f i z) âŠ† â†‘is
P G
category_theory.limits.has_coequalizers C
â‡‘f (a + b) = â‡‘f a + â‡‘f b
â‡‘(probability_theory.cond Î¼ s) t = (â‡‘Î¼ s)â»Â¹ * â‡‘Î¼ (s âˆ© t)
(hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.biproduct.is_limit f)).inv = category_theory.limits.biproduct.desc b.Î¹
fintype.card R â‰¤ p.nat_degree * (finset.image (Î» (x : R), polynomial.eval x p) finset.univ).card
discrim a b c < 0
(â‹ƒ (i : Î¹) (H : i âˆˆ s), t i H).finite
nonempty (E â‰ƒL[ğ•œ] F)
f (x * y) = f x * f y
p âˆˆ (a * b).factors
is_max a â†’ is_min (â‡‘order_dual.of_dual a)
F.sections.nonempty
finset.image g (finset.imageâ‚‚ f s t) = finset.imageâ‚‚ f' (finset.image g' t) s
â‡‘f 1 â‰  0
uniform_embedding f â†” function.injective f âˆ§ uniform_continuous f âˆ§ âˆ€ (Î´ : ennreal), Î´ > 0 â†’ (âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î±}, has_edist.edist (f a) (f b) < Îµ â†’ has_edist.edist a b < Î´)
algebra.finite_type R (add_monoid_algebra R G) â†” add_group.fg G
x + t â€¢ y âˆˆ interior s
has_deriv_at complex.sinh (complex.cosh x) x
affine_subspace.direction_of_nonempty h = s.direction
f âˆˆ s.dfinsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘f i âˆˆ â‡‘t i
padic_norm p (q * r) = padic_norm p q * padic_norm p r
nonempty (field Î±) â†” is_prime_pow (fintype.card Î±)
â‡‘(reflection Ká—®) v = -v
bdd_above s
algebra.discr â„š â‡‘((is_primitive_root.power_basis â„š hÎ¶).basis) = algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis)
emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s
has_inner.inner (v - â†‘(â‡‘(orthogonal_projection K) v)) w = 0
has_dist.dist t.orthocenter (â‡‘(euclidean_geometry.reflection (affine_span â„ (t.points '' {iâ‚, iâ‚‚}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€á¶  (a : set Î±) in v.filter_at x, 0 < â‡‘Î¼ a
filter.tendsto f (filter.comap g (nhds d)) (nhds a)
a âŠ‚ b
is_preconnected (â‹ƒ (n : Î¹), s n)
s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i * g i) â†” monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
v â‰¤ shrinking_lemma.partial_refinement.chain_Sup c hc ne hfin hU
M.det â‰  0 â†’ M.nondegenerate
filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.Iio a)) l
continuous (Î» (t : Y), (Î³ t).extend (f t))
1 â‰¤ a * b
â‡‘(hT.diagonalization_basis hn) (â‡‘T v) i = â†‘(hT.eigenvalues hn i) * â‡‘(hT.diagonalization_basis hn) v i
maximals r s = t
set.eq_on f g (complex.re â»Â¹' set.Icc a b)
metric.Hausdorff_dist s t = 0 â†” s = t
fin.init (function.update q (fin.last n) z) = fin.init q
dense s â†” âˆ€ (o : set Î±), o âˆˆ b â†’ o.nonempty â†’ (o âˆ© s).nonempty
H = K
E2.fixing_subgroup â‰¤ E1.fixing_subgroup
a â‰  b
a * b < 1
p -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) âˆˆ (s.direction)á—®
hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = â†‘real.pi
false
category_theory.epi c.Ï€
â‡‘(linear_map.to_matrix b b') linear_map.id = b'.to_matrix â‡‘b
s âˆˆ nhds_within a (set.Ici a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Icc a u âŠ† s
measure_theory.analytic_set (f '' s)
(g â€¢ m)â»Â¹ = gâ»Â¹ â€¢ mâ»Â¹
âˆ« (x : E), f x * (measure_theory.pdf X Â«â„™Â» Î¼ x).to_real âˆ‚Î¼ = âˆ« (x : Î±), f (X x) âˆ‚Â«â„™Â»
measure_theory.integrable F' Î¼ âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
E.map (alg_hom.id K L) = E
(add_con.ker_lift f).mrange = f.mrange
bdd_above (set.range f)
hb.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x
o.oangle x x = 0
nonempty (V â‰ƒâ‚—[K] V') â†” (module.rank K V).lift = (module.rank K V').lift
s âˆˆ nhds a â†” âˆƒ (l u : Î±), a âˆˆ set.Ioo l u âˆ§ set.Ioo l u âŠ† s
(Q i).anisotropic
a + x = y + a
category_theory.limits.cokernel.Ï€ f = 0
hb.oangle x z - hb.oangle x y = hb.oangle y z
summable (Î» (i : Î¹), â‡‘(V i) (f i)) â†” summable (Î» (i : Î¹), âˆ¥f iâˆ¥ ^ 2)
real.sqrt â†‘a â‰¤ â†‘(nat.sqrt a) + 1
s1.direction < s2.direction
measure_theory.integrable_on (Î» (Î¸ : fin n â†’ â„), finset.univ.prod (Î» (i : fin n), â†‘(R i) * complex.exp (â†‘(Î¸ i) * complex.I) * complex.I) â€¢ f (torus_map c R Î¸)) (set.Icc 0 (Î» (_x : fin n), 2 * real.pi)) measure_theory.measure_space.volume
âˆƒ (f : V â†’â‚—[K] K) (H : f â‰  0), p â‰¤ f.ker
cont_diff_within_at ğ•œ n (f âˆ˜ â‡‘g) (â‡‘g â»Â¹' s) x
f.nat_degree â‰¤ N â†’ P f
(r âŠ“ s).rel = r.rel âŠ“ s.rel
is_connected (â‹ƒ (n : Î²), s n)
has_fpower_series_on_ball f (p.change_origin y) (x + y) (r - â†‘âˆ¥yâˆ¥â‚Š)
â†‘u â‰¤ nhds x â†” x = mjoin u
is_open_map quotient.mk
fin.init (function.update q (â‡‘fin.cast_succ i) y) = function.update (fin.init q) i y
âˆƒ (râ‚ râ‚‚ : R), 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y
measure_theory.measurably_separable s t
â‡‘(witt_vector.map f) (â‡‘witt_vector.verschiebung x) = â‡‘witt_vector.verschiebung (â‡‘(witt_vector.map f) x)
pythagorean_triple (k * x) (k * y) (k * z) â†” pythagorean_triple x y z
emetric.inf_edist (Î¦ x) (Î¦ '' t) = emetric.inf_edist x t
t.prod (Î» (i : Î¹), g i) âˆˆ t.prod (Î» (i : Î¹), f i)
monotone (Î» (x : Î±), linear_order.min (f x) (g x))
finite_dimensional.finrank ğ•œ â†¥(Kâ‚á—® âŠ“ Kâ‚‚) = n
module.projective R P
âˆ¥bounded_continuous_function.const Î± bâˆ¥ â‰¤ âˆ¥bâˆ¥
â†‘a.val = a
t.sum (Î» (i : Î¹), w i â€¢ f (p i)) â‰¤ f (t.sum (Î» (i : Î¹), w i â€¢ p i))
emetric.Hausdorff_edist s t â‰¤ emetric.diam (s âˆª t)
âˆ¥normed_group_hom.id Vâˆ¥ = 1
emetric.inf_edist x t â‰¤ emetric.Hausdorff_edist s t
category_theory.limits.has_limit F
m < b ^ (b.digits m).length
cardinal.ord âˆ˜ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}
polynomial.eval r (p * (polynomial.X - â‡‘polynomial.C r)) = 0
(âˆ f) = (fintype.elems Î¹).sup f
p x hx
(x.some_basis h).orientation = x
cont_mdiff_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s x â†’ cont_diff_within_at ğ•œ n f s x
function.injective â‡‘f
real.sinh x = (real.exp x - real.exp (-x)) / 2
t.prod (Î» (i : Î¹), f i) âˆˆ s
convex ğ•œ (â‡‘f â»Â¹' s)
(finsupp.on_finset s f hf).prod g = s.prod (Î» (a : Î±), g a (f a))
category_theory.limits.has_finite_biproducts C
function.update g i a âˆ˜ f = g âˆ˜ f
cont_diff_at ğ•œ n prod.fst p
â‡‘f (Î» (i : Î¹), finset.univ.sum (Î» (j : Î± i), g i j)) = finset.univ.sum (Î» (r : Î  (i : Î¹), Î± i), â‡‘f (Î» (i : Î¹), g i (r i)))
p qâ‚ qâ‚‚
filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
continuous_within_at f s x â†’ continuous_within_at f (has_insert.insert x s) x
â‡‘linear_equiv.det (â‡‘rotation a).to_linear_equiv = 1
S.pointed
measure_theory.locally_integrable f Î¼
algebra.is_algebraic L A
polish_space â†¥s
function.surjective â‡‘f â†’ category_theory.epi f
â†‘â†‘a = a
(âˆ€ (x y : Î  (n : â„•), E n), has_dist.dist (f x) (f y) â‰¤ has_dist.dist x y) â†” âˆ€ (x y : Î  (n : â„•), E n) (n : â„•), y âˆˆ pi_nat.cylinder x n â†’ has_dist.dist (f x) (f y) â‰¤ (1 / 2) ^ n
âˆ¥âˆ‘' (i : Î¹), f iâˆ¥â‚Š â‰¤ a
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
âˆ«â» (a : Î±), filter.at_top.liminf (Î» (n : â„•), f n a) âˆ‚Î¼ â‰¤ filter.at_top.liminf (Î» (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼)
a / c < b / d â†’ (a * d - b * c) / (c * d) < 0
âˆƒ (g : E â†’â‚—[â„] â„), (âˆ€ (x : â†¥(f.domain)), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ€ (x : E), â‡‘g x â‰¤ N x
tendsto_locally_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n (y - x)) f filter.at_top (emetric.ball x r)
âˆ¥f.extend e h_dense _âˆ¥ â‰¤ â†‘N * âˆ¥fâˆ¥
differentiable_on â„ (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s
a â‰  0
â‡‘(v.valuation) (â‡‘(algebra_map R K) r) = â‡‘(v.int_valuation) r
âˆ¥fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C
x âˆˆ monoid.closure (s âˆª t) â†” âˆƒ (y : M) (H : y âˆˆ monoid.closure s) (z : M) (H : z âˆˆ monoid.closure t), y * z = x
is_cau_seq has_norm.norm u â†” cauchy_seq u
category_theory.limits.has_colimit F
â‡‘((mv_polynomial.eval (Î» (p : m Ã— m), A p.fst p.snd)).map_matrix) (matrix.mv_polynomial_X m m R) = A
x â‰  0 â†’ (âˆƒ! (y : R), x * y = 1)
âˆƒ! (l : s.X âŸ¶ t.X), âˆ€ (j : J), l â‰« t.Ï€.app j = s.Ï€.app j
(â¨… (K : submodule ğ•œ E) (H : K âˆˆ s), Ká—®) = (has_Sup.Sup s)á—®
continuous (Î» (g : G), g + h + -g)
ring_hom_inv_pair â†‘e â†‘(e.symm)
measurable f
âˆƒ (Î¸ : real.angle), bâ‚‚ = b.map (hb.rotation Î¸).to_linear_equiv
(âˆƒ (g : Gâ‚€Ë£), p g) â†” âˆƒ (g : Gâ‚€) (hg : g â‰  0), p (units.mk0 g hg)
âˆƒ (y : Î±), function.is_fixed_pt f y âˆ§ filter.tendsto (Î» (n : â„•), f^[n] x) filter.at_top (nhds y) âˆ§ âˆ€ (n : â„•), has_edist.edist (f^[n] x) y â‰¤ has_edist.edist x (f x) * â†‘K ^ n / (1 - â†‘K)
(uniformity Î±).has_basis p (Î» (x : Î²), {p : Î± Ã— Î± | has_edist.edist p.fst p.snd â‰¤ f x})
is_open_map prod.fst
(âˆƒ (fs : finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = x), v = â‡‘(fs.weighted_vsub_of_point p b) w) â†” âˆƒ (fs : finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = x), v = â‡‘(fs.weighted_vsub_of_point (Î» (i : â†¥s), p â†‘i) b) w
is_seq_closed s â†’ is_closed s
is_path_connected (coe â»Â¹' W)
is_algebraic L x
Ï†.order = âŠ¤ â†” Ï† = 0
s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
s.sum (Î» (i : Î±), g i (f i)) = t.sum (Î» (i : Î±), g i (â†‘s.indicator f i))
measure_theory.integrable_at_filter f l Î¼
filter.tendsto has_abs.abs filter.at_bot filter.at_top
filter.mapâ‚‚ m (filter.map n f) g = filter.map n' (filter.mapâ‚‚ m' f g)
â‡‘Î¼ â†‘s = 0
â‡‘(â‡‘matrix.to_lin' (M.mul N)) x = â‡‘(â‡‘matrix.to_lin' M) (â‡‘(â‡‘matrix.to_lin' N) x)
polynomial.cyclotomic n R = (polynomial.X ^ n - 1) /â‚˜ n.proper_divisors.prod (Î» (i : â„•), polynomial.cyclotomic i R)
dimH (set.range f) â‰¤ dimH set.univ / â†‘r
â‡‘Î¼ s â‰¤ â‡‘Î¼ t
f x = 1
category_theory.limits.has_equalizers C
antitone_on f s â†’ monotone_on (â‡‘order_dual.to_dual âˆ˜ f) s
âˆ¥finset.univ.prod (Î» (j : fin (n + 1)), I.upper j - I.lower j) â€¢ â‡‘f' (pi.single i 1) - (box_integral.integral (I.face i) âŠ¥ (f âˆ˜ i.insert_nth (I.upper i)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (f âˆ˜ i.insert_nth (I.lower i)) box_integral.box_additive_map.volume)âˆ¥ â‰¤ 2 * Îµ * â†‘c * finset.univ.prod (Î» (j : fin (n + 1)), I.upper j - I.lower j)
finset.univ.sum (Î» (i : Î¹), f i * g i) < finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â†” Â¬antivary (f âˆ˜ â‡‘Ïƒ) g
(finset.subtype p s).sum (Î» (x : subtype p), f â†‘x) = s.sum (Î» (x : Î±), f x)
is_regular g
filter.tendsto f k l â†” âˆ€ (x : â„• â†’ Î±), filter.tendsto x filter.at_top k â†’ filter.tendsto (f âˆ˜ x) filter.at_top l
hf.degree = f.nat_degree
is_add_monoid_hom (Î» (a : Î±), -f a)
topological_space.separable_space Î²
list.drop i (list.take (i + 1) L) = [L.nth_le i hi]
f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
o.oangle y (â‡‘(o.rotation (o.oangle x y)) x) = 0
(Ï€.restrict J).boxes = Ï€.boxes
pairwise (disjoint on Î» (n : Î±), set.Ioo (f n) (f (order.succ n)))
disjoint (residual â„) measure_theory.measure_space.volume.ae
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.weighted_vsub pâ‚) w
(a * b).factorization = a.factorization + b.factorization
(nhds c).has_basis (Î» (f : smooth_bump_function I c), tsupport â‡‘f âŠ† s) (Î» (f : smooth_bump_function I c), function.support â‡‘f)
(f =o[l] Î» (x : Î±), -g' x) â†’ f =o[l] g'
category_theory.is_iso f â†” f â‰  0
âˆƒ (b : â†¥M), âˆ€ (a : S), a âˆˆ s â†’ is_localization.is_integer R (â†‘b â€¢ a)
filter.tendsto (Î» (i : Î¹), convolution (Î» (x : G), (Ï† i).normed Î¼ x) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) l (nhds (g xâ‚€))
unique_diff_within_at ğ•œ (f '' s) (f x)
complete_lattice.independent (f âˆ˜ coe) â†’ s.sup_indep f
filter.tendsto â‡‘complex.norm_sq (filter.cocompact â„‚) filter.at_top
f.liminf u = a
fâ‚ = fâ‚‚
measurable_space.pi = measurable_space.generate_from (set.univ.pi '' set.univ.pi C)
(Î» (y : E), f (x + y) - p.partial_sum n y) =O[nhds 0] Î» (y : E), âˆ¥yâˆ¥ ^ n
|x - a| â‰¤ |b - a|
(e.map f).orientation = -e.orientation â†” â‡‘linear_map.det â†‘f < 0
t2_space Î± â†” âˆ€ {x y : Î±}, (nhds x âŠ“ nhds y).ne_bot â†’ x = y
P.fg â†” âˆƒ (S : set M), submonoid.closure S = P âˆ§ S.finite
v = (generalized_continued_fraction.of v).convergents n
finsum (Î» (i : Î±), f i) = finsum (Î» (j : Î²), g j)
rack.pre_envel_group_rel' R a b â†’ rack.pre_envel_group_rel R a b
â†‘(zmod.legendre_sym p a) = â†‘a ^ (p / 2)
â‡‘(polynomial.aeval M) p = â‡‘(polynomial.aeval M) (p %â‚˜ M.charpoly)
finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index n), f i) = finset.univ.sum (Î» (i : fin (n + 1)), f (affine.simplex.points_with_circumcenter_index.point_index i)) + f affine.simplex.points_with_circumcenter_index.circumcenter_index
uniform_continuous â‡‘f
category_theory.essentially_small C
1 < a * b
-a â‰¤ a
is_preconnected s
conformal_at f z â†” (differentiable_at â„‚ f z âˆ¨ differentiable_at â„‚ (f âˆ˜ â‡‘(star_ring_end â„‚)) (â‡‘(star_ring_end â„‚) z)) âˆ§ fderiv â„ f z â‰  0
s.finite
set.surj_on f (metric.closed_ball b Îµ) (metric.closed_ball (f b) (((â†‘(f'symm.nnnorm))â»Â¹ - â†‘c) * Îµ))
âŠ¥ â‹– a â†’ is_atom a
padic_val_nat p 0 = 0
(power_series.X ^ n).order = â†‘n
k âŠ† â†‘(subgroup.closure k)
âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst
finset.centroid k finset.univ p = 2â»Â¹ â€¢ (p 1 -áµ¥ p 0) +áµ¥ p 0
a = b â†’ a âŠ† b
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ + (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real
subsingleton M
(â‡‘(power_series.monomial R n) a).order = â†‘n
â‡‘linear_map.det â†‘f * â‡‘linear_map.det â†‘(f.symm) = 1
(â†‘p + 1) * (finset.range n).sum (Î» (k : â„•), â†‘k ^ p) = polynomial.eval â†‘n (polynomial.bernoulli p.succ) - bernoulli p.succ
((âˆ€ (a : â†¥P), â‡‘g (â‡‘f a) = 0) âˆ§ âˆ€ (b : â†¥Q), â‡‘g b = 0 â†’ (âˆƒ (a : â†¥P), â‡‘f a = b)) â†’ category_theory.exact f g
{x : Î“â‚€ | x < Î³} âˆˆ nhds 0
cont_diff_on ğ•œ n f s â†” âˆ€ (y : F), cont_diff_on ğ•œ n (Î» (x : E), â‡‘(f x) y) s
cont_diff ğ•œ n (Î» (x : E), (f x, g x))
(s.prod (Î» (i : Î¹), f i)).leading_coeff = s.prod (Î» (i : Î¹), (f i).leading_coeff)
e.source âˆ© â‡‘e â»Â¹' s = e'.source âˆ© â‡‘e' â»Â¹' s
s.monge_point = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.monge_point_weights_with_circumcenter n)
âˆƒ (T : C), âˆ€ (X : C), nonempty (T âŸ¶ X)
emetric.ball x (ennreal.of_real Îµ) = metric.ball x Îµ
vector.scanl f b v = b::áµ¥f b v.head::áµ¥vector.nil
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ has_insert.insert a s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
âˆƒ (t : set (Î± Ã— â„)), t.countable âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.fst âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.snd âˆˆ f p.fst) âˆ§ â‡‘Î¼ (s  â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), metric.closed_ball p.fst p.snd) = 0 âˆ§ t.pairwise_disjoint (Î» (p : Î± Ã— â„), metric.closed_ball p.fst p.snd)
âˆƒ (f : V â†’ K), t.sum (Î» (e : V), f e â€¢ e) = 0 âˆ§ âˆƒ (x : V) (H : x âˆˆ t), f x â‰  0
v = 0
set.eq_on f g {z : â„‚ | 0 â‰¤ z.re}
locally_compact_space G
Â¬b < a
(list.permutations_aux2 t ts r ys f).snd = list.map (Î» (x : list Î±), f (x ++ ts)) (list.permutations_aux2 t list.nil list.nil ys id).snd ++ r
tendsto_uniformly F f p â†” filter.tendsto (Î» (q : Î¹ Ã— Î±), (f q.snd, F q.fst q.snd)) (p.prod âŠ¤) (uniformity Î²)
is_scalar_tower N Î± Î²
add_subsemigroup.closure s â‰¤ add_subsemigroup.closure t
measure_theory.unif_integrable (Î» (n : Î¹), g) p Î¼
fourier_subalgebra.separates_points
polynomial.cyclotomic n R â‰  0
-a < 0 â†” 0 < a
s.sup_indep f â†’ complete_lattice.independent (f âˆ˜ coe)
iterated_deriv_within (n + 1) f s x = iterated_deriv_within n (deriv_within f s) s x
p x
cauchy_seq u â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), n â‰¥ N â†’ has_edist.edist (u n) (u N) < Îµ)
is_add_left_regular b
finset.filter (Î» (a : Î²), a = b) s = ite (b âˆˆ s) {b} âˆ…
a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d
category_theory.exponential_ideal i
function.injective â‡‘(â‡‘free_group.lift a)
â‡‘(k.to_map) (â‡‘g x) = â‡‘(k.to_map) (â‡‘g y)
1 âˆˆ s
âˆ¥a ^ nâˆ¥ â‰¤ âˆ¥aâˆ¥ ^ n
â‡‘(witt_vector.ghost_component n) (â‡‘(witt_vector.teichmuller p) r) = r ^ p ^ n
asymptotics.is_O_with c l f g' â†’ asymptotics.is_O_with c l f (Î» (x : Î±), -g' x)
âˆ«â» (x : Î±), F (âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ«â» (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ - âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
filter.tendsto (Î» (x : Î±), r * f x) l filter.at_top
f = g
m âˆˆ S
âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ f x) âˆ§ upper_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), â†‘(g x)) Î¼ âˆ§ âˆ« (x : Î±), â†‘(f x) âˆ‚Î¼ - Îµ â‰¤ âˆ« (x : Î±), â†‘(g x) âˆ‚Î¼
category_theory.is_connected J
cont_mdiff I I' n f â†” continuous f âˆ§ âˆ€ (y : M'), cont_mdiff_on I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' y) âˆ˜ f) (f â»Â¹' (ext_chart_at I' y).source)
ps.pairwise (Î» (p1 p2 : P), has_dist.dist p1 p = has_dist.dist p2 p) â†” ps.pairwise (Î» (p1 p2 : P), has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = has_dist.dist p2 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p))
affine_independent k p
B.nondegenerate â†” (â‡‘bilin_form.to_lin B).ker = âŠ¥
p x y
(âˆ€ (x y : R), â‡‘f (x * y) = â‡‘f x * â‡‘f y) â†” add_monoid_hom.mul.comprâ‚‚ f = (add_monoid_hom.mul.comp f).complâ‚‚ f
add_con_gen r = has_Inf.Inf {s : add_con M | âˆ€ (x y : M), r x y â†’ â‡‘s x y}
is_add_hom (Î» (a : Î±), f a + g a)
âˆƒ (q : polynomial R), polynomial.map f q = p âˆ§ q.degree = p.degree âˆ§ q.monic
âˆƒ (x : X), f x = g x
cont_diff_groupoid n I â‰¤ cont_diff_groupoid m I
continuous_within_at f (set.Iic a) a
â‡‘(p m) v = â‡‘(p n) w
has_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) b
(m.gcd n).factor_multiset = m.factor_multiset âŠ“ n.factor_multiset
continuous (p.partial_sum n)
âˆƒ (f : â„• â†’ Î±), strict_anti f
semiconj_by â†‘u x (â†‘u * x * â†‘uâ»Â¹)
âˆƒ (C : nnreal), C â‰¤ A + B âˆ§ has_sum (Î» (i : Î¹), (f i + g i) ^ p) (C ^ p)
probability_theory.cond (probability_theory.cond Î¼ s) t = probability_theory.cond Î¼ (s âˆ© t)
nat.bitwise f n m = nat.bitwise f m n
polynomial.eval (1 + y) (â‡‘(polynomial.monomial d) (â†‘d + 1)) - polynomial.eval y (â‡‘(polynomial.monomial d) (â†‘d + 1)) = (finset.range (d + 1)).sum (Î» (x_1 : â„•), â†‘((d + 1).choose x_1) * (â†‘x_1 * y ^ (x_1 - 1)))
s âˆˆ nhds_within a (set.Iio a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Ioo l a âŠ† s
free_group.red Lâ‚ Lâ‚‚ â†’ free_group.red Lâ‚ Lâ‚ƒ â†’ relation.join free_group.red Lâ‚‚ Lâ‚ƒ
measure_theory.measure.add_haar_measure (topological_space.positive_compacts.pi_Icc01 Î¹) = measure_theory.measure_space.volume
is_left_regular (a * b)
â†‘âŠ¤ = set.univ
r jâ‚ jâ‚‚
n < k â†’ n.desc_factorial k = 0
0 < finite_dimensional.finrank K â†¥(â‡‘(f.generalized_eigenspace Î¼) k)
pairwise (disjoint on Î» (n : Î±), set.Ioo (f (order.pred n)) (f n))
convolution â‡‘Ï† g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€ = measure_theory.integral Î¼ â‡‘Ï† â€¢ g xâ‚€
measure_theory.measure.pi Î¼ = Î¼Î½
unique_diff_on ğ•œ s â†’ unique_mdiff_on (model_with_corners_self ğ•œ E) s
â†‘s âˆ© â†‘(affine_subspace.mk' p (s.direction)á—®) = {euclidean_geometry.orthogonal_projection_fn s p}
monotone_on f D
||a|| = |a|
(âˆ€ (n : â„•), 0 < n â†’ n.divisors.prod (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.prod (Î» (x : â„• Ã— â„•), g x.snd ^ â‡‘nat.arithmetic_function.moebius x.fst) = f n
finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.reflection_circumcenter_weights_with_circumcenter iâ‚ iâ‚‚ i) = 1
metric.thickening Î´ E = â‹ƒ (x : X) (H : x âˆˆ E), metric.ball x Î´
add_monoid.is_torsion M
has_fpower_series_on_ball (Î» (z : ğ•œ), ring.inverse (1 - z â€¢ a)) (Î» (n : â„•), continuous_multilinear_map.mk_pi_field ğ•œ (fin n) (a ^ n)) 0 (â†‘âˆ¥aâˆ¥â‚Š)â»Â¹
âˆƒ (x : Î²), âˆ€ (y : Î²), f y â‰¤ f x
inner_product_geometry.angle x (-y) = real.pi - inner_product_geometry.angle x y
is_left_regular g
is_cyclotomic_extension (S âˆª T) A C
is_open_map proj
pythagorean_triple x y z â†” âˆƒ (k m n : â„¤), (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§ (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2))
(finset.univ.pi t).prod (Î» (x : Î  (a : Î±), a âˆˆ finset.univ â†’ Î´ a), f x) = (fintype.pi_finset t).prod (Î» (x : Î  (a : Î±), Î´ a), f (Î» (a : Î±) (_x : a âˆˆ finset.univ), x a))
filter.tendsto f b (nhds a)
âˆƒ (Z : multiset (prime_spectrum R)), (multiset.map coe Z).prod â‰¤ I
category_theory.limits.has_binary_biproducts C
finset.univ.prod (Î» (i : fin 0), f i) = 1
âˆƒ (j : set Î±), measurable_set j âˆ§ j âŠ† i âˆ§ measure_theory.vector_measure.restrict s j â‰¤ 0.restrict j âˆ§ â‡‘s j < 0
âˆ€á¶  (t : Î¹) in lt, interval_integrable f Î¼ (u t) (v t)
âˆƒ (y : E) (H : y âˆˆ frontier K), metric.inf_dist x Ká¶œ = has_dist.dist x y
(category_theory.cocone_of_representable P).Î¹.app j = (category_theory.yoneda_sections_small ((category_theory.category_of_elements.Ï€ P).left_op.obj j) (((category_theory.functor.const (P.elements)áµ’áµ–).obj (category_theory.cocone_of_representable P).X).obj j)).inv (opposite.unop j).snd
metric.bounded (normed_space.polar ğ•œ s)
has_fderiv_at_filter f f' x L â†” has_deriv_at_filter f (â‡‘f' 1) x L
category_theory.is_iso c.Ï€
a + b < 0
lower_semicontinuous_at (Î» (z : Î±), f z + g z) x
category_theory.exp_comparison F A â‰« category_theory.whisker_left F (category_theory.pre (F.map f)) = category_theory.whisker_right (category_theory.pre f) F â‰« category_theory.exp_comparison F A'
L.nth_le i hi = (list.take j L).nth_le i _
category_theory.is_iso f
has_edist.edist x y = â†‘(has_nndist.nndist x y)
has_fderiv_at ring.inverse (-â‡‘(â‡‘(continuous_linear_map.lmul_left_right ğ•œ R) â†‘xâ»Â¹) â†‘xâ»Â¹) â†‘x
M.conj_transpose j i = has_star.star (M i j)
strict_convex ğ•œ (metric.closed_ball x r)
â‡‘(s.weighted_vsub_of_point p bâ‚) w +áµ¥ bâ‚ = â‡‘(s.weighted_vsub_of_point p bâ‚‚) w +áµ¥ bâ‚‚
has_fpower_series_on_ball f (cauchy_power_series f c â†‘R) c â†‘R
mem_â„“p f p
F.map (category_theory.limits.prod.map f g) â‰« category_theory.limits.prod_comparison F A' B' = category_theory.limits.prod_comparison F A B â‰« category_theory.limits.prod.map (F.map f) (F.map g)
â‡‘(convex_hull ğ•œ) s = â‹ƒ (t : finset E) (hss : â†‘t âŠ† s) (hai : affine_independent ğ•œ coe), â‡‘(convex_hull ğ•œ) â†‘t
(âˆ€á¶  (x : Î±) in l, âˆ€ (i : Î¹), i âˆˆ I â†’ p i x) â†” âˆ€ (i : Î¹), i âˆˆ I â†’ (âˆ€á¶  (x : Î±) in l, p i x)
âˆƒ (U : set Î±) (H : U âŠ‡ s), is_open U âˆ§ â‡‘Î¼ U < âŠ¤
subgroup.closure â†‘(finset.image (Î» (g : G), âŸ¨g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹, _âŸ©) (R * S)) = âŠ¤
exp ğ•‚ (x + y) = exp ğ•‚ x * exp ğ•‚ y
â‡‘(f.lift hg) z + â‡‘g â†‘((f.sec z).snd) = â‡‘g (f.sec z).fst
inner_product_geometry.angle x (-x) = real.pi
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ has_insert.insert a s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
is_open_map â‡‘f
polynomial.is_splitting_field K L (polynomial.cyclotomic â†‘n K)
category_theory.inv (L.map (h.unit.app X)) = h.counit.app (L.obj X)
filter.mapâ‚‚ m f (filter.mapâ‚‚ n g h) â‰¤ filter.mapâ‚‚ n' (filter.mapâ‚‚ mâ‚ f g) (filter.mapâ‚‚ mâ‚‚ f h)
(M.mul N).det = (N.mul M).det
s âŠ† balanced_core ğ•œ t
category_theory.limits.has_finite_limits C
measure_theory.analytic_set s â†” âˆƒ (Î² : Type) (h : topological_space Î²) (h' : polish_space Î²) (f : Î² â†’ Î±), continuous f âˆ§ set.range f = s
is_noetherian Râ‚ â†¥I
powers a âŠ† s
category_theory.limits.image_subobject (h â‰« f) = category_theory.limits.image_subobject f
a < b â†’ b < c â†’ a < c
s.sum (Î» (i : Î¹), |f i|) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), |f i| ^ p)
continuous â‡‘f
âˆ¥continuous_linear_map.lsmul ğ•œ ğ•œ'âˆ¥ â‰¤ 1
category_theory.limits.coprod_comparison F A B â‰« F.map (category_theory.limits.coprod.map f g) = category_theory.limits.coprod.map (F.map f) (F.map g) â‰« category_theory.limits.coprod_comparison F A' B'
has_Sup.Sup (has_insert.insert a s) = a âŠ” has_Sup.Sup s
|a + b| â‰¤ |a| + |b|
|v - (generalized_continued_fraction.of v).convergents n| â‰¤ 1 / ((generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators (n + 1))
lâ‚ <:+ lâ‚‚ â†’ lâ‚.reverse <+: lâ‚‚.reverse
â‡‘(algebra.norm K) Î¶ = (-1) ^ finite_dimensional.finrank K L
add_monoid.is_torsion G
metric.bounded (closure s)
âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
complete_lattice.independent p â†” âˆ€ (i : Î¹) (x : â†¥(p i)) (v : Î â‚€ (i : Î¹), â†¥(p i)), â‡‘(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)) (dfinsupp.erase i v) = â†‘x â†’ x = 0
âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f y â‰¤ f x
(list.of_fn f).length = n
âˆ« (x : â„) in aâ‚..bâ‚, âˆ« (y : â„) in aâ‚‚..bâ‚‚, â‡‘(f' (x, y)) (1, 0) + â‡‘(g' (x, y)) (0, 1) = (((âˆ« (x : â„) in aâ‚..bâ‚, g (x, bâ‚‚)) - âˆ« (x : â„) in aâ‚..bâ‚, g (x, aâ‚‚)) + âˆ« (y : â„) in aâ‚‚..bâ‚‚, f (bâ‚, y)) - âˆ« (y : â„) in aâ‚‚..bâ‚‚, f (aâ‚, y)
x âˆˆ (closure_operator.mkâ‚ƒ f p hf hfp hmin).closed
category_theory.is_pushout hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚
â‡‘continuous_linear_map.adjoint (A.comp B) = (â‡‘continuous_linear_map.adjoint B).comp (â‡‘continuous_linear_map.adjoint A)
nonempty (category_theory.limits.cone F)
p s
measure_theory.integrable_on (Î» (x : â„), real.exp (-x) * x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
even a â†’ even (-a)
x * s â€¢ y = s â€¢ (x * y)
(category_theory.category_of_elements.map Î±).op â‹™ category_theory.category_of_elements.to_costructured_arrow Fâ‚‚ = category_theory.category_of_elements.to_costructured_arrow Fâ‚ â‹™ category_theory.costructured_arrow.map Î±
free_group.reduce (free_group.reduce L) = free_group.reduce L
(p * â‡‘polynomial.C a).nat_degree = p.nat_degree
emetric.diam (f '' s) = emetric.diam s
category_theory.limits.has_limits_of_shape J D
((ideal.quotient.mk (ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P)).comp polynomial.C).comp (ideal.quotient.mk (ideal.comap polynomial.C P)) = ((ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P).quotient_map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) ideal.le_comap_map).comp ((ideal.quotient.mk P).comp polynomial.C)
f' =O[l] g' â†’ ((Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
a â©¿ b â†’ â‡‘order_dual.to_dual b â©¿ â‡‘order_dual.to_dual a
tendsto_uniformly f (f x) (nhds x)
filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.univ  {a})) l
summable (Î» (n : â„•), (â†‘n ^ p)â»Â¹) â†” 1 < p
(x * 1).equiv x
filter.mapâ‚‚ m f (filter.map n g) = filter.map n' (filter.mapâ‚‚ m' f g)
emetric.diam {x} = 0
is_artinian R â†¥(submodule.span R A)
inner_product_geometry.angle x x = 0
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), witt_vector.init n)
lie_module.weight_space M 0 = âŠ¤
âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ â‰¤ âˆ¥fâˆ¥ / 3 âˆ§ has_dist.dist (g.comp_continuous e) f â‰¤ 2 / 3 * âˆ¥fâˆ¥
(category_theory.limits.prod.braiding P Q).hom â‰« (category_theory.limits.prod.braiding Q P).hom = ğŸ™ (P â¨¯ Q)
prod.rprod rÎ± rÎ² â‰¤ relation.trans_gen (relation.game_add rÎ± rÎ²)
filter.tendsto has_neg.neg (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
nonempty (field Î±) â†” is_prime_pow (cardinal.mk Î±)
(x * 0).equiv 0
â‡‘(g â€¢ f) a = â‡‘f (gâ»Â¹ â€¢ a)
measure_theory.ae_strongly_measurable f Î¼ â†” ae_measurable f Î¼
âˆ€á¶  (x : â„) in residual â„, liouville x
add_commute (a + b) c
â‡‘((hV.linear_isometry_equiv hV').symm) (Wâ‚€.sum (lp.single 2)) = Wâ‚€.sum (Î» (i : Î¹), â‡‘(V i))
p qâ‚ qâ‚‚
x = y â†” âˆ€ (g : normed_space.dual ğ•œ E), â‡‘g x = â‡‘g y
v âˆˆ (submodule.span ğ•œ {u})á—®
has_strict_deriv_at complex.cos (-complex.sin x) x
filter.tendsto (Î» (n : â„•), u n / â†‘n) filter.at_top (nhds l)
semi_normed_group.core E
a * b â‰¤ |a| ^ p / p + |b| ^ q / q
metric.ball x r = set.univ.pi (Î» (b : Î²), metric.ball (x b) r)
âˆƒ (S : set Î±), measurable_set S âˆ§ measure_theory.vector_measure.restrict j.to_signed_measure S â‰¤ 0.restrict S âˆ§ 0.restrict Sá¶œ â‰¤ measure_theory.vector_measure.restrict j.to_signed_measure Sá¶œ âˆ§ â‡‘(j.pos_part) S = 0 âˆ§ â‡‘(j.neg_part) Sá¶œ = 0
continuous_on f s
â†‘â†‘f = â†‘f
category_theory.epi f â†” function.surjective â‡‘(simplex_category.hom.to_order_hom f)
even a â†’ (âˆƒ (b : Î±), a = bit0 b)
p1 -áµ¥ (g +áµ¥ p2) = p1 -áµ¥ p2 - g
emetric.Hausdorff_edist s u â‰¤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u
cauchy_seq f
continuous Z.proj
lipschitz_on_with C f s
monoid.is_torsion â†¥H
p ^ â‡‘((n.choose k).factorization) p â‰¤ n
category_theory.ProjectiveResolution.lift_f_one f P Q â‰« Q.complex.d 1 0 = P.complex.d 1 0 â‰« category_theory.ProjectiveResolution.lift_f_zero f P Q
M.mul (list.take k (matrix.pivot.list_transvec_row M)).prod i (sum.inr ()) = M i (sum.inr ())
(upper_bounds s âˆ© t).nonempty â†’ bdd_above (f '' s)
f = g
Î¼.absolutely_continuous Î½ â†’ Î¼.ae â‰¤ Î½.ae
(Î» (t : Î¹), ((âˆ« (x : â„) in v t..b, f x) - âˆ« (x : â„) in u t..b, f x) + (v t - u t) â€¢ c) =o[lt] (v - u)
add_le_cancellable â†‘a
a âŠ‚ b â†’ b â‰  a
â‡‘(orthogonal_projection (submodule.span ğ•œ {v})á—®) v = 0
dioph.dioph_fn (Î» (v : Î± â†’ â„•), f v ^ g v)
subsingleton L
P.fg â†” P.to_add_submonoid.fg
matrix.dot_product u (â‡‘(â‡‘cross_product v) w) = matrix.dot_product v (â‡‘(â‡‘cross_product w) u)
category_theory.solution_set_condition G
(x + y) ^ n = (finset.range (n + 1)).sum (Î» (m : â„•), x ^ m * y ^ (n - m) * â†‘(n.choose m))
â‡‘(reflection K) v = -v
m < (b + 2) ^ ((b + 2).digits m).length
convolution f g (continuous_linear_map.lmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f (x - t) * g t âˆ‚Î¼
âˆ… âˆ‰ r.classes
monoid.is_torsion H â†” monoid.is_torsion G
âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
padic_val_nat p p = 1
f =O[l] g â†” âˆƒ (c : â„), âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥
â‡‘((n.choose k).factorization) p â‰¤ nat.log p n
subsingleton R
s.nodup â†’ s.powerset.nodup
â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
â‡‘f aâ»Â¹ = (â‡‘f a)â»Â¹
s.prod (Î» (a : Î±), (t a).sum (Î» (b : Î´ a), f a b)) = (s.pi t).sum (Î» (p : Î  (a : Î±), a âˆˆ s â†’ Î´ a), s.attach.prod (Î» (x : {x // x âˆˆ s}), f x.val (p x.val _)))
â‡‘(linear_map.trace R M) (â†‘f * g * â†‘fâ»Â¹) = â‡‘(linear_map.trace R M) g
category_theory.is_equivalence.of_iso e' (category_theory.is_equivalence.of_iso e hF) = category_theory.is_equivalence.of_iso (e â‰ªâ‰« e') hF
âˆƒ (j : J) (y : F.obj j), category_theory.limits.colimit.Î¹ F j y = x
Mon.filtered_colimits.colimit_mul_aux F x y = Mon.filtered_colimits.colimit_mul_aux F x' y
linear_order.max a 0 - linear_order.max (-a) 0 = a
(a * b).factorization = a.factorization + b.factorization
â‡‘Ï {x : Î± | v.lim_ratio_meas hÏ x = 0} = 0
finset.centroid k s p = â‡‘(s.affine_combination p) (finset.centroid_weights k s)
(e.units_smul w).orientation = (finset.univ.prod (Î» (i : Î¹), w i))â»Â¹ â€¢ e.orientation
(polynomial.cyclotomic' n R).roots = (primitive_roots n R).val
direct_sum.is_internal (add_monoid_algebra.grade_by R â‡‘f)
Gromov_Hausdorff.GH_dist X Y â‰¤ Îµâ‚ + Îµâ‚‚ / 2 + Îµâ‚ƒ
antitone f â†’ monotone (â‡‘order_dual.to_dual âˆ˜ f)
continuous â‡‘(add_monoid_hom.mul_right x)
bdd_above (â‹ƒ (i : Î²) (H : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ bdd_above (S i)
continuous_on â‡‘((hf.to_local_equiv hc).symm) (f '' s)
set.eq_on f 0 {z : â„‚ | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}
category_theory.is_pushout 0 (ğŸ™ X) 0 0
(Î» (h : â„), f (x + h â€¢ v + h â€¢ w) - f (x + h â€¢ v) - h â€¢ â‡‘(f' x) w - h ^ 2 â€¢ â‡‘(â‡‘f'' v) w - (h ^ 2 / 2) â€¢ â‡‘(â‡‘f'' w) w) =o[nhds_within 0 (set.Ioi 0)] Î» (h : â„), h ^ 2
e âˆˆ charted_space.atlas H H â†” e = local_homeomorph.refl H
â‡‘(convex_hull R) s = â‹ƒ (t : finset E) (w : â†‘t âŠ† s), â‡‘(convex_hull R) â†‘t
category_theory.is_iso Î³
category_theory.limits.has_finite_wide_pullbacks C
filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
x âˆˆ finset.nat.antidiagonal n â†” x.fst + x.snd = n
witt_vector.lift (Î» (kâ‚‚ : â„•), f kâ‚‚) f_compat = g
âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (x : â„) in f a..f b, g x
ordered_smul k M
measurable_embedding (s.restrict f)
âˆƒ (A : â„), 0 < A âˆ§ âˆ€ (z : Z) (a : N), 1 â‰¤ d a * (has_dist.dist Î± (j z a) * A)
t.prod.nat_degree = (multiset.map (Î» (f : polynomial R), f.nat_degree) t).sum
âˆƒ (U : set Î±) (H : U âŠ‡ A), is_open U âˆ§ â‡‘Î¼ U < r
lie_algebra.is_nilpotent R L
affine_span k (set.range p) = âŠ¤
finite_dimensional K V
has_Inf.Inf {a} = a
witt_vector.peval (witt_vector.poly_of_interest p n) ![Î» (i : â„•), x.coeff i, Î» (i : â„•), y.coeff i] = (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) - x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1)
analytic_at â„‚ f z
âˆƒ (K : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_compact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (H : i âˆˆ t), K i
f z â‰¤ linear_order.max (f x) (f y)
âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
function.injective â‡‘f â†’ âˆ€ (a : â†¥P), â‡‘f a = 0 â†’ a = 0
spectrum ğ•œ 0 = {0}
strict_convex_on ğ•œ s (-f) â†” strict_concave_on ğ•œ s f
s.Î¹.app j â‰« k = s.Î¹.app j â‰« l
a â€¢ closure s + b â€¢ interior s âŠ† interior s
(euclidean_geometry.reflection s).symm = euclidean_geometry.reflection s
bornology.is_vonN_bounded ğ•œ sâ‚
is_regular 0 â†” subsingleton R
f =o[l] g â†” âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ asymptotics.is_O_with c l f g
continuous_within_at f (set.Iic a) a
(fundamental_groupoid.fundamental_groupoid_functor.map g).map p = continuous_map.homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I (ğŸ™ {down := 1}) p) â‰« continuous_map.homotopy.hcast _
hb.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
fâ‚ = fâ‚‚
y - x âˆˆ tangent_cone_at â„ s x
convolution (convolution f g L Î¼) k Lâ‚‚ Î½ xâ‚€ = convolution f (convolution g k Lâ‚„ Î½) Lâ‚ƒ Î¼ xâ‚€
category_theory.limits.pushout f g = x âŠ” y
con_gen â‡‘c = c
linear_independent K (fin.cons x v)
has_inner.inner (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚) (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚‚) = lâ‚.sum (Î» (i : Î¹) (y : ğ•œ), â‡‘(star_ring_end ğ•œ) y * â‡‘lâ‚‚ i)
a + c < b + d
is_cyclotomic_extension {n} A B â†” (âˆƒ (r : B), â‡‘(polynomial.aeval r) (polynomial.cyclotomic â†‘n A) = 0) âˆ§ âˆ€ (x : B), x âˆˆ algebra.adjoin A {b : B | b ^ â†‘n = 1}
metric.inf_dist (Î¦ x) (Î¦ '' t) = metric.inf_dist x t
(âˆƒá¶  (x : Î±) in nhds a, x âˆˆ s) â†’ a âˆˆ closure s
category_theory.limits.has_finite_products C
f '' connected_component a = {f a}
x = y
p = pâ‚ âˆ¨ p = pâ‚‚
âˆƒ (xâ‚€ : E), xâ‚€ âˆ‰ F âˆ§ âˆ€ (y : E), y âˆˆ F â†’ r * âˆ¥xâ‚€âˆ¥ â‰¤ âˆ¥xâ‚€ - yâˆ¥
âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ f m = âŠ¤
âˆƒ (r : â„), âˆ€ (sx : affine.simplex â„ P n), set.range sx.points âŠ† ps â†’ sx.circumradius = r
b â‰¤ c
J.covers S (g â‰« f)
finset.univ.sum f = finset.univ.sum g
(â‡‘(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen
n.factors.to_finset = finset.filter nat.prime n.divisors
submodule.span R {t : tensor_product R M N | âˆƒ (m : M) (n : N), m âŠ—â‚œ[R] n = t} = âŠ¤
metric.diam âˆ… = 0
set.eq_on â‡‘f â‡‘g â†‘(subsemiring.closure s)
topological_space.separable_space Î²
a ^ (p - 1) = 1
I.radical = I.jacobson â†” âŠ¥.radical = âŠ¥.jacobson
category_theory.is_preconnected K
continuous (Î» (g : G Ã— G), g.fst + g.snd + -g.fst)
s.ord_connected â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ set.Icc x y âŠ† s
p x hx
summable (Î» (n : â„•), Î¾ ^ n) â†” âˆ¥Î¾âˆ¥ < 1
submodule.torsion R (M â§¸ submodule.torsion R M) = âŠ¥
x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
âˆƒ (h : P â†’â‚—[R] M), f.comp h = g
a ^ n = b ^ n â†” a = b
measure_theory.measure.sum (Î» (a : Î±), â‡‘Î¼ {a} â€¢ measure_theory.measure.dirac a) = Î¼
(matrix.from_blocks A B C D).is_hermitian â†” A.is_hermitian âˆ§ B.conj_transpose = C âˆ§ C.conj_transpose = B âˆ§ D.is_hermitian
finsupp.comap_domain f (vâ‚ + vâ‚‚) _ = finsupp.comap_domain f vâ‚ _ + finsupp.comap_domain f vâ‚‚ _
c âŠ” d = con_gen (setoid.r âŠ” setoid.r)
has_deriv_within_at f f' (set.Iic x) x â†’ has_deriv_within_at f f' (set.Iio x) x
â‡‘multiset.card (multiset.nat.antidiagonal n) = n + 1
âˆƒ (f : Î² â†’ Î±), measurable f âˆ§ âˆ€ (n : â„•) (x : Î²), x âˆˆ t n â†’ f x = g n x
tendsto_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n y) (Î» (y : E), f (x + y)) filter.at_top (metric.ball 0 â†‘r')
is_empty Î± â†” is_empty Î²
c âŠ” d = add_con_gen (setoid.r âŠ” setoid.r)
M.subsemiring_closure = subsemiring.closure â†‘M
(âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.interval_oc a b â†’ P x) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.Ioc a b â†’ P x) âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.Ioc b a â†’ P x
is_compl K Ká—®
f = g
f (ite P a b) = ite P (f a) (f b)
âˆ« (y : â„) in a..b, g' y = g b - g a
padic_norm p â†‘p = 1 / â†‘p
fâ‚ = fâ‚‚
â‡‘f x = â‡‘g x
coe âˆ˜ zmod.val = coe
has_ftaylor_series_up_to_on n fâ‚ p s
lipschitz_with C.to_nnreal â‡‘f
âˆ€áµ (x : Î±) âˆ‚Î½, Î¼.rn_deriv Î½ x < âŠ¤
ideal.map f I â‰¤ ideal.comap g I
t = h.extend f
emetric.diam (â‡‘(convex_hull â„) s) = emetric.diam s
Class.iota p âˆˆ Class.univ
âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ = 0 â†” m âˆˆ closure â†‘S
category_theory.presieve.is_sheaf_for P â‡‘(category_theory.sieve.bind â‡‘U B)
(â¨ (x : Î±) in t, f x âˆ‚Î¼, â¨ (x : Î±) in t, g (f x) âˆ‚Î¼) âˆˆ {p : E Ã— â„ | p.fst âˆˆ s âˆ§ p.snd â‰¤ g p.fst}
Y âˆˆ F'.ess_image
E1.map e.to_alg_hom â‰¤ E2.map e.to_alg_hom
f =O[l] g' â†’ (f =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
has_inner.inner (finset.univ.sum (Î» (i : Î¹), l i â€¢ v i)) (v i) = â‡‘(star_ring_end ğ•œ) (l i)
strict_convex_on â„ (set.Ici 0) (Î» (x : â„), x ^ n)
s.fg
âˆ« (x : G), f (g * x) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
fintype.card {i // p i â‰  âŠ¥} â‰¤ finite_dimensional.finrank K V
a âˆˆ s â†’ a âˆ‰ t â†’ s â‰  t
add_commute b a
algebra.is_algebraic K A
dense_range has_pure.pure
(finset.range n).sum (Î» (i : â„•), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
has_inner.inner (â‡‘f x) (â‡‘f y) = has_inner.inner x y
âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ g.restrict s = f
category_theory.is_iso f
(l.nth 0).get_or_else 0 + l.tail.sum = l.sum
measure_theory.vadd_invariant_measure â†¥(Î“.opposite) G Î¼
continuous_map.compact_open = â¨… (s : set Î±) (hs : is_compact s), topological_space.induced (continuous_map.restrict s) continuous_map.compact_open
z = â†‘(z.re)
cardinal.mk Î¹ â‰¤ â†‘(fintype.card â†¥w)
â‡‘(v.valuation) (â‡‘(algebra_map R K) r) < 1 â†” v.as_ideal âˆ£ ideal.span {r}
disjoint a a â†’ a = âŠ¥
(xâ‚ ^ 2 + n * xâ‚‚ ^ 2) * (yâ‚ ^ 2 + n * yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - n * xâ‚‚ * yâ‚‚) ^ 2 + n * (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2
is_field â†¥A
s.sum (Î» (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), g i ^ p) ^ (1 / p)
(âˆ€ (b : A), b âˆˆ t â†’ f b âˆˆ s) â†’ t.sum (Î» (b : A), f b) âˆˆ s
â‡‘s v = 0
â‡‘Î¼ s = â‡‘Î¼ t
â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = p â†” p âˆˆ s
continuous_on f s â†” continuous_on (â‡‘e âˆ˜ f) s
(â†‘s1 âˆ© â†‘s2).nonempty
a âŠ‚ c
is_add_monoid_hom â‡‘h
has_deriv_at (l âˆ˜ f) (â‡‘l' f') x
âˆ«â» (a : Î±), f a * g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
(â‡‘(matrix.reindex e e) A).det = A.det
â‡‘continuous_linear_map.adjoint (â‡‘continuous_linear_map.adjoint A) = A
unique_mdiff_within_at (model_with_corners_self ğ•œ E) s x â†’ unique_diff_within_at ğ•œ s x
measure_theory.has_no_atoms (measure_theory.measure.pi Î¼)
filter.is_cobounded r f
module.End.has_eigenvector â†‘T (â†‘â¨… (x : {x // x â‰  0}), (Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) â†‘x) xâ‚€
filter.tendsto (Î» (i : Î¹), âˆ«â» (a : Î±), â†‘(â‡‘(fs i) a) âˆ‚â†‘Î¼) L (nhds (âˆ«â» (a : Î±), â†‘(f a) âˆ‚â†‘Î¼))
cont_diff_at ğ•œ n (Î» (x : E Ã— F), f x.fst) x
âˆƒ! (P : polynomial â„¤), polynomial.map (int.cast_ring_hom K) P = polynomial.cyclotomic' â†‘n K
p (s.sum (Î» (x : Î±), f x))
a â‹– âŠ¤ â†’ is_coatom a
(model_with_corners_self ğ•œ E).to_local_equiv = local_equiv.refl E
I â€¢ J = I * J
p (s.prod (Î» (x : Î±), f x))
category_theory.is_pushout (ğŸ™ X) 0 0 0
a * a' = ((dfinsupp.support a).product (dfinsupp.support a')).sum (Î» (ij : Î¹ Ã— Î¹), â‡‘(direct_sum.of A (ij.fst + ij.snd)) (graded_monoid.ghas_mul.mul (â‡‘a ij.fst) (â‡‘a' ij.snd)))
cardinal.mk â†¥(set.Ico a b) = cardinal.continuum
has_nndist.nndist (f x) (f y) = has_nndist.nndist x y
has_dist.dist (â‡‘f x) (â‡‘g x) â‰¤ has_dist.dist f g
Ï† = Ïˆ
analytic_at ğ•œ (g âˆ˜ f) x
set.eq_on â‡‘f â‡‘g â†‘(add_subsemigroup.closure s)
âˆ¥x - yâˆ¥ = |âˆ¥xâˆ¥ - âˆ¥yâˆ¥|
continuous (Î» (x : Î±), metric.inf_nndist x s)
is_fraction_ring C L
has_strict_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca) (a, b)
x âˆˆ set.extreme_points ğ•œ A â†” x âˆˆ A âˆ§ âˆ€ (xâ‚ : E), xâ‚ âˆˆ A â†’ âˆ€ (xâ‚‚ : E), xâ‚‚ âˆˆ A â†’ x âˆˆ segment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ¨ xâ‚‚ = x
A.sum (has_pow.pow 2) < 2 ^ k
Â¬has_sbtw.sbtw c b a
âˆƒ (y : Î²), b â‰¤ â†‘((finset.filter (Î» (x : Î±), f x = y) finset.univ).card)
â‡‘(i.succ.succ_above) 1 = (â‡‘(i.succ_above) 0).succ
â‡‘Î¼ K < âŠ¤
e.to_local_equiv.source âˆ© â‡‘e â»Â¹' t = e.to_local_equiv.source âˆ© s â†’ e.is_image s t
has_dist.dist (f t) (g t) â‰¤ Î´ * real.exp (K * (t - a))
filter.tendsto (Î» (x : â„), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-xâ»Â¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
submodule.span (polynomial R) {g : polynomial R | âˆƒ (i : â„•), g = â‡‘polynomial.C (f.coeff i)} â‰¤ I
âˆƒ (b : Î²), âˆ€ (p : Î± Ã— Î²), p âˆˆ f.val â†’ cmp p.fst a = cmp p.snd b
0 < padic_val_rat p ((finset.range n).sum (Î» (i : â„•), F i))
monoid.closure {x} = powers x
bdd_above s â†’ bdd_above t â†’ bdd_above (set.image2 f s t)
fintype.card (sym2 Î±) = fintype.card Î± * (fintype.card Î± + 1) / 2
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
F.map_iso (category_theory.eq_to_iso p) = category_theory.eq_to_iso _
measure_theory.fin_strongly_measurable f Î¼
{i : Î¹ | (f i).nonempty}.finite
n.factorization = 0 â†” n = 0 âˆ¨ n = 1
order_of (lucas_lehmer.Ï‰_unit (p' + 2)) = 2 ^ (p' + 2)
finite_dimensional.finrank R â†¥(submodule.map â†‘f p) = finite_dimensional.finrank R â†¥p
D.diagram_over_open_Ï€ U i â‰« D.Î¹_inv_app_Ï€_eq_map U â‰« D.Î¹_inv_app U â‰« D.diagram_over_open_Ï€ U j = D.diagram_over_open_Ï€ U j
s âˆˆ ğ’œ.up_shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), t âŠ† s âˆ§ t.card + 1 = s.card
filter.tendsto (Î» (n : â„•), â†‘âˆ¥a ^ nâˆ¥â‚Š ^ (1 / â†‘n)) filter.at_top (nhds (spectral_radius â„‚ a))
a â‰  b â†’ order.succ a â‰  order.succ b
filter.tendsto f (nhds_within x (set.Iio x)) (nhds (has_Sup.Sup (f '' set.Iio x)))
generalized_continued_fraction.convergents'_aux s (n + 2) = generalized_continued_fraction.convergents'_aux (generalized_continued_fraction.squash_seq s n) (n + 1)
subsemigroup.map f (subsemigroup.closure s) = subsemigroup.closure (â‡‘f '' s)
function.injective (category_theory.limits.colimit_limit_to_limit_colimit F)
A.det = finset.univ.sum (Î» (j : fin n.succ), (-1) ^ â†‘j * A 0 j * (A.minor fin.succ â‡‘(j.succ_above)).det)
b - (b - a) â‰¤ a
âˆƒ (s : set E) (H : s âˆˆ nhds a), approximates_linear_on f f' s c
linear_independent R (â‡‘f âˆ˜ v)
Îµ ^ p.to_real * â‡‘Î¼ {x : Î± | Îµ â‰¤ â†‘âˆ¥f xâˆ¥â‚Š} â‰¤ measure_theory.snorm f p Î¼ ^ p.to_real
(s.product t).prod (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = t.prod (Î» (y : Î±), s.prod (Î» (x : Î³), f x y))
set.Icc (f a) (f b) âŠ† set.range f
a * x * x + b * x + c = 0 â†” x = (-b + s) / (2 * a) âˆ¨ x = (-b - s) / (2 * a)
xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚
(A.mul (â…Ÿ B)).mul B = A
is_bounded_linear_map ğ•œ (Î» (p : continuous_multilinear_map ğ•œ E F Ã— continuous_multilinear_map ğ•œ E G), p.fst.prod p.snd)
measure_theory.conservative f^[n] Î¼
X.as = Y.as
f.ker.is_prime
category_theory.presieve.family_of_elements.restrict _ x.sieve_extend = x
topological_space.is_separable (f â»Â¹' s)
P f
linear_independent k (Î» (v : â†¥s), â†‘v) â†” affine_independent k (Î» (p : â†¥({pâ‚} âˆª (Î» (v : V), v +áµ¥ pâ‚) '' s)), â†‘p)
âˆƒ (iâ‚€ iâ‚ : fin (h.card Îµ ^ fintype.card Î¹).succ), iâ‚€ â‰  iâ‚ âˆ§ âˆ€ (k : Î¹), â†‘(â‡‘abv (A iâ‚ k % b - A iâ‚€ k % b)) < â‡‘abv b â€¢ Îµ
(b.to_matrix â‡‘b').mul (b'.to_matrix â‡‘b) = 1
âˆƒ (y : N), â‡‘f x * y = 1
Î¼.inner_content âŸ¨â‹ƒ (i : â„•), U i, _âŸ© â‰¤ âˆ‘' (i : â„•), Î¼.inner_content âŸ¨U i, _âŸ©
measure_theory.unif_integrable f p Î¼
filter.map coe filter.at_top = filter.at_top
Jâ‚.close S â‰¤ T
(â‹ƒ (i : Î¹') (H : i âˆˆ s), g i).pairwise_disjoint f
x.lf z
I âˆ£ J â†” J â‰¤ I
z âˆˆ algebra.adjoin R {B.gen}
âˆƒ (x : Î±) (H : x âˆˆ s) (m : â„•) (H : m â‰  0), f^[m] x âˆˆ s
bornology.is_bounded {x : Î± | p x} â†’ bounded_space (subtype p)
âˆ« (x : â„) in a..b, c âˆ‚Î¼ = ((â‡‘Î¼ (set.Iic b)).to_real - (â‡‘Î¼ (set.Iic a)).to_real) â€¢ c
uniformity Î± = â¨… (Îµ : ennreal) (H : Îµ > 0), filter.principal {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < Îµ}
0 â‰  1 âˆ¨ âˆ€ (a : Mâ‚€), a = 0
s.monge_point âˆˆ affine_span â„ (set.range s.points)
topological_space.separable_space Î²
t.center_mass w id âˆˆ â‡‘(convex_hull R) â†‘t
has_inner.inner x y = has_inner.inner â†‘x â†‘y
dense (â‹‚ (s : Î²) (H : s âˆˆ S), f s)
is_closed s
â†‘(a.desc_factorial 2) = â†‘a * (â†‘a - 1)
â‡‘Ï s â‰¤ â†‘p * â‡‘Î¼ s
ideal.is_jacobson R â†” âˆ€ (P : ideal R), P.is_prime â†’ P.jacobson = P
B = C
has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆ¥yâˆ¥ â€¢ x = âˆ¥xâˆ¥ â€¢ y
âˆ¥f.mk_continuous C hâˆ¥ â‰¤ linear_order.max C 0
(polynomial_functions unit_interval).comap' (continuous_map.comp_right_alg_hom â„ (Icc_homeo_I a b h).symm.to_continuous_map) = polynomial_functions (set.Icc a b)
is_add_group_hom (g âˆ˜ f)
â‡‘(orthogonal_projection s.direction) (p -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p)) = 0
uniform_cauchy_seq_on F p s
g.continuants (n + 2) = {a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b}
list.ordered_insert r a l = list.take_while (Î» (b : Î±), Â¬r a b) l ++ a :: list.drop_while (Î» (b : Î±), Â¬r a b) l
has_sbtw.sbtw a b d
category_theory.presheaf.is_sheaf (opens.grothendieck_topology â†¥X) F â†” F.is_sheaf_opens_le_cover
f =O[l] g' â†’ (f =O[l] Î» (x : Î±), -g' x)
â‡‘f x = â‡‘f y
uniform_embedding f
â†‘({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_char F a + 1
has_fderiv_at (exp ğ•‚) 1 0
algebra.discr A b = 0
âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
v (â‡‘(equiv.swap i j) k) = v k
contracting_with.efixed_point' f hsc hsf hfs x hxs hx = contracting_with.efixed_point' f htc htf hft y hyt hy
âˆƒ (d : Î±), d â‰  0 âˆ§ âˆ¥d â€¢ xâˆ¥ < Îµ âˆ§ Îµ / âˆ¥câˆ¥ â‰¤ âˆ¥d â€¢ xâˆ¥ âˆ§ âˆ¥dâˆ¥â»Â¹ â‰¤ Îµâ»Â¹ * âˆ¥câˆ¥ * âˆ¥xâˆ¥
(convex_cone.positive_cone ğ•œ E).pointed
polynomial.rev_at_fun N i = â‡‘(polynomial.rev_at N) i
(s âˆ© t).nonempty
finset.pimage f s = finset.image (Î» (x : {x // x âˆˆ finset.filter (Î» (x : Î±), (f x).dom) s}), (f â†‘x).get _) (finset.filter (Î» (x : Î±), (f x).dom) s).attach
(l.split_wrt_composition c).length = c.length
â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det â†‘f| * â‡‘Î¼ s
(â¨† (i : Î¹), s i) = â¨† (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
â‡‘f l.sum = (list.map â‡‘f l).sum
affine_independent k p â†” âˆ€ (w : Î¹ â†’ k), finset.univ.sum (Î» (i : Î¹), w i) = 0 â†’ â‡‘(finset.univ.weighted_vsub p) w = 0 â†’ âˆ€ (i : Î¹), w i = 0
(h.comp g).comp f = h.comp (g.comp f)
mv_polynomial.esymm Ïƒ R n = finset.univ.sum (Î» (t : {s // s.card = n}), â†‘t.prod (Î» (i : Ïƒ), mv_polynomial.X i))
finsupp.comap_domain f (r â€¢ v) _ = r â€¢ finsupp.comap_domain f v _
âˆ¥f zâˆ¥ â‰¤ C
a * b < c â†’ b < aâ»Â¹ * c
has_fderiv_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p x 1)) x
(âˆ€ (x : category_theory.presieve.family_of_elements P R), x.compatible â†’ (âˆƒ (t : P.obj (opposite.op X)), x.is_amalgamation t)) â†’ category_theory.presieve.is_sheaf_for P R
first_order.language.is_fraisse K
x âˆˆ set.Icc a b â†’ f x â‰¤ B x
g '' set.image2 f s t = set.image2 f' s (g' '' t)
function.is_periodic_pt id n x
a + b < 0
balanced_hull ğ•œ s âŠ† t
direct_sum.is_internal A
continuous_on f s
â‡‘(â‡‘(fourier_series.repr) f) i = âˆ« (t : â†¥circle), â†‘t ^ -i * â‡‘f t âˆ‚haar_circle
f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
x = e.orientation âˆ¨ x = -e.orientation
uniform_continuous (Î» (p : uniform_space.completion Î± Ã— uniform_space.completion Î±), has_dist.dist p.fst p.snd)
(fundamental_groupoid.fundamental_groupoid_functor.map f).map p = continuous_map.homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I (ğŸ™ {down := 0}) p) â‰« continuous_map.homotopy.hcast _
convex_independent ğ•œ p â†” âˆ€ (i : Î¹) (s : set Î¹), p i âˆ‰ â‡‘(convex_hull ğ•œ) (p '' (s  {i}))
(M.mul (N.mul P)).det = (N.mul (M.mul P)).det
m.sum âˆˆ S
orthogonal_projection_fn K v âˆˆ K
irrational golden_conj
C a
f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
âˆƒ (S : C) (T : Î  {X : C}, X âˆˆ O â†’ (S âŸ¶ X)), âˆ€ {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y}, âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H â†’ T mX â‰« f = T mY
âˆƒ (P : finset (ideal R)) [_inst_7 : decidable_eq â†¥P] [_inst_8 : âˆ€ (p : ideal R), p âˆˆ P â†’ prime p] (e : â†¥P â†’ â„•), direct_sum.is_internal (Î» (p : â†¥P), submodule.torsion_by_set R M â†‘(â†‘p ^ e p))
circle_map c R '' set.Ioc 0 (2 * real.pi) = metric.sphere c |R|
has_sum (Î» (n : â„•), x ^ (n + 1) / (â†‘n + 1)) (-real.log (1 - x))
a.factors.disjoint b.factors
add_monoid.is_torsion_free (G â§¸ add_torsion G)
well_founded has_lt.lt
continuous (_.extend (Î» (p : Î² Ã— Î´), â‡‘(â‡‘Ï† p.fst) p.snd))
module.rank K V + module.rank K Vâ‚ = module.rank K Vâ‚‚ + module.rank K Vâ‚ƒ
0 â‰¤ â‡‘(fderiv_within â„ f s a) y
â‡‘f x = â‡‘g x
s.sum (Î» (i : Î¹), w i * z i) ^ p â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ p)
nonempty (V â‰ƒâ‚—[K] Vâ‚‚) â†” finite_dimensional.finrank K V = finite_dimensional.finrank K Vâ‚‚
is_least {n : â„• | 0 < n âˆ§ âˆƒ (x y : â„¤), â†‘n = a * x + b * y} (a.gcd b)
1 < a * b
metric.Hausdorff_dist (set.range (Gromov_Hausdorff.optimal_GH_injl X Y)) (set.range (Gromov_Hausdorff.optimal_GH_injr X Y)) â‰¤ Gromov_Hausdorff.HD f
antisymm_rel r a b â†’ a = b
A = â‡‘continuous_linear_map.adjoint B â†” âˆ€ (x : E) (y : F), has_inner.inner (â‡‘A x) y = has_inner.inner x (â‡‘B y)
asymptotics.is_O_with c l f (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ asymptotics.is_O_with c l f g'
âˆƒ (t : fin n â†’ fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š)), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†’ â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
â‡‘f l.prod = (list.map â‡‘f l).prod
â†‘a â‰¤ â†‘b â†” a â‰¤ b
is_atom a â†’ âŠ¥ â‹– a
a < b â†’ order.pred a < order.pred b
(generalized_continued_fraction.of v).h = â†‘âŒŠvâŒ‹
I = J
âˆƒ (N : â„•), âˆ€ (m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ padic_norm p (â‡‘f n) = padic_norm p (â‡‘f m)
â†‘n â‰¤ Ï†.order
filter.tendsto (Î» (n : Î¹), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) L (nhds (â‡‘â†‘Î¼ E))
is_totally_disconnected set.univ
category_theory.is_iso f
is_of_fin_add_order 0
(âˆ€ (a : set (submodule R M)), a.nonempty â†’ (âˆƒ (M' : submodule R M) (H : M' âˆˆ a), âˆ€ (I : submodule R M), I âˆˆ a â†’ M' â‰¤ I â†’ I = M')) â†” is_noetherian R M
is_add_left_regular (a + b)
2 â€¢ hb.oangle (r â€¢ x) y = 2 â€¢ hb.oangle x y
â‡‘Î¼ s = â¨… (t : {t // s âŠ† t âˆ§ measurable_set t}), â‡‘Î¼ â†‘t
s = has_insert.insert t.orthocenter (set.range t.points)
â‡‘h (x - y) = â‡‘h x - â‡‘h y
A.adjugate.adjugate = A.det ^ (fintype.card n - 2) â€¢ A
b < c
cont_diff ğ•œ n f â†” (âˆ€ (m : â„•), â†‘m â‰¤ n â†’ continuous (iterated_deriv m f)) âˆ§ âˆ€ (m : â„•), â†‘m < n â†’ differentiable ğ•œ (iterated_deriv m f)
(measure_theory.Lp.bounded_continuous_function E p Î¼).topological_closure = âŠ¤
polynomial.X * â‡‘polynomial.C r = â‡‘polynomial.C r * polynomial.X
category_theory.ProjectiveResolution.lift f P Q â‰« Q.Ï€ = P.Ï€ â‰« (chain_complex.singleâ‚€ C).map f
r âŠ” s = eqv_gen.setoid (r.rel âŠ” s.rel)
lipschitz_with C f â†’ âˆ€ (x y : E), âˆ¥f x - f yâˆ¥ â‰¤ â†‘C * âˆ¥x - yâˆ¥
smooth ((model_with_corners_self ğ•œ ğ•œ).prod (model_with_corners_self ğ•œ V)) (model_with_corners_self ğ•œ V) (Î» (p : ğ•œ Ã— V), p.fst â€¢ p.snd)
p i
âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
function.injective real.sinh
category_theory.cover_preserving J L (F â‹™ G)
â‡‘(probability_theory.cond Î¼ s) t * â‡‘Î¼ s + â‡‘(probability_theory.cond Î¼ sá¶œ) t * â‡‘Î¼ sá¶œ = â‡‘Î¼ t
strict_convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
0 < -a â†” a < 0
s âˆˆ uniformity Î± â†” âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î±}, has_edist.edist a b < Îµ â†’ (a, b) âˆˆ s
â‡‘c w x â†’ â‡‘c wâ»Â¹ xâ»Â¹
â‡‘clifford_algebra.involute (list.map â‡‘(clifford_algebra.Î¹ Q) l).prod = (-1) ^ l.length â€¢ (list.map â‡‘(clifford_algebra.Î¹ Q) l).prod
is_preirreducible s â†” âˆ€ (zâ‚ zâ‚‚ : set Î±), is_closed zâ‚ â†’ is_closed zâ‚‚ â†’ s âŠ† zâ‚ âˆª zâ‚‚ â†’ s âŠ† zâ‚ âˆ¨ s âŠ† zâ‚‚
submodule.map p.subtype âŠ¤ = p
function.surjective quotient.mk
f.mrange = âŠ¤
differentiable_on â„‚ (function.update f c (lim (nhds_within c {c}á¶œ) f)) s
A.adjugate.adjugate = A.det ^ (fintype.card n - 2) â€¢ A
âˆ« (x : â„) in a..b, real.sin x ^ (n + 2) = (real.sin a ^ (n + 1) * real.cos a - real.sin b ^ (n + 1) * real.cos b) / (â†‘n + 2) + (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, real.sin x ^ n
(s.altitude i).direction = (vector_span â„ (s.points '' â†‘(finset.univ.erase i)))á—® âŠ“ vector_span â„ (set.range s.points)
complete_lattice.independent p â†” function.injective â‡‘(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype))
n â‰  0 â†’ f n = n.factorization.prod (Î» (p k : â„•), f (p ^ k))
âŠ¤ âˆˆ F
group.normal_closure s âŠ† t
has_ftaylor_series_up_to â†‘(n + 1) f p â†” (âˆ€ (x : E), (p x 0).uncurry0 = f x) âˆ§ (âˆ€ (x : E), has_fderiv_at (Î» (y : E), p y 0) (p x 1).curry_left x) âˆ§ has_ftaylor_series_up_to â†‘n (Î» (x : E), â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p x 1)) (Î» (x : E), (p x).shift)
subsingleton (floor_semiring Î±)
g = c.lift f H
has_sum (Î» (n : â„•), r ^ n) (1 - r)â»Â¹
f.is_subordinate U â†’ f.to_partition_of_unity.is_subordinate U
s.prod (Î» (i : Î¹), f i + g i) = s.prod (Î» (i : Î¹), f i) + s.sum (Î» (i : Î¹), g i * (finset.filter (Î» (_x : Î¹), _x < i) s).prod (Î» (j : Î¹), f j + g j) * (finset.filter (Î» (j : Î¹), i < j) s).prod (Î» (j : Î¹), f j))
(âˆ€ (u : â„• â†’ Î±), cauchy_seq u â†’ (âˆƒ (a : Î±), filter.tendsto u filter.at_top (nhds a))) â†’ complete_space Î±
metric.thickening Î´â‚ E âŠ† metric.thickening Î´â‚‚ E
a.coprime p
(âˆ€ (i j : n), A j i = A i j) â†’ A.is_symm
tendsto_uniformly_on F f p s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), x âˆˆ s â†’ has_edist.edist (f x) (F n x) < Îµ)
f t = g t
âˆƒ (e : Î± â‰ƒ Î²), âˆ€ (a : Î±), g (â‡‘e a) = f a
x.compatible â†’ (category_theory.presieve.family_of_elements.restrict h x).compatible
filter.map n (filter.mapâ‚‚ m f g) = filter.mapâ‚‚ m' (filter.map n' f) g
(finset.range n).sum (Î» (i : â„•), i) * 2 = n * (n - 1)
f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
a âŠ‚ b â†’ b âŠ‚ c â†’ a âŠ‚ c
has_strict_fderiv_at (Î» (x : â„ Ã— â„), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) â€¢ continuous_linear_map.fst â„ â„ â„ + (p.fst ^ p.snd * real.log p.fst - real.exp (real.log p.fst * p.snd) * real.sin (p.snd * real.pi) * real.pi) â€¢ continuous_linear_map.snd â„ â„ â„) p
(âˆ€ (f : â„• â†’o submodule R M), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘f n = â‡‘f m) â†” is_noetherian R M
commute a a
_.mpr q = category_theory.eq_to_hom p â‰« q
-a < 0 â†” 0 < a
dense_range coe
f (t.center_mass w p) â‰¤ t.center_mass w (f âˆ˜ p)
hb.oangle (â‡‘(hb.conj_lie) x) (â‡‘(hb.conj_lie) y) = -hb.oangle x y
(generalized_continued_fraction.of v).s.nth n = option.some {a := 1, b := â†‘((generalized_continued_fraction.int_fract_pair.of (ifp_n.fr)â»Â¹).b)}
t.orthocenter âˆˆ affine.simplex.altitude t iâ‚
a âˆ£ -b â†” a âˆ£ b
euclidean_geometry.angle p2 p1 p3 = 0
path_connected_space E
a + b < 0
same_ray â„ x y â†” âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
same_ray R x z
t = uniform_space.to_topological_space
(â¨… (hâ‚ : p) (hâ‚‚ : q), s hâ‚ hâ‚‚) = â¨… (h : p âˆ§ q), s _ _
â‡‘f l.prod = (list.map â‡‘f l).prod
â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w - y) (x - z)
P p
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆ¥âˆ« (x : Î±), f x âˆ‚Î¼âˆ¥ < (â‡‘Î¼ set.univ).to_real * C
s.terminated_at n
k â‰¤ â‡‘roth_number_nat n
strict_anti_on f s â†’ strict_mono_on (f âˆ˜ â‡‘order_dual.of_dual) s
âˆƒ (y : Î²), infinite â†¥(f â»Â¹' {y})
âˆƒ (x : â„• â†’ Î±), filter.tendsto x filter.at_top f
set.eq_on f g t
p âˆˆ I
is_min a â†’ is_max (â‡‘order_dual.of_dual a)
f =o[nhds b] g â†” (f âˆ˜ â‡‘e) =o[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
asymptotics.is_O_with c l f' g' â†’ asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥)
small Î±
continuous (Î» (g : G), g * h * gâ»Â¹)
aâ»Â¹ < bâ»Â¹ â†’ b < a
(s.product t).sum (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = s.sum (Î» (x : Î³), t.sum (Î» (y : Î±), f x y))
torus_integrable (f + g) c R
(uniformity Î±).has_basis (Î» (Îµ : ennreal), 0 < Îµ) (Î» (Îµ : ennreal), {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < Îµ})
unique_diff_on ğ•œ ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source))
(nhds 0).has_basis (Î» (n : â„•), true) (Î» (n : â„•), â†‘(I ^ n))
âˆ€áµ (x : Î±) âˆ‚Î¼, P x
âˆƒ (c : F), f = function.const E c
complex.abs (complex.exp (â†‘a * (complex.exp z + complex.exp (-z)))) â‰¤ real.exp (a * real.cos b * real.exp |z.re|)
hf.degree âˆ£ f.nat_degree
measure_theory.mem_â„’p f p Î¼
finset.univ.sum (Î» (a : Î±), fintype.card â†¥(mul_action.fixed_by Î± Î² a)) = fintype.card (quotient (mul_action.orbit_rel Î± Î²)) * fintype.card Î±
(1 + A.mul B).det = (1 + B.mul A).det
â‡‘((category_theory.unit_comp_partial_bijective_aux A B).symm) f = (category_theory.adjunction.of_right_adjoint i).unit.app A â‰« f
has_dist.dist f g = 0
algebraic_geometry.structure_sheaf.to_open â†¥(algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X)) (prime_spectrum.basic_open r) â‰« f = X.to_to_Î“_Spec_map_basic_open r â†” f = X.to_Î“_Spec_c_app r
f â‰¤ nhds x
Ï† - â‡‘(power_series.C R) (â‡‘(power_series.constant_coeff R) Ï†) = power_series.mk (Î» (p : â„•), â‡‘(power_series.coeff R (p + 1)) Ï†) * power_series.X
isometry g
âˆƒ (m : â„¤), nonempty (witt_vector.isocrystal_equiv p k (witt_vector.standard_one_dim_isocrystal p k m) V)
b â‰¤ c - a â†’ a + b â‰¤ c
finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index (n + 2)), affine.simplex.monge_point_weights_with_circumcenter n i) = 1
s.noncomm_prod (f * g) _ = s.noncomm_prod f comm_ff * s.noncomm_prod g comm_gg
algebra.finite_type R (monoid_algebra R M) â†” monoid.fg M
fderiv_within â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (s Ã—Ë¢ t) (a, b) = (continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca
â‡‘(affine_map.line_map (f a) (f b)) r < f (â‡‘(affine_map.line_map a b) r) â†” slope f a b < slope f a (â‡‘(affine_map.line_map a b) r)
b = a
linear_map.trace R M = (contract_left R M).comp (dual_tensor_hom_equiv_of_basis b).symm.to_linear_map
mfderiv_within (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x = fderiv_within ğ•œ f s x
s.nonempty â†’ 0 < s.card
filter.map n (filter.mapâ‚‚ m f g) = filter.mapâ‚‚ m' (filter.map n' g) f
âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), âˆ¥z - xâˆ¥â»Â¹ * âˆ¥f z - f xâˆ¥ < r
is_integral R x â†’ is_algebraic R x
category_theory.is_iso f
âˆ¥xâˆ¥ ^ 2 = âˆ¥â‡‘(orthogonal_projection S) xâˆ¥ ^ 2 + âˆ¥â‡‘(orthogonal_projection Sá—®) xâˆ¥ ^ 2
a â‰¤ c - b â†’ a + b â‰¤ c
padic_val_int p â†‘p = 1
â‡‘zmod.Ï‡â‚ˆ' â†‘n = ite (n % 2 = 0) 0 (ite (n % 8 = 1 âˆ¨ n % 8 = 3) 1 (-1))
âˆƒ (f : bounded_continuous_function X â„), set.eq_on â‡‘f (function.const X a) s âˆ§ set.eq_on â‡‘f (function.const X b) t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc a b
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ {a, b}), f i)) = f a + f b
set.Union_lift S f hf T _ (op x y) = opÎ² (set.Union_lift S f hf T _ x) (set.Union_lift S f hf T _ y)
Â¬monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ is_of_fin_order g
frontier sá¶œ = frontier s
4 ^ n < n * n.central_binom
f = g
has_inner.inner x (s.sum (Î» (i : Î¹), f i)) = s.sum (Î» (i : Î¹), has_inner.inner x (f i))
P Î±
has_fpower_series_on_ball p.sum p 0 p.radius
category_theory.mono f
E.is_solution (E.mk_sol init)
âˆƒ (f : Î¹ â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ (s : set Î±), â‡‘Î¼ s < Î´ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ < Îµ
cont_diff_within_at ğ•œ â†‘(n + 1) f s x â†” âˆƒ (u : set E) (H : u âˆˆ nhds_within x (has_insert.insert x s)) (f' : E â†’ (E â†’L[ğ•œ] F)), (âˆ€ (x : E), x âˆˆ u â†’ has_fderiv_within_at f (f' x) u x) âˆ§ cont_diff_within_at ğ•œ â†‘n f' u x
category_theory.epi f
i.maximal â†” âˆ€ (Îº : Type v) (w : Îº â†’ M), linear_independent R w â†’ âˆ€ (j : Î¹ â†’ Îº), w âˆ˜ j = v â†’ function.surjective j
(f =O[l] Î» (x : Î±), -g' x) â†’ f =O[l] g'
infinite Î±
continuous f
a * (b - c) = a * b - a * c
Â¬a < b â†’ multiset.Ioc a b = 0
s.sum (Î» (i : Î¹), f i) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), f i ^ p)
has_dist.dist (f n) a â‰¤ C / 2 ^ n
is_lub s (has_Sup.Sup s)
continuous (Î» (f : â†¥(measure_theory.Lp G 1 Î¼)), measure_theory.integrable.to_L1 â‡‘f _)
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ set.range g), f i)) = finsum (Î» (j : Î²), f (g j))
is_submonoid set.univ
filter.tendsto (Î» (n : Î±), c n â€¢ (f (x + d n) - f x)) l (nhds (â‡‘f' v))
â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
ifp_succ_n.fr.num < ifp_n.fr.num
add_subgroup.comap f H.normalizer = (add_subgroup.comap f H).normalizer
a < b - c â†” c + a < b
â‡‘(fderiv_within â„ f s a) y â‰¤ 0
â†‘(intermediate_field.adjoin â†¥(intermediate_field.adjoin F S) T) = â†‘(intermediate_field.adjoin â†¥(intermediate_field.adjoin F T) S)
(â¨† (i : {i // f i â‰  âŠ¥}), f â†‘i) = â¨† (i : Î¹), f i
âˆ« (x : â„) in t..s + T, f x = (âˆ« (x : â„) in t..s, f x) + âˆ« (x : â„) in t..t + T, f x
m âˆˆ add_submonoid.closure S
â‡‘polynomial.C (â‡‘f r) * p âˆˆ polynomial.lifts f
set.range subtype.val = s
(spectrum â„‚ a).nonempty
e.is_image s t â†’ e.target âˆ© â‡‘(e.symm) â»Â¹' s = e.target âˆ© t
(â‡‘(power_series.monomial R n) a).order = ite (a = 0) âŠ¤ â†‘n
âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).card â‰¤ n
a < b â†’ b â‰¤ c â†’ a < c
âˆƒ (n : â„•), n âˆˆ finset.card '' {t : finset G | K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g * h) â»Â¹' V}
totally_bounded t
(Î½.restrict s).rn_deriv Î½ =áµ[Î½] s.indicator 1
category_theory.limits.has_colimits_of_size C
âˆƒ (x' : E) (H : x' âˆˆ s) (y' : E) (H : y' âˆˆ t), has_dist.dist x y â‰¤ has_dist.dist x' y'
âˆƒ (n : â„•), y ^ n < x
âˆƒ (p : polynomial â„), âˆ€ (x : â„), x âˆˆ set.Icc a b â†’ |polynomial.eval x p - f x| < Îµ
bdd_below (s âˆ© t)
has_inner.inner u v = 0
2 â€¢ o.oangle x (r â€¢ x) = 0
2 < lucas_lehmer.q (p' + 2)
has_sum (Î» (b : Î¹), â‡‘e (f b)) y â†” has_sum f (â‡‘(e.symm) y)
category_theory.is_filtered D
g b - g a â‰¤ âˆ« (y : â„) in a..b, Ï† y
isometry f
(B.restrict W).is_symm
closure (set.Ioi a) = set.Ici a
nonempty (category_theory.limits.is_limit (P.map_cone (category_theory.sieve.generate R).arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), category_theory.presieve.is_sheaf_for (P â‹™ category_theory.coyoneda.obj E) R
real.sin (inner_product_geometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = real.sqrt (has_inner.inner x x * has_inner.inner y y - has_inner.inner x y * has_inner.inner x y)
irreducible (polynomial.cyclotomic n â„¤)
âˆ¥fâˆ¥ = 0 â†” f = 0
mdifferentiable (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f â†” differentiable ğ•œ f
Ï† = Ïˆ â†” âˆ€ (n : â„•), â‡‘(power_series.coeff R n) Ï† = â‡‘(power_series.coeff R n) Ïˆ
â†‘r â‰¤ (q.comp p).radius
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), f x x)
p s
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
âˆƒ (y : Î±) (H : y âˆˆ set.Ico 0 c), f x = f y
convex_independent ğ•œ (Î» (i : â†¥s), p â†‘i)
has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥
â‡‘(hfdifferential _) (â‡‘(derivation.eval_at 1) â†‘X) = â‡‘(derivation.eval_at g) â†‘X
dense_range coe
âˆƒ (r : R), 0 â‰¤ r âˆ§ x = r â€¢ y
metric.Hausdorff_dist (closure s) t = metric.Hausdorff_dist s t
has_dist.dist p1 (midpoint â„ p1 p2) = has_dist.dist p2 (midpoint â„ p1 p2)
â‡‘v x = 0 â†” x = 0
x â‰  -x
â‡‘(measure_theory.outer_measure.restrict s) (has_Inf.Inf m) = has_Inf.Inf (â‡‘(measure_theory.outer_measure.restrict s) '' m)
â‡‘zmod.Ï‡â‚ˆ' a = 0 âˆ¨ â‡‘zmod.Ï‡â‚ˆ' a = 1 âˆ¨ â‡‘zmod.Ï‡â‚ˆ' a = -1
subsingleton (Î± â‰ƒ+*o Î²)
(list.drop i L).nth_le j h = L.nth_le (i + j) _
{a}.min' _ = a
irrational x
vector_span k (set.range p) = submodule.span k (set.range (Î» (i : Î¹), p i0 -áµ¥ p i))
category_theory.is_iso f â†” function.bijective f
coe â»Â¹' (coe '' U) = â‹ƒ (x : Î±) (H : x âˆˆ U), connected_component x
conformal_at f x â†” is_conformal_map (fderiv â„ f x)
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), (lgb - lga) * deriv f c = (lfb - lfa) * deriv g c
convex_independent ğ•œ p â†” âˆ€ (s : finset Î¹) (x : Î¹), p x âˆˆ â‡‘(convex_hull ğ•œ) â†‘(finset.image p s) â†’ x âˆˆ s
continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I M â»Â¹' s)
filter.tendsto coe filter.cofinite (filter.cocompact â„)
add_subgroup.pi set.univ H â‰¤ J â†” âˆ€ (i : Î·), add_subgroup.map (add_monoid_hom.single f i) (H i) â‰¤ J
cont_diff ğ•œ n f â†’ cont_mdiff (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f
continuous_on (iterated_deriv_within m f s) s
âˆƒ (t : set Î³) (H : t âŠ† s), t.countable âˆ§ s = closure t
S = T
finite_dimensional.finrank ğ•œ (X âŸ¶ X) = 1
â‡‘(e.adjust_to_orientation x) i = â‡‘e i âˆ¨ â‡‘(e.adjust_to_orientation x) i = -â‡‘e i
0 < L.length
âˆ¥S.normed_mkâˆ¥ = 0
f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
category_theory.mono f
cauchy_seq s
x ^ y * x ^ z â‰¤ x ^ (y + z)
f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
(n + 2).factors = (n + 2).min_fac :: ((n + 2) / (n + 2).min_fac).factors
bdd_above s
transitive (Î» (a b : S), âˆƒ (c : S), semiconj_by c a b)
âˆƒ (y : Î²), n < (finset.filter (Î» (x : Î±), f x = y) finset.univ).card
â†‘(â‡‘e i) = â†‘i
0 < a + b
(â‡‘â¨… (i : Î¹), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹), â‡‘(m i) (t n)
is_add_submonoid set.univ
measure_theory.integrable_on f K Î¼
finite_dimensional k â†¥((affine_span k s).direction)
function.injective (option.map f)
filter.tendsto (Î» (x : â„), real.exp x / x ^ s) filter.at_top filter.at_top
mul_action.fixed_points (conj_act G) G = â†‘(subgroup.center G)
has_Sup.Sup (s âˆª t) = has_Sup.Sup s âŠ” has_Sup.Sup t
euclidean_geometry.orthogonal_projection_fn s p -áµ¥ p âˆˆ (s.direction)á—®
mul_opposite.op (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), mul_opposite.op (f x))
filter.tendsto f (nhds_within x s) (nhds (f x))
(s.product t).bUnion f = s.bUnion (Î» (a : Î±), t.bUnion (Î» (b : Î²), f (a, b)))
topological_space.is_topological_basis (â‹ƒ (i : Î¹), (Î» (u : set (E i)), sigma.mk i '' u) '' s i)
strict_mono f â†’ strict_anti (â‡‘order_dual.to_dual âˆ˜ f)
b â‰¤ c â†’ a = b â†’ a â‰¤ c
s.powerset.sum (Î» (t : finset Î±), f t) = (finset.range (s.card + 1)).sum (Î» (j : â„•), (finset.powerset_len j s).sum (Î» (t : finset Î±), f t))
filter.tendsto (Î» (t : Î±), has_strict_fderiv_at.implicit_function f f' hf hf' (gâ‚ t) (gâ‚‚ t)) l (nhds a)
filter.tendsto f filter.at_top filter.at_top â†” âˆ€ (b : Î²), âˆƒ (a : Î±), b â‰¤ f a
1 + â†‘n * a â‰¤ (1 + a) ^ n
1 â‰¤ aâ»Â¹ â†’ a â‰¤ 1
a âˆˆ s
f = g â†” âˆ€ (p i : â„•), nat.prime p â†’ â‡‘f (p ^ i) = â‡‘g (p ^ i)
(â‡‘dfinsupp.lift_add_hom f).comp (dfinsupp.single_add_hom Î² i) = f i
filter.tendsto (Î» (x : Î±), f x * r) l filter.at_top
g.convergents (n + 1) = (g.squash_gcf n).convergents n
a * x * x + b * x + c = 0 â†” discrim a b c = (2 * a * x + b) ^ 2
generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.none â†” generalized_continued_fraction.int_fract_pair.stream v n = option.none âˆ¨ âˆƒ (ifp : generalized_continued_fraction.int_fract_pair K), generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp âˆ§ ifp.fr = 0
f x âˆ˜ f y = f (f x y)
(Î» (_x : Mâ‚€), _x * 0) = function.const Mâ‚€ 0
set.eq_on f 0 {z : â„‚ | 0 â‰¤ z.re}
â‡‘f (c â€¢ x) = c â€¢ â‡‘f x
category_theory.limits.has_limit K
(polynomial.cyclotomic n R).monic
Â¬(a âˆ§ b) â†” Â¬a âˆ¨ Â¬b
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ has_insert.insert a s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
galois_connection (Î» (I : ideal R), prime_spectrum.zero_locus â†‘I) (Î» (t : (set (prime_spectrum R))áµ’áµˆ), prime_spectrum.vanishing_ideal t)
antilipschitz_with K f â†’ âˆ€ (x y : Î±), has_nndist.nndist x y â‰¤ K * has_nndist.nndist (f x) (f y)
has_strict_deriv_at complex.cosh (complex.sinh x) x
is_unit (â†‘u * a) â†” is_unit a
Î¼.restrict s â‰¤ Î½.restrict s'
set.surj_on (Î» (g : matrix.special_linear_group (fin 2) R), â†‘g 1) set.univ {cd : fin 2 â†’ R | is_coprime (cd 0) (cd 1)}
1 < a * b
measurable_set {x : Î± | Ï„ x < i}
is_semiring_hom (g âˆ˜ f)
complete_lattice.independent f â†’ finset.univ.sup_indep f
has_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)) (a, b)
X.Î´ i â‰« X.Î´ (â‡‘fin.cast_succ i) = X.Î´ i â‰« X.Î´ i.succ
add_con_gen r â‰¤ add_con_gen s
finite_dimensional.finrank ğ•œ (X âŸ¶ Y) = 0
A.det â€¢ matrix.vec_mul b Aâ»Â¹ = â‡‘(A.transpose.cramer) b
Â¬bdd_below s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), y < x
fact (even (fintype.card (fin (bit0 k))))
â‡‘zmod.Ï‡â‚„ â†‘n = (-1) ^ (n / 2)
e.to_matrix â‡‘(e.units_smul w) = matrix.diagonal (coe âˆ˜ w)
âˆƒ (t : finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i) = âˆ…
list.sorted has_le.le (denumerable.raise l n)
1 = Mon.filtered_colimits.M.mk F âŸ¨j, 1âŸ©
(generalized_continued_fraction.of v).s.nth n = option.some {a := 1, b := â†‘(ifp_succ_n.b)}
orthonormal ğ•œ (gram_schmidt_normed ğ•œ f)
f.range = âŠ¤
a â‰  0
cont_diff_at ğ•œ n (Î» (x : E), -f x) x
measure_theory.uniform_integrable (Î» (n : Î¹), g) p Î¼
âˆ¥measure_theory.Lp_meas_subgroup_to_Lp_trim F p Î¼ hm fâˆ¥ = âˆ¥fâˆ¥
âˆƒ (n : â„•), n â‰  0 âˆ§ (f ^ n).ker âŠ“ (f ^ n).range = âŠ¥
(Î» (i : Î±), dite (i âˆˆ s) (Î» (h : i âˆˆ s), function.update v j x (â‡‘(e.symm) âŸ¨i, hâŸ©)) (Î» (h : i âˆ‰ s), w i)) = function.update (Î» (i : Î±), dite (i âˆˆ s) (Î» (h : i âˆˆ s), v (â‡‘(e.symm) âŸ¨i, hâŸ©)) (Î» (h : i âˆ‰ s), w i)) â†‘(â‡‘e j) x
âˆ€á¶  (a : set Î±) in v.filter_at x, â‡‘Î¼ a < âŠ¤
â‡‘(c.lift f H) â†‘x = â‡‘f x
(âˆ€ (x : Î±), âˆƒ (y : Î² x), P x y) â†” âˆƒ (f : Î  (a : Î±), Î² a), âˆ€ (x : Î±), P x (f x)
2 â€¢ o.oangle (r â€¢ x) x = 0
ennreal.of_real |(matrix.diagonal D).det| â€¢ measure_theory.measure.map â‡‘(â‡‘matrix.to_lin' (matrix.diagonal D)) measure_theory.measure_space.volume = measure_theory.measure_space.volume
â‡‘f (a + -b) = â‡‘f a + -â‡‘f b
totally_separated_space Î±
a :: lâ‚ <+~ a :: lâ‚‚ â†’ lâ‚ <+~ lâ‚‚
â‡‘f xâ»Â¹ = â‡‘g xâ»Â¹
I = 0
metric.bounded s
â‡‘(power_series.coeff R n) (Ï† * Ïˆ) = 0
measure_theory.outer_measure.mk_metric mâ‚ â‰¤ measure_theory.outer_measure.mk_metric mâ‚‚
measure_theory.measure.map f Î¼ = measure_theory.measure.sum (Î» (b : Î²), â‡‘Î¼ (f â»Â¹' {b}) â€¢ measure_theory.measure.dirac b)
image_to_kernel f g w â‰« category_theory.limits.kernel_subobject_map Î² = category_theory.limits.image_subobject_map Î± â‰« image_to_kernel f' g' w'
f = g
filter.tendsto (Î» (r : â„), â‡‘Î¼ (metric.cthickening r s)) (nhds 0) (nhds (â‡‘Î¼ (closure s)))
Â¬a < b â†’ finset.Ioc a b = âˆ…
interval_integrable (Î» (Î¸ : â„), deriv (circle_map c R) Î¸ â€¢ f (circle_map c R Î¸)) measure_theory.measure_space.volume 0 (2 * real.pi)
(setoid.mk_classes c _).classes = c
b < aâ»Â¹ * c â†’ a * b < c
disjoint s t â†’ disjoint (filter.principal s) (filter.principal t)
l <+: list.nil â†’ l = list.nil
(f + g).sum h = f.sum h + g.sum h
category_theory.limits.has_limit F
âˆƒ (M : ideal Î±), M.is_maximal
(â¨… (i : Î¹), f i) = b
set.image2 f s (g '' t) = g' '' set.image2 f' t s
0 < real.cosh x
multiplicity p (p * (n + 1)).factorial = multiplicity p (p * n).factorial + multiplicity p (n + 1) + 1
â‡‘(alternating_map.dom_coprod.summand a b Ïƒ) v + â‡‘(alternating_map.dom_coprod.summand a b (equiv.swap i j â€¢ Ïƒ)) v = 0
has_deriv_at (exp ğ•‚) (exp ğ•‚ x) x
is_regular 1
â‡‘Î¼ K < âŠ¤
function.injective p
âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0
strict_mono (Î» (x : Î²), f x + g x)
j - pnat_multiplicity p âŸ¨j + 1, _âŸ© + n = i + j + (n - i - pnat_multiplicity p âŸ¨j + 1, _âŸ©)
(s.face h).points i = s.points (â‡‘(fs.order_emb_of_fin h) i)
(s.affine_combination p).linear = s.weighted_vsub p
measure_theory.simple_func.integral Î¼ (measure_theory.simple_func.map (ennreal.to_real âˆ˜ g) f) = (âˆ«â» (a : Î±), g (â‡‘f a) âˆ‚Î¼).to_real
Ï€â‚.boxes.sum (Î» (J : box_integral.box Î¹), â‡‘f J) = Ï€â‚‚.boxes.sum (Î» (J : box_integral.box Î¹), â‡‘f J)
list.split_on x ([x].intercalate ls) = ls
â‡‘g (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), â‡‘g (f x))
category_theory.is_pullback hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚
â†‘u â‰  0
(Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom â‰« category_theory.limits.pi.Ï€ (Î» (p : (Î£ (V : topological_space.opens â†¥X), {f // R f}) Ã— Î£ (V : topological_space.opens â†¥X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R p.fst âŠ“ Top.presheaf.covering_of_presieve U R p.snd))) (f, g) = category_theory.limits.pi.Ï€ (Î» (fg : (Î£ (V : topological_space.opens â†¥X), {f // R f}) Ã— Î£ (W : topological_space.opens â†¥X), {g // R g}), F.obj (opposite.op (category_theory.limits.pullback fg.fst.snd.val fg.snd.snd.val))) (f, g) â‰« F.map (category_theory.eq_to_hom _).op
category_theory.limits.has_binary_product Q P
0.lf x â†” âˆƒ (i : x.left_moves), âˆ€ (j : (x.move_left i).right_moves), 0.lf ((x.move_left i).move_right j)
(polynomial_functions unit_interval).topological_closure = âŠ¤
category_theory.exact (F.map f) (F.map g)
â†‘(â‡‘(s.orthogonal_projection_span) p) = s.circumcenter
f (â‡‘(affine_map.line_map a b) r) < â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a b < slope f (â‡‘(affine_map.line_map a b) r) b
(Î± â†ª Î²) â†’ (Î² â†ª Î±) â†’ nonempty (Î± â‰ƒ Î²)
euclidean_geometry.angle p1 p2 p3 + euclidean_geometry.angle p2 p3 p1 + euclidean_geometry.angle p3 p1 p2 = real.pi
â‡‘f (g ^ n) = â‡‘f g ^ n
B.nondegenerate â†” âˆ€ (i : n), Â¬B.is_ortho (â‡‘v i) (â‡‘v i)
is_closed_map prod.snd
is_prime_pow n â†” âˆƒ! (p : â„•), nat.prime p âˆ§ p âˆ£ n
function.is_fixed_pt id x
cont_diff ğ•œ n f â†” has_ftaylor_series_up_to n f (ftaylor_series ğ•œ f)
â‡‘(clifford_algebra.Î¹ Q) m * â‡‘(clifford_algebra.Î¹ Q) m = â‡‘(algebra_map R (clifford_algebra Q)) (â‡‘Q m)
noncompact_space E
continuous (Î» (p : continuous_multilinear_map ğ•œ E G Ã— Î  (i : Î¹), E i), â‡‘(p.fst) p.snd)
âˆƒ (Î½ : measure_theory.measure Î±), measure_theory.is_finite_measure Î½ âˆ§ Î¼.absolutely_continuous Î½
add_comm_monoid.add_torsion G = âŠ¤
c = d
â‡‘(algebra.norm K) x = 0 â†” x = 0
x - x ^ 3 / 4 < real.sin x
has_nndist.nndist x y = 0 â†” x = y
(âˆ€ (a : K), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
category_theory.limits.has_terminal D
matrix.det (Î» (i j : n), v i * A i j) = finset.univ.prod (Î» (i : n), v i) * A.det
0 < a - b â†’ b < a
zmod.legendre_sym p (a ^ 2) = 1
measure_theory.unif_integrable f p Î¼
cardinal.mk â†¥(S âˆª T) â‰¤ cardinal.mk â†¥S + cardinal.mk â†¥T
s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
is_domain (polynomial R â§¸ ideal.map polynomial.C P)
linear_independent L (Î» (f : G â†’* L), â‡‘f)
âˆƒ (x : P), x âˆˆ ğ’Ÿ i âˆ§ x âˆˆ order.ideal_of_cofinals p ğ’Ÿ
e.to_linear_map.to_add_monoid_hom = e.to_add_equiv.to_add_monoid_hom
s.countable â†’ {t : set Î± | t.finite âˆ§ t âŠ† s}.countable
cardinal.mk Îº â‰¤ cardinal.mk Î¹
â…Ÿ A = Aâ»Â¹
subfield.closure s â‰¤ subfield.closure t
x.is_amalgamation (category_theory.Ran_is_sheaf_of_cover_lifting.glued_section hu â„± hS hx)
linear_map.trace R M = (contract_left R M).comp (dual_tensor_hom_equiv R M M).symm.to_linear_map
âˆƒ (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C / â†‘r ^ n
valuation_ring ğ’ª
Î¼.absolutely_continuous Î½
(s.erase a).sum (Î» (x : Î±), f x) + f a = s.sum (Î» (x : Î±), f x)
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ âˆ…), f i)) = 1
(matrix.diagonal v).is_symm
cont_diff_on ğ•œ n (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) â†” cont_diff_on ğ•œ n f s
â†‘-1 = â†‘n - 1
l.has_basis (Î» (i : Î¹), p i âˆ§ s i âŠ† V) s
is_compact s â†” âˆ€ {Î¹ : Type u} (Z : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_closed (Z i)) â†’ (s âˆ© â‹‚ (i : Î¹), Z i) = âˆ… â†’ (âˆƒ (t : finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i) = âˆ…)
filter.tendsto (Î» (x : Î±), xâ»Â¹) (nhds_within 0 (set.Ioi 0)) filter.at_top
t.orthocenter = affine.simplex.monge_point t
function.injective (function.comp g)
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆ¥â¨ (x : Î±), f x âˆ‚Î¼âˆ¥ < C
o.to_pgame.numeric
filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
measure_theory.integrable_on g' (set.Ioc a b) measure_theory.measure_space.volume
(s.circumcenter_circumradius.fst âˆˆ affine_span â„ (set.range s.points) âˆ§ âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) s.circumcenter_circumradius.fst = s.circumcenter_circumradius.snd) âˆ§ âˆ€ (cccr : P Ã— â„), (cccr.fst âˆˆ affine_span â„ (set.range s.points) âˆ§ âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) cccr.fst = cccr.snd) â†’ cccr = s.circumcenter_circumradius
continuous_within_at f (set.Iic a) a
minpoly A 0 = polynomial.X
T.morâ‚ â‰« T.morâ‚‚ = 0
C x hx
real.arsinh (real.sinh x) = x
real.pi < a
subsingleton Î±
has_dist.dist p â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) â‰  0
a < b â†’ P a b
function.injective (Î» (_x : P), _x -áµ¥ p)
nat.find _ = group.nilpotency_class G
finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary f (g âˆ˜ â‡‘Ïƒ)
affine_independent k (Î» (x : â†¥(set.range p)), â†‘x)
Â¬is_max a
set.inj_on (Î» (J : box_integral.box Î¹), {i : Î¹ | J.lower i = x i}) {J : box_integral.box Î¹ | J âˆˆ Ï€ âˆ§ x âˆˆ â‡‘box_integral.box.Icc J}
f y = g y
spectrum ğ•œ (â‡‘(polynomial.aeval a) p) = (Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a
(L.prod)â»Â¹ = (list.map (Î» (x : G), xâ»Â¹) L).reverse.prod
measure_theory.strongly_measurable f â†” measurable f âˆ§ topological_space.is_separable (set.range f)
order_of (quaternion_group.a 1) = 2 * n
âˆ« (x : â„) in 0..t, g x â‰¤ has_Sup.Sup ((Î» (t : â„), âˆ« (x : â„) in 0..t, g x) '' set.Icc 0 T) + âŒŠt / TâŒ‹ â€¢ âˆ« (x : â„) in 0..T, g x
upper_semicontinuous_at (Î» (z : Î±), f z + g z) x
â‡‘(is_localization.lift hg) (is_localization.mk' S x y) = â‡‘g x * â†‘(â‡‘(is_unit.lift_right (g.to_monoid_hom.restrict M) hg) y)â»Â¹
set.eq_on f 0 {z : â„‚ | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}
âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0
function.semiconj (Î» (x : Î±), â¨† (g' : G), â‡‘(â‡‘fâ‚ g')â»Â¹ (â‡‘(â‡‘fâ‚‚ g') x)) â‡‘(â‡‘fâ‚‚ g) â‡‘(â‡‘fâ‚ g)
function.injective tensor_product.algebra_tensor_module.curry
category_theory.has_lifting_property i (category_theory.arrow.mk (ğŸ™ X))
bdd_above â†‘s
â†‘Aâ»Â¹ = (â†‘A)â»Â¹
convex_on ğ•œ s (-f) â†” concave_on ğ•œ s f
measure_theory.measure.mk_metric mâ‚ â‰¤ measure_theory.measure.mk_metric mâ‚‚
s.direction = âŠ¤ â†” s = âŠ¤
k âŠ† â†‘(add_subgroup.closure k)
category_theory.is_reflexive_pair g f
(c.lift f H).comp c.mk' = f
equiv.swap i j * (equiv.swap i j * Ïƒ) = Ïƒ
S.normed_mk.ker = S
âˆ¥â‡‘(add_monoid_hom.mul_right x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
(polynomial.X ^ n - â‡‘polynomial.C â†‘u).separable
subsingleton Î±
(âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.interval_oc a b), P x) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.Ioc a b), P x) âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.Ioc b a), P x
â¨ (x : Î±), g (f x) âˆ‚Î¼ â‰¤ g (â¨ (x : Î±), f x âˆ‚Î¼)
list.take (list.take i (list.map list.length L)).sum L.join = (list.take i L).join
âˆ«â» (x : G), f (x + g) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
function.bijective â‡‘(algebra_map K Kâ‚˜)
f = g
n â€¢ a âˆˆ s
function.injective â‡‘(I.quotient_map f le_rfl)
x âˆˆ S â†’ xâ»Â¹ âˆˆ S
is_compact s â†” is_seq_compact s
âŸ¦x.some_ray_vectorâŸ§ = x
lower_semicontinuous (Î» (z : Î±), f z + g z)
1 < a * b
measurable (Î» (x : Î±), ite (p x) (f x) (g x))
(nhds a).has_basis (Î» (s : set Î±), a âˆˆ s âˆ§ is_open s) (Î» (s : set Î±), s)
âˆƒ (y : Î±) (H : y âˆˆ set.Ico a (a + c)), f x = f y
affine_independent k coe â†” affine_independent k coe
algebraic_topology.alternating_face_map_complex.obj_d X (n + 1) â‰« algebraic_topology.alternating_face_map_complex.obj_d X n = 0
â†‘(â‡‘(orthogonal_projection K) v) = v â†” v âˆˆ K
âˆƒ (Î´ : â„) (hÎ´ : 0 < Î´), âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰¤ ennreal.of_real Î´ â†’ measure_theory.snorm (s.indicator f) p Î¼ â‰¤ 2 * ennreal.of_real Îµ
filter.tendsto f filter.at_top (nhds b) â†” âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (N : Î±), âˆ€ (n : Î±), N < n â†’ âˆ¥f n - bâˆ¥ < Îµ)
(f =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f =O[l] g'
category_theory.simple X
â†‘(â‡‘abv (â‡‘(algebra.norm R) a)) < â†‘(class_group.norm_bound abv bS) * y ^ fintype.card Î¹
finset.univ.sum (Î» (i : Î¹), finset.centroid_weights_indicator k s i) = 1
is_add_submonoid (sâ‚ âˆ© sâ‚‚)
setoid.r = setoid.r â†” c = d
finsupp.map_domain â‡‘f (x * y) = finsupp.map_domain â‡‘f x * finsupp.map_domain â‡‘f y
f = g
same_ray R (-x) (-y) â†” same_ray R x y
category_theory.is_filtered D
function.bijective â‡‘(polynomial.gal.gal_action_hom p â„‚)
(Î¼.restrict A).weakly_regular
H = add_subgroup.closure {a}
a + b < 0
âˆƒ (m : M), â‡‘(quotient_add_group.mk' S) m = x âˆ§ âˆ¥mâˆ¥ < âˆ¥xâˆ¥ + Îµ
âˆƒ (p : â„•), liouville.liouville_number_initial_terms â†‘m k = â†‘p / â†‘m ^ k.factorial
measure_theory.integrable_on f K Î¼
is_bot a â†’ is_top (â‡‘order_dual.of_dual a)
â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds_within (â‡‘(ext_chart_at I x) x') (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I)
â†‘(â‡‘(category_theory.limits.trident.is_limit.hom_iso ht Z') (q â‰« k)) = q â‰« â†‘(â‡‘(category_theory.limits.trident.is_limit.hom_iso ht Z) k)
pairwise (disjoint on Î» (n : Î±), set.Ico (f (order.pred n)) (f n))
â‡‘f s.prod = (multiset.map â‡‘f s).prod
0.order = âŠ¤
tangent_map I I.tangent (tangent_bundle.zero_section I M) p = âŸ¨âŸ¨p.fst, 0âŸ©, (p.snd, 0)âŸ©
is_of_fin_order (x i)
filter.tendsto (Î» (x : Î²), f x / r) l filter.at_bot
f (x + y) = f x + f y
add_subgroup.map f (add_subgroup.closure s) = add_subgroup.closure (â‡‘f '' s)
âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
x + t â€¢ (y - x) âˆˆ interior s
cont_diff_at ğ•œ n ring.inverse â†‘x
ideal.map (algebra_map R (localization.at_prime I)) I = local_ring.maximal_ideal (localization I.prime_compl)
x âˆˆ s â†’ xâ»Â¹ âˆˆ s
âˆ«â» (x : G), f (g * x) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
is_coprime (polynomial.X - â‡‘polynomial.C a) (f /â‚˜ (polynomial.X - â‡‘polynomial.C a))
F.is_sheaf â†” F.is_sheaf_unique_gluing
same_ray R x (r â€¢ y)
topological_space.is_separable (f '' s)
inner_product_space.is_self_adjoint (T.restrict hV)
s âˆˆ nhds a â†” âˆƒ (t : set Î±) (H : t âˆˆ b), a âˆˆ t âˆ§ t âŠ† s
simplex_category.Î´ i.succ â‰« simplex_category.Ïƒ i = ğŸ™ (simplex_category.mk n)
upper_central_series_step H = subgroup.comap (quotient_group.mk' H) (subgroup.center (G â§¸ H))
collinear k s â†” finite_dimensional.finrank k â†¥(vector_span k s) â‰¤ 1
0 < a ^ 2
v.reverse.to_list = v.to_list.reverse
function.bijective â‡‘f âˆ¨ f = 0
filter.tendsto (Î» (n : â„•), â†‘n * r ^ n) filter.at_top (nhds 0)
algebra.discr K â‡‘(B.basis) â€¢ z âˆˆ algebra.adjoin R {B.gen}
complete_space (Î£ (i : Î¹), E i)
function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 1 â†’ a = 1
filter.tendsto (Î» (x : Î±), f x / g x) l (nhds 0) â†’ f =o[l] g
set.eq_on f 0 {z : â„‚ | 0 â‰¤ z.re âˆ§ z.im â‰¤ 0}
joined âŸ¨x, _âŸ© âŸ¨y, _âŸ©
âˆƒ (i j : set Î±), measurable_set i âˆ§ 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i âˆ§ measurable_set j âˆ§ measure_theory.vector_measure.restrict s j â‰¤ 0.restrict j âˆ§ is_compl i j
measurable f â†’ measurable_space.comap f mâ‚‚ â‰¤ mâ‚
cauchy_seq u â†” âˆ€ (Îµ : nnreal), 0 < Îµ â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), N â‰¤ n â†’ has_edist.edist (u n) (u N) < â†‘Îµ)
â†‘(ideal.quotient.mkâ‚ Râ‚ I).ker = I
analytic_on ğ•œ (fderiv ğ•œ f) s
affine_independent k p â†” finite_dimensional.finrank k â†¥(vector_span k (set.range p)) = n
a + b â‰¤ c â†’ b â‰¤ c - a
s âŠ† â†‘(subring.closure s)
set.eq_on f g {z : â„‚ | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}
vector_span k s = submodule.span k ((Î» (_x : P), _x -áµ¥ p) '' s)
âˆƒ (z : â„¤), b = â†‘z
âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds (Ï.rn_deriv Î¼ x))
2 * polynomial.chebyshev.T R m * polynomial.chebyshev.T R (m + k) = polynomial.chebyshev.T R (2 * m + k) + polynomial.chebyshev.T R k
â‡‘Ï s â‰¤ â‡‘Î½ s
(algebraic_topology.dold_kan.HÏƒ q).f n = G.map ((algebraic_topology.dold_kan.HÏƒ q).f n)
k = l
category_theory.is_cofiltered D
g = c.lift f H
x âˆˆ upper_central_series G (n + 1) â†” âˆ€ (y : G), x * y * xâ»Â¹ * yâ»Â¹ âˆˆ upper_central_series G n
zmod.legendre_sym p (a * b) = zmod.legendre_sym p a * zmod.legendre_sym p b
is_compl (submodule.span K {x}) (B.orthogonal (submodule.span K {x}))
is_right_regular (a * b)
âˆƒ (s : set Î±), s.countable âˆ§ dense s âˆ§ (âˆ€ (x : Î±), is_bot x â†’ x âˆ‰ s) âˆ§ âˆ€ (x : Î±), is_top x â†’ x âˆ‰ s
k â‰  0
C * (y - x) â‰¤ f y - f x
X = category_theory.subobject.mk f
category_theory.limits.has_colimit F
matrix.det (Î» (i j : n), v j * A i j) = finset.univ.prod (Î» (i : n), v i) * A.det
âˆƒ (Î´ : â„), 0 < Î´ âˆ§ Î´ < 1 âˆ§ âˆ€ (s : finset E), (âˆ€ (c : E), c âˆˆ s â†’ âˆ¥câˆ¥ â‰¤ 2) â†’ (âˆ€ (c : E), c âˆˆ s â†’ âˆ€ (d : E), d âˆˆ s â†’ c â‰  d â†’ 1 - Î´ â‰¤ âˆ¥c - dâˆ¥) â†’ s.card â‰¤ besicovitch.multiplicity E
(p ^ k).factors.to_finset = {p}
has_edist.edist x y â‰¤ emetric.diam s
category_theory.is_pullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚
c.pairwise_disjoint id
0 < exp_neg_inv_glue x
discrete_valuation_ring (witt_vector p k)
Ï†â‚ = Ï†â‚‚
finset.filter p s = s
cardinal.aleph_0 â‰¤ a * b â†” a â‰  0 âˆ§ b â‰  0 âˆ§ (cardinal.aleph_0 â‰¤ a âˆ¨ cardinal.aleph_0 â‰¤ b)
â‡‘((category_theory.tensor_right_hom_equiv (X' âŠ— X) Y Y' (Z' âŠ— Z)).symm) ((g âŠ— f) â‰« (Î±_ Z' Z Y').inv) = (Î±_ X' X Y).hom â‰« (g âŠ— â‡‘((category_theory.tensor_right_hom_equiv X Y Y' Z).symm) f)
measure_theory.condexp m Î¼ f =áµ[Î¼.restrict s] measure_theory.condexp mâ‚‚ Î¼ f
dense (â‹ƒ (s : Î²), interior (f s))
filter.tendsto f tâ‚€ (nhds 0)
filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)
category_theory.limits.has_binary_biproduct X Y
âˆƒ (U : set Î±) (H : U âˆˆ nhds x), U âˆ© s = {x}
f (infi g) = infi (f âˆ˜ g)
uniform_continuous â‡‘f â†” is_open â†‘(â†‘f.ker)
is_clopen (Z âˆ© a)
f âˆˆ s.finsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘f i âˆˆ â‡‘t i
isometry (Gromov_Hausdorff.optimal_GH_injr X Y)
box_integral.has_integral I âŠ¥ (Î» (x : fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i)) box_integral.box_additive_map.volume (finset.univ.sum (Î» (i : fin (n + 1)), box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.upper i) x) i) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.lower i) x) i) box_integral.box_additive_map.volume))
I = âŠ¥ âˆ¨ I = âŠ¤
summable (Î» (i : Î±), âˆ¥â‡‘f iâˆ¥ * âˆ¥â‡‘g iâˆ¥) âˆ§ âˆ‘' (i : Î±), âˆ¥â‡‘f iâˆ¥ * âˆ¥â‡‘g iâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥gâˆ¥
is_add_left_regular g
strict_convex_space â„ E
â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |(â‡‘linear_map.det f)â»Â¹| * â‡‘Î¼ s
(s + 1).partial_Gamma X = s * s.partial_Gamma X - â†‘(real.exp (-X)) * â†‘X ^ s
has_fpower_series_on_ball (Î» (z : E), f (z - y)) p (x + y) r
a + b - c = a + (b - c)
has_deriv_at (exp_neg_inv_glue.f_aux n) (polynomial.eval x (exp_neg_inv_glue.P_aux (n + 1)) * real.exp (-xâ»Â¹) / x ^ (2 * (n + 1))) x
F = G
box_integral.has_integral I l f Î¼.to_box_additive.to_smul (âˆ« (x : Î¹ â†’ â„) in â†‘I, f x âˆ‚Î¼)
measure_theory.has_pdf (g âˆ˜ X) Â«â„™Â» Î½
submodule.map clifford_algebra.reverse (p * q) = submodule.map clifford_algebra.reverse q * submodule.map clifford_algebra.reverse p
std_simplex â„ Î¹ âŠ† metric.closed_ball 0 1
reflection âŠ¥ = linear_isometry_equiv.neg ğ•œ
gauge s x = has_Inf.Inf {r âˆˆ set.Ioi 0 | râ»Â¹ â€¢ x âˆˆ s}
D1 = D2
â‡‘(measure_theory.measure.hausdorff_measure d) s = â¨† (r : ennreal) (hr : 0 < r), â¨… (t : â„• â†’ set X) (hts : s âŠ† â‹ƒ (n : â„•), t n) (ht : âˆ€ (n : â„•), emetric.diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (h : (t n).nonempty), emetric.diam (t n) ^ d
x.lf z
â‡‘(ideal.quotient.mk I) x âˆˆ ideal.map (ideal.quotient.mk I) J â†” x âˆˆ J
set.interval a c âŠ† set.interval a b âˆª set.interval b c
â‡‘(orientation.map Î¹ f) x = (â‡‘linear_equiv.det f)â»Â¹ â€¢ x
e.symm.trans e' âˆˆ G
a + b < 0
is_prime_pow (fintype.card Î±)
lipschitz_on_with C f s
ideal.comap (algebra_map R (localization.at_prime I)) (local_ring.maximal_ideal (localization I.prime_compl)) = I
(-o).oangle x y = -o.oangle x y
filter.map (Î» (s : finset Î²), s.sum (Î» (b : Î²), f b)) filter.at_top â‰¤ filter.map (Î» (s : finset Î³), s.sum (Î» (x : Î³), g x)) filter.at_top
group.fg G â†” monoid.fg G
â‡‘f x = â‡‘f y â†’ (âˆƒ (z : â†¥P), â‡‘f z = 0 âˆ§ âˆ€ (R : C) (g : P âŸ¶ R), â‡‘g y = 0 â†’ â‡‘g z = â‡‘g x)
padic_val_rat p (q ^ k) = â†‘k * padic_val_rat p q
fourier_subalgebra.topological_closure = âŠ¤
has_deriv_at (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x
strict_convex_on â„ set.univ f
Î¼.restrict s â‰¤ Î½.restrict s'
filter.tendsto f (nhds_within c {c}á¶œ) (nhds (lim (nhds_within c {c}á¶œ) f))
0 < -a â†’ a < 0
âˆƒ (f : (Î  (n : â„•), E n) â†’ Î  (n : â„•), E n), (âˆ€ (x : Î  (n : â„•), E n), x âˆˆ s â†’ f x = x) âˆ§ set.range f = s âˆ§ continuous f
â‡‘(algebra.norm K) pb.gen = (-1) ^ pb.dim * (minpoly K pb.gen).coeff 0
p (finprod (Î» (i : Î±), f i))
âˆƒ (v : F) (H : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (w : â†¥K), âˆ¥u - â†‘wâˆ¥
has_inner.inner x y = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
âˆƒ (t : â„• â†’ set E) (A : â„• â†’ (E â†’L[â„] F)), pairwise (disjoint on t) âˆ§ (âˆ€ (n : â„•), measurable_set (t n)) âˆ§ (s âŠ† â‹ƒ (n : â„•), t n) âˆ§ (âˆ€ (n : â„•), approximates_linear_on f (A n) (s âˆ© t n) (r (A n))) âˆ§ (s.nonempty â†’ âˆ€ (n : â„•), âˆƒ (y : E) (H : y âˆˆ s), A n = f' y)
is_topological_fiber_bundle F prod.snd
(p ^ n).totient = p ^ (n - 1) * (p - 1)
(X.presheaf_to_Type T).is_sheaf
filter.tendsto (Î» (x : â„), x ^ (1 / x)) filter.at_top (nhds 1)
(linear_map.rtensor (module.dual K V) (contract_left K V)).comp ((tensor_product.assoc K (module.dual K V) V (module.dual K V)).symm.to_linear_map.comp (linear_map.ltensor (module.dual K V) (coevaluation K V))) = (tensor_product.lid K (module.dual K V)).symm.to_linear_map.comp (tensor_product.rid K (module.dual K V)).to_linear_map
(â‹ƒ (a : Î±), â†‘(f a)).finite
measurable (Î» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½)
(finset.Ico s t).card = 2 ^ (t.card - s.card) - 1
(minpoly A x).coeff 0 = 0 â†” x = 0
âˆƒ (C : â„), 0 â‰¤ C âˆ§ C â‰¤ A + B âˆ§ has_sum (Î» (i : Î¹), (f i + g i) ^ p) (C ^ p)
f x = f y
vector_span k (set.range p) = submodule.span k (set.range (Î» (i : {x // x â‰  iâ‚€}), p â†‘i -áµ¥ p iâ‚€))
is_closed (coe_fn '' normed_space.polar ğ•œ s)
category_theory.is_pushout (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right})) c.inl c.inr
(â‹ƒ (k : Îº), â†‘((â‡‘(b.repr) (v k)).support)) = set.univ
category_theory.reflects_isomorphisms (category_theory.forgetâ‚‚ C D)
analytic_on ğ•œ (â‡‘g âˆ˜ f) s
f = g
strict_convex ğ•œ s â†” convex ğ•œ s
Ï†â‚ = Ï†â‚‚
category_theory.limits.has_finite_products C
category_theory.pretopology.to_grothendieck C âŠ¥ = âŠ¥
s.sum (Î» (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), g i ^ p) ^ (1 / p)
s1 < s2 â†” s1 â‰¤ s2 âˆ§ âˆƒ (p : P) (H : p âˆˆ s2), p âˆ‰ s1
continuous_at f a
measure_theory.strongly_measurable (Î» (x : Î±), ite (p x) (f x) (g x))
affine_span k â†‘s = s
(matrix.from_blocks A 0 0 D).is_diag
âˆƒ (y : Î²), b < â†‘((finset.filter (Î» (x : Î±), f x = y) finset.univ).card)
â‡‘(equiv.symm (equiv.add_right a)) = Î» (x : G), x + -a
â‡‘((finset.map e sâ‚‚).affine_combination p) w = â‡‘(sâ‚‚.affine_combination (p âˆ˜ â‡‘e)) (w âˆ˜ â‡‘e)
f (â¨… (i : Î¹), g i) = â¨… (i : Î¹), f (g i)
continuous (Î» (a : Î±), (f a).fst)
a â‰¤ b â†’ Â¬b â‰¤ a â†’ a < b
category_theory.mono Î³
â‡‘(orientation.map Î¹ f) x = x â†” 0 < â‡‘linear_map.det â†‘f
affine_span k (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), affine_span k (s i)
u â€¢ v = v
metric.inf_dist x t â‰¤ metric.inf_dist x s + metric.Hausdorff_dist s t
s.face _ = affine.simplex.mk_of_point k (s.points i)
continuous_on f (s Ã—Ë¢ t)
function.involutive (Î» (_x : equiv.perm Î±), _x * equiv.swap i j)
continuous_at â‡‘f x
s.nonempty
âˆ« (x : Î±) in s, f i x âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, f j x âˆ‚Î¼
â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
filter.tendsto u filter.at_bot filter.at_bot
âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
closure s âŠ† interior (â‡‘(affine_map.homothety x t) '' s)
category_theory.is_iso f
lâ‚.sum â‰¤ lâ‚‚.sum
â‡‘(f.map hy k) z = u â†” â‡‘(k.to_map) (â‡‘g (f.sec z).fst) = â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) + u
continuous_on (Î» (p : E Ã— E), â‡‘(fderiv_within ğ•œ f s p.fst) p.snd) (s Ã—Ë¢ set.univ)
cardinal.mk (mv_polynomial Ïƒ R) â‰¤ linear_order.max (linear_order.max (cardinal.mk R) (cardinal.mk Ïƒ)) cardinal.aleph_0
is_GÎ´ (â‹ƒ (i : Î¹) (H : i âˆˆ s), f i)
is_right_regular k
â‡‘(affine_homeomorph a b _) '' set.Icc 0 1 = set.Icc b (a + b)
category_theory.presieve.is_sheaf_for P R â†” nonempty (category_theory.limits.is_limit (category_theory.limits.fork.of_Î¹ (category_theory.equalizer.fork_map P R) _))
has_btw.btw c a b
2 â€¢ o.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
a < b
(Ï† + Ïˆ).order = Ï†.order âŠ“ Ïˆ.order
linear_order.min a b = a âˆ§ a â‰¤ b âˆ¨ linear_order.min a b = b âˆ§ b < a
x â‰¤ y â†” (âˆ€ (i : x.left_moves), (âˆƒ (i' : y.left_moves), x.move_left i â‰¤ y.move_left i') âˆ¨ âˆƒ (j : (x.move_left i).right_moves), (x.move_left i).move_right j â‰¤ y) âˆ§ âˆ€ (j : y.right_moves), (âˆƒ (i : (y.move_right j).left_moves), x â‰¤ (y.move_right j).move_left i) âˆ¨ âˆƒ (j' : x.right_moves), x.move_right j' â‰¤ y.move_right j
measure_theory.mem_â„’p.to_Lp â‡‘(f + g) _ = measure_theory.mem_â„’p.to_Lp â‡‘f _ + measure_theory.mem_â„’p.to_Lp â‡‘g _
continuous_within_at f (set.Ici a) a
a â€¢ s.center_mass wâ‚ z + b â€¢ s.center_mass wâ‚‚ z = s.center_mass (Î» (i : Î¹), a * wâ‚ i + b * wâ‚‚ i) z
strict_convex_on ğ•œ s f â†” convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) < (f z - f y) / (z - y)
emetric.Hausdorff_edist s t = 0 â†” closure s = closure t
âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ is_compact (closure U)
function.right_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p Î¼ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p Î¼ hm)
â‡‘(closure_operator.mkâ‚ƒ f p hf hfp hmin) x â‰¤ y
â‡‘f â†‘y = â‡‘f â†‘z
â‡‘f (g ^ n) = â‡‘f g ^ n
f â‰¤ nhds (Lim f)
convex ğ•œ ((Î» (x : E), x + z) â»Â¹' s)
is_preconnected (â‹ƒ (n : Î²) (H : n âˆˆ t), s n)
(â¨… (x : L), (â‡‘(lie_algebra.ad R L) x).maximal_generalized_eigenspace 0) = âŠ¤
a.to_list = list.of_fn a.read
filter.tendsto real.log filter.at_top filter.at_top
âˆƒ (R : â„) (H : R > 0), âˆ€ (m n : â„•), has_dist.dist (u m) (u n) < R
unique_factorization_monoid R
(âˆ€ (A : finset Î±), A.card â‰¤ fintype.card â†¥(rel.image r â†‘A)) â†” âˆƒ (f : Î± â†’ Î²), function.injective f âˆ§ âˆ€ (x : Î±), r x (f x)
(generalized_continued_fraction.int_fract_pair.stream v).is_seq
Â¬interval_integrable g measure_theory.measure_space.volume a b
convex_on ğ•œ s â‡‘f
âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1), (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =o[filter.at_top] has_pow.pow a
convolution f g L Î¼ xâ‚€ = âˆ« (t : G), â‡‘(â‡‘L (f t)) (g xâ‚€) âˆ‚Î¼
filter.mapâ‚‚ m (filter.mapâ‚‚ n f g) h â‰¤ filter.mapâ‚‚ n' (filter.mapâ‚‚ mâ‚ f h) (filter.mapâ‚‚ mâ‚‚ g h)
âˆ«â» (a : Î²), f a âˆ‚measure_theory.measure.map g Î¼ = âˆ«â» (a : Î±), f (g a) âˆ‚Î¼
a âˆ‰ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s
f â‰« category_theory.is_filtered.coeq_hom f f' = f' â‰« category_theory.is_filtered.coeq_hom f f'
padic_val_nat p (b / p) = padic_val_nat p b - 1
same_ray â„ x y â†” x = 0 âˆ¨ y = 0 âˆ¨ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
function.periodic f (2 * c)
B.nondegenerate
r = s.circumradius
finite_dimensional.finrank ğ•œ â†¥Kâ‚ + finite_dimensional.finrank ğ•œ â†¥(Kâ‚á—® âŠ“ Kâ‚‚) = finite_dimensional.finrank ğ•œ â†¥Kâ‚‚
is_submonoid (set.Inter s)
â‡‘g x = â‡‘g y
subsemiring.closure â†‘s = s
same_ray R x x
â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
is_connected (â‹ƒ (n : Î¹) (H : n âˆˆ t), s n)
âˆ«â» (a : Î±), f a âˆ‚Î¼ = â¨† (Ï† : measure_theory.simple_func Î± nnreal) (hf : âˆ€ (x : Î±), â†‘(â‡‘Ï† x) â‰¤ f x), (measure_theory.simple_func.map coe Ï†).lintegral Î¼
â‡‘(hs.out) (hs.proj x) = hs.some (hs.index x)
monotone (f âŠ” g)
subsingleton (option Î±) â†” is_empty Î±
cardinal.sum f < cardinal.prod g
2 â€¢ o.oangle (-x) y = 2 â€¢ o.oangle x y
âˆƒ! (d : t.X âŸ¶ s.X), âˆ€ (j : J), t.Î¹.app j â‰« d = s.Î¹.app j
âˆƒ (y : Î±) (H : y âˆˆ set.Ioc a (a + c)), f x = f y
(r â€¢ m) âŠ—â‚œ[R] n = m âŠ—â‚œ[R] (r â€¢ n)
fderiv_measurable_aux.D f K âŠ† {x : E | differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K}
emetric.diam s = 0
(x âˆˆ â¨† (i : Î¹), S i) â†” âˆƒ (i : Î¹), x âˆˆ S i
measure_theory.adapted f (measure_theory.stopped_process u Ï„)
0 < a + b
(âˆ€ (x : V), has_inner.inner (â‡‘T x) x = 0) â†” T = 0
x âˆ‰ submodule.span R s
âˆƒ (t' : topological_space Î±), t' â‰¤ t âˆ§ continuous f âˆ§ polish_space Î±
continuous f
âˆƒ (r : nnreal) (H : r > 0), summable (Î» (i : Î£ (n : â„•), composition n), âˆ¥q.comp_along_composition p i.sndâˆ¥â‚Š * r ^ i.fst)
shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z â†” shelf.act x z = z
â‡‘f 0 = 0
0 = 1 â†” â‡‘f 1 = 0
2 â€¢ o.oangle (r â€¢ x) y = 2 â€¢ o.oangle x y
complex.abs (z + w) â‰¤ complex.abs z + complex.abs w
0 < b â†’ a - b < a
filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.Iio a)) l
â†‘(s.direction) = has_vsub.vsub p '' â†‘s
monoid.exponent_exists G
is_compact (â‡‘weak_dual.to_normed_dual â»Â¹' metric.closed_ball x' r)
â‡‘(b.equiv_fun.symm) x = finset.univ.sum (Î» (i : Î¹), x i â€¢ â‡‘b i)
âˆƒ (g : Î± â†’ ereal), (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§ upper_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ + Îµ
emetric.Hausdorff_edist s âˆ… = âŠ¤
Â¬Â¬a â†” a
2 â€¢ hb.oangle (r â€¢ x) x = 0
âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼) ^ (1 / q)
strict_anti f â†’ strict_mono (f âˆ˜ â‡‘order_dual.of_dual)
local_homeomorph.of_set s hs âˆˆ cont_diff_groupoid n I
e.to_local_equiv.source = e'.to_local_equiv.source
category_theory.limits.has_colimit G
âˆƒ (u : â„• â†’ Î±), dense_range u
finite_dimensional.finrank ğ•œ â†¥K + finite_dimensional.finrank ğ•œ â†¥Ká—® = finite_dimensional.finrank ğ•œ E
measure_theory.is_stopping_time ğ’¢ (s.piecewise Ï„ Î·)
âˆƒ (t : set P), s âŠ† t âˆ§ t âŠ† u âˆ§ affine_independent â„ coe âˆ§ affine_span â„ t = âŠ¤
borel X â‰¤ Î¼.caratheodory
same_ray R v (r â€¢ v)
D.opens_image_preimage_map i j U â‰« (D.to_glue_data.f j k).c.app (opposite.op ((topological_space.opens.map (D.to_glue_data.Î¹ j).base).obj (_.functor.obj U))) = (category_theory.limits.pullback.fst â‰« D.to_glue_data.t j i â‰« D.to_glue_data.f i j).c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map (category_theory.limits.pullback.fst â‰« D.to_glue_data.t j i â‰« D.to_glue_data.f i j).base).op.obj (opposite.op U))) â‰« (D.to_glue_data.V (j, k)).presheaf.map (category_theory.eq_to_hom _)
filter.tendsto f tâ‚€ (nhds 0)
e.prod e' âˆˆ cont_diff_groupoid âŠ¤ (I.prod I')
strict_mono f â†’ strict_anti (f âˆ˜ â‡‘order_dual.of_dual)
monoid.is_torsion_free (G â§¸ torsion G)
â‡‘g (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), â‡‘g (f x))
â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘C ^ d * â‡‘(measure_theory.measure.hausdorff_measure (â†‘r * d)) s
has_dist.dist p1 p2 â‰  0
is_of_fin_order xâ»Â¹ â†” is_of_fin_order x
âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.sum (Î» (i : Î¹), finset.univ.prod (Î» (j : Î¹), ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (linear_order.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
has_dist.dist (f z) c â‰¤ has_dist.dist z c
âŠ¤.fg
s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) < s.sum (Î» (i : Î¹), f i * g i) â†” Â¬monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
function.injective (finsupp.single a)
f y - f x < C * (y - x)
â‡‘f (-a) = -â‡‘f a
lie_module.is_nilpotent R L M â†” âˆƒ (k : â„•), lie_module.lower_central_series R L M k = âŠ¥
âˆƒ (u v : set E), is_open u âˆ§ is_open v âˆ§ convex â„ u âˆ§ convex â„ v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ disjoint u v
f ^ k = â‡‘(polynomial.aeval f) (polynomial.X ^ k %â‚˜ f.charpoly)
(A.mul B).mul (â…Ÿ B) = A
x âˆˆ closure s â†” emetric.inf_edist x s = 0
function.surjective f
s.singular_part Î¼ + Î¼.with_densityáµ¥ (s.rn_deriv Î¼) = s
âˆƒ (V : set Î±), s âŠ† V âˆ§ is_open V âˆ§ V âŠ† U
strict_concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
â‡‘(algebra.trace K L) (â‡‘(algebra_map K L) x) = finite_dimensional.finrank K L â€¢ x
âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
irreducible (polynomial.cyclotomic n â„š)
hb.oangle x (x - y) = hb.oangle (y - x) y
is_pi_system (set.image2 has_set_prod.prod C D)
has_strict_deriv_at (exp ğ•‚) 1 0
differentiable_on ğ•œ (Î» (z : ğ•œ), ring.inverse (1 - z â€¢ a)) (metric.closed_ball 0 â†‘r)
(list.permutations_aux2 t list.nil r ys (Î» (x : list Î±), f (x ++ ts))).snd = (list.permutations_aux2 t ts r ys f).snd
relation.fibration (relation.game_add (relation.cut_expand r) (relation.cut_expand r)) (relation.cut_expand r) (Î» (s : multiset Î± Ã— multiset Î±), s.fst + s.snd)
list.count p n.factors = â‡‘(n.factorization) p
x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
antitone (Î» (x : Î±), linear_order.min (f x) (g x))
(f =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f =o[l] g'
cont_diff_on ğ•œ n f s
measure_theory.fin_strongly_measurable f Î¼ â†” measurable f
euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p2 p4
Î¼â‚ = Î¼â‚‚
(s.product t).prod (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = s.prod (Î» (x : Î³), t.prod (Î» (y : Î±), f x y))
continuous_within_at f (set.Iic a) a
F.is_sheaf â†” F.is_sheaf_preserves_limit_pairwise_intersections
inner_product_geometry.angle (r â€¢ x) y = inner_product_geometry.angle (-x) y
category_theory.limits.has_limits_of_shape J D
antitone f â†’ monotone (f âˆ˜ â‡‘order_dual.of_dual)
(âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, p x) â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, p x)
âˆƒ (Î¹ : Type u) (c : Î¹ â†’ Î±) (r r' : Î¹ â†’ â„), (âˆ€ (i : Î¹), 0 < r i âˆ§ r i < r' i âˆ§ r' i < R (c i)) âˆ§ locally_finite (Î» (i : Î¹), metric.ball (c i) (r' i)) âˆ§ (â‹ƒ (i : Î¹), metric.ball (c i) (r i)) = set.univ
fintype.card (â†¥(H.normalizer) â§¸ subgroup.comap H.normalizer.subtype H) â‰¡ fintype.card (G â§¸ H) [MOD p]
Ï†.order â‰¤ â†‘n
mdifferentiable_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x â†’ differentiable_within_at ğ•œ f s x
continuous_at (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.snd) (0, z)
â‡‘g â†‘((f.sec z).snd) + â‡‘(f.lift hg) z = â‡‘g (f.sec z).fst
(f.prod has_pow.pow).factorization = f
is_compact (std_simplex â„ Î¹)
Gromov_Hausdorff.HD (Gromov_Hausdorff.candidates_b_dist X Y) â‰¤ metric.diam set.univ + 1 + metric.diam set.univ
category_theory.abelian.factor_thru_image f â‰« category_theory.abelian.image.Î¹ f = f
Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬y â‰¤ x
pythagorean_triple x y z â†” pythagorean_triple y x z
dimH s = 0
s.inf (Î» (i : Î¹), f i ^ e i) = s.prod (Î» (i : Î¹), f i ^ e i)
r â‰¤ â†‘b ^ x â†” int.clog b r â‰¤ x
Â¬B.is_ortho (â‡‘v i) (â‡‘v i)
nonempty (category_theory.limits.is_limit (P.map_cone S.arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), category_theory.presieve.is_sheaf_for (P â‹™ category_theory.coyoneda.obj E) â‡‘S
unique_diff_on ğ•œ ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' s)
â‡‘Î¼ (f â»Â¹' s) â‰¤ â‡‘(measure_theory.measure.map f Î¼) s
pairwise (Î» (a b : Î¹), has_inner.inner (gram_schmidt ğ•œ f a) (gram_schmidt ğ•œ f b) = 0)
z âˆˆ set.Icc x y â†” âˆƒ (a b : ğ•œ), 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
k = k'
add_monoid.is_torsion H â†” add_monoid.is_torsion G
m â‰¤ n â†’ P n
finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary (f âˆ˜ â‡‘Ïƒ) g
has_dist.dist p â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = 0 â†” p âˆˆ s
â†‘u âŠ† s -áµ¥ t â†’ (âˆƒ (s' t' : finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' -áµ¥ t')
finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â‰¤ finset.univ.sum (Î» (i : Î¹), f i â€¢ g i)
âˆƒ (f : â„• â†’ Î±), (âˆ€ (n : â„•), P (f n)) âˆ§ âˆ€ (m n : â„•), m < n â†’ r (f m) (f n)
Î¼.have_lebesgue_decomposition Î½
dense (â‹‚ (s : Î²), f s)
hb.rotation Î¸ = hbâ‚‚.rotation Î¸
is_of_fin_add_order (-x) â†” is_of_fin_add_order x
1 â‰¤ b
continuous (Î» (x : Î±), metric.inf_dist x s)
function.is_fixed_pt f (contracting_with.fixed_point f^[n] hf)
o.oangle y z = 2 â€¢ o.oangle (y - x) (z - x)
2 â€¢ hb.oangle (-x) x = 0
measurable_space.comap f mâ‚‚ â‰¤ mâ‚ â†’ measurable f
p.to_ball_package.c x âˆˆ p.Union_up_to p.last_step
1 âˆ‰ f.ker
(finset.subtype p s).prod (Î» (x : subtype p), f â†‘x) = (finset.filter p s).prod (Î» (x : Î±), f x)
0 â‰¤ a * b
open_embedding â‡‘(category_theory.limits.limit.Ï€ (category_theory.limits.cospan f g) category_theory.limits.walking_cospan.one)
s1.direction âŠ” s2.direction â‰¤ (s1 âŠ” s2).direction
I.is_maximal
analytic_at â„‚ f z
is_preconnected (â‹ƒ (n : Î¹) (H : n âˆˆ t), s n)
smul_comm_class N M Î±
continuous (convolution f g L Î¼)
fixing_submonoid M (â‹ƒ (i : Î¹), s i) = â¨… (i : Î¹), fixing_submonoid M (s i)
is_empty (besicovitch.satellite_config E (besicovitch.multiplicity E) (besicovitch.good_Ï„ E))
filter.tendsto (Î» (N : â„•), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top
cont_diff_at ğ•œ â†‘(n + 1) f x â†” âˆƒ (f' : E â†’ (E â†’L[ğ•œ] F)), (âˆƒ (u : set E) (H : u âˆˆ nhds x), âˆ€ (x : E), x âˆˆ u â†’ has_fderiv_at f (f' x) x) âˆ§ cont_diff_at ğ•œ â†‘n f' x
algebra.finite_presentation R A â†’ algebra.finite_type R A
â‡‘(s.weighted_vsub_of_point p (p j)) wâ‚ = â‡‘(s.weighted_vsub_of_point p (p j)) wâ‚‚
â†‘a < â†‘b â†” a < b
subgroup.closure k â‰¤ K â†” k âŠ† â†‘K
n â€¢ a = n â€¢ b â†” a = b
padic_norm p (q / r) = padic_norm p q / padic_norm p r
deriv (Î» (u : â„), âˆ« (x : â„) in u..b, f x) a = -c
is_add_monoid_hom (Î» (y : Î³), y * x)
(is_localization.map W l hl).comp (is_localization.map Q g hy) = is_localization.map W (l.comp g) _
measure_theory.ae_strongly_measurable f (Î¼.restrict s)
Jâ‚.is_closed S â†’ Jâ‚.is_closed (category_theory.sieve.pullback f S)
submodule.map f (submodule.span R s) â‰¤ N â†” âˆ€ (m : M), m âˆˆ s â†’ â‡‘f m âˆˆ N
p x y
has_scalar.smul aâ‚ âˆ˜ has_scalar.smul aâ‚‚ = has_scalar.smul (aâ‚ * aâ‚‚)
x âˆˆ s â†’ -x âˆˆ s
a â‰¤ b â†’ a < b âˆ¨ a = b
unique_diff_on â„ (set.Icc 0 1)
strict_concave_on ğ•œ s (f âŠ“ g)
tendsto_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n (y - x)) f filter.at_top (metric.ball x â†‘r')
cardinal.mk Îº â‰¤ cardinal.mk Î¹
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), is_extr_on f (set.Icc a b) c
has_fderiv_at (exp ğ•‚) (exp ğ•‚ x â€¢ 1) x
a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d
is_commutative X mâ‚‚
asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) g â†’ asymptotics.is_O_with c l f' g
M p
has_strict_deriv_at (Î» (x : â„), a ^ x) (a ^ x * real.log a - real.exp (real.log a * x) * real.sin (x * real.pi) * real.pi) x
continuous (Î» (f : C(Î±, Î²)), â‡‘f a)
{x : Î± | âˆƒ (y : Î±), y < x âˆ§ set.Ioo y x = âˆ…}.countable
set.range (circle_map c R) = metric.sphere c |R|
â‡‘f (m + m') = finset.univ.sum (Î» (s : finset Î¹), â‡‘f (s.piecewise m m'))
âˆ« (y : â„) in a..b, f' y = f b - f a
Î¼.is_haar_measure
âˆ‘' (i : â„•), m (â‹ƒ (b : Î³) (H : b âˆˆ encodable.decodeâ‚‚ Î³ i), s b) = âˆ‘' (b : Î³), m (s b)
finite_dimensional K V
finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒ (i : Î¹), t i), f a)) = finsum (Î» (i : Î¹), finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ t i), f a)))
concave_on ğ•œ s f
(nhds_within a s).is_measurably_generated
â‡‘(equiv.symm (equiv.add_left a)) = has_add.add (-a)
category_theory.mono (category_theory.limits.trident.Î¹ c)
â‡‘(direct_sum.of M i) (c â€¢ x) = c â€¢ â‡‘(direct_sum.of M i) x
continuous â‡‘f
category_theory.is_iso f
âˆ« (x : â„) in a..b, f' x = f b - f a
(l.split_wrt_composition c).join = l
convex_on â„ set.univ f
continuous (f âˆ˜ int.fract)
strict_convex_on â„ D f
order.pred a < order.pred b â†’ a < b
a * b âˆ£ a * c â†” b âˆ£ c
minpoly K x = minpoly K y
vadd_comm_class N M Î±
nontrivial (Î  (i : I), f i)
â‡‘(direct_sum.to_module R Î¹ N Ï†) = â‡‘(direct_sum.to_add_monoid (Î» (i : Î¹), (Ï† i).to_add_monoid_hom))
asymptotics.is_O_with C (nhds b) f g â†” asymptotics.is_O_with C (nhds (â‡‘(e.symm) b)) (f âˆ˜ â‡‘e) (g âˆ˜ â‡‘e)
âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
nhds â†‘Î³ = has_pure.pure â†‘Î³
p a
F = G
set.maps_to f (closure s) (closure t)
locally_convex_space â„ E
âˆƒ (r' : â„) (H : r' < r), s âŠ† metric.ball x r'
continuous â‡‘F
âˆƒ (i : Î¹), V i âŠ† U
topological_space.metrizable_space X
v.int_valuation_def (x + y) â‰¤ linear_order.max (v.int_valuation_def x) (v.int_valuation_def y)
S = T
a.countable
category_theory.is_pullback category_theory.limits.pullback.fst category_theory.limits.pullback.snd f g
x = y
a âˆ£ u * b â†” a âˆ£ b
add_semiconj_by (â†‘-a) y x
1 â‰¤ a * b
algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ (â†‘p ^ k * (â†‘p - 1) / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
â†‘(ifp_succ_n.b) â‰¤ (ifp_n.fr)â»Â¹
padic_val_rat p â†‘z = â†‘((multiplicity â†‘p z).get _)
relation.game_add rÎ± rÎ² â‰¤ prod.lex rÎ± rÎ²
dense (s âˆ© t)
x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
tâ‚.orthocenter = tâ‚‚.orthocenter
hb.oangle x y = hbâ‚‚.oangle x y
is_smul_regular M (a ^ n) â†” is_smul_regular M a
has_dist.dist (f n) a â‰¤ C * r ^ n / (1 - r)
(â‡‘(polynomial.taylor r) f).sum (Î» (i : â„•) (a : R), â‡‘polynomial.C a * (polynomial.X - â‡‘polynomial.C r) ^ i) = f
(âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), g + h) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_add_left_invariant
cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I H â»Â¹' s)
(â¨† (i : Î¹'), s i) = â¨† (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
s.countable
set.Icc (f b) (f a) âŠ† f '' set.Icc a b
filter.tendsto u f (nhds a) â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (x : Î±) in f, u x âˆˆ set.Icc (a - Îµ) (a + Îµ))
strict_concave_on ğ•œ s f â†’ strict_convex_on ğ•œ s (-f)
dimH (f '' s) â‰¤ dimH s
isometry sum.inr
measurable (function.update f a)
add_semiconj_by a 0 0
sâ‚ = sâ‚‚
category_theory.faithful F
measure_theory.integrable_at_filter f l Î¼
â†‘(â‡‘(orthogonal_projection K) u) = v
e = e'
let g : generalized_continued_fraction K := generalized_continued_fraction.of v, B : K := (g.continuants_aux (n + 1)).b, pB : K := (g.continuants_aux n).b in v - g.convergents n = ite (ifp.fr = 0) 0 ((-1) ^ n / (B * ((ifp.fr)â»Â¹ * B + pB)))
box_integral.has_integral I l g Î¼.to_box_additive.to_smul y
module.projective R P
iterated_deriv (n + 1) f = iterated_deriv n (deriv f)
A.sum (Î» (i : â„•), 2 ^ i) â‰¤ B.sum (Î» (i : â„•), 2 ^ i) â†” A.to_colex â‰¤ B.to_colex
1 â‰¤ a * b
x < real.tan x
0 â‰¤ a + b
âˆƒ (K : subgroup G), fintype.card â†¥K = p ^ (n + 1) âˆ§ H â‰¤ K
filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I Ï€â‚€) (nhds (Ï€â‚€.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)))
f = g
subsingleton (Î± â‰ƒ+*o Î²)
is_localization (submonoid.map (algebra_map R S).to_monoid_hom N) T
âˆƒ (t' : topological_space Î±), (âˆ€ (n : Î¹), t' â‰¤ m n) âˆ§ t' â‰¤ t âˆ§ polish_space Î±
â‡‘g â†‘((f.sec z).snd) * â‡‘(f.lift hg) z = â‡‘g (f.sec z).fst
con_gen r = has_Inf.Inf {s : con M | âˆ€ (x y : M), r x y â†’ â‡‘s x y}
concave_on ğ•œ s â‡‘f
f = g
âˆƒ (n : â„•) (Î¹ : Type u) [_inst_8 : fintype Î¹] (p : Î¹ â†’ R) [_inst_9 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), nonempty (N â‰ƒâ‚—[R] (fin n â†’â‚€ R) Ã— direct_sum Î¹ (Î» (i : Î¹), R â§¸ submodule.span R {p i ^ e i}))
has_fderiv_at f f' a â†’ f' = 0
â‡‘f x = â‡‘g x
is_unit (â‡‘(X.to_PresheafedSpace.presheaf.map (category_theory.hom_of_le _).op) f)
âˆ¥âˆ¯ (x : fin n â†’ â„‚) in T(c, R), f xâˆ¥ â‰¤ (2 * real.pi) ^ n * finset.univ.prod (Î» (i : fin n), |R i|) * C
infi f * x = â¨… (i : Î¹), f i * x
orthonormal ğ•œ (â‡‘f âˆ˜ v)
cardinal.aleph_0 â‰¤ a * b â†” a â‰  0 âˆ§ cardinal.aleph_0 â‰¤ b âˆ¨ cardinal.aleph_0 â‰¤ a âˆ§ b â‰  0
1 âˆˆ S
module.rank R M = â†‘(fintype.card Î¹)
tactic.ring2.csring_expr.eval t râ‚ = tactic.ring2.csring_expr.eval t râ‚‚
0 < a â†’ c â€¢ a < 0
âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
hb.oangle x y + hb.oangle y x = 0
âˆƒ (y : A) (H : y â‰  0), âˆ€ (x : L), x âˆˆ s â†’ is_integral A (y â€¢ x)
set.eq_on â‡‘(e.symm) â‡‘(e'.symm) e.to_local_equiv.target
p y
category_theory.limits.has_cokernel (f - g)
irrational x
a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d
discrete_valuation_ring R
âˆƒ (w : set E) (b : hilbert_basis â†¥w ğ•œ E), â‡‘b = coe
cont_diff_within_at ğ•œ n prod.snd s p
orthonormal ğ•œ (v âˆ˜ f)
I.jacobson = I â†” âˆƒ (M : set (ideal R)), (âˆ€ (J : ideal R), J âˆˆ M â†’ J.is_maximal âˆ¨ J = âŠ¤) âˆ§ I = has_Inf.Inf M
(â¨… (x : L), (â‡‘(lie_module.to_endomorphism R L M) x).maximal_generalized_eigenspace 0) = âŠ¤
2 â‰  0
â‡‘(algebra.norm K) (Î¶ - 1) = â†‘p
âˆ¥â‡‘f mâˆ¥â‚Š â‰¤ âˆ¥fâˆ¥â‚Š * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥â‚Š)
finite_dimensional.finrank K â†¥(f.range) + finite_dimensional.finrank K â†¥(f.ker) = finite_dimensional.finrank K V
p (finsum (Î» (i : Î±), f i))
dense (â‹‚ (n : â„•), f n)
(âˆ€ (i : Î¹), Î¼.restrict (s i) = Î½.restrict (s i)) â†’ Î¼ = Î½
(filter.map (Î» (_x : Î±), b) (filter.principal {a})).coprod (filter.map id (filter.principal {i})) = filter.principal ({b} Ã—Ë¢ set.univ âˆª set.univ Ã—Ë¢ {i})
â†‘I * (â†‘I)â»Â¹ = 1
(hb.rotation Î¸â‚).trans (hb.rotation Î¸â‚‚) = hb.rotation (Î¸â‚‚ + Î¸â‚)
f = g
category_theory.is_pushout f g category_theory.limits.pushout.inl category_theory.limits.pushout.inr
algebra.finite_type R A â†” âˆƒ (s : finset A) (f : mv_polynomial {x // x âˆˆ s} R â†’â‚[R] A), function.surjective â‡‘f
category_theory.is_iso f
category_theory.forget_enrichment.hom_to W (ğŸ™ X) = category_theory.e_id W (category_theory.forget_enrichment.to W X)
metric.bounded s
filter.tendsto (Î» (x : Î²), f x * r) l filter.at_top
function.injective â‡‘(â‡‘free_product.lift f)
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.affine_combination pâ‚) w -áµ¥ pâ‚‚
â‡‘linear_equiv.det hb.conj_lie.to_linear_equiv = -1
continuous â‡‘(f.linear) â†” continuous â‡‘f
polynomial.cyclotomic n â„¤ = minpoly â„¤ Î¼
filter.tendsto (Î» (n : â„•), â†‘n ^ k * r ^ n) filter.at_top (nhds 0)
M p
â‡‘f s.sum = (multiset.map â‡‘f s).sum
is_closed {x âˆˆ s | f x â‰¤ g x}
has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) a
list.of_fn f = list.nil
has_dist.dist t.orthocenter (â‡‘(euclidean_geometry.reflection (affine_span â„ (t.points '' â†‘{iâ‚, iâ‚‚}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
âˆƒ (n : â„•), v = (generalized_continued_fraction.of v).convergents n
e.option_congr = equiv_functor.map_equiv option e
u * a âˆ£ b â†” a âˆ£ b
âˆ¥continuous_linear_map.lsmul ğ•œ ğ•œ'âˆ¥ = 1
âˆƒ (C : â„) (H : C â‰¥ 0), âˆ€ (y : F), âˆƒ (x : E), has_dist.dist (â‡‘f x) y â‰¤ 1 / 2 * âˆ¥yâˆ¥ âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
fintype.card (lucas_lehmer.X q)Ë£ < â†‘q ^ 2
finset.image g (finset.imageâ‚‚ f s t) = finset.imageâ‚‚ f' (finset.image g' s) t
âˆƒ (a b : set Î±), measurable_set a âˆ§ measurable_set b âˆ§ {x : Î± | v.lim_ratio Ï x < â†‘p} âŠ† a âˆ§ {x : Î± | â†‘q < v.lim_ratio Ï x} âŠ† b âˆ§ â‡‘Î¼ (a âˆ© b) = 0
cont_diff_on ğ•œ â†‘(n + 1) fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ â†‘n (deriv_within fâ‚‚ sâ‚‚) sâ‚‚
H = K
category_theory.strong_epi F'.e
has_edist.edist x y â‰  âŠ¤
linear_independent R v
Â¬summable (Î» (n : â„•), (â†‘n)â»Â¹)
â†‘u.product M âŠ¨ Ï† â†” âˆ€á¶  (a : Î±) in â†‘u, M a âŠ¨ Ï†
p = q â†” nat.prime p
category_theory.simple X
commute x y
mv_polynomial.coeff m ((â‡‘(mv_polynomial.fin_succ_equiv R n) f).coeff i) = mv_polynomial.coeff (finsupp.cons i m) f
filter.tendsto (Î» (x : â„•), (1 + t / â†‘x) ^ x) filter.at_top (nhds (real.exp t))
convex_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
f a âˆ£ finprod f
F = G
0 â‰¤ box_integral.integral I l g Î¼.to_box_additive.to_smul
witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x y))
witt_vector.is_poly p (Î» (R : Type u_1) (_x : comm_ring R), has_neg.neg)
polish_space Î±
filter.tendsto (Î» (r : â„), â‡‘Î¼ (metric.cthickening r s)) (nhds 0) (nhds (â‡‘Î¼ s))
â‡‘f (fin.snoc m (c â€¢ x)) = c â€¢ â‡‘f (fin.snoc m x)
finite_dimensional K Vâ‚‚
category_theory.limits.has_pushouts C
is_group_hom (Î» (a : Î±), (f a)â»Â¹)
polynomial.cyclotomic' 2 R = polynomial.X + 1
0 < l.prod
p = s.circumcenter
â‡‘(linear_map.inr ğ•œ E F) '' tangent_cone_at ğ•œ t y âŠ† tangent_cone_at ğ•œ (s Ã—Ë¢ t) (x, y)
category_theory.presieve.is_sheaf (category_theory.pretopology.to_grothendieck C K) P â†” âˆ€ {X : C} (R : category_theory.presieve X), R âˆˆ â‡‘K X â†’ category_theory.presieve.is_sheaf_for P R
filter.map coe filter.at_top = filter.at_top
{c : cardinal | âˆƒ (S : set Î±), (âˆ€ (a : Î±), âˆƒ (b : Î±) (H : b âˆˆ S), r a b) âˆ§ cardinal.mk â†¥S = c}.nonempty
Â¬x â‰¤ y â†” y.lf x
category_theory.is_pushout f g c.inl c.inr
âˆƒ (b' : basis Î¹ R S) (a : Î¹ â†’ R) (ab' : basis Î¹ R â†¥I), âˆ€ (i : Î¹), â†‘(â‡‘ab' i) = a i â€¢ â‡‘b' i
localization.r S = localization.r' S
is_open â†‘H
o.oangle (r â€¢ x) y = o.oangle x y
matrix.dot_product v (â‡‘(â‡‘cross_product v) w) = 0
âˆƒ (H : subgroup G), H.is_complement' N
0 < s.circumradius
deriv_within (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s b = f b
v.to_list = [v.head]
f (â¨† (i : Î³), g i) = â¨† (i : Î³), f (g i)
f = g
â‡‘zmod.Ï‡â‚ˆ a = 0 âˆ¨ â‡‘zmod.Ï‡â‚ˆ a = 1 âˆ¨ â‡‘zmod.Ï‡â‚ˆ a = -1
y â‰« category_theory.limits.limit.Ï€ (category_theory.Ran.diagram G.op â„±.val (opposite.op V)) W = (category_theory.Ran_is_sheaf_of_cover_lifting.glued_limit_cone hu â„± hS hx).Ï€.app ((category_theory.structured_arrow.map f.op).obj W)
finite_dimensional.finrank K V = 1 â†” âˆƒ (v : V) (n : v â‰  0), âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w
p â‰¤ 0 â†’ ennreal.of_real p = 0
filter.tendsto (â‡‘Î¼ âˆ˜ s) filter.at_top (nhds (â‡‘Î¼ (â‹ƒ (n : Î¹), s n)))
C n x hx
nat.nth p n = â†‘(â‡‘(nat.subtype.order_iso_of_nat (set_of p)) n)
0 â‰¤ (x.move_right j).move_left (pgame.left_response h j)
is_compact s â†’ âˆ€ (f : ultrafilter Î±), â†‘f â‰¤ filter.principal s â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), â†‘f â‰¤ nhds a)
Â¬function.surjective f
has_deriv_within_at f e (set.Ici a) a
continuous (Î» (p : C(Î±, Î²) Ã— Î±), â‡‘(p.fst) p.snd)
set.Union_lift S f hf T _ (u x) = uÎ² (set.Union_lift S f hf T _ x)
â‡‘(algebra.norm K) (Î¶ ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
a * b â‰¤ a ^ p / p + b ^ q / q
has_Inf.Inf (has_insert.insert a s) = a âŠ“ has_Inf.Inf s
is_monoid_hom â‡‘h
e.symm.trans e âˆˆ cont_diff_groupoid n I
âŠ¤.is_SRG_with (fintype.card V) (fintype.card V - 1) (fintype.card V - 2) Î¼
sá¶œ âˆˆ f
p ^ (n - pnat_multiplicity p âŸ¨j + 1, _âŸ©) âˆ£ (p ^ n).choose (j + 1)
filter.tendsto (Î» (x : â„), (b * real.exp x + c) / x ^ n) filter.at_top filter.at_top
is_mul_hom (Î» (a : Î±), (f a)â»Â¹)
(p.left_inv i).comp p = formal_multilinear_series.id ğ•œ E
x â‰¤ y â†” (âˆ€ (i : x.left_moves), (x.move_left i).lf y) âˆ§ âˆ€ (j : y.right_moves), x.lf (y.move_right j)
âˆƒáµ (x : Î±) âˆ‚Î¼, x âˆˆ s âˆ§ âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s
is_submonoid (powers x)
add_semiconj_by 0 x x
â‡‘(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
(measure_theory.measure.map â‡‘f Î¼).is_add_haar_measure
fintype.card m = fintype.card n
âˆƒ (g : â†¥A), âˆ€ (x : X), âˆ¥â‡‘g x - f xâˆ¥ < Îµ
â†‘b ^ x < r â†” x < int.clog b r
is_ring_hom (g âˆ˜ f)
(linear_map.ltensor V (contract_left K V)).comp ((tensor_product.assoc K V (module.dual K V) V).to_linear_map.comp (linear_map.rtensor V (coevaluation K V))) = (tensor_product.rid K V).symm.to_linear_map.comp (tensor_product.lid K V).to_linear_map
â‡‘(s.affine_combination p) w âˆˆ affine_span k (set.range p)
f = g
bdd_below (s âˆ© t)
(finset.Ioc s t).card = 2 ^ (t.card - s.card) - 1
nonempty (C â‰Œ category_theory.discrete punit) â†” nonempty C âˆ§ âˆ€ (x y : C), nonempty (unique (x âŸ¶ y))
inner_product_geometry.angle x y = 0 â†” x â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ x
category_theory.mono (category_theory.limits.terminal.from A)
is_unit n â†’ n.nat_abs = 1
category_theory.is_cofiltered D
â‡‘f (exp ğ•‚ x) = exp ğ•‚ (â‡‘f x)
same_ray R (x + y) z
isometry f
has_edist.edist (f x) (f y) = has_edist.edist x y
p * polynomial.X ^ n * â‡‘polynomial.C r = p * â‡‘polynomial.C r * polynomial.X ^ n
nat.count p n = fintype.card {k // k < n âˆ§ p k}
âˆ« (x : â„) in a..b, f x âˆ‚Î¼ < âˆ« (x : â„) in a..b, g x âˆ‚Î¼
k â‰« s.Ï€.app j = l â‰« s.Ï€.app j
x = y
ordered_smul ğ•œ E
y - x âˆˆ tangent_cone_at â„ s x
t.nonempty
category_theory.faithful R
add_localization.r S = add_localization.r' S
finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒâ‚€t), f a)) = finprod (Î» (s : set Î±), finprod (Î» (H : s âˆˆ t), finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ s), f a))))
(â‡‘(b.repr) x).sum (Î» (i : Î¹) (xi : Râ‚‚), (â‡‘(b.repr) y).sum (Î» (j : Î¹) (yj : Râ‚‚), xi â€¢ yj â€¢ â‡‘Bâ‚‚ (â‡‘b i) (â‡‘b j))) = â‡‘Bâ‚‚ x y
âˆƒ (j : Î¹) (hij : i â‰¤ j), â‡‘(f i j hij) x = 0
category_theory.is_iso f
â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det â†‘f| * â‡‘Î¼ s
f (t.sum (Î» (i : Î¹), w i â€¢ p i)) â‰¤ t.sum (Î» (i : Î¹), w i â€¢ f (p i))
finset.univ.prod (Î» (i : fin (n + 1)), f i) = finset.univ.prod (Î» (i : fin n), f (â‡‘fin.cast_succ i)) * f (fin.last n)
has_fderiv_within_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)) (s Ã—Ë¢ t) (a, b)
g +áµ¥ p -áµ¥ p = g
(cont_diff_groupoid âŠ¤ I).local_invariant_prop (cont_diff_groupoid âŠ¤ I') (cont_diff_within_at_prop I I' n)
has_strict_deriv_at f (deriv f x) x
normed_space.polar ğ•œ (metric.closed_ball 0 r) = metric.closed_ball 0 râ»Â¹
function.bijective â‡‘(algebra_map R Râ‚˜)
has_sum (Î» (b : Î¹), â‡‘Ï† (f b)) (â‡‘Ï† x)
0 â‰¤ padic_norm p q
â†‘(t.inf f) = t.inf (Î» (x : Î²), â†‘(f x))
(âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.nat.antidiagonal n).sum (Î» (kl : â„• Ã— â„•), f kl.fst * g kl.snd)
is_add_submonoid (set.range f)
âˆ« (y : â„) in a..b, f' y = f b - f a
âˆƒ (K : set Î±) (H : K âŠ† A), is_compact K âˆ§ â‡‘Î¼ (A  K) < Îµ
s âŠ† closure (f '' (f â»Â¹' s))
add_action.stabilizer Î± (g +áµ¥ x) = add_subgroup.map (add_equiv.to_add_monoid_hom (â‡‘add_aut.conj g)) (add_action.stabilizer Î± x)
filter.map n (filter.mapâ‚‚ m f g) = filter.mapâ‚‚ m' f (filter.map n' g)
category_theory.presieve.is_sheaf_for P R â†” category_theory.presieve.is_sheaf_for P â‡‘(category_theory.sieve.generate R)
acc rÎ² (f a)
â†‘(â‡‘((s.face h).orthogonal_projection_span) s.circumcenter) = (s.face h).circumcenter
f (â‡‘(affine_map.line_map a b) r) â‰¤ â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a (â‡‘(affine_map.line_map a b) r) â‰¤ slope f (â‡‘(affine_map.line_map a b) r) b
â‡‘(convex_hull R) (set.range (Î» (i j : Î¹), ite (i = j) 1 0)) = std_simplex R Î¹
a * b = b * a
(wâ‚ * zâ‚ + wâ‚‚ * zâ‚‚) ^ p â‰¤ wâ‚ * zâ‚ ^ p + wâ‚‚ * zâ‚‚ ^ p
has_inner.inner (â‡‘(sâ‚.weighted_vsub pâ‚) wâ‚) (â‡‘(sâ‚‚.weighted_vsub pâ‚‚) wâ‚‚) = -sâ‚.sum (Î» (iâ‚ : Î¹â‚), sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚ iâ‚ * wâ‚‚ iâ‚‚ * (has_dist.dist (pâ‚ iâ‚) (pâ‚‚ iâ‚‚) * has_dist.dist (pâ‚ iâ‚) (pâ‚‚ iâ‚‚)))) / 2
finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒ (x : Î¹) (H : x âˆˆ I), t x), f a)) = finprod (Î» (i : Î¹), finprod (Î» (H : i âˆˆ I), finprod (Î» (j : Î±), finprod (Î» (H : j âˆˆ t i), f j))))
padic_norm_e (q + r) â‰¤ linear_order.max (padic_norm_e q) (padic_norm_e r)
â‡‘linear_map.det â†‘(complex.conj_lie.to_linear_equiv) = -1
f = g
âˆ«â» (x : G), f (g + x) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
has_dist.dist pâ‚ (â‡‘(euclidean_geometry.reflection s) pâ‚‚) = has_dist.dist pâ‚ pâ‚‚
âˆ¥f zâˆ¥ â‰¤ C
c.map_gen f = c.map_of_surjective f H h hf
âˆƒ (t : fin n â†’ fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š)), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†” â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
âˆƒ (q : polynomial R), polynomial.map f q = p âˆ§ q.degree = p.degree
function.injective has_dvd.dvd
is_closed (coe_fn '' weak_dual.polar ğ•œ s)
multiset.count true (multiset.map p s) = â‡‘multiset.card (multiset.filter p s)
strict_convex ğ•œ s â†’ s.ord_connected
rack.act (shelf.act x y) = rack.act x * rack.act y * (rack.act x)â»Â¹
f (â¨† (i : Î¹), g i) = â¨† (i : Î¹), f (g i)
l <:+ list.nil â†’ l = list.nil
e â€¢ v = â‡‘(module.ray.map e) v
seq_closure s âŠ† closure s
add_monoid.fg M â†” âˆƒ (S : set M), add_submonoid.closure S = âŠ¤ âˆ§ S.finite
category_theory.is_filtered D
dense_range (quotient.mk âˆ˜ f)
isometry (Kuratowski_embedding.embedding_of_subset x)
0 < a + b
a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d
bdd_below s
is_max_chain r (max_chain r)
irreducible p â†” irreducible (polynomial.map (int.cast_ring_hom â„š) p)
p a
strict_concave_on â„ D f
âˆƒ (t : finset Î¹), s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i
relation.join (relation.refl_trans_gen r) b c
has_dist.dist x y â‰¤ metric.diam s
s âŠ† interior (â‡‘(affine_map.homothety x t) '' s)
g.comp_linear_map (Î» (i : Î¹), â†‘(f i)) = 0 â†” g = 0
F.is_sheaf_opens_le_cover â†” F.is_sheaf_pairwise_intersections
f = g
âˆƒ (f : bump_covering Î¹ X s), (âˆ€ (i : Î¹), p â‡‘(â‡‘f i)) âˆ§ f.is_subordinate U
(â‹‚ (n : â„•), s n).nonempty
(a + b) * c = a * c + b * c
f.cycle_factors_finset.noncomm_prod id comm = f
I â‰¤ lie_ideal.comap f (lie_ideal.map f I)
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” has_inner.inner x y = 0
a * b < 1
a âŠ‚ b
âˆƒ (Z : multiset (prime_spectrum A)), (M ::â‚˜ multiset.map prime_spectrum.as_ideal Z).prod â‰¤ I âˆ§ Â¬(multiset.map prime_spectrum.as_ideal Z).prod â‰¤ I
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ t), g j))
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), â‡‘witt_vector.frobenius)
padic_val_rat p q â‰¤ padic_val_rat p (q + r)
is_top a â†’ is_bot (â‡‘order_dual.of_dual a)
f i = b
2 / real.pi * x â‰¤ real.sin x
â‡‘(orthogonal_projection K) â†‘v = v
affine_independent k (Î» (i : â†¥s), p â†‘i)
f = g
x âˆˆ metric.thickening Î´ E â†” âˆƒ (z : X) (H : z âˆˆ E), has_dist.dist x z < Î´
âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (u : â„) in f a..f b, g u
h = k
padic_val_rat p â†‘n = â†‘(padic_val_nat p n)
hb.rotation â†‘real.pi = linear_isometry_equiv.neg â„
category_theory.limits.has_limits_of_shape J Cáµ’áµ–
â‡‘(algebra_map A B) y = x
e.symm.trans e' âˆˆ G
is_max a â†’ is_min (â‡‘order_dual.to_dual a)
category_theory.limits.has_limit G
â‡‘m s = 0
(âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ asymptotics.is_O_with c l f g) â†’ f =o[l] g
âˆƒ (i : Î¹), b < f i
is_open {x : E | analytic_at ğ•œ f x}
P 1 â†’ (âˆ€ (f : equiv.perm Î±) (x y : Î±), x â‰  y â†’ P f â†’ P (equiv.swap x y * f)) â†’ P f
f = g
is_preconnected (set.Icc a b)
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), is_local_extr f c
H.normal
â‡‘(k.map hl j) (â‡‘(f.map hy k) x) = â‡‘(f.map _ j) x
s = t
aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a
â†‘(s.sum (Î» (i : Î¹), x i)) = s.sum (Î» (i : Î¹), â†‘(x i))
âˆ« (x : fin (n + 1) â†’ â„) in â‡‘box_integral.box.Icc I, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
(reflection K).symm = reflection K
a * b âˆˆ add_submonoid.closure â†‘S
(âˆƒ (b : Î²), a = u b) â†” a = u (l a)
C x hx
âˆƒ (Ï€' : box_integral.prepartition I), Ï€'.Union = â†‘I  Ï€.Union
f (ite P a b) (ite P c d) = ite P (f a c) (f b d)
continuous Î³.extend
linear_order.min (f x) (f y) < f z
category_theory.exponential_ideal i
0 â‰¤ a + b
(â‡‘(measure_theory.outer_measure.restrict s) Î¼).trim = â‡‘(measure_theory.outer_measure.restrict s) Î¼.trim
set.range f = {f inhabited.default}
0 < finite_dimensional.finrank K V â†” nontrivial V
add_subsemigroup.map f (add_subsemigroup.closure s) = add_subsemigroup.closure (â‡‘f '' s)
measure_theory.measure.map â‡‘f measure_theory.measure_space.volume = ennreal.of_real |(â‡‘linear_map.det f)â»Â¹| â€¢ measure_theory.measure_space.volume
x âˆˆ multiset.nat.antidiagonal n â†” x.fst + x.snd = n
â‡‘g (finprod (Î» (j : Î±), finprod (Î» (H : j âˆˆ s), f j))) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), â‡‘g (f i)))
x = y â†” hb.oangle x y = 0
Î¼.restrict (s âˆª t) = Î½.restrict (s âˆª t) â†” Î¼.restrict s = Î½.restrict s âˆ§ Î¼.restrict t = Î½.restrict t
â‡‘linear_equiv.det (hb.rotation Î¸).to_linear_equiv = 1
has_inner.inner (â‡‘(bounded_continuous_function.to_Lp 2 Î¼ ğ•œ) f) (â‡‘(bounded_continuous_function.to_Lp 2 Î¼ ğ•œ) g) = âˆ« (x : Î±), â‡‘(star_ring_end ğ•œ) (â‡‘f x) * â‡‘g x âˆ‚Î¼
p1 -áµ¥ p2 + (p2 -áµ¥ p3) = p1 -áµ¥ p3
(f + g).prod h = f.prod h * g.prod h
â‡‘(algebra.norm K) (Î¶ - 1) = â†‘(â†‘n.min_fac)
bdd_above (set.range f)
-(p1 -áµ¥ p2) = p2 -áµ¥ p1
a âˆˆ s
is_greatest s a â†’ is_least (f '' s) (f a)
cardinal.ord âˆ˜ cardinal.aleph' = ordinal.enum_ord {b : ordinal | b.card.ord = b}
âˆƒ (s : finset Ïƒ) (q : mv_polynomial {x // x âˆˆ s} R), p = â‡‘(mv_polynomial.rename coe) q
is_extr_filter (â‡‘order_dual.to_dual âˆ˜ f) l a â†’ is_extr_filter f l a
(n / d).totient = (finset.filter (Î» (k : â„•), n.gcd k = d) (finset.range n)).card
a * c âˆ£ b * c â†” a âˆ£ b
finset.image g (finset.imageâ‚‚ f s t) = finset.imageâ‚‚ f' s (finset.image g' t)
measurable (Î» (y : Î²), â‡‘Î¼ ((Î» (x : Î±), (x, y)) â»Â¹' s))
â‡‘Î¼ (f '' s) â‰¤ â†‘Îµ * â‡‘Î¼ (metric.closed_ball 0 R)
âˆƒ (s : Î± â†’ Î± â†’ Prop) (_x : is_linear_order Î± s), r â‰¤ s
is_least t a â†’ is_greatest (f '' t) (f a)
commute a (b * c)
âˆƒ (x : â„), â‡‘f x = x + f.translation_number
has_Sup.Sup s = a
collinear k {p}
cardinal.mk â„‚ = cardinal.continuum
Î¼.finite_at_filter (f âŠ“ Î¼.ae) â†’ Î¼.finite_at_filter f
p x
f = â‡‘(s.order_emb_of_fin h)
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ âˆ…), f i)) = 0
simple_graph.adj_matrix Î± h.to_graph = A
finite_dimensional.finrank ğ•œ â†¥Ká—® = n
pythagorean_triple 0 0 0
strict_convex_on â„ D f
X.Ïƒ j.succ â‰« X.Î´ (â‡‘fin.cast_succ i) = X.Î´ i â‰« X.Ïƒ j
filter.comap coe (nhds_within b (set.Iio b)) = filter.at_top
p â‰  0
âˆ« (x : â„) in a..b, real.sin x ^ m * real.cos x ^ (2 * n + 1) = âˆ« (u : â„) in real.sin a..real.sin b, u ^ m * (1 - u ^ 2) ^ n
â‡‘(A.cramer) b = A.adjugate.mul_vec b
(n + 1) * (n + 1).central_binom = 2 * (2 * n + 1) * n.central_binom
â†‘(l.dprod fÎ¹ fA) = (list.map (Î» (a : Î±), â†‘(fA a)) l).prod
category_theory.limits.has_colimit (category_theory.limits.span f g)
ideal.comap f I â‰¤ ideal.map g I
hb.oangle (â‡‘(hb.rotation Î¸) x) x = -Î¸
dense_range (prod.map f g)
bdd_below (has_insert.insert a s) â†” bdd_below s
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
cardinal.mk Î¹ â‰¤ â†‘(fintype.card â†¥w)
category_theory.preadditive_yoneda â‹™ (category_theory.whiskering_right Cáµ’áµ– AddCommGroup (Type v)).obj (category_theory.forget AddCommGroup) = category_theory.yoneda
emetric.inf_edist x s â‰¤ emetric.inf_edist x (metric.thickening Î´ s) + ennreal.of_real Î´
t.sum (Î» (i : Î¹), f i) âˆˆ S
âˆ¥âˆ‘' (i : Î¹), f iâˆ¥â‚Š â‰¤ âˆ‘' (i : Î¹), âˆ¥f iâˆ¥â‚Š
measure_theory.integrable F' Î¼ âˆ§ has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
{o : ordinal | a < b * order.succ o}.nonempty
P a b
s.nonempty â†’ (finset.map f s).nonempty
J â‰¤ category_theory.sheaf.finest_topology Ps
algebraic_independent R coe â†’ algebraic_independent R f
v âˆˆ (submodule.span ğ•œ {u})á—®
(nat.fib n).coprime (nat.fib (n + 1))
s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
lâ‚.prod â‰¤ lâ‚‚.prod
is_simple_group Î±
f (f (f x)) = f x
a â‰¤ b â†’ b â‰¤ a â†’ b = a
pi.single i x i' = pi.single i' x i
has_continuous_mul G
normalizer_condition G â†” âˆ€ (H : subgroup G), H.normalizer = H â†’ H = âŠ¤
(category_theory.category_of_elements.to_costructured_arrow F).right_op â‹™ category_theory.category_of_elements.from_costructured_arrow F = ğŸ­ F.elements
metric.bounded s â†” âˆƒ (r : â„), s âŠ† metric.closed_ball c r
âˆƒ (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ (âˆ€ â¦ƒm n : â„•â¦„, m < n â†’ r (Ï† m) (Ï† n)) âˆ§ f.has_antitone_basis (s âˆ˜ Ï†)
âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), 0 < g x) âˆ§ measurable g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ < Îµ
is_closed (B.polar s)
E âŠ† metric.thickening Î´ E
inner_product_geometry.angle (r â€¢ x) y = inner_product_geometry.angle x y
category_theory.mono f â†” function.injective f
strict_mono (Î» (x : Î²), f x + g x)
x ^ n = 1 â†” x ^ n.gcd (fintype.card G) = 1
(âˆ€ (E : A), category_theory.presieve.is_separated J (P â‹™ category_theory.coyoneda.obj (opposite.op E))) â†” âˆ€ â¦ƒX : Câ¦„ (S : category_theory.sieve X), S âˆˆ â‡‘J X â†’ âˆ€ (c : category_theory.limits.cone (S.arrows.diagram.op â‹™ P)), subsingleton (c âŸ¶ P.map_cone S.arrows.cocone.op)
(double_quot.quot_quot_mk I J).ker = I âŠ” J
has_star.star x = x
cauchy_seq f
âˆƒ (V : open_add_subgroup R), r â€¢ â†‘V âŠ† â†‘U
antitone f
a + b = b + a
add_con_gen r â‰¤ c
â‡‘(sâ‚.weighted_vsub p) w = â‡‘(sâ‚‚.weighted_vsub p) (â†‘sâ‚.indicator w)
âˆƒ (g : Î± â†’ â„), lipschitz_with K g âˆ§ set.eq_on f g s
âˆƒ (xâ‚€ : E), âˆ¥xâ‚€âˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ F â†’ 1 â‰¤ âˆ¥xâ‚€ - yâˆ¥
â‡‘(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R
same_ray R x (y + z)
(g.squash_gcf (n + 1)).s.nth m = g.s.nth m
padic_val_nat p n = (multiplicity p n).get _
function.surjective quotient.mk'
subsingleton M
âˆƒ (c : set M) (H : c âˆˆ s) (b : stream M), hindman.FP b âŠ† c
complete_lattice.is_compact_element k â†” âˆ€ (s : set Î±), s.nonempty â†’ directed_on has_le.le s â†’ k â‰¤ has_Sup.Sup s â†’ (âˆƒ (x : Î±), x âˆˆ s âˆ§ k â‰¤ x)
category_theory.mono f
relation.trans_gen r n m
has_fpower_series_at (g âˆ˜ f) (q.comp p) x
has_dist.dist p1 p2 = has_dist.dist p1 p3
perfection_map p f
continuous f
â†‘(lucas_lehmer.s i) = lucas_lehmer.X.Ï‰ ^ 2 ^ i + lucas_lehmer.X.Ï‰b ^ 2 ^ i
has_dist.dist (f m) (f n) â‰¤ (finset.Ico m n).sum (Î» (i : â„•), has_dist.dist (f i) (f (i + 1)))
cont_diff_within_at ğ•œ n (Î» (x : E), f x + g x) s x
finset.imageâ‚‚ f (finset.image g s) t = finset.image g' (finset.imageâ‚‚ f' s t)
function.left_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p Î¼ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p Î¼ hm)
nonempty (E â‰ƒL[ğ•œ] F) â†” finite_dimensional.finrank ğ•œ E = finite_dimensional.finrank ğ•œ F
âˆƒ (Î¹ : Type u) (_x : fintype Î¹) (z : Î¹ â†’ E) (w : Î¹ â†’ ğ•œ) (hss : set.range z âŠ† s) (hai : affine_independent ğ•œ z) (hw : âˆ€ (i : Î¹), 0 < w i), finset.univ.sum (Î» (i : Î¹), w i) = 1 âˆ§ finset.univ.sum (Î» (i : Î¹), w i â€¢ z i) = x
category_theory.is_iso f
finite_dimensional.finrank K V = 1 â†” nonempty (basis Î¹ K V)
â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) (measure_theory.mem_â„’p.to_Lp (Î» (a : Î±), has_inner.inner c (â‡‘f a)) _)) =áµ[Î¼] Î» (a : Î±), has_inner.inner c (â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) f) a)
(0 + x).equiv x
metric.cthickening Î´ Eâ‚ âŠ† metric.cthickening Î´ Eâ‚‚
p f
âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ C * â†‘(fintype.card Î¹) * linear_order.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
is_of_fin_order (x * y)
monotone (Î» (n : N), f (Î¼ n m))
âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), s âŠ† t
vector.scanl f b (x::áµ¥v) = b::áµ¥vector.scanl f (f b x) v
â‡‘linear_map.det (c â€¢ f) = c ^ finite_dimensional.finrank ğ•œ M * â‡‘linear_map.det f
has_inner.inner x y < 1 â†” x â‰  y
padic_norm p â†‘z â‰¤ 1
is_domain (localization M)
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆƒ (t : set Î±), measurable_set t âˆ§ â‡‘Î¼ t â‰  0 âˆ§ â‡‘Î¼ tá¶œ â‰  0 âˆ§ â¨ (x : Î±) in t, f x âˆ‚Î¼ â‰  â¨ (x : Î±) in tá¶œ, f x âˆ‚Î¼
(a - b) * c = a * c - b * c
filter.mapâ‚‚ m f (filter.map n g) = filter.map n' (filter.mapâ‚‚ m' g f)
is_ring_hom f
e.det â‰  0
a â‰¤ b â†’ a - b â‰¤ 0
category_theory.limits.has_binary_biproduct X Y
filter.tendsto u filter.at_top filter.at_top
(âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), h * g) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_mul_right_invariant
filter.tendsto (Î» (i : Î¹), â‡‘(measure_theory.L1.set_to_L1 hT) (fs i)) l (nhds (â‡‘(measure_theory.L1.set_to_L1 hT) f))
v.int_valuation_def x â‰  0
0 < finite_dimensional.finrank K V
has_inner.inner (A.transpose i) (B.transpose j) = A.conj_transpose.mul B i j
function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 0 â†’ a = 0
â‡‘f (a / b) = â‡‘f a / â‡‘f b
(k.map hl j).comp (f.map hy k) = f.map _ j
x +áµ¥ r â€¢ metric.ball 0 1 = metric.ball x r
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i - g i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) - finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), g i))
filter.Coprod (Î» (d : Î´), filter.cocompact (Îº d)) = filter.cocompact (Î  (d : Î´), Îº d)
open_embedding coe
v.prod.factor_multiset = v
is_open_map prod.snd
(f.lift g).has_basis (Î» (i : Î£ (i : Î¹), Î² i), p i.fst âˆ§ pg i.fst i.snd) (Î» (i : Î£ (i : Î¹), Î² i), sg i.fst i.snd)
hb.oangle (r â€¢ x) x = 0
collinear k s â†” âˆƒ (pâ‚€ : P) (v : V), âˆ€ (p : P), p âˆˆ s â†’ (âˆƒ (r : k), p = r â€¢ v +áµ¥ pâ‚€)
(S.prod g).factorization = S.sum (Î» (x : Î±), (g x).factorization)
add_con_gen â‡‘(add_con_gen r) = add_con_gen r
strict_convex ğ•œ (â‡‘f '' s)
âˆ¥g + hâˆ¥ â‰¤ âˆ¥gâˆ¥ + âˆ¥hâˆ¥
â‡‘(exterior_algebra.Î¹ R) m * â‡‘(exterior_algebra.Î¹ R) m = 0
{x : â„ | differentiable_within_at â„ f (set.Ici x) x âˆ§ deriv_within f (set.Ici x) x âˆˆ K} âŠ† right_deriv_measurable_aux.D f K
(m + n).choose k = (finset.nat.antidiagonal k).sum (Î» (ij : â„• Ã— â„•), m.choose ij.fst * n.choose ij.snd)
âˆ«â» (a : Î±), (â¨† (b : Î²), f b a) âˆ‚Î¼ = â¨† (b : Î²), âˆ«â» (a : Î±), f b a âˆ‚Î¼
monoid.is_torsion_free (Î  (i : Î·), Gs i)
(reflection K).trans (reflection K) = linear_isometry_equiv.refl ğ•œ E
âˆ¥q.comp_along_composition p câˆ¥ â‰¤ âˆ¥q c.lengthâˆ¥ * finset.univ.prod (Î» (i : fin c.length), âˆ¥p (c.blocks_fun i)âˆ¥)
â‡‘(â‡‘(b.repr) x) i = f x i
â†‘c.convergents = â†‘c.convergents'
f.comp_linear_map â†‘g = 0 â†” f = 0
has_dist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ = has_dist.dist pâ‚ pâ‚‚ â†” r = 0 âˆ¨ r = (-2) * has_inner.inner v (pâ‚ -áµ¥ pâ‚‚) / has_inner.inner v v
a < 1 â†’ 1 < aâ»Â¹
u =O[l] v â†’ (âˆƒ (Ï† : Î± â†’ ğ•œ) (hÏ† : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ Ï†)), u =á¶ [l] Ï† * v)
(polynomial.cyclotomic n R).coeff 0 = 1
âˆ«â» (x : Î±) in s, â†‘âˆ¥g xâˆ¥â‚Š âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±) in s, â†‘âˆ¥f xâˆ¥â‚Š âˆ‚Î¼
uniform_embedding topological_space.nonempty_compacts.to_closeds
â‡‘(v.valuation) (â‡‘(algebra_map R K) r) â‰¤ 1
F.is_sheaf â†” F.is_sheaf_pairwise_intersections
â‡‘m (â‹ƒ (n : â„•), s n) = â¨† (n : â„•), â‡‘m (s n)
âˆ¥w - vâˆ¥ = âˆ¥w + vâˆ¥
set.image2 f (set.image2 g s t) u âŠ† set.image2 g' (set.image2 fâ‚ s u) (set.image2 fâ‚‚ t u)
(â¨† (hâ‚ : p) (hâ‚‚ : q), s hâ‚ hâ‚‚) = â¨† (h : p âˆ§ q), s _ _
hb.oangle y z + hb.oangle x y = hb.oangle x z
â‡‘f (g - h) = â‡‘f g - â‡‘f h
a â€¢ s.center_mass ws zs + b â€¢ t.center_mass wt zt = (finset.map function.embedding.inl s âˆª finset.map function.embedding.inr t).center_mass (sum.elim (Î» (i : Î¹), a * ws i) (Î» (j : Î¹'), b * wt j)) (sum.elim zs zt)
f = nat.cast_ring_hom R
hb.oangle (r â€¢ x) y = hb.oangle (-x) y
âˆ« (y : â„) in a..b, deriv f y = f b - f a
â‡‘(f j k hjk) (â‡‘(f i j hij) x) = â‡‘(f i k _) x
âˆƒ (m : Î±), âˆ€ (a : Î±), r m a â†’ r a m
â‡‘((pmf.pure a).to_measure) s = ite (a âˆˆ s) 1 0
Sâ‚ = Sâ‚‚
linear_order.min (f x) (f y) â‰¤ f z
metric.bounded (s âˆª t)
â‡‘f (bit0 a) = bit0 (â‡‘f a)
has_deriv_within_at f f' s x â†’ has_deriv_within_at f f' t x
cauchy_seq f
âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
Â¬bdd_above {p : â„• | nat.prime p}
category_theory.presheaf.is_sheaf J E.X
(finset.range n).sum (Î» (i : â„•), f i â€¢ g i) = f (n - 1) â€¢ (finset.range n).sum (Î» (i : â„•), g i) - (finset.range (n - 1)).sum (Î» (i : â„•), (f (i + 1) - f i) â€¢ (finset.range (i + 1)).sum (Î» (i : â„•), g i))
m.sum âˆˆ S
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
(Î» (t : Î¹), ((âˆ« (x : â„) in va t..vb t, f x) - âˆ« (x : â„) in ua t..ub t, f x) - ((vb t - ub t) â€¢ cb - (va t - ua t) â€¢ ca)) =o[lt] Î» (t : Î¹), âˆ¥va t - ua tâˆ¥ + âˆ¥vb t - ub tâˆ¥
filter.tendsto F p (nhds f) â†” âˆ€ (K : set Î±), is_compact K â†’ tendsto_uniformly_on (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p K
category_theory.subobject.lower Fâ‚ = category_theory.subobject.lower Fâ‚‚
has_strict_fderiv_at (exp ğ•‚) 1 0
s.infinite
bâ‚ = bâ‚‚
category_theory.is_connected K
a â€¢ s + b â€¢ interior s âŠ† interior s
aâ»Â¹ < 1 â†’ 1 < a
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = 0
category_theory.presieve.is_sheaf âŠ¥ P
Fâ‚ = Fâ‚‚
is_extr_on (â‡‘order_dual.to_dual âˆ˜ f) s a â†’ is_extr_on f s a
â‡‘(has_Inf.Inf m) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (Î¼ : measure_theory.outer_measure Î±) (h3 : Î¼ âˆˆ m), â‡‘Î¼ (t n)
padic_norm_e 1 = 1
s.sum (Î» (i : Î¹), w i * z i) â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ p) ^ (1 / p)
strict_mono_on f s â†’ strict_anti_on (f âˆ˜ â‡‘order_dual.of_dual) s
Î¼.is_add_haar_measure
âˆƒ (S : C) (T : Î  {X : C}, X âˆˆ O â†’ (X âŸ¶ S)), âˆ€ {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y}, âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H â†’ f â‰« T mY = T mX
âˆƒ (u : set Ï„) (H : u âˆˆ f), closure (set.image2 Ï• u s) âŠ† n
nat.find _ = group.nilpotency_class G
âˆƒ (y : Î±) (H : y âˆˆ t), has_edist.edist x y < r
r a b â†” r b a
âˆƒ (i : Î¹), V i âŠ† U
sá¶œ âˆˆ filter.hyperfilter Î±
s.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i))
f.ker = âŠ¥
is_smul_regular M s
âˆƒ (y : Î²) (H : y âˆˆ t), b â‰¤ (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
âˆƒ (is : finset Î¹) {n : set X} (hnâ‚ : n âˆˆ nhds x) (hnâ‚‚ : n âŠ† â‹‚ (i : Î¹) (H : i âˆˆ is), U i), âˆ€ (z : X), z âˆˆ n â†’ function.support (Î» (i : Î¹), f i z) âŠ† â†‘is
is_bot a â†’ a = âŠ¥
filter.cofinite = filter.at_top
nonempty â†¥(set.Ico x (x + dx)  set.Ico y (y + dy))
char.quadratic_char F a = -1 â†” Â¬char.quadratic_char F a = 1
(finset.univ.pi t).sum (Î» (x : Î  (a : Î±), a âˆˆ finset.univ â†’ Î´ a), f x) = (fintype.pi_finset t).sum (Î» (x : Î  (a : Î±), Î´ a), f (Î» (a : Î±) (_x : a âˆˆ finset.univ), x a))
filter.map (prod.map (Î» (_x : Î±), b) id) ((filter.principal {a}).coprod (filter.principal {i})) = filter.principal ({b} Ã—Ë¢ set.univ)
(Î» (n : â„•), (âˆ« (a : Î©), (finset.range n).sum (Î» (i : â„•), probability_theory.truncation (X i) â†‘i) a) - â†‘n * âˆ« (a : Î©), X 0 a) =o[filter.at_top] coe
liouville.liouville_number m = liouville.liouville_number_initial_terms m k + liouville.liouville_number_tail m k
âˆ¥S.normed_mkâˆ¥ â‰¤ 1
a < 0 â†’ c â€¢ a < 0
âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼) ^ (1 / q)
is_square m â†’ (âˆƒ (c : Î±), m = c ^ 2)
1 < a * b
v.int_valuation_def x â‰¤ 1
category_theory.limits.has_limits Cáµ’áµ–
â‡‘((finset.map e sâ‚‚).weighted_vsub_of_point p b) w = â‡‘(sâ‚‚.weighted_vsub_of_point (p âˆ˜ â‡‘e) b) (w âˆ˜ â‡‘e)
p f
s.monge_point -áµ¥ finset.centroid â„ {iâ‚, iâ‚‚}á¶œ s.points = â‡‘(finset.univ.weighted_vsub s.points_with_circumcenter) (affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter iâ‚ iâ‚‚)
s.prod (Î» (c : Î³), g c) = Î» (a : Î±), s.prod (Î» (c : Î³), g c a)
ray_of_ne_zero R vâ‚ hvâ‚ = ray_of_ne_zero R vâ‚‚ hvâ‚‚ â†” same_ray R vâ‚ vâ‚‚
s.sum (Î» (x : Î±), ite (x = a) (b x) 0) = ite (a âˆˆ s) (b a) 0
â‡‘(â‡‘(finsupp.total Î¹ (module.dual R M) R b.coord) f) (â‡‘b i) = â‡‘f i
cardinal.mk (quaternion_algebra R câ‚ câ‚‚) = cardinal.mk R ^ 4
cont_diff_on ğ•œ n (Î» (x : E), f x - g x) s
continuous_at f a
c âŠ” d = con_gen (Î» (x y : M), â‡‘c x y âˆ¨ â‡‘d x y)
â‡‘(e.det) v â€¢ (basis.mk hli hsp).coord i = e.det.to_multilinear_map.to_linear_map v i
âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), t âŠ† s
category_theory.limits.pi.Ï€ g b (category_theory.limits.pi.map Î± x) = Î± b (category_theory.limits.pi.Ï€ f b x)
measurable f
is_domain (mv_polynomial Ïƒ R)
x âˆˆ s.antidiagonal â†” x.fst + x.snd = s
M f
algebra.finite_type R (add_monoid_algebra R M) â†” add_monoid.fg M
â†‘(t.sup f) = t.sup (Î» (x : Î²), â†‘(f x))
nonempty (V â‰ƒâ‚—[K] Vâ‚‚)
spectrum ğ•œ (â‡‘(polynomial.aeval a) p) = (Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a
summable (Î» (k : â„•), 2 ^ k * f (2 ^ k)) â†” summable f
is_greatest t a â†’ is_least (f '' t) (f a)
(polynomial.X ^ n - â‡‘polynomial.C a).separable
set.Iio a âŠ† set.Iio b
continuous (convolution f g L Î¼)
multiplicity p n â‰¤ multiplicity p (n.choose k) + multiplicity p k
C q
âˆ¥fâˆ¥â‚Š â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥â‚Š â‰¤ C
x âˆˆ set.Icc a b â†’ f x â‰¤ B x
n.divisors.prod (Î» (i : â„•), polynomial.cyclotomic' i K) = polynomial.X ^ n - 1
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ + (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real
âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ = has_Inf.Inf ((Î» (x : M), âˆ¥m + xâˆ¥) '' â†‘S)
-a < a
measure_theory.integrable_at_filter f (l âŠ“ Î¼.ae) Î¼ â†’ measure_theory.integrable_at_filter f l Î¼
x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
Q.basis_repr v = quadratic_form.weighted_sum_squares Râ‚ (Î» (i : Î¹), â‡‘Q (â‡‘v i))
f =o[l] g â†’ âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ asymptotics.is_O_with c l f g
â‡‘Î¼ K < âŠ¤
p x y
x â‰¤ y â†” (âˆ€ (i : x.left_moves), x.move_left i < y) âˆ§ âˆ€ (j : y.right_moves), x < y.move_right j
function.injective (has_vsub.vsub p)
no_zero_smul_divisors R M
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), f' c = (f b - f a) / (b - a)
â†‘(affine_subspace.mk' p direction).nonempty
relation.trans_gen r n m
(truncated_witt_vector.zmod_equiv_trunc p n).symm.to_ring_hom.comp (truncated_witt_vector.truncate hm) = (zmod.cast_hom _ (zmod (p ^ n))).comp (truncated_witt_vector.zmod_equiv_trunc p m).symm.to_ring_hom
continuous f â†” continuous (â‡‘e âˆ˜ f)
nat.fib (n + 2) = nat.fib n + nat.fib (n + 1)
has_dist.dist (â‡‘f x) (â‡‘f y) â‰¤ 2 * âˆ¥fâˆ¥
is_monoid_hom f
measure_theory.strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½)
inner_product_space.is_self_adjoint T â†” âˆ€ (v : V), â‡‘(star_ring_end â„‚) (has_inner.inner (â‡‘T v) v) = has_inner.inner (â‡‘T v) v
âˆƒ (i : Î¹) (x : G i), â‡‘(first_order.language.direct_limit.of L Î¹ G f i) x = z
(sâ‚ âŠ“ sâ‚‚).direction = sâ‚.direction âŠ“ sâ‚‚.direction
â†‘(s.direction) = â†‘s -áµ¥ â†‘s
is_empty (subtype p)
polynomial.has_separable_contraction q f
cont_diff_within_at ğ•œ n (g âˆ˜ f) s x
convex ğ•œ s â†’ s.ord_connected
(â¨† (i : Î¹), Î¼ i).trim = â¨† (i : Î¹), (Î¼ i).trim
module.rank R (M Ã— N) = (module.rank R M).lift + (module.rank R N).lift
â‡‘(hb.rotation Î¸) x = x â†” x = 0 âˆ¨ Î¸ = 0
âˆƒ (V : open_subgroup G) (W : open_subgroup K), â†‘V Ã—Ë¢ â†‘W âŠ† U
filter.at_top.limsup (Î» (n : â„•), â†‘âˆ¥a ^ nâˆ¥â‚Š ^ (1 / â†‘n)) â‰¤ spectral_radius â„‚ a
f.lintegral Î¼ = g.lintegral Î½
P = Q
filter.tendsto (Î» (r : â„), metric.closed_ball x r) (nhds_within 0 (set.Ioi 0)) ((besicovitch.vitali_family Î¼).filter_at x)
monoid.is_torsion G
asymptotics.is_O_with c l f' g â†’ asymptotics.is_O_with c l (Î» (x : Î±), -f' x) g
topological_semiring R
0 âˆˆ S
bdd_above (set.range f)
âŠ¥.is_clique s â†’ s.subsingleton
filter.tendsto (Î» (n : Î±), c n â€¢ (f (x + (c n)â»Â¹ â€¢ v) - f x)) l (nhds (â‡‘f' v))
â‡‘(mâ‚.trim) s = op (â‡‘(mâ‚‚.trim) s)
(â‡‘quadratic_form.associated' Q).nondegenerate
â‡‘linear_map.det â†‘(f.symm) = (â‡‘linear_map.det â†‘f)â»Â¹
filter.tendsto (Î» (n : â„•), thickened_indicator_aux (Î´seq n) E) filter.at_top (nhds ((closure E).indicator (Î» (x : Î±), 1)))
âˆƒ (u v : set Î±), is_open u âˆ§ is_open v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ u âˆ© v = âˆ…
algebra.finite_type R A â†” âˆƒ (n : â„•) (f : mv_polynomial (fin n) R â†’â‚[R] A), function.surjective â‡‘f
p1 = p2
â‡‘Î¼ (f '' s) = 0
âˆ« (x : Î±), f x âˆ‚Î¼ âˆˆ s
p = p' â†’ ps = ps' â†’ p + ps = p' + ps'
(finsupp.map_domain f s).sum (Î» (b : Î²) (m : M), â‡‘(h b) m) = s.sum (Î» (a : Î±) (m : M), â‡‘(h (f a)) m)
C * (y - x) < f y - f x
k = 1
metric.cthickening Î´ E = â‹ƒ (x : Î±) (H : x âˆˆ E), metric.closed_ball x Î´
A âˆˆ ğ’œ.slice r â†” A âˆˆ ğ’œ âˆ§ A.card = r
vector_span k (set.range p) = sm
generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n â†’ v = generalized_continued_fraction.comp_exact_value ((generalized_continued_fraction.of v).continuants_aux n) ((generalized_continued_fraction.of v).continuants_aux (n + 1)) ifp_n.fr
category_theory.limits.kernel_subobject (f â‰« h) = category_theory.limits.kernel_subobject f
â‡‘(c.map d h) x = â‡‘(c.lift d.mk' _) x
P.fg â†” âˆƒ (S : set G), subgroup.closure S = P âˆ§ S.finite
finset.imageâ‚‚ f s t = finset.imageâ‚‚ f' s t
e.is_image s t â†’ e.source âˆ© â‡‘e â»Â¹' t = e.source âˆ© s
âˆƒ (C : â„), âˆ€ (z : E), âˆ¥â‡‘f zâˆ¥ â‰¤ C * âˆ¥zâˆ¥
continuous (Î» (a_1 : Î³), set.Icc_extend h (f a_1) (g a_1))
H = âŠ¥ âˆ¨ nontrivial â†¥H
is_smul_regular R g
âˆƒ (l : list F), l.length â‰¤ n âˆ§ Ï† = (list.map (Î» (v : F), reflection (submodule.span â„ {v})á—®) l).prod
is_add_hom (g âˆ˜ f)
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ g '' s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ s), f (g j)))
lipschitz_with C f â†’ holder_with C 1 f
((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod (sum.inl i) (sum.inr ()) = 0
dimH (f '' s) â‰¤ dimH s
relation.refl_trans_gen r n m
s.sum (Î» (x : Î³), (t x).sum (Î» (y : Î±), f x y)) = t'.sum (Î» (y : Î±), (s' y).sum (Î» (x : Î³), f x y))
category_theory.limits.has_wide_coequalizers C
finset.univ.sum (Î» (i : Î¹), f i * g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i))
(âˆƒ (b : Î±), âˆ€ (x : Î²), r (u x) b) â†’ filter.is_bounded_under r f u
module.rank Î± â†¥(E.sol_space) = â†‘(E.order)
a * b â‰¤ 1
(g.comp_linear_map fâ‚).comp_linear_map fâ‚‚ = g.comp_linear_map (Î» (i : Î¹), (fâ‚ i).comp (fâ‚‚ i))
char_p K p
vector_span k s = submodule.span k (has_vsub.vsub p '' (s  {p}))
iterated_deriv n (exp_neg_inv_glue.f_aux 0) = exp_neg_inv_glue.f_aux n
has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) a
f = f'
list.split_on_p p xs = [xs]
has_inner.inner â†‘(â‡‘(orthogonal_projection K) u) v = has_inner.inner u â†‘(â‡‘(orthogonal_projection K) v)
âˆƒ (Î± : Type v) (c : Î± â†’ X) (r : Î  (a : Î±), Î¹ (c a)), (âˆ€ (a : Î±), p (c a) (r a)) âˆ§ (â‹ƒ (a : Î±), B (c a) (r a)) = set.univ âˆ§ locally_finite (Î» (a : Î±), B (c a) (r a))
C x
has_inner.inner x y * has_inner.inner x y â‰¤ has_inner.inner x x * has_inner.inner y y
s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) < s.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
measurable_set (f '' s)
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆ© t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, complex.I â€¢ â‡‘(f' (â†‘x + â†‘y * complex.I)) 1 - â‡‘(f' (â†‘x + â†‘y * complex.I)) complex.I
aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
âˆƒ (x : M), â‡‘Q x â‰  0
emetric.diam (s âˆª t) â‰¤ emetric.diam s + has_edist.edist x y + emetric.diam t
function.injective â‡‘(I.quotient_map f H)
âˆ¥fâˆ¥â‚Š â‰¤ M
set.eq_on f g {z : â„‚ | 0 â‰¤ z.re âˆ§ z.im â‰¤ 0}
f = g
e.trans e.symm â‰ˆ local_equiv.of_set e.source
is_domain K
matrix.dot_product (â‡‘(â‡‘cross_product u) v) (â‡‘(â‡‘cross_product w) x) = matrix.dot_product u w * matrix.dot_product v x - matrix.dot_product u x * matrix.dot_product v w
s.sum (Î» (i : Î¹), f i) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), f i ^ p)
mul_action.stabilizer R m = mul_action.stabilizer R â†‘m
module.finite R M
(âˆ€ (a : â†¥P), â‡‘f a = 0) â†’ f = 0
category_theory.epi Î²
is_right_regular b
f = g
b ^ x â‰¤ y â†” x â‰¤ nat.log b y
uniformity Î± = â¨† (x : Î±), nhds (x, x)
x âˆˆ set.Icc a b â†’ f x â‰¤ B x
disjoint Hâ‚ Hâ‚‚
â†‘u âŠ† s - t â†’ (âˆƒ (s' t' : finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' - t')
finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â†” Â¬antivary f (g âˆ˜ â‡‘Ïƒ)
denoms_clearable a b f.nat_degree f i
âˆƒ (a : â„¤), H = add_subgroup.closure {a}
polynomial.X * p = p * polynomial.X
(matrix.from_blocks A 0 C D).is_diag
â‡‘(â‡‘cross_product u) (â‡‘(â‡‘cross_product v) w) + â‡‘(â‡‘cross_product v) (â‡‘(â‡‘cross_product w) u) + â‡‘(â‡‘cross_product w) (â‡‘(â‡‘cross_product u) v) = 0
finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary f (g âˆ˜ â‡‘Ïƒ)
â‡‘vâ‚ i = â‡‘vâ‚‚ i
âˆƒ (c : P), âˆ€ (sx : affine.simplex â„ P n), set.range sx.points âŠ† ps â†’ sx.circumcenter = c
iterated_fderiv ğ•œ n f = â‡‘(continuous_multilinear_map.pi_field_equiv ğ•œ (fin n) F) âˆ˜ iterated_deriv n f
âˆƒ (t : set E') (H : t âˆˆ nhds x), lipschitz_on_with K f t
Ï†.order = n â†” (âˆ€ (i : â„•), â†‘i = n â†’ â‡‘(power_series.coeff R i) Ï† â‰  0) âˆ§ âˆ€ (i : â„•), â†‘i < n â†’ â‡‘(power_series.coeff R i) Ï† = 0
a â‰¤ b â†’ c â‰¤ d
direct_sum.is_internal V â†” (supr V)á—® = âŠ¥
âˆ« (x : â„) in a..b, real.cos x ^ (n + 2) = (real.cos b ^ (n + 1) * real.sin b - real.cos a ^ (n + 1) * real.sin a) / (â†‘n + 2) + (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, real.cos x ^ n
list.duplicate x l â†” [x, x] <+ l
f x = b
(Î½.with_density f).rn_deriv Î½ =áµ[Î½] f
0 â‰¤ t
v +áµ¥ p âˆˆ s
f = g
â‡‘linear_map.det â†‘((â‡‘rotation a).to_linear_equiv) = 1
polynomial.cyclotomic n â„š = minpoly â„š Î¼
âˆƒ (u : â„¤Ë£) (n : â„•), algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = â†‘u * â†‘p ^ n
filter.comap f (filter.cocompact Î²) â‰¤ filter.cocompact Î±
function_field Fq F â†” finite_dimensional Fqt F
is_max_on (â‡‘order_dual.to_dual âˆ˜ f) s a â†’ is_min_on f s a
relation.refl_trans_gen r a b
has_sbtw.sbtw a b c
L.limsup (Î» (i : Î¹), â‡‘â†‘(Î¼s i) F) â‰¤ â‡‘â†‘Î¼ F
has_strict_fderiv_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•‚ E' F') (p x 1)) x
a âˆˆ tactic.interval_cases.set_elems s
finset.univ.prod (Î» (a : Î±), (t a).sum (Î» (b : Î´ a), f a b)) = (fintype.pi_finset t).sum (Î» (p : Î  (a : Î±), Î´ a), finset.univ.prod (Î» (x : Î±), f x (p x)))
cont_diff ğ•œ n prod.fst
0 < k â†’ polynomial.cyclotomic (p ^ k * m) R = polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1))
category_theory.epi Î±
f = g
function.surjective â‡‘f
1 â‰¤ a * b
measure_theory.integrable f (Î¼.prod Î½) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼, measure_theory.integrable (Î» (y : Î²), f (x, y)) Î½) âˆ§ measure_theory.integrable (Î» (x : Î±), âˆ« (y : Î²), âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼
set.Icc a b âŠ† s
is_scalar_tower R S T
finset.map (function.embedding.subtype p) (finset.subtype p s) = s
hb.oangle (-x) (-y) = hb.oangle x y
l.dprod fÎ¹ fA = âŸ¨(list.map (Î» (a : Î±), â†‘(fA a)) l).prod, _âŸ©
filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i)) filter.at_top (nhds a)
measurable_set s â†’ (filter.principal s).is_measurably_generated
zmod.legendre_sym p a = 1 âˆ¨ zmod.legendre_sym p a = -1
dense_range (g âˆ˜ f)
category_theory.limits.has_kernel (f - g)
z âˆˆ set.Ioc x y â†” âˆƒ (a b : ğ•œ), 0 â‰¤ a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
is_compact s â†” is_compact (f '' s)
âˆƒ (y : N), â‡‘f x + y = 0
disjoint (exterior_algebra.Î¹ R).range 1
(âˆ¥u - vâˆ¥ = â¨… (w : â†¥K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : F), w âˆˆ K â†’ has_inner.inner (u - v) (w - v) â‰¤ 0
âˆƒ (i j : â„•) (b c : R), i + j = n âˆ§ a = b * c âˆ§ x = b * p ^ i âˆ§ y = c * p ^ j
âˆ«â» (x : E) in s, ennreal.of_real |(f' x).det| âˆ‚Î¼ = â‡‘Î¼ (f '' s)
âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), f x â‰¤ g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), f x âˆ‚Î¼ + Îµ
âŠ¥ = âŠ¤
is_top a â†’ is_bot (â‡‘order_dual.to_dual a)
filter.tendsto (Î» (n : Î¹), âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
âˆƒ (y : E) (H : y âˆˆ frontier s), metric.inf_dist x sá¶œ = has_dist.dist x y
has_edist.edist (f 0) a â‰¤ 2 * C
category_theory.presheaf.fork_map R F â‰« (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom = F.map (category_theory.eq_to_hom _).op â‰« Top.presheaf.sheaf_condition_equalizer_products.res F (Top.presheaf.covering_of_presieve U R)
euclidean_geometry.orthogonal_projection_fn s p âˆˆ affine_subspace.mk' p (s.direction)á—®
finsum (Î» (i : Î±), f i - g i) = finsum (Î» (i : Î±), f i) - finsum (Î» (i : Î±), g i)
odd a â†’ (âˆƒ (b : Î±), a = bit1 b)
padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r
category_theory.mono t.inl
f.translation_number = â†‘m / â†‘n
f i = 0
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ has_insert.insert a s), f i)) = f a * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - 2 * âˆ¥xâˆ¥ * âˆ¥yâˆ¥ * real.cos (inner_product_geometry.angle x y)
category_theory.is_iso (category_theory.limits.limit.Ï€ F j)
a / a * a = a
â‡‘f x = â‡‘g x
continuous_on f s
cardinal.mk â†¥(set.Ioi a) = cardinal.continuum
x âˆˆ H â†’ -x âˆˆ H
category_theory.limits.initial_mono_class C
t.prod (Î» (i : Î¹), fâ‚ i) âŠ† t.prod (Î» (i : Î¹), fâ‚‚ i)
classical.some _ â‰  0
measure_theory.measure.mk_metric mâ‚ â‰¤ c â€¢ measure_theory.measure.mk_metric mâ‚‚
â‡‘(orthogonal_projection Ká—®) v = 0
local_homeomorph.refl H âˆˆ structure_groupoid.maximal_atlas H G
âˆ«â» (a : Î±), f a + g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼
is_mul_hom â‡‘h
Î¼.inner_regular is_compact (Î» (s : set Î±), measurable_set s âˆ§ â‡‘Î¼ s â‰  âŠ¤)
asymptotics.is_O_with c l u v
(wâ‚ * zâ‚ + wâ‚‚ * zâ‚‚) ^ p â‰¤ wâ‚ * zâ‚ ^ p + wâ‚‚ * zâ‚‚ ^ p
(con.ker_lift f).mrange = f.mrange
category_theory.is_iso (category_theory.limits.prod_comparison (category_theory.left_adjoint i) A B)
category_theory.presieve.is_sheaf_for P R
â†‘a = â†‘b â†” â‡‘c a b
(âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
category_theory.limits.has_pushouts C
âˆƒ (s : Î²), (interior (f s)).nonempty
â‡‘((hV.linear_isometry_equiv hV').symm) w = âˆ‘' (i : Î¹), â‡‘(V i) (â‡‘w i)
function.is_periodic_pt f n x
(finset.range (n + 1)).sum (Î» (m : â„•), n.choose m) = 2 ^ n
âˆƒ (p : polynomial â„), âˆ¥p.to_continuous_map_on (set.Icc a b) - fâˆ¥ < Îµ
measurable (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s))
fintype.card â†¥(H.normalizer) â‰¡ fintype.card G [MOD p ^ (n + 1)]
set.Icc a b âŠ† s
âˆƒ (f : â„• â†’ E), (âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ R) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ 1 â‰¤ âˆ¥f m - f nâˆ¥
bdd_below s â†’ bdd_below t â†’ (s âˆ© t).nonempty â†’ has_Inf.Inf s âŠ” has_Inf.Inf t â‰¤ has_Inf.Inf (s âˆ© t)
aâ»Â¹ < 1 â†” 1 < a
coe âˆ˜ coe = coe
(2 * n).choose r â‰¤ n.central_binom
â‡‘((p.bind_on_support f).to_measure) s = âˆ‘' (a : Î±), â†‘(â‡‘p a) * dite (â‡‘p a = 0) (Î» (h : â‡‘p a = 0), 0) (Î» (h : Â¬â‡‘p a = 0), â‡‘((f a h).to_measure) s)
dense (â‹‚â‚€ S)
pi.single i (r â€¢ x) = r â€¢ pi.single i x
set.eq_on (has_norm.norm âˆ˜ f) (function.const E âˆ¥f zâˆ¥) (metric.closed_ball z r)
set.eq_on â‡‘f' â‡‘fâ‚' (tangent_cone_at ğ•œ s x)
set.range coe = {x : Î± | p x}
is_add_regular (a + b) âˆ§ is_add_regular (b + a) â†” is_add_regular a âˆ§ is_add_regular b
-b + a < c â†’ a < b + c
a ^ 2 - b ^ 2 = (a + b) * (a - b)
s.sym2.card = s.card * (s.card + 1) / 2
filter.map (Î» (s : finset Î³), s.prod (Î» (i : Î³), f (g i))) filter.at_top = filter.map (Î» (s : finset Î²), s.prod (Î» (i : Î²), f i)) filter.at_top
a âˆˆ closure s â†” âˆ€ (o : set Î±), o âˆˆ b â†’ a âˆˆ o â†’ (o âˆ© s).nonempty
(multiset.nat.antidiagonal n).nodup
fintype.card â†¥(add_action.orbit Î± b) * fintype.card â†¥(add_action.stabilizer Î± b) = fintype.card Î±
âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
-vâ‚ â‰ˆ -vâ‚‚ â†” vâ‚ â‰ˆ vâ‚‚
bdd_above s
f =O[l] g â†” âˆƒ (c : â„), asymptotics.is_O_with c l f g
âˆ« (x : G), f x âˆ‚Î¼ = 0
qpf.Wequiv x y â†’ qpf.recF u x = qpf.recF u y
measure_theory.is_fundamental_domain G s Î¼
has_dist.dist (s.points i) s.circumcenter = s.circumradius
s.circumcenter âˆˆ affine_span â„ (set.range s.points)
âˆƒ (x : Î²), âˆ€ (y : Î²), f x â‰¤ f y
linear_independent K (Î» (i : fin (minpoly K x).nat_degree), x ^ â†‘i)
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
disjoint a.factorization.support b.factorization.support
x âˆˆ set.Icc a b â†’ f x â‰¤ B x
subfield.closure â†‘s = s
|a * b| â‰¤ |a| * |b|
has_Sup.Sup S = add_con_gen (Î» (x y : M), âˆƒ (c : add_con M), c âˆˆ S âˆ§ â‡‘c x y)
is_min_filter (â‡‘order_dual.to_dual âˆ˜ f) l a â†’ is_max_filter f l a
irreducible Ï– â†” local_ring.maximal_ideal R = ideal.span {Ï–}
b = a
âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ â‡‘g âˆ˜ e = â‡‘f
f âˆˆ measure_theory.Lp.bounded_continuous_function E p Î¼ â†” âˆƒ (fâ‚€ : bounded_continuous_function Î± E), continuous_map.to_ae_eq_fun Î¼ fâ‚€.to_continuous_map = â†‘f
(âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.sum âˆˆ K
finset.centroid k s p = â‡‘(finset.univ.affine_combination p) (finset.centroid_weights_indicator k s)
filter.tendsto (Î» (x : â„), real.exp x / x ^ n) filter.at_top filter.at_top
nat.fib (m + n + 1) = nat.fib m * nat.fib n + nat.fib (m + 1) * nat.fib (n + 1)
p âˆˆ affine_span k (has_insert.insert p2 â†‘s) â†” âˆƒ (r : k) (p0 : P) (hp0 : p0 âˆˆ s), p = r â€¢ (p2 -áµ¥ p1) +áµ¥ p0
p s hs
I * Iâ»Â¹ = 1
measurable (Î» (h : G), h - g)
c = d
galois_connection (Î» (s : set A), projective_spectrum.zero_locus ğ’œ s) (Î» (t : (set (projective_spectrum ğ’œ))áµ’áµˆ), â†‘(projective_spectrum.vanishing_ideal t))
Î¼ = Î½
filter.tendsto f filter.at_bot filter.at_bot â†” âˆ€ (b : Î²), âˆƒ (a : Î±), f a â‰¤ b
A.det = finset.univ.sum (Î» (i : fin n.succ), (-1) ^ â†‘i * A i 0 * (A.minor â‡‘(i.succ_above) fin.succ).det)
category_theory.limits.has_colimits_of_shape J C
âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
b âˆˆ s
0 â‰¤ a ^ 2
â‡‘Î¼ (frontier s) = 0
1 â‰¤ ifp_succ_n.b
â‡‘(linear_map.trace R M) f = (â‡‘(linear_map.to_matrix b b) f).trace
â‡‘Dâ‚ f = â‡‘Dâ‚‚ f
âˆƒ (Q : ideal S), Q.is_maximal âˆ§ ideal.comap (algebra_map R S) Q = P
galois_connection (â‡‘order_dual.to_dual âˆ˜ fixing_submonoid M) ((Î» (P : submonoid M), mul_action.fixed_points â†¥P Î±) âˆ˜ â‡‘order_dual.of_dual)
is_preconnected (f '' s)
measure_theory.measure_preserving (prod.map f g) (Î¼a.prod Î¼c) (Î¼b.prod Î¼d)
filter.tendsto complex.abs (filter.cocompact â„‚) filter.at_top
â‡‘(measure_theory.measure.map â‡‘f Î¼) s = â‡‘Î¼ (â‡‘f â»Â¹' s)
â‡‘(c.lift f H) â†‘x = â‡‘f x
i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.snd.blocks = j.snd.blocks
discrim a b c â‰¤ 0
p âˆˆ affine_subspace.mk' p direction
C q
supr S = (dfinsupp.sum_add_hom (Î» (i : Î¹), (S i).subtype)).mrange
padic_norm p q â‰  0
module.projective R P â†” category_theory.projective (Module.of R P)
category_theory.limits.has_kernels (Module R)
continuous_at ring.inverse â†‘x
x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
dimH (set.range f) â‰¤ dimH set.univ / â†‘r
has_fderiv_at (Î» (x : H), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' xâ‚€ t âˆ‚Î¼) xâ‚€
has_Sup.Sup (s âˆ© t) â‰¤ has_Sup.Sup s âŠ“ has_Sup.Sup t
âˆƒ (f : L â†’ P), function.injective f âˆ§ âˆ€ (l : L), f l âˆ‰ l
âˆƒ (a b : â„), (a, b) â‰  0 âˆ§ a â€¢ f' + b â€¢ Ï†' = 0
M.det = 0
order_of x = n
add_monoid.closure {x} = multiples x
(f'.prod Ï†').range â‰  âŠ¤
metric.bounded (metric.sphere x r)
algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p ^ (k + 1)).totient / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
2 â€¢ hb.oangle (-x) y = 2 â€¢ hb.oangle x y
âˆ€á¶  (t : set (Î± Ã— Î±)) in (uniformity Î±).small_sets, comp_rel t t âŠ† s
hb.rotation 0 = linear_isometry_equiv.refl â„ V
category_theory.is_iso (category_theory.limits.limit.Ï€ F i)
âˆ€áµ (x : Î±) âˆ‚Î¼, P x
is_descending_central_series (lower_central_series G)
(x.move_left i).move_right (pgame.right_response h i) â‰¤ 0
N.is_commutative
is_closed (weak_dual.polar ğ•œ s)
f t = g t
module.rank R (Î¹ â†’â‚€ R) = (cardinal.mk Î¹).lift
cont_diff ğ•œ â†‘(n + 1) fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ â†‘n (deriv fâ‚‚)
(polynomial.cyclotomic n R).is_primitive
is_compact (s  t)
â‡‘zmod.Ï‡â‚ˆ â†‘n = ite (n % 2 = 0) 0 (ite (n % 8 = 1 âˆ¨ n % 8 = 7) 1 (-1))
has_fpower_series_on_ball (Î» (w : â„‚), (2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, â†‘R), (z - w)â»Â¹ â€¢ f z) (cauchy_power_series f c â†‘R) c â†‘R
â†‘p âˆˆ s
S = T
has_sbtw.sbtw a b c â†” has_sbtw.sbtw c a b
finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index (n + 2)), affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter iâ‚ iâ‚‚ i) = 0
category_theory.topology_of_closure_operator Jâ‚.closure_operator _ = Jâ‚
polynomial.cyclotomic' 1 R = polynomial.X - 1
category_theory.limits.colimit.Î¹ F j â‰« category_theory.limits.colimit.desc F c = c.Î¹.app j
(measure_theory.measure.map â‡‘(quotient_group.mk' Î“) (Î¼.restrict ğ“•)).is_mul_left_invariant
s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L1_clm hm Î¼) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
p.radius = filter.at_top.liminf (Î» (n : â„•), 1 / â†‘(âˆ¥p nâˆ¥â‚Š ^ (1 / â†‘n)))
t.prod (Î» (i : Î¹), f i) âˆˆ s
(âˆƒ (v : n â†’ K) (H : v â‰  0), M.mul_vec v = 0) â†” M.det = 0
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆ© t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
â‡‘Î¼ E * âˆ«â» (y : G), f y âˆ‚Î½ = âˆ«â» (x : G), â‡‘Î½ ((Î» (z : G), z * x) â»Â¹' E) * f xâ»Â¹ âˆ‚Î¼
has_dist.dist x y â‰¤ metric.diam s
âˆ¥xâˆ¥ < r â†” âˆ€ (i : Î¹), âˆ¥x iâˆ¥ < r
function.injective (Î» (n : â„•), polynomial.cyclotomic n R)
uniform_embedding f â†’ ((âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ {a b : Î±}, has_dist.dist a b < Î´ â†’ has_dist.dist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : â„), Î´ > 0 â†’ (âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ {a b : Î±}, has_dist.dist (f a) (f b) < Îµ â†’ has_dist.dist a b < Î´))
supr A = âŠ¤
f.prod (Î» (x : Î±) (v : M), ite (x = a) (b x v) 1) = ite (a âˆˆ f.support) (b a (â‡‘f a)) 1
subgroup.normal_closure {âŸ¨equiv.swap 0 4 * equiv.swap 1 3, _âŸ©} = âŠ¤
s.nonempty â†’ (âˆ€ (a : Î±), a âˆˆ s â†’ b â‰¤ a) â†’ (âˆ€ (w : Î±), b < w â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), a < w)) â†’ has_Inf.Inf s = b
âˆ….up_shadow = âˆ…
is_compact (s âˆ© t)
âˆ« (x : F) in set.Icc a b, DF x = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in set.Icc (â‡‘eL a âˆ˜ â‡‘(i.succ_above)) (â‡‘eL b âˆ˜ â‡‘(i.succ_above)), f i (â‡‘(eL.symm) (i.insert_nth (â‡‘eL b i) x))) - âˆ« (x : fin n â†’ â„) in set.Icc (â‡‘eL a âˆ˜ â‡‘(i.succ_above)) (â‡‘eL b âˆ˜ â‡‘(i.succ_above)), f i (â‡‘(eL.symm) (i.insert_nth (â‡‘eL a i) x)))
dense (s âˆ© t)
âˆ« (x : â„) in a..b, real.sin x ^ (2 * m) * real.cos x ^ (2 * n) = âˆ« (x : â„) in a..b, ((1 - real.cos (2 * x)) / 2) ^ m * ((1 + real.cos (2 * x)) / 2) ^ n
â‡‘multilinear_map.alternatization â†‘a = (fintype.card Î¹).factorial â€¢ a
padic_val_int p 0 = 0
lie_algebra.is_solvable R â†¥I â†” I â‰¤ lie_algebra.radical R L
â†‘0 = 0
metric.diam (s âˆª t) â‰¤ metric.diam s + has_dist.dist x y + metric.diam t
directed r f
â‡‘f (Î» (i : Î¹), finset.univ.sum (Î» (j : Î± i), g i j)) = finset.univ.sum (Î» (r : Î  (i : Î¹), Î± i), â‡‘f (Î» (i : Î¹), g i (r i)))
âˆƒ (x : Î²), âˆ€ (y : Î²), f x â‰¤ f y
a âˆ£ b
has_nndist.nndist a a = 0
set.image2 f s t âŠ† set.image2 f s' t'
(s.erase a).prod (Î» (x : Î±), f x) * f a = s.prod (Î» (x : Î±), f x)
Ï† = Ïˆ â†” âˆ€ (n : Ïƒ â†’â‚€ â„•), â‡‘(mv_power_series.coeff R n) Ï† = â‡‘(mv_power_series.coeff R n) Ïˆ
âˆ‘' (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2 â‰¤ âˆ¥xâˆ¥ ^ 2
(â‹‚ (l : E â†’L[â„] â„), {x : E | âˆƒ (y : E) (H : y âˆˆ s), â‡‘l x â‰¤ â‡‘l y}) = s
â‡‘f x = â‡‘f y
convex_on â„ D f
âˆƒ (s : set Î±), s.countable âˆ§ dense s âˆ§ (âˆ€ (x : Î±), is_bot x â†’ x âˆˆ s) âˆ§ âˆ€ (x : Î±), is_top x â†’ x âˆˆ s
f.maximal_generalized_eigenspace Î¼ = â‡‘(f.generalized_eigenspace Î¼) (f.maximal_generalized_eigenspace_index Î¼)
strict_convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
_.oangle x y = hb.oangle (â‡‘(f.symm) x) (â‡‘(f.symm) y)
âˆƒ (j : J) (g : locally_constant â†¥(F.obj j) Î±), f = locally_constant.comap â‡‘(C.Ï€.app j) g
matrix.dot_product u (â‡‘(â‡‘cross_product v) w) = matrix.det ![u, v, w]
filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_bot filter.at_bot
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
polynomial.X ^ n - 1 = (polynomial.nth_roots_finset n R).prod (Î» (Î¶ : R), polynomial.X - â‡‘polynomial.C Î¶)
lipschitz_with âˆ¥xâˆ¥â‚Š (Î» (f : E â†’SL[Ïƒâ‚â‚‚] F), â‡‘f x)
module.rank K â†¥s â‰¤ 1 â†” âˆƒ (vâ‚€ : V), s â‰¤ submodule.span K {vâ‚€}
â‡‘clifford_algebra.reverse (list.map â‡‘(clifford_algebra.Î¹ Q) l).prod = (list.map â‡‘(clifford_algebra.Î¹ Q) l).reverse.prod
â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2 -áµ¥ âŸ¨p1, hp1âŸ©) âˆˆ s.direction
a = 0
âˆƒ (K : nnreal) (t : set E') (H : t âˆˆ nhds x), lipschitz_on_with K f t
has_groupoid Î± G
s âˆˆ nhds_within a (set.Iic a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Ioc l a âŠ† s
filter.tendsto complex.exp (filter.comap complex.re filter.at_bot) (nhds 0)
has_deriv_at (Î» (x : â„), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-xâ»Â¹) / x ^ (2 * n)) (polynomial.eval x (exp_neg_inv_glue.P_aux (n + 1)) * real.exp (-xâ»Â¹) / x ^ (2 * (n + 1))) x
closure E âŠ† metric.thickening Î´ E
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
L.tail.sum = L.sum - L.head
P f
finset.univ.prod f = finset.univ.prod g
cont_mdiff_at I I' â†‘n f x â†” âˆƒ (u : set M) (H_1 : u âˆˆ nhds x), cont_mdiff_on I I' â†‘n f u
set.image3 g s t u = set.image3 g' s t u
free_group.red ((x, b) :: L) list.nil â†” free_group.red L [(x, !b)]
continuous_at â‡‘(e.symm) x
monotone (Î» (x : Î²), f x + g x)
2 â€¢ hb.oangle x (r â€¢ y) = 2 â€¢ hb.oangle x y
continuous (Î» (x : Î± Ã— Î²), f x.snd)
uniform_continuous_on f s
category_theory.faithful Compactum_to_CompHaus
open_segment â„ x y âŠ† metric.ball z r
category_theory.mono f â†” function.injective â‡‘(simplex_category.hom.to_order_hom f)
measure_theory.integrable (X * Y) Î¼
â‡‘s (i âˆ† j) = 0 âˆ§ â‡‘s (iá¶œ âˆ† já¶œ) = 0
polynomial.erase n p âˆˆ polynomial.lifts f
a âˆ§ b âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)
0 = 1 â†” âˆ€ (x : Î±), â‡‘f x = 0
cont_diff_on ğ•œ âŠ¤ fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ âŠ¤ (deriv_within fâ‚‚ sâ‚‚) sâ‚‚
(s.erase a).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
torus_integrable (f - g) c R
P x
algebra.is_algebraic S A
cardinal.mk R = cardinal.mk L
âˆƒ (n : set (Î± Ã— Î±)) (H : n âˆˆ uniformity Î±), âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (t : set Î±) (H : t âˆˆ c), âˆ€ (y : Î±), (x, y) âˆˆ n â†’ y âˆˆ t)
b â‰¤ aâ»Â¹ * c â†’ a * b â‰¤ c
âˆƒ (p : polynomial R), p âˆˆ P âˆ§ polynomial.map (ideal.quotient.mk (ideal.comap polynomial.C P)) p â‰  0
x âˆˆ powers x
âˆƒ (w : fin (finite_dimensional.finrank â„ M) â†’ â„), (âˆ€ (i : fin (finite_dimensional.finrank â„ M)), w i = -1 âˆ¨ w i = 1) âˆ§ Q.equivalent (quadratic_form.weighted_sum_squares â„ w)
A.det = 1
finite_dimensional.finrank ğ•œ (X âŸ¶ X) = 1
category_theory.presheaf.is_sheaf K ((category_theory.Ran G.op).obj â„±.val)
(Î» (N : â„•), â†‘(â‡‘roth_number_nat N)) =O[filter.at_top] Î» (N : â„•), â†‘N
âˆƒ (g : matrix.special_linear_group (fin 2) â„¤), g â€¢ z âˆˆ modular_group.fd
has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c s b
finset.univ.sum (Î» (g : G), â‡‘f g) = 0
measure_theory.strongly_measurable f
a * b < 1
factorization (x ^ n) = n â€¢ factorization x
-a â‰¤ b â†” -b â‰¤ a
lâ‚.prod = lâ‚‚.prod
module.rank R â†¥(submodule.map â†‘f p) = module.rank R â†¥p
box_integral.has_integral I l f vol (â‡‘g I)
P x
âˆƒ (t : finset G), K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g * h) â»Â¹' V
(omega_limit f Ï• s).nonempty
lipschitz_with (list.map K l).prod (list.map f l).prod
S.is_pwo
is_add_unit (a + â†‘u) â†” is_add_unit a
has_Sup.Sup s < k
f = g
s.sum (Î» (i : Î±), f i) = t.sum (Î» (i : Î±), â†‘s.indicator f i)
â‡‘((s.erase i).weighted_vsub_of_point p (p i)) w = â‡‘(s.weighted_vsub_of_point p (p i)) w
inner_product_geometry.angle x y = inner_product_geometry.angle y x
r.map f = r.map_of_surjective f h hf
â‡‘(algebra.norm K) (Î¶ - 1) = â†‘p
a < 2 ^ a
â‡‘(measure_theory.measure.mk_metric m) s â‰¤ l.liminf (Î» (n : Î²), âˆ‘' (i : Î¹ n), m (emetric.diam (t n i)))
â†‘g 1 0 = 0
module.End.has_eigenvector â†‘T (â†‘â¨† (x : {x // x â‰  0}), (Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) â†‘x) xâ‚€
is_of_fin_add_order (x i)
affine_independent k (â‡‘f âˆ˜ p)
matrix.dot_product w (â‡‘(â‡‘cross_product v) w) = 0
add_con.lift_on â†‘x f h = f x
bdd_above (f '' K)
strict_convex_on â„ set.univ real.exp
X âˆˆ continuous_map.compact_convergence_uniformity â†” âˆƒ (K : set Î±) (V : set (Î² Ã— Î²)) (hK : is_compact K) (hV : V âˆˆ uniformity Î²), {fg : C(Î±, Î²) Ã— C(Î±, Î²) | âˆ€ (x : Î±), x âˆˆ K â†’ (â‡‘(fg.fst) x, â‡‘(fg.snd) x) âˆˆ V} âŠ† X
Kâ‚á—®á—® â‰¤ Kâ‚‚á—®á—®
filter.tendsto u filter.at_top filter.at_top
fintype.card (sylow p G) â‰¡ 1 [MOD p]
â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w * y) (x * z)
(sâ‚ âŠ“ sâ‚‚).direction = sâ‚.direction âŠ“ sâ‚‚.direction
a < b + c â†’ a - b < c
multiset.count (f x) (multiset.map f s) = multiset.count x s
T.inv_rotate âˆˆ dist_triang C
cont_mdiff I I'' n (g âˆ˜ f)
â‡‘linear_equiv.det complex.conj_lie.to_linear_equiv = -1
category_theory.limits.has_pullback g f
â‡‘(o.rotation Î¸) x = x â†” Î¸ = 0
padic_val_int p â†‘n = padic_val_nat p n
(module.rank R M).lift = (module.rank R M').lift
âˆƒ (s : C) (Î± : kâ‚ âŸ¶ s) (Î² : kâ‚‚ âŸ¶ s), fâ‚ â‰« Î± = gâ‚ â‰« Î² âˆ§ fâ‚‚ â‰« Î± = gâ‚‚ â‰« Î²
aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a
ğŸ­ â†¥C = ğŸ™ C
Ï†.order + Ïˆ.order â‰¤ (Ï† * Ïˆ).order
0 < v.int_valuation_def â†‘x
S = âŠ¥ âˆ¨ âˆƒ (x : M) (H : x âˆˆ S), x â‰  1
âˆƒ (x : Î±) (H : x âˆˆ s), f x â‰  1
hs.proj (â‡‘(hs.out) x) = x
is_group_hom has_inv.inv
totally_bounded (closure s)
filter.tendsto (Î» (x : â„), x ^ ((-1) / x)) filter.at_top (nhds 1)
âˆ« (x : Î±) in s, â‡‘(measure_theory.condexp_L1 hm Î¼ f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
âˆƒ (g : bounded_continuous_function Y â„), (âˆ€ (y : Y), âˆƒ (xâ‚ xâ‚‚ : X), â‡‘g y âˆˆ set.Icc (â‡‘f xâ‚) (â‡‘f xâ‚‚)) âˆ§ â‡‘g âˆ˜ e = â‡‘f
(Î» (x : â„), real.exp (-x) * x ^ s) =o[filter.at_top] Î» (x : â„), real.exp (-(1 / 2) * x)
Gá¶œ.is_SRG_with n (n - k - 1) (n - (2 * k - Î¼) - 2) (n - (2 * k - â„“))
is_closed {x : Î± | cluster_pt x f}
Â¬b < a
âˆƒ (l : â„), filter.tendsto (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i)) filter.at_top (nhds l)
(has_insert.insert a s).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
is_glb t a
measurable (Î» (x : Î´), filter.at_top.liminf (Î» (i : â„•), f i x))
âˆƒ (f_lim : Î± â†’ Î²) (hf_lim_meas : measure_theory.strongly_measurable f_lim), âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (f_lim x))
function.is_fixed_pt (f âˆ˜ g) x
m â‰  0 â†’ b ^ (b.digits m).length â‰¤ b * m
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
deriv f a = 0
a * b = b * a
â‡‘Î¼ (t âˆ© s) = â‡‘Î¼ (u âˆ© s)
metric.thickening Î´ Eâ‚ âŠ† metric.thickening Î´ Eâ‚‚
lie_module.is_nilpotent R L M â†” âˆ€ (x : L), is_nilpotent (â‡‘(lie_module.to_endomorphism R L M) x)
âˆƒ (v : Î¹ â†’ set X), (âˆ€ (a : Î¹), is_open (v a)) âˆ§ (â‹ƒ (i : Î¹), v i) = set.univ âˆ§ locally_finite v âˆ§ âˆ€ (a : Î¹), v a âŠ† u a
filter.tendsto (Î» (i : Î¹), Î¼.test_against_nn (fs i)) L (nhds (Î¼.test_against_nn f))
linear_independent â„š (Î» (Î½ : fin (n + 1)), bernstein_polynomial â„š n â†‘Î½)
is_add_submonoid (set.Inter s)
Î¼ = Î½
has_Inf.Inf s âŠ” a â‰¤ â¨… (b : Î±) (H : b âˆˆ s), b âŠ” a
f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
has_dist.dist pâ‚ (â‡‘(euclidean_geometry.reflection s) pâ‚‚) = has_dist.dist (â‡‘(euclidean_geometry.reflection s) pâ‚) pâ‚‚
complete_lattice.independent (s âˆ˜ f)
âˆƒ (y : E) (H : y âˆˆ s), f y â‰¤ f x
set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}
filter.tendsto (Î» (x : Î±), f x * r) l filter.at_bot
f = g
z.im < (modular_group.S â€¢ z).im
convex_independent ğ•œ (p âˆ˜ â‡‘f)
(finset.Ico m n).sum (Î» (i : â„•), f i â€¢ g i) = f (n - 1) â€¢ (finset.range n).sum (Î» (i : â„•), g i) - f m â€¢ (finset.range m).sum (Î» (i : â„•), g i) - (finset.Ico m (n - 1)).sum (Î» (i : â„•), (f (i + 1) - f i) â€¢ (finset.range (i + 1)).sum (Î» (i : â„•), g i))
âˆƒ (f : E â†’L[â„] â„) (u v : â„), (âˆ€ (a : E), a âˆˆ s â†’ â‡‘f a < u) âˆ§ u < v âˆ§ âˆ€ (b : E), b âˆˆ t â†’ v < â‡‘f b
aâ»Â¹ < 1 â†” 1 < a
dense (closure s) â†” dense s
c (f ^ n) = (c f^[n])
e = e'
âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ = 1
open_embedding â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚)
convex_on â„ set.univ f
continuous (Î» (x : Î±), h x (f x / g x))
a < 0 â†’ 0 < -a
(âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥) â†’ asymptotics.is_O_with c l f g
zmod.legendre_sym p a = 1 â†” is_square â†‘a
is_compact (weak_dual.polar ğ•œ s)
continuous f â†” seq_continuous f
a â‰¤ c
âˆ¥f zâˆ¥ â‰¤ C
(-o).rotation Î¸ = o.rotation (-Î¸)
omega_complete_partial_order.continuous' coe
filter.tendsto â†¿F (p.prod âŠ¤) (nhds c) â†” tendsto_uniformly F (Î» (_x : Î±), c) p
(âˆ€ (a : Î±), a âˆˆ s â†’ acc (relation.cut_expand r) {a}) â†’ acc (relation.cut_expand r) s
ordinal.enum_ord S o = has_Inf.Inf (S âˆ© {b : ordinal | âˆ€ (c : ordinal), c < o â†’ ordinal.enum_ord S c < b})
finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.circumcenter_weights_with_circumcenter n i) = 1
frontier (metric.cthickening Î´ E) âŠ† {x : Î± | emetric.inf_edist x E = ennreal.of_real Î´}
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), f' c = 0
f' = 0
âˆƒ (V' : set (Î² Ã— Î²)) (H : V' âˆˆ uniformity Î²), V' âŠ† V âˆ§ âˆ€ (g : C(Î±, Î²)), g âˆˆ continuous_map.compact_conv_nhd K V' f â†’ continuous_map.compact_conv_nhd K V' g âŠ† continuous_map.compact_conv_nhd K V f
Jâ‚.covers S f â†” â‡‘S f
(polynomial.cyclotomic n R).is_root Î¼ â†” is_primitive_root Î¼ n
function.right_inverse â‡‘(mv_polynomial.map f) â‡‘(mv_polynomial.map g)
real.sin (real.pi / 3) = real.sqrt 3 / 2
F.Lim = X.str F
padic_norm p (-q) = padic_norm p q
strict_convex ğ•œ ((Î» (x : E), z + x) â»Â¹' s)
âˆƒ (t : set Î±), s âŠ† t âˆ§ measurable_set t âˆ§ âˆ€ (i : Î¹), â‡‘(Î¼ i) t = â‡‘((Î¼ i).trim) s
m â‰¤ n â†’ P n
algebra.finite_presentation R A â†” âˆƒ (Î¹ : Type u_2) (_x : fintype Î¹) (f : mv_polynomial Î¹ R â†’â‚[R] A), function.surjective â‡‘f âˆ§ f.to_ring_hom.ker.fg
x ^ n.totient = 1
x âˆˆ supr S â†” âˆƒ (f : Î â‚€ (i : Î¹), â†¥(S i)), f.sum (Î» (i : Î¹) (xi : â†¥(S i)), â†‘xi) = x
(polynomial.cyclotomic' n R).nat_degree = n.totient
is_least (s âˆª t) (linear_order.min a b)
set.image2 f s (set.image2 g t u) âŠ† set.image2 g' (set.image2 fâ‚ s t) (set.image2 fâ‚‚ s u)
â‡‘Î¼ (metric.closed_ball x r) = ennreal.of_real (r ^ finite_dimensional.finrank â„ E) * â‡‘Î¼ (metric.closed_ball 0 1)
Â¬is_smul_regular M 0 â†” nontrivial M
2 * a * b â‰¤ a ^ 2 + b ^ 2
(s.sigma t).sum (Î» (x : Î£ (i : Î±), Ïƒ i), f x) = s.sum (Î» (a : Î±), (t a).sum (Î» (s : Ïƒ a), f âŸ¨a, sâŸ©))
totally_disconnected_space Î± â†” âˆ€ (x : Î±), connected_component x = {x}
dense (set.range f)á¶œ
same_ray â„ x y â†’ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
p âˆ‰ âŠ¥
(A.mul B + 1).det = (B.mul A + 1).det
z = w + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y â†” z + â‡‘f â†‘y = w
K âŠ“ Ká—® = âŠ¥
f =áµ[Î¼] s.rn_deriv Î¼
f 0 = 0
dense t
â‡‘roth_number_nat (M + N) â‰¤ â‡‘roth_number_nat M + â‡‘roth_number_nat N
cauchy_seq (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), f i â€¢ z i))
emetric.diam s â‰¤ emetric.diam t
convex_on â„ (set.Ioi 0) (Î» (x : â„), x ^ m)
a + b = c + d â†” a = c âˆ§ b = d
metric.diam (s âˆª t) â‰¤ metric.diam s + metric.diam t
finset.univ.prod (Î» (i : fin n), f â†‘i) = (finset.range n).prod (Î» (i : â„•), f i)
algebra.is_algebraic K L
finset.univ.sum (Î» (s : finset Î±), a ^ s.card * b ^ (fintype.card Î± - s.card)) = (a + b) ^ fintype.card Î±
(n ^ k).factorization = k â€¢ n.factorization
free_group.mk Lâ‚ = free_group.mk Lâ‚‚
l.head * l.tail.prod = l.prod
f a â‰  x
â‡‘h 1 = 1
polynomial.cyclotomic' 0 R = 1
l.cyclic_permutations.nodup
(polynomial.map (int.cast_ring_hom (zmod p)) (minpoly â„¤ Î¼)).separable
has_strict_deriv_at (exp ğ•‚) 1 0
interval_integrable F' Î¼ a b âˆ§ has_fderiv_at (Î» (x : H), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' t âˆ‚Î¼) xâ‚€
s.sum (Î» (a : Î±), f a) < âŠ¤ â†” âˆ€ (a : Î±), a âˆˆ s â†’ f a < âŠ¤
affine_independent k (â‡‘f âˆ˜ p) â†” affine_independent k p
liouville_with p x
âˆƒ (L L' : list (matrix.transvection_struct n ğ•œ)) (D : n â†’ ğ•œ), M = ((list.map matrix.transvection_struct.to_matrix L).prod.mul (matrix.diagonal D)).mul (list.map matrix.transvection_struct.to_matrix L').prod
â†‘(finite_dimensional.finrank K V) = module.rank K V
0 < a + b
setoid.comap f r = setoid.ker (quotient.mk âˆ˜ f)
summable (Î» (n : â„•), x ^ n / â†‘(n.factorial))
uniform_continuous (Î» (x : Î±), metric.inf_nndist x s)
submodule.torsion R â†¥(submodule.torsion R M) = âŠ¤
(âˆ€ (s : finset Î¹), s.card â‰¤ (s.bUnion t).card) â†” âˆƒ (f : Î¹ â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
(finset.image (Î» (i : fin n), â†‘i) A).to_colex â‰¤ (finset.image (Î» (i : fin n), â†‘i) B).to_colex â†” A.to_colex â‰¤ B.to_colex
is_square a â†” a ^ (fintype.card F / 2) = 1
is_of_fin_order (x * y)
has_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c b
mul_opposite.op (x ^ z) = mul_opposite.op x ^ z
category_theory.epi f â†” function.surjective f
set.eq_on (iterated_fderiv_within ğ•œ n f s) (iterated_fderiv ğ•œ n f) s
âˆƒ (eq_1 : opposite.op U = opposite.op ((topological_space.opens.map (category_theory.limits.colimit.Î¹ D.to_glue_data.diagram.multispan (opposite.unop (opposite.op (category_theory.limits.walking_multispan.right i)))).base).obj (_.functor.obj U))), D.Î¹_inv_app U â‰« D.diagram_over_open_Ï€ U i = (D.to_glue_data.U i).presheaf.map (category_theory.eq_to_hom eq_1)
is_min_on f s a â†’ is_max_on (â‡‘order_dual.to_dual âˆ˜ f) s a
(h.comp g).comp f = h.comp (g.comp f)
complex.abs (deriv f c) â‰¤ Râ‚‚ / Râ‚
polynomial.is_splitting_field K L (polynomial.X ^ â†‘n - 1)
has_fderiv_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p x 1)) x
n.factorization.support = n.factors.to_finset
finite_dimensional.finrank ğ•œ (X âŸ¶ Y) â‰¤ 1
â‡‘zmod.Ï‡â‚„ a = 0 âˆ¨ â‡‘zmod.Ï‡â‚„ a = 1 âˆ¨ â‡‘zmod.Ï‡â‚„ a = -1
r a b â†’ r b a â†’ a = b
(a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2
(polynomial.cyclotomic' n R).monic
submodule.span S â†‘(submodule.span R s) = submodule.span S s
is_compl (submodule.span K {x}) ((submodule.span K {x}).orthogonal_bilin B)
f.inverse = 0
zmod.legendre_sym p a = zmod.legendre_sym p (a % â†‘p)
gâ‚ = gâ‚‚
has_strict_deriv_at g f'â»Â¹ a
finite_dimensional.finrank K K = 1
â‡‘(measure_theory.measure.hausdorff_measure dâ‚‚) s = 0 âˆ¨ â‡‘(measure_theory.measure.hausdorff_measure dâ‚) s = âŠ¤
has_inner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
0 < âˆ« (x : â„) in a..b, f x âˆ‚Î¼ â†” a < b âˆ§ 0 < â‡‘Î¼ (function.support f âˆ© set.Ioc a b)
1 + â†‘n * (a - 1) â‰¤ a ^ n
is_add_monoid_hom f
a âˆˆ s â†’ b âˆ‰ s â†’ a â‰  b
f a â‰  x
category_theory.presieve.is_sheaf Jâ‚ (category_theory.functor.closed_sieves Jâ‚)
â‡‘(witt_vector.map f) (â‡‘(witt_vector.teichmuller p) r) = â‡‘(witt_vector.teichmuller p) (â‡‘f r)
k â‰« s.Ï€.app j = l â‰« s.Ï€.app j
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = pâ‚ -áµ¥ â‡‘(s.affine_combination pâ‚‚) w
n.choose r â‰¤ n.choose (r + 1)
p1 âˆˆ affine_span k (set.range p) â†” âˆƒ (s : finset Î¹) (w : Î¹ â†’ k) (hw : s.sum (Î» (i : Î¹), w i) = 1), p1 = â‡‘(s.affine_combination p) w
cont_diff_at ğ•œ n (â‡‘g âˆ˜ f) x
(finset.Ioo s t).card = 2 ^ (t.card - s.card) - 2
fintype.card Î¹ â‰¤ fintype.card â†¥w
cont_diff ğ•œ n (Î» (x : E Ã— F), f x.fst)
(generalized_continued_fraction.int_fract_pair.seq1 v).fst = generalized_continued_fraction.int_fract_pair.of v
s.pairwise (Î» (x y : Î±), f x = f y) â†” âˆƒ (z : Î¹), âˆ€ (x : Î±), x âˆˆ s â†’ f x = z
(finset.image quotient.mk s.diag).card = s.card
iterated_fderiv_within ğ•œ (n + 1) f s = â‡‘(continuous_multilinear_curry_left_equiv ğ•œ (Î» (i : fin (n + 1)), E) F) âˆ˜ fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n f s) s
a < c - b â†’ a + b < c
S = âŠ¤
category_theory.presieve.is_sheaf_for P â‡‘âŠ¤
lâ‚ <+~ lâ‚‚ â†’ a :: lâ‚ <+~ a :: lâ‚‚
c â‰¤ infi f
category_theory.is_equivalence.of_iso (category_theory.iso.refl F) hF = hF
Î¼ = Î½
P Î±
âˆƒ (t : set Î±), s âŠ† t âˆ§ measurable_set t âˆ§ âˆ€ (i : Î¹), â‡‘(Î¼ i) t = â‡‘(Î¼ i) s
has_star.star 1 = 1
âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
category_theory.is_cofiltered.eq_hom f f' â‰« f = category_theory.is_cofiltered.eq_hom f f' â‰« f'
liouville_with p (x * â†‘r) â†” liouville_with p x
â‡‘(sâ‚.affine_combination p) w = â‡‘(sâ‚‚.affine_combination p) (â†‘sâ‚.indicator w)
function.injective â‡‘(ideal.ker_lift_alg f)
first_order.language.Structure.fg L M â†” âˆƒ (S : set M), S.finite âˆ§ â‡‘(first_order.language.substructure.closure L) S = âŠ¤
u = v â†” set.eq_on u v â†‘(finset.range E.order)
filter.tendsto real.exp filter.at_top filter.at_top
iterated_fderiv_within ğ•œ n fâ‚ s x = iterated_fderiv_within ğ•œ n f s x
upper_semicontinuous_on (Î» (z : Î±), f z + g z) s
acc (relation.cut_expand r) {a}
affine_subspace.mk' p s.direction = s
Ïƒ.to_pequiv.to_matrix i j = 1 (â‡‘Ïƒ i) j
(C.boundaries i).of_le (C.cycles i) h = C.boundaries_to_cycles i
pi.mul_single i x i' = pi.mul_single i' x i
has_inner.inner x y = â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥ â†” â†‘âˆ¥yâˆ¥ â€¢ x = â†‘âˆ¥xâˆ¥ â€¢ y
list.chain' R (lâ‚ ++ lâ‚‚ ++ lâ‚ƒ)
Q.equivalent (quadratic_form.weighted_sum_squares â„‚ 1)
âˆƒ (c : â†¥S), x + â†‘((f.sec (f.mk' x y)).snd) + â†‘c = (f.sec (f.mk' x y)).fst + â†‘y + â†‘c
s.points i = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.point_weights_with_circumcenter i)
finite_dimensional.finrank K V â‰¤ 1
inducing (Î» (x : X) (i : Î¹), f i x)
(has_insert.insert a s).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
isometry â‡‘f â†” âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ = âˆ¥xâˆ¥
âˆ¥f zâˆ¥ â‰¤ C
l.dprod fÎ¹ fA = (list.map fA l).prod
algebra.finite_type R A â†” âˆƒ (Î¹ : Type u_2) (_x : fintype Î¹) (f : mv_polynomial Î¹ R â†’â‚[R] A), function.surjective â‡‘f
is_compact (f â»Â¹' K)
nontrivial Mâ‚€'
is_closed_map (Î» (x : Î±), c â€¢ x)
pâ‚ = pâ‚‚ âˆ¨ pâ‚ = â‡‘(euclidean_geometry.reflection (affine_span â„ (set.range s.points))) pâ‚‚
is_bounded_bilinear_map ğ•œ (Î» (p : (F â†’L[ğ•œ] G) Ã— continuous_multilinear_map ğ•œ E F), p.fst.comp_continuous_multilinear_map p.snd)
euclidean_geometry.cospherical ps â†” âˆƒ (center : P) (H : center âˆˆ s) (radius : â„), âˆ€ (p : P), p âˆˆ ps â†’ has_dist.dist p center = radius
has_fderiv_at (exp ğ•‚) (exp ğ•‚ x â€¢ 1) x
p = q
âˆƒá¶  (n : â„•) in filter.at_top, âˆ€ (k : â„•), k < n â†’ u n < u k
((M.mul N).mul Mâ»Â¹).det = N.det
âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ g.comp_continuous e = f
a * b = c * d â†” a = c âˆ§ b = d
setoid.r = setoid.r âŠ“ setoid.r
cont_diff_on ğ•œ â†‘(n + 1) f s â†” âˆ€ (x : E), x âˆˆ s â†’ (âˆƒ (u : set E) (H : u âˆˆ nhds_within x (has_insert.insert x s)) (f' : E â†’ (E â†’L[ğ•œ] F)), (âˆ€ (x : E), x âˆˆ u â†’ has_fderiv_within_at f (f' x) u x) âˆ§ cont_diff_on ğ•œ â†‘n f' u)
category_theory.is_iso f
mdifferentiable_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s â†’ differentiable_on ğ•œ f s
list.split_on_p p (xs ++ sep :: as) = xs :: list.split_on_p p as
a âˆ£ â†‘u * b â†” a âˆ£ b
has_btw.btw a b c
s.circumcenter = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.circumcenter_weights_with_circumcenter n)
is_noetherian R â†¥(submodule.span R A)
set.Ioi b âŠ† set.Ici a
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), 0)) = 0
has_strict_fderiv_at (exp ğ•‚) 1 0
s.prod (Î» (x : Î±), f x) = t.prod (Î» (x : Î³), g x)
has_Inf.Inf (coe '' t) âˆˆ s
is_unit (â‡‘(X.to_to_Î“_Spec_map_basic_open r) r)
â‡‘(add_con.ker_lift f) â†‘x = â‡‘f x
âˆƒ (L L' : list (matrix.transvection_struct p ğ•œ)) (D : p â†’ ğ•œ), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
category_theory.is_iso f
ennreal.of_real (â‡‘f b - â‡‘f a) â‰¤ âˆ‘' (i : â„•), ennreal.of_real (â‡‘f (d i) - â‡‘f (c i))
âˆƒ (b : F), â‡‘(algebra.trace (zmod (ring_char F)) F) (a * b) â‰  0
Aâ‚€ * Bâ‚€ + Aâ‚€ * Bâ‚ + Aâ‚ * Bâ‚€ - Aâ‚ * Bâ‚ â‰¤ 2
is_irreducible s â†” âˆ€ (U : finset (set Î±)), (âˆ€ (u : set Î±), u âˆˆ U â†’ is_open u) â†’ (âˆ€ (u : set Î±), u âˆˆ U â†’ (s âˆ© u).nonempty) â†’ (s âˆ© â‹‚â‚€ â†‘U).nonempty
finset.image (Î» (i : â„•), x ^ i) (finset.range (order_of x)) = â†‘(subgroup.zpowers x).to_finset
p x
x = y
comm_monoid.torsion G = (torsion G).to_submonoid
complete_lattice.is_sup_closed_compact Î± â†’ complete_lattice.is_Sup_finite_compact Î±
s.powerset.prod (Î» (t : finset Î±), f t) = (finset.range (s.card + 1)).prod (Î» (j : â„•), (finset.powerset_len j s).prod (Î» (t : finset Î±), f t))
free_group.reduce Lâ‚ = Lâ‚‚
measure_theory.is_add_fundamental_domain G s Î¼
âˆƒ (g : C(Y, â„)), continuous_map.restrict s g = f
g y (â‡‘f y) + (finsupp.erase y f).sum g = f.sum g
(cf.prec cg).eval (nat.mkpair a 0) = cf.eval a
â‡‘f (-x) = -â‡‘f x
measure_theory.has_pdf X Â«â„™Â» measure_theory.measure_space.volume â†” (measure_theory.measure.map X Â«â„™Â»).absolutely_continuous measure_theory.measure_space.volume
category_theory.limits.has_colimit K
âˆ« (x : â„) in a..b, real.sin x * real.cos x = (real.cos a ^ 2 - real.cos b ^ 2) / 2
has_strict_deriv_at â‡‘(f.symm) f'â»Â¹ a
continuous â‡‘(e.symm)
âˆ¥f 1 - f 0âˆ¥ â‰¤ C
fintype.card (quaternion_group n) = 4 * n
s âŠ† â†‘(affine_span k s)
has_strict_deriv_at f f' x
o.oangle x y + o.oangle y z = o.oangle x z
â‡‘{to_fun := f, linear := linear, map_vadd' := add} = f
emetric.inf_edist x s â‰¤ has_edist.edist x y
âˆ¥f.to_continuous_linear_map.comp gâˆ¥ = âˆ¥gâˆ¥
z - â†‘(â‡‘padic_int.to_zmod z) âˆˆ local_ring.maximal_ideal â„¤_[p]
âˆƒ (x : M), Â¬B.is_ortho x x
â‡‘(direct_sum.is_internal.subordinate_orthonormal_basis hn hV) a âˆˆ V (direct_sum.is_internal.subordinate_orthonormal_basis_index hn hV a)
is_complemented Î±
closed_embedding f
category_theory.limits.has_terminal (category_theory.over B)
b âˆˆ f.fix a
has_scalar.smul 1 = id
nontrivial (category_theory.subobject X)
filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_top
is_locally_homeomorph f
â‡‘(measure_theory.measure.mk_metric m) s = â¨† (r : ennreal) (hr : 0 < r), â¨… (t : â„• â†’ set X) (h : s âŠ† set.Union t) (h' : âˆ€ (n : â„•), emetric.diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (h : (t n).nonempty), m (emetric.diam (t n))
comm_monoid.torsion G = âŠ¤
âˆƒ (f : X â†’ bounded_continuous_function â„• â„), embedding f
category_theory.epi k
hb.oangle (r â€¢ x) y = hb.oangle x y
âˆƒ (ub : â„¤), P ub âˆ§ âˆ€ (z : â„¤), P z â†’ z â‰¤ ub
polynomial.cyclotomic 0 R = 1
eqv_gen.setoid (eqv_gen.setoid r).rel = eqv_gen.setoid r
x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s
has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 - 2 * has_dist.dist p1 p2 * has_dist.dist p3 p2 * real.cos (euclidean_geometry.angle p1 p2 p3)
â†‘u âŠ† s â€¢ t â†’ (âˆƒ (s' : finset Î±) (t' : finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' â€¢ t')
is_irreducible s â†” âˆ€ (Z : finset (set Î±)), (âˆ€ (z : set Î±), z âˆˆ Z â†’ is_closed z) â†’ s âŠ† â‹ƒâ‚€â†‘Z â†’ (âˆƒ (z : set Î±) (H : z âˆˆ Z), s âŠ† z)
a / b = a * bâ»Â¹
s â‰¤ t â†’ s âŠ† t
f.Liminf = a
is_compact (set.range f)
polynomial.chebyshev.T R (m * n) = (polynomial.chebyshev.T R m).comp (polynomial.chebyshev.T R n)
category_theory.limits.has_zero_object C
filter.tendsto (Î» (x : Î±), x ^ -â†‘n) filter.at_top (nhds 0)
(matrix.from_blocks A B C D).is_symm â†” A.is_symm âˆ§ B.transpose = C âˆ§ C.transpose = B âˆ§ D.is_symm
f = g
a ^ (fintype.card F / 2) = 1 âˆ¨ a ^ (fintype.card F / 2) = -1
linear_independent ğ•œ v
Â¬is_left_regular 0
F.is_sheaf â†” Top.presheaf.is_sheaf (F â‹™ G)
f =o[l] g â†’ âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
is_principal_ideal_ring S
category_theory.is_iso f
g (â¨ (x : Î±), f x âˆ‚Î¼) â‰¤ â¨ (x : Î±), g (f x) âˆ‚Î¼
â‡‘(equiv.symm (equiv.mul_right a)) = Î» (x : G), x * aâ»Â¹
normal_space Î±
metric.Hausdorff_dist s t â‰¤ r
âˆƒ (r : â„), âˆ€ (t : affine.triangle â„ P), set.range t.points âŠ† s â†’ affine.simplex.circumradius t = r
s âˆˆ nhds_within a (set.Iic a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Ioc l a âŠ† s
subsingleton (lie_ideal R â†¥âŠ¥)
â‡‘(first_order.language.substructure.closure L) s â‰¤ S â†” s âŠ† â†‘S
(âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.prod âˆˆ K
Â¬add_monoid.is_torsion G â†” âˆƒ (g : G), Â¬is_of_fin_add_order g
monotone f â†” âˆ€ (i : fin n), f (â‡‘fin.cast_succ i) â‰¤ f i.succ
add_monoid_algebra.of' R M m âˆˆ submodule.span R (add_monoid_algebra.of' R M '' S) â†” m âˆˆ S
â‡‘(s.weighted_vsub p) w = s.sum (Î» (i : Î¹), w i â€¢ p i)
q âˆˆ affine_span k (set.range p) â†” âˆƒ (s : finset Î¹) (w : Î¹ â†’ k), q = â‡‘(s.weighted_vsub_of_point p (p j)) w +áµ¥ p j
(â‹ƒ (x : Î±) (H : x âˆˆ Z), connected_component x) = Z
a * x * x + b * x + c = 0 â†” x = -b / (2 * a)
âˆƒ (s : M) (H : s âˆˆ S), âˆ¥m + sâˆ¥ < âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ + Îµ
âˆ¥deriv f câˆ¥ â‰¤ C / R
has_dist.dist s.circumcenter (s.points i) = s.circumradius
g +áµ¥ p1 -áµ¥ p2 = g + (p1 -áµ¥ p2)
p.comp (p.right_inv i) = formal_multilinear_series.id ğ•œ F
â‡‘linear_equiv.det complex.conj_ae.to_linear_equiv = -1
padic_val_nat p (q ^ n) = n * padic_val_nat p q
â‡‘(algebra.norm K) (Î¶ - 1) = 2
f.has_generalized_eigenvalue Î¼ m
A.mul ((â…Ÿ A).mul B) = B
tangent_map I I â‡‘((charted_space.chart_at H p.fst).symm) q = â‡‘((charted_space.chart_at (model_prod H E) p).symm) (â‡‘(equiv.sigma_equiv_prod H E) q)
aâº = a
âˆ€á¶  (n : â„•) in filter.at_top, v = (generalized_continued_fraction.of v).convergents n
â‡‘(equiv.symm (equiv.mul_left a)) = has_mul.mul aâ»Â¹
m.prod âˆˆ S
(nhds 0).has_basis (Î» (_x : Î“â‚€Ë£), true) (Î» (Î³â‚€ : Î“â‚€Ë£), {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
has_strict_deriv_at complex.sinh (complex.cosh x) x
f.comp g = linear_map.id â†” g.comp f = linear_map.id
â‡‘(algebra_map (polynomial R) (ratfunc R)) (polynomial.cyclotomic n R) = n.divisors_antidiagonal.prod (Î» (i : â„• Ã— â„•), â‡‘(algebra_map (polynomial R) (ratfunc R)) (polynomial.X ^ i.snd - 1) ^ â‡‘nat.arithmetic_function.moebius i.fst)
category_theory.is_iso f
x âŠ” y âˆˆ s
s.to_colex < {r}.to_colex â†” âˆ€ (x : Î±), x âˆˆ s â†’ x < r
continuous (Î» (f : â†¥(measure_theory.Lp E 1 (Î¼.prod Î½))), âˆ« (x : Î±), âˆ« (y : Î²), â‡‘f (x, y) âˆ‚Î½ âˆ‚Î¼)
e.source âˆ© â‡‘e â»Â¹' t = e.source âˆ© s â†’ e.is_image s t
metric.Hausdorff_dist s t = metric.Hausdorff_dist t s
category_theory.presieve.is_sheaf (category_theory.sheaf.canonical_topology C) (category_theory.yoneda.obj X)
â‡‘f (g + -h) = â‡‘f g + -â‡‘f h
measure_theory.mem_â„’p.to_Lp â‡‘f _ âˆˆ measure_theory.Lp_meas_subgroup F m p Î¼
is_free_groupoid.spanning_tree.loop_of_hom T (is_free_groupoid.of e) = ğŸ™ (root' T)
âˆƒ (g : Î± â†’ Î¹ â†’ â„), lipschitz_with K g âˆ§ set.eq_on f g s
âˆ‘' (i : â„¤), âˆ¥â‡‘(â‡‘(fourier_series.repr) f) iâˆ¥ ^ 2 = âˆ« (t : â†¥circle), âˆ¥â‡‘f tâˆ¥ ^ 2 âˆ‚haar_circle
con.mul_ker coe _ = c
filter.tendsto F p (nhds f)
(Î» (t : R), ring.inverse (â†‘x + t)) =O[nhds 0] Î» (t : R), 1
same_ray R (r â€¢ v) v
ğŸ™ (X, Y) = (ğŸ™ X, ğŸ™ Y)
has_inner.inner (l.sum (Î» (i : Î¹) (a : ğ•œ), a â€¢ v i)) x = l.sum (Î» (i : Î¹) (a : ğ•œ), â‡‘(star_ring_end ğ•œ) a â€¢ has_inner.inner (v i) x)
ring_char (zmod n) = n
measure_theory.measure.map â‡‘(â‡‘matrix.to_lin' M) measure_theory.measure_space.volume = ennreal.of_real |(M.det)â»Â¹| â€¢ measure_theory.measure_space.volume
measure_theory.smul_invariant_measure G (G â§¸ Î“) (measure_theory.measure.map quotient_group.mk (Î¼.restrict ğ“•))
s âˆˆ {set.Icc (has_Inf.Inf s) (has_Sup.Sup s), set.Ico (has_Inf.Inf s) (has_Sup.Sup s), set.Ioc (has_Inf.Inf s) (has_Sup.Sup s), set.Ioo (has_Inf.Inf s) (has_Sup.Sup s), set.Ici (has_Inf.Inf s), set.Ioi (has_Inf.Inf s), set.Iic (has_Sup.Sup s), set.Iio (has_Sup.Sup s), set.univ, âˆ…}
(s.sum (Î» (a : Î±), f a)).to_nnreal = s.sum (Î» (a : Î±), (f a).to_nnreal)
(âˆ€á¶  (x : Î±) in residual Î±, p x) â†” âˆƒ (t : set Î±), is_GÎ´ t âˆ§ dense t âˆ§ âˆ€ (x : Î±), x âˆˆ t â†’ p x
X.Î´ j.succ â‰« X.Î´ i = X.Î´ (â‡‘fin.cast_succ i) â‰« X.Î´ j
finset.centroid k s p = finset.centroid k sâ‚‚ pâ‚‚
cont_mdiff_on I I'' n (g âˆ˜ f) (s âˆ© f â»Â¹' t)
â†‘(N âŠ” H) = â†‘N * â†‘H
pi.mul_single i x i' = ite (i' = i) x 1
âˆƒ (c : Î±), filter.tendsto u f (nhds c)
âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ f m = âŠ¥
strict_anti_on f s â†’ strict_mono_on (â‡‘order_dual.to_dual âˆ˜ f) s
t.sum (Î» (i : Î¹), f i) âˆˆ s
measure_theory.strongly_measurable (Î» (x : Î±), g (f x)) â†” measure_theory.strongly_measurable f
â‡‘(algebra.norm K) (â‡‘(algebra_map K L) x) = x ^ finite_dimensional.finrank K L
cast h = â‡‘(fin.cast _)
â‡‘is_R_or_C.im (has_inner.inner x y) = (âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ * âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ - âˆ¥x + is_R_or_C.I â€¢ yâˆ¥ * âˆ¥x + is_R_or_C.I â€¢ yâˆ¥) / 4
(n + 1) / (b + 2) < n + 1
is_connected (f â»Â¹' connected_component t)
finset.centroid k s p âˆˆ affine_span k (set.range p)
submodule.span S â†‘p = submodule.restrict_scalars S p
f.has_eigenvalue Î¼
â‡‘(Î¼.prod measure_theory.measure_space.volume) (region_between f g s) = ennreal.of_real (âˆ« (y : Î±) in s, (g - f) y âˆ‚Î¼)
(âˆ€ (x : L), x âˆˆ l â†’ x âˆˆ S) â†’ l.sum âˆˆ S
inner_product_geometry.angle (-x) (-y) = inner_product_geometry.angle x y
(category_theory.presieve.is_separated_for P R âˆ§ âˆ€ (x : category_theory.presieve.family_of_elements P R), x.compatible â†’ (âˆƒ (t : P.obj (opposite.op X)), x.is_amalgamation t)) â†” category_theory.presieve.is_sheaf_for P R
finset.filter (eq b) s = ite (b âˆˆ s) {b} âˆ…
uniform_add_group G
âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x
f = g
p I
â†‘s âˆ© â†‘(affine_subspace.mk' p (s.direction)á—®) = {â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p)}
subsingleton Î±
âˆƒ (n : â„•), n â‰  0 âˆ§ (f ^ n).ker âŠ” (f ^ n).range = âŠ¤
is_right_regular (b * a) â†” is_right_regular b
âˆƒ (n : set (Î± Ã— Î±)) (H : n âˆˆ uniformity Î±), âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (i : Î¹), {y : Î± | (x, y) âˆˆ n} âŠ† c i)
hb.oangle x y = Î¸ â†” (x â‰  0 âˆ§ y â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(hb.rotation Î¸) x) âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
has_sum (Î» (n : Î¹), âˆ« (t : â„) in a..b, F n t âˆ‚Î¼) (âˆ« (t : â„) in a..b, f t âˆ‚Î¼)
fintype.card (zmod n)Ë£ = n.totient
finite_dimensional K â†¥âŠ¥
âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
set.inj_on (Î» (x : Î±), (x âŠ” u)  v) {x : Î± | disjoint u x âˆ§ v â‰¤ x}
âˆƒ (n : â„•) (H : n â‰¥ N), âˆ€ (k : â„•), k < n â†’ u k < u n
is_adic J â†” (âˆ€ (n : â„•), is_open â†‘(J ^ n)) âˆ§ âˆ€ (s : set R), s âˆˆ nhds 0 â†’ (âˆƒ (n : â„•), â†‘(J ^ n) âŠ† s)
â‡‘(measure_theory.measure.hausdorff_measure dâ‚‚) s â‰¤ â‡‘(measure_theory.measure.hausdorff_measure dâ‚) s
a * a - b * b = (a + b) * (a - b)
âˆ¥f'âˆ¥ â‰¤ C
vector_span k (set.range p) = submodule.span k (set.range (Î» (i : {x // x â‰  iâ‚€}), p iâ‚€ -áµ¥ p â†‘i))
o.oangle (-x) x = â†‘real.pi
âˆƒ (H : subgroup G), N.is_complement' H
bdd_below t â†’ bdd_below s
fourier_subalgebra.to_submodule = submodule.span â„‚ (set.range fourier)
box_integral.has_integral I box_integral.integration_params.McShane f vol (â‡‘g I)
s.monge_plane iâ‚ iâ‚‚ = s.monge_plane iâ‚‚ iâ‚
dimH (f '' s) â‰¤ dimH s / â†‘r
Â¬is_min a â†’ order.pred a < a
subgroup.map f.to_monoid_hom H.normalizer = (subgroup.map f.to_monoid_hom H).normalizer
(âˆ€ (s : set Î±), s âˆˆ S â†’ Î¼.restrict s = Î½.restrict s) â†’ Î¼ = Î½
a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)
a â©¿ b
P M
measurable g
emetric.inf_edist x s = 0
â‡‘(algebra.norm K) (Î¶ ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
finite_dimensional.finrank K V â‰¤ 1 â†” âˆƒ (v : V), âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w
filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.univ  {a})) l
is_smul_regular M 0 â†” subsingleton M
I.is_maximal â†” is_field (R â§¸ I)
cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I M â»Â¹' s)
affine_independent k p
c âˆˆ set.range f
cauchy_seq f
(pgame.mk xl xr xL xR).lf (pgame.mk yl yr yL yR) â†” (âˆƒ (i : yl), pgame.mk xl xr xL xR â‰¤ yL i) âˆ¨ âˆƒ (j : xr), xR j â‰¤ pgame.mk yl yr yL yR
0 < order_of x â†” is_of_fin_order x
measure_theory.ae_strongly_measurable f Î¼
S = T
cardinal.mk â†¥{t : set Î± | measurable_space.generate_measurable s t} â‰¤ linear_order.max (cardinal.mk â†¥s) 2 ^ cardinal.aleph_0
p1 -áµ¥ p3 - (p2 -áµ¥ p3) = p1 -áµ¥ p2
zmod.legendre_sym p a ^ 2 = 1
â†‘f.to_equiv = â†‘f.to_equiv
finite_dimensional K C
linear_independent K v
b < c â†’ a â‰¤ b â†’ a < c
subsingleton R
algebra.finite_type R (monoid_algebra R G) â†” group.fg G
âˆƒ (s : set Î±), s.countable âˆ§ (â‹ƒ (x : Î±) (H : x âˆˆ s), f x) = set.univ
c âˆˆ add_submonoid.closure {a, b} â†” âˆƒ (m n : â„•), m â€¢ a + n â€¢ b = c
cardinal.mk Î¹ â‰¤ cardinal.mk Îº
measurable (Î» (y : Î²), âˆ«â» (x : Î±), f x y âˆ‚Î¼)
a - b = 0
padic_norm p â†‘p < 1
finite_dimensional K â†¥Sâ‚
â‡‘v x = âŠ¤ â†” x = 0
Î¼ = â‡‘Î¼ â†‘Kâ‚€ â€¢ measure_theory.measure.haar_measure Kâ‚€
filter.tendsto (e âˆ˜ f) l filter.at_bot â†” filter.tendsto f l filter.at_bot
s âˆˆ ğ’œ.up_shadow â†” âˆƒ (a : Î±) (H : a âˆˆ s), s.erase a âˆˆ ğ’œ
âˆƒ (p : Î±), associated a p âˆ§ f = {p}
metric.cthickening Î´â‚ E âŠ† metric.cthickening Î´â‚‚ E
polynomial.splits (ring_hom.id K) p â†” â‡‘multiset.card p.roots = p.nat_degree
linear_map.to_matrix (pi.basis_fun R n) (pi.basis_fun R n) = linear_map.to_matrix'
mdifferentiable (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f â†’ differentiable ğ•œ f
unique_diff_within_at ğ•œ (s Ã—Ë¢ t) (x, y)
category_theory.limits.has_colimits_of_shape J D
is_add_submonoid (f â»Â¹' s)
fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(add_action.stabilizer Î± (Ï† Ï‰)))
c < b
affine_span k ({p} âˆª (Î» (v : V), v +áµ¥ p) '' s) = âŠ¤
-L.sum = (list.map (Î» (x : G), -x) L).reverse.sum
s.pairwise_disjoint id
direct_sum.is_internal A â†” is_compl (A i) (A j)
has_dist.dist x y â‰¤ C / (1 - â†‘K)
continuous X.to_Î“_Spec_fun
â‡‘h (-x) = -â‡‘h x
l.prod âˆˆ S
Â¬0.nondegenerate
Â¬monoid.is_torsion G â†” âˆƒ (g : G), Â¬is_of_fin_order g
â‡‘(affine_map.line_map (f a) (f b)) r â‰¤ f (â‡‘(affine_map.line_map a b) r) â†” slope f (â‡‘(affine_map.line_map a b) r) b â‰¤ slope f a b
â‡‘(c.map d h) x = â‡‘(c.lift d.mk' _) x
dimH (f '' t) â‰¤ dimH t
complete_space Î±
category_theory.limits.has_finite_coproducts C
a â‰¤ b â†’ b â‰  a â†’ a < b
concave_on ğ•œ s f â†’ convex_on ğ•œ s (-f)
0 â‰¤áµ[Î¼] f
module.rank R (tensor_product R M N) = (module.rank R M).lift * (module.rank R N).lift
set.Icc a b âŠ† s
âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ â‰¤ 1
f (â‡‘(affine_map.line_map a b) r) â‰¤ â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a b â‰¤ slope f (â‡‘(affine_map.line_map a b) r) b
a < 0 â†’ 0 < c â€¢ a
â†‘â†‘a = a
x * â‡‘(algebra_map R A) r * y = x * y * â‡‘(algebra_map R A) r
category_theory.subobject.exists f = category_theory.subobject.map f
b â‰¤ -a
P.fg â†” âˆƒ (S : set G), add_subgroup.closure S = P âˆ§ S.finite
algebra.is_algebraic R A â†” âŠ¤.is_algebraic
s.nodup â†’ s.dedup = s
G.local_invariant_prop G G.is_local_structomorph_within_at
eâ‚ = eâ‚‚
closure E = â‹‚ (Î´ : â„) (H : Î´ âˆˆ s), metric.thickening Î´ E
â‡‘Î¼ E * âˆ«â» (y : G), f yâ»Â¹ / â‡‘Î½ ((Î» (x : G), x * yâ»Â¹) â»Â¹' E) âˆ‚Î½ = âˆ«â» (x : G), f x âˆ‚Î¼
0 â‰¤ has_Sup.Sup S
âˆ« (x : G), f (x * g) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
has_ftaylor_series_up_to_on n (â‡‘g âˆ˜ f) (Î» (x : E) (k : â„•), g.comp_continuous_multilinear_map (p x k)) s
summable (Î» (b : Î¹), â‡‘Ï† (f b))
âˆƒ (n : â„¤), x âˆˆ set.Ico (y ^ n) (y ^ (n + 1))
is_solvable q.gal
continuous_on f s â†” continuous_on (f âˆ˜ â‡‘e) (e.to_local_equiv.source âˆ© â‡‘e â»Â¹' s)
disjoint K Ká—®
âˆƒ (Îµ : â„) (H : Îµ > 0), metric.ball x Îµ âˆ© s = {x}
measurable â‡‘(measure_theory.Lp.simple_func.to_simple_func f)
has_fderiv_at f f' x â†” has_deriv_at f (â‡‘f' 1) x
p x
category_theory.bicategory.whisker_right (category_theory.bicategory.left_unitor f).hom g = (category_theory.bicategory.associator (ğŸ™ a) f g).hom â‰« (category_theory.bicategory.left_unitor (f â‰« g)).hom
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.affine_combination pâ‚) w -áµ¥ â‡‘(s.affine_combination pâ‚‚) w
s.sum (Î» (b : Î²), â‡‘Î¼ (f â»Â¹' {b})) = â‡‘Î¼ (f â»Â¹' â†‘s)
â‡‘Î¼ (s âˆ© t) + â‡‘Î¼ (s  t) = â‡‘Î¼ s
B.is_adjoint_pair B Ïˆ Ï† â†” Ïˆ = B.left_adjoint_of_nondegenerate b Ï†
finset.map â†‘Ïƒ s = s
order.pred a â‰¤ order.pred b â†’ a â‰¤ b
is_preconnected s â†” âˆ€ (u v : set Î±), is_closed u â†’ is_closed v â†’ s âŠ† u âˆª v â†’ s âˆ© (u âˆ© v) = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v
fin.tail (function.update q i.succ y) = function.update (fin.tail q) i y
f.c.app (opposite.op U) â‰« H.inv_app ((topological_space.opens.map f.base).obj U) = Y.presheaf.map (category_theory.eq_to_hom _).op
â‡‘(p.succ_above) i < p â†” â‡‘fin.cast_succ i < p
hb.oangle x (-y) + hb.oangle y (-x) = 0
filter.at_top = filter.comap coe filter.at_top
asymptotics.is_O_with c l f (Î» (x : Î±), -g' x) â†’ asymptotics.is_O_with c l f g'
finite_dimensional.finrank k â†¥(vector_span k (set.range p)) â‰¤ n
â†¥((fin.find p).is_some) â†” âˆƒ (i : fin n), p i
â†‘(affine_span k s) = span_points k s
â‡‘F f = finsupp.sum f (Î» (a : G) (b : k), b â€¢ â‡‘F (finsupp.single a 1))
cont_diff ğ•œ n (Î» (x : E), f x * g x)
S â‰¤ Jâ‚.close S
(finset.range n).sum (Î» (i : â„•), i) = n * (n - 1) / 2
âˆ¥fâˆ¥ â‰¤ M
âˆ€á¶  (y : E) in nhds x, has_fderiv_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p y 1)) y
a < -b â†’ b < -a
â‡‘(q.comp p 1) v = â‡‘(q 1) (Î» (i : fin 1), â‡‘(p 1) v)
topological_ring Î±
a = b âˆ¨ a < b
set.eq_on â‡‘f â‡‘g (closure â†‘(submodule.span Râ‚ s))
âˆƒ (F : circle_deg1_lift), function.semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
isometry (Kuratowski_embedding Î±)
has_inner.inner (x + y) (x + y) = has_inner.inner x x + has_inner.inner x y + has_inner.inner y x + has_inner.inner y y
filter.tendsto F l (nhds f) â†” tendsto_uniformly (Î» (i : Î¹), â‡‘(F i)) â‡‘f l
function.injective measure_theory.jordan_decomposition.to_signed_measure
cont_diff_on ğ•œ n (â‡‘e âˆ˜ f) s â†” cont_diff_on ğ•œ n f s
multiples a âŠ† s
is_compact s
(l.split_wrt_composition c).nth_le i hi = list.drop (c.size_up_to i) (list.take (c.size_up_to (i + 1)) l)
â‡‘(measure_theory.measure.map f Î¼) s = â‡‘Î¼ (f â»Â¹' s)
measure_theory.integrable_on (Î» (x : â„), â†‘(real.exp (-x)) * â†‘x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume
â‡‘f (a â€¢ x + b â€¢ y) = a â€¢ â‡‘f x + b â€¢ â‡‘f y
â‡‘f v âˆˆ infi p
âˆƒ (l : list M), (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) âˆ§ l.prod = a
â‡‘(linear_map.inl ğ•œ E F) '' tangent_cone_at ğ•œ s x âŠ† tangent_cone_at ğ•œ (s Ã—Ë¢ t) (x, y)
a < c
filter.tendsto (Î» (n : â„•), âˆ«â» (x : Î±), f n x âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))
has_inner.inner (v i) (finset.univ.sum (Î» (i : Î¹), l i â€¢ v i)) = l i
a âˆ£ b â†’ 0 < multiplicity a b
âˆƒ (C : â„), âˆ€ (y : E), y âˆˆ emetric.ball x r' â†’ âˆ€ (z : E), z âˆˆ emetric.ball x r' â†’ âˆ¥f y - f z - â‡‘(p 1) (Î» (_x : fin 1), y - z)âˆ¥ â‰¤ C * linear_order.max âˆ¥y - xâˆ¥ âˆ¥z - xâˆ¥ * âˆ¥y - zâˆ¥
upper_semicontinuous (Î» (z : Î±), f z + g z)
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ set.range g), f i)) = finprod (Î» (j : Î²), f (g j))
s.finite
p Î¸
âˆƒ (C : â„) (hâ‚€ : 0 < C), âˆƒá¶  (n : â„•) in filter.at_top, 1 â‰¤ n âˆ§ âˆƒ (m : â„¤), x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < C / â†‘n ^ p
infi f â‰¤ f c
power_series.exp A * â‡‘power_series.eval_neg_hom (power_series.exp A) = 1
category_theory.is_iso f
m â‰¤ n â†’ g.continuants_aux m = (g.squash_gcf n).continuants_aux m
Â¬p j
â†‘(â‡‘multilinear_map.alternatization a).dom_coprod â†‘(â‡‘multilinear_map.alternatization b) = finset.univ.sum (Î» (Ïƒa : equiv.perm Î¹a), finset.univ.sum (Î» (Ïƒb : equiv.perm Î¹b), â‡‘equiv.perm.sign Ïƒa â€¢ â‡‘equiv.perm.sign Ïƒb â€¢ (multilinear_map.dom_dom_congr Ïƒa a).dom_coprod (multilinear_map.dom_dom_congr Ïƒb b)))
polynomial.splits (ring_hom.id K) (polynomial.X ^ n - â‡‘polynomial.C 1)
list.take (lâ‚.length + i) (lâ‚ ++ lâ‚‚) = lâ‚ ++ list.take i lâ‚‚
f = g
category_theory.exact (category_theory.projective.d f) f
a + b â‰¤ c â†’ a â‰¤ c - b
cont_diff_at ğ•œ n prod.snd p
a * b < 1
(finset.range n).sum (Î» (i : â„•), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
disjoint (ğ’œ.slice m) (finset.falling n ğ’œ).shadow
âˆƒ (c : P) (H : c âˆˆ affine_span â„ (set.range t.points)), âˆ€ (pâ‚ : P), pâ‚ âˆˆ set.range p â†’ has_dist.dist pâ‚ c = affine.simplex.circumradius t
1 âˆˆ s
polynomial.eval â†‘n (polynomial.bernoulli p.succ) = bernoulli p.succ + (â†‘p + 1) * (finset.range n).sum (Î» (k : â„•), â†‘k ^ p)
â‡‘(orthogonal_projection K) v = 0
(finset.range (n + 1)).sum (Î» (Î½ : â„•), (n â€¢ polynomial.X - â†‘Î½) ^ 2 * bernstein_polynomial R n Î½) = n â€¢ polynomial.X * (1 - polynomial.X)
euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b
is_mul_hom id
liouville_with p (x * â†‘r)
category_theory.limits.has_limits_of_size D
finite_dimensional.finrank k â†¥(vector_span k (set.range p)) â‰¤ n â†” Â¬affine_independent k p
âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
cauchy_seq f
X.Î´ (â‡‘fin.cast_succ i) â‰« X.Î´ i = X.Î´ i.succ â‰« X.Î´ i
is_semiring_hom id
infi f * x = â¨… (i : Î¹), f i * x
deriv_within (Î» (u : â„), âˆ« (x : â„) in u..b, f x) s a = -c
â‡‘F f = finsupp.sum f (Î» (a : G) (b : k), b â€¢ â‡‘F (finsupp.single a 1))
fib_rec.is_solution (Î» (x : â„•), â†‘(nat.fib x))
category_theory.exact fâ‚‚ gâ‚‚
module.is_torsion R â†¥(submodule.torsion R M)
âˆƒ (u : set Î±) (v : set Î²), is_open u âˆ§ is_open v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ u Ã—Ë¢ v âŠ† n
relation.trans_gen r n m
filter.tendsto (Î» (x : â„), x ^ n / (b * real.exp x + c)) filter.at_top (nhds 0)
metric.cthickening Îµ (metric.thickening Î´ s) âŠ† metric.cthickening (Îµ + Î´) s
is_empty (Î± â†ª Î²)
minpoly A x â‰  1
((Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f' =o[l] g'
(f.prod g).range = f.range.prod g.range
â‡‘Î¼ (f â»Â¹' s) = â‡‘Î½ (g â»Â¹' s)
has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) s a
category_theory.is_pushout (F.map f) (F.map g) (F.map h) (F.map i)
cont_diff_at ğ•‚ n (hf.local_inverse hf' hn) (f a)
dense_range f
(F.right_derived n).map f = (F.right_derived_obj_iso n Q).hom â‰« (homology_functor D (complex_shape.up â„•) n).map ((F.map_homological_complex (complex_shape.up â„•)).map g) â‰« (F.right_derived_obj_iso n P).inv
linear_independent R v â†’ m â‰¤ n
filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)
upper_semicontinuous_within_at (Î» (z : Î±), f z + g z) s x
algebraic_independent R coe â†’ cardinal.mk â†¥s â‰¤ â†‘n
(s âˆª t).noncomm_sum f comm = s.noncomm_sum f scomm + t.noncomm_sum f tcomm
complete_space Î±
â‡‘(euclidean_geometry.reflection s) (â‡‘(euclidean_geometry.reflection s) p) = p
â†‘(n.succ) â€¢ polynomial.bernoulli n = â‡‘(polynomial.monomial n) â†‘(n.succ) - (finset.range n).sum (Î» (k : â„•), â†‘((n + 1).choose k) â€¢ polynomial.bernoulli k)
B.separating_left
module.rank R (matrix m n R) = (cardinal.mk m * cardinal.mk n).lift
0 â‰¤ a + b
âˆƒ (m : M) (H : m âˆˆ s), m * m = m
â‡‘(orientation.map Î¹ f) x = -x â†” â‡‘linear_map.det â†‘f < 0
continuous_within_at f (set.Iic a) a
âˆ¥â‡‘(add_monoid_hom.mul_left x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{r}.to_colex < {s}.to_colex â†” r < s
F.is_sheaf
differentiable_on â„‚ (function.update f c (lim (nhds_within c {c}á¶œ) f)) s
is_compact (s âˆ© t)
fintype.card (dihedral_group n) = 2 * n
âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K'
finprod (Î» (i : Î±), f i / g i) = finprod (Î» (i : Î±), f i) / finprod (Î» (i : Î±), g i)
(finset.subtype p s).sum (Î» (x : subtype p), f â†‘x) = (finset.filter p s).sum (Î» (x : Î±), f x)
filter.map f filter.at_top = filter.at_top
0 â‰¤ a * b âˆ¨ 0 â‰¤ b * c âˆ¨ 0 â‰¤ c * a
s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â‰¤ s.sum (Î» (i : Î¹), f i * g i)
âˆƒ (q : S) (r : R) (H : r âˆˆ class_group.finset_approx bS adm), â‡‘abv (â‡‘(algebra.norm R) (r â€¢ a - q * b)) < â‡‘abv (â‡‘(algebra.norm R) b)
bdd_above s â†’ bdd_above t â†’ bdd_above (s âˆª t)
x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
bdd_below (s âˆª t) â†” bdd_below s âˆ§ bdd_below t
i.inv â‰« sq.left â‰« p.hom = sq.right
ring.inverse x = â…Ÿ x
is_primitive_root (is_cyclotomic_extension.zeta n A B) â†‘n
continuous (convolution f g L Î¼)
lower_semicontinuous_at (Î» (z : Î±), f z + g z) x
finite_dimensional.finrank R (Î¹ â†’ R) = fintype.card Î¹
âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).card < n
category_theory.limits.has_limits C
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = -â‡‘(s.weighted_vsub pâ‚‚) w
fixing_subgroup M (s âˆª t) = fixing_subgroup M s âŠ“ fixing_subgroup M t
antitone (Î» (n : â„•), f^[n] x)
category_theory.limits.has_binary_products C
subtype.topological_space = topological_space.induced (set.inclusion ts) subtype.topological_space
padic_val_rat p (-q) = padic_val_rat p q
âˆƒ (p : P), â†‘s1 âˆ© â†‘s2 = {p}
cont_mdiff_at I I'' n (g âˆ˜ f) x
star_convex ğ•œ x (â‡‘f â»Â¹' s)
âˆƒ (l : â„), filter.tendsto (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i)) filter.at_top (nhds l)
(â¨† (i : Î¹) (h : p i), S i) = ((dfinsupp.sum_add_hom (Î» (i : Î¹), (S i).subtype)).comp (dfinsupp.filter_add_monoid_hom (Î» (i : Î¹), â†¥(S i)) p)).mrange
finset.filter p s = âˆ…
b = 0
(generalized_continued_fraction.of v).denominators n â‰¤ (generalized_continued_fraction.of v).denominators (n + 1)
f = g
a + b = b + a
measurable_space.generate_from (set.univ.pi '' set.univ.pi C) = measurable_space.pi
(submodule.span â„‚ (set.range (fourier_Lp p))).topological_closure = âŠ¤
is_lower_set s â†’ is_upper_set (â‡‘order_dual.to_dual â»Â¹' s)
ultrafilter.extend f b = c â†” â†‘(ultrafilter.map f b) â‰¤ nhds c
order_of (zmod.unit_of_coprime a _) âˆ£ n
continuous_at f a
â‡‘(monoid_algebra.of R M) m âˆˆ submodule.span R (â‡‘(monoid_algebra.of R M) '' S) â†” m âˆˆ S
fib_rec.is_solution (has_pow.pow golden_ratio)
I = (ideal.map (ring_hom.fst R S) I).prod (ideal.map (ring_hom.snd R S) I)
filter.tendsto d l (nhds 0)
category_theory.presheaf.second_map R F â‰« (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom â‰« Top.presheaf.sheaf_condition_equalizer_products.right_res F (Top.presheaf.covering_of_presieve U R)
metric.diam s â‰¤ C
Ï€.bUnion_index Ï€i J' = J
summable (Î» (i : â„•), 1 / m ^ f i)
set.bij_on f s t
(s.sup g).sup_indep f
exp ğ•‚ (x + y) = exp ğ•‚ x * exp ğ•‚ y
probability_theory.indep_fun f g Î¼ â†” âˆ€ {Ï† : Î² â†’ â„} {Ïˆ : Î²' â†’ â„}, measurable Ï† â†’ measurable Ïˆ â†’ measure_theory.integrable (Ï† âˆ˜ f) Î¼ â†’ measure_theory.integrable (Ïˆ âˆ˜ g) Î¼ â†’ measure_theory.integral Î¼ (Ï† âˆ˜ f * Ïˆ âˆ˜ g) = measure_theory.integral Î¼ (Ï† âˆ˜ f) * measure_theory.integral Î¼ (Ïˆ âˆ˜ g)
(finset.filter p (finset.Ico n (n + a))).card = nat.count p a
e.is_image s t â†’ e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' (e.to_local_equiv.source âˆ© s) = e.to_local_equiv.target âˆ© t
P.next_coeff = -P.roots.sum
metric.bounded (metric.ball x r)
has_deriv_at f f' x â†” has_fderiv_at f (1.smul_right f') x
âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ C * finset.univ.sum (Î» (i : Î¹), finset.univ.prod (Î» (j : Î¹), ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (linear_order.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
e.target âˆ© â‡‘(e.symm) â»Â¹' s = e.target âˆ© t â†’ e.is_image s t
(linear_map.trace R M).comp (dual_tensor_hom R M M) = contract_left R M
s âˆˆ ğ’œ.up_shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ) (a : Î±) (H : a âˆ‰ t), has_insert.insert a t = s
(â‡‘(topological_space.compacts.equiv f) K).carrier = â‡‘(f.symm) â»Â¹' K.carrier
â‡‘x = â‡‘â†‘x
(a * b).factors.to_finset = a.factors.to_finset âˆª b.factors.to_finset
set.Ioi b âŠ† set.Ioi a
strict_convex_on ğ•œ s f
fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(mul_action.stabilizer Î± (Ï† Ï‰)))
antitone_on f s â†’ monotone_on (f âˆ˜ â‡‘order_dual.of_dual) s
has_sbtw.sbtw b c a
has_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) a
filter.tendsto (Î» (x : Î±), f x * r) l filter.at_bot
set.image2 f (g '' s) t = g' '' set.image2 f' t s
set.interval (f a) (f b) âŠ† f '' set.interval a b
âˆƒ (k : â„•+), n = k + 1
differentiable_on ğ•œ f s â†’ mdifferentiable_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s
finite_dimensional.finrank K (V â§¸ s) + finite_dimensional.finrank K â†¥s = finite_dimensional.finrank K V
is_compact (â‡‘f â»Â¹' s)
continuous_within_at f s x â†” continuous_within_at (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) (â‡‘(e.symm) x)
minpoly A x â‰  0
y âˆˆ â‹ƒ (x : Î±) (H : x âˆˆ s), t x
witt_structure_rat p Î¦ n = â‡‘mv_polynomial.C (1 / â†‘p ^ n) * (â‡‘(mv_polynomial.bindâ‚ (Î» (b : idx), â‡‘(mv_polynomial.rename (Î» (i : â„•), (b, i))) (witt_polynomial p â„š n))) Î¦ - (finset.range n).sum (Î» (i : â„•), â‡‘mv_polynomial.C (â†‘p ^ i) * witt_structure_rat p Î¦ i ^ p ^ (n - i)))
â‡‘Î¼ K < âŠ¤
a â€¢ x + b â€¢ y âˆˆ metric.ball z r
continuous_at (Î» (a : Î±), (f a).snd) x
â‡‘f (v +áµ¥ p) = â‡‘(f.linear) v +áµ¥ â‡‘f p
B.separating_right â†” B.flip.ker = âŠ¥
category_theory.is_iso f
â‡‘linear_map.adjoint (A.comp B) = (â‡‘linear_map.adjoint B).comp (â‡‘linear_map.adjoint A)
group.nilpotency_class G â‰¤ 1
Ï€ â»Â¹' (Ï€ '' U) = U
-a < b â†’ -b < a
has_inner.inner (sâ‚.sum (Î» (iâ‚ : Î¹â‚), wâ‚ iâ‚ â€¢ vâ‚ iâ‚)) (sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚‚ iâ‚‚ â€¢ vâ‚‚ iâ‚‚)) = -sâ‚.sum (Î» (iâ‚ : Î¹â‚), sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚ iâ‚ * wâ‚‚ iâ‚‚ * (âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥ * âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥))) / 2
convex_on â„ s has_norm.norm
a â‹– b â†’ â‡‘order_dual.to_dual b â‹– â‡‘order_dual.to_dual a
âˆƒ (m : â†¥M), m â€¢ x âˆˆ algebra.adjoin R â†‘(is_localization.finset_integer_multiple (submonoid.map â†‘(algebra_map R S) M) s)
f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
f.of_add_equiv_of_dom _ = f
0 < (polynomial.cyclotomic n R).degree
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
convex â„ (p.ball x r)
â‡‘Î¼ (â‹‚ (i : Î¹), s i) = â¨… (i : Î¹), â‡‘Î¼ (s i)
has_inner.inner (x + y) (x + y) + has_inner.inner (x - y) (x - y) = 2 * (has_inner.inner x x + has_inner.inner y y)
Jâ‚.close (category_theory.sieve.pullback f S) = category_theory.sieve.pullback f (Jâ‚.close S)
bornology.is_cobounded sá¶œ â†’ bornology.is_bounded s
â‡‘witt_vector.verschiebung x = x * â†‘p
sâ‚.circumcenter = sâ‚‚.circumcenter
â†‘(affine_span k (p '' s1)) âˆ© â†‘(affine_span k (p '' s2)) = âˆ…
exp ğ•‚ (x + y) = exp ğ•‚ x * exp ğ•‚ y
measure_theory.is_locally_finite_measure Î¼
function.update (fin.cons x p) 0 z = fin.cons z p
p f
multiset.count (f x) (multiset.map f s) = multiset.count x s
Kâ‚‚á—® â‰¤ Kâ‚á—®
(L.update_nth n a).prod = L.prod * dite (n < L.length) (Î» (hn : n < L.length), (L.nth_le n hn)â»Â¹ * a) (Î» (hn : Â¬n < L.length), 1)
affine_independent k (Î» (i : Î¹), â‡‘(affine_map.line_map (p j) (p i)) â†‘(w i))
sâ»Â¹.nonempty â†’ s.nonempty
has_deriv_within_at (l âˆ˜ f) (â‡‘l' f') s x
has_nndist.nndist x y = (has_edist.edist x y).to_nnreal
â‡‘((mv_polynomial.aeval (Î» (p : m Ã— m), A p.fst p.snd)).map_matrix) (matrix.mv_polynomial_X m m R) = A
0 = 1 â†” subsingleton Mâ‚€
c * c = c
âˆƒ (c : â„) (H : c < a) (B : â„), (f - g) =O[filter.comap complex.abs filter.at_top âŠ“ l] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)
(âˆ€á¶  (x : Î±) in l, x âˆˆ s â†” x âˆˆ t) â†’ s =á¶ [l] t
continuous_within_at f (set.Iic a) a
convolution (Ï†.normed Î¼) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€ = g xâ‚€
is_closed_map â‡‘f
â‡‘h (x / y) = â‡‘h x / â‡‘h y
e.source = e'.source
âˆƒ (x : X) (H : x âˆˆ s), f x = g x
continuous_at (Î» (x : â„‚), x ^ w) z
âˆ« (y : â„) in a..b, f' y = f b - f a
Î¼ = Î½
âˆƒ (m : â„•) (H : m > N), â‡‘Î¼ (s âˆ© f^[m] â»Â¹' s) â‰  0
continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)
âˆƒ (s : finset (Î¹ Ã— â„)), box_integral.prepartition.split_many I s â‰¤ Ï€
(category_theory.cocone_of_representable Pâ‚).Î¹.app j â‰« Î± = (category_theory.cocone_of_representable Pâ‚‚).Î¹.app ((category_theory.category_of_elements.map Î±).op.obj j)
(Î» (t : Î¹), âˆ« (x : â„) in va t..vb t, f x âˆ‚Î¼ - âˆ« (x : â„) in ua t..ub t, f x âˆ‚Î¼ - (âˆ« (x : â„) in ub t..vb t, cb âˆ‚Î¼ - âˆ« (x : â„) in ua t..va t, ca âˆ‚Î¼)) =o[lt] Î» (t : Î¹), âˆ¥âˆ« (x : â„) in ua t..va t, 1 âˆ‚Î¼âˆ¥ + âˆ¥âˆ« (x : â„) in ub t..vb t, 1 âˆ‚Î¼âˆ¥
measurable_space.generate_from (set.univ.pi '' set.univ.pi (Î» (i : Î¹), {s : set (Î± i) | measurable_set s})) = measurable_space.pi
âˆƒ (g : C(Y, â„)), â‡‘g âˆ˜ e = â‡‘f
nat.log p n < b â†’ multiplicity p n.factorial = â†‘((finset.Ico 1 b).sum (Î» (i : â„•), n / p ^ i))
group.is_nilpotent G â†” âˆƒ (n : â„•) (H : â„• â†’ subgroup G), is_ascending_central_series H âˆ§ H n = âŠ¤
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i * g i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), g i))
0 â‰¤ â‡‘is_R_or_C.re (has_inner.inner x (â‡‘(â‡‘linear_map.adjoint T * T) x))
âˆƒ (x : E), c < âˆ¥xâˆ¥
cont_diff_on ğ•œ n f s â†” (âˆ€ (m : â„•), â†‘m â‰¤ n â†’ continuous_on (iterated_deriv_within m f s) s) âˆ§ âˆ€ (m : â„•), â†‘m < n â†’ differentiable_on ğ•œ (iterated_deriv_within m f s) s
is_min_filter f l a â†’ is_max_filter (â‡‘order_dual.to_dual âˆ˜ f) l a
Î¼.absolutely_continuous Î½
t.sum (Î» (c : Î¹), f c) âˆˆ S
âˆƒ (z : E) (H : z âˆˆ frontier U), is_max_on (has_norm.norm âˆ˜ f) (closure U) z
(â¨† (b : Î±) (H : b âˆˆ s), b âŠ“ a) â‰¤ has_Sup.Sup s âŠ“ a
filter.tendsto has_abs.abs filter.at_top filter.at_top
uniform_continuous â‡‘f
Ï† = Ïˆ
âˆ¥measure_theory.mem_â„’p.to_Lp â‡‘f _âˆ¥ â‰¤ âˆ¥fâˆ¥
p âˆˆ s1 âŠ“ s2 â†” p âˆˆ s1 âˆ§ p âˆˆ s2
âˆ‘' (i : â„•), 1 / m ^ (i + (n + 1)).factorial < (1 - 1 / m)â»Â¹ * (1 / m ^ (n + 1).factorial)
P I
has_dist.dist (f t) (g t) â‰¤ Î´ * real.exp (â†‘K * (t - a))
Î¼.inner_regular p (Î» (s : set Î±), measurable_set s âˆ§ â‡‘Î¼ s â‰  âŠ¤)
â‡‘(sâ‚.weighted_vsub_of_point p b) w = â‡‘(sâ‚‚.weighted_vsub_of_point p b) (â†‘sâ‚.indicator w)
reflection (submodule.map â†‘(f.to_linear_equiv) K) = f.symm.trans ((reflection K).trans f)
â‡‘(measure_theory.measure.hausdorff_measure d) s â‰¤ l.liminf (Î» (n : Î²), âˆ‘' (i : Î¹ n), emetric.diam (t n i) ^ d)
âˆƒ (Ï– : R), prime Ï–
âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ â‰¤ âˆ¥mâˆ¥
function.injective â‡‘f
â‡‘(first_order.language.substructure.closure L) â†‘S = S
âˆƒ (j : J) (V : set â†¥(F.obj j)) (hV : is_clopen V), U = â‡‘(C.Ï€.app j) â»Â¹' V
is_unit (â‡‘linear_map.det â†‘f)
s -áµ¥ s âŠ† â†‘(vector_span k s)
a * b âˆˆ add_submonoid.closure â†‘S
s âˆˆ ğ’œ.shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), s âŠ† t âˆ§ t.card = s.card + 1
multiplicity a b = â†‘(multiset.count (â‡‘normalize a) (unique_factorization_monoid.normalized_factors b))
(âˆƒ (r : â„), âˆ€ (p1 : P), p1 âˆˆ ps â†’ has_dist.dist p1 p = r) â†” âˆƒ (r : â„), âˆ€ (p1 : P), p1 âˆˆ ps â†’ has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = r
exp ğ•‚ (s.sum (Î» (i : Î¹), f i)) = s.prod (Î» (i : Î¹), exp ğ•‚ (f i))
emetric.inf_edist x (s âˆª t) = emetric.inf_edist x s âŠ“ emetric.inf_edist x t
deriv (Î» (y : â„), real.tan y - y) x = 1 / real.cos x ^ 2 - 1
cont_diff_on ğ•œ n (g âˆ˜ f) s
(b.reindex e).to_matrix v = â‡‘(matrix.reindex_alg_equiv R e) (b.to_matrix (v âˆ˜ â‡‘e))
dimH â†‘s = 0
function.is_fixed_pt g x
âˆƒ (x y : R), gcd_monoid.gcd a b = a * x + b * y
algebra.finite_presentation R (mv_polynomial Î¹ R)
strict_anti f â†” âˆ€ (i : fin n), f i.succ < f (â‡‘fin.cast_succ i)
hb.oangle x y = -hbâ‚‚.oangle x y
continuous_within_at f (set.Ici a) a
âˆ€á¶  (z : â„) in nhds_within x s, âˆ¥z - xâˆ¥â»Â¹ * âˆ¥f z - f xâˆ¥ < r
x = y
eqv_gen.setoid r â‰¤ s
âˆƒ (F : set Î±) (H : F âŠ† U), is_closed F âˆ§ r < â‡‘Î¼ F
analytic_at ğ•œ f y
x.lf 0 â†” âˆƒ (j : x.right_moves), âˆ€ (i : (x.move_right j).left_moves), ((x.move_right j).move_left i).lf 0
o.oangle (r â€¢ x) y = o.oangle (-x) y
hV.linear_isometry.to_linear_map.range = (â¨† (i : Î¹), (V i).to_linear_map.range).topological_closure
âˆƒ (r : R), r - 1 âˆˆ I âˆ§ âˆ€ (n : M), n âˆˆ N â†’ r â€¢ n = 0
â‡‘linear_equiv.det (o.rotation Î¸).to_linear_equiv = 1
(âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : {a // p a}), q â†‘x _
is_of_fin_order 1
âˆ® (z : â„‚) in C(c, R), (z - w) ^ n = 0
f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
cardinal.mk â†¥{t : set Î± | measurable_set t} â‰¤ linear_order.max (cardinal.mk â†¥s) 2 ^ cardinal.aleph_0
âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥
finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) â‰¤ finset.univ.sum (Î» (i : Î¹), f i * g i)
a âˆ£ b * â†‘u â†” a âˆ£ b
orthonormal â„‚ (fourier_Lp 2)
Aâ»Â¹ = B
has_mul.mul 0 = function.const Mâ‚€ 0
(polynomial.cyclotomic (p ^ k * m) R).is_root Î¼ â†” is_primitive_root Î¼ m
same_ray R v (r â€¢ v) â†” 0 < r
is_bounded_linear_map ğ•œ (Î» (p : E Ã— F), h.deriv p)
B.separating_right
x = 0
liouville_with p (â†‘r * x) â†” liouville_with p x
semilattice_sup.to_partial_order Î± = semilattice_inf.to_partial_order Î±
is_open {u : ultrafilter Î± | s âˆˆ u}
ideal.is_jacobson R â†” âˆ€ {I : ideal R}, I.is_prime â†’ (âˆƒ (M : set (ideal R)), (âˆ€ (J : ideal R), J âˆˆ M â†’ J.is_maximal âˆ¨ J = âŠ¤) âˆ§ I = has_Inf.Inf M)
v +áµ¥ p âˆˆ affine_subspace.mk' p direction
has_Inf.Inf ((Î» (t : â„), âˆ« (x : â„) in 0..t, g x) '' set.Icc 0 T) + âŒŠt / TâŒ‹ â€¢ âˆ« (x : â„) in 0..T, g x â‰¤ âˆ« (x : â„) in 0..t, g x
f' =o[l] g â†’ (Î» (x : Î±), -f' x) =o[l] g
0 < 1
â‡‘f (g * hâ»Â¹) = â‡‘f g * (â‡‘f h)â»Â¹
âˆ¥f xâˆ¥ â‰¤ gronwall_bound Î´ K Îµ (x - a)
s âŠ† â†‘(submonoid.closure s)
cont_diff_on ğ•œ n f s
measurable g
is_mul_hom (g âˆ˜ f)
continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I H â»Â¹' s)
is_monoid_hom (g âˆ˜ f)
Î¼.inner_content (â¨† (i : â„•), U i) â‰¤ âˆ‘' (i : â„•), Î¼.inner_content (U i)
f.eigenspace Î¼ â‰¤ â‡‘(f.generalized_eigenspace Î¼) k
add_subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S
f.mrange = âŠ¤
solvable_by_rad.P Î±
âˆƒ (u : set (set Î±)) (H : u âŠ† t), u.countable âˆ§ u.pairwise_disjoint id âˆ§ â‡‘Î¼ (s  â‹ƒ (a : set Î±) (H : a âˆˆ u), a) = 0
d = disjointed f
measure_theory.ae_strongly_measurable f Î¼
continuous (Î» (x : X), (A x).mul (B x))
finset.nat.antidiagonal 0 = {(0, 0)}
â‡‘g (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), â‡‘g (f x))
o.rotation 0 = linear_isometry_equiv.refl â„ V
filter.at_bot = filter.comap coe filter.at_bot
free_group.red list.nil L â†” L = list.nil
0 âˆˆ S
category_theory.limits.limit F = infi F.obj
continuous (show B â†’ Z.total_space, from Î» (x : B), âŸ¨x, vâŸ©)
â‡‘f x = â‡‘f y
1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
module.End.has_eigenvalue T (â†‘â¨† (x : {x // x â‰  0}), â‡‘is_R_or_C.re (has_inner.inner (â‡‘T â†‘x) â†‘x) / âˆ¥â†‘xâˆ¥ ^ 2)
x - y âˆˆ H
measurable_set (region_between f g s)
x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
âˆ¥(â†‘âˆ¥xâˆ¥)â»Â¹ â€¢ xâˆ¥ = 1
-a < 0 â†” 0 < a
â‡‘(fin.cast h) = cast _
(â‡‘(matrix.reindex_alg_equiv R e) A).det = A.det
continuous (Î» (f : C(Î±, Î²)), â‡‘f x)
quot.lift f h (quot.mk r a) = f a
is_left_regular k
function.injective mul_action.to_perm
â†‘(submodule.span R s) âŠ† â†‘(submodule.span S s)
has_inner.inner (r â€¢ x) x = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
filter.tendsto f lâ‚ lâ‚‚ â†’ lâ‚ â‰¤ filter.comap f lâ‚‚
âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (x : â„) in f a..f b, g x
continuous f
finset.univ.sum (Î» (i : Î¹), finset.centroid_weights_indicator k s i) = 1
âˆƒ (y : N), y + â‡‘f x = 0
a â€¢ interior s + b â€¢ s âŠ† interior s
Â¬a â©¿ b â†” âˆƒ (c : Î±), a < c âˆ§ c < b
H = K
a < b * c â†’ bâ»Â¹ * a < c
finite_dimensional.finrank K (Î¹ â†’ K) = fintype.card Î¹
finite_dimensional.finrank K â†¥s â‰¤ finite_dimensional.finrank K V
âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (z : Î² Ã— Î±), f z.snd z.fst âˆ‚Î½.prod Î¼
emetric.inf_edist x t â‰¤ emetric.inf_edist x s + emetric.Hausdorff_edist s t
â‡‘witt_vector.frobenius (â‡‘witt_vector.verschiebung x) = x * â†‘p
cont_diff_within_at ğ•œ n f s x â†’ cont_mdiff_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s x
0 â‰¤ ifp_n.fr
âˆƒ (K : set Î±) (H : K âŠ† s), is_closed K âˆ§ â‡‘Î¼ s < â‡‘Î¼ K + Îµ
(âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.prod âˆˆ K
set.surj_on f s set.univ
â†‘(nat.sqrt a) â‰¤ real.sqrt â†‘a
tâ‚ = tâ‚‚
dense {x}á¶œ â†” Â¬is_open {x}
L.reverse.prod = ((list.map (Î» (x : G), xâ»Â¹) L).prod)â»Â¹
â‡‘(c âŠ“ d) x y â†” â‡‘c x y âˆ§ â‡‘d x y
spectrum ğ•œ (k â€¢ a) = k â€¢ spectrum ğ•œ a
cauchy_seq (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i))
S.blunt â†’ S.salient
âˆ«â» (a : Î±), f a âˆ‚Î¼ + Îµ * â‡‘Î¼ {x : Î± | f x + Îµ â‰¤ g x} â‰¤ âˆ«â» (a : Î±), g a âˆ‚Î¼
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ set.range g), f i)) = finsum (Î» (j : Î²), f (g j))
cont_diff ğ•œ n f
s.monge_point = (â†‘(n + 1) / â†‘(n - 1)) â€¢ (finset.centroid â„ finset.univ s.points -áµ¥ s.circumcenter) +áµ¥ s.circumcenter
finite_dimensional.finrank R (tensor_product R M N) = finite_dimensional.finrank R M * finite_dimensional.finrank R N
n â‰¤ polynomial.root_multiplicity a p
(âˆ€ (s : finset Î¹), s.card â‰¤ (s.bUnion t).card) â†” âˆƒ (f : Î¹ â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
set.eq_on â‡‘e â‡‘e' e.source
âˆ¥â‡‘f zâˆ¥ â‰¤ c / r * âˆ¥zâˆ¥
is_closed {t : topological_space.closeds Î± | â†‘t âŠ† s}
filter.tendsto f (nhds x) (nhds y)
âˆƒ (M : â„), 0 < M âˆ§ measure_theory.snorm ({x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f) p Î¼ â‰¤ ennreal.of_real Îµ
cont_diff_on ğ•œ n f s
â†‘(â‡‘(category_theory.limits.fork.is_limit.hom_iso ht Z') (q â‰« k)) = q â‰« â†‘(â‡‘(category_theory.limits.fork.is_limit.hom_iso ht Z) k)
has_deriv_at â‡‘(f.symm) f'â»Â¹ a
dense (s  {x})
filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
is_coatom a â†’ a â‹– âŠ¤
filter.tendsto f b (nhds a)
(âˆ€ (f : â„• â†’o (submodule R M)áµ’áµˆ), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘f n = â‡‘f m) â†” is_artinian R M
â‡‘g x = â‡‘g y
is_regular a
(âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n
irreducible (minpoly A x)
âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ C
(lower_bounds s âˆ© t).nonempty â†’ bdd_above (f '' s)
(list.map f l).prod = graded_monoid.mk (l.dprod_index (Î» (i : Î±), (f i).fst)) (l.dprod (Î» (i : Î±), (f i).fst) (Î» (i : Î±), (f i).snd))
filter.tendsto (Î» (x : Î±), f x * r) l filter.at_top
measure_theory.conservative f Î¼
a = b â†’ b âŠ† a
s âˆˆ nhds_within a (set.Iic a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Icc l a âŠ† s
minpoly A x âˆ£ p
finset.image g (finset.imageâ‚‚ f s t) = finset.imageâ‚‚ f' t (finset.image g' s)
is_group_hom id
âˆƒ (x : Î²), âˆ€ (y : Î²), f y â‰¤ f x
y âˆˆ â‹‚ (x : Î±) (H : x âˆˆ s), t x
P (â‡‘f x - x)
finite_dimensional.finrank k â†¥(vector_span k â†‘(finset.image p s)) â‰¤ n
continuous_within_at f s x â†” continuous_within_at (â‡‘e âˆ˜ f) s x
function.injective f â†’ pairwise (ne on f)
sym.map (Î» (x : Î±), x) s = s
Ï.character 1 = â†‘(finite_dimensional.finrank k V)
â‡‘f = â‡‘(f.linear) + Î» (z : V1), â‡‘f 0
âˆ¥f zâˆ¥ â‰¤ C
âˆƒ (G : finset M), algebra.adjoin R (add_monoid_algebra.of' R M '' â†‘G) = âŠ¤
p x
p I
analytic_on ğ•œ (iterated_fderiv ğ•œ n f) s
â‡‘(f.lift hg) (f.mk' x y) = â‡‘g x + â†‘-â‡‘(is_add_unit.lift_right (g.restrict S) hg) y
fintype.card {x // Â¬p x} = fintype.card {x // Â¬q x}
category_theory.presieve.is_sheaf_for P R â†’ category_theory.presieve.is_sheaf_for P' R
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ has_insert.insert a s), f i)) = f a * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
0 â‰¤ â‡‘f' y
F.sections.nonempty
âˆƒ (c : set M) (H : c âˆˆ s) (a : stream M), hindman.FP a âŠ† c
cauchy_seq (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), f i â€¢ z i))
-a âˆ£ b â†” a âˆ£ b
tendsto_uniformly F f p â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), has_dist.dist (f x) (F n x) < Îµ)
â‡‘(orientation.map Î¹ f) x = (â‡‘linear_equiv.det f)â»Â¹ â€¢ x
finset.univ = finset.map equiv.perm.decompose_option.symm.to_embedding finset.univ
cauchy_seq (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i))
is_closed (â‡‘(convex_hull â„) s)
(((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod).is_two_block_diagonal
(affine_subspace.mk' p direction).direction = direction
b = c â†’ a â‰¤ b â†’ a â‰¤ c
x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
[x].intercalate (list.split_on x xs) = xs
âˆ¥â‡‘f xâˆ¥ = 0
âˆƒ (l : list Î±), list.chain r a l âˆ§ (a :: l).last _ = b
0 âˆˆ s
c âˆˆ submonoid.closure {a, b} â†” âˆƒ (m n : â„•), a ^ m * b ^ n = c
p âˆˆ I
âˆƒ (M : category_theory.bundled L.Structure), first_order.language.Structure.cg L â†¥M âˆ§ L.age â†¥M = K
t.sum (Î» (i : Î¹), fâ‚ i) âŠ† t.sum (Î» (i : Î¹), fâ‚‚ i)
continuous_at proj x
is_unit (matrix.diagonal v) â†” is_unit v
r.sign = -1 âˆ¨ r.sign = 1
is_coprime a b
b < c
a = b âˆ¨ a âŠ‚ b
âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (u : â„) in f a..f b, g u
x.lf y â†” (âˆƒ (i : y.left_moves), (âˆ€ (i' : x.left_moves), (x.move_left i').lf (y.move_left i)) âˆ§ âˆ€ (j : (y.move_left i).right_moves), x.lf ((y.move_left i).move_right j)) âˆ¨ âˆƒ (j : x.right_moves), (âˆ€ (i : (x.move_right j).left_moves), ((x.move_right j).move_left i).lf y) âˆ§ âˆ€ (j' : y.right_moves), (x.move_right j).lf (y.move_right j')
subsemigroup.closure s â‰¤ subsemigroup.closure t
submodule.span R s â‰¤ submodule.restrict_scalars R (submodule.span S s)
free_group.red [x] Lâ‚ â†” Lâ‚ = [x]
well_founded gt
|â‡‘f (bernstein.z k) - â‡‘f x| < Îµ / 2
has_strict_deriv_at complex.sin (complex.cos x) x
pairwise (disjoint on t)
â†‘-v = -â†‘v
â‡‘f (Î» (i : Î¹), c i â€¢ m i) = finset.univ.prod (Î» (i : Î¹), c i) â€¢ â‡‘f m
multiplicity m n = â†‘((finset.filter (Î» (i : â„•), m ^ i âˆ£ n) (finset.Ico 1 b)).card)
âˆƒ (P : finset (ideal R)) [_inst_6 : decidable_eq â†¥P] [_inst_7 : âˆ€ (p : ideal R), p âˆˆ P â†’ prime p] (e : â†¥P â†’ â„•), direct_sum.is_internal (Î» (p : â†¥P), submodule.torsion_by_set R M â†‘(â†‘p ^ e p))
measure_theory.integrable f Î¼
âˆƒ (a : Î±), infinite â†¥(f â»Â¹' {a})
g = h
set.range (â‡‘b âˆ˜ â‡‘(e.symm)) = set.range â‡‘b
v = (generalized_continued_fraction.of v).convergents (n - 1)
âˆ¥â‡‘f mâˆ¥ â‰¤ âˆ¥fâˆ¥
nonempty {t // s âŠ† t âˆ§ measurable_set t}
filter.cofinite.coprod filter.cofinite = filter.cofinite
(uniformity Î±).has_basis (Î» (V : set (Î± Ã— Î±)), V âˆˆ uniformity Î± âˆ§ is_open V âˆ§ symmetric_rel V) id
a âˆ£ b + a â†” a âˆ£ b
strict_mono f
subgroup.normal_closure {âŸ¨f, _âŸ©} = âŠ¤
add_submonoid.map f (add_submonoid.closure s) = add_submonoid.closure (â‡‘f '' s)
I / J = I * Jâ»Â¹
filter.tendsto (Î» (x : Î²), f x + g x) l filter.at_top
finset.univ.sum (Î» (a : F), char.quadratic_char F a) = 0
â‡‘f 1 = 1
collinear k s â†” module.rank k â†¥(vector_span k s) â‰¤ 1
dense (s âˆ© t)
multilinear_map.dom_dom_congr (Ïƒa.sum_congr Ïƒb) (a.dom_coprod b) = (multilinear_map.dom_dom_congr Ïƒa a).dom_coprod (multilinear_map.dom_dom_congr Ïƒb b)
x âˆˆ closure s â†” metric.inf_dist x s = 0
a + b â‰¤ 0
is_invariant Ï• s
submonoid.closure s â‰¤ S â†” s âŠ† â†‘S
â†‘(â‡‘(is_unit.lift_right (f.restrict S) h) y)â»Â¹ = z
â‡‘(s.order_emb_of_fin h) âŸ¨k - 1, _âŸ© = s.max' _
semiconj_by â†‘aâ»Â¹ y x
algebraic_geometry.to_Spec_Î“ (algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X)) â‰« X.to_Î“_Spec.val.c.app (opposite.op âŠ¤) = ğŸ™ (algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X))
coe =o[filter.at_top] Î» (n : â„•), r ^ n
measurable (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s))
filter.tendsto fâ‚‚ p (nhds a)
Â¬function.surjective f
cont_diff_at â„ n (Î» (x : X), â‡‘(f x) (g x)) x
âˆƒ (n : â„•), y ^ (n + 1) < x âˆ§ x â‰¤ y ^ n
(âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
category_theory.presheaf.is_sheaf J (J.plus_obj P)
proper_space E
filter.tendsto (Î» (i : Î¹), âˆ«â» (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
âˆƒ (v : Î¹ â†’ set X), set.Union v = set.univ âˆ§ (âˆ€ (i : Î¹), is_open (v i)) âˆ§ âˆ€ (i : Î¹), closure (v i) âŠ† u i
subfield.map f (subfield.closure s) = subfield.closure (â‡‘f '' s)
emetric.diam s â‰¤ d
(â‡‘(orientation.map (fin 2) f.to_linear_equiv) o).oangle x y = o.oangle (â‡‘(f.symm) x) (â‡‘(f.symm) y)
cardinal.mk â†¥s â‰¤ cardinal.continuum â†’ cardinal.mk â†¥{t : set Î± | measurable_set t} â‰¤ cardinal.continuum
is_GÎ´ s
function.injective â‡‘(ring.direct_limit.of G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h)) i)
â‡‘(algebra.norm K) Î¶ = 1
âˆ¥h.comp fâˆ¥ â‰¤ âˆ¥hâˆ¥ * âˆ¥fâˆ¥
Î¼ = (â‡‘Î¼ E / â‡‘Î½ E) â€¢ Î½
summable f
affine_independent k (Î» (x : â†¥s), â†‘x)
category_theory.sieve.generate (Top.presheaf.presieve_of_covering U) âˆˆ â‡‘(opens.grothendieck_topology â†¥X) (supr U)
âˆ¥f.mk_continuous C Hâˆ¥ â‰¤ linear_order.max C 0
b âˆˆ list.map f l â†’ (âˆƒ (a : Î±), a âˆˆ l âˆ§ f a = b)
complete_lattice.independent f â†” finset.univ.sup_indep f
is_add_right_regular (a + b)
g '' (f '' s) = (Î» (x : Î±), g (f x)) '' s
âˆƒ (V : set (Î± Ã— Î±)) (H : V âˆˆ uniformity Î±), is_open V âˆ§ âˆ€ (x : Î±), x âˆˆ K â†’ uniform_space.ball x V âŠ† U
âˆƒ (Ï€ : box_integral.tagged_prepartition I), Ï€.is_partition âˆ§ Ï€.is_Henstock âˆ§ Ï€.is_subordinate r âˆ§ (âˆ€ (J : box_integral.box Î¹), J âˆˆ Ï€ â†’ (âˆƒ (m : â„•), âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m)) âˆ§ Ï€.distortion = I.distortion
disjoint s t â†’ 1 âˆ‰ s / t
is_unit (â‡‘(power_series.constant_coeff R) Ï†)
continuous_on f (emetric.ball x r)
â‡‘(p.succ_above) i = i.succ
is_GÎ´ {x : Î± | continuous_at f x}
v âˆˆ vector_span k (set.range p) â†” âˆƒ (s : finset Î¹) (w : Î¹ â†’ k) (h : s.sum (Î» (i : Î¹), w i) = 0), v = â‡‘(s.weighted_vsub p) w
filter.tendsto f l lb â†’ â†‘f.tendsto lb
(âˆƒ (fs : finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = 1), p0 = â‡‘(fs.affine_combination p) w) â†” âˆƒ (fs : finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = 1), p0 = â‡‘(fs.affine_combination (Î» (i : â†¥s), p â†‘i)) w
add_le_cancellable a â†” a â‰  âŠ¤
linear_order.min (polynomial.root_multiplicity a p) (polynomial.root_multiplicity a q) â‰¤ polynomial.root_multiplicity a (p + q)
has_dist.dist x y + has_dist.dist y z = has_dist.dist x z â†” y âˆˆ segment â„ x z
x âˆˆ set.exposed_points ğ•œ A â†” is_exposed ğ•œ A {x}
âˆƒ (L L' : list (matrix.transvection_struct (fin r âŠ• unit) ğ•œ)) (D : fin r âŠ• unit â†’ ğ•œ), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
a + b - b â‰¤ a
has_fpower_series_on_ball f (cauchy_power_series f z â†‘R) z âŠ¤
âˆ€á¶  (y : Î±) in nhds a, f â‰¤á¶ [nhds y] g
has_dist.dist x y = metric.Hausdorff_dist â†‘x â†‘y
f (ite P x (f x)) = ite (Â¬P) x (f x)
measure_theory.strongly_measurable f
prime power_series.X
category_theory.limits.has_limits_of_shape J C
cont_diff ğ•œ n prod.snd
â‡‘(reflection K) x = x â†” x âˆˆ K
â‡‘(fin.add_nat m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.add_nat m) i)
0 â‰¤ exp_neg_inv_glue x
a - b < a - c â†” c < b
function.surjective â‡‘(I.quotient_map (algebra_map R S) H)
category_theory.limits.has_colimits Cáµ’áµ–
p x
(f1 + f2).prod g = f1.prod g * f2.prod g
r x y â†’ x = y
ideal.map â†‘(f.symm) (ideal.map â†‘f I) = I
false
âˆƒ (x : G), order_of x = p
âˆƒ (K : nnreal), antilipschitz_with K â‡‘f
cardinal.mk (â†¥ğ’«s) = 2 ^ cardinal.mk â†¥s
convex_on ğ•œ s f
even (finset.filter (Î» (v : V), odd (G.degree v)) finset.univ).card
continuous_at f x â†” continuous_at (f âˆ˜ â‡‘e) (â‡‘(e.symm) x)
continuous_linear_map.id ğ•œ E = K.subtypeL.comp (orthogonal_projection K) + Ká—®.subtypeL.comp (orthogonal_projection Ká—®)
(finset.range n).sum (Î» (k : â„•), f k) = s n
â‡‘((finset.map e sâ‚‚).weighted_vsub p) w = â‡‘(sâ‚‚.weighted_vsub (p âˆ˜ â‡‘e)) (w âˆ˜ â‡‘e)
circle_integrable (Î» (z : â„‚), (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ w âˆ‰ metric.sphere c |R|
a â‹– b â†’ â†‘a â‹– â†‘b
category_theory.projective M
a + b < c â†’ a < c - b
function.is_fixed_pt f^[n] x
âˆ‘' (b : â†¥s), â‡‘Î¼ (f â»Â¹' {â†‘b}) = â‡‘Î¼ (f â»Â¹' s)
cont_diff_on ğ•œ â†‘(n + 1) fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ â†‘n (deriv fâ‚‚) sâ‚‚
category_theory.epi f
cont_diff_on ğ•œ âŠ¤ f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ âŠ¤ (Î» (y : E), fderiv ğ•œ f y) s
âˆƒ (K : set Î±) (H : K âŠ† U), is_compact K âˆ§ r < â‡‘Î¼ K
(âˆ€ (x : â„•), x < t.fresh_index â†’ v x = w x) â†’ omega.nat.preterm.val v t = omega.nat.preterm.val w t
has_dist.dist x y = (has_edist.edist x y).to_real
âˆƒ (S : L.elementary_substructure M), s âŠ† â†‘S âˆ§ (cardinal.mk â†¥S).lift = Îº.lift
strict_mono f âˆ§ set.range f = S â†” f = ordinal.enum_ord S
(omega.eq_elim ee c).unsat â†’ c.unsat
measure_theory.integrable â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) (measure_theory.indicator_const_Lp 2 hs hÎ¼s x)) Î¼
f.range = âŠ¤
â†‘(affine_span k {p}) = {p}
a.size_up_to (b.size_up_to i + j) = (a.gather b).size_up_to i + (a.sigma_composition_aux b âŸ¨i, _âŸ©).size_up_to j
(Î³â‚.prod Î³â‚‚).trans (Î´â‚.prod Î´â‚‚) = (Î³â‚.trans Î´â‚).prod (Î³â‚‚.trans Î´â‚‚)
is_unit f
cont_mdiff_within_at I I'' n (g âˆ˜ f) s x
is_regular (a * b) âˆ§ is_regular (b * a) â†” is_regular a âˆ§ is_regular b
âˆƒ (v : Î±) (H : v âˆˆ K), filter.tendsto u filter.at_top (nhds v)
topological_space.is_topological_basis s
minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ m)
padic_norm p â†‘q = 1
bâ»Â¹ * a < c â†’ a < b * c
add_con.add_ker coe _ = c
finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒ (i : Î¹), t i), f a)) = finprod (Î» (i : Î¹), finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ t i), f a)))
cont_diff ğ•œ n (prod.map f g)
A âˆˆ i.ess_image
filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
â‡‘measure_theory.measure.count s = âŠ¤
S.functor_inclusion â‰« g = x â†” (â‡‘category_theory.presieve.nat_trans_equiv_compatible_family x).val.is_amalgamation (â‡‘category_theory.yoneda_equiv g)
box_integral.prepartition.split I i x = âŠ¤
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i * g i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), g i))
(â†‘n)â»Â¹ â€¢ s â€¢ x = s â€¢ (â†‘n)â»Â¹ â€¢ x
cardinal.mk â†¥set.univ = cardinal.mk R ^ 4
f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
s.min' _ < s.max' _
is_totally_disconnected set.univ
(G.map_homological_complex c).map (homotopy.null_homotopic_map hom) = homotopy.null_homotopic_map (Î» (i j : Î¹), G.map (hom i j))
f = g
âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L1_clm hm Î¼) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ o.oangle x y = 0
â‡‘fin.cast_succ i < p âˆ¨ p â‰¤ â‡‘fin.cast_succ i
0 < â‡‘fin.cast_succ i
has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = 0
âˆ¥normed_group_hom.equalizer.lift Ï† hâˆ¥ â‰¤ C
p âˆ£ L.prod â†” âˆƒ (a : M) (H : a âˆˆ L), p âˆ£ a
âˆ¥0âˆ¥ = 0
1 < a * b
âˆƒ (V : topological_space.opens â†¥X) (i : V âŸ¶ U) (hxV : x.val âˆˆ V), is_unit (â‡‘(X.to_PresheafedSpace.presheaf.map i.op) f)
category_theory.limits.has_colimit F
emetric.Hausdorff_edist s t â‰  âŠ¤
x < y â†’ f y - f x < C * (y - x)
a âˆˆ s
Y' âˆˆ F.ess_image
filter.tendsto (Î» (n : Î¹), âˆ« (x : â„) in a..b, F n x âˆ‚Î¼) l (nhds (âˆ« (x : â„) in a..b, f x âˆ‚Î¼))
p x
âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ < âˆ« (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
â‡‘f x = â‡‘g x
disjoint (f.generalized_eigenrange Î¼ (finite_dimensional.finrank K V)) (â‡‘(f.generalized_eigenspace Î¼) (finite_dimensional.finrank K V))
algebra.discr A ((P.map â‡‘(algebra_map A B)).mul_vec b) = P.det ^ 2 * algebra.discr A b
function.update f a' b a = ite (a = a') b (f a)
(âˆ€á¶  (x : Î±) in l, p x) â†’ (âˆ€á¶  (s : set Î±) in l.small_sets, âˆ€ (x : Î±), x âˆˆ s â†’ p x)
â‡‘(fin.cast h) i.succ = (â‡‘(fin.cast _) i).succ
(cardinal.sup f).lift â‰¤ (cardinal.sup f').lift
function.surjective â‡‘(finsupp.total M M R id)
f âˆˆ A.topological_closure
(Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ b) =o[li] m
â‡‘Î¼ (measure_theory.to_measurable Î¼ t âˆ© s) = â‡‘Î¼ (t âˆ© s)
finset.univ.sum (Î» (v : V), G.degree v) = 2 * G.edge_finset.card
((category_theory.equalizer.first_obj_eq_family P â‡‘S).hom x).compatible â†” category_theory.equalizer.sieve.first_map P S x = category_theory.equalizer.sieve.second_map P S x
function_field.class_number Fq F = 1 â†” is_principal_ideal_ring â†¥(function_field.ring_of_integers Fq F)
closure (set.Iio a) = set.Iic a
affine_independent k p â†” Â¬collinear k (set.range p)
ring_char F = 2 â†” fintype.card F % 2 = 0
f z = f w
category_theory.is_iso (category_theory.limits.equalizer.Î¹ f g)
set.surj_on f s (set.interval (f a) (f b))
char.quadratic_char F a = -1 â†” Â¬is_square a
continuous â‡‘(add_monoid_hom.mul_left x)
p âˆ¨ Â¬p
âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C * a ^ n
category_theory.is_connected J
l.sum âˆˆ s
â‡‘((p.bind f).to_measure) s = âˆ‘' (a : Î±), â†‘(â‡‘p a) * â‡‘((f a).to_measure) s
1 âˆˆ H
category_theory.is_cofiltered D
vector_span k s = submodule.span k ((Î» (_x : P), _x -áµ¥ p) '' (s  {p}))
is_R_or_C.abs (has_inner.inner x y) * is_R_or_C.abs (has_inner.inner y x) â‰¤ â‡‘is_R_or_C.re (has_inner.inner x x) * â‡‘is_R_or_C.re (has_inner.inner y y)
a â‰¡ b [MOD m]
p x
âˆƒ (i : Î¹), f i < a
cont_diff_within_at ğ•œ n (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) (â‡‘(e.symm) x) â†” cont_diff_within_at ğ•œ n f s x
f = g
R.final
filter.tendsto (Î» (x : â„), real.exp (b * x) / x ^ s) filter.at_top filter.at_top
(s.prod (Î» (i : Î¹), f i)).leading_coeff = s.prod (Î» (i : Î¹), (f i).leading_coeff)
Top.presheaf.presieve_of_covering_aux (Top.presheaf.covering_of_presieve Y R) Y = R
finset.univ.sum (Î» (x : Î±), f x) = finset.univ.sum (Î» (x : Î²), g x)
cont_diff_within_at ğ•œ n (â‡‘g âˆ˜ f) s x
Ïƒ âˆˆ E.fixing_subgroup â†” âˆ€ (x : L), x âˆˆ E â†’ â‡‘Ïƒ x = x
g1 = g2
function.injective f
â‡‘(Î¼ - Î½) s = â‡‘Î¼ s - â‡‘Î½ s
set.image2 f s t = set.image2 f' s t
c = d
category_theory.limits.kernel_subobject f â‰¤ category_theory.limits.kernel_subobject (f â‰« h)
algebraic_geometry.polynomial.image_of_Df f = â‡‘(prime_spectrum.comap polynomial.C) '' (prime_spectrum.zero_locus {f})á¶œ
filter.tendsto (â‡‘Î¼ âˆ˜ s) filter.at_top (nhds (â‡‘Î¼ (â‹‚ (n : Î¹), s n)))
(âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated (s i) t) â†’ is_metric_separated (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) t
f * g = 1 â†” g * f = 1
inner_product_geometry.angle (-x) x = real.pi
has_dist.dist p1 p3 = has_dist.dist p2 p3 â†” has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p3) = has_dist.dist p2 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p3)
t.sum (Î» (c : Î¹), f c) âˆˆ S
F j = F j'
p.radius - â†‘âˆ¥xâˆ¥â‚Š â‰¤ (p.change_origin x).radius
is_prime_pow n â†” âˆƒ (p : R) (k : â„•), prime p âˆ§ p ^ (k + 1) = n
function.periodic (circle_map c R) (2 * real.pi)
has_edist.edist x y â‰¤ has_edist.edist z x + has_edist.edist z y
â‡‘(euclidean_geometry.reflection sâ‚) p = â‡‘(euclidean_geometry.reflection sâ‚‚) p â†” â†‘(â‡‘(euclidean_geometry.orthogonal_projection sâ‚) p) = â†‘(â‡‘(euclidean_geometry.orthogonal_projection sâ‚‚) p)
(list.map (Î» (a : Î±), equiv.perm.prod_extend_right a (Ïƒ a)) l).prod = equiv.prod_congr_right Ïƒ
â‡‘(algebra.norm K) (Î¶ ^ 2 ^ k - 1) = (-2) ^ 2 ^ k
âˆ« (x : fin (n + 1) â†’ â„) in set.Icc a b, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth (b i) x) i) - âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth (a i) x) i)
f =o[l] g â†” âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
a + c < b + d
E.mk_sol init â†‘n = init n
category_theory.presheaf.is_sheaf J P â†” category_theory.presheaf.is_sheaf' J P
sxâ‚.circumcenter = sxâ‚‚.circumcenter
(â¨… (o : option Î²), option.elim a f o) = a âŠ“ â¨… (b : Î²), f b
measure_theory.tendsto_in_measure Î¼ (Î» (n : Î¹), â‡‘(f n)) l â‡‘g
â‡‘e (â‡‘(e.symm) y) = y
âˆƒ (n : â„•) (H : n â‰¥ N), âˆ€ (k : â„•), k < n â†’ u n < u k
g y (â‡‘f y) * (finsupp.erase y f).prod g = f.prod g
p1 -áµ¥ p = p2 -áµ¥ p â†” p1 = p2
x * x + y * y = 0 â†” x = 0 âˆ§ y = 0
a + b < 0
s.card â‰¤ 1
filter.comap (prod.map f f) (uniformity Î²) = filter.principal id_rel
category_theory.is_iso f
fintype.card Î± â‰¡ fintype.card â†¥(mul_action.fixed_points G Î±) [MOD p]
false
is_add_right_regular a
is_add_group_hom (Î» (a : Î±), f a + g a)
monoid.is_torsion_free G â†’ Â¬monoid.is_torsion G
â‡‘(â‡‘(dfinsupp.lsum S) F) (dfinsupp.single i x) = â‡‘(F i) x
g = g' â†” g.h = g'.h âˆ§ g.s = g'.s
filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.Ioi a)) l
continuous f
âˆƒ (l : list F), l.length â‰¤ finite_dimensional.finrank â„ F âˆ§ Ï† = (list.map (Î» (v : F), reflection (submodule.span â„ {v})á—®) l).prod
âˆƒ (b : â†¥M), âˆ€ (i : Î¹), i âˆˆ s â†’ is_localization.is_integer R (â†‘b â€¢ f i)
â‡‘(formal_multilinear_series.id ğ•œ E 1) v = v 0
algebraic_geometry.PresheafedSpace.stalk_map Î± x â‰« category_theory.eq_to_hom _ = category_theory.eq_to_hom _ â‰« algebraic_geometry.PresheafedSpace.stalk_map Î² x'
strict_mono (Î» (x : Î²), f x + g x)
(âˆ€ (a : Î±), a âˆˆ s â†’ b â‰¤ a) â†’ (âˆ€ (w : Î±), b < w â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), a < w)) â†’ has_Inf.Inf s = b
â‡‘f â»Â¹' S = â‡‘(f.symm) '' S
gauge s (r â€¢ x) = |r| â€¢ gauge s x
âˆ¥fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C
continuous f
metric.diam s â‰¤ metric.diam t
(has_Inf.Inf S).to_setoid = has_Inf.Inf (add_con.to_setoid '' S)
x * infi f = â¨… (i : Î¹), x * f i
is_add_hom â‡‘h
â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w + y) (x + z)
topological_space.separable_space â†¥s
linear_independent R coe â†’ cardinal.mk â†¥s â‰¤ â†‘n
S = T
x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
tendsto_locally_uniformly_on F f p s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ âˆ€ (x : Î²), x âˆˆ s â†’ (âˆƒ (t : set Î²) (H : t âˆˆ nhds_within x s), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_edist.edist (f y) (F n y) < Îµ)
category_theory.limits.initial_mono_class C
well_founded empty_relation
filter.tendsto (Î» (x : Î±), (f x)â»Â¹) l (nhds yâ»Â¹)
filter.tendsto x l f
g '' set.image2 f s t = set.image2 f' (g' '' s) t
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i + g i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), g i))
M.mul (matrix.pivot.list_transvec_row M).prod i (sum.inr ()) = M i (sum.inr ())
conformal_at f z
module.is_torsion_by R M a â†” submodule.torsion_by R M a = âŠ¤
eâ‚.orientation = eâ‚‚.orientation â†” 0 < â‡‘(eâ‚.det) â‡‘eâ‚‚
âˆƒ (Ï€ : K), â‡‘(v.valuation) Ï€ = â†‘(â‡‘multiplicative.of_add (-1))
l.attach.nodup â†’ l.nodup
â‡‘(fderiv_within â„ f s a) y = 0
is_unit (â‡‘(mv_power_series.constant_coeff Ïƒ R) Ï†)
is_fraction_ring.num A r âˆ£ p.coeff 0
âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
âˆ«â» (x : G), f (x * g) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
is_integral R x
algebraic_geometry.structure_sheaf.comap (ring_hom.id R) U V _ = (algebraic_geometry.Spec.structure_sheaf R).val.map iVU.op
x âˆˆ add_monoid.closure (s âˆª t) â†” âˆƒ (y : M) (H : y âˆˆ add_monoid.closure s) (z : M) (H : z âˆˆ add_monoid.closure t), y + z = x
âˆ¥x + yâˆ¥ = âˆ¥x - yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
is_open (metric.thickening Î´ E)
bdd_above s â†’ bdd_below (f '' s)
u.step.v = u.v.swap
s âŠ† span_points k s
order.succ a < order.succ b â†’ a < b
a âˆˆ s
set.eq_on f 0 {z : â„‚ | z.re â‰¤ 0 âˆ§ 0 â‰¤ z.im}
filter.tendsto f filter.at_top filter.at_top
differentiable ğ•œ f â†’ mdifferentiable (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f
(1 - 1 / a)â»Â¹ â‰¤ 2
is_lie_abelian â†¥(lie_algebra.radical R L) â†” âˆ€ (I : lie_ideal R L), lie_algebra.is_solvable R â†¥I â†’ is_lie_abelian â†¥I
category_theory.limits.has_limits_of_size D
âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
is_smul_regular M (a â€¢ s)
H = âŠ¤
(matrix.from_blocks A B C D).is_symm
âˆƒ (n : â„•), âˆ€ (m' : M), m' âˆˆ hindman.FP (stream.drop n a) â†’ m * m' âˆˆ hindman.FP a
hb.oangle x y = Î¸ â†” âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(hb.rotation Î¸) x
is_least {t : convex_cone ğ•œ E | s âŠ† â†‘t} (convex.to_cone s hs)
â‡‘(iterated_fderiv_within ğ•œ n f s x) m = finset.univ.prod (Î» (i : fin n), m i) â€¢ iterated_deriv_within n f s x
â‡‘clifford_algebra_complex.of_complex (â‡‘(star_ring_end â„‚) c) = â‡‘clifford_algebra.involute (â‡‘clifford_algebra_complex.of_complex c)
âˆƒ (Î¸ : real.angle), f = hb.rotation Î¸ âˆ¨ f = hb.conj_lie.trans (hb.rotation Î¸)
filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
s.prod (Î» (i : Î¹), z i ^ â†‘(w i)) â‰¤ s.sum (Î» (i : Î¹), w i * z i)
transcendental â„¤ x
0 < âˆ« (x : â„) in a..b, f x
SemiNormedGroup.explicit_cokernel_desc condb â‰« g = SemiNormedGroup.explicit_cokernel.map h â‰« SemiNormedGroup.explicit_cokernel_desc condd
â‡‘polynomial.to_laurent p = finsupp.map_domain coe p.to_finsupp
âˆƒ (K : nnreal) (t : set E) (H : t âˆˆ nhds_within x s), lipschitz_on_with K f t
m âˆˆ submodule.span R s â†” âˆƒ (c : M â†’â‚€ R), â†‘(c.support) âŠ† s âˆ§ c.sum (Î» (mi : M) (r : R), r â€¢ mi) = m
topological_space.induced f âŠ¥ = âŠ¥
measure_theory.smul_invariant_measure â†¥(Î“.opposite) G Î¼
filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
formal_multilinear_series.id ğ•œ E n = 0
lipschitz_with C (bounded_continuous_function.comp G H)
turing.list_blank.cons l.head l.tail = l
f '' a âŠ† f '' b
add_subgroup.comap f H.normalizer â‰¤ (add_subgroup.comap f H).normalizer
category_theory.is_iso (category_theory.limits.colimit.Î¹ F j)
has_dist.dist (f t) (g t) â‰¤ gronwall_bound Î´ K (Îµf + Îµg) (t - a)
â‡‘(c âŠ“ d) x y â†” â‡‘c x y âˆ§ â‡‘d x y
algebra.finite_presentation R B
âˆƒ (i j : Î¹) (w' : free_product.neword M i j), w'.to_word = w
X.Î´ (â‡‘fin.cast_succ i) â‰« X.Ïƒ j.succ = X.Ïƒ j â‰« X.Î´ i
cont_diff ğ•œ n f
âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) < b
power_series.exp A ^ k = â‡‘(power_series.rescale â†‘k) (power_series.exp A)
has_strict_fderiv_at g â†‘(f'.symm) a
algebra.adjoin R (â‹ƒ (f : monoid_algebra R M) (H : f âˆˆ S), â‡‘(monoid_algebra.of R M) '' â†‘(f.support)) = âŠ¤
âˆƒ (Î¦ : X â†’ â†¥(lp (Î» (n : â„•), â„) âŠ¤)) (Î¨ : Y â†’ â†¥(lp (Î» (n : â„•), â„) âŠ¤)), isometry Î¦ âˆ§ isometry Î¨ âˆ§ Gromov_Hausdorff.GH_dist X Y = metric.Hausdorff_dist (set.range Î¦) (set.range Î¨)
finite_dimensional K Vâ‚‚
â‡‘(â‡‘f'' v) w = â‡‘(â‡‘f'' w) v
r âŠ” s = eqv_gen.setoid (Î» (x y : Î±), r.rel x y âˆ¨ s.rel x y)
(â¨… (i : Î¹'), s i) = â¨… (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
âˆƒ (Î¸ : real.angle), f = hb.conj_lie.trans (hb.rotation Î¸)
category_theory.limits.has_limit (category_theory.limits.parallel_pair f g)
(f + g).prod h = f.prod h * g.prod h
(âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated (s i) t) â†’ is_metric_separated (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) t
set.eq_on â‡‘f â‡‘g â†‘(submodule.span R s)
p1 = p2
u = E.mk_sol init
has_dist.dist p1 p3 = has_dist.dist p1 p2 + has_dist.dist p3 p2
mdifferentiable_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x â†” differentiable_within_at ğ•œ f s x
measure_theory.simple_func.integral Î¼ (measure_theory.simple_func.map g f) = f.range.sum (Î» (x : E), (â‡‘Î¼ (â‡‘f â»Â¹' {x})).to_real â€¢ g x)
mul_opposite.op (x ^ n) = mul_opposite.op x ^ n
âˆƒ (x : Î±) (H : x âˆˆ s), f x â‰  0
âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), â‡‘f x â‰¤ g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚Î¼ + Îµ
b ^ c â‰¤ x â†” c â‰¤ ordinal.log b x
group.is_nilpotent G â†” âˆƒ (n : â„•) (H : â„• â†’ subgroup G), is_descending_central_series H âˆ§ H n = âŠ¥
measure_theory.strongly_measurable (Î» (y : Î²), âˆ« (x : Î±), f (x, y) âˆ‚Î¼)
(has_insert.insert a s).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
function.injective fin
ae_measurable f Î¼
has_star.star (x * y) = has_star.star x * has_star.star y
filter.tendsto f (l âŠ“ filter.principal s) (nhds a) â†” filter.tendsto f l (nhds a)
submodule.torsion_by_set R M s = submodule.torsion_by_set R M â†‘(ideal.span s)
âˆ¥normed_group_hom.id Vâˆ¥ = 1
cardinal.mk K = cardinal.mk Î¹
con.ker c.mk' = c
a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d
(â¨† (x : Î±), nhds (x, x)) â‰¤ uniformity Î±
(measure_theory.outer_measure.mk_metric' m).is_metric
â‡‘f xâ‚ * â†‘(â‡‘(is_unit.lift_right (f.restrict S) h) yâ‚)â»Â¹ = â‡‘f xâ‚‚ * â†‘(â‡‘(is_unit.lift_right (f.restrict S) h) yâ‚‚)â»Â¹ â†” â‡‘f (xâ‚ * â†‘yâ‚‚) = â‡‘f (xâ‚‚ * â†‘yâ‚)
cont_diff ğ•œ n (Î» (x : E), -f x)
minpoly A x âˆ£ P
p = pâ‚ âˆ¨ p = pâ‚‚
s.monge_plane iâ‚ iâ‚‚ = affine_subspace.mk' (finset.centroid â„ {iâ‚, iâ‚‚}á¶œ s.points) (submodule.span â„ {s.points iâ‚ -áµ¥ s.points iâ‚‚})á—® âŠ“ affine_span â„ (set.range s.points)
f.comp_linear_map linear_map.id = f
cont_diff_on ğ•œ n (g âˆ˜ f) s
u = v â†” list.of_fn (Î» (i : fin u.fst.length), (u.snd i).blocks) = list.of_fn (Î» (i : fin v.fst.length), (v.snd i).blocks)
x âˆˆ list.nat.antidiagonal n â†” x.fst + x.snd = n
interval_integrable (Î» (x : â„), xâ»Â¹) measure_theory.measure_space.volume a b â†” a = b âˆ¨ 0 âˆ‰ set.interval a b
dense (f '' s)
ext_chart_at (model_with_corners_self ğ•œ E) x = local_equiv.refl E
Â¬interval_integrable g measure_theory.measure_space.volume a b
cont_diff_at ğ•œ n â‡‘(f.symm) a
pairwise (Î» (x y : â†¥s), r â†‘x â†‘y) â†’ s.pairwise r
matrix.circulant (Î» (i : fin n), ite (â†‘i = 0) 1 0) = 1
âˆƒ (w : m â†’ R), matrix.dot_product v (M.mul_vec w) â‰  0
âˆ¥âˆ‘' (n : â„•), x ^ nâˆ¥ â‰¤ âˆ¥1âˆ¥ - 1 + (1 - âˆ¥xâˆ¥)â»Â¹
(h.comp g).comp f = h.comp (g.comp f)
is_compact (f '' s) â†” is_compact s
affine_span k sâ‚ â‰¤ affine_span k sâ‚‚
function.bijective â‡‘f
â‡‘(dfinsupp.sum_add_hom Ï†) f = f.sum (Î» (x : Î¹), â‡‘(Ï† x))
a ^ 2 = a * a
(â†‘n)â»Â¹ â€¢ s â€¢ x = s â€¢ (â†‘n)â»Â¹ â€¢ x
linear_independent R coe â†’ linear_independent R f
affine_independent k p â†” Â¬finite_dimensional.finrank k â†¥(vector_span k (set.range p)) â‰¤ n
continuous_on (extend_from A f) B
p x hx
has_inner.inner (s.monge_point -áµ¥ finset.centroid â„ {iâ‚, iâ‚‚}á¶œ s.points) (s.points iâ‚ -áµ¥ s.points iâ‚‚) = 0
absorbent ğ•œ A
t = s.singular_part Î¼
cont_diff ğ•œ n b
c = d
category_theory.limits.has_colimits_of_size C
has_deriv_at (exp_neg_inv_glue.f_aux n) (exp_neg_inv_glue.f_aux (n + 1) x) x
polynomial.cyclotomic (n * p) R = polynomial.cyclotomic n R ^ (p - 1)
deriv (Î» (u : â„), âˆ« (x : â„) in u..b, f x) a = -f a
box_integral.integrable J l f vol
cont_diff_at ğ•œ n (Î» (x : E), f x - g x) x
âˆ« (x : â„) in a..b, real.sin x ^ (2 * m + 1) * real.cos x ^ n = âˆ« (u : â„) in real.cos b..real.cos a, u ^ n * (1 - u ^ 2) ^ m
âˆƒ (f : Î¹ â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
f â‰« homotopy.null_homotopic_map hom = homotopy.null_homotopic_map (Î» (i j : Î¹), f.f i â‰« hom i j)
cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_diff_within_at ğ•œ n (written_in_ext_chart_at I I' x f) (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I) (â‡‘(ext_chart_at I x) x)
0 â‰¤ -a â†’ a â‰¤ 0
(s âˆ© t).nonempty
âˆ¥f.comp g.to_linear_isometry.to_continuous_linear_mapâˆ¥ = âˆ¥fâˆ¥
â†‘(â‡‘(fin.cast h) i) = â†‘i
â‡‘(â‡‘dfinsupp.lift_add_hom f) (dfinsupp.single i x) = â‡‘(f i) x
âˆƒ (a : â†¥s â†’â‚€ R) (ha : âˆ€ (i : â†¥s), â‡‘a i âˆˆ I), a.sum (Î» (i : â†¥s) (c : R), c â€¢ f â†‘i) = x
continuous_within_at f (set.Ici a) a
0 âˆˆ s
hb.oangle y z = 2 â€¢ hb.oangle (y - x) (z - x)
â†‘âŠ¥ = âˆ…
a âˆ£ b
is_integral R x
semiconj_by 1 x x
char_zero A
k = l
(â¨† (Î¼ : ğ•œ), module.End.eigenspace T Î¼)á—® = âŠ¥
R (m (sâ‚ âŠ” sâ‚‚)) (m sâ‚ + m sâ‚‚)
category_theory.limits.image_subobject (h â‰« f) â‰¤ category_theory.limits.image_subobject f
âˆ¥dslope f c zâˆ¥ â‰¤ Râ‚‚ / Râ‚
a * b < 1
â‡‘(convex_hull R) s = â‡‘(finset.univ.sum (Î» (x : â†¥s), (linear_map.proj x).smul_right x.val)) '' std_simplex R â†¥s
â‡‘polynomial.derivative (polynomial.evalâ‚‚ polynomial.C q p) = polynomial.evalâ‚‚ polynomial.C q (â‡‘polynomial.derivative p) * â‡‘polynomial.derivative q
ring_subgroups_basis (Î» (Î³ : Î“â‚€Ë£), v.lt_add_subgroup Î³)
inseparable x y â†’ nhds x = nhds y
â‡‘(â‡‘(matrix.to_lin vâ‚ vâ‚ƒ) (A.mul B)) x = â‡‘(â‡‘(matrix.to_lin vâ‚‚ vâ‚ƒ) A) (â‡‘(â‡‘(matrix.to_lin vâ‚ vâ‚‚) B) x)
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.weighted_vsub pâ‚) w - â‡‘(s.weighted_vsub pâ‚‚) w
âŠ¥ = âŠ¤
p (finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)))
deriv_within (Î» (u : â„), âˆ« (x : â„) in u..b, f x) s a = -f a
lower_semicontinuous_within_at (Î» (z : Î±), f z + g z) s x
set.eq_on f 0 (complex.re â»Â¹' set.Icc a b)
bdd_above s â†” small â†¥s
P = Q
a = b âˆ¨ a < b
y âˆˆ add_submonoid.closure {x} â†” âˆƒ (n : â„•), n â€¢ x = y
0 < a * b
linear_independent ğ•œ v
continuous_at (Î» (x : Î±), h x (f x / g x)) a
complete_lattice.independent (â‡‘f âˆ˜ a)
category_theory.is_iso A.str
â‡‘(algebra.trace R S) (â‡‘(algebra_map R S) x) = fintype.card Î¹ â€¢ x
function.surjective â‡‘(mv_polynomial.aeval (Î» (s : â†¥S), â‡‘(monoid_algebra.of R M) â†‘s))
algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p - 1) / 2) * â†‘p ^ (â†‘p - 2)
has_inner.inner (â‡‘(â‡‘linear_map.adjoint A) y) x = has_inner.inner y (â‡‘A x)
dense (f '' t)á¶œ
group.nilpotency_class (Gâ‚ Ã— Gâ‚‚) = linear_order.max (group.nilpotency_class Gâ‚) (group.nilpotency_class Gâ‚‚)
s.sum (Î» (i : Î¹), f i â€¢ g i) < s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â†” Â¬antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
s.sum (Î» (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), g i ^ p) ^ (1 / p)
has_dist.dist x y = â†‘(has_nndist.nndist x y)
{x : Î± | âˆƒ (y : Î±), x < y âˆ§ set.Ioo x y = âˆ…}.countable
linear_independent R (fin.cons x v)
s âŠ† â†‘(add_submonoid.closure s)
(list.map f (list.range n.succ)).prod = f 0 * (list.map (Î» (i : â„•), f i.succ) (list.range n)).prod
is_bounded_bilinear_map ğ•œ (Î» (p : ğ•œ' Ã— ğ•œ'), â‡‘(â‡‘(continuous_linear_map.lmul_left_right ğ•œ ğ•œ') p.fst) p.snd)
a â€¢ interior s + b â€¢ closure s âŠ† interior s
(s + 1).Gamma_integral = s * s.Gamma_integral
f âˆˆ ideal.map polynomial.C I â†” âˆ€ (n : â„•), f.coeff n âˆˆ I
category_theory.is_idempotent_complete C â†” category_theory.is_idempotent_complete D
0 < 2
l.nodup â†’ l.attach.nodup
âˆƒ! (x : X), f x = y
iterated_fderiv ğ•œ (n + 1) f = â‡‘(continuous_multilinear_curry_left_equiv ğ•œ (Î» (i : fin (n + 1)), E) F) âˆ˜ fderiv ğ•œ (iterated_fderiv ğ•œ n f)
is_GÎ´ (â‹‚ (i : Î¹), s i)
(matrix.mv_polynomial_X m m R).det â‰  0
âˆƒ (n : â„•) (e : M â†’ euclidean_space â„ (fin n)), smooth I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e âˆ§ closed_embedding e âˆ§ âˆ€ (x : M), function.injective â‡‘(mfderiv I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e x)
(finset.image quotient.mk s.off_diag).card = s.card.choose 2
category_theory.limits.has_colimit F
p = 0
is_submonoid (sâ‚ âˆ© sâ‚‚)
â‡‘(polynomial.aeval x) (minpoly A x) = 0
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t  s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
a = 0
aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
finite_dimensional.finrank K V = 0 â†” subsingleton V
monoid.fg M
C p q
metric.closed_ball x Î´ âŠ† metric.cthickening Î´ E
F = G
(Î» (h : â„), f (x + h â€¢ (2 â€¢ v + 2 â€¢ w)) + f (x + h â€¢ (v + w)) - f (x + h â€¢ (2 â€¢ v + w)) - f (x + h â€¢ (v + 2 â€¢ w)) - h ^ 2 â€¢ â‡‘(â‡‘f'' v) w) =o[nhds_within 0 (set.Ioi 0)] Î» (h : â„), h ^ 2
algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = (-1) ^ ((â†‘p ^ k).totient / 2) * â†‘p ^ (â†‘p ^ (k - 1) * ((â†‘p - 1) * k - 1))
âˆ¥c.smul_right fâˆ¥â‚Š = âˆ¥câˆ¥â‚Š * âˆ¥fâˆ¥â‚Š
r â€¢ x * y = r â€¢ (x * y)
category_theory.is_pullback c.fst c.snd f g
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ t), f i j)))) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ t), finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i j))))
pairwise (Î» (i j : I), âˆ€ (x : f i) (y : f j), commute (pi.mul_single i x) (pi.mul_single j y))
âˆƒ (C' : â„), âˆ€ (i : Î¹), âˆ¥g iâˆ¥ â‰¤ C'
category_theory.bicategory.whisker_left ((category_theory.free_bicategory.preinclusion B).map {as := p}) Î· â‰« (category_theory.free_bicategory.normalize_iso p g).hom = (category_theory.free_bicategory.normalize_iso p f).hom â‰« (category_theory.free_bicategory.preinclusion B).mapâ‚‚ (category_theory.eq_to_hom _)
algebraic_geometry.structure_sheaf.comap (ring_hom.id R) U V _ = category_theory.eq_to_hom _
0 < a + b
s.fg â†” finite_dimensional K â†¥s
s âˆˆ ğ’œ.shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ) (a : Î±) (H : a âˆˆ t), t.erase a = s
metric.inf_dist x s = 0
category_theory.is_iso f
p x y
embedding â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚)
âˆƒ (eq_1 : (topological_space.opens.map (D.to_glue_data.t k i).base).op.obj (opposite.op (_.open_functor.obj U)) = opposite.op (_.open_functor.obj (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))))), _.inv_app U â‰« (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) â‰« (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom eq_1) = (D.to_glue_data.t' k i j).c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U)))
continuous (extend_from A f)
_.inv_app U â‰« (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) = (D.to_glue_data.t' k i j).c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))) â‰« (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom _)
category_theory.presieve.is_sheaf_for P R
is_add_regular a âˆ§ is_add_regular b
is_cyclotomic_extension S A B â†” (âˆ€ (a : â„•+), a âˆˆ S â†’ (âˆƒ (r : B), â‡‘(polynomial.aeval r) (polynomial.cyclotomic â†‘a A) = 0)) âˆ§ algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1} = âŠ¤
uniform_continuous_on f s
-a < -b â†’ b < a
well_founded has_lt.lt
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ g '' s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ s), f (g j)))
â‡‘c x y â†’ â‡‘c y z â†’ â‡‘c x z
s.sum (Î» (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2) â‰¤ âˆ¥xâˆ¥ ^ 2
â‡‘polynomial.C r = â‡‘(algebra_map R (polynomial R)) r
subsingleton (Î± â†’+*o Î²)
x ^ n.totient â‰¡ 1 [MOD n]
âˆ« (x : â„) in t..t + T, f x = âˆ« (x : â„) in s..s + T, f x
Â¬bdd_below s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬x â‰¤ y
has_dist.dist a b ^ 2 * has_dist.dist c p + has_dist.dist a c ^ 2 * has_dist.dist b p = has_dist.dist b c * (has_dist.dist a p ^ 2 + has_dist.dist b p * has_dist.dist c p)
f.limsup (Î» (x : Î²), âŠ¥) = âŠ¥
â†‘(x * y) = â†‘x * â†‘y
s.prod (Î» (a : Î±), f a + g a) = s.powerset.sum (Î» (t : finset Î±), t.prod (Î» (a : Î±), f a) * (s  t).prod (Î» (a : Î±), g a))
bernoulli' n = 0
function.injective â‡‘(x.succ_above)
T.is_satisfiable â†” T.is_finitely_satisfiable
âˆ« (x : fin (n + 1) â†’ â„) in set.Icc a b, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' i x) (pi.single i 1)) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f i (i.insert_nth (b i) x)) - âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f i (i.insert_nth (a i) x))
âˆƒ (v : basis (fin (finite_dimensional.finrank K V)) K V), B.is_Ortho â‡‘v
euclidean_geometry.angle p1 p2 p3 â‰¤ real.pi
a + b - c â‰¤ a + (b - c)
hb.oangle (-x) y = hb.oangle x y + â†‘real.pi
b < a â†’ 0 < a - b
cont_diff_on ğ•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t)
0 â‰¤ metric.inf_dist x s
âˆƒ (e : topological_fiber_bundle.trivialization F proj), set.Icc a b âŠ† e.base_set
irreducible (c 1)
strict_mono (Î» (x : Î²), f x * g x)
â‡‘(0.succ_above) = fin.succ
âˆƒ (f : (â„• â†’ â„•) â†’ Î±), continuous f âˆ§ function.surjective f
f n = n.factorization.prod (Î» (p k : â„•), f (p ^ k))
p * q = p.support.sum (Î» (i : â„•), q.sum (Î» (j : â„•) (a : R), â‡‘(polynomial.monomial (i + j)) (p.coeff i * a)))
g = h
iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x
âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds 0)
g '' set.image2 f s t = set.image2 f' t (g' '' s)
(âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ has_dist.dist (f x) (f y) â‰¤ â†‘K * has_dist.dist x y) â†’ lipschitz_on_with K f s
Â¬is_field â„¤
f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
fderiv â„ f a = 0
a = âŠ¥
free_group.red Lâ‚ ((x1, !b1) :: (x2, b2) :: Lâ‚‚)
l.has_basis (Î» (i : Î¹), p i âˆ§ q i) s
category_theory.presheaf.is_sheaf J P â†” category_theory.presheaf.is_sheaf J (P â‹™ s)
0 < âˆ« (x : â„) in a..b, f x âˆ‚Î¼ â†” a < b âˆ§ 0 < â‡‘Î¼ (function.support f âˆ© set.Ioc a b)
continuous_at f a
pairwise (disjoint on Î» (n : Î±), set.Ico (f (order.succ n)) (f n))
category_theory.is_subterminal A
(âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), g * h) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_mul_left_invariant
module.rank K V â‰¤ 1 â†” âˆƒ (vâ‚€ : V), âˆ€ (v : V), âˆƒ (r : K), r â€¢ vâ‚€ = v
âˆ¥âˆ‘' (i : Î¹), f iâˆ¥ â‰¤ a
âˆƒ (K : set Î±), is_compact K âˆ§ K âˆˆ nhds x
lipschitz_on_with C f s
iterated_deriv_within n f s x = (Î» (g : ğ•œ â†’ F), deriv_within g s)^[n] f x
cont_diff_at ğ•œ n (Î» (x : E), f x + g x) x
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), deriv f c = 0
finset.univ.sum (Î» (i : Î¹), finset.centroid_weights_indicator k s i) = 1
sâ‚ = sâ‚‚
measure_theory.integrable_on g (f '' s) Î¼ â†” measure_theory.integrable_on (Î» (x : E), |(f' x).det| â€¢ g (f x)) s Î¼
continuous_map.to_ae_eq_fun Î¼ f.to_continuous_map âˆˆ measure_theory.Lp E p Î¼
has_inner.inner (â‡‘(finsupp.total Î¹ E ğ•œ v) l) (v i) = 0
âˆƒ (G : finset M), algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â†‘G) = âŠ¤
(l.nth 0).get_or_else 1 * l.tail.prod = l.prod
uniform_embedding f
ratfunc.eval f a (x * y) = ratfunc.eval f a x * ratfunc.eval f a y
function.injective (Top.stalk_to_fiber P x)
1 < a * b
1.order = 0
ğŸ™ P = P.decomp_id_i â‰« P.decomp_id_p
v.last = v.nth (fin.last n)
dense_inducing (Î» (p : Î± Ã— Î³), (eâ‚ p.fst, eâ‚‚ p.snd))
is_bounded_bilinear_map ğ•œ (Î» (p : (E â†’L[ğ•œ] ğ•œ) Ã— F), p.fst.smul_right p.snd)
âˆƒ (Î± : Type v) (c : Î± â†’ X) (r : Î  (a : Î±), Î¹ (c a)), (âˆ€ (a : Î±), c a âˆˆ s âˆ§ p (c a) (r a)) âˆ§ (s âŠ† â‹ƒ (a : Î±), B (c a) (r a)) âˆ§ locally_finite (Î» (a : Î±), B (c a) (r a))
cardinal.mk Î² â‰¤ cardinal.mk â†¥(set.range f)
âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ s â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
â‡‘linear_map.adjoint (â‡‘linear_map.adjoint A) = A
mdifferentiable_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s â†” differentiable_on ğ•œ f s
n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b
monotone (Î» (n : N), f (Î¼ m n))
m = m'
â‡‘(Î¼.with_density (v.lim_ratio_meas hÏ)) s â‰¤ â†‘t ^ 2 * â‡‘Ï s
cont_diff_at ğ•œ n (Î» (x : E), (f x).snd) x
summable (Î» (k : â„•), 2 ^ k * f (2 ^ k)) â†” summable f
euclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4
âˆƒ (g : linear_pmap â„ E â„), f < g âˆ§ âˆ€ (x : â†¥(g.domain)), â†‘x âˆˆ s â†’ 0 â‰¤ â‡‘g x
â†‘f.to_monoid_hom = â†‘f.to_monoid_hom
category_theory.limits.has_finite_products (category_theory.over B)
âˆ¥fâˆ¥ = has_Inf.Inf {C : â„ | 0 â‰¤ C âˆ§ âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C}
âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, filter.tendsto (Î» (a : set Î±), â‡‘Î¼ (s âˆ© a) / â‡‘Î¼ a) (v.filter_at x) (nhds 1)
has_dist.dist (f 0) a â‰¤ C
tangent_cone_at ğ•œ (s âˆ© t) x = tangent_cone_at ğ•œ s x
âˆƒ (x : Î±) (H : x âˆˆ s), has_dist.dist x y < r
category_theory.epi f
f' =o[l] g' â†’ ((Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
Ï† = Ïˆ
cont_mdiff I.tangent I'.tangent m (tangent_map I I' f)
order_of (quaternion_group.a i) = 2 * n / (2 * n).gcd i.val
finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.centroid_weights_with_circumcenter fs i) = 1
c â‰¤ d â†” âˆ€ {x y : M}, â‡‘c x y â†’ â‡‘d x y
is_monoid_hom id
finite_dimensional ğ•œ E
b < has_Sup.Sup s
â‡‘multilinear_map.alternatization (a.dom_coprod b) = (â‡‘multilinear_map.alternatization a).dom_coprod (â‡‘multilinear_map.alternatization b)
(x + 0).equiv x
strong_rank_condition R â†” âˆ€ (n : â„•) (f : (fin (n + 1) â†’ R) â†’â‚—[R] fin n â†’ R), Â¬function.injective â‡‘f
padic_norm p â†‘p = 1 / â†‘p
A.mul (â…Ÿ A) = 1
(uv.compress U V A).card = A.card
â‡‘laurent_polynomial.C r = â‡‘(algebra_map R (laurent_polynomial R)) r
p1 = g +áµ¥ p2 â†” p1 -áµ¥ p2 = g
algebra.is_integral R B
(â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) = â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
function.left_inverse â‡‘(mv_polynomial.map f) â‡‘(mv_polynomial.map g)
category_theory.limits.has_colimit G
s âˆ‰ filter.hyperfilter Î±
a * b â‰¤ 1
is_of_fin_order (â‡‘f x)
filter.tendsto (Î» (x : Î²), ((f x).snd, (f x).fst)) l (uniformity Î±)
filter.mapâ‚‚ m (filter.map n f) g = filter.map n' (filter.mapâ‚‚ m' g f)
u ^ 2 = 1
âˆƒ (V : set G) (H : V âˆˆ nhds 0), K + V âŠ† U
[group.is_nilpotent G, normalizer_condition G, âˆ€ (H : subgroup G), is_coatom H â†’ H.normal, âˆ€ (p : â„•), fact (nat.prime p) â†’ âˆ€ (P : sylow p G), â†‘P.normal, nonempty ((Î  (p : â†¥((fintype.card G).factorization.support)) (P : sylow â†‘p G), â†¥â†‘P) â‰ƒ* G)].tfae
filter.tendsto (Î» (n : Î¹), measure_theory.set_to_fun Î¼ T hT (fs n)) l (nhds (measure_theory.set_to_fun Î¼ T hT f))
{o : ordinal | x < b ^ o}.nonempty
âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p
function.surjective f
set.eq_on f g {z : â„‚ | z.re â‰¤ 0 âˆ§ 0 â‰¤ z.im}
â‡‘(polynomial.map_alg R S) p = polynomial.map (algebra_map R S) p
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = s.sum (Î» (i : Î¹), w i) â€¢ (pâ‚ -áµ¥ b) - â‡‘(s.weighted_vsub_of_point pâ‚‚ b) w
commute b a
(uniformity Î±).has_basis p (Î» (x : Î²), {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < f x})
t.prod.leading_coeff = (multiset.map polynomial.leading_coeff t).prod
â†‘S = â†‘T â†” S = T
x.lf z
â‡‘(euclidean_geometry.reflection (affine_span â„ (s.points '' {iâ‚, iâ‚‚}))) s.circumcenter = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.reflection_circumcenter_weights_with_circumcenter iâ‚ iâ‚‚)
category_theory.is_iso f
polish_space.is_clopenable s â†” measurable_set s
filter.comap coe (nhds_within a (set.Ioi a)) = filter.at_bot
polynomial.splits (algebra_map K L) (polynomial.cyclotomic â†‘n K)
v.int_valuation_def (x * y) = v.int_valuation_def x * v.int_valuation_def y
y âˆˆ omega_limit f Ï• s â†” âˆ€ (n : set Î²), n âˆˆ nhds y â†’ (âˆƒá¶  (t : Ï„) in f, (s âˆ© Ï• t â»Â¹' n).nonempty)
lower_semicontinuous_within_at (Î» (z : Î±), f z + g z) s x
has_sum (Î» (n : â„•), â‡‘(cauchy_power_series f c R n) (Î» (_x : fin n), w)) ((2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)
s.pairwise r â†’ âˆ€ â¦ƒa : Î±â¦„, a âˆˆ s â†’ âˆ€ â¦ƒb : Î±â¦„, b âˆˆ s â†’ r a b
g (â¨ (x : Î±) in t, f x âˆ‚Î¼) â‰¤ â¨ (x : Î±) in t, g (f x) âˆ‚Î¼
is_R_or_C.abs (has_inner.inner x y / (â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥)) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : ğ•œ), r â‰  0 âˆ§ y = r â€¢ x
âˆƒ (J : â†¥(non_zero_divisors (ideal S))), â‡‘(class_group.mk0 L) I = â‡‘(class_group.mk0 L) J âˆ§ â‡‘(algebra_map R S) ((class_group.finset_approx bS adm).prod (Î» (m : R), m)) âˆˆ â†‘J
0 < â‡‘Î¼ U
-a < 0 â†’ 0 < a
s âŠ† monoid.closure s
category_theory.limits.has_colimits C
(L.update_nth n a).sum = L.sum + dite (n < L.length) (Î» (hn : n < L.length), -L.nth_le n hn + a) (Î» (hn : Â¬n < L.length), 0)
strict_convex_on ğ•œ s f
c.map_gen f = c.map_of_surjective f H h hf
fixing_subgroup M (â‹ƒ (i : Î¹), s i) = â¨… (i : Î¹), fixing_subgroup M (s i)
â‡‘(measure_theory.measure.haar.haar_content Kâ‚€) Kâ‚€.to_compacts = 1
bdd_above (s âˆª t) â†” bdd_above s âˆ§ bdd_above t
aâ»Â¹ â‰¤ 1 â†’ 1 â‰¤ a
(finset.range n).sum (Î» (k : â„•), â†‘k ^ p) = (finset.range (p + 1)).sum (Î» (i : â„•), bernoulli i * â†‘((p + 1).choose i) * â†‘n ^ (p + 1 - i) / (â†‘p + 1))
â‡‘f â†‘x = â‡‘(algebra_map â„ A) x
âŠ¤ âˆˆ fixed_by_finite K L
t.sum (Î» (i : Î¹), f i) âˆˆ s
C n x hx
f = g â†” âˆ€ (a : Î±), â‡‘f a = â‡‘g a
interior s = âˆ…
F.is_sheaf â†” F.is_sheaf_opens_le_cover
L = L' â†” L.join = L'.join âˆ§ list.map list.length L = list.map list.length L'
differentiable_at ğ•œ f x
âˆ«â» (a : Î±), â†‘((f * g) a) âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), â†‘(f a) ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), â†‘(g a) ^ q âˆ‚Î¼) ^ (1 / q)
metric.cthickening Î´ âˆ… = âˆ…
closure E = â‹‚ (Î´ : â„) (H : Î´ âˆˆ s), metric.cthickening Î´ E
category_theory.limits.has_colimit G
âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
â‡‘(reflection K) p = bit0 â†‘(â‡‘(orthogonal_projection K) p) - p
âˆƒ (Ïˆ : â„• â†’ â„•), strict_mono Ïˆ âˆ§ filter.tendsto (u âˆ˜ Ïˆ) filter.at_top (nhds x)
finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” monovary (f âˆ˜ â‡‘Ïƒ) g
has_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca) (a, b)
f' = 0
is_max_on f s a â†’ is_min_on (â‡‘order_dual.to_dual âˆ˜ f) s a
cont_diff ğ•œ n â‡‘f
Ká—® = â¨… (v : â†¥K), (â‡‘innerSL â†‘v).ker
(category_theory.shift_functor C j).map ((category_theory.shift_functor C i).map f) = (category_theory.shift_comm X i j).hom â‰« (category_theory.shift_functor C i).map ((category_theory.shift_functor C j).map f) â‰« (category_theory.shift_comm Y j i).hom
relation.refl_trans_gen r n m
lipschitz_with âˆ¥fâˆ¥â‚Š â‡‘f
eqv_gen.setoid setoid.r = r
metric.thickening Î´ E âŠ† metric.cthickening Î´ E
â‡‘(has_star.star f) = has_star.star â‡‘f
â‡‘clifford_algebra.reverse x = x
strict_mono_on f D
topological_space.is_topological_basis {U : set â†¥(C.X) | âˆƒ (j : J) (V : set â†¥(F.obj j)), V âˆˆ T j âˆ§ U = â‡‘(C.Ï€.app j) â»Â¹' V}
(âˆ€ (u : set E), u âŠ‡ v â†’ orthonormal ğ•œ coe â†’ u = v) â†” âˆƒ (b : basis â†¥v ğ•œ E), â‡‘b = coe
nhds Î³ = has_pure.pure Î³
s.prod (Î» (i : Î¹), 1 - f i) = 1 - s.sum (Î» (i : Î¹), f i * (finset.filter (Î» (_x : Î¹), _x < i) s).prod (Î» (j : Î¹), 1 - f j))
category_theory.inv (R.map (h.counit.app X)) = h.unit.app (R.obj X)
âˆ® (z : â„‚) in C(c, R), f' z = 0
category_theory.limits.has_pullbacks C
n.desc_factorial k = n.factorial / (n - k).factorial
(has_insert.insert x s).powerset.sum (Î» (a : finset Î±), f a) = s.powerset.sum (Î» (a : finset Î±), f a) + s.powerset.sum (Î» (t : finset Î±), f (has_insert.insert x t))
metric.inductive_limit_dist f x y = has_dist.dist (nat.le_rec_on hx f x.snd) (nat.le_rec_on hy f y.snd)
is_R_or_C.abs (has_inner.inner x y) = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆƒ (r : ğ•œ), r â‰  0 âˆ§ y = r â€¢ x
s âˆˆ ğ’œ.shadow â†” âˆƒ (a : Î±) (H : a âˆ‰ s), has_insert.insert a s âˆˆ ğ’œ
â‡‘f 0 = 0
is_group_hom (g âˆ˜ f)
â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (fintype.pi_finset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
âˆƒ (t : set Î“â‚€) (H : t âˆˆ linear_ordered_comm_group_with_zero.nhds_fun Î“â‚€ x), t âŠ† s âˆ§ âˆ€ (y : Î“â‚€), y âˆˆ t â†’ s âˆˆ linear_ordered_comm_group_with_zero.nhds_fun Î“â‚€ y
x + t â€¢ (y - x) âˆˆ interior s
algebra.is_algebraic A C â†” algebra.is_algebraic K C
ess_sup f (Î¼.restrict s) = ess_sup f Î¼
â‡‘polynomial.C p.leading_coeff * (multiset.map (Î» (a : K), polynomial.X - â‡‘polynomial.C a) p.roots).prod = p
monotone (f âŠ“ g)
R (m (â¨† (b : Î³), s b)) (âˆ‘' (b : Î³), m (s b))
category_theory.is_iso f
emetric.closed_ball x â†‘Îµ = metric.closed_ball x â†‘Îµ
affine_span k s = has_Inf.Inf {s' : affine_subspace k P | s âŠ† â†‘s'}
A.is_hermitian â†” inner_product_space.is_self_adjoint (â‡‘((pi_Lp.linear_equiv Î± (Î» (_x : n), Î±)).symm.conj) (â‡‘matrix.to_lin' A))
has_dist.dist â†‘x â†‘y = has_dist.dist x y
well_founded (relation.game_add rÎ± rÎ²)
probability_theory.variance (s.sum (Î» (i : Î¹), X i)) measure_theory.measure_space.volume = s.sum (Î» (i : Î¹), probability_theory.variance (X i) measure_theory.measure_space.volume)
is_integral R (p.leading_coeff â€¢ x)
n.divisors.prod (Î» (i : â„•), polynomial.cyclotomic i R) = polynomial.X ^ n - 1
âˆƒ (L L' : list (matrix.transvection_struct (fin r âŠ• unit) ğ•œ)), (((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod).is_two_block_diagonal
finset.centroid k s p âˆˆ affine_span k (set.range p)
setoid.is_partition â†‘(f.parts)
primitive_roots n K âŠ† (polynomial.map (int.cast_ring_hom K) (minpoly â„¤ Î¼)).roots.to_finset
fin.tail (fin.init q) = fin.init (fin.tail q)
f.translation_number = â†‘m
measure_theory.measure.map (Î» (z : G Ã— G), (z.fst, (z.fst)â»Â¹ * z.snd)) (Î¼.prod Î½) = Î¼.prod Î½
has_deriv_at (exp ğ•‚) 1 0
âˆƒ (x : Î±), filter.tendsto u filter.at_top (nhds x)
has_dist.dist a p * has_dist.dist b p = |has_dist.dist b q ^ 2 - has_dist.dist p q ^ 2|
interval_integrable (Î» (x : â„), x ^ r) measure_theory.measure_space.volume a b
hA.eigenvector_matrix_inv.mul A = (matrix.diagonal (coe âˆ˜ hA.eigenvalues)).mul hA.eigenvector_matrix_inv
âˆƒ (v : V), G.min_degree = G.degree v
add_commute a (b + c)
l <+ l' â†” âˆƒ (f : fin l.length â†ªo fin l'.length), âˆ€ (ix : fin l.length), l.nth_le â†‘ix _ = l'.nth_le â†‘(â‡‘f ix) _
(algebraic_geometry.structure_sheaf.stalk_iso â†¥R (â‡‘(prime_spectrum.comap f) p)).hom â‰« localization.local_ring_hom (â‡‘(prime_spectrum.comap f) p).as_ideal p.as_ideal f rfl â‰« (algebraic_geometry.structure_sheaf.stalk_iso â†¥S p).inv = algebraic_geometry.PresheafedSpace.stalk_map (algebraic_geometry.Spec.SheafedSpace_map f) p
r â€¢ p âˆˆ polynomial.lifts (algebra_map R S)
l.sum âˆˆ S
has_dist.dist (box_integral.integral_sum f vol Ï€) (Ï€â‚€.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)) â‰¤ Îµ
â‡‘(e.coord_change e' b) y = (â‡‘e' (â‡‘(e.to_fiber_bundle_trivialization.to_local_homeomorph.symm) (b, y))).snd
function.surjective real.sinh
s âˆˆ residual Î± â†” âˆƒ (t : set Î±) (H : t âŠ† s), is_GÎ´ t âˆ§ dense t
0.comp_linear_map f = 0
f â‰¤ nhds a â†” âˆ€ (s : set Î±), a âˆˆ s â†’ is_open s â†’ s âˆˆ f
function.injective â‡‘(polynomial.expand R n)
p = p' â†’ ps = ps' â†’ p * ps = p' * ps'
(matrix.circulant v).is_symm â†” âˆ€ (i : n), v (-i) = v i
â‡‘(iterated_fderiv ğ•œ n f x) m = finset.univ.prod (Î» (i : fin n), m i) â€¢ iterated_deriv n f x
same_ray â„ x y â†” âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
â‡‘(ideal.quotient.mk I) x âˆˆ ideal.map (ideal.quotient.mk I) J â†” x âˆˆ J âŠ” I
(hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.binary_biproduct.is_limit X Y)).inv = category_theory.limits.biprod.desc b.inl b.inr
setoid.r = setoid.r â†” c = d
has_Sup.Sup S = con_gen (has_Sup.Sup (coe_fn '' S))
â‡‘f (fin.cons (c â€¢ x) m) = c â€¢ â‡‘f (fin.cons x m)
f = f'
âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
(âˆ€ (i : Î¹), i âˆˆ t â†’ x.coprime (s i)) â†’ x.coprime (t.prod (Î» (i : Î¹), s i))
â†‘n â‰¤ (a ^ n - 1) / (a - 1)
(âˆ€ (i j : â„•), â‡‘(â‡‘câ‚€ i) (â‡‘câ‚ j) â‰¤ z) â†” âˆ€ (i : â„•), â‡‘(â‡‘câ‚€ i) (â‡‘câ‚ i) â‰¤ z
id â‰¤ (f^[n])
âˆƒ (i : Î¹) (H : i âˆˆ t), f (p i) â‰¤ f (t.center_mass w p)
cont_mdiff_on I I n â‡‘e e.to_local_equiv.source
ae_measurable f Î¼
a â‰¤ b â†’ a - b â‰¤ 0
is_open_map â‡‘(f.linear) â†” is_open_map â‡‘f
K â‰ƒ+* L
(is_localization.map Sâ‚˜ (algebra_map R S) _).is_integral_elem (â‡‘(algebra_map S Sâ‚˜) x)
a âŠ‚ b âˆ¨ a = b
algebraic_geometry.SheafedSpace.is_open_immersion f
cont_diff_on ğ•œ n (Î» (x : E), f x + g x) s
âˆƒ (P : polynomial â„¤), polynomial.map (int.cast_ring_hom K) P = polynomial.cyclotomic' n K âˆ§ P.degree = (polynomial.cyclotomic' n K).degree âˆ§ P.monic
prod.map g g' (prod.map f f' x) = prod.map (g âˆ˜ f) (g' âˆ˜ f') x
x.succ_above = y.succ_above â†” x = y
is_closed_map (Î» (x : M), c â€¢ x)
filter.tendsto u f (nhds a)
Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—®
(x::áµ¥vector.nil).nth ix = x
cardinal.mk â†¥(measurable_space.generate_measurable_rec s i) â‰¤ linear_order.max (cardinal.mk â†¥s) 2 ^ cardinal.aleph_0
p x
category_theory.limits.has_colimits_of_size C
o.oangle x y = Î¸ â†” âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(o.rotation Î¸) x
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), f' c = 0
âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0 âˆ§ a0 % 2 = 1
rack.pre_envel_group_rel' R a b â†’ rack.to_envel_group.map_aux f a = rack.to_envel_group.map_aux f b
fintype.card Î± = 0
â‡‘((has_insert.insert i s).weighted_vsub_of_point p (p i)) w = â‡‘(s.weighted_vsub_of_point p (p i)) w
has_inner.inner x y = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
matrix.to_lin (pi.basis_fun R n) (pi.basis_fun R m) = matrix.to_lin'
odd n â†’ odd n.nat_abs
â‡‘(algebra.trace K S) pb.gen = -(minpoly K pb.gen).next_coeff
fintype.card (class_group R K) = 1
x.equiv y â†” x.to_set = y.to_set
s.sum (Î» (x : Î±), f x) = âŠ¤ â†” âˆƒ (a : Î±) (H : a âˆˆ s), f a = âŠ¤
measure_theory.integral Î¼ (X * Y) = measure_theory.integral Î¼ X * measure_theory.integral Î¼ Y
(â¨ (x : Î±) in t, f x âˆ‚Î¼, â¨ (x : Î±) in t, g (f x) âˆ‚Î¼) âˆˆ {p : E Ã— â„ | p.fst âˆˆ s âˆ§ g p.fst â‰¤ p.snd}
filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_bot
âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
is_regular â†‘a
Â¬a â‹– b
X.Î´ (â‡‘fin.cast_succ i) â‰« X.Ïƒ i = ğŸ™ (X.obj (simplex_category.mk n))
â…lie_ideal.comap I.incl Iâ‚,lie_ideal.comap I.incl Iâ‚‚â† = lie_ideal.comap I.incl â…Iâ‚,Iâ‚‚â†
(euclidean_geometry.orthogonal_projection s).linear = â†‘(orthogonal_projection s.direction)
is_compact (metric.sphere x r)
setoid.r = setoid.r âŠ“ setoid.r
â‡‘c w x â†’ â‡‘c (w ^ n) (x ^ n)
filter.tendsto (Î» (n : Î¹), âˆ« (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ« (a : Î±), f a âˆ‚Î¼))
s âˆˆ nhds_within a (set.Ioi a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ioc a u âŠ† s
(has_insert.insert a s).card = ite (a âˆˆ s) s.card (s.card + 1)
-ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _
metric.diam (f '' s) = metric.diam s
x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s
â‡‘mv_polynomial.C â†‘n âˆ£ Ï† â†” â‡‘(mv_polynomial.map (int.cast_ring_hom (zmod n))) Ï† = 0
char.quadratic_char F a = 1 â†” is_square a
is_add_regular a
set.Icc (f a) (f b) âŠ† f '' set.Icc a b
L.head â‰¤ L.sum
set.image2 f s (g '' t) = g' '' set.image2 f' s t
submodule.map p.subtype (module.End.eigenspace (linear_map.restrict f hfp) Î¼) â‰¤ f.eigenspace Î¼
is_submonoid (â‹ƒ (i : Î¹), s i)
filter.tendsto (Î» (x : Î±), op (f x) (g x)) l (nhds 0)
âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), (z - x)â»Â¹ * (âˆ¥f zâˆ¥ - âˆ¥f xâˆ¥) < r
_.inv_app U â‰« (D.to_glue_data.f i k).c.app (opposite.op (_.open_functor.obj U)) = category_theory.limits.pullback.fst.c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map category_theory.limits.pullback.fst.base).op.obj (opposite.op U))) â‰« (D.to_glue_data.V (i, k)).presheaf.map (category_theory.eq_to_hom _)
add_submonoid.closure s â‰¤ S â†” s âŠ† â†‘S
(Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] g â†’ f' =O[l] g
same_ray R (â‡‘e x) (â‡‘e y) â†” same_ray R x y
s.sum (Î» (i : Î¹), f i) < âŠ¤
âˆƒ (a : Î±) (H : a âˆˆ s), a < b
contracting_with K (set.maps_to.restrict f s s hs)
is_compact (â‡‘(convex_hull â„) s)
subgroup.closure ((Î» (g : G), g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹) '' (R * S)) = H
topological_space.second_countable_topology Î±
has_fderiv_within_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca) (s Ã—Ë¢ t) (a, b)
(vector.scanl f b v).nth i.succ = f ((vector.scanl f b v).nth (â‡‘fin.cast_succ i)) (v.nth i)
uniform_space.to_topological_space â‰¤ weak_dual.topological_space ğ•œ E
cont_diff_on ğ•œ âŠ¤ f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ âŠ¤ (Î» (y : E), fderiv_within ğ•œ f s y) s
f 0 = 0
â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ interior s
set.eq_on â‡‘f â‡‘g â†‘(subgroup.closure s)
equiv.swap i j â€¢ Ïƒ = Ïƒ â†’ â‡‘(alternating_map.dom_coprod.summand a b Ïƒ) v = 0
(â¨… (i : Î¹), f i) = b
fintype.card â†¥(mul_action.orbit Î± b) * fintype.card â†¥(mul_action.stabilizer Î± b) = fintype.card Î±
x * infi f = â¨… (i : Î¹), x * f i
matrix.vec_cons x u 1 = matrix.vec_head u
â†‘s.pairwise_disjoint f â†’ s.sup_indep f
nontrivial Î²
filter.tendsto (Î» (x : â„), x ^ -y) filter.at_top (nhds 0)
p3 -áµ¥ p2 - (p3 -áµ¥ p1) = p1 -áµ¥ p2
âˆƒ (H : subgroup G), H.is_complement' N
monotone f
(A  B).to_colex < (B  A).to_colex â†” A.to_colex < B.to_colex
n.choose r â‰¤ n.choose (n / 2)
local_ring R
strict_convex ğ•œ s â†” s.pairwise (Î» (x y : E), âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ interior s)
polynomial.cyclotomic n K = (primitive_roots n K).prod (Î» (Î¼ : K), polynomial.X - â‡‘polynomial.C Î¼)
â†‘(â‡‘(s.orthogonal_projection_span) p) = s.circumcenter
is_add_monoid_hom id
(finset.range n).prod (Î» (i : â„•), f (i + 1) * (f i)â»Â¹) = f n * (f 0)â»Â¹
vector_span k (p '' s) = submodule.span k (has_vsub.vsub (p i) '' (p '' (s  {i})))
filter.tendsto f filter.at_top filter.at_top
spectrum â„‚ â†‘a = coe âˆ˜ complex.re '' spectrum â„‚ â†‘a
category_theory.presieve.is_sheaf (category_theory.sheaf.canonical_topology C) P
(finset.powerset_len n s).card = s.card.choose n
algebra.adjoin R (â‹ƒ (f : add_monoid_algebra R M) (H : f âˆˆ S), add_monoid_algebra.of' R M '' â†‘(f.support)) = âŠ¤
module.rank R M = cardinal.mk (module.free.choose_basis_index R M)
differentiable_on ğ•œ (iterated_deriv_within m f s) s
â‡‘(f.linear) = â‡‘f - Î» (z : V1), â‡‘f 0
v.tail = vector.nil
âˆƒ (c : F), âˆ€ (z : E), f z = c
has_inner.inner (v i) (s.sum (Î» (i : Î¹), l i â€¢ v i)) = l i
j = k
(polynomial.cyclotomic n R).is_root Î¼
metric.Hausdorff_dist s (closure t) = metric.Hausdorff_dist s t
s = Î¼.singular_part Î½
J.is_prime â†” (ideal.comap (algebra_map R S) J).is_prime âˆ§ disjoint â†‘M â†‘(ideal.comap (algebra_map R S) J)
F.is_sheaf_unique_gluing
âˆƒ (y : Î²) (H : y âˆˆ t), b < (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
convex ğ•œ (closure s)
filter.tendsto (Î» (n : â„•), â†‘n * r ^ n) filter.at_top (nhds 0)
C x
(A  B).to_colex â‰¤ (B  A).to_colex â†” A.to_colex â‰¤ B.to_colex
e.is_image s t â†’ e.to_local_equiv.source âˆ© â‡‘e â»Â¹' (e.to_local_equiv.target âˆ© t) = e.to_local_equiv.source âˆ© s
f = g
ratfunc.eval f a (x + y) = ratfunc.eval f a x + ratfunc.eval f a y
sá¶œ âˆˆ f
âˆƒ (U : topological_space.opens â†¥X) (m : x âˆˆ U) (s : â†¥(F.obj (opposite.op U))), â‡‘(F.germ âŸ¨x, mâŸ©) s = t
âˆƒ (C : finset Î±), B âŠ† C âˆ§ C âŠ† A âˆ§ C.card = i + B.card
proper_space E
(âˆƒ (c : Î±), m = 2 â€¢ c) â†’ even m
f (a â€¢ x + b â€¢ y) â‰¤ linear_order.max (f x) (f y)
has_inner.inner v u = 0
has_Inf.Inf s â‰¤ has_Sup.Sup s
set.image2 f (g '' s) t = g' '' set.image2 f' s t
category_theory.is_pullback fst snd f g
0 â‰¤ b â†’ a - b â‰¤ a
finite_dimensional.finrank K L = â†‘n.totient
lie_submodule.ucs k âŠ¥ â‰¤ Nâ‚
â‡‘(linear_map.to_matrix complex.basis_one_I complex.basis_one_I) complex.conj_ae.to_linear_map = ![![1, 0], ![0, -1]]
â‡‘(algebra.norm K) Î¶ = 1
subgroup.comap f H.normalizer = (subgroup.comap f H).normalizer
â‡‘(c.lift f H) (â‡‘(c.mk') x) = â‡‘f x
inner_product_geometry.angle x 0 = real.pi / 2
category_theory.zigzag (F.obj jâ‚) (F.obj jâ‚‚)
finset.univ.sum (Î» (i : Î¹), âˆ¥x iâˆ¥â‚Š) â‰¤ fintype.card Î¹ â€¢ âˆ¥xâˆ¥â‚Š
C x
finset.centroid k s p = finset.centroid k finset.univ (Î» (x : â†¥ps), â†‘x)
irrational x
is_add_regular 0
galois_connection (â‡‘order_dual.to_dual âˆ˜ fixing_subgroup M) ((Î» (P : subgroup M), mul_action.fixed_points â†¥P Î±) âˆ˜ â‡‘order_dual.of_dual)
affine_independent k p â†” âˆ€ (s : finset Î¹) (w : Î¹ â†’ k), s.sum (Î» (i : Î¹), w i) = 0 â†’ â‡‘(s.weighted_vsub p) w = 0 â†’ âˆ€ (i : Î¹), i âˆˆ s â†’ w i = 0
topological_add_group G
Â¬is_regular 0
differentiable_within_at ğ•œ f (has_insert.insert x s) x
âˆƒ (V : set Î±), is_open V âˆ§ K âŠ† V âˆ§ is_compact (closure V)
tendsto_uniformly_on F f p s
emetric.inf_edist x (closure s) = emetric.inf_edist x s
(â¨… (i : Î¹), filter.principal (s i)).has_basis (Î» (t : set Î¹), t.finite) (Î» (t : set Î¹), â‹‚ (i : Î¹) (H : i âˆˆ t), s i)
âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ y
â‡‘Î¼ A = â¨† (K : set Î±) (H : K âŠ† A) (h : is_compact K), â‡‘Î¼ K
0 < a + b
implies p r
(integral_closure R A).map â†‘f = integral_closure R B
a < b âˆ¨ a = b
tendsto_locally_uniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
a - b < 0 â†’ a < b
finset.centroid_weights k s i = (â†‘(s.card))â»Â¹
cont_mdiff_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f x â†’ cont_diff_at ğ•œ n f x
a â‰¤ c
(âˆƒ (k : â„¤), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m
deriv f c = (2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - c) ^ -2 â€¢ f z
function.injective (Î» (g : alternating_map R M N Î¹), g.comp_linear_map f)
category_theory.faithful L
Qâ‚.anisotropic âˆ§ Qâ‚‚.anisotropic
â†‘p ^ k âˆ£ m â†” k â‰¤ multiset.count p m.factor_multiset
function.injective â‡‘(â‡‘zsqrtd.lift r)
mv_polynomial.homogeneous_submodule Ïƒ R n = finsupp.supported R R {d : Ïƒ â†’â‚€ â„• | d.support.sum (Î» (i : Ïƒ), â‡‘d i) = n}
has_dist.dist x y = âˆ¥x -áµ¥ yâˆ¥
has_strict_deriv_at (Î» (x : ğ•œ), polynomial.eval x p) (polynomial.eval x (â‡‘polynomial.derivative p)) x
bdd_below s â†’ bdd_above (f '' s)
âˆƒ (f : â„ â†’ E), f â†‘(v.tâ‚€) = v.xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ set.Icc v.t_min v.t_max â†’ has_deriv_within_at f (â‡‘v t (f t)) (set.Icc v.t_min v.t_max) t
x = 0
category_theory.limits.has_binary_biproduct X Y
continuous_at â‡‘e x
âˆƒ (u : ultrafilter Î±), â†‘u â‰¤ f
f = g
category_theory.limits.has_binary_coproducts C
A.det = B.det
p = q â†” p.fst = q.fst
order_of (quaternion_group.xa i) = 4
s.sum (Î» (i : Î±), f i) + sá¶œ.sum (Î» (i : Î±), f i) = finset.univ.sum (Î» (i : Î±), f i)
N = âŠ¥
is_add_regular (a + b) â†” is_add_regular a âˆ§ is_add_regular b
âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (z : Î± Ã— Î²), f z.fst z.snd âˆ‚Î¼.prod Î½
âˆƒ (V : set Î±), s âŠ† V âˆ§ is_open V âˆ§ V âŠ† U
âˆƒ (Î¹ : Type) [_inst_3 : fintype Î¹], âˆ€ (C : (Î¹ â†’ Î±) â†’ Îº), âˆƒ (l : combinatorics.line Î± Î¹), combinatorics.line.is_mono C l
is_compact s â†” âˆ€ {Î¹ : Type u} (U : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_open (U i)) â†’ (s âŠ† â‹ƒ (i : Î¹), U i) â†’ (âˆƒ (t : finset Î¹), s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i)
category_theory.forget_enrichment.hom_to W (f â‰« g) = ((Î»_ (ğŸ™_ W)).inv â‰« (category_theory.forget_enrichment.hom_to W f âŠ— category_theory.forget_enrichment.hom_to W g)) â‰« category_theory.e_comp W (category_theory.forget_enrichment.to W X) (category_theory.forget_enrichment.to W Y) (category_theory.forget_enrichment.to W Z)
{p : Î± Ã— Î± | has_dist.dist p.fst p.snd < Îµ} âˆˆ uniformity Î±
1 < a * b
s =á¶ [l] t â†’ (âˆ€á¶  (x : Î±) in l, x âˆˆ s â†” x âˆˆ t)
function.is_fixed_pt f x
o.oangle (â‡‘(o.rotation Î¸) x) (â‡‘(o.rotation Î¸) y) = o.oangle x y
{x : ordinal | x âˆˆ S âˆ§ âˆ€ (c : ordinal), c < o â†’ ordinal.enum_ord S c < x}.nonempty
is_noetherian R N
linear_map.range x.hom = linear_map.range y.hom
finite_dimensional ğ•œ M
f (l.nth_le n H) = (list.map f l).nth_le n _
isometry â‡‘(algebra_map ğ•œ ğ•œ')
(x * (y + z)).equiv (x * y + x * z)
s âŠ† â‹ƒ (i : Î¹), t i
(s.prod (Î» (i : Î¹), f i)).vars âŠ† s.bUnion (Î» (i : Î¹), (f i).vars)
category_theory.faithful F
filter.tendsto (Î» (x : â„), x ^ y) filter.at_top filter.at_top
add_commute (pi.single i (x i)) (pi.single j (x j))
b = 0
affine_span â„ {p, s.points i} = s.altitude i â†” p â‰  s.points i âˆ§ p âˆˆ affine_span â„ (set.range s.points) âˆ§ p -áµ¥ s.points i âˆˆ ((affine_span â„ (s.points '' â†‘(finset.univ.erase i))).direction)á—®
(finset.Ico 1 (n + 1)).sum (Î» (k : â„•), a ^ k * âˆ¥p.right_inv i kâˆ¥) â‰¤ âˆ¥â†‘(i.symm)âˆ¥ * a + âˆ¥â†‘(i.symm)âˆ¥ * C * (finset.Ico 2 (n + 1)).sum (Î» (k : â„•), (r * (finset.Ico 1 n).sum (Î» (j : â„•), a ^ j * âˆ¥p.right_inv i jâˆ¥)) ^ k)
filter.tendsto (Î» (n : â„•), bernstein_approximation n f) filter.at_top (nhds f)
has_ftaylor_series_up_to_on n (Î» (y : E), (f y, g y)) (Î» (y : E) (k : â„•), (p y k).prod (q y k)) s
metric.inf_dist x (closure s) = metric.inf_dist x s
free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚
a < bâ»Â¹ â†’ b < aâ»Â¹
âˆ« (z : Î± Ã— Î²) in s Ã—Ë¢ t, f z âˆ‚Î¼.prod Î½ = âˆ« (x : Î±) in s, âˆ« (y : Î²) in t, f (x, y) âˆ‚Î½ âˆ‚Î¼
(âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n
(fin.last n).succ_above = fin.cast_succ
convex_on â„ set.univ real.exp
topological_space.metrizable_space X
generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n â†” âˆƒ (ifp_n : generalized_continued_fraction.int_fract_pair K), generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n âˆ§ ifp_n.fr â‰  0 âˆ§ generalized_continued_fraction.int_fract_pair.of (ifp_n.fr)â»Â¹ = ifp_succ_n
âˆ« (x : â„), x * (measure_theory.pdf X Â«â„™Â» measure_theory.measure_space.volume x).to_real = âˆ« (x : Î±), X x âˆ‚Â«â„™Â»
âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f x y âˆ‚Î¼ âˆ‚Î½
â‡‘f x = â‡‘g x
g.nat_degree = hf.degree
v.reverse.head = v.last
measure_theory.mem_â„’p (Exists.some _) p (Î¼.trim hm)
o.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
G.equiv (nim G.grundy_value)
add_subgroup.map f.to_add_monoid_hom H.normalizer = (add_subgroup.map f.to_add_monoid_hom H).normalizer
N âŠ” I â€¢ N' = N âŠ” J â€¢ N'
category_theory.is_pushout f g inl inr
a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c
(generalized_continued_fraction.of v).numerators n * (generalized_continued_fraction.of v).denominators (n + 1) - (generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).numerators (n + 1) = (-1) ^ (n + 1)
is_add_group_hom id
â‡‘(f.linear) (p1 -áµ¥ p2) = â‡‘f p1 -áµ¥ â‡‘f p2
(âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
[âˆƒ (a : â„) (H : a âˆˆ set.Ioo (-R) R), f =o[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), f =o[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo (-R) R), f =O[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), f =O[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a < R) (C : â„) (hâ‚€ : 0 < C âˆ¨ 0 < R), âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R) (C : â„) (H : C > 0), âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n, âˆƒ (a : â„) (H : a < R), âˆ€á¶  (n : â„•) in filter.at_top, |f n| â‰¤ a ^ n, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), âˆ€á¶  (n : â„•) in filter.at_top, |f n| â‰¤ a ^ n].tfae
continuous â‡‘l
filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.Ioi a)) l
category_theory.limits.has_cokernels C
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
F.sections.nonempty
filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
euclidean_geometry.orthogonal_projection_fn s p âˆˆ s
filter.tendsto (Î» (x : Î²), f x + g x) l filter.at_bot
euclidean_geometry.angle p2 p3 p1 = 0
char_zero R
has_strict_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)) (a, b)
is_algebraic S x
âˆƒ (d : Î±), d â‰  0 âˆ§ âˆ¥d â€¢ xâˆ¥ < Îµ âˆ§ Îµ / âˆ¥câˆ¥ â‰¤ âˆ¥d â€¢ xâˆ¥ âˆ§ âˆ¥dâˆ¥â»Â¹ â‰¤ Îµâ»Â¹ * âˆ¥câˆ¥ * âˆ¥xâˆ¥
gp.a = 1 âˆ§ âˆƒ (z : â„¤), gp.b = â†‘z
p i âˆˆ â‡‘(convex_hull ğ•œ) (p '' s) â†” i âˆˆ s
â‡‘(âˆ….weighted_vsub p) w = 0
(M.mul N).det = (N.mul M).det
(e.units_smul (function.update 1 i (-1))).orientation = -e.orientation
finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒ (x : Î¹) (H : x âˆˆ I), t x), f a)) = finsum (Î» (i : Î¹), finsum (Î» (H : i âˆˆ I), finsum (Î» (j : Î±), finsum (Î» (H : j âˆˆ t i), f j))))
category_theory.is_iso ((category_theory.adjunction.of_right_adjoint i).unit.app A)
0 = a * b â†” a = 0 âˆ¨ b = 0
vector.nil.tail = vector.nil
â†‘(ğ’œ.card) / â†‘((fintype.card Î±).choose r) â‰¤ â†‘(ğ’œ.shadow.card) / â†‘((fintype.card Î±).choose (r - 1))
dense_inducing has_pure.pure
â‡‘(power_series.coeff R n) Ï† = 0
â‡‘f aâ»Â¹ = (â‡‘f a)â»Â¹
relation.refl_trans_gen r n m
exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue
(Î» (x : â„), x ^ k) =o[filter.at_top] Î» (x : â„), real.exp (b * x)
(âˆ€ (n : â„•), 0 < n â†’ n.divisors.prod (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.prod (Î» (x : â„• Ã— â„•), g x.snd ^ â‡‘nat.arithmetic_function.moebius x.fst) = f n
Bâ‚‚ = Fâ‚‚
inner_product_geometry.angle (-x) y = real.pi - inner_product_geometry.angle x y
finite_dimensional.finrank K V = 1
f = g
f (-x) = -f x
âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
euclidean_geometry.angle p1 p1 p2 = real.pi / 2
set.sized r A âˆ§ set.sized r B â†’ set.sized r (A âˆª B)
âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (x : â„) in f a..f b, g x
â‡‘(add_con.ker f) x = â‡‘f â»Â¹' {â‡‘f x}
order_of (dihedral_group.sr i) = 2
measure_theory.integrable f (Î¼.prod Î½) â†” (âˆ€áµ (y : Î²) âˆ‚Î½, measure_theory.integrable (Î» (x : Î±), f (x, y)) Î¼) âˆ§ measure_theory.integrable (Î» (y : Î²), âˆ« (x : Î±), âˆ¥f (x, y)âˆ¥ âˆ‚Î¼) Î½
convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
(quotient.mk '' L.age M).countable
{t : set Î± | measurable_space.generate_measurable s t} = â‹ƒ (i : (quotient.out (cardinal.aleph 1).ord).Î±), measurable_space.generate_measurable_rec s i
(âˆ€ (p : â„), liouville_with p x) â†” liouville x
(âˆ€ (b : A), b âˆˆ t â†’ f b âˆˆ s) â†’ t.prod (Î» (b : A), f b) âˆˆ s
function.injective coe_fn
o.oangle x z - o.oangle y z = o.oangle x y
u = â‹ƒâ‚€{s âˆˆ B | s âŠ† u}
order.succ a â‰¤ order.succ b â†’ a â‰¤ b
(finset.filter (Î» (J : box_integral.box Î¹), Ï€.tag J = x) Ï€.to_prepartition.boxes).card â‰¤ 2 ^ fintype.card Î¹
subsingleton (A â†’â‚[R] B)
m âˆ£ n + m â†” m âˆ£ n
âˆƒ (f : V â†’ K), t.sum (Î» (e : V), f e â€¢ e) = 0 âˆ§ t.sum (Î» (e : V), f e) = 0 âˆ§ âˆƒ (x : V) (H : x âˆˆ t), f x â‰  0
(cardinal.mk Î¹).lift = (cardinal.mk Î¹').lift
â‡‘(Î¼.prod Î½) s = 0 â†” (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s)) =áµ[Î¼] 0
filter.tendsto (Î» (n : â„•), x ^ n) filter.at_top (nhds 0)
prime (minpoly A x)
set.eq_on â‡‘f â‡‘g â†‘(â‡‘(first_order.language.substructure.closure L) s)
(uniformity Î±).has_basis (Î» (V : set (Î± Ã— Î±)), V âˆˆ uniformity Î± âˆ§ is_open V) id
0 â‰¤ a - b â†’ b â‰¤ a
â‡‘(f.map hy k) z = u â†” â‡‘(k.to_map) (â‡‘g (f.sec z).fst) = â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) * u
p n â†’ nat.count p (n + 1) = nat.count p n + 1
b â©¿ a â†’ â‡‘order_dual.of_dual a â©¿ â‡‘order_dual.of_dual b
add_monoid.closure s âŠ† add_monoid.closure t
g = h
Â¬is_field â†¥(number_field.ring_of_integers K)
Î¼.absolutely_continuous Î½ â†” Î½.with_density (Î¼.rn_deriv Î½) = Î¼
has_fpower_series_on_ball f (cauchy_power_series f c â†‘R) c â†‘R
(fundamental_groupoid_functor.proj X i).map p = path.homotopic.proj i p
a - b.succ = a - b - 1
discrete_topology X
M.mul (matrix.pivot.list_transvec_row M).prod (sum.inr ()) (sum.inl i) = 0
filter.is_bounded r f â†’ filter.is_cobounded (flip r) f
function.injective (cardinal.cantor_function c)
o.rotation â†‘real.pi = linear_isometry_equiv.neg â„
polynomial.dickson 1 1 (m * n) = (polynomial.dickson 1 1 m).comp (polynomial.dickson 1 1 n)
linear_order.max a b = a âˆ§ b â‰¤ a âˆ¨ linear_order.max a b = b âˆ§ a < b
s.prod (Î» (x : Î³), (t x).prod (Î» (y : Î±), f x y)) = t'.prod (Î» (y : Î±), (s' y).prod (Î» (x : Î³), f x y))
s1 â‰¤ s2 â†” âˆ€ (p : P), p âˆˆ s1 â†’ p âˆˆ s2
(subgroup.map N.subtype â†‘P).normalizer âŠ” N = âŠ¤
dense (quotient.mk '' s)
(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)).comp ((dfinsupp.map_range.linear_map (Î» (i : Î¹), linear_map.to_span_singleton R â†¥(p i) âŸ¨v i, _âŸ©)).comp (finsupp_lequiv_dfinsupp R).to_linear_map) = finsupp.total Î¹ N R v
cauchy_seq f
subring.closure s â‰¤ t â†” s âŠ† â†‘t
âˆƒ (r' : â„) (H : r' âˆˆ set.Ioo 0 r), s âŠ† metric.ball x r'
[measure_theory.vadd_invariant_measure G Î± Î¼, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (has_vadd.vadd c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (c +áµ¥ s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (has_vadd.vadd c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (c +áµ¥ s) = â‡‘Î¼ s, âˆ€ (c : G), measure_theory.measure.map (has_vadd.vadd c) Î¼ = Î¼, âˆ€ (c : G), measure_theory.measure_preserving (has_vadd.vadd c) Î¼ Î¼].tfae
has_inner.inner x (â‡‘(â‡‘linear_map.adjoint A) y) = has_inner.inner (â‡‘A x) y
strict_convex_space ğ•œ E
Q.to_fun = â‡‘Q
category_theory.mono (t.to B)
category_theory.limits.image.Î¹ f = 0
Î¼ = Î½
â†‘(H âŠ” N) = â†‘H * â†‘N
generalized_continued_fraction.squash_seq s n = s
â‡‘(s.affine_combination p) w = â‡‘(s.weighted_vsub_of_point p b) w +áµ¥ b
acc (relation.game_add rÎ± rÎ²) (a, b)
âˆƒ (v : Î¹ â†’ set X), set.Union v = set.univ âˆ§ (âˆ€ (i : Î¹), is_closed (v i)) âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
strongly_measurable_at_filter f (nhds_within x s) Î¼
category_theory.limits.has_limit D
filter.tendsto (Î» (x : â„), (1 + t / x) ^ x) filter.at_top (nhds (real.exp t))
antitone_on f D
f x = y â†” x = f y
â†‘(a.val) = a
âˆƒá¶  (m : â„•) in filter.at_top, m â‰¡ d [MOD n]
bâ‚ = bâ‚‚
f' = 0
cont_diff_on ğ•œ n f s
f âˆˆ submodule.span k (â‡‘(monoid_algebra.of k G) '' â†‘(f.support))
L.initial
L.prod = 0 â†” 0 âˆˆ L
add_monoid.is_torsion â†¥H
1 < a * b
z âˆˆ set.Ioo x y â†” âˆƒ (a b : ğ•œ), 0 < a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
g.terminated_at m
a ^ n âˆˆ s
has_fderiv_within_at f f' s x â†’ has_mfderiv_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x f'
span_points k s âŠ† â†‘s1
âˆƒ (y : Î²), b < (finset.filter (Î» (x : Î±), f x = y) finset.univ).sum (Î» (x : Î±), w x)
has_dist.dist f g â‰¤ C â†” âˆ€ (x : Î±), has_dist.dist (â‡‘f x) (â‡‘g x) â‰¤ C
â‡‘(â‡‘cross_product u) (â‡‘(â‡‘cross_product v) w) = â‡‘(â‡‘cross_product (â‡‘(â‡‘cross_product u) v)) w + â‡‘(â‡‘cross_product v) (â‡‘(â‡‘cross_product u) w)
s.card * m â‰¤ t.card * n
p y
is_upper_set s â†’ is_lower_set (â‡‘order_dual.to_dual â»Â¹' s)
x * (â‡‘(algebra_map R A) r * y) = â‡‘(algebra_map R A) r * (x * y)
disjoint (primitive_roots k R) (primitive_roots l R)
is_right_regular g
âˆƒ (t : set Î±) (H : t âŠ† s), t.finite âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), metric.ball x e
set.Icc x y  set.univ.pi (Î» (i : Î¹), set.Ioo (x' i) (y' i)) âŠ† (â‹ƒ (i : Î¹), set.Icc x (function.update y i (x' i))) âˆª â‹ƒ (i : Î¹), set.Icc (function.update x i (y' i)) y
f â‰¤ nhds x
function.injective equiv.perm.cycle_factors_finset
â†‘u âˆ£ a
âˆƒ (y : Î²), â†‘((finset.filter (Î» (x : Î±), f x = y) finset.univ).card) â‰¤ b
B.sum (Î» (t : finset Î±), (s âˆ© t).card) = s.card * n
âˆƒ (y : Î²) (H : y âˆˆ t), b â‰¤ (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
â‡‘(reflection K) (â‡‘(reflection K) p) = p
summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p
is_compact s
âˆƒ (V : set G) (H : V âˆˆ nhds 1), V * K âŠ† U
infinite Î±
cont_diff ğ•œ â†‘(n + 1) f â†” differentiable ğ•œ f âˆ§ âˆ€ (y : E), cont_diff ğ•œ â†‘n (Î» (x : E), â‡‘(fderiv ğ•œ f x) y)
(matrix.from_blocks A B C D).det = D.det * (A - (B.mul (â…Ÿ D)).mul C).det
â‡‘(polynomial.aeval f) p = â‡‘(polynomial.aeval f) (p %â‚˜ f.charpoly)
F.is_gluing U ((F.pi_opens_iso_sections_family U).hom sf) s â†” Top.presheaf.sheaf_condition_equalizer_products.res F U s = sf
convex_on â„ D f
cauchy_seq (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i))
âˆƒ (y : Î±), y * y - b * y + c = 0 âˆ§ x + y = b âˆ§ x * y = c
is_min_on f (set.Icc a b) a
f = g
(âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) â†” c = d
has_inner.inner x (l.sum (Î» (i : Î¹) (a : ğ•œ), a â€¢ v i)) = l.sum (Î» (i : Î¹) (a : ğ•œ), a â€¢ has_inner.inner x (v i))
linear_order.min Ï†.order Ïˆ.order â‰¤ (Ï† + Ïˆ).order
0 â‰¤ âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
has_fderiv_at â‡‘(f.symm) â†‘(f'.symm) a
setoid.mk_classes r.classes setoid.classes_eqv_classes = r
measurable_space.generate_from (set.image2 has_set_prod.prod C D) = prod.measurable_space
cardinal.mk â†¥(set.Ici a) = cardinal.continuum
âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Î¼ (s âˆ© a) / â‡‘Î¼ a) (v.filter_at x) (nhds (s.indicator 1 x))
same_ray R y x
function.bijective â‡‘(polynomial.gal.gal_action_hom p â„‚)
â‡‘(e.symm) (â‡‘e x) = x
â‡‘Î¼ (f â»Â¹' s) = 0
âˆ¥â‡‘(continuous_multilinear_map.comp_along_composition p c f) vâˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.prod (Î» (i : fin c.length), âˆ¥p (c.blocks_fun i)âˆ¥) * finset.univ.prod (Î» (i : fin n), âˆ¥v iâˆ¥)
submonoid.closure s â‰¤ submonoid.closure t
1 / a < 1 / b â†” b < a
convex ğ•œ s â†” âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 < a + b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ s
âˆ¥â‡‘innerSL xâˆ¥ = âˆ¥xâˆ¥
filter.at_top â‰¤ filter.cofinite
(padic_int.to_zmod_pow n).comp (padic_int.lift f_compat) = f n
local_ring R
(finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s).prod (Î» (x : Î±), g x) = s.prod (Î» (x : {x // p x}), f x)
a âˆˆ finset.univ.sum (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), g i âˆˆ f i), finset.univ.sum (Î» (i : Î¹), g i) = a
(â‡‘(polynomial.taylor r) f).coeff n = polynomial.eval r (â‡‘(polynomial.hasse_deriv n) f)
(âˆƒ (x : â„•), p x) â†’ well_founded (nat.upto.gt p)
âˆƒ (t : set Î±) (H : t âŠ† s), measurable_set t âˆ§ â‡‘Î¼ t â‰¤ ennreal.of_real Îµ âˆ§ tendsto_uniformly_on f g filter.at_top (s  t)
âˆƒ (t : â„• â†’ set E) (A : â„• â†’ (E â†’L[â„] F)), (âˆ€ (n : â„•), is_closed (t n)) âˆ§ (s âŠ† â‹ƒ (n : â„•), t n) âˆ§ (âˆ€ (n : â„•), approximates_linear_on f (A n) (s âˆ© t n) (r (A n))) âˆ§ (s.nonempty â†’ âˆ€ (n : â„•), âˆƒ (y : E) (H : y âˆˆ s), A n = f' y)
(B.restrict W).nondegenerate â†” is_compl W (B.orthogonal W)
(category_theory.presieve.family_of_elements.functor_pushforward G x).compatible
finset.univ.prod (Î» (i : Ïƒ), â‡‘polynomial.C (r i) + polynomial.X) = (finset.range (fintype.card Ïƒ + 1)).sum (Î» (i : â„•), (finset.powerset_len i finset.univ).sum (Î» (t : finset Ïƒ), t.prod (Î» (i : Ïƒ), â‡‘polynomial.C (r i))) * polynomial.X ^ (fintype.card Ïƒ - i))
âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
a â‰  âŠ¤
subgroup.closure h â‰¤ subgroup.closure k
function.surjective â‡‘(c.lift f h)
filter.tendsto f tâ‚€ (nhds 0)
summable (Î» (i : Î¹), f i * g i) âˆ§ âˆ‘' (i : Î¹), f i * g i â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) * (âˆ‘' (i : Î¹), g i ^ q) ^ (1 / q)
finite_dimensional K V
s.pairwise âŠ¥ â†’ s.subsingleton
(Î» (n : â„•), â†‘n ^ k * râ‚ ^ n) =o[filter.at_top] Î» (n : â„•), râ‚‚ ^ n
list.drop n (lâ‚ ++ lâ‚‚) = list.drop n lâ‚ ++ list.drop (n - lâ‚.length) lâ‚‚
linear_independent R v â†” (â‡‘(linear_map.lsum R (Î» (i : Î¹), R) â„•) (Î» (i : Î¹), linear_map.id.smul_right (v i))).ker = âŠ¥
R âŠ“ S âˆˆ â‡‘J X
category_theory.limits.initial_mono_class C
L.age (first_order.language.direct_limit G f) = â‹ƒ (i : Î¹), L.age (G i)
witt_vector.is_polyâ‚‚ p (Î» (_x : Type u_1) (_x_1 : comm_ring _x), has_add.add)
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ has_insert.insert a s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
is_extr_filter f l a â†’ is_extr_filter (â‡‘order_dual.to_dual âˆ˜ f) l a
âˆƒ (Ï€ : R), v.int_valuation_def Ï€ = â†‘(â‡‘multiplicative.of_add (-1))
(x + y) ^ n = (finset.range (n + 1)).sum (Î» (m : â„•), x ^ m * y ^ (n - m) * â†‘(n.choose m))
relation.trans_gen r n m
submonoid.map f (submonoid.closure s) = submonoid.closure (â‡‘f '' s)
âˆƒ (c : â†¥S), x * â†‘((f.sec (f.mk' x y)).snd) * â†‘c = (f.sec (f.mk' x y)).fst * â†‘y * â†‘c
(âˆ€ (u : set E), u âŠ‡ v â†’ orthonormal ğ•œ coe â†’ u = v) â†” (submodule.span ğ•œ v)á—® = âŠ¥
âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
âˆƒ (a : F), char.quadratic_char F a = -1
â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
0 âˆˆ H
âˆƒ (B : finset Î±), B âŠ† A âˆ§ B.card = i
measure_theory.tendsto_in_measure Î¼ f filter.at_top g
(F.left_derived 0).map f â‰« category_theory.abelian.functor.left_derived_zero_to_self_app F Q = category_theory.abelian.functor.left_derived_zero_to_self_app F P â‰« F.map f
cauchy_seq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), n â‰¥ N â†’ has_dist.dist (u n) (u N) < Îµ)
continuous (bounded_continuous_function.comp G H)
â‡‘e (a - b) = â‡‘e a - â‡‘e b
supr (Top.presheaf.covering_of_presieve U R) = U
cardinal.mk Î± = cardinal.mk Î²
filter.tendsto (Î» (n : â„•), u n / â†‘n) filter.at_top (nhds l)
s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â‰¤ s.sum (Î» (i : Î¹), f i â€¢ g i)
strict_convex ğ•œ ((Î» (x : E), x + z) â»Â¹' s)
dense_range stone_cech_unit
p1 -áµ¥ p2 âˆˆ vector_span k s
f =áµ[Î¼] g
x.lf y
â‡‘(algebra_map K E) (â‡‘(algebra.norm K) x) = finset.univ.prod (Î» (Ïƒ : L â†’â‚[K] E), â‡‘Ïƒ x)
â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) âˆˆ s
âˆƒ! (F : G â†’* H), âˆ€ (a : is_free_group.generators G), â‡‘F (is_free_group.of a) = f a
â‡‘measure_theory.measure_space.volume {Ï‰ : Î© | c â‰¤ |X Ï‰ - âˆ« (a : Î©), X a|} â‰¤ ennreal.of_real (probability_theory.variance X measure_theory.measure_space.volume / c ^ 2)
(s.bUnion g).sup_indep f
measurable_set (f '' s)
a - b < a - c â†” c < b
â†‘(T.re_apply_inner_self x) = has_inner.inner (â‡‘T x) x
measure_theory.integral Î¼ (X * Y) = measure_theory.integral Î¼ X * measure_theory.integral Î¼ Y
measure_theory.ae_strongly_measurable f Î¼ â†” ae_measurable f Î¼ âˆ§ âˆƒ (t : set Î²), topological_space.is_separable t âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ t
f = g
e.target = e'.target
â‡‘(f.lift hg) z = v â†” â‡‘g (f.sec z).fst = â‡‘g â†‘((f.sec z).snd) * v
metric.bounded (std_simplex â„ Î¹)
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆ© t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
(intermediate_field.adjoin F S).to_subfield â‰¤ K
E.is_solution u â†” u âˆˆ E.sol_space
is_domain (mv_polynomial (fin n) R)
âˆƒ (t : set (Î± Ã— Î±)) (H : t âˆˆ uniformity Î±), symmetric_rel t âˆ§ comp_rel t t âŠ† s
â‡‘Î¼ (measure_theory.to_measurable Î¼ t âˆ© s) = â‡‘Î¼ (t âˆ© s)
cont_mdiff_on I I'' n (g âˆ˜ f) s
â‡‘(s.affine_combination p) w = â‡‘(s.weighted_vsub_of_point p (classical.choice add_torsor.nonempty)) w +áµ¥ classical.choice add_torsor.nonempty
(fin.cast h).to_equiv = equiv.cast _
emetric.diam s â‰¤ ennreal.of_real C
has_Sup.Sup (coe '' t) âˆˆ s
category_theory.zigzag jâ‚ jâ‚‚
real.cos (inner_product_geometry.angle x y) = has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
f =o[nhds b] g â†” (f âˆ˜ â‡‘e) =o[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
metric.bounded s
measure_theory.conservative id Î¼
f = g
measurable (Î» (x : Î±), f (nat.find _) x)
f a â‰¤ f x
category_theory.is_iso Î±
1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
2 â€¢ hb.oangle x (-x) = 0
subsingleton (floor_ring Î±)
(finset.filter (Î» (i : â„•), j < c ^ i) (finset.range N)).sum (Î» (i : â„•), 1 / (c ^ i) ^ 2) â‰¤ c ^ 3 * (c - 1)â»Â¹ / j ^ 2
has_inner.inner (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚) (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚‚) = lâ‚‚.sum (Î» (i : Î¹) (y : ğ•œ), â‡‘(star_ring_end ğ•œ) (â‡‘lâ‚ i) * y)
category_theory.limits.has_colimit (category_theory.limits.span a b)
n = m
filter.tendsto u filter.at_top (nhds a)
A.mul Aâ»Â¹ = 1
category_theory.limits.has_strict_initial_objects C
v âˆˆ s.direction â†” âˆƒ (p2 : P) (H : p2 âˆˆ s), v = p2 -áµ¥ p
has_sum f r â†” filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i)) filter.at_top (nhds r)
filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_top
disjoint (t x) (â¨† (i : Î¹) (H : i âˆˆ y), t i)
algebra.finite_presentation R (A â§¸ I)
complete_lattice.is_compact_element (submodule.span R â†‘S)
a * b < 1
â‡‘({a}.order_emb_of_fin _) i = a
bdd_below s
filter.is_bounded r f â†” âˆƒ (s : set Î±) (H : s âˆˆ f.sets) (b : Î±), s âŠ† {x : Î± | r x b}
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€áµ (y : Î²) âˆ‚Î½, p (x, y)
set.eq_on f g U
has_compact_support f â†’ has_compact_support (Î» (x : Î±), âˆ¥f xâˆ¥)
padic_norm p 1 = 1
a - b = a + -b
submodule.map clifford_algebra.reverse (p ^ n) = submodule.map clifford_algebra.reverse p ^ n
xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚
category_theory.limits.has_binary_products (category_theory.over B)
uniform_embedding f â†” (âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a b : Î³}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : ennreal), Î´ > 0 â†’ (âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î³}, has_edist.edist (f a) (f b) < Îµ â†’ has_edist.edist a b < Î´)
s.card â‰¤ 5 ^ finite_dimensional.finrank â„ E
fermat_42.minimal a b c â†’ fermat_42.minimal a b (-c)
is_fractional S (algebra.adjoin R {x}).to_submodule
â‡‘(f.comp g) p = â‡‘f (â‡‘g p)
{r}.to_colex â‰¤ s.to_colex â†” âˆƒ (x : Î±) (H : x âˆˆ s), r â‰¤ x
(Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =o[filter.at_top] Î» (_x : â„•), 1
filter.tendsto (Î» (A : â„), âˆ« (x : Î±), probability_theory.truncation f A x âˆ‚Î¼) filter.at_top (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))
measure_theory.unif_integrable f p Î¼
âˆƒ (t : set P), s âŠ† t âˆ§ affine_independent k (Î» (p : â†¥t), â†‘p) âˆ§ affine_span k t = âŠ¤
disjoint x (has_Sup.Sup y)
continuous has_inv.inv
concave_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
0 < a + b
â‡‘Î¼ s = 0
ae_measurable f (Î¼.restrict s)
polynomial.cyclotomic (n * p) R = polynomial.cyclotomic n R ^ p
(is_localization.map Sâ‚˜ (P.quotient_map polynomial.C le_rfl) _).is_integral
f â‰« h = g â‰« h
has_deriv_within_at f f' (set.Ioi x) x â†’ has_deriv_within_at f f' (set.Ici x) x
filter.tendsto F filter.at_top (nhds f)
âˆ¥vâˆ¥ â‰¤ âˆ¥uâˆ¥ + âˆ¥u - vâˆ¥
âˆ« (x : Î±), âˆ« (y : Î²), (f + g) (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ + âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
s.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i)
concave_on â„ D f
â‡‘(c.lift f H) (â‡‘(c.mk') x) = â‡‘f x
approximates_linear_on â‡‘((hf.to_local_equiv hc).symm) â†‘(f'.symm) (f '' s) (âˆ¥â†‘(f'.symm)âˆ¥â‚Š * (âˆ¥â†‘(f'.symm)âˆ¥â‚Šâ»Â¹ - c)â»Â¹ * c)
set.image2 f s t = â‹ƒ (i : Î±) (H : i âˆˆ s) (j : Î²) (H : j âˆˆ t), {f i j}
s.finite
padic_norm p (â‡‘f (padic_seq.stationary_point hf)) = padic_norm p (â‡‘f (linear_order.max v1 (linear_order.max (padic_seq.stationary_point hf) v3)))
(âˆ€ (x : â„), x âˆˆ s â†’ f' x < m) âˆ¨ âˆ€ (x : â„), x âˆˆ s â†’ m < f' x
squarefree (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly â„¤ Î¼))
monoid.is_torsion_free â†¥H
finset.univ = finset.map equiv.perm.decompose_fin.symm.to_embedding finset.univ
transitive (Î» (a b : S), âˆƒ (c : S), add_semiconj_by c a b)
âˆƒ (i : Î¹) (H : i âˆˆ t), f (t.center_mass w p) â‰¤ f (p i)
a = p ^ (k + 1)
group.nilpotency_class â†¥H â‰¤ group.nilpotency_class G
category_theory.is_iso f
category_theory.subobject.mk f = X
algebraic_geometry.identity_to_Î“_Spec.app (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)) â‰« algebraic_geometry.Spec.to_LocallyRingedSpace.map (algebraic_geometry.Spec_Î“_identity.inv.app R).op = ğŸ™ ((ğŸ­ algebraic_geometry.LocallyRingedSpace).obj (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)))
category_theory.presieve.is_sheaf_for P (category_theory.presieve.singleton (ğŸ™ X))
convex ğ•œ (â‡‘f '' s)
has_deriv_at complex.cosh (complex.sinh x) x
metric.to_inductive_limit I n.succ âˆ˜ f n = metric.to_inductive_limit I n
â‡‘f x = â‡‘g x
coe â»Â¹' {â†‘x} = connected_component x
âˆƒ (x : set Î±) (H : x âˆˆ s), set.unbounded r x
is_compact (closure (coe_fn '' s))
category_theory.is_iso c.Î¹
padic_val_rat p (q / r) = padic_val_rat p q - padic_val_rat p r
interval_integrable f Î¼ a b â†” measure_theory.integrable_on f (set.interval_oc a b) Î¼
continuous â‡‘l â†” is_closed â†‘(l.ker)
A.det = A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 + A 0 2 * A 1 0 * A 2 1 - A 0 2 * A 1 1 * A 2 0
category_theory.mono f
0 â‰  1
Ïƒ * equiv.swap i j * equiv.swap i j = Ïƒ
3 âˆ£ n â†” 3 âˆ£ (10.digits n).sum
âˆ® (z : â„‚) in C(c, R), (z - w) ^ n = 0
(category_theory.presieve.family_of_elements.restrict _ x).sieve_extend = x
category_theory.strong_mono f
â†‘r â€¢ x = â†‘r â€¢ x
s.Î¹.app j â‰« k = s.Î¹.app j â‰« l
(polynomial.cyclotomic n R).degree = â†‘(n.totient)
interval_integrable g' measure_theory.measure_space.volume a b
measurable_set {x : E | differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K}
t.prod.leading_coeff = (multiset.map (Î» (f : polynomial R), f.leading_coeff) t).prod
category_theory.is_pullback 0 0 (ğŸ™ X) 0
p ^ r âˆ£ n.factorial â†” r â‰¤ (finset.Ico 1 b).sum (Î» (i : â„•), n / p ^ i)
(list.nat.antidiagonal n).length = n + 1
f^[n] â‰¤ (g^[n])
filter.tendsto (Î» (x : Î²), f x + g x) l filter.at_top
finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s
p i âˆˆ affine_span k (p '' s) â†” i âˆˆ s
function.surjective â‡‘(c.lift f h)
is_pi_system (set.image2 has_set_prod.prod {s : set Î± | measurable_set s} {t : set Î² | measurable_set t})
orthonormal â„ â‡‘(orientation.fin_orthonormal_basis hn h x)
category_theory.limits.has_equalizers C
C x
â‡‘(fourier n) (â‡‘exp_map_circle ((â†‘n)â»Â¹ * real.pi) * z) = -â‡‘(fourier n) z
is_glb s (has_Inf.Inf s)
0 < â‡‘(p.succ_above) i
f â‰« g = f â‰« h
directed r f
module.rank R (matrix m n R) = (cardinal.mk m).lift * (cardinal.mk n).lift
(mul_opposite.op r â€¢ A).map f = mul_opposite.op (f r) â€¢ A.map f
has_strict_deriv_at f f' x â†’ has_strict_fderiv_at f (1.smul_right f') x
x â‰¤ b ^ y â†” nat.clog b x â‰¤ y
âˆƒ (y : N), y * â‡‘f x = 1
is_closed (metric.cthickening Î´ E)
discrete_topology X â†” nhds = has_pure.pure
âˆƒ (q : â„š), v = â†‘q
X.to_Î“_Spec_fun â»Â¹' (prime_spectrum.basic_open r).val = (X.to_RingedSpace.basic_open r).val
algebra.discr K â‡‘b â‰  0
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.weighted_vsub_of_point pâ‚ b) w - â‡‘(s.weighted_vsub_of_point pâ‚‚ b) w
â‡‘f (-a) = -â‡‘f a
has_deriv_at (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x
t.prod (Î» (c : Î¹), f c) âˆˆ S
category_theory.limits.has_limit F
s.prod = âŠ¥ â†” âˆƒ (I : ideal R) (H : I âˆˆ s), I = âŠ¥
âˆƒ (Îµ : nnreal), 0 < Îµ âˆ§ âˆƒ (E : set Î±), measurable_set E âˆ§ 0 < â‡‘Î½ E âˆ§ 0.restrict E â‰¤ (Î¼.to_signed_measure - (Îµ â€¢ Î½).to_signed_measure).restrict E
uniform_embedding f
(âˆ‘' (x : Î²), f x) * âˆ‘' (y : Î³), g y = âˆ‘' (z : Î² Ã— Î³), f z.fst * g z.snd
measurable_set (set.range f)
module.End.has_eigenvector â†‘T â†‘((Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) xâ‚€) xâ‚€
padic_norm p (q + r) â‰¤ padic_norm p q + padic_norm p r
is_max_filter f l a â†’ is_min_filter (â‡‘order_dual.to_dual âˆ˜ f) l a
module.End.eigenspace (linear_map.restrict f hfp) Î¼ = âŠ¥
measure_theory.integrable_on f (set.Ioi a) measure_theory.measure_space.volume
measure_theory.measure.add_haar_measure topological_space.positive_compacts.Icc01 = measure_theory.measure_space.volume
algebra.finite_presentation R R
pairwise (disjoint on Î» (n : Î±), set.Ioo (f n) (f (order.pred n)))
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) = 0
f.mk' (f.sec z).fst (f.sec z).snd = z
âˆƒ (f : â„• â†’ Î±), strict_mono f
b â‰  âŠ¥
f =á¶ [l] g â†’ â†‘f = â†‘g
o.oangle x (-y) = o.oangle x y + â†‘real.pi
function.surjective â‡‘(algebra_map R L)
s.sum (Î» (x : Î±), f x) = t.sum (Î» (x : Î³), g x)
hwf.fix F x = F x (Î» (y : Î±) (h : r y x), hwf.fix F y)
â‡‘(linear_map.to_matrix complex.basis_one_I complex.basis_one_I) â†‘((â‡‘rotation a).to_linear_equiv) = â‡‘(matrix.plane_conformal_matrix â†‘a.re â†‘a.im _)
v.int_valuation_def r < 1 â†” v.as_ideal âˆ£ ideal.span {r}
âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ - âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
âˆƒ (H : subgroup G), N.is_complement' H
minpoly A (â‡‘(algebra_map A B) a) = polynomial.X - â‡‘polynomial.C a
(s.face h).points = s.points âˆ˜ â‡‘(fs.order_emb_of_fin h)
is_square a â†’ is_square aâ»Â¹
exp ğ•‚ (s.sum (Î» (i : Î¹), f i)) = s.noncomm_prod (Î» (i : Î¹), exp ğ•‚ (f i)) _
set.sized r â†‘(ğ’œ.slice r)
s.prod (Î» (a : Î±), f a) < âŠ¤
â‡‘(affine_map.line_map (slope f a b) (slope f b c)) ((c - b) / (c - a)) = slope f a c
â‡‘f x = â‡‘g y
finset.centroid k s p âˆˆ affine_span k (set.range p)
p1 âˆˆ affine_span k {p2} â†” p1 = p2
T.rotate âˆˆ dist_triang C
polynomial.cyclotomic 1 R = polynomial.X - 1
measurable (s.piecewise f g)
measure_theory.integrable_on f (set.interval_oc a b) Î¼
is_greatest ((Î» (g : Î¹ â†’ nnreal), s.sum (Î» (i : Î¹), f i * g i)) '' {g : Î¹ â†’ nnreal | s.sum (Î» (i : Î¹), g i ^ q) â‰¤ 1}) (s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p))
padic_norm p 0 = 0
â‡‘Î¼ A = â¨† (K : set Î±) (H : K âŠ† A) (h : is_closed K), â‡‘Î¼ K
f = g
function.injective â‡‘f
(Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a âŠ† spectrum ğ•œ (â‡‘(polynomial.aeval a) p)
metric.inf_dist x s = 0
euclidean_geometry.angle p1 p2 p1 = 0
module.rank R M = module.rank R Mâ‚
continuous_within_at (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) s xâ‚€
â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds (â‡‘(ext_chart_at I x) x)
set.Icc a b âˆª set.Icc c d = set.Icc (linear_order.min a c) (linear_order.max b d)
{s : set Î± | is_preconnected s} âŠ† set.range (function.uncurry set.Icc) âˆª set.range (function.uncurry set.Ico) âˆª set.range (function.uncurry set.Ioc) âˆª set.range (function.uncurry set.Ioo) âˆª (set.range set.Ici âˆª set.range set.Ioi âˆª set.range set.Iic âˆª set.range set.Iio âˆª {set.univ, âˆ…})
A.det = B.det
summable (Î» (i : Î¹), (f i + g i) ^ p) âˆ§ (âˆ‘' (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) + (âˆ‘' (i : Î¹), g i ^ p) ^ (1 / p)
metric.diam (metric.ball x r) â‰¤ 2 * r
function.injective fin.succ_above
f * laurent_polynomial.T m * laurent_polynomial.T n = f * laurent_polynomial.T (m + n)
f = s.order_emb_of_fin h
has_sbtw.sbtw c a b
group.nilpotency_class (G â§¸ H) â‰¤ group.nilpotency_class G
fâ‚ = fâ‚‚
âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
disjoint (â‡‘(convex_hull ğ•œ) â†‘s) (â‡‘(convex_hull ğ•œ) â†‘t) âˆ¨ âˆƒ (u : finset E) (H : u âˆˆ K.faces), â‡‘(convex_hull ğ•œ) â†‘s âˆ© â‡‘(convex_hull ğ•œ) â†‘t = â‡‘(convex_hull ğ•œ) â†‘u
âˆƒ (K : subgroup G), fintype.card â†¥K = p ^ m âˆ§ H â‰¤ K
is_fraction_ring â†¥(integral_closure A L) L
measure_theory.strongly_measurable f
concave_on â„ set.univ f
âˆƒ (a : X) (H : a âˆˆ closure s) (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ filter.tendsto (x âˆ˜ Ï†) filter.at_top (nhds a)
Â¬algebraic_topology.dold_kan.c.rel 0 j
finset.centroid k fsâ‚ s.points = finset.centroid k fsâ‚‚ s.points â†” fsâ‚ = fsâ‚‚
char.quadratic_char F (a * b) = char.quadratic_char F a * char.quadratic_char F b
â‡‘(f.map hy k) z + â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) = â‡‘(k.to_map) (â‡‘g (f.sec z).fst)
vector_span k (set.range p) = submodule.span k (set.range (Î» (i : Î¹), p i -áµ¥ p i0))
isometry coe
s.powerset.sum (Î» (t : finset Î±), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real
ideal.comap â†‘f (ideal.comap â†‘(f.symm) I) = I
x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
a + c < b + d
a âŠ‚ b â†’ a â‰  b
âŠ¤.direction = âŠ¤
is_right_regular a
measurable f â†’ mâ‚‚ â‰¤ measurable_space.map f mâ‚
âˆƒ (C : â„) (H : C > 0), âˆ€ â¦ƒx : Î±â¦„, g'' x â‰  0 â†’ âˆ¥f xâˆ¥ â‰¤ C * âˆ¥g'' xâˆ¥
(Î» (t : R), ring.inverse (â†‘x + t) - â†‘xâ»Â¹ + â†‘xâ»Â¹ * t * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ 2
star_convex ğ•œ x ((Î» (x : E), x + z) â»Â¹' s)
f âˆˆ algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â†‘(f.support))
â†‘(â‡‘(polynomial.gal.restrict p E) Ï• â€¢ x) = â‡‘Ï• â†‘x
linear_independent K b â†” fintype.card Î¹ = set.finrank K (set.range b)
real.sin (inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = real.sin (inner_product_geometry.angle x y)
is_right_regular a â†” is_smul_regular R (mul_opposite.op a)
interior (â‡‘(convex_hull â„) (set.range b.points)) = {x : E | âˆ€ (i : Î¹), 0 < â‡‘(b.coord i) x}
filter.tendsto (Î» (Ï€ : box_integral.tagged_prepartition I Ã— box_integral.tagged_prepartition I), (box_integral.integral_sum f vol Ï€.fst, box_integral.integral_sum f vol Ï€.snd)) ((l.to_filter I).prod (l.to_filter I) âŠ“ filter.principal {Ï€ : box_integral.tagged_prepartition I Ã— box_integral.tagged_prepartition I | Ï€.fst.Union = Ï€.snd.Union}) (uniformity F)
u x âŠ† â‹ƒ (x : Î±) (H : x âˆˆ s), u x
has_dist.dist (convolution (Ï†.normed Î¼) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) (g xâ‚€) â‰¤ Îµ
v âˆˆ Ká—® â†” âˆ€ (u : E), u âˆˆ K â†’ has_inner.inner u v = 0
â†‘a = â†‘b â†” â‡‘c a b
0 < order_of x
(â‹‚ (i : Î¹), s i) âŠ† t
subsingleton â†¥s â†” s.subsingleton
f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
n â€¢ b = â†‘n â€¢ b
Ï†.realize (â‡‘f âˆ˜ x) â†” Ï†.realize x
cont_diff_at ğ•œ n (Î» (x : E), (f x).fst) x
âˆ¥dslope f c zâˆ¥ â‰¤ Râ‚‚ / Râ‚
âˆƒ (t : Î¹ â†’ fin (h.card Îµ)), âˆ€ (iâ‚€ iâ‚ : Î¹), t iâ‚€ = t iâ‚ â†’ â†‘(â‡‘abv (A iâ‚ % b - A iâ‚€ % b)) < â‡‘abv b â€¢ Îµ
(mâ‚ âŠ” mâ‚‚).trim = mâ‚.trim âŠ” mâ‚‚.trim
âˆƒ (lb : â„¤), P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z
âˆƒ (z : â„‚), f.is_root z
U âˆˆ gal_basis K L â†” U âˆˆ subgroup.carrier '' fixed_by_finite K L
f = category_theory.eq_to_hom h â‰« g â‰« category_theory.eq_to_hom _ â†” f == g
finite_dimensional.finrank k â†¥(vector_span k â†‘(finset.image p s)) = n
u / v * v =á¶ [l] u
âˆƒ (U : set Î±) (H : U âˆˆ nhds_within x {x}á¶œ), disjoint U s
bdd_below â†‘s
p1 -áµ¥ p2 = 0 â†” p1 = p2
f (x - y) = f x - f y
s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = s.sum (Î» (i : Î¹), f i * g i) â†” monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
function.update g (f i) a âˆ˜ f = function.update (g âˆ˜ f) i a
continuous_within_at f (set.Ici a) a
(hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.biproduct.is_limit f)).hom = category_theory.limits.biproduct.lift b.Ï€
set.eq_on f g {z : â„‚ | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}
Â¬interval_integrable f measure_theory.measure_space.volume a b
âˆ«â» (a : Î±), g a âˆ‚Î¼.with_density f = âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼
f âˆˆ submodule.span k (â‡‘(add_monoid_algebra.of k G) '' â†‘(f.support))
category_theory.mono c.Î¹
(c.lift f H).comp c.mk' = f
â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
â‡‘zmod.Ï‡â‚ˆ' a = â‡‘zmod.Ï‡â‚„ â†‘a * â‡‘zmod.Ï‡â‚ˆ a
1 < a * b
continuous Z.proj
âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y
â‡‘f (bit1 a) = bit1 (â‡‘f a)
âˆƒ (y : Î±) (H : y âˆˆ t), has_dist.dist x y < r
a = p ^ nat.find _
(âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
measure_theory.ae_strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½) Î¼
AddMon.filtered_colimits.M.mk F x + AddMon.filtered_colimits.M.mk F y = AddMon.filtered_colimits.M.mk F âŸ¨k, â‡‘(F.map f) x.snd + â‡‘(F.map g) y.sndâŸ©
âˆƒ (t : fin n â†’ fin âŒˆ1 / ÎµâŒ‰â‚Š), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†’ â†‘|A iâ‚ % b - A iâ‚€ % b| < |b| â€¢ Îµ
â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |(â‡‘linear_map.det â†‘f)â»Â¹| * â‡‘Î¼ s
add_monoid.is_torsion_free G â†’ Â¬add_monoid.is_torsion G
e.to_local_equiv.source âˆ© â‡‘e â»Â¹' interior s = e.to_local_equiv.source âˆ© interior (â‡‘e â»Â¹' s)
â‡‘h xâ»Â¹ = (â‡‘h x)â»Â¹
same_ray R (r â€¢ x) y
o.oangle (â‡‘(o.rotation (o.oangle x y)) x) y = 0
(uniformity Î±).has_basis (Î» (V : set (Î± Ã— Î±)), V âˆˆ uniformity Î±) closure
â†‘(finite_dimensional.finrank K V) = cardinal.mk Î¹
function.injective coe_fn
â†‘r < p.radius
function.update (fin.snoc p x) (fin.last n) z = fin.snoc p z
âˆƒ (V : set Î±), is_open V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ is_compact (closure V)
char_p (R â§¸ I) p
is_cyclotomic_extension S K K
a âŠ† b â†’ b âŠ† c â†’ a âŠ† c
measure_theory.condexp m Î¼ (s.indicator f) =áµ[Î¼] s.indicator (measure_theory.condexp m Î¼ f)
filter.tendsto (Î» (n : â„•), (â‡‘(f ^ n) x - x) / â†‘n) filter.at_top (nhds f.translation_number)
(â¨† (i : Î¹), f i) = b
concave_on ğ•œ s (f âŠ“ g)
g y (â‡‘f y) + (finsupp.erase y f).sum g = f.sum g
category_theory.strong_mono (f â‰« g)
measure_theory.outer_measure.mk_metric mâ‚ â‰¤ c â€¢ measure_theory.outer_measure.mk_metric mâ‚‚
measurable g
x â€¢ mâ»Â¹ = (x â€¢ m)â»Â¹
has_edist.edist (f n) a â‰¤ âˆ‘' (m : â„•), d (n + m)
â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |â‡‘linear_map.det â†‘(f.symm)| * â‡‘Î¼ s
(category_theory.category_of_elements.from_costructured_arrow F).right_op â‹™ category_theory.category_of_elements.to_costructured_arrow F = ğŸ­ (category_theory.costructured_arrow category_theory.yoneda F)
measure_theory.is_probability_measure (probability_theory.cond Î¼ s)
2 â€¢ o.oangle x (-x) = 0
f = g
âˆ¥fâˆ¥ â‰¤ M
(Î» (x : Î±), x) '' s = s
inner_product_geometry.angle 0 x = real.pi / 2
f = g
is_square a
â‡‘(Î¼.restrict s) t = â‡‘Î¼ (t âˆ© s)
f =O[l] g' â†” âˆ€á¶  (c : â„) in filter.at_top, âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g' xâˆ¥
(â¨… (i : Î¹), (K i)á—®) = (supr K)á—®
z âˆˆ algebra.adjoin R {B.gen}
metric.bounded (set.range f) â†” âˆƒ (C : â„), âˆ€ (x y : Î²), has_dist.dist (f x) (f y) â‰¤ C
M ^ k = â‡‘(polynomial.aeval M) (polynomial.X ^ k %â‚˜ M.charpoly)
p s
category_theory.limits.has_colimit (category_theory.limits.parallel_pair f g)
affine_span k (set.range p) = âŠ¤ â†” fintype.card Î¹ = finite_dimensional.finrank k V + 1
euclidean_geometry.angle p1 (midpoint â„ p1 p2) p2 = real.pi
mul_action.fixed_points â†¥(P âŠ” Q) Î± = mul_action.fixed_points â†¥P Î± âˆ© mul_action.fixed_points â†¥Q Î±
set.center MË£ = coe â»Â¹' set.center M
â‡‘Î¼ (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) = I.sum (Î» (i : Î¹), â‡‘Î¼ (s i))
(list.of_fn f).nth i = list.of_fn_nth_val f i
filter.tendsto (Î» (n : â„•), â†‘n ^ k * r ^ n) filter.at_top (nhds 0)
âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ x
âˆƒ (f : bump_covering Î¹ X s), (âˆ€ (i : Î¹), p â‡‘(â‡‘f i)) âˆ§ f.is_subordinate U
f.fix a = f.fix a'
is_closed (function.fixed_points f)
is_preconnected s â†’ convex â„ s
âˆƒ (F : circle_deg1_lift), function.semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
â‡‘(add_con.ker f) x y â†” â‡‘f x = â‡‘f y
F.map (category_theory.eq_to_hom p) = category_theory.eq_to_hom _
measure_theory.measure.map f ((Î¼.restrict s).with_density (Î» (x : E), ennreal.of_real |(f' x).det|)) = Î¼.restrict (f '' s)
(has_Inf.Inf S).to_setoid = has_Inf.Inf (con.to_setoid '' S)
filter.at_top = filter.comap coe filter.at_top
(âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.range (n + 1)).sum (Î» (k : â„•), f k * g (n - k))
filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), 1 / (â†‘i + 1))) filter.at_top filter.at_top
unique_factorization_monoid.factors x = unique_factorization_monoid.normalized_factors x
function.update g i a âˆ˜ f = g âˆ˜ f
â‡‘f (exp ğ•‚ x) = exp ğ•‚ (â‡‘f x)
convex â„ s â†’ is_preconnected s
filter.tendsto f filter.at_top filter.at_top â†” âˆ€ (b : Î²), âˆƒ (i : Î±), âˆ€ (a : Î±), i â‰¤ a â†’ b â‰¤ f a
S = T
âˆƒ (f : â„ â†’ E), f tâ‚€ = xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ set.Icc t_min t_max â†’ has_deriv_within_at f (v t (f t)) (set.Icc t_min t_max) t
metric.diam s = has_Sup.Sup s - has_Inf.Inf s
â‡‘multiset.card (polynomial.nth_roots n 1) = n
âˆƒ (s : C) (Î± : kâ‚ âŸ¶ s) (Î² : l âŸ¶ s) (Î³ : kâ‚‚ âŸ¶ s), fâ‚ â‰« Î± = gâ‚ â‰« Î² âˆ§ fâ‚‚ â‰« Î± = fâ‚ƒ â‰« Î³ âˆ§ fâ‚„ â‰« Î³ = gâ‚‚ â‰« Î²
f a * (s.erase a).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
is_topological_fiber_bundle F Z.proj
b â‰¤ a â†’ â‡‘order_dual.to_dual a â‰¤ â‡‘order_dual.to_dual b
x = y
prod.topological_space = topological_space.induced (Î» (p : Î± Ã— Î³), (f p.fst, g p.snd)) prod.topological_space
(0 * x).equiv 0
has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2| â†” euclidean_geometry.angle p1 p2 p3 = 0
cardinal.mk (W_type Î²) â‰¤ linear_order.max (cardinal.mk Î±) cardinal.aleph_0
âˆƒ (f : E â†’ â„), f =á¶ [nhds x] 1 âˆ§ (âˆ€ (y : E), f y âˆˆ set.Icc 0 1) âˆ§ cont_diff â„ âŠ¤ f âˆ§ has_compact_support f âˆ§ tsupport f âŠ† s
ray_of_ne_zero R (r â€¢ v) hrv = ray_of_ne_zero R v h
(category_theory.cover_dense.types.pushforward_family H Î± x).compatible
s âˆˆ nhds_within a (set.Ioi a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ioo a u âŠ† s
s.prod (Î» (i : Î¹), f i) < âŠ¤
â‡‘(e.det) â‡‘(e.units_smul w) = finset.univ.prod (Î» (i : Î¹), â†‘(w i))
finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i)
locally_compact_space M
Â¬(a âˆ¨ b) â†” Â¬a âˆ§ Â¬b
z = g â€¢ z
s.prod (Î» (x : Î±), ite (x = a) (b x) 1) = ite (a âˆˆ s) (b a) 1
no_zero_smul_divisors R A
(cardinal.sup f).lift = cardinal.sup (Î» (i : Î¹), (f i).lift)
category_theory.limits.pullback.lift category_theory.limits.pullback.snd (category_theory.limits.pullback.fst â‰« algebraic_geometry.Scheme.pullback.p2 ğ’° f g) _ â‰« (algebraic_geometry.Scheme.pullback.gluing ğ’° f g).Î¹ i = category_theory.limits.pullback.fst
L.join.nth_le ((list.take i (list.map list.length L)).sum + j) _ = (L.nth_le i hi).nth_le j hj
(Î» (x : Î±), -f' x) =O[l] g â†’ f' =O[l] g
category_theory.is_iso f
Â¬x.lf y â†” y â‰¤ x
set.sized (r - 1) â†‘(ğ’œ.shadow)
â†‘(â‡‘(orthogonal_projection K) u) = â†‘(â‡‘(orthogonal_projection K') u)
(âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
affine_span k (has_insert.insert p â†‘(affine_span k ps)) = affine_span k (has_insert.insert p ps)
Ï.character (h * g * hâ»Â¹) = Ï.character g
finite_dimensional k â†¥(vector_span k s)
f '' add_monoid.closure s = add_monoid.closure (f '' s)
(mâ‚ + mâ‚‚).trim = mâ‚.trim + mâ‚‚.trim
fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(mul_action.stabilizer Î± Ï‰.out'))
âˆƒ (x : Î±) (H : x âˆˆ s) (y : Î±) (H : y âˆˆ s), x â‰  y âˆ§ f x = f y
function.surjective â‡‘f
(algebraic_topology.dold_kan.HÏƒ q).f 0 = 0
box_integral.has_integral I l f vol (â‡‘g I)
s Ã—Ë¢ t âŠ† sâ‚ Ã—Ë¢ tâ‚ â†” s âŠ† sâ‚ âˆ§ t âŠ† tâ‚ âˆ¨ s = âˆ… âˆ¨ t = âˆ…
local_ring R
0 < f.prod has_pow.pow
measure_theory.integrable_on (Î» (x : â„), âˆ¥real.exp (-x) * real.log x * x ^ (s - 1)âˆ¥) (set.Ioi 0) measure_theory.measure_space.volume
(s.product t).sum (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = t.sum (Î» (y : Î±), s.sum (Î» (x : Î³), f x y))
â‡‘complex.norm_sq â†‘(modular_group.S â€¢ z) < 1
z = â†‘(z.re)
â‡‘f x = finset.univ.sum (Î» (i : Î¹), x i â€¢ â‡‘f (Î» (j : Î¹), ite (i = j) 1 0))
continuous_on f s
dense (â‹‚â‚€ S)
âˆƒ (i : D.J) (y : F.obj (D.U i)), F.map (D.Î¹ i) y = x
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
multiset.count p (unique_factorization_monoid.normalized_factors x) = n
p (â‡‘(closure_operator.mkâ‚ƒ f p hf hfp hmin) x)
(A.minor â‡‘e â‡‘e).det = A.det
â‡‘(measure_theory.measure.mk_metric m) s â‰¤ l.liminf (Î» (n : Î²), finset.univ.sum (Î» (i : Î¹ n), m (emetric.diam (t n i))))
âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2
X.Ïƒ (â‡‘fin.cast_succ j) â‰« X.Î´ i.succ = X.Î´ i â‰« X.Ïƒ j
f = g
a â‰  0
has_Inf.Inf (s âˆª t) = has_Inf.Inf s âŠ“ has_Inf.Inf t
asymptotics.is_O_with c l f' g â†’ asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) g
submodule.span ğ•œ (gram_schmidt ğ•œ f '' set.Iio c) = submodule.span ğ•œ (f '' set.Iio c)
(â¨† (i : Î¹) (h : p i), S i) = ((â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (S i).subtype)).comp (dfinsupp.filter_linear_map R (Î» (i : Î¹), â†¥(S i)) p)).range
path.homotopic.proj_left (path.homotopic.prod qâ‚ qâ‚‚) = qâ‚
complete_lattice.independent p â†” function.injective â‡‘(dfinsupp.sum_add_hom (Î» (i : Î¹), (p i).subtype))
(L.prod)â»Â¹ = (list.map (Î» (x : G), xâ»Â¹) L).prod
subsingleton Î± âˆ¨ nontrivial Î±
(s1 âŠ” s2).direction = s1.direction âŠ” s2.direction âŠ” submodule.span k {p2 -áµ¥ p1}
(category_theory.limits.is_limit.of_nat_iso.limit_cone h).extend (category_theory.limits.is_limit.of_nat_iso.hom_of_cone h s) = s
âˆƒ (iâ‚€ iâ‚ : fin m.succ), iâ‚€ â‰  iâ‚ âˆ§ (A iâ‚ - A iâ‚€).degree < â†‘(b.nat_degree - d)
iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x
cont_mdiff (model_with_corners_self â„ â„) (model_with_corners_self â„ (euclidean_space â„ (fin 1))) âŠ¤ â‡‘exp_map_circle
p.mapq pâ‚ƒ (g.comp f) h = (pâ‚‚.mapq pâ‚ƒ g hg).comp (p.mapq pâ‚‚ f hf)
char.quadratic_char F a = ite (a ^ (fintype.card F / 2) = 1) 1 (-1)
(âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, p x) â†” âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, p x
cont_diff_at ğ•œ n (Î» (x : E), f x â€¢ g x) x
f.srange = âŠ¤
â‡‘(exp_series ğ•‚ ğ”¸ n) (Î» (_x : fin n), x) = â‡‘(exp_series ğ•‚' ğ”¸ n) (Î» (_x : fin n), x)
is_conformal_map f â†” âˆƒ (c : â„), 0 < c âˆ§ âˆ€ (u v : E), has_inner.inner (â‡‘f u) (â‡‘f v) = c * has_inner.inner u v
filter.map n (filter.mapâ‚‚ m f g) = filter.mapâ‚‚ m' g (filter.map n' f)
â‡‘(n.central_binom.factorization) p = 0
set.Icc x z  set.univ.pi (Î» (i : Î¹), set.Ioc (y i) (z i)) âŠ† â‹ƒ (i : Î¹), set.Icc x (function.update z i (y i))
âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
monotone f â†’ antitone (â‡‘order_dual.to_dual âˆ˜ f)
uâ»Â¹ â€¢ v = u â€¢ v
is_compact s â†’ s.nonempty â†’ âˆ€ {f : Î² â†’ Î±}, continuous_on f s â†’ (âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f y â‰¤ f x)
polish_space â†¥s
f = 0
â‡‘clifford_algebra_quaternion.to_quaternion (â‡‘clifford_algebra.involute (â‡‘clifford_algebra.reverse c)) = â‡‘quaternion_algebra.conj (â‡‘clifford_algebra_quaternion.to_quaternion c)
nat.prime p
is_closed_map â‡‘f
lipschitz_with âŸ¨âˆ¥fâˆ¥, _âŸ© â‡‘f
|b - x| â‰¤ |b - a|
metric.diam s = 0
âˆƒ (c : S) (d : R) (H : d â‰  0), d â€¢ a = b * c
s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
bornology.is_bounded s â†’ bornology.is_cobounded sá¶œ
closure (set.Ioi a) = set.Ici a
f = g
f (a â€¢ x + b â€¢ y) < linear_order.max (f x) (f y)
p (s.prod (Î» (x : Î±), f x))
t.center_mass w (f âˆ˜ p) â‰¤ f (t.center_mass w p)
strict_anti f â†’ strict_mono (â‡‘order_dual.to_dual âˆ˜ f)
add_group.fg G â†” add_monoid.fg G
category_theory.limits.limit.pre F E = (category_theory.limits.limit.iso_limit_cone t).hom â‰« s.is_limit.lift (category_theory.limits.cone.whisker E t.cone) â‰« (category_theory.limits.limit.iso_limit_cone s).inv
continuous â‡‘f
â‡‘(S.normed_mk) m = â‡‘(quotient_add_group.mk' S) m
(matrix.kronecker_map has_mul.mul A B).is_diag
has_deriv_at (exp ğ•‚) 1 0
(â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) = â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
C x hx
function.injective f â†’ function.injective (set.cod_restrict f t h)
(p.take_until u h).append (p.drop_until u h) = p
f.lintegral Î¼ â‰¤ g.lintegral Î½
f i = 1
finset.univ.sum (Î» (i : Î¹), âˆ¥x iâˆ¥) â‰¤ fintype.card Î¹ â€¢ âˆ¥xâˆ¥
u.r + (u.bp + 1) * u.q = u.ap + 1
âˆƒ (a : Î±), cardinal.mk â†¥(f â»Â¹' {a}) = cardinal.mk Î²
âˆ« (x : Î±), f x âˆ‚Î¼ = I
f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
metric.bounded s
is_compact (set.univ.pi s)
l.prod.degree = (list.map polynomial.degree l).sum
(equiv_functor.map_equiv f ab).trans (equiv_functor.map_equiv f bc) = equiv_functor.map_equiv f (ab.trans bc)
is_smul_regular M 1
is_glb s (has_Inf.Inf s)
cont_diff ğ•œ m (Î» (p : E Ã— E), â‡‘(fderiv ğ•œ f p.fst) p.snd)
â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
((Î» (x : Î±), 1) =O[l] Î» (x : Î±), real.exp (f x)) â†” filter.is_bounded_under ge l f
âˆƒ (N : T.Model), Îº.lift â‰¤ cardinal.mk â†¥N
âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
âˆƒ (g : E â†’L[â„] â„), (âˆ€ (x : â†¥p), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥
setoid.ker f = r
emetric.Hausdorff_edist s t = 0 â†” s = t
x â‰  y â†’ r x y â†” r x y
has_pure.pure â‰¤ linear_ordered_comm_group_with_zero.nhds_fun Î“â‚€
function.injective2 fin.cons
o.oangle (-x) y + o.oangle (-y) z + o.oangle (-z) x = â†‘real.pi
a = b â†’ a / b = 1
a â‰¤ b â†’ b < c â†’ a < c
âˆ¥fâˆ¥ = 0 â†” f = 0
a - b < c â†’ a < b + c
â‡‘(algebra_map K F) (â‡‘(algebra.trace K S) pb.gen) = (polynomial.map (algebra_map K F) (minpoly K pb.gen)).roots.sum
S = âŠ¥ âˆ¨ âˆƒ (x : M) (H : x âˆˆ S), x â‰  0
âˆ¥dGamma_integrand t xâˆ¥ â‰¤ dGamma_integrand_real s1 x + dGamma_integrand_real s2 x
p x hx
finite_dimensional.finrank R (Î¹ â†’â‚€ R) = fintype.card Î¹
category_theory.is_iso c.Î¹
Î¼.regular
â†‘(pâ‚.nat_degree) - â†‘(qâ‚.nat_degree) = â†‘(pâ‚‚.nat_degree) - â†‘(qâ‚‚.nat_degree)
(cardinal.sup f).lift â‰¤ t
cluster_pt x (filter.principal s) â†” âˆ€ (U : set Î±), U âˆˆ nhds x â†’ (U âˆ© s).nonempty
âˆƒ (y : Î²), (finset.filter (Î» (x : Î±), f x = y) finset.univ).card < n
function.injective coe_fn
âˆƒ (V : open_subgroup G), â†‘V Ã—Ë¢ â†‘V âŠ† U
C x hx
(m âˆˆ â¨† (i : Î¹), p i) â†” âˆƒ (s : finset Î¹), m âˆˆ â¨† (i : Î¹) (H : i âˆˆ s), p i
L.prod = 0
f = â‡‘f â‡‘e â€¢ e.det
x âŠ“ y âˆˆ F
â‡‘c x y â†’ â‡‘c y x
â‡‘(â‡‘f'' v) w = â‡‘(â‡‘f'' w) v
set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))
f.inverse = (ring.inverse (â†‘(e.symm).comp f)).comp â†‘(e.symm)
(o.rotation Î¸).symm = o.rotation (-Î¸)
has_strict_deriv_at (Î» (x : â„), (e â†‘x).re) e'.re z
cont_diff ğ•œ âŠ¤ â‡‘(equiv.prod_assoc E F G)
âˆƒ (C : â„) (H : C > 0), âˆ€ (y : F), âˆƒ (x : E), â‡‘f x = y âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
â‡‘Î¼ s = â‡‘Î¼ t
â‡‘f 0 = 0
fin_succ_equiv' 0 = fin_succ_equiv n
â‡‘(star_ring_end R) (â‡‘(star_ring_end R) x) = x
â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) * â‡‘(f.map hy k) z = â‡‘(k.to_map) (â‡‘g (f.sec z).fst)
R âˆˆ â‡‘J X
(âˆ€ (x : K), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
s1 = s2
measurable_set (f '' s)
is_closed â†‘(E.fixing_subgroup)
â‡‘(s.weighted_vsub_of_point (Î» (_x : Î¹), p) b) w = s.sum (Î» (i : Î¹), w i) â€¢ (p -áµ¥ b)
(list.nat.antidiagonal_tuple k n).nodup
â‡‘(s.order_emb_of_fin h) âŸ¨0, hzâŸ© = s.min' _
metric.Hausdorff_dist s t = 0 â†” closure s = closure t
function.injective free_group.of
a * b = 0 â†” b * a = 0
A.to_colex â‰¤ B.to_colex
continuous (Î» (st : Î² Ã— Î±), f st.fst (int.fract st.snd))
âˆƒ (q : S) (r : R) (H : r âˆˆ class_group.finset_approx bS adm), â‡‘abv (â‡‘(algebra.norm R) (r â€¢ a - b â€¢ q)) < â‡‘abv (â‡‘(algebra.norm R) (â‡‘(algebra_map R S) b))
a * u âˆ£ b â†” a âˆ£ b
padic_norm p â†‘p < 1
â‡‘((a.pred ha).succ_above) (b.pred hb) = (â‡‘(a.succ_above) b).pred hk
f = g
f m â‰¤ g n
polynomial.cyclotomic p R = (finset.range p).sum (Î» (i : â„•), polynomial.X ^ i)
box_integral.integrable I l f Î¼.to_box_additive.to_smul
has_strict_fderiv_at g â†‘(f'.symm) (f a)
category_theory.is_iso f
(âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), h + g) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_add_right_invariant
(b.to_matrix â‡‘b').mul (b'.to_matrix b'') = b.to_matrix b''
p x hx
category_theory.eq_to_hom _ â‰« C.d i' j = C.d i j
âˆƒ (q : â„š), (generalized_continued_fraction.of v).convergents n = â†‘q
s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
âˆ¥f zâˆ¥ â‰¤ C
cont_mdiff_on I I' n f s
â‡‘fâ‚ pâ‚ = â‡‘fâ‚‚ pâ‚‚
is_smul_regular M (a ^ n)
lie_algebra.is_nilpotent R L â†” âˆ€ (x : L), is_nilpotent (â‡‘(lie_algebra.ad R L) x)
hb.oangle (-x) x = â†‘real.pi
â‡‘(formal_multilinear_series.id ğ•œ E n) v = v âŸ¨0, _âŸ©
v âˆˆ s.direction â†” âˆƒ (p1 : P) (H : p1 âˆˆ s) (p2 : P) (H : p2 âˆˆ s), v = p1 -áµ¥ p2
summable (Î» (n : â„•), x ^ n)
(âˆ€ (x y : Î±), has_nndist.nndist x y â‰¤ K * has_nndist.nndist (f x) (f y)) â†’ antilipschitz_with K f
q = 1 â†” p = 0
affine_span k s = âŠ¤ â†” vector_span k s = âŠ¤
totally_bounded s
âˆƒ (M : set Î±), is_max_chain r M âˆ§ c âŠ† M
prod.map g g' âˆ˜ prod.map f f' = prod.map (g âˆ˜ f) (g' âˆ˜ f')
â‡‘f (s.piecewise (Î» (i : Î¹), c i â€¢ m i) m) = s.prod (Î» (i : Î¹), c i) â€¢ â‡‘f m
0 â‰¤ gauge s x
x.sieve_extend.compatible
interior (frontier s) = âˆ…
(âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
first_order.language.Structure.cg L M â†” âˆƒ (S : set M), S.countable âˆ§ â‡‘(first_order.language.substructure.closure L) S = âŠ¤
measure_theory.integrable_on (Î» (x : â„), â†‘(real.exp (-x)) * â†‘(real.log x) * â†‘x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume âˆ§ has_deriv_at complex.Gamma_integral (âˆ« (x : â„) in set.Ioi 0, â†‘(real.exp (-x)) * â†‘(real.log x) * â†‘x ^ (s - 1)) s
category_theory.limits.has_pushout g f
embedding f
mul_opposite.unop (â‡‘f l.prod) = (list.map (mul_opposite.unop âˆ˜ â‡‘f) l).reverse.prod
has_inner.inner x (â‡‘(â‡‘continuous_linear_map.adjoint A) y) = has_inner.inner (â‡‘A x) y
(v.on_quot hJ).supp = ideal.map (ideal.quotient.mk J) v.supp
â‡‘(s.order_emb_of_fin h) i = â‡‘(s.order_emb_of_fin h') j â†” â†‘i = â†‘j
y âˆˆ omega_limit f Ï• s â†” âˆ€ (n : set Î²), n âˆˆ nhds y â†’ (âˆƒá¶  (t : Ï„) in f, (Ï• t '' s âˆ© n).nonempty)
cont_diff_within_at ğ•œ n (Î» (x : E), (f x, g x)) s x
(submodule.span â„‚ (set.range fourier)).topological_closure = âŠ¤
(lower_bounds s âˆ© t).nonempty â†’ bdd_below (f '' s)
âˆ€á¶  (Î´ : nnreal) in nhds_within 0 (set.Ioi 0), âˆ€ (s : set E) (f : E â†’ E), approximates_linear_on f A s Î´ â†’ â‡‘Î¼ (f '' s) â‰¤ â†‘m * â‡‘Î¼ s
filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_bot
category_theory.limits.has_finite_biproducts C
â‡‘(f.lift hg) z + w = v â†” â‡‘g (f.sec z).fst + w = â‡‘g â†‘((f.sec z).snd) + v
is_smul_regular M (a * b) âˆ§ is_smul_regular M (b * a) â†” is_smul_regular M a âˆ§ is_smul_regular M b
strict_concave_on â„ D f
(matrix.from_blocks A B C D).is_hermitian
finite_dimensional.finrank K â†¥(submodule.map f p) â‰¤ finite_dimensional.finrank K â†¥p
p -áµ¥ p1 = p -áµ¥ p2 â†” p1 = p2
âˆ¥x + yâˆ¥ â‰¤ âˆ¥xâˆ¥ + âˆ¥yâˆ¥
A âˆˆ i.ess_image
(x â¨¯ y) = x âŠ“ y
L.join.split_wrt_composition c = L
matrix.circulant (k â€¢ v) = k â€¢ matrix.circulant v
v +áµ¥ p âˆˆ s â†” v âˆˆ s.direction
is_noetherian S M
category_theory.is_connected J
(ideal.map (algebra_map R S) I).is_maximal
A.topological_closure = âŠ¤
is_open s â†” âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (V : set (Î± Ã— Î±)) (H : V âˆˆ uniformity Î±), uniform_space.ball x V âŠ† s)
âˆƒ (L L' : list (matrix.transvection_struct n ğ•œ)) (D : n â†’ ğ•œ), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
finset.centroid k finset.univ (s.face hâ‚).points = finset.centroid k finset.univ (s.face hâ‚‚).points â†” fsâ‚ = fsâ‚‚
(c.lift f H).mrange = f.mrange
topological_group G
uniform_continuous (Î» (x : Î±), metric.inf_dist x s)
J.is_maximal â†” (ideal.comap (algebra_map R S) J).is_maximal âˆ§ y âˆ‰ ideal.comap (algebra_map R S) J
(fundamental_groupoid.fundamental_groupoid_functor.map f).map âŸ¦pâŸ§ == (fundamental_groupoid.fundamental_groupoid_functor.map g).map âŸ¦qâŸ§
s = {x : Î± | (setoid.mk_classes c H).rel x y}
measurable_set {x : â„ | differentiable_within_at â„ f (set.Ici x) x âˆ§ deriv_within f (set.Ici x) x âˆˆ K}
(category_theory.subobject.pullback g).obj (fâ‚ âŠ“ fâ‚‚) = (category_theory.subobject.pullback g).obj fâ‚ âŠ“ (category_theory.subobject.pullback g).obj fâ‚‚
mul_opposite.unop (â‡‘f l.prod) = (list.map (mul_opposite.unop âˆ˜ â‡‘f) l).reverse.prod
ordinal.principal has_mul.mul o â†” o â‰¤ 2 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a
G.degree v â‰¤ G.max_degree
homotopy.null_homotopic_map hom â‰« g = homotopy.null_homotopic_map (Î» (i j : Î¹), hom i j â‰« g.f j)
o.rotation â†‘Î¸ = hb.rotation â†‘Î¸
(âˆ€ (a : L), a âˆˆ m â†’ a âˆˆ S) â†’ m.prod âˆˆ S
discrete_valuation_ring R
set.maps_to g (function.fixed_points fa) (function.fixed_points fb)
âˆƒ (Ï– : R), irreducible Ï–
1 â‰¤ a * b
âˆƒ (x : Î±), x âˆˆ S âˆ§ is_closed {x}
(finset.filter (Î» (i : â„•), j < â†‘âŒŠc ^ iâŒ‹â‚Š) (finset.range N)).sum (Î» (i : â„•), 1 / â†‘âŒŠc ^ iâŒ‹â‚Š ^ 2) â‰¤ c ^ 5 * (c - 1)â»Â¹ ^ 3 / j ^ 2
cardinal.mk Î¹ â‰¤ â†‘(fintype.card â†¥w)
aâ»Â¹ â‰¤ b â†’ bâ»Â¹ â‰¤ a
s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
topological_space.second_countable_topology Î±
vector_span k {p} = âŠ¥
a * b â‰¤ 1
Ï†â‚ = Ï†â‚‚
has_sum f (s.sum (Î» (b : Î²), f b))
differentiable_at ğ•œ f x
(matrix.circulant v).mul (matrix.circulant w) = matrix.circulant ((matrix.circulant v).mul_vec w)
â‡‘(f.lift hg) z = v â†” â‡‘g (f.sec z).fst = â‡‘g â†‘((f.sec z).snd) + v
âˆ¥-xâˆ¥ = âˆ¥xâˆ¥
f = g
nonempty (Z j)
â‡‘Î¼ s = 0
continuous (Î» (p : bounded_continuous_function Î± Î² Ã— Î±), â‡‘(p.fst) p.snd)
â†‘(â‡‘(orthogonal_projection K) u) = v
linear_independent R (â‡‘f âˆ˜ v)
is_R_or_C.abs (has_inner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
(â¨† (i : Î¹), A i) = (direct_sum.coe_alg_hom A).range.to_submodule
(â‡‘â¨… (i : Î¹) (H : i âˆˆ I), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹) (H : i âˆˆ I), â‡‘(m i) (t n)
âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
is_compl (A i) (A j)
âˆ« (x : G), f x âˆ‚Î¼ = 0
category_theory.is_iso (category_theory.limits.coequalizer.Ï€ f g)
fderiv â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (a, b) = (continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)
measure_theory.integrable_on (Î» (x : â„), real.exp (-b * x)) (set.Ioi a) measure_theory.measure_space.volume
polynomial.splits (ring_hom.id K) (polynomial.cyclotomic' n K)
category_theory.sieve.generate R = âŠ¤
(â‹‚ (i : Î¹'), s i) = â‹‚ (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
vector.map id v = v
algebra.finite_presentation R (mv_polynomial Î¹ A)
bdd_below s â†’ bdd_below (f '' s)
(Î¼.restrict s).to_outer_measure = â‡‘(measure_theory.outer_measure.restrict s) Î¼.to_outer_measure
s.finite
padic_val_rat p q = â†‘((multiplicity â†‘p n).get _) - â†‘((multiplicity â†‘p d).get _)
(Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom â‰« category_theory.limits.pi.Ï€ (Î» (i : Î£ (V : topological_space.opens â†¥X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R i))) f = category_theory.limits.pi.Ï€ (Î» (f : Î£ (V : topological_space.opens â†¥X), {f // R f}), F.obj (opposite.op f.fst)) f
nat.find _ = group.nilpotency_class G
â‡‘f' y = 0
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * has_inner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
y âˆˆ S â†’ âˆ€ {x : K}, x â€¢ y âˆˆ S
category_theory.idempotents.to_karoubi (J â¥¤ C) â‹™ category_theory.idempotents.karoubi_functor_category_embedding J C = (category_theory.whiskering_right J C (category_theory.idempotents.karoubi C)).obj (category_theory.idempotents.to_karoubi C)
(tactic.ring2.horner_expr.of_csexpr r).is_cs âˆ§ tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r) = tactic.ring2.csring_expr.eval t r
â‡‘(s.weighted_vsub p) wâ‚ +áµ¥ â‡‘(s.affine_combination p) wâ‚‚ = â‡‘(s.affine_combination p) (wâ‚ + wâ‚‚)
(affine_span k (has_insert.insert p2 â†‘s)).direction = submodule.span k {p2 -áµ¥ p1} âŠ” s.direction
filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_top
category_theory.limits.initial_mono_class C
s.countable â†’ (complex.exp â»Â¹' s).countable
A.is_diag â†” matrix.diagonal A.diag = A
tendsto_locally_uniformly_on F f p s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆ€ (x : Î²), x âˆˆ s â†’ (âˆƒ (t : set Î²) (H : t âˆˆ nhds_within x s), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_dist.dist (f y) (F n y) < Îµ)
âˆ¥fâˆ¥ â‰¤ C
metric.Hausdorff_dist (Î¦ '' s) (Î¦ '' t) = metric.Hausdorff_dist s t
â‡‘f 0 = 0
cont_mdiff (model_with_corners_self â„ (euclidean_space â„ (fin n))) (model_with_corners_self â„ (euclidean_space â„ (fin n))) âŠ¤ (Î» (x : â†¥(metric.sphere 0 1)), -x)
(â¨† (Î¼ : K) (k : â„•), â‡‘(f.generalized_eigenspace Î¼) k) = âŠ¤
(âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
filter.tendsto f filter.at_top (nhds b) â†” âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (N : Î±), âˆ€ (n : Î±), N â‰¤ n â†’ âˆ¥f n - bâˆ¥ < Îµ)
L.reverse.sum = -(list.map (Î» (x : G), -x) L).sum
Î¼.is_open_pos_measure
iterated_deriv (n + 1) f = deriv (iterated_deriv n f)
âˆ‘' (i : â„•), m (â¨† (b : Î³) (H : b âˆˆ encodable.decodeâ‚‚ Î³ i), s b) = âˆ‘' (b : Î³), m (s b)
f 1 = 1
has_ftaylor_series_up_to_on â†‘(n + 1) f p s â†” (âˆ€ (x : E), x âˆˆ s â†’ (p x 0).uncurry0 = f x) âˆ§ (âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at (Î» (y : E), p y 0) (p x 1).curry_left s x) âˆ§ has_ftaylor_series_up_to_on â†‘n (Î» (x : E), â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p x 1)) (Î» (x : E), (p x).shift) s
l = âŠ¤
filter.tendsto (Î» (x : â„), x * real.log (1 + t / x)) filter.at_top (nhds t)
continuous (Î» (a : Î±), (f a).snd)
-a â‰¤ 0 â†’ 0 â‰¤ a
y âˆˆ subgroup.closure {x} â†” âˆƒ (n : â„¤), x ^ n = y
eqv_gen.setoid r = has_Inf.Inf {s : setoid Î± | âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ s.rel x y}
(âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.sum âˆˆ K
f.surjective_on_with K.topological_closure (C + Îµ)
unique_factorization_monoid Î±
category_theory.essentially_small C â†” small (category_theory.skeleton C) âˆ§ category_theory.locally_small C
a = c
power_series.X.order = 1
â‡‘linear_map.det â†‘(f.symm) * â‡‘linear_map.det â†‘f = 1
simplex_category.Î´ (â‡‘fin.cast_succ i) â‰« simplex_category.Ïƒ i = ğŸ™ (simplex_category.mk n)
measure_theory.measure.map â‡‘(quotient_group.mk' Î“) (Î¼.restrict ğ“•) = â‡‘Î¼ (ğ“• âˆ© â‡‘(quotient_group.mk' Î“) â»Â¹' â†‘K) â€¢ measure_theory.measure.haar_measure K
âˆ« (x : Î±), s.indicator f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
category_theory.presieve.is_sheaf J P'
i.hom â‰« sq.right â‰« p.inv = sq.left
n â€¢ a < cardinal.aleph_0 â†” a < cardinal.aleph_0
âˆ€á¶  (y : Î±) in nhds a, f =á¶ [nhds y] g
|has_inner.inner x y| â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
isometry (Gromov_Hausdorff.optimal_GH_injl X Y)
t.sum (Î» (i : Î¹), g i) âˆˆ t.sum (Î» (i : Î¹), f i)
a + b < c â†’ b < -a + c
âˆ¥f wâˆ¥ = âˆ¥f zâˆ¥
linear_independent R v
star_convex ğ•œ x s â†” âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ {x} + b â€¢ s âŠ† s
smooth I (I.prod (model_with_corners_self ğ•œ E')) (show M â†’ Z.to_topological_vector_bundle_core.total_space, from Î» (x : M), âŸ¨x, vâŸ©)
F.final
conformal_at f x â†” âˆƒ (c : â„), 0 < c âˆ§ âˆ€ (u v : E), has_inner.inner (â‡‘(fderiv â„ f x) u) (â‡‘(fderiv â„ f x) v) = c * has_inner.inner u v
âˆ« (x : â„) in a..b, f' x = f b - f a
âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
inner_product_geometry.angle x y = real.pi â†” x â‰  0 âˆ§ âˆƒ (r : â„), r < 0 âˆ§ y = r â€¢ x
â†‘T.map (c.Î¹.app j) â‰« category_theory.monad.forget_creates_colimits.lambda c t = (D.obj j).a â‰« c.Î¹.app j
âˆƒ (b : â†¥M), is_localization.is_integer R (a * â‡‘(algebra_map R S) â†‘b)
has_btw.btw a b c â†” has_btw.btw c a b
function.surjective â‡‘(S.normed_mk)
order_of (dihedral_group.r 1) = n
nontrivial Î±
1.update_row i (1 i + c â€¢ 1 j) = matrix.transvection i j c
âˆƒ (dâ‚ : Î±) (hdâ‚ : dâ‚ âˆ£ m) (dâ‚‚ : Î±) (hdâ‚‚ : dâ‚‚ âˆ£ n), k = dâ‚ * dâ‚‚
dense s â†’ dense (closure s)
{a : cardinal | âˆƒ {Î¹ : Type u} (f : Î¹ â†’ ordinal), ordinal.lsub f = o âˆ§ cardinal.mk Î¹ = a}.nonempty
s.powerset.card = 2 ^ s.card
has_strict_fderiv_at (exp ğ•‚) (exp ğ•‚ x â€¢ 1) x
category_theory.limits.kernel.Î¹ f = 0
u âˆ£ a
measurable (Î» (x : Î´), u.limsup (Î» (i : Î¹), f i x))
number_field L
S.to_submodule * T.to_submodule = (S âŠ” T).to_submodule
x = 0
f =áµ[Î½] Î¼.rn_deriv Î½
antitone f â†” âˆ€ (i : fin n), f i.succ â‰¤ f (â‡‘fin.cast_succ i)
is_square 0
(basis.of_vector_space_index K V).finite
cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_diff_within_at ğ•œ n (â‡‘(ext_chart_at I' (f x)) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' (f x)).source)) (â‡‘(ext_chart_at I x) x)
â‡‘T v âˆˆ (module.End.eigenspace T Î¼)á—®
is_regular (a ^ n) â†” is_regular a
category_theory.is_subterminal A
function.surjective (Top.stalk_to_fiber P x)
p f
â‡‘f' y â‰¤ 0
category_theory.is_connected J
category_theory.is_iso f
affine_independent k p
convolution g f L.flip Î¼ = convolution f g L Î¼
subsemiring.closure s â‰¤ t â†” s âŠ† â†‘t
âˆƒ (f : E â†’L[â„] â„) (u : â„), (âˆ€ (a : E), a âˆˆ s â†’ â‡‘f a < u) âˆ§ âˆ€ (b : E), b âˆˆ t â†’ u â‰¤ â‡‘f b
âˆ€á¶  (r : ğ•œ) in nhds 0, {x} + r â€¢ s âŠ† u
âˆ€á¶  (t : R) in nhds 0, ring.inverse (â†‘x + t) = (finset.range n).sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹ + (-â†‘xâ»Â¹ * t) ^ n * ring.inverse (â†‘x + t)
dense (s  â†‘t)
â‡‘linear_map.det 0 = 0 ^ finite_dimensional.finrank ğ•œ M
â‡‘(measure_theory.outer_measure.of_function m m_empty) (s âˆª t) = â‡‘(measure_theory.outer_measure.of_function m m_empty) s + â‡‘(measure_theory.outer_measure.of_function m m_empty) t
category_theory.limits.has_initial D
function.surjective â‡‘(c.mk')
F.map f â‰« category_theory.abelian.functor.right_derived_zero_to_self_app_inv F Q = category_theory.abelian.functor.right_derived_zero_to_self_app_inv F P â‰« (F.right_derived 0).map f
minimals r s = t
âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (x : â„) in f a..f b, g x
is_subgroup (group.normal_closure s)
function.is_fixed_pt fb (g x)
iterated_deriv n f = deriv^[n] f
â†‘n â‰¤ a ^ n / (a - 1)
finset.imageâ‚‚ f (finset.image g s) t = finset.image g' (finset.imageâ‚‚ f' t s)
category_theory.subobject.mk f = category_theory.subobject.mk g
s.pairwise_disjoint id â†’ complete_lattice.set_independent s
âˆƒ (c : P), âˆ€ (sx : affine.simplex â„ P n), set.range sx.points âŠ† ps â†’ sx.circumcenter = c
continuous_within_at f (set.Iic a) a
âˆƒ (u : set Ï„) (H : u âˆˆ f), closure (set.image2 Ï• u s) âŠ† n
a âˆˆ uv.compression u v s â†” a âˆˆ s âˆ§ uv.compress u v a âˆˆ s âˆ¨ a âˆ‰ s âˆ§ âˆƒ (b : Î±) (H : b âˆˆ s), uv.compress u v b = a
âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ = 1
â‡‘(fderiv_within â„ f s a) y = 0
Q x â†’ u x = v x
linear_independent R coe
â‡‘(s.affine_combination p) wâ‚ -áµ¥ â‡‘(s.affine_combination p) wâ‚‚ = â‡‘(s.weighted_vsub p) (wâ‚ - wâ‚‚)
category_theory.strong_epi g
continuous_at (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.snd) p
metric.closed_ball x r = set.univ.pi (Î» (b : Î²), metric.closed_ball (x b) r)
real.cos (real.pi / 3) = 1 / 2
finset.univ = finset.cons p (finset.map p.succ_above.to_embedding finset.univ) _
inner_product_geometry.angle (â‡‘f' u) (â‡‘f' v) = inner_product_geometry.angle u v
â‡‘(power_series.rescale a) (power_series.exp A) * â‡‘(power_series.rescale b) (power_series.exp A) = â‡‘(power_series.rescale (a + b)) (power_series.exp A)
Î¼ = Î½ â†” âˆ€ (i : Î¹), i âˆˆ S â†’ Î¼.restrict (s i) = Î½.restrict (s i)
âˆƒ (g : Î± â†’ F), measure_theory.fin_strongly_measurable g (Î¼.trim hm) âˆ§ â‡‘f =áµ[Î¼] g
a ^ 2 - b ^ 2 = (a + b) * (a - b)
(pequiv.single a b).to_matrix.mul ((pequiv.single b c).to_matrix.mul M) = (pequiv.single a c).to_matrix.mul M
âˆƒ (r' : Î¹ â†’ â„), (s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) âˆ§ âˆ€ (i : Î¹), r' i âˆˆ set.Ioo 0 (r i)
minpoly â„¤ Î¼ âˆ£ polynomial.X ^ n - 1
âˆƒ (F : circle_deg1_lift), âˆ€ (g : G), function.semiconj â‡‘F â‡‘(â‡‘fâ‚ g) â‡‘(â‡‘fâ‚‚ g)
finsum (Î» (ab : Î± Ã— Î²), finsum (Î» (h : ab âˆˆ s), f ab)) = finsum (Î» (a : Î±), finsum (Î» (b : Î²), finsum (Î» (h : b âˆˆ finset.image prod.snd (finset.filter (Î» (ab : Î± Ã— Î²), ab.fst = a) s)), f (a, b))))
add_subgroup.map f H.normalizer â‰¤ (add_subgroup.map f H).normalizer
filter.comap f filter.cofinite = filter.cofinite
finset.univ.prod (Î» (x : Î±), f x) = finset.univ.prod (Î» (x : Î²), g x)
f = g
f.to_fun = â‡‘f
has_dist.dist (f 0) a â‰¤ C / (1 - r)
category_theory.compatible_preserving K G
B = C
âˆ¥â‡‘(f.restr s hk z) vâˆ¥ â‰¤ C * âˆ¥zâˆ¥ ^ (n - k) * finset.univ.prod (Î» (i : fin k), âˆ¥v iâˆ¥)
Ï†â‚ = Ï†â‚‚
set.maps_to â‡‘(linear_map.single i) (tangent_cone_at ğ•œ (s i) (x i)) (tangent_cone_at ğ•œ (set.univ.pi s) x)
(nhds_within x {x}á¶œ).ne_bot
(Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] g â†’ f' =o[l] g
â‡‘((hV.linear_isometry_equiv hV').symm) (lp.single 2 i x) = â‡‘(V i) x
â‡‘((basis.mk hli hsp).coord i) (v j) = 0
âŸ¦H.eval_at xâŸ§ = continuous_map.homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I unit_interval.uhpath01 (ğŸ™ x)) â‰« continuous_map.homotopy.hcast _
add_submonoid.closure â†‘S = S
â‡‘(algebra_map K E) (algebra.discr K b) = (algebra.embeddings_matrix_reindex K E b e).det ^ 2
category_theory.limits.has_pullbacks C
topological_space.is_topological_basis {s : set H | is_clopen s}
has_dist.dist (â‡‘f x) (â‡‘g x) â‰¤ has_dist.dist f g
category_theory.limits.has_limits_of_size C
add_con.comap â‡‘f _ c = add_con.ker (c.mk'.comp f)
v.int_valuation_def 0 = 0
function.surjective â‡‘(ideal.quotient.mkâ‚ Râ‚ I)
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
a < b - c â†” a + c < b
t.orthocenter âˆˆ affine_span â„ (set.range t.points)
cardinal.mk â†¥(set.Iic a) = cardinal.continuum
(generalized_continued_fraction.squash_seq s n).nth n = option.some {a := gp_n.a, b := gp_n.b + gp_succ_n.a / gp_succ_n.b}
category_theory.pretopology.to_grothendieck (topological_space.opens T) (opens.pretopology T) = opens.grothendieck_topology T
âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f x â‰¤ f y
M p
submodule.map f (f.generalized_eigenrange Î¼ n) â‰¤ f.generalized_eigenrange Î¼ n
f = 0
multiset.count i (nat.partition.of_sums n l hl).parts = multiset.count i l
category_theory.sheaf.subcanonical J
affine_independent k (p âˆ˜ â‡‘f)
deriv (Î» (u : â„), âˆ« (x : â„) in a..u, f x) b = c
â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
â‡‘c x x
(finset.image f A).to_colex < (finset.image f B).to_colex â†” A.to_colex < B.to_colex
absorbent ğ•œ (p.ball x r)
finite_dimensional K V
a < b â†’ a â‰¤ b
â‡‘g (s.prod (Î» (x : Î±), f x)) = s.prod (Î» (x : Î±), â‡‘g (f x))
continuous_at (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) xâ‚€
filter.tendsto (Î» (x : â„), f x / g x) filter.at_bot l
f i = b
âˆ€á¶  (p : F Ã— â†¥(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_function f f' hf hf' p.fst p.snd) = p.fst
real.sin x < x
is_add_regular g
add_salem_spencer (frontier s)
x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
âˆƒ (T : finset M), â†‘T âŠ† S âˆ§ x âˆˆ submodule.span R â†‘T
function.surjective â‡‘f
f = g
s1 â‰¤ s2 â†” â†‘s1 âŠ† â†‘s2
f = g
function.injective (Î» (_x : Î±), n â€¢ _x)
a + b < 0
metric.bounded (set.range f)
hb.oangle x y + hb.oangle y z = hb.oangle x z
metric.cthickening Îµ (metric.cthickening Î´ s) âŠ† metric.cthickening (Îµ + Î´) s
â‡‘(convex_hull R) s = {x : E | âˆƒ (Î¹ : Type u') (t : finset Î¹) (w : Î¹ â†’ R) (z : Î¹ â†’ E) (hwâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hwâ‚ : t.sum (Î» (i : Î¹), w i) = 1) (hz : âˆ€ (i : Î¹), i âˆˆ t â†’ z i âˆˆ s), t.center_mass w z = x}
1 < aâ»Â¹ â†’ a < 1
subgroup.normal_closure s â‰¤ N
(polynomial.cyclotomic n R).nat_degree = n.totient
cardinal.mk â†¥(set.Iio a) = cardinal.continuum
directed_on r s â†’ directed r coe
finite_dimensional.finrank R (matrix m n R) = fintype.card m * fintype.card n
âˆƒ (u : set (set Î±)) (H : u âŠ† t), u.pairwise_disjoint id âˆ§ âˆ€ (a : set Î±), a âˆˆ t â†’ (âˆƒ (b : set Î±) (H : b âˆˆ u), (a âˆ© b).nonempty âˆ§ Î´ a â‰¤ Ï„ * Î´ b)
polynomial.eval x s.prod = (multiset.map (polynomial.eval x) s).prod
quotient.lift f H = g
(â‡‘(matrix.reindex_linear_equiv R R e e) M).det = M.det
strict_convex ğ•œ s
is_right_regular 0 â†” subsingleton R
cont_mdiff (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f â†’ cont_diff ğ•œ n f
âˆƒ (x : Î²), âˆ€ (y : Î²), f x â‰¤ f y
H.sheaf_hom (category_theory.whisker_left G.op Î±) = Î±
ess_sup f (Î¼.restrict s) = ess_sup f Î¼
pgame.mk xl xr xL xR â‰¤ pgame.mk yl yr yL yR â†” (âˆ€ (i : xl), (xL i).lf (pgame.mk yl yr yL yR)) âˆ§ âˆ€ (j : yr), (pgame.mk xl xr xL xR).lf (yR j)
is_complemented Î±
subgroup.map f (subgroup.closure s) = subgroup.closure (â‡‘f '' s)
s.points_with_circumcenter affine.simplex.points_with_circumcenter_index.circumcenter_index = s.circumcenter
(âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
fâ‚ = fâ‚‚
â†‘(lie_module.lower_central_series R L (L â§¸ I) k) = â†‘(lie_module.lower_central_series R (L â§¸ I) (L â§¸ I) k)
n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]
p (s.sum (Î» (x : Î±), f x))
a + b < 0
affine_independent k p â†” n â‰¤ finite_dimensional.finrank k â†¥(vector_span k (set.range p))
submodule.span R X = submodule.restrict_scalars R (submodule.span A X)
(-A).det = (-1) ^ fintype.card n â€¢ A.det
0 â‰¤ inner_product_geometry.angle x y
a * e + c = b * e + d â†’ (a - b) * e + c = d
cont_diff_on ğ•œ â†‘(n + 1) f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ â†‘n (Î» (y : E), fderiv_within ğ•œ f s y) s
cont_mdiff_within_at I I' n f s x' â†” continuous_within_at f s x' âˆ§ cont_diff_within_at ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source)) (â‡‘(ext_chart_at I x) x')
is_localization.at_prime T (ideal.comap (algebra_map R S) p)
o.oangle y z = 2 â€¢ o.oangle (y - x) (z - x)
has_fpower_series_on_ball (fderiv ğ•œ f) (â†‘(continuous_multilinear_curry_fin1 ğ•œ E F).comp_formal_multilinear_series (p.change_origin_series 1)) x r
â‡‘(algebra.norm K) (Î¶ - 1) = â†‘(polynomial.eval 1 (polynomial.cyclotomic â†‘n â„¤))
âˆƒ (a : Î±) (H : a âˆˆ s), b < a
has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c b
collinear k âˆ…
iterated_fderiv_within ğ•œ (n + 1) f s x = (â‡‘(continuous_multilinear_curry_right_equiv' ğ•œ n E F) âˆ˜ iterated_fderiv_within ğ•œ n (Î» (y : E), fderiv_within ğ•œ f s y) s) x
dimH (set.range f) â‰¤ dimH set.univ
â‡‘Î¼ {x âˆˆ s | âˆ€ (m : â„•), m â‰¥ n â†’ f^[m] x âˆ‰ s} = 0
unique_mdiff_on (model_with_corners_self ğ•œ E) s â†’ unique_diff_on ğ•œ s
P n
1 < a * b
(xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2 + xâ‚… ^ 2 + xâ‚† ^ 2 + xâ‚‡ ^ 2 + xâ‚ˆ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2 + yâ‚… ^ 2 + yâ‚† ^ 2 + yâ‚‡ ^ 2 + yâ‚ˆ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„ - xâ‚… * yâ‚… - xâ‚† * yâ‚† - xâ‚‡ * yâ‚‡ - xâ‚ˆ * yâ‚ˆ) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ + xâ‚… * yâ‚† - xâ‚† * yâ‚… - xâ‚‡ * yâ‚ˆ + xâ‚ˆ * yâ‚‡) ^ 2 + (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚ + xâ‚… * yâ‚‡ + xâ‚† * yâ‚ˆ - xâ‚‡ * yâ‚… - xâ‚ˆ * yâ‚†) ^ 2 + (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚ + xâ‚… * yâ‚ˆ - xâ‚† * yâ‚‡ + xâ‚‡ * yâ‚† - xâ‚ˆ * yâ‚…) ^ 2 + (xâ‚ * yâ‚… - xâ‚‚ * yâ‚† - xâ‚ƒ * yâ‚‡ - xâ‚„ * yâ‚ˆ + xâ‚… * yâ‚ + xâ‚† * yâ‚‚ + xâ‚‡ * yâ‚ƒ + xâ‚ˆ * yâ‚„) ^ 2 + (xâ‚ * yâ‚† + xâ‚‚ * yâ‚… - xâ‚ƒ * yâ‚ˆ + xâ‚„ * yâ‚‡ - xâ‚… * yâ‚‚ + xâ‚† * yâ‚ - xâ‚‡ * yâ‚„ + xâ‚ˆ * yâ‚ƒ) ^ 2 + (xâ‚ * yâ‚‡ + xâ‚‚ * yâ‚ˆ + xâ‚ƒ * yâ‚… - xâ‚„ * yâ‚† - xâ‚… * yâ‚ƒ + xâ‚† * yâ‚„ + xâ‚‡ * yâ‚ - xâ‚ˆ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚ˆ - xâ‚‚ * yâ‚‡ + xâ‚ƒ * yâ‚† + xâ‚„ * yâ‚… - xâ‚… * yâ‚„ - xâ‚† * yâ‚ƒ + xâ‚‡ * yâ‚‚ + xâ‚ˆ * yâ‚) ^ 2
char_zero R
a + b < 0
P.fg â†” âˆƒ (S : set M), add_submonoid.closure S = P âˆ§ S.finite
f = g
p i
âˆ¥fâˆ¥ â‰¤ M
category_theory.exact f g â†” âˆƒ (w : f â‰« g = 0), nonempty (homology f g w â‰… 0)
category_theory.is_subterminal A
measure_theory.measure.map has_inv.inv Î¼ = Î¼
category_theory.is_iso (category_theory.limits.diag A)
function.bijective (mul_semiring_action.to_alg_hom â†¥(fixed_points.subfield G F) F)
perfection_map p (ring_hom.id R)
char_zero K
â†‘(â‡‘(orthogonal_projection K) u) = v
metric.Hausdorff_dist s u â‰¤ metric.Hausdorff_dist s t + metric.Hausdorff_dist t u
lower_semicontinuous_on (Î» (z : Î±), f z + g z) s
(s + 1).Gamma = s * s.Gamma
â‡‘(con.ker f) x = â‡‘f â»Â¹' {â‡‘f x}
finite_dimensional.finrank R (Î  (i : Î¹), M i) = finset.univ.sum (Î» (i : Î¹), finite_dimensional.finrank R (M i))
convex_independent ğ•œ (Î» (x : â†¥s), â†‘x) â†” âˆ€ (x : E), x âˆˆ s â†’ x âˆ‰ â‡‘(convex_hull ğ•œ) (s  {x})
1 < aâ»Â¹ â†” a < 1
antitone (f âŠ” g)
(â‹ƒ (x : Î±) (H : x âˆˆ s), uniform_space.ball x U) = set.univ
f = g
irrational (real.sqrt 2)
bdd_below (f '' K)
pairwise (Î» (i j : I), âˆ€ (x : f i) (y : f j), add_commute (pi.single i x) (pi.single j y))
filter.Coprod (Î» (i : Î¹), filter.cofinite) = filter.cofinite
f.range = âŠ¤
finset.univ.inf f = infi f
unique_diff_on ğ•œ (I.pi s)
category_theory.limits.has_colimits_of_shape J Cáµ’áµ–
continuous_map.compact_open = continuous_map.compact_convergence_topology
f a â‰  x
(G.map_homological_complex c).map (homotopy.null_homotopic_map' hom) = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), G.map (hom i j hij))
measure_theory.analytic_set (â‹ƒ (n : Î¹), s n)
((M.mul N).mul M').det = N.det
set.unbounded has_lt.lt (â‹‚ (i : ordinal) (hi : i < o), function.fixed_points (f i hi))
P x hx
category_theory.is_iso Î±
s.finite
cont_mdiff I (model_with_corners_self â„ (euclidean_space â„ (fin n))) m (set.cod_restrict (Î» (x : M), f x) (metric.sphere 0 1) hf')
(âˆƒá¶  (x : Î±) in â†‘f, p x) â†’ (âˆ€á¶  (x : Î±) in â†‘f, p x)
matrix.vec_mul (â‡‘(b.coords) x) (b.to_matrix bâ‚‚.points)â»Â¹ = â‡‘(bâ‚‚.coords) x
orthonormal ğ•œ v â†” âˆ€ (i j : Î¹), has_inner.inner (v i) (v j) = ite (i = j) 1 0
continuous (function.uncurry (Î» (x : E) (y : F), â‡‘(â‡‘f x) y))
(generalized_continued_fraction.int_fract_pair.of qâ»Â¹).fr.num < q.num
Â¬a â‹– b â†’ (âˆƒ (c : Î±), a < c âˆ§ c < b)
1 / a < 1 / b â†” b < a
(â¨† (i : Î¹) (H : i âˆˆ t), â¨… (j : Î¹) (hj : j âˆˆ t) (ij : j â‰  i), I j) = âŠ¤ â†” â†‘t.pairwise (Î» (i j : Î¹), I i âŠ” I j = âŠ¤)
(Î» (n : â„•), â†‘n ^ k) =o[filter.at_top] Î» (n : â„•), r ^ n
affine_span k (s âˆª t) = affine_span k s âŠ” affine_span k t
f â‰« g â‰« h = (f â‰« g) â‰« h
category_theory.abelian.coimage.Ï€ f â‰« category_theory.abelian.factor_thru_coimage f = f
is_closed (set.range topological_space.nonempty_compacts.to_closeds)
x = â‡‘(o.rotation Î¸) x â†” x = 0 âˆ¨ Î¸ = 0
is_integral R (algebra.discr K b)
has_strict_fderiv_at f (f' x) x
nontrivial Î±
â‡‘p x â‰¤ â‡‘p y + â‡‘p (x - y)
add_subgroup.closure h â‰¤ add_subgroup.closure k
âˆƒ (a : Î±), cardinal.mk Î± < cardinal.mk â†¥(f â»Â¹' {a})
Î²
p.degree â‰¤ â†‘n â†’ p.nat_degree â‰¤ n
function.injective p
âˆ€áµ (x : Î²) âˆ‚Î¼, filter.tendsto (Î» (r : â„), â‡‘Ï (metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (Ï.rn_deriv Î¼ x))
category_theory.limits.colimit F = supr F.obj
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i + g i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), g i))
is_compact (closure A)
âˆ€á¶  (z : â„) in nhds_within x s, âˆ¥z - xâˆ¥â»Â¹ * (âˆ¥f zâˆ¥ - âˆ¥f xâˆ¥) < r
âˆƒá¶  (n : â„•) in filter.at_top, âˆƒ (m : â„¤), x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < â†‘n ^ -q
(1 + (matrix.col u).mul (matrix.row v)).det = 1 + matrix.dot_product v u
a * b < 1
|(finset.range n).sum (Î» (i : â„•), x ^ (i + 1) / (â†‘i + 1)) + real.log (1 - x)| â‰¤ |x| ^ (n + 1) / (1 - |x|)
0 â‰¤ s.circumradius
â‡‘g (s.prod (Î» (x : Î±), f x)) = s.prod (Î» (x : Î±), â‡‘g (f x))
category_theory.inv (category_theory.limits.prod_comparison F A B) â‰« F.map (category_theory.limits.prod.map f g) = category_theory.limits.prod.map (F.map f) (F.map g) â‰« category_theory.inv (category_theory.limits.prod_comparison F A' B')
vector_span k s = âŠ¤
filter.tendsto (Î» (n : â„•), â‡‘(thickened_indicator _ E)) filter.at_top (nhds ((closure E).indicator (Î» (x : Î±), 1)))
affine_span â„ {t.orthocenter, t.points i} â‰¤ affine.simplex.altitude t i
cont_diff_on ğ•œ n (prod.map f g) (s Ã—Ë¢ t)
cont_diff ğ•œ n (Î» (x : E Ã— F), f x.snd)
s.nonempty â†’ s.sym2.nonempty
âˆƒ (V : set M), is_open V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U
â‡‘(p n) (Î» (i : fin n), y) = 0
lipschitz_with K f â†’ âˆ€ (x y : Î±), has_dist.dist (f x) (f y) â‰¤ â†‘K * has_dist.dist x y
finite_dimensional.finrank R (direct_sum Î¹ (Î» (i : Î¹), M i)) = finset.univ.sum (Î» (i : Î¹), finite_dimensional.finrank R (M i))
concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
s âˆˆ nhds_within a (set.Iic a) â†” âˆƒ (l : Î±), l < a âˆ§ set.Icc l a âŠ† s
â‡‘((a * b).factorization) p = â‡‘(b.factorization) p
â†‘â…I,Nâ† = submodule.span R {m : M | âˆƒ (x : â†¥I) (n : â†¥N), â…â†‘x,â†‘nâ† = m}
0 < (minpoly A x).degree
is_conformal_map g â†” ((âˆƒ (map : â„‚ â†’L[â„‚] â„‚), continuous_linear_map.restrict_scalars â„ map = g) âˆ¨ âˆƒ (map : â„‚ â†’L[â„‚] â„‚), continuous_linear_map.restrict_scalars â„ map = g.comp â†‘complex.conj_cle) âˆ§ g â‰  0
is_min a â†’ is_max (â‡‘order_dual.to_dual a)
hb.oangle (-x) y + hb.oangle (-y) z + hb.oangle (-z) x = â†‘real.pi
real.sin (inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = 0
nat.fib (m.gcd n) = (nat.fib m).gcd (nat.fib n)
closure s âŠ† â‡‘(affine_map.homothety x t) '' interior s
â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta p K L - 1) = â†‘p
f =o[l] g' â†’ (f =o[l] Î» (x : Î±), -g' x)
real.sqrt (1 + real.sinh x ^ 2) = real.cosh x
â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det f| * â‡‘Î¼ s
(â¨† (b : Î±) (H : b âˆˆ s), a âŠ“ b) â‰¤ a âŠ“ has_Sup.Sup s
0 â‰¤ âˆ¥xâˆ¥
unique_mdiff_on (I.prod (model_with_corners_self ğ•œ F)) (Z.to_topological_vector_bundle_core.proj â»Â¹' s)
set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
is_complete (m '' s) â†” is_complete s
âˆ‘' (n : â„•), f n < âˆ‘' (n : â„•), g n
is_irreducible S
continuous_at f a
s.sum (Î» (x : Î²), â‡‘(A.cramer) (f x)) = â‡‘(A.cramer) (s.sum (Î» (x : Î²), f x))
Ï†â‚ = Ï†â‚‚
topological_space.is_topological_basis ((Î» (u : set Î±), sum.inl '' u) '' s âˆª (Î» (u : set Î²), sum.inr '' u) '' t)
â‡‘f x = â‡‘f y
zmod.legendre_sym p (-1) = â‡‘zmod.Ï‡â‚„ â†‘p
subgroup.closure ((Î» (g : G), âŸ¨g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹, _âŸ©) '' (R * S)) = âŠ¤
j âˆˆ p
âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
a * -1 = -a
â‡‘(measure_theory.measure.haar.haar_content Kâ‚€) (topological_space.compacts.map (Î» (b : G), g * b) _ K) = â‡‘(measure_theory.measure.haar.haar_content Kâ‚€) K
0 < 3
âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
hs.index (quotient.out' x) = hs.index (â‡‘(hs.out) x)
affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter iâ‚ iâ‚‚ = affine.simplex.monge_point_weights_with_circumcenter n - affine.simplex.centroid_weights_with_circumcenter {iâ‚, iâ‚‚}á¶œ
{a}.max' _ = a
nat.partrec f â†” âˆƒ (c : nat.partrec.code), c.eval = f
(path.homotopic.prod qâ‚ qâ‚‚).comp (path.homotopic.prod râ‚ râ‚‚) = path.homotopic.prod (qâ‚.comp râ‚) (qâ‚‚.comp râ‚‚)
category_theory.is_pullback c.fst c.snd (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right}))
continuous (Î» (p : C(Î±, Î²) Ã— Î±), â‡‘(p.fst) p.snd)
real.cos (inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = -real.cos (inner_product_geometry.angle x y)
is_add_left_regular (a + b) â†” is_add_left_regular b
complete_space Î±
âˆƒ (x' : E) (H : x' âˆˆ s), has_dist.dist x y â‰¤ has_dist.dist x' y
âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
continuous (Î» (h : G), g * h * gâ»Â¹)
âˆ¥x - yâˆ¥ = |âˆ¥xâˆ¥ - âˆ¥yâˆ¥| â†” inner_product_geometry.angle x y = 0
âˆƒ (u : set (set Î±)) (H : u âŠ† t), u.pairwise_disjoint id âˆ§ âˆ€ (a : set Î±), a âˆˆ t â†’ (âˆƒ (x : Î±) (r : â„), metric.closed_ball x r âˆˆ u âˆ§ a âŠ† metric.closed_ball x (5 * r))
z âˆˆ set.Ico x y â†” âˆƒ (a b : ğ•œ), 0 < a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
(-a) ^ 2 = a ^ 2
no_zero_smul_divisors R M â†” submodule.torsion R M = âŠ¥
pi_nat.cylinder x (pi_nat.longest_prefix x s) = pi_nat.cylinder y (pi_nat.longest_prefix y s)
fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(add_action.stabilizer Î± Ï‰.out'))
e.restr s â‰ˆ e'.restr s
a * a - b * b = (a + b) * (a - b)
no_zero_divisors Mâ‚€
continuous continuous_map.uncurry
v (-i) = v i
{b : set Î± | b âŠ† a}.finite
mv_polynomial.esymm Ïƒ R n = (finset.powerset_len n finset.univ).sum (Î» (t : finset Ïƒ), â‡‘(mv_polynomial.monomial (t.sum (Î» (i : Ïƒ), finsupp.single i 1))) 1)
(normed_group_hom.equalizer.lift Ï† h).norm_noninc
(â‡‘â¨… (i : Î¹), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹), â‡‘(m i) (t n)
measure_theory.uniform_integrable f p Î¼
add_con.ker f = c
B = C
f âˆˆ ideal.map mv_polynomial.C I â†” âˆ€ (m : Ïƒ â†’â‚€ â„•), mv_polynomial.coeff m f âˆˆ I
has_sum (Î» (b : Î¹), â‡‘Ï† (f b)) (â‡‘Ï† x)
âˆƒ (u : ultrafilter Î±), â†‘u â‰¤ f
x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
N.topological_closure.normal
linear_independent R v â†’ function.injective â‡‘(finsupp.total Î¹ M R v)
s.subsingleton
âˆƒ (p : P) (H : p âˆˆ s2), p âˆ‰ s1
z âˆˆ uniform_space.ball x (comp_rel V W)
monotone_on f s â†’ antitone_on (â‡‘order_dual.to_dual âˆ˜ f) s
finite_dimensional.finrank K (fin n â†’ K) = n
p -áµ¥ p = 0
N = J â€¢ N
a * c < b * d
metric.bounded s
m â€¢ x = (m % n) â€¢ x
has_inner.inner (x - y) (x - y) = has_inner.inner x x - 2 * has_inner.inner x y + has_inner.inner y y
continuous â‡‘g
category_theory.presieve.is_sheaf_for P â‡‘S
asymptotics.is_O_with c l f g â†” âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥
â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (fintype.pi_finset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
category_theory.is_iso c.Ï€
â‡‘f l.sum = (list.map â‡‘f l).sum
direct_sum.is_internal (Î» (Î¼ : module.End.eigenvalues T), module.End.eigenspace T â†‘Î¼)
âˆƒ (f : â„• â†’ Î±), (âˆ€ (n : â„•), P (f n)) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ r (f m) (f n)
(âˆƒ (y : (zmod p)Ë£), y ^ 2 = x) â†” x ^ (p / 2) = 1
category_theory.free_bicategory.normalize_aux p f = category_theory.free_bicategory.normalize_aux p g
irrational r
âˆƒ (g : E â†’â‚—[â„] â„), (âˆ€ (x : â†¥(f.domain)), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ€ (x : E), x âˆˆ s â†’ 0 â‰¤ â‡‘g x
measure_theory.ae_strongly_measurable f Î¼
p (finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)))
y âˆˆ multiples x â†’ z âˆˆ multiples x â†’ y + z âˆˆ multiples x
torus_integrable (Î» (_x : fin n â†’ â„‚), a) c R
hb.oangle (â‡‘(hb.rotation Î¸) x) (â‡‘(hb.rotation Î¸) y) = hb.oangle x y
is_R_or_C.abs (has_inner.inner x (r â€¢ x)) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±), F i x âˆ‚Î¼) l (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))
cont_mdiff_on I I n â‡‘(e.symm) e.to_local_equiv.target
f.sum (Î» (x : Î±) (v : M), ite (x = a) (b x v) 0) = ite (a âˆˆ f.support) (b a (â‡‘f a)) 0
hb.oangle x (r â€¢ x) = 0
1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
âˆƒ (r : R), 0 â‰¤ r âˆ§ r â€¢ x = y
â‡‘(f i i h) x = x
âˆƒ (N : category_theory.bundled L.Structure), nonempty (L.elementary_embedding M â†¥N) âˆ§ cardinal.mk â†¥N = Îº.lift
(cardinal.mk Î±).lift â‰¤ (cardinal.mk Î²).lift â†” nonempty (Î± â†ª Î²)
metric.Hausdorff_dist âˆ… s = 0
complete_lattice.independent f.eigenspace
(âˆ€ (c : category_theory.limits.cone (S.arrows.diagram.op â‹™ P)), subsingleton (c âŸ¶ P.map_cone S.arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), category_theory.presieve.is_separated_for (P â‹™ category_theory.coyoneda.obj E) â‡‘S
L.head + L.tail.sum = L.sum
(a * b).factors ~ a.factors ++ b.factors
âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥
1 < a * b
s.sum (Î» (i : Î¹), f i) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), f i ^ p)
(â‡‘(linear_map.to_matrix b b) f).det = (â‡‘(linear_map.to_matrix c c) f).det
{l : list Î± | âˆ€ (x : Î±), x âˆˆ l â†’ x âˆˆ s}.partially_well_ordered_on (list.sublist_forallâ‚‚ r)
(F.left_derived n).map f = (F.left_derived_obj_iso n P).hom â‰« (homology_functor D (complex_shape.down â„•) n).map ((F.map_homological_complex (complex_shape.down â„•)).map g) â‰« (F.left_derived_obj_iso n Q).inv
fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b
squarefree (m * n) â†” squarefree m âˆ§ squarefree n
category_theory.is_pullback (F.map f) (F.map g) (F.map h) (F.map i)
euclidean_geometry.angle p1 p3 p2 + euclidean_geometry.angle p1 p3 p4 = real.pi
category_theory.limits.colimit.pre F E = (category_theory.limits.colimit.iso_colimit_cocone s).hom â‰« s.is_colimit.desc (category_theory.limits.cocone.whisker E t.cocone) â‰« (category_theory.limits.colimit.iso_colimit_cocone t).inv
x âˆˆ closure s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (y : Î±) (H : y âˆˆ s), has_edist.edist x y < Îµ)
category_theory.limits.has_finite_coproducts C
â‡‘e (x * y) = â‡‘e x * â‡‘e y
âˆƒ (aâ‚˜ : Î±), s.nth m = option.some aâ‚˜
lipschitz_on_with K.to_nnreal f s
Â¬âˆƒ (t : â„•), t * t = n
pi.single i x i' = 0
complete_space Î±
Â¬a < b â†’ multiset.Ico a b = 0
â‡‘f (t.piecewise (m + m') m') = t.powerset.sum (Î» (s : finset Î¹), â‡‘f (s.piecewise m m'))
continuous_at (Î» (x : Î± Ã— Î²), f x.fst) x
irreducible (polynomial.cyclotomic (p ^ m) R)
0 < finite_dimensional.finrank K V â†” âˆƒ (x : V), x â‰  0
i = j
category_theory.limits.pullback f g = x âŠ“ y
dense (â‹‚ (s : Î²) (H : s âˆˆ S), f s H)
p.color i < N
uniform_cauchy_seq_on F filter.at_top s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ âˆ€ (x : Î³), x âˆˆ s â†’ has_dist.dist (F m x) (F n x) < Îµ)
summable (Î» (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2)
a âˆˆ closure s â†” âˆƒ (x : â„• â†’ X), (âˆ€ (n : â„•), x n âˆˆ s) âˆ§ filter.tendsto x filter.at_top (nhds a)
âˆƒ (f : W â†’ L), t.sum (Î» (e : W), f e â€¢ e) = 0 âˆ§ t.sum (Î» (e : W), f e) = 0 âˆ§ âˆƒ (x : W) (H : x âˆˆ t), 0 < f x
set.eq_on â‡‘f â‡‘g â†‘(subring.closure s)
â‡‘(s.affine_combination p) w = p i
has_edist.edist (f 0) (f n) â‰¤ (finset.range n).sum (Î» (i : â„•), d i)
filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_top filter.at_top
multiplicity.finite â†‘p a â†” a â‰  0
has_inner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥) â†” inner_product_geometry.angle x y = real.pi
char.quadratic_char F a ^ 2 = 1
is_bounded_linear_map ğ•œ (Î» (f : continuous_multilinear_map ğ•œ (Î» (i : Î¹), E) F), f.comp_continuous_linear_map (Î» (_x : Î¹), g))
0 â‰¤ ifp_n.fr âˆ§ ifp_n.fr < 1
uniform_embedding f â†” (âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ {a b : Î³}, has_dist.dist a b < Î´ â†’ has_dist.dist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : â„), Î´ > 0 â†’ (âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ {a b : Î³}, has_dist.dist (f a) (f b) < Îµ â†’ has_dist.dist a b < Î´)
is_unit A â†” is_unit A.det
Â¬function.injective f
âˆƒ (a b : R), polynomial.eval a f + polynomial.eval b g = 0
sâ‚.monge_point = sâ‚‚.monge_point
Â¬is_max a â†’ a < order.succ a
mul_opposite.unop (â‡‘f l.prod) = (list.map (mul_opposite.unop âˆ˜ â‡‘f) l).reverse.prod
linear_independent K xs
seq_continuous f â†’ continuous f
cont_diff_on ğ•œ m (Î» (p : E Ã— E), â‡‘(fderiv_within ğ•œ f s p.fst) p.snd) (s Ã—Ë¢ set.univ)
Â¬add_monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  0 âˆ§ is_of_fin_add_order g
0 < add_order_of x
â‡‘(s.weighted_vsub p) w = s.sum (Î» (i : Î¹), w i â€¢ (p i -áµ¥ classical.choice add_torsor.nonempty))
p x hx
metric.Hausdorff_dist s t â‰¤ metric.diam (s âˆª t)
y âˆˆ omega_limit f Ï• {x} â†” map_cluster_pt y f (Î» (t : Ï„), Ï• t x)
a + b â‰¤ 0
s âŠ† â†‘(subsemigroup.closure s)
convex_on ğ•œ s (f âŠ” g)
filter.tendsto (Î» (x : Î±), op (f x) (g x)) l (nhds 0)
padic_val_rat m 0 = 0
â†‘(x + y) = â†‘x + â†‘y
continuous f.curry'
gauge s 0 = 0
R (m (â¨† (d : Î´) (H : d âˆˆ t), s d)) (t.sum (Î» (d : Î´), m (s d)))
(cardinal.mk Î±).lift = (cardinal.mk Î²).lift â†” nonempty (Î± â‰ƒ Î²)
(factorization n).support = (unique_factorization_monoid.normalized_factors n).to_finset
â†‘u âŠ† s / t â†’ (âˆƒ (s' t' : finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' / t')
inner_product_geometry.angle x (x - y) = inner_product_geometry.angle y (y - x)
â†‘(intermediate_field.adjoin â†¥(intermediate_field.adjoin F S) T) = intermediate_field.adjoin F (S âˆª T)
(x + y) ^ n = (finset.nat.antidiagonal n).sum (Î» (m : â„• Ã— â„•), n.choose m.fst â€¢ (x ^ m.fst * y ^ m.snd))
â‡‘T v âˆˆ (â¨† (Î¼ : ğ•œ), module.End.eigenspace T Î¼)á—®
p q
function.injective â‡‘(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype))
âˆƒ (t : set (Î± Ã— â„)), t.countable âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.fst âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.snd âˆˆ f p.fst) âˆ§ â‡‘Î¼ (s  â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), metric.closed_ball p.fst p.snd) = 0 âˆ§ t.pairwise_disjoint (Î» (p : Î± Ã— â„), metric.closed_ball p.fst p.snd)
â‡‘f (a * b) = â‡‘f a * â‡‘f b
(list.take i (list.map list.length L)).sum + j < (list.take (i + 1) (list.map list.length L)).sum
(âˆƒ (x : Î±) (h : p x), q x h) â†” âˆƒ (x : {a // p a}), q â†‘x _
x ^ p = x
C p q
measure_theory.strongly_measurable g
âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (y : Î²), âˆ« (x : Î±), f x y âˆ‚Î¼ âˆ‚Î½
(list.zip_with has_append.append (list.split_on_p p as) (list.map (Î» (x : Î±), [x]) (list.filter p as) ++ [list.nil])).join = as
convolution_exists_at f g xâ‚€ L Î¼
â‡‘c x x
a < b
has_Sup.Sup S â‰¤ 0
f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
is_preconnected t
âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
(â¨† (x : X), (nhds_within x s).small_sets.limsup dimH) = dimH s
same_ray R (s â€¢ x) (s â€¢ y)
â‡‘f (a - b) = â‡‘f a - â‡‘f b
âˆƒ (r' : Î¹ â†’ â„), (s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) âˆ§ âˆ€ (i : Î¹), r' i < r i
is_add_monoid_hom f
(âˆ€ (a : â†¥P), â‡‘f a = 0 â†’ a = 0) â†’ category_theory.mono f
âˆ¥normed_group_hom.id Vâˆ¥ â‰¤ 1
category_theory.is_iso f
s1.direction â‰¤ s2.direction
â¨ (x : Î±) in t, g (f x) âˆ‚Î¼ â‰¤ g (â¨ (x : Î±) in t, f x âˆ‚Î¼)
hb.rotation Î¸ = hbâ‚‚.rotation (-Î¸)
strict_convex_on â„ set.univ f
concave_on â„ D f
category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)
J = Iâ»Â¹
continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars â„ fourier_subalgebra)
is_GÎ´ (â‹‚â‚€ S)
â‡‘(continuous_linear_map.comp_LpL p Î¼ (c â€¢ L)) f = c â€¢ â‡‘(continuous_linear_map.comp_LpL p Î¼ L) f
embedding (sigma.map id f)
(path.pi Î³â‚€).trans (path.pi Î³â‚) = path.pi (Î» (i : Î¹), (Î³â‚€ i).trans (Î³â‚ i))
A.is_symm â†” âˆ€ (i j : n), A j i = A i j
category_theory.limits.colimit F = finset.univ.sup F.obj
category_theory.limits.kernel.lift g f w â‰« category_theory.limits.kernel.map g g' q r hâ‚‚ = p â‰« category_theory.limits.kernel.lift g' f' w'
mâ‚‚ â‰¤ measurable_space.map f mâ‚ â†’ measurable f
âˆƒ (g : Î± â†’ ereal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ
âˆ€áµ (x : Î²) âˆ‚Î¼.restrict s, filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
continuous f
has_fpower_series_on_ball f (cauchy_power_series f c â†‘R) c â†‘R
Î¼.prod Î½ = Î¼Î½
category_theory.is_iso f
G.is_sheaf
continuous â‡‘f
measurable_embedding (s.restrict f)
category_theory.is_iso (category_theory.limits.kernel.Î¹ 0)
a - b â‰¤ 0 â†’ a â‰¤ b
relation.trans_gen r n m
â†‘q * â‡‘Î¼ s â‰¤ â‡‘Ï s
4 ^ n â‰¤ 2 * n * n.central_binom
âˆ« (x : Î±), X x âˆ‚Â«â„™Â» = (â‡‘measure_theory.measure_space.volume s)â»Â¹.to_real * âˆ« (x : â„) in s, x
â‡‘f (m + m') = finset.univ.sum (Î» (s : finset Î¹), â‡‘f (s.piecewise m m'))
closure {x}á¶œ = set.univ
concave_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
padic_val_rat p 1 = 0
(category_theory.limits.image_subobject f).of_le (category_theory.limits.kernel_subobject g) h = image_to_kernel f g w
function.injective (f a)
is_monoid_hom f
k = l
strict_convex_on â„ set.univ (Î» (x : â„), x ^ n)
is_noetherian_ring (polynomial R)
x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)
is_left_regular a â†” is_smul_regular R a
â‡‘(â‡‘(matrix.kronecker_map_bilinear f) (A.mul B)) (A'.mul B') = (â‡‘(â‡‘(matrix.kronecker_map_bilinear f) A) A').mul (â‡‘(â‡‘(matrix.kronecker_map_bilinear f) B) B')
(s.product t).sup f = s.sup (Î» (i : Î²), t.sup (Î» (i' : Î³), f (i, i')))
is_dedekind_domain A
filter.tendsto u filter.at_bot filter.at_bot
vâ‚ â‰ˆ vâ‚‚ â†” same_ray R â†‘vâ‚ â†‘vâ‚‚
0 < 4
finsum (Î» (i : Î±), g (e i)) = finsum (Î» (j : Î²), g j)
0 â‰¤ euclidean_geometry.angle p1 p2 p3
n.choose 2 = n * (n - 1) / 2
w = â†‘(â‡‘(orthogonal_projection K) w) + â†‘(â‡‘(orthogonal_projection Ká—®) w)
s1.direction âŠ” s2.direction < (s1 âŠ” s2).direction
e.unit.app (e.inverse.obj Y) â‰« e.inverse.map (e.counit.app Y) = ğŸ™ (e.inverse.obj Y)
b = c â†’ a < b â†’ a < c
â†‘(finite_dimensional.finrank R M) = module.rank R M
âˆƒ (g : C(Y, â„)), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ continuous_map.restrict s g = f
continuous_at (Î» (p : ereal Ã— ereal), p.fst + p.snd) p
tendsto_uniformly_on (Î» (n : Î¹), F n âˆ˜ g) (f âˆ˜ g) p (g â»Â¹' s)
dense {x}á¶œ
fin.snoc (fin.init q) (q (fin.last n)) = q
r â€¢ x * y = r â€¢ (x * y)
Â¬small ordinal
closure E = â‹‚ (Î´ : â„) (h : 0 < Î´), metric.cthickening Î´ E
strict_convex_on ğ•œ s f â†’ strict_concave_on ğ•œ s (-f)
finite_dimensional.finrank K â†¥s < finite_dimensional.finrank K V
has_inner.inner (â‡‘(continuous_map.to_Lp 2 Î¼ ğ•œ) f) (â‡‘(continuous_map.to_Lp 2 Î¼ ğ•œ) g) = âˆ« (x : Î±), â‡‘(star_ring_end ğ•œ) (â‡‘f x) * â‡‘g x âˆ‚Î¼
f y = g y
o.oangle y x = â†‘real.pi - 2 â€¢ o.oangle (y - x) y
is_add_right_regular (b + a) â†” is_add_right_regular b
filter.tendsto f filter.cofinite (nhds 0)
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, complex.I â€¢ â‡‘(fderiv â„ f (â†‘x + â†‘y * complex.I)) 1 - â‡‘(fderiv â„ f (â†‘x + â†‘y * complex.I)) complex.I
finite_dimensional ğ•œ E
function.injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0
U = â¨… (Îµ : Î²) (H : Îµ > z), filter.principal {p : Î± Ã— Î± | D p.fst p.snd < Îµ}
finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i â€¢ g i)
(âˆƒ (k : â„•), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m
iterated_deriv_within n f s = â‡‘((continuous_multilinear_map.pi_field_equiv ğ•œ (fin n) F).symm) âˆ˜ iterated_fderiv_within ğ•œ n f s
f â»Â¹' interior s âŠ† interior (f â»Â¹' s)
âˆ‘' (n : Î²), f n = f b + âˆ‘' (n : Î²), ite (n = b) 0 (f n)
(polynomial.X ^ n - â‡‘polynomial.C a).monic
â†‘(nat.fib (n + 1)) â‰¤ (generalized_continued_fraction.of v).denominators n
f (â¨† (i : Î¹), g i) = â¨† (i : Î¹), f (g i)
concave_on â„ set.univ f
category_theory.skeletal (D â¥¤ C)
P x
supr p = (â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)).range
relation.refl_trans_gen r n m
continuous c.lim
âˆƒ (y : Î²), n â‰¤ (finset.filter (Î» (x : Î±), f x = y) finset.univ).card
(Î» (n : â„•), â†‘(nat.fib n)) = Î» (n : â„•), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
is_open_map f
filter.map coe filter.at_bot = filter.at_bot
P f
group.is_nilpotent G'
minpoly A (â‡‘(algebra_map A B) a) = polynomial.X - â‡‘polynomial.C a
emetric.Hausdorff_edist s t â‰¤ r
polynomial.eval x l.prod = (list.map (polynomial.eval x) l).prod
(charted_space.chart_at (model_prod H E) p).to_local_equiv = (equiv.sigma_equiv_prod H E).to_local_equiv
f z = f w
(matrix.diagonal v).is_hermitian
category_theory.cover_lifting J L (F â‹™ G)
measurable â‡‘f
category_theory.is_iso (category_theory.frobenius_morphism F h A)
strict_mono (Î» (n : â„•), nat.fib (n + 2))
â‡‘f (x * y) = â‡‘f x * â‡‘f y
0.is_diag
â‡‘(Ï.average_map) v âˆˆ Ï.invariants
s.prod (Î» (i : Î±), g i) + s.prod (Î» (i : Î±), h i) = s.prod (Î» (i : Î±), f i)
s âˆˆ finset.powerset_len n t â†” s âŠ† t âˆ§ s.card = n
(â‹ƒ (i : Î¹), s i) = â‹ƒ (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
âˆƒ (c : â„) (H : c < a) (B : â„), (f - g) =O[l] Î» (z : â„‚), real.exp (B * real.exp (c * |u z|))
add_monoid.is_torsion G
is_compact A
p qâ‚ qâ‚‚ qâ‚ƒ
is_scalar_tower R S A
â†‘b ^ x â‰¤ r â†” x â‰¤ int.log b r
âˆƒ (y : E) (H : y âˆˆ K) (z : E) (H : z âˆˆ Ká—®), v = y + z
set.eq_on â‡‘f â‡‘g â†‘(subsemigroup.closure s)
has_strict_fderiv_at â‡‘(f.symm) â†‘(f'.symm) a
convex_independent ğ•œ (Î» (x : â†¥s), â†‘x)
category_theory.epi t.fst
âˆƒ (x : Î±) (H : x âˆˆ s), is_open {x}
P 1 â†’ (âˆ€ (f : equiv.perm Î±) (x y : Î±), x â‰  y â†’ P f â†’ P (f * equiv.swap x y)) â†’ P f
e.to_local_equiv.source âˆ© â‡‘e â»Â¹' (e.to_local_equiv.target âˆ© t) = e.to_local_equiv.source âˆ© s â†’ e.is_image s t
â†‘a = â†‘â†‘a
metric.inf_dist x âˆ… = 0
âˆƒ (n : â„•), y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)
â†‘(â‡‘((measure_theory.Lp_meas_to_Lp_trim_lie F â„ p Î¼ hm).symm) (measure_theory.indicator_const_Lp p hs hÎ¼s c)) = measure_theory.indicator_const_Lp p _ _ c
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ set.range g), f i)) = finprod (Î» (j : Î²), f (g j))
module.rank K V < cardinal.aleph_0
fermat_42.minimal a b c â†’ fermat_42.minimal b a c
strict_convex_space â„ E
(complex.cos z + complex.sin z * complex.I) ^ n = complex.cos (â†‘n * z) + complex.sin (â†‘n * z) * complex.I
â‡‘(category_theory.colimit_adj.restrict_yoneda_hom_equiv A P Eâ‚‚ t) (k â‰« g) = â‡‘(category_theory.colimit_adj.restrict_yoneda_hom_equiv A P Eâ‚ t) k â‰« (category_theory.colimit_adj.restricted_yoneda A).map g
f â‰« homotopy.null_homotopic_map' hom = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), f.f i â‰« hom i j hij)
category_theory.limits.prod.map f g â‰« (category_theory.limits.prod.braiding Y W).hom = (category_theory.limits.prod.braiding X Z).hom â‰« category_theory.limits.prod.map g f
(h.comp g).comp f = h.comp (g.comp f)
âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ s âŠ† closure t
âˆƒ (M : ideal Î±), M.is_maximal âˆ§ I â‰¤ M
is_unit (â‡‘linear_map.det f)
(affine_span k s).direction = vector_span k s
is_max a â†’ a = âŠ¤
has_edist.edist (f 0) a â‰¤ âˆ‘' (m : â„•), d m
is_compact s
x âˆˆ S â†’ y âˆˆ S â†’ x - y âˆˆ S
âˆ« (x : â„) in t..t + T, f x = âˆ« (x : â„) in s..s + T, f x
x - y âˆˆ H
filter.tendsto (Î» (n : â„•), u n / â†‘n) filter.at_top (nhds h.lim)
â‡‘g (finsum (Î» (j : Î±), finsum (Î» (H : j âˆˆ s), f j))) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), â‡‘g (f i)))
âˆƒ (s : set Î±), measurable_set s âˆ§ (âˆ€ (t : set Î±), measurable_set t â†’ t âŠ† s â†’ â‡‘Î½ t â‰¤ â‡‘Î¼ t) âˆ§ âˆ€ (t : set Î±), measurable_set t â†’ t âŠ† sá¶œ â†’ â‡‘Î¼ t â‰¤ â‡‘Î½ t
bdd_below s
metric.Hausdorff_dist s u â‰¤ metric.Hausdorff_dist s t + metric.Hausdorff_dist t u
s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
fintype.card Î± * n â‰¤ B.sum (Î» (s : finset Î±), s.card)
o.oangle y z + o.oangle x y = o.oangle x z
filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_top filter.at_top
â†‘s.finite
mul_opposite.unop (â‡‘f l.prod) = (list.map (mul_opposite.unop âˆ˜ â‡‘f) l).reverse.prod
category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom h f = (category_theory.limits.is_colimit.of_nat_iso.colimit_cocone h).extend f
submodule.span R s = (finsupp.total â†¥s M R coe).range
â‡‘f a âˆˆ local_ring.maximal_ideal S
0 = 1 â†’ subsingleton Mâ‚€
L.nth_le (i + j) h = (list.drop i L).nth_le j _
A.definable L ((Î» (g : Î² â†’ M), g âˆ˜ f) '' s)
cont_diff_within_at ğ•œ n prod.fst s p
group.fg G â†” âˆƒ (S : set G), subgroup.closure S = âŠ¤ âˆ§ S.finite
differentiable_at ğ•œ f x â†’ mdifferentiable_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x
submodule.span R {x} = (linear_map.to_span_singleton R M x).range
even (m ^ n) â†” even m âˆ§ n â‰  0
subgroup.closure (set.range (Î» (v : F), reflection (submodule.span â„ {v})á—®)) = âŠ¤
o.oangle x (x - y) = o.oangle (y - x) y
-1 â‰  1
â†‘(â‡‘star_module.re x) + complex.I â€¢ â†‘(â‡‘star_module.im x) = x
aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
infi f â‰¤ infi g
Î¼.absolutely_continuous Î½
B.sum (Î» (s : finset Î±), s.card) = fintype.card Î± * n
â‡‘(power_series.coeff R (Ï†.order.get h)) Ï† â‰  0
e.trans f â‰ˆ e'.trans f'
a < b - c â†” c + a < b
dense (s  t)
continuous_within_at f s x
â‡‘(s.weighted_vsub p) w âˆˆ vector_span k (set.range p)
strict_concave_on ğ•œ s (-f) â†” strict_convex_on ğ•œ s f
fderiv â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (a, b) = (continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca
0 < a * b
a + b < 0
has_Sup.Sup {a} = a
âˆƒ (y : Î²), (finset.filter (Î» (x : Î±), f x = y) finset.univ).sum (Î» (x : Î±), w x) â‰¤ b
s âˆˆ nhds_within a (set.Ici a) â†” âˆƒ (u : Î±), a < u âˆ§ set.Icc a u âŠ† s
is_R_or_C.abs (has_inner.inner x y) * is_R_or_C.abs (has_inner.inner y x) â‰¤ â‡‘is_R_or_C.re (has_inner.inner x x) * â‡‘is_R_or_C.re (has_inner.inner y y)
relation.trans_gen r n m
A.det = A inhabited.default inhabited.default
category_theory.is_iso c.Ï€
x + 1 â‰¤ real.exp x
padic_norm p (q + r) = linear_order.max (padic_norm p q) (padic_norm p r)
fib_rec.is_solution (has_pow.pow golden_conj)
âˆ¥S.normed_mkâˆ¥ = 1
H n â‰¤ upper_central_series G n
continuous â‡‘f
(âˆƒ (f : C(Î±, Î²)), filter.tendsto F l (nhds f)) â†” âˆ€ (s : set Î±), is_compact s â†’ (âˆƒ (f : C(â†¥s, Î²)), filter.tendsto (Î» (i : Î¹), continuous_map.restrict s (F i)) l (nhds f))
âˆƒ (Îµ' : â„) (H : Îµ' < Îµ), x âˆˆ metric.ball y Îµ'
closure (â‡‘(convex_hull â„) (set.extreme_points â„ s)) = s
âˆ¥f.mk_continuous C Hâˆ¥ â‰¤ C
a âˆˆ closure s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (b : Î±) (H : b âˆˆ s), has_dist.dist a b < Îµ)
filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_top
cauchy_seq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ has_dist.dist (u m) (u n) < Îµ)
hb.conj_lie.symm = hb.conj_lie
âˆƒ (C : â„), 0 â‰¤ C âˆ§ C â‰¤ A * B âˆ§ has_sum (Î» (i : Î¹), f i * g i) C
transitive (category_theory.abelian.pseudo_equal P)
s âŠ† â†‘(â‡‘(first_order.language.substructure.closure L) s)
â†‘(g â€¢ z) = â†‘(â‡‘(modular_group.lc_row0 p) â†‘â†‘g) / (â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2) + (â†‘(p 1) * â†‘z - â†‘(p 0)) / ((â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2) * (â†‘(p 0) * â†‘z + â†‘(p 1)))
t.prod (Î» (c : Î¹), f c) âˆˆ S
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), (g b - g a) * deriv f c = (f b - f a) * deriv g c
0 < (p.right_inv i).radius
is_dedekind_domain A â†” is_dedekind_domain_inv A
finite_dimensional.finrank K V = 1 â†” submodule.span K {v} = âŠ¤
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
â‡‘(Î¼.prod measure_theory.measure_space.volume) (region_between f g s) = âˆ«â» (y : Î±) in s, ennreal.of_real ((g - f) y) âˆ‚Î¼
con_gen r â‰¤ con_gen s
X.to_Î“_Spec_map_basic_open r = X.to_RingedSpace.basic_open r
1 â‰¤ a * b
convex_on â„ set.univ (Î» (x : â„), x ^ n)
cont_diff_on ğ•œ â†‘(n + 1) f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ â†‘n (Î» (y : E), fderiv ğ•œ f y) s
s - t â‰¤ u â†” s â‰¤ u + t
continuous coe_fn
âˆƒ (Uâ‚ : set Î±) (H : Uâ‚ âˆˆ nhds x) (Vâ‚ : set Î±) (H : Vâ‚ âˆˆ nhds x) (Uâ‚‚ : set Î±) (H : Uâ‚‚ âˆˆ nhds y) (Vâ‚‚ : set Î±) (H : Vâ‚‚ âˆˆ nhds y), is_closed Vâ‚ âˆ§ is_closed Vâ‚‚ âˆ§ is_open Uâ‚ âˆ§ is_open Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Uâ‚ âˆ© Uâ‚‚ = âˆ…
a âˆ£ c * b
has_deriv_within_at f f' s x â†” has_fderiv_within_at f (1.smul_right f') s x
âˆƒ (n : â„•) (e : M â†’ euclidean_space â„ (fin n)), smooth I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e âˆ§ function.injective e âˆ§ âˆ€ (x : M), function.injective â‡‘(mfderiv I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e x)
â‡‘f (x ^ n) = â‡‘f x ^ n
bdd_below s â†’ bdd_below t â†’ bdd_below (set.image2 f s t)
Â¬p n â†’ nat.count p (n + 1) = nat.count p n
â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w / y) (x / z)
âˆƒ (f : smooth_partition_of_unity Î¹ I M s), f.is_subordinate U
is_add_group_hom has_neg.neg
â‡‘(affine_map.line_map (slope f (â‡‘(affine_map.line_map a b) r) b) (slope f a (â‡‘(affine_map.line_map a b) r))) r = slope f a b
âˆƒ (f : nat.partrec.code â†’ â„• â†’ nat.partrec.code), computableâ‚‚ f âˆ§ âˆ€ (c : nat.partrec.code) (n x : â„•), (f c n).eval x = c.eval (nat.mkpair n x)
finite_dimensional.finrank k â†¥(vector_span k (set.range p)) = n
free_group.red Lâ‚ Lâ‚‚ â†’ Lâ‚‚ <+ Lâ‚
zmod.legendre_sym q â†‘p * zmod.legendre_sym p â†‘q = (-1) ^ (p / 2 * (q / 2))
âˆƒ (g : C(Y, â„)), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ â‡‘g âˆ˜ e = â‡‘f
is_algebraic K x â†” is_integral K x
â‡‘(probability_theory.cond_count (s âˆ© u)) t * â‡‘(probability_theory.cond_count s) u + â‡‘(probability_theory.cond_count (s âˆ© uá¶œ)) t * â‡‘(probability_theory.cond_count s) uá¶œ = â‡‘(probability_theory.cond_count s) t
a âˆ£ b * c
âˆƒ (u : M) (a b : R), 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ vâ‚ = a â€¢ u âˆ§ vâ‚‚ = b â€¢ u
âˆƒ (y : Î²) (H : y âˆˆ t), n < (finset.filter (Î» (x : Î±), f x = y) s).card
is_lub t a
polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n â„¤) = polynomial.cyclotomic n R
char.quadratic_char F a = 1
(s.prod (Î» (i : Î¹), f i)).nat_degree = s.sum (Î» (i : Î¹), (f i).nat_degree)
measure_theory.uniform_integrable f p Î¼ â†” (âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) âˆ§ âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (C : nnreal), âˆ€ (i : Î¹), measure_theory.snorm ({x : Î± | C â‰¤ âˆ¥f i xâˆ¥â‚Š}.indicator (f i)) p Î¼ â‰¤ ennreal.of_real Îµ)
has_deriv_at f (g x) x
x +áµ¥ r â€¢ metric.closed_ball 0 1 = metric.closed_ball x r
n.asc_factorial k = (n + k).factorial / n.factorial
2 â€¢ hb.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
fintype.card â†¥(G.common_neighbors v w) < G.degree v
â‡‘(polynomial.aeval M) M.charpoly = 0
subsemiring.map f (subsemiring.closure s) = subsemiring.closure (â‡‘f '' s)
category_theory.is_idempotent_complete C â†” âˆ€ (X : C) (p : X âŸ¶ X), p â‰« p = p â†’ category_theory.limits.has_equalizer (ğŸ™ X) p
âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ â‰¤ 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
A.definable L ((Î» (g : Î² â†’ M), g âˆ˜ â‡‘f) '' s)
closure E = â‹‚ (Î´ : â„) (h : 0 < Î´), metric.thickening Î´ E
{to_finsupp := a} = {to_finsupp := b} â†” a = b
cont_diff_at ğ•œ n (Î» (x : E Ã— F), f x.snd) x
finset.univ = finset.cons 0 (finset.map {to_fun := fin.succ n, inj' := _} finset.univ) _
(vector.scanl f b v).head = b
(â‹ƒ (i : Î±) (H : i âˆˆ set.Ico m n), set.Ioc (f i) (f (order.succ i))) = set.Ioc (f m) (f n)
set.eq_on f g U
is_coprime (polynomial.cyclotomic n â„š) (polynomial.cyclotomic m â„š)
âˆƒ (u : â„¤Ë£) (n : â„•), algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = â†‘u * â†‘p ^ n
s.sum (Î» (i : Î¹), w i * z i) ^ n â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ n)
â†‘f.to_add_monoid_hom = â†‘f.to_add_monoid_hom
finset.univ.sum (Î» (i : Î¹), f i * g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i)
Aâ»Â¹.mul A = 1
interval_integrable (F' xâ‚€) Î¼ a b âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' xâ‚€ t âˆ‚Î¼) xâ‚€
has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€
metric.inf_dist x s < r â†” âˆƒ (y : Î±) (H : y âˆˆ s), has_dist.dist x y < r
(âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
â‡‘polynomial.C s âˆˆ polynomial.lifts f
(s1 âŠ“ s2).direction â‰¤ s1.direction âŠ“ s2.direction
Î¼.absolutely_continuous Î½ â†’ Î¼.ae â‰¤ Î½.ae
padic_val_rat p â†‘p = 1
list.take n (lâ‚ ++ lâ‚‚) = list.take n lâ‚ ++ list.take (n - lâ‚.length) lâ‚‚
set.inj_on nat.factorization {x : â„• | x â‰  0}
S = âŠ¥ âˆ¨ nontrivial â†¥S
star_convex ğ•œ x s â†” âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 < a + b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ s
âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
s.prod (Î» (i : Î±), f i) * sá¶œ.prod (Î» (i : Î±), f i) = finset.univ.prod (Î» (i : Î±), f i)
I âˆ£ J â†’ J â‰¤ I
list.insertion_sort r l = l
b = a
k = l
x ^ k âˆ£ x ^ l â†” k â‰¤ l
finset.univ = âˆ…
function.surjective proj
((M.mul N).mul P).det = ((M.mul P).mul N).det
measure_theory.measure.map (Î» (z : G Ã— G), (z.snd, z.snd * z.fst)) (Î¼.prod Î½) = Î½.prod Î¼
mul_action.stabilizer Î± (g â€¢ x) = subgroup.map (mul_equiv.to_monoid_hom (â‡‘mul_aut.conj g)) (mul_action.stabilizer Î± x)
simplex_category.Î´ i.succ â‰« simplex_category.Ïƒ (â‡‘fin.cast_succ j) = simplex_category.Ïƒ j â‰« simplex_category.Î´ i
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ g (â¨ (x : Î±), f x âˆ‚Î¼) < â¨ (x : Î±), g (f x) âˆ‚Î¼
filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), â†‘(f a) âˆ‚â†‘Î¼))
balanced ğ•œ (metric.ball 0 r)
filter.tendsto (Î» (n : Î¹), F n x) p (nhds (f x))
S = T
filter.tendsto (Î» (x : Î²), f x * r) l filter.at_bot
category_theory.limits.has_images C
â†‘â†‘e = â†‘â†‘e
add_con.ker c.mk' = c
Îµ ^ p.to_real * â‡‘Î¼ {x : Î± | Îµ â‰¤ â†‘âˆ¥â‡‘f xâˆ¥â‚Š} â‰¤ ennreal.of_real âˆ¥fâˆ¥ ^ p.to_real
Mon.filtered_colimits.M.mk F x * Mon.filtered_colimits.M.mk F y = Mon.filtered_colimits.M.mk F âŸ¨k, â‡‘(F.map f) x.snd * â‡‘(F.map g) y.sndâŸ©
x âˆ‰ s â†” 0 < metric.inf_dist x s
(cf.prec cg).eval (nat.mkpair a k.succ) = (cf.prec cg).eval (nat.mkpair a k) >>= Î» (ih : â„•), cg.eval (nat.mkpair a (nat.mkpair k ih))
iterated_deriv n f = â‡‘((continuous_multilinear_map.pi_field_equiv ğ•œ (fin n) F).symm) âˆ˜ iterated_fderiv ğ•œ n f
continuous_at (Î» (a : Î±), (f a).fst) x
quotient_map proj
closure (set.Ioo a b) = set.Icc a b
f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
o.compares b a â†’ o.swap.compares a b
(upper_bounds s âˆ© t).nonempty â†’ bdd_below (f '' s)
continuous (Î» (p : Î± Ã— Î±), p.fst * p.snd)
metric.bounded (s âˆª t) â†” metric.bounded s âˆ§ metric.bounded t
x â‰¤ y
(quiver.shortest_path r a).length â‰¤ p.length
â‡‘matrix.to_lin' A.conj_transpose = â‡‘linear_map.adjoint (â‡‘matrix.to_lin' A)
metric.inf_dist x {y} = has_dist.dist x y
is_regular a âˆ§ is_regular b
pairwise (disjoint on Î» (n : Î±), set.Ico (f n) (f (order.succ n)))
1 < a * b
âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ f x) âˆ§ upper_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ
b < a â†’ â‡‘order_dual.to_dual a < â‡‘order_dual.to_dual b
a < b â†’ a - b < 0
cardinal.mk (quaternion R) = cardinal.mk R ^ 4
finset.imageâ‚‚ f s (finset.image g t) = finset.image g' (finset.imageâ‚‚ f' s t)
hb.oangle y x = -hb.oangle x y
deriv f a = 0
Â¬B.is_ortho (â‡‘v i) (â‡‘v i)
e.to_matrix â‡‘(e.is_unit_smul hw) = matrix.diagonal w
âˆƒ (k : ğ•œ), k âˆˆ spectrum ğ•œ a
x âˆˆ S â†’ -x âˆˆ S
Â¬a
bornology.is_cobounded s â†’ bornology.is_bounded sá¶œ
function.periodic_orbit f x = â†‘(list.map (Î» (n : â„•), f^[n] x) (list.range (function.minimal_period f x)))
âˆ« (x : Î±) in s, measure_theory.condexp m Î¼ f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
lipschitz_on_with C f s
s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
semiconj_by a 1 1
category_theory.mono Î±
w * â†‘(â‡‘(is_unit.lift_right (f.restrict S) h) y)â»Â¹ = z â†” w = â‡‘f â†‘y * z
Îµ * â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼
1 âˆˆ s
fâ‚ = fâ‚‚
âˆƒ (S : C), âˆ€ {X : C}, X âˆˆ O â†’ nonempty (S âŸ¶ X)
P f
finset.fold op b (Î» (i : Î±), ite (p i) (f i) (g i)) s = op (finset.fold op b f (finset.filter p s)) (finset.fold op b g (finset.filter (Î» (i : Î±), Â¬p i) s))
box_integral.integrable I l f vol â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (r : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)), (âˆ€ (c : nnreal), l.r_cond (r c)) âˆ§ âˆ€ (câ‚ câ‚‚ : nnreal) (Ï€â‚ Ï€â‚‚ : box_integral.tagged_prepartition I), l.mem_base_set I câ‚ (r câ‚) Ï€â‚ â†’ Ï€â‚.is_partition â†’ l.mem_base_set I câ‚‚ (r câ‚‚) Ï€â‚‚ â†’ Ï€â‚‚.is_partition â†’ has_dist.dist (box_integral.integral_sum f vol Ï€â‚) (box_integral.integral_sum f vol Ï€â‚‚) â‰¤ Îµ)
has_dist.dist (box_integral.integral_sum f vol Ï€) (Ï€.to_prepartition.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)) â‰¤ Îµ
is_square (-1) â†” fintype.card F % 4 â‰  3
function.is_fixed_pt f y
has_sum (Î» (i : â„¤), â‡‘(â‡‘(fourier_series.repr) f) i â€¢ fourier_Lp 2 i) f
g.convergents' (n + 1) = (g.squash_gcf n).convergents' n
nonempty (fintype Î¹)
âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z
s.points_with_circumcenter (affine.simplex.points_with_circumcenter_index.point_index i) = s.points i
category_theory.limits.has_coproducts_of_shape X Cáµ’áµ–
lower_semicontinuous (Î» (z : Î±), f z + g z)
has_edist.edist x.val y.val â‰  âŠ¤
finsupp.comap_domain f 0 hif = 0
measure_theory.null_measurable_set s Î¼
a + b â‰¤ c â†’ b â‰¤ -a + c
is_totally_disconnected s
bornology.is_vonN_bounded ğ•œ {x}
1 / a â‰¤ 1 / b â†” b â‰¤ a
Â¬B.is_ortho (â‡‘v i) (â‡‘v i)
(finsupp.on_finset s f hf).sum g = s.sum (Î» (a : Î±), g a (f a))
is_open (s Ã—Ë¢ t) â†” is_open s âˆ§ is_open t âˆ¨ s = âˆ… âˆ¨ t = âˆ…
âˆƒ (g : matrix.special_linear_group (fin 2) â„¤), â†‘g 1 = cd âˆ§ âˆ€ (g' : matrix.special_linear_group (fin 2) â„¤), â†‘g 1 = â†‘g' 1 â†’ |(g â€¢ z).re| â‰¤ |(g' â€¢ z).re|
set.Union_lift S f hf T hT c = cÎ²
âˆƒ (t : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), t i âŠ† s i) âˆ§ (âˆ€ (i : Î¹), s i =áµ[Î¼] t i) âˆ§ (âˆ€ (i : Î¹), measurable_set (t i)) âˆ§ pairwise (disjoint on t)
p x
F.is_sheaf â†” F.is_sheaf_unique_gluing
category_theory.is_iso (category_theory.limits.cokernel.Ï€ 0)
(â‹‚ (i : Î¹), s i) = â‹‚ (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
uniform_continuous f
âˆƒ (g : E â‰ƒâ‚œ F), set.eq_on f â‡‘g s
Ïˆ = Ïˆ'
-â‡‘(â‡‘cross_product v) w = â‡‘(â‡‘cross_product w) v
padic_val_rat p (rat.mk nâ‚ dâ‚) â‰¤ padic_val_rat p (rat.mk nâ‚‚ dâ‚‚) â†” âˆ€ (n : â„•), â†‘p ^ n âˆ£ nâ‚ * dâ‚‚ â†’ â†‘p ^ n âˆ£ nâ‚‚ * dâ‚
function.periodic_orbit f x = cycle.map (Î» (n : â„•), f^[n] x) â†‘(list.range (function.minimal_period f x))
â‡‘(star_ring_end R) (â‡‘(star_ring_end R) x) = x
set.maps_to â‡‘f' (tangent_cone_at ğ•œ s x) (tangent_cone_at ğ•œ (f '' s) (f x))
A.definable L ((Î» (g : Î± âŠ• fin m â†’ M), g âˆ˜ sum.inl) '' s)
approximates_linear_on f f' s c â†’ lipschitz_on_with c (f - â‡‘f') s
has_ftaylor_series_up_to_on n f (ftaylor_series_within ğ•œ f s) s
emetric.ball x â†‘Îµ = metric.ball x â†‘Îµ
(list.take i (list.map list.length L)).sum + j < L.join.length
((Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f' =O[l] g'
âˆ¥c.smul_right fâˆ¥ = âˆ¥câˆ¥ * âˆ¥fâˆ¥
padic_val_rat p (q * r) = padic_val_rat p q + padic_val_rat p r
{Î³} âˆˆ nhds Î³
âˆƒ (c : K), f.has_eigenvalue c
Gromov_Hausdorff.to_GH_space X = Gromov_Hausdorff.to_GH_space Y â†” nonempty (X â‰ƒáµ¢ Y)
topological_space.induced has_pure.pure ultrafilter.topological_space = âŠ¥
â†‘(mersenne p) = 0
(f â‰« g)á˜ = gá˜ â‰« fá˜
isometry id
u =o[l] v â†’ (âˆƒ (Ï† : Î± â†’ ğ•œ) (hÏ† : filter.tendsto Ï† l (nhds 0)), u =á¶ [l] Ï† * v)
s.prod (Î» (x : Î±), f x) = t.prod (Î» (x : Î³), g x)
finite_dimensional K â†¥s
list.map list.length (l.split_wrt_composition c) = c.blocks
sizeof u.step < sizeof u
x = y
is_algebraic A x â†” is_algebraic K x
â‡‘(affine_map.line_map (f a) (f b)) r < f (â‡‘(affine_map.line_map a b) r) â†” slope f (â‡‘(affine_map.line_map a b) r) b < slope f a b
finset.centroid k (finset.map e sâ‚‚) p = finset.centroid k sâ‚‚ (p âˆ˜ â‡‘e)
is_of_fin_order x â†” is_of_fin_order â†‘x
âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f x â‰¤ f y
âˆƒ! (b : set Î±) (H : b âˆˆ c), a âˆˆ b
unique_diff_within_at â„ s x
(k + n).prime_counting' â‰¤ k.prime_counting' + a.totient * (n / a + 1)
âˆƒ (r : â„) (hr : r âˆˆ set.Ioo 0 f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R), s âŠ† (charted_space.chart_at H c).to_local_equiv.source âˆ© â‡‘(ext_chart_at I c) â»Â¹' euclidean.ball (â‡‘(ext_chart_at I c) c) r
n â‰¤ k â†’ '0' â‰¤ buffer.read cb âŸ¨k, _âŸ© âˆ§ buffer.read cb âŸ¨k, _âŸ© â‰¤ '9'
0.prod = 1
râ‚ = râ‚‚ â†” âˆ€ (x : Î±), {y : Î± | râ‚.rel x y} = {y : Î± | râ‚‚.rel x y}
Î¼.is_open_pos_measure
âˆƒ (x : E), âˆ¥xâˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ s â†’ 1 â‰¤ âˆ¥y - xâˆ¥
homotopy.null_homotopic_map' hom â‰« g = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), hom i j hij â‰« g.f j)
module.rank R M < cardinal.aleph_0
filter.tendsto (Î» (x : Î±), x ^ n) filter.at_top filter.at_top
(â‹ƒ (i : Î¹'), s i) = â‹ƒ (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
(âˆ€ (n : â„•), 0 < n â†’ n.divisors.sum (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.sum (Î» (x : â„• Ã— â„•), â‡‘nat.arithmetic_function.moebius x.fst â€¢ g x.snd) = f n
(category_theory.limits.biprod.braiding P Q).hom â‰« (category_theory.limits.biprod.braiding Q P).hom = ğŸ™ (P âŠ Q)
complex.abs (deriv f c) â‰¤ 1
polynomial.X ^ n âˆˆ polynomial.lifts f
category_theory.is_iso f
finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” monovary f (g âˆ˜ â‡‘Ïƒ)
module.End.has_eigenvalue T (â†‘â¨… (x : {x // x â‰  0}), â‡‘is_R_or_C.re (has_inner.inner (â‡‘T â†‘x) â†‘x) / âˆ¥â†‘xâˆ¥ ^ 2)
(p /â‚˜ q).leading_coeff = p.leading_coeff
s âŠ† â†‘(subsemiring.closure s)
measure_theory.condexp m Î¼ (s.indicator f) =áµ[Î¼] s.indicator (measure_theory.condexp m Î¼ f)
â‡‘((a * b).factorization) p = â‡‘(a.factorization) p
m.factor_multiset â‰¤ n.factor_multiset â†” m âˆ£ n
a * b = 0 â†” a = 0 âˆ¨ b = 0
â‡‘p y â‰¤ â‡‘p x + â‡‘p (x - y)
hb.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
cont_diff_within_at ğ•œ n (â‡‘e âˆ˜ f) s x â†” cont_diff_within_at ğ•œ n f s x
real.sinh (real.arsinh x) = x
0 < L.length
complete_lattice.independent V
has_inner.inner (s.sum (Î» (i : Î¹), f i)) x = s.sum (Î» (i : Î¹), has_inner.inner (f i) x)
nonarchimedean_group H
padic_val_rat p â†‘z = â†‘(padic_val_int p z)
s.fg â†” complete_lattice.is_compact_element s
a * b < 1
â‡‘dfinsupp.lift_add_hom (dfinsupp.single_add_hom Î²) = add_monoid_hom.id (Î â‚€ (i : Î¹), Î² i)
measure_theory.integrable â‡‘(measure_theory.condexp_ind_smul hm hs hÎ¼s x) Î¼
lipschitz_on_with C f s â†’ holder_on_with C 1 f s
s.sum (Î» (a : Î±), f (g a)) = (finset.image g s).sum (Î» (b : Î³), (finset.filter (Î» (a : Î±), g a = b) s).card â€¢ f b)
a * b â‰¤ 1
â‡‘f aâ»Â¹ = (â‡‘f a)â»Â¹
(category_theory.limits.coprod.braiding P Q).hom â‰« (category_theory.limits.coprod.braiding Q P).hom = ğŸ™ (P â¨¿ Q)
â‡‘linear_map.det â†‘((o.rotation Î¸).to_linear_equiv) = 1
category_theory.is_iso f
(âˆƒ (a : Î±), b = l a) â†” b = l (u b)
(â‹‚ (j : Î¹'), â‹ƒ (i : Î¹), s i j) = â‹ƒ (i : Î¹), â‹‚ (j : Î¹'), s i j
â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ s
add_monoid.is_torsion_free (Î  (i : Î·), Gs i)
âˆƒ (i : Î¹) (x : G i), â‡‘(module.direct_limit.of R Î¹ G f i) x = z
(simple_graph.adj_matrix Î± G).is_adj_matrix
category_theory.is_iso f
char.quadratic_char F a = 0 â†” a = 0
p -áµ¥ p2 âˆˆ s.direction â†” p2 âˆˆ s
a âˆ£ b
is_compact t
continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)
â‡‘f 1 = 1
has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s c) f = âˆ« (x : Î±) in s, has_inner.inner c (â‡‘f x) âˆ‚Î¼
p1 -áµ¥ p2 +áµ¥ p2 = p1
fintype.card P â‰¤ fintype.card L
has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2|
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.weighted_vsub_of_point pâ‚ b) w - s.sum (Î» (i : Î¹), w i) â€¢ (pâ‚‚ -áµ¥ b)
s.countable â†” âˆƒ (f : â„• â†’ â†¥s), function.surjective f
has_strict_deriv_at (exp ğ•‚) (exp ğ•‚ x) x
dense (â‹ƒ (s : Î²) (H : s âˆˆ S), interior (f s))
â‡‘((â‡‘fin.cast_succ p).succ_above) (p.pred_above i) = i
â‡‘(euclidean_geometry.reflection s) p = p â†” p âˆˆ s
fintype.card Î± = 1
category_theory.limits.has_products (category_theory.over B)
has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = -1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), r < 0 âˆ§ y = r â€¢ x
is_of_fin_add_order (x + y)
convolution f g L Î¼ x = âˆ« (t : G), â‡‘(â‡‘L (f (x - t))) (g t) âˆ‚Î¼
Â¬is_unit (minpoly A x)
(infi f).ne_bot
n â€¢ x = n â€¢ x
finset.centroid R s p = s.center_mass (finset.centroid_weights R s) p
Â¬is_min a
continuous_at f x â†” continuous_at (â‡‘e âˆ˜ f) x
b â‰¤ a â†’ 0 â‰¤ a - b
continuous (Î» (x : â„ Ã— â„ Ã— â†¥unit_interval), â‡‘(Î³.truncate x.fst x.snd.fst) x.snd.snd)
mfderiv (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x = fderiv ğ•œ f x
(â‹‚ (n : â„•), s n).nonempty
âˆƒ (V : set G) (H : V âˆˆ nhds 1), K * V âŠ† U
(â†‘I âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ â†‘s), â†‘(f i)) â†” âˆƒ (i : Î¹) (H : i âˆˆ s), I â‰¤ f i
â‡‘(algebra_map K L) x âˆˆ S
xs.next_or x d = xs.next_or x d'
set.Icc (f a) (f b) âŠ† f '' s
â‡‘((basis.mk hli hsp).coord i) (v i) = 1
Â¬a â‰¤ b â†’ multiset.Icc a b = 0
â‡‘f x = â‡‘g x
has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
1 â‰¤ â†‘b ^ f.nat_degree * |polynomial.eval (â†‘a / â†‘b) (polynomial.map (algebra_map â„¤ K) f)|
pairwise (disjoint on Î» (n : Î±), set.Ioo (f (order.succ n)) (f n))
â†‘p.factor_multiset = prime_multiset.of_prime p
â†‘-u = -â†‘u
con_gen â‡‘(con_gen r) = con_gen r
â‡‘Î¼ (filter.at_top.limsup s) = 0
â‡‘(algebra_map K E) (algebra.discr K â‡‘(pb.basis)) = finset.univ.prod (Î» (i : fin pb.dim), (finset.filter (Î» (j : fin pb.dim), i < j) finset.univ).prod (Î» (j : fin pb.dim), -((â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) * (â‡‘(â‡‘e i) pb.gen - â‡‘(â‡‘e j) pb.gen))))
emetric.closed_ball x (ennreal.of_real Îµ) = metric.closed_ball x Îµ
finite_dimensional K S
polynomial.nth_roots_finset â†‘n R = â†‘n.divisors.bUnion (Î» (i : â„•), primitive_roots i R)
âˆƒ (u : set Î±), measurable_set u âˆ§ â‡‘Î¼ u = 0 âˆ§ disjoint (s  u) t
b < c - a â†’ a + b < c
âˆƒ (l : list M), (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) âˆ§ l.sum = a
dense s â†” âˆ€ (a b : Î±), a < b â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), a < c âˆ§ c < b)
âˆƒ (y : â†¥â†‘t), x âˆˆ â‡‘(convex_hull ğ•œ) â†‘(t.erase â†‘y)
aâ»Â¹ < b â†” bâ»Â¹ < a
dimH (set.range f) â‰¤ â†‘(finite_dimensional.finrank â„ E)
p âˆˆ (a * b).factors
fintype.card â†¥s âˆ£ fintype.card Î±
x âˆˆ supr p â†” âˆƒ (f : Î â‚€ (i : Î¹), â†¥(p i)), f.sum (Î» (i : Î¹) (xi : â†¥(p i)), â†‘xi) = x
f = f'
category_theory.presheaf.first_map R F â‰« (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom â‰« Top.presheaf.sheaf_condition_equalizer_products.left_res F (Top.presheaf.covering_of_presieve U R)
âˆƒ (r' : Î¹ â†’ â„), (â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) = set.univ âˆ§ âˆ€ (i : Î¹), r' i < r i
{c : cardinal | âˆƒ (S : set Î±), set.unbounded r S âˆ§ cardinal.mk â†¥S = c}.nonempty
n â€¢ b = â†‘n â€¢ b
s_1 âˆˆ f.lift g â†” âˆƒ (i : Î¹) (hi : p i) (x : Î² i) (hx : pg i x), sg i x âŠ† s_1
module.rank R (Î¹ â†’â‚€ R) = cardinal.mk Î¹
is_coatomic â†¥(set.Iic k)
set.sized r â†‘ğ’œ â†’ ğ’œ âŠ† finset.powerset_len r finset.univ
p x y
affine_span k âˆ… = âŠ¥
(â‹‚ (j : Î¹'), â‹ƒ (i : Î¹), s i j) = â‹ƒ (i : Î¹), â‹‚ (j : Î¹'), s i j
affine_independent â„ p
Â¬is_left_regular 0 â†” nontrivial R
metric.bounded s
(finset.range d).attach.sum (Î» (i : {x // x âˆˆ finset.range d}), (holor.unit_vec d â†‘i).mul (x.slice â†‘i _)) = x
X.Î´ i.succ â‰« X.Ïƒ i = ğŸ™ (X.obj (simplex_category.mk n))
category_theory.cover_preserving J J (ğŸ­ C)
bdd_above s
t.prod.degree = (multiset.map (Î» (f : polynomial R), f.degree) t).sum
category_theory.essentially_small C â†” small (category_theory.skeleton C)
dite (Â¬P) x y = dite P (Î» (h : P), y _) x
subring.closure â†‘s = s
p a b
(â¨† (g : ultrafilter Î±) (hg : â†‘g â‰¤ f), â†‘g) = f
âˆ¥xâˆ¥ = âˆ¥yâˆ¥
âˆƒ (t : â†¥M), t â€¢ x âˆˆ submodule.span R s
category_theory.presheaf.is_sheaf J (J.plus_obj (J.plus_obj P))
p.remove_zero.left_inv i = p.left_inv i
s.Î¹ â‰« Top.presheaf.presieve_of_covering.pi_opens_to_first_obj F U â‰« Top.presheaf.presieve_of_covering.first_obj_to_pi_opens F U = s.Î¹
f = g
Î¼.prod Î½ = Î¼Î½
supr f â‰¤ supr g
â‡‘c w x â†’ â‡‘c (n â€¢ w) (n â€¢ x)
cont_diff_on ğ•œ n f s â†’ cont_mdiff_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s
x * s â€¢ y = s â€¢ (x * y)
_.closure_operator = c
well_founded gt â†’ complete_lattice.is_sup_closed_compact Î±
set.range (s.face h).points = s.points '' â†‘fs
dimH (f '' s) â‰¤ dimH s
nontrivial V
dimH s = 0
[s âˆˆ nhds_within a (set.Ioi a), s âˆˆ nhds_within a (set.Ioc a b), s âˆˆ nhds_within a (set.Ioo a b), âˆƒ (u : Î±) (H : u âˆˆ set.Ioc a b), set.Ioo a u âŠ† s, âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ioo a u âŠ† s].tfae
is_unit (algebra.discr K â‡‘b)
r â€¢ metric.ball 0 1 = metric.ball 0 r
has_inner.inner (v i) (â‡‘(finsupp.total Î¹ E ğ•œ v) l) = â‡‘l i
ite (Â¬P) a b = ite P b a
is_chain (flip r) s
emetric.Hausdorff_edist s t â‰¤ r
â‡‘multilinear_map.alternatization (g.comp_multilinear_map f) = â‡‘(g.comp_alternating_map) (â‡‘multilinear_map.alternatization f)
isometry f
filter.tendsto (Î» (x : Î±), f x / g x) l (nhds 0) â†’ f =o[l] g
ğ’œ.card â‰¤ (fintype.card Î±).choose (fintype.card Î± / 2)
n.totient â‰¤ (minpoly â„¤ Î¼).nat_degree
ğ’œ.card * r â‰¤ ğ’œ.shadow.card * (fintype.card Î± - r + 1)
a - âŠ¤ = 0
âˆƒ (Î¹ : Type u) [_inst_8 : fintype Î¹] (p : Î¹ â†’ R) [_inst_9 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), nonempty (N â‰ƒâ‚—[R] direct_sum Î¹ (Î» (i : Î¹), R â§¸ submodule.span R {p i ^ e i}))
v +áµ¥ p âˆˆ span_points k s
a.countable
category_theory.mono f
function.injective coe
is_cyclic G
set.range â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚) = â‡‘category_theory.limits.pullback.fst â»Â¹' set.range â‡‘iâ‚ âˆ© â‡‘category_theory.limits.pullback.snd â»Â¹' set.range â‡‘iâ‚‚
âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) â‰¤ b
function.involutive â‡‘(euclidean_geometry.reflection s)
inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x) = real.pi
finset.centroid â„ fs s.points = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.centroid_weights_with_circumcenter fs)
(finset.range (fintype.card Î± + 1)).sum (Î» (r : â„•), â†‘((ğ’œ.slice r).card) / â†‘((fintype.card Î±).choose r)) â‰¤ 1
f x â‰¤ gronwall_bound Î´ K Îµ (x - a)
list.duplicate x l â†” âˆƒ (n : â„•) (hn : n < l.length) (m : â„•) (hm : m < l.length) (h : n < m), x = l.nth_le n hn âˆ§ x = l.nth_le m hm
bâ»Â¹ * a < c â†’ a < b * c
function.injective â‡‘f
category_theory.limits.has_colimits_of_shape J C
g.numerators (n + 2) = gp.b * predA + gp.a * ppredA
(âˆ€ (a : K), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
f' =O[l] g â†’ (Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] g
disjoint s t â†’ 0 âˆ‰ s - t
âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ linear_order.max C 0
cauchy_seq (Î» (s : finset â„•), s.sum (Î» (x : â„•), f x))
âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), deriv f c = (f b - f a) / (b - a)
bdd_below s â†’ a âˆˆ s â†’ a < b â†’ has_Inf.Inf s < b
category_theory.exact (F.map f) (F.map g)
euclidean_geometry.cospherical ps â†” âˆƒ (center : P) (H : center âˆˆ s) (radius : â„), âˆ€ (p : P), p âˆˆ ps â†’ has_dist.dist p center = radius
a * b < 1
c = closure_operator.mkâ‚ƒ â‡‘c c.closed _ _ _
submodule.map f (submodule.span R s) = submodule.span Râ‚‚ (â‡‘f '' s)
(list.permutations_aux2 t ts list.nil ys f).snd ++ r = (list.permutations_aux2 t ts r ys f).snd
â‡‘(euclidean_geometry.reflection s) (r â€¢ (pâ‚‚ -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) pâ‚‚)) +áµ¥ pâ‚) = -(r â€¢ (pâ‚‚ -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) pâ‚‚))) +áµ¥ pâ‚
(cauchy_power_series f c R).sum w = (2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z
linear_independent R v
is_R_or_C.abs (has_inner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
order_of (dihedral_group.r i) = n / n.gcd i.val
c â€¢ s âˆˆ nhds (c â€¢ x)
is_submonoid (f â»Â¹' s)
âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
measure_theory.null_measurable_set (f â»Â¹' t) Î¼
has_dist.dist (â‡‘(s.affine_combination p) wâ‚) (â‡‘(s.affine_combination p) wâ‚‚) * has_dist.dist (â‡‘(s.affine_combination p) wâ‚) (â‡‘(s.affine_combination p) wâ‚‚) = -s.sum (Î» (iâ‚ : Î¹), s.sum (Î» (iâ‚‚ : Î¹), (wâ‚ - wâ‚‚) iâ‚ * (wâ‚ - wâ‚‚) iâ‚‚ * (has_dist.dist (p iâ‚) (p iâ‚‚) * has_dist.dist (p iâ‚) (p iâ‚‚)))) / 2
(a * d - b * c) / (c * d) < 0 â†’ a / c < b / d
g.convergents n = g.convergents' n
category_theory.limits.has_binary_biproducts C
function.surjective f â†’ set.range f = set.univ
s.pairwise (Î» (x y : Î±), f x = f y) â†” âˆƒ (z : Î¹), âˆ€ (x : Î±), x âˆˆ s â†’ f x = z
p x
linear_order.min (padic_val_rat p q) (padic_val_rat p r) â‰¤ padic_val_rat p (q + r)
(e.adjust_to_orientation x).orientation = x
filter.tendsto (Î» (i : Î¹), convolution (Î» (x : G), (Ï† i).normed Î¼ x) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) l (nhds (g xâ‚€))
p âˆ£ fintype.card {x // âˆ€ (i : Î¹), i âˆˆ s â†’ â‡‘(mv_polynomial.eval x) (f i) = 0}
p âˆ£ ring_char R â†” p âˆ£ fintype.card R
âˆƒ (K : set Î±), is_compact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U
category_theory.is_iso (category_theory.exp_comparison F A)
finset.fold op b (Î» (i : Î±), ite (p i) (f i) (g i)) s = op (finset.fold op b f (finset.filter p s)) (finset.fold op b g (finset.filter (Î» (i : Î±), Â¬p i) s))
âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
p âˆˆ polynomial.lifts (algebra_map R S) â†” p âˆˆ (polynomial.map_alg R S).range
same_ray R x y â†’ same_ray R (-x) (-y)
(âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)) â†’ f =o[l] g
Ï€â‚.compl = Ï€â‚‚.compl
(âˆ€ {d : R}, d âˆ£ a â†’ d âˆ£ c â†’ Â¬prime d) â†’ a âˆ£ b * c â†’ a âˆ£ b
gram_schmidt ğ•œ f n â‰  0
o.oangle x y = hb.oangle x y
has_deriv_at g f'â»Â¹ a
â‡‘(algebra.norm R) (â‡‘(algebra_map R S) x) = x ^ fintype.card Î¹
ring_hom_surjective Ïƒâ‚â‚ƒ
aâ»Â¹ * a * a = a
0 â‰¤ -a â†” a â‰¤ 0
â‡‘g (finsum (Î» (j : Î±), finsum (Î» (H : j âˆˆ s), f j))) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), â‡‘g (f i)))
metric.thickening Îµ (metric.thickening Î´ s) âŠ† metric.thickening (Îµ + Î´) s
is_add_hom (Î» (a : Î±), -f a)
âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„) in a..b, g x âˆ‚Î¼
âˆƒá¶  (b : â„•) in filter.at_top, âˆƒ (a : â„¤), x â‰  â†‘a / â†‘b âˆ§ |x - â†‘a / â†‘b| < 1 / â†‘b ^ n
finprod (Î» (ab : Î± Ã— Î²), finprod (Î» (h : ab âˆˆ s), f ab)) = finprod (Î» (a : Î±), finprod (Î» (b : Î²), finprod (Î» (h : (a, b) âˆˆ s), f (a, b))))
module.is_torsion_by R â†¥(submodule.torsion_by R M a) a
(l.rotate n).nth_le ((l.length - n % l.length + k) % l.length) _ = l.nth_le k hk
metric.inf_dist x t â‰¤ metric.inf_dist x s
summable (Î» (x : Î±), |f x|) â†’ summable f
t.prod (Î» (c : Î¹), f c) âˆˆ K
â‡‘c x y â†’ â‡‘c y z â†’ â‡‘c x z
(finset.nat.antidiagonal n).card = n + 1
bdd_above (set.range f)
continuous f
has_fderiv_at f f' x â†’ has_mfderiv_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x f'
a â‰  b â†’ order.pred a â‰  order.pred b
cont_diff_at ğ•œ n â‡‘(f.symm) a
(Î» (t : R), ring.inverse (â†‘x + t) - (finset.range n).sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ n
âˆƒ (v : E) (H : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥
measurable_set s â†” âˆ€ (t : set Î±), P t â†’ â‡‘(measure_theory.induced_outer_measure m P0 m0) (t âˆ© s) + â‡‘(measure_theory.induced_outer_measure m P0 m0) (t  s) â‰¤ â‡‘(measure_theory.induced_outer_measure m P0 m0) t
hb.oangle x x = 0
s a b â†” r a b âˆ§ Â¬r b a
âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) + g (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ + âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
s âŠ† t
a + b < c â†’ b < c - a
â‡‘g (s.prod (Î» (x : Î±), f x)) = s.prod (Î» (x : Î±), â‡‘g (f x))
(list.map f (list.range n.succ)).sum = f 0 + (list.map (Î» (i : â„•), f i.succ) (list.range n)).sum
measurable (Î» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½)
â‡‘(algebra_map K E) (algebra.discr K â‡‘(pb.basis)) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * finset.univ.prod (Î» (i : fin pb.dim), (finset.filter (Î» (j : fin pb.dim), i < j) finset.univ).prod (Î» (j : fin pb.dim), (â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) * (â‡‘(â‡‘e i) pb.gen - â‡‘(â‡‘e j) pb.gen)))
1 + â†‘n * a â‰¤ (1 + a) ^ n
mul_action.fixed_points â†¥(supr P) Î± = â‹‚ (i : Î¹), mul_action.fixed_points â†¥(P i) Î±
Ï†â‚ = Ï†â‚‚
x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
â‡‘measure_theory.measure_space.volume (â‹ƒ (p : â„) (hp : 2 < p), {x : â„ | liouville_with p x}) = 0
real.cos (inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = -1
measure_theory.unif_integrable f p Î¼
category_theory.presheaf.is_sheaf J P â†” âˆ€ â¦ƒX : Câ¦„ (S : category_theory.sieve X), S âˆˆ â‡‘J X â†’ nonempty (category_theory.limits.is_limit (P.map_cone S.arrows.cocone.op))
-a â‰¤ b â†’ -b â‰¤ a
f = g
{x : E | differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K} âŠ† fderiv_measurable_aux.D f K
category_theory.indecomposable X
has_inner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
(1 * x).equiv x
S â‰¤ Î¼.outer_measure.caratheodory
c.lift (f.comp c.mk') _ = f
râ‚ = râ‚‚ â†” râ‚.rel = râ‚‚.rel
convex_independent ğ•œ (Î» (x : â†¥(set.range p)), â†‘x)
is_add_right_regular g
o.oangle x (-y) + o.oangle y (-x) = 0
uniform_continuous coe
mv_polynomial.vanishing_ideal (mv_polynomial.zero_locus I) = I.radical
âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) â‰¤ b
bdd_below (set.range f)
â‡‘Î¼ ((Î» (h : G), g * h) â»Â¹' A) = â‡‘Î¼ A
p x m = iterated_fderiv_within ğ•œ m f s x
a / b â‰¤ c
continuous (Î» (x : Î²), â‡‘Ï• (t x) (f x))
âˆƒ (y : Î²) (H : y âˆˆ t), n â‰¤ (finset.filter (Î» (x : Î±), f x = y) s).card
â‡‘(linear_map.to_matrix bM bN) (â‡‘(dual_tensor_hom R M N) (bM.coord j âŠ—â‚œ[R] â‡‘bN i)) = matrix.std_basis_matrix i j 1
complex.sin ((â†‘n + 1) * Î¸) = polynomial.eval (complex.cos Î¸) (polynomial.chebyshev.U â„‚ n) * complex.sin Î¸
(finset.univ.prod (Î» (i : Ïƒ), â‡‘polynomial.C (r i) + polynomial.X)).coeff k = (finset.powerset_len (fintype.card Ïƒ - k) finset.univ).sum (Î» (t : finset Ïƒ), t.prod (Î» (i : Ïƒ), r i))
connected_component x = â‹‚ (Z : {Z // is_clopen Z âˆ§ x âˆˆ Z}), â†‘Z
finset.centroid k {iâ‚, iâ‚‚} p = 2â»Â¹ â€¢ (p iâ‚‚ -áµ¥ p iâ‚) +áµ¥ p iâ‚
add_subgroup.closure k â‰¤ K â†” k âŠ† â†‘K
B.nondegenerate
matrix.det (Î» (i : n), M (â‡‘Ïƒ i)) = â†‘(â‡‘equiv.perm.sign Ïƒ) * M.det
hb.oangle x (r â€¢ y) = hb.oangle x (-y)
f = g
has_dist.dist (r1 â€¢ v +áµ¥ p1) (r2 â€¢ v +áµ¥ p2) * has_dist.dist (r1 â€¢ v +áµ¥ p1) (r2 â€¢ v +áµ¥ p2) = has_dist.dist p1 p2 * has_dist.dist p1 p2 + (r1 - r2) * (r1 - r2) * (âˆ¥vâˆ¥ * âˆ¥vâˆ¥)
measurable_embedding f
cardinal.mk â†¥set.univ = cardinal.continuum
(uniformity Î±).has_basis p (Î» (i : Î²), {p : Î± Ã— Î± | has_dist.dist p.fst p.snd < f i})
a * (b + c) = a * b + a * c
â†‘(m / n) â‰¤ â†‘m / â†‘n
o.oangle (r â€¢ x) x = 0
â‡‘Î¼ s â‰¤ â‡‘Î¼ t
pairwise (disjoint on Î» (n : Î±), set.Ioc (f (order.pred n)) (f n))
(s.monge_plane iâ‚ iâ‚‚).direction = (submodule.span â„ {s.points iâ‚ -áµ¥ s.points iâ‚‚})á—® âŠ“ vector_span â„ (set.range s.points)
function.injective â‡‘(add_con.ker_lift f)
s.nonempty â†’ (closure s).nonempty
finprod (Î» (ab : Î± Ã— Î²), finprod (Î» (h : ab âˆˆ s), f ab)) = finprod (Î» (a : Î±), finprod (Î» (b : Î²), finprod (Î» (h : b âˆˆ finset.image prod.snd (finset.filter (Î» (ab : Î± Ã— Î²), ab.fst = a) s)), f (a, b))))
f x = f y
s.prod (Î» (i : Î¹), g i) + s.prod (Î» (i : Î¹), h i) â‰¤ s.prod (Î» (i : Î¹), f i)
same_ray R (â‡‘f x) (â‡‘f y)
measure_theory.simple_func.integral Î¼ f = (âˆ«â» (a : Î±), ennreal.of_real (â‡‘f a) âˆ‚Î¼).to_real
affine_independent k ![pâ‚, pâ‚‚]
Â¬a < b â†’ finset.Ico a b = âˆ…
algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â‹ƒ (f : monoid_algebra R M) (H : f âˆˆ S), â†‘(f.support)) = âŠ¤
is_unit (a * â†‘u) â†” is_unit a
(has_insert.insert x s).powerset.prod (Î» (a : finset Î±), f a) = s.powerset.prod (Î» (a : finset Î±), f a) * s.powerset.prod (Î» (t : finset Î±), f (has_insert.insert x t))
âˆƒ (K : set Î±) (H : K âŠ† A), is_compact K âˆ§ â‡‘Î¼ A < â‡‘Î¼ K + Îµ
(â‹‚ (i : Î¹), Z i).nonempty
(b.to_matrix bâ‚‚.points).det â€¢ â‡‘(bâ‚‚.coords) x = â‡‘((b.to_matrix bâ‚‚.points).transpose.cramer) (â‡‘(b.coords) x)
âˆ¥â†‘mâˆ¥ â‰¤ âˆ¥mâˆ¥