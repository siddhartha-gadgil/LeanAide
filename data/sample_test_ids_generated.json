[
  {
    "theorem": "{  Œ±  :  Sort  u_1  }{  p  :  Œ±  ‚Üí  Prop  }(  h  :  ‚àÄ  (  x  :  Œ±  )  ,  p  x  )(  x  :  Œ±  ) :  p  x ",
    "ids": "",
    "generated": [
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  }[  UniformSpace  Œ±  ]{  V  :  ‚Ñï  ‚Üí  Set  Œ±   √ó   Œ±  }(  hV  :  ‚àÄ  (  n  :  ‚Ñï  )  ,  V  n   ‚àà   uniformity  Œ±  ){  u  :  ‚Ñï  ‚Üí  Œ±  }(  hu  :  CauchySeq  u  ) :  ‚àÉ  (  œÜ  :  ‚Ñï  ‚Üí  ‚Ñï  )  ,  StrictMono  œÜ   ‚àß   ‚àÄ  (  n  :  ‚Ñï  )  ,  (  u  œÜ  n   +   1  ,  u  œÜ  n  )   ‚àà   V  n ",
    "ids": "Filter.extraction_forall_of_eventually'; LT.lt.le; lt_add_one",
    "generated": [
      "CauchySeq.cauchySeq",
      "Iff.mpr; Set.singleton_subset_iff; StrictMono; Set; Eq.symm; le_total; setOf; Filter.Tendsto; uniformity; Eq.mpr; id; Filter.tendsto_atTop_atTop; Filter.Tendsto.comp; Filter.tendsto_atTop_atTop; Filter.tendsto_id",
      "Prod.exists_strictMono_tendsto; And.left; Eq.mp; cauchySeq_iff; Filter.Tendsto; Filter.tendsto_map'_iff; Filter.map; uniformity",
      "CauchySeq.comp; CauchySeq.cauchySeq; Iff.mp; StrictMono; le_total; Eq.symm; Set.range; Eq.mpr; Set.eq_univ_iff_forall; id; le_refl; refl_mem_uniformity; le_rfl; Set.range_subset_iff; Classical.choose; StrictMono.monotone; Iff.mpr; Classical.choose_spec; Set.range_subset_iff; Set.range_mono; And.left; And.right",
      "CauchySeq.cauchySeq"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_2  }{  Œ≤  :  Type  u_1  }[  Preorder  Œ±  ][  Preorder  Œ≤  ](  f  :  Œ±   ‚Ü™o   Œ≤  ){  a  :  Œ±  }{  b  :  Œ±  } :  ¬¨  ‚Üë  RelEmbedding.toEmbedding  f  b   ‚â§   ‚Üë  RelEmbedding.toEmbedding  f  a   =   ¬¨  b   ‚â§   a ",
    "ids": "congrArg; Not; RelEmbedding.map_rel_iff",
    "generated": [
      "congrArg; Not",
      "congrArg; Not; RelEmbedding.toEmbedding",
      "congrArg; Not",
      "congrArg; Not; OrderEmbedding.le_iff_le",
      "congrArg; Not"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }{  Œ≤  :  Type  u_4  }{  Œ≥  :  Type  u_3  }{  Œ¥  :  Type  u_2  }{  r  :  Œ±  ‚Üí  Œ≤  ‚Üí  Prop  }{  p  :  Œ≤  ‚Üí  Œ≥  ‚Üí  Prop  }{  q  :  Œ≥  ‚Üí  Œ¥  ‚Üí  Prop  }(  a  :  Œ±  )(  d  :  Œ¥  )(  x  :  Relation.Comp  Relation.Comp  r  p  q  a  d  ) :  ‚àÉ  (  b  :  Œ≤  )  ,  r  a  b   ‚àß   p  b  c ",
    "ids": "",
    "generated": [
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_2  }{  Œ≤  :  Type  u_3  }{  Œ≥  :  Type  u_1  }(  f  :  Part  Œ±  )(  g  :  Œ±  ‚Üí  Part  Œ≤  )(  k  :  Œ≤  ‚Üí  Part  Œ≥  )(  a  :  Œ≥  ) :  a   ‚àà   Part.bind  f  fun  (  x  :  Œ±  )  ‚Ü¶  Part.bind  g  x  k   =   ‚àÉ  (  a_1  :  Œ±  )  ,  a_1   ‚àà   f   ‚àß   a   ‚àà   Part.bind  g  a_1  k ",
    "ids": "",
    "generated": [
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "theorem": " :  ‚àÄ  {  Œ≤  :  Type  u  }  {  Œ±  :  Type  v  }  [  inst  :  AddCommMonoid  Œ≤  ]  [  inst_1  :  DecidableEq  Œ±  ]  (  s  :  Finset  Œ±  )  (  a  :  Œ±  )  (  b  :  Œ±  ‚Üí  Œ≤  )  ,  Finset.sum  s  fun  (  x  :  Œ±  )  ‚Ü¶  if  h  :  x   =   a  then  b  x  else  0   =   if  a   ‚àà   s  then  b  a  else  0 ",
    "ids": "Finset.sum_dite_eq'",
    "generated": [
      "Finset.sum_dite_eq'",
      "Finset.sum_dite_eq'",
      "Eq.mpr; id; Finset.sum; congrFun; congrArg; Eq.trans; Finset.sum_ite_eq'; Finset.sum_congr; dif_pos; rfl",
      "Classical.em; Eq.mpr; id; Finset.sum; congrFun; congrArg; if_neg; if_pos; Finset.sum_eq_zero; Finset.sum_eq_single; Finset.single; of_eq_true; dif_neg; dif_pos; Eq.trans; implies_congr; Not; dite_congr; eq_self; eq_false; eq_true; Eq.mpr_prop",
      "Finset.sum_dite_eq"
    ]
  },
  {
    "theorem": "{  œÉ‚ÇÅ  :  Type  u_1  }{  œÉ‚ÇÇ  :  Type  u_2  }{  f‚ÇÅ  :  œÉ‚ÇÅ  ‚Üí  Option  œÉ‚ÇÅ  }{  f‚ÇÇ  :  œÉ‚ÇÇ  ‚Üí  Option  œÉ‚ÇÇ  }{  tr  :  œÉ‚ÇÅ  ‚Üí  œÉ‚ÇÇ  ‚Üí  Prop  }(  H  :  Turing.Respects  f‚ÇÅ  f‚ÇÇ  tr  ){  a‚ÇÅ  :  œÉ‚ÇÅ  }{  a‚ÇÇ  :  œÉ‚ÇÇ  }(  aa  :  tr  a‚ÇÅ  a‚ÇÇ  ){  b‚ÇÅ  :  œÉ‚ÇÅ  }(  ab  :  Turing.Reaches‚ÇÅ  f‚ÇÅ  a‚ÇÅ  b‚ÇÅ  ){  c‚ÇÅ  :  œÉ‚ÇÅ  }(  ac  :  c‚ÇÅ   ‚àà   f‚ÇÅ  a‚ÇÅ  ) :  match  f‚ÇÅ  a‚ÇÅ  with  |  some  b‚ÇÅ  =>  ‚àÉ  (  b‚ÇÇ  :  œÉ‚ÇÇ  )  ,  tr  b‚ÇÅ  b‚ÇÇ   ‚àß   Turing.Reaches‚ÇÅ  f‚ÇÇ  a‚ÇÇ  b‚ÇÇ  |  none  =>  f‚ÇÇ  a‚ÇÇ   =   none   =   match  some  c‚ÇÅ  with  |  some  b‚ÇÅ  =>  ‚àÉ  (  b‚ÇÇ  :  œÉ‚ÇÇ  )  ,  tr  b‚ÇÅ  b‚ÇÇ   ‚àß   Turing.Reaches‚ÇÅ  f‚ÇÇ  a‚ÇÇ  b‚ÇÇ  |  none  =>  f‚ÇÇ  a‚ÇÇ   =   none ",
    "ids": "Turing.Reaches‚ÇÅ",
    "generated": [
      "id; Eq.symm; Turing.Reaches‚ÇÅ",
      "id; Eq.symm; Turing.Reaches‚ÇÅ",
      "id; Turing.Reaches‚ÇÅ",
      "id",
      "id; Turing.Reaches‚ÇÅ"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  }{  Œ≤  :  Type  v  }(  f  :  Œ±  ‚Üí  Option  Œ≤  )(  l  :  List  Œ±  ){  b  :  Œ≤  }(  a  :  Œ±  )(  l  :  List  Œ±  )(  IH  :  b   ‚àà   List.filterMap  f  l   ‚Üî   ‚àÉ  (  a  :  Œ±  )  ,  a   ‚àà   l   ‚àß   f  a   =   some  b  )(  b'  :  Œ≤  )(  h  :  f  a   =   some  b'  )(  h  :  f  a   =   some  b'  )(  a_1  :  Œ±  ) :  a_1   ‚àà   a   ::   l   =   a_1   =   a   ‚à®    a_1   ‚àà   l ",
    "ids": "",
    "generated": [
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "theorem": "{  M  :  Type  u_1  }[  Add  M  ]{  S  :  Set  AddSubsemigroup  M  }(  hS  :  DirectedOn  fun  (  x  :  AddSubsemigroup  M  )  (  x_1  :  AddSubsemigroup  M  )  ‚Ü¶  x   ‚â§   x_1  S  )(  x  :  M  )(  x_0  :  M  )(  x_0  :  M  ) :  x_0   ‚àà   sup‚Çõ  S   ‚Üî   ‚àÉ  (  s  :  AddSubsemigroup  M  )  ,  s   ‚àà   S   ‚àß   x_0   ‚àà   s ",
    "ids": "AddSubsemigroup.mem_sup‚Çõ_of_directed_on",
    "generated": [
      "AddSubsemigroup.mem_sup‚Çõ_of_directedOn",
      "AddSubsemigroup.mem_sup‚Çõ_of_directedOn",
      "AddSubsemigroup.mem_sup‚Çõ_of_directedOn",
      "AddSubsemigroup.mem_sup‚Çõ_of_directed_on",
      "AddSubsemigroup.mem_sup‚Çõ_of_directedOn"
    ]
  },
  {
    "theorem": "{  n  :  ‚Ñï  }(  i  :  Fin  n   +   1  )(  a  :  Fin  n  )(  b  :  Fin  n  )(  H  :  a   ‚â§   b  )(  ha  :  ‚Üë  RelEmbedding.toEmbedding  Fin.castSucc  a   <   i  ) :  if  h  :  ‚Üë  RelEmbedding.toEmbedding  Fin.castSucc  a   <   i  then  Fin.pred  i  Fin.predAbove.proof_1  a  i  h  else  Fin.castLt  i  Fin.predAbove.proof_2  a  i  h   ‚â§   if  h  :  ‚Üë  RelEmbedding.toEmbedding  Fin.castSucc  b   <   i  then  Fin.pred  i  Fin.predAbove.proof_1  b  i  h  else  Fin.castLt  i  Fin.predAbove.proof_2  b  i  h ",
    "ids": "Eq.mpr; id; Classical.em; congrFun; Fin.castLt; Fin.pred; congrArg; LE.le; le_refl; Nat.pred_le; RelEmbedding.toEmbedding; Fin.castSucc; Fin.predAbove.proof_1; Fin.predAbove.proof_2; dif_pos; dif_neg",
    "generated": [
      "Classical.em; Eq.mpr; id; Nat.le_pred_of_lt; congrFun; Fin.castLt; Fin.pred; congrArg; Fin.predAbove.proof_1; LE.le; dif_pos; dif_neg; lt_of_le_of_lt; Fin.is_lt; Eq.mp; LE.le; Fin.coe_pred",
      "Classical.em; Eq.mpr; id; Fin.castSucc_le_castSucc; add_le_add_left; congrFun; Fin.castLt; Fin.pred; RelEmbedding.toEmbedding; congrArg; LE.le; Fin.predAbove.proof_2; Fin.coe_pred; Fin.predAbove.proof_1; Fin.le_pred; le_trans; dif_pos; Nat.le_pred_of_lt",
      "Classical.em; Eq.mpr; id; Fin.castLt; Fin.pred; RelEmbedding.toEmbedding; congrFun; Fin.predAbove.proof_1; Fin.predAbove.proof_2; congrArg; LE.le; of_eq_true; dif_pos; Eq.trans; LE.le; Fin.coe_pred; Fin.castSucc; eq_true; Fin.predAbove.proof_2; dif_neg; lt_zero_iff_le",
      "Classical.em; Eq.mpr; id; Fin.castLt; Fin.pred; congrFun; RelEmbedding.toEmbedding; Fin.castSucc; LE.le.trans; congrArg; Fin.le_castSucc; Fin.predAbove.proof_1; Fin.predAbove.proof_2; LE.le; dif_pos; dif_neg; lt_irrefl; Nat.zero_le; lt_of_le_of_lt; Fin.predAbove.proof_1; LE.le.trans_lt; Eq.mp; Fin.coe_pred",
      "Classical.em; Eq.mpr; id; Fin.pred; congrArg; LE.le; Fin.predAbove.proof_3; LT.lt; Fin.castSucc_lt_castSucc_iff; dif_pos; Fin.predAbove.proof_2; dif_neg; lt_irrefl; Fin.castLt; Nat.pred_lt_pred_of_lt; Nat.pred_le; Eq.symm; RelEmbedding.toEmbedding; Fin.castSucc"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  Unique  Œ±  ]{  s  :  Finset  Œ±  }(  x  :  Œ±  ) :  x   ‚àà   s   =   x   ‚àà   s ",
    "ids": "",
    "generated": [
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "theorem": "{  a  :  ‚Ñï  }{  b  :  ‚Ñï  }{  c  :  ‚Ñï  }{  m  :  ‚Ñï  }(  hc  :  c   ‚â†   0  )(  x_0  :  ‚Ñ§  )(  x_1  :  ‚Ñ§  )(  x_0  :  ‚Ñ§  )(  x_1  :  ‚Ñ§  ) :  ¬¨  ‚Üë  c   =   0   =   True ",
    "ids": "Eq.trans; congrArg; Not; eq_false",
    "generated": [
      "Eq.trans; congrArg; Not; eq_false",
      "Eq.trans; congrArg; Not; eq_false",
      "Eq.trans; congrArg; Not; eq_false",
      "Eq.trans; congrArg; Not; eq_false",
      "Eq.trans; congrArg; Not; eq_false"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }(  arr  :  Array  Œ±  )(  l  :  List  Œ±  ) :  Array.data  arr   ++   l   =   Array.data  arr   ++   l   =   True ",
    "ids": "eq_self; Array.data",
    "generated": [
      "eq_self; Array.data",
      "eq_self; Array.data",
      "eq_self; Array.data",
      "eq_self; Array.data",
      "eq_self; Array.data"
    ]
  },
  {
    "theorem": "(  u  :  PNat.XgcdType  )(  hs  :  PNat.XgcdType.IsSpecial  u  ) :  PNat.XgcdType.y  u   =   PNat.XgcdType.y  u   ^   Nat.rawCast  1   *   Nat.rawCast  1   +   0 ",
    "ids": "PNat.XgcdType.y",
    "generated": [
      "PNat.XgcdType.y",
      "PNat.XgcdType.y",
      "PNat.XgcdType.y",
      "PNat.XgcdType.y",
      "PNat.XgcdType.y"
    ]
  },
  {
    "theorem": "{  R  :  Type  u_1  }{  M  :  Type  u_2  }[  Semiring  R  ][  AddCommMonoid  M  ][  Module  R  M  ](  x  :  Submodule  R  M  )(  x_1  :  Submodule  R  M  )(  x_2  :  Submodule  R  M  ) :  ‚Üë  x   ‚äÜ   ‚Üë  x_1  ‚Üí  ‚Üë  x   ‚äÜ   ‚Üë  x_2  ‚Üí  ‚Üë  x   ‚äÜ   ‚Üë  x_1   ‚à©   ‚Üë  x_2 ",
    "ids": "Set.subset_inter",
    "generated": [
      "Set.subset_inter",
      "Set.subset_inter",
      "Set.subset_inter",
      "Set.subset_inter",
      "Set.subset_inter"
    ]
  },
  {
    "theorem": "{  n  :  ‚Ñ§  }{  a  :  ‚Ñ§  } :  a   %   n   =   0   %   n   ‚Üî   n   ‚à£   a   =   a   %   n   =   0   %   n   ‚Üî   n   ‚à£   a ",
    "ids": "",
    "generated": [
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "theorem": "{  R  :  Type  u_1  }[  Field  R  ][  StarRing  R  ](  x  :  {  x  :  R  //  x   ‚àà   selfAdjoint  R  }  )(  y  :  {  x  :  R  //  x   ‚àà   selfAdjoint  R  }  ) :  ‚Üë  x   ‚àà   selfAdjoint  R ",
    "ids": "Subtype.prop",
    "generated": [
      "Subtype.prop",
      "Subtype.prop",
      "Subtype.prop",
      "Subtype.property",
      "Subtype.prop"
    ]
  },
  {
    "theorem": " :  ‚àÄ  {  M  :  Type  u_1  }  {  N  :  Type  u_2  }  [  inst  :  Add  M  ]  [  inst_1  :  Add  N  ]  (  s  :  AddSubsemigroup  M  )  (  t  :  AddSubsemigroup  N  )  {  a  b  :  M   √ó   N  }  ,  a   ‚àà   ‚Üë  s   √óÀ¢   ‚Üë  t  ‚Üí  b   ‚àà   ‚Üë  s   √óÀ¢   ‚Üë  t  ‚Üí  Prod.fst  a   +   b   ‚àà   ‚Üë  s   ‚àß   Prod.snd  a   +   b   ‚àà   ‚Üë  t ",
    "ids": "AddSubsemigroup.add_mem; And.right; And.left",
    "generated": [
      "AddSubsemigroup.add_mem; And.right; And.left",
      "AddSubsemigroup.add_mem; And.right; And.left",
      "AddSubsemigroup.add_mem; And.left; And.right",
      "AddSubsemigroup.add_mem; And.right; And.left",
      "AddSubsemigroup.add_mem; And.right; And.left"
    ]
  },
  {
    "theorem": "(  Œ±  :  Type  u_1  )[  ConditionallyCompleteLinearOrder  Œ±  ](  a  :  Œ±  )(  b  :  Œ±  )(  h‚ÇÅ  :  a   ‚â§   b  ) :  True  ‚Üí  a   =   a ",
    "ids": "",
    "generated": [
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  }[  TopologicalSpace  Œ±  ]{  s  :  Set  Œ±  }{  t  :  Set  Œ±  }(  H  :  IsPreconnected  s  )(  Kst  :  s   ‚äÜ   t  )(  Ktcs  :  t   ‚äÜ   closure  s  )(  u  :  Set  Œ±  )(  v  :  Set  Œ±  )(  hu  :  IsOpen  u  )(  hv  :  IsOpen  v  )(  htuv  :  t   ‚äÜ   u   ‚à™   v  )(  x  :  Set.Nonempty  t   ‚à©   u  )(  x_1  :  Set.Nonempty  t   ‚à©   v  ) :  _y   ‚àà   closure  s   ‚Üî   ‚àÄ  (  o  :  Set  Œ±  )  ,  IsOpen  o  ‚Üí  _y   ‚àà   o  ‚Üí  Set.Nonempty  o   ‚à©   s ",
    "ids": "mem_closure_iff",
    "generated": [
      "mem_closure_iff",
      "mem_closure_iff",
      "mem_closure_iff",
      "mem_closure_iff",
      "mem_closure_iff"
    ]
  },
  {
    "theorem": "{  n  :  ‚Ñï  }{  Œ±  :  Type  u_1  }(  a  :  Fin  n  ‚Üí  Œ±  )(  m‚ÇÅ  :  ‚Ñï  )(  m‚ÇÇ  :  ‚Ñï  ) :  Fin.repeat  m‚ÇÅ   +   m‚ÇÇ  a   =   Fin.append  Fin.repeat  m‚ÇÅ  a  Fin.repeat  m‚ÇÇ  a   ‚àò   ‚Üë  RelEmbedding.toEmbedding  RelIso.toRelEmbedding  Fin.cast  add_mul  m‚ÇÅ  m‚ÇÇ  n ",
    "ids": "funext; Eq.mpr; id; Fin.addCases; of_eq_true; Eq.trans; Fin.repeat; Function.Surjective.forall; Fin.append; eq_self; congr; RelEmbedding.toEmbedding; OrderIso.surjective; RelIso.toRelEmbedding; Fin.cast; congrArg; Fin.append_right; Eq.symm; Fin.append_left; add_mul; Fin.modNat.proof_1; congrFun; Fin.cast_trans; Nat.mod_mod; HMod.hMod; Fin.coe_orderIso_apply; FunLike.coe; Fin.natAdd; Fin.castAdd; Nat.add_mod; Fin.cast_refl; zero_add; HAdd.hAdd; Nat.mul_mod_left",
    "generated": [
      "Eq.mpr; id; Function.comp_apply; Fin.repeat; Fin.append; RelEmbedding.toEmbedding; RelIso.toRelEmbedding; Fin.natAdd; Fin.append_right; Fin.cast; add_mul",
      "Fin.append_left; Fin.repeat",
      "id; Eq.mpr; congrArg; Eq.trans; congrFun; Fin.append; Nat.add_mod_left; Fin.append_right; Fin.repeat; Fin.append_left; funext; RelEmbedding.toEmbedding; RelIso.toRelEmbedding; Fin.cast; add_mul; Fin.is_lt; HMod.hMod; Eq.symm",
      "funext; Eq.mpr; id; congrFun; Fin.append; congrArg; Fin.repeat; Nat.add_mod_left; Fin.append_right; Fin.append_left; Fin.repeat_add; Fin.append_left",
      "funext; of_eq_true; Eq.trans; eq_self; congrArg; Fin.append_right; Fin.repeat; congrFun; RelEmbedding.toEmbedding; RelIso.toRelEmbedding; Fin.cast; add_mul"
    ]
  },
  {
    "theorem": "{  n  :  ‚Ñï  }(  hn  :  n   ‚â†   0  )(  x  :  ‚Ñï  ) :  0   ‚â§   0   ^   n ",
    "ids": "Nat.zero_le",
    "generated": [
      "zero_le; Nat.zero_pow",
      "zero_le",
      "Nat.zero_le",
      "Nat.zero_le; Nat.pow_zero",
      "Nat.zero_le; Nat.zero_pow"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }{  Œ≤  :  Type  u_2  }{  s  :  Set  Œ±  }{  s‚ÇÅ  :  Set  Œ±  }{  t  :  Set  Œ≤  }{  t‚ÇÅ  :  Set  Œ≤  }(  h  :  Set.Nonempty  s   √óÀ¢   t  )(  h_1  :  (  (  Set.eq_empty_or_nonempty  s   √óÀ¢   t  =:  s   √óÀ¢   t   =   ‚àÖ   ‚à®    Set.Nonempty  s   √óÀ¢   t  )  =:  s   √óÀ¢   t   =   ‚àÖ   ‚à®    Set.Nonempty  s   √óÀ¢   t  )   =   (  (  Or.inr  h  =:  s   √óÀ¢   t   =   ‚àÖ   ‚à®    Set.Nonempty  s   √óÀ¢   t  )  =:  s   √óÀ¢   t   =   ‚àÖ   ‚à®    Set.Nonempty  s   √óÀ¢   t  )  ) :  s   =   s‚ÇÅ   ‚àß   t   =   t‚ÇÅ   ‚à®    False   =   s   =   s‚ÇÅ   ‚àß   t   =   t‚ÇÅ ",
    "ids": "",
    "generated": [
      "or_false",
      "or_false",
      "or_false",
      "or_false",
      "congrArg; eq_false"
    ]
  },
  {
    "theorem": "{  M  :  Type  u_1  }[  AddCommGroup  M  ](  s  :  AddSubgroup  M  ) :  Submodule.toAddSubgroup  Submodule.span  ‚Ñ§  ‚Üë  s   =   AddSubgroup.closure  ‚Üë  s ",
    "ids": "Submodule.span_int_eq_addSubgroup_closure",
    "generated": [
      "Eq.mpr; Submodule.toAddSubgroup_eq; id; AddSubgroup.closure; Submodule.span_eq; Submodule.toAddSubgroup; Submodule.span",
      "Submodule.toAddSubgroup_of_span_eq; AddSubgroup.zsmul_mem",
      "Eq.mpr; id; AddSubgroup.closure; Submodule.toAddSubgroup; Submodule.span_eq; Submodule.span",
      "Eq.mpr; id; AddSubgroup.closure; Submodule.toAddSubgroup; Submodule.span_eq; Submodule.span",
      "AddSubgroup.zsmul_span_toAddSubgroup"
    ]
  },
  {
    "theorem": "(  a  :  PUnit  ) :  a  ·∂ú   =   a  ·∂ú ",
    "ids": "rfl",
    "generated": [
      "rfl",
      "rfl",
      "",
      "rfl",
      "rfl"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  }{  L‚ÇÅ  :  List  Œ±   √ó   Bool  }{  L‚ÇÇ  :  List  Œ±   √ó   Bool  }(  h  :  FreeGroup.Red  L‚ÇÅ  L‚ÇÇ  ){  L‚ÇÇ  :  List  Œ±   √ó   Bool  }{  L‚ÇÉ  :  List  Œ±   √ó   Bool  }(  _h‚ÇÅ‚ÇÇ  :  Relation.ReflTransGen  FreeGroup.Red.Step  L‚ÇÅ  L‚ÇÇ  )(  h‚ÇÇ‚ÇÉ  :  FreeGroup.Red.Step  L‚ÇÇ  L‚ÇÉ  )(  ih  :  ‚àÉ  (  n  :  ‚Ñï  )  ,  List.length  L‚ÇÅ   =   List.length  L‚ÇÇ   +   2   *   n  )(  n  :  ‚Ñï  )(  eq  :  List.length  L‚ÇÅ   =   List.length  L‚ÇÇ   +   2   *   n  ) :  List.length  L‚ÇÅ   =   List.length  L‚ÇÉ   +   2   +   2   *   n ",
    "ids": "Eq.trans; congrFun; congrArg; HAdd.hAdd; Eq.symm; FreeGroup.Red.Step.length",
    "generated": [
      "Eq.trans; congr; congrArg; congrFun; HAdd.hAdd",
      "Eq.trans; congrArg; congrFun; List.length; HAdd.hAdd; Eq.symm; mul_add; of_eq_true; mul_one; eq_self; mul_comm",
      "Eq.trans; congrArg; congrFun; List.length; HAdd.hAdd",
      "Eq.trans; congr; congrArg; congrFun; HAdd.hAdd",
      "Eq.trans; congrArg; congr; HAdd.hAdd; Eq.symm; mul_add; mul_one; List.length"
    ]
  },
  {
    "theorem": "{  R  :  Type  u_1  }{  S  :  Type  u_2  }[  Ring  R  ][  LinearOrderedCommRing  S  ](  abv  :  AbsoluteValue  R  S  )(  x  :  ‚Ñ§  À£  )(  y  :  R  )(  h  :  x   =   1  ) :  ‚Üë  abv  1   ‚Ä¢   y   =   ‚Üë  abv  y ",
    "ids": "of_eq_true; Eq.trans; eq_self; congrFun; congrArg; one_smul",
    "generated": [
      "congrArg; one_smul",
      "Eq.mpr; of_eq_true; id; Eq.trans; eq_self; congr; one_smul; congrArg; AbsoluteValue.map_one; congrFun; AbsoluteValue.map_neg; Neg.neg; mul_one",
      "congrArg; one_smul",
      "Eq.mpr; id; one_smul",
      "congrArg; map_one; one_smul"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }{  M  :  Type  u_2  }[  One  M  ]{  s  :  Set  Œ±  }{  a  :  Œ±  }(  h  :  a   ‚àà   s  )(  f  :  Œ±  ‚Üí  M  ) :  if  a   ‚àà   s  then  f  a  else  1   =   f  a ",
    "ids": "if_pos",
    "generated": [
      "if_pos",
      "if_pos",
      "if_pos",
      "if_pos",
      "if_pos"
    ]
  },
  {
    "theorem": "{  Œπ  :  Type  u_3  }{  M  :  Type  u_2  }{  N  :  Type  u_1  }[  AddCommMonoid  M  ][  OrderedAddCommMonoid  N  ](  f  :  M  ‚Üí  N  )(  p  :  M  ‚Üí  Prop  )(  h_one  :  f  0   =   0  )(  h_mul  :  ‚àÄ  (  x  y  :  M  )  ,  p  x  ‚Üí  p  y  ‚Üí  f  x   +   y   ‚â§   f  x   +   f  y  )(  hp_mul  :  ‚àÄ  (  x  y  :  M  )  ,  p  x  ‚Üí  p  y  ‚Üí  p  x   +   y  )(  g  :  Œπ  ‚Üí  M  ){  s  :  Finset  Œπ  }(  hs  :  ‚àÄ  (  i  :  Œπ  )  ,  i   ‚àà   s  ‚Üí  p  g  i  ) :  f  Finset.sum  s  fun  (  i  :  Œπ  )  ‚Ü¶  g  i   ‚â§   Finset.sum  s  fun  (  i  :  Œπ  )  ‚Ü¶  f  g  i ",
    "ids": "Finset.eq_empty_or_nonempty; Finset.le_sum_nonempty_of_subadditive_on_pred; Eq.symm; of_eq_true; Finset.sum; Eq.trans; congrFun; congrArg; LE.le",
    "generated": [
      "id; Finset.sum_induction; Finset.sum",
      "Multiset.sum_induction_nonempty; Finset.nodup",
      "le_refl; Finset.sum",
      "Finset.sum; Multiset.map; Finset.val",
      "Trans.trans; Finset.sum_le_sum_of_subset_of_nonneg; Eq.symm; Multiset.map_map; Finset.val"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }{  Œ≤  :  Type  u_2  }(  x  :  Œ±   ‚äï   Œ≤  )(  val  :  Œ±  ) :  Sum.inl  val   ‚àà   Set.range  Sum.inl   =   ‚àÉ  (  x  :  Œ±  )  ,  x   =   val ",
    "ids": "Eq.trans; congrArg; funext; Sum.inl.injEq",
    "generated": [
      "Eq.trans; congrArg; funext; and_true; eq_self",
      "Eq.trans; congrArg; funext; Sum.inl.injEq",
      "Eq.trans; congrArg; funext; true_and; congr; Sum.inl.injEq",
      "Eq.trans; congrArg; funext; Sum.inl.injEq",
      "Eq.trans; congrArg; funext; Sum.inl.injEq"
    ]
  },
  {
    "theorem": "{  G‚ÇÅ  :  Type  u_3  }{  G‚ÇÇ  :  Type  u_2  }{  G‚ÇÉ  :  Type  u_1  }[  AddGroup  G‚ÇÅ  ][  AddGroup  G‚ÇÇ  ][  AddGroup  G‚ÇÉ  ](  f  :  G‚ÇÅ   ‚Üí+   G‚ÇÇ  )(  f_inv  :  G‚ÇÇ  ‚Üí  G‚ÇÅ  )(  hf  :  Function.RightInverse  f_inv  ‚Üë  f  )(  g  :  G‚ÇÅ   ‚Üí+   G‚ÇÉ  )(  hg  :  AddMonoidHom.ker  f   ‚â§   AddMonoidHom.ker  g  )(  x  :  G‚ÇÇ  )(  y  :  G‚ÇÇ  ) :  ‚Üë  g  f_inv  x   +   y   +   -  f_inv  x   +   f_inv  y   =   0   =   f_inv  x   +   y   +   -  f_inv  x   +   f_inv  y   ‚àà   AddMonoidHom.ker  g ",
    "ids": "id; Eq.symm; AddMonoidHom.mem_ker",
    "generated": [
      "id; AddMonoidHom.mem_ker",
      "id; Eq.symm; AddMonoidHom.mem_ker",
      "",
      "",
      "id; AddMonoidHom.mem_ker"
    ]
  },
  {
    "theorem": "{  G‚ÇÅ  :  Type  u_3  }{  G‚ÇÇ  :  Type  u_2  }{  G‚ÇÉ  :  Type  u_1  }[  AddGroup  G‚ÇÅ  ][  AddGroup  G‚ÇÇ  ][  AddGroup  G‚ÇÉ  ](  f  :  G‚ÇÅ   ‚Üí+   G‚ÇÇ  )(  f_inv  :  G‚ÇÇ  ‚Üí  G‚ÇÅ  )(  hf  :  Function.RightInverse  f_inv  ‚Üë  f  )(  g  :  G‚ÇÅ   ‚Üí+   G‚ÇÉ  )(  hg  :  AddMonoidHom.ker  f   ‚â§   AddMonoidHom.ker  g  )(  x  :  G‚ÇÇ  )(  y  :  G‚ÇÇ  ) :  Eq  ‚Üë  f  f_inv  x   +   y   =   Eq  x   +   y ",
    "ids": "congrArg",
    "generated": [
      "congrArg",
      "congrArg; congrFun",
      "congrArg",
      "congrArg",
      "congrArg"
    ]
  },
  {
    "theorem": "{  Œ≤  :  Type  u  }{  Œ±  :  Type  v  }{  s‚ÇÅ  :  Finset  Œ±  }{  s‚ÇÇ  :  Finset  Œ±  }{  f  :  Œ±  ‚Üí  Œ≤  }[  CommMonoid  Œ≤  ](  h  :  s‚ÇÅ   ‚äÜ   s‚ÇÇ  )(  hf  :  ‚àÄ  (  x  :  Œ±  )  ,  x   ‚àà   s‚ÇÇ  ‚Üí  ¬¨  x   ‚àà   s‚ÇÅ  ‚Üí  f  x   =   1  ) :  ‚àÄ  (  x  :  Œ±  )  ,  x   ‚àà   s‚ÇÇ   \\   s‚ÇÅ  ‚Üí  f  x   =   1 ",
    "ids": "Eq.mpr; id; forall_congr; Eq.trans; implies_congr",
    "generated": [
      "Iff.mpr; Finset.mem_sdiff",
      "Eq.mpr; id; forall_congr; Eq.trans; implies_congr; congrArg; Not; of_eq_true; eq_true",
      "Iff.mpr; forall_eq; Eq.mpr; id; forall_congr; implies_congr; Eq.trans; congrArg; Not",
      "Eq.mpr; id; forall_congr; Eq.trans; implies_congr; congrArg; Not; congrFun",
      "Finset.prod.proof_1"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  DivisionRing  Œ±  ](  r  :  ‚Ñö  ) :  MulOpposite.unop  ‚Üë  Rat.den  r  ‚Åª¬π   *   MulOpposite.unop  ‚Üë  Rat.num  r   =   ‚Üë  r   =   ‚Üë  Rat.den  r  ‚Åª¬π   *   MulOpposite.unop  ‚Üë  Rat.num  r   =   ‚Üë  r ",
    "ids": "id; MulOpposite.unop_natCast; Rat.den; MulOpposite.unop; Rat.num",
    "generated": [
      "id; MulOpposite.unop_intCast; MulOpposite.unop; Rat.den; Rat.num",
      "id; MulOpposite.unop_intCast; MulOpposite.unop; Rat.den; Rat.num",
      "id; MulOpposite.unop_intCast; MulOpposite.unop; Rat.den; Rat.num",
      "id; MulOpposite.unop_intCast; MulOpposite.unop; Rat.den; Rat.num",
      "id; MulOpposite.unop_intCast; MulOpposite.unop; Rat.num; Rat.den"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  LinearOrder  Œ±  ] :  ‚àÄ  (  a  :  Œ±  )  ,  max  a  a   =   a ",
    "ids": "of_eq_true; Eq.trans; forall_congr; implies_true; eq_self; congrFun; congrArg; max_self",
    "generated": [
      "max_self",
      "max_self",
      "max_self",
      "LinearOrder.max_self",
      "max_self"
    ]
  },
  {
    "theorem": " :  ‚àÄ  {  Œ±  :  Type  u_1  }  [  inst  :  LinearOrder  Œ±  ]  {  s  :  Finset  Œ±  }  {  a  :  Œ±  }  ,  Finset.max  s   =   ‚Üë  a  ‚Üí  a   ‚àà   s ",
    "ids": "Finset.induction_on; instDecidableEq; Finset.max; max_choice; Finset.mem_insert_self; Eq.symm; Finset.mem_insert_of_mem; Eq.mp; Finset.max_insert; eq_of_heq; rfl",
    "generated": [
      "Finset.mem_of_max; Eq.le",
      "Finset.max; Eq.symm; Finset.exists_eq_max'; Eq.mpr; id; Eq.mp; Finset.max_mem_iff; Finset.mem_coe; Finset.coe_max",
      "Finset.max_mem; Eq.symm",
      "Finset.mem_of_max; WithBot.coe_lt_coe",
      "Iff.mp; WithBot.coe_eq_coe; Finset.max_mem"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }{  Œ≤  :  Type  u_2  }[  Add  Œ±  ][  AddZeroClass  Œ≤  ](  f  :  AddHom  Œ±  Œ≤  )(  x  :  WithZero  Œ±  )(  y  :  WithZero  Œ±  )(  x  :  Œ±  ) :  ZeroHom.toFun  {  toFun  :=  fun  (  x  :  WithZero  Œ±  )  ‚Ü¶  Option.casesOn  x  0  ‚Üë  f  ,  map_zero'  :=  rfl  }  ‚Üë  x   +   0   =   ZeroHom.toFun  {  toFun  :=  fun  (  x  :  WithZero  Œ±  )  ‚Ü¶  Option.casesOn  x  0  ‚Üë  f  ,  map_zero'  :=  rfl  }  ‚Üë  x ",
    "ids": "add_zero; ZeroHom.toFun; rfl",
    "generated": [
      "add_zero; ZeroHom.toFun; rfl",
      "add_zero; ZeroHom.toFun; rfl",
      "add_zero; ZeroHom.toFun; rfl",
      "add_zero; ZeroHom.toFun; rfl",
      "AddMonoidHom.map_add; ZeroHom.toFun; rfl"
    ]
  },
  {
    "theorem": "{  G  :  Type  u_1  }{  H  :  Type  u_2  }[  Group  G  ][  Group  H  ]{  f  :  G  ‚Üí  H  }(  hf  :  IsGroupHom  f  ){  s  :  Set  H  }(  hs  :  IsSubgroup  s  ){  a  :  G  }{  b  :  G  }(  a_1  :  f  a   ‚àà   s  )(  a_2  :  f  b   ‚àà   s  )(  x  :  G  )(  y  :  G  ) :  IsMulHom  f ",
    "ids": "IsGroupHom.toIsMulHom",
    "generated": [
      "IsGroupHom.toIsMulHom",
      "IsGroupHom.toIsMulHom",
      "IsGroupHom.toIsMulHom",
      "IsGroupHom.toIsMulHom",
      "IsGroupHom.toIsMulHom"
    ]
  },
  {
    "theorem": "{  I  :  Type  u_3  }{  C  :  I  ‚Üí  Type  u_1  }[  (  i  :  I  )  ‚Üí  CategoryTheory.Category  C  i  ]{  A  :  Type  u_1  }[  CategoryTheory.Category  A  ](  f  :  (  i  :  I  )  ‚Üí  A   ‚•§   C  i  ){  X  :  A  }{  Y  :  A  }{  Z  :  A  }(  f_1  :  X   ‚ü∂   Y  )(  g  :  Y   ‚ü∂   Z  ) :  ‚àÄ  (  i  :  I  )  ,  Prefunctor.map  CategoryTheory.Functor.toPrefunctor  f  i  f_1   ‚â´   g   =   Prefunctor.map  CategoryTheory.Functor.toPrefunctor  f  i  f_1   ‚â´   Prefunctor.map  CategoryTheory.Functor.toPrefunctor  f  i  g ",
    "ids": "CategoryTheory.Functor.map_comp",
    "generated": [
      "CategoryTheory.Functor.map_comp",
      "CategoryTheory.Functor.map_comp",
      "CategoryTheory.Functor.map_comp",
      "Eq.symm; CategoryTheory.Functor.map_comp",
      "CategoryTheory.Functor.map_comp"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }{  a  :  Œ±  }{  b  :  Œ±  }[  MulZeroClass  Œ±  ][  Preorder  Œ±  ][  PosMulMono  Œ±  ](  ha  :  0   ‚â§   a  )(  hb  :  b   ‚â§   0  ) :  a   *   b   ‚â§   a   *   0 ",
    "ids": "mul_le_mul_of_nonneg_left",
    "generated": [
      "mul_le_mul_of_nonpos_left",
      "mul_le_mul_of_nonpos_left",
      "mul_le_mul_of_nonpos_left",
      "mul_le_mul_of_nonpos_left",
      "mul_le_mul_of_nonneg_left"
    ]
  },
  {
    "theorem": " :  Nat.zero   =   Nat.zero ",
    "ids": "rfl",
    "generated": [
      "rfl",
      "rfl",
      "rfl",
      "rfl",
      "rfl"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }{  Œ≤  :  Type  u_2  }{  l‚ÇÅ  :  List  Œ±  }{  l‚ÇÇ  :  List  Œ±  }(  h  :  l‚ÇÅ   <+:   l‚ÇÇ  )(  f  :  Œ±  ‚Üí  Option  Œ≤  )(  hd‚ÇÅ  :  Œ±  )(  tl‚ÇÅ  :  List  Œ±  )(  hl  :  ‚àÄ  {  l‚ÇÇ  :  List  Œ±  }  ,  tl‚ÇÅ   <+:   l‚ÇÇ  ‚Üí  List.filterMap  f  tl‚ÇÅ   <+:   List.filterMap  f  l‚ÇÇ  ){  l‚ÇÇ  :  List  Œ±  }(  h  :  hd‚ÇÅ   ::   tl‚ÇÅ   <+:   l‚ÇÇ  )(  hd‚ÇÇ  :  Œ±  )(  tl‚ÇÇ  :  List  Œ±  )(  h_1  :  l‚ÇÇ   =   hd‚ÇÇ   ::   tl‚ÇÇ  )(  h  :  hd‚ÇÅ   ::   tl‚ÇÅ   <+:   hd‚ÇÇ   ::   tl‚ÇÇ  ) :  hd‚ÇÅ   ::   tl‚ÇÅ   <+:   hd‚ÇÇ   ::   tl‚ÇÇ   ‚Üî   hd‚ÇÅ   =   hd‚ÇÇ   ‚àß   tl‚ÇÅ   <+:   tl‚ÇÇ ",
    "ids": "List.cons_prefix_iff",
    "generated": [
      "List.prefix_cons_inj",
      "List.prefix_cons_inj",
      "List.add_prefix",
      "List.prefix_cons_inj",
      "List.prefix_cons_inj"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }{  Œ≤  :  Type  u_2  }{  f  :  Œ±  ‚Üí  Œ≤  }{  c  :  Œ±  }[  AddCommMonoid  Œ±  ](  hf  :  Function.Periodic  f  c  )(  a  :  {  x  :  Œ±  //  x   ‚àà   AddSubmonoid.multiples  c  }  )(  x  :  Œ±  )(  val  :  Œ±  )(  property  :  val   ‚àà   AddSubmonoid.multiples  c  )(  m  :  ‚Ñï  )(  h  :  fun  (  i  :  ‚Ñï  )  ‚Ü¶  i   ‚Ä¢   c  m   =   val  )(  x_0  :  Œ±  )(  x_0  :  Œ±  ) :  x_0   +   x   =   x   +   x_0 ",
    "ids": "add_comm",
    "generated": [
      "add_comm",
      "add_comm",
      "add_comm",
      "add_comm",
      "add_comm"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  DecidableEq  Œ±  ][  Fintype  Œ±  ]{  x  :  Œ±  }{  y  :  Œ±  }{  z  :  Œ±  }(  h  :  List.Nodup  [  x  ,  y  ,  z  ]  ) :  ¬¨  x   =   y   ‚à®    x   =   z   ‚à®    False   ‚àß   ¬¨  y   =   z   ‚à®    False ",
    "ids": "Eq.mp; Eq.trans; congr; congrArg; Not",
    "generated": [
      "Eq.mp; List.Nodup.insert; List.Nodup.sublist; Iff.mp; List.nodup_cons; List.mem_cons",
      "or_false_iff; And.right",
      "Eq.mp; Eq.trans; congr; or_self; congrArg; false_or; and_false; Not",
      "or_false_iff; And.right; Eq.mp; List.Nodup.insert_on; List.nodup_singleton",
      "Or.imp_right; Eq.mp; Eq.trans; congr; congrArg; Not"
    ]
  },
  {
    "theorem": "{  R  :  Type  u  }{  M  :  Type  v  }{  M‚ÇÇ  :  Type  w  }{  M‚ÇÉ  :  Type  y  }[  CommSemiring  R  ][  AddCommMonoid  M  ][  AddCommMonoid  M‚ÇÇ  ][  AddCommMonoid  M‚ÇÉ  ][  Module  R  M  ][  Module  R  M‚ÇÇ  ][  Module  R  M‚ÇÉ  ] :  ‚àÄ  (  x  :  R  )  (  x_1  :  M  )  ,  AddHom.toFun  {  toFun  :=  fun  (  x  :  M  )  ‚Ü¶  LinearMap.vecEmpty  ,  map_add'  :=  fun  (  x  :  M  )  ‚Ü¶  (  _  :  ‚àÄ  (  x_2  :  M  )  ,  fun  (  x  :  M  )  ‚Ü¶  LinearMap.vecEmpty  x   +   x_2   =   fun  (  x  :  M  )  ‚Ü¶  LinearMap.vecEmpty  x   +   fun  (  x  :  M  )  ‚Ü¶  LinearMap.vecEmpty  x_2  )  }  x   ‚Ä¢   x_1   =   ‚Üë  RingHom.id  R  x   ‚Ä¢   AddHom.toFun  {  toFun  :=  fun  (  x  :  M  )  ‚Ü¶  LinearMap.vecEmpty  ,  map_add'  :=  fun  (  x  :  M  )  ‚Ü¶  (  _  :  ‚àÄ  (  x_2  :  M  )  ,  fun  (  x  :  M  )  ‚Ü¶  LinearMap.vecEmpty  x   +   x_2   =   fun  (  x  :  M  )  ‚Ü¶  LinearMap.vecEmpty  x   +   fun  (  x  :  M  )  ‚Ü¶  LinearMap.vecEmpty  x_2  )  }  x_1 ",
    "ids": "LinearMap.vecEmpty‚ÇÇ.proof_3",
    "generated": [
      "LinearMap.vecEmptyHom.proof_2",
      "LinearEquiv.idEmpty.proof_3",
      "LinearMap.id.proof_2",
      "LinearMap.id.proof_2",
      "LinearMap.vecEmptyHom.proof_3"
    ]
  },
  {
    "theorem": "{  p  :  ‚Ñï  }(  pp  :  Nat.Prime  p  )(  k  :  ‚Ñï  ){  x  :  ‚Ñï  }(  a  :  ‚Ñï  )(  h  :  a   <   k   ‚àß   x   =   p   ^   a  )(  h_left  :  a   <   k  )(  right  :  x   =   p   ^   a  ) :  a   ‚â§   k   ‚àß   p   ^   a   =   p   ^   a   ‚àß   a   <   k   =   True   ‚àß   True ",
    "ids": "congr; Eq.trans; congrArg; and_self; of_eq_true; eq_true; eq_self",
    "generated": [
      "congr; Eq.trans; congrArg; eq_self; congrFun",
      "congr; Eq.trans; congrArg; eq_true",
      "congr; Eq.trans; congrArg; and_self; eq_true",
      "congr; Eq.trans; congrArg; and_self; eq_true",
      "congr; Eq.trans; congrArg; eq_true"
    ]
  },
  {
    "theorem": "(  R  :  Type  u_2  ){  M  :  Type  u_3  }{  M‚ÇÇ  :  Type  u_1  }[  Semiring  R  ][  AddCommMonoid  M  ][  Module  R  M  ][  AddCommMonoid  M‚ÇÇ  ][  SMul  R  M‚ÇÇ  ](  f  :  M   ‚Üí+   M‚ÇÇ  )(  hf  :  Function.Surjective  ‚Üë  f  )(  smul  :  ‚àÄ  (  c  :  R  )  (  x  :  M  )  ,  ‚Üë  f  c   ‚Ä¢   x   =   c   ‚Ä¢   ‚Üë  f  x  )(  c‚ÇÅ  :  R  )(  c‚ÇÇ  :  R  )(  x  :  M‚ÇÇ  ) :  ‚àÄ  (  x_1  :  M  )  ,  ‚Üë  f  x_1   =   x  ‚Üí  c‚ÇÅ   +   c‚ÇÇ   ‚Ä¢   x   =   c‚ÇÅ   ‚Ä¢   x   +   c‚ÇÇ   ‚Ä¢   x ",
    "ids": "of_eq_true; Eq.trans; congr; eq_self; congrArg; Eq.symm; HAdd.hAdd; AddMonoidHom.map_add; add_smul",
    "generated": [
      "of_eq_true; Eq.trans; congr; eq_self; congrArg; add_smul; HAdd.hAdd; Eq.symm",
      "of_eq_true; Eq.trans; eq_self; congr; congrArg; add_smul; HAdd.hAdd; Eq.symm; congrFun; HSMul.hSMul; map_add",
      "of_eq_true; Eq.trans; forall_congr; implies_true; eq_self; congr; congrArg; add_smul; HAdd.hAdd; congrFun",
      "of_eq_true; Eq.trans; eq_self; congr; congrArg; add_smul; HAdd.hAdd; Eq.symm; congrFun",
      "congr_fun"
    ]
  },
  {
    "theorem": "{  R  :  Type  u_1  }[  Ring  R  ](  s  :  Set  Subring  R  ) :  Eq  ‚Üë  inf·µ¢  fun  (  i  :  Subring  R  )  ‚Ü¶  inf·µ¢  fun  (  h  :  i   ‚àà   s  )  ‚Ü¶  Subsemiring.toSubmonoid  Subring.toSubsemiring  i   =   Eq  Set.inter·µ¢  fun  (  x  :  Subring  R  )  ‚Ü¶  Set.inter·µ¢  fun  (  x_1  :  x   ‚àà   s  )  ‚Ü¶  ‚Üë  x ",
    "ids": "congrArg; Eq.trans; Submonoid.coe_inf·µ¢; Set.inter·µ¢; funext; Set.inter·µ¢_congr_Prop; Iff.of_eq",
    "generated": [
      "congrArg; Eq.trans; Set.binter·µ¢_eq_inter·µ¢; Set.inter·µ¢; Subring.toSubmonoid; funext; Set.inter·µ¢_congr_Prop; Iff.of_eq; Subsemiring.toSubmonoid; Subring.toSubsemiring; inf·µ¢_congr_Prop; inf·µ¢_pos; of_eq_true",
      "congrArg; Eq.trans; Set.binter·µ¢_eq_inter·µ¢; Set.inter·µ¢; Subsemiring.toSubmonoid; Subring.toSubsemiring; funext; Set.inter·µ¢_congr_Prop; Iff.of_eq",
      "congrArg; Eq.trans; Set.binter·µ¢_eq_inter·µ¢; Set.inter·µ¢; funext; Submonoid.coe_inf·µ¢; Set.inter·µ¢_congr_Prop; Iff.of_eq",
      "congrArg; Eq.trans; Set.inter·µ¢; Subring.coe_inf·µ¢; funext; Set.inter·µ¢_congr_Prop; Iff.of_eq",
      "congrArg; Eq.trans; Set.inter·µ¢; funext; Submonoid.coe_inf·µ¢; Set.inter·µ¢_congr_Prop; Iff.of_eq"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  }[  CommGroup  Œ±  ][  Preorder  Œ±  ][  CovariantClass  Œ±  Œ±  fun  (  x  :  Œ±  )  (  x_1  :  Œ±  )  ‚Ü¶  x   *   x_1  fun  (  x  :  Œ±  )  (  x_1  :  Œ±  )  ‚Ü¶  x   ‚â§   x_1  ]{  a  :  Œ±  }{  b  :  Œ±  }{  c  :  Œ±  }{  d  :  Œ±  }(  hab  :  a   ‚â§   b  )(  hcd  :  c   ‚â§   d  ) :  a   *   d  ‚Åª¬π   ‚â§   c  ‚Åª¬π   *   b   =   c   *   a   ‚â§   b   *   d ",
    "ids": "id; mul_inv_le_inv_mul_iff",
    "generated": [
      "mul_inv_le_inv_mul_iff",
      "mul_inv_le_inv_mul_iff",
      "mul_inv_le_inv_mul_iff",
      "id; mul_inv_le_inv_mul_iff",
      "mul_inv_le_inv_mul_iff"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  }{  p  :  Œ±  ‚Üí  Prop  }(  x  :  List  Œ±  )(  x  :  List  Œ±  )(  f  :  List.below  x  )(  x  :  List.below  a   ::   tail  ) :  List.All‚ÇÇ  p  a   ::   tail   ‚Üî   ‚àÄ  (  x  :  Œ±  )  ,  x   ‚àà   a   ::   tail  ‚Üí  p  x   =   List.All‚ÇÇ  p  a   ::   tail   ‚Üî   p  a   ‚àß   ‚àÄ  (  x  :  Œ±  )  ,  x   ‚àà   tail  ‚Üí  p  x ",
    "ids": "id; List.All‚ÇÇ; List.forall_mem_cons",
    "generated": [
      "id; List.All‚ÇÇ; List.mem_cons",
      "congrArg; Eq.trans; List.All‚ÇÇ; congrFun; forall_congr; implies_congr",
      "id; congrArg; List.All‚ÇÇ; forall_congr; Eq.trans; implies_congr",
      "id; List.All‚ÇÇ; List.mem_cons",
      "id; forall_congr; congrArg; List.All‚ÇÇ; Eq.trans; implies_congr; PProd.fst"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  LinearOrderedField  Œ±  ]{  Œ≤  :  Type  u_2  }[  Ring  Œ≤  ]{  abv  :  Œ≤  ‚Üí  Œ±  }[  IsAbsoluteValue  abv  ][  CauSeq.IsComplete  Œ≤  abv  ](  f  :  CauSeq  Œ≤  abv  )(  g  :  CauSeq  Œ≤  abv  ) :  Function.const  ‚Ñï  CauSeq.lim  f   *   CauSeq.lim  g   -   ‚Üë  f   *   ‚Üë  g   =   ‚Üë  CauSeq.const  abv  CauSeq.lim  f   -   f   *   g   +   ‚Üë  CauSeq.const  abv  CauSeq.lim  f   *   CauSeq.const  abv  CauSeq.lim  g   -   g   =   True ",
    "ids": "Eq.trans; eq_self; congrArg; Function.const; CauSeq.lim; congr; sub_add_sub_cancel'; Subtype.val; HAdd.hAdd; mul_sub; CauSeq.const; sub_mul",
    "generated": [
      "Eq.trans; eq_self; congr; congrArg; Subtype.val; sub_add_sub_cancel; CauSeq.const; HAdd.hAdd; CauSeq.lim; mul_comm; sub_mul",
      "Eq.trans; eq_self; congr; CauSeq.const; congrArg; CauSeq.lim; sub_add_sub_cancel; congrFun; HAdd.hAdd; add_zero; sub_mul",
      "Eq.trans; eq_self; congr; congrArg; sub_add_sub_cancel; Subtype.val; congrFun; CauSeq.const; CauSeq.lim; HAdd.hAdd; mul_sub; sub_mul",
      "Eq.trans; CauSeq.const; congr; congrArg; CauSeq.lim; sub_add_sub_cancel; HAdd.hAdd; sub_mul; congrFun; mul_sub; HMul.hMul; CauSeq.const_lim",
      "Eq.trans; eq_self; congr; congrArg; sub_mul; congrFun; CauSeq.const; CauSeq.lim; HSub.hSub; CauSeq.const_mul; mul_comm; sub_add; HAdd.hAdd; neg_mul; CauSeq.const_inv; CauSeq.const_mul"
    ]
  },
  {
    "theorem": "{  C  :  Type  u  }[  CategoryTheory.Category  C  ]{  X  :  C  }(  f  :  X   ‚ü∂   X  )(  w  :  ‚àÄ  {  Y  :  C  }  (  g  :  Y   ‚ü∂   X  )  ,  g   ‚â´   f   =   g  ) :  f   =   ùüô  X   =   ùüô  X   ‚â´   f   =   ùüô  X ",
    "ids": "of_eq_true; Eq.trans; eq_self; congrArg; CategoryTheory.Category.id_comp",
    "generated": [
      "id; Eq.symm; CategoryTheory.Category.id_comp",
      "id; Eq.symm; CategoryTheory.cancel_mono",
      "id; Eq.symm; CategoryTheory.Category.id_comp",
      "Eq.symm; CategoryTheory.cancel_mono",
      "id; Eq.symm; CategoryTheory.Category.id_comp"
    ]
  },
  {
    "theorem": "{  n  :  ‚Ñï  }(  i  :  Fin  n   +   1  ) :  ‚Üë  Fin.last  n   -   ‚Üë  i   =   ‚Üë  ‚Üë  Fin.rev  i   =   ‚Üë  Fin.last  n   -   ‚Üë  i   =   ‚Üë  ‚Üë  Fin.rev  i ",
    "ids": "Fin.rev; Fin.last",
    "generated": [
      "Fin.rev; Fin.last",
      "Fin.rev; Fin.last",
      "Fin.last; Fin.rev",
      "Fin.last; Fin.rev",
      "Fin.rev; Fin.last"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  }{  Œ≤  :  Type  v  }{  Œ≥  :  Type  x  }[  AddCommMonoid  Œ≤  ](  f  :  Œ±  ‚Üí  Œ≥  )(  s  :  Finset  Œ≥  )(  hf  :  Set.InjOn  f  f   ‚Åª¬π'   ‚Üë  s  )(  g  :  Œ≥  ‚Üí  Œ≤  )(  hg  :  ‚àÄ  (  x  :  Œ≥  )  ,  x   ‚àà   s  ‚Üí  ¬¨  x   ‚àà   Set.range  f  ‚Üí  g  x   =   0  )(  x  :  Œ≥  )(  hx  :  x   ‚àà   s  ) :  ¬¨  x   ‚àà   Set.range  f  ‚Üí  g  x   =   0 ",
    "ids": "",
    "generated": [
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "theorem": "(  a  :  ‚Ñï  )(  b  :  ‚Ñï  )(  b  :  ‚Ñï  )(  f  :  Nat.below  (  motive  :=  fun  (  b  :  ‚Ñï  )  ‚Ü¶  ‚àÄ  (  a  :  ‚Ñï  )  ,  a   <<<   b   =   a   *   2   ^   b  )  b  )(  a  :  ‚Ñï  )(  x  :  Nat.below  (  motive  :=  fun  (  b  :  ‚Ñï  )  ‚Ü¶  ‚àÄ  (  a  :  ‚Ñï  )  ,  a   <<<   b   =   a   *   2   ^   b  )  Nat.succ  z  ) :  2   *   a   *   2   ^   z   =   a   *   2   ^   z   *   2   =   True ",
    "ids": "Eq.trans; eq_self; congr; congrArg; HMul.hMul; Nat.mul_comm; congrFun; Nat.mul_assoc",
    "generated": [
      "Eq.trans; eq_self; congr; congrArg; mul_one; HMul.hMul; congrFun; pow_one; HPow.hPow",
      "Eq.trans; eq_self; congr; congrArg; mul_one; HMul.hMul",
      "Eq.trans; eq_self; congr; congrArg; mul_one; mul_right_comm; HMul.hMul; pow_zero",
      "Eq.trans; eq_self; congr; congrArg; mul_one; HMul.hMul",
      "eq_self"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  }(  x  :  List  Œ±  )(  x_1  :  List  Œ±  )(  x_2  :  List.Sublist  x  x_1  )(  x_3  :  List.length  x   =   List.length  x_1  )(  x  :  List  Œ±  )(  f  :  List.below  (  motive  :=  fun  (  x  :  List  Œ±  )  ‚Ü¶  ‚àÄ  (  x_4  :  List  Œ±  )  ,  List.Sublist  x  x_4  ‚Üí  List.length  x   =   List.length  x_4  ‚Üí  x   =   x_4  )  x  )(  x_4  :  List  Œ±  )(  x_5  :  List.Sublist  x  x_4  )(  x_6  :  List.length  x   =   List.length  x_4  )(  x_7  :  List.below  (  motive  :=  fun  (  x  :  List  Œ±  )  ‚Ü¶  ‚àÄ  (  x_7  :  List  Œ±  )  ,  List.Sublist  x  x_7  ‚Üí  List.length  x   =   List.length  x_7  ‚Üí  x   =   x_7  )  x  )(  t  :  False  ) :  List.length  l‚ÇÇ   <   Nat.succ  List.length  l‚ÇÇ ",
    "ids": "Nat.lt_succ_self; List.length",
    "generated": [
      "Nat.lt_succ_self; List.length",
      "Nat.lt_succ_self; List.length",
      "Nat.lt_succ_self; List.length",
      "Nat.lt_succ_self; List.length",
      "Nat.lt_succ_self; List.length"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  GeneralizedBooleanAlgebra  Œ±  ][  DecidableRel  Disjoint  ][  DecidableRel  fun  (  x  :  Œ±  )  (  x_1  :  Œ±  )  ‚Ü¶  x   ‚â§   x_1  ](  u  :  Œ±  )(  v  :  Œ±  )(  a  :  Œ±  )(  h  :  ¬¨  Disjoint  u  a   ‚àß   v   ‚â§   a  ) :  ¬¨  Disjoint  u  a   ‚àß   v   ‚â§   a  ‚Üí  if  Disjoint  u  a   ‚àß   v   ‚â§   a  then  a   ‚äî   u   \\   v  else  a   =   a ",
    "ids": "if_neg",
    "generated": [
      "if_neg",
      "if_neg",
      "if_neg",
      "if_neg",
      "if_neg"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  LinearOrderedRing  Œ±  ](  x  :  Œ±  )(  y  :  Œ±  )(  h  :  x   =   0   ‚à®    0   <   x  )(  hx  :  0   <   x  )(  h  :  y   =   0   ‚à®    0   <   y  ) :  ‚Üë  SignType.sign  x   *   y   =   ‚Üë  SignType.sign  x   *   ‚Üë  SignType.sign  y ",
    "ids": "of_eq_true; Eq.trans; eq_self; congr; congrArg; sign_pos; mul_one; sign_zero; HMul.hMul; SignType.sign; eq_true",
    "generated": [
      "of_eq_true; Eq.symm; Eq.trans; eq_self; congrFun; congrArg; SignType.cast; neg_mul; SignType.sign; Neg.neg; mul_neg",
      "Eq.symm; Eq.mpr; id; SignType.cast_mul; SignType.sign; mul_pos",
      "of_eq_true; Eq.symm; Eq.trans; congr; eq_self; congrArg; SignType.cast; mul_one; SignType.sign; Neg.neg; mul_neg; mul_add; HAdd.hAdd; Nat.cast_mul",
      "of_eq_true; Eq.symm; Eq.trans; congr; eq_self; congrArg; mul_one; neg_mul; SignType.cast_neg; Neg.neg; mul_neg; SignType.cast; neg_mul; Nat.cast_zero; Nat.cast; mul_pos; SignType.sign; Nat.cast_mul",
      "of_eq_true; Eq.symm; Eq.trans; eq_self; congr; mul_one; congrArg; SignType.cast; neg_mul; Neg.neg; mul_neg; neg_mul; Nat.cast_mul"
    ]
  },
  {
    "theorem": "{  Œπ  :  Type  u_1  }{  Œ±  :  Type  u_2  }[  CanonicallyOrderedAddMonoid  Œ±  ][  LocallyFiniteOrder  Œ±  ](  f  :  Œπ   ‚Üí‚ÇÄ   Œ±  ) :  ‚àÄ  (  x  :  Œπ  )  ,  x   ‚àà   Finsupp.support  ‚ä•   ‚à™   Finsupp.support  f  ‚Üí  Finset.card  Finset.Icc  ‚Üë  ‚ä•  x  ‚Üë  f  x   =   Finset.card  Finset.Icc  ‚Üë  ‚ä•  x  ‚Üë  f  x ",
    "ids": "Finset.card; Finset.Icc",
    "generated": [
      "Finset.card; Finset.Icc",
      "Finset.card; Finset.Icc",
      "Finset.card; Finset.Icc",
      "Finset.card; Finset.Icc",
      "Finset.card; Finset.Icc"
    ]
  },
  {
    "theorem": " :  ‚àÄ  {  G  :  Type  u_1  }  [  inst  :  AddGroup  G  ]  {  N  :  Type  u_2  }  [  inst_1  :  AddGroup  N  ]  {  H‚ÇÅ  K‚ÇÅ  :  AddSubgroup  G  }  {  H‚ÇÇ  K‚ÇÇ  :  AddSubgroup  N  }  [  h‚ÇÅ  :  AddSubgroup.Normal  AddSubgroup.addSubgroupOf  H‚ÇÅ  K‚ÇÅ  ]  [  h‚ÇÇ  :  AddSubgroup.Normal  AddSubgroup.addSubgroupOf  H‚ÇÇ  K‚ÇÇ  ]  ,  AddSubgroup.Normal  AddSubgroup.addSubgroupOf  AddSubgroup.prod  H‚ÇÅ  H‚ÇÇ  AddSubgroup.prod  K‚ÇÅ  K‚ÇÇ ",
    "ids": "AddSubgroup.sum_addSubgroupOf_sum_normal.proof_1",
    "generated": [
      "AddSubgroup.Normal.conj_mem; And.left; And.right; Iff.mp; AddSubgroup.mem_prod; Subtype.property",
      "AddSubgroup.Normal.conj_mem; And.left; And.right; Prod.fst; Prod.snd; Iff.mp; Subtype.property",
      "AddSubgroup.normal_addSubgroupOf_prod.proof_1",
      "AddSubgroup.normal_addSubgroupOf_prod.proof_1",
      "AddSubgroup.Normal.conj_mem; And.right; And.left; Iff.mp; AddSubgroup.mem_prod; Subtype.property"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  DecidableEq  Œ±  ](  a  :  Œ±  )(  x  :  List  Œ±  )(  x  :  List  Œ±  )(  f  :  List.below  x  )(  x  :  List.below  b   ::   l  ) :  ¬¨  b   =   a   =   ¬¨  False ",
    "ids": "congrArg; Not; eq_false; Ne.symm",
    "generated": [
      "congrArg; Not; eq_false",
      "congrArg; Not; eq_false",
      "congrArg; Not; eq_false",
      "congrArg; Not; eq_false",
      "congrArg; Not; eq_false"
    ]
  },
  {
    "theorem": "{  M  :  Type  u_1  }{  N  :  Type  u_2  }{  P  :  Type  u_3  }[  AddZeroClass  M  ][  AddCommMonoid  N  ][  AddCommMonoid  P  ](  g  :  N   ‚Üí+   P  )(  f‚ÇÅ  :  M   ‚Üí+   N  )(  f‚ÇÇ  :  M   ‚Üí+   N  )(  x  :  M  ) :  ‚Üë  g  ‚Üë  f‚ÇÅ  x   +   ‚Üë  g  ‚Üë  f‚ÇÇ  x   =   ‚Üë  g  ‚Üë  f‚ÇÅ  x   +   ‚Üë  g  ‚Üë  f‚ÇÇ  x   =   True ",
    "ids": "eq_self",
    "generated": [
      "eq_self",
      "eq_self",
      "eq_self",
      "eq_self",
      "eq_self"
    ]
  },
  {
    "theorem": "{  C  :  Type  u‚ÇÅ  }[  CategoryTheory.Category  C  ]{  D  :  Type  u‚ÇÇ  }[  CategoryTheory.Category  D  ](  F  :  C   ‚•§   D  )[  CategoryTheory.Full  F  ][  CategoryTheory.Faithful  F  ]{  X  :  C  }{  Y  :  C  }(  f  :  X   ‚ü∂   Y  )[  CategoryTheory.IsIso  Prefunctor.map  CategoryTheory.Functor.toPrefunctor  F  f  ] :  CategoryTheory.CategoryStruct.comp  Prefunctor.map  CategoryTheory.Functor.toPrefunctor  F  CategoryTheory.Functor.preimage  F  CategoryTheory.inv  Prefunctor.map  CategoryTheory.Functor.toPrefunctor  F  f   =   CategoryTheory.CategoryStruct.comp  CategoryTheory.inv  Prefunctor.map  CategoryTheory.Functor.toPrefunctor  F  f ",
    "ids": "congrArg; CategoryTheory.CategoryStruct.comp; CategoryTheory.Functor.image_preimage; CategoryTheory.inv; Prefunctor.map; CategoryTheory.Functor.toPrefunctor",
    "generated": [
      "congrArg; CategoryTheory.CategoryStruct.comp; CategoryTheory.Functor.image_preimage; CategoryTheory.inv",
      "congrArg; CategoryTheory.CategoryStruct.comp; CategoryTheory.Functor.image_preimage; CategoryTheory.inv",
      "congrArg; CategoryTheory.CategoryStruct.comp; CategoryTheory.Functor.image_preimage; CategoryTheory.inv",
      "congrArg; CategoryTheory.CategoryStruct.comp; CategoryTheory.Functor.image_preimage; CategoryTheory.inv",
      "congrArg; CategoryTheory.CategoryStruct.comp; Eq.trans; CategoryTheory.Functor.image_preimage; Prefunctor.map; CategoryTheory.Functor.toPrefunctor; CategoryTheory.IsIso.inv_hom_id; CategoryTheory.Functor.image_preimage"
    ]
  },
  {
    "theorem": "{  Œπ  :  Type  u_1  }{  Œ±  :  Œπ  ‚Üí  Type  u_2  }[  DecidableEq  Œπ  ][  (  i  :  Œπ  )  ‚Üí  LinearOrder  Œ±  i  ](  x  :  (  i  :  Œπ  )  ‚Üí  Œ±  i  )(  y  :  (  i  :  Œπ  )  ‚Üí  Œ±  i  )(  x'  :  (  i  :  Œπ  )  ‚Üí  Œ±  i  )(  y'  :  (  i  :  Œπ  )  ‚Üí  Œ±  i  )‚¶É  a  :  (  i  :  Œπ  )  ‚Üí  Œ±  i  ‚¶Ñ(  a_1  :  a   ‚àà   Set.Icc  x  y   \\   Set.pi  Set.univ  fun  (  i  :  Œπ  )  ‚Ü¶  Set.Ioo  x'  i  y'  i  )(  left  :  a   ‚àà   Set.Icc  x  y  )(  ha'  :  ¬¨  a   ‚àà   Set.pi  Set.univ  fun  (  i  :  Œπ  )  ‚Ü¶  Set.Ioo  x'  i  y'  i  )(  hxa  :  x   ‚â§   a  )(  hay  :  a   ‚â§   y  ) :  ‚àÉ  (  x  :  Œπ  )  ,  x'  x   <   a  x  ‚Üí  y'  x   ‚â§   a  x ",
    "ids": "Eq.mp; Eq.trans; congrArg; funext; Not; forall_congr; implies_congr",
    "generated": [
      "",
      "",
      "Eq.mp; Eq.trans; congrArg; funext; Not; eq_true",
      "LT.lt.le; And.right",
      ""
    ]
  },
  {
    "theorem": "{  R  :  Type  u  }[  InvolutiveStar  R  ]{  r  :  R  }{  s  :  R  }(  h  :  r   =   star  s  ) :  star  r   =   s ",
    "ids": "Eq.trans; congrArg; star_star",
    "generated": [
      "Eq.trans; congrArg; star_star; InvolutiveStar.toFun",
      "Eq.trans; star_star; congrArg",
      "Eq.trans; star_star; congrArg",
      "Eq.trans; congr_arg; star_star; InvolutiveStar.toFun",
      "Eq.mpr; id"
    ]
  },
  {
    "theorem": "{  Œ≤  :  Type  u  }{  Œ±  :  Type  v  }[  CommMonoid  Œ≤  ][  DecidableEq  Œ±  ](  s  :  Finset  Œ±  )(  a  :  Œ±  )(  b  :  (  x  :  Œ±  )  ‚Üí  a   =   x  ‚Üí  Œ≤  )(  h  :  a   ‚àà   s  )(  h  :  True  ) :  a   =   a   =   True ",
    "ids": "eq_self",
    "generated": [
      "eq_self",
      "eq_self",
      "eq_self",
      "eq_self",
      "eq_self"
    ]
  },
  {
    "theorem": "{  Œ±  :  Sort  u_2  }{  Œ≤  :  Sort  u_3  }{  Œ≥  :  Sort  u_1  }(  f  :  Œ±  ‚Üí  Œ≤  ‚Üí  Œ≥  )(  P  :  Prop  )[  Decidable  P  ](  a  :  P  ‚Üí  Œ±  )(  b  :  ¬¨  P  ‚Üí  Œ±  )(  c  :  P  ‚Üí  Œ≤  )(  d  :  ¬¨  P  ‚Üí  Œ≤  ) :  f  dite  P  a  b   =   f  if  h_1  :  False  then  a  Eq.mpr_prop  eq_false  h  h_1  else  b  Eq.mpr_not  eq_false  h  h_1 ",
    "ids": "congrArg; dite_congr; eq_false; Eq.mpr_not; Eq.mpr_prop",
    "generated": [
      "congrArg; dite_congr; eq_false; Eq.mpr_not; Eq.mpr_prop",
      "congrArg; dite_congr; eq_false; Eq.mpr_prop; Eq.mpr_not",
      "congrArg; dite_congr; eq_false; Eq.mpr_not; Eq.mpr_prop",
      "congrArg; dite_congr; eq_false; Eq.mpr_prop; Eq.mpr_not",
      "congrArg; dite_congr; eq_false; Eq.mpr_prop; Eq.mpr_not"
    ]
  },
  {
    "theorem": "{  Œì  :  Type  u_1  }[  Inhabited  Œì  ]{  n  :  ‚Ñï  }{  enc  :  Œì  ‚Üí  Vector  Bool  n  }(  enc0  :  enc  default   =   Vector.replicate  n  false  ) :  List.reverse  Vector.toList  enc  default   =   List.replicate  n  false   =   True ",
    "ids": "Eq.trans; eq_self; congrFun; List.replicate; congrArg; List.reverse_replicate; List.reverse; Vector.toList",
    "generated": [
      "Eq.trans; eq_self; congrFun; List.replicate; congrArg; List.reverse; Vector.toList_reverse; Vector.toList",
      "Eq.trans; eq_self; congrFun; List.replicate; congrArg; Vector.toList_reverse; List.reverse_replicate; Vector.toList",
      "Eq.trans; eq_self; congrFun; List.replicate; congrArg; List.reverse; Vector.toList; Vector.reverse_replicate; List.reverse_map; Vector.toList_reverse",
      "Eq.trans; eq_self; congrFun; List.replicate; congrArg; List.reverse_replicate; Vector.toList_reverse",
      "Eq.trans; eq_true_of_decide; congrFun; List.replicate; congrArg; Vector.toList_reverse; Vector.replicate; List.reverse"
    ]
  },
  {
    "theorem": "{  Œπ  :  Type  u_2  }{  M  :  Type  u_1  }[  CanonicallyOrderedMonoid  M  ]{  f  :  Œπ  ‚Üí  M  }{  s  :  Finset  Œπ  } :  ‚àÄ  (  x  :  Œπ  )  ,  x   ‚àà   s  ‚Üí  1   ‚â§   f  x ",
    "ids": "one_le",
    "generated": [
      "one_le",
      "one_le",
      "one_le",
      "one_le",
      "one_le"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  OrderedAddCommGroup  Œ±  ]{  s  :  Set  Œ±  }{  t  :  Set  Œ±  }(  hs  :  IsUpperSet  s  ) :  s   -   t   =   s   +   -  t ",
    "ids": "sub_eq_add_neg",
    "generated": [
      "sub_eq_add_neg",
      "sub_eq_add_neg",
      "sub_eq_add_neg",
      "sub_eq_add_neg",
      "sub_eq_add_neg"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_2  }{  Œ≤  :  Type  u_1  }(  op  :  Œ±  ‚Üí  Œ±  ‚Üí  Œ±  )[  IsCommutative  Œ±  op  ][  IsAssociative  Œ±  op  ]{  f  :  Œ≤  ‚Üí  Œ±  }{  g  :  Œ≤  ‚Üí  Œ±  }(  u‚ÇÅ  :  Œ±  )(  u‚ÇÇ  :  Œ±  )(  s  :  Multiset  Œ≤  )(  a  :  Œ≤  )(  b  :  Multiset  Œ≤  )(  h  :  Multiset.fold  op  op  u‚ÇÅ  u‚ÇÇ  Multiset.map  fun  (  x  :  Œ≤  )  ‚Ü¶  op  f  x  g  x  b   =   op  Multiset.fold  op  u‚ÇÅ  Multiset.map  f  b  Multiset.fold  op  u‚ÇÇ  Multiset.map  g  b  ) :  op  f  a  op  op  Multiset.fold  op  u‚ÇÅ  Multiset.map  f  b  g  a  Multiset.fold  op  u‚ÇÇ  Multiset.map  g  b   =   op  op  f  a  Multiset.fold  op  u‚ÇÅ  Multiset.map  f  b  op  Multiset.fold  op  u‚ÇÇ  Multiset.map  g  b  g  a   =   op  f  a  op  Multiset.fold  op  u‚ÇÅ  Multiset.map  f  b  op  g  a  Multiset.fold  op  u‚ÇÇ  Multiset.map  g  b   =   op  op  f  a  Multiset.fold  op  u‚ÇÅ  Multiset.map  f  b  op  Multiset.fold  op  u‚ÇÇ  Multiset.map  g  b  g  a ",
    "ids": "id; IsAssociative.assoc; Multiset.fold; Multiset.map",
    "generated": [
      "id; Eq.symm; Multiset.fold; Multiset.map",
      "Multiset.fold; Multiset.map",
      "Multiset.fold; Multiset.map",
      "id; Eq.symm; Multiset.map; Multiset.fold",
      "Multiset.fold; Multiset.map"
    ]
  },
  {
    "theorem": "{  M  :  Type  u_1  }[  Monoid  M  ]{  l  :  List  M  }(  hl  :  ‚àÄ  (  x  :  M  )  ,  x   ‚àà   l  ‚Üí  x   =   1  )(  i  :  M  )(  l  :  List  M  )(  hil  :  ‚àÄ  (  x  :  M  )  ,  x   ‚àà   l  ‚Üí  x   =   1  ‚Üí  List.prod  l   =   1  )(  hl  :  ‚àÄ  (  x  :  M  )  ,  x   ‚àà   i   ::   l  ‚Üí  x   =   1  ) :  i   *   1   =   1 ",
    "ids": "Eq.mpr; id; List.mem_cons_self; one_mul",
    "generated": [
      "List.mul_mem_of_mem",
      "Eq.mpr; id; List.mul_mem_cancel; List.mem_cons_of_mem",
      "And.right; Eq.mp; List.forall_mem_cons",
      "Eq.mpr; id; mul_one",
      "Eq.mpr; id; List.prod_cons; List.prod"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  NonUnitalNonAssocSemiring  Œ±  ](  s  :  Multiset  Œ±  )(  a  :  Œ±  )(  h  :  ‚àÄ  (  b  :  Œ±  )  ,  b   ‚àà   s  ‚Üí  Commute  a  b  )(  a_1  :  List  Œ±  )(  h  :  ‚àÄ  (  b  :  Œ±  )  ,  b   ‚àà   Quotient.mk  List.isSetoid  Œ±  a_1  ‚Üí  Commute  a  b  ) :  Commute  a  List.sum  a_1 ",
    "ids": "Commute.list_sum_right",
    "generated": [
      "Commute.list_sum_right",
      "Commute.list_sum_right",
      "Commute.list_sum_right",
      "Commute.list_sum_right; Commute.symm",
      "Commute.list_sum_right"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_2  }{  Œ≤  :  Type  u_3  }{  Œ≥  :  Type  u_1  }[  DecidableEq  Œ≥  ]{  f  :  Œ±  ‚Üí  Œ≤  ‚Üí  Œ≥  }{  s  :  Finset  Œ±  }{  t  :  Finset  Œ≤  } :  Iff  ¬¨  Finset.Nonempty  s   ‚àß   Finset.Nonempty  t   =   Iff  ¬¨  Finset.Nonempty  s   ‚à®    ¬¨  Finset.Nonempty  t ",
    "ids": "congrArg",
    "generated": [
      "congrArg",
      "congrArg",
      "congrArg",
      "congrArg",
      "congrArg"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  }{  Œ≤  :  Type  v  }[  PartialOrder  Œ±  ][  Preorder  Œ≤  ]{  l  :  Œ±  ‚Üí  Œ≤  }{  u  :  Œ≤  ‚Üí  Œ±  }(  gc  :  GaloisConnection  l  u  ){  l'  :  Œ±  ‚Üí  Œ≤  }{  u'  :  Œ≤  ‚Üí  Œ±  }(  gc'  :  GaloisConnection  l'  u'  )(  hl  :  ‚àÄ  (  a  :  Œ±  )  ,  l  a   =   l'  a  ){  b  :  Œ≤  } :  l'  u'  b   =   l  u'  b ",
    "ids": "Eq.symm",
    "generated": [
      "Eq.symm",
      "",
      "GaloisConnection.l_u'",
      "Eq.symm; GaloisConnection.l_u_eq_l",
      "Eq.symm"
    ]
  },
  {
    "theorem": "{  I  :  Type  u_1  }{  f  :  I  ‚Üí  Type  u_2  }[  (  i  :  I  )  ‚Üí  OrderedCommGroup  f  i  ] :  ‚àÄ  (  a  b  :  (  i  :  I  )  ‚Üí  f  i  )  ,  a   ‚â§   b  ‚Üí  b   ‚â§   a  ‚Üí  a   =   b ",
    "ids": "PartialOrder.le_antisymm",
    "generated": [
      "PartialOrder.le_antisymm",
      "PartialOrder.le_antisymm",
      "PartialOrder.le_antisymm",
      "PartialOrder.le_antisymm",
      "PartialOrder.le_antisymm"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  } :  ‚ä•  ·∂ú   =   ‚ä§ ",
    "ids": "compl_bot",
    "generated": [
      "compl_bot",
      "compl_bot",
      "compl_bot",
      "compl_bot",
      "compl_bot"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }[  StrictOrderedRing  Œ±  ](  a  :  Œ±  )(  b  :  Œ±  )(  c  :  Œ±  )(  h  :  a   <   b  )(  hc  :  0   <   c  ) :  0   <   c   *   b   -   a   =   c   *   a   <   c   *   b ",
    "ids": "Eq.trans; congrArg; LT.lt; mul_sub",
    "generated": [
      "sub_pos",
      "sub_pos",
      "sub_pos",
      "sub_pos",
      "Eq.trans; congrArg; LT.lt; sub_eq_add_neg"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u  }{  Œ≤  :  Type  v  }[  UniformSpace  Œ±  ][  SemilatticeSup  Œ≤  ]{  u  :  Œ≤  ‚Üí  Œ±  }(  h  :  CauchySeq  u  ) :  Filter.map  Prod.map  u  u  Filter.prod  Filter.atTop  Filter.atTop   =   Filter.map  Prod.map  u  u  Filter.atTop ",
    "ids": "congrArg; Filter.map; Filter.prod_atTop_atTop_eq; Prod.map",
    "generated": [
      "congrArg; Filter.map; Prod.map; Filter.prod_atTop_atTop_eq",
      "Filter.prod_atTop_atTop_eq; Filter.map; Filter.atTop; Prod.map",
      "congrArg; Filter.map; Filter.prod_atTop_atTop_eq; Prod.map",
      "congrArg; Filter.map; Filter.prod_atTop_atTop_eq; Prod.map",
      "congrArg; Filter.map; Prod.map; Filter.prod_atTop_atTop_eq"
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_2  }{  Œ≤  :  Type  u_1  }[  Preorder  Œ≤  ]{  f  :  Œ±  ‚Üí  Œ≤  }{  l  :  Filter  Œ±  }(  hf  :  Filter.Tendsto  f  l  Filter.atTop  )(  c  :  Œ≤  ) :  Filter.Eventually  fun  (  x  :  Œ≤  )  ‚Ü¶  c   ‚â§   x  Filter.atTop ",
    "ids": "Filter.eventually_ge_atTop",
    "generated": [
      "Filter.eventually_ge_atTop",
      "Filter.eventually_ge_atTop",
      "Filter.eventually_ge_atTop",
      "Filter.eventually_le_atTop",
      "Filter.eventually_ge_atTop"
    ]
  },
  {
    "theorem": "{  G  :  Type  u_1  }[  AddGroup  G  ](  s  :  Set  G  ) :  AddSubgroup.toAddSubmonoid  AddSubgroup.closure  -  s   =   AddSubmonoid.closure  -  s   ‚à™   -  -  s ",
    "ids": "AddSubgroup.closure_toAddSubmonoid",
    "generated": [
      "AddSubgroup.closure_toAddSubmonoid",
      "AddSubgroup.closure_toAddSubmonoid",
      "AddSubgroup.closure_toAddSubmonoid",
      "AddSubgroup.closure_toAddSubmonoid",
      "AddSubgroup.closure_toAddSubmonoid"
    ]
  },
  {
    "theorem": "{  n  :  ‚Ñï  }{  C  :  Fin  n   +   1  ‚Üí  Sort  u_1  }(  h0  :  C  Fin.last  n  )(  hs  :  (  i  :  Fin  n  )  ‚Üí  C  Fin.succ  i  ‚Üí  C  ‚Üë  RelEmbedding.toEmbedding  Fin.castSucc  i  )(  h  :  ¬¨  True  )(  h_1  :  n   =   n  ) :  Fin.last  n   =   Fin.last  n   =   True ",
    "ids": "eq_self; Fin.last",
    "generated": [
      "eq_self; Fin.last",
      "eq_self; Fin.last",
      "eq_self; Fin.last",
      "eq_self; Fin.last",
      "eq_self; Fin.last"
    ]
  },
  {
    "theorem": " :  ‚àÄ  {  Œ±  :  Type  u_1  }  [  inst  :  LinearOrderedAddCommGroup  Œ±  ]  ,  Nontrivial  WithTop  Œ± ",
    "ids": "Nontrivial.exists_pair_ne",
    "generated": [
      "WithTop.nontrivial",
      "WithTop.nontrivial",
      "LinearOrder.WithTop.nontrivial",
      "WithTop.Nontrivial",
      "WithTop.nontrivial"
    ]
  },
  {
    "theorem": "{  n  :  ‚Ñï  }(  i  :  Fin  Nat.succ  n  )(  a  :  Fin  n  ) :  a   ‚àà   Finset.univ   ‚àß   ‚Üë  RelEmbedding.toEmbedding  Fin.succEmbedding  n  a   =   i   =   True   ‚àß   ‚Üë  RelEmbedding.toEmbedding  Fin.succEmbedding  n  a   =   i ",
    "ids": "congrFun; congrArg; RelEmbedding.toEmbedding; Fin.succEmbedding",
    "generated": [
      "congrFun; congrArg; RelEmbedding.toEmbedding; Fin.succEmbedding",
      "congrFun; congrArg; RelEmbedding.toEmbedding; Fin.succEmbedding",
      "congrFun; congrArg; RelEmbedding.toEmbedding; Fin.succEmbedding",
      "congrFun; congrArg; RelEmbedding.toEmbedding; Fin.succEmbedding",
      "congrFun; congrArg; RelEmbedding.toEmbedding; Fin.succEmbedding"
    ]
  },
  {
    "theorem": "{  m  :  Type  u_1  ‚Üí  Type  u_2  }{  Œ±  :  Type  u_1  }{  œÅ  :  Type  u_1  }{  p  :  Œ±  ‚Üí  Prop  }{  x  :  StateT  œÅ  m  Œ±  }[  Monad  m  ][  LawfulMonad  m  ](  x_1  :  SatisfiesM  p  x  ) :  ‚àÉ  (  f  :  œÅ  ‚Üí  m  {  a  :  Œ±   √ó   œÅ  //  fun  (  x  :  Œ±   √ó   œÅ  )  ‚Ü¶  p  Prod.fst  x  a  }  )  ,  ‚àÄ  (  x_2  :  œÅ  )  ,  Subtype.val   <$>   f  x_2   =   x  x_2 ",
    "ids": "Eq.mpr; id; Eq.symm; Subtype.val; map_eq_pure_bind",
    "generated": [
      "Subtype.val",
      "",
      "",
      "Subtype.val; Prod.snd",
      ""
    ]
  },
  {
    "theorem": "{  Œ±  :  Type  u_1  }{  Œ≤  :  Type  u_2  }[  LinearOrder  Œ±  ][  TopologicalSpace  Œ±  ][  OrderTopology  Œ±  ][  LinearOrder  Œ≤  ][  TopologicalSpace  Œ≤  ][  OrderTopology  Œ≤  ]{  f  :  Œ±  ‚Üí  Œ≤  }{  s  :  Set  Œ±  }{  a  :  Œ±  }(  h_mono  :  StrictMonoOn  f  s  )(  hs  :  s   ‚àà   nhds  a  )(  hfs_l  :  ‚àÄ  (  b  :  Œ≤  )  ,  b   <   f  a  ‚Üí  ‚àÉ  (  c  :  Œ±  )  ,  c   ‚àà   s   ‚àß   f  c   ‚àà   Set.Ico  b  f  a  )(  hfs_r  :  ‚àÄ  (  b  :  Œ≤  )  ,  b   >   f  a  ‚Üí  ‚àÉ  (  c  :  Œ±  )  ,  c   ‚àà   s   ‚àß   f  c   ‚àà   Set.Ioc  f  a  b  ) :  ContinuousWithinAt  f  Set.Iic  a  a ",
    "ids": "StrictMonoOn.continuousWithinAt_left_of_exists_between; mem_nhdsWithin_of_mem_nhds",
    "generated": [
      "StrictMonoOn.continuousWithinAt_right_of_exists_between; LE.le.trans_lt; StrictMonoOn.lt_iff_lt",
      "StrictMonoOn.continuousWithinAt_right_of_closure_image_mem_nhdsWithin; Filter.univ_mem'; id; Eq.mpr; And.left; implies_congr; StrictMonoOn.lt_iff_lt; congrArg; funext; congrFun",
      "StrictMonoOn.continuousWithinAt_right_of_exists_between; LE.le.trans_lt; StrictMonoOn.lt_iff_lt",
      "StrictMonoOn.continuousWithinAt_right_of_exists_between; LE.le.trans_lt; StrictMonoOn.lt_iff_lt",
      "StrictMonoOn.continuousWithinAt_right_of_exists_between; LE.le.trans; StrictMonoOn.dual"
    ]
  }
]