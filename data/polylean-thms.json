[{"type": "∀ x : Fin 3, x + 0 = x",
  "tactic-prompt": "example  : ∀ x : Fin 3, x + 0 = x := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x : Fin 3, x + 0 = x",
  "args": ""},
 {"type": "∀ x y : Fin 3, x + y = y + x",
  "tactic-prompt":
  "example  : ∀ x y : Fin 3, x + y = y + x := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y : Fin 3, x + y = y + x",
  "args": ""},
 {"type": "∀ x y z : Fin 3, (x + y) + z = x + (y + z)",
  "tactic-prompt":
  "theorem  : ∀ x y z : Fin 3, (x + y) + z = x + (y + z) := by decide; sorry",
  "name": "Zmod3.assoc",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y z : Fin 3, (x + y) + z = x + (y + z)",
  "args": ""},
 {"type":
  "∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val",
  "tactic-prompt":
  "example  : ∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt":
  " : ∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val",
  "args": ""},
 {"type":
  "∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] : ∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g := by intro (k, q); sorry",
  "name": "product_comm",
  "kind": "theorem",
  "first-tactic": "intro (k, q)",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] : ∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g",
  "args": "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K]"},
 {"type": "(a, b) = (c, d) ↔ (a = c) ∧ (b = d)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β) : (a, b) = (c, d) ↔ (a = c) ∧ (b = d) := by apply Iff.intro; sorry",
  "name": "prod_eq",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β) : (a, b) = (c, d) ↔ (a = c) ∧ (b = d)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β)"},
 {"type":
  "MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b')",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B} : MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b') := by show (a + a' + 0, b + b') = _; sorry",
  "name": "mul",
  "kind": "theorem",
  "first-tactic": "show (a + a' + 0, b + b') = _",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B} : MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b')",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B}"},
 {"type": "(a, b) + (a', b') = (a + a', b + b')",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B) : (a, b) + (a', b') = (a + a', b + b') := by simp only [HAdd.hAdd]; sorry",
  "name": "add",
  "kind": "theorem",
  "first-tactic": "simp only [HAdd.hAdd]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B) : (a, b) + (a', b') = (a + a', b + b')",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B)"},
 {"type": "∀ {q : Q}, c 0 q = (0 : K)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c 0 q = (0 : K) := by intro q; sorry",
  "name": "leftId",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c 0 q = (0 : K)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ {q : Q}, c q 0 = (0 : K)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c q 0 = (0 : K) := by intro q; sorry",
  "name": "rightId",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c q 0 = (0 : K)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ q : Q, c q (-q) = q • (c (-q) q)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c q (-q) = q • (c (-q) q) := by intro q; sorry",
  "name": "invRel",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c q (-q) = q • (c (-q) q)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ q : Q, c (-q) q = (-q) • (c q (-q))",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c (-q) q = (-q) • (c q (-q)) := by intro q; sorry",
  "name": "invRel'",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c (-q) q = (-q) • (c q (-q))",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k := by intro ⟨⟨ka, 0⟩, rfl⟩; sorry",
  "name": "Metabelian.Kernel.mul_comm",
  "kind": "theorem",
  "first-tactic": "intro ⟨⟨ka, 0⟩, rfl⟩",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "(succ n) * (succ m) =\n          succ ((succ n) * m + n)",
  "tactic-prompt":
  "theorem (n m: Nat) : (succ n) * (succ m) =\n          succ ((succ n) * m + n) := by rfl; sorry",
  "name": "mul_succ_succ",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (succ n) * (succ m) =\n          succ ((succ n) * m + n)",
  "args": "(n m: Nat)"},
 {"type": "n * m = 0 → n = 0 ∨ m = 0",
  "tactic-prompt":
  "theorem (n m: Nat) : n * m = 0 → n = 0 ∨ m = 0 := by cases n; sorry",
  "name": "nat_domain",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n m: Nat) : n * m = 0 → n = 0 ∨ m = 0",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n)) := by rfl; sorry",
  "name": "int_mul_succ_succ",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n)",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n) := by rfl; sorry",
  "name": "int_mul_succ_negsucc",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n)",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n)) := by rfl; sorry",
  "name": "int_mul_negsucc_negsucc",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "args": "(n m: Nat)"},
 {"type": "n' * m' = 0 → n' = 0 ∨ m' = 0",
  "tactic-prompt":
  "theorem (n' m': Int) : n' * m' = 0 → n' = 0 ∨ m' = 0 := by cases n'; sorry",
  "name": "int_domain",
  "kind": "theorem",
  "first-tactic": "cases n'",
  "core-prompt": "(n' m': Int) : n' * m' = 0 → n' = 0 ∨ m' = 0",
  "args": "(n' m': Int)"},
 {"type": "gsmul (n+1) x = x + gsmul n x",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A) : gsmul (n+1) x = x + gsmul n x := by cases n; sorry",
  "name": "gsmul_succ",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A) : gsmul (n+1) x = x + gsmul n x",
  "args": "{A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A)"},
 {"type": "zhom x (n + m) = zhom x n + zhom x m",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat) : zhom x (n + m) = zhom x n + zhom x m := by induction m; sorry",
  "name": "isHom₁",
  "kind": "theorem",
  "first-tactic": "induction m",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat) : zhom x (n + m) = zhom x n + zhom x m",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat)"},
 {"type":
  "zhom x ((Int.negSucc n) + (Int.negSucc m)) = \n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n)",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat) : zhom x ((Int.negSucc n) + (Int.negSucc m)) = \n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n) := by simp [zhom]; sorry",
  "name": "isHom₂",
  "kind": "theorem",
  "first-tactic": "simp [zhom]",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat) : zhom x ((Int.negSucc n) + (Int.negSucc m)) = \n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n)",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat)"},
 {"type": "zhom x (n + m) = zhom x n + zhom x m",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ) : zhom x (n + m) = zhom x n + zhom x m := by cases m; sorry",
  "name": "zhom_is_hom",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ) : zhom x (n + m) = zhom x n + zhom x m",
  "args": "{A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ)"},
 {"type": "zhom x 1 = x",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A) : zhom x 1 = x := by simp [zhom]; sorry",
  "name": "zhom_one",
  "kind": "theorem",
  "first-tactic": "simp [zhom]",
  "core-prompt": "{A : Type}  [abg : AddCommGroup A] (x : A) : zhom x 1 = x",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)"},
 {"type": "f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1)",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1) := by intro hyp; sorry",
  "name": "unique_morphism_nat",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1)",
  "args":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g]"},
 {"type": "f 1 = g 1  → f = g",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → f = g := by intro hyp; sorry",
  "name": "unique_morphism",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → f = g",
  "args":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g]"},
 {"type": "F → A",
  "tactic-prompt":
  "def {F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A) : F → A := by apply fag.inducedMap; sorry",
  "name": "fromBasis",
  "kind": "def",
  "first-tactic": "apply fag.inducedMap",
  "core-prompt":
  "{F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A) : F → A",
  "args":
  "{F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A)"},
 {"type":
  "@AddCommGroup.Homomorphism F A _ _ \n    (@fromBasis F _ X  fag A _ f)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (@fromBasis F _ X  fag A _ f) := by apply fag.induced_hom; sorry",
  "name": "fromBasisHom",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (@fromBasis F _ X  fag A _ f)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A}"},
 {"type": "D →  F → A",
  "tactic-prompt":
  "def (F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A) : D →  F → A := by intro p; sorry",
  "name": "fromBasisFamily",
  "kind": "def",
  "first-tactic": "intro p",
  "core-prompt":
  "(F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A) : D →  F → A",
  "args":
  "(F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A)"},
 {"type":
  "@AddCommGroup.Homomorphism F A _ _ \n    ((@fromBasisFamily F _ X  fag A _ D f) p)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D} : @AddCommGroup.Homomorphism F A _ _ \n    ((@fromBasisFamily F _ X  fag A _ D f) p) := by apply fag.induced_hom; sorry",
  "name": "fromBasisFamilyHom",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D} : @AddCommGroup.Homomorphism F A _ _ \n    ((@fromBasisFamily F _ X  fag A _ D f) p)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D}"},
 {"type": "@AddCommGroup.Homomorphism F A _ _ \n    (fag.inducedMap A f)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (fag.inducedMap A f) := by apply fag.induced_hom; sorry",
  "name": "fromBasisHom'",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (fag.inducedMap A f)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A}"},
 {"type": "Decidable (f = g)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g] : Decidable (f = g) := by apply decideHomsEqual X; sorry",
  "name": "decHomsEqual",
  "kind": "instance",
  "first-tactic": "apply decideHomsEqual X",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g] : Decidable (f = g)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g]"},
 {"type":
  "∀ (x y: Fin 2), \n  (egAction' x) ∘ (egAction' y) = egAction' (x + y)",
  "tactic-prompt":
  "theorem  : ∀ (x y: Fin 2), \n  (egAction' x) ∘ (egAction' y) = egAction' (x + y) := by decide; sorry",
  "name": "egIsAction",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt":
  " : ∀ (x y: Fin 2), \n  (egAction' x) ∘ (egAction' y) = egAction' (x + y)",
  "args": ""},
 {"type":
  "(FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl)) := by apply funext; sorry",
  "name": "FreeAbelianGroup.induced_left",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G)"},
 {"type":
  "(FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr)) := by apply funext; sorry",
  "name": "FreeAbelianGroup.induced_right",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G)"},
 {"type":
  "FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A) : FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B)) := by simp [i]; sorry",
  "name": "FreeAbelianGroup.left_incl",
  "kind": "theorem",
  "first-tactic": "simp [i]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A) : FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A)"},
 {"type":
  "FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb)",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B) : FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb) := by simp [i]; sorry",
  "name": "FreeAbelianGroup.right_incl",
  "kind": "theorem",
  "first-tactic": "simp [i]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B) : FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb)",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B)"},
 {"type": "a * b = a * c → b = c",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : a * b = a * c → b = c := by intro h; sorry",
  "name": "Group.mul_left_cancel",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : a * b = a * c → b = c",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "b * a = c * a → b = c",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : b * a = c * a → b = c := by intro h; sorry",
  "name": "Group.mul_right_cancel",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : b * a = c * a → b = c",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "(1 : G)⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G] : (1 : G)⁻¹ = 1 := by have : (1 : G)⁻¹ * 1 = 1 := mul_left_inv 1; sorry",
  "name": "one_inv",
  "kind": "theorem",
  "first-tactic": "have : (1 : G)⁻¹ * 1 = 1 := mul_left_inv 1",
  "core-prompt":
  "{G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G] : (1 : G)⁻¹ = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G]"},
 {"type": "a * b = a ↔ b = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : a * b = a ↔ b = 1 := by apply Iff.intro; sorry",
  "name": "mul_left_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : a * b = a ↔ b = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "b * a = a ↔ b = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : b * a = a ↔ b = 1 := by apply Iff.intro; sorry",
  "name": "mul_right_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : b * a = a ↔ b = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "a + b = a ↔ b = 0",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : a + b = a ↔ b = 0 := by apply Iff.intro; sorry",
  "name": "add_left_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : a + b = a ↔ b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "b + a = a ↔ b = 0",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : b + a = a ↔ b = 0 := by rw [add_comm]; sorry",
  "name": "add_right_eq_cancel",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : b + a = a ↔ b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "(-0 : A) = (0 : A)",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : (-0 : A) = (0 : A) := by have : (-0 : A) + (0 : A) = (0 : A) := neg_add_self (0 : A); sorry",
  "name": "neg_zero",
  "kind": "theorem",
  "first-tactic": "have : (-0 : A) + (0 : A) = (0 : A) := neg_add_self (0 : A)",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : (-0 : A) = (0 : A)",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "ϕ 1 = 1",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] : ϕ 1 = 1 := by have : (ϕ 1) * (ϕ 1) = (ϕ 1) * 1 := by rw [← Homomorphism.mul_distrib]; sorry",
  "name": "one_image",
  "kind": "theorem",
  "first-tactic":
  "have : (ϕ 1) * (ϕ 1) = (ϕ 1) * 1 := by rw [← Homomorphism.mul_distrib]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] : ϕ 1 = 1",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]"},
 {"type": "(ϕ g)⁻¹ = ϕ g⁻¹",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G} : (ϕ g)⁻¹ = ϕ g⁻¹ := by have : ϕ g * ϕ g⁻¹ = ϕ g * (ϕ g)⁻¹ := by rw [← Homomorphism.mul_distrib]; simp; sorry",
  "name": "hom_inv",
  "kind": "theorem",
  "first-tactic":
  "have : ϕ g * ϕ g⁻¹ = ϕ g * (ϕ g)⁻¹ := by rw [← Homomorphism.mul_distrib]; simp",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G} : (ϕ g)⁻¹ = ϕ g⁻¹",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}"},
 {"type": "(ϕ g) ^ n = ϕ (g ^ n)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ} : (ϕ g) ^ n = ϕ (g ^ n) := by induction n; sorry",
  "name": "hom_pow",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ} : (ϕ g) ^ n = ϕ (g ^ n)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ}"},
 {"type": "SubNegMonoid.gsmul (↑(n) + 1) a = a + SubNegMonoid.gsmul (↑ n) a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ) : SubNegMonoid.gsmul (↑(n) + 1) a = a + SubNegMonoid.gsmul (↑ n) a := by rw [← Int.cast_ofNat]; sorry",
  "name": "SubNegMonoid.gsmul_succ'_",
  "kind": "theorem",
  "first-tactic": "rw [← Int.cast_ofNat]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ) : SubNegMonoid.gsmul (↑(n) + 1) a = a + SubNegMonoid.gsmul (↑ n) a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ)"},
 {"type": "SubNegMonoid.gsmul 1 a = a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) : SubNegMonoid.gsmul 1 a = a := by rw [← Int.ofNat_one]; sorry",
  "name": "SubNegMonoid.gsmul_one",
  "kind": "theorem",
  "first-tactic": "rw [← Int.ofNat_one]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) : SubNegMonoid.gsmul 1 a = a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A)"},
 {"type": "ϕ (0 : A) = (0 : B)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ϕ (0 : A) = (0 : B) := by have : ϕ 0 + ϕ 0 = ϕ 0 + 0 := by rw [← add_dist]; simp; sorry",
  "name": "zero_image",
  "kind": "theorem",
  "first-tactic": "have : ϕ 0 + ϕ 0 = ϕ 0 + 0 := by rw [← add_dist]; simp",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ϕ (0 : A) = (0 : B)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a : A, ϕ (-a) = -ϕ a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ϕ (-a) = -ϕ a := by intro a; sorry",
  "name": "neg_push",
  "kind": "theorem",
  "first-tactic": "intro a",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ϕ (-a) = -ϕ a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a'",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a' := by intros; sorry",
  "name": "neg_dist",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a'",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a) := by intro a n; sorry",
  "name": "hom_mul",
  "kind": "theorem",
  "first-tactic": "intro a n",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type":
  "∀ n : ℕ, ∀ a b : A, nsmul_rec n (a + b) = nsmul_rec n a + nsmul_rec n b",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℕ, ∀ a b : A, nsmul_rec n (a + b) = nsmul_rec n a + nsmul_rec n b := by intros n a b; sorry",
  "name": "nsmul_hom",
  "kind": "theorem",
  "first-tactic": "intros n a b",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℕ, ∀ a b : A, nsmul_rec n (a + b) = nsmul_rec n a + nsmul_rec n b",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type":
  "∀ n : ℤ, ∀ a b : A, gsmul_rec n (a + b) = gsmul_rec n a + gsmul_rec n b",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℤ, ∀ a b : A, gsmul_rec n (a + b) = gsmul_rec n a + gsmul_rec n b := by intros n a b; sorry",
  "name": "gsmul_hom",
  "kind": "theorem",
  "first-tactic": "intros n a b",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℤ, ∀ a b : A, gsmul_rec n (a + b) = gsmul_rec n a + gsmul_rec n b",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a a' : A, -(a + a') = -a + -a'",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, -(a + a') = -a + -a' := by intro a a'; sorry",
  "name": "neg_hom",
  "kind": "theorem",
  "first-tactic": "intro a a'",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, -(a + a') = -a + -a'",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "AddCommGroup.Isomorphism A A",
  "tactic-prompt":
  "instance {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A] : AddCommGroup.Isomorphism A A := by assumption; sorry",
  "name": "refl",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A] : AddCommGroup.Isomorphism A A",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A]"},
 {"type": "AddCommGroup.Homomorphism (action q)",
  "tactic-prompt":
  "instance (q : Q) : AddCommGroup.Homomorphism (action q) := by revert q; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "revert q",
  "core-prompt": "(q : Q) : AddCommGroup.Homomorphism (action q)",
  "args": "(q : Q)"},
 {"type": "coords (mulMonom 0 g s) x₀ = 0",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G) : coords (mulMonom 0 g s) x₀ = 0 := by induction s; sorry",
  "name": "mul_monom_zero",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G) : coords (mulMonom 0 g s) x₀ = 0",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀ := by induction s₁; sorry",
  "name": "mul_monom_dist",
  "kind": "theorem",
  "first-tactic": "induction s₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G)"},
 {"type":
  "coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G) : coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀ := by induction s₂; sorry",
  "name": "mul_dist",
  "kind": "theorem",
  "first-tactic": "induction s₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G) : coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G) : coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀ := by induction s; sorry",
  "name": "mul_monom_monom_assoc",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G) : coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀ := by induction s₂; sorry",
  "name": "mul_monom_assoc",
  "kind": "theorem",
  "first-tactic": "induction s₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G)"},
 {"type":
  "coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G) : coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀ := by induction s; sorry",
  "name": "mul_monom_add",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G) : coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G)"},
 {"type": "mul s ((0, h) :: t) ≈  mul s t",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G) : mul s ((0, h) :: t) ≈  mul s t := by induction s; sorry",
  "name": "mul_zero_cons",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G) : mul s ((0, h) :: t) ≈  mul s t",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G)"},
 {"type": "FormalSum R G → FreeModule R G → FreeModule R G",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FormalSum R G → FreeModule R G → FreeModule R G := by intro s; sorry",
  "name": "mulAux",
  "kind": "def",
  "first-tactic": "intro s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FormalSum R G → FreeModule R G → FreeModule R G",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G]"},
 {"type": "coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀ := by induction rel; sorry",
  "name": "mul_monom_invariant",
  "kind": "theorem",
  "first-tactic": "induction rel",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂)"},
 {"type": "FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t := by cases t; sorry",
  "name": "first_arg_invariant",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂)"},
 {"type": "FreeModule R G → FreeModule R G → FreeModule R G",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FreeModule R G → FreeModule R G → FreeModule R G := by let f  := fun (s : FormalSum R G) => \n    fun  (t : FreeModule R G) => mulAux  s t; sorry",
  "name": "mul",
  "kind": "def",
  "first-tactic":
  "let f  := fun (s : FormalSum R G) => \n    fun  (t : FreeModule R G) => mulAux  s t",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FreeModule R G → FreeModule R G → FreeModule R G",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G]"},
 {"type": "(ex : E) → G.bar (G.bar ex) = ex",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E} : (ex : E) → G.bar (G.bar ex) = ex := by intro ex; sorry",
  "name": "bar_involution",
  "kind": "theorem",
  "first-tactic": "intro ex",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E} : (ex : E) → G.bar (G.bar ex) = ex",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}"},
 {"type": "(EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x → (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x) := by intro h; sorry",
  "name": "term_bar_equals_init",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(term G e = x) → G.init (G.bar e) = x",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) → G.init (G.bar e) = x := by intro hyp; sorry",
  "name": "init_bar_equals_term",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) → G.init (G.bar e) = x",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G x y) : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G x y) : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G x y)"},
 {"type": "multiply (basicpath x ex h₁ h₂) exy = cons ex h₁ h₂ exy",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : multiply (basicpath x ex h₁ h₂) exy = cons ex h₁ h₂ exy := by simp[basicpath]; sorry",
  "name": "basicpath_mult",
  "kind": "theorem",
  "first-tactic": "simp[basicpath]",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : multiply (basicpath x ex h₁ h₂) exy = cons ex h₁ h₂ exy",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type":
  "inverse (cons ex h₁ h₂ exy) = multiply (inverse exy) (basicpath y (G.bar ex) h₂ (term_bar_equals_init h₁) )",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : inverse (cons ex h₁ h₂ exy) = multiply (inverse exy) (basicpath y (G.bar ex) h₂ (term_bar_equals_init h₁) ) := by rfl; sorry",
  "name": "inverse_lemma",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : inverse (cons ex h₁ h₂ exy) = multiply (inverse exy) (basicpath y (G.bar ex) h₂ (term_bar_equals_init h₁) )",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "inverse (multiply p q) = multiply s r",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (x y z : V)  (p : EdgePath G x y)  (q : EdgePath G y z)  (r : EdgePath G y x)  (s : EdgePath G z y)  (h₁ : r = inverse p)  (h₂ : s = inverse q) : inverse (multiply p q) = multiply s r := by induction p; sorry",
  "name": "inverse_mult",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (x y z : V)  (p : EdgePath G x y)  (q : EdgePath G y z)  (r : EdgePath G y x)  (s : EdgePath G z y)  (h₁ : r = inverse p)  (h₂ : s = inverse q) : inverse (multiply p q) = multiply s r",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (x y z : V)  (p : EdgePath G x y)  (q : EdgePath G y z)  (r : EdgePath G y x)  (s : EdgePath G z y)  (h₁ : r = inverse p)  (h₂ : s = inverse q)"},
 {"type": "inverse (inverse p) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p : EdgePath G x y) : inverse (inverse p) = p := by induction p; sorry",
  "name": "inverse_involution",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p : EdgePath G x y) : inverse (inverse p) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p : EdgePath G x y)"},
 {"type": "{ rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length}",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length} := by cases exy; sorry",
  "name": "reducePathAux",
  "kind": "def",
  "first-tactic": "cases exy",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length}",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "homotopy p q → homotopy q r → homotopy p r",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q → homotopy q r → homotopy p r := by intro h₁ h₂; sorry",
  "name": "homotopy_trans",
  "kind": "theorem",
  "first-tactic": "intro h₁ h₂",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q → homotopy q r → homotopy p r",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y)"},
 {"type":
  "(p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q) := by intro p q h ex h1 h2; sorry",
  "name": "homotopy_left_mult_edge",
  "kind": "theorem",
  "first-tactic": "intro p q h ex h1 h2",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "homotopy p p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y : V}  (p : EdgePath G x y) : homotopy p p := by rfl; sorry",
  "name": "homotopy_rfl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y : V}  (p : EdgePath G x y) : homotopy p p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y : V}  (p : EdgePath G x y)"},
 {"type":
  "homotopy p (multiply p (cons ey h₁ h₂ (cons ey' h₃ h₄ (single y)) ))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}   (ey ey' : E)   { x w y : V}  (p : EdgePath G x y)  (h₁ : G.init ey = y)  (h₂ : term G ey = w)  (t : G.bar ey = ey')  (h₃ : G.init ey' = w)  (h₄ : term G ey' = y) : homotopy p (multiply p (cons ey h₁ h₂ (cons ey' h₃ h₄ (single y)) )) := by induction p; sorry",
  "name": "induct_homotopy_inverse_cancel",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}   (ey ey' : E)   { x w y : V}  (p : EdgePath G x y)  (h₁ : G.init ey = y)  (h₂ : term G ey = w)  (t : G.bar ey = ey')  (h₃ : G.init ey' = w)  (h₄ : term G ey' = y) : homotopy p (multiply p (cons ey h₁ h₂ (cons ey' h₃ h₄ (single y)) ))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}   (ey ey' : E)   { x w y : V}  (p : EdgePath G x y)  (h₁ : G.init ey = y)  (h₂ : term G ey = w)  (t : G.bar ey = ey')  (h₃ : G.init ey' = w)  (h₄ : term G ey' = y)"},
 {"type":
  "homotopy p q → homotopy (multiply p (basicpath y ey h₁ h₂)) (multiply q (basicpath y ey h₁ h₂))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p q : EdgePath G x y)  (ey : E)  (h₁ : G.init ey = y)  (h₂ : term G ey = z) : homotopy p q → homotopy (multiply p (basicpath y ey h₁ h₂)) (multiply q (basicpath y ey h₁ h₂)) := by intro h; sorry",
  "name": "induct_homotopy_inverse_mult",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p q : EdgePath G x y)  (ey : E)  (h₁ : G.init ey = y)  (h₂ : term G ey = z) : homotopy p q → homotopy (multiply p (basicpath y ey h₁ h₂)) (multiply q (basicpath y ey h₁ h₂))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p q : EdgePath G x y)  (ey : E)  (h₁ : G.init ey = y)  (h₂ : term G ey = z)"},
 {"type": "homotopy p₁ p₂ → homotopy q₁ q₂",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ p₂: EdgePath G x y)  (q₁ q₂ : EdgePath G y x)  (h₁ : q₁ = inverse p₁)  (h₂ : q₂ = inverse p₂) : homotopy p₁ p₂ → homotopy q₁ q₂ := by intro h₀; sorry",
  "name": "homotopy_inverse",
  "kind": "theorem",
  "first-tactic": "intro h₀",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ p₂: EdgePath G x y)  (q₁ q₂ : EdgePath G y x)  (h₁ : q₁ = inverse p₁)  (h₂ : q₂ = inverse p₂) : homotopy p₁ p₂ → homotopy q₁ q₂",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ p₂: EdgePath G x y)  (q₁ q₂ : EdgePath G y x)  (h₁ : q₁ = inverse p₁)  (h₂ : q₂ = inverse p₂)"},
 {"type": "homotopy p₁ p₂ → homotopy (inverse p₁) (inverse p₂)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  {p₁ p₂: EdgePath G x y} : homotopy p₁ p₂ → homotopy (inverse p₁) (inverse p₂) := by apply homotopy_inverse p₁ p₂ (inverse p₁) (inverse p₂) rfl rfl; sorry",
  "name": "homotopy_inverse_quick",
  "kind": "theorem",
  "first-tactic":
  "apply homotopy_inverse p₁ p₂ (inverse p₁) (inverse p₂) rfl rfl",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  {p₁ p₂: EdgePath G x y} : homotopy p₁ p₂ → homotopy (inverse p₁) (inverse p₂)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  {p₁ p₂: EdgePath G x y}"},
 {"type": "(homotopy (multiply p₁ q) (multiply p₂ q))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p₁ p₂ : EdgePath G x y)  (q : EdgePath G y z)  (h :homotopy p₁ p₂) : (homotopy (multiply p₁ q) (multiply p₂ q)) := by have r₁ : homotopy (inverse p₁) (inverse p₂) := by apply homotopy_inverse_quick h; sorry",
  "name": "homotopy_right_mult",
  "kind": "theorem",
  "first-tactic":
  "have r₁ : homotopy (inverse p₁) (inverse p₂) := by apply homotopy_inverse_quick h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p₁ p₂ : EdgePath G x y)  (q : EdgePath G y z)  (h :homotopy p₁ p₂) : (homotopy (multiply p₁ q) (multiply p₂ q))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p₁ p₂ : EdgePath G x y)  (q : EdgePath G y z)  (h :homotopy p₁ p₂)"},
 {"type": "ht G y z →  ht G x z",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y) : ht G y z →  ht G x z := by let func: EdgePath G y z → ht G x z := by intro p ; exact htclass (multiply p₁ p); sorry",
  "name": "homotopy_left_multiplication",
  "kind": "def",
  "first-tactic":
  "let func: EdgePath G y z → ht G x z := by intro p ; exact htclass (multiply p₁ p)",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y) : ht G y z →  ht G x z",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)"},
 {"type":
  "homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z) : homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂) := by simp[htclass]; sorry",
  "name": "homotopy_left_multiplication_class",
  "kind": "theorem",
  "first-tactic": "simp[htclass]",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z) : homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z)"},
 {"type": "ht G x y → ht G y z → ht G x z",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} : ht G x y → ht G y z → ht G x z := by intro p₁ p₂; sorry",
  "name": "homotopy_multiplication",
  "kind": "def",
  "first-tactic": "intro p₁ p₂",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} : ht G x y → ht G y z → ht G x z",
  "args": "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V}"},
 {"type":
  "(r : ht G y z) → (htclass (multiply p q)) # r = (htclass p) # ((htclass q) # r)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {w x y z : V}  (p : EdgePath G w x)  (q : EdgePath G x y) : (r : ht G y z) → (htclass (multiply p q)) # r = (htclass p) # ((htclass q) # r) := by apply Quot.ind; sorry",
  "name": "homotopy_mult_path_path_assoc",
  "kind": "theorem",
  "first-tactic": "apply Quot.ind",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {w x y z : V}  (p : EdgePath G w x)  (q : EdgePath G x y) : (r : ht G y z) → (htclass (multiply p q)) # r = (htclass p) # ((htclass q) # r)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {w x y z : V}  (p : EdgePath G w x)  (q : EdgePath G x y)"},
 {"type": "(q : ht G x y) → (htclass p # q) # r = (htclass p) # (q # r)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {w x y z : V}  (p : EdgePath G w x)  (r : ht G y z) : (q : ht G x y) → (htclass p # q) # r = (htclass p) # (q # r) := by apply Quot.ind; sorry",
  "name": "homotopy_mult_path_assoc",
  "kind": "theorem",
  "first-tactic": "apply Quot.ind",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {w x y z : V}  (p : EdgePath G w x)  (r : ht G y z) : (q : ht G x y) → (htclass p # q) # r = (htclass p) # (q # r)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {w x y z : V}  (p : EdgePath G w x)  (r : ht G y z)"},
 {"type": "(a : ht G w x) → ((a # b) # c ) = (a # (b # c) )",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {w x y z : V}  (b : ht G x y)  (c : ht G y z) : (a : ht G w x) → ((a # b) # c ) = (a # (b # c) ) := by apply Quot.ind; sorry",
  "name": "homotopy_mult_assoc",
  "kind": "theorem",
  "first-tactic": "apply Quot.ind",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {w x y z : V}  (b : ht G x y)  (c : ht G y z) : (a : ht G w x) → ((a # b) # c ) = (a # (b # c) )",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {w x y z : V}  (b : ht G x y)  (c : ht G y z)"},
 {"type": "homotopy (cons ex h₁ h₂ exy) (reducePathAux ex h₁ h₂ exy)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : homotopy (cons ex h₁ h₂ exy) (reducePathAux ex h₁ h₂ exy) := by simp[homotopy]; sorry",
  "name": "homotopy_reducePathAux",
  "kind": "theorem",
  "first-tactic": "simp[homotopy]",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : homotopy (cons ex h₁ h₂ exy) (reducePathAux ex h₁ h₂ exy)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "homotopy p₁ (reducePath p₁)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y) : homotopy p₁ (reducePath p₁) := by induction p₁; sorry",
  "name": "homotopy_reducePath",
  "kind": "theorem",
  "first-tactic": "induction p₁",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y) : homotopy p₁ (reducePath p₁)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y)"},
 {"type": "((a # b) # c) = (a # ( b # c))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V}  (a b c : ht G x x) : ((a # b) # c) = (a # ( b # c)) := by let k := @homotopy_mult_assoc V E G x x x x; sorry",
  "name": "ht_mult_assoc",
  "kind": "theorem",
  "first-tactic": "let k := @homotopy_mult_assoc V E G x x x x",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V}  (a b c : ht G x x) : ((a # b) # c) = (a # ( b # c))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V}  (a b c : ht G x x)"},
 {"type": "(a₀ : ht G x x) → ht_mul.mul a₀  (@ht_one V E G x).one = a₀",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} : (a₀ : ht G x x) → ht_mul.mul a₀  (@ht_one V E G x).one = a₀ := by have  k (b : EdgePath G x x) : homotopy_multiplication (htclass b) (htclass (single x)) = (htclass b) := by \n    let l :=mult_const b ▸ homotopy_left_multiplication_class b (single x)\n    have : (htclass b) # (htclass (single x)) = homotopy_left_multiplication b (htclass (single x)) := by rfl\n    apply Eq.trans this l; sorry",
  "name": "ht_right_identity",
  "kind": "theorem",
  "first-tactic":
  "have  k (b : EdgePath G x x) : homotopy_multiplication (htclass b) (htclass (single x)) = (htclass b) := by \n    let l :=mult_const b ▸ homotopy_left_multiplication_class b (single x)\n    have : (htclass b) # (htclass (single x)) = homotopy_left_multiplication b (htclass (single x)) := by rfl\n    apply Eq.trans this l",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} : (a₀ : ht G x x) → ht_mul.mul a₀  (@ht_one V E G x).one = a₀",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V}"},
 {"type": "(a₀ : ht G x x) → ht_mul.mul (@ht_one V E G x).one a₀ = a₀",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} : (a₀ : ht G x x) → ht_mul.mul (@ht_one V E G x).one a₀ = a₀ := by have  k (b : EdgePath G x x) : homotopy_multiplication (htclass (single x)) (htclass b) = (htclass b) := by \n    have : (htclass b) # (htclass (single x)) = (htclass (multiply b (single x))) := by rfl\n    apply (mult_const b) ▸ this; sorry",
  "name": "ht_left_identity",
  "kind": "theorem",
  "first-tactic":
  "have  k (b : EdgePath G x x) : homotopy_multiplication (htclass (single x)) (htclass b) = (htclass b) := by \n    have : (htclass b) # (htclass (single x)) = (htclass (multiply b (single x))) := by rfl\n    apply (mult_const b) ▸ this",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} : (a₀ : ht G x x) → ht_mul.mul (@ht_one V E G x).one a₀ = a₀",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V}"},
 {"type": "ProofTree (x :: w)",
  "tactic-prompt":
  "def {w : Word}  (x: Letter)           (pt: ProofTree w) : ProofTree (x :: w) := by have exp : x :: w = [x] ++ w := by rfl; sorry",
  "name": "ProofTree.prepend",
  "kind": "def",
  "first-tactic": "have exp : x :: w = [x] ++ w := by rfl",
  "core-prompt":
  "{w : Word}  (x: Letter)           (pt: ProofTree w) : ProofTree (x :: w)",
  "args": "{w : Word}  (x: Letter)           (pt: ProofTree w)"},
 {"type": "ps.fst.length + 1 ≤ w.length",
  "tactic-prompt":
  "theorem {l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.fst.length + 1 ≤ w.length := by let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append; sorry",
  "name": "splitFirst",
  "kind": "theorem",
  "first-tactic":
  "let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append",
  "core-prompt":
  "{l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.fst.length + 1 ≤ w.length",
  "args": "{l: Letter} {w: Word} (ps: ProvedSplit l w)"},
 {"type": "ps.snd.length + 1 ≤ w.length",
  "tactic-prompt":
  "theorem {l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.snd.length + 1 ≤ w.length := by let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append; sorry",
  "name": "splitSecond",
  "kind": "theorem",
  "first-tactic":
  "let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append",
  "core-prompt":
  "{l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.snd.length + 1 ≤ w.length",
  "args": "{l: Letter} {w: Word} (ps: ProvedSplit l w)"},
 {"type": "(inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n) : (inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩ := by rw [ℤbasisElem]; sorry",
  "name": "induced_free_map_at",
  "kind": "theorem",
  "first-tactic": "rw [ℤbasisElem]",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n) : (inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩",
  "args":
  "{A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n)"},
 {"type": "x + z - y + x - y + z =  viafree# (x + z - y + x - y + z)",
  "tactic-prompt":
  "theorem {α : Type} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]      (x y z : α) : x + z - y + x - y + z =  viafree# (x + z - y + x - y + z) := by simp only [AddCommGroup.Homomorphism.neg_dist]; sorry",
  "name": "egViaFreeEql",
  "kind": "theorem",
  "first-tactic": "simp only [AddCommGroup.Homomorphism.neg_dist]",
  "core-prompt":
  "{α : Type} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]      (x y z : α) : x + z - y + x - y + z =  viafree# (x + z - y + x - y + z)",
  "args":
  "{α : Type} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]      (x y z : α)"},
 {"type": "x + x + y - x - y + z - x = z",
  "tactic-prompt":
  "example {x y z : ℤ} : x + x + y - x - y + z - x = z := by have p := freeGroupEq# (x + x + y - x - y + z - x); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq# (x + x + y - x - y + z - x)",
  "core-prompt": "{x y z : ℤ} : x + x + y - x - y + z - x = z",
  "args": "{x y z : ℤ}"},
 {"type": "Graph Unit Bool",
  "tactic-prompt": "example  : Graph Unit Bool := by apply Graph.mk; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Graph.mk",
  "core-prompt": " : Graph Unit Bool",
  "args": ""},
 {"type": "(EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x → (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x) := by intro h; sorry",
  "name": "lemma1",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "x⁻¹ * (x * y) = y",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x⁻¹ * (x * y) = y := by rw [← mul_assoc]; sorry",
  "name": "left_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x⁻¹ * (x * y) = y",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(1 : G)⁻¹ = (1 : G)",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (1 : G)⁻¹ = (1 : G) := by have := left_inv_cancel (1 : G) (1 : G); sorry",
  "name": "one_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (1 : G) (1 : G)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (1 : G)⁻¹ = (1 : G)",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(x⁻¹)⁻¹ = x",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x⁻¹)⁻¹ = x := by have := left_inv_cancel (x⁻¹) x; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) x",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x⁻¹)⁻¹ = x",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "x * x⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * x⁻¹ = 1 := by have := left_inv_cancel (x⁻¹) (1 : G); sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) (1 : G)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * x⁻¹ = 1",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "x * (x⁻¹ * y) = y",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * (x⁻¹ * y) = y := by have := left_inv_cancel (x⁻¹) y; sorry",
  "name": "left_cancel_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) y",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * (x⁻¹ * y) = y",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(x * y)⁻¹ = y⁻¹ * x⁻¹",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x * y)⁻¹ = y⁻¹ * x⁻¹ := by have := left_cancel_inv (x * y)⁻¹ (y⁻¹ * x⁻¹); sorry",
  "name": "prod_inv",
  "kind": "theorem",
  "first-tactic": "have := left_cancel_inv (x * y)⁻¹ (y⁻¹ * x⁻¹)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x * y)⁻¹ = y⁻¹ * x⁻¹",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G)",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : ((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G) := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : ((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G)",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "b * ((a * b)⁻¹ * a) = 1",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : b * ((a * b)⁻¹ * a) = 1 := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : b * ((a * b)⁻¹ * a) = 1",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G)",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G) := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G)",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l}",
  "tactic-prompt":
  "lemma {α : Type _}  (l : List α) : ∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l} := by induction l; sorry",
  "name": "List.aux_append",
  "kind": "lemma",
  "first-tactic": "induction l",
  "core-prompt":
  "{α : Type _}  (l : List α) : ∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l}",
  "args": "{α : Type _}  (l : List α)"},
 {"type": "l.toArray.data = l",
  "tactic-prompt":
  "theorem {A : Type _}  (l : List A) : l.toArray.data = l := by rw [toArray]; sorry",
  "name": "List.arraydata",
  "kind": "theorem",
  "first-tactic": "rw [toArray]",
  "core-prompt": "{A : Type _}  (l : List A) : l.toArray.data = l",
  "args": "{A : Type _}  (l : List A)"},
 {"type": "l.toArray.size = l.length",
  "tactic-prompt":
  "theorem {α : Type _}  (l : List α) : l.toArray.size = l.length := by rw [Array.size]; sorry",
  "name": "List.arraysize",
  "kind": "theorem",
  "first-tactic": "rw [Array.size]",
  "core-prompt": "{α : Type _}  (l : List α) : l.toArray.size = l.length",
  "args": "{α : Type _}  (l : List α)"},
 {"type": "List.length (h :: tl) = Nat.succ m → List.length tl = m",
  "tactic-prompt":
  "theorem  : List.length (h :: tl) = Nat.succ m → List.length tl = m := by intro hyp; sorry",
  "name": "List.cons_len_eq_succ",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt": " : List.length (h :: tl) = Nat.succ m → List.length tl = m",
  "args": ""},
 {"type":
  "IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos]))",
  "tactic-prompt":
  "theorem (t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas : IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos])) := by induction t; sorry",
  "name": "IndexAddTree.fold_tree_freegroup_eq",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "(t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas : IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos]))",
  "args":
  "(t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas"},
 {"type": "s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂ := by intro h; sorry",
  "name": "cons_equiv_of_equiv",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X)"},
 {"type":
  "monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat) : monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x) := by repeat (rw [monomCoeff]); sorry",
  "name": "monom_coeff_hom",
  "kind": "theorem",
  "first-tactic": "repeat (rw [monomCoeff])",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat) : monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x)",
  "args": "(X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat)"},
 {"type": "monomCoeff x₀ (0, x) = 0",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ x : X) : monomCoeff x₀ (0, x) = 0 := by rw [monomCoeff]; sorry",
  "name": "monom_coeff_at_zero",
  "kind": "theorem",
  "first-tactic": "rw [monomCoeff]",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ x : X) : monomCoeff x₀ (0, x) = 0",
  "args": "(X: Type) [DecidableEq X] (x₀ x : X)"},
 {"type": "coeff  x₀  s₁ = coeff  x₀ s₂",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂) : coeff  x₀  s₁ = coeff  x₀ s₂ := by induction h; sorry",
  "name": "coeff_move_invariant",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂) : coeff  x₀  s₁ = coeff  x₀ s₂",
  "args":
  "(X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂)"},
 {"type": "FreeNatModuleAux.coeff X x (sum s) = coeff x s",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x: X) (s: FormalSum X) : FreeNatModuleAux.coeff X x (sum s) = coeff x s := by simp [FreeNatModuleAux.coeff]; sorry",
  "name": "coeff_factors",
  "kind": "theorem",
  "first-tactic": "simp [FreeNatModuleAux.coeff]",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x: X) (s: FormalSum X) : FreeNatModuleAux.coeff X x (sum s) = coeff x s",
  "args": "(X: Type) [DecidableEq X] (x: X) (s: FormalSum X)"},
 {"type": "s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X) : s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂) := by intro hyp; sorry",
  "name": "coeff_well_defined",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X) : s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂)",
  "args": "(X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X)"},
 {"type":
  "0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length))",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X) : 0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length)) := by induction s; sorry",
  "name": "pos_coeff_has_complement",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X) : 0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length))",
  "args": "(X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X)"},
 {"type": "f = g → equalOnSupport l f g",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat) : f = g → equalOnSupport l f g := by intro hyp; sorry",
  "name": "equal_on_support_of_equal",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat) : f = g → equalOnSupport l f g",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat)"},
 {"type": "eqlCoords X s s",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X) : eqlCoords X s s := by rfl; sorry",
  "name": "refl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X) : eqlCoords X s s",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X)"},
 {"type": "eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁ := by intro hyp; sorry",
  "name": "symm",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X}"},
 {"type": "eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃ := by intro hyp₁ hyp₂; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "intro hyp₁ hyp₂",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X}"},
 {"type":
  "(∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β) : (∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂) := by intro hyp; sorry",
  "name": "func_eql_of_move_equiv",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β) : (∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂)",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β)"},
 {"type": "FreeNatModule X → Nat",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat) : FreeNatModule X → Nat := by apply Quotient.lift (linear_extension f₀); sorry",
  "name": "miniUniversalProperty",
  "kind": "def",
  "first-tactic": "apply Quotient.lift (linear_extension f₀)",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat) : FreeNatModule X → Nat",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat)"},
 {"type": "Bool",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Bool := by apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum X) => \n          decide ( ⟦ s₁ ⟧ = ⟦ s₂ ⟧)); sorry",
  "name": "FreeNatModule.beq?",
  "kind": "def",
  "first-tactic":
  "apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum X) => \n          decide ( ⟦ s₁ ⟧ = ⟦ s₂ ⟧))",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Bool",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X)"},
 {"type": "∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂ := by let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = true → x₁ = x₂); sorry",
  "name": "FreeNatModule.eq_of_beq_true",
  "kind": "def",
  "first-tactic":
  "let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = true → x₁ = x₂)",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]"},
 {"type": "∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂)",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂) := by let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = false →\n                Not (x₁ = x₂)); sorry",
  "name": "FreeNatModule.neq_of_beq_false",
  "kind": "def",
  "first-tactic":
  "let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = false →\n                Not (x₁ = x₂))",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂)",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]"},
 {"type": "Decidable (x₁ = x₂)",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Decidable (x₁ = x₂) := by match p:x₁.beq? x₂ with\n    | true => \n      apply Decidable.isTrue\n      apply FreeNatModule.eq_of_beq_true\n      assumption\n    | false => \n      apply Decidable.isFalse\n      apply FreeNatModule.neq_of_beq_false\n      assumption; sorry",
  "name": "FreeNatModule.decEq",
  "kind": "def",
  "first-tactic":
  "match p:x₁.beq? x₂ with\n    | true => \n      apply Decidable.isTrue\n      apply FreeNatModule.eq_of_beq_true\n      assumption\n    | false => \n      apply Decidable.isFalse\n      apply FreeNatModule.neq_of_beq_false\n      assumption",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Decidable (x₁ = x₂)",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X)"},
 {"type": "(EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x → (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x) := by intro h; sorry",
  "name": "term_bar_equals_init",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(term G e = x) → G.init (G.bar e) = x",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) → G.init (G.bar e) = x := by intro hyp; sorry",
  "name": "init_bar_equals_term",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) → G.init (G.bar e) = x",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y}"},
 {"type": "{ rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length}",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length} := by cases exy; sorry",
  "name": "reducePath0",
  "kind": "def",
  "first-tactic": "cases exy",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length}",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "homotopy p q → homotopy q r → homotopy p r",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q → homotopy q r → homotopy p r := by intro h₁ h₂; sorry",
  "name": "homotopy_trans",
  "kind": "theorem",
  "first-tactic": "intro h₁ h₂",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q → homotopy q r → homotopy p r",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y)"},
 {"type":
  "(p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q) := by intro p q h ex h1 h2; sorry",
  "name": "homotopy_left_mult_edge",
  "kind": "theorem",
  "first-tactic": "intro p q h ex h1 h2",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "ht G y z →  ht G x z",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y) : ht G y z →  ht G x z := by let func: EdgePath G y z → ht G x z := by intro p ; exact htclass (multiply p₁ p); sorry",
  "name": "homotopy_left_multiplication",
  "kind": "def",
  "first-tactic":
  "let func: EdgePath G y z → ht G x z := by intro p ; exact htclass (multiply p₁ p)",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y) : ht G y z →  ht G x z",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)"},
 {"type":
  "homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z) : homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂) := by simp[htclass]; sorry",
  "name": "homotopy_left_multiplication_class",
  "kind": "theorem",
  "first-tactic": "simp[htclass]",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z) : homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z)"},
 {"type": "homotopy (cons ex h₁ h₂ exy) (reducePath0 ex h₁ h₂ exy)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : homotopy (cons ex h₁ h₂ exy) (reducePath0 ex h₁ h₂ exy) := by simp[homotopy]; sorry",
  "name": "homotopy_reducePath0",
  "kind": "theorem",
  "first-tactic": "simp[homotopy]",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : homotopy (cons ex h₁ h₂ exy) (reducePath0 ex h₁ h₂ exy)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "homotopy p₁ (reducePath p₁)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y) : homotopy p₁ (reducePath p₁) := by induction p₁; sorry",
  "name": "homotopy_reducePath",
  "kind": "theorem",
  "first-tactic": "induction p₁",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y) : homotopy p₁ (reducePath p₁)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y)"},
 {"type": "x + x + y - x - y + z - x = z",
  "tactic-prompt":
  "example {x y z : ℤ} : x + x + y - x - y + z - x = z := by have p := freeGroupEq# (x + x + y - x - y + z - x); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq# (x + x + y - x - y + z - x)",
  "core-prompt": "{x y z : ℤ} : x + x + y - x - y + z - x = z",
  "args": "{x y z : ℤ}"},
 {"type": "(a + b) - (b - a) - a = a",
  "tactic-prompt":
  "example {A : Type _}  [AddCommGroup A]  {a b : A} : (a + b) - (b - a) - a = a := by have p := freeGroupEq# ((a + b) - (b - a) - a); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq# ((a + b) - (b - a) - a)",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b : A} : (a + b) - (b - a) - a = a",
  "args": "{A : Type _}  [AddCommGroup A]  {a b : A}"},
 {"type": "a + b - a - b = b - b + a - a",
  "tactic-prompt":
  "example {a b : ℤ} : a + b - a - b = b - b + a - a := by have pₗ := freeGroupEq# (a + b - a - b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have pₗ := freeGroupEq# (a + b - a - b)",
  "core-prompt": "{a b : ℤ} : a + b - a - b = b - b + a - a",
  "args": "{a b : ℤ}"},
 {"type": "a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0",
  "tactic-prompt":
  "example {A : Type _}  [AddCommGroup A]  {a b c d e : A} : a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0 := by have p := freeGroupEq# (a + b - c - d + e - a + b + c - a - e + a - b + d - b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "have p := freeGroupEq# (a + b - c - d + e - a + b + c - a - e + a - b + d - b)",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c d e : A} : a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c d e : A}"},
 {"type":
  "(∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1))",
  "tactic-prompt":
  "theorem  : (∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1)) := by apply Iff.intro; sorry",
  "name": "eqn_iff_free_basis",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  " : (∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1))",
  "args": ""},
 {"type": "arr.getIdx? a = some i → arr.size > 0",
  "tactic-prompt":
  "lemma {α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ} : arr.getIdx? a = some i → arr.size > 0 := by rw [getIdx?]; sorry",
  "name": "Array.size_pos_if_index",
  "kind": "lemma",
  "first-tactic": "rw [getIdx?]",
  "core-prompt":
  "{α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ} : arr.getIdx? a = some i → arr.size > 0",
  "args": "{α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ}"},
 {"type": "(arr.push a).size > 0",
  "tactic-prompt":
  "lemma {α : Type _}  (arr : Array α)  (a : α) : (arr.push a).size > 0 := by match arr with\n    | ⟨l⟩ =>\n      simp only [push]; sorry",
  "name": "Array.push_size_pos",
  "kind": "lemma",
  "first-tactic": "match arr with\n    | ⟨l⟩ =>\n      simp only [push]",
  "core-prompt":
  "{α : Type _}  (arr : Array α)  (a : α) : (arr.push a).size > 0",
  "args": "{α : Type _}  (arr : Array α)  (a : α)"},
 {"type": "(arr : Array α) → (t.indexTree arr).2.size > 0",
  "tactic-prompt":
  "theorem {α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α) : (arr : Array α) → (t.indexTree arr).2.size > 0 := by induction t; sorry",
  "name": "pos_size",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α) : (arr : Array α) → (t.indexTree arr).2.size > 0",
  "args": "{α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α)"},
 {"type": "egIndMap x y = x + y + x - y",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α) : egIndMap x y = x + y + x - y := by simp; sorry",
  "name": "egIndMapInv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α) : egIndMap x y = x + y + x - y",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α)"},
 {"type": "egIndMap'' x y = x + y + x - y",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α) : egIndMap'' x y = x + y + x - y := by simp; sorry",
  "name": "egIndMapInv''",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α) : egIndMap'' x y = x + y + x - y",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α)"},
 {"type": "x + y + x - y =  roundtrip# (x + y + x - y)",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]       (x y : α) : x + y + x - y =  roundtrip# (x + y + x - y) := by rfl; sorry",
  "name": "egRoundtrip",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]       (x y : α) : x + y + x - y =  roundtrip# (x + y + x - y)",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]       (x y : α)"},
 {"type":
  "monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R) : monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x) := by repeat\n    (\n      rw [monomCoeff]); sorry",
  "name": "monom_coords_hom",
  "kind": "theorem",
  "first-tactic": "repeat\n    (\n      rw [monomCoeff])",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R) : monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R)"},
 {"type": "monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R) : monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x) := by repeat\n    (\n      rw [monomCoeff]); sorry",
  "name": "monom_coords_mul",
  "kind": "theorem",
  "first-tactic": "repeat\n    (\n      rw [monomCoeff])",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R) : monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R)"},
 {"type": "monomCoeff R X x₀ (0, x) = 0",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X) : monomCoeff R X x₀ (0, x) = 0 := by rw [monomCoeff]; sorry",
  "name": "monom_coords_at_zero",
  "kind": "theorem",
  "first-tactic": "rw [monomCoeff]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X) : monomCoeff R X x₀ (0, x) = 0",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)"},
 {"type": "f = g → equalOnSupport l f g",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R) : f = g → equalOnSupport l f g := by intro hyp; sorry",
  "name": "equal_on_support_of_equal",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R) : f = g → equalOnSupport l f g",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R)"},
 {"type": "eqlCoords R X s s",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X) : eqlCoords R X s s := by rfl; sorry",
  "name": "refl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X) : eqlCoords R X s s",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X)"},
 {"type": "eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁ := by intro hyp; sorry",
  "name": "symm",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X}"},
 {"type": "eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃ := by intro hyp₁ hyp₂; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "intro hyp₁ hyp₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X}"},
 {"type": "beqOnSupport l f g = true → equalOnSupport l f g",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R} : beqOnSupport l f g = true → equalOnSupport l f g := by intro hyp; sorry",
  "name": "eql_on_support_of_true",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R} : beqOnSupport l f g = true → equalOnSupport l f g",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R}"},
 {"type": "⟦s₁⟧ = ⟦s₂⟧",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords) : ⟦s₁⟧ = ⟦s₂⟧ := by let ch₁ := eql_on_support_of_true c₁; sorry",
  "name": "eqlquot_of_beq_support",
  "kind": "theorem",
  "first-tactic": "let ch₁ := eql_on_support_of_true c₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords) : ⟦s₁⟧ = ⟦s₂⟧",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords)"},
 {"type": "Bool",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Bool := by apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum R X) => decide (⟦s₁⟧ = ⟦s₂⟧)); sorry",
  "name": "beq_quot",
  "kind": "def",
  "first-tactic":
  "apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum R X) => decide (⟦s₁⟧ = ⟦s₂⟧))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Bool",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂ := by let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = true → x₁ = x₂); sorry",
  "name": "eq_of_beq_true",
  "kind": "def",
  "first-tactic":
  "let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = true → x₁ = x₂)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂)",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂) := by let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = false → Not (x₁ = x₂)); sorry",
  "name": "neq_of_beq_false",
  "kind": "def",
  "first-tactic":
  "let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = false → Not (x₁ = x₂))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂)",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "Decidable (x₁ = x₂)",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Decidable (x₁ = x₂) := by match p : x₁.beq_quot x₂ with\n  | true =>\n    apply Decidable.isTrue\n    apply FreeModule.eq_of_beq_true\n    assumption\n  | false =>\n    apply Decidable.isFalse\n    apply FreeModule.neq_of_beq_false\n    assumption; sorry",
  "name": "decEq",
  "kind": "def",
  "first-tactic":
  "match p : x₁.beq_quot x₂ with\n  | true =>\n    apply Decidable.isTrue\n    apply FreeModule.eq_of_beq_true\n    assumption\n  | false =>\n    apply Decidable.isFalse\n    apply FreeModule.neq_of_beq_false\n    assumption",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Decidable (x₁ = x₂)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "s₁ ≈ s₂ → s₁.coords = s₂.coords",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) : s₁ ≈ s₂ → s₁.coords = s₂.coords := by intro hyp; sorry",
  "name": "equal_coords_of_approx",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) : s₁ ≈ s₂ → s₁.coords = s₂.coords",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)"},
 {"type": "FreeModule R X →  R",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) : FreeModule R X →  R := by apply Quotient.lift (fun s : FormalSum R X => s.coords x₀); sorry",
  "name": "coordinates",
  "kind": "def",
  "first-tactic": "apply Quotient.lift (fun s : FormalSum R X => s.coords x₀)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) : FreeModule R X →  R",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)"},
 {"type": "(r * s.coords x₀) = (s.scmul r).coords x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X) : (r * s.coords x₀) = (s.scmul r).coords x₀ := by induction s; sorry",
  "name": "scmul_coords",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X) : (r * s.coords x₀) = (s.scmul r).coords x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X)"},
 {"type": "R → FreeModule R X → FreeModule R X",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : R → FreeModule R X → FreeModule R X := by intro r; sorry",
  "name": "FreeModule.scmul",
  "kind": "def",
  "first-tactic": "intro r",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : R → FreeModule R X → FreeModule R X",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "(s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X) : (s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀ := by induction s₁; sorry",
  "name": "append_coords",
  "kind": "theorem",
  "first-tactic": "induction s₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X) : (s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X)"},
 {"type": "(s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X) : (s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂ := by intro eqv₁ eqv₂; sorry",
  "name": "append_equiv",
  "kind": "theorem",
  "first-tactic": "intro eqv₁ eqv₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X) : (s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X)"},
 {"type": "FreeModule R X → FreeModule R X → FreeModule R X",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : FreeModule R X → FreeModule R X → FreeModule R X := by let f : FormalSum R X → FormalSum R X → FreeModule R X := fun s₁ s₂ => ⟦s₁ ++ s₂⟧; sorry",
  "name": "FreeModule.add",
  "kind": "def",
  "first-tactic":
  "let f : FormalSum R X → FormalSum R X → FreeModule R X := fun s₁ s₂ => ⟦s₁ ++ s₂⟧",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : FreeModule R X → FreeModule R X → FreeModule R X",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "(s.scmul b).scmul a = s.scmul (a * b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul b).scmul a = s.scmul (a * b) := by induction s; sorry",
  "name": "action",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul b).scmul a = s.scmul (a * b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X)"},
 {"type": "(s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b) := by induction s; sorry",
  "name": "act_sum",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X)"},
 {"type": "a • (b • x) = (a * b) • x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X) : a • (b • x) = (a * b) • x := by apply @Quotient.ind (motive := fun x : FreeModule R X => a • (b • x) = (a * b) • x); sorry",
  "name": "module_action",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => a • (b • x) = (a * b) • x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X) : a • (b • x) = (a * b) • x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X)"},
 {"type": "x₁ + x₂ = x₂ + x₁",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : x₁ + x₂ = x₂ + x₁ := by apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => x₁ + x₂ = x₂ + x₁); sorry",
  "name": "addn_comm",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => x₁ + x₂ = x₂ + x₁)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : x₁ + x₂ = x₂ + x₁",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "(⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X) : (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃) := by apply @Quotient.ind₂ (motive := fun x₂ x₃ : FreeModule R X => (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)); sorry",
  "name": "add_assoc_aux",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₂ x₃ : FreeModule R X => (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X) : (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X)"},
 {"type": "(x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X) : (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃) := by apply @Quotient.ind (motive := fun x₁ : FreeModule R X => (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)); sorry",
  "name": "addn_assoc",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x₁ : FreeModule R X => (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X) : (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X)"},
 {"type": "x + zero = x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : x + zero = x := by apply @Quotient.ind (motive := fun x : FreeModule R X => x + zero = x); sorry",
  "name": "addn_zero",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => x + zero = x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : x + zero = x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "zero + x = x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : zero + x = x := by apply @Quotient.ind (motive := fun x : FreeModule R X => zero + x = x); sorry",
  "name": "zero_addn",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => zero + x = x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : zero + x = x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "a • (x₁ + x₂) = a • x₁ + a • x₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X) : a • (x₁ + x₂) = a • x₁ + a • x₂ := by apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => a • (x₁ + x₂) = a • x₁ + a • x₂); sorry",
  "name": "elem_distrib",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => a • (x₁ + x₂) = a • x₁ + a • x₂)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X) : a • (x₁ + x₂) = a • x₁ + a • x₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X)"},
 {"type": "a • x + b • x = (a + b) • x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X) : a • x + b • x = (a + b) • x := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    a • x + b • x = (a + b) • x); sorry",
  "name": "coeffs_distrib",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    a • x + b • x = (a + b) • x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X) : a • x + b • x = (a + b) • x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X)"},
 {"type": "(1 : R) • x =  x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (1 : R) • x =  x := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (1 : R) • x =  x); sorry",
  "name": "unit_coeffs",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (1 : R) • x =  x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (1 : R) • x =  x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "(0 : R) • x =  ⟦ [] ⟧",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (0 : R) • x =  ⟦ [] ⟧ := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (0 : R) • x =  ⟦ [] ⟧); sorry",
  "name": "zero_coeffs",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (0 : R) • x =  ⟦ [] ⟧)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (0 : R) • x =  ⟦ [] ⟧",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "coords s₁ x₀ = coords s₂ x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂) : coords s₁ x₀ = coords s₂ x₀ := by induction h; sorry",
  "name": "coords_move_invariant",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂) : coords s₁ x₀ = coords s₂ x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂)"},
 {"type": "FreeModuleAux.coeff  x (sum s) = s.coords x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X) : FreeModuleAux.coeff  x (sum s) = s.coords x := by simp [FreeModuleAux.coeff]; sorry",
  "name": "coeff_factors",
  "kind": "theorem",
  "first-tactic": "simp [FreeModuleAux.coeff]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X) : FreeModuleAux.coeff  x (sum s) = s.coords x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X)"},
 {"type": "s₁ ≃ s₂ → s₁.coords x = s₂.coords x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X) : s₁ ≃ s₂ → s₁.coords x = s₂.coords x := by intro hyp; sorry",
  "name": "coords_well_defined",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X) : s₁ ≃ s₂ → s₁.coords x = s₂.coords x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X)"},
 {"type": "s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂ := by intro h; sorry",
  "name": "cons_equiv_of_equiv",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X)"},
 {"type":
  "0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length))",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X) : 0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length)) := by induction s; sorry",
  "name": "nonzero_coeff_has_complement",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X) : 0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length))",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X)"},
 {"type":
  "(∀ s₁ s₂ : FormalSum R X, ∀ mv : ElementaryMove R X s₁ s₂, f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β) : (∀ s₁ s₂ : FormalSum R X, ∀ mv : ElementaryMove R X s₁ s₂, f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂) := by intro hyp; sorry",
  "name": "func_eql_of_move_equiv",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β) : (∀ s₁ s₂ : FormalSum R X, ∀ mv : ElementaryMove R X s₁ s₂, f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β)"},
 {"type": "a ≤ max a b",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : a ≤ max a b := by simp [max]; sorry",
  "name": "fst_le_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : a ≤ max a b",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type": "b ≤ max a b",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : b ≤ max a b := by simp [max]; sorry",
  "name": "snd_le_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : b ≤ max a b",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type": "(max a b = a) ∨ (max a b = b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : (max a b = a) ∨ (max a b = b) := by simp [max]; sorry",
  "name": "eq_fst_or_snd_of_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : (max a b = a) ∨ (max a b = b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type":
  "maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1 := by intro h; sorry",
  "name": "max_in_support",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X)"},
 {"type":
  "(x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : (x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s := by intro x h₁ h₂; sorry",
  "name": "supp_below_max",
  "kind": "theorem",
  "first-tactic": "intro x h₁ h₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : (x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X)"},
 {"type": "s₁.normSucc norm = s₂.normSucc norm",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂) : s₁.normSucc norm = s₂.normSucc norm := by apply Nat.le_antisymm; sorry",
  "name": "norm_succ_eq",
  "kind": "theorem",
  "first-tactic": "apply Nat.le_antisymm",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂) : s₁.normSucc norm = s₂.normSucc norm",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂)"},
 {"type": "Nat",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X] : Nat := by let f : FormalSum R X → Nat := fun s => s.normSucc (nx.norm); sorry",
  "name": "FreeModule.normBound",
  "kind": "def",
  "first-tactic":
  "let f : FormalSum R X → Nat := fun s => s.normSucc (nx.norm)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X] : Nat",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X]"},
 {"type": "{a : ℤ} → ¬(a + a + 1 = 0)",
  "tactic-prompt": "lemma  : {a : ℤ} → ¬(a + a + 1 = 0) := by intro a h; sorry",
  "name": "odd_ne_zero",
  "kind": "lemma",
  "first-tactic": "intro a h",
  "core-prompt": " : {a : ℤ} → ¬(a + a + 1 = 0)",
  "args": ""},
 {"type": "∀ g : P, g ^ 2 = 1 → g = 1",
  "tactic-prompt":
  "theorem  : ∀ g : P, g ^ 2 = 1 → g = 1 := by intro ⟨(p, q, r), x⟩; sorry",
  "name": "square_free",
  "kind": "theorem",
  "first-tactic": "intro ⟨(p, q, r), x⟩",
  "core-prompt": " : ∀ g : P, g ^ 2 = 1 → g = 1",
  "args": ""},
 {"type": "∀ {a : A}, a • (0 : B) = (0 : B)",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, a • (0 : B) = (0 : B) := by intro; sorry",
  "name": "act_zero",
  "kind": "theorem",
  "first-tactic": "intro",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, a • (0 : B) = (0 : B)",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b'",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b' := by intro; sorry",
  "name": "add_dist",
  "kind": "theorem",
  "first-tactic": "intro",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b'",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b)",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b) := by intros; sorry",
  "name": "neg_push",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b)",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "¬ (trivial_element α)",
  "tactic-prompt": "theorem  : ¬ (trivial_element α) := by intro contra; sorry",
  "name": "α_non_trivial",
  "kind": "theorem",
  "first-tactic": "intro contra",
  "core-prompt": " : ¬ (trivial_element α)",
  "args": ""}]