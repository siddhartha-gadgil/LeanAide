{Î± : Type u} [pseudoMetricSpace Î±] (x y z : Î±) : HasNndist.nndist x z â‰¤ HasNndist.nndist x y + HasNndist.nndist y z
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] : IsNoetherian K V â†” Module.rank K V < Cardinal.aleph_0
{Î± : Type u_2} [DecidableEq Î±] {s : Finset Î±} {B : Finset (Finset Î±)} {n : â„•} (h : âˆ€ (a : Î±), a âˆˆ s â†’ (Finset.filter (HasMem.Mem a) B).card â‰¤ n) : B.sum (Î» (t : Finset Î±), (s âˆ© t).card) â‰¤ s.card * n
{R : Type u_1} {n : â„•} {M : Fin n â†’ Type u_3} {Mâ‚‚ : Type u_4} [CommSemiring R] [AddCommMonoid Mâ‚‚] [Î  (i : Fin n), AddCommMonoid (M i)] [Î  (i : Fin n), Module R (M i)] [Module R Mâ‚‚] {f g : MultilinearMap R M Mâ‚‚} {Î¹â‚ : Fin n â†’ Type u_2} (e : Î  (i : Fin n), Basis (Î¹â‚ i) R (M i)) (h : âˆ€ (v : Î  (i : Fin n), Î¹â‚ i), â‡‘f (Î» (i : Fin n), â‡‘(e i) (v i)) = â‡‘g (Î» (i : Fin n), â‡‘(e i) (v i))) : f = g
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] (F : Top.Sheaf C X) (U : TopologicalSpace.Opens â†¥X) (s t : â†¥(F.val.obj (Opposite.op U))) (h : âˆ€ (x : â†¥U), â‡‘(F.val.germ x) s = â‡‘(F.val.germ x) t) : s = t
{G : Type u_7} [AddGroup G] (L : List G) (i : â„•) (p : i < L.length) : (List.drop (i + 1) L).sum = -L.nth_LE i p + (List.drop i L).sum
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} : a - b < 0 â†” a < b
{ð•œ : Type u_1} {ð• : Type u_2} {E : Type u_3} [normedField ð•œ] [normedRing ð•] [normedSpace ð•œ ð•] [AddCommGroup E] [Module ð•œ E] [smulWithZero ð• E] [isScalarTower ð•œ ð• E] {s : Set E} (hs : Balanced ð• s) {a : ð•} {b : ð•œ} (h : âˆ¥aâˆ¥ â‰¤ âˆ¥bâˆ¥) : a â€¢ s âŠ† b â€¢ s
{C : Type u} [CategoryTheory.Category C] (i p : CategoryTheory.Arrow C) (h : CategoryTheory.Limits.IsInitial i.left) : CategoryTheory.HasLiftingProperty i p â†” âˆ€ {e : i.right âŸ¶ p.right}, âˆƒ (l : i.right âŸ¶ p.left), l â‰« p.hom = e
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.PosMulMono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (a0 : 0 < a) : a * b â‰¤ 1
(R : Type u_1) [CommRing R] {n m : â„•} (hpos : 0 < n) (hm : m âˆ£ n) (hdiff : m â‰  n) : Polynomial.x ^ m - 1 âˆ£ n.proper_divisors.prod (Î» (i : â„•), Polynomial.cyclotomic i R)
{M : Type u_6} {N : Type u_7} [hasMul M] [hasMul N] (e : M â‰ƒ* N) (y : N) : â‡‘e (â‡‘(e.symm) y) = y
(p : â„•) : WittVector.IsPoly p (Î» (R : Type u_1) (_Rcr : CommRing R), WittVector.verschiebungFun)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : E â†’ F} (g : F â†’L[ð•œ] G) (hF : ContDiff ð•œ n f) : ContDiff ð•œ n (Î» (x : E), â‡‘g (f x))
{R : Type u_1} [AddMonoid R] (a : addUnits R) : IsAddRegular â†‘a
{Î± : Type u_1} [topologicalSpace Î±] (S : Set (Set Î±)) (hS : âˆ€ (s : â†¥S), is_IsOpen â†‘s) [hS' : âˆ€ (s : â†¥S), QuasiSober â†¥s] (hS'' : â‹ƒâ‚€S = âŠ¤) : QuasiSober Î±
{Î± : Type u_1} {n : Type u_4} [hasZero Î±] [Subsingleton n] (A : Matrix n n Î±) : A.is_diag
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set â„} [Interval_integral.FTC_Filter b (nhdsWithin b s) (nhdsWithin b t)] (hmeas : StronglyMeasurableAtFilter f (nhdsWithin b t) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhdsWithin b t âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) (hs : UniqueDiffWithinAt â„ s b . "UniqueDiffWithinAt_ici_Iic_Univ") : derivWithin (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s b = c
{C : Type uâ‚} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} : â‡‘S (ðŸ™ X) â†” S = âŠ¤
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : HasDist.dist p1 p3 * HasDist.dist p1 p3 = HasDist.dist p1 p2 * HasDist.dist p1 p2 + HasDist.dist p3 p2 * HasDist.dist p3 p2 â†” EuclideanGeometry.angle p1 p2 p3 = Real.pi / 2
{M : Type u_2} [AddCommGroup M] {ð•œ : Type u_1} [Field ð•œ] [Module ð•œ M] {f : M â†’â‚—[ð•œ] M} (hF : â‡‘LinearMap.det f = 0) : âŠ¥ < f.ker
{m : Type u_2} {n : Type u_3} {R : Type u_7} [Fintype n] [Fintype m] [nonUnitalSemiring R] (v : m â†’ R) (A : Matrix m n R) (w : n â†’ R) : Matrix.dotProduct v (A.mul_vec w) = Matrix.dotProduct (Matrix.vecMul v A) w
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type uâ‚‚} [CategoryTheory.Category D] [CategoryTheory.Abelian D] (F : C â¥¤ D) (G : D â¥¤ C) [G.preserves_Zero_morphisms] (i : F â‹™ G â‰… ðŸ­ C) [CategoryTheory.Limits.PreservesFiniteLimits G] : CategoryTheory.Limits.HasKernels C
{V : Type u} (G : SimpleGraph V) {v w : V} : G.adj v w â†” v â‰  w âˆ§ âˆƒ (e : Sym2 V) (H : e âˆˆ G.edge_Set), v âˆˆ e âˆ§ w âˆˆ e
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [Module ð•œ E] {s : Set E} : s.nonempty â†’ (â‡‘(convexHull ð•œ) s).nonempty
{G : Type u_1} [AddGroup G] [Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)] (hdvd : p âˆ£ Fintype.card G) : âˆƒ (x : G), addOrderOf x = p
{Î± : Type u} [HasSubset Î±] [hasSsubset Î±] [isNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {a b c : Î±} [IsTrans Î± HasSubset.Subset] (hâ‚ : a âŠ‚ b) (hâ‚‚ : b âŠ† c) : a âŠ‚ c
{R : Type u} {S : Type v} [CommRing R] [CommRing S] (f : R â†’+* S) : Function.Injective â‡‘(f.ker_Lift)
{G : Type u_1} [AddCommGroup G] (f : â„• â†’ G) (n : â„•) : (Finset.range n).sum (Î» (i : â„•), f (i + 1) - f i) = f n - f 0
{M : Type u_2} [AddCommGroup M] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] {A : Type u_5} [CommRing A] [Module A M] (b : Basis Î¹ A M) (f : M â†’â‚—[A] M) : â‡‘(LinearMap.detAux (Trunc.mk b)) f = (â‡‘(LinearMap.toMatrix b b) f).det
{Î± : Type u_1} {l l' : List Î±} : l <+ l' â†” âˆƒ (f : â„• â†ªo â„•), âˆ€ (ix : â„•), l.nth ix = l'.nth (â‡‘f ix)
{C : Type u} [CategoryTheory.Category C] {X Y Z : C} {i : CategoryTheory.Arrow C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} (hF : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.mk f)) (hg : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.mk g)) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.mk (f â‰« g))
{Î± : Type u_1} [hasLt Î±] {a b : Î±áµ’áµˆ} : b < a â†’ â‡‘OrderDual.ofDual a < â‡‘OrderDual.ofDual b
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e e' : localHomeomorph Î± Î²} (h : e â‰ˆ e') : e.to_local_equiv.target = e'.to_local_equiv.target
{Î± : Type u} [topologicalSpace Î±] [SigmaCompactSpace Î±] {f : Î± â†’ Set Î±} {s : Set Î±} (hs : is_IsClosed s) (hF : âˆ€ (x : Î±), x âˆˆ s â†’ f x âˆˆ nhdsWithin x s) : âˆƒ (t : Set Î±) (H : t âŠ† s), t.countable âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), f x
{R : Type u_1} {G : Type u_2} [CommRing R] [is_IsDomain R] [Group G] [Fintype G] (f : G â†’* R) [Decidable (f = 1)] : finset.univ.sum (Î» (g : G), â‡‘f g) = Ite (f = 1) â†‘(Fintype.card G) 0
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] {C : Type u} [CategoryTheory.Category C] (F : J Ã— K â¥¤ C) [CategoryTheory.Limits.HasLimitsOfShape J C] [CategoryTheory.Limits.HasColimitsOfShape K C] (j : J) (k : K) : CategoryTheory.Limits.colimitÎ¹ (Category_theory.curry.obj (CategoryTheory.prod.swap K J â‹™ F) â‹™ CategoryTheory.Limits.lim) k â‰« CategoryTheory.Limits.colimitLimitToLimitColimit F â‰« CategoryTheory.Limits.limitÏ€ (Category_theory.curry.obj F â‹™ CategoryTheory.Limits.colim) j = CategoryTheory.Limits.limitÏ€ ((Category_theory.curry.obj (CategoryTheory.prod.swap K J â‹™ F)).obj k) j â‰« CategoryTheory.Limits.colimitÎ¹ ((Category_theory.curry.obj F).obj j) k
{b : â„} (a X : â„) (h2 : 0 < b) : âˆ« (x : â„) in a..X, Real.exp (-b * x) â‰¤ Real.exp (-b * a) / b
{F : Type u_1} {K : Type u_2} {L : Type u_3} [Field F] [Field K] [Field L] [Algebra F K] [Algebra F L] (s : Finset K) : (âˆ€ (x : K), x âˆˆ s â†’ IsIntegral F x âˆ§ Polynomial.Splits (algebraMap F L) (minpoly F x)) â†’ Nonempty (â†¥(Algebra.adjoin F â†‘s) â†’â‚[F] L)
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b c : Î±} : a - c < b â†’ a < b + c
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hst : s âŠ† t) (ht : (t âˆ© Function.MulSupport f).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t  s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
{R : Type u_1} [Semiring R] (x y : DualNumber R) : (x * y).snd = TrivSqZeroExt.fst x * TrivSqZeroExt.snd y + TrivSqZeroExt.fst y * TrivSqZeroExt.snd x
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a u' : Î±} {s : Set Î±} (hu' : a < u') : s âˆˆ nhdsWithin a (Set.Ioi a) â†” âˆƒ (u : Î±) (H : u âˆˆ Set.Ioi a), Set.Ioo a u âŠ† s
{Î² : Type u_4} [LinearOrder Î²] [NoMaxOrder Î²] {u : â„• â†’ Î²} (hu : Filter.Tendsto u Filter.atTop Filter.atTop) : âˆƒá¶  (n : â„•) in Filter.atTop, âˆ€ (k : â„•), k < n â†’ u k < u n
{Î“â‚€ : Type u_1} [LinearOrderedCommGroupWithZero Î“â‚€] (Î³ : Î“â‚€Ë£) : {x : Î“â‚€ | x < â†‘Î³} âˆˆ nhds 0
{Î² : Type u_2} {f g : Î² â†’ Nnreal} {r : Nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b) (hfr : HasSum f r) : âˆƒ (p : Nnreal) (H : p â‰¤ r), HasSum g p
(c : Turing.ToPartrec.Code) (k k' : Turing.ToPartrec.Cont) (v : List â„•) : Turing.ToPartrec.stepNormal c (k.then k') v = (Turing.ToPartrec.stepNormal c k v).then k'
{C : Type uâ‚} [CategoryTheory.Category C] {T : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] [CategoryTheory.Limits.PreservesColimitsOfShape J â†‘T] (D : J â¥¤ T.algebra) [CategoryTheory.Limits.HasColimit (D â‹™ T.forget)] : CategoryTheory.Limits.HasColimit D
{R : Type u_1} {Î¹ : Type u_4} [linearOrderedField R] [Fintype Î¹] {f : Î¹ â†’ R} (hF : f âˆˆ StdSimplex R Î¹) (x : Î¹) : f x âˆˆ Set.Icc 0 1
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] (Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚) (Ïƒâ‚‚â‚ : Râ‚‚ â†’+* Râ‚) [RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} [CategoryTheory.Limits.HasEqualizer f g] [CategoryTheory.Epi (CategoryTheory.Limits.equalizerÎ¹ f g)] : f = g
{Î± : Type u} [pseudoMetricSpace Î±] (x : Î±) : Emetric.Ball x âŠ¤ = Set.Univ
{Î± : Type u_1} (p : Pmf Î±) {s t : Set Î±} (h : s âˆ© p.support âŠ† t) : â‡‘(p.to_outerMeasure) s â‰¤ â‡‘(p.to_outerMeasure) t
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] : 0 â‰¤ (GeneralizedContinuedFraction.of v).denominators n
{n : WithTop â„•} {ð•‚ : Type u_6} [is_R_or_C ð•‚] {F' : Type u_8} [NormedGroup F'] [normedSpace ð•‚ F'] {f : ð•‚ â†’ F'} {x : ð•‚} (hF : ContDiff ð•‚ n f) (hn : 1 â‰¤ n) : HasStrictDerivAt f (deriv f x) x
{p q x : â„} (h : LiouvilleWith p x) (hle : q â‰¤ p) : LiouvilleWith q x
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : P) (s : Set P) : p âˆˆ s â†’ p âˆˆ SpanPoints k s
{Î± : Type u_1} [completeLattice Î±] [IsCompactlyGenerated Î±] {a : Î±} {s : Set Î±} : a âŠ“ HasSup.sup s = â¨† (t : Finset Î±) (H : â†‘t âŠ† s), a âŠ“ t.sup Id
{C : Type u_1} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) : CategoryTheory.CoverLifting J J (ðŸ­ C)
{Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [Î  (i : Î¹), topologicalSpace (X i)] {as bs : Î  (i : Î¹), X i} (i : Î¹) (Paths : Î  (i : Î¹), Path.Homotopic.Quotient (as i) (bs i)) : Path.Homotopic.proj i (Path.Homotopic.pi Paths) = Paths i
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle â„ P) : t.orthocenter = 3 â€¢ (Finset.centroid â„ Finset.univ t.points -áµ¥ Affine.Simplex.circumcenter t) +áµ¥ Affine.Simplex.circumcenter t
{Î± : Type u_1} [hasLt Î±] {a b : Î±} (h : a < b) : Â¬a â‹– b â†’ (âˆƒ (c : Î±), a < c âˆ§ c < b)
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î± â†’ Î³} (hF : Continuous f) : Continuous (Î» (x : Î± Ã— Î²), f x.fst)
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [rÎ± : NonUnitalNonAssocSemiring Î±] [rÎ² : NonUnitalNonAssocSemiring Î²] {rÎ³ : NonUnitalNonAssocSemiring Î³} {Î´ : Type u_1} {rÎ´ : NonUnitalNonAssocSemiring Î´} (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) (h : Î³ â†’â‚™+* Î´) : (h.comp g).comp f = h.comp (g.comp f)
(Î“â‚€ : Type u_1) [LinearOrderedCommGroupWithZero Î“â‚€] : Directed GE (Î» (Î³â‚€ : Î“â‚€Ë£), Filter.principal {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
(n : â„•) {a : â„} (h : Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2) : a < Real.pi
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X : C} (p : X âŸ¶ X) (hp : p â‰« p = p) : (ðŸ™ X - p) â‰« (ðŸ™ X - p) = ðŸ™ X - p
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hst : s âŠ† t) (ht : t.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t  s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
{Î± : Type u_1} {Î² : Type u_4} [PartialOrder Î±] [PartialOrder Î²] {u : Î² â†’ Î±} (l : lowerAdjoint u) : l.closed = Set.Range (u âˆ˜ â‡‘l)
{G : Type u} [Group G] [Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] (hdvd : p ^ (n + 1) âˆ£ Fintype.card G) {H : Subgroup G} (hH : Fintype.card â†¥H = p ^ n) : p ^ (n + 1) âˆ£ Fintype.card â†¥(H.normalizer)
{E : Type u_1} {Î² : Type u_2} [AddCommGroup E] [topologicalSpace E] [Module â„ E] [TopologicalAddGroup E] [HasContinuousSmul â„ E] [OrderedAddCommGroup Î²] [Module â„ Î²] [OrderedSmul â„ Î²] {s : Set E} {f : E â†’ Î²} {a : E} (a_in_s : a âˆˆ s) (h_localmax : is_IsLocalMaxOn f s a) (h_conc : ConcaveOn â„ s f) : IsMaxOn f s a
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {x : E} {n : â„•} : iteratedFderiv ð•œ (n + 1) f x = (â‡‘(continuousMultilinearCurryRightEquiv' ð•œ n E F) âˆ˜ iteratedFderiv ð•œ n (Î» (y : E), fderiv ð•œ f y)) x
{Î¹ : Type u_1} {R : Type u_2} [CommRing R] [LinearOrder Î¹] (s : Finset Î¹) (f g : Î¹ â†’ R) : s.prod (Î» (i : Î¹), f i - g i) = s.prod (Î» (i : Î¹), f i) - s.sum (Î» (i : Î¹), g i * (Finset.filter (Î» (_x : Î¹), _x < i) s).prod (Î» (j : Î¹), f j - g j) * (Finset.filter (Î» (j : Î¹), i < j) s).prod (Î» (j : Î¹), f j))
(p : â„•) [Fact (Nat.Prime p)] (a : â„¤) : Zmod.legendreSym p a = 0 â†” â†‘a = 0
(i j : â„•) (h : j + 1 = i) : algebraic_topology.dold_kan.c.rel i j
{Î± : Type u_1} [metricSpace Î±] {K : Nnreal} {f : Î± â†’ Î±} (hF : ContractingWith K f) [Nonempty Î±] [CompleteSpace Î±] : Function.IsFixedPt f (ContractingWith.fixedPoint f hF)
{Î± : Type u_1} [hasMul Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LT.lt] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a b c d : Î±} (hâ‚ : a < b) (hâ‚‚ : c < d) : a * c < b * d
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f g : Î± â†’ M} (hF : (Function.MulSupport f).finite) (hg : (Function.MulSupport g).finite) : finprod (Î» (i : Î±), f i * g i) = finprod (Î» (i : Î±), f i) * finprod (Î» (i : Î±), g i)
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} : 0 â‰¤ Metric.hausdorffDist s t
{K : Type u} [Field K] (s : Subfield K) {l : List K} : (âˆ€ (x : K), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (u : E) {v : E} (hv : v âˆˆ (Submodule.span ð•œ {u})á—®) : HasInner.inner u v = 0
{R : Type u_1} {a : R} [cancelMonoidWithZero R] [Nontrivial R] : IsRegular a â†” a â‰  0
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {a : Î±} {s : Set Î±} (f : Î± â†’ M) (h : a âˆ‰ s) (hs : (s âˆ© Function.Support f).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ HasInsert.insert a s), f i)) = f a + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
{Î± : Type u_1} {n : Type u_4} [hasZero Î±] [DecidableEq n] {A : Matrix n n Î±} (h : A.is_diag) : Matrix.diagonal A.diag = A
{R : Type u_1} [CommRing R] [is_IsDomain R] {f : Polynomial R} {P : Ideal R} (hP : P.is_Prime) (hfl : f.leading_Coeff âˆ‰ P) (hfP : âˆ€ (n : â„•), â†‘n < f.degree â†’ f.coeff n âˆˆ P) (hfd0 : 0 < f.degree) (h0 : f.coeff 0 âˆ‰ P ^ 2) (hu : f.is_primitive) : Irreducible f
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x : Î±} (h : s.nonempty) : Emetric.infEdist x s â‰  âŠ¤
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {xâ‚ xâ‚‚ y z : V} (hxâ‚yne : xâ‚ â‰  y) (hxâ‚zne : xâ‚ â‰  z) (hxâ‚‚yne : xâ‚‚ â‰  y) (hxâ‚‚zne : xâ‚‚ â‰  z) {r : â„} (hxâ‚ : âˆ¥xâ‚âˆ¥ = r) (hxâ‚‚ : âˆ¥xâ‚‚âˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : 2 â€¢ o.oangle (y - xâ‚) (z - xâ‚) = 2 â€¢ o.oangle (y - xâ‚‚) (z - xâ‚‚)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = Real.pi) : HasDist.dist p3 p2 â‰  0
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [Module ð•œ Î²] [LinearOrder E] {s : Set E} {f : E â†’ Î²} (hs : Convex ð•œ s) (hF : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ð•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)) : StrictConcaveOn ð•œ s f
{M : Type u_1} [AddZeroClass M] {p : M â†’ Prop} (x : M) {s : Set M} (hs : AddSubmonoid.closure s = âŠ¤) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (H1 : p 0) (HMul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) : p x
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” InnerProductGeometry.angle x y = 0
{D : Set â„} (hD : Convex â„ D) (hDâ‚‚ : is_IsOpen D) {f : â„ â†’ â„} (hF' : DifferentiableOn â„ f D) (hF'' : âˆ€ (x : â„), x âˆˆ D â†’ 0 < deriv^[2] f x) : StrictConvexOn â„ D f
{r p : Nnreal} : â†‘(r - p) = â†‘r - â†‘p
{G : Type u_1} [Group G] (H : â„• â†’ Subgroup G) (hH : IsDescendingCentralSeries H) (n : â„•) : lowerCentralSeries G n â‰¤ H n
(p : â„•) [p_Prime : Fact (Nat.Prime p)] (q : â„š) : padicValRat p qâ»Â¹ = -padicValRat p q
{k : Type u_1} {V : Type u_2} [Ring k] [AddCommGroup V] [Module k V] {Î¹ : Type u_4} (s : Finset Î¹) (p : Î¹ â†’ V) (w : Î¹ â†’ k) (hw : s.sum (Î» (i : Î¹), w i) = 1) : â‡‘(s.affine_combination p) w = s.sum (Î» (i : Î¹), w i â€¢ p i)
{Î± : Type u} [Preorder Î±] {f : â„¤ â†’ Î±} (hF : Antitone f) (n : â„¤) {x : Î±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : â„¤) : f a â‰  x
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚} {R C : â„} (hR : 0 < R) (hc : ContinuousOn f (Metric.Sphere c R)) (hF : âˆ€ (z : â„‚), z âˆˆ Metric.Sphere c R â†’ âˆ¥f zâˆ¥ â‰¤ C) (hlt : âˆƒ (z : â„‚) (H : z âˆˆ Metric.Sphere c R), âˆ¥f zâˆ¥ < C) : âˆ¥âˆ® (z : â„‚) in C(c, R), f zâˆ¥ < 2 * Real.pi * R * C
{Î± : Type u_1} [measurableSpace Î±] {f : â„• â†’ Î± â†’ Ennreal} {g : Î± â†’ Ennreal} (hF : âˆ€ (i : â„•), Measurable (f i)) (lim : Filter.Tendsto f Filter.atTop (nhds g)) : Measurable g
{Î¹ : Type u} {f g : Î¹ â†’ Nnreal} {A B : Nnreal} {p q : â„} (hpq : p.is_conjugate_exponent q) (hF : HasSum (Î» (i : Î¹), f i ^ p) (A ^ p)) (hg : HasSum (Î» (i : Î¹), g i ^ q) (B ^ q)) : âˆƒ (C : Nnreal), C â‰¤ A * B âˆ§ HasSum (Î» (i : Î¹), f i * g i) C
{Î± : Type u_1} {Î² : Type u_2} {la : Filter Î±} {lb : Filter Î²} {f : Î± â†’ Set Î²} : Filter.Tendsto f la lb.small_sets â†” âˆ€ (t : Set Î²), t âˆˆ lb â†’ (âˆ€á¶  (x : Î±) in la, f x âŠ† t)
(R : Type u_1) [CommRing R] [LocalRing R] (q : â„•) [Char_R_q : Char_p R q] : q = 0 âˆ¨ IsPrimePow q
(x y : Pgame) : x < y âˆ¨ x.equiv y âˆ¨ y < x âˆ¨ x.fuzzy y
{M : Type u_1} [MulOneClass M] (S : Submonoid M) : S = âŠ¥ âˆ¨ Nontrivial â†¥S
{R : Type u_1} {a : R} [Monoid R] (n : â„•) (rla : IsLeftRegular a) : IsLeftRegular (a ^ n)
{G : Type u_1} [Group G] (H : Subgroup G) {x : G} : x âˆˆ H â†’ xâ»Â¹ âˆˆ H
(ð•œ : Type u_1) (E : Type u_2) [orderedSemiring ð•œ] [OrderedAddCommGroup E] [Module ð•œ E] [OrderedSmul ð•œ E] : (ConvexCone.positiveCone ð•œ E).salient
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s u : Set E} {f : E â†’ F} {x : E} {n : â„•} (hu : u âˆˆ nhdsWithin x s) (hs : UniqueDiffOn ð•œ s) (xs : x âˆˆ s) : iteratedFderivWithin ð•œ n f (s âˆ© u) x = iteratedFderivWithin ð•œ n f s x
{C : Type uâ‚} [CategoryTheory.Category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {X : C} (S : CategoryTheory.Sieve X) : CategoryTheory.Presieve.IsSheafFor P â‡‘S â†” Nonempty (CategoryTheory.Limits.IsLimit (Category_theory.limits.fork.of_Î¹ (CategoryTheory.Equalizer.forkMap P â‡‘S) _))
{X : Type u} {Y : Type v} [Preorder X] [Preorder Y] (f : X â¥¤ Y) : Monotone f.obj
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Mâ‚ : Type u_4} [topologicalSpace Mâ‚] [AddCommMonoid Mâ‚] {Mâ‚‚ : Type u_6} [topologicalSpace Mâ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚ Mâ‚] [Module Râ‚‚ Mâ‚‚] [RingHomSurjective Ïƒâ‚â‚‚] [topologicalSpace Râ‚] [topologicalSpace Râ‚‚] [HasContinuousSmul Râ‚ Mâ‚] [HasContinuousAdd Mâ‚] [HasContinuousSmul Râ‚‚ Mâ‚‚] [HasContinuousAdd Mâ‚‚] {f : Mâ‚ â†’sl[Ïƒâ‚â‚‚] Mâ‚‚} (hF' : DenseRange â‡‘f) {s : Submodule Râ‚ Mâ‚} (hs : s.topological_Closure = âŠ¤) : (Submodule.map â†‘f s).topological_Closure = âŠ¤
{Î± : Type u_1} {Î¹ : sort u_4} {Î¹' : sort u_5} {s : Î¹ â†’ Î¹' â†’ Set Î±} : (â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) âŠ† â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [CommMonoid M] {g : Î² â†’ M} (e : Î± â†’ Î²) (hEâ‚€ : Function.bijective e) : finprod (Î» (i : Î±), g (e i)) = finprod (Î» (j : Î²), g j)
 : Real.cos (Real.pi / 6) ^ 2 = 3 / 4
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î² â†’ Î³} {x : Î± Ã— Î²} (hF : ContinuousAt f x.snd) : ContinuousAt (Î» (x : Î± Ã— Î²), f x.snd) x
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [isScalarTower R S A] {B : powerBasis S A} (hB : IsIntegral R B.gen) [is_IsDomain S] (hmin : minpoly S B.gen = Polynomial.map (algebraMap R S) (minpoly R B.gen)) (n : â„•) (i : Fin B.dim) : IsIntegral R (â‡‘(â‡‘(B.basis.repr) (B.gen ^ n)) i)
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] [Nonempty Î²] [hasOne Î±] {f : Î² â†’ Î±} (hF : Continuous f) (h : HasCompactMulSupport f) : âˆƒ (x : Î²), âˆ€ (y : Î²), f y â‰¤ f x
{M : Type u_1} {Îº : Type u_2} [AddCommMonoid M] (S : Finset M) [Fintype Îº] (C : M â†’ Îº) : âˆƒ (a : â„•) (H : a > 0) (b : M) (c : Îº), âˆ€ (s : M), s âˆˆ S â†’ C (a â€¢ s + b) = c
{R : Type u_1} {a : R} [Monoid R] {n : â„•} (n0 : 0 < n) : IsRightRegular (a ^ n) â†” IsRightRegular a
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {E : Type u_3} [hasNorm E] {F : Type u_4} [hasNorm F] (e : localHomeomorph Î± Î²) {b : Î²} (hb : b âˆˆ e.to_local_equiv.target) {f : Î² â†’ E} {g : Î² â†’ F} : f =O[nhds b] g â†” (f âˆ˜ â‡‘e) =O[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
(A : Type u_2) (K : Type u_3) [CommRing A] [Field K] [is_IsDomain A] [Algebra A K] [IsFractionRing A K] (L : Type u_4) [Field L] [Algebra K L] [FiniteDimensional K L] [Algebra A L] [isScalarTower A K L] : âˆƒ (s : Finset L) (b : Basis â†¥s K L), âˆ€ (x : â†¥s), IsIntegral A (â‡‘b x)
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {f : M â†’* P} (x : M) : â‡‘(Con.kerLift f) â†‘x = â‡‘f x
{Î± : Type u_1} {s : Set (Set Î±)} (hs : IsPiSystem s) : MeasurableSpace.generateFrom s = (MeasurableSpace.DynkinSystem.generate s).to_measurableSpace _
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup Vâ‚‚] [Module k Vâ‚‚] [addTorsor Vâ‚‚ Pâ‚‚] {p : Î¹ â†’ P} (e : P â‰ƒáµƒ[k] Pâ‚‚) : AffineIndependent k (â‡‘e âˆ˜ p) â†” AffineIndependent k p
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLattice Î±] [SemilatticeSup Î²] {f g : Î² â†’ Î±} (h : Antitone (Î» (n : Î²), Set.Icc (f n) (g n))) (h' : âˆ€ (n : Î²), f n â‰¤ g n) : (â¨† (n : Î²), f n) âˆˆ â‹‚ (n : Î²), Set.Icc (f n) (g n)
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) : S.normed_mk.is_Quotient
{C : Type u} [CategoryTheory.Category C] {A B R : C} {f g : R âŸ¶ A} {q : A âŸ¶ B} (h : CategoryTheory.IsKernelPair q f g) : CategoryTheory.IsReflexivePair f g
{Î± : Type u} [pseudoEmetricSpace Î±] (f : â„• â†’ Î±) {m n : â„•} (h : m â‰¤ n) : HasEdist.edist (f m) (f n) â‰¤ (Finset.ico m n).sum (Î» (i : â„•), HasEdist.edist (f i) (f (i + 1)))
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {f : Î± â†’ Î² â†’ Î³} (hF : Function.Injective2 f) (b : Î²) : Function.Injective (Î» (a : Î±), f a b)
{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : Function.IsPeriodicPt f 0 x
{Î± : Type u_3} {Î² : Type u_4} [linearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto f l Filter.atTop) : Filter.Tendsto (Î» (x : Î²), f x / r) l Filter.atTop
{R : Type u_2} {Î“â‚€ : Type u_3} {Î“'â‚€ : Type u_4} [linearOrderedAddCommMonoidWithTop Î“â‚€] [linearOrderedAddCommMonoidWithTop Î“'â‚€] [Ring R] {vâ‚ : addValuation R Î“â‚€} {vâ‚‚ : addValuation R Î“'â‚€} {S : Type u_1} [Ring S] (f : S â†’+* R) (h : vâ‚.is_Equiv vâ‚‚) : (AddValuation.comap f vâ‚).is_Equiv (AddValuation.comap f vâ‚‚)
{G : Type u_4} [NormedGroup G] [normedSpace â„ G] {s : Set G} (conv : Convex â„ s) (hs : (Interior s).nonempty) : UniqueDiffOn â„ s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] {f : J â†’ C} [CategoryTheory.Limits.HasBiproduct f] : finset.univ.sum (Î» (j : J), CategoryTheory.Limits.biproductÏ€ f j â‰« CategoryTheory.Limits.biproductÎ¹ f j) = ðŸ™ (â¨ f)
{Î± : Type u_1} [Preorder Î±] [OrderTop Î±] {a : Î±} : IsCoatom a â†’ IsAtom (â‡‘OrderDual.toDual a)
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {f : Î± â†’ Î²} : Isometry f â†” âˆ€ (x y : Î±), HasDist.dist (f x) (f y) = HasDist.dist x y
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {E' : Type u_7} [innerProductSpace ð•œ E'] {v : Basis Î¹ ð•œ E} (hv : Orthonormal ð•œ â‡‘v) (f : E â‰ƒâ‚—áµ¢[ð•œ] E') : Orthonormal ð•œ â‡‘(v.map f.to_linearEquiv)
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) {x y : M} (h : â‡‘(f.to_Map) x = â‡‘(f.to_Map) y) : â‡‘g x = â‡‘g y
{Î± : Type u_1} {Î² : Type u_2} [Nontrivial Î±] {f : Î± â†’ Î²} (hF : Function.Injective f) (y : Î²) : âˆƒ (x : Î±), f x â‰  y
{Î± : Type u_1} [SemiNormedRing Î±] [NormOneClass Î±] (a : Î±) (n : â„•) : âˆ¥a ^ nâˆ¥ â‰¤ âˆ¥aâˆ¥ ^ n
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhdsWithin a (Set.Ici a) â†” âˆƒ (u : Î±) (H : u âˆˆ Set.Ioi a), Set.Ico a u âŠ† s
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {s : Set E} {x y : E} {f' : E â†’ (E â†’L[â„] â„)} (hF : âˆ€ (x : E), x âˆˆ s â†’ HasFderivWithinAt f (f' x) s x) (hs : Convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆƒ (z : E) (H : z âˆˆ Segment â„ x y), f y - f x = â‡‘(f' z) (y - x)
(p : â„•) [hp : Fact (Nat.Prime p)] {q r : â„š} : padicNorm p (q + r) â‰¤ Linear_order.max (padicNorm p q) (padicNorm p r)
{R : Type u_1} [CommRing R] : is_is_IsOpenMap â‡‘(PrimeSpectrum.comap Polynomial.c)
{Î± : Type u} {G : Type u_1} [Group G] (f g : FreeGroup Î± â†’* G) (h : âˆ€ (a : Î±), â‡‘f (FreeGroup.of a) = â‡‘g (FreeGroup.of a)) : f = g
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {f : Filter Î±} {a : Î±} (hl : Filter.IsBounded LE.le f) (hg : Filter.IsBounded GE f) (hs : f.Limsup = a) (hi : f.Liminf = a) : f â‰¤ nhds a
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {n : WithTop â„•} (hF : ContDiffOn ð•œ n f s) (g : G â†’L[ð•œ] E) : ContDiffOn ð•œ n (f âˆ˜ â‡‘g) (â‡‘g â»Â¹' s)
{M : Type u_1} [AddMonoid M] (x : M) : IsAddSubmonoid (Multiples x)
{a b c : â„} : IntervalIntegrable (Î» (x : â„), (x - c)â»Â¹) MeasureTheory.MeasureSpace.volume a b â†” a = b âˆ¨ c âˆ‰ Set.Interval a b
{Î± : Type u_1} {m : Set Î± â†’ Ennreal} {s t : Set Î±} (h : âˆ€ (u : Set Î±), (s âˆ© u).nonempty â†’ (t âˆ© u).nonempty â†’ m u = âŠ¤) : â‡‘(MeasureTheory.OuterMeasure.boundedBy m) (s âˆª t) = â‡‘(MeasureTheory.OuterMeasure.boundedBy m) s + â‡‘(MeasureTheory.OuterMeasure.boundedBy m) t
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv f x < 0) : StrictAntiOn f D
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] {f : Filter Î²} {g : Î² â†’ Î±} (h : âˆƒ (a : Î±), Filter.Tendsto g f (nhds a)) : Filter.Tendsto g f (nhds (lim f g))
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [Ring R] [AddCommGroup N] [Module R N] [NoZeroSmulDivisors R N] (p : Î¹ â†’ Submodule R N) (hp : CompleteLattice.Independent p) {v : Î¹ â†’ N} (hv : âˆ€ (i : Î¹), v i âˆˆ p i) (hv' : âˆ€ (i : Î¹), v i â‰  0) : LinearIndependent R v
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {n : WithTop â„•} {s : Set E} {f g : E â†’ ð•œ} (hF : ContDiffOn ð•œ n f s) (hg : ContDiffOn ð•œ n g s) : ContDiffOn ð•œ n (Î» (x : E), f x * g x) s
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} (is_IsOpenMap : is_is_IsOpenMap f) (Cont : Continuous f) (surj : Function.Surjective f) : quotientMap f
{M : Type u_1} [hasMul M] (S : Subsemigroup M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] [Algebra R S] [is_IsDomain S] (H : Algebra.IsIntegral R S) (P : Ideal R) [P.is_Prime] (hP : (algebraMap R S).ker â‰¤ P) : âˆƒ (Q : Ideal S), Q.is_Prime âˆ§ Ideal.comap (algebraMap R S) Q = P
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i : D.to_glue_data.J) (U : TopologicalSpace.Opens â†¥((D.to_glue_data.U i).carrier)) : D.diagram_over_IsOpen_Ï€ U i â‰« D.Î¹_Inv_AppÏ€_Eq_Map U â‰« D.Î¹_Inv_App U = ðŸ™ (CategoryTheory.Limits.limit (D.diagram_over_IsOpen U))
{ð•œ : Type u_1} [is_R_or_C ð•œ] {F : Type u_2} [semiNormedGroup F] [normedSpace ð•œ F] [normedSpace â„ F] [isScalarTower â„ ð•œ F] (fr : F â†’L[â„] â„) (x : F) : âˆ¥â‡‘(fr.to_Linear_map.extend_toð•œ') xâˆ¥ â‰¤ âˆ¥frâˆ¥ * âˆ¥xâˆ¥
{Î¹ : Type u} {X : Type v} [topologicalSpace X] {s : Set X} [NormalSpace X] (hs : is_IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ (i : Î¹), is_IsOpen (U i)) (hF : LocallyFinite U) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : BumpCovering Î¹ X s), f.is_subordinate U
{Î± : Type u_1} {n : Type u_4} {m : Type u_5} [hasZero Î±] {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} : (Matrix.fromBlocks A B C D).is_diag â†” A.is_diag âˆ§ B = 0 âˆ§ C = 0 âˆ§ D.is_diag
 : Set.Unbounded LT.lt {b : Ordinal | b.card.ord = b âˆ§ Ordinal.omega â‰¤ b}
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} (h : IsLocalExtr f a) : fderiv â„ f a = 0
{Î± : Type u} [topologicalSpace Î±] {s : Set (Î± Ã— Î±)} {x : Î±} (hx : s âˆˆ nhds (x, x)) : âˆƒ (U : Set Î±), is_IsOpen U âˆ§ x âˆˆ U âˆ§ U Ã—Ë¢ U âŠ† s
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Abelian C] [CategoryTheory.HasInjectiveResolutions C] [CategoryTheory.Abelian D] {F G : C â¥¤ D} [F.additive] [G.additive] (Î± : F âŸ¶ G) (n : â„•) {X : C} (P : CategoryTheory.injectiveResolution X) : (CategoryTheory.NatTrans.rightDerived Î± n).app X = (F.right_derived_obj_iso n P).hom â‰« (homologyFunctor D (ComplexShape.up â„•) n).map ((CategoryTheory.NatTrans.mapHomologicalComplex Î± (ComplexShape.up â„•)).app P.cocomplex) â‰« (G.right_derived_obj_iso n P).inv
{H : Type u_1} {M : Type u_2} [topologicalSpace H] [topologicalSpace M] [chartedSpace H M] {H' : Type u_3} {M' : Type u_4} [topologicalSpace H'] [topologicalSpace M'] [chartedSpace H' M'] {G : StructureGroupoid H} {G' : StructureGroupoid H'} {e e' : localHomeomorph M H} {f f' : localHomeomorph M' H'} {P : (H â†’ H') â†’ Set H â†’ H â†’ Prop} {g : M â†’ M'} {s : Set M} {x : M} (hG : G.local_invariant_prop G' P) (hE : e âˆˆ StructureGroupoid.MaximalAtlas M G) (xe : x âˆˆ e.to_local_equiv.source) (hE' : e' âˆˆ StructureGroupoid.MaximalAtlas M G) (xe' : x âˆˆ e'.to_local_equiv.source) (hF : f âˆˆ StructureGroupoid.MaximalAtlas M' G') (xf : g x âˆˆ f.to_local_equiv.source) (hF' : f' âˆˆ StructureGroupoid.MaximalAtlas M' G') (xf' : g x âˆˆ f'.to_local_equiv.source) (hgs : ContinuousWithinAt g s x) (h : P (â‡‘f âˆ˜ g âˆ˜ â‡‘(e.symm)) (e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' (s âˆ© g â»Â¹' f.to_local_equiv.source)) (â‡‘e x)) : P (â‡‘f' âˆ˜ g âˆ˜ â‡‘(e'.symm)) (e'.to_local_equiv.target âˆ© â‡‘(e'.symm) â»Â¹' (s âˆ© g â»Â¹' f'.to_local_equiv.source)) (â‡‘e' x)
{p : â„•} (hp : Nat.Prime p) {R : Type u_1} [CommRing R] [is_IsDomain R] {n : â„•} (hn : n â‰  0) (h : Irreducible (Polynomial.cyclotomic (p ^ n) R)) : Irreducible (Polynomial.cyclotomic p R)
{Î² : Type u} {Î± : Type v} {s : Finset Î±} [CommMonoid Î²] (f : Î± â†’ Î²) {p : Î± â†’ Prop} [DecidablePred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : (Finset.subtype p s).prod (Î» (x : Subtype_ p), f â†‘x) = s.prod (Î» (x : Î±), f x)
{Î± : Type u_3} {Î² : Type u_4} [linearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hF : Filter.Tendsto f l Filter.atTop) : Filter.Tendsto (Î» (x : Î²), f x * r) l Filter.atBot
{M : Type u_3} {N : Type u_4} [hasZero M] [hasZero N] {f g : ZeroHom M N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] : Function.involutive â‡‘(reflection K)
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (N : Submonoid S) (T : Type u_4) [CommRing T] [Algebra R T] [Algebra S T] [isScalarTower R S T] [IsLocalization M S] [IsLocalization N T] : IsLocalization (IsLocalization.localizationLocalizationSubmodule M N) T
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R M) (x : Orientation R M Î¹) : x â‰  e.orientation â†” x = -e.orientation
{b : â„•} {l : List â„•} (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) : Nat.ofDigits (b + 2) l < (b + 2) ^ l.length
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (t : CategoryTheory.Limits.IsTerminal X) (f : X âŸ¶ Y) : CategoryTheory.Mono f
{G : Type u} [Group G] [Fintype G] (p : â„•) {n : â„•} [Fact (Nat.Prime p)] (hdvd : p ^ n âˆ£ Fintype.card G) : âˆƒ (K : Subgroup G), Fintype.card â†¥K = p ^ n
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} {T : Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [CommMonoid Q] {k : T.localization_Map Q} (z : N) : â‡‘(f.map hy k) z * â‡‘(k.to_Map) (â‡‘g â†‘((f.sec z).snd)) = â‡‘(k.to_Map) (â‡‘g (f.sec z).fst)
{Î± : Type u_1} [CancelCommMonoidWithZero Î±] [dec_irr : Î  (p : Associates Î±), Decidable (Irreducible p)] [UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {p a : Associates Î±} (hp : Irreducible p) {n : â„•} (h : a âˆ£ p ^ n) : a = p ^ p.count a.factors
{n : â„•} (p : Fin (n + 1)) (i : Fin n) : p < â‡‘(p.succ_above) i â†” p â‰¤ â‡‘fin.cast_Succ i
{Î± : Type u_1} [AddCommMonoid Î±] (m M N : â„•) (f : (Î£ (n : â„•), Fin n â†’ â„•) â†’ Î±) (g : (Î£ (n : â„•), Composition n) â†’ Î±) (h : âˆ€ (e : Î£ (n : â„•), Fin n â†’ â„•) (hE : e âˆˆ FormalMultilinearSeries.compPartialSumSource m M N), f e = g (FormalMultilinearSeries.compChangeOfVariables m M N e hE)) : (FormalMultilinearSeries.compPartialSumSource m M N).sum (Î» (e : Î£ (n : â„•), Fin n â†’ â„•), f e) = (FormalMultilinearSeries.compPartialSumTarget m M N).sum (Î» (e : Î£ (n : â„•), Composition n), g e)
{K : Type u} [Field K] (s : Subfield K) {x : K} : x âˆˆ s â†’ -x âˆˆ s
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} {T : addSubmonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [AddCommMonoid Q] {k : T.localization_Map Q} {A : Type u_5} [AddCommMonoid A] {U : addSubmonoid A} {R : Type u_6} [AddCommMonoid R] (j : U.localization_Map R) {l : P â†’+ A} (hl : âˆ€ (w : â†¥T), â‡‘l â†‘w âˆˆ U) (x : N) : â‡‘(k.map hl j) (â‡‘(f.map hy k) x) = â‡‘(f.map _ j) x
{Î± : Type u_1} {Î´ : Type u_5} [topologicalSpace Î±] [measurableSpace Î±] [BorelSpace Î±] [measurableSpace Î´] [completeLinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_2} {Î¹' : Type u_3} {f : Î¹ â†’ Î´ â†’ Î±} {u : Filter Î¹} (hF : âˆ€ (i : Î¹), Measurable (f i)) {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set Î¹} (hu : u.has_countable_Basis p s) (hs : âˆ€ (i : Î¹'), (s i).countable) : Measurable (Î» (x : Î´), u.liminf (Î» (i : Î¹), f i x))
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : hb.oangle (-x) y + hb.oangle (-y) x = 0
{Î± : Type u} [pseudoEmetricSpace Î±] (Î´ : â„) (E : Set Î±) : Closure E âŠ† Metric.Cthickening Î´ E
(R : Type u_1) [Ring R] : algebraMap â„¤ R = Int.castRingHom R
{Î¹ : Type u} {X : Type v} [topologicalSpace X] {s : Set X} [NormalSpace X] (hs : is_IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ (i : Î¹), is_IsOpen (U i)) (hF : LocallyFinite U) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : PartitionOfUnity Î¹ X s), f.is_subordinate U
{n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3
{Gâ‚€ : Type u_2} [groupWithZero Gâ‚€] (a : Gâ‚€) : a * aâ»Â¹ * a = a
(ð•œ : Type u_1) (E : Type u_2) [is_R_or_C ð•œ] [innerProductSpace ð•œ E] : GaloisConnection Submodule.orthogonal Submodule.orthogonal
{M : Type u_1} [hasAdd M] {s : Set M} : s âŠ† â†‘(AddSubsemigroup.closure s)
 : Dense {x : â„ | Liouville x}
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {b : M} [linearOrderedCommRing M] (ht : t.nonempty) (hb : â†‘(s.card) â‰¤ t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), â†‘((Finset.filter (Î» (x : Î±), f x = y) s).card) â‰¤ b
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] (h : âˆ€ (x : E), Module.rank F â†¥FâŸ®xâŸ¯ = 1) : âŠ¥ = âŠ¤
{Î± : Type u_1} {r : Setoid Î±} {x y : Î±} : Quotient.mk' x = Quotient.mk' y â†” r.rel x y
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : f =o[l] g' â†’ (f =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {u : â„• â†’ E} {l : E} (h : Filter.Tendsto u Filter.atTop (nhds l)) : Filter.Tendsto (Î» (n : â„•), (â†‘n)â»Â¹ â€¢ (Finset.range n).sum (Î» (i : â„•), u i)) Filter.atTop (nhds l)
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a u' : Î±} {s : Set Î±} (hu' : a < u') : s âˆˆ nhdsWithin a (Set.Ici a) â†” âˆƒ (u : Î±) (H : u âˆˆ Set.Ioi a), Set.Ico a u âŠ† s
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x y + hb.oangle y z + hb.oangle z x = 0
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : EuclideanGeometry.angle p1 p2 p3 = EuclideanGeometry.angle p3 p2 p1
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] (y : R) [Algebra R S] [IsLocalization.Away y S] [H : Ideal.IsJacobson R] : Ideal.IsJacobson S
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [CharZero k] {s : Finset Î¹} (p : Î¹ â†’ P) (h : s.nonempty) : Finset.centroid k s p âˆˆ affineSpan k (Set.Range p)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (h : s.sum (Î» (i : Î¹), w i) = 0) (bâ‚ bâ‚‚ : P) : â‡‘(s.weighted_vsub_of_point p bâ‚) w = â‡‘(s.weighted_vsub_of_point p bâ‚‚) w
(R : Type u_1) [CommRing R] (M : Type u_2) [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [Nontrivial R] : â‡‘(LinearMap.trace R M) 1 = â†‘(FiniteDimensional.finrank R M)
{Î± : Type u_1} {Î² : Type u_2} [MulOneClass Î±] [CommGroup Î²] {f : Î± â†’ Î²} (hF : IsMonoidHom f) : IsMonoidHom (Î» (a : Î±), (f a)â»Â¹)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace F] (p : FormalMultilinearSeries ð•œ E F) {x y : E} (h : â†‘âˆ¥xâˆ¥â‚Š + â†‘âˆ¥yâˆ¥â‚Š < p.radius) : (p.change_origin x).sum y = p.sum (x + y)
{G : Type u} [CategoryTheory.Groupoid G] [IsFreeGroupoid G] {a b : G} : Nonempty (a âŸ¶ b) â†’ Nonempty (Quiver.Path (symgen a) (symgen b))
{K : Type u_4} {V : Type u} {V' : Type u_8} [Field K] [AddCommGroup V] [AddCommGroup V'] [Module K V] [Module K V'] {p : Submodule K V} (f : â†¥p â†’â‚—[K] V') : âˆƒ (g : V â†’â‚—[K] V'), g.comp p.subtype = f
(R : Type u) [Semiring R] (q : â„•) [hp : Char_p R 0] [hq : ExpChar R q] : q = 1
{Î± : Type u_3} {Î² : Type u_4} [linearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hF : Filter.Tendsto f l Filter.atBot) : Filter.Tendsto (Î» (x : Î²), r * f x) l Filter.atTop
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} [uniformSpace Î³] {g : Î² â†’ Î³} (h : TendstoUniformlyOn F f p s) (hg : UniformContinuous g) : TendstoUniformlyOn (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ f) p s
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {s : Set E} {x : E} {f' : TangentSpace (modelWithCornersSelf ð•œ E) x â†’L[ð•œ] TangentSpace (modelWithCornersSelf ð•œ E') (f x)} : HasMfderivWithinAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f s x f' â†’ HasFderivWithinAt f f' s x
{n : â„•} {i j : Fin (n + 1)} (H : i â‰¤ j) : SimplexCategoryÏƒ (â‡‘fin.cast_Succ i) â‰« SimplexCategoryÏƒ j = SimplexCategoryÏƒ j.succ â‰« SimplexCategoryÏƒ i
{R : Type u_1} {S : Type u_4} [CommRing R] [CommRing S] (f : R â†’+* S) (p : Polynomial R) (x : S) (h : Polynomial.evalâ‚‚ f x p = 0) : f.is_integral_elem (â‡‘f p.leading_Coeff * x)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â‰ƒL[ð•œ] F} {g : F â†’ E} {a : F} (hg : ContinuousAt g a) (hF : HasFderivAt f â†‘f' (g a)) (hfg : âˆ€á¶  (y : F) in nhds a, f (g y) = y) : HasFderivAt g â†‘(f'.symm) a
{Î± : Type u_1} [linearOrderedField Î±] {a b c d : Î±} (hc : c â‰  0) (hD : d â‰  0) : a / c â‰¤ b / d â†’ (a * d - b * c) / (c * d) â‰¤ 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s1 s2 : AffineSubspace k P) : Â¬s1 â‰¤ s2 â†” âˆƒ (p : P) (H : p âˆˆ s1), p âˆ‰ s2
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) : v.int_Valuation_def 1 = 1
{Î± : Type u_1} [CommMonoid Î±] {a b : Î±} {u : Î±Ë£} : â†‘u * a âˆ£ b â†” a âˆ£ b
{M : Type u_1} {R : Type u_4} [NonUnitalNonAssocSemiring R] [SetLike M R] [mulMemClass M R] {S : M} {a b : R} (ha : a âˆˆ AddSubmonoid.closure â†‘S) (hb : b âˆˆ S) : a * b âˆˆ AddSubmonoid.closure â†‘S
(z : â„‚) : â†‘(z.re) = (z + â‡‘(starRingEnd â„‚) z) / 2
{m : Type u_2} {n : Type u_3} {R : Type u_7} {Î± : Type v} [hasStar R] [hasStar Î±] [HasScalar R Î±] [StarModule R Î±] (c : R) (M : Matrix m n Î±) : (c â€¢ M).conj_transpose = HasStar.star c â€¢ M.conj_transpose
{n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i â‰¤ â‡‘fin.cast_Succ j) : SimplexCategoryÎ´ (â‡‘fin.cast_Succ i) â‰« SimplexCategoryÏƒ j.succ = SimplexCategoryÏƒ j â‰« SimplexCategoryÎ´ i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] (f : J â†’ C) [CategoryTheory.Limits.HasProduct f] : CategoryTheory.Limits.HasBiproduct f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace F] [CompleteSpace E] (g : E â†’â‚—[ð•œ] F) (hg : is_IsClosed â†‘(g.graph)) : Continuous â‡‘g
{ð•œ : Type u_1} {E : Type u_2} [normedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [HasContinuousSmul ð•œ E] : â‹ƒâ‚€setOf (bornology.is_vonN_bounded ð•œ) = Set.Univ
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {a : Î±} : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ {a}), f i)) = f a
{R : Type u_1} [normedRing R] [CompleteSpace R] : is_IsOpen {x : R | IsUnit x}
{M : Type u_1} {N : Type u_2} [MulOneClass M] [MulOneClass N] {f g : M â†’* N} {s : Set M} (h : Set.EqOn â‡‘f â‡‘g s) : Set.EqOn â‡‘f â‡‘g â†‘(Submonoid.closure s)
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [is_R_or_C ð•‚] [normedRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] {x y : ð”¸} (hxy : Commute x y) : Exp ð•‚ (x + y) = Exp ð•‚ x * Exp ð•‚ y
{M : Type u_3} {N : Type u_4} [MulZeroOneClass M] [MulZeroOneClass N] {f g : M â†’*â‚€ N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
{R : Type u_1} {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K] [is_IsDomain R] [IsDedekindDomain R] [Fintype (ClassGroup R K)] : Fintype.card (ClassGroup R K) = 1 â†” IsPrincipalIdealRing R
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
{Î± : Type u} [Ring Î±] {a b : Î±} : a âˆ£ a + b â†” a âˆ£ b
{Î¹ : Type w} {R : Type u} [Ring R] [RankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {J : Set M} (v : Basis Î¹ R M) (hJ : Submodule.span R J = âŠ¤) : Cardinal.mk â†¥(Set.Range â‡‘v) â‰¤ Cardinal.mk â†¥J
{R : Type u} [Ring R] {s : Set R} {p : R â†’ Prop} {x : R} (h : x âˆˆ Subring.closure s) (Hs : âˆ€ (x : R), x âˆˆ s â†’ p x) (H0 : p 0) (H1 : p 1) (HAdd : âˆ€ (x y : R), p x â†’ p y â†’ p (x + y)) (Hneg : âˆ€ (x : R), p x â†’ p (-x)) (HMul : âˆ€ (x y : R), p x â†’ p y â†’ p (x * y)) : p x
{p : Prop} (a : Erased p) : p
{Î± : Type u_1} {Î¹ : Type u_4} [LinearOrder Î±] [DecidableEq Î¹] (f : Î¹ â†’ Î±) {p : Finset Î¹ â†’ Prop} (s : Finset Î¹) (h0 : p âˆ…) (step : âˆ€ (a : Î¹) (s : Finset Î¹), a âˆ‰ s â†’ (âˆ€ (x : Î¹), x âˆˆ s â†’ f a â‰¤ f x) â†’ p s â†’ p (HasInsert.insert a s)) : p s
{M : Type u_1} [AddMonoid M] {Î¹ : Type u_2} [hÎ¹ : Nonempty Î¹] {s : Î¹ â†’ Set M} (hs : âˆ€ (i : Î¹), IsAddSubmonoid (s i)) (Directed : âˆ€ (i j : Î¹), âˆƒ (k : Î¹), s i âŠ† s k âˆ§ s j âŠ† s k) : IsAddSubmonoid (â‹ƒ (i : Î¹), s i)
{Î± : Type u_1} {Î¹ : Type u_2} {Î¹' : Type u_3} [Lattice Î±] [OrderBot Î±] {s : Set Î¹'} {g : Î¹' â†’ Finset Î¹} {f : Î¹ â†’ Î±} (hs : s.pairwise_Disjoint (Î» (i' : Î¹'), (g i').sup f)) (hg : âˆ€ (i : Î¹'), i âˆˆ s â†’ â†‘(g i).pairwise_Disjoint f) : (â‹ƒ (i : Î¹') (H : i âˆˆ s), â†‘(g i)).pairwise_Disjoint f
{G : Type u_1} [DivInvMonoid G] (a b : G) : a / b = a * bâ»Â¹
(x : â„¤) : â†‘(x.nat_Abs) ^ 2 = x ^ 2
(R : Type u) (M : Type v) [CommRing R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] (N : Type v) [AddCommGroup N] [Module R N] [Module.Free R N] : Module.rank R (tensorProduct R M N) = Module.rank R M * Module.rank R N
{F : Type u_3} [innerProductSpace â„ F] {x y : F} (h : HasInner.inner x y = 0) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R (r â€¢ x) y
{C : Type u} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryCoproduct A B] [CategoryTheory.Limits.HasBinaryCoproduct A' B'] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')] (f : A âŸ¶ A') (g : B âŸ¶ B') [CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)] [CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A' B')] : CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B) â‰« CategoryTheory.Limits.coprod.map (F.map f) (F.map g) = F.map (CategoryTheory.Limits.coprod.map f g) â‰« CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A' B')
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {X Y Z : C} (a : X âŸ¶ Z) (b : Y âŸ¶ Z) [CategoryTheory.Mono a] [CategoryTheory.Mono b] : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan a b)
{Î± : Type u} {Î² : Type v} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} (hinf : a â‰¤ f.liminf u) (hsup : f.limsup u â‰¤ a) (h : Filter.IsBoundedUnder LE.le f u . "is_bounded_Default") (h' : Filter.IsBoundedUnder GE f u . "is_bounded_Default") : Filter.Tendsto u f (nhds a)
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (t : CategoryTheory.Limits.IsInitial X) (f g : X âŸ¶ Y) : f = g
{M : Type u_5} [AddCommMonoid M] (h : Module â„• M) (n : â„•) (x : M) : n â€¢ x = n â€¢ x
{ð•œ : Type u_1} [linearOrderedField ð•œ] {x : ð•œ} {s : Set ð•œ} (hx : x âˆˆ s) : StarConvex ð•œ x s â†’ s.ord_connected
{ð•œ : Type u_1} {E : Type u_2} [SemiNormedRing ð•œ] [AddCommGroup E] [Module ð•œ E] {t t' : topologicalSpace E} (h : t â‰¤ t') {s : Set E} (hs : bornology.is_vonN_bounded ð•œ s) : bornology.is_vonN_bounded ð•œ s
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {f : Î± â†’ Î²} (hF : Isometry f) (x y : Î±) : HasDist.dist (f x) (f y) = HasDist.dist x y
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (f : E â†’L[ð•œ] F) [CompleteSpace F] [CompleteSpace E] (surj : Function.Surjective â‡‘f) : is_is_IsOpenMap â‡‘f
 : Real.sin (Real.pi / 6) = 1 / 2
{C : Type uâ‚} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : CategoryTheory.Presieve.IsSheafFor P â‡‘S) (f : S.functor âŸ¶ P) : S.functor_inclusion â‰« h.extend f = f
(q : â„š) : (GeneralizedContinuedFraction.of q).terminates
{R : Type v} [CommRing R] {n : â„•} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R} (c : Fin n â†’ R) (A_Zero : âˆ€ (j : Fin (n + 1)), A 0 j = B 0 j) (A_Succ : âˆ€ (i : Fin n) (j : Fin (n + 1)), A i.succ j = B i.succ j + c i * A (â‡‘fin.cast_Succ i) j) : A.det = B.det
{E : Type u} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] (f g : â„ Ã— â„ â†’ E) (f' g' : â„ Ã— â„ â†’ (â„ Ã— â„ â†’L[â„] E)) (a b : â„ Ã— â„) (hle : a â‰¤ b) (s : Set (â„ Ã— â„)) (hs : s.countable) (Hcf : ContinuousOn f (Set.Icc a b)) (Hcg : ContinuousOn g (Set.Icc a b)) (Hdf : âˆ€ (x : â„ Ã— â„), x âˆˆ Set.Ioo a.fst b.fst Ã—Ë¢ Set.Ioo a.snd b.snd  s â†’ HasFderivAt f (f' x) x) (Hdg : âˆ€ (x : â„ Ã— â„), x âˆˆ Set.Ioo a.fst b.fst Ã—Ë¢ Set.Ioo a.snd b.snd  s â†’ HasFderivAt g (g' x) x) (Hi : MeasureTheory.IntegrableOn (Î» (x : â„ Ã— â„), â‡‘(f' x) (1, 0) + â‡‘(g' x) (0, 1)) (Set.Icc a b) MeasureTheory.MeasureSpace.volume) : âˆ« (x : â„ Ã— â„) in Set.Icc a b, â‡‘(f' x) (1, 0) + â‡‘(g' x) (0, 1) = (((âˆ« (x : â„) in a.fst..b.fst, g (x, b.snd)) - âˆ« (x : â„) in a.fst..b.fst, g (x, a.snd)) + âˆ« (y : â„) in a.snd..b.snd, f (b.fst, y)) - âˆ« (y : â„) in a.snd..b.snd, f (a.fst, y)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {E' : Type u_6} [NormedGroup E'] [normedSpace ð•œ E'] {F' : Type u_7} [NormedGroup F'] [normedSpace ð•œ F'] {f : E â†’ F} {g : E' â†’ F'} {p : E Ã— E'} (hF : ContDiffAt ð•œ n f p.fst) (hg : ContDiffAt ð•œ n g p.snd) : ContDiffAt ð•œ n (Prod.map f g) p
{E : Type u_2} {ð•œ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] {s : Set E} (hs : Convex ð•œ s) {x y : E} (hx : x âˆˆ Closure s) (hy : x + y âˆˆ Interior s) {t : ð•œ} (ht : t âˆˆ Set.Ioc 0 1) : x + t â€¢ y âˆˆ Interior s
{Î± : Type u} {s : Set Î±} : s.countable â†” âˆƒ (f : Î± â†’ â„•), Set.InjOn f s
{Î± : Type u_1} {Î³ : Type u_3} [topologicalSpace Î±] [measurableSpace Î±] [OpensMeasurableSpace Î±] [topologicalSpace Î³] [measurableSpace Î³] [BorelSpace Î³] {f : Î± â†’ Î³} (hF : Continuous f) : Measurable f
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (q n m : â„•) (hnm : algebraic_topology.dold_kan.c.rel m n) {X Y : CategoryTheory.SimplicialObject C} (f : X âŸ¶ Y) : f.app (Opposite.op (SimplexCategory.mk n)) â‰« algebraic_topology.dold_kan.hÏƒ' q n m hnm = algebraic_topology.dold_kan.hÏƒ' q n m hnm â‰« f.app (Opposite.op (SimplexCategory.mk m))
(R L : Type u) [CommRing R] [CommRing L] [is_IsDomain L] [Algebra R L] [NoZeroSmulDivisors R L] (halg : Algebra.IsAlgebraic R L) : Cardinal.mk L â‰¤ Linear_order.max (Cardinal.mk R) Cardinal.aleph_0
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : Set.MapsTo f (Function.FixedPoints (g âˆ˜ f)) (Function.FixedPoints (f âˆ˜ g))
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteBiproducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {sâ‚ sâ‚‚ : AffineSubspace â„ P} [Nonempty â†¥sâ‚] [CompleteSpace â†¥(sâ‚.direction)] (hle : sâ‚ â‰¤ sâ‚‚) {p : P} (hp : p âˆˆ sâ‚‚) : â‡‘(EuclideanGeometry.reflection sâ‚) p âˆˆ sâ‚‚
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b c : Î±} : b < -a + c â†’ a + b < c
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {n : WithTop â„•} (h : ContDiff ð•œ n f) (hn : 1 â‰¤ n) : Continuous (Î» (p : E Ã— E), â‡‘(fderiv ð•œ f p.fst) p.snd)
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] [discreteTopology Î±] {f : Î± â†’ Î² â†’ Î³} (hF : âˆ€ (a : Î±), Continuous (f a)) : Continuous (Function.uncurry f)
(M : Type u_1) (Î± : Type u_2) [Monoid M] [mulAction M Î±] {Î¹ : sort u_3} {P : Î¹ â†’ Submonoid M} : MulAction.FixedPoints â†¥(supr P) Î± = â‹‚ (i : Î¹), MulAction.FixedPoints â†¥(P i) Î±
{K : Type u_1} {n : â„•} {s : Seq (GeneralizedContinuedFraction.Pair K)} [divisionRing K] {m : â„•} (m_Lt_n : m < n) : (GeneralizedContinuedFraction.squashSeq s n).nth m = s.nth m
{ð•œ : Type u_1} {E : Type u_2} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] {pâ‚ pâ‚‚ : FormalMultilinearSeries ð•œ ð•œ E} {f : ð•œ â†’ E} {x : ð•œ} (hâ‚ : HasFpowerSeriesAt f pâ‚ x) (hâ‚‚ : HasFpowerSeriesAt f pâ‚‚ x) : pâ‚ = pâ‚‚
(p q r : â„•+) : 1 < ADE_inequality.sum_Inv {p, q, r} â†” ADE_inequality.admissible {p, q, r}
{Î± : Type u_3} {Î² : Type u_4} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Monotone f) (h : âˆ€ (b : Î²), âˆƒ (a : Î±), f a â‰¤ b) : Filter.Tendsto f Filter.atBot Filter.atBot
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : F â†’ G} {x : E} {y : F} (hF : ContDiffAt ð•œ n f y) : ContDiffAt ð•œ n (Î» (x : E Ã— F), f x.snd) (x, y)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : hb.oangle x (â‡‘(hb.rotation Î¸) y) = hb.oangle x y + Î¸
{J : Type v} {C : Type u} [CategoryTheory.Category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [Nonempty J] {c : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.parallelFamily f)} (i : CategoryTheory.Limits.IsColimit c) : CategoryTheory.Epi (c.Î¹.app CategoryTheory.Limits.WalkingParallelFamily.one)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P (n + 1)) (i : Fin (n + 2)) : FiniteDimensional.finrank â„ â†¥((s.altitude i).direction) = 1
(x y : Pgame) : (x * y).equiv (y * x)
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [denselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [topologicalSpace Î´] [OrderClosedTopology Î´] {f : Î± â†’ Î´} {s : Set Î±} [s.ord_connected] (hs : s.nonempty) (hF : ContinuousOn f s) (hbot : Filter.Tendsto (Î» (x : â†¥s), f â†‘x) Filter.atBot Filter.atBot) (htop : Filter.Tendsto (Î» (x : â†¥s), f â†‘x) Filter.atTop Filter.atTop) : Set.SurjOn f s Set.Univ
{E : Type u_1} [innerProductSpace â„ E] {n : â„•} [Fact (FiniteDimensional.finrank â„ E = n + 1)] : ContMdiff (modelWithCornersSelf â„ (EuclideanSpace â„ (Fin n))) (modelWithCornersSelf â„ E) âŠ¤ Coe
(p : â„ Ã— â„) (hp : 0 < p.fst) : HasStrictFderivAt (Î» (x : â„ Ã— â„), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) â€¢ ContinuousLinearMap.fst â„ â„ â„ + (p.fst ^ p.snd * Real.log p.fst) â€¢ ContinuousLinearMap.snd â„ â„ â„) p
{Î± : Type u_1} [normedDivisionRing Î±] {a : Î±} (ha : a â‰  0) : Filter.Tendsto (Mul.mul a) (Filter.comap HasNorm.norm Filter.atTop) (Filter.comap HasNorm.norm Filter.atTop)
{Î± : Type u_1} [hasMul Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {b c : Î±} (bc : b < c) (a : Î±) : a * b < a * c
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x z - hb.oangle y z = hb.oangle x y
(A : Type u_4) [CommRing A] [is_IsDomain A] {L : Type u_6} [Field L] [Algebra A L] (C : Type u_7) [CommRing C] [is_IsDomain C] [Algebra C L] [IsIntegralClosure C A L] [Algebra A C] [isScalarTower A C L] (alg : Algebra.IsAlgebraic A L) (inj : âˆ€ (x : A), â‡‘(algebraMap A L) x = 0 â†’ x = 0) : IsFractionRing C L
{Î± : Type u} [Preorder Î±] (a : Î±) : a â‰¤ a
{F : Type u_3} [innerProductSpace â„ F] (x y : F) : HasInner.inner x y â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{E : Type u_1} {PE : Type u_2} [NormedGroup E] [normedSpace â„ E] [metricSpace PE] [NormedAddTorsor E PE] {F : Type u_3} {PF : Type u_4} [NormedGroup F] [normedSpace â„ F] [metricSpace PF] [NormedAddTorsor F PF] (f : PE â‰ƒáµ¢ PF) (x y : PE) : â‡‘f (midpoint â„ x y) = midpoint â„ (â‡‘f x) (â‡‘f y)
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [divisionRing R] [divisionRing S] [Module R E] [Module S E] (n : â„•) (x : E) : (â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
(k : Type u_1) (G : Type u_2) [CommSemiring k] [Group G] [Fintype G] [Invertible â†‘(Fintype.card G)] (g : G) : Finsupp.single g 1 * GroupAlgebra.average k G = GroupAlgebra.average k G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] (X : C) : CategoryTheory.Simple X â†” IsSimpleOrder (CategoryTheory.Subobject X)
{Î± : Type u_1} [SemiNormedRing Î±] (a : Î±) {n : â„•} : 0 < n â†’ âˆ¥a ^ nâˆ¥â‚Š â‰¤ âˆ¥aâˆ¥â‚Š ^ n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X âŸ¶ Y) [CategoryTheory.Limits.HasBinaryBiproduct X X] : f + g = CategoryTheory.Limits.biprod.lift (ðŸ™ X) (ðŸ™ X) â‰« CategoryTheory.Limits.biprod.desc f g
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : Function.Injective f â†” setoid.ker f = âŠ¥
{Î± : Type u_1} {G : Type u_4} {s : Set Î±} [divisionCommMonoid G] (f g : Î± â†’ G) (hs : s.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i / g i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) / finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), g i))
{Î± : Type u_1} [pseudoMetricSpace Î±] (x y : Î±) : HasEdist.edist x y < âŠ¤
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (f : R â†’+* S) (r : R) : â‡‘Polynomial.c (â‡‘f r) âˆˆ Polynomial.lifts f
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} : Monotone (Set.image f)
{k : Type u_1} {K : Type u_2} [Field k] [IsAlgClosed k] [Field K] {f : K â†’+* k} (p : Polynomial K) : Polynomial.Splits f p
{Î± : Type u_1} {Î¹ : Type u_3} [completeLattice Î±] [Fintype Î¹] {f : Î¹ â†’ Î±} : finset.univ.sup_indep f â†’ CompleteLattice.Independent f
{Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} : lâ‚ <+: lâ‚‚ â†’ lâ‚.reverse <:+ lâ‚‚.reverse
 : Filter.Tendsto (Î» (x : â„), Real.exp (-x)) Filter.atTop (nhds 0)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’â‚€ ð•œ) (i : Î¹) : HasInner.inner (â‡‘(Finsupp.total Î¹ E ð•œ v) l) (v i) = â‡‘(starRingEnd ð•œ) (â‡‘l i)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall f p x r) (h : â†‘r' < r) : âˆƒ (a : â„) (H : a âˆˆ Set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (y : E), y âˆˆ Metric.Ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥f (x + y) - p.partial_Sum n yâˆ¥ â‰¤ C * (a * (âˆ¥yâˆ¥ / â†‘r')) ^ n
{R : Type u_1} [normedRing R] [CompleteSpace R] : is_is_IsOpenMap Coe
{ð•‚ : Type u_1} [is_R_or_C ð•‚] {x : ð•‚} : HasStrictDerivAt (Exp ð•‚) (Exp ð•‚ x) x
{n : â„•} {l : List â„•} (hâ‚ : l.prod = n) (hâ‚‚ : âˆ€ (p : â„•), p âˆˆ l â†’ Nat.Prime p) : l ~ n.factors
{Î± : Type u} [Preorder Î±] {x y : Î±} (h : x = y) : y â‰¤ x
 : Â¬set.univ.countable
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {n : WithTop â„•} (h : ContDiff ð•œ n f) (hn : 1 â‰¤ n) : Differentiable ð•œ f
{S : Type u} [Semigroup S] {a b x y z : S} (ha : SemiconjBy a y z) (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z
{ð•œ : Type u_1} {E : Type u_2} [SemiNormedRing ð•œ] [HasScalar ð•œ E] [hasZero E] [topologicalSpace E] {sâ‚ sâ‚‚ : Set E} (hsâ‚ : bornology.is_vonN_bounded ð•œ sâ‚) (hsâ‚‚ : bornology.is_vonN_bounded ð•œ sâ‚‚) : bornology.is_vonN_bounded ð•œ (sâ‚ âˆª sâ‚‚)
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] {F : Type v} [NormedGroup F] [normedSpace â„‚ F] [Nontrivial E] {f g : E â†’ F} {U : Set E} (hU : Metric.Bounded U) (hF : DiffContOnCl â„‚ f U) (hg : DiffContOnCl â„‚ g U) (hfg : Set.EqOn f g (Frontier U)) : Set.EqOn f g (Closure U)
{R : Type u} [Semiring R] (r : R) (n : â„•) : Polynomial.x ^ n * â‡‘Polynomial.c r = â‡‘Polynomial.c r * Polynomial.x ^ n
{ð•œ : Type u_1} {E : Type u_3} [normedField ð•œ] [AddCommGroup E] [Module ð•œ E] {A : Set E} (hA : Balanced ð•œ A) : Absorbs ð•œ A A
{V : Type u_9} {K : Type u_10} [Field K] [AddCommGroup V] [Module K V] (B : BilinForm K V) (bâ‚ : B.nondegenerate) (bâ‚‚ : B.is_refl) {x : V} (hx : Â¬B.is_IsOrtho x x) : (B.restrict (B.orthogonal (Submodule.span K {x}))).nondegenerate
{Î± : sort u_1} {Î² : sort u_2} {f : Î± â†’ Î²} (hF : Function.bijective f) (b : Î²) : âˆƒ! (a : Î±), f a = b
{Î± : Type u} [Preorder Î±] {a b : Î±} : a = b â†’ a â‰¤ b
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : HasDist.dist p1 p2 = HasDist.dist p1 p3) : EuclideanGeometry.angle p1 p2 p3 = EuclideanGeometry.angle p1 p3 p2
{x y z : â„¤} (h : PythagoreanTriple x y z) (k : â„¤) : PythagoreanTriple (k * x) (k * y) (k * z)
{Î± : Type u_1} {Î¹ : sort u_3} [conditionallyCompleteLattice Î±] {f : Î¹ â†’ Î±} (H : BddAbove (Set.Range f)) (c : Î¹) : f c â‰¤ supr f
{C : Type u} [CategoryTheory.CategoryStruct C] {X Y : CategoryTheory.LocallyDiscrete C} {f g : X âŸ¶ Y} (Î· : f âŸ¶ g) : f = g
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {F : Type u_2} [NormedGroup F] [normedSpace â„ F] {f : E â†’ F} {s : Set E} {x : E} {f' : E â†’L[â„] F} (f_Diff : DifferentiableOn â„ f s) (s_conv : Convex â„ s) (s_IsOpen : is_IsOpen s) (f_Cont : âˆ€ (y : E), y âˆˆ Closure s â†’ ContinuousWithinAt f s y) (h : Filter.Tendsto (Î» (y : E), fderiv â„ f y) (nhdsWithin x s) (nhds f')) : HasFderivWithinAt f f' (Closure s) x
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {Î¹ : Type u_3} [hne : Nonempty Î¹] [Fintype Î¹] {p : Î¹ â†’ P} (ha : AffineIndependent â„ p) : âˆƒ! (cccr : P Ã— â„), cccr.fst âˆˆ affineSpan â„ (Set.Range p) âˆ§ âˆ€ (i : Î¹), HasDist.dist (p i) cccr.fst = cccr.snd
{Î± : Type u_1} [PartialOrder Î±] [succOrder Î±] {a : Î±} : IsMax a â†’ Order.succ a = a
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (i1 : Î¹) : AffineIndependent k p â†” LinearIndependent k (Î» (i : {x // x â‰  i1}), p â†‘i -áµ¥ p i1)
{Î¹ : Type u_1} {Î± : Type u_2} {E : Type u_3} [semiNormedGroup E] {f : Î¹ â†’ E} (hF : Summable (Î» (a : Î¹), âˆ¥f aâˆ¥)) {s : Î± â†’ Finset Î¹} {p : Filter Î±} [p.ne_IsBot] (hs : Filter.Tendsto s p Filter.atTop) {a : E} (ha : Filter.Tendsto (Î» (b : Î±), (s b).sum (Î» (i : Î¹), f i)) p (nhds a)) : HasSum f a
{Î± : Type u_1} {M : Type u_5} [hasZero M] {f g : Î± â†’â‚€ M} (h : f = g) (a : Î±) : â‡‘f a = â‡‘g a
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±} [topologicalSpace Î±] (h : TendstoUniformly F f p) (hF : ContinuousAt f x) (hg : Filter.Tendsto g p (nhds x)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.IsPreconnected J] {X Y : C} (Î± : (CategoryTheory.Functor.const J).obj X âŸ¶ (CategoryTheory.Functor.const J).obj Y) (j j' : J) : Î±.app j = Î±.app j'
{Î² Î± : Type u} (f : Î² â†’ Î±) (Î¸ : Cardinal) (hÎ¸ : Î¸ â‰¤ Cardinal.mk Î²) (hâ‚ : Cardinal.aleph_0 â‰¤ Î¸) (hâ‚‚ : Cardinal.mk Î± < Î¸.ord.cof) : âˆƒ (a : Î±), Î¸ â‰¤ Cardinal.mk â†¥(f â»Â¹' {a})
{F : Type u_1} [Field F] (p q : Polynomial F) : Function.Injective â‡‘(Polynomial.Gal.restrictProd p q)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} [DecidableEq Î¹] [FiniteDimensional ð•œ E] {V : Î¹ â†’ Submodule ð•œ E} (hV : OrthogonalFamily ð•œ (Î» (i : Î¹), (V i).subtypeâ‚—áµ¢)) : DirectSum.IsInternal V â†” (supr V)á—® = âŠ¥
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] {F : Type w} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace ð•œ] {Î¹ : Type u_1} [Fintype Î¹] (v : Basis Î¹ ð•œ E) : âˆƒ (C : Nnreal) (H : C > 0), âˆ€ {u : E â†’L[ð•œ] F} (M : Nnreal), (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥â‚Š â‰¤ M) â†’ âˆ¥uâˆ¥â‚Š â‰¤ C * M
{X : Type u} [Lattice X] [JordanHolderLattice X] (s : CompositionSeries X) (x : X) (hm : JordanHolderLattice.IsMaximal x s.top) (hb : s.bot â‰¤ x) : âˆƒ (t : CompositionSeries X), t.bot = s.bot âˆ§ t.length + 1 = s.length âˆ§ âˆƒ (htx : t.top = x), s.equivalent (t.snoc s.top _)
(F : Type u) (K : Type v) (A : Type w) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [Module K A] [Module F A] [isScalarTower F K A] [FiniteDimensional F K] : FiniteDimensional.finrank F K * FiniteDimensional.finrank K A = FiniteDimensional.finrank F A
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscreteNormedField ð•‚] [normedRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] (h : 0 < (expSeries ð•‚ ð”¸).radius) : HasFderivAt (Exp ð•‚) 1 0
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] {b : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.some b) : b * (GeneralizedContinuedFraction.of v).denominators n â‰¤ (GeneralizedContinuedFraction.of v).denominators (n + 1)
{G : Type u} [Group G] [Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] (hdvd : p ^ (n + 1) âˆ£ Fintype.card G) {H : Subgroup G} (hH : Fintype.card â†¥H = p ^ n) : p âˆ£ Fintype.card (â†¥(H.normalizer) â§¸ Subgroup.comap H.normalizer.subtype H)
{F : Type u_3} [Field F] [Fintype F] (hF : ringChar F â‰  2) {a : F} (ha : a â‰  0) : IsSquare a â†” a ^ (Fintype.card F / 2) = 1
(k : Type u_1) [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) : Finset.centroidWeights k s = Function.const Î¹ (â†‘(s.card))â»Â¹
{x y : SimplexCategory} {f : x âŸ¶ y} : CategoryTheory.Mono f â†’ x.len â‰¤ y.len
(n : â„•) : (1 + n).pred = n
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [LinearOrder Î²] [succOrder Î²] [IsSuccArchimedean Î²] {s : Î² â†’ Set Î±} (H : âˆ€ (n : Î²), IsPreconnected (s n)) (K : âˆ€ (n : Î²), (s n âˆ© s (Order.succ n)).nonempty) : IsPreconnected (â‹ƒ (n : Î²), s n)
(p n : â„•) : wittPolynomial p (Zmod(p ^ (n + 1))) (n + 1) = â‡‘(MvPolynomial.expand p) (wittPolynomial p (Zmod(p ^ (n + 1))) n)
{Î± : Type u} [pseudoMetricSpace Î±] {s : â„• â†’ Î±} : CauchySeq s â†” âˆƒ (b : â„• â†’ â„), (âˆ€ (n : â„•), 0 â‰¤ b n) âˆ§ (âˆ€ (n m N : â„•), N â‰¤ n â†’ N â‰¤ m â†’ HasDist.dist (s n) (s m) â‰¤ b N) âˆ§ Filter.Tendsto b Filter.atTop (nhds 0)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ Mon_) [CategoryTheory.IsFiltered J] {x y y' : Î£ (j : J), â†¥(F.obj j)} (hyy' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F â‹™ CategoryTheory.forget Mon_) y y') : Mon.FilteredColimits.colimitMulAux F x y = Mon.FilteredColimits.colimitMulAux F x y'
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} [t2_Space Î±] [ProperSpace Î±] : is_IsCompact s â†” is_IsClosed s âˆ§ Metric.Bounded s
(x : â„‚) : HasDerivAt Complex.sin (Complex.cos x) x
{p : â„‚ Ã— â„‚} (hâ‚ : 0 â‰¤ p.fst.re âˆ¨ p.fst.im â‰  0) (hâ‚‚ : 0 < p.snd.re) : ContinuousAt (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.snd) p
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : ringChar F â‰  2) : char.quadratic_Char F (-1) = â‡‘ZmodÏ‡â‚„ â†‘(Fintype.card F)
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (x : Î± 0) (p : Î  (i : Fin n), Î± i.succ) (i : Fin n) (y : Î± i.succ) : fin.cons x (Function.update p i y) = Function.update (fin.cons x p) i.succ y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.FinCategory J] (F : J â¥¤ C) : Nonempty (CategoryTheory.Limits.Cocone F)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (a : CategoryTheory.Over P) : â†‘a = 0 â†” a.hom = 0
{R : Type u} [CommRing R] {P : Ideal R} (H : P.is_Prime) : (Ideal.map Polynomial.c P).is_Prime
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [AddCommGroup Î²] {f g : Î± â†’ Î²} (hF : IsAddGroupHom f) (hg : IsAddGroupHom g) : IsAddGroupHom (Î» (a : Î±), f a - g a)
{a b c : Prop} : a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c
{R : â„} {c w : â„‚} {s : Set â„‚} (hs : s.countable) (hw : w âˆˆ Metric.Ball c R) {f : â„‚ â†’ â„‚} (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball c R  s â†’ DifferentiableAt â„‚ f z) : âˆ® (z : â„‚) in C(c, R), f z / (z - w) = 2 * â†‘Real.pi * Complex.i * f w
{Î± : Type u_1} {P : Î± â†’ Prop} : Antitone (Î» (s : Set Î±), âˆ€ (x : Î±), x âˆˆ s â†’ P x)
{Î± : Type u} [Preorder Î±] {a b c : Î±} : b < c â†’ a < b â†’ a < c
{Î± : Type u} [topologicalSpace Î±] (x : Î±) (c : Set (Set Î±)) (H1 : âˆ€ (s : Set Î±), s âˆˆ c â†’ x âˆˆ s) (H2 : âˆ€ (s : Set Î±), s âˆˆ c â†’ IsPreconnected s) : IsPreconnected (â‹ƒâ‚€c)
{M : Type u_1} [MulOneClass M] (S : Submonoid M) : Submonoid.closure â†‘S = S
(ð•œ : Type v) [is_R_or_C ð•œ] {E : Type u} [NormedGroup E] [normedSpace ð•œ E] (x : E) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (f : NormedSpace.Dual ð•œ E), âˆ¥â‡‘f xâˆ¥ â‰¤ M * âˆ¥fâˆ¥) : âˆ¥xâˆ¥ â‰¤ M
{a b c : Prop} : (a âˆ¨ b) âˆ§ c â†” a âˆ§ c âˆ¨ b âˆ§ c
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] : (Filter.cocompact Î±).coprod (Filter.cocompact Î²) = Filter.cocompact (Î± Ã— Î²)
{G : Type u_1} {s : Set G} [Group G] : IsNormalSubgroup (group.normal_Closure s)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {n : WithTop â„•} : ContDiff ð•œ n Id
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b c : Î±} : a < b + c â†’ a - c < b
{Î± : Type u} [pseudoMetricSpace Î±] (f : â„• â†’ Î±) (n : â„•) : HasDist.dist (f 0) (f n) â‰¤ (Finset.range n).sum (Î» (i : â„•), HasDist.dist (f i) (f (i + 1)))
{Î± : Type u} [Preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.Mono f] [CategoryTheory.SplitEpi f] : CategoryTheory.IsIso f
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] [LocallyCompactSpace (Î± Ã— Î²)] : Continuous ContinuousMap.curry
{x y z : â„¤} (h : PythagoreanTriple x y z) (h_IsCoprime : x.gcd y = 1) (h_parity : x % 2 = 1) (h_Pos : 0 < z) : âˆƒ (m n : â„¤), x = m ^ 2 - n ^ 2 âˆ§ y = 2 * m * n âˆ§ z = m ^ 2 + n ^ 2 âˆ§ m.gcd n = 1 âˆ§ (m % 2 = 0 âˆ§ n % 2 = 1 âˆ¨ m % 2 = 1 âˆ§ n % 2 = 0) âˆ§ 0 â‰¤ m
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] : K âŠ” Ká—® = âŠ¤
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (M N : Submonoid R) [IsLocalization M S] (h : M â‰¤ N) (h' : âˆ€ (x : â†¥N), âˆƒ (m : R), m * â†‘x âˆˆ M) : IsLocalization N S
{R : Type u} {n : â„•} {M : Fin n.succ â†’ Type v} {Mâ‚‚ : Type vâ‚‚} [Semiring R] [Î  (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid Mâ‚‚] [Î  (i : Fin n.succ), Module R (M i)] [Module R Mâ‚‚] (f : MultilinearMap R M Mâ‚‚) (m : Î  (i : Fin n), M (â‡‘fin.cast_Succ i)) (x y : M (fin.last n)) : â‡‘f (fin.snoc m (x + y)) = â‡‘f (fin.snoc m x) + â‡‘f (fin.snoc m y)
{Î± : Type u} {a b : Î±} [MulZeroOneClass Î±] [PartialOrder Î±] [ZeroLt.MulPosMono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b â‰¤ 1
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) {p : Polynomial A} (pmonic : p.monic) (hp : â‡‘(Polynomial.aeval x) p = 0) : (minpoly A x).degree â‰¤ p.degree
{p : â„•} [Fact (Nat.Prime p)] {f : PadicSeq p} (hF : Â¬f â‰ˆ 0) (v2 v3 : â„•) : padicNorm p (â‡‘f (PadicSeq.stationaryPoint hF)) = padicNorm p (â‡‘f (Linear_order.max (PadicSeq.stationaryPoint hF) (Linear_order.max v2 v3)))
{M : Type u_3} {N : Type u_4} [MulZeroOneClass M] [MulZeroOneClass N] (f : M â†’*â‚€ N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
{k : Type u_1} {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {n : â„•} {sâ‚ sâ‚‚ : Affine.Simplex k P n} (h : Set.Range sâ‚.points = Set.Range sâ‚‚.points) : Finset.centroid k Finset.univ sâ‚.points = Finset.centroid k Finset.univ sâ‚‚.points
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (P : RegularExpression Î±) : (RegularExpression.map f P).matches = â‡‘(Language.map f) P.matches
(S : Set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ 0 â‰¤ x) : 0 â‰¤ HasInf.inf S
(Î± : Type u) [metricSpace Î±] [TopologicalSpace.SeparableSpace Î±] : âˆƒ (f : Î± â†’ â†¥(Lp (Î» (n : â„•), â„) âŠ¤)), Isometry f
{L : FirstOrder.Language} {M : Type w} [L.Structure M] (s : Set M) {p : Î  (x : M), x âˆˆ â‡‘(FirstOrder.Language.Substructure.closure L) s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (Hfun : âˆ€ {n : â„•} (f : L.functions n), FirstOrder.Language.ClosedUnder f {x : M | âˆƒ (hx : x âˆˆ â‡‘(FirstOrder.Language.Substructure.closure L) s), p x hx}) {x : M} (hx : x âˆˆ â‡‘(FirstOrder.Language.Substructure.closure L) s) : p x hx
{Î± : Type u_1} {Î² : Type u_2} [completeLattice Î±] {f : Filter Î²} {u : Î² â†’ Î±} : f.liminf u = â¨† (s : Set Î²) (H : s âˆˆ f), â¨… (a : Î²) (H : a âˆˆ s), u a
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [hasZero M] [CommMonoid N] [CommMonoid P] (h : N â‰ƒ* P) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ N) : â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
{Î± : Type u} [Preorder Î±] {s t : Set Î±} (h : BddAbove t) : BddAbove (s âˆ© t)
{G : Type u_1} [Group G] {k : Set G} {p : G â†’ Prop} {x : G} (h : x âˆˆ Subgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ p x) (Hk_Inv : âˆ€ (x : G), x âˆˆ k â†’ p xâ»Â¹) (H1 : p 1) (HMul : âˆ€ (x y : G), p x â†’ p y â†’ p (x * y)) : p x
{Y : Type u_2} [topologicalSpace Y] [NormalSpace Y] {s : Set Y} (f : boundedContinuousFunction â†¥s â„) (hs : is_IsClosed s) {t : Set â„} [t.ord_connected] (hF : âˆ€ (x : â†¥s), â‡‘f x âˆˆ t) (hne : t.nonempty) : âˆƒ (g : boundedContinuousFunction Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ g.restrict s = f
{n : â„•} {Î± : Type u_1} [Preorder Î±] {f g : Fin n â†ªo Î±} (h : Set.Range â‡‘f = Set.Range â‡‘g) : f = g
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (H : IsPreconnected s) : IsPreconnected (Closure s)
(A B : Finset â„•) : A.sum (Î» (i : â„•), 2 ^ i) < B.sum (Î» (i : â„•), 2 ^ i) â†” A.to_colex < B.to_colex
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [FiniteDimensional ð•œ E] (T : E â†’â‚—[ð•œ] E) : InnerProductSpace.IsSelfAdjoint (â‡‘LinearMap.adjoint T * T)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : StrictConcaveOn ð•œ s f) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hxy : x â‰  y) {a b : ð•œ} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : Linear_order.min (f x) (f y) < f (a â€¢ x + b â€¢ y)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {c : â„} {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : asymptotics.is_O_with c l f g â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
{R : Type u_1} {S : Type u_2} [conditionallyCompleteLinearOrder R] (s : Finset S) (f : S â†’ Tropical (WithTop R)) : Tropical.untrop (s.sum (Î» (i : S), f i)) = â¨… (i : â†¥s), Tropical.untrop (f â†‘i)
{Î¹ : Type u_1} {ð•œ : Type u_3} [is_R_or_C ð•œ] {E : Type u_4} [innerProductSpace ð•œ E] {E' : Type u_5} [innerProductSpace ð•œ E'] [Fintype Î¹] (v : Basis Î¹ ð•œ E) (hv : Orthonormal ð•œ â‡‘v) (f : E â‰ƒâ‚—áµ¢[ð•œ] E') : ((v.map f.to_linearEquiv).to_Orthonormal_Basis _).repr = f.symm.trans (v.to_Orthonormal_Basis hv).repr
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} {R : Type u_11} [Monoid R] [AddMonoid M] [AddCommMonoid N] [DistribMulAction R M] {g : Î± â†’â‚€ M} {b : R} {h : Î± â†’ M â†’+ N} : (b â€¢ g).sum (Î» (a : Î±), â‡‘(h a)) = g.sum (Î» (i : Î±) (c : M), â‡‘(h i) (b â€¢ c))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : Set P} {pâ‚€ : P} (h : pâ‚€ âˆˆ s) : Collinear k s â†” âˆƒ (v : V), âˆ€ (p : P), p âˆˆ s â†’ (âˆƒ (r : k), p = r â€¢ v +áµ¥ pâ‚€)
{R : Type u} [Field R] (p : Polynomial R) : (Multiset.map (Î» (a : R), Polynomial.x - â‡‘Polynomial.c a) p.roots).prod âˆ£ p
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [denselyOrdered Î±] {a b : Î±} {s : Set Î±} (hs : is_IsClosed (s âˆ© Set.Icc a b)) (ha : a âˆˆ s) (hgt : âˆ€ (x : Î±), x âˆˆ s âˆ© Set.Ico a b â†’ s âˆˆ nhdsWithin x (Set.Ioi x)) : Set.Icc a b âŠ† s
{A : Type u_2} [normedRing A] [NormedAlgebra â„‚ A] [CompleteSpace A] [NormOneClass A] (a : A) : Filter.Tendsto (Î» (n : â„•), Ennreal.ofReal (âˆ¥a ^ nâˆ¥ ^ (1 / â†‘n))) Filter.atTop (nhds (spectralRadius â„‚ a))
{p : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero â†‘â†‘p] {k : â„•} [hpri : Fact (Nat.Prime â†‘p)] [IsCyclotomicExtension {p ^ (k + 1)} K L] (hirr : Irreducible (Polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (h : p â‰  2) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta (p ^ (k + 1)) K L - 1) = â†‘p
{F : Type u} [Field F] {n : â„•} : (Polynomial.x ^ n - 1).separable â†” â†‘n â‰  0
{x y : Pgame} (ox : x.numeric) (oy : y.numeric) : x < y â†” (âˆƒ (i : y.left_moves), x â‰¤ y.move_Left i) âˆ¨ âˆƒ (j : x.right_moves), x.move_Right j â‰¤ y
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {f' : F} [LinearOrder ð•œ] [OrderClosedTopology ð•œ] {x y : ð•œ} (h : x < y) : HasDerivWithinAt f f' (Set.Ioi x) x â†’ HasDerivWithinAt f f' (Set.Ioo x y) x
{Î± : Type u} [PartialOrder Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ a = b
(f f' : â„ â†’ â„) {a b : â„} (hab : a < b) (g g' : â„ â†’ â„) {lfa lga lfb lgb : â„} (hff' : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) (hgg' : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt g (g' x) x) (hfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds lfa)) (hga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds lga)) (hfb : Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds lfb)) (hgb : Filter.Tendsto g (nhdsWithin b (Set.Iio b)) (nhds lgb)) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), (lgb - lga) * f' c = (lfb - lfa) * g' c
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : Dense s â†’ âˆ€ (U : Set Î±), is_IsOpen U â†’ U.nonempty â†’ (U âˆ© s).nonempty
{V : Type u_1} [CategoryTheory.Category V] {Aâ‚ Bâ‚ Câ‚ Aâ‚‚ Bâ‚‚ Câ‚‚ Aâ‚ƒ Bâ‚ƒ Câ‚ƒ : V} {fâ‚ : Aâ‚ âŸ¶ Bâ‚} {gâ‚ : Bâ‚ âŸ¶ Câ‚} {fâ‚‚ : Aâ‚‚ âŸ¶ Bâ‚‚} {gâ‚‚ : Bâ‚‚ âŸ¶ Câ‚‚} {fâ‚ƒ : Aâ‚ƒ âŸ¶ Bâ‚ƒ} {gâ‚ƒ : Bâ‚ƒ âŸ¶ Câ‚ƒ} {Î±â‚ : CategoryTheory.Arrow.mk fâ‚ âŸ¶ CategoryTheory.Arrow.mk fâ‚‚} {Î²â‚ : CategoryTheory.Arrow.mk gâ‚ âŸ¶ CategoryTheory.Arrow.mk gâ‚‚} {Î±â‚‚ : CategoryTheory.Arrow.mk fâ‚‚ âŸ¶ CategoryTheory.Arrow.mk fâ‚ƒ} {Î²â‚‚ : CategoryTheory.Arrow.mk gâ‚‚ âŸ¶ CategoryTheory.Arrow.mk gâ‚ƒ} (pâ‚ : Î±â‚.right = Î²â‚.left) (pâ‚‚ : Î±â‚‚.right = Î²â‚‚.left) : (Î±â‚ â‰« Î±â‚‚).right = (Î²â‚ â‰« Î²â‚‚).left
{x : Pgame} : 0 â‰¤ x â†” âˆ€ (j : x.right_moves), âˆƒ (i : (x.move_Right j).left_moves), 0 â‰¤ (x.move_Right j).move_Left i
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [CommMonoid Î±] {f : Î² â†’ Î±} {g : Î³ â†’ Î±} (h_Eq : âˆ€ (u : Finset Î³), âˆƒ (v : Finset Î²), âˆ€ (v' : Finset Î²), v âŠ† v' â†’ (âˆƒ (u' : Finset Î³), u âŠ† u' âˆ§ u'.prod (Î» (x : Î³), g x) = v'.prod (Î» (b : Î²), f b))) : Filter.map (Î» (s : Finset Î²), s.prod (Î» (b : Î²), f b)) Filter.atTop â‰¤ Filter.map (Î» (s : Finset Î³), s.prod (Î» (x : Î³), g x)) Filter.atTop
{R : Type u_1} {M : Type u_2} [orderedSemiring R] [orderedAddCommMonoid M] [smulWithZero R M] [OrderedSmul R M] {a : M} {c : R} (hc : 0 < c) : 0 < a â†’ 0 < c â€¢ a
{S : Set Ordinal} (hS : Set.Unbounded LT.lt S) (a : Ordinal) : (S âˆ© Set.Ici a).nonempty
{R : Type u_1} [linearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [FiniteDimensional R M] (xâ‚ xâ‚‚ : Orientation R M Î¹) (h : Fintype.card Î¹ = FiniteDimensional.finrank R M) : xâ‚ â‰  xâ‚‚ â†” xâ‚ = -xâ‚‚
{S : Type u} [AddSemigroup S] {a b x y z : S} (ha : AddSemiconjBy a y z) (hb : AddSemiconjBy b x y) : AddSemiconjBy (a + b) x z
{Î± : Type u} : DenseEmbedding Pure.pure
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (f : E â†’L[ð•œ] F) : IsBoundedLinearMap ð•œ â‡‘f
{k : Type u_1} [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) (h : â†‘(s.card) â‰  0) : s.sum (Î» (i : Î¹), Finset.centroidWeights k s i) = 1
{p : â„•} (hp : Nat.Prime p) : p.factorization = Finsupp.single p 1
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s1 s2 : AffineSubspace k P} (hD : s1.direction = s2.direction) (hn : (â†‘s1 âˆ© â†‘s2).nonempty) : s1 = s2
{G : Type u_7} [AddCommGroup G] (L : List G) : -L.sum = (List.map (Î» (x : G), -x) L).sum
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : o.oangle (-x) y = o.oangle x (-y)
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (b : n â†’ Î±) (h : IsUnit A.det) : A.det â€¢ Aâ»Â¹.mul_vec b = â‡‘(A.cramer) b
{Î¹ : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {l l' : Filter â„} {Lt : Filter Î¹} {a : â„} [Interval_integral.FTC_Filter a l l'] (hfm : StronglyMeasurableAtFilter f l' MeasureTheory.MeasureSpace.volume) (hF : Filter.Tendsto f (l' âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) {u v : Î¹ â†’ â„} (hu : Filter.Tendsto u Lt l) (hv : Filter.Tendsto v Lt l) : (Î» (t : Î¹), (âˆ« (x : â„) in u t..v t, f x) - (v t - u t) â€¢ c) =o[Lt] (v - u)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_Continuous C hâˆ¥ â‰¤ C
{M : Type u_1} [hasAdd M] (S : AddSubsemigroup M) : AddSubsemigroup.closure â†‘S = S
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [orderedSemiring ð•œ] [AddCommGroup E] [Module ð•œ E] {p : Î¹ â†’ E} (hi : Function.Injective p) : ConvexIndependent ð•œ (Î» (x : â†¥(Set.Range p)), â†‘x) â†” ConvexIndependent ð•œ p
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {s : Set E} (hscomp : is_IsCompact s) (hsnemp : s.nonempty) : (Set.ExtremePoints â„ s).nonempty
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (a b c : P) : HasDist.dist a b ^ 2 + HasDist.dist a c ^ 2 = 2 * (HasDist.dist a (midpoint â„ b c) ^ 2 + (HasDist.dist b c / 2) ^ 2)
{M : Type u_1} {N : Type u_2} [MulOneClass M] [MulOneClass N] {c : Con M} {f : N â†’* M} : Con.comap â‡‘f _ c = Con.ker (c.mk'.comp f)
(R : Type u_1) {S : Type u_2} {M : Type u_3} [CommRing R] [Ring S] [AddCommGroup M] [Algebra R S] [Module S M] [Module R M] [isScalarTower R S M] (h : IsArtinian R M) : IsArtinian S M
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] : ContDiff ð•œ âŠ¤ â‡‘((equiv.prod_assoc E F G).symm)
{R : Type u_1} [CommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] : Disjoint (TensorAlgebraÎ¹ R).range 1
(p : â„ Ã— â„) (hp : p.fst â‰  0) {n : WithTop â„•} : ContDiffAt â„ n (Î» (p : â„ Ã— â„), p.fst ^ p.snd) p
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (f : C(Î±, Î²)) : Continuous â‡‘f
{Î± : Type u} [Preorder Î±] {a b : Î±} (h : a < b) : Â¬b â‰¤ a
{M : Type u_1} [AddMonoid M] (u : addUnits M) (a : M) : IsAddUnit (â†‘u + a) â†” IsAddUnit a
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
{Î± : Type u} [pseudoEmetricSpace Î±] (Î´ : â„) : Metric.Thickening Î´ âˆ… = âˆ…
{Î± : Type u} {f : Filter Î±} {Î² : Type v} {s : Î² â†’ Set Î±} (is : Finset Î²) : (â‹‚ (i : Î²) (H : i âˆˆ is), s i) âˆˆ f â†” âˆ€ (i : Î²), i âˆˆ is â†’ s i âˆˆ f
{C : Type uâ‚} [CategoryTheory.Category C] {X Y Z : C} (p : X âŸ¶ Y) (q : Z = Y) : _.mpr p = p â‰« CategoryTheory.eqToHom _
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : hb.oangle (â‡‘(hb.rotation (hb.oangle x y)) x) y = 0
{M : Type u_1} [AddMonoid M] {s : Set M} : s âŠ† Add_monoid.closure s
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] (oi : Î± â‰ƒo Î²) : GaloisConnection â‡‘oi â‡‘(oi.symm)
{R : Type u_1} {M : Type u_2} [Ring R] [topologicalSpace R] [topologicalSpace M] [AddCommGroup M] [HasContinuousAdd M] [Module R M] [HasContinuousSmul R M] [(nhdsWithin 0 {x : R | IsUnit x}).ne_IsBot] (s : Submodule R M) (hs : (Interior â†‘s).nonempty) : s = âŠ¤
{T : â„} {g : â„ â†’ â„} (hg : Function.Periodic g T) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.MeasureSpace.volume tâ‚ tâ‚‚) (hâ‚€ : âˆ€ (x : â„), 0 < g x) (hT : 0 < T) : Filter.Tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) Filter.atBot Filter.atBot
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [OrderedAddCommGroup Î²] [HasScalar ð•œ E] [Module ð•œ Î²] {s : Set E} {f : E â†’ Î²} : ConvexOn ð•œ s f â†’ ConcaveOn ð•œ s (-f)
{Î± : Type u} [topologicalSpace Î±] (Z : â„• â†’ Set Î±) (hZd : âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) (hZn : âˆ€ (i : â„•), (Z i).nonempty) (hZ0 : is_IsCompact (Z 0)) (hZcl : âˆ€ (i : â„•), is_IsClosed (Z i)) : (â‹‚ (i : â„•), Z i).nonempty
{R : Type u_1} [CommSemiring R] (M : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] [IsLocalization M S] (z : S) : â‡‘(algebraMap R S) (IsLocalization.sec M z).fst = â‡‘(algebraMap R S) â†‘((IsLocalization.sec M z).snd) * z
{R : Type u_1} {a b : R} [commSemigroup R] : IsRegular (a * b) â†” IsRegular a âˆ§ IsRegular b
{Î· : Type u_5} {f : Î· â†’ Type u_6} [Î  (i : Î·), Group (f i)] [DecidableEq Î·] [Fintype Î·] {H : Î  (i : Î·), Subgroup (f i)} {J : Subgroup (Î  (i : Î·), f i)} : Subgroup.pi Set.Univ H â‰¤ J â†” âˆ€ (i : Î·), Subgroup.map (MonoidHom.single f i) (H i) â‰¤ J
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (hF : Set.EqOn f 1 s) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) = 1
(k : Type u_1) {V : Type u_2} (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : P) (s : AffineSubspace k P) : p âˆˆ â†‘s â†” p âˆˆ s
{Î“â‚€ : Type u_1} [LinearOrderedCommGroupWithZero Î“â‚€] (Î³ : Î“â‚€Ë£) : {â†‘Î³} âˆˆ nhds â†‘Î³
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} {r : â„} (hr : 0 â‰¤ r) (H1 : âˆ€ (x : Î±), x âˆˆ s â†’ Metric.infDist x t â‰¤ r) (H2 : âˆ€ (x : Î±), x âˆˆ t â†’ Metric.infDist x s â‰¤ r) : Metric.hausdorffDist s t â‰¤ r
{R : Type u_1} {Râ‚ : Type u_2} {Râ‚‚ : Type u_3} {Mâ‚ : Type u_6} {Mâ‚‚ : Type u_7} [CommSemiring R] [CommSemiring Râ‚] [AddCommMonoid Mâ‚] [Module Râ‚ Mâ‚] [CommSemiring Râ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {Iâ‚ : Râ‚ â†’+* R} {Iâ‚‚ : Râ‚‚ â†’+* R} {B : Mâ‚ â†’â‚›â‚—[Iâ‚] Mâ‚‚ â†’â‚›â‚—[Iâ‚‚] R} : B.separating_Left â†” B.ker = âŠ¥
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {ps : Set P} {n : â„•} [FiniteDimensional â„ V] (hD : FiniteDimensional.finrank â„ V = n) (hc : EuclideanGeometry.Cospherical ps) {sxâ‚ sxâ‚‚ : Affine.Simplex â„ P n} (hsxâ‚ : Set.Range sxâ‚.points âŠ† ps) (hsxâ‚‚ : Set.Range sxâ‚‚.points âŠ† ps) : sxâ‚.circumcenter = sxâ‚‚.circumcenter
{Î± : Type u_1} {p : Prop} {q : Î± â†’ Prop} : p â†’ âˆ€ (x : Î±), q x â†” âˆ€ (x : Î±), p â†’ q x
{M : Type u_1} [AddMonoid M] (c : AddCon M) (n : â„•) {w x : M} : â‡‘c w x â†’ â‡‘c (n â€¢ w) (n â€¢ x)
{R : Type u} {N : Type z} [Semiring R] [AddCommMonoid N] [Module R N] {P : Type v} [AddCommMonoid P] [Module R P] (h : Module.Free R P) (e : P â‰ƒâ‚—[R] N) : Module.Free R N
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] {a b : Î±} (hab : a â‰  b) : Closure (Set.Ico a b) = Set.Icc a b
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] (O : Finset C) (H : Finset (Î£' (X Y : C) (mX : X âˆˆ O) (mY : Y âˆˆ O), X âŸ¶ Y)) {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y} (mf : âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H) : CategoryTheory.IsCofiltered.infTo O H mX â‰« f = CategoryTheory.IsCofiltered.infTo O H mY
{Î± : Type u_1} {Î² : Type u_2} [AddCommGroup Î±] [uniformSpace Î±] [UniformAddGroup Î±] [t1_Space Î±] (f : Î² â†’ Î±) : Filter.Tendsto (Î» (s : Finset Î²), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) Filter.atTop (nhds 0)
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (h : Function.Injective â‡‘(algebraMap R A)) (p : â„•) [Char_p R p] : Char_p A p
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] {p1 p2 : P} (h : p1 -áµ¥ p2 = 0) : p1 = p2
{G : Type u_1} [AddGroup G] [hN : Nontrivial G] : Add_monoid.is_torsion G â†’ Â¬Add_monoid.is_torsion_free G
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [topologicalSpace Î±] [pseudoMetricSpace Î²] [pseudoMetricSpace Î³] {G : Î² â†’ Î³} {C : Nnreal} (H : LipschitzWith C G) : UniformContinuous (BoundedContinuousFunction.comp G H)
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} (a b : M) : â‡‘(CliffordAlgebraÎ¹ Q) a * â‡‘(CliffordAlgebraÎ¹ Q) b + â‡‘(CliffordAlgebraÎ¹ Q) b * â‡‘(CliffordAlgebraÎ¹ Q) a = â‡‘(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar â‡‘Q a b)
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] (f : M â†’* P) : Function.Injective â‡‘(Con.kerLift f)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] {S T : intermediateField K L} (h : âˆ€ (x : L), x âˆˆ S â†” x âˆˆ T) : S = T
{R : Type u} {L : Type v} {L' : Type wâ‚‚} [CommRing R] [LieRing L] [lieAlgebra R L] [LieRing L'] [lieAlgebra R L'] (f : L â†’â‚—â…Râ† L') {Iâ‚ Iâ‚‚ : LieIdeal R L} : LieIdeal.map f â…Iâ‚,Iâ‚‚â† â‰¤ â…LieIdeal.map f Iâ‚,LieIdeal.map f Iâ‚‚â†
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : is_IsClosed (Frontier s)
{G : Type u_1} [Group G] (H : Subgroup G) : H = âŠ¥ âˆ¨ âˆƒ (x : G) (H : x âˆˆ H), x â‰  1
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {f : E Ã— F â†’ G} (h : IsBoundedBilinearMap ð•œ f) : Continuous f
{Î± : Type u} [pseudoMetricSpace Î±] {f : â„• â†’ Î±} {m n : â„•} (hmn : m â‰¤ n) {d : â„• â†’ â„} (hD : âˆ€ {k : â„•}, m â‰¤ k â†’ k < n â†’ HasDist.dist (f k) (f (k + 1)) â‰¤ d k) : HasDist.dist (f m) (f n) â‰¤ (Finset.ico m n).sum (Î» (i : â„•), d i)
{A : Type u_4} [CommRing A] [is_IsDomain A] {L : Type u_6} [Field L] [Algebra A L] (alg : Algebra.IsAlgebraic A L) (inj : âˆ€ (x : A), â‡‘(algebraMap A L) x = 0 â†’ x = 0) : IsFractionRing â†¥(integralClosure A L) L
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [NormedGroup G] [normedSpace ð•œ G] (q : FormalMultilinearSeries ð•œ F G) (p : FormalMultilinearSeries ð•œ E F) (N : â„•) (z : E) : q.partial_Sum N ((Finset.ico 1 N).sum (Î» (i : â„•), â‡‘(p i) (Î» (j : Fin i), z))) = (FormalMultilinearSeries.compPartialSumTarget 0 N N).sum (Î» (i : Î£ (n : â„•), Composition n), â‡‘(q.comp_along_Composition p i.snd) (Î» (j : Fin i.fst), z))
{Î± : sort u_1} (P : Prop) [Decidable P] (a b : Î±) : dite P (Î» (h : P), a) (Î» (h : Â¬P), b) = Ite P a b
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹} (h : TendstoUniformly F f p) (g : Î³ â†’ Î±) : TendstoUniformly (Î» (n : Î¹), F n âˆ˜ g) (f âˆ˜ g) p
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} {F F' : CategoryTheory.Limits.MonoFactorisation f} (hI : F.I = F'.I) (hm : F.m = CategoryTheory.eqToHom hI â‰« F'.m) : F = F'
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : Affine.Simplex â„ P 0) (i : Fin 1) : s.circumcenter = s.points i
{M : Type u_1} [Nonempty M] [Semigroup M] [topologicalSpace M] [CompactSpace M] [t2_Space M] (Continuous_mulLeft : âˆ€ (r : M), Continuous (Î» (_x : M), _x * r)) : âˆƒ (m : M), m * m = m
{R : Type u_1} (M : Type u_3) [Monoid R] [mulAction R M] (a : RË£) : IsSmulRegular M â†‘a
{cb : CharBuffer} {n n' val : â„•} (h : Parser.nat cb n = ParseResult.done n' val) (hn : n' < Buffer.size cb) : '0' â‰¤ Buffer.read cb âŸ¨n', hnâŸ© â†’ '9' < Buffer.read cb âŸ¨n', hnâŸ©
{Î± : Type u} {f g : Î± â†’ Î±} (h : Function.Commute f g) : Set.BijOn f (Function.FixedPoints (f âˆ˜ g)) (Function.FixedPoints (f âˆ˜ g))
{F : Type u_3} [innerProductSpace â„ F] (K : Submodule â„ F) {u v : F} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : F), w âˆˆ K â†’ HasInner.inner (u - v) w = 0
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {l : Filter Î±} {a : Î±} : IsMaxFilter (â‡‘OrderDual.toDual âˆ˜ f) l a â†’ IsMinFilter f l a
{m : Type u_1} {n : Type u_2} [Fintype m] [Fintype n] {R : Type v} [Field R] : FiniteDimensional.finrank R (Matrix m n R) = Fintype.card m * Fintype.card n
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {x : E} (hF : HasStrictFderivAt f f' x) (K : Nnreal) (hK : âˆ¥f'âˆ¥â‚Š < K) : âˆƒ (s : Set E) (H : s âˆˆ nhds x), LipschitzOnWith K f s
(n : â„•+) : n.factor_multiset.prod = n
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] (X : C) : CategoryTheory.IsPullback 0 0 0 (ðŸ™ X)
{M : Type u_1} [Monoid M] (c : Con M) (n : â„•) {w x : M} : â‡‘c w x â†’ â‡‘c (w ^ n) (x ^ n)
{Î± : Type u_1} {M : Type u_5} [hasZero M] {b : M} (h : b â‰  0) : Function.Injective (Î» (a : Î±), Finsupp.single a b)
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} [CategoryTheory.SplitMono f] [CategoryTheory.Mono (CategoryTheory.retraction f)] : CategoryTheory.IsIso f
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [Î  (i : Î¹), hasZero (Î² i)] {i j : Î¹} {xi : Î² i} {xj : Î² j} (h : âŸ¨i, xiâŸ© = âŸ¨j, xjâŸ©) : Dfinsupp.single i xi = Dfinsupp.single j xj
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {M : Matrix n n R} {i j : n} (i_NE_j : i â‰  j) (hij : M i = M j) : M.det = 0
(r : Ennreal) : âˆ‘' (n : â„•), r ^ n = (1 - r)â»Â¹
{p : â„•} [Fact (Nat.Prime p)] : WittVector.IsPolyâ‚‚ p (Î» (_x : Type u_1) (_x_1 : CommRing _x), Mul.mul)
{R : Type u_2} {Î“â‚€ : Type u_3} [Ring R] [linearOrderedCommMonoidWithZero Î“â‚€] {vâ‚ vâ‚‚ : Valuation R Î“â‚€} : vâ‚ = vâ‚‚ â†” âˆ€ (r : R), â‡‘vâ‚ r = â‡‘vâ‚‚ r
(R : Type u) (L : Type v) [CommRing R] [LieRing L] [lieAlgebra R L] (H : LieSubalgebra R L) [LieAlgebra.IsNilpotent R â†¥H] (h : LieAlgebra.zeroRootSubalgebra R L H = H) : H.is_cartan_Subalgebra
{Î± : Type u_1} {ð’œ : Finset (Finset Î±)} {r : â„•} : ð’œ.slice r âŠ† ð’œ
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x : V} (hx : x â‰  0) (Î¸ : Real.Angle) : o.oangle (â‡‘(o.rotation Î¸) x) x = -Î¸
{G : Type u_3} [AddGroup G] : Add_group.fg G â†” âˆƒ (S : Set G), AddSubgroup.closure S = âŠ¤ âˆ§ S.finite
(a b c : â„) (hb : 0 â‰  b) : Filter.Tendsto (Î» (x : â„), x ^ (a / (b * x + c))) Filter.atTop (nhds 1)
{R : Type u_1} [orderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {x y : M} : SameRay R (-x) (-y) â†’ SameRay R x y
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {câ‚ câ‚‚ pâ‚ pâ‚‚ : P} (hcâ‚ : HasDist.dist pâ‚ câ‚ = HasDist.dist pâ‚‚ câ‚) (hcâ‚‚ : HasDist.dist pâ‚ câ‚‚ = HasDist.dist pâ‚‚ câ‚‚) : HasInner.inner (câ‚‚ -áµ¥ câ‚) (pâ‚‚ -áµ¥ pâ‚) = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {p : Î¹ â†’ P} (hi : AffineIndependent k p) {s : Finset Î¹} {sp : AffineSubspace k P} [FiniteDimensional k â†¥(sp.direction)] (hle : affineSpan k â†‘(Finset.image p s) â‰¤ sp) (hc : s.card = FiniteDimensional.finrank k â†¥(sp.direction) + 1) : affineSpan k â†‘(Finset.image p s) = sp
{Î± : Type u_1} {Î² : Type u_2} [AddCommGroup Î±] [uniformSpace Î±] [CompleteSpace Î±] {f : Î² â†’ Î±} : Summable f â†” CauchySeq (Î» (s : Finset Î²), s.sum (Î» (b : Î²), f b))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} {v : V} {s : Set Î¹} {p : Î¹ â†’ P} : (âˆƒ (fs : Finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = 0), v = â‡‘(fs.weighted_vsub p) w) â†” âˆƒ (fs : Finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = 0), v = â‡‘(fs.weighted_vsub (Î» (i : â†¥s), p â†‘i)) w
{Î± : Type u} {Î² : Type v} {s : Set Î²} (hs : s.subsingleton) {f : Î± â†’ Î²} (hF : Function.Injective f) : (f â»Â¹' s).subsingleton
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] : IsNoetherian R M â†” âˆ€ (s : Submodule R M), s.fg
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {s : Set Î±} (hs : IsConnected s) (hb : BddBelow s) (ha : BddAbove s) : Set.Ioo (HasInf.inf s) (HasSup.sup s) âŠ† s
{Î¹ : Type u_1} {R : Type u_3} {A : Type u_5} {x : Î¹ â†’ A} [CommRing R] [CommRing A] [Algebra R A] {K : Type u_2} [CommRing K] [Algebra R K] [Algebra K A] [isScalarTower R K A] (hinj : Function.Injective â‡‘(algebraMap R K)) (ai : AlgebraicIndependent K x) : AlgebraicIndependent R x
{n : WithTop â„•} {ð•‚ : Type u_6} [is_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [normedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [normedSpace ð•‚ F'] {f : E' â†’ F'} {x : E'} (hF : ContDiffAt ð•‚ n f x) (hn : 1 â‰¤ n) : HasStrictFderivAt f (fderiv ð•‚ f x) x
{a b c : Prop} : a âˆ¨ b âˆ§ c â†” (a âˆ¨ b) âˆ§ (a âˆ¨ c)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [normedSpace ð•œ E'] {n : WithTop â„•} {f : E â†’ E'} {s : Set E} : ContMdiffOn (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') n f s â†’ ContDiffOn ð•œ n f s
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_3} [Fintype Î±] [Fintype Î²] [CommMonoid M] (e : Î± â‰ƒ Î²) (f : Î± â†’ M) (g : Î² â†’ M) (h : âˆ€ (x : Î±), f x = g (â‡‘e x)) : finset.univ.prod (Î» (x : Î±), f x) = finset.univ.prod (Î» (x : Î²), g x)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Î± : Type uu} [DecidableEq Î±] {lâ‚ lâ‚‚ : List Î±} : lâ‚ <+~ lâ‚‚ â†” âˆ€ (x : Î±), x âˆˆ lâ‚ â†’ List.count x lâ‚ â‰¤ List.count x lâ‚‚
{Î¹ : Type u_1} {M : Type u_4} [orderedAddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M} : s.sum (Î» (i : Î¹), f i) < âŠ¤ â†” âˆ€ (i : Î¹), i âˆˆ s â†’ f i < âŠ¤
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {xâ‚ xâ‚‚ y z : V} (hxâ‚yne : xâ‚ â‰  y) (hxâ‚zne : xâ‚ â‰  z) (hxâ‚‚yne : xâ‚‚ â‰  y) (hxâ‚‚zne : xâ‚‚ â‰  z) {r : â„} (hxâ‚ : âˆ¥xâ‚âˆ¥ = r) (hxâ‚‚ : âˆ¥xâ‚‚âˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : 2 â€¢ hb.oangle (y - xâ‚) (z - xâ‚) = 2 â€¢ hb.oangle (y - xâ‚‚) (z - xâ‚‚)
{A : Type u_1} (B : Type u_2) [Ring A] [Ring B] [is_IsDomain B] (e : A â‰ƒ+* B) : is_IsDomain A
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {s : Set E} {f : E â†’ ð•œ} {g : E â†’ F} (hF : ContDiffOn ð•œ n f s) (hg : ContDiffOn ð•œ n g s) : ContDiffOn ð•œ n (Î» (x : E), f x â€¢ g x) s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : AffineSubspace k P) : s.direction = vectorSpan k â†‘s
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] (f : â„‚ â†’ E) (f' : â„‚ â†’ (â„‚ â†’L[â„] E)) (z w : â„‚) (Hc : ContinuousOn f (Set.Interval z.re w.re Ã—â„‚ Set.Interval z.im w.im)) (hD : âˆ€ (x : â„‚), x âˆˆ Set.Ioo (Linear_order.min z.re w.re) (Linear_order.max z.re w.re) Ã—â„‚ Set.Ioo (Linear_order.min z.im w.im) (Linear_order.max z.im w.im) â†’ HasFderivAt f (f' x) x) (Hi : MeasureTheory.IntegrableOn (Î» (z : â„‚), Complex.i â€¢ â‡‘(f' z) 1 - â‡‘(f' z) Complex.i) (Set.Interval z.re w.re Ã—â„‚ Set.Interval z.im w.im) MeasureTheory.MeasureSpace.volume) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * Complex.i) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, Complex.i â€¢ â‡‘(f' (â†‘x + â†‘y * Complex.i)) 1 - â‡‘(f' (â†‘x + â†‘y * Complex.i)) Complex.i
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] {a : K} (nth_Part_Num_Eq : (GeneralizedContinuedFraction.of v).partial_numerators.nth n = Option.some a) : a = 1
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {b : M} [linearOrderedCommRing M] (hb : â†‘(Fintype.card Î±) < Fintype.card Î² â€¢ b) : âˆƒ (y : Î²), â†‘((Finset.filter (Î» (x : Î±), f x = y) Finset.univ).card) < b
{Î± : Type u} [Preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a
{Î± : Type u_1} {E : Î± â†’ Type u_2} {p : Ennreal} [Î  (i : Î±), NormedGroup (E i)] [DecidableEq Î±] [Fact (1 â‰¤ p)] (hp : p â‰  âŠ¤) (f : â†¥(Lp E p)) : HasSum (Î» (i : Î±), lp.single p i (â‡‘f i)) f
{G : Type u} {y : G} [AddMonoid G] {x : G} (h : AddCommute x y) (hx : IsOfFinAddOrder x) (hy : IsOfFinAddOrder y) : IsOfFinAddOrder (x + y)
(Î¸ : â„‚) (n : â„•) : Polynomial.eval (Complex.cos Î¸) (Polynomial.Chebyshev.t â„‚ n) = Complex.cos (â†‘n * Î¸)
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R M) (f : M â‰ƒâ‚—[R] M) : (e.map f).orientation = e.orientation â†” 0 < â‡‘LinearMap.det â†‘f
{A : Type u_1} [CommRing A] [Algebra â„š A] (t : A) : PowerSeries.mk (Î» (n : â„•), â‡‘(Polynomial.aeval t) ((1 / â†‘(n.factorial)) â€¢ Polynomial.bernoulli n)) * (PowerSeries.exp A - 1) = PowerSeries.x * â‡‘(PowerSeries.rescale t) (PowerSeries.exp A)
{p : â„•+} {k : â„•} [hp : Fact (Nat.Prime â†‘p)] : IsIntegralClosure (CyclotomicRing (p ^ k) â„¤ â„š) â„¤ (CyclotomicField (p ^ k) â„š)
{Î± : Type u_1} [DecidableEq Î±] (a : Î±) : Derangements.Equiv.RemoveNone.Fiber (Option.some a) = {f : Equiv.perm Î± | Function.FixedPoints â‡‘f âŠ† {a}}
{M : Type u_1} [hasAdd M] {S T : AddSubsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
{M : Type u} [Monoid M] {x y : M} (hxy : x âˆ£ y) {n : â„•} (hn : n â‰  0) : x âˆ£ y ^ n
{Î± : Type u_1} {Î² : Type u_2} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {K : Nnreal} {f : Î± â†’ Î²} : AntilipschitzWith K f â†’ âˆ€ (x y : Î±), HasDist.dist x y â‰¤ â†‘K * HasDist.dist (f x) (f y)
{Î± : Type u} {Î¹ : Type v} [metricSpace Î±] [ProperSpace Î±] {c : Î¹ â†’ Î±} {r : Î¹ â†’ â„} (hr : âˆ€ (i : Î¹), 0 < r i) (uf : âˆ€ (x : Î±), {i : Î¹ | x âˆˆ Metric.Ball (c i) (r i)}.finite) (uU : (â‹ƒ (i : Î¹), Metric.Ball (c i) (r i)) = Set.Univ) : âˆƒ (r' : Î¹ â†’ â„), (â‹ƒ (i : Î¹), Metric.Ball (c i) (r' i)) = Set.Univ âˆ§ âˆ€ (i : Î¹), r' i âˆˆ Set.Ioo 0 (r i)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {x : E} {f' : TangentSpace (modelWithCornersSelf ð•œ E) x â†’L[ð•œ] TangentSpace (modelWithCornersSelf ð•œ E') (f x)} : HasMfderivAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f x f' â†’ HasFderivAt f f' x
{G : Type u_1} [AddGroup G] (tG : Add_monoid.is_torsion_free G) (H : AddSubgroup G) : Add_monoid.is_torsion_free â†¥H
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x y : Î±} : Metric.infDist x s â‰¤ Metric.infDist y s + HasDist.dist x y
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} {T : addSubmonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [AddCommMonoid Q] {k : T.localization_Map Q} {A : Type u_5} [AddCommMonoid A] {U : addSubmonoid A} {R : Type u_6} [AddCommMonoid R] (j : U.localization_Map R) {l : P â†’+ A} (hl : âˆ€ (w : â†¥T), â‡‘l â†‘w âˆˆ U) : (k.map hl j).comp (f.map hy k) = f.map _ j
{Î± : Type u_1} [Preorder Î±] [BoundedOrder Î±] [IsSimpleOrder Î±] {a b : Î±} (h : a < b) : b = âŠ¤
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (hab : a < b) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : f (â‡‘(AffineMap.lineMap a b) r) < â‡‘(AffineMap.lineMap (f a) (f b)) r â†” slope f a (â‡‘(AffineMap.lineMap a b) r) < slope f (â‡‘(AffineMap.lineMap a b) r) b
{A : Type u_1} {R : Type u_2} (K : Type u_3) [CommRing A] [is_IsDomain A] [NormalizedGcdMonoid A] [Field K] [CommRing R] [is_IsDomain R] [Algebra A K] [IsFractionRing A K] [Algebra K R] [Algebra A R] [isScalarTower A K R] {x : R} (hx : IsIntegral A x) : minpoly K x = Polynomial.map (algebraMap A K) (minpoly A x)
{R : Type u_1} {M : Type u_3} {a b : R} [Monoid R] [mulAction R M] (h : a * b = 1) : IsSmulRegular M b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : E â†’ G} {x : E} {y : F} (hF : ContDiffAt ð•œ n f x) : ContDiffAt ð•œ n (Î» (x : E Ã— F), f x.fst) (x, y)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {f g : E â†’ F} (hF : ContDiff ð•œ n f) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Î» (x : E), f x - g x)
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {C : â„} (hâ‚€ : 0 â‰¤ C) (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ HasDist.dist x y â‰¤ C) : Metric.diam s â‰¤ C
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {x : E} {n : WithTop â„•} {f : E â†’ F} {g : E â†’ G} (hF : ContDiffAt ð•œ n f x) (hg : ContDiffAt ð•œ n g x) : ContDiffAt ð•œ n (Î» (x : E), (f x, g x)) x
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] : IsNoetherian K V â†” Module.Finite K V
(R : Type u) [Ring R] [StrongRankCondition R] (m n : Type u) [Fintype m] [Fintype n] : Module.rank R (Matrix m n R) = Cardinal.mk m * Cardinal.mk n
{Î± : Type u} [PartialOrder Î±] {a b : Î±} : a â‰¤ b â†’ a â‰  b â†’ a < b
{Mâ‚€ : Type u_1} [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” b * a â‰  0
{Î± : Type u_1} [PartialOrder Î±] [succOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ Set.Ico n m â†’ r i (Order.succ i)) (hnm : n < m) : Relation.TransGen r n m
{A : Type u_1} {K : Type u_2} [CommRing A] [is_IsDomain A] [UniqueFactorizationMonoid A] [Field K] [Algebra A K] [IsFractionRing A K] {p : Polynomial A} (hp : p.monic) {r : K} (hr : â‡‘(Polynomial.aeval r) p = 0) : IsLocalization.IsInteger A r
(ð•œ : Type u_1) {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {v : E} (w : E) : â†‘(â‡‘(orthogonalProjection (Submodule.span ð•œ {v})) w) = (HasInner.inner v w / â†‘âˆ¥vâˆ¥ ^ 2) â€¢ v
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] [denselyOrdered Î²] {f : Î± â†’ Î²} (h_Mono : Monotone f) (h_surj : Function.Surjective f) : Continuous f
{Î± : Type u} {s : Set Î±} : s.finite âˆ¨ s.infinite
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace ð•œ] (s : Submodule ð•œ E) [FiniteDimensional ð•œ â†¥s] : IsComplete â†‘s
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] [Nontrivial E] {x : E} {r : â„} : (Metric.Sphere x r).nonempty â†” 0 â‰¤ r
{Î¹ : Type u_1} {N : Type u_5} [orderedAddCommMonoid N] {f g : Î¹ â†’ N} {s : Finset Î¹} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰¤ g i) : s.sum (Î» (i : Î¹), f i) â‰¤ s.sum (Î» (i : Î¹), g i)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (lâ‚ lâ‚‚ : Î¹ â†’ ð•œ) (s : Finset Î¹) : HasInner.inner (s.sum (Î» (i : Î¹), lâ‚ i â€¢ v i)) (s.sum (Î» (i : Î¹), lâ‚‚ i â€¢ v i)) = s.sum (Î» (i : Î¹), â‡‘(starRingEnd ð•œ) (lâ‚ i) * lâ‚‚ i)
{G : Type u_1} [AddGroup G] (g1 g2 : G) : g1 -áµ¥ g2 = g1 - g2
{P : Type u_2} [metricSpace P] (ps : Set P) : EuclideanGeometry.Cospherical ps â†” âˆƒ (Center : P) (radius : â„), âˆ€ (p : P), p âˆˆ ps â†’ HasDist.dist p Center = radius
{Î± : Type u_1} [topologicalSpace Î±] {s : Set Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] [HasContinuousAdd Î³] {f g : Î± â†’ Î³} (hF : LowerSemicontinuousOn f s) (hg : LowerSemicontinuousOn g s) : LowerSemicontinuousOn (Î» (z : Î±), f z + g z) s
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : Polynomial A} (pnz : p â‰  0) (hp : â‡‘(Polynomial.aeval x) p = 0) : (minpoly A x).degree â‰¤ p.degree
{Î± : Type u} {Î² : Type v} [pseudoEmetricSpace Î±] [pseudoEmetricSpace Î²] {f : Î± â†’ Î²} (hF : Isometry f) : Continuous f
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [FiniteDimensional k V] {s : Set P} (hi : AffineIndependent k Coe) : s.finite
{Î¹ : Type u_1} {E : Type u_3} [semiNormedGroup E] [CompleteSpace E] {f : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : Summable g) (h : âˆ€á¶  (i : Î¹) in Filter.cofinite, âˆ¥f iâˆ¥ â‰¤ g i) : Summable f
{Î± : Type u} [AddCommGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] {a b c : Î±} : a - b â‰¤ c â†’ a â‰¤ b + c
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} : Metric.hausdorffDist s s = 0
{K : Type u} [Field K] {s : Set K} : s âŠ† â†‘(Subfield.closure s)
{Î¹ : Type u_1} {R : Type u_4} [DecidableEq Î¹] [AddMonoid Î¹] [Semiring R] (A : Î¹ â†’ addSubmonoid R) [SetLike.GradedMonoid A] (i : Î¹) (x : â†¥(A i)) : â‡‘(DirectSum.coeRingHom A) (â‡‘(DirectSum.of (Î» (i : Î¹), â†¥(A i)) i) x) = â†‘x
{Î± Î² : Type u} (r : Î± â†’ Î± â†’ Prop) [wo : IsWellOrder Î± r] (s : Î² â†’ Set Î±) (hâ‚ : Set.Unbounded r (â‹ƒ (x : Î²), s x)) (hâ‚‚ : Cardinal.mk Î² < StrictOrder.cof r) : âˆƒ (x : Î²), Set.Unbounded r (s x)
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F G : J â¥¤ C} [CategoryTheory.Limits.HasLimit F] (Î± : F â‰… G) : CategoryTheory.Limits.HasLimit G
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : â‡‘(EuclideanGeometry.reflection s) p = â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p) -áµ¥ p +áµ¥ â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p)
{n : â„•} (p : Fin (n + 1)) (i : Fin n) (h : â‡‘fin.cast_Succ i < p) : â‡‘(p.succ_above) i = â‡‘fin.cast_Succ i
{G : Type u_1} [AddGroup G] (H N : AddSubgroup G) [N.normal] : â†‘(H âŠ” N) = â†‘H + â†‘N
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {t : Set (Set Î±)} (h : t.pairwise_Disjoint Id) (htâ‚€ : t.finite) (htâ‚ : âˆ€ (x : Set Î±), x âˆˆ t â†’ x.finite) : finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒâ‚€t), f a)) = finsum (Î» (s : Set Î±), finsum (Î» (H : s âˆˆ t), finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ s), f a))))
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸â‚ Î¸â‚‚ : Real.Angle) : (o.rotation Î¸â‚).trans (o.rotation Î¸â‚‚) = o.rotation (Î¸â‚‚ + Î¸â‚)
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : f =O[l] g' â†” âˆ€á¶  (c : â„) in Filter.atTop, asymptotics.is_O_with c l f g'
{Î± : Type u_1} [LinearOrder Î±] {s : Set Î±} : Â¬BddAbove s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), x < y
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {A B : Matrix n n Î±} (h : A.mul B = 1) : Aâ»Â¹ = B
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.forget C)] {X : Top} (F : Top.Sheaf C X) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥X) (V : TopologicalSpace.Opens â†¥X) (iUV : Î  (i : Î¹), U i âŸ¶ V) (hcover : V â‰¤ supr U) (sf : Î  (i : Î¹), â†¥(F.val.obj (Opposite.op (U i)))) (h : F.val.is_compatible U sf) : âˆƒ! (s : â†¥(F.val.obj (Opposite.op V))), âˆ€ (i : Î¹), â‡‘(F.val.map (iUV i).op) s = sf i
(n k : â„•) : n.factorial * n.asc_factorial k = (n + k).factorial
{Î± : Type u_1} {Î² : Type u_2} [measurableSpace Î±] [measurableSpace Î²] (e : Î± â‰ƒáµ Î²) : MeasurableEmbedding â‡‘e
{F : Type u_3} [innerProductSpace â„ F] (x : F) (r : â„) : HasInner.inner x (r â€¢ x) = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : hb.oangle (â‡‘(hb.rotation Î¸) x) y = hb.oangle x y - Î¸
 : CategoryTheory.EssSurj compactumToCompHaus
{D : Set â„} (hD : Convex â„ D) (hDâ‚‚ : is_IsOpen D) {f : â„ â†’ â„} (hF' : DifferentiableOn â„ f D) (hF'' : DifferentiableOn â„ (deriv f) D) (hF''_nonpos : âˆ€ (x : â„), x âˆˆ D â†’ deriv^[2] f x â‰¤ 0) : ConcaveOn â„ D f
{k : Type u_1} {K : Type u_2} [Field k] [IsAlgClosed k] [Field K] {f : k â†’+* K} (p : Polynomial k) : Polynomial.Splits f p
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [FiniteDimensional k V] [Fintype Î¹] {p : Î¹ â†’ P} (hi : AffineIndependent k p) (hc : Fintype.card Î¹ = FiniteDimensional.finrank k V + 1) : vectorSpan k (Set.Range p) = âŠ¤
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (Q : C) (a : â†¥P) : â‡‘0 a = 0
{E : Type u_1} {F : Type u_2} {ð•œ : Type u_3} {ð•œâ‚‚ : Type u_4} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] {Î¹ : Type u_5} [CompleteSpace E] {g : Î¹ â†’ (E â†’sl[Ïƒâ‚â‚‚] F)} (h : âˆ€ (x : E), (â¨† (i : Î¹), â†‘âˆ¥â‡‘(g i) xâˆ¥â‚Š) < âŠ¤) : (â¨† (i : Î¹), â†‘âˆ¥g iâˆ¥â‚Š) < âŠ¤
{G : Type u_1} [AddGroup G] {x y : G} : y âˆˆ AddSubgroup.closure {x} â†” âˆƒ (n : â„¤), n â€¢ x = y
{G : Type u_1} [AddGroup G] (H : AddSubgroup G) {x y : G} : x âˆˆ H â†’ y âˆˆ H â†’ x + y âˆˆ H
{M : Type u_1} [MulOneClass M] {c : Con M} : â†‘1 = 1
{R : Type u_1} [MulZeroClass R] (h : IsRegular 0) : Subsingleton R
{C : Type u} [CategoryTheory.Category C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ C) [CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor F.obj)] [CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor (Î» (f : Î£ (p : J Ã— J), p.fst âŸ¶ p.snd), F.obj f.fst.snd))] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasLimit F
{Î· : Type u_2} [Fintype Î·] {Gs : Î· â†’ Type u_3} [Î  (i : Î·), Group (Gs i)] [âˆ€ (i : Î·), group.is_nilpotent (Gs i)] : group.nilpotency_class (Î  (i : Î·), Gs i) = finset.univ.sup (Î» (i : Î·), group.nilpotency_class (Gs i))
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
{p : â„•} (hp : Nat.Prime p) (n : â„•) : (p ^ (n + 1)).totient = p ^ n * (p - 1)
{Î± : Type u} [pseudoEmetricSpace Î±] {f : â„• â†’ Î±} {m n : â„•} (hmn : m â‰¤ n) {d : â„• â†’ Ennreal} (hD : âˆ€ {k : â„•}, m â‰¤ k â†’ k < n â†’ HasEdist.edist (f k) (f (k + 1)) â‰¤ d k) : HasEdist.edist (f m) (f n) â‰¤ (Finset.ico m n).sum (Î» (i : â„•), d i)
{R : Type u_4} {S : Type u_5} [NonAssocSemiring R] [NonAssocSemiring S] (f : R â‰ƒ+* S) : â‡‘f 1 = 1
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {ps : Set P} {n : â„•} [FiniteDimensional â„ V] (hD : FiniteDimensional.finrank â„ V = n) (hc : EuclideanGeometry.Cospherical ps) {sxâ‚ sxâ‚‚ : Affine.Simplex â„ P n} (hsxâ‚ : Set.Range sxâ‚.points âŠ† ps) (hsxâ‚‚ : Set.Range sxâ‚‚.points âŠ† ps) : sxâ‚.circumradius = sxâ‚‚.circumradius
 : List.Nat.antidiagonal 0 = [(0, 0)]
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D â¥¤ C} [CategoryTheory.Reflective i] (X : C) : (CategoryTheory.Adjunction.ofRightAdjoint i).unit.app (i.obj ((CategoryTheory.leftAdjoint i).obj X)) = i.map ((CategoryTheory.leftAdjoint i).map ((CategoryTheory.Adjunction.ofRightAdjoint i).unit.app X))
 : Multiset.Nat.antidiagonal 0 = {(0, 0)}
{Î± : Type u} [topologicalSpace Î±] [t2_Space Î±] {K U V : Set Î±} (hK : is_IsCompact K) (hU : is_IsOpen U) (hV : is_IsOpen V) (h2K : K âŠ† U âˆª V) : âˆƒ (Kâ‚ Kâ‚‚ : Set Î±), is_IsCompact Kâ‚ âˆ§ is_IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [isScalarTower R A B] (A_Int : Algebra.IsIntegral R A) (x : B) (hx : IsIntegral A x) : IsIntegral R x
{x y : Pgame} (ox : x.numeric) (oy : y.numeric) : x < y â†” (âˆƒ (i : y.left_moves), (âˆ€ (i' : x.left_moves), x.move_Left i' < y.move_Left i) âˆ§ âˆ€ (j : (y.move_Left i).right_moves), x < (y.move_Left i).move_Right j) âˆ¨ âˆƒ (j : x.right_moves), (âˆ€ (i : (x.move_Right j).left_moves), (x.move_Right j).move_Left i < y) âˆ§ âˆ€ (j' : y.right_moves), x.move_Right j < y.move_Right j'
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [addCancelCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [HasScalar ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : StrictConcaveOn ð•œ s f) (c : E) : StrictConcaveOn ð•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] [Group Î±] [UniformGroup Î±] {hom : Type u_3} [uniformSpace Î²] [discreteTopology Î²] [Group Î²] [UniformGroup Î²] [monoidHomClass hom Î± Î²] {f : hom} : UniformContinuous â‡‘f â†” is_IsOpen â†‘(â†‘f.ker)
{Î± : sort u_1} {sâ‚ : Setoid Î±} {p : Quotient sâ‚ â†’ Prop} (h : âˆ€ (a : Î±), p (Quotient.mk' a)) (q : Quotient sâ‚) : p q
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] {F : Type v} [NormedGroup F] [normedSpace â„‚ F] [Nontrivial E] {f : E â†’ F} {U : Set E} (hU : Metric.Bounded U) (hD : DiffContOnCl â„‚ f U) {C : â„} (hC : âˆ€ (z : E), z âˆˆ Frontier U â†’ âˆ¥f zâˆ¥ â‰¤ C) {z : E} (hz : z âˆˆ Closure U) : âˆ¥f zâˆ¥ â‰¤ C
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.IsEquivalence F] : CategoryTheory.EssSurj F
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (v : E) : v - â†‘(â‡‘(orthogonalProjection K) v) âˆˆ Ká—®
{Î± : Type u_1} {Î¹' : sort u_5} {f : Filter Î±} [h : f.is_countably_generated] {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set Î±} (hs : f.has_Basis p s) : âˆƒ (x : â„• â†’ Î¹'), (âˆ€ (i : â„•), p (x i)) âˆ§ f.has_Antitone_Basis (Î» (i : â„•), s (x i))
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [HasScalar ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : ConvexOn ð•œ s f) (c : E) : ConvexOn ð•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {s : Set E} {x : E} : UniqueDiffWithinAt ð•œ s x â†’ UniqueMdiffWithinAt (modelWithCornersSelf ð•œ E) s x
{C : Type u} [CategoryTheory.Category C] {X Y : C} (J : CategoryTheory.GrothendieckTopology C) (f : Y âŸ¶ X) (S R : CategoryTheory.Sieve X) (h : J.covers S f) : (âˆ€ {Z : C} (g : Z âŸ¶ X), â‡‘S g â†’ J.covers R g) â†’ J.covers R f
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] {F : Type w} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace ð•œ] {X : Type u_1} [topologicalSpace X] [FiniteDimensional ð•œ E] {f : X â†’ (E â†’L[ð•œ] F)} {s : Set X} : ContinuousOn f s â†” âˆ€ (y : E), ContinuousOn (Î» (x : X), â‡‘(f x) y) s
{Î± : Type u} [pseudoMetricSpace Î±] {x : Î±} {r : â„} : Metric.Bounded (Metric.ClosedBall x r)
{a : â„•} (a1 : 1 < a) {x y : â„•} (hp : x * x - d a1 * y * y = 1) : âˆƒ (n : â„•), x = Pell.xn a1 n âˆ§ y = Pell.yn a1 n
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hr : WellFounded r) : WellFounded (Relation.CutExpand r)
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semiNormedGroup Vâ‚] [semiNormedGroup Vâ‚‚] : âˆ¥0âˆ¥ = 0
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {f : Î± â†’ Î²} (hF : IsGroupHom f) : Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (A : Matrix m m R) (B : Matrix m n R) (D : Matrix n n R) : (Matrix.fromBlocks A B 0 D).det = A.det * D.det
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), Group (Gs i)] (H K : Î  (i : Î·), Subgroup (Gs i)) : â…Subgroup.pi Set.Univ H,Subgroup.pi Set.Univ Kâ† â‰¤ Subgroup.pi Set.Univ (Î» (i : Î·), â…H i,K iâ†)
{Î± : Type u_1} {r : Setoid Î±} (a : Î±) : âˆƒ! (b : Set Î±) (H : b âˆˆ r.classes), a âˆˆ b
{R : Type u} [CommRing R] [is_IsDomain R] (a : R) (n : â„•) : Polynomial.rootMultiplicity a ((Polynomial.x - â‡‘Polynomial.c a) ^ n) = n
{ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [NormedGroup G] [normedSpace ð•œ G] {f : ?? â†’ G} (hF : Differentiable ð•œ f) (hF' : âˆ€ (x : ð•œ), deriv f x = 0) (x y : ð•œ) : f x = f y
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} : Metric.hausdorffDist s âˆ… = 0
{Î± : Type u_1} {Î² : Type u_2} [completeLattice Î±] {f : Filter Î²} {u : Î² â†’ Î±} : f.limsup u = â¨… (s : Set Î²) (H : s âˆˆ f), â¨† (a : Î²) (H : a âˆˆ s), u a
{cb : CharBuffer} {n n' val : â„•} (h : Parser.nat cb n = ParseResult.done n' val) : val = Nat.ofDigits 10 (List.map (Î» (c : Char), c.to_Nat - '0'.to_Nat) (List.take (n' - n) (List.drop n (Buffer.toList cb))).reverse)
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {x : ð•œ} {s : Set ð•œ} {f' : ð•œ â†’L[ð•œ] F} : HasFderivWithinAt f f' s x â†” HasDerivWithinAt f (â‡‘f' 1) s x
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} {Î¹ : Type v} (hs : is_IsCompact s) (Z : Î¹ â†’ Set Î±) (hZc : âˆ€ (i : Î¹), is_IsClosed (Z i)) (hsZ : âˆ€ (t : Finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i).nonempty) : (s âˆ© â‹‚ (i : Î¹), Z i).nonempty
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) (v : E) : v âˆˆ Ká—® â†” âˆ€ (u : E), u âˆˆ K â†’ HasInner.inner v u = 0
{R : Type u_1} [CommRing R] [Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : P.is_Maximal] : ((Ideal.Quotient.mk P).comp Polynomial.c).is_integral
{a b : â„} {g' g : â„ â†’ â„} (hab : a â‰¤ b) (hcont : ContinuousOn g (Set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt g (g' x) (Set.Ioi x) x) (g'Pos : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 â‰¤ g' x) : MeasureTheory.IntegrableOn g' (Set.Ioc a b) MeasureTheory.MeasureSpace.volume
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [Ring k] [AddCommGroup V1] [Module k V1] [addTorsor V1 P1] [AddCommGroup V2] [Module k V2] [addTorsor V2 P2] [AddCommGroup V3] [Module k V3] [addTorsor V3 P3] (f : P2 â†’áµƒ[k] P3) (g : P1 â†’áµƒ[k] P2) : â‡‘(f.comp g) = â‡‘f âˆ˜ â‡‘g
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] {s t : Set E} (hsâ‚ : Convex â„ s) (hsâ‚‚ : is_IsClosed s) (htâ‚ : Convex â„ t) (htâ‚‚ : is_IsCompact t) (disj : Disjoint s t) : âˆƒ (f : E â†’L[â„] â„) (u v : â„), (âˆ€ (a : E), a âˆˆ s â†’ â‡‘f a < u) âˆ§ u < v âˆ§ âˆ€ (b : E), b âˆˆ t â†’ v < â‡‘f b
{Î± : Type u_3} {Î² : Type u_4} [Preorder Î²] {f : Î² â†’ Finset Î±} (h : Monotone f) (h' : âˆ€ (x : Î±), âˆƒ (n : Î²), x âˆˆ f n) : Filter.Tendsto f Filter.atTop Filter.atTop
{Î± : Type u_1} [linearOrderedField Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 1 / a â‰¤ 1 / b â†” b â‰¤ a
{Î± : Type u_1} (L : List (List Î±)) (i : â„•) : List.drop (List.take i (List.map List.length L)).sum L.join = (List.drop i L).join
{R : Type u} [NonAssocSemiring R] {s : Set R} {p : R â†’ R â†’ Prop} {x y : R} (hx : x âˆˆ Subsemiring.closure s) (hy : y âˆˆ Subsemiring.closure s) (Hs : âˆ€ (x : R), x âˆˆ s â†’ âˆ€ (y : R), y âˆˆ s â†’ p x y) (H0_Left : âˆ€ (x : R), p 0 x) (H0_Right : âˆ€ (x : R), p x 0) (H1_Left : âˆ€ (x : R), p 1 x) (H1_Right : âˆ€ (x : R), p x 1) (HAdd_Left : âˆ€ (xâ‚ xâ‚‚ y : R), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ + xâ‚‚) y) (HAdd_Right : âˆ€ (x yâ‚ yâ‚‚ : R), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ + yâ‚‚)) (HMul_Left : âˆ€ (xâ‚ xâ‚‚ y : R), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ * xâ‚‚) y) (HMul_Right : âˆ€ (x yâ‚ yâ‚‚ : R), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ * yâ‚‚)) : p x y
{Î± : Type u} (s : Set Î±) : is_IsClosed {u : Ultrafilter Î± | s âˆˆ u}
{Î± : Type u} [topologicalSpace Î±] [SigmaCompactSpace Î±] {Î¹ : Type u_1} {f : Î¹ â†’ Set Î±} (hF : LocallyFinite f) (hne : âˆ€ (i : Î¹), (f i).nonempty) : set.univ.countable
{F : Type u_3} [Field F] [Fintype F] (hF : ringChar F = 2) (a : F) : IsSquare a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {p1 : P} {p : Î¹ â†’ P} (h : p1 âˆˆ affineSpan k (Set.Range p)) : âˆƒ (s : Finset Î¹) (w : Î¹ â†’ k) (hw : s.sum (Î» (i : Î¹), w i) = 1), p1 = â‡‘(s.affine_combination p) w
{n : Type u_3} [Fintype n] {A : Type u_1} [DecidableEq n] [CommRing A] [is_IsDomain A] {M : Matrix n n A} : M.nondegenerate â†’ M.det â‰  0
 : â‡‘MeasureTheory.MeasureSpace.volume {x : â„ | Liouville x} = 0
(k : Type uâ‚) {G : Type uâ‚‚} [Semiring k] [hasMul G] {A : Type uâ‚ƒ} [NonUnitalNonAssocSemiring A] [DistribMulAction k A] {Ï†â‚ Ï†â‚‚ : MonoidAlgebra k G â†’â‚™â‚[k] A} (h : âˆ€ (x : G), â‡‘Ï†â‚ (Finsupp.single x 1) = â‡‘Ï†â‚‚ (Finsupp.single x 1)) : Ï†â‚ = Ï†â‚‚
{M : Type u_1} [MulOneClass M] {s : Set M} {p : M â†’ Prop} {x : M} (h : x âˆˆ Submonoid.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (H1 : p 1) (HMul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) : p x
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : M (Sum.inr ()) (Sum.inr ()) â‰  0) : âˆƒ (L L' : List (Matrix.TransvectionStruct (Fin r âŠ• Unit) ð•œ)), (((List.map Matrix.TransvectionStruct.toMatrix L).prod.mul M).mul (List.map Matrix.TransvectionStruct.toMatrix L').prod).is_two_block_Diagonal
{M : Type u_1} [Monoid M] {s t : Set M} (ht : IsSubmonoid t) (h : s âŠ† t) : monoid.closure s âŠ† t
(a : â„¤) : â†‘(a.nat_Abs) â‰¤ a ^ 2
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {s : Set (E Ã— F)} : ContDiffOn ð•œ n Prod.fst s
{Î± : Type u_1} [LinearOrder Î±] [succOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ Set.Ico n m â†’ r i (Order.succ i)) (h2 : âˆ€ (i : Î±), i âˆˆ Set.Ico m n â†’ r (Order.succ i) i) : Relation.ReflTransGen r n m
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [normedCommRing ð•œ] [AddCommMonoid E] [AddCommMonoid F] [Module ð•œ E] [Module ð•œ F] (B : E â†’â‚—[ð•œ] F â†’â‚—[ð•œ] ð•œ) : GaloisConnection (â‡‘OrderDual.toDual âˆ˜ B.polar) (B.flip.polar âˆ˜ â‡‘OrderDual.ofDual)
{Î± : Type u_2} [Bornology Î±] {s : Set Î±} : Bornology.IsBounded sá¶œ â†’ Bornology.IsCobounded s
{n : Type u_3} {Î± : Type v} [Fintype n] [nonUnitalSemiring Î±] [starRing Î±] (M N : Matrix n n Î±) : HasStar.star (M.mul N) = (HasStar.star N).mul (HasStar.star M)
(C : Type u) [CategoryTheory.Category C] [âˆ€ {J : Type v} {X Y : C} {f : J â†’ (X âŸ¶ Y)}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelFamily f)] : CategoryTheory.Limits.HasWideEqualizers C
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] [is_IsDomain Î²] (e : Î± â‰ƒ+* Î²) : is_IsDomain Î±
{m : â„¤} (hmâ‚€ : m â‰  0) (hmâ‚ : m â‰  1) : StrictConvexOn â„ (Set.Ioi 0) (Î» (x : â„), x ^ m)
{l : Filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in Filter.atTop, DifferentiableAt â„ f x) (hg' : âˆ€á¶  (x : â„) in Filter.atTop, deriv g x â‰  0) (hftop : Filter.Tendsto f Filter.atTop (nhds 0)) (hgtop : Filter.Tendsto g Filter.atTop (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv f x / deriv g x) Filter.atTop l) : Filter.Tendsto (Î» (x : â„), f x / g x) Filter.atTop l
(M : Type u_1) (Î± : Type u_2) [Monoid M] [mulAction M Î±] {s t : Set Î±} : fixingSubmonoid M (s âˆª t) = fixingSubmonoid M s âŠ“ fixingSubmonoid M t
{R : Type u_1} {M : Type u_2} [linearOrderedSemiring R] [orderedAddCommMonoid M] [mulActionWithZero R M] (hR : âˆ€ {c : R}, c â‰  0 â†’ IsUnit c) (hlt : âˆ€ â¦ƒa b : Mâ¦„ â¦ƒc : Râ¦„, a < b â†’ 0 < c â†’ c â€¢ a â‰¤ c â€¢ b) : OrderedSmul R M
{Î± : Type u} [hasSsubset Î±] [IsIrrefl Î± HasSsubset.Ssubset] {a : Î±} : Â¬a âŠ‚ a
{X : Type u} [metricSpace X] [CompactSpace X] [Nonempty X] {Y : Type v} [metricSpace Y] [CompactSpace Y] [Nonempty Y] {Î³ : Type w} [metricSpace Î³] {Î¦ : X â†’ Î³} {Î¨ : Y â†’ Î³} (ha : Isometry Î¦) (hb : Isometry Î¨) : Gromov_Hausdorff.GH_dist X Y â‰¤ Metric.hausdorffDist (Set.Range Î¦) (Set.Range Î¨)
{Î± : Type u} [pseudoMetricSpace Î±] {x : Î±} {u : Set Î±} (hu : u âˆˆ nhds x) : âˆ€á¶  (r : â„) in nhds 0, Metric.ClosedBall x r âŠ† u
{M : Type u_3} [Monoid M] [Preorder M] (L : List M) (h : 1 < L.prod) : 0 < L.length
{G : Type u_7} [Group G] (L : List G) (i : â„•) (p : i < L.length) : (List.drop (i + 1) L).prod = (L.nth_LE i p)â»Â¹ * (List.drop i L).prod
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {mÎ± : measurableSpace Î±} [measurableSpace Î²] [topologicalSpace Î²] [TopologicalSpace.MetrizableSpace Î²] [BorelSpace Î²] [TopologicalSpace.SecondCountableTopology Î²] : MeasureTheory.StronglyMeasurable f â†” Measurable f
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (h : 0 < r * (b - a)) : â‡‘(AffineMap.lineMap (f a) (f b)) r â‰¤ f (â‡‘(AffineMap.lineMap a b) r) â†” slope f a b â‰¤ slope f a (â‡‘(AffineMap.lineMap a b) r)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {s : Set E} {x : E} : DifferentiableWithinAt ð•œ f s x â†’ MdifferentiableWithinAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f s x
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (Î¸ : Real.Angle) : o.oangle x y = Î¸ â†” (x â‰  0 âˆ§ y â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(o.rotation Î¸) x) âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} (g : F â†’L[ð•œ] G) (h : HasFpowerSeriesOnBall f p x r) : HasFpowerSeriesOnBall (â‡‘g âˆ˜ f) (g.comp_FormalMultilinearSeries p) x r
{Î± : Type u} [topologicalSpace Î±] {f : Filter Î±} {a : Î±} {s : Set Î±} (h : a âˆˆ s) (o : is_IsOpen s) (sf : Filter.principal s â‰¤ f) : nhds a â‰¤ f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {a : E} (hF : HasStrictFderivAt f f' a) (hF' : f'.range = âŠ¤) (hker : f'.ker.closed_complemented) : âˆ€á¶  (x : E) in nhds a, HasStrictFderivAt.implicitFunctionOfComplemented f f' hF hF' hker (f x) (â‡‘(HasStrictFderivAt.implicitToLocalHomeomorphOfComplemented f f' hF hF' hker) x).snd = x
{n : â„•} {E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : (Fin (n + 1) â†’ â„‚) â†’ E} {c : Fin (n + 1) â†’ â„‚} {R : Fin (n + 1) â†’ â„} (hF : TorusIntegrable f c R) : âˆ¯ (x : Fin (n + 1) â†’ â„‚) in T(c, R), f x = âˆ® (x : â„‚) in C(c 0, R 0), âˆ¯ (y : Fin n â†’ â„‚) in T(c âˆ˜ Fin.succ, R âˆ˜ Fin.succ), f (fin.cons x y)
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hD : DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz_re : z.re â‰¤ 0) (hz_im : z.im â‰¤ 0) : âˆ¥f zâˆ¥ â‰¤ C
{Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} : lâ‚ <:+: lâ‚‚ â†’ lâ‚.reverse <:+: lâ‚‚.reverse
{Î± : Type u} [nonUnitalRing Î±] {a b c : Î±} (h : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c
{X : Type u_1} [topologicalSpace X] [NormalSpace X] {s t : Set X} (hs : is_IsClosed s) (ht : is_IsClosed t) (hD : Disjoint s t) : âˆƒ (f : C(X, â„)), Set.EqOn â‡‘f 0 s âˆ§ Set.EqOn â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ Set.Icc 0 1
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) : (SpanPoints k s).nonempty â†” s.nonempty
{Î± : Type u} {l : List Î±} : l.sublists'.nodup â†’ l.nodup
{R : Type u_1} [Ring R] (s : Subring R) (m : Multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {X Y : C} (f : X âŸ¶ Y) (s : Function.Surjective â‡‘f) : CategoryTheory.Epi f
{ð•œ : Type u_1} {E : Type u_3} [normedField ð•œ] [AddCommGroup E] [Module ð•œ E] {A : Set E} [topologicalSpace E] [HasContinuousSmul ð•œ E] (hA : Balanced ð•œ A) : Balanced ð•œ (0 âˆª Interior A)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [normedSpace â„ E] : IsBoundedBilinearMap â„ (Î» (p : E Ã— E), HasInner.inner p.fst p.snd)
{Î± : Type u} [Lattice Î±] [AddCommGroup Î±] (a : Î±) (h : 0 â‰¤ a) : aâº = a
{Î± : Type u} [pseudoEmetricSpace Î±] {x y : Î±} : Emetric.infEdist x {y} = HasEdist.edist x y
(n : â„•) {R : Type u_1} {S : Type u_2} [Ring R] [Ring S] (f : R â†’+* S) : Polynomial.map f (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S
{Î¹ : Type u_1} {R : Type u_8} [OrderedCommSemiring R] {f g : Î¹ â†’ R} {s : Finset Î¹} (h0 : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ f i) (h1 : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰¤ g i) : s.prod (Î» (i : Î¹), f i) â‰¤ s.prod (Î» (i : Î¹), g i)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X âŸ¶ Y) [CategoryTheory.Limits.HasCokernel (f - g)] : CategoryTheory.Limits.HasCoequalizer f g
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) {u v : E} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : E), w âˆˆ K â†’ HasInner.inner (u - v) w = 0
{Î± : Type u} {Î² : Type v} [MulOneClass Î±] [Group Î²] {f : Î± â†’ Î²} (hF : IsMulHom f) : IsMonoidHom f
{Î± : Type u} [topologicalSpace Î±] {Î¹ : Type u_1} {f : Î¹ â†’ Set Î±} (hF : LocallyFinite f) {s : Set Î±} (hs : is_IsCompact s) : {i : Î¹ | (f i âˆ© s).nonempty}.finite
{s : Set â„} (h : Metric.Bounded s) : Emetric.diam s = Ennreal.ofReal (HasSup.sup s - HasInf.inf s)
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b c : Î±} : a < b + c â†’ -b + a < c
(Î± : Type u) [t : topologicalSpace Î±] [TopologicalSpace.SeparableSpace Î±] [Nonempty Î±] : DenseRange (TopologicalSpace.denseSeq Î±)
{Î± : Type u} [pseudoMetricSpace Î±] (s : Set Î±) : LipschitzWith 1 (Î» (x : Î±), Metric.infNndist x s)
{C : Type uâ‚} [CategoryTheory.Category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {X : C} (R : CategoryTheory.Presieve X) [CategoryTheory.Limits.HasPullbacks C] (x : CategoryTheory.Equalizer.FirstObj P R) : ((CategoryTheory.Equalizer.firstObjEqFamily P R).hom x).compatible â†” CategoryTheory.Equalizer.Presieve.firstMap P R x = CategoryTheory.Equalizer.Presieve.secondMap P R x
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 âˆˆ s) : â†‘(âŸ¨p1, hp1âŸ© -áµ¥ â‡‘(EuclideanGeometry.orthogonalProjection s) p2) âˆˆ s.direction
{R : Type u_1} [Ring R] {f g : â„• â†’ R} : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.sum (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.sum (Î» (x : â„• Ã— â„•), â†‘(â‡‘Nat.ArithmeticFunction.moebius x.fst) * g x.snd) = f n
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscreteNormedField R] [NormedGroup F] [normedSpace R F] [topologicalSpace B] {Î¹ : Type u_6} (Z : TopologicalVectorBundleCore R B F Î¹) : is_is_IsOpenMap Z.proj
{R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} [HasScalar R M] [HasScalar R S] [HasScalar S M] [isScalarTower R S M] (b : S) (ha : IsSmulRegular M a) : IsSmulRegular M (a â€¢ b) â†” IsSmulRegular M b
{Î² : Type u_2} [CommMonoid Î²] {n : â„•} (f : Fin (n + 1) â†’ Î²) : finset.univ.prod (Î» (i : Fin (n + 1)), f i) = f 0 * finset.univ.prod (Î» (i : Fin n), f i.succ)
{G : Type u_1} [AddCommMonoid G] : Add_monoid.is_torsion â†¥(Add_comm_monoid.add_torsion G)
(ð•œ : Type u_1) [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (f : E â†’ F) [measurableSpace E] [OpensMeasurableSpace E] [CompleteSpace F] : MeasurableSet {x : E | DifferentiableAt ð•œ f x}
{ð•œ : Type u_3} {E : Type u_4} [normedField ð•œ] [semiNormedGroup E] [normedSpace ð•œ E] {r : â„} {x : E} (hx : âˆ¥xâˆ¥ < r) : Absorbent ð•œ (Metric.Ball x r)
{Î± : Type u} [topologicalSpace Î±] : TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), (ConnectedComponent x).subsingleton
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (i : Fin r âŠ• Unit) : (Matrix.Pivot.listTransvecCol M).prod.mul M (Sum.inr ()) i = M (Sum.inr ()) i
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (h : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) â‰  1) : s.nonempty
{Î¹ : Type u_1} {x : â„•} {s : Î¹ â†’ â„•} {t : Finset Î¹} : (âˆ€ (i : Î¹), i âˆˆ t â†’ (s i).coprime x) â†’ (t.prod (Î» (i : Î¹), s i)).coprime x
 : Â¬set.univ.countable
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_3} [Fintype Î±] [Fintype Î²] [AddCommMonoid M] (e : Î± â‰ƒ Î²) (f : Î± â†’ M) (g : Î² â†’ M) (h : âˆ€ (x : Î±), f x = g (â‡‘e x)) : finset.univ.sum (Î» (x : Î±), f x) = finset.univ.sum (Î» (x : Î²), g x)
{M : Type u_3} [Monoid M] (L : List M) (h : L.prod â‰  1) : 0 < L.length
{V : Type u_1} [innerProductSpace â„ V] (x y : V) {r : â„} (hr : 0 < r) : InnerProductGeometry.angle x (r â€¢ y) = InnerProductGeometry.angle x y
{Î± : Type u_1} {ð’œ : Finset (Finset Î±)} {Aâ‚ Aâ‚‚ : Finset Î±} {râ‚ râ‚‚ : â„•} (hâ‚ : Aâ‚ âˆˆ ð’œ.slice râ‚) (hâ‚‚ : Aâ‚‚ âˆˆ ð’œ.slice râ‚‚) : râ‚ â‰  râ‚‚ â†’ Aâ‚ â‰  Aâ‚‚
{ð•œ : Type u_1} {E : Type u_2} [normedLinearOrderedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] {A B : Set E} (hAB : IsExposed ð•œ A B) : âˆƒ (l : E â†’L[ð•œ] ð•œ) (a : ð•œ), B = {x âˆˆ A | a â‰¤ â‡‘l x}
(K : Type u_1) [Field K] [Fintype K] [Fintype KË£] (i : â„•) : finset.univ.sum (Î» (x : KË£), â†‘x ^ i) = Ite (Fintype.card K - 1 âˆ£ i) (-1) 0
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] {p : Î± â†’ Prop} {s : Finset {x // p x}} {f : {x // p x} â†’ Î²} {g : Î± â†’ Î²} (h : âˆ€ (x : {x // p x}), x âˆˆ s â†’ g â†‘x = f x) : (Finset.map (Function.Embedding.subtype (Î» (x : Î±), p x)) s).sum (Î» (x : Î±), g x) = s.sum (Î» (x : {x // p x}), f x)
{G : Type u_1} [Group G] (K : Subgroup G) : Subgroup.closure â†‘K = K
{Î± : Type u} [topologicalSpace Î±] [t2_Space Î±] [CompactSpace Î±] : TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î±
{f : â„ â†’ â„} {f' a : â„} (h : is_is_IsLocalMax f a) (hF : HasDerivAt f f' a) : f' = 0
{F : Type u_1} [NormedGroup F] [normedSpace â„ F] (f : â„ â†’ F) [CompleteSpace F] : MeasurableSet {x : â„ | DifferentiableWithinAt â„ f (Set.Ioi x) x}
{Î² : Type u_2} {f g : Î² â†’ Nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b) : Summable f â†’ Summable g
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [NormedGroup F] [normedSpace â„ F] {s : Set E} (s_conv : Convex â„ s) {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€ (x : E), x âˆˆ Interior s â†’ HasFderivAt f (f' x) x) {x : E} (xs : x âˆˆ s) (hx : HasFderivWithinAt f' f'' (Interior s) x) {v w : E} (h4v : x + 4 â€¢ v âˆˆ Interior s) (h4w : x + 4 â€¢ w âˆˆ Interior s) : â‡‘(â‡‘f'' w) v = â‡‘(â‡‘f'' v) w
{ð•œ : Type u} [nondiscreteNormedField ð•œ] (p : Polynomial ð•œ) (x : ð•œ) : HasDerivAt (Î» (x : ð•œ), Polynomial.eval x p) (Polynomial.eval x (â‡‘Polynomial.derivative p)) x
{Î± : Type u_1} [PartialOrder Î±] (c : closureOperator Î±) (x : Î±) : x â‰¤ â‡‘c x
{R : Type u_2} {Î“â‚€ : Type u_3} {Î“'â‚€ : Type u_4} [Ring R] [linearOrderedCommMonoidWithZero Î“â‚€] [linearOrderedCommMonoidWithZero Î“'â‚€] {vâ‚ : Valuation R Î“â‚€} {vâ‚‚ : Valuation R Î“'â‚€} {S : Type u_1} [Ring S] (f : S â†’+* R) (h : vâ‚.is_Equiv vâ‚‚) : (Valuation.comap f vâ‚).is_Equiv (Valuation.comap f vâ‚‚)
(n : â„•+) (S : Set â„•+) (K : Type w) (L : Type z) [Field K] [Field L] [Algebra K L] [NeZero â†‘â†‘n] [H : IsCyclotomicExtension S K L] (hS : n âˆˆ S) : Polynomial.Splits (algebraMap K L) (Polynomial.x ^ â†‘n - 1)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p : P) (h : s.sum (Î» (i : Î¹), w i) = 0) : â‡‘(s.weighted_vsub (Î» (_x : Î¹), p)) w = 0
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [LinearOrder Î±] [OrderClosedTopology Î±] [Nonempty Î±] [topologicalSpace Î²] [hasOne Î±] {f : Î² â†’ Î±} (hF : Continuous f) (h : HasCompactMulSupport f) : BddBelow (Set.Range f)
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} (h : Function.Injective f) (s : Set Î±) : Set.InjOn f s
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (M : Matrix n n R) : M.transpose.det = M.det
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] (f : S.localization_Map N) : f.of_mulEquiv_of_Dom _ = f
{k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G â†’+* R} (hâ‚ : f.comp MonoidAlgebra.singleOneRingHom = g.comp MonoidAlgebra.singleOneRingHom) (h_of : â†‘f.comp (MonoidAlgebra.of k G) = â†‘g.comp (MonoidAlgebra.of k G)) : f = g
(Î± : Type u) [uniformSpace Î±] [(Uniformity Î±).is_countably_generated] [TopologicalSpace.SeparableSpace Î±] : TopologicalSpace.SecondCountableTopology Î±
(R : Type u_1) [CommRing R] (M : Type u_2) [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [Nontrivial R] : â‡‘(LinearMap.trace R M) LinearMap.id = â†‘(FiniteDimensional.finrank R M)
{Î± : Type u_1} [linearOrderedField Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ < bâ»Â¹ â†” b < a
{Î± : Type u_1} {r s : Î± â†’ Î± â†’ Prop} (h : âˆ€ (x y : Î±), r x y â†’ s x y) : EqvGen.setoid r â‰¤ EqvGen.setoid s
{p : â„•} [Fact (Nat.Prime p)] {f : PadicSeq p} (hF : Â¬f â‰ˆ 0) (v1 v2 : â„•) : padicNorm p (â‡‘f (PadicSeq.stationaryPoint hF)) = padicNorm p (â‡‘f (Linear_order.max v1 (Linear_order.max v2 (PadicSeq.stationaryPoint hF))))
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
{Î± : Type u_1} [HasLe Î±] {s : Set Î±} : IsUpperSet s â†’ IsLowerSet (â‡‘OrderDual.ofDual â»Â¹' s)
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] [DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ Î²) {a : Î±} (h : a âˆˆ s) : f a + (s.erase a).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {A : Type uâ‚ƒ} [CategoryTheory.Category A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (hGâ‚ : CategoryTheory.CompatiblePreserving K G) (hGâ‚‚ : CategoryTheory.CoverPreserving J K G) (â„± : CategoryTheory.Sheaf K A) : CategoryTheory.Presheaf.IsSheaf J (G.op â‹™ â„±.val)
{Î± : Type u_1} [topologicalSpace Î±] {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] {f g : Î± â†’ Î³} (hF : UpperSemicontinuous f) (hg : UpperSemicontinuous g) (hcont : âˆ€ (x : Î±), ContinuousAt (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : UpperSemicontinuous (Î» (z : Î±), f z + g z)
{Î± : Type u_1} {n : Type u_2} {m : Type u_3} [hasMul Î±] [AddCommMonoid Î±] (A : Matrix m n Î±) [Fintype m] : A.transpose.has_Orthogonal_rows â†” A.has_Orthogonal_cols
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} (t : CategoryTheory.Limits.Fork f g) [CategoryTheory.Epi t.Î¹] : f = g
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [NormedGroup F] [normedSpace â„ F] {f : E â†’ F} {p : E â†’ FormalMultilinearSeries â„ E F} {s : Set E} {x : E} (hF : HasFtaylorSeriesUpToOn 1 f p (HasInsert.insert x s)) (hs : Convex â„ s) (K : Nnreal) (hK : âˆ¥p x 1âˆ¥â‚Š < K) : âˆƒ (t : Set E) (H : t âˆˆ nhdsWithin x s), LipschitzOnWith K f t
(a b : â„•) {c : â„•} (hc : 0 < c) : c * a / (c * b) = a / b
{s : Set â„•} (hs : s.infinite) {k : â„•} (hk : 0 < k) : âˆƒ (m : â„•) (H : m âˆˆ s) (n : â„•) (H : n âˆˆ s), m < n âˆ§ m â‰¡ n [Mod k]
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {X X' Y Y' Z Z' : C} [CategoryTheory.ExactPairing Y Y'] (f : X âŸ¶ Y âŠ— Z) (g : X' âŸ¶ Z') : â‡‘((CategoryTheory.tensorLeftHomEquiv (X âŠ— X') Y Y' (Z âŠ— Z')).symm) ((f âŠ— g) â‰« (Î±_ Y Z Z').hom) = (Î±_ Y' X X').inv â‰« (â‡‘((CategoryTheory.tensorLeftHomEquiv X Y Y' Z).symm) f âŠ— g)
{C : Type uâ‚} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : Cáµ’áµ– â¥¤ Type vâ‚} : CategoryTheory.Presieve.IsSheafFor P â‡‘S â†” CategoryTheory.Presieve.YonedaSheafCondition P S
(p : â„•) [hp : Fact (Nat.Prime p)] {q r : â„š} : padicNorm p (q - r) â‰¤ Linear_order.max (padicNorm p q) (padicNorm p r)
(Î± : Type u) (Î² : Type v) [AddGroup Î±] [addAction Î± Î²] [Fintype Î±] [Î  (a : Î±), Fintype â†¥(AddAction.FixedBy Î± Î² a)] [Fintype (Quotient (AddAction.orbitRel Î± Î²))] : finset.univ.sum (Î» (a : Î±), Fintype.card â†¥(AddAction.FixedBy Î± Î² a)) = Fintype.card (Quotient (AddAction.orbitRel Î± Î²)) * Fintype.card Î±
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s1 s2 : AffineSubspace k P) : s1 < s2 â†” â†‘s1 âŠ‚ â†‘s2
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] : âˆ¥orthogonalProjection Kâˆ¥ â‰¤ 1
{Î¹ : Type u_1} {R : Type u_8} [OrderedCommSemiring R] {s : Finset Î¹} {i : Î¹} {f g h : Î¹ â†’ R} (hi : i âˆˆ s) (h2i : g i + h i â‰¤ f i) (hgf : âˆ€ (j : Î¹), j âˆˆ s â†’ j â‰  i â†’ g j â‰¤ f j) (hhf : âˆ€ (j : Î¹), j âˆˆ s â†’ j â‰  i â†’ h j â‰¤ f j) (hg : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ g i) (hH : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ h i) : s.prod (Î» (i : Î¹), g i) + s.prod (Î» (i : Î¹), h i) â‰¤ s.prod (Î» (i : Î¹), f i)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (r : â„) (v : V) (pâ‚ pâ‚‚ : P) : HasDist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ * HasDist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ = HasInner.inner v v * r * r + 2 * HasInner.inner v (pâ‚ -áµ¥ pâ‚‚) * r + HasInner.inner (pâ‚ -áµ¥ pâ‚‚) (pâ‚ -áµ¥ pâ‚‚)
{M : Type u_1} [Nonempty M] [AddSemigroup M] [topologicalSpace M] [CompactSpace M] [t2_Space M] (Continuous_mulLeft : âˆ€ (r : M), Continuous (Î» (_x : M), _x + r)) : âˆƒ (m : M), m + m = m
 : IsTrivialTopologicalFiberBundle â„ Complex.re
{k : â„•} (n : â„•) (hpos : 0 < k) : âˆƒ (p : â„•), Nat.Prime p âˆ§ n â‰¤ p âˆ§ p â‰¡ 1 [Mod k]
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) {p1 : P} (p2 : P) (r : â„) (hp : p1 âˆˆ affineSpan â„ (Set.Range s.points)) : â‡‘(s.orthogonal_projection_Span) (r â€¢ (p2 -áµ¥ â†‘(â‡‘(s.orthogonal_projection_Span) p2)) +áµ¥ p1) = âŸ¨p1, hpâŸ©
 : IsTrivialTopologicalFiberBundle â„ Complex.im
{M : Type u_1} [hasMul M] {c d : Con M} (H : c.to_Setoid = d.to_Setoid) : c = d
{R : Type u} {L : Type v} [CommRing R] [LieRing L] [lieAlgebra R L] (M : Type w) [AddCommGroup M] [Module R M] [LieRingModule L M] [lieModule R L M] [Nontrivial M] [LieAlgebra.IsNilpotent R L] [LieModule.IsNilpotent R L M] : LieModule.IsWeight âŠ¤ M 0
{B : Type u_2} {F : Type u_3} [topologicalSpace B] [topologicalSpace F] : IsTopologicalFiberBundle F Prod.fst
{X : Type u} {Y : Type v} [Preorder X] [Preorder Y] {L : X â¥¤ Y} {R : Y â¥¤ X} (Adj : L âŠ£ R) : GaloisConnection L.obj R.obj
{Î± : Type u_1} [topologicalSpace Î±] [BaireSpace Î±] {S : Set (Set Î±)} (hc : âˆ€ (s : Set Î±), s âˆˆ S â†’ is_IsClosed s) (hS : S.countable) (hU : â‹ƒâ‚€S = Set.Univ) : Dense (â‹ƒ (s : Set Î±) (H : s âˆˆ S), Interior s)
{S : Type u} [Semigroup S] {a x y x' y' : S} (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y')
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : 2 â€¢ o.oangle x (-y) = 2 â€¢ o.oangle x y
{Î¹ : Type u_1} {ð•œ : Type u_2} [is_R_or_C ð•œ] {E : Type u_3} [innerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), innerProductSpace ð•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ V) [âˆ€ (i : Î¹), CompleteSpace (G i)] (hV' : (â¨† (i : Î¹), (V i).to_LinearMap.range).topological_Closure = âŠ¤) (w : â†¥(Lp G 2)) : HasSum (Î» (i : Î¹), â‡‘(V i) (â‡‘w i)) (â‡‘((hV.linear_Isometry_Equiv hV').symm) w)
{R : Type u_1} [Semiring R] {M : LaurentPolynomial R â†’ Prop} (p : LaurentPolynomial R) (h_Add : âˆ€ (p q : LaurentPolynomial R), M p â†’ M q â†’ M (p + q)) (h_C_Mul_T : âˆ€ (n : â„¤) (a : R), M (â‡‘LaurentPolynomial.c a * LaurentPolynomial.t n)) : M p
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’ ð•œ) {s : Finset Î¹} {i : Î¹} (hi : i âˆˆ s) : HasInner.inner (s.sum (Î» (i : Î¹), l i â€¢ v i)) (v i) = â‡‘(starRingEnd ð•œ) (l i)
{R : Type u} [Ring R] {Î¹ : sort u_1} [hÎ¹ : Nonempty Î¹] {S : Î¹ â†’ Subring R} (hS : Directed LE.le S) {x : R} : (x âˆˆ â¨† (i : Î¹), S i) â†” âˆƒ (i : Î¹), x âˆˆ S i
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (hp1p2 : p1 â‰  p2) (hp3p2 : p3 â‰  p2) : HasDist.dist p1 p3 = HasDist.dist p1 p2 + HasDist.dist p3 p2 â†” EuclideanGeometry.angle p1 p2 p3 = Real.pi
(R : Type u_1) (M : Type u_2) [Semiring R] [Nontrivial M] [AddCommMonoid M] [Module R M] : Nontrivial R
{Î± : Type u} {Î² : Type v} [Preorder Î±] [LinearOrder Î²] {f g : Î± â†’ Î²} (hF : Antitone f) (hg : Antitone g) : Antitone (Î» (x : Î±), Linear_order.max (f x) (g x))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) (h : p 1 = â‡‘((Continuous_multilinear_Curry_Fin1 ð•œ E F).symm) â†‘i) : p.left_Inv i = p.right_Inv i
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hF : Function.Injective f) (hg : Function.Injective g) : âˆƒ (h : Î± â†’ Î²), Function.bijective h
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] (s t : Submodule K V) [FiniteDimensional K â†¥s] [FiniteDimensional K â†¥t] : FiniteDimensional.finrank K â†¥(s âŠ” t) + FiniteDimensional.finrank K â†¥(s âŠ“ t) = FiniteDimensional.finrank K â†¥s + FiniteDimensional.finrank K â†¥t
{R : Type u_1} [CancelCommMonoidWithZero R] {Î± : Type u_2} [DecidableEq Î±] {x y a : R} {s : Finset Î±} {p : Î± â†’ R} (hp : âˆ€ (i : Î±), i âˆˆ s â†’ Prime (p i)) (hx : x * y = a * s.prod (Î» (i : Î±), p i)) : âˆƒ (t u : Finset Î±) (b c : R), t âˆª u = s âˆ§ Disjoint t u âˆ§ a = b * c âˆ§ x = b * t.prod (Î» (i : Î±), p i) âˆ§ y = c * u.prod (Î» (i : Î±), p i)
{G : Type w} [topologicalSpace G] [AddGroup G] [TopologicalAddGroup G] {K V : Set G} (hK : is_IsCompact K) (hV : (Interior V).nonempty) : âˆƒ (t : Finset G), K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g + h) â»Â¹' V
{p n k b : â„•} (hp : Nat.Prime p) (hkn : k â‰¤ n) (hnb : Nat.log p n < b) : multiplicity p (n.choose k) = â†‘((Finset.filter (Î» (i : â„•), p ^ i â‰¤ k % p ^ i + (n - k) % p ^ i) (Finset.ico 1 b)).card)
{M : Type u_1} [hasMul M] {s : Set M} {S : Subsemigroup M} : Subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S
{Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [CommMonoid Î²] (R : Setoid Î±) [DecidableRel Setoid.r] (h : âˆ€ (x : Î±), x âˆˆ s â†’ (Finset.filter (Î» (y : Î±), y â‰ˆ x) s).prod (Î» (a : Î±), f a) = 1) : s.prod (Î» (x : Î±), f x) = 1
{Î± : Type u_1} {r : Setoid Î±} {x : Î±} {b : Set Î±} (hc : b âˆˆ r.classes) (hb : x âˆˆ b) {b' : Set Î±} (hc' : b' âˆˆ r.classes) (hb' : x âˆˆ b') : b = b'
{Î± : sort u_1} {a a' : Î±} {Î² : sort u_2} (y : Î²) (h : a = a') : eq.rec y h = y
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} : FreeGroup.Red.Step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [HasScalar ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : ConcaveOn ð•œ s f) (c : E) : ConcaveOn ð•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
{ð•œ : Type u_1} {E : Type u_3} {F : Type u_4} [orderedRing ð•œ] [topologicalSpace E] [topologicalSpace F] [AddCommGroup E] [AddCommGroup F] [Module ð•œ E] [Module ð•œ F] {s : Set F} (hs : StrictConvex ð•œ s) {f : E â†’áµƒ[ð•œ] F} (hF : Continuous â‡‘f) (hfinj : Function.Injective â‡‘f) : StrictConvex ð•œ (â‡‘f â»Â¹' s)
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} (ha : a â‰  0) : char.quadratic_Char F a = 1 âˆ¨ char.quadratic_Char F a = -1
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] : orthogonalProjection âŠ¥ = 0
{R : Type u_1} {a : R} [Semigroup R] (b : R) (ha : IsLeftRegular a) : IsLeftRegular (a * b) â†” IsLeftRegular b
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b c : Î±} : a * b â‰¤ c â†’ b â‰¤ aâ»Â¹ * c
(x y : â„•) : â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y
(ð•œ : Type u_1) {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_3} [LinearOrder Î¹] [OrderBot Î¹] [locallyFiniteOrder Î¹] [IsWellOrder Î¹ LT.lt] (f : Î¹ â†’ E) {a b : Î¹} (hâ‚€ : a â‰  b) : HasInner.inner (gramSchmidt ð•œ f a) (gramSchmidt ð•œ f b) = 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {sâ‚ sâ‚‚ : Set P} (h : sâ‚ âŠ† sâ‚‚) : vectorSpan k sâ‚ â‰¤ vectorSpan k sâ‚‚
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) (z : N) : â‡‘(f.lift hg) z * â‡‘g â†‘((f.sec z).snd) = â‡‘g (f.sec z).fst
{a b : Ereal} (h : -a â‰¤ b) : -b â‰¤ a
{X : Type u_1} [topologicalSpace X] [SequentialSpace X] {s : Set X} : IsSeqClosed s â†” is_IsClosed s
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {xâ‚€ : E} (hF : HasFderivAt f f' xâ‚€) {s : Set E} (hs : s âˆˆ nhds xâ‚€) {C : Nnreal} (hlip : LipschitzOnWith C f s) : âˆ¥f'âˆ¥ â‰¤ â†‘C
{R : Type u_1} [CommRing R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) [Invertible A] : (â…Ÿ A).mul A = 1
{K : Type u} [Field K] (s : Subfield K) {Î¹ : Type u_1} {t : Finset Î¹} {f : Î¹ â†’ K} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.prod (Î» (i : Î¹), f i) âˆˆ s
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (f : C(Î±, Î²)) {x y : Î±} (h : x = y) : â‡‘f x = â‡‘f y
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.PosMulStrictMono Î±] (ha : 1 â‰¤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [CompleteSpace E] [CompleteSpace F] (A : E â†’L[ð•œ] F) (x : E) (y : F) : HasInner.inner (â‡‘(â‡‘ContinuousLinearMap.adjoint A) y) x = HasInner.inner y (â‡‘A x)
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Î¹ : Type w} {b : Finset Î¹} (h : Basis â†¥b K V) : FiniteDimensional.finrank K V = b.card
{n n' : â„•} (m : â„•) (i : Fin n') (h : n' = n) : â‡‘(fin.nat_Add m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.nat_Add m) i)
{M : Type u_3} {N : Type u_4} [MulOneClass M] [MulOneClass N] (f : M â†’* N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
{Î± : Type u_1} [measurableSpace Î±] {f : â„• â†’ Î± â†’ Nnreal} {g : Î± â†’ Nnreal} (hF : âˆ€ (i : â„•), Measurable (f i)) (lim : Filter.Tendsto f Filter.atTop (nhds g)) : Measurable g
{x : Pgame} : x.lf 0 â†” âˆƒ (j : x.right_moves), x.move_Right j â‰¤ 0
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : f' =O[l] g â†’ (Î» (x : Î±), -f' x) =O[l] g
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} : Monotone f â†’ Antitone (f âˆ˜ â‡‘OrderDual.ofDual)
(ð•‚ : Type u_1) (ð”¸ : Type u_2) [is_R_or_C ð•‚] [normedRing ð”¸] [NormedAlgebra ð•‚ ð”¸] : (expSeries ð•‚ ð”¸).radius = âŠ¤
{K : Type u} {L : Type v} [Field K] [Field L] {f g : K â†’+* L} {s : Set K} (h : Set.EqOn â‡‘f â‡‘g s) : Set.EqOn â‡‘f â‡‘g â†‘(Subfield.closure s)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {sâ‚ sâ‚‚ : AffineSubspace k P} {p : P} (hâ‚ : p âˆˆ sâ‚) (hâ‚‚ : p âˆˆ sâ‚‚) : sâ‚ = sâ‚‚ â†” sâ‚.direction = sâ‚‚.direction
{R : Type u_2} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R] {a b c : R} (ha : a â‰  0) (no_Factors : âˆ€ {d : R}, d âˆ£ a â†’ d âˆ£ b â†’ Â¬Prime d) : a âˆ£ b * c â†’ a âˆ£ c
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {s : Set P} [Nontrivial P] : affineSpan k s = âŠ¤ â†” vectorSpan k s = âŠ¤
{C : Type u} [CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} (hJ : CategoryTheory.Sheaf.Subcanonical J) (P : Cáµ’áµ– â¥¤ Type v) [P.representable] : CategoryTheory.Presieve.IsSheaf J P
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : Dense s â†” âˆ€ (U : Set Î±), is_IsOpen U â†’ U.nonempty â†’ (U âˆ© s).nonempty
{Î± : Type u_2} {Î² : Type u_3} [DecidableEq Î²] [hasVadd Î± Î²] {u : Finset Î²} {s : Set Î±} {t : Set Î²} : â†‘u âŠ† s +áµ¥ t â†’ (âˆƒ (s' : Finset Î±) (t' : Finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' +áµ¥ t')
(ð•œ : Type u_1) {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {v : E} (hv : âˆ¥vâˆ¥ = 1) (w : E) : â†‘(â‡‘(orthogonalProjection (Submodule.span ð•œ {v})) w) = HasInner.inner v w â€¢ v
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.PosMulMono Î±] (ha : 1 < a) (hb : 1 â‰¤ b) (a0 : 0 < a) : 1 < a * b
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hst : s âŠ† t) (ht : (t âˆ© Function.Support f).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t  s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {v : Set E} [FiniteDimensional ð•œ E] (hv : Orthonormal ð•œ Coe) : âˆƒ (u : Set E) (H : u âŠ‡ v) (b : Basis â†¥u ð•œ E), Orthonormal ð•œ â‡‘b âˆ§ â‡‘b = Coe
(S : Set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ 0) : HasInf.inf S â‰¤ 0
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Kâ‚ Kâ‚‚ : Submodule ð•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) [CompleteSpace â†¥Kâ‚] : Kâ‚ âŠ” Kâ‚á—® âŠ“ Kâ‚‚ = Kâ‚‚
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} {ps : Set P} (h : ps âŠ† â†‘s) [Nonempty â†¥s] {n : â„•} [FiniteDimensional â„ â†¥(s.direction)] (hD : FiniteDimensional.finrank â„ â†¥(s.direction) = n) (hc : EuclideanGeometry.Cospherical ps) {sxâ‚ sxâ‚‚ : Affine.Simplex â„ P n} (hsxâ‚ : Set.Range sxâ‚.points âŠ† ps) (hsxâ‚‚ : Set.Range sxâ‚‚.points âŠ† ps) : sxâ‚.circumradius = sxâ‚‚.circumradius
{Î± : sort u} {Î² : sort v} {Î³ : sort w} {g : Î² â†’ Î³} (hg : Function.Surjective g) : Function.Surjective (Function.comp g)
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {f' : F} {x : ð•œ} [PartialOrder ð•œ] : HasDerivWithinAt f f' (Set.Ici x) x â†’ HasDerivWithinAt f f' (Set.Ioi x) x
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] : EuclideanGeometry.Cospherical âˆ…
{Î± : Type v} [LinearOrder Î±] {xâ‚ xâ‚‚ yâ‚ yâ‚‚ : Î±} (h : Disjoint (Set.Ico xâ‚ xâ‚‚) (Set.Ico yâ‚ yâ‚‚)) (hx : xâ‚ < xâ‚‚) (h2 : xâ‚‚ âˆˆ Set.Ico yâ‚ yâ‚‚) : yâ‚ = xâ‚‚
{R : Type u_1} [CommRing R] [is_IsDomain R] : (Ideal.span {PowerSeries.x}).is_Prime
{F : Type u_1} [Field F] (p : Polynomial F) (E : Type u_2) [Field E] [Algebra F E] [Fact (Polynomial.Splits (algebraMap F E) p)] : Function.Injective â‡‘(Polynomial.Gal.galActionHom p E)
{Î± : Type u_1} [measurableSpace Î±] (s : MeasureTheory.SignedMeasure Î±) : s.to_jordan_decomposition.to_SignedMeasure = s
(C : Type u) [CategoryTheory.Category C] [âˆ€ {X Y : C} {f g : X âŸ¶ Y}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair f g)] : CategoryTheory.Limits.HasCoequalizers C
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p âˆˆ s) (p2 : P) : p2 -áµ¥ p âˆˆ s.direction â†” p2 âˆˆ s
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : M (Sum.inr ()) (Sum.inr ()) â‰  0) (i : Fin r) : (Matrix.Pivot.listTransvecCol M).prod.mul M (Sum.inl i) (Sum.inr ()) = 0
{p n : â„•} (h : 2 * n < p) : â‡‘(n.central_binom.factorization) p = 0
{G : Type u} [Group G] (a x : G) : SemiconjBy a x (a * x * aâ»Â¹)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E} (f_Diff : DifferentiableOn â„ f s) (f_lim : ContinuousWithinAt f s a) (hs : s âˆˆ nhdsWithin a (Set.Iio a)) (f_lim' : Filter.Tendsto (Î» (x : â„), deriv f x) (nhdsWithin a (Set.Iio a)) (nhds e)) : HasDerivWithinAt f e (Set.Iic a) a
{R : Type u_1} [Semiring R] (f : LaurentPolynomial R) {Q : LaurentPolynomial R â†’ Prop} (is_qf : âˆ€ (f : Polynomial R), Q (â‡‘Polynomial.toLaurent f)) (QT : âˆ€ (f : LaurentPolynomial R), Q (f * LaurentPolynomial.t 1) â†’ Q f) : Q f
{k : Type u_1} {G : Type u_2} {V : Type u_3} [CommSemiring k] [Group G] [AddCommMonoid V] [Module k V] (Ï : Representation k G V) [Fintype G] [Invertible â†‘(Fintype.card G)] (v : V) (hv : v âˆˆ Ï.invariants) : â‡‘(Ï.average_Map) v = v
{G : Type u_3} [Group G] (P : Subgroup G) : P.fg â†” P.to_submonoid.fg
{ð•œ : Type u_1} {E : Type u_2} [orderedRing ð•œ] [AddCommGroup E] [Module ð•œ E] {K : Geometry.SimplicialComplex ð•œ E} {s t : Finset E} (hs : s âˆˆ K.faces) (ht : t âˆˆ K.faces) : â‡‘(convexHull ð•œ) â†‘s âŠ† â‡‘(convexHull ð•œ) â†‘t â†” s âŠ† t
{J : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] {Î± : Type uâ‚} (F : J â¥¤ CategoryTheory.Discrete Î±) (j j' : J) : F.obj j = F.obj j'
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [denselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [topologicalSpace Î´] [OrderClosedTopology Î´] {s : Set Î±} [hs : s.ord_connected] {f : Î± â†’ Î´} (hF : ContinuousOn f s) {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) : Set.SurjOn f s (Set.Icc (f a) (f b))
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {X Y Z : C} [CategoryTheory.HasLeftDual X] [CategoryTheory.HasLeftDual Y] [CategoryTheory.HasLeftDual Z] {f : X âŸ¶ Y} {g : Y âŸ¶ Z} : á˜(f â‰« g) = á˜g â‰« á˜f
{Î³ : Type w} [SemilatticeSup Î³] {a b : Î³} {s t : Set Î³} (hs : is_is_IsLub s a) (ht : is_is_IsLub t b) : is_is_IsLub (s âˆª t) (a âŠ” b)
{K : Type u} [hfield : Field K] (p : Polynomial K) {q : Polynomial K} (hq : q â‰  0) : â‡‘Polynomial.c ((q / GcdMonoid.gcd p q).leading_Coeff)â»Â¹ * (p / GcdMonoid.gcd p q) âˆ£ p
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) : AffineIndependent k p â†” âˆ€ (s1 s2 : Finset Î¹) (w1 w2 : Î¹ â†’ k), s1.sum (Î» (i : Î¹), w1 i) = 1 â†’ s2.sum (Î» (i : Î¹), w2 i) = 1 â†’ â‡‘(s1.affine_combination p) w1 = â‡‘(s2.affine_combination p) w2 â†’ â†‘s1.indicator w1 = â†‘s2.indicator w2
{R : Type u_1} {M : Type u_2} {N : Type u_3} {P : Type u_4} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N] [AddCommGroup P] [Module R P] (f : M â†’â‚—[R] N) (g : N â†’â‚—[R] P) (hF1 : f.ker.fg) (hF2 : g.ker.fg) (hsur : Function.Surjective â‡‘f) : (g.comp f).ker.fg
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : o.oangle (â‡‘(o.rotation Î¸) x) y = o.oangle x y - Î¸
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {c : F} : ContDiff ð•œ n (Î» (x : E), c)
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] [Nontrivial Î±] {s : Set Î±} [TopologicalSpace.SeparableSpace â†¥s] (hs : Dense s) : âˆƒ (t : Set Î±) (H : t âŠ† s), t.countable âˆ§ Dense t âˆ§ (âˆ€ (x : Î±), IsBot x â†’ x âˆ‰ t) âˆ§ âˆ€ (x : Î±), IsTop x â†’ x âˆ‰ t
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [CommRing ð•œ] [AddCommGroup E] [AddCommGroup F] [Module ð•œ E] [Module ð•œ F] [topologicalSpace E] [topologicalSpace F] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] [TopologicalAddGroup F] [HasContinuousConstSmul ð•œ F] (q : FormalMultilinearSeries ð•œ E F) (p : FormalMultilinearSeries ð•œ E E) : q.comp p 0 = q 0
{Mâ‚€ : Type u_1} [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [dec_E : DecidableEq E] {s : Set E} : Orthonormal ð•œ Coe â†” âˆ€ (v : E), v âˆˆ s â†’ âˆ€ (w : E), w âˆˆ s â†’ HasInner.inner v w = Ite (v = w) 1 0
{M : Type u_1} [hasAdd M] {s : Set M} {p : M â†’ Prop} {x : M} (h : x âˆˆ AddSubsemigroup.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (HMul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) : p x
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [subtractionMonoid Î²] (f : Î± â†’+ Î²) (g : Î±) (n : â„¤) : â‡‘f (n â€¢ g) = n â€¢ â‡‘f g
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [Semiring Î²] [hasAdd Î±] [hasAdd Î±â‚‚] {F : Type u_4} [addHomClass F Î± Î±â‚‚] (f : F) (x y : AddMonoidAlgebra Î² Î±) : Finsupp.mapDomain â‡‘f (x * y) = Finsupp.mapDomain â‡‘f x * Finsupp.mapDomain â‡‘f y
{Î± : Type u_2} [DecidableEq Î±] [hasMul Î±] {u : Finset Î±} {s t : Set Î±} : â†‘u âŠ† s * t â†’ (âˆƒ (s' t' : Finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' * t')
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [Fintype Î¹] (p : Î¹ â†’ P) : AffineIndependent k p â†” âˆ€ (w1 w2 : Î¹ â†’ k), finset.univ.sum (Î» (i : Î¹), w1 i) = 1 â†’ finset.univ.sum (Î» (i : Î¹), w2 i) = 1 â†’ â‡‘(finset.univ.affine_combination p) w1 = â‡‘(finset.univ.affine_combination p) w2 â†’ w1 = w2
{Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] {Î´ : Type u_1} [Î  (i : Î¹), AddZeroClass (Î² i)] [AddCommMonoid Î³] [AddCommMonoid Î´] (g : Î³ â†’+ Î´) (f : Î  (i : Î¹), Î² i â†’+ Î³) : g.comp (â‡‘Dfinsupp.liftAddHom f) = â‡‘Dfinsupp.liftAddHom (Î» (a : Î¹), g.comp (f a))
{ð•œ : Type u_1} {E : Type u_2} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] {f : ð•œ â†’ E} {r : Ennreal} {x : ð•œ} {p : FormalMultilinearSeries ð•œ ð•œ E} (h : HasFpowerSeriesOnBall f p x r) (h' : âˆ€ (r' : Nnreal), 0 < r' â†’ (âˆƒ (p' : FormalMultilinearSeries ð•œ ð•œ E), HasFpowerSeriesOnBall f p' x â†‘r')) : HasFpowerSeriesOnBall f p x âŠ¤
(R : Type u_1) [CommSemiring R] (X : Type u_2) {C : FreeAlgebra R X â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(algebraMap R (FreeAlgebra R X)) r)) (h_grade1 : âˆ€ (x : X), C (FreeAlgebraÎ¹ R x)) (h_Mul : âˆ€ (a b : FreeAlgebra R X), C a â†’ C b â†’ C (a * b)) (h_Add : âˆ€ (a b : FreeAlgebra R X), C a â†’ C b â†’ C (a + b)) (a : FreeAlgebra R X) : C a
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semiNormedGroup E'] [semiNormedGroup F'] {c : â„} {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ asymptotics.is_O_with c l f' g'
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topologicalSpace B] [topologicalSpace F] {Proj : Z â†’ B} [topologicalSpace Z] {B' : Type u_5} [topologicalSpace B'] (h : IsTopologicalFiberBundle F Proj) {f : B' â†’ B} (hF : Continuous f) : IsTopologicalFiberBundle F (Î» (x : â†¥{p : B' Ã— Z | f p.fst = Proj p.snd}), â†‘x.fst)
{Î± : Type u} [pseudoMetricSpace Î±] {f : â„• â†’ Î±} (n : â„•) {d : â„• â†’ â„} (hD : âˆ€ {k : â„•}, k < n â†’ HasDist.dist (f k) (f (k + 1)) â‰¤ d k) : HasDist.dist (f 0) (f n) â‰¤ (Finset.range n).sum (Î» (i : â„•), d i)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {x : E} {n : WithTop â„•} {f g : E â†’ ð•œ} (hF : ContDiffAt ð•œ n f x) (hg : ContDiffAt ð•œ n g x) : ContDiffAt ð•œ n (Î» (x : E), f x * g x) x
{Î± : Type u_1} [LinearOrder Î±] [denselyOrdered Î±] [NoMinOrder Î±] [NoMaxOrder Î±] [nonem : Nonempty Î±] (lo hi : Finset Î±) (lo_Lt_hi : âˆ€ (x : Î±), x âˆˆ lo â†’ âˆ€ (y : Î±), y âˆˆ hi â†’ x < y) : âˆƒ (m : Î±), (âˆ€ (x : Î±), x âˆˆ lo â†’ x < m) âˆ§ âˆ€ (y : Î±), y âˆˆ hi â†’ m < y
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : M (Sum.inr ()) (Sum.inr ()) â‰  0) (i : Fin r) : ((Matrix.Pivot.listTransvecCol M).prod.mul M).mul (Matrix.Pivot.listTransvecRow M).prod (Sum.inr ()) (Sum.inl i) = 0
{K : Type u_1} [Field K] [Invertible 2] {a b c : K} (ha : a â‰  0) (h : âˆƒ (s : K), discrim a b c = s * s) : âˆƒ (x : K), a * x * x + b * x + c = 0
{R : Type v} [CommRing R] {n : â„•} (A : Matrix (Fin n.succ) (Fin n.succ) R) (j : Fin n.succ) : A.det = finset.univ.sum (Î» (i : Fin n.succ), (-1) ^ (â†‘i + â†‘j) * A i j * (A.minor â‡‘(i.succ_above) â‡‘(j.succ_above)).det)
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {a b : Î±} (h : a â‰  b) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ {a, b}), f i)) = f a * f b
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [Ring R] [AddCommGroup M] [Module R M] [Nontrivial R] (b : Basis Î¹ R M) : _.maximal
{R : Type u_1} {a b : R} [Semigroup R] (Ab : IsLeftRegular (a * b)) : IsLeftRegular b
{E : Type u_1} [AddCommGroup E] [Module â„ E] {s : Set E} {x : E} (Absorbs : Absorbent â„ s) : {r : â„ | 0 < r âˆ§ x âˆˆ r â€¢ s}.nonempty
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.MulPosStrictMono Î±] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsNoetherian R M] (f : M â†’â‚—[R] M) (s : Function.Surjective â‡‘f) : Function.bijective â‡‘f
{n : â„•} {a b : Fin n} {x : Fin (n + 1)} : â‡‘(x.succ_above) a = â‡‘(x.succ_above) b â†” a = b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ F} {f' : E â†’L[ð•œ] F} (x : E) {g : F â†’ G} {g' : F â†’L[ð•œ] G} (hg : HasStrictFderivAt g g' (f x)) (hF : HasStrictFderivAt f f' x) : HasStrictFderivAt (Î» (x : E), g (f x)) (g'.comp f') x
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] {F : Type v} [NormedGroup F] [normedSpace â„‚ F] {f : E â†’ F} {c : E} (hD : âˆ€á¶  (z : E) in nhds c, DifferentiableAt â„‚ f z) (hc : is_is_IsLocalMax (HasNorm.norm âˆ˜ f) c) : âˆ€á¶  (y : E) in nhds c, âˆ¥f yâˆ¥ = âˆ¥f câˆ¥
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =O[Filter.atTop] Î» (n : â„•), 1) : â†‘r â‰¤ p.radius
{R : Type u} [Ring R] {s : Set R} {p : R â†’ R â†’ Prop} {a b : R} (ha : a âˆˆ Subring.closure s) (hb : b âˆˆ Subring.closure s) (Hs : âˆ€ (x : R), x âˆˆ s â†’ âˆ€ (y : R), y âˆˆ s â†’ p x y) (H0_Left : âˆ€ (x : R), p 0 x) (H0_Right : âˆ€ (x : R), p x 0) (H1_Left : âˆ€ (x : R), p 1 x) (H1_Right : âˆ€ (x : R), p x 1) (Hneg_Left : âˆ€ (x y : R), p x y â†’ p (-x) y) (Hneg_Right : âˆ€ (x y : R), p x y â†’ p x (-y)) (HAdd_Left : âˆ€ (xâ‚ xâ‚‚ y : R), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ + xâ‚‚) y) (HAdd_Right : âˆ€ (x yâ‚ yâ‚‚ : R), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ + yâ‚‚)) (HMul_Left : âˆ€ (xâ‚ xâ‚‚ y : R), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ * xâ‚‚) y) (HMul_Right : âˆ€ (x yâ‚ yâ‚‚ : R), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ * yâ‚‚)) : p a b
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {f' : F} {x : ð•œ} [PartialOrder ð•œ] : HasDerivWithinAt f f' (Set.Iio x) x â†’ HasDerivWithinAt f f' (Set.Iic x) x
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {c : â„} {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : asymptotics.is_O_with c l f g' â†’ asymptotics.is_O_with c l f (Î» (x : Î±), âˆ¥g' xâˆ¥)
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] [Nontrivial R] {Î¹ : Type w} (b : Basis Î¹ R M) [Infinite Î¹] {Îº : Type w'} (v : Îº â†’ M) (i : LinearIndependent R v) (m : i.maximal) : (Cardinal.mk Î¹).lift â‰¤ (Cardinal.mk Îº).lift
{M : Type u_1} [AddSemigroup M] [topologicalSpace M] [t2_Space M] (Continuous_mulLeft : âˆ€ (r : M), Continuous (Î» (_x : M), _x + r)) (s : Set M) (snemp : s.nonempty) (s_IsCompact : is_IsCompact s) (s_Add : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ x + y âˆˆ s) : âˆƒ (m : M) (H : m âˆˆ s), m + m = m
{R : Type u_1} [CommRing R] {S : Submonoid R} {P : Type u_2} [CommRing P] [Algebra R P] : â†‘1 = IsLocalization.coeSubmodule P âŠ¤
{Î± : Type v} [LinearOrder Î±] [topologicalSpace Î±] [OrderClosedTopology Î±] {s : Set Î±} (hs : IsPreconnected s) (hb : Â¬BddBelow s) (ha : Â¬BddAbove s) : s = Set.Univ
{Î± : Type u} [pseudoMetricSpace Î±] (s : Set Î±) : LipschitzWith 1 (Î» (x : Î±), Metric.infDist x s)
{G : Type u_1} [Group G] [Fintype G] : monoid.is_torsion G
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {s : Set E} (hs : Orthonormal ð•œ Coe) : âˆƒ (w : Set E) (H : w âŠ‡ s), Orthonormal ð•œ Coe âˆ§ âˆ€ (u : Set E), u âŠ‡ w â†’ Orthonormal ð•œ Coe â†’ u = w
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {x : E} {n : WithTop â„•} {p : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n f p s) (hn : 1 â‰¤ n) (hx : x âˆˆ s) : HasFderivWithinAt f (â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (p x 1)) s x
{Î± : Type u_2} {Î¹ : Type u_5} [AddCommMonoid Î±] (t : Finset Î¹) (f : Î¹ â†’ Set Î±) (a : Î±) : a âˆˆ t.sum (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ {i : Î¹}, i âˆˆ t â†’ g i âˆˆ f i), t.sum (Î» (i : Î¹), g i) = a
{Î± : Type u} [Infinite Î±] : Nonempty (Field Î±)
(n a : â„•) : Finset.image (Î» (_x : â„•), _x % a) (Finset.ico n (n + a)) = Finset.range a
{n : â„•} {a b : Fin n} : a â‹– b â†’ â†‘a â‹– â†‘b
{X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X} {eâ‚ eâ‚‚ : X} (hâ‚ : EckmannHilton.IsUnital mâ‚ eâ‚) (hâ‚‚ : EckmannHilton.IsUnital mâ‚‚ eâ‚‚) (Distrib : âˆ€ (a b c d : X), mâ‚ (mâ‚‚ a b) (mâ‚‚ c d) = mâ‚‚ (mâ‚ a c) (mâ‚ b d)) : mâ‚ = mâ‚‚
{G : Type u_1} [Group G] : group.is_nilpotent G â†” âˆƒ (n : â„•), lowerCentralSeries G n = âŠ¥
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
(T : Type u) [topologicalSpace T] : CategoryTheory.Pretopology.ofGrothendieck (TopologicalSpace.Opens T) (Opens.grothendieckTopology T) = Opens.pretopology T
{Î± : Type u_1} [LinearOrder Î±] [succOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (hr : Reflexive r) (h1 : âˆ€ (i : Î±), i âˆˆ Set.Ico n m â†’ r i (Order.succ i)) (h2 : âˆ€ (i : Î±), i âˆˆ Set.Ico m n â†’ r (Order.succ i) i) : Relation.TransGen r n m
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) (b : n â†’ Î±) : A.mul_vec (â‡‘(A.cramer) b) = A.det â€¢ b
{ð•œ : Type u_3} {E : Type u_4} [SemiNormedRing ð•œ] [AddCommGroup E] [Module ð•œ E] (p : Seminorm ð•œ E) (r : â„) : Balanced ð•œ (p.ball 0 r)
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} : Metric.hausdorffDist (Closure s) (Closure t) = Metric.hausdorffDist s t
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {c : â„} {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : asymptotics.is_O_with c l (Î» (x : Î±), -f' x) g â†’ asymptotics.is_O_with c l f' g
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} : MonotoneOn f s â†’ AntitoneOn (f âˆ˜ â‡‘OrderDual.ofDual) s
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
(z : â„‚) : â†‘(z.im) = (z - â‡‘(starRingEnd â„‚) z) / (2 * Complex.i)
{Î¹ : Type u} (s : Finset Î¹) (w z : Î¹ â†’ â„) (hw : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ w i) (hw' : s.sum (Î» (i : Î¹), w i) = 1) (hz : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ z i) : s.prod (Î» (i : Î¹), z i ^ w i) â‰¤ s.sum (Î» (i : Î¹), w i * z i)
{Î± : Type u_1} {p : Finset Î± â†’ Prop} [DecidableEq Î±] (S : Finset Î±) (hâ‚ : p âˆ…) (hâ‚‚ : âˆ€ {a : Î±} {s : Finset Î±}, a âˆˆ S â†’ s âŠ† S â†’ a âˆ‰ s â†’ p s â†’ p (HasInsert.insert a s)) : p S
{Î± : Type u} [Preorder Î±] {a b c : Î±} : b < c â†’ a = b â†’ a < c
(n : â„•) (p : â„• â†’ â„) (hp : âˆ€ (k : â„•), 0 â‰¤ p k) {r a : â„} (hr : 0 â‰¤ r) (ha : 0 â‰¤ a) : (Finset.ico 2 (n + 1)).sum (Î» (k : â„•), a ^ k * {c : Composition k | 1 < c.length}.to_finset.sum (Î» (c : Composition k), r ^ c.length * finset.univ.prod (Î» (j : Fin c.length), p (c.blocks_fun j)))) â‰¤ (Finset.ico 2 (n + 1)).sum (Î» (j : â„•), r ^ j * (Finset.ico 1 n).sum (Î» (k : â„•), a ^ k * p k) ^ j)
(l : List â„•) (n : â„•) : List.Sorted LT.lt (Denumerable.raise' l n)
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚‚} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J â¥¤ C} (e : K â‰Œ J) [CategoryTheory.Limits.HasLimit (e.functor â‹™ F)] : CategoryTheory.Limits.HasLimit F
{Î± : Type u} {Î² : Type v} [Fintype Î²] (r : Î± â†’ Î² â†’ Prop) [Î  (a : Î±), DecidablePred (r a)] : (âˆ€ (A : Finset Î±), A.card â‰¤ (Finset.filter (Î» (b : Î²), âˆƒ (a : Î±) (H : a âˆˆ A), r a b) Finset.univ).card) â†” âˆƒ (f : Î± â†’ Î²), Function.Injective f âˆ§ âˆ€ (x : Î±), r x (f x)
{Î± : Type u} {f : Î± â†’ Î±} {x : Î±} (hF : Function.IsFixedPt f x) : f x = x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] [CategoryTheory.Limits.HasPullbacks C] {P Q R : C} {f : P âŸ¶ R} {g : Q âŸ¶ R} {p : â†¥P} {q : â†¥Q} : â‡‘f p = â‡‘g q â†’ (âˆƒ (s : â†¥(CategoryTheory.Limits.pullback f g)), â‡‘CategoryTheory.Limits.pullback.fst s = p âˆ§ â‡‘CategoryTheory.Limits.pullback.snd s = q)
{Î± : Type u} {l : List Î±} : l.sublists.nodup â†’ l.nodup
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (v : M) {r : R} (h : 0 â‰¤ r) : SameRay R (r â€¢ v) v
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {g : Î² â†’ M} (e : Î± â†’ Î²) (hEâ‚€ : Function.bijective e) (hEâ‚ : âˆ€ (x : Î±), f x = g (e x)) : finprod (Î» (i : Î±), f i) = finprod (Î» (j : Î²), g j)
{K : Type u} {V Vâ‚ : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [AddCommGroup Vâ‚] [Module K Vâ‚] (Cond : Module.rank K V = Module.rank K Vâ‚) : Nonempty (V â‰ƒâ‚—[K] Vâ‚)
{R : Type u_1} [normedRing R] [CompleteSpace R] (x : RË£) : âˆ€á¶  (t : R) in nhds 0, Ring.inverse (â†‘x + t) = Ring.inverse (1 + â†‘xâ»Â¹ * t) * â†‘xâ»Â¹
{E : Type u_2} [semiNormedGroup E] [normedSpace â„ E] : ConvexOn â„ Set.Univ HasNorm.norm
 : goldenRatioâ»Â¹ = -goldenConj
{Î± : Type u_3} {Î² : Type u_4} [Preorder Î²] {f : Î² â†’ Finset Î±} (h : Monotone f) (h' : âˆ€ (x : Î±), âˆƒ (n : Î²), x âˆˆ f n) : Filter.Tendsto f Filter.atTop Filter.atTop
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] (f : â„‚ â†’ E) (z w : â„‚) (Hc : ContinuousOn f (Set.Interval z.re w.re Ã—â„‚ Set.Interval z.im w.im)) (hD : DifferentiableOn â„‚ f (Set.Ioo (Linear_order.min z.re w.re) (Linear_order.max z.re w.re) Ã—â„‚ Set.Ioo (Linear_order.min z.im w.im) (Linear_order.max z.im w.im))) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * Complex.i) = 0
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] {a b : Î±} {h : a â‰¤ b} [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] {f : â†¥(Set.Icc a b) â†’ Î²} (hF : Continuous f) : Continuous (Set.iccExtend h f)
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±} (H : IsLeast s a) : HasInf.inf s = a
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsNoetherian R M] (f : M â†’â‚—[R] M) (s : Function.Surjective â‡‘f) : Function.Injective â‡‘f
{R : Type u} {M : Type v} [CommRing R] [Nontrivial R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] (f : M â†’â‚—[R] M) {Î¹ : Type w} [Fintype Î¹] (b : Basis Î¹ R M) : (â‡‘(LinearMap.toMatrix b b) f).charpoly = f.charpoly
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R â†’+* S} {s : S} (n : â„•) (h : s âˆˆ Set.Range â‡‘f) : â‡‘(Polynomial.monomial n) s âˆˆ Polynomial.lifts f
{Gâ‚€ : Type u_2} [groupWithZero Gâ‚€] (a : Gâ‚€) : a * a / a = a
{ð•œ : Type u_1} {E : Type u_3} [normedField ð•œ] [AddCommGroup E] [Module ð•œ E] {A : Set E} [topologicalSpace E] [HasContinuousSmul ð•œ E] (hA : Balanced ð•œ A) (h : 0 âˆˆ Interior A) : Balanced ð•œ (Interior A)
{F : Type u_3} [innerProductSpace â„ F] {x y : F} : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * HasInner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{M : Type u_3} [AddMonoid M] [Inhabited M] (l : List M) (h : l â‰  List.nil) : l.head + l.tail.sum = l.sum
{p k : â„•} (hp : Nat.Prime p) : (p ^ k).factorization = Finsupp.single p k
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {tâ‚ tâ‚‚ : Affine.Triangle â„ P} {iâ‚ iâ‚‚ iâ‚ƒ jâ‚ jâ‚‚ jâ‚ƒ : Fin 3} (hiâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hiâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hiâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) (hjâ‚â‚‚ : jâ‚ â‰  jâ‚‚) (hjâ‚â‚ƒ : jâ‚ â‰  jâ‚ƒ) (hjâ‚‚â‚ƒ : jâ‚‚ â‰  jâ‚ƒ) (hâ‚ : tâ‚‚.points jâ‚ = tâ‚.orthocenter) (hâ‚‚ : tâ‚‚.points jâ‚‚ = tâ‚.points iâ‚‚) (hâ‚ƒ : tâ‚‚.points jâ‚ƒ = tâ‚.points iâ‚ƒ) : tâ‚‚.orthocenter = tâ‚.points iâ‚
{Î¹ : Type u} {f g : Î¹ â†’ Nnreal} {p : â„} (hp : 1 â‰¤ p) (hF : Summable (Î» (i : Î¹), f i ^ p)) (hg : Summable (Î» (i : Î¹), g i ^ p)) : Summable (Î» (i : Î¹), (f i + g i) ^ p) âˆ§ (âˆ‘' (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) + (âˆ‘' (i : Î¹), g i ^ p) ^ (1 / p)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±} [topologicalSpace Î±] (h : ContinuousAt f x) (hg : Filter.Tendsto g p (nhds x)) (hunif : âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : Set Î±) (H : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
{R : Type u_1} {M : Type u_3} {a b : R} [commSemigroup R] [HasScalar R M] [isScalarTower R R M] : IsSmulRegular M (a * b) â†” IsSmulRegular M a âˆ§ IsSmulRegular M b
{Î± : Type u_1} [Monoid Î±] {p q : Î±} (hp : Irreducible p) (hq : Irreducible q) : p âˆ£ q â†’ q âˆ£ p
{R : Type u_1} {S : Type u_2} [CommRing R] [Nontrivial R] [CommRing S] [is_IsDomain S] [Algebra R S] (H : Algebra.IsIntegral R S) (hRS : Function.Injective â‡‘(algebraMap R S)) (hS : IsField S) : IsField R
{Î± : Type u_1} {Î¹ : Type u_4} [completeLattice Î±] (s : Î¹ â†’ Î±) : (â¨… (i : Î¹), s i) = â¨… (t : Finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
{R : Type u} [Ring R] (s : Subring R) {x y : R} (hx : x âˆˆ s) (hy : y âˆˆ s) : x - y âˆˆ s
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {S T : ConvexCone ð•œ E} (h : âˆ€ (x : E), x âˆˆ S â†” x âˆˆ T) : S = T
{p n k : â„•} (p_Large : n < p ^ 2) : â‡‘((n.choose k).factorization) p â‰¤ 1
{R : Type u} [Ring R] {L M N : Module R} (f : L âŸ¶ M) [CategoryTheory.Limits.HasImage f] (g : â†‘(CategoryTheory.Limits.imageSubobject f) âŸ¶ N) [CategoryTheory.Limits.HasCokernel g] {x y : â†¥N} (l : â†¥L) (w : x = y + â‡‘g (â‡‘(CategoryTheory.Limits.factorThruImageSubobject f) l)) : â‡‘(CategoryTheory.Limits.cokernelÏ€ g) x = â‡‘(CategoryTheory.Limits.cokernelÏ€ g) y
{Î± : Type u} [pseudoEmetricSpace Î±] (f : â„• â†’ Î±) (n : â„•) : HasEdist.edist (f 0) (f n) â‰¤ (Finset.range n).sum (Î» (i : â„•), HasEdist.edist (f i) (f (i + 1)))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {x : E} {n : WithTop â„•} {s : Set E} {f g : E â†’ F} (hF : ContDiffWithinAt ð•œ n f s x) (hg : ContDiffWithinAt ð•œ n g s x) : ContDiffWithinAt ð•œ n (Î» (x : E), f x - g x) s x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (h_Int : Algebra.IsIntegral K L) : t2_Space (L â‰ƒâ‚[K] L)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) (hF : Continuous â‡‘f) : âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (e : localHomeomorph Î± Î²) (h : e.to_local_equiv.source = Set.Univ) : OpenEmbedding â‡‘e
 : âˆƒ (Î± Î² : Type) (IÎ± : topologicalSpace Î±) (IÎ² : topologicalSpace Î²), CompactSpace Î± âˆ§ t1_Space Î² âˆ§ âˆƒ (f : Î± â‰ƒ Î²), Continuous â‡‘f âˆ§ Â¬Continuous â‡‘(f.symm)
{G : Type u_1} {H : Type u_2} [Group G] [Group H] {f : G â†’* H} (hF : Function.Surjective â‡‘f) (tG : monoid.is_torsion G) : monoid.is_torsion H
{G : Type u_1} {H : Type u_2} [AddGroup G] [AddGroup H] {f : G â†’+ H} (hF : Function.Surjective â‡‘f) (tG : Add_monoid.is_torsion G) : Add_monoid.is_torsion H
{Î± : Type u} [Group Î±] [Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)] (h : Fintype.card Î± = p) : IsCyclic Î±
{M : Type u_1} [AddZeroClass M] {S T : addSubmonoid M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
{Î± : Type u} [topologicalSpace Î±] {S U : Set Î±} (hS : IsPreirreducible S) (hU : is_IsOpen U) (h : (S âˆ© U).nonempty) : S âŠ† Closure (S âˆ© U)
{l : Type u_1} {m : Type u_2} {Î± : Type v} [hasZero Î±] [DecidableEq m] [DecidableEq l] (d : m â†’ Î±) (e : l â†’ m) (hE : Function.Injective e) : (Matrix.diagonal d).minor e e = Matrix.diagonal (d âˆ˜ e)
{Mâ‚€ : Type u_1} [cancelMonoidWithZero Mâ‚€] {a b : Mâ‚€} (hâ‚ : b â‰  1) (hâ‚‚ : a * b = a) : a = 0
{a b : Cardinal} (ha : Cardinal.aleph_0 â‰¤ a) (hb : Cardinal.aleph_0 â‰¤ b) : a * b = Linear_order.max a b
{E : Type u_1} {Î² : Type u_2} [AddCommGroup E] [topologicalSpace E] [Module â„ E] [TopologicalAddGroup E] [HasContinuousSmul â„ E] [OrderedAddCommGroup Î²] [Module â„ Î²] [OrderedSmul â„ Î²] {f : E â†’ Î²} {a : E} (h_is_IsLocalMax : is_is_IsLocalMax f a) (h_conc : ConcaveOn â„ Set.Univ f) (x : E) : f x â‰¤ f a
(s : â„) {b : â„} (hb : 0 < b) : (Î» (x : â„), x ^ s) =o[Filter.atTop] Î» (x : â„), Real.exp (b * x)
{C : Type u} [CategoryTheory.Category C] {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.Limits.HasImage f] : (CategoryTheory.Limits.Image.monoFactorisation f).e = CategoryTheory.Limits.factorThruImage f
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] : âŠ¥.fixing_Subgroup = âŠ¤
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G : C â¥¤ D} (h_obj : âˆ€ (X : C), F.obj X = G.obj X) (h_Map : âˆ€ (X Y : C) (f : X âŸ¶ Y), F.map f == G.map f) : F = G
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] [NormalSpace Y] (f : boundedContinuousFunction X â„) {t : Set â„} {e : X â†’ Y} [hs : t.ord_connected] (hF : âˆ€ (x : X), â‡‘f x âˆˆ t) (hne : t.nonempty) (hE : ClosedEmbedding e) : âˆƒ (g : boundedContinuousFunction Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ â‡‘g âˆ˜ e = â‡‘f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) : â‡‘g âˆ˜ â‡‘f = â‡‘(f â‰« g)
{R : Type uâ‚} [CommRing R] (a b : R) : (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2
{Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [Î  (i : Î¹), topologicalSpace (X i)] {as bs cs : Î  (i : Î¹), X i} (Î³â‚€ : Î  (i : Î¹), Path.Homotopic.Quotient (as i) (bs i)) (Î³â‚ : Î  (i : Î¹), Path.Homotopic.Quotient (bs i) (cs i)) : (Path.Homotopic.pi Î³â‚€).comp (Path.Homotopic.pi Î³â‚) = Path.Homotopic.pi (Î» (i : Î¹), (Î³â‚€ i).comp (Î³â‚ i))
{p : â„•} {G : Type u_1} [Group G] (hG : is_p_Group p G) [hp : Fact (Nat.Prime p)] (Î± : Type u_2) [mulAction G Î±] [Fintype Î±] [Fintype â†¥(MulAction.FixedPoints G Î±)] (hpÎ± : Â¬p âˆ£ Fintype.card Î±) : (MulAction.FixedPoints G Î±).nonempty
{ð•œ : Type u_1} {E : Type u_2} [orderedRing ð•œ] [AddCommGroup E] [Module ð•œ E] (Q : AffineSubspace ð•œ E) : Convex ð•œ â†‘Q
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization M S] (a : S) : âˆƒ (b : â†¥M), IsLocalization.IsInteger R (â†‘b â€¢ a)
{a b c : â„•} (h : a % c = b % c) : (a - b) % c = 0
 : Fact (FiniteDimensional.finrank â„ â„‚ = 2)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : intermediateField K L) [FiniteDimensional K â†¥E] : is_IsOpen â†‘(E.fixing_Subgroup)
{M : Type u_1} [AddCommMonoid M] (f : â„• â†’ â„• â†’ M) (n : â„•) : (Finset.Nat.antidiagonal n).sum (Î» (ij : â„• Ã— â„•), f ij.fst ij.snd) = (Finset.range n.succ).sum (Î» (k : â„•), f k (n - k))
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] [Nonempty V] (k : â„•) (h : âˆ€ (v : V), k â‰¤ G.degree v) : k â‰¤ G.min_degree
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ AddMon) [CategoryTheory.IsFiltered J] {x y y' : Î£ (j : J), â†¥(F.obj j)} (hyy' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F â‹™ CategoryTheory.forget AddMon) y y') : AddMon.FilteredColimits.colimitAddAux F x y = AddMon.FilteredColimits.colimitAddAux F x y'
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] (f : â„‚ â†’ E) (z w : â„‚) (H : DifferentiableOn â„‚ f (Set.Interval z.re w.re Ã—â„‚ Set.Interval z.im w.im)) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * Complex.i) = 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) (a : â†¥P) : â‡‘(f â‰« g) a = â‡‘g (â‡‘f a)
{n : â„•} {Î± : Type u_1} {v w : Vector Î± n} (h : âˆ€ (m : Fin n), v.nth m = w.nth m) : v = w
{R : Type u} [Field R] [starRing R] (x y : R) : HasStar.star (x / y) = HasStar.star x / HasStar.star y
{G : Type u} [AddMonoid G] {H : Type v} [AddMonoid H] (f : G â†’+ H) {x : G} (h : IsOfFinAddOrder x) : IsOfFinAddOrder (â‡‘f x)
(k : Type u_1) [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) : Finset.centroidWeightsIndicator k s = â†‘s.indicator (Finset.centroidWeights k s)
{Î± : Type u_1} [completeLattice Î±] {a : Î±} {s : Set Î±} : a âŠ” HasInf.inf s â‰¤ â¨… (b : Î±) (H : b âˆˆ s), a âŠ” b
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {R : â„} {c w : â„‚} {f : â„‚ â†’ E} (hD : DifferentiableOn â„‚ f (Metric.ClosedBall c R)) (hw : w âˆˆ Metric.Ball c R) : âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘Real.pi * Complex.i) â€¢ f w
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.forget C)] {X : Top} (F : Top.Sheaf C X) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥X) (sf : Î  (i : Î¹), â†¥(F.val.obj (Opposite.op (U i)))) (h : F.val.is_compatible U sf) : âˆƒ! (s : â†¥(F.val.obj (Opposite.op (supr U)))), F.val.is_gluing U sf s
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î² â†’ Î³} {x : Î±} {y : Î²} (hF : ContinuousAt f y) : ContinuousAt (Î» (x : Î± Ã— Î²), f x.snd) (x, y)
{Î± : Type u_1} {l : Filter Î±} {p : Î± â†’ Prop} : (âˆ€á¶  (s : Set Î±) in l.small_sets, âˆ€ (x : Î±), x âˆˆ s â†’ p x) â†’ (âˆ€á¶  (x : Î±) in l, p x)
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {p : Î¹ â†’ P} (hi : AffineIndependent k p) {s : Finset Î¹} {sm : Submodule k V} [FiniteDimensional k â†¥sm] (hle : vectorSpan k â†‘(Finset.image p s) â‰¤ sm) (hc : s.card = FiniteDimensional.finrank k â†¥sm + 1) : vectorSpan k â†‘(Finset.image p s) = sm
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} : Metric.Bounded s â†” Emetric.diam s â‰  âŠ¤
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {x : E} : MdifferentiableAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f x â†” DifferentiableAt ð•œ f x
{Î± : Type u_1} {l l' : List Î±} (f : â„• â†ªo â„•) (hF : âˆ€ (ix : â„•), l.nth ix = l'.nth (â‡‘f ix)) : l <+ l'
{X : Type u_1} [topologicalSpace X] [CompactSpace X] (A : Subalgebra â„ C(X, â„)) (w : A.separates_points) : A.topological_Closure = âŠ¤
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x z - o.oangle x y = o.oangle y z
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] : affineSpan k Set.Univ = âŠ¤
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} (hF : ConvexOn ð•œ s f) {x y z : ð•œ} (hx : x âˆˆ s) (hz : z âˆˆ s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)
(a b : â„) : (polynomialFunctions (Set.Icc a b)).topological_Closure = âŠ¤
(a b : â„) (f : C(â†¥(Set.Icc a b), â„)) : f âˆˆ (polynomialFunctions (Set.Icc a b)).topological_Closure
{R : Type u_1} {E : Type u_2} [linearOrderedField R] [AddCommGroup E] [Module R E] {Î¹ : Type u_3} (b : AffineBasis Î¹ R E) : â‡‘(convexHull R) (Set.Range b.points) = {x : E | âˆ€ (i : Î¹), 0 â‰¤ â‡‘(b.coord i) x}
{Î± : Type u} {p : Î± â†’ Prop} {a : Î±} (h : a âˆˆ {x : Î± | p x}) : p a
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) (z : Î± 0) : fin.tail (Function.update q 0 z) = fin.tail q
{Î± : Type u_1} [DecidableEq Î±] : Monotone Finset.shadow
(R : Type u_1) (A : Type u_2) [CommSemiring R] : Pi.constRingHom A R = algebraMap R (A â†’ R)
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : CategoryTheory.Presieve X} : CategoryTheory.Presieve.IsSheafFor P R â†’ CategoryTheory.Presieve.IsSeparatedFor P R
{G : Type u_6} {H : Type u_7} {F : Type u_8} [AddGroup G] [subtractionMonoid H] [addMonoidHomClass F G H] (f : F) (n : â„¤) (g : G) : â‡‘f (n â€¢ g) = n â€¢ â‡‘f g
(n : â„•) : â†‘(n.totient) = â†‘n * n.factors.to_finset.prod (Î» (p : â„•), 1 - (â†‘p)â»Â¹)
{E : Type u_1} [AddCommGroup E] [Module â„ E] (p : Seminorm â„ E) : gauge (p.ball 0 1) = â‡‘p
{F : Type u_3} [innerProductSpace â„ F] {x : F} {r : â„} (hx : x â‰  0) (hr : r < 0) : HasInner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = -1
{R : Type u_1} {Î± : Type u_2} (G : SimpleGraph Î±) [hasZero R] [hasOne R] [DecidableEq Î±] [DecidableRel G.adj] {a : Î±} {e : Sym2 Î±} : SimpleGraph.incMatrix R G a e = Ite (e âˆˆ G.incidence_Set a) 1 0
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (B : Matrix n m Î±) [Invertible A] : (â…Ÿ A).mul (A.mul B) = B
(p : â„•) [hp : Fact (Nat.Prime p)] {q : â„š} (h : padicNorm p q = 0) : q = 0
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : o.oangle (-x) (-y) = o.oangle x y
{Î± : Type u} [Preorder Î±] [NoMaxOrder Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), StrictMono f âˆ§ f 0 = a
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s : Set Î±} {b : Î±} (hs : s.nonempty) (H : âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ b) (H' : âˆ€ (w : Î±), w < b â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), w < a)) : HasSup.sup s = b
(p : Polynomial â„š) : (p.root_Set â„‚).to_finset.card = (p.root_Set â„).to_finset.card + (â‡‘(Polynomial.Gal.galActionHom p â„‚) (â‡‘(Polynomial.Gal.restrict p â„‚) (AlgEquiv.restrictScalars â„š Complex.conjAe))).support.card
(z : UpperHalfPlane) : Filter.Tendsto (Î» (p : Fin 2 â†’ â„¤), â‡‘Complex.normSq (â†‘(p 0) * â†‘z + â†‘(p 1))) Filter.cofinite Filter.atTop
{p : â„•} [hp : Fact (Nat.Prime p)] : WittVector.IsPoly p (Î» (R : Type u_1) (_Rcr : CommRing R), â‡‘WittVector.verschiebung)
{Î¹ : Type u} {X : Type v} [topologicalSpace X] {s : Set X} [NormalSpace X] [ParacompactSpace X] (hs : is_IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ (i : Î¹), is_IsOpen (U i)) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : BumpCovering Î¹ X s), f.is_subordinate U
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {X Y : C} (g : Y âŸ¶ X) [CategoryTheory.Mono g] (fâ‚ fâ‚‚ : CategoryTheory.Subobject Y) : (CategoryTheory.Subobject.map g).obj (fâ‚ âŠ“ fâ‚‚) = (CategoryTheory.Subobject.map g).obj fâ‚ âŠ“ (CategoryTheory.Subobject.map g).obj fâ‚‚
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ AddMon) [CategoryTheory.IsFiltered J] (j : J) : 0 = AddMon.FilteredColimits.M.mk F âŸ¨j, 0âŸ©
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x : Î±} (h : is_IsClosed s) (hs : s.nonempty) : x âˆˆ s â†” Metric.infDist x s = 0
{ð•œ : Type u_1} {X : Type u_2} [is_R_or_C ð•œ] [topologicalSpace X] {A : Subalgebra ð•œ C(X, ð•œ)} (hA : A.separates_points) (hA' : ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ A)) : ((Subalgebra.restrictScalars â„ A).comap' (AlgHom.compLeftContinuous â„ is_R_or_C.of_Real_am is_R_or_C.continuous_ofReal)).separates_points
{X : Type u} {Y : Type v} [metricSpace X] [metricSpace Y] : Isometry Sum.inl
(s b : â„) (hb : 0 < b) : Filter.Tendsto (Î» (x : â„), x ^ s * Real.exp (-b * x)) Filter.atTop (nhds 0)
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} [ProperSpace Î±] (h : Metric.Bounded s) : is_IsCompact (Closure s)
{ð•œ : Type u_1} [normedField ð•œ] [CompleteSpace ð•œ] {r : ð•œ} (hr : âˆ¥râˆ¥ < 1) : HasSum (Î» (n : â„•), â†‘n * r ^ n) (r / (1 - r) ^ 2)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x y : E) : â‡‘is_R_or_C.re (HasInner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 4
{Î± : Type u} [PartialOrder Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : a = b
{Î± : Type u} {Î² : Type v} {s : Set Î±} {f : Î± â†’ Î²} : Set.InjOn f s â†’ Function.Injective (s.restrict f)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [LinearOrder Î²] {f g : Î± â†’ Î²} (hF : Monotone f) (hg : Monotone g) : Monotone (Î» (x : Î±), Linear_order.max (f x) (g x))
{A : Type u_1} {B : Type u_2} [i : SetLike A B] {p q : A} (h : âˆ€ (x : B), x âˆˆ p â†” x âˆˆ q) : p = q
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) : 2 â€¢ o.oangle (-x) x = 0
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (f : R â†’+* S) : Polynomial.x âˆˆ Polynomial.lifts f
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [linearOrderedField ð•œ] [AddCommGroup E] [linearOrderedAddCommGroup Î²] [Module ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : ConvexOn ð•œ (â‡‘(convexHull ð•œ) s) f) {x : E} (hx : x âˆˆ â‡‘(convexHull ð•œ) s) : âˆƒ (y : E) (H : y âˆˆ s), f x â‰¤ f y
{Î± : Type u} {Î² : Type v} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} [f.ne_IsBot] (h : Filter.Tendsto u f (nhds a)) : f.limsup u = a
{R : Type u_1} [Semiring R] {Q : LaurentPolynomial R â†’ Prop} (f : LaurentPolynomial R) (is_qf : âˆ€ {f : Polynomial R} {n : â„•}, Q (â‡‘Polynomial.toLaurent f * LaurentPolynomial.t (-â†‘n))) : Q f
{Î± : Type u} [pseudoMetricSpace Î±] {x : Î±} {r : â„} (h : 0 â‰¤ r) : Metric.diam (Metric.ClosedBall x r) â‰¤ 2 * r
(Î± : Type u_1) (Î² : Type u_2) [LinearOrder Î±] [LinearOrder Î²] [Encodable Î±] [denselyOrdered Î±] [NoMinOrder Î±] [NoMaxOrder Î±] [Nonempty Î±] [Encodable Î²] [denselyOrdered Î²] [NoMinOrder Î²] [NoMaxOrder Î²] [Nonempty Î²] : Nonempty (Î± â‰ƒo Î²)
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a : Î±) : â‡‘f (bit1 a) = bit1 (â‡‘f a)
{Î± : Type u_1} {f g : Poly Î±} : (âˆ€ (x : Î± â†’ â„•), â‡‘f x = â‡‘g x) â†’ f = g
{Î± : Type u_2} {Î² : Type u_3} [nonAssocRing Î±] [nonAssocRing Î²] (f : Î± â†’+* Î²) (x y : Î±) : â‡‘f (x - y) = â‡‘f x - â‡‘f y
{R : Type u} {Î¹ : Type v} {Mâ‚ : Î¹ â†’ Type wâ‚} {Mâ‚‚ : Type wâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] [Î  (i : Î¹), topologicalSpace (Mâ‚ i)] [topologicalSpace Mâ‚‚] (f : ContinuousMultilinearMap R Mâ‚ Mâ‚‚) {Î± : Î¹ â†’ Type u_1} [Fintype Î¹] (g : Î  (i : Î¹), Î± i â†’ Mâ‚ i) (A : Î  (i : Î¹), Finset (Î± i)) : â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (Fintype.piFinset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
{Î± : Type u_1} (f : Î± â†’ Î± â†’ Î±) [IsAssociative Î± f] (x y : Î±) : ((Î» (z : Î±), f z x) âˆ˜ Î» (z : Î±), f z y) = Î» (z : Î±), f z (f y x)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X âŸ¶ Y) [CategoryTheory.Limits.HasKernel (f - g)] : CategoryTheory.Limits.HasEqualizer f g
{X : Type u_1} [topologicalSpace X] {s : Set X} (h : âˆ€ (x : â„• â†’ X) (a : X), (âˆ€ (n : â„•), x n âˆˆ s) â†’ Filter.Tendsto x Filter.atTop (nhds a) â†’ a âˆˆ s) : IsSeqClosed s
{m n : â„•} : m âˆ£ m + n â†” m âˆ£ n
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [linearOrderedField ð•œ] [AddCommGroup E] [AddCommGroup F] [orderedAddCommMonoid Î²] [Module ð•œ E] [Module ð•œ F] [HasScalar ð•œ Î²] {f : F â†’ Î²} (g : E â†’áµƒ[ð•œ] F) {s : Set F} (hF : ConvexOn ð•œ s f) : ConvexOn ð•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
{Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [Semiring Î²] [hasZero Î±] [hasZero Î±â‚‚] {F : Type u_4} [zeroHomClass F Î± Î±â‚‚] (f : F) : Finsupp.mapDomain â‡‘f 1 = 1
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] [CategoryTheory.HasProjectiveResolutions C] [CategoryTheory.Preadditive D] [CategoryTheory.Limits.HasZeroObject D] [CategoryTheory.Limits.HasEqualizers D] [CategoryTheory.Limits.HasCokernels D] [CategoryTheory.Limits.HasImages D] [CategoryTheory.Limits.HasImageMaps D] {F G : C â¥¤ D} [F.additive] [G.additive] (Î± : F âŸ¶ G) (n : â„•) {X : C} (P : CategoryTheory.projectiveResolution X) : (CategoryTheory.NatTrans.leftDerived Î± n).app X = (F.left_derived_obj_iso n P).hom â‰« (homologyFunctor D (ComplexShape.down â„•) n).map ((CategoryTheory.NatTrans.mapHomologicalComplex Î± (ComplexShape.down â„•)).app P.complex) â‰« (G.left_derived_obj_iso n P).inv
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : InnerProductGeometry.angle x y â‰¤ Real.pi
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {r : â„•} (hð’œ : Set.Sized r â†‘ð’œ) : Set.Sized (r + 1) â†‘(ð’œ.up_shadow)
{H : Type u} {M : Type u_2} [topologicalSpace H] [topologicalSpace M] [chartedSpace H M] (G : StructureGroupoid H) [HasGroupoid M G] {e : localHomeomorph M H} (hE : e âˆˆ ChartedSpace.Atlas H M) : e âˆˆ StructureGroupoid.MaximalAtlas M G
{R : Type u_1} {a b : R} [Monoid R] (h : b * a = 1) : IsLeftRegular a
{K : Type v} [Field K] {P : Polynomial K} (hmo : P.monic) (hP : Polynomial.Splits (RingHom.id K) P) : P.coeff 0 = (-1) ^ P.nat_degree * P.roots.prod
{R : Type u} (L : Type v) [CommRing R] [LieRing L] [lieAlgebra R L] (Mâ‚ : Type wâ‚) (Mâ‚‚ : Type wâ‚‚) (Mâ‚ƒ : Type wâ‚ƒ) [AddCommGroup Mâ‚] [Module R Mâ‚] [LieRingModule L Mâ‚] [lieModule R L Mâ‚] [AddCommGroup Mâ‚‚] [Module R Mâ‚‚] [LieRingModule L Mâ‚‚] [lieModule R L Mâ‚‚] [AddCommGroup Mâ‚ƒ] [Module R Mâ‚ƒ] [LieRingModule L Mâ‚ƒ] [lieModule R L Mâ‚ƒ] (g : tensorProduct R Mâ‚ Mâ‚‚ â†’â‚—â…R,Lâ† Mâ‚ƒ) (Ï‡â‚ Ï‡â‚‚ : L â†’ R) : (â†‘g.comp (TensorProduct.mapIncl (LieModule.preWeightSpace Mâ‚ Ï‡â‚) (LieModule.preWeightSpace Mâ‚‚ Ï‡â‚‚))).range â‰¤ LieModule.preWeightSpace Mâ‚ƒ (Ï‡â‚ + Ï‡â‚‚)
(p : â„•) [Fact (Nat.Prime p)] : â†‘((p - 1).factorial) = -1
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} : IsMinOn (â‡‘OrderDual.toDual âˆ˜ f) s a â†’ IsMaxOn f s a
{Î± : Type u_1} [normedDivisionRing Î±] {a : Î±} (ha : a â‰  0) : Filter.Tendsto (Î» (x : Î±), x * a) (Filter.comap HasNorm.norm Filter.atTop) (Filter.comap HasNorm.norm Filter.atTop)
{R : Type u_1} {a : R} [Monoid R] (ua : IsUnit a) : IsRegular a
{a : â„} {l : Filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Univ  {a}), DifferentiableAt â„ f x) (hg' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Univ  {a}), deriv g x â‰  0) (hfa : Filter.Tendsto f (nhdsWithin a (Set.Univ  {a})) (nhds 0)) (hga : Filter.Tendsto g (nhdsWithin a (Set.Univ  {a})) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv f x / deriv g x) (nhdsWithin a (Set.Univ  {a})) l) : Filter.Tendsto (Î» (x : â„), f x / g x) (nhdsWithin a (Set.Univ  {a})) l
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] (f : S.localization_Map N) (z : N) : f.mk' (f.sec z).fst (f.sec z).snd = z
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Antitone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ioc (f n) (f (Order.pred n)))
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [Î  (i : Î¹), hasZero (Î² i)] (i j : Î¹) (xi : Î² i) (xj : Î² j) : Dfinsupp.single i xi = Dfinsupp.single j xj â†” i = j âˆ§ xi == xj âˆ¨ xi = 0 âˆ§ xj = 0
{Î± : Type u_1} {Î² : Type u_2} [Semigroup Î±] [commSemigroup Î²] {f g : Î± â†’ Î²} (hF : IsMulHom f) (hg : IsMulHom g) : IsMulHom (Î» (a : Î±), f a * g a)
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [topologicalSpace Î±] (L : âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (F : Î± â†’ Î²), ContinuousOn F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u)) : ContinuousOn f s
{X : Type u_2} {Y : Type u_3} [topologicalSpace X] [topologicalSpace Y] [TopologicalSpace.PseudoMetrizableSpace Y] {f : X â†’ Y} (hF : Inducing f) : TopologicalSpace.PseudoMetrizableSpace X
 : Function.RightInverse Coe â‡‘Cardinal.toNat
{R : Type u_1} [CommRing R] {a b : Quaternion R} (h : Commute a b) : Commute (â‡‘Quaternion.conj a) (â‡‘Quaternion.conj b)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (X Y : C) [CategoryTheory.Limits.HasBinaryBiproduct X Y] {b : CategoryTheory.Limits.BinaryBicone X Y} (hb : b.is_bilimit) : (hb.is_limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)).hom = CategoryTheory.Limits.biprod.lift b.fst b.snd
{M : Type u_1} {N : Type u_2} [AddZeroClass M] [AddZeroClass N] (h : M â‰ƒ+ N) : â‡‘h 0 = 0
{R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring Râ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {Î¹ : Type u_3} {v : Î¹ â†’ M} {f g : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (hv : Submodule.span R (Set.Range v) = âŠ¤) (h : âˆ€ (i : Î¹), â‡‘f (v i) = â‡‘g (v i)) : f = g
{G : Type u_1} [Group G] [hN : Nontrivial G] : monoid.is_torsion G â†’ Â¬monoid.is_torsion_free G
{Î± : Type u_1} [hasLt Î±] {a b : Î±} {o : Ordering} : o.swap.compares a b â†’ o.compares b a
{Î± : Type u_1} : Sym2.map (Î» (x : Î±), x) = Id
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] {x y : E} (hxy : x â‰  y) : âˆƒ (f : E â†’L[â„] â„), â‡‘f x < â‡‘f y
{a : Ennreal} (h : a < âŠ¤) : AddLeCancellable a
{x y : SimplexCategory} {f : x âŸ¶ y} : CategoryTheory.Epi f â†’ y.len â‰¤ x.len
{R : Type u_1} [MulZeroClass R] : IsLeftRegular 0 â†” Subsingleton R
{Î± : Type u_1} [LinearOrder Î±] {r s : Î±} : {r}.to_colex â‰¤ {s}.to_colex â†” r â‰¤ s
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {f : Î± â†’ Î²} (hF : IsAddGroupHom f) (a : Î±) : f (-a) = -f a
{Î± : Type u} {s : Set Î±} (hc : s.countable) (hs : s.nonempty) : âˆƒ (f : â„• â†’ Î±), s = Set.Range f
{Î± : Type u_1} (o : Part Î±) : {Dom := o.dom, get := Î» (h : o.dom), o.get h} = o
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' fâ‚' : E â†’L[ð•œ] F} {x : E} {s : Set E} (H : UniqueDiffWithinAt ð•œ s x) (hF : HasFderivWithinAt f f' s x) (hg : HasFderivWithinAt f fâ‚' s x) : f' = fâ‚'
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : â‡‘fin.cast_Succ j < i) : X.Î´ i.succ â‰« X.Ïƒ (â‡‘fin.cast_Succ j) = X.Ïƒ j â‰« X.Î´ i
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {u v : E} (hvm : v âˆˆ K) (hvo : âˆ€ (w : E), w âˆˆ K â†’ HasInner.inner (u - v) w = 0) : orthogonalProjectionFn K u = v
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {a : E} (hF : HasStrictFderivAt f f' a) (hF' : f'.range = âŠ¤) (hker : f'.ker.closed_complemented) : âˆ€á¶  (p : F Ã— â†¥(f'.ker)) in nhds (f a, 0), f (HasStrictFderivAt.implicitFunctionOfComplemented f f' hF hF' hker p.fst p.snd) = p.fst
{k : Type u_1} {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {n : â„•} (s : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : â„•} (h : fs.card = m + 1) : Finset.centroid k Finset.univ (s.face h).points = Finset.centroid k fs s.points
{Î± : Type u_1} {Î¹ : Type u_3} [Lattice Î±] [OrderBot Î±] {s : Finset Î¹} {f : Î¹ â†’ Î±} [DecidableEq Î¹] : s.sup_indep f â†” âˆ€ (i : Î¹), i âˆˆ s â†’ Disjoint (f i) ((s.erase i).sup f)
(x : â„‚) : HasDerivAt Complex.cos (-Complex.sin x) x
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {f' : F} {x : ð•œ} {L : Filter ð•œ} : HasDerivAtFilter f f' x L â†” Filter.Tendsto (slope f x) (L âŠ“ Filter.principal {x}á¶œ) (nhds f')
{L : FirstOrder.Language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.hom M N) (g : L.hom N P) (h : L.hom P Q) : (h.comp g).comp f = h.comp (g.comp f)
{E : Type u_2} [semiNormedGroup E] [normedSpace â„ E] {s : Set E} : Metric.Bounded (â‡‘(convexHull â„) s) â†” Metric.Bounded s
{Î± : Type u_1} [Preorder Î±] [AddCommSemigroup Î±] [HasSub Î±] [HasOrderedSub Î±] {a b : Î±} : a + b - a â‰¤ b
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
 : absolute_value.abs.is_euclidean
{R : Type u} {n : â„•} {M : Fin n.succ â†’ Type v} {Mâ‚‚ : Type vâ‚‚} [Semiring R] [Î  (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid Mâ‚‚] [Î  (i : Fin n.succ), Module R (M i)] [Module R Mâ‚‚] (f : MultilinearMap R M Mâ‚‚) (m : Î  (i : Fin n), M i.succ) (x y : M 0) : â‡‘f (fin.cons (x + y) m) = â‡‘f (fin.cons x m) + â‡‘f (fin.cons y m)
{Î± : Type u_1} (G : SimpleGraph Î±) [Fintype Î±] [DecidableEq Î±] [DecidableRel G.adj] {n : â„•} : G.clique_free n â†’ G.clique_Finset n = âˆ…
 : RingHom.LocalizationPreserves RingHom.Finite
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [DecidableEq Î±] (H : FreeGroup.Red Lâ‚ Lâ‚‚) : FreeGroup.Red Lâ‚‚ (FreeGroup.reduce Lâ‚)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p âˆˆ s) (v : V) : v âˆˆ s.direction â†” âˆƒ (p2 : P) (H : p2 âˆˆ s), v = p -áµ¥ p2
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w} [CategoryTheory.Category D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)] (P : Cáµ’áµ– â¥¤ D) [âˆ€ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.cover X)áµ’áµ– D] : J.plus_Map (J.to_plus P) = J.to_plus (J.plus_obj P)
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (hb : t.card â€¢ b < s.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²) (H : y âˆˆ t), b < (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
{Î± : Type u} {Î² : Type v} {mâ‚ mâ‚‚ : Î± â†’ Î²} {f : Filter Î±} (h : mâ‚ =á¶ [f] mâ‚‚) : Filter.map mâ‚ f = Filter.map mâ‚‚ f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} {f : ð•œ â†’ F} {s : Set ð•œ} : iteratedFderivWithin ð•œ n f s = â‡‘(ContinuousMultilinearMap.piFieldEquiv ð•œ (Fin n) F) âˆ˜ iteratedDerivWithin n f s
{G : Type u} [CategoryTheory.Groupoid G] [IsFreeGroupoid G] (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) [Quiver.Arborescence â†¥T] {a : G} (p : Quiver.Path (Quiver.root â†¥T) a) : IsFreeGroupoid.SpanningTree.treeHom T a = IsFreeGroupoid.SpanningTree.homOfPath T p
{Î± : Type u_1} [LinearOrder Î±] {A B : Finset Î±} (h : A âŠ‚ B) : A.to_colex < B.to_colex
{Î± : Type u_1} [hasAdd Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {b c : Î±} (bc : b < c) (a : Î±) : a + b < a + c
{X : Type u_2} {Y : Type u_3} [emetricSpace X] [emetricSpace Y] {K : Nnreal} {f : X â†’ Y} (h : LipschitzWith K f) : dimH (Set.Range f) â‰¤ dimH Set.Univ
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) {C : â„} (hF'_GT : âˆ€ (x : â„), x âˆˆ Interior D â†’ C < deriv f x) (x : â„) (H : x âˆˆ D) (y : â„) (H_1 : y âˆˆ D) : x < y â†’ C * (y - x) < f y - f x
{Î± : Type u_1} [AddSemigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x + x) âˆ˜ Î» (_x : Î±), _x + y) = Î» (_x : Î±), _x + (y + x)
{Î² : Type u} (f : Î² â†’ Type u) {P : Type u} (s : Î  (b : Î²), P âŸ¶ f b) (b : Î²) (x : P) : Category_theory.limits.pi.Ï€ f b (CategoryTheory.Limits.Pi.lift s x) = s b x
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [cs : CompleteSpace E] {f : E â†’ F} {f' : E â‰ƒL[ð•œ] F} {a : E} (hF : HasStrictFderivAt f â†‘f' a) : HasStrictFderivAt (HasStrictFderivAt.localInverse f f' a hF) â†‘(f'.symm) (f a)
{Î± : Type u} [topologicalSpace Î±] [t2_Space Î±] (s : Finset Î±) : âˆƒ (f : Î± â†’ Set Î±), â†‘s.pairwise_Disjoint f âˆ§ âˆ€ (x : Î±), x âˆˆ s â†’ x âˆˆ f x âˆ§ is_IsOpen (f x)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {xâ‚€ : E} (hF : DifferentiableAt ð•œ f xâ‚€) {s : Set E} (hs : s âˆˆ nhds xâ‚€) {C : Nnreal} (hlip : LipschitzOnWith C f s) : âˆ¥fderiv ð•œ f xâ‚€âˆ¥ â‰¤ â†‘C
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] {xâ‚€ : Î±} {K : Set Î²} (hK : is_IsCompact K) {P : Î± â†’ Î² â†’ Prop} (hP : âˆ€ (y : Î²), y âˆˆ K â†’ (âˆ€á¶  (z : Î± Ã— Î²) in nhds (xâ‚€, y), P z.fst z.snd)) : âˆ€á¶  (x : Î±) in nhds xâ‚€, âˆ€ (y : Î²), y âˆˆ K â†’ P x y
{Î± : Type u} {s : Set (Set Î±)} (hs : Cardinal.mk â†¥s â‰¤ Cardinal.continuum) : Cardinal.mk â†¥{t : Set Î± | MeasurableSpace.GenerateMeasurable s t} â‰¤ Cardinal.continuum
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {n : WithTop â„•} (g : F â†’L[ð•œ] G) (hF : ContDiffOn ð•œ n f s) : ContDiffOn ð•œ n (â‡‘g âˆ˜ f) s
{G : Type u_1} [topologicalSpace G] [AddGroup G] [TopologicalAddGroup G] (N : AddSubgroup G) [N.normal] : N.topological_closure.normal
{ð•œ : Type u_1} {Î± : Type u_2} [linearOrderedField ð•œ] [DecidableEq Î±] {k : â„•} {ð’œ : Finset (Finset Î±)} [Fintype Î±] (hk : k â‰¤ Fintype.card Î±) (hð’œ : IsAntichain HasSubset.Subset â†‘ð’œ) : (Finset.range (k + 1)).sum (Î» (r : â„•), â†‘((ð’œ.slice (Fintype.card Î± - r)).card) / â†‘((Fintype.card Î±).choose (Fintype.card Î± - r))) â‰¤ â†‘((Finset.falling (Fintype.card Î± - k) ð’œ).card) / â†‘((Fintype.card Î±).choose (Fintype.card Î± - k))
{Î· : Type u_1} [Fintype Î·] {Gs : Î· â†’ Type u_2} [Î  (i : Î·), Group (Gs i)] (H K : Î  (i : Î·), Subgroup (Gs i)) : â…Subgroup.pi Set.Univ H,Subgroup.pi Set.Univ Kâ† = Subgroup.pi Set.Univ (Î» (i : Î·), â…H i,K iâ†)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} [CompleteSpace E] (e : E â‰ƒL[ð•œ] F) : ContDiffAt ð•œ n ContinuousLinearMap.inverse â†‘e
(n p : â„•) : (Finset.filter (Î» (e : â„•), p âˆ£ e + 1) (Finset.range n)).card = n / p
{B : Type u_2} {F : Type u_3} [topologicalSpace B] [topologicalSpace F] : IsTrivialTopologicalFiberBundle F Prod.fst
{R : Type u} {S : Type v} [Semiring R] [AddCommMonoid S] (p : Polynomial R) {f : â„• â†’ R â†’ S} (h : âˆ€ (n : â„•), f n 0 = 0) : p.sum f = (Finset.range (p.nat_degree + 1)).sum (Î» (a : â„•), f a (p.coeff a))
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] (F : J Ã— K â¥¤ Type v) [CategoryTheory.IsFiltered K] [CategoryTheory.FinCategory J] : Function.Surjective (CategoryTheory.Limits.colimitLimitToLimitColimit F)
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} : Emetric.hausdorffEdist (Closure s) t = Emetric.hausdorffEdist s t
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : x = y â†” o.oangle x y = 0
{Î± : Type u_1} [topologicalSpace Î±] {x : Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] [HasContinuousAdd Î³] {f g : Î± â†’ Î³} (hF : UpperSemicontinuousAt f x) (hg : UpperSemicontinuousAt g x) : UpperSemicontinuousAt (Î» (z : Î±), f z + g z) x
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] [FiniteDimensional K L] : Algebra.IsIntegral K L
{Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [AddCommMonoid Î²] (R : Setoid Î±) [DecidableRel Setoid.r] : s.sum (Î» (x : Î±), f x) = (Finset.image Quotient.mk s).sum (Î» (xbar : Quotient R), (Finset.filter (Î» (y : Î±), âŸ¦yâŸ§ = xbar) s).sum (Î» (y : Î±), f y))
{C D E : CategoryTheory.Groupoid} (f : C âŸ¶ D) (g : D âŸ¶ E) : f â‰« g = f â‹™ g
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {x : E} {n : WithTop â„•} {s : Set E} {f : E â†’ F} (hF : ContDiffWithinAt ð•œ n f s x) : ContDiffWithinAt ð•œ n (Î» (x : E), -f x) s x
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {f g : C(Î±, Î²)} (H : f = g) (x : Î±) : â‡‘f x = â‡‘g x
{G : Type w} [topologicalSpace G] [AddGroup G] [TopologicalAddGroup G] {K U : Set G} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K âŠ† U) : âˆƒ (V : Set G) (H : V âˆˆ nhds 0), V + K âŠ† U
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (x : Module.Ray R M) : x.some_Vector â‰  0
(k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [Ring k] [AddCommGroup V1] [Module k V1] [addTorsor V1 P1] (p : P1) : â‡‘(AffineMap.id k P1) p = p
{n : â„•} {F : Typevec (n + 1) â†’ Type u} [Mvfunctor F] [q : Mvqpf F] {Î± : Typevec n} (r : Mvqpf.Cofix F Î± â†’ Mvqpf.Cofix F Î± â†’ Prop) (h : âˆ€ (x y : Mvqpf.Cofix F Î±), r x y â†’ Mvfunctor.Liftr (Î±.rel_Last r) x.dest y.dest) (x y : Mvqpf.Cofix F Î±) : r x y â†’ x = y
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P (n + 1)) (i : Fin (n + 2)) : s.points i âˆˆ s.altitude i
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [denselyOrdered Î±] : {s : Set Î± | IsPreconnected s} = Set.Range (Function.uncurry Set.Icc) âˆª Set.Range (Function.uncurry Set.Ico) âˆª Set.Range (Function.uncurry Set.Ioc) âˆª Set.Range (Function.uncurry Set.Ioo) âˆª (Set.Range Set.Ici âˆª Set.Range Set.Ioi âˆª Set.Range Set.Iic âˆª Set.Range Set.Iio âˆª {Set.Univ, âˆ…})
{Î± : Type u} [pseudoMetricSpace Î±] (R : â„) (h : âˆ€ (x : Î±) (r : â„), R â‰¤ r â†’ is_IsCompact (Metric.ClosedBall x r)) : ProperSpace Î±
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {f : Î± â†’ Î² â†’ Î³} (hF : Function.Injective2 f) [Nonempty Î±] : Function.Injective (Î» (b : Î²) (a : Î±), f a b)
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] [StrictConvexSpace â„ E] {x y : E} (h : Â¬SameRay â„ x y) : âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{G : Type u_1} [Group G] {Gâ‚‚ : Type u_2} [Group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)] [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)] (hne : pâ‚ â‰  pâ‚‚) (Hâ‚ : Subgroup G) (Hâ‚‚ : Subgroup Gâ‚‚) [Fintype â†¥Hâ‚] [Fintype â†¥Hâ‚‚] (hHâ‚ : is_p_Group pâ‚ â†¥Hâ‚) (hHâ‚‚ : is_p_Group pâ‚‚ â†¥Hâ‚‚) : (Fintype.card â†¥Hâ‚).coprime (Fintype.card â†¥Hâ‚‚)
{Î± : Type u} [SemilatticeSup Î±] [OrderBot Î±] (x y : Î±) : (x â¨¿ y) = x âŠ” y
(R : Type u) [CommRing R] : GaloisConnection (Î» (s : Set R), PrimeSpectrum.ZeroLocus s) (Î» (t : (Set (PrimeSpectrum R))áµ’áµˆ), â†‘(PrimeSpectrum.vanishingIdeal t))
{C : Type uâ‚} [CategoryTheory.Category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚ƒâ‚ Xâ‚ƒâ‚‚ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚ƒâ‚ : Xâ‚ƒâ‚ âŸ¶ Xâ‚ƒâ‚‚} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚ƒâ‚} {vâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚ƒâ‚‚} (s : CategoryTheory.IsPushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : CategoryTheory.IsPushout hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚) : CategoryTheory.IsPushout hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (H : Subgroup G) {f : G â†’* N} (hF : Function.bijective â‡‘f) : Subgroup.map f H.normalizer = (Subgroup.map f H).normalizer
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {f : â„ â†’ E} {a b C : â„} (hF : DifferentiableOn â„ f (Set.Icc a b)) (bound : âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ¥derivWithin f (Set.Icc a b) xâˆ¥ â‰¤ C) (x : â„) (H : x âˆˆ Set.Icc a b) : âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
{C : Type u} [CategoryTheory.Category C] {J K : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.Category K] (F : J â¥¤ C) (G : K â¥¤ C) (h : F.cones â‰… G.cones) [CategoryTheory.Limits.HasLimit F] : CategoryTheory.Limits.HasLimit G
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [Semiring R] [AddCommMonoid M] [Module R M] {s : Set Î¹} : Â¬LinearIndependent R (v âˆ˜ Coe) â†” âˆƒ (f : Î¹ â†’â‚€ R), f âˆˆ Finsupp.supported R R s âˆ§ f.support.sum (Î» (i : Î¹), â‡‘f i â€¢ v i) = 0 âˆ§ f â‰  0
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} {P : CategoryTheory.Subobject Y} {f g : X âŸ¶ â†‘P} (h : f â‰« P.arrow = g â‰« P.arrow) : f = g
{Î¹ : Type u_1} [Fintype Î¹] [DecidableEq Î¹] {R : Type u_2} [Semiring R] (x : Î¹ â†’ R) : x = finset.univ.sum (Î» (i : Î¹), x i â€¢ Î» (j : Î¹), Ite (i = j) 1 0)
{V : Type u} [Fintype V] [DecidableEq V] {â„“ : â„•} : âŠ¥.is_SRG_with (Fintype.card V) 0 â„“ 0
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topologicalSpace Î±] [uniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [CompactSpace Î±] : Filter.Tendsto F p (nhds f) â†” TendstoUniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
{E : Type u_1} {Î² : Type u_2} [AddCommGroup E] [topologicalSpace E] [Module â„ E] [TopologicalAddGroup E] [HasContinuousSmul â„ E] [OrderedAddCommGroup Î²] [Module â„ Î²] [OrderedSmul â„ Î²] {s : Set E} {f : E â†’ Î²} {a : E} (a_in_s : a âˆˆ s) (h_localmin : is_IsLocalMinOn f s a) (h_conv : ConvexOn â„ s f) : IsMinOn f s a
{Î¹ : Type u_6} [DecidableEq Î¹] {K : Type u_1} [Ring K] {M : Type u_2} [AddCommGroup M] [Module K M] {N : Type u_3} [AddCommGroup N] [Module K N] [NoZeroSmulDivisors K N] (f : AlternatingMap K M N Î¹) (v : Î¹ â†’ M) (h : Â¬LinearIndependent K v) : â‡‘f v = 0
{Î± : Type u_1} {s : Multiset Î±} : s.powerset.nodup â†’ s.nodup
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [Ring R] [Nontrivial R] [AddCommGroup M] [Module R M] [NoZeroSmulDivisors R M] (v : Î¹ â†’ M) [Unique Î¹] : v Inhabited.default â‰  0 â†’ LinearIndependent R v
{ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [NormedGroup G] [normedSpace ð•œ G] {f : ð•œ â†’ G} {s : Set ð•œ} {C : Nnreal} (hs : Convex â„ s) (hF : DifferentiableOn ð•œ f s) (bound : âˆ€ (x : ð•œ), x âˆˆ s â†’ âˆ¥derivWithin f s xâˆ¥â‚Š â‰¤ C) : LipschitzOnWith C f s
(R : Type u_1) [Rack R] (G : Type u_2) [Group G] (f : ShelfHom R (Quandle.Conj G)) : (Quandle.Conj.map (â‡‘Rack.toEnvelGroup.map f)).comp (Rack.toEnvelGroup R) = f
{Î± : Type u} {lâ‚ lâ‚‚ : List Î±} (i : â„•) : List.drop (lâ‚.length + i) (lâ‚ ++ lâ‚‚) = List.drop i lâ‚‚
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [IsAntisymm Î± r] {a b : Î±} : r a b â†’ r b a â†’ b = a
{f : â„• â†’ Nnreal} {r : Nnreal} : HasSum f r â†” Filter.Tendsto (Î» (n : â„•), (Finset.range n).sum (Î» (i : â„•), f i)) Filter.atTop (nhds r)
{X : Type u_1} {Y : Type u_2} [pseudoEmetricSpace X] [pseudoEmetricSpace Y] {C r : Nnreal} {f : X â†’ Y} (hF : HolderWith C r f) (h0 : 0 < r) : UniformContinuous f
{a b : â„} (h : a < b) : Cardinal.mk â†¥(Set.Icc a b) = Cardinal.continuum
{Î¹â‚ : Type u_1} {Î¹â‚‚ : Type u_2} {R : Type u_3} {Râ‚‚ : Type u_4} {S : Type u_5} {Sâ‚‚ : Type u_6} {M : Type u_7} {N : Type u_8} {P : Type u_9} [CommRing R] [CommRing S] [CommRing Râ‚‚] [CommRing Sâ‚‚] [AddCommGroup M] [AddCommGroup N] [AddCommGroup P] [Module R M] [Module S N] [Module Râ‚‚ P] [Module Sâ‚‚ P] [SmulCommClass Sâ‚‚ Râ‚‚ P] {Ïâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚â‚‚ : S â†’+* Sâ‚‚} (bâ‚ : Basis Î¹â‚ R M) (bâ‚‚ : Basis Î¹â‚‚ S N) {B : M â†’â‚›â‚—[Ïâ‚â‚‚] N â†’â‚›â‚—[Ïƒâ‚â‚‚] P} (x : M) (y : N) : (â‡‘(bâ‚.repr) x).sum (Î» (i : Î¹â‚) (xi : R), (â‡‘(bâ‚‚.repr) y).sum (Î» (j : Î¹â‚‚) (yj : S), â‡‘Ïâ‚â‚‚ xi â€¢ â‡‘Ïƒâ‚â‚‚ yj â€¢ â‡‘(â‡‘B (â‡‘bâ‚ i)) (â‡‘bâ‚‚ j))) = â‡‘(â‡‘B x) y
{x y : â„} (h : x < y) : âˆƒ (r : â„), Irrational r âˆ§ x < r âˆ§ r < y
{Î± : Type u} [CommSemiring Î±] {p p' : Î±} {ps ps' : â„•} : p = p' â†’ ps = ps' â†’ p ^ ps = p' ^ ps'
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] [FiniteDimensional F E] : [IsGalois F E, IntermediateField.fixedField âŠ¤ = âŠ¥, Fintype.card (E â‰ƒâ‚[F] E) = FiniteDimensional.finrank F E, âˆƒ (p : Polynomial F), p.separable âˆ§ Polynomial.IsSplittingField F E p].tfae
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [NormedGroup F] [normedSpace â„ F] {f : E â†’ F} {s : Set E} {x : E} (hF : ContDiffWithinAt â„ 1 f s x) (hs : Convex â„ s) : âˆƒ (K : Nnreal) (t : Set E) (H : t âˆˆ nhdsWithin x s), LipschitzOnWith K f t
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [BaireSpace Î±] [Encodable Î²] {f : Î² â†’ Set Î±} (ho : âˆ€ (s : Î²), is_GÎ´ (f s)) (hD : âˆ€ (s : Î²), Dense (f s)) : Dense (â‹‚ (s : Î²), f s)
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] [Nonempty V] : âˆƒ (v : V), G.max_degree = G.degree v
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f f' : X âŸ¶ Y} [CategoryTheory.Limits.HasImage f] [CategoryTheory.Limits.HasImage f'] [CategoryTheory.Limits.HasEqualizers C] (h : f = f') : CategoryTheory.Limits.imageÎ¹ f = (CategoryTheory.Limits.image.eqToIso h).hom â‰« CategoryTheory.Limits.imageÎ¹ f'
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {n : WithTop â„•} (h : ContDiffOn ð•œ n f s) (hn : 1 â‰¤ n) : DifferentiableOn ð•œ f s
(p : â„•) [Fact (Nat.Prime p)] (hp : p â‰  2) (a : â„¤) : â†‘({x : Zmod p | x ^ 2 = â†‘a}.to_finset.card) = Zmod.legendreSym p a + 1
{C : Type uâ‚} [CategoryTheory.Category C] {B : C} {X Y : CategoryTheory.Subobject B} (f : â†‘X â‰… â†‘Y) (w : f.hom â‰« Y.arrow = X.arrow) : X = Y
{Î± : Type u_1} [CancelCommMonoidWithZero Î±] [UniqueFactorizationMonoid Î±] [normalizationMonoid Î±] [DecidableEq Î±] {a b : Î±} (ha : a â‰  0) (hb : b â‰  0) : factorization (a * b) = factorization a + factorization b
{Î± : Type u} [Preorder Î±] {a : Î±} : a â‰¤ a
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] [topologicalSpace Î´] {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î³ â†’ Î´} (deâ‚ : DenseEmbedding eâ‚) (deâ‚‚ : DenseEmbedding eâ‚‚) : DenseEmbedding (Î» (p : Î± Ã— Î³), (eâ‚ p.fst, eâ‚‚ p.snd))
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a b : Î±} (h : a < b) (s : Set Î±) : [s âˆˆ nhdsWithin b (Set.Iic b), s âˆˆ nhdsWithin b (Set.Icc a b), s âˆˆ nhdsWithin b (Set.Ioc a b), âˆƒ (l : Î±) (H : l âˆˆ Set.Ico a b), Set.Ioc l b âŠ† s, âˆƒ (l : Î±) (H : l âˆˆ Set.Iio b), Set.Ioc l b âŠ† s].tfae
{Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ Ennreal} (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) : (s.sum (Î» (a : Î±), f a)).to_Real = s.sum (Î» (a : Î±), (f a).to_Real)
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [pseudoMetricSpace Î²] {f g : boundedContinuousFunction Î± Î²} {C : â„} (C0 : 0 â‰¤ C) : HasDist.dist f g â‰¤ C â†” âˆ€ (x : Î±), HasDist.dist (â‡‘f x) (â‡‘g x) â‰¤ C
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) : â†‘(affineSpan k s).nonempty â†” s.nonempty
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] (g : C(Î², Î³)) : Continuous g.comp
(P L : Type u) [hasMem P L] [Configuration.HasPoints P L] [Fintype P] [Fintype L] : Fintype.card L â‰¤ Fintype.card P
{R : Type u_1} {a : R} [Monoid R] {n : â„•} (n0 : 0 < n) : IsLeftRegular (a ^ n) â†” IsLeftRegular a
{K : Type u_1} {n : â„•} {s : Seq (GeneralizedContinuedFraction.Pair K)} [divisionRing K] : (GeneralizedContinuedFraction.squashSeq s (n + 1)).tail = GeneralizedContinuedFraction.squashSeq s.tail n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.NonPreadditiveAbelian C] {X Y : C} (f : X âŸ¶ Y) : CategoryTheory.NonPreadditiveAbelianÏƒ â‰« f = CategoryTheory.Limits.prod.map f f â‰« CategoryTheory.NonPreadditiveAbelianÏƒ
{R : Type u_1} {M : Type u_2} [AddZeroClass R] [AddZeroClass M] {P : TrivSqZeroExt R M â†’ Prop} (h : âˆ€ (r : R) (m : M), P (TrivSqZeroExt.inl r + TrivSqZeroExt.inr m)) (x : TrivSqZeroExt R M) : P x
{Î¹ : Type u_1} {R : Type u_2} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] [Fintype Î¹] {O : Type u_3} [AddCommGroup O] [Module R O] (M N : Submodule R O) (b'M : Basis Î¹ R â†¥M) (N_IsBot : N â‰  âŠ¥) (N_LE_M : N â‰¤ M) : âˆƒ (y : O) (H : y âˆˆ M) (a : R) (hay : a â€¢ y âˆˆ N) (M' : Submodule R O) (H : M' â‰¤ M) (N' : Submodule R O) (H : N' â‰¤ N) (N'_LE_M' : N' â‰¤ M') (y_IsOrtho_M' : âˆ€ (c : R) (z : O), z âˆˆ M' â†’ c â€¢ y + z = 0 â†’ c = 0) (ay_IsOrtho_N' : âˆ€ (c : R) (z : O), z âˆˆ N' â†’ c â€¢ a â€¢ y + z = 0 â†’ c = 0), âˆ€ (n' : â„•) (bN' : Basis (Fin n') R â†¥N'), âˆƒ (bN : Basis (Fin (n' + 1)) R â†¥N), âˆ€ (m' : â„•) (hn'm' : n' â‰¤ m') (bM' : Basis (Fin m') R â†¥M'), âˆƒ (hnm : n' + 1 â‰¤ m' + 1) (bM : Basis (Fin (m' + 1)) R â†¥M), âˆ€ (as : Fin n' â†’ R), (âˆ€ (i : Fin n'), â†‘(â‡‘bN' i) = as i â€¢ â†‘(â‡‘bM' (â‡‘(fin.cast_LE hn'm') i))) â†’ (âˆƒ (as' : Fin (n' + 1) â†’ R), âˆ€ (i : Fin (n' + 1)), â†‘(â‡‘bN i) = as' i â€¢ â†‘(â‡‘bM (â‡‘(fin.cast_LE hnm) i)))
{G : Type u_1} [AddGroup G] (K : AddSubgroup G) : AddSubgroup.closure â†‘K = K
{E : â„• â†’ Type u_1} [Î  (n : â„•), topologicalSpace (E n)] [âˆ€ (n : â„•), discreteTopology (E n)] {s : Set (Î  (n : â„•), E n)} (hs : is_IsClosed s) (hne : s.nonempty) : âˆƒ (f : (Î  (n : â„•), E n) â†’ Î  (n : â„•), E n), (âˆ€ (x : Î  (n : â„•), E n), x âˆˆ s â†’ f x = x) âˆ§ Set.Range f = s âˆ§ LipschitzWith 1 f
{Î± : Type u} {Î² : Type v} (e : Î± â‰ƒ Î²) [Nontrivial Î²] : Nontrivial Î±
{Î± : Type u_1} [measurableSpace Î±] {mâ‚ mâ‚‚ mâ‚ƒ : MeasureTheory.OuterMeasure Î±} {Op : Ennreal â†’ Ennreal â†’ Ennreal} (h : âˆ€ (s : Set Î±), â‡‘mâ‚ s = Op (â‡‘mâ‚‚ s) (â‡‘mâ‚ƒ s)) (s : Set Î±) : â‡‘(mâ‚.trim) s = Op (â‡‘(mâ‚‚.trim) s) (â‡‘(mâ‚ƒ.trim) s)
{Î± : Type u} [AddCommGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] {a b c : Î±} : a â‰¤ b + c â†’ a - b â‰¤ c
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [FiniteDimensional ð•œ E] [FiniteDimensional ð•œ F] {Î¹â‚ : Type u_4} {Î¹â‚‚ : Type u_5} (bâ‚ : Basis Î¹â‚ ð•œ E) (bâ‚‚ : Basis Î¹â‚‚ ð•œ F) (A : E â†’â‚—[ð•œ] F) (B : F â†’â‚—[ð•œ] E) : A = â‡‘LinearMap.adjoint B â†” âˆ€ (iâ‚ : Î¹â‚) (iâ‚‚ : Î¹â‚‚), HasInner.inner (â‡‘A (â‡‘bâ‚ iâ‚)) (â‡‘bâ‚‚ iâ‚‚) = HasInner.inner (â‡‘bâ‚ iâ‚) (â‡‘B (â‡‘bâ‚‚ iâ‚‚))
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {Î¹ : Type u_3} {t : Finset Î¹} {f : Î¹ â†’ L} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.prod (Î» (i : Î¹), f i) âˆˆ S
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚} (hD : âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) (hb : Filter.IsBoundedUnder LE.le (nhdsWithin c {c}á¶œ) (Î» (z : â„‚), âˆ¥f z - f câˆ¥)) : Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (lim (nhdsWithin c {c}á¶œ) f))
{R : Type u_1} [CommSemiring R] {A : Type u} [topologicalSpace A] [Semiring A] [Algebra R A] [TopologicalSemiring A] (s : Subalgebra R A) {B : Type u_2} [topologicalSpace B] [Ring B] [TopologicalRing B] [Algebra R B] (f : B â†’â‚[R] A) (f' : B â‰ƒâ‚œ A) (w : â‡‘f = â‡‘f') : s.topological_closure.comap' f = (s.comap' f).topological_Closure
{Î± : Type u_1} {C : Cycle Î± â†’ Prop} (s : Cycle Î±) (H0 : C Cycle.nil) (HI : âˆ€ (a : Î±) (l : List Î±), C â†‘l â†’ C â†‘(a :: l)) : C s
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) (Î¸ : Real.Angle) : â‡‘(hb.rotation Î¸) x = x â†” Î¸ = 0
{x y : â„} : Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y
{X : Type u_2} [emetricSpace X] [TopologicalSpace.SecondCountableTopology X] {s : Set X} {r : Ennreal} (h : r < dimH s) : âˆƒ (x : X) (H : x âˆˆ s), âˆ€ (t : Set X), t âˆˆ nhdsWithin x s â†’ r < dimH t
{A : Type u_1} [CommRing A] [Algebra â„š A] (n : â„•) : (Finset.range n).sum (Î» (k : â„•), PowerSeries.exp A ^ k) = PowerSeries.mk (Î» (p : â„•), (Finset.range n).sum (Î» (k : â„•), â†‘k ^ p * â‡‘(algebraMap â„š A) (â†‘(p.factorial))â»Â¹))
{G : Type u_1} [CommMonoid G] : monoid.is_torsion â†¥(comm_monoid.torsion G)
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} {s : Set Î±} {r : Ennreal} : Emetric.infEdist x s < r â†” âˆƒ (y : Î±) (H : y âˆˆ s), HasEdist.edist x y < r
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : ContinuousMultilinearMap ð•œ E G) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * â†‘(Fintype.card Î¹) * Linear_order.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (Fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
{fâ‚ fâ‚‚ : Circle_deg1_Lift} (hâ‚ : Function.bijective â‡‘fâ‚) (hâ‚‚ : Function.bijective â‡‘fâ‚‚) (h : fâ‚.translation_number = fâ‚‚.translation_number) : âˆƒ (F : Circle_deg1_Lift), Function.Semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
{X : Type u} [Lattice X] [JordanHolderLattice X] (sâ‚ sâ‚‚ : CompositionSeries X) (hb : sâ‚.bot = sâ‚‚.bot) (ht : sâ‚.top = sâ‚‚.top) : sâ‚.equivalent sâ‚‚
{Î± : Type u_1} [completeLattice Î±] {s : Set Î±} {b : Î±} (_x : âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ b) (H : âˆ€ (w : Î±), w < b â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), w < a)) : HasSup.sup s = b
{K : Type u_1} [Field K] [Fintype K] (i : â„•) (h : i < Fintype.card K - 1) : finset.univ.sum (Î» (x : K), x ^ i) = 0
{R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [Ring R] [AddCommGroup M] [AddCommGroup Mâ‚‚] [Module R M] [Module R Mâ‚‚] (f : M â‰ƒâ‚—[R] Mâ‚‚) : FiniteDimensional.finrank R M = FiniteDimensional.finrank R Mâ‚‚
{R : Type u} {S : Type v} [Semiring R] [AddCommMonoid S] (p : Polynomial R) {f : â„• â†’ R â†’ S} (h : âˆ€ (n : â„•), f n 0 = 0) (n : â„•) (w : p.nat_degree < n) : p.sum f = (Finset.range n).sum (Î» (a : â„•), f a (p.coeff a))
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R) {r : R} {s : â†¥(NonZeroDivisors R)} : â‡‘(v.valuation) (IsLocalization.mk' K r s) = â‡‘(v.int_Valuation) r / â‡‘(v.int_Valuation) â†‘s
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) (C : Nnreal) {r : Nnreal} (h : âˆ€ (n : â„•), âˆ¥p nâˆ¥â‚Š * r ^ n â‰¤ C) : â†‘r â‰¤ p.radius
{Î± : Type u_1} [linearOrderedField Î±] [Archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : 1 < y) : âˆƒ (n : â„¤), x âˆˆ Set.Ioc (y ^ n) (y ^ (n + 1))
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {f : M â†’* N} (h : âˆ€ (y : â†¥S), IsUnit (â‡‘f â†‘y)) (y : â†¥S) (w z : N) : z = w * â†‘(â‡‘(IsUnit.liftRight (f.restrict S) h) y)â»Â¹ â†” z * â‡‘f â†‘y = w
{Î± : Type u} {Î² : Type v} [AddZeroClass Î±] [AddZeroClass Î²] {f : Î± â†’ Î²} (hF : IsAddMonoidHom f) {Î³ : Type u_1} [AddZeroClass Î³] {g : Î² â†’ Î³} (hg : IsAddMonoidHom g) : IsAddMonoidHom (g âˆ˜ f)
(Î± : Type u_1) [completeLattice Î±] : CompleteLattice.IsSupFiniteCompact Î± â†’ WellFounded GT
{R : Type u_1} [MulZeroClass R] [nR : Nontrivial R] : Â¬IsRightRegular 0
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (hs : is_IsCompact s) {p : Set Î± â†’ Prop} (hE : p âˆ…) (hmono : âˆ€ â¦ƒs t : Set Î±â¦„, s âŠ† t â†’ p t â†’ p s) (hunion : âˆ€ â¦ƒs t : Set Î±â¦„, p s â†’ p t â†’ p (s âˆª t)) (hnhds : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (t : Set Î±) (H : t âˆˆ nhdsWithin x s), p t)) : p s
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {f : Î± â†’ Î²} (hF : IsGroupHom f) (a : Î±) : f aâ»Â¹ = (f a)â»Â¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q) (a b : CategoryTheory.Over P) : a â‰ˆ b â†’ CategoryTheory.Abelian.app f a â‰ˆ CategoryTheory.Abelian.app f b
{Î± : Type u_1} {Î² : Type u_3} [measurableSpace Î±] [measurableSpace Î²] : MeasurableSpace.generateFrom (Set.image2 HasSetProd.prod {s : Set Î± | MeasurableSet s} {t : Set Î² | MeasurableSet t}) = Prod.measurableSpace
{ð•œ : Type u_1} {E : Type u_2} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] {pâ‚ pâ‚‚ : FormalMultilinearSeries ð•œ ð•œ E} {f : ð•œ â†’ E} {râ‚ râ‚‚ : Ennreal} {x : ð•œ} (hâ‚ : HasFpowerSeriesOnBall f pâ‚ x râ‚) (hâ‚‚ : HasFpowerSeriesOnBall f pâ‚‚ x râ‚‚) : HasFpowerSeriesOnBall f pâ‚ x râ‚‚
{R : Type u} [Semiring R] {p : Polynomial R} {n : â„•} : p.nat_degree â‰¤ n â†’ p.degree â‰¤ â†‘n
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {n : â„•} [Nonempty Î²] (hn : Fintype.card Î± â‰¤ Fintype.card Î² * n) : âˆƒ (y : Î²), (Finset.filter (Î» (x : Î±), f x = y) Finset.univ).card â‰¤ n
{X : Top} {T : â†¥X â†’ Type v} (P : Top.LocalPredicate T) : (Top.subpresheafToTypes P.to_prelocal_predicate).is_sheaf
{ð•œ : Type u_2} [is_R_or_C ð•œ] {E : Type u_3} [innerProductSpace ð•œ E] [cplt : CompleteSpace E] {s : Set E} (hs : Orthonormal ð•œ Coe) : âˆƒ (w : Set E) (b : HilbertBasis â†¥w ð•œ E), s âŠ† w âˆ§ â‡‘b = Coe
{ð•œ : Type u_1} [is_R_or_C ð•œ] {F : Type u_2} [semiNormedGroup F] [normedSpace ð•œ F] (p : Subspace ð•œ F) (f : â†¥p â†’L[ð•œ] ð•œ) : âˆƒ (g : F â†’L[ð•œ] ð•œ), (âˆ€ (x : â†¥p), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥
{C : Type uâ‚} [CategoryTheory.Category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚â‚ƒ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚‚â‚ƒ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚â‚ƒ} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚‚â‚ƒ} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚â‚ƒ : Xâ‚â‚ƒ âŸ¶ Xâ‚‚â‚ƒ} (s : CategoryTheory.IsPushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : CategoryTheory.IsPushout hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚) : CategoryTheory.IsPushout (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {f : Î± â†’ Î² â†’ Î³} {tas : Set (topologicalSpace Î±)} {tbs : Set (topologicalSpace Î²)} {ta : topologicalSpace Î±} {tb : topologicalSpace Î²} {Tc : topologicalSpace Î³} (ha : ta âˆˆ tas) (hb : tb âˆˆ tbs) (hF : Continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)) : Continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)
{M : Type u_1} [MulOneClass M] {Î¹ : sort u_2} (S : Î¹ â†’ Submonoid M) {C : M â†’ Prop} {x : M} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : M), x âˆˆ S i â†’ C x) (h1 : C 1) (HMul : âˆ€ (x y : M), C x â†’ C y â†’ C (x * y)) : C x
{G : Type u} [Group G] [Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G) : Fintype.card â†¥P = p ^ â‡‘((Fintype.card G).factorization) p
(n : â„•) : HasDerivAt (expNegInvGlue.fAux n) 0 0
{Î± : Type u} [NonUnitalNonAssocRing Î±] {a b c d e : Î±} : a * e + c = b * e + d â†” (a - b) * e + c = d
{f : Ordinal â†’ Ordinal} (H : Ordinal.IsNormal f) : Set.Unbounded LT.lt (Function.FixedPoints f)
{Î± : Type u_1} [measurableSpace Î±] {Î¹ : Type u_2} {f : Î¹ â†’ Î± â†’ Nnreal} {g : Î± â†’ Nnreal} (u : Filter Î¹) [u.ne_IsBot] [u.is_countably_generated] (hF : âˆ€ (i : Î¹), Measurable (f i)) (lim : Filter.Tendsto f u (nhds g)) : Measurable g
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} (h_Mono : StrictMonoOn f s) (hs : s âˆˆ nhds a) (hfs_l : âˆ€ (b : Î²), b < f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ Set.Ico b (f a))) (hfs_r : âˆ€ (b : Î²), b > f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ Set.Ioc (f a) b)) : ContinuousAt f a
{x y : Pgame} (h : x < y) : x.lf y
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : âˆ€ (c : Set Î±), IsChain r c â†’ (âˆƒ (ub : Î±), âˆ€ (a : Î±), a âˆˆ c â†’ r a ub)) (Trans : âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) : âˆƒ (m : Î±), âˆ€ (a : Î±), r m a â†’ r a m
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] [t2_Space Î±] {s : Set Î²} {f g : Î² â†’ Î±} (h : Set.EqOn f g s) (hF : Continuous f) (hg : Continuous g) : Set.EqOn f g (Closure s)
{Î± : Type u} [pseudoEmetricSpace Î±] {x y : Î±} {s : Set Î±} : Emetric.infEdist x s â‰¤ Emetric.infEdist y s + HasEdist.edist x y
{M : Type u_1} [AddGroup M] (c : AddCon M) {w x : M} : â‡‘c w x â†’ â‡‘c (-w) (-x)
{R : Type u_1} {a : R} [Monoid R] (n : â„•) (rra : IsRightRegular a) : IsRightRegular (a ^ n)
{E : Type u_2} {ð•œ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] {s : Set E} (hs : Convex ð•œ s) : Convex ð•œ (Interior s)
{Î² : Type v} [pseudoEmetricSpace Î²] {Î± : Type u} [emetricSpace Î±] {f : Î± â†’ Î²} (h : Isometry f) : Function.Injective f
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : hb.oangle (-x) y = hb.oangle x (-y)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {s : Set (E Ã— F)} : ContDiffOn ð•œ n Prod.snd s
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} {x : Î±} : x âˆˆ Closure s â†” âˆƒ (u : Ultrafilter Î±), s âˆˆ u âˆ§ â†‘u â‰¤ nhds x
 : Filter.Tendsto (Î» (k : â„•), (Finset.range k).sum (Î» (i : â„•), (-1) ^ i / (2 * â†‘i + 1))) Filter.atTop (nhds (Real.pi / 4))
{H : Type u_1} [topologicalSpace H] {x : H} : ChartedSpace.chartAt H x = LocalHomeomorph.refl H
{R : Type u_1} [CommRing R] {xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ) ^ 2 + (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚) ^ 2
{R : Type u_1} {a b : R} [AddMonoid R] (h : b + a = 0) : IsAddLeftRegular a
{G : Type u_1} [AddGroup G] (tG : Add_monoid.is_torsion G) (bounded : (Set.Range (Î» (g : G), addOrderOf g)).finite) : Add_monoid.exponent_exists G
{Î± : Type u} [Preorder Î±] {s : Set Î±} {a : Î±} (h : IsLeast s a) : BddBelow s
(p : â„•) [Fact (Nat.Prime p)] (R : Type uâ‚) [CommSemiring R] [Char_p R p] : PerfectionMap p (Perfection.coeff R p 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] {X : C} (Y : CategoryTheory.Subobject X) : CategoryTheory.Simple â†‘Y â†” IsAtom Y
{Î¹ : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {lb lb' : Filter â„} {Lt : Filter Î¹} {a b : â„} {u v : Î¹ â†’ â„} [Interval_integral.FTC_Filter b lb lb'] (hab : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f lb' MeasureTheory.MeasureSpace.volume) (hF : Filter.Tendsto f (lb' âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) (hu : Filter.Tendsto u Lt lb) (hv : Filter.Tendsto v Lt lb) : (Î» (t : Î¹), ((âˆ« (x : â„) in a..v t, f x) - âˆ« (x : â„) in a..u t, f x) - (v t - u t) â€¢ c) =o[Lt] (v - u)
{Î± : Type u} [canonicallyOrderedCommSemiring Î±] [Nontrivial Î±] : 0 < 1
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace ð•œ] (s : Submodule ð•œ E) [FiniteDimensional ð•œ â†¥s] : is_IsClosed â†‘s
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (Î¸ : Real.Angle) : (hb.rotation Î¸).symm = hb.rotation (-Î¸)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : Set P} (ho : EuclideanGeometry.OrthocentricSystem s) {p : Fin 3 â†’ P} (hps : Set.Range p âŠ† s) (hpi : Function.Injective p) : affineSpan â„ (Set.Range p) = affineSpan â„ s
{G : Type u_2} [AddGroup G] {a b : G} : a = b â†’ a - b = 0
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {v w : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (hw : âˆ€ (i : Î¹), w i = v i âˆ¨ w i = -v i) : Orthonormal ð•œ w
 : Function.bijective Real.sinh
{Î± : Type u} [HasSubset Î±] [hasSsubset Î±] [isNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {a b : Î±} [IsAntisymm Î± HasSubset.Subset] (hâ‚ : a â‰  b) (hâ‚‚ : a âŠ† b) : a âŠ‚ b
(p : â„•) [Fact (Nat.Prime p)] {a : Zmod p} (ha : a â‰  0) : IsSquare a â†” a ^ (p / 2) = 1
{Î³ : Type w} [SemilatticeSup Î³] (a : Î³) {s : Set Î³} : BddAbove (HasInsert.insert a s) â†” BddAbove s
{Î± : Type u_2} [DecidableEq Î±] {s : Finset Î±} {B : Finset (Finset Î±)} {n : â„•} (h : âˆ€ (a : Î±), a âˆˆ s â†’ n â‰¤ (Finset.filter (HasMem.Mem a) B).card) : s.card * n â‰¤ B.sum (Î» (t : Finset Î±), (s âˆ© t).card)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {p : P} (hp : p âˆˆ s) {v : V} (hv : v âˆˆ (s.direction)á—®) : â‡‘(EuclideanGeometry.reflection s) (v +áµ¥ p) = -v +áµ¥ p
{R : Type u_1} {K : Type u_2} [Ring R] [Field K] (f : R â†’+* K) (hF : Function.Surjective â‡‘f) : f.ker.is_Maximal
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Vâ‚‚ : Type v'} [AddCommGroup Vâ‚‚] [Module K Vâ‚‚] [h : FiniteDimensional K V] (f : V â†’â‚—[K] Vâ‚‚) (hF : f.range = âŠ¤) : FiniteDimensional K Vâ‚‚
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semiNormedGroup Vâ‚] [semiNormedGroup Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_NormedGroupHom C hâˆ¥ â‰¤ C
{ð•œ : Type u_3} {E : Type u_4} [normedField ð•œ] [AddCommGroup E] [Module ð•œ E] (p : Seminorm ð•œ E) {r : â„} (hr : 0 < r) : Absorbent ð•œ (p.ball 0 r)
{R : Type uâ‚} [Monoid R] [HasDistribNeg R] : (-1) ^ 2 = 1
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x y : E} (hx : âˆ¥xâˆ¥ = 1) (hy : âˆ¥yâˆ¥ = 1) : HasInner.inner x y = 1 â†” x = y
{Î± : Type u} [Preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a < b â†’ a < c
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : 0 < r) : hb.oangle x (r â€¢ y) = hb.oangle x y
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {k : S.localization_Map P} (z : N) : â‡‘(k.lift _) (â‡‘(f.lift _) z) = z
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurableSpace Î±} [topologicalSpace Î²] [Preorder Î¹] {u : Î¹ â†’ Î± â†’ Î²} {f : MeasureTheory.Filtration Î¹ m} [topologicalSpace Î¹] [TopologicalSpace.MetrizableSpace Î¹] [measurableSpace Î¹] [TopologicalSpace.SecondCountableTopology Î¹] [OpensMeasurableSpace Î¹] [TopologicalSpace.MetrizableSpace Î²] (h : MeasureTheory.Adapted f u) (hu_Cont : âˆ€ (x : Î±), Continuous (Î» (i : Î¹), u i x)) : MeasureTheory.ProgMeasurable f u
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p) âˆˆ AffineSubspace.mk' p (s.direction)á—®
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {E : Type u_3} [hasNorm E] {F : Type u_4} [hasNorm F] (e : localHomeomorph Î± Î²) {b : Î²} (hb : b âˆˆ e.to_local_equiv.target) {f : Î² â†’ E} {g : Î² â†’ F} {C : â„} : asymptotics.is_O_with C (nhds b) f g â†” asymptotics.is_O_with C (nhds (â‡‘(e.symm) b)) (f âˆ˜ â‡‘e) (g âˆ˜ â‡‘e)
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} {r : R} (h : SameRay R x y) (hr : 0 â‰¤ r) : SameRay R x (r â€¢ y)
{G : Type u_1} [AddGroup G] {k : Set G} {p : G â†’ Prop} {x : G} (h : x âˆˆ AddSubgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ p x) (Hk_Inv : âˆ€ (x : G), x âˆˆ k â†’ p (-x)) (H1 : p 0) (HMul : âˆ€ (x y : G), p x â†’ p y â†’ p (x + y)) : p x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) (m : Multiset L) : (âˆ€ (a : L), a âˆˆ m â†’ a âˆˆ S) â†’ m.sum âˆˆ S
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} : ConvexOn ð•œ s f â†” Convex ð•œ s âˆ§ âˆ€ â¦ƒx y z : ð•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) (Î¸ : Real.Angle) : hb.oangle x (â‡‘(hb.rotation Î¸) x) = Î¸
{Î± : Type u} [topologicalSpace Î±] {s t : Set Î±} (hs : IsPreconnected s) (ht : is_IsClopen t) : Disjoint s t âˆ¨ s âŠ† t
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {n : WithTop â„•} {p : E â†’ FormalMultilinearSeries ð•œ E F} (hF : HasFtaylorSeriesUpToOn n f p s) (g : G â†’L[ð•œ] E) : HasFtaylorSeriesUpToOn n (f âˆ˜ â‡‘g) (Î» (x : G) (k : â„•), (p (â‡‘g x) k).comp_ContinuousLinearMap (Î» (_x : Fin k), g)) (â‡‘g â»Â¹' s)
{R : Type u_1} [CommRing R] {M : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] (Râ‚˜ : Type u_4) (Sâ‚˜ : Type u_5) [CommRing Râ‚˜] [CommRing Sâ‚˜] [Algebra R Râ‚˜] [IsLocalization M Râ‚˜] [Algebra S Sâ‚˜] [IsLocalization (Algebra.algebraMapSubmonoid S M) Sâ‚˜] (hRS : Function.Injective â‡‘(algebraMap R S)) (hM : Algebra.algebraMapSubmonoid S M â‰¤ NonZeroDivisors S) : Function.Injective â‡‘(algebraMap Râ‚˜ Sâ‚˜)
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] (S : Type u_3) [CommMonoid S] [DistribMulAction S M] [SmulCommClass S R M] : Module.IsTorsion' â†¥(Submodule.torsion' R M S) S
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} {s : Set E} (h : is_IsLocalMaxOn f s a) (hF : HasFderivWithinAt f f' s a) {y : E} (hy : y âˆˆ PosTangentConeAt s a) (hy' : -y âˆˆ PosTangentConeAt s a) : â‡‘f' y = 0
{Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [CommMonoid Î²] (R : Setoid Î±) [DecidableRel Setoid.r] : s.prod (Î» (x : Î±), f x) = (Finset.image Quotient.mk s).prod (Î» (xbar : Quotient R), (Finset.filter (Î» (y : Î±), âŸ¦yâŸ§ = xbar) s).prod (Î» (y : Î±), f y))
{M : Type u_1} [hasMul M] {N : Type u_2} [hasMul N] (f : M â†’â‚™* N) (hF : Function.Surjective â‡‘f) : f.srange = âŠ¤
(f : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfI : f a = f b) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), deriv f c = 0
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Limits.HasBinaryProducts C
(n : â„•) (R : Type u_1) [CommRing R] [is_IsDomain R] : Polynomial.cyclotomic' n R â‰  0
{Î± : Type u} [Preorder Î±] {s t : Set Î±} (h : BddAbove s) : BddAbove (s âˆ© t)
{Î± : Type u_1} [uniformSpace Î±] (x : Î±) : nhds (x, x) â‰¤ Uniformity Î±
{Î± : Type u_2} {Î¹ : Type u_5} [CommMonoid Î±] (t : Finset Î¹) (f : Î¹ â†’ Set Î±) (a : Î±) : a âˆˆ t.prod (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ {i : Î¹}, i âˆˆ t â†’ g i âˆˆ f i), t.prod (Î» (i : Î¹), g i) = a
{ð•œ : Type u_1} {A : Type u_2} [is_R_or_C ð•œ] [normedRing A] [NormedAlgebra ð•œ A] [CompleteSpace A] (a : A) {z : ð•œ} (hz : z âˆˆ Spectrum ð•œ a) : Exp ð•œ z âˆˆ Spectrum ð•œ (Exp ð•œ a)
(n : â„•) : â†‘n.numeric
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {p : E â†’ FormalMultilinearSeries ð•œ E F} {n : â„•} : HasFtaylorSeriesUpToOn (â†‘n + 1) f p s â†” HasFtaylorSeriesUpToOn â†‘n f p s âˆ§ (âˆ€ (x : E), x âˆˆ s â†’ HasFderivWithinAt (Î» (y : E), p y n) (p x n.succ).curry_Left s x) âˆ§ ContinuousOn (Î» (x : E), p x (n + 1)) s
{n : WithTop â„•} : ContDiff â„ n expNegInvGlue
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : o.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {x y : Î±} : (setoid.ker f).rel x y â†” x âˆˆ f â»Â¹' {f y}
{p : â„•} : padicValInt p 1 = 0
{S : Type u_2} [CommRing S] {K : Type u_4} {F : Type u_6} [Field K] [Field F] [Algebra K F] [Algebra K S] (pB : powerBasis K S) (hF : Polynomial.Splits (algebraMap K F) (minpoly K pb.gen)) : â‡‘(algebraMap K F) (â‡‘(Algebra.norm K) pb.gen) = (Polynomial.map (algebraMap K F) (minpoly K pb.gen)).roots.prod
{a b : Ordinal} : {o : Ordinal | a â‰¤ b + o}.nonempty
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] {r : â„} (hr : 0 â‰¤ r) : r â€¢ Metric.ClosedBall 0 1 = Metric.ClosedBall 0 r
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {p1 : P} (p2 : P) (r : â„) (hp : p1 âˆˆ s) : â‡‘(EuclideanGeometry.orthogonalProjection s) (r â€¢ (p2 -áµ¥ â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p2)) +áµ¥ p1) = âŸ¨p1, hpâŸ©
(k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) [Ring k] [AddCommGroup V1] [Module k V1] [addTorsor V1 P1] : â‡‘(AffineMap.id k P1) = Id
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (k : â„•) (h : âˆ€ (v : V), G.degree v â‰¤ k) : G.max_degree â‰¤ k
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e e' : localHomeomorph Î± Î²} (h : e â‰ˆ e') : e.symm â‰ˆ e'.symm
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E1 E2 : intermediateField K L) (h1 : FiniteDimensional K â†¥E1) (h2 : FiniteDimensional K â†¥E2) : FiniteDimensional K â†¥(E1 âŠ” E2)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (u : E) {v : E} (hv : v âˆˆ (Submodule.span ð•œ {u})á—®) : HasInner.inner v u = 0
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 2 R = Polynomial.x + 1
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [OrderedAddCommGroup Î²] [HasScalar ð•œ E] [Module ð•œ Î²] {s : Set E} {f : E â†’ Î²} : ConcaveOn ð•œ s (-f) â†” ConvexOn ð•œ s f
(G : Type u_1) [AddCommGroup G] : Add_comm_monoid.add_torsion G = (addTorsion G).to_addSubmonoid
{Î± : Type u} [pseudoMetricSpace Î±] : Isometry Coe
{Î³ : Type u_3} [tÎ³ : topologicalSpace Î³] [PolishSpace Î³] [measurableSpace Î³] [BorelSpace Î³] {Î² : Type u_4} [tÎ² : topologicalSpace Î²] [t2_Space Î²] [measurableSpace Î²] [BorelSpace Î²] {f : Î³ â†’ Î²} (f_Cont : Continuous f) (f_inj : Function.Injective f) : MeasurableEmbedding f
{R : Type u_1} [CommSemiring R] (M : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization M S] (j k : S â†’ P) (hj1 : j 1 = 1) (hk1 : k 1 = 1) (hjm : âˆ€ (a b : S), j (a * b) = j a * j b) (hkm : âˆ€ (a b : S), k (a * b) = k a * k b) (h : âˆ€ (a : R), j (â‡‘(algebraMap R S) a) = k (â‡‘(algebraMap R S) a)) : j = k
{Î± : Type u} [topologicalSpace Î±] {S : Set (Set Î±)} (K : DirectedOn HasSubset.Subset S) (H : âˆ€ (s : Set Î±), s âˆˆ S â†’ IsPreconnected s) : IsPreconnected (â‹ƒâ‚€S)
{Î± : Type u_1} [Lattice Î±] [IsModularLattice Î±] {Î² : Type u_2} {Î³ : Type u_3} [PartialOrder Î²] [Preorder Î³] (hâ‚ : WellFounded LT.lt) (hâ‚‚ : WellFounded LT.lt) (K : Î±) (fâ‚ : Î² â†’ Î±) (fâ‚‚ : Î± â†’ Î²) (gâ‚ : Î³ â†’ Î±) (gâ‚‚ : Î± â†’ Î³) (gci : GaloisCoinsertion fâ‚ fâ‚‚) (gi : GaloisInsertion gâ‚‚ gâ‚) (hF : âˆ€ (a : Î±), fâ‚ (fâ‚‚ a) = a âŠ“ K) (hg : âˆ€ (a : Î±), gâ‚ (gâ‚‚ a) = a âŠ” K) : WellFounded LT.lt
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] {a : Î±} : IsMin a â†’ Order.pred a = a
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) : t.prod.degree â‰¤ (Multiset.map Polynomial.degree t).sum
{M : Type u_1} [hasAdd M] {c d : AddCon M} : (âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) â†” c = d
(F : Type u) (K A : Type v) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [Module K A] [Module F A] [isScalarTower F K A] : Module.rank F K * Module.rank K A = Module.rank F A
{M : Type u_1} [CommMonoid M] (f s : â„• â†’ M) (h0 : s 0 = 1) (h : âˆ€ (n : â„•), s (n + 1) = s n * f n) (n : â„•) : (Finset.range n).prod (Î» (k : â„•), f k) = s n
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [DecidableEq Î±] (H : FreeGroup.mk Lâ‚ = FreeGroup.mk Lâ‚‚) : FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚
{Î± : Type u} [pseudoEmetricSpace Î±] {p : Î± â†’ Prop} (x y : Subtype_ p) : HasEdist.edist x y = HasEdist.edist â†‘x â†‘y
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] {a b : Î±} (hab : a â‰  b) : Closure (Set.Ioc a b) = Set.Icc a b
{n : â„•} {p : Fin n â†’ Prop} [DecidablePred p] : fin.find p = Option.none â†” âˆ€ (i : Fin n), Â¬p i
{A : Type u_2} {K : Type u_3} [CommRing A] [Field K] [is_IsDomain A] [IsDedekindDomain A] [Algebra A K] [IsFractionRing A K] {J : Ideal A} (hJ : J â‰  âŠ¤) {Î¹ : Type u_1} (s : Finset Î¹) (f : Î¹ â†’ K) {j : Î¹} (hjs : j âˆˆ s) (hjf : f j â‰  0) : âˆƒ (a : K), (âˆ€ (i : Î¹), i âˆˆ s â†’ IsLocalization.IsInteger A (a * f i)) âˆ§ âˆƒ (i : Î¹) (H : i âˆˆ s), a * f i âˆ‰ â†‘J
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.MulPosMono Î±] (ha : 1 â‰¤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x : V} (hx : x â‰  0) : o.oangle x (-x) = â†‘Real.pi
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [normedSpace ð•œ E'] {n : WithTop â„•} {f : E â†’ E'} {x : E} : ContDiffAt ð•œ n f x â†’ ContMdiffAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') n f x
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [divisionRing K] (TerminatedAt_n : g.terminated_at n) : g.squash_gcf n = g
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (i : Î¹) : Finset.centroid k {i} p = p i
{Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [CommMonoid M] [orderedCommMonoid N] (f : M â†’ N) (h_One : f 1 = 1) (h_Mul : âˆ€ (x y : M), f (x * y) â‰¤ f x * f y) (s : Finset Î¹) (g : Î¹ â†’ M) : f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] {F : Type w} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace ð•œ] {f : E â†’â‚—[ð•œ] F} (hF : f.ker = âŠ¥) [FiniteDimensional ð•œ E] : ClosedEmbedding â‡‘f
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [succOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Monotone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ioc (f n) (f (Order.succ n)))
{n : â„•} (p i : Fin n) : p.pred_above (â‡‘((â‡‘fin.cast_Succ p).succ_above) i) = i
{F : Type u_8} {G : Type u_1} {H : Type u_2} [AddGroup G] [AddZeroClass H] [addMonoidHomClass F G H] (f : F) : Function.Injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 0 â†” a = 0
{Î± : Type u_1} {c : Set (Set Î±)} (H : âˆ€ (a : Î±), âˆƒ! (b : Set Î±) (H : b âˆˆ c), a âˆˆ b) {y : Î±} : {x : Î± | (setoid.mk_Classes c H).rel x y} âˆˆ c
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topologicalSpace B] [topologicalSpace F] (Z : TopologicalFiberBundleCore Î¹ B F) (i j : Î¹) : (Z.local_triv_as_LocalEquiv i).symm.trans (Z.local_triv_as_LocalEquiv j) â‰ˆ (Z.triv_change i j).to_LocalEquiv
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hD : DiffContOnCl â„‚ f {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : Filter.IsBoundedUnder LE.le Filter.atTop (Î» (x : â„), âˆ¥f â†‘xâˆ¥)) (him : âˆ€ (x : â„), âˆ¥f (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz : 0 â‰¤ z.re) : âˆ¥f zâˆ¥ â‰¤ C
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] [StrictConvexSpace â„ E] {x y : E} {a b r : â„} (hx : âˆ¥xâˆ¥ â‰¤ r) (hy : âˆ¥yâˆ¥ â‰¤ r) (hne : x â‰  y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : âˆ¥a â€¢ x + b â€¢ yâˆ¥ < r
{M : Type u_1} [Monoid M] {x y : M} : y âˆˆ Submonoid.closure {x} â†” âˆƒ (n : â„•), x ^ n = y
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} : 0 â‰¤ Metric.diam s
{G : Type u_1} [AddGroup G] [topologicalSpace G] [TopologicalAddGroup G] {H : AddSubgroup G} (h_1_Int : 0 âˆˆ Interior â†‘H) : is_IsOpen â†‘H
{Î± : Type u_1} [Bornology Î±] {s : Set Î±} : Bornology.IsBounded s â†’ BoundedSpace â†¥s
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {p : P} {ps : Set P} (h : p âˆˆ affineSpan k ps) : affineSpan k (HasInsert.insert p ps) = affineSpan k ps
{R : Type u} [CommGroup R] [starSemigroup R] (x y : R) : HasStar.star (x / y) = HasStar.star x / HasStar.star y
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] [NoZeroSmulDivisors R M] {v : M} (hv : v â‰  0) {r : R} (hr : r â‰  0) : SameRay R (r â€¢ v) v â†” 0 < r
{R : Type u_1} {M : Type u_3} [monoidWithZero R] [hasZero M] [mulActionWithZero R M] [sM : Subsingleton M] : IsSmulRegular M 0
{F : Type} [CommSemiring F] {q : â„•} {f g : Polynomial F} (hF : Polynomial.IsSeparableContraction q f g) : âˆƒ (m : â„•), g.nat_degree * q ^ m = f.nat_degree
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {X : C} (S : CategoryTheory.Sieve X) : Jâ‚.is_IsClosed S â†” Jâ‚.close S = S
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : CategoryTheory.Exact f g â†” CategoryTheory.Limits.imageSubobject f = CategoryTheory.Limits.kernelSubobject g
{Î¹ : Type u_2} {R : Type u_3} [DecidableEq Î¹] [AddMonoid Î¹] [CommSemiring R] : DirectSum.IsInternal (AddMonoidAlgebra.grade R)
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (H : AddSubgroup G) {f : G â†’+ N} (hF : Function.bijective â‡‘f) : AddSubgroup.map f H.normalizer = (AddSubgroup.map f H).normalizer
{Î± : Type u_2} [DecidableEq Î±] [hasAdd Î±] {u : Finset Î±} {s t : Set Î±} : â†‘u âŠ† s + t â†’ (âˆƒ (s' t' : Finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' + t')
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {X Y : C} (f : X âŸ¶ Y) (Z : C) (l : CategoryTheory.Limits.IsColimit (Category_theory.limits.cokernel_cofork.of_Ï€ 0 _)) : CategoryTheory.Epi f
{B : Type u_2} {F : Type u_3} [topologicalSpace B] [topologicalSpace F] : IsTrivialTopologicalFiberBundle F Prod.snd
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {a : Î±} {s : Set Î±} (f : Î± â†’ M) (h : a âˆ‰ s) (hs : s.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ HasInsert.insert a s), f i)) = f a + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
(R : Type u) [Semiring R] [Nontrivial R] (p : â„•) [hp : Char_p R p] [hq : ExpChar R 1] : p = 0
{R : Type u_1} [normedRing R] [CompleteSpace R] (x : RË£) : (Î» (t : R), Ring.inverse (â†‘x + t) - â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥
{M : Type u_1} [Monoid M] {x : M} : 1 âˆˆ Powers x
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [AddCommMonoid Î±] {g : Î³ â†’ Î²} (hg : Function.Injective g) {f : Î² â†’ Î±} (hF : âˆ€ (x : Î²), x âˆ‰ Set.Range g â†’ f x = 0) : Filter.map (Î» (s : Finset Î³), s.sum (Î» (i : Î³), f (g i))) Filter.atTop = Filter.map (Î» (s : Finset Î²), s.sum (Î» (i : Î²), f i)) Filter.atTop
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : HasDist.dist p3 p1 = HasDist.dist p3 p2) : EuclideanGeometry.angle p3 (midpoint â„ p1 p2) p1 = Real.pi / 2
{R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} [linearOrderedField R] [AddCommGroup E] [Module R E] {s : Set E} {t : Finset Î¹} {w : Î¹ â†’ R} {z : Î¹ â†’ E} (hs : Convex R s) : (âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) â†’ 0 < t.sum (Î» (i : Î¹), w i) â†’ (âˆ€ (i : Î¹), i âˆˆ t â†’ z i âˆˆ s) â†’ t.center_mass w z âˆˆ s
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), AddCommMonoid (Mâ‚' i)] [Î  (i : Î¹), Module R (Mâ‚' i)] (f : Î  (i : Î¹), Mâ‚ i â†’â‚—[R] Mâ‚' i) (hF : âˆ€ (i : Î¹), Function.Surjective â‡‘(f i)) : Function.Injective (Î» (g : MultilinearMap R Mâ‚' Mâ‚‚), g.comp_Linear_Map f)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] : âŠ¥.direction = âŠ¥
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x y : E} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ ^ 2
(Î± : Type u) [pseudoEmetricSpace Î±] [SigmaCompactSpace Î±] : TopologicalSpace.SecondCountableTopology Î±
{ð•‚ : Type u_1} [is_R_or_C ð•‚] {x : ð•‚} : HasDerivAt (Exp ð•‚) (Exp ð•‚ x) x
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (ha : ContinuousAt f a) : HasDerivAt (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) a
(R : Type u) (L : Type v) (M : Type w) [CommRing R] [LieRing L] [lieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [lieModule R L M] {N : LieSubmodule R L M} (hâ‚ : N â‰¤ LieModule.maxTrivSubmodule R L M) (hâ‚‚ : LieModule.IsNilpotent R L (M â§¸ N)) : LieModule.IsNilpotent R L M
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) (Î¸ : Real.Angle) : x = â‡‘(hb.rotation Î¸) x â†” Î¸ = 0
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [AddCommMonoid Î±] [topologicalSpace Î±] [HasContinuousAdd Î±] [RegularSpace Î±] {f : Î² Ã— Î³ â†’ Î±} {g : Î² â†’ Î±} {a : Î±} (ha : HasSum f a) (hF : âˆ€ (b : Î²), HasSum (Î» (c : Î³), f (b, c)) (g b)) : HasSum g a
{Î± : Type u} [Preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a â‰¤ b â†’ a â‰¤ c
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.preadditiveCoyoneda â‹™ (CategoryTheory.whiskeringRight C AddCommGroup (Type v)).obj (CategoryTheory.forget AddCommGroup) = CategoryTheory.coyoneda
{Î± : Type u_1} (f : Poly Î±) : IsPoly â‡‘f
{Î± : Type u} {Î² : Î± â†’ Type u} {Îº : Cardinal} (hÎº : Cardinal.sum (Î» (a : Î±), Îº ^ Cardinal.mk (Î² a)) â‰¤ Îº) : Cardinal.mk (W_type Î²) â‰¤ Îº
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasInitial C] : CategoryTheory.Limits.HasZeroObject C
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {f g : E â†’ F} (hF : ContDiff ð•œ n f) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Î» (x : E), f x + g x)
(p : â„•) [hp : Fact (Nat.Prime p)] (a : Zmod p) (hap : a â‰  0) : Multiset.map (Î» (x : â„•), (a * â†‘x).val_min_abs.nat_Abs) (Finset.ico 1 (p / 2).succ).val = Multiset.map (Î» (a : â„•), a) (Finset.ico 1 (p / 2).succ).val
{Î± : Type u_1} [topologicalSpace Î±] {ð•œ : Type u_5} [topologicalSpace ð•œ] [Field ð•œ] [TopologicalRing ð•œ] {s : Subalgebra ð•œ C(Î±, ð•œ)} (h : s.separates_points) : â†‘s.separates_points_strongly
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (N : Submonoid S) (T : Type u_4) [CommRing T] [Algebra R T] [Algebra S T] [isScalarTower R S T] [IsLocalization M S] [IsLocalization N T] (H : âˆ€ (x : S), IsUnit x â†’ x âˆˆ N) : IsLocalization (Submonoid.comap (algebraMap R S).to_MonoidHom N) T
{Ï„ : Type u_1} {Î± : Type u_2} [CanonicallyOrderedAddMonoid Ï„] {Ï• : Ï„ â†’ Î± â†’ Î±} {s : Set Î±} : IsFwInvariant Ï• s â†” IsInvariant Ï• s
{Î± : Type u} [pseudoEmetricSpace Î±] {s : Set Î±} : Emetric.hausdorffEdist s s = 0
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [FiniteDimensional ð•œ E] [FiniteDimensional ð•œ F] (A : E â†’â‚—[ð•œ] F) (B : F â†’â‚—[ð•œ] E) : A = â‡‘LinearMap.adjoint B â†” âˆ€ (x : E) (y : F), HasInner.inner (â‡‘A x) y = HasInner.inner x (â‡‘B y)
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] (hb : finset.univ.sum (Î» (x : Î±), w x) < Fintype.card Î² â€¢ b) : âˆƒ (y : Î²), (Finset.filter (Î» (x : Î±), f x = y) Finset.univ).sum (Î» (x : Î±), w x) < b
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = â†‘Real.pi
{R : Type u_4} {S : Type u_5} [hasMul R] [hasAdd R] [hasMul S] [hasAdd S] (e : R â‰ƒ+* S) (x y : R) : â‡‘e (x + y) = â‡‘e x + â‡‘e y
{M : Type u_3} {F : Type u_8} {G : Type u_1} [AddGroup G] [AddMonoid M] [addMonoidHomClass F G M] {f g : F} {x : G} (h : â‡‘f x = â‡‘g x) : â‡‘f (-x) = â‡‘g (-x)
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] {l : Filter Î²} {fâ‚ fâ‚‚ fâ‚ƒ : Î² â†’ Î±} (hâ‚â‚‚ : Filter.Tendsto (Î» (x : Î²), (fâ‚ x, fâ‚‚ x)) l (Uniformity Î±)) (hâ‚‚â‚ƒ : Filter.Tendsto (Î» (x : Î²), (fâ‚‚ x, fâ‚ƒ x)) l (Uniformity Î±)) : Filter.Tendsto (Î» (x : Î²), (fâ‚ x, fâ‚ƒ x)) l (Uniformity Î±)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} [CategoryTheory.Limits.HasBinaryBiproduct X Y] : CategoryTheory.Limits.biprod.fst â‰« CategoryTheory.Limits.biprod.inl + CategoryTheory.Limits.biprod.snd â‰« CategoryTheory.Limits.biprod.inr = ðŸ™ (X âŠž Y)
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] [FiniteDimensional F E] (h : âˆ€ (x : E), FiniteDimensional.finrank F â†¥FâŸ®xâŸ¯ â‰¤ 1) : âŠ¥ = âŠ¤
(n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ Nat.Prime p
{Î± : Type u} [MulZeroClass Î±] [HasDistribNeg Î±] : -0 = 0
{R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (r : R) (x : A) : â‡‘(algebraMap R A) r * x = x * â‡‘(algebraMap R A) r
{Î± : Type u_1} {c : Set (Set Î±)} (hc : setoid.is_Partition c) {s : Set Î±} (h : s âˆˆ c) : s.nonempty
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] {F : Type w} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace ð•œ] {Î¹ : Type u_1} [Fintype Î¹] (v : Basis Î¹ ð•œ E) : âˆƒ (C : â„) (H : C > 0), âˆ€ {u : E â†’L[ð•œ] F} {M : â„}, 0 â‰¤ M â†’ (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥ â‰¤ M) â†’ âˆ¥uâˆ¥ â‰¤ C * M
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] [Nonempty V] : G.max_degree < Fintype.card V
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {X : C} (h : Category_theory.yoneda.obj X â‹™ CategoryTheory.uliftFunctor â‰… F.cones) {Y : C} (f : Y âŸ¶ X) : CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom h f = (CategoryTheory.Limits.IsLimit.OfNatIso.limitCone h).extend f
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] [uniformSpace Î²] [SeparatedSpace Î±] {s : Set Î±} {f : Î± â†’ Î²} (hs : is_IsCompact s) (hF : ContinuousOn f s) : UniformContinuousOn f s
{a b c : â„¤} (h : fermat_42 a b c) : âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} {T : addSubmonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [AddCommMonoid Q] {k : T.localization_Map Q} (z : N) : â‡‘(k.to_Map) (â‡‘g â†‘((f.sec z).snd)) + â‡‘(f.map hy k) z = â‡‘(k.to_Map) (â‡‘g (f.sec z).fst)
{Î² : Type u_2} [CommMonoid Î²] {n : â„•} (f : Fin (n + 1) â†’ Î²) (x : Fin (n + 1)) : finset.univ.prod (Î» (i : Fin (n + 1)), f i) = f x * finset.univ.prod (Î» (i : Fin n), f (â‡‘(x.succ_above) i))
{n : â„•} {a : Cardinal} : n â€¢ a < Cardinal.aleph_0 â†” n = 0 âˆ¨ a < Cardinal.aleph_0
{Î± : Type u} {Î¹ : sort x} {f : Î¹ â†’ Filter Î±} [hn : Nonempty Î±] (hD : Directed GE f) (hb : âˆ€ (i : Î¹), (f i).ne_IsBot) : (infi f).ne_IsBot
{Î± : Type u_3} {Î² : Type u_4} [linearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto f l Filter.atBot) : Filter.Tendsto (Î» (x : Î²), r * f x) l Filter.atBot
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (v : M) {r : R} (h : 0 < r) : SameRay R v (r â€¢ v)
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {a : Filter Î±} {bâ‚ bâ‚‚ : Filter Î²} (hF : Filter.Tendsto f a bâ‚) [a.ne_IsBot] (hb : Disjoint bâ‚ bâ‚‚) : Â¬Filter.Tendsto f a bâ‚‚
{S : Type u_1} [hasAdd S] (a : S) : AddCommute a a
{A : Type u_2} [CommRing A] [is_IsDomain A] [IsDedekindDomain A] {P : Ideal A} (hP : P â‰  âŠ¥) : Prime P â†” P.is_Prime
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {b : M} [linearOrderedCommRing M] (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (ht : t.card â€¢ b < â†‘(s.card)) : âˆƒ (y : Î²) (H : y âˆˆ t), b < â†‘((Finset.filter (Î» (x : Î±), f x = y) s).card)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (Î¸ : Real.Angle) : â‡‘LinearMap.det â†‘((hb.rotation Î¸).to_linearEquiv) = 1
(p : â„•) [Fact (Nat.Prime p)] (a : (Zmod p)Ë£) : a ^ (p - 1) = 1
{Î± : Type u} {l : List Î±} : l.nodup â†’ l.sublists.nodup
(R : CommRing) (M : Submonoid â†¥R) (x : PrimeSpectrum (Localization M)) : CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.stalkMap (algebraic_geometry.Spec.to_PresheafedSpace.map (CommRing.of_hom (algebraMap â†¥R (Localization M))).op) x)
 : Filter.Tendsto Real.exp (nhds 0) (nhds 1)
{M : Type u_1} [Monoid M] {Î³ : Type u_2} [Monoid Î³] {f : M â†’ Î³} (hF : IsMonoidHom f) : IsSubmonoid (Set.Range f)
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] {a b c : Î±} : b â‰¤ -a + c â†’ a + b â‰¤ c
{f : Nat.Partrec.Code â†’ Nat.Partrec.Code} (hF : Computable f) : âˆƒ (c : Nat.Partrec.Code), (f c).eval = c.eval
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {f : E â†’ ð•œ} {g : E â†’ F} (hF : ContDiff ð•œ n f) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Î» (x : E), f x â€¢ g x)
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s t : Set Î±} (sne : s.nonempty) (tne : t.nonempty) (hst : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ t â†’ x â‰¤ y) : (UpperBounds s âˆ© LowerBounds t).nonempty
{r : Nnreal} : âŠ¤ - â†‘r = âŠ¤
{R : Type u_1} {M : Type u_3} [monoidWithZero R] [hasZero M] [mulActionWithZero R M] [nM : Nontrivial M] : Â¬IsSmulRegular M 0
{Î± : Type u_1} [GeneralizedBooleanAlgebra Î±] [DecidableRel Disjoint] [DecidableRel LE.le] {s : Finset Î±} {u v a : Î±} (ha : a âˆˆ Uv.compression u v s) (hva : v â‰¤ a) (hua : Disjoint u a) : (a âŠ” u)  v âˆˆ s
{Î± : Type u} [HasSubset Î±] {a b : Î±} [IsAntisymm Î± HasSubset.Subset] (h : a âŠ† b) (h' : b âŠ† a) : a = b
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 âˆˆ s) (hp2 : p2 âˆˆ s) : p1 -áµ¥ p2 âˆˆ s.direction
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : o.oangle y x = -o.oangle x y
{J : Type uâ‚} [CategoryTheory.Category J] [Nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), CategoryTheory.Zigzag jâ‚ jâ‚‚) : CategoryTheory.IsConnected J
{p : â„•} {G : Type u_1} [Group G] (hG : is_p_Group p G) [hp : Fact (Nat.Prime p)] (Î± : Type u_2) [mulAction G Î±] [Fintype Î±] [Fintype â†¥(MulAction.FixedPoints G Î±)] (hpÎ± : p âˆ£ Fintype.card Î±) {a : Î±} (ha : a âˆˆ MulAction.FixedPoints G Î±) : âˆƒ (b : Î±), b âˆˆ MulAction.FixedPoints G Î± âˆ§ a â‰  b
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) : o.oangle (-x) y = o.oangle x y + â†‘Real.pi
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {p : Î¹ â†’ P} (ha : AffineIndependent k (Î» (x : â†¥(Set.Range p)), â†‘x)) (hi : Function.Injective p) : AffineIndependent k p
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {X Y Z X' Y' Z' : C} (f : X âŸ¶ Y) [CategoryTheory.Limits.HasCokernel f] (g : Y âŸ¶ Z) (w : f â‰« g = 0) (f' : X' âŸ¶ Y') [CategoryTheory.Limits.HasCokernel f'] (g' : Y' âŸ¶ Z') (w' : f' â‰« g' = 0) (p : X âŸ¶ X') (q : Y âŸ¶ Y') (r : Z âŸ¶ Z') (hâ‚ : f â‰« q = p â‰« f') (hâ‚‚ : g â‰« r = q â‰« g') : CategoryTheory.Limits.cokernel.map f f' p q hâ‚ â‰« CategoryTheory.Limits.cokernel.desc f' g' w' = CategoryTheory.Limits.cokernel.desc f g w â‰« r
{Î± : Type u_2} [AddMonoid Î±] (m : Î±) : Even m â†’ (âˆƒ (c : Î±), m = 2 â€¢ c)
(R : Type u) [nonAssocRing R] (p : â„•) [hc : Char_p R p] [Fintype R] : p â‰  0
(R : Type u) [Ring R] [StrongRankCondition R] {Î¹ : Type v} (M : Î¹ â†’ Type w) [Î  (i : Î¹), AddCommGroup (M i)] [Î  (i : Î¹), Module R (M i)] [âˆ€ (i : Î¹), Module.Free R (M i)] : Module.rank R (DirectSum Î¹ (Î» (i : Î¹), M i)) = Cardinal.sum (Î» (i : Î¹), Module.rank R (M i))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : Finset P} {p : P} (hp : p âˆˆ s) : vectorSpan k â†‘s = Submodule.span k â†‘(Finset.image (Î» (_x : P), _x -áµ¥ p) (s.erase p))
(R : Type u) (M : Type v) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] (N : Type v) [AddCommGroup N] [Module R N] [Module.Free R N] : Module.rank R (M Ã— N) = Module.rank R M + Module.rank R N
{R : Type u_1} [monoidWithZero R] {f : Nat.ArithmeticFunction R} : f.is_Multiplicative â†” â‡‘f 1 = 1 âˆ§ âˆ€ {m n : â„•}, m â‰  0 â†’ n â‰  0 â†’ m.coprime n â†’ â‡‘f (m * n) = â‡‘f m * â‡‘f n
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] (c : Con M) (f : M â†’* P) (H : c â‰¤ Con.ker f) (h : Function.Injective â‡‘(c.lift f H)) : Con.ker f = c
{n : â„•} {E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : (Fin (n + 1) â†’ â„‚) â†’ E} {c : Fin (n + 1) â†’ â„‚} {R : Fin (n + 1) â†’ â„} (hF : TorusIntegrable f c R) (i : Fin (n + 1)) : âˆ¯ (x : Fin (n + 1) â†’ â„‚) in T(c, R), f x = âˆ® (x : â„‚) in C(c i, R i), âˆ¯ (y : Fin n â†’ â„‚) in T(c âˆ˜ â‡‘(i.succ_above), R âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth x y)
{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), n â‰¤ m â†’ P n â†’ P (n - 1)) (n : â„¤) : n â‰¤ m â†’ P n
{Î± : Type u} [HasSubset Î±] [hasSsubset Î±] [isNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {a b : Î±} (h : a âŠ‚ b) : Â¬b âŠ† a
(s : â„) : (Î» (x : â„), x ^ s) =o[Filter.atTop] Real.exp
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹} {s : Set Î±} : TendstoUniformlyOn F f p s â†” Filter.Tendsto (Î» (q : Î¹ Ã— Î±), (f q.snd, F q.fst q.snd)) (p.prod (Filter.principal s)) (Uniformity Î²)
{R : Type u_1} [CommSemiring R] (M : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] [IsLocalization M S] (z : S) : z * â‡‘(algebraMap R S) â†‘((IsLocalization.sec M z).snd) = â‡‘(algebraMap R S) (IsLocalization.sec M z).fst
{X : Type u_2} [emetricSpace X] [TopologicalSpace.SecondCountableTopology X] (s : Set X) : (â¨† (x : X) (H : x âˆˆ s), (nhdsWithin x s).small_sets.limsup dimH) = dimH s
{R : Type u} {a : R} [Semiring R] {p : Polynomial R} (h : a * p.leading_Coeff â‰  0) : (â‡‘Polynomial.c a * p).nat_degree = p.nat_degree
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] (f : Equiv.perm Î±) {x : Î±} : (f.cycle_of x).is_Cycle â†” â‡‘f x â‰  x
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [linearOrderedAddCommGroup Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hF : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), f x + g x) l Filter.atBot
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : ConcaveOn ð•œ s f) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) {a b : ð•œ} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) : Linear_order.min (f x) (f y) â‰¤ f (a â€¢ x + b â€¢ y)
(R : Type u_1) [Rack R] (G : Type u_2) [Group G] (f : ShelfHom R (Quandle.Conj G)) (g : Rack.EnvelGroup R â†’* G) (h : f = (Quandle.Conj.map g).comp (Rack.toEnvelGroup R)) : g = â‡‘Rack.toEnvelGroup.map f
{K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero 2] {k : â„•} (hk : 2 â‰¤ k) [IsCyclotomicExtension {2 ^ k} K L] (hirr : Irreducible (Polynomial.cyclotomic (2 ^ k) K)) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {f : Î± â†’ Î²} (hF : âˆ€ (x y : Î±), f (x + y) = f x + f y) : IsAddGroupHom f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {g : F â†’ G} {f : E â†’ F} (hg : ContDiff ð•œ n g) (hF : ContDiff ð•œ n f) : ContDiff ð•œ n (g âˆ˜ f)
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (hab : a < b) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : â‡‘(AffineMap.lineMap (f a) (f b)) r â‰¤ f (â‡‘(AffineMap.lineMap a b) r) â†” slope f (â‡‘(AffineMap.lineMap a b) r) b â‰¤ slope f a (â‡‘(AffineMap.lineMap a b) r)
{X : Top} (F : Top.Presheaf (Type v) X) (Fsh : F.is_sheaf_Unique_gluing) : F.is_sheaf
{ð•œ : Type u_3} [is_R_or_C ð•œ] {n m : â„•} (A B : Matrix (Fin n) (Fin m) ð•œ) (i j : Fin n) : HasInner.inner (A i) (B j) = B.mul A.conj_transpose j i
{M : Type u_1} [AddZeroClass M] {s : Set M} {p : M â†’ M â†’ Prop} {x y : M} (hx : x âˆˆ AddSubmonoid.closure s) (hy : y âˆˆ AddSubmonoid.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ p x y) (H1_Left : âˆ€ (x : M), p 0 x) (H1_Right : âˆ€ (x : M), p x 0) (HMul_Left : âˆ€ (x y z : M), p x z â†’ p y z â†’ p (x + y) z) (HMul_Right : âˆ€ (x y z : M), p z x â†’ p z y â†’ p z (x + y)) : p x y
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (hs : is_IsCompact s) (U : Î¹ â†’ Set Î±) (hUo : âˆ€ (i : Î¹), is_IsOpen (U i)) (hsU : s âŠ† â‹ƒ (i : Î¹), U i) (hdU : Directed HasSubset.Subset U) : âˆƒ (i : Î¹), s âŠ† U i
{Î± : Type u_1} [uniformSpace Î±] : (Uniformity Î±).has_Basis (Î» (s : Set (Î± Ã— Î±)), s âˆˆ Uniformity Î± âˆ§ SymmetricRel s) Id
{ð•œ : Type u_1} {E : Type u_3} [orderedSemiring ð•œ] [topologicalSpace E] [AddCommGroup E] [Module ð•œ E] [HasContinuousAdd E] {s : Set E} (hs : StrictConvex ð•œ s) (x : E) : StrictConvex ð•œ (x +áµ¥ s)
{V : Type u_1} [innerProductSpace â„ V] {P : Type u_2} [metricSpace P] [NormedAddTorsor V P] {a b c d p : P} (h : EuclideanGeometry.Cospherical {a, b, c, d}) (hapc : EuclideanGeometry.angle a p c = Real.pi) (hbpd : EuclideanGeometry.angle b p d = Real.pi) : HasDist.dist a b * HasDist.dist c d + HasDist.dist b c * HasDist.dist d a = HasDist.dist a c * HasDist.dist b d
{R : Type u_1} [linearOrderedField R] [floorRing R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : r < â†‘b ^ x â†” Int.log b r < x
{Î± : Type u_1} [topologicalSpace Î±] [PolishSpace Î±] [measurableSpace Î±] [BorelSpace Î±] {s : Set Î±} (hs : MeasurableSet s) : PolishSpace.IsClopenable s
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [Ring R] [AddCommGroup M] [Module R M] {hli : LinearIndependent R v} {hsp : Submodule.span R (Set.Range v) = âŠ¤} {i j : Î¹} : â‡‘((Basis.mk hli hsp).coord i) (v j) = Ite (j = i) 1 0
{p n : â„•} (h_Pos : 0 < â‡‘(n.central_binom.factorization) p) : p â‰¤ 2 * n
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {R : â„} {c w : â„‚} {f : â„‚ â†’ E} {s : Set â„‚} (hs : s.countable) (hw : w âˆˆ Metric.Ball c R) (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : âˆ€ (x : â„‚), x âˆˆ Metric.Ball c R  s â†’ DifferentiableAt â„‚ f x) : (2 * â†‘Real.pi * Complex.i)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = f w
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [LinearOrder Î²] [succOrder Î²] [IsSuccArchimedean Î²] {s : Î² â†’ Set Î±} {t : Set Î²} (hnt : t.nonempty) (ht : t.ord_connected) (H : âˆ€ (n : Î²), n âˆˆ t â†’ IsConnected (s n)) (K : âˆ€ (n : Î²), n âˆˆ t â†’ Order.succ n âˆˆ t â†’ (s n âˆ© s (Order.succ n)).nonempty) : IsConnected (â‹ƒ (n : Î²) (H : n âˆˆ t), s n)
{R : Type v} [CommRing R] (A : Matrix (Fin 2) (Fin 2) R) : A.det = A 0 0 * A 1 1 - A 0 1 * A 1 0
(R : Type u_3) (M : Type u_4) [AddCommMonoid M] [Semiring R] [Module R M] (tr : Add_monoid.is_torsion R) : Add_monoid.is_torsion M
{Î± : Type u} [topologicalSpace Î±] {p : Î± â†’ Prop} {a : Î±} (h : âˆ€á¶  (y : Î±) in nhds a, p y) : p a
{G : Type u_1} [Group G] (h : group.is_nilpotent (G â§¸ Subgroup.center G)) : group.is_nilpotent G
{G : Type u_1} [hG : Group G] [hF : Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (h : is_p_Group p G) : group.is_nilpotent G
{P : Type u_2} [metricSpace P] (p : P) : EuclideanGeometry.Cospherical {p}
{K : Type u_1} [linearOrderedField K] [floorRing K] (v : K) : (GeneralizedContinuedFraction.of v).terminates â†” âˆƒ (q : â„š), v = â†‘q
{E : Type u_1} {PE : Type u_2} [NormedGroup E] [normedSpace â„ E] [metricSpace PE] [NormedAddTorsor E PE] {x y : PE} (e : PE â‰ƒáµ¢ PE) : â‡‘e x = x â†’ â‡‘e y = y â†’ â‡‘e (midpoint â„ x y) = midpoint â„ x y
(S T : Set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension T A B] (hS : S âŠ† T) : IsCyclotomicExtension S A â†¥(Algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1})
{R : Type u_1} (M : Type u_3) {a : R} [Monoid R] [mulAction R M] (ua : IsUnit a) : IsSmulRegular M a
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {t : Affine.Triangle â„ P} (ho : t.orthocenter âˆ‰ Set.Range t.points) {p : Fin 3 â†’ P} (hps : Set.Range p âŠ† HasInsert.insert t.orthocenter (Set.Range t.points)) (hpi : Function.Injective p) : (âˆƒ (iâ‚ iâ‚‚ iâ‚ƒ jâ‚‚ jâ‚ƒ : Fin 3), iâ‚ â‰  iâ‚‚ âˆ§ iâ‚ â‰  iâ‚ƒ âˆ§ iâ‚‚ â‰  iâ‚ƒ âˆ§ (âˆ€ (i : Fin 3), i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ) âˆ§ p iâ‚ = t.orthocenter âˆ§ jâ‚‚ â‰  jâ‚ƒ âˆ§ t.points jâ‚‚ = p iâ‚‚ âˆ§ t.points jâ‚ƒ = p iâ‚ƒ) âˆ¨ Set.Range p = Set.Range t.points
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] (S : Set M) (h : S.finite) : CompleteLattice.IsCompactElement (Submodule.span R S)
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (H : WellFounded r) (s : Set Î±) : s.nonempty â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), âˆ€ (x : Î±), x âˆˆ s â†’ Â¬r x a)
{E : Type u_1} [innerProductSpace â„ E] {Î¹ : Type u_2} [Fintype Î¹] [DecidableEq Î¹] [Nonempty Î¹] {e : Basis Î¹ â„ E} (h : Orthonormal â„ â‡‘e) (x : Orientation â„ E Î¹) : Orthonormal â„ â‡‘(e.adjust_to_Orientation x)
{Î± : Type u_1} {E' : Type u_6} {E'' : Type u_9} [semiNormedGroup E'] [NormedGroup E''] {f' : Î± â†’ E'} {l : Filter Î±} {c : E''} (hc : c â‰  0) : (Î» (x : Î±), c) =O[l] f' â†” âˆƒ (b : â„), 0 < b âˆ§ âˆ€á¶  (x : Î±) in l, b â‰¤ âˆ¥f' xâˆ¥
{G : Type u} {n : â„•} [Fintype G] [addLeftCancelMonoid G] (x : G) : addOrderOf (n â€¢ x) = addOrderOf x / (addOrderOf x).gcd n
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] [CompleteSpace ð•œ] {f f' : ð•œ â†’ ð•œ} (hF : âˆ€ (x : ð•œ), HasStrictDerivAt f (f' x) x) (h0 : âˆ€ (x : ð•œ), f' x â‰  0) : is_is_IsOpenMap f
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] {p : Ideal R} {P : Ideal S} [Algebra R S] [Algebra (R â§¸ p) (S â§¸ P)] [isScalarTower R (R â§¸ p) (S â§¸ P)] (h : Function.Injective â‡‘(algebraMap (R â§¸ p) (S â§¸ P))) : Ideal.comap (algebraMap R S) P = p
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {k : S.localization_Map P} (z : N) : â‡‘(k.lift _) (â‡‘(f.lift _) z) = z
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {f : Î± â†’ Î²} {x : Î±} {r : â„} (hr : 0 < r) (K : â„) (h : âˆ€ (y : Î±), HasDist.dist y x < r â†’ HasDist.dist (f y) (f x) â‰¤ K * HasDist.dist y x) : ContinuousAt f x
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : Function.Injective (Quotient.lift f _)
{ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [NormedGroup G] [normedSpace ð•œ G] {f : ð•œ â†’ G} {s : Set ð•œ} {x y : ð•œ} {C : â„} (hF : âˆ€ (x : ð•œ), x âˆˆ s â†’ DifferentiableAt ð•œ f x) (bound : âˆ€ (x : ð•œ), x âˆˆ s â†’ âˆ¥deriv f xâˆ¥ â‰¤ C) (hs : Convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{M : Type u_2} [AddCommGroup M] {ð•œ : Type u_1} [Field ð•œ] [Module ð•œ M] {f : M â†’â‚—[ð•œ] M} (hF : â‡‘LinearMap.det f = 0) : f.range < âŠ¤
{Î± : Type u_1} {Î² : Type u_2} [pseudoEmetricSpace Î±] [Nonempty Î²] [SemilatticeSup Î²] {s : Î² â†’ Î±} : CauchySeq s â†” âˆƒ (b : Î² â†’ Ennreal), (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ HasEdist.edist (s n) (s m) â‰¤ b N) âˆ§ Filter.Tendsto b Filter.atTop (nhds 0)
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] (f : Î² â†’ Î±) (l : Filter Î²) : Filter.Tendsto (Î» (x : Î²), (f x, f x)) l (Uniformity Î±)
{Î´ : Type u_1} [Fintype Î´] {Îº : Î´ â†’ Type u_2} {t : Î  (d : Î´), Set (Îº d)} (ht : âˆ€ (d : Î´), (t d).finite) : (set.univ.pi t).finite
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] (f : M â†’* P) {x y : M} : â‡‘(Con.ker f) x y â†” â‡‘f x = â‡‘f y
{C : Type u} [CategoryTheory.Category C] {Jâ‚ Jâ‚‚ : CategoryTheory.GrothendieckTopology C} (h : CategoryTheory.Presieve.IsSheaf Jâ‚ (CategoryTheory.Functor.closedSieves Jâ‚‚)) : Jâ‚ â‰¤ Jâ‚‚
(E : Type u_1) [AddCommGroup E] : Subsingleton (Module â„š E)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) (Î¸ : Real.Angle) : x = â‡‘(hb.rotation Î¸) x â†” x = 0 âˆ¨ Î¸ = 0
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : IsConnected s â†” âˆ€ (U : Finset (Set Î±)), (âˆ€ (u v : Set Î±), u âˆˆ U â†’ v âˆˆ U â†’ (s âˆ© (u âˆ© v)).nonempty â†’ u = v) â†’ (âˆ€ (u : Set Î±), u âˆˆ U â†’ is_IsOpen u) â†’ s âŠ† â‹ƒâ‚€â†‘U â†’ (âˆƒ (u : Set Î±) (H : u âˆˆ U), s âŠ† u)
{G : Type u_1} [AddCommGroup G] (K : AddSubgroup G) {Î¹ : Type u_2} {t : Finset Î¹} {f : Î¹ â†’ G} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ K) : t.sum (Î» (c : Î¹), f c) âˆˆ K
(ð•œ : Type u_1) {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_3} [LinearOrder Î¹] [OrderBot Î¹] [locallyFiniteOrder Î¹] [IsWellOrder Î¹ LT.lt] (f : Î¹ â†’ E) (n : Î¹) : gramSchmidt ð•œ f n = f n - (Finset.iio n).sum (Î» (i : Î¹), â†‘(â‡‘(orthogonalProjection (Submodule.span ð•œ {gramSchmidt ð•œ f i})) (f n)))
(n : â„•) : (List.Nat.antidiagonal n).nodup
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {p : FormalMultilinearSeries ð•œ E F} [CompleteSpace F] : ContinuousOn p.sum (Emetric.Ball 0 p.radius)
{Î± J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.FinCategory J] [SemilatticeInf Î±] [OrderTop Î±] (F : J â¥¤ Î±) : CategoryTheory.Limits.limit F = finset.univ.inf F.obj
{Î± : Type u_1} [SemiNormedRing Î±] [NormOneClass Î±] (a : Î±) (n : â„•) : âˆ¥a ^ nâˆ¥â‚Š â‰¤ âˆ¥aâˆ¥â‚Š ^ n
{G : Type u_1} [CategoryTheory.Groupoid G] [IsFreeGroupoid G] {X : Type v} [Group X] (f g : G â¥¤ CategoryTheory.SingleObj X) (h : âˆ€ (a b : IsFreeGroupoid.Generators G) (e : a âŸ¶ b), f.map (IsFreeGroupoid.of e) = g.map (IsFreeGroupoid.of e)) : f = g
(n : â„•) {R : Type u_1} [linearOrderedCommRing R] {x : R} (hx : 1 â‰¤ x) : 0 â‰¤ Polynomial.eval x (Polynomial.cyclotomic n R)
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (l : List (Matrix n n Î±)) : (l.prod)â»Â¹ = (List.map Inv.inv l.reverse).prod
{R : Type u} [Semiring R] {P : Ideal R} (hmax : âˆ€ (m : Ideal R), P < m â†’ Â¬m.is_Maximal) (J : Ideal R) (hPJ : P < J) : J = âŠ¤
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (P : Cáµ’áµ– â¥¤ A) [CategoryTheory.Limits.HasPullbacks C] (K : CategoryTheory.Pretopology C) : CategoryTheory.Presheaf.IsSheaf (CategoryTheory.Pretopology.toGrothendieck C K) P â†” âˆ€ â¦ƒX : Câ¦„ (R : CategoryTheory.Presieve X), R âˆˆ â‡‘K X â†’ Nonempty (CategoryTheory.Limits.IsLimit (P.map_cone (CategoryTheory.Sieve.generate R).arrows.cocone.op))
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] {s : Finset Î±} {f : Î± â†’ Î²} {a : Î±} (hp : s.sum (Î» (x : Î±), f x) = 0) (h1 : âˆ€ (x : Î±), x âˆˆ s â†’ x â‰  a â†’ f x = 0) (x : Î±) (H : x âˆˆ s) : f x = 0
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [divisionRing R] [divisionRing S] [Module R E] [Module S E] (n : â„¤) (x : E) : (â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x
{E : Type u_3} {F : Type u_4} [semiNormedGroup E] [semiNormedGroup F] (f : E â†’+ F) (C : â„) (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : Continuous â‡‘f
{Î± : Type u} [pseudoEmetricSpace Î±] {Î´â‚ Î´â‚‚ : â„} (Î´â‚‚_Pos : 0 < Î´â‚‚) (hlt : Î´â‚ < Î´â‚‚) (E : Set Î±) : Metric.Cthickening Î´â‚ E âŠ† Metric.Thickening Î´â‚‚ E
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] (f : Î± â†’ C(Î², Î³)) (h : Continuous (Function.uncurry (Î» (x : Î±) (y : Î²), â‡‘(f x) y))) : Continuous f
{Î± : Type u} [topologicalSpace Î±] [LocallyCompactSpace Î±] [RegularSpace Î±] {K U : Set Î±} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K âŠ† U) : âˆƒ (K' : Set Î±), is_IsCompact K' âˆ§ K âŠ† Interior K' âˆ§ K' âŠ† U
(n : â„•+) (x : â„‚Ë£) : x âˆˆ rootsOfUnity n â„‚ â†” âˆƒ (i : â„•) (H : i < â†‘n), Complex.exp (2 * â†‘Real.pi * Complex.i * (â†‘i / â†‘n)) = â†‘x
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : Fin 3 â†’ P) : Collinear k (Set.Range p) â†” Â¬AffineIndependent k p
{Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : topologicalSpace Î±} {tâ‚ƒ : topologicalSpace Î²} (hâ‚ : tâ‚‚ â‰¤ tâ‚) {s : Set Î±} {f : Î± â†’ Î²} (hâ‚‚ : ContinuousOn f s) : ContinuousOn f s
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} (h_Mono : StrictMonoOn f s) (hs : s âˆˆ nhdsWithin a (Set.Ici a)) (hfs : âˆ€ (b : Î²), b > f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ Set.Ioc (f a) b)) : ContinuousWithinAt f (Set.Ici a) a
{C : Type u} [CategoryTheory.Category C] {X Y Z : AlgebraicGeometry.PresheafedSpace C} (Î± : X âŸ¶ Y) (Î² : Y âŸ¶ Z) (U : (TopologicalSpace.Opens â†¥(Z.carrier))áµ’áµ–) : (Î± â‰« Î²).c.app U = Î².c.app U â‰« Î±.c.app (Opposite.op ((TopologicalSpace.Opens.map Î².base).obj (Opposite.unop U)))
{n k : â„•} : k â‰¤ n â†’ (n - k).factorial * n.desc_factorial k = n.factorial
{a b : â„} (h : a < b) : Cardinal.mk â†¥(Set.Ioo a b) = Cardinal.continuum
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î± â†’ Î³} {x : Î±} {y : Î²} (hF : ContinuousAt f x) : ContinuousAt (Î» (x : Î± Ã— Î²), f x.fst) (x, y)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} {f : ð•œ â†’ F} {s : Set ð•œ} {x : ð•œ} (hxs : UniqueDiffWithinAt ð•œ s x) : iteratedDerivWithin (n + 1) f s x = derivWithin (iteratedDerivWithin n f s) s x
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [FiniteDimensional ð•œ E] {n : â„•} (hn : FiniteDimensional.finrank ð•œ E = n) {Î¹ : Type u_4} [Fintype Î¹] [DecidableEq Î¹] {V : Î¹ â†’ Submodule ð•œ E} (hV : DirectSum.IsInternal V) (hV' : OrthogonalFamily ð•œ (Î» (i : Î¹), (V i).subtypeâ‚—áµ¢)) : Orthonormal ð•œ â‡‘(DirectSum.IsInternal.subordinateOrthonormalBasis hn hV)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) : TendstoLocallyUniformlyOn (Î» (n : â„•) (y : E), p.partial_Sum n y) (Î» (y : E), f (x + y)) Filter.atTop (Emetric.Ball 0 r)
{Î± : Type u} [emetricSpace Î±] : Continuous (Î» (p : Î± Ã— TopologicalSpace.Closeds Î±), Emetric.infEdist p.fst â†‘(p.snd))
(R : Type u) [Semiring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), AddCommMonoid (M i)] [Î  (i : Î¹), Module R (M i)] (s : Finset Î¹) (c : R) (x : Î  (i : â†¥â†‘s), M i.val) : â‡‘(DirectSum.mk M s) (c â€¢ x) = c â€¢ â‡‘(DirectSum.mk M s) x
{Î± : Type u_1} [pseudoEmetricSpace Î±] (r C : Ennreal) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (f n) (f (n + 1)) â‰¤ C * r ^ n) {a : Î±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) (n : â„•) : HasEdist.edist (f n) a â‰¤ C * r ^ n / (1 - r)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] (pâ‚ pâ‚‚ : P) : Collinear k {pâ‚, pâ‚‚}
{Î± : Type u_1} [DecidableEq Î±] : âˆ….shadow = âˆ…
{R : Type u_1} {S : Type u_2} {M : Type u_3} {s : S} [HasScalar R M] [HasScalar R S] [HasScalar S M] [isScalarTower R S M] (a : R) (Ab : IsSmulRegular M (a â€¢ s)) : IsSmulRegular M s
{Î± : Type u_1} [semiNormedGroup Î±] {r C : â„} {f : â„• â†’ Î±} (hr : r < 1) (hF : âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ C * r ^ n) {a : Î±} (ha : HasSum f a) (n : â„•) : âˆ¥(Finset.range n).sum (Î» (x : â„•), f x) - aâˆ¥ â‰¤ C * r ^ n / (1 - r)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ AddMon) [CategoryTheory.IsFiltered J] {x x' y : Î£ (j : J), â†¥(F.obj j)} (hxx' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F â‹™ CategoryTheory.forget AddMon) x x') : AddMon.FilteredColimits.colimitAddAux F x y = AddMon.FilteredColimits.colimitAddAux F x' y
{M : Type u_3} [Monoid M] [Preorder M] (L : List M) (h : L.prod < 1) : 0 < L.length
{Î± : Type u_1} [topologicalSpace Î±] {s t : Set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t) : is_GÎ´ (s âˆª t)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) : o.oangle 0 x = 0
(n : â„•) : n.totient = n / n.factors.to_finset.prod (Î» (p : â„•), p) * n.factors.to_finset.prod (Î» (p : â„•), p - 1)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) {r : â„} (hr : 0 â‰¤ r) : o.oangle x (r â€¢ x) = 0
{C : Type u} [CategoryTheory.Category C] {A B : C} {f g : A âŸ¶ B} [CategoryTheory.IsCoreflexivePair f g] : CategoryTheory.IsCoreflexivePair g f
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (G : Set A) (hG : âˆ€ (x : A), x âˆˆ G â†’ IsIntegral R x) (x : A) (H : x âˆˆ Subring.closure G) : IsIntegral R x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.Limits.HasLimitsOfSize D] [CategoryTheory.CreatesLimitsOfSize F] : CategoryTheory.Limits.HasLimitsOfSize C
 : Â¬Summable (Î» (n : â„•), 1 / â†‘n)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] [CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y) (hF : âˆ€ (Z : C) (g : Y âŸ¶ Z), f â‰« g = 0 â†’ g = 0) : CategoryTheory.Epi f
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Mâ‚ : Type u_4} [topologicalSpace Mâ‚] [AddCommMonoid Mâ‚] {Mâ‚‚ : Type u_6} [topologicalSpace Mâ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚ Mâ‚] [Module Râ‚‚ Mâ‚‚] [RingHomSurjective Ïƒâ‚â‚‚] [topologicalSpace Râ‚] [topologicalSpace Râ‚‚] [HasContinuousSmul Râ‚ Mâ‚] [HasContinuousAdd Mâ‚] [HasContinuousSmul Râ‚‚ Mâ‚‚] [HasContinuousAdd Mâ‚‚] (f : Mâ‚ â†’sl[Ïƒâ‚â‚‚] Mâ‚‚) (s : Submodule Râ‚ Mâ‚) : Submodule.map â†‘f s.topological_Closure â‰¤ (Submodule.map â†‘f s).topological_Closure
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {s : Set E} : Convex ð•œ s â†” âˆ€ â¦ƒa b : ð•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ s + b â€¢ s âŠ† s
{M : Type u_1} [hasAdd M] {N : Type u_2} [hasAdd N] (f : AddHom M N) (hF : Function.Surjective â‡‘f) : f.srange = âŠ¤
{Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), metricSpace (E i)] (i : Î¹) : Isometry (Sigma.mk i)
(x : â„) : Real.cosh x = (Real.exp x + Real.exp (-x)) / 2
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} : a â‰¤ -b â†’ b â‰¤ -a
{Î± : Type u} [PartialOrder Î±] {a b : Î±} (h : a â‰¤ b) : b = a âˆ¨ a < b
(n : â„•) : â†‘(Nat.fib n) = (goldenRatio ^ n - goldenConj ^ n) / Real.sqrt 5
{S : Set â„•} (hb : 0 âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) (n : â„•) : n âˆˆ S
{E : Type u_1} [innerProductSpace â„ E] {c : E} (f : ContDiffBumpOfInner c) (x : E) : 0 â‰¤ â‡‘f x
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] {A : Set X} {f : X â†’ Y} {x : X} (h : âˆƒ (y : Y), Filter.Tendsto f (nhdsWithin x A) (nhds y)) : Filter.Tendsto f (nhdsWithin x A) (nhds (extendFrom A f x))
(R : Type u) (M : Type v) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] : FiniteDimensional.finrank R M = Fintype.card (Module.Free.ChooseBasisIndex R M)
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} : -a â‰¤ -b â†’ b â‰¤ a
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : Polynomial A} (pmonic : p.monic) (hp : â‡‘(Polynomial.aeval x) p = 0) (pmin : âˆ€ (q : Polynomial A), q.monic â†’ â‡‘(Polynomial.aeval x) q = 0 â†’ p.degree â‰¤ q.degree) : p = minpoly A x
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (i : Fin r âŠ• Unit) {k : â„•} (hk : k â‰¤ r) : (List.drop k (Matrix.Pivot.listTransvecCol M)).prod.mul M (Sum.inr ()) i = M (Sum.inr ()) i
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {fâ‚‚ : ð•œ â†’ F} {sâ‚‚ : Set ð•œ} (hs : is_IsOpen sâ‚‚) : ContDiffOn ð•œ âŠ¤ fâ‚‚ sâ‚‚ â†” DifferentiableOn ð•œ fâ‚‚ sâ‚‚ âˆ§ ContDiffOn ð•œ âŠ¤ (deriv fâ‚‚) sâ‚‚
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] [DecidableEq Î±] (s : Finset Î±) {f : Î± â†’ Î²} {a : Î±} (h : f a = 1) : (s.erase a).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
{G : Type u_1} [Group G] {s : Set G} {x c : G} : x âˆˆ group.conjugates_ofSet s â†’ c * x * câ»Â¹ âˆˆ group.conjugates_ofSet s
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b c : Î±} : a â‰¤ b * c â†’ bâ»Â¹ * a â‰¤ c
{R : Type u_1} [nonAssocRing R] [Nontrivial R] [NoZeroDivisors R] (hR : ringChar R â‰  2) {a : R} : -a = a â†” a = 0
{G : Type u_1} [AddGroup G] {Î¹ : sort u_2} (S : Î¹ â†’ AddSubgroup G) {C : G â†’ Prop} {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : G), x âˆˆ S i â†’ C x) (h1 : C 0) (HMul : âˆ€ (x y : G), C x â†’ C y â†’ C (x + y)) : C x
{n : Type u_1} {ð•œ : Type u_3} [Field ð•œ] [DecidableEq n] [Fintype n] (P : Matrix n n ð•œ â†’ Prop) (M : Matrix n n ð•œ) (hMdet : M.det â‰  0) (hdiag : âˆ€ (D : n â†’ ð•œ), (Matrix.diagonal D).det â‰  0 â†’ P (Matrix.diagonal D)) (htransvec : âˆ€ (t : Matrix.TransvectionStruct n ð•œ), P t.to_Matrix) (HMul : âˆ€ (A B : Matrix n n ð•œ), A.det â‰  0 â†’ B.det â‰  0 â†’ P A â†’ P B â†’ P (A.mul B)) : P M
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [isScalarTower R S A] {B : powerBasis S A} (hB : IsIntegral R B.gen) [is_IsDomain S] {x : A} (hx : âˆ€ (i : Fin B.dim), IsIntegral R (â‡‘(â‡‘(B.basis.repr) x) i)) (hmin : minpoly S B.gen = Polynomial.map (algebraMap R S) (minpoly R B.gen)) (n : â„•) (i : Fin B.dim) : IsIntegral R (â‡‘(â‡‘(B.basis.repr) (x ^ n)) i)
{R : Type u} {Î¹ : Type v} {Mâ‚ : Î¹ â†’ Type wâ‚} {Mâ‚‚ : Type wâ‚‚} [DecidableEq Î¹] [CommSemiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] [Î  (i : Î¹), topologicalSpace (Mâ‚ i)] [topologicalSpace Mâ‚‚] (f : ContinuousMultilinearMap R Mâ‚ Mâ‚‚) [Fintype Î¹] (c : Î¹ â†’ R) (m : Î  (i : Î¹), Mâ‚ i) : â‡‘f (Î» (i : Î¹), c i â€¢ m i) = finset.univ.prod (Î» (i : Î¹), c i) â€¢ â‡‘f m
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} (ha : a â‰  0) : char.quadratic_Char F (a ^ 2) = 1
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} [discreteTopology â†¥s] {x : Î±} (hx : x âˆˆ s) : nhdsWithin x s = Pure.pure x
{Î± : Type u_1} [canonicallyLinearOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b c : Î±} (ha : AddLeCancellable a) (hb : AddLeCancellable b) (h : b â‰¤ a) : a - b < a - c â†” c < b
{A : Type u_4} [CommRing A] [is_IsDomain A] {K : Type u_5} [Field K] {L : Type u_7} [Field L] [Algebra A K] [IsFractionRing A K] {g : A â†’+* L} (hg : Function.Injective â‡‘g) (x : A) : â‡‘(IsFractionRing.lift hg) (â‡‘(algebraMap A K) x) = â‡‘g x
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : o.oangle x y + o.oangle y x = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {sâ‚ sâ‚‚ : AffineSubspace k P} (hD : sâ‚.direction = sâ‚‚.direction) (hn : â†‘sâ‚.nonempty) (hle : sâ‚ â‰¤ sâ‚‚) : sâ‚ = sâ‚‚
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.forget C)] {X : Top} (F : Top.Sheaf C X) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥X) (V : TopologicalSpace.Opens â†¥X) (iUV : Î  (i : Î¹), U i âŸ¶ V) (hcover : V â‰¤ supr U) (s t : â†¥(F.val.obj (Opposite.op V))) (h : âˆ€ (i : Î¹), â‡‘(F.val.map (iUV i).op) s = â‡‘(F.val.map (iUV i).op) t) : s = t
{Î± : Type u_1} {o p : Part Î±} (H1 : o.dom â†” p.dom) (H2 : âˆ€ (hâ‚ : o.dom) (hâ‚‚ : p.dom), o.get hâ‚ = p.get hâ‚‚) : o = p
{Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) : Vector.scanl f b Vector.nil = b::áµ¥Vector.nil
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [LinearOrder Î²] {f : Î± â†’ Î²} (hâ‚ : StrictMono f) (A B : Finset Î±) : (Finset.image f A).to_colex â‰¤ (Finset.image f B).to_colex â†” A.to_colex â‰¤ B.to_colex
{Î± : Type u} [pseudoEmetricSpace Î±] {s : Set Î±} : Continuous (Î» (x : Î±), Emetric.infEdist x s)
{Î± : Type u_1} [linearOrderedField Î±] {a b c d : Î±} (hc : c â‰  0) (hD : d â‰  0) : (a * d - b * c) / (c * d) â‰¤ 0 â†’ a / c â‰¤ b / d
{Î± : Type u_1} [topologicalSpace Î±] {U : Set Î±} {hU : is_IsOpen U} : â†‘âŸ¨U, hUâŸ© = U
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î²] {f : Î± â†’ Î²} {x : Î±} [topologicalSpace Î±] (L : âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : Set Î±) (H : t âˆˆ nhds x) (F : Î± â†’ Î²), ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u)) : ContinuousAt f x
{X : Type u_1} [topologicalSpace X] [Infinite X] [discreteTopology X] : Â¬Continuous â‡‘(cofinite_topology.of.symm)
{ð•œ : Type u_3} [is_R_or_C ð•œ] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {f f' : ð•œ â†’ G} {x : ð•œ} (hder : âˆ€á¶  (y : ð•œ) in nhds x, HasDerivAt f (f' y) y) (hcont : ContinuousAt f' x) : HasStrictDerivAt f (f' x) x
{n : â„•} (a : Fin (n + 1)) : â†‘(a.val) = a
{g : Equiv.perm (Fin 5)} (ha : g âˆˆ alternatingGroup (Fin 5)) (h1 : g â‰  1) (h2 : âˆ€ (n : â„•), n âˆˆ g.cycle_type â†’ n = 2) : IsConj (equiv.swap 0 4 * equiv.swap 1 3) g
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topologicalSpace B] [topologicalSpace F] (Z : TopologicalFiberBundleCore Î¹ B F) : is_is_IsOpenMap Z.proj
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {K : Nnreal} {s : Set Î±} {f : Î± â†’ Î²} : LipschitzOnWith K f s â†’ âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ HasDist.dist (f x) (f y) â‰¤ â†‘K * HasDist.dist x y
{M : Type u_1} [hasMul M] {Î² : sort u_2} (c : Con M) (f : M â†’ Î²) (h : âˆ€ (a b : M), â‡‘c a b â†’ f a = f b) (x : M) : Con.liftOn â†‘x f h = f x
{R : Type u_1} [CommRing R] {câ‚ câ‚‚ : R} (q : QuaternionAlgebra R câ‚ câ‚‚) : â‡‘CliffordAlgebraQuaternion.ofQuaternion (â‡‘QuaternionAlgebra.conj q) = â‡‘CliffordAlgebra.involute (â‡‘CliffordAlgebra.reverse (â‡‘CliffordAlgebraQuaternion.ofQuaternion q))
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} (hs : Convex ð•œ s) (hF : âˆ€ {x y z : ð•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x)) : StrictConcaveOn ð•œ s f
{Î± : Type u_1} {Î¹ : sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {t : Set Î±} (hl : l.has_Basis p s) : t âˆˆ l â†” âˆƒ (i : Î¹) (hi : p i), s i âŠ† t
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} {Î³ : Type u_3} [Î  (a : Î±), AddCommMonoid (Î² a)] (s : Finset Î³) (g : Î³ â†’ Î  (a : Î±), Î² a) : s.sum (Î» (c : Î³), g c) = Î» (a : Î±), s.sum (Î» (c : Î³), g c a)
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (x : Î± (fin.last n)) (p : Î  (i : Fin n), Î± (â‡‘fin.cast_Succ i)) (i : Fin n) (y : Î± (â‡‘fin.cast_Succ i)) : fin.snoc (Function.update p i y) x = Function.update (fin.snoc p x) (â‡‘fin.cast_Succ i) y
{X : Type u} [metricSpace X] [CompactSpace X] [Nonempty X] {Y : Type v} [metricSpace Y] [CompactSpace Y] [Nonempty Y] : Metric.hausdorffDist (Set.Range (Gromov_Hausdorff.optimal_GH_injl X Y)) (Set.Range (Gromov_Hausdorff.optimal_GH_injr X Y)) = Gromov_Hausdorff.GH_dist X Y
{Î± : Type u} [orderedSemiring Î±] {a b c d : Î±} [HasExistsAddOfLe Î±] (hba : b â‰¤ a) (hdc : d â‰¤ c) : a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) : o.oangle x 0 = 0
{Î± : Type u} [pseudoEmetricSpace Î±] (Î´ : â„) (E : Set Î±) : Metric.Thickening Î´ E = (Î» (x : Î±), Emetric.infEdist x E) â»Â¹' Set.Iio (Ennreal.ofReal Î´)
{M : Type u_3} {S : Type u_4} [DivInvMonoid M] [SetLike S M] [hSM : subgroupClass S M] {H : S} {x y : M} (hx : x âˆˆ H) (hy : y âˆˆ H) : x / y âˆˆ H
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} (hF : StrictConvexOn ð•œ s f) {x y z : ð•œ} (hx : x âˆˆ s) (hz : z âˆˆ s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) < (f z - f y) / (z - y)
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] [Nontrivial R] (x : R) : IsAlgebraic R (â‡‘(algebraMap R A) x)
{G : Type u} [Group G] {x : G} (hx : IsOfFinOrder x) : IsOfFinOrder xâ»Â¹
{Î± : Type u} [LinearOrder Î±] {x y : Î±} : x < y âˆ¨ y < x â†” x â‰  y
(n : â„•) : âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] : reflection K * reflection K = 1
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [Module.Finite K L] [IsAlgClosed E] (pB : powerBasis K L) (e : Fin pb.dim â‰ƒ (L â†’â‚[K] E)) [IsSeparable K L] : â‡‘(algebraMap K E) (Algebra.discr K â‡‘(pb.basis)) = finset.univ.prod (Î» (i : Fin pb.dim), (Finset.filter (Î» (j : Fin pb.dim), i < j) Finset.univ).prod (Î» (j : Fin pb.dim), (â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) ^ 2))
{a b : Cardinal} (ha : Cardinal.aleph_0 â‰¤ a) : a + b = Linear_order.max a b
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [isScalarTower R S A] {B : powerBasis S A} (hB : IsIntegral R B.gen) [is_IsDomain S] {x y : A} (hx : âˆ€ (i : Fin B.dim), IsIntegral R (â‡‘(â‡‘(B.basis.repr) x) i)) (hy : âˆ€ (i : Fin B.dim), IsIntegral R (â‡‘(â‡‘(B.basis.repr) y) i)) (hmin : minpoly S B.gen = Polynomial.map (algebraMap R S) (minpoly R B.gen)) (i : Fin B.dim) : IsIntegral R (â‡‘(â‡‘(B.basis.repr) (x * y)) i)
{R : Type u} {Î¹ : Type u'} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [AddCommMonoid Mâ‚‚] [Module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), AddCommMonoid (Mâ‚' i)] [Î  (i : Î¹), Module R (Mâ‚' i)] (g : MultilinearMap R Mâ‚' Mâ‚‚) : g.comp_Linear_Map (Î» (i : Î¹), LinearMap.id) = g
{a : Ennreal} (h : a â‰  âŠ¤) : AddLeCancellable a
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] [uniformSpace Î²] [CompactSpace Î±] [SeparatedSpace Î±] {f : Î± â†’ Î²} (h : Continuous f) : UniformContinuous f
(Î± : Type u_1) (Î² : Type u_2) [LinearOrder Î±] [LinearOrder Î²] [Encodable Î±] [denselyOrdered Î²] [Nontrivial Î²] : Nonempty (Î± â†ªo Î²)
{Î± : Type u} [nonUnitalRing Î±] {a b c : Î±} (h : a âˆ£ c) : a âˆ£ b + c â†” a âˆ£ b
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : CategoryTheory.Presieve X} {xâ‚ xâ‚‚ : CategoryTheory.Presieve.FamilyOfElements P â‡‘(CategoryTheory.Sieve.generate R)} (tâ‚ : xâ‚.compatible) (tâ‚‚ : xâ‚‚.compatible) : CategoryTheory.Presieve.FamilyOfElements.restrict _ xâ‚ = CategoryTheory.Presieve.FamilyOfElements.restrict _ xâ‚‚ â†’ xâ‚ = xâ‚‚
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {s : Set E} {f : E â†’ F} (hF : ContDiffOn ð•œ n f s) : ContDiffOn ð•œ n (Î» (x : E), -f x) s
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a b : Î±} (h : a < b) (s : Set Î±) : [s âˆˆ nhdsWithin b (Set.Iio b), s âˆˆ nhdsWithin b (Set.Ico a b), s âˆˆ nhdsWithin b (Set.Ioo a b), âˆƒ (l : Î±) (H : l âˆˆ Set.Ico a b), Set.Ioo l b âŠ† s, âˆƒ (l : Î±) (H : l âˆˆ Set.Iio b), Set.Ioo l b âŠ† s].tfae
{Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hF : Function.Injective f) : Filter.Tendsto f Filter.cofinite Filter.cofinite
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [pseudoMetricSpace Î²] {x : Î±} : Continuous (Î» (f : boundedContinuousFunction Î± Î²), â‡‘f x)
{Î³ : Type w} [metricSpace Î³] {x y : Î³} : HasNndist.nndist x y = 0 â†’ x = y
{R : Type u_1} {M : Type u_2} [AddCommMonoid M] [CommRing R] [Nontrivial R] [h : Algebra.FiniteType R (AddMonoidAlgebra R M)] : Add_monoid.fg M
{Î± : Type u} [topologicalSpace Î±] (x : Î±) [(nhdsWithin x {x}á¶œ).ne_IsBot] : Interior {x} = âˆ…
{m : Type u_1} {n : Type u_2} {R : Type u_3} {S : Type u_4} [CommSemiring R] [CommSemiring S] (f : R â†’+* S) (A : Matrix m n S) : (matrix.mv_Polynomial.x m n R).map (MvPolynomial.evalâ‚‚ f (Î» (p : m Ã— n), A p.fst p.snd)) = A
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) (x : M) (y : â†¥S) : â‡‘(f.lift hg) (f.mk' x y) = â‡‘g x * â†‘(â‡‘(IsUnit.liftRight (g.restrict S) hg) y)â»Â¹
{Î± : Type uu} [DecidableEq Î±] {lâ‚ lâ‚‚ : List Î±} (h : âˆ€ (x : Î±), x âˆˆ lâ‚ â†’ List.count x lâ‚ â‰¤ List.count x lâ‚‚) : lâ‚ ++ lâ‚‚.diff lâ‚ ~ lâ‚‚
{Î± : Type u} {f g : Î± â†’ Î±} (h : Function.Commute f g) : Set.InvOn f g (Function.FixedPoints (f âˆ˜ g)) (Function.FixedPoints (f âˆ˜ g))
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 p2 : P) : EuclideanGeometry.angle p1 p2 p2 = Real.pi / 2
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : 2 â€¢ hb.oangle x (-y) = 2 â€¢ hb.oangle x y
{Î± : Type u_1} {E : Type u_3} [semiNormedGroup E] {l : Filter Î±} {f : Î± â†’ E} (h : Filter.Tendsto (Î» (y : Î±), âˆ¥f yâˆ¥) l Filter.atTop) (x : E) : âˆ€á¶  (y : Î±) in l, f y â‰  x
{Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : a â‰¤ b) : Set.Iio a âŠ† Set.Iic b
{R : Type u_1} {a : R} [Monoid R] (n : â„•) (ra : IsRegular a) : IsRegular (a ^ n)
{Î± : Type u_2} {Î² : Type u_3} [Ring Î±] [is_IsDomain Î±] [Ring Î²] (f : Î² â†’+* Î±) (hF : Function.Injective â‡‘f) : is_IsDomain Î²
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [conditionallyCompleteLinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] [Nonempty Î³] {f : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : ContinuousAt f (â¨… (i : Î³), g i)) (Mf : Monotone f) (H : BddBelow (Set.Range g)) : f (â¨… (i : Î³), g i) = â¨… (i : Î³), f (g i)
{Î± : Type u_1} {Î² : Type u_2} [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) (h : Fintype.card Î² < Fintype.card Î±) : âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {n : â„•} (hn : FiniteDimensional.finrank K V = n.succ) : Nontrivial V
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : ContinuousAt f b) : deriv (Î» (u : â„), âˆ« (x : â„) in a..u, f x) b = f b
{R : Type u} [Semiring R] (p q : Polynomial R) (n : â„•) : (p * q).coeff n = (Finset.Nat.antidiagonal n).sum (Î» (x : â„• Ã— â„•), p.coeff x.fst * q.coeff x.snd)
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : Top} (f : X âŸ¶ Y) [CategoryTheory.Limits.HasProducts C] {F : Top.Presheaf C X} (h : F.is_sheaf) : (f _* F).is_sheaf
(n : â„•) : Filter.Tendsto (Î» (x : â„), x ^ n * Real.exp (-x)) Filter.atTop (nhds 0)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p : P) (h : s.sum (Î» (i : Î¹), w i) = 1) : â‡‘(s.affine_combination (Î» (_x : Î¹), p)) w = p
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderClosedTopology Î±] [Nonempty Î±] {s : Set Î±} (hs : is_IsCompact s) : BddBelow s
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topologicalSpace B] [topologicalSpace F] {Proj : Z â†’ B} [topologicalSpace Z] (h : IsTopologicalFiberBundle F Proj) : Continuous Proj
{Î± : Type u_1} [topologicalSpace Î±] [nonAssocRing Î±] [HasContinuousMul Î±] : HasContinuousNeg Î±
{Î± : Type u} [pseudoEmetricSpace Î±] {Î´ : â„} (E : Set Î±) : E âŠ† Metric.Cthickening Î´ E
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {p : P} {s : Set P} (hp : p âˆˆ s) : p âˆˆ affineSpan k s
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) : S.is_algebraic â†” Algebra.IsAlgebraic R â†¥S
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.HasPushouts C] : CategoryTheory.Limits.HasBinaryCoproducts C
{R : Type u_1} [CommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {C : TensorAlgebra R M â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(algebraMap R (TensorAlgebra R M)) r)) (h_grade1 : âˆ€ (x : M), C (â‡‘(TensorAlgebraÎ¹ R) x)) (h_Mul : âˆ€ (a b : TensorAlgebra R M), C a â†’ C b â†’ C (a * b)) (h_Add : âˆ€ (a b : TensorAlgebra R M), C a â†’ C b â†’ C (a + b)) (a : TensorAlgebra R M) : C a
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [Preorder Î±] [t : OrderClosedTopology Î±] {f g : Î² â†’ Î±} {b : Filter Î²} {aâ‚ aâ‚‚ : Î±} [b.ne_IsBot] (hF : Filter.Tendsto f b (nhds aâ‚)) (hg : Filter.Tendsto g b (nhds aâ‚‚)) (h : f â‰¤á¶ [b] g) : aâ‚ â‰¤ aâ‚‚
{Î± : Type u_1} [LinearOrder Î±] [DecidableEq Î±] {p : Finset Î± â†’ Prop} (s : Finset Î±) (h0 : p âˆ…) (step : âˆ€ (a : Î±) (s : Finset Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ x < a) â†’ p s â†’ p (HasInsert.insert a s)) : p s
{R : Type u_1} [CommRing R] (g : Matrix.SpecialLinearGroup (Fin 2) R) : IsCoprime (â†‘g 1 0) (â†‘g 1 1)
(Î± : Type u) [Preorder Î±] [Nonempty Î±] [NoMinOrder Î±] [NoMaxOrder Î±] : âˆƒ (f : â„¤ â†’ Î±), StrictAnti f
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [uniformSpace Î±] [uniformSpace Î²] [SeparatedSpace Î±] [LocallyCompactSpace Î±] [CompactSpace Î²] [SeparatedSpace Î²] [uniformSpace Î³] (f : Î± â†’ Î² â†’ Î³) (h : Continuous â†¿f) (x : Î±) : TendstoUniformly f (f x) (nhds x)
{K : Type u_1} [Field K] [NumberField K] : NumberField.classNumber K = 1 â†” IsPrincipalIdealRing â†¥(NumberField.ringOfIntegers K)
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” InnerProductGeometry.angle x y = Real.pi
{ð•œ : Type u} [hnorm : nondiscreteNormedField ð•œ] {E : Type v} [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul ð•œ E] [CompleteSpace ð•œ] [t2_Space E] {Î¹ : Type u_1} [Fintype Î¹] (Î¾ : Basis Î¹ ð•œ E) : Continuous â‡‘(Î¾.equiv_fun)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {F : Type u_6} [NormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} {E' : Type u_10} [semiNormedGroup E'] [normedSpace ð•œ E'] [RingHomIsometric Ïƒâ‚â‚‚] {f : â„• â†’ (E' â†’sl[Ïƒâ‚â‚‚] F)} {g : E' â†’sl[Ïƒâ‚â‚‚] F} (hg : Filter.Tendsto (Î» (n : â„•) (x : E'), â‡‘(f n) x) Filter.atTop (nhds â‡‘g)) (hF : CauchySeq f) : Filter.Tendsto f Filter.atTop (nhds g)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set â„} [Interval_integral.FTC_Filter a (nhdsWithin a s) (nhdsWithin a t)] (hmeas : StronglyMeasurableAtFilter f (nhdsWithin a t) MeasureTheory.MeasureSpace.volume) (ha : ContinuousWithinAt f t a) : HasDerivWithinAt (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) s a
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) (Î¸ : Real.Angle) : â‡‘(o.rotation Î¸) x = x â†” x = 0 âˆ¨ Î¸ = 0
{R : Type u} [NonAssocSemiring R] (s : Set R) : â†‘(Subsemiring.closure s) = â†‘(AddSubmonoid.closure â†‘(Submonoid.closure s))
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {s : Finset Î¹} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) {a : Î¹ â†’ Î¹ â†’ ð•œ} : s.sum (Î» (i : Î¹), s.sum (Î» (j : Î¹), a i j â€¢ HasInner.inner (v j) (v i))) = s.sum (Î» (k : Î¹), a k k)
{K : Type u} {V Vâ‚ : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [AddCommGroup Vâ‚] [Module K Vâ‚] : Nonempty (V â‰ƒâ‚—[K] Vâ‚) â†” Module.rank K V = Module.rank K Vâ‚
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e e' : localHomeomorph Î± Î²} (h : e â‰ˆ e') : Set.EqOn â‡‘e â‡‘e' e.to_local_equiv.source
{Î± : Type u_1} [linearOrderedField Î±] [floorSemiring Î±] (m n : â„•) : âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n
{K L : Type} [Field K] [Field L] [IsAlgClosed K] [IsAlgClosed L] (p : â„•) [Char_p K p] [Char_p L p] (hK : Cardinal.aleph_0 < Cardinal.mk K) (hKL : Cardinal.mk K = Cardinal.mk L) : K â‰ƒ+* L
{Î± : Type u_1} [hÎ± : uniformSpace Î±] (h : Uniformity Î± = Filter.principal IdRel) : discreteTopology Î±
{b m d : â„•} (hb : 2 â‰¤ b) (hD : d âˆˆ b.digits m) : d < b
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : o.oangle x (â‡‘(o.rotation Î¸) y) = o.oangle x y + Î¸
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {E : Type u_3} [hasNorm E] {F : Type u_4} [hasNorm F] (e : Î± â‰ƒâ‚œ Î²) {b : Î²} {f : Î² â†’ E} {g : Î² â†’ F} : f =O[nhds b] g â†” (f âˆ˜ â‡‘e) =O[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
(G : AddSubgroup â„) : Dense â†‘G âˆ¨ âˆƒ (a : â„), G = AddSubgroup.closure {a}
{n : â„•} {Î± : Type u_1} [Preorder Î±] {f : Fin (n + 1) â†’ Î±} : StrictMono f â†” âˆ€ (i : Fin n), f (â‡‘fin.cast_Succ i) < f i.succ
{R : Type u_1} [CommRing R] {M : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] {Râ‚˜ : Type u_4} {Sâ‚˜ : Type u_5} [CommRing Râ‚˜] [CommRing Sâ‚˜] [Algebra R Râ‚˜] [IsLocalization M Râ‚˜] [Algebra S Sâ‚˜] [IsLocalization (Algebra.algebraMapSubmonoid S M) Sâ‚˜] (H : Algebra.IsIntegral R S) : (IsLocalization.map Sâ‚˜ (algebraMap R S) _).is_integral
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasWideEqualizers C] {T : C} (hT : âˆ€ (X : C), Nonempty (T âŸ¶ X)) : CategoryTheory.Limits.HasInitial C
{x y : Pgame} : x.lf y â†” (âˆƒ (i : y.left_moves), x â‰¤ y.move_Left i) âˆ¨ âˆƒ (j : x.right_moves), x.move_Right j â‰¤ y
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x : V} (hx : x â‰  0) (Î¸ : Real.Angle) : o.oangle x (â‡‘(o.rotation Î¸) x) = Î¸
{G : Type u_1} {H : Type u_2} [Group G] {N : Subgroup G} [Group H] {f : G â†’* H} (hN : N = f.ker) (tH : monoid.is_torsion H) (tN : monoid.is_torsion â†¥N) : monoid.is_torsion G
{Î± : Type u_1} {Î² : Type u_2} (e : LocalEquiv Î± Î²) : e.symm.trans e â‰ˆ LocalEquiv.ofSet e.target
{Î± : Type u_1} {Î² : Type u_2} [PartialOrder Î±] [Preorder Î²] {fa : Î± â‰ƒo Î±} {fb : Î² â†ªo Î²} {g : Î± â†’ Î²} (h : Function.Semiconj g â‡‘fa â‡‘fb) {g' : Î² â†’ Î±} (hg' : IsOrderRightAdjoint g g') : Function.Semiconj g' â‡‘fb â‡‘fa
{V : Type u_1} (Î± : Type u_2) (G : SimpleGraph V) [DecidableRel G.adj] [MulZeroOneClass Î±] [Nontrivial Î±] : _.to_graph = G
{Î± : Type u_1} {Î² : Type u_2} {e e' : LocalEquiv Î± Î²} (h : e â‰ˆ e') : Set.EqOn â‡‘(e.symm) â‡‘(e'.symm) e.target
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Limits.HasEqualizers C
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] (S : Type u_3) [CommMonoid S] [DistribMulAction S M] [SmulCommClass S R M] : Module.IsTorsion' M S â†” Submodule.torsion' R M S = âŠ¤
(Î¹ : Type u_1) [Fintype Î¹] : is_IsClosed (StdSimplex â„ Î¹)
{Î± : Type u_1} [Preorder Î±] [succOrder Î±] {a b : Î±} [NoMaxOrder Î±] : a < b â†’ Order.succ a < Order.succ b
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (z : V) (h : InnerProductGeometry.angle x y = Real.pi) : InnerProductGeometry.angle x z + InnerProductGeometry.angle y z = Real.pi
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (Î¸ : Real.Angle) : o.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
{Î² : Type u} {Î± : Type v} {s : Finset Î±} {a : Î±} {f : Î± â†’ Î²} [AddCommMonoid Î²] [DecidableEq Î±] (h : a âˆ‰ s â†’ f a = 0) : (HasInsert.insert a s).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
{Î± : Type u_1} {Î¹ : sort u_4} [completeLattice Î±] (f : Î¹ â†’ Î±) : (â¨… (i : {i // f i â‰  âŠ¤}), f â†‘i) = â¨… (i : Î¹), f i
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} : Metric.hausdorffDist s (Closure s) = 0
{ð•œ : Type u_1} {_x : Ring ð•œ} {E : Type u_2} [semiNormedGroup E] {_x_1 : Module ð•œ E} {s : Submodule ð•œ E} (x : â†¥s) : âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
{n : â„•} {F : Typevec (n + 1) â†’ Type u} [Mvfunctor F] [q : Mvqpf F] {Î± : Typevec n} (r : Mvqpf.Cofix F Î± â†’ Mvqpf.Cofix F Î± â†’ Prop) (h : âˆ€ (x y : Mvqpf.Cofix F Î±), r x y â†’ Mvfunctor.Liftr' (Î±.rel_Last' r) x.dest y.dest) (x y : Mvqpf.Cofix F Î±) : r x y â†’ x = y
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (hb : s.sum (Î» (x : Î±), w x) < t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) < b
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {f : Filter Î±} {a : Î±} [f.ne_IsBot] : f â‰¤ nhds a â†’ f.Limsup = a
{S : Type u} [hasMul S] {a x y : S} (h : SemiconjBy a x y) : a * x = y * a
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topologicalSpace Î±] [uniformSpace Î²] {K : Set Î±} (f : C(Î±, Î²)) (hK : is_IsCompact K) {U : Set Î²} (hU : is_IsOpen U) (hF : f âˆˆ ContinuousMap.CompactOpen.Gen K U) : âˆƒ (V : Set (Î² Ã— Î²)) (H : V âˆˆ Uniformity Î²), is_IsOpen V âˆ§ ContinuousMap.CompactConvNhd K V f âŠ† ContinuousMap.CompactOpen.Gen K U
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : â„•} {i : Fin (n + 1)} : X.Ïƒ i â‰« X.Î´ (â‡‘fin.cast_Succ i) = ðŸ™ (X.obj (Opposite.op (SimplexCategory.mk n)))
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) : fin.cons (q 0) (fin.tail q) = q
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] (s : Submodule K V) : Module.rank K â†¥s â‰¤ 1 â†” âˆƒ (vâ‚€ : V) (H : vâ‚€ âˆˆ s), s â‰¤ Submodule.span K {vâ‚€}
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (v w : E) (H : w âˆˆ K) : HasInner.inner (v - orthogonalProjectionFn K v) w = 0
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a b : Î±} (hab : a < b) (s : Set Î±) : [s âˆˆ nhdsWithin a (Set.Ici a), s âˆˆ nhdsWithin a (Set.Icc a b), s âˆˆ nhdsWithin a (Set.Ico a b), âˆƒ (u : Î±) (H : u âˆˆ Set.Ioc a b), Set.Ico a u âŠ† s, âˆƒ (u : Î±) (H : u âˆˆ Set.Ioi a), Set.Ico a u âŠ† s].tfae
{C : Type u} [CategoryTheory.Category C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) [CategoryTheory.StrongEpi f] [CategoryTheory.StrongEpi g] : CategoryTheory.StrongEpi (f â‰« g)
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {Î¹ : Type u_6} [DecidableEq Î¹] {Mâ‚‚ : Type u_7} [AddCommMonoid Mâ‚‚] [Module R Mâ‚‚] {Mâ‚ƒ : Type u_8} [AddCommMonoid Mâ‚ƒ] [Module R Mâ‚ƒ] (f : AlternatingMap R M N Î¹) (gâ‚ : Mâ‚‚ â†’â‚—[R] M) (gâ‚‚ : Mâ‚ƒ â†’â‚—[R] Mâ‚‚) : (f.comp_Linear_Map gâ‚).comp_Linear_Map gâ‚‚ = f.comp_Linear_Map (gâ‚.comp gâ‚‚)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [CommSemiring R] (s : Subsemiring R) (m : Multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
{n n' : â„•} (m : â„•) (i : Fin n') (h : n' = n) : â‡‘(fin.cast_Add m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.cast_Add m) i)
{F : Type} [Field F] (q : â„•) [hq : Fact (Nat.Prime q)] [hF : Char_p F q] (g g' : Polynomial F) (m m' : â„•) (h_expand : â‡‘(Polynomial.expand F (q ^ m)) g = â‡‘(Polynomial.expand F (q ^ m')) g') (h : m < m') (hg : g.separable) : g.nat_degree = g'.nat_degree
{Î± : Type u_1} {n : Type u_4} [commSemigroup Î±] [AddCommMonoid Î±] [Fintype n] [AddCommGroup n] (v w : n â†’ Î±) : (Matrix.circulant v).mul (Matrix.circulant w) = (Matrix.circulant w).mul (Matrix.circulant v)
{Î± : Type u} [pseudoMetricSpace Î±] (x y : Î±) : HasNndist.nndist x y = (HasDist.dist x y).to_Nnreal
(Î± : Type u_1) [PartialOrder Î±] : WellFounded GT â†” âˆ€ (a : â„• â†’o Î±), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘a n = â‡‘a m
{F : Type u_3} [innerProductSpace â„ F] {x y : F} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + 2 * HasInner.inner x y + HasInner.inner y y
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {n : â„•} [Fact (FiniteDimensional.finrank ð•œ E = n + 1)] {v : E} (hv : v â‰  0) : FiniteDimensional.finrank ð•œ â†¥(Submodule.span ð•œ {v})á—® = n
{V : Type u_4} [innerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V) (x y : V) : HasInner.inner (â‡‘T y) x = (HasInner.inner (â‡‘T (x + y)) (x + y) - HasInner.inner (â‡‘T (x - y)) (x - y) + Complex.i * HasInner.inner (â‡‘T (x + Complex.i â€¢ y)) (x + Complex.i â€¢ y) - Complex.i * HasInner.inner (â‡‘T (x - Complex.i â€¢ y)) (x - Complex.i â€¢ y)) / 4
{Î¹â‚ : Type u_1} {Î¹â‚‚ : Type u_2} {R : Type u_3} {Râ‚‚ : Type u_4} {S : Type u_5} {Sâ‚‚ : Type u_6} {M : Type u_7} {N : Type u_8} {P : Type u_9} [CommRing R] [CommRing S] [CommRing Râ‚‚] [CommRing Sâ‚‚] [AddCommGroup M] [AddCommGroup N] [AddCommGroup P] [Module R M] [Module S N] [Module Râ‚‚ P] [Module Sâ‚‚ P] [SmulCommClass Sâ‚‚ Râ‚‚ P] {Ïâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚â‚‚ : S â†’+* Sâ‚‚} (bâ‚ : Basis Î¹â‚ R M) (bâ‚‚ : Basis Î¹â‚‚ S N) {B B' : M â†’â‚›â‚—[Ïâ‚â‚‚] N â†’â‚›â‚—[Ïƒâ‚â‚‚] P} (h : âˆ€ (i : Î¹â‚) (j : Î¹â‚‚), â‡‘(â‡‘B (â‡‘bâ‚ i)) (â‡‘bâ‚‚ j) = â‡‘(â‡‘B' (â‡‘bâ‚ i)) (â‡‘bâ‚‚ j)) : B = B'
{p : â„•} : Summable (Î» (n : â„•), (â†‘n ^ p)â»Â¹) â†” 1 < p
{Î± : Type u_1} {Î² : Type u_2} [completeLattice Î±] {f : Filter Î²} : f.liminf (Î» (x : Î²), âŠ¤) = âŠ¤
{Î± : Type u} [metricSpace Î±] (x : â„• â†’ Î±) (a b : Î±) : HasDist.dist (KuratowskiEmbedding.embeddingOfSubset x a) (KuratowskiEmbedding.embeddingOfSubset x b) â‰¤ HasDist.dist a b
{Î± : Type u_1} {Î² : Type u_2} [Fintype Î±] [completeLattice Î²] (f : Î± â†’ Î²) : finset.univ.sup f = supr f
{Î± : Type u_1} [GeneralizedBooleanAlgebra Î±] [DecidableRel Disjoint] [DecidableRel LE.le] (u v : Î±) (s : Finset Î±) : (Uv.compression u v s).card = s.card
{R : Type u} {Î¹ : Type w} (s : Finset Î¹) [CommSemiring R] [NoZeroDivisors R] (f : Î¹ â†’ Polynomial R) [Nontrivial R] : (s.prod (Î» (i : Î¹), f i)).degree = s.sum (Î» (i : Î¹), (f i).degree)
 : â‡‘LinearMap.det complex.conj_ae.to_Linear_Map = -1
{R : Type u_1} [linearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {vâ‚ vâ‚‚ : M} (h : SameRay R vâ‚ vâ‚‚) : âˆƒ (a b : R), 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ vâ‚ = a â€¢ (vâ‚ + vâ‚‚) âˆ§ vâ‚‚ = b â€¢ (vâ‚ + vâ‚‚)
{Î± : Type u} [pseudoEmetricSpace Î±] {s : Set Î±} (hs : is_IsCompact s) : âˆƒ (t : Set Î±) (H : t âŠ† s), t.countable âˆ§ s âŠ† Closure t
{S : Type v} [CommRing S] {R : Type u} (c : â„¤ â†’+* S) (f : MvPolynomial R â„¤ â†’+* S) (x : MvPolynomial R â„¤) : MvPolynomial.evalâ‚‚ c (â‡‘f âˆ˜ MvPolynomial.x) x = â‡‘f x
{Î± : Type u_1} [AddSemigroup Î±] (x y : Î±) : Add.add x âˆ˜ Add.add y = Add.add (x + y)
{A : Type u} {B : Type v} {Î¹ : Type w} [CommRing A] [CommRing B] [Algebra A B] [Fintype Î¹] [DecidableEq Î¹] (b : Î¹ â†’ B) (P : Matrix Î¹ Î¹ A) : Algebra.discr A (Matrix.vecMul b (P.map â‡‘(algebraMap A B))) = P.det ^ 2 * Algebra.discr A b
{b : â„•} {S : Set â„•} (hb : b âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) {n : â„•} (hbn : b â‰¤ n) : n âˆˆ S
{G : Type u} [AddGroup G] (H : AddSubgroup G) (h : Subsingleton (G â§¸ H)) : H = âŠ¤
{Î± : Type u_1} {M : Type u_5} [hasZero M] {f g : Î± â†’â‚€ M} : â‡‘f = â‡‘g â†” f = g
{R : Type u} [Ring R] : CategoryTheory.Limits.HasCokernels (Module R)
{Î± : Type u_1} {Î² : Type u_2} (t : Î±) (ts ys : List Î±) (f : List Î± â†’ Î²) : List.map f (List.permutationsAux2 t ts List.nil ys Id).snd = (List.permutationsAux2 t ts List.nil ys f).snd
{f : â„ â†’ â„} (hF : Differentiable â„ f) (hF'_anti : StrictAnti (deriv f)) : StrictConcaveOn â„ Set.Univ f
{Î± : Type u} [pseudoMetricSpace Î±] {x : Î±} : Metric.diam {x} = 0
{n : â„•} : 0 < n â†’ 0 < SzemerediRegularity.stepBound n
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [Module ð•œ E] {s : Set E} (hs : Convex ð•œ s) (z : E) : Convex ð•œ ((Î» (x : E), z + x) â»Â¹' s)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e : localHomeomorph Î± Î²} {s : Set Î±} {t : Set Î²} : e.is_image s t â†’ e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s = e.to_local_equiv.target âˆ© t
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [IsTrans Î± r] (f : â„• â†’ Î±) : âˆƒ (g : â„• â†ªo â„•), (âˆ€ (m n : â„•), m < n â†’ r (f (â‡‘g m)) (f (â‡‘g n))) âˆ¨ âˆ€ (m n : â„•), m < n â†’ Â¬r (f (â‡‘g m)) (f (â‡‘g n))
{M : Type u_1} [AddMonoid M] {x : M} : x âˆˆ Multiples x
 : Filter.Tendsto Complex.exp (Filter.comap Complex.re Filter.atTop) (Filter.comap Complex.abs Filter.atTop)
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : Function.Injective coeFn
{R S : Type u} [CommRing R] [CommRing S] (M : Submonoid R) (R' : Type u) [CommRing R'] [Algebra R R'] [Algebra R' S] [Algebra R S] [isScalarTower R R' S] [IsLocalization M R'] (s : Set S) (x : S) (hx : x âˆˆ Algebra.adjoin R' s) : âˆƒ (t : â†¥M), t â€¢ x âˆˆ Algebra.adjoin R s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasFiniteCoproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasFiniteColimits C
{G : Type u_1} [Group G] {k : Set G} {p : G â†’ Prop} {x : G} (h : x âˆˆ Subgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ p x) (H1 : p 1) (HMul : âˆ€ (x y : G), p x â†’ p y â†’ p (x * y)) (Hinv : âˆ€ (x : G), p x â†’ p xâ»Â¹) : p x
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [succOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Antitone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ioc (f (Order.succ n)) (f n))
{G : Type u} {x : G} [AddMonoid G] : 0 < addOrderOf x â†” IsOfFinAddOrder x
{R : Type u} [CommSemiring R] [starRing R] {x : R} : â‡‘(starRingEnd R) x = HasStar.star x
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] (v : V) (nz : v â‰  0) : FiniteDimensional.finrank K V = 1 â†” âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w
{G : Type w} [topologicalSpace G] [hasInv G] [hasMul G] [HasContinuousMul G] [HasContinuousInv G] : Continuous (Î» (g : G Ã— G), g.fst * g.snd * (g.fst)â»Â¹)
{E : Type u_3} [semiNormedGroup E] (u v : E) : âˆ¥vâˆ¥â‚Š â‰¤ âˆ¥uâˆ¥â‚Š + âˆ¥u - vâˆ¥â‚Š
{Î± : Type u_1} {Î² : Type u_2} [AddCommMonoid Î±] [topologicalSpace Î±] : HasSum (Î» (b : Î²), 0) 0
{Î± : Type u_1} {M : Type u_5} {N : Type u_6} [CommMonoid M] [CommMonoid N] {s : Set Î±} {f : Î± â†’ M} (g : M â†’* N) (hâ‚€ : (s âˆ© Function.MulSupport f).finite) : â‡‘g (finprod (Î» (j : Î±), finprod (Î» (H : j âˆˆ s), f j))) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), â‡‘g (f i)))
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [isScalarTower R A B] {x : B} (h : IsIntegral R x) : IsIntegral A x
{Î± : Type u_1} [topologicalSpace Î±] [t2_Space Î±] [measurableSpace Î±] [BorelSpace Î±] {f g : (â„• â†’ â„•) â†’ Î±} (hF : Continuous f) (hg : Continuous g) (h : Disjoint (Set.Range f) (Set.Range g)) : MeasureTheory.MeasurablySeparable (Set.Range f) (Set.Range g)
{n : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero â†‘â†‘n] (hn : IsPrimePow â†‘n) [IsCyclotomicExtension {n} K L] (hirr : Irreducible (Polynomial.cyclotomic â†‘n K)) (h : n â‰  2) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta n K L - 1) = â†‘(â†‘n.min_fac)
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [CommGroup Î²] {f g : Î± â†’ Î²} (hF : IsGroupHom f) (hg : IsGroupHom g) : IsGroupHom (Î» (a : Î±), f a * g a)
{R : Type u} {n : â„•} {M : Fin n.succ â†’ Type w} {Mâ‚‚ : Type wâ‚‚} [Semiring R] [Î  (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid Mâ‚‚] [Î  (i : Fin n.succ), Module R (M i)] [Module R Mâ‚‚] [Î  (i : Fin n.succ), topologicalSpace (M i)] [topologicalSpace Mâ‚‚] (f : ContinuousMultilinearMap R M Mâ‚‚) (m : Î  (i : Fin n), M i.succ) (c : R) (x : M 0) : â‡‘f (fin.cons (c â€¢ x) m) = c â€¢ â‡‘f (fin.cons x m)
{G : Type u} {n : â„•} [Fintype G] [LeftCancelMonoid G] (x : G) : orderOf (x ^ n) = orderOf x / (orderOf x).gcd n
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] [PolishSpace Î²] {f : Î± â†’ Î²} (hF : ClosedEmbedding f) : PolishSpace Î±
{Î“ : Type u_1} [Inhabited Î“] (l : Turing.ListBlank Î“) : âˆƒ (a : Î“) (l' : Turing.ListBlank Î“), l = Turing.ListBlank.cons a l'
{E : Type u_2} [semiNormedGroup E] [normedSpace â„ E] {s : Set E} (hsâ‚€ : 0 âˆˆ s) (hsâ‚ : Convex â„ s) (hsâ‚‚ : is_IsOpen s) {xâ‚€ : E} (hxâ‚€ : xâ‚€ âˆ‰ s) : âˆƒ (f : E â†’L[â„] â„), â‡‘f xâ‚€ = 1 âˆ§ âˆ€ (x : E), x âˆˆ s â†’ â‡‘f x < 1
{b m d : â„•} : d âˆˆ (b + 2).digits m â†’ d < b + 2
{Î± : sort u_1} {p : Î± â†’ Prop} (P : âˆƒ (a : Î±), p a) : p P.some
{Î± : Type u} [pseudoEmetricSpace Î±] {Î´ : â„} {s : Set Î±} {x : Î±} : Emetric.infEdist x s â‰¤ Emetric.infEdist x (Metric.Cthickening Î´ s) + Ennreal.ofReal Î´
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (A : Matrix m m R) (C : Matrix n m R) (D : Matrix n n R) : (Matrix.fromBlocks A 0 C D).det = A.det * D.det
{Î± : Type u_1} [CanonicallyOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b c : Î±} [ContravariantClass Î± Î± Add.add LE.le] (h : c â‰¤ b) : a < b - c â†” a + c < b
{R : Type u_4} [linearOrderedCommRing R] (a b : R) : 2 * a * b â‰¤ a ^ 2 + b ^ 2
(A : Type u_2) [CommRing A] [is_IsDomain A] (K : Type u_1) [Field K] [Algebra A K] [IsFractionRing A K] : IsDedekindDomain A â†” IsNoetherianRing A âˆ§ ring.dimension_LE_One A âˆ§ âˆ€ {x : K}, IsIntegral A x â†’ (âˆƒ (y : A), â‡‘(algebraMap A K) y = x)
{a b c m : â„•} (hmc : m.gcd c = 1) (h : c * a â‰¡ c * b [Mod m]) : a â‰¡ b [Mod m]
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} {t : CategoryTheory.Limits.Cofork f g} {Z Z' : C} (q : Z âŸ¶ Z') (ht : CategoryTheory.Limits.IsColimit t) (k : t.X âŸ¶ Z) : â†‘(â‡‘(CategoryTheory.Limits.Cofork.IsColimit.homIso ht Z') (k â‰« q)) = â†‘(â‡‘(CategoryTheory.Limits.Cofork.IsColimit.homIso ht Z) k) â‰« q
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] [denselyOrdered Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhdsWithin a (Set.Iio a) â†” âˆƒ (l : Î±) (H : l âˆˆ Set.Iio a), Set.Ico l a âŠ† s
{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] {S : Finset Î¹} {q : Î¹ â†’ R} (hq : â†‘S.pairwise (IsCoprime on q)) (hM : Module.IsTorsionBy R M (S.prod (Î» (i : Î¹), q i))) : DirectSum.IsInternal (Î» (i : â†¥S), Submodule.torsionBy R M (q â†‘i))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) : vectorSpan k s = Submodule.span k (s -áµ¥ s)
(F : Type u) (K : Type v) (A : Type w) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [Module K A] [Module F A] [isScalarTower F K A] : (Module.rank F K).lift * (Module.rank K A).lift = (Module.rank F A).lift
{Î± : Type u_1} [GeneralizedBooleanAlgebra Î±] [DecidableRel Disjoint] [DecidableRel LE.le] (u v a : Î±) : Uv.compress u v (Uv.compress u v a) = Uv.compress u v a
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : Reflexive r) {x y : Î±} : x â‰  y â†’ r x y â†” r x y
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {f : Î± â†’ â„} (K : Nnreal) (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + â†‘K * HasDist.dist x y) : LipschitzOnWith K f s
{ð•œ : Type u_1} [is_R_or_C ð•œ] {E : Type u_2} {E' : Type u_3} [innerProductSpace ð•œ E] [innerProductSpace ð•œ E'] (f : E â‰ƒâ‚—áµ¢[ð•œ] E') (p : Submodule ð•œ E) [CompleteSpace â†¥p] (x : E') : â†‘(â‡‘(orthogonalProjection (Submodule.map â†‘(f.to_linearEquiv) p)) x) = â‡‘f â†‘(â‡‘(orthogonalProjection p) (â‡‘(f.symm) x))
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (lâ‚ : Filter Î±) (lâ‚‚ : Filter Î²) : Filter.Tendsto f lâ‚ lâ‚‚ â†” âˆ€ (g : Ultrafilter Î±), â†‘g â‰¤ lâ‚ â†’ Filter.Tendsto f â†‘g lâ‚‚
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {c : â„‚} {r R : â„} (h0 : 0 < r) (hle : r â‰¤ R) {f : â„‚ â†’ E} {s : Set â„‚} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c R  Metric.Ball c r)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball c R  Metric.ClosedBall c r  s â†’ DifferentiableAt â„‚ f z) : âˆ® (z : â„‚) in C(c, R), f z = âˆ® (z : â„‚) in C(c, r), f z
{A : Type u_4} [CommRing A] [is_IsDomain A] {K : Type u_5} [Field K] {L : Type u_7} [Field L] [Algebra A K] [IsFractionRing A K] {g : A â†’+* L} (hg : Function.Injective â‡‘g) (x : A) (y : â†¥(NonZeroDivisors A)) : â‡‘(IsFractionRing.lift hg) (IsLocalization.mk' K x y) = â‡‘g x / â‡‘g â†‘y
{v : â„• â†’ â„} {c : â„} (hâ‚€ : 0 < v 0) (hc : 1 < c) (hu : âˆ€ (n : â„•), c * v n â‰¤ v (n + 1)) : Filter.Tendsto v Filter.atTop Filter.atTop
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : Set P} {p1 p2 : P} (hp1 : p1 âˆˆ SpanPoints k s) (hp2 : p2 âˆˆ SpanPoints k s) : p1 -áµ¥ p2 âˆˆ vectorSpan k s
(G : Type u_1) [Group G] : IsAscendingCentralSeries (upperCentralSeries G)
{G : Type u_1} [Group G] [hH : group.is_nilpotent G] [Nontrivial G] : group.nilpotency_class G = group.nilpotency_class (G â§¸ Subgroup.center G) + 1
(a b : Nnreal) {p q : â„} (hpq : p.is_conjugate_exponent q) : a * b â‰¤ a ^ p / p.to_Nnreal + b ^ q / q.to_Nnreal
{p : â„•} [Fact (Nat.Prime p)] : p % 2 = 1 â†” p â‰  2
 : â‡‘fourierSeries = fourierLp 2
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (g : Î² â†’ Î³) (f : Î± â†’ Î²) : List.map g âˆ˜ List.map f = List.map (g âˆ˜ f)
{R : Type u_1} {S : Type u_2} [euclideanDomain R] [CommRing S] [is_IsDomain S] [Algebra R S] (abv : AbsoluteValue R â„¤) {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] (bS : Basis Î¹ R S) (a : S) {y : â„¤} (hy : âˆ€ (k : Î¹), â‡‘abv (â‡‘(â‡‘(bS.repr) a) k) â‰¤ y) : â‡‘abv (â‡‘(Algebra.norm R) a) â‰¤ ClassGroup.normBound abv bS * y ^ Fintype.card Î¹
{R : Type u_1} [MulZeroClass R] : Â¬IsRightRegular 0 â†” Nontrivial R
(x y : â„¤) : â†‘(x.gcd y) = x * x.gcd_a y + y * x.gcd_b y
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [is_R_or_C ð•‚] [normedCommRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] {x : ð”¸} : HasStrictFderivAt (Exp ð•‚) (Exp ð•‚ x â€¢ 1) x
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} {P : Type uâ‚„} [AddCommGroup V] [addTorsor V P] [Ring k] [Module k V] (b : AffineBasis Î¹ k P) [Fintype Î¹] (bâ‚‚ : AffineBasis Î¹ k P) (x : P) : Matrix.vecMul (â‡‘(bâ‚‚.coords) x) (b.to_Matrix bâ‚‚.points) = â‡‘(b.coords) x
{K : Type u_1} [is_R_or_C K] : â‡‘is_R_or_C.re is_R_or_C.I = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {n : â„•} (s1 s2 : Affine.Simplex k P n) : s1 = s2 â†” âˆ€ (i : Fin (n + 1)), s1.points i = s2.points i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X âŸ¶ Y) [CategoryTheory.Limits.HasBinaryBiproduct Y Y] : f + g = CategoryTheory.Limits.biprod.lift f g â‰« CategoryTheory.Limits.biprod.desc (ðŸ™ Y) (ðŸ™ Y)
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {Râ‚ Râ‚‚ : â„} {f : â„‚ â†’ E} {c : â„‚} (hD : DifferentiableOn â„‚ f (Metric.Ball c Râ‚)) (h_maps : Set.MapsTo f (Metric.Ball c Râ‚) (Metric.Ball (f c) Râ‚‚)) (hâ‚€ : 0 < Râ‚) : âˆ¥deriv f câˆ¥ â‰¤ Râ‚‚ / Râ‚
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x y : Î±} (h : y âˆˆ s) : Metric.infDist x s â‰¤ HasDist.dist x y
{M : Type u_1} [hasAdd M] (c : AddCon M) : addConGen â‡‘c = c
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [Module ð•œ E] {x z : E} {s : Set E} (hs : StarConvex ð•œ (z + x) s) : StarConvex ð•œ x ((Î» (x : E), z + x) â»Â¹' s)
{Î± : Type u_1} [isEmpty Î±] (s : Finset Î±) : s = âˆ…
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [CompleteSpace E] (v : E) : â‡‘(reflection (Submodule.span ð•œ {v})á—®) v = -v
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î²'] [DecidableEq Î³] [DecidableEq Î´] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²' â†’ Î³} {g : Î² â†’ Î²'} {f' : Î² â†’ Î± â†’ Î´} {g' : Î´ â†’ Î³} (h_Right_anticomm : âˆ€ (a : Î±) (b : Î²), f a (g b) = g' (f' b a)) : Finset.imageâ‚‚ f s (Finset.image g t) = Finset.image g' (Finset.imageâ‚‚ f' t s)
{Î¹ : Type u_1} {N : Type u_5} [orderedCommMonoid N] {f g : Î¹ â†’ N} {s : Finset Î¹} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰¤ g i) : s.prod (Î» (i : Î¹), f i) â‰¤ s.prod (Î» (i : Î¹), g i)
{Î± : Type u_2} {Î² : Type u_3} [hasZero Î±] [hasZero Î²] [smulWithZero Î± Î²] {s : Set Î²} (h : s.nonempty) : 0 â€¢ s = 0
{R : Type u_1} [Ring R] [topologicalSpace R] [NonarchimedeanRing R] (U : openAddSubgroup R) : âˆƒ (V : openAddSubgroup R), â†‘V * â†‘V âŠ† â†‘U
{Î± : Type u} {Î² : Type v} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hF : Filter.Tendsto f l Filter.atTop) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), f x * g x) l Filter.atBot
{Î± : Type u_1} [HasLe Î±] {a : Î±} : IsBot a â†’ IsTop (â‡‘OrderDual.toDual a)
{ð•œ : Type u_2} {E : Type u_5} {F : Type u_6} [topologicalSpace ð•œ] [CommSemiring ð•œ] [AddCommMonoid E] [Module ð•œ E] [AddCommMonoid F] [Module ð•œ F] {B : E â†’â‚—[ð•œ] F â†’â‚—[ð•œ] ð•œ} (hB : Function.Injective â‡‘B) : Embedding (Î» (x : WeakBilin B) (y : F), â‡‘(â‡‘B x) y)
 : {p : â„• | Nat.Prime p}.infinite
(Î± : Type u) (Î² : Type v) : Nonempty (Î± â†ª Î²) âˆ¨ Nonempty (Î² â†ª Î±)
{n : â„•} {i j : Fin (n + 2)} (H : i â‰¤ j) : SimplexCategoryÎ´ i â‰« SimplexCategoryÎ´ j.succ = SimplexCategoryÎ´ j â‰« SimplexCategoryÎ´ (â‡‘fin.cast_Succ i)
(p : â„•) [hp : Fact (Nat.Prime p)] : WittVector.IsPoly p (Î» (R : Type u_1) (_Rcr : CommRing R), WittVector.frobeniusFun)
{M : Type u_6} {N : Type u_7} [hasAdd M] [hasAdd N] (f : M â‰ƒ+ N) (x y : M) : â‡‘f (x + y) = â‡‘f x + â‡‘f y
{Î¹ : Type u} {X : Type v} [topologicalSpace X] [ParacompactSpace X] {s : Set X} (hs : is_IsClosed s) (u : Î¹ â†’ Set X) (uo : âˆ€ (i : Î¹), is_IsOpen (u i)) (us : s âŠ† â‹ƒ (i : Î¹), u i) : âˆƒ (v : Î¹ â†’ Set X), (âˆ€ (i : Î¹), is_IsOpen (v i)) âˆ§ (s âŠ† â‹ƒ (i : Î¹), v i) âˆ§ LocallyFinite v âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
{Î¹ : Type u_1} {V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape Î¹} (C : HomologicalComplex V c) {i j j' : Î¹} (rij : c.rel i j) (rij' : c.rel i j') : C.d i j' â‰« CategoryTheory.eqToHom _ = C.d i j
{Î± : Type u} [Preorder Î±] {s : Set Î±} {a : Î±} (h : is_is_IsLub s a) : BddAbove s
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {f : Î± â†’ Î² â†’ Î³} (hF : Function.Injective2 f) [Nonempty Î²] : Function.Injective f
{R : Type u} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] {N : Type (max u v)} [AddCommGroup N] [Module R N] {p : R} (hp : Irreducible p) (hN : Module.IsTorsion' N â†¥(Submonoid.powers p)) [h' : Module.Finite R N] : âˆƒ (d : â„•) (k : Fin d â†’ â„•), Nonempty (N â‰ƒâ‚—[R] DirectSum (Fin d) (Î» (i : Fin d), R â§¸ Submodule.span R {p ^ k i}))
(S : Set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [is_IsDomain B] [IsNoetherianRing A] [Fintype â†¥S] [IsCyclotomicExtension S A B] : Algebra.IsIntegral A B
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {Î± Î² Î³ : â†¥(solvableByRad F E)} (hÎ³ : Î³ âˆˆ FâŸ®Î±, Î²âŸ¯) (hÎ± : solvableByRad.P Î±) (hÎ² : solvableByRad.P Î²) : solvableByRad.P Î³
{k k' : Turing.ToPartrec.Cont} {v : List â„•} : Turing.ToPartrec.stepRet (k.then k') v = (Turing.ToPartrec.stepRet k v).then k'
{Î± : Type u_1} [LinearOrder Î±] [topologicalSpace Î±] [CompactIccSpace Î±] {a b : Î±} : is_IsCompact (Set.Interval a b)
(k : Type u_1) [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) [Fintype Î¹] : finset.univ.sum (Î» (i : Î¹), Finset.centroidWeightsIndicator k s i) = s.sum (Î» (i : Î¹), Finset.centroidWeights k s i)
{a b : â„•} (hab : a.coprime b) : (a * b).factors ~ a.factors ++ b.factors
{M : Type u_1} [hasMul M] {c d : Con M} : c â‰¤ d â†” âˆ€ {x y : M}, â‡‘c x y â†’ â‡‘d x y
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhdsWithin a (Set.Iio a) â†” âˆƒ (l : Î±) (H : l âˆˆ Set.Iio a), Set.Ioo l a âŠ† s
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {x : E} {n : WithTop â„•} {s : Set E} {f : E â†’ ð•œ} {g : E â†’ F} (hF : ContDiffWithinAt ð•œ n f s x) (hg : ContDiffWithinAt ð•œ n g s x) : ContDiffWithinAt ð•œ n (Î» (x : E), f x â€¢ g x) s x
{R : Type u} [orderedRing R] [starOrderedRing R] [Algebra â„ R] [OrderedSmul â„ R] [StarModule â„ R] (Aâ‚€ Aâ‚ Bâ‚€ Bâ‚ : R) (T : is_CHSH_tuple Aâ‚€ Aâ‚ Bâ‚€ Bâ‚) : Aâ‚€ * Bâ‚€ + Aâ‚€ * Bâ‚ + Aâ‚ * Bâ‚€ - Aâ‚ * Bâ‚ â‰¤ Real.sqrt 2 ^ 3 â€¢ 1
{Î± : sort u_1} {Î² : sort u_2} (f : Î± â†’ Î²) (P : Prop) [Decidable P] (x : P â†’ Î±) (y : Â¬P â†’ Î±) : f (dite P x y) = dite P (Î» (h : P), f (x h)) (Î» (h : Â¬P), f (y h))
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±} [topologicalSpace Î±] (h : TendstoLocallyUniformly F f p) (hF : ContinuousAt f x) (hg : Filter.Tendsto g p (nhds x)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
{Î± : Type u_1} [metricSpace Î±] {Î² : Type u} {N : â„•} {Ï„ : â„} (hÏ„ : 1 < Ï„) (hN : isEmpty (Besicovitch.SatelliteConfig Î± N Ï„)) (q : Besicovitch.BallPackage Î² Î±) : âˆƒ (s : Fin N â†’ Set Î²), (âˆ€ (i : Fin N), (s i).pairwise_Disjoint (Î» (j : Î²), Metric.ClosedBall (q.c j) (q.r j))) âˆ§ Set.Range q.c âŠ† â‹ƒ (i : Fin N) (j : Î²) (H : j âˆˆ s i), Metric.Ball (q.c j) (q.r j)
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {a : Î±} : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ {a}), f i)) = f a
{Î± : Type u_1} {M : Type u_4} {N : Type u_5} [CommMonoid M] [hasOne N] (f : Î± â†’ N) (g : Î± â†’ N â†’ M) {s t : Finset Î±} (h : s âŠ† t) (hg : âˆ€ (a : Î±), g a 1 = 1) : s.prod (Î» (i : Î±), g i (f i)) = t.prod (Î» (i : Î±), g i (â†‘s.mul_indicator f i))
{E : Type u_1} [semiNormedGroup E] {s : AddSubgroup E} (x : â†¥s) : âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
{Î¹ : Type u} (s : Finset Î¹) (w z : Î¹ â†’ Nnreal) (hw' : s.sum (Î» (i : Î¹), w i) = 1) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), w i * z i) ^ p â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ p)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e : localHomeomorph Î± Î²} {s : Set Î±} {t : Set Î²} : e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' (e.to_local_equiv.source âˆ© s) = e.to_local_equiv.target âˆ© t â†’ e.is_image s t
{o : Ordinal} : Ordinal.Principal Add.add o â†” o = 0 âˆ¨ âˆƒ (a : Ordinal), o = Ordinal.omega ^ a
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : GaloisConnection l u) {x y z : Î±} (hxy : x â‰¤ u (l y)) (hyz : y â‰¤ u (l z)) : x â‰¤ u (l z)
{G : Type u_1} [Group G] {H : Subgroup G} {N : Type u_3} [Group N] (f : G â†’* N) : Subgroup.map f H.normalizer â‰¤ (Subgroup.map f H).normalizer
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] {a b : Î±} : aâ»Â¹ < b â†’ bâ»Â¹ < a
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] {f : J â†’ C} (b : CategoryTheory.Limits.Bicone f) (Total : finset.univ.sum (Î» (j : J), b.Ï€ j â‰« b.Î¹ j) = ðŸ™ b.X) : CategoryTheory.Limits.HasBiproduct f
{R : Type u_1} (câ‚ câ‚‚ : R) : Cardinal.mk â†¥Set.Univ = Cardinal.mk R ^ 4
{n : â„•} (p : Fin (n + 1)) (i : Fin n) : â‡‘fin.cast_Succ i < p âˆ¨ p < i.succ
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {v : â„ â†’ E â†’ E} {K : Nnreal} (hv : âˆ€ (t : â„), LipschitzWith K (v t)) {f g f' g' : â„ â†’ E} {a b Îµf Îµg Î´ : â„} (hF : ContinuousOn f (Set.Icc a b)) (hF' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' t) (Set.Ici t) t) (f_bound : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDist.dist (f' t) (v t (f t)) â‰¤ Îµf) (hg : ContinuousOn g (Set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt g (g' t) (Set.Ici t) t) (g_bound : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDist.dist (g' t) (v t (g t)) â‰¤ Îµg) (ha : HasDist.dist (f a) (g a) â‰¤ Î´) (t : â„) (H : t âˆˆ Set.Icc a b) : HasDist.dist (f t) (g t) â‰¤ gronwallBound Î´ â†‘K (Îµf + Îµg) (t - a)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {x : E} (hF : HasStrictFderivAt f f' x) : âˆƒ (K : Nnreal) (s : Set E) (H : s âˆˆ nhds x), LipschitzOnWith K f s
{Î± : Type u_1} {Î² : Type u_2} {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : IsCountablySpanning C) (hD : IsCountablySpanning D) : Prod.measurableSpace = MeasurableSpace.generateFrom (Set.image2 HasSetProd.prod C D)
{Î± : Type u_1} [GeneralizedBooleanAlgebra Î±] [DecidableRel Disjoint] [DecidableRel LE.le] (u v : Î±) (s : Finset Î±) : Uv.compression u v (Uv.compression u v s) = Uv.compression u v s
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e : localHomeomorph Î± Î²} {s : Set Î±} {t : Set Î²} : e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s = e.to_local_equiv.target âˆ© t â†’ e.is_image s t
{n a b : â„•} (h : a â‰¤ b) : a â‰¡ b [Mod n] â†” n âˆ£ b - a
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] {ifp_n : GeneralizedContinuedFraction.IntFractPair K} (nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n) : ifp_n.fr < 1
(R : Type u_1) {K : Type u_2} {T : Type u_3} {U : Type u_4} [CommRing R] [Field K] [CommRing T] [Algebra R K] [Algebra K T] [Algebra R T] [isScalarTower R K T] [CommSemiring U] [Algebra K U] [Algebra R U] [isScalarTower R K U] (x : T) (y : U) (hy : â‡‘(Polynomial.aeval y) (minpoly K x) = 0) : â‡‘(Polynomial.aeval y) (minpoly R x) = 0
{n : â„•} (P : Mvpfunctor (n + 1)) {Î± : Typevec n} {C : P.W Î± â†’ Prop} (ih : âˆ€ (a : P.A) (f' : (P.drop.B a).arrow Î±) (f : P.last.B a â†’ P.W Î±), (âˆ€ (i : P.last.B a), C (f i)) â†’ C (P.W_Mk a f' f)) (x : P.W Î±) : C x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (h : s.sum (Î» (i : Î¹), w i) = 0) (b : P) : â‡‘(s.weighted_vsub p) w = â‡‘(s.weighted_vsub_of_point p b) w
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) : K â‰¤ Ká—®á—®
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {x : E} : MdifferentiableAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f x â†’ DifferentiableAt ð•œ f x
{G : Type u_1} [AddGroup G] (N H : AddSubgroup G) [N.normal] : â†‘(N âŠ” H) = â†‘N + â†‘H
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {x : E} {n : WithTop â„•} {s : Set E} {f g : E â†’ ð•œ} (hF : ContDiffWithinAt ð•œ n f s x) (hg : ContDiffWithinAt ð•œ n g s x) : ContDiffWithinAt ð•œ n (Î» (x : E), f x * g x) s x
{Î± : Type u} {L L' : List Î±} (h : L = L') {i : â„•} (hi : i < L.length) : L.nth_LE i hi = L'.nth_LE i _
{Î± : Type u_1} [HasLe Î±] {s : Set Î±} : IsLowerSet s â†’ IsUpperSet (â‡‘OrderDual.ofDual â»Â¹' s)
{M : Type u} [Monoid M] (a : M) : a ^ 2 = a * a
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) : hb.oangle x (-y) = hb.oangle x y + â†‘Real.pi
{M : Type u_1} [hasMul M] (S : Subsemigroup M) : Subsemigroup.closure â†‘S = S
{Î± : Type u_1} [Preorder Î±] {f g : Î± â†’ Î±} (hg : Monotone g) (h : f â‰¤ g) (n : â„•) : f^[n] â‰¤ (g^[n])
{R : Type v} [CommRing R] {n : â„•} (A : Matrix (Fin n.succ) (Fin n.succ) R) (i : Fin n.succ) : A.det = finset.univ.sum (Î» (j : Fin n.succ), (-1) ^ (â†‘i + â†‘j) * A i j * (A.minor â‡‘(i.succ_above) â‡‘(j.succ_above)).det)
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} {T : Submonoid P} {Q : Type u_4} [CommMonoid Q] (hg : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) (k : T.localization_Map Q) {x y : M} (h : â‡‘(f.to_Map) x = â‡‘(f.to_Map) y) : â‡‘(k.to_Map) (â‡‘g x) = â‡‘(k.to_Map) (â‡‘g y)
{Î± : Type u_1} (f : Filter Î±) [f.is_countably_generated] : âˆƒ (x : â„• â†’ Set Î±), f.has_Antitone_Basis x
(K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [Module.Finite K L] (pB : powerBasis K L) [IsSeparable K L] : Algebra.discr K â‡‘(pb.basis) = (-1) ^ (FiniteDimensional.finrank K L * (FiniteDimensional.finrank K L - 1) / 2) * â‡‘(Algebra.norm K) (â‡‘(Polynomial.aeval pb.gen) (â‡‘Polynomial.derivative (minpoly K pb.gen)))
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} (f g : c.quotient â†’+ P) (h : âˆ€ (a : M), â‡‘f â†‘a = â‡‘g â†‘a) : f = g
(k : Type u_1) [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) [CharZero k] (h : s.card â‰  0) : s.sum (Î» (i : Î¹), Finset.centroidWeights k s i) = 1
{Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ Ennreal} (h : âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) : s.sum (Î» (a : Î±), f a) < âŠ¤
{R : Type u_1} [CommRing R] [Fintype R] (p : â„•) [Fact (Nat.Prime p)] (hp : p âˆ£ Fintype.card R) : Â¬IsUnit â†‘p
{m : Type u} {Î± : Type v} [CommRing Î±] [Fintype m] [DecidableEq m] {M : Matrix m m Î±} (h : IsUnit M) (N : Matrix m m Î±) : ((Mâ»Â¹.mul N).mul M).det = N.det
{Î± : Type u_1} [topologicalSpace Î±] {x : Î±} {s : Set Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] [HasContinuousAdd Î³] {f g : Î± â†’ Î³} (hF : UpperSemicontinuousWithinAt f s x) (hg : UpperSemicontinuousWithinAt g s x) : UpperSemicontinuousWithinAt (Î» (z : Î±), f z + g z) s x
{u : â„• â†’ â„} {l : â„} (h : Filter.Tendsto u Filter.atTop (nhds l)) : Filter.Tendsto (Î» (n : â„•), (â†‘n)â»Â¹ * (Finset.range n).sum (Î» (i : â„•), u i)) Filter.atTop (nhds l)
{k : Type u_1} {V : Type u_2} [Ring k] [AddCommGroup V] [Module k V] {Î¹ : Type u_3} {p : Î¹ â†’ V} : AffineIndependent k p â†” âˆ€ (s : Finset Î¹) (w : Î¹ â†’ k), s.sum w = 0 â†’ s.sum (Î» (e : Î¹), w e â€¢ p e) = 0 â†’ âˆ€ (e : Î¹), e âˆˆ s â†’ w e = 0
{F : Type u_1} [Field F] {p : Polynomial F} (hp : p.separable) : Fintype.card p.gal = FiniteDimensional.finrank F p.splitting_Field
(S T : Set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension (S âˆª T) A B] : IsCyclotomicExtension T â†¥(Algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1}) B
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] {a : Î±} : -a â‰¤ 0 â†” 0 â‰¤ a
{R : Type u_1} [CommRing R] (P : Ideal (Polynomial R)) : Function.Injective â‡‘((Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.c P))) P).quotient_Map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.c P))) Ideal.le_comap_Map)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {s : Set E} {c : Nnreal} : LipschitzOnWith c (f - â‡‘f') s â†’ ApproximatesLinearOn f f' s c
{n p k : â„•} (hn : n â‰  0) (h : n.factorization = Finsupp.single p k) : n = p ^ k
(p q : â„•) [hp : Fact (Nat.Prime p)] (hq0 : â†‘q â‰  0) : (Finset.ico 1 (p / 2).succ).sum (Î» (a : â„•), a * q / p) + (Finset.ico 1 (q / 2).succ).sum (Î» (a : â„•), a * p / q) = p / 2 * (q / 2)
{Î± : Type u} {Î² : Type v} [Semiring Î±] [Semiring Î²] {f : Î± â†’ Î²} (hF : IsSemiringHom f) : IsAddMonoidHom f
{c w : â„‚} {R : â„} (hw : w âˆˆ Metric.Ball c R) : âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ = 2 * â†‘Real.pi * Complex.i
{Î± : Type u_1} {Î² : Type u_2} [completeLattice Î±] (a : Î±) (f : Î² â†’ Î±) : (â¨† (o : Option Î²), Option.elim a f o) = a âŠ” â¨† (b : Î²), f b
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} {s t : Set Î±} (h : s âŠ† t) : Emetric.infEdist x t â‰¤ Emetric.infEdist x s
{Î± : Type u_1} {Î² : Type u_2} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {K : Nnreal} {f : Î± â†’ Î²} : (âˆ€ (x y : Î±), HasDist.dist x y â‰¤ â†‘K * HasDist.dist (f x) (f y)) â†’ AntilipschitzWith K f
{R : Type u} [Semiring R] {P : Type (max u v)} [AddCommMonoid P] [Module R P] (huniv : âˆ€ {M : Type (max v u)} {N : Type (max u v)} [_inst_8 : AddCommMonoid M] [_inst_9 : AddCommMonoid N] [_inst_10 : Module R M] [_inst_11 : Module R N] (f : M â†’â‚—[R] N) (g : P â†’â‚—[R] N), Function.Surjective â‡‘f â†’ (âˆƒ (h : P â†’â‚—[R] M), f.comp h = g)) : Module.Projective R P
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (e : C â‰Œ D) : CategoryTheory.WellPowered C â†” CategoryTheory.WellPowered D
{Î± : Type u_1} [CommRing Î±] (E : LinearRecurrence Î±) (q : Î±) : E.is_solution (Î» (n : â„•), q ^ n) â†” E.char_poly.is_root q
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {R : â„} (h0 : 0 < R) {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball c R  s â†’ DifferentiableAt â„‚ f z) : âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = (2 * â†‘Real.pi * Complex.i) â€¢ f c
{Î± : Type u_1} {M : Type u_4} [CommMonoid M] (f : Î± â†’ M) {s t : Finset Î±} (h : s âŠ† t) : s.prod (Î» (i : Î±), f i) = t.prod (Î» (i : Î±), â†‘s.mul_indicator f i)
{a b : â„} (h : a < b) : Cardinal.mk â†¥(Set.Ioc a b) = Cardinal.continuum
{q : â„•+} : Fintype.card (LucasLehmer.X q) = â†‘q ^ 2
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : ContinuousAt f b) : HasStrictDerivAt (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) b
{Î± : Type u_1} [Preorder Î±] [locallyFiniteOrder Î±] {a b : Î±} : Â¬a â‰¤ b â†’ Finset.icc a b = âˆ…
 : WellFounded Nat.lt
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {K : Nnreal} {f : Î± â†’ Î²} : (âˆ€ (x y : Î±), HasDist.dist (f x) (f y) â‰¤ â†‘K * HasDist.dist x y) â†’ LipschitzWith K f
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B} (hx : IsIntegral A x) : (minpoly A x).monic
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLattice Î±] [SemilatticeSup Î²] {f g : Î² â†’ Î±} (hF : Monotone f) (hg : Antitone g) (h : f â‰¤ g) : (â¨† (n : Î²), f n) âˆˆ â‹‚ (n : Î²), Set.Icc (f n) (g n)
{M : Type u_3} [AddMonoid M] (L : List M) (h : L.sum â‰  0) : 0 < L.length
{Î¹ : Type u_1} {M : Type u_4} [orderedAddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M} : s.sum (Î» (i : Î¹), f i) = âŠ¤ â†” âˆƒ (i : Î¹) (H : i âˆˆ s), f i = âŠ¤
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [CommRing R] {p n : â„•} (hp : Nat.Prime p) : Polynomial.cyclotomic (p ^ (n + 1)) R = (Finset.range p).sum (Î» (i : â„•), (Polynomial.x ^ p ^ n) ^ i)
{cb : CharBuffer} {n n' val : â„•} : Parser.nat cb n = ParseResult.done n' val â†” âˆƒ (hn : n < n'), val = Nat.ofDigits 10 (List.map (Î» (c : Char), c.to_Nat - '0'.to_Nat) (List.take (n' - n) (List.drop n (Buffer.toList cb))).reverse) âˆ§ (âˆ€ (hn' : n' < Buffer.size cb), '0' â‰¤ Buffer.read cb âŸ¨n', hn'âŸ© â†’ '9' < Buffer.read cb âŸ¨n', hn'âŸ©) âˆ§ âˆƒ (hn'' : n' â‰¤ Buffer.size cb), âˆ€ (k : â„•) (hk : k < n'), n â‰¤ k â†’ '0' â‰¤ Buffer.read cb âŸ¨k, _âŸ© âˆ§ Buffer.read cb âŸ¨k, _âŸ© â‰¤ '9'
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (v : V) : G.min_degree â‰¤ G.degree v
{ð•œ : Type u_1} [is_R_or_C ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {r : â„} (r_nonneg : 0 â‰¤ r) {x : E} (hx : x â‰  0) : âˆ¥(â†‘r * (â†‘âˆ¥xâˆ¥)â»Â¹) â€¢ xâˆ¥ = r
{Î± : Type u_1} {Gâ‚€ : Type u_3} [groupWithZero Gâ‚€] [topologicalSpace Gâ‚€] [HasContinuousInvâ‚€ Gâ‚€] [HasContinuousMul Gâ‚€] {f g : Î± â†’ Gâ‚€} [topologicalSpace Î±] {a : Î±} (hF : ContinuousAt f a) (hg : ContinuousAt g a) (hâ‚€ : g a â‰  0) : ContinuousAt (f / g) a
{R : Type u_2} {Î“â‚€ : Type u_3} [linearOrderedAddCommMonoidWithTop Î“â‚€] [CommRing R] (v : addValuation R Î“â‚€) {J : Ideal R} (hJ : J â‰¤ v.supp) : (v.on_quot hJ).supp = Ideal.map (Ideal.Quotient.mk J) v.supp
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Î¹ : Type w} [Fintype Î¹] (h : Basis Î¹ K V) : FiniteDimensional.finrank K V = Fintype.card Î¹
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 âˆˆ s) : HasDist.dist p1 p2 * HasDist.dist p1 p2 = HasDist.dist p1 â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p2) * HasDist.dist p1 â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p2) + HasDist.dist p2 â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p2) * HasDist.dist p2 â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p2)
{Î± : Type u} [pseudoEmetricSpace Î±] {s : Set Î±} : Emetric.hausdorffEdist s (Closure s) = 0
{Î± : Type u_1} [PartialOrder Î±] [succOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ Set.Ico n m â†’ r i (Order.succ i)) (hnm : n â‰¤ m) : Relation.ReflTransGen r n m
{f : â„ â†’ â„} {a : â„} (h : is_is_IsLocalMax f a) : deriv f a = 0
{R : Type u} {Î¹ : Type w} (s : Finset Î¹) [CommSemiring R] (f : Î¹ â†’ Polynomial R) (h : s.prod (Î» (i : Î¹), (f i).leading_Coeff) â‰  0) : (s.prod (Î» (i : Î¹), f i)).nat_degree = s.sum (Î» (i : Î¹), (f i).nat_degree)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : P) (i : Fin 1) : (Affine.Simplex.mkOfPoint k p).points i = p
{k : Type u} [linearOrderedField k] {a : k} (ha : 0 < a) : (Set.Ioo 0 a)â»Â¹ = Set.Ioi aâ»Â¹
{Î± : Type u_1} {Î² : Type u_2} (e e' : LocalEquiv Î± Î²) (h : e â‰ˆ e') (s : e.source = Set.Univ) (t : e.target = Set.Univ) : e = e'
{ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [NormedGroup G] [normedSpace ð•œ G] {f : ð•œ â†’ G} {C : Nnreal} (hF : Differentiable ð•œ f) (bound : âˆ€ (x : ð•œ), âˆ¥deriv f xâˆ¥â‚Š â‰¤ C) : LipschitzWith C f
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [Preorder Î²] {a : Î±} {f : Î± â†’ Î²} (hâ‚ : StrictAntiOn f (Set.Iic a)) (hâ‚‚ : StrictAntiOn f (Set.Ici a)) : StrictAnti f
{R : Type u_1} {F : Type u_3} [AddCommGroup F] [topologicalSpace F] [TopologicalAddGroup F] [Ring R] [Module R F] [topologicalSpace R] [HasContinuousSmul R F] {p v : F} : Continuous â‡‘(AffineMap.lineMap p v)
{Î± : Type u_1} {s t : Set Î±} : s = t â†’ s âŠ† t
{M : Type u_3} {N : Type u_4} [hasMul M] [hasMul N] (f : M â†’â‚™* N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
{m n : â„•} (cop : m.coprime n) (hm : 1 < m) (hn : 1 < n) : IsFrobeniusNumber (m * n - m - n) {m, n}
{Î³ : Type w} [emetricSpace Î³] {x y : Î³} : HasEdist.edist x y = 0 â†” x = y
{p : â„•} [hp_Prime : Fact (Nat.Prime p)] {R : Type u_1} [NonAssocSemiring R] {f : Î  (k : â„•), R â†’+* Zmod(p ^ k)} (f_compat : âˆ€ (k1 k2 : â„•) (hk : k1 â‰¤ k2), (Zmod.castHom _ (Zmod(p ^ k1))).comp (f k2) = f k1) (g : R â†’+* â„¤_[p]) (hg : âˆ€ (n : â„•), (PadicInt.toZmodPow n).comp g = f n) : PadicInt.lift f_compat = g
{Î± : Type u_1} [DecidableEq Î±] (s : Multiset Î±) : s - 0 = s
{p n : â„•} (hp : Nat.Prime p) (HDiv : Â¬p âˆ£ n) (R : Type u_1) [CommRing R] : â‡‘(Polynomial.expand R p) (Polynomial.cyclotomic n R) = Polynomial.cyclotomic (n * p) R * Polynomial.cyclotomic n R
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {s : Set E} : Convex ð•œ s â†’ âˆ€ â¦ƒa b : ð•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ s + b â€¢ s âŠ† s
(R : Type u) [Field R] : IsField R
{M : Type u_1} [CommMonoid M] (f : â„• â†’ â„• â†’ M) (n : â„•) : (Finset.Nat.antidiagonal n).prod (Î» (ij : â„• Ã— â„•), f ij.fst ij.snd) = (Finset.range n.succ).prod (Î» (k : â„•), f k (n - k))
{M : Type u_1} [hasAdd M] (c : AddCon M) {x y : M} : â‡‘c x y â†’ â‡‘c y x
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} [AddCommGroup V] [Ring k] [Module k V] [Fintype Î¹] (b : AffineBasis Î¹ k V) (v : V) : finset.univ.sum (Î» (i : Î¹), â‡‘(b.coord i) v â€¢ b.points i) = v
{Î¹ : Type u_1} {V : Type u} [CategoryTheory.Category V] [CategoryTheory.Preadditive V] {c : ComplexShape Î¹} {C D : HomologicalComplex V c} {f g : C âŸ¶ D} [CategoryTheory.Limits.HasEqualizers V] [CategoryTheory.Limits.HasCokernels V] [CategoryTheory.Limits.HasImages V] [CategoryTheory.Limits.HasImageMaps V] [CategoryTheory.Limits.HasZeroObject V] (h : Homotopy f g) (i : Î¹) : (homologyFunctor V c i).map f = (homologyFunctor V c i).map g
{Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [orderedAddCommMonoid N] (f : M â†’ N) (h_One : f 0 = 0) (h_Mul : âˆ€ (x y : M), f (x + y) â‰¤ f x + f y) (s : Finset Î¹) (g : Î¹ â†’ M) : f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {E' : Type u_7} [innerProductSpace ð•œ E'] (f : E â‰ƒâ‚—áµ¢[ð•œ] E') (x y : E) : HasInner.inner (â‡‘f x) (â‡‘f y) = HasInner.inner x y
{Î± : Type u_1} {Î² : Type u_2} [Fintype Î±] (f : Î± â†’ Î²) [Fintype Î²] [DecidablePred (Î» (y : Î²), y âˆˆ Set.Range f)] [DecidableEq Î²] : Finset.filter (Î» (y : Î²), y âˆˆ Set.Range f) Finset.univ = Finset.image f Finset.univ
{Î¹ : Type u} {f : Î¹ â†’ Ordinal â†’ Ordinal} (H : âˆ€ (i : Î¹), Ordinal.IsNormal (f i)) : Set.Unbounded LT.lt (â‹‚ (i : Î¹), Function.FixedPoints (f i))
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) : Aâ»Â¹ = Ring.inverse A
{K : Type u} {V Vâ‚ : Type v} [Field K] [AddCommGroup V] [Module K V] [AddCommGroup Vâ‚] [Module K Vâ‚] (f : V â†’â‚—[K] Vâ‚) : Module.rank K â†¥(f.range) + Module.rank K â†¥(f.ker) = Module.rank K V
{X : Type u_2} [emetricSpace X] {s : Set X} (hs : s.countable) : dimH s = 0
{Î± : Type u_1} {Î² : Type u_4} [Preorder Î±] [Preorder Î²] {u : Î² â†’ Î±} (l : lowerAdjoint u) (x : Î±) : x â‰¤ u (â‡‘l x)
{Mâ‚€ : Type u_1} [monoidWithZero Mâ‚€] (x : Mâ‚€) (h : Â¬IsUnit x) : Ring.inverse x = 0
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [hasZero M] [CommMonoid N] (f : Î± â†’â‚€ M) (y : Î±) (g : Î± â†’ M â†’ N) (hyf : y âˆˆ f.support) : g y (â‡‘f y) * (Finsupp.erase y f).prod g = f.prod g
(x y z : Pgame) : ((x + y) * z).equiv (x * z + y * z)
{Î± : Type u} [HasSubset Î±] [hasSsubset Î±] [isNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {a b : Î±} (h : a âŠ† b) : Â¬b âŠ‚ a
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [orderedSemiring ð•œ] [AddCommGroup E] [Module ð•œ E] [Subsingleton Î¹] (p : Î¹ â†’ E) : ConvexIndependent ð•œ p
{Î± : sort u_1} (hH : Î±) {Î² : Prop} (x : Tactic.CalculatedProp Î² hH . "derive_reassoc_proof") : Î²
{F : Type u_1} [NormedGroup F] [normedSpace â„ F] (f : â„ â†’ F) [CompleteSpace F] : MeasurableSet {x : â„ | DifferentiableWithinAt â„ f (Set.Ici x) x}
(M : Type u_1) (Î± : Type u_2) [Group M] [mulAction M Î±] {P Q : Subgroup M} : MulAction.FixedPoints â†¥(P âŠ” Q) Î± = MulAction.FixedPoints â†¥P Î± âˆ© MulAction.FixedPoints â†¥Q Î±
{M : Type u_1} [MulOneClass M] {p : M â†’ Prop} (x : M) {s : Set M} (hs : Submonoid.closure s = âŠ¤) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (H1 : p 1) (HMul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) : p x
{Î± : Type u_2} [Monoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = c ^ 2) â†’ IsSquare m
{R : Type u_1} [CommRing R] (M : Submonoid R) (S : Type u_2) [CommRing S] [Algebra R S] {P : Type u_3} [CommRing P] [IsLocalization M S] (Q : Type u_5) [CommRing Q] {g : R â†’+* P} [Algebra P Q] (hg : Function.Injective â‡‘g) [IsLocalization (Submonoid.map â†‘g M) Q] (hM : Submonoid.map â†‘g M â‰¤ NonZeroDivisors P) : Function.Injective â‡‘(IsLocalization.map Q g _)
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} {N : Type u_7} [AddCommMonoid M] [AddCommMonoid N] (f : Î± â†’ Î²) (v : Î± â†’â‚€ M) (g : M â†’ N) (h0 : g 0 = 0) (HAdd : âˆ€ (x y : M), g (x + y) = g x + g y) : Finsupp.mapDomain f (Finsupp.mapRange g h0 v) = Finsupp.mapRange g h0 (Finsupp.mapDomain f v)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] (f : J â†’ C) [CategoryTheory.Limits.HasCoproduct f] : CategoryTheory.Limits.HasBiproduct f
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] [Nonempty Î²] (hb : Fintype.card Î² â€¢ b â‰¤ finset.univ.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²), b â‰¤ (Finset.filter (Î» (x : Î±), f x = y) Finset.univ).sum (Î» (x : Î±), w x)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (pâ‚ pâ‚‚ : P) : EuclideanGeometry.Cospherical {pâ‚, pâ‚‚}
 : goldenConjâ»Â¹ = -goldenRatio
{Î± : Type u} [topologicalSpace Î±] (a : Î±) : (nhds a).has_Basis (Î» (s : Set Î±), s âˆˆ nhds a âˆ§ is_IsOpen s) (Î» (x : Set Î±), x)
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] (s : Set X) : dimH s = â¨† (d : Nnreal) (hD : â‡‘(MeasureTheory.Measure.hausdorffMeasure â†‘d) s = âŠ¤), â†‘d
{M : Type u_1} [AddMonoid M] {s t : Set M} (ht : IsAddSubmonoid t) (h : s âŠ† t) : Add_monoid.closure s âŠ† t
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {G : C â¥¤ D} {K : CategoryTheory.GrothendieckTopology D} [CategoryTheory.Full G] [CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G) : CategoryTheory.CoverLifting Hld.induced_topology K G
{R : Type u_1} [linearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [FiniteDimensional R M] (xâ‚ xâ‚‚ : Orientation R M Î¹) (h : Fintype.card Î¹ = FiniteDimensional.finrank R M) : xâ‚ = xâ‚‚ âˆ¨ xâ‚ = -xâ‚‚
{Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Î± â†’ Set Î²} {x : Î±} (xs : x âˆˆ s) : (â‹‚ (x : Î±) (H : x âˆˆ s), t x) âŠ† t x
{Î± : Type u_1} {s t : Set Î±} : (s âˆ© t).nonempty â†’ Â¬Disjoint s t
{R : Type u_1} {S : Type u_2} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] [Semiring S] (f : R â†’+* S) (s : Submonoid S) (a : R) (ha : a â‰  0) (h : âˆ€ (b : R), b âˆˆ PrincipalIdealRing.factors a â†’ â‡‘f b âˆˆ s) (hF : âˆ€ (c : RË£), â‡‘f â†‘c âˆˆ s) : â‡‘f a âˆˆ s
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [normedSpace ð•œ E] [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {x : E} {f' : E â†’ (E â†’L[ð•œ] G)} (hs : Convex â„ s) {f : E â†’ G} (hder : âˆ€á¶  (y : E) in nhdsWithin x s, HasFderivWithinAt f (f' y) s y) (hcont : ContinuousWithinAt f' s x) (K : Nnreal) (hK : âˆ¥f' xâˆ¥â‚Š < K) : âˆƒ (t : Set E) (H : t âˆˆ nhdsWithin x s), LipschitzOnWith K f t
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] {f : â„ â†’ E} {T : â„} (hF : Function.Periodic f T) (n : â„¤) (t : â„) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable f MeasureTheory.MeasureSpace.volume tâ‚ tâ‚‚) : âˆ« (x : â„) in t..t + n â€¢ T, f x = n â€¢ âˆ« (x : â„) in t..t + T, f x
{Î± : Type u} [Preorder Î±] [NoMinOrder Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), StrictAnti f âˆ§ f 0 = a
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a : Î±} : 0 < -a â†” a < 0
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {f : V â‰ƒâ‚—áµ¢[â„] V} (hD : 0 < â‡‘LinearMap.det â†‘(f.to_linearEquiv)) : âˆƒ (Î¸ : Real.Angle), f = hb.rotation Î¸
{C : Type uâ‚} [CategoryTheory.Category C] {A : C} (hA : CategoryTheory.IsSubterminal A) {T : C} (hT : CategoryTheory.Limits.IsTerminal T) : CategoryTheory.Mono (hT.from A)
{Î± : Type u_1} {Î¹ : Type u_2} (m : MeasureTheory.OuterMeasure Î±) {s : Î¹ â†’ Set Î±} (l : Filter Î¹) [l.ne_IsBot] (h0 : Filter.Tendsto (Î» (k : Î¹), â‡‘m ((â‹ƒ (n : Î¹), s n)  s k)) l (nhds 0)) : â‡‘m (â‹ƒ (n : Î¹), s n) = â¨† (n : Î¹), â‡‘m (s n)
{M : Type u_1} [MulOneClass M] {Î¹ : sort u_2} (S : Î¹ â†’ Submonoid M) {C : Î  (x : M), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : M) (H : x âˆˆ S i), C x _) (h1 : C 1 _) (HMul : âˆ€ (x y : M) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x * y) _) {x : M} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
{M : Type u_1} [Monoid M] (s : Submonoid M) {l : List M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.prod âˆˆ s
{Î± : Type u_1} {s : Finset Î±} : s.nonempty â†’ â†‘s.nonempty
(x y z : Pgame) : (x * y * z).equiv (x * (y * z))
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {Î´ : outParam (sort u_4)} [hasCoe Î± Î²] [hasCoe_t_aux Î² Î³] [hasCoeToFun Î³ (Î» (_x : Î³), Î´)] (x : Î±) : â‡‘x = â‡‘â†‘x
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (hn : x â‰  y) (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : hb.oangle y x = â†‘Real.pi - 2 â€¢ hb.oangle (y - x) y
(R : Type u) (M : Type v) (N : Type w) [CommRing R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [AddCommGroup N] [Module R N] [Module.Free R N] [Module.Finite R N] : FiniteDimensional.finrank R (M â†’â‚—[R] N) = FiniteDimensional.finrank R M * FiniteDimensional.finrank R N
{H : Type u} [topologicalSpace H] (G : StructureGroupoid H) : ClosedUnderRestriction G â†” idRestrGroupoid â‰¤ G
{R : Type u_1} {M : Type u_2} {Râ‚‚ : Type u_3} {Mâ‚‚ : Type u_4} [Ring R] [Ring Râ‚‚] [AddCommMonoid M] [AddCommGroup Mâ‚‚] [Module R M] [Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [RingHomSurjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} (h : âˆ€ (u v : Mâ‚‚ â†’â‚—[Râ‚‚] Mâ‚‚ â§¸ f.range), u.comp f = v.comp f â†’ u = v) : f.range = âŠ¤
{M : Type u_1} [AddCommGroup M] [Module â„‚ M] [FiniteDimensional â„‚ M] (Qâ‚ Qâ‚‚ : QuadraticForm â„‚ M) (hQâ‚ : (â‡‘QuadraticForm.associated Qâ‚).nondegenerate) (hQâ‚‚ : (â‡‘QuadraticForm.associated Qâ‚‚).nondegenerate) : Qâ‚.equivalent Qâ‚‚
{J : Type u} [CategoryTheory.SmallCategory J] (F : J â¥¤ Top) [CategoryTheory.IsCofiltered J] [âˆ€ (j : J), Nonempty â†¥(F.obj j)] [âˆ€ (j : J), CompactSpace â†¥(F.obj j)] [âˆ€ (j : J), t2_Space â†¥(F.obj j)] : Nonempty â†¥((Top.limitCone F).X)
{R : Type u_1} {a b : R} [AddSemigroup R] (Ab : IsAddRightRegular (b + a)) : IsAddRightRegular b
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] {s : Set Î±} {t : Set Î²} (hs : Dense s) (ht : Dense t) : Dense (s Ã—Ë¢ t)
{R : Type u_1} [CommRing R] [is_IsDomain R] [NormalizedGcdMonoid R] {K : Type u_2} [Field K] [Algebra R K] [IsFractionRing R K] {p : Polynomial R} (hp : p.is_primitive) : Irreducible p â†” Irreducible (Polynomial.map (algebraMap R K) p)
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topologicalSpace B] [topologicalSpace F] (Z : TopologicalFiberBundleCore Î¹ B F) (b : B) : Continuous (Bundle.totalSpaceMk b)
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (hs : is_IsCompact s) {e : â„} (hE : 0 < e) : âˆƒ (t : Set Î±) (H : t âŠ† s), t.finite âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), Metric.Ball x e
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] (M : Submodule R A) {C : A â†’ Prop} (hr : âˆ€ (r : R), C (â‡‘(algebraMap R A) r)) (HAdd : âˆ€ (x y : A), C x â†’ C y â†’ C (x + y)) (HMul : âˆ€ (x : A), C x â†’ âˆ€ (m : A), m âˆˆ M â†’ C (x * m)) {x : A} {n : â„•} (hx : x âˆˆ M ^ n) : C x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] {F G : Top.Sheaf C X} (f : F âŸ¶ G) (U : TopologicalSpace.Opens â†¥X) (hinj : âˆ€ (x : â†¥U), Function.Injective â‡‘((Top.Presheaf.stalkFunctor C x.val).map f)) (hsurj : âˆ€ (t : â†¥(G.val.obj (Opposite.op U))) (x : â†¥U), âˆƒ (V : TopologicalSpace.Opens â†¥X) (m : x.val âˆˆ V) (iVU : V âŸ¶ U) (s : â†¥(F.val.obj (Opposite.op V))), â‡‘(f.app (Opposite.op V)) s = â‡‘(G.val.map iVU.op) t) : Function.Surjective â‡‘(f.app (Opposite.op U))
{R : Type u_1} [CommSemiring R] {X : Type u_2} {A : Type u_3} [Semiring A] [Algebra R A] {f g : FreeAlgebra R X â†’â‚[R] A} (w : â‡‘f âˆ˜ FreeAlgebraÎ¹ R = â‡‘g âˆ˜ FreeAlgebraÎ¹ R) : f = g
(Î± : Type u) [Preorder Î±] [Nonempty Î±] [NoMinOrder Î±] [NoMaxOrder Î±] : âˆƒ (f : â„¤ â†’ Î±), StrictMono f
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} : Function.Commute â‡‘CliffordAlgebra.reverse â‡‘CliffordAlgebra.involute
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R M) {w : Î¹ â†’ R} (hw : âˆ€ (i : Î¹), IsUnit (w i)) : â‡‘(e.det) â‡‘(e.is_Unit_Smul hw) = finset.univ.prod (Î» (i : Î¹), w i)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : â†‘r < p.radius) : âˆƒ (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [divisionMonoid Î²] (f : Î± â†’* Î²) (g h : Î±) : â‡‘f (g / h) = â‡‘f g / â‡‘f h
{Î± : sort u_1} {Î² : sort u_2} (f : Î± â†’ Î²) : Nonempty Î± â†’ Nonempty Î²
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {J' : Type uâ‚‚} [CategoryTheory.Category J'] (e : J â‰Œ J') [CategoryTheory.Limits.HasColimitsOfShape J C] : CategoryTheory.Limits.HasColimitsOfShape J' C
{c : â„} (h1 : 0 < c) (h2 : c < 1 / 2) {n : â„•} {f g : â„• â†’ Bool} (hn : âˆ€ (k : â„•), k < n â†’ f k = g k) (fn : f n = bool.ff) (gn : g n = bool.tt) : Cardinal.cantorFunction c f < Cardinal.cantorFunction c g
{F : Type u_1} [NormedGroup F] [normedSpace â„ F] {f : â„ â†’ F} {K : Set F} (hK : IsComplete K) : RightDerivMeasurableAux.D f K âŠ† {x : â„ | DifferentiableWithinAt â„ f (Set.Ici x) x âˆ§ derivWithin f (Set.Ici x) x âˆˆ K}
{b : â„•} {l : List â„•} (hb : 2 â‰¤ b) (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b) : Nat.ofDigits b l < b ^ l.length
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [NormedGroup F] [normedSpace â„ F] {x : E} {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€á¶  (y : E) in nhds x, HasFderivAt f (f' y) y) (hx : HasFderivAt f' f'' x) (v w : E) : â‡‘(â‡‘f'' v) w = â‡‘(â‡‘f'' w) v
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {f : Î± â†’ Î²} (hF : âˆ€ (x y : Î±), f (x * y) = f x * f y) : IsGroupHom f
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i j : Fin (n + 2)} (H : i â‰¤ j) : X.Î´ i â‰« X.Î´ j.succ = X.Î´ j â‰« X.Î´ (â‡‘fin.cast_Succ i)
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (h : 0 < r * (b - a)) : f (â‡‘(AffineMap.lineMap a b) r) â‰¤ â‡‘(AffineMap.lineMap (f a) (f b)) r â†” slope f a (â‡‘(AffineMap.lineMap a b) r) â‰¤ slope f a b
{f : â„ â†’ â„} (hF' : âˆ€ (x : â„), deriv f x < 0) : StrictAnti f
{Î± : Type u_1} {E : Type u_2} {m mâ‚‚ : measurableSpace Î±} [topologicalSpace E] [hasZero E] {s : Set Î±} {f : Î± â†’ E} (hs_m : MeasurableSet s) (hs : âˆ€ (t : Set Î±), MeasurableSet (s âˆ© t) â†’ MeasurableSet (s âˆ© t)) (hF : MeasureTheory.StronglyMeasurable f) (hF_Zero : âˆ€ (x : Î±), x âˆ‰ s â†’ f x = 0) : MeasureTheory.StronglyMeasurable f
{f : â„ â†’ â„} (hF' : âˆ€ (x : â„), 0 < deriv f x) : StrictMono f
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] (M : Submodule R A) {C : A â†’ Prop} (hr : âˆ€ (r : R), C (â‡‘(algebraMap R A) r)) (HAdd : âˆ€ (x y : A), C x â†’ C y â†’ C (x + y)) (HMul : âˆ€ (m : A), m âˆˆ M â†’ âˆ€ (x : A), C x â†’ C (m * x)) {x : A} {n : â„•} (hx : x âˆˆ M ^ n) : C x
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [AddCommMonoid M] {s : Set Î±} {t : Set Î²} {f : Î± â†’ M} {g : Î² â†’ M} (e : Î± â†’ Î²) (hEâ‚€ : Set.BijOn e s t) (hEâ‚ : âˆ€ (x : Î±), x âˆˆ s â†’ f x = g (e x)) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ t), g j))
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {F F' : C â¥¤ D} (h : F â‰… F') : F.ess_image = F'.ess_image
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (x : E) (hg : ContDiffWithinAt ð•œ n g t (f x)) (hF : ContDiffWithinAt ð•œ n f s x) : ContDiffWithinAt ð•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t) x
{Î± : Type u_1} [pseudoEmetricSpace Î±] (r C : Ennreal) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (f n) (f (n + 1)) â‰¤ C * r ^ n) {a : Î±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) : HasEdist.edist (f 0) a â‰¤ C / (1 - r)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [AddCommMonoid Î±] [topologicalSpace Î±] {f : Î² â†’ Î±} [AddCommMonoid Î³] [topologicalSpace Î³] {G : Type u_4} [addEquivClass G Î± Î³] (g : G) (hg : Continuous â‡‘g) (hg' : Continuous (AddEquivClass.inv g)) : Summable (â‡‘g âˆ˜ f) â†” Summable f
{G : Type u} [AddGroup G] (a x : G) : AddSemiconjBy a x (a + x + -a)
{Î² : Type u_2} [AddCommMonoid Î²] (f : Fin 0 â†’ Î²) : finset.univ.sum (Î» (i : Fin 0), f i) = 0
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] [LocallyCompactSpace Î²] (f : C(Î±, C(Î², Î³))) : Continuous (Function.uncurry (Î» (x : Î±) (y : Î²), â‡‘(â‡‘f x) y))
(c : Turing.ToPartrec.Code) (k : turing.partrec_to_tm2.cont') : turing.TM2.supports turing.partrec_to_tm2.tr (turing.partrec_to_tm2.code_supp c k)
{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) {P : Î  (x : CliffordAlgebra Q), x âˆˆ CliffordAlgebra.evenOdd Q 0 â†’ Prop} (hr : âˆ€ (r : R), P (â‡‘(algebraMap R (CliffordAlgebra Q)) r) _) (HAdd : âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 0}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_Mul : âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 0}, P x hx â†’ P (â‡‘(CliffordAlgebraÎ¹ Q) mâ‚ * â‡‘(CliffordAlgebraÎ¹ Q) mâ‚‚ * x) _) (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 0) : P x hx
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} (f : Î± â†’ Î² â†’ Î³) (P : Prop) [Decidable P] (a : P â†’ Î±) (b : Â¬P â†’ Î±) (c : P â†’ Î²) (d : Â¬P â†’ Î²) : f (dite P a b) (dite P c d) = dite P (Î» (h : P), f (a h) (c h)) (Î» (h : Â¬P), f (b h) (d h))
{Î± : Type u_1} [hasLt Î±] {a b : Î±áµ’áµˆ} : b â‹– a â†’ â‡‘OrderDual.ofDual a â‹– â‡‘OrderDual.ofDual b
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a : Î±} {s : Set Î±} (hl : âˆƒ (l : Î±), l < a) (hu : âˆƒ (u : Î±), a < u) : s âˆˆ nhds a â†” âˆƒ (l u : Î±), a âˆˆ Set.Ioo l u âˆ§ Set.Ioo l u âŠ† s
{S : Type u} [AddSemigroup S] {a x y x' y' : S} (h : AddSemiconjBy a x y) (h' : AddSemiconjBy a x' y') : AddSemiconjBy a (x + x') (y + y')
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [pseudoEmetricSpace Î±] [pseudoEmetricSpace Î²] [pseudoEmetricSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : Isometry g) (hF : Isometry f) : Isometry (g âˆ˜ f)
{Î± : Type u_1} [completeLattice Î±] [IsCompactlyGenerated Î±] {a : Î±} {s : Set Î±} (h : DirectedOn LE.le s) : a âŠ“ HasSup.sup s = â¨† (b : Î±) (H : b âˆˆ s), a âŠ“ b
{Î± : Type u} [topologicalSpace Î±] {x : Î±} : ConnectedComponent x âŠ† â‹‚ (Z : {Z // is_IsClopen Z âˆ§ x âˆˆ Z}), â†‘Z
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : Function.Injective coeFn
{H : Type u_1} [topologicalSpace H] [LocallyCompactSpace H] [t2_Space H] : TotallyDisconnectedSpace H â†” TotallySeparatedSpace H
{G : Type u_1} {P : Type u_2} [AddGroup G] [addTorsor G P] {x y : P} (h : Function.Injective bit0) : â‡‘(equiv.point_reflection x) y = y â†” y = x
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {E' : Type u_7} [innerProductSpace ð•œ E'] {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (f : E â†’â‚—áµ¢[ð•œ] E') : Orthonormal ð•œ (â‡‘f âˆ˜ v)
{C : Type u} [CategoryTheory.Category C] {Jâ‚ Jâ‚‚ : CategoryTheory.GrothendieckTopology C} (h : â‡‘Jâ‚ = â‡‘Jâ‚‚) : Jâ‚ = Jâ‚‚
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {f : Î± â†’ Î²} (hF : IsRingHom f) : IsSemiringHom f
{Î± : Type u_1} [HasLe Î±] {a b : Î±áµ’áµˆ} : b â‰¤ a â†’ â‡‘OrderDual.ofDual a â‰¤ â‡‘OrderDual.ofDual b
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {f : V â‰ƒâ‚—áµ¢[â„] V} (hD : 0 < â‡‘LinearMap.det â†‘(f.to_linearEquiv)) : âˆƒ (Î¸ : Real.Angle), f = o.rotation Î¸
{V : Type u_1} [innerProductSpace â„ V] (x y : V) (h : InnerProductGeometry.angle x y = Real.pi / 2) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
(R : Type u) [CommRing R] [is_IsDomain R] : DiscreteValuationRing R â†” IsPrincipalIdealRing R âˆ§ âˆƒ! (P : Ideal R), P â‰  âŠ¥ âˆ§ P.is_Prime
{Î³ : Type w} [SemilatticeInf Î³] {aâ‚ aâ‚‚ : Î³} {s t : Set Î³} (hs : IsGlb s aâ‚) (ht : IsGlb t aâ‚‚) : IsGlb (s âˆª t) (aâ‚ âŠ“ aâ‚‚)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ F} {f' : E â†’L[ð•œ] F} (x : E) {g : F â†’ G} {g' : F â†’L[ð•œ] G} (hg : HasFderivAt g g' (f x)) (hF : HasFderivAt f f' x) : HasFderivAt (g âˆ˜ f) (g'.comp f') x
{M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_1} [hasOne M] [hasOne N] [hasOne P] [hasOne Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q) : (h.comp g).comp f = h.comp (g.comp f)
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (t : CategoryTheory.Limits.IsTerminal X) (f g : Y âŸ¶ X) : f = g
{Î¹ : Type u_1} {X : Type u_2} [topologicalSpace X] [NormalSpace X] {u : Î¹ â†’ Set X} {s : Set X} (hs : is_IsClosed s) (uo : âˆ€ (i : Î¹), is_IsOpen (u i)) (uf : âˆ€ (x : X), x âˆˆ s â†’ {i : Î¹ | x âˆˆ u i}.finite) (us : s âŠ† â‹ƒ (i : Î¹), u i) : âˆƒ (v : Î¹ â†’ Set X), s âŠ† Set.Union v âˆ§ (âˆ€ (i : Î¹), is_IsClosed (v i)) âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
 : IsAbsoluteValue.uniformSpace HasAbs.abs = PseudoMetricSpace.toUniformSpace
{Î± : Type u_1} [topologicalSpace Î±] [PartialOrder Î±] {s : Set Î±} [TopologicalSpace.SeparableSpace â†¥s] (hs : Dense s) : âˆƒ (t : Set Î±) (H : t âŠ† s), t.countable âˆ§ Dense t âˆ§ (âˆ€ (x : Î±), IsBot x â†’ x âˆˆ s â†’ x âˆˆ t) âˆ§ âˆ€ (x : Î±), IsTop x â†’ x âˆˆ s â†’ x âˆˆ t
{Î± : Type u} [HasSubset Î±] [hasSsubset Î±] [isNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {a b : Î±} (h : a âŠ‚ b) : a âŠ† b
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {s t : CategoryTheory.Limits.Cone F} (P : CategoryTheory.Limits.IsLimit s) (Q : CategoryTheory.Limits.IsLimit t) (f : s âŸ¶ t) : CategoryTheory.IsIso f
(n : â„•) : ConvexOn â„ (Set.Ici 0) (Î» (x : â„), x ^ n)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’sl[Ïƒâ‚â‚‚] F) (x : E) : âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace E] {f : E â†’ F} {f' : E â†’ (E â‰ƒL[ð•œ] F)} (hF : âˆ€ (x : E), HasStrictFderivAt f â†‘(f' x) x) : is_is_IsOpenMap f
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {ps : Set P} {n : â„•} [FiniteDimensional â„ V] (hD : FiniteDimensional.finrank â„ V = n) (hc : EuclideanGeometry.Cospherical ps) : âˆƒ (r : â„), âˆ€ (sx : Affine.Simplex â„ P n), Set.Range sx.points âŠ† ps â†’ sx.circumradius = r
{A : Type u_1} {B : Type u_2} [CommRing A] [is_IsDomain A] [Ring B] [Algebra A B] {x : B} {a : Polynomial A} (hx : IsIntegral A x) (hamonic : a.monic) (hdvd : DvdNotUnit a (minpoly A x)) : â‡‘(Polynomial.aeval x) a â‰  0
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} {C : CliffordAlgebra Q â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(algebraMap R (CliffordAlgebra Q)) r)) (h_grade1 : âˆ€ (x : M), C (â‡‘(CliffordAlgebraÎ¹ Q) x)) (h_Mul : âˆ€ (a b : CliffordAlgebra Q), C a â†’ C b â†’ C (a * b)) (h_Add : âˆ€ (a b : CliffordAlgebra Q), C a â†’ C b â†’ C (a + b)) (a : CliffordAlgebra Q) : C a
{p : NatOrdinal â†’ Prop} (i : NatOrdinal) (h : âˆ€ (j : NatOrdinal), (âˆ€ (k : NatOrdinal), k < j â†’ p k) â†’ p j) : p i
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) {r : â„} (hr : r â‰  0) : 2 â€¢ o.oangle x (r â€¢ y) = 2 â€¢ o.oangle x y
{Î± : Type u} [pseudoMetricSpace Î±] {x : Î±} : Metric.Bounded {x}
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hst : Disjoint (s âˆ© Function.MulSupport f) (t âˆ© Function.MulSupport f)) (hs : (s âˆ© Function.MulSupport f).finite) (ht : (t âˆ© Function.MulSupport f).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
{R : Type u_1} [CommRing R] {xâ‚ xâ‚‚ yâ‚ yâ‚‚ : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2
{Î± : Type u} [pseudoMetricSpace Î±] {f : Î± â†’ â„} (K : â„) (h : âˆ€ (x y : Î±), f x â‰¤ f y + K * HasDist.dist x y) : LipschitzWith K.to_Nnreal f
(n a : â„•) (p : â„• â†’ Prop) [DecidablePred p] (pp : Function.Periodic p a) : â‡‘Multiset.card (Multiset.filter p (Multiset.ico n (n + a))) = Nat.count p a
{Î± : Type u_1} [Semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x * x) âˆ˜ Î» (_x : Î±), _x * y) = Î» (_x : Î±), _x * (y * x)
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C â¥¤ D} (H : CategoryTheory.CoverDense K G) [CategoryTheory.Full G] {â„± : Dáµ’áµ– â¥¤ A} {â„±' : CategoryTheory.Sheaf K A} (Î± : G.op â‹™ â„± âŸ¶ G.op â‹™ â„±'.val) : CategoryTheory.whiskerLeft G.op (H.sheaf_hom Î±) = Î±
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] [h : group.is_nilpotent G] (f : G â†’* G') (hF : Function.Surjective â‡‘f) : group.is_nilpotent G'
{ð•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_8} {Pâ‚‚ : Type u_9} [normedField ð•œ] [semiNormedGroup V] [semiNormedGroup Vâ‚‚] [normedSpace ð•œ V] [normedSpace ð•œ Vâ‚‚] [pseudoMetricSpace P] [pseudoMetricSpace Pâ‚‚] [NormedAddTorsor V P] [NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’ Pâ‚‚} (hF : Isometry f) {p : P} {g : V â†’ Vâ‚‚} (hg : âˆ€ (v : V), g v = f (v +áµ¥ p) -áµ¥ f p) : Isometry g
{Î¹ : Type u_1} {R : Type u_8} [OrderedCommSemiring R] {f : Î¹ â†’ R} {s : Finset Î¹} (h0 : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ f i) (h1 : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰¤ 1) : s.prod (Î» (i : Î¹), f i) â‰¤ 1
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {A : Set E} {x : E} : x âˆˆ Set.ExtremePoints ð•œ A â†” IsExtreme ð•œ A {x}
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : hb.oangle y (â‡‘(hb.rotation (hb.oangle x y)) x) = 0
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] [NormalSpace Y] (f : boundedContinuousFunction X â„) {a b : â„} {e : X â†’ Y} (hF : âˆ€ (x : X), â‡‘f x âˆˆ Set.Icc a b) (hle : a â‰¤ b) (hE : ClosedEmbedding e) : âˆƒ (g : boundedContinuousFunction Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ Set.Icc a b) âˆ§ â‡‘g âˆ˜ e = â‡‘f
{R S : Type u} [CommRing R] [CommRing S] (M : Submonoid R) (S' : Type u) [CommRing S'] [Algebra S S'] [Algebra R S] [Algebra R S'] [isScalarTower R S S'] [IsLocalization (Submonoid.map â†‘(algebraMap R S) M) S'] (x : S) (s : Finset S') (hx : â‡‘(algebraMap S S') x âˆˆ Submodule.span R â†‘s) : âˆƒ (m : â†¥M), m â€¢ x âˆˆ Submodule.span R â†‘(IsLocalization.finsetIntegerMultiple (Submonoid.map â†‘(algebraMap R S) M) s)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] (Î¹ : Type u_2) [Fintype Î¹] (E : Î¹ â†’ Type u_3) [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] (s : Î  (i : Î¹), Set (E i)) (h : âˆ€ (i : Î¹), UniqueDiffOn ð•œ (s i)) : UniqueDiffOn ð•œ (set.univ.pi s)
(x : â„‚) : HasDerivAt Complex.exp (Complex.exp x) x
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : D â¥¤ C) (Y : D) : F.obj Y âˆˆ F.ess_image
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) : hb.oangle x 0 = 0
{G : Type u} [Group G] [Fintype G] {p : â„•} [hp : Fact (Nat.Prime p)] (P : Sylow p G) : (Fintype.card â†¥P).coprime â†‘P.index
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [h : Subsingleton V] : FiniteDimensional.finrank K V = 0
(X : Top) (T : â†¥X â†’ Type u) : (X.presheaf_to_Types T).is_sheaf
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a : Î±) : â‡‘f (bit0 a) = bit0 (â‡‘f a)
{Î± : Type u} [t : topologicalSpace Î±] {Î¹ : Type u_1} [Encodable Î¹] {U : Î¹ â†’ Set Î±} [âˆ€ (i : Î¹), TopologicalSpace.SecondCountableTopology â†¥(U i)] (Uo : âˆ€ (i : Î¹), is_IsOpen (U i)) (hc : (â‹ƒ (i : Î¹), U i) = Set.Univ) : TopologicalSpace.SecondCountableTopology Î±
(S : Set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [is_IsDomain B] [hâ‚ : Fintype â†¥S] [hâ‚‚ : IsCyclotomicExtension S A B] : Module.Finite A B
 : Primrec (Î» (a : (â„• Ã— Nat.Partrec.Code) Ã— â„•), Nat.Partrec.Code.evaln a.fst.fst a.fst.snd a.snd)
{Î± : Type u} [pseudoEmetricSpace Î±] (B : â„• â†’ Ennreal) (hB : âˆ€ (n : â„•), 0 < B n) (H : âˆ€ (u : â„• â†’ Î±), (âˆ€ (N n m : â„•), N â‰¤ n â†’ N â‰¤ m â†’ HasEdist.edist (u n) (u m) < B N) â†’ (âˆƒ (x : Î±), Filter.Tendsto u Filter.atTop (nhds x))) : CompleteSpace Î±
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (e : localHomeomorph Î± Î²) : e.trans e.symm â‰ˆ LocalHomeomorph.ofSet e.to_local_equiv.source _
{n : Type u} [DecidableEq n] [Fintype n] {R : Type v} [linearOrderedCommRing R] (g : Matrix.SpecialLinearGroup n R) : â†‘â†‘â†‘g = â†‘g
{B : Type u_3} (Eâ‚ : B â†’ Type u_6) (Eâ‚‚ : B â†’ Type u_7) [topologicalSpace (Bundle.TotalSpace Eâ‚)] [topologicalSpace (Bundle.TotalSpace Eâ‚‚)] : Inducing (Î» (p : Bundle.TotalSpace (Î» (x : B), Eâ‚ x Ã— Eâ‚‚ x)), (âŸ¨p.fst, p.snd.fstâŸ©, âŸ¨p.fst, p.snd.sndâŸ©))
(n : â„•) : n.totient * n.factors.to_finset.prod (Î» (p : â„•), p) = n * n.factors.to_finset.prod (Î» (p : â„•), p - 1)
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a : Î±} {s : Set Î±} (ha : IsGlb s a) (hs : s.nonempty) (sc : is_IsClosed s) : a âˆˆ s
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u_3} [CategoryTheory.Category D] [CategoryTheory.Preadditive D] (G : C â¥¤ D) [G.additive] (X : CategoryTheory.SimplicialObject C) (q n m : â„•) (hnm : algebraic_topology.dold_kan.c.rel m n) : algebraic_topology.dold_kan.hÏƒ' q n m hnm = G.map (algebraic_topology.dold_kan.hÏƒ' q n m hnm)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : â„•} {i j : Fin (n + 1)} (H : i â‰¤ j) : X.Ïƒ j â‰« X.Ïƒ (â‡‘fin.cast_Succ i) = X.Ïƒ i â‰« X.Ïƒ j.succ
(a : Ordinal) : âˆƒ (f : Î  (b : Ordinal), b < a.cof.ord â†’ Ordinal), a.is_fundamental_sequence a.cof.ord f
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±} [topologicalSpace Î±] (h : TendstoLocallyUniformlyOn F f p s) (hF : ContinuousWithinAt f s x) (hx : x âˆˆ s) (hg : Filter.Tendsto g p (nhdsWithin x s)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f g : Î± â†’ M} (hF : (Function.Support f).finite) (hg : (Function.Support g).finite) : finsum (Î» (i : Î±), f i + g i) = finsum (Î» (i : Î±), f i) + finsum (Î» (i : Î±), g i)
(k : â„¤) {b : â„} (hb : 0 < b) : (Î» (x : â„), x ^ k) =o[Filter.atTop] Î» (x : â„), Real.exp (b * x)
{Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [DecidableRel R] {l : List Î±} : List.Pairwise R l â†’ List.pwFilter R l = l
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (h : Î² â†’ Î³) (g : Î± â†’ Î²) (l : List Î±) : List.map (h âˆ˜ g) l = List.map h (List.map g l)
{C : Type u} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type v} (Ps : Set (Cáµ’áµ– â¥¤ Type v)) (h : P âˆˆ Ps) : CategoryTheory.Presieve.IsSheaf (CategoryTheory.Sheaf.finestTopology Ps) P
{x : â„} (hx : x â‰¤ 0) : expNegInvGlue x = 0
{C : Type uâ‚} [CategoryTheory.Category C] (X : Type vâ‚) [CategoryTheory.Limits.HasCoproductsOfShape X C] : CategoryTheory.Limits.HasProductsOfShape X Cáµ’áµ–
{Î± : Type u_1} {f g : â„• â†’ Î±} [topologicalSpace Î±] [NonUnitalNonAssocSemiring Î±] [RegularSpace Î±] [TopologicalSemiring Î±] (hF : Summable f) (hg : Summable g) (hfg : Summable (Î» (x : â„• Ã— â„•), f x.fst * g x.snd)) : (âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (Finset.range (n + 1)).sum (Î» (k : â„•), f k * g (n - k))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {fâ‚‚ : ð•œ â†’ F} : ContDiff ð•œ âŠ¤ fâ‚‚ â†” Differentiable ð•œ fâ‚‚ âˆ§ ContDiff ð•œ âŠ¤ (deriv fâ‚‚)
{G : Type u_1} [Group G] {H : Subgroup G} [hG : group.fg G] (hH : H.index â‰  0) : group.fg â†¥H
 : Filter.Tendsto (Î» (k : â„•), (Finset.range k).prod (Î» (i : â„•), (2 * â†‘i + 2) / (2 * â†‘i + 1) * ((2 * â†‘i + 2) / (2 * â†‘i + 3)))) Filter.atTop (nhds (Real.pi / 2))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : E â†’ F} {g : G â†’L[ð•œ] E} (hF : ContDiff ð•œ n f) : ContDiff ð•œ n (f âˆ˜ â‡‘g)
{Î± : Type u} [pseudoEmetricSpace Î±] (E : Set Î±) : Metric.Cthickening 0 E = Closure E
{S : Set Ordinal} (o : Ordinal) : Ordinal.enumOrd S o = HasInf.inf (S âˆ© Set.Ici (o.blsub (Î» (a : Ordinal) (_x : a < o), Ordinal.enumOrd S a)))
{M : Type u_1} [AddCommGroup M] [Module â„ M] [FiniteDimensional â„ M] (Q : QuadraticForm â„ M) : âˆƒ (w : Fin (FiniteDimensional.finrank â„ M) â†’ â„), (âˆ€ (i : Fin (FiniteDimensional.finrank â„ M)), w i = -1 âˆ¨ w i = 0 âˆ¨ w i = 1) âˆ§ Q.equivalent (QuadraticForm.weightedSumSquares â„ w)
{G : AddSubgroup â„} {gâ‚€ : â„} (gâ‚€_in : gâ‚€ âˆˆ G) (gâ‚€_NE : gâ‚€ â‰  0) (H' : Â¬âˆƒ (a : â„), IsLeast {g : â„ | g âˆˆ G âˆ§ 0 < g} a) : Dense â†‘G
{R : Type u_1} [CommRing R] [Nontrivial R] {M : Ideal R} (max : M.is_Maximal) (not_IsField : Â¬IsField R) : M â‰  âŠ¥
{Î¹a : Type u_7} {Î¹b : Type u_8} [DecidableEq Î¹a] [DecidableEq Î¹b] [Fintype Î¹a] [Fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [CommSemiring R'] [AddCommGroup Nâ‚] [Module R' Nâ‚] [AddCommGroup Nâ‚‚] [Module R' Nâ‚‚] [AddCommMonoid Máµ¢] [Module R' Máµ¢] (a : AlternatingMap R' Máµ¢ Nâ‚ Î¹a) (b : AlternatingMap R' Máµ¢ Nâ‚‚ Î¹b) : â‡‘MultilinearMap.alternatization (â†‘a.dom_Coprod â†‘b) = ((Fintype.card Î¹a).factorial * (Fintype.card Î¹b).factorial) â€¢ a.dom_Coprod b
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [DecidableEq J] (f : J â†’ C) [CategoryTheory.Limits.HasBiproduct f] (j j' : J) : CategoryTheory.Limits.biproductÎ¹ f j â‰« CategoryTheory.Limits.biproductÏ€ f j' = dite (j = j') (Î» (h : j = j'), CategoryTheory.eqToHom _) (Î» (h : Â¬j = j'), 0)
(n : â„•) (Î¸ : â„‚) : Complex.cos (â†‘n * Î¸) = Polynomial.eval (Complex.cos Î¸) (Polynomial.Chebyshev.t â„‚ n)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : o.oangle (-x) y + o.oangle (-y) x = 0
{f : â„‚ â†’ â„‚} {z : â„‚} {R : â„} (hD : DifferentiableOn â„‚ f (Metric.Ball 0 R)) (h_maps : Set.MapsTo f (Metric.Ball 0 R) (Metric.Ball 0 R)) (hâ‚€ : f 0 = 0) (hz : Complex.abs z < R) : Complex.abs (f z) â‰¤ Complex.abs z
{M : Type u_1} [Monoid M] {f g : â„¤ â†’* M} (h_Neg_One : â‡‘f (-1) = â‡‘g (-1)) (h_Nat : f.comp int.of_Nat_hom.to_MonoidHom = g.comp int.of_Nat_hom.to_MonoidHom) : f = g
{Î¹ : Type v} {Î¹' : Type v'} (f : Î¹ â†’ Cardinal) (f' : Î¹' â†’ Cardinal) (g : Î¹ â†’ Î¹') (h : âˆ€ (i : Î¹), (f i).lift â‰¤ (f' (g i)).lift) : (Cardinal.sup f).lift â‰¤ (Cardinal.sup f').lift
{Î± : Type u_1} [Monoid Î±] {a b : Î±} {u : Î±Ë£} : a * â†‘u âˆ£ b â†” a âˆ£ b
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [CommMonoid M] {s : Set Î±} {t : Set Î²} (f : Î± â†’ Î² â†’ M) (hs : s.finite) (ht : t.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ t), f i j)))) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ t), finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i j))))
{x y z : Pgame} (hâ‚ : x.lf y) (hâ‚‚ : y â‰¤ z) : x.lf z
{L : FirstOrder.Language} {M : Type w} [L.Structure M] [h : Nonempty L.constants] : Nonempty M
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] (f : (Fin 1 â†’ â„‚) â†’ E) (c : Fin 1 â†’ â„‚) (R : Fin 1 â†’ â„) : âˆ¯ (x : Fin 1 â†’ â„‚) in T(c, R), f x = âˆ® (z : â„‚) in C(c 0, R 0), f (Î» (_x : Fin 1), z)
{Î± : Type u_1} [measurableSpace Î±] {R : Type u_2} [HasScalar R Ennreal] [isScalarTower R Ennreal Ennreal] (c : R) (m : MeasureTheory.OuterMeasure Î±) : (c â€¢ m).trim = c â€¢ m.trim
{Fq : Type u_1} [Fintype Fq] [Semiring Fq] {d m : â„•} (hm : Fintype.card Fq ^ d â‰¤ m) (b : Polynomial Fq) (hb : b.nat_degree â‰¤ d) (A : Fin m.succ â†’ Polynomial Fq) (hA : âˆ€ (i : Fin m.succ), (A i).degree < b.degree) : âˆƒ (iâ‚€ iâ‚ : Fin m.succ), iâ‚€ â‰  iâ‚ âˆ§ A iâ‚ = A iâ‚€
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] [t2_Space Î±] {s : Set Î²} (hs : Dense s) {f g : Î² â†’ Î±} (hF : Continuous f) (hg : Continuous g) (h : Set.EqOn f g s) : f = g
{c : Cardinal} (h : Cardinal.aleph_0 â‰¤ c) : c + c = c
{ð’œ : Type u_1} [CategoryTheory.Category ð’œ] [CategoryTheory.Preadditive ð’œ] [CategoryTheory.Limits.HasKernels ð’œ] [CategoryTheory.Limits.HasImages ð’œ] [CategoryTheory.Limits.HasBinaryBiproducts ð’œ] (A B : ð’œ) : CategoryTheory.Exact CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.snd
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] : Monotone Finset.upShadow
{Î± : Type u} [MulOneClass Î±] [HasDistribNeg Î±] (a : Î±) : (-1) * a = -a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup Vâ‚‚] [Module k Vâ‚‚] [addTorsor Vâ‚‚ Pâ‚‚] (p : Î¹ â†’ P) (w : Î¹ â†’ k) (hw : s.sum w = 1) (f : P â†’áµƒ[k] Pâ‚‚) : â‡‘f (â‡‘(s.affine_combination p) w) = â‡‘(s.affine_combination (â‡‘f âˆ˜ p)) w
(R : Type u) (M : Type v) (N : Type w) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [AddCommGroup N] [Module R N] [Module.Free R N] [Module.Finite R N] : FiniteDimensional.finrank R (M Ã— N) = FiniteDimensional.finrank R M + FiniteDimensional.finrank R N
(R : Type u_1) [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (K : Type u_5) [Field K] [is_IsDomain R] [is_IsDomain S] [Algebra R K] [Algebra S K] [NoZeroSmulDivisors R K] [IsFractionRing S K] [isScalarTower R S K] : Algebra.IsAlgebraic R S â†” Algebra.IsAlgebraic R K
{Î± : Type u_1} [semigroupWithZero Î±] {a : Î±} : 0 âˆ£ a â†” a = 0
{Î± : Type u_1} [DecidableEq Î±] {s t : Finset Î±} (h : s âŠ† t) : (Finset.icc s t).card = 2 ^ (t.card - s.card)
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurableSpace Î±} [topologicalSpace Î²] (hF : MeasureTheory.StronglyMeasurable f) : TopologicalSpace.IsSeparable (Set.Range f)
(p : â„•) [Fact (Nat.Prime p)] {a : â„¤} (hp : p â‰  2) (ha0 : â†‘a â‰  0) : Zmod.legendreSym p a = (-1) ^ (Finset.filter (Î» (x : â„•), p / 2 < (â†‘a * â†‘x).val) (Finset.ico 1 (p / 2).succ)).card
{n p : â„•} (hp : Nat.Prime p) : multiplicity p (p * n).factorial = multiplicity p n.factorial + â†‘n
{M : Type u_2} [AddCommGroup M] {A : Type u_5} [CommRing A] [Module A M] [DecidableEq M] {P : A â†’ Prop} (f : M â†’â‚—[A] M) (hb : âˆ€ (s : Finset M) (b : Basis â†¥s A M), P (â‡‘(LinearMap.toMatrix b b) f).det) (h1 : P 1) : P (â‡‘LinearMap.det f)
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {f c : Equiv.perm Î±} {a : Î±} (ha : a âˆˆ c.support) (hc : c âˆˆ f.cycle_Factors_Finset) : c = f.cycle_of a
{Î± : Type u_1} [topologicalSpace Î±] [measurableSpace Î±] [BorelSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {s : Set Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ s âˆˆ nhdsWithin x (Set.Ioi x)) : MeasurableSet s
{V : Type u_1} [innerProductSpace â„ V] {P : Type u_2} [metricSpace P] [NormedAddTorsor V P] {a b c d p : P} (h : EuclideanGeometry.Cospherical {a, b, c, d}) (hapb : EuclideanGeometry.angle a p b = Real.pi) (hcpd : EuclideanGeometry.angle c p d = Real.pi) : HasDist.dist a p * HasDist.dist b p = HasDist.dist c p * HasDist.dist d p
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} : StrictMonoOn f s â†’ StrictAntiOn (â‡‘OrderDual.toDual âˆ˜ f) s
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b c : Î±} : -b + a < c â†’ a < b + c
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {f : â„ â†’ E} {g : â„ â†’ F} {a b c : â„} (h_deriv : âˆ€á¶  (x : â„) in nhdsWithin c {c}á¶œ, DifferentiableAt â„ f x) (h_infty : Filter.Tendsto (Î» (x : â„), âˆ¥f xâˆ¥) (nhdsWithin c {c}á¶œ) Filter.atTop) (hg : deriv f =O[nhdsWithin c {c}á¶œ] g) (hne : a â‰  b) (hc : c âˆˆ Set.Interval a b) : Â¬IntervalIntegrable g MeasureTheory.MeasureSpace.volume a b
{Î± : Type u} {a b : Î±} [MulZeroClass Î±] [PartialOrder Î±] [ZeroLt.MulPosMono Î±] (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a * b
{Î± : Type u_1} {t : Set Î±} (s : Finset â†¥t) : â†‘(Finset.map (Function.Embedding.subtype (Î» (x : Î±), x âˆˆ t)) s) âŠ† t
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} (f : c.quotient â†’+ P) : c.lift (f.comp c.mk') _ = f
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {b : M} [linearOrderedCommRing M] (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (ht : t.nonempty) (hb : t.card â€¢ b â‰¤ â†‘(s.card)) : âˆƒ (y : Î²) (H : y âˆˆ t), b â‰¤ â†‘((Finset.filter (Î» (x : Î±), f x = y) s).card)
{E : Type u_1} [innerProductSpace â„ E] {n : â„•} (hn : 0 < n) (h : FiniteDimensional.finrank â„ E = n) (x : Orientation â„ E (Fin n)) : (Orientation.finOrthonormalBasis hn h x).orientation = x
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] [Algebra A B] [isScalarTower R A B] (hfpA : Algebra.FinitePresentation R A) (hfpB : Algebra.FinitePresentation A B) : Algebra.FinitePresentation R B
{M : Type u_1} {N : Type u_2} {Î± : Type u_6} {Î² : Type u_7} [HasScalar M Î±] [HasScalar Î² Î±] [SmulCommClass M Î² Î±] (g : N â†’ M) : SmulCommClass N Î² Î±
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hcont : ContinuousOn f (Set.Interval a b)) (hderiv : âˆ€ (x : â„), x âˆˆ Set.Ioo (Linear_order.min a b) (Linear_order.max a b) â†’ HasDerivWithinAt f (f' x) (Set.Ioi x) x) (hint : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : âˆ« (y : â„) in a..b, f' y = f b - f a
{n : â„•} (P : Mvpfunctor (n + 1)) {Î± : Typevec n} {C : Type u_1} (g : Î  (a : P.A), (P.drop.B a).arrow Î± â†’ (P.last.B a â†’ P.W Î±) â†’ (P.last.B a â†’ C) â†’ C) (a : P.A) (f' : (P.drop.B a).arrow Î±) (f : P.last.B a â†’ P.W Î±) : P.W_rec g (P.W_Mk a f' f) = g a f' f (Î» (i : P.last.B a), P.W_rec g (f i))
{Î± : Type u_1} [canonicallyLinearOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b c : Î±} [ContravariantClass Î± Î± Add.add LE.le] (h : c â‰¤ a) : a - c < b - c â†” a < b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {s : Set ð•œ} [CompleteSpace F] (h : AnalyticOn ð•œ f s) : AnalyticOn ð•œ (deriv f) s
{Î± : Type u_1} {ð•œ : Type u_14} [normedField ð•œ] {l : Filter Î±} {u v : Î± â†’ ð•œ} (h : u =o[l] v) : u / v * v =á¶ [l] u
{Î± : Type u_1} [CircularPreorder Î±] {a b c : Î±} (h : HasSbtw.Sbtw a b c) : Â¬HasBtw.Btw c b a
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] {x : B} (hx : IsIntegral A x) : 0 < (minpoly A x).nat_degree
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [hÎ¹ : Î  (n : Î²), Fintype (Î¹ n)] (d : â„) (s : Set X) {l : Filter Î²} (r : Î² â†’ Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ Set X) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), Emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, s âŠ† â‹ƒ (i : Î¹ n), t n i) : â‡‘(MeasureTheory.Measure.hausdorffMeasure d) s â‰¤ l.liminf (Î» (n : Î²), finset.univ.sum (Î» (i : Î¹ n), Emetric.diam (t n i) ^ d))
{t : â†¥UnitInterval} : t â‰¤ 1
{Î± : Type u_1} {s : Finset Î±} {a : Î±} [DecidableEq Î±] : (s.erase a).card = Ite (a âˆˆ s) (s.card - 1) s.card
{C : Type uâ‚} [CategoryTheory.Category C] (G : CategoryTheory.Comonad C) {A B : G.coalgebra} (f : A âŸ¶ B) [CategoryTheory.IsIso f.f] : CategoryTheory.IsIso f
{l : Filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in Filter.atBot, DifferentiableAt â„ f x) (hg' : âˆ€á¶  (x : â„) in Filter.atBot, deriv g x â‰  0) (hfbot : Filter.Tendsto f Filter.atBot (nhds 0)) (hgbot : Filter.Tendsto g Filter.atBot (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv f x / deriv g x) Filter.atBot l) : Filter.Tendsto (Î» (x : â„), f x / g x) Filter.atBot l
{V : Type u_1} [innerProductSpace â„ V] {P : Type u_2} [metricSpace P] [NormedAddTorsor V P] {a b c d p : P} (h : EuclideanGeometry.Cospherical {a, b, c, d}) (hapb : âˆƒ (kâ‚ : â„), kâ‚ â‰  1 âˆ§ b -áµ¥ p = kâ‚ â€¢ (a -áµ¥ p)) (hcpd : âˆƒ (kâ‚‚ : â„), kâ‚‚ â‰  1 âˆ§ d -áµ¥ p = kâ‚‚ â€¢ (c -áµ¥ p)) : HasDist.dist a p * HasDist.dist b p = HasDist.dist c p * HasDist.dist d p
{f : â„ â†’ â„} {f' a : â„} (h : IsLocalExtr f a) : HasDerivAt f f' a â†’ f' = 0
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Î¹ â†’ M} [Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [Module R M] [Module R M'] (f : M â†’â‚—[R] M') (hF_inj : f.ker = âŠ¥) : LinearIndependent R (â‡‘f âˆ˜ v) â†” LinearIndependent R v
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] [CompleteSpace ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [FiniteDimensional ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {a : E} (hF : HasStrictFderivAt f f' a) (hF' : f'.range = âŠ¤) : âˆ€á¶  (x : E) in nhds a, HasStrictFderivAt.implicitFunction f f' hF hF' (f x) (â‡‘(HasStrictFderivAt.implicitToLocalHomeomorph f f' hF hF') x).snd = x
{F : Type u_3} [innerProductSpace â„ F] (T : F â†’â‚—[â„] F) : InnerProductSpace.IsSelfAdjoint T â†” BilinForm_ofReal_inner.is_selfAdjoint T
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M â†’+ P} (H : c â‰¤ AddCon.ker f) : (c.lift f H).mrange = f.mrange
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] : Ká—®á—® = K
(b m : â„•) (hm : m â‰  0) : (b + 2) ^ ((b + 2).digits m).length â‰¤ (b + 2) * m
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) (hxy : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) (hxz : âˆ¥xâˆ¥ = âˆ¥zâˆ¥) : hb.oangle y z = 2 â€¢ hb.oangle (y - x) (z - x)
{Î± : Type u_1} [hasAdd Î±] [HasLe Î±] [ContravariantClass Î± Î± Add.add LE.le] {a b c : Î±} (bc : a + b â‰¤ a + c) : b â‰¤ c
{Î± : Type u} {L : List (Î± Ã— Bool)} [DecidableEq Î±] : FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L
{p a b : â„•} (hab : a.coprime b) : â‡‘((a * b).factorization) p = â‡‘(a.factorization) p + â‡‘(b.factorization) p
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} {s : Set â„‚} {c : â„‚} (hc : s âˆˆ nhdsWithin c {c}á¶œ) (hD : DifferentiableOn â„‚ f s) (ho : (Î» (z : â„‚), f z - f c) =o[nhdsWithin c {c}á¶œ] Î» (z : â„‚), (z - c)â»Â¹) : DifferentiableOn â„‚ (Function.update f c (lim (nhdsWithin c {c}á¶œ) f)) (HasInsert.insert c s)
{C : Type uâ‚} [CategoryTheory.Category C] (X : C) [h : Î  (Y : C), Unique (Y âŸ¶ X)] : CategoryTheory.Limits.HasTerminal C
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {R : â„} {c w : â„‚} {f : â„‚ â†’ E} {s : Set â„‚} (hs : s.countable) (hw : w âˆˆ Metric.Ball c R  s) (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : âˆ€ (x : â„‚), x âˆˆ Metric.Ball c R  s â†’ DifferentiableAt â„‚ f x) : âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘Real.pi * Complex.i) â€¢ f w
{Î± : Type u_1} {Î² : Type u_2} [hasMul Î±] [Preorder Î±] [Preorder Î²] {f g : Î² â†’ Î±} [CovariantClass Î± Î± Mul.mul LT.lt] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] (hF : StrictMono f) (hg : StrictMono g) : StrictMono (Î» (x : Î²), f x * g x)
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (h : 0 < r * (b - a)) : f (â‡‘(AffineMap.lineMap a b) r) < â‡‘(AffineMap.lineMap (f a) (f b)) r â†” slope f a (â‡‘(AffineMap.lineMap a b) r) < slope f a b
{G : Type u_6} {H : Type u_7} {F : Type u_8} [Group G] [divisionMonoid H] [monoidHomClass F G H] (f : F) (a b : G) : â‡‘f (a * bâ»Â¹) = â‡‘f a * (â‡‘f b)â»Â¹
{Î± : Type u_1} {c : Set (Set Î±)} (hc : setoid.is_Partition c) {s : Set Î±} (hs : s âˆˆ c) : âˆƒ (y : Î±), s = {x : Î± | (setoid.mk_Classes c _).rel x y}
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] : (reflection K)â»Â¹ = reflection K
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} {A : Type u_3} [Semiring A] [Algebra R A] {f g : CliffordAlgebra Q â†’â‚[R] A} : f.to_Linear_map.comp (CliffordAlgebraÎ¹ Q) = g.to_Linear_map.comp (CliffordAlgebraÎ¹ Q) â†’ f = g
{ð•œ : Type u_3} {E : Type u_4} [normedField ð•œ] [semiNormedGroup E] [normedSpace ð•œ E] {r : â„} (hr : 0 < r) : Absorbent ð•œ (Metric.Ball 0 r)
{F : Type u_1} [Field F] (p q : Polynomial F) (hq : q.nat_degree â‰  0) : Polynomial.Splits (algebraMap F (p.comp q).splitting_Field) p
{M : Type u_3} {N : Type u_4} [MulOneClass M] [MulOneClass N] {f g : M â†’* N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {X : C} (S : CategoryTheory.Sieve X) : Jâ‚.close S = âŠ¤ â†” S âˆˆ â‡‘Jâ‚ X
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle â„ P) {iâ‚ iâ‚‚ iâ‚ƒ : Fin 3} (hâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) : Affine.Simplex.altitude t iâ‚ = Affine.Simplex.mongePlane t iâ‚‚ iâ‚ƒ
{Î± : Type u_1} {Gâ‚€ : Type u_3} [hasZero Gâ‚€] [hasInv Gâ‚€] [topologicalSpace Gâ‚€] [HasContinuousInvâ‚€ Gâ‚€] {l : Filter Î±} {f : Î± â†’ Gâ‚€} {a : Gâ‚€} (hF : Filter.Tendsto f l (nhds a)) (ha : a â‰  0) : Filter.Tendsto (Î» (x : Î±), (f x)â»Â¹) l (nhds aâ»Â¹)
{X : Type u_1} [topologicalSpace X] {s : Set X} (hs : is_IsClosed s) : IsSeqClosed s
{Î± : Type u_2} {Î¹ : Type u_5} [CommMonoid Î±] [Fintype Î¹] (f : Î¹ â†’ Set Î±) (a : Î±) : a âˆˆ finset.univ.prod (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), g i âˆˆ f i), finset.univ.prod (Î» (i : Î¹), g i) = a
{R : Type u_2} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R] (a : R) (H : a â‰  0) (b : R) : âˆƒ (a' b' c' : R), (âˆ€ {d : R}, d âˆ£ a' â†’ d âˆ£ b' â†’ IsUnit d) âˆ§ c' * a' = a âˆ§ c' * b' = b
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {Î± Î² : â†¥(solvableByRad F E)} (hÎ² : Î² âˆˆ FâŸ®Î±âŸ¯) (hÎ± : solvableByRad.P Î±) : solvableByRad.P Î²
{n : â„•} (c : Composition n) : c.boundaries.order_emb_of_Fin _ = c.boundary
{Î¹ : Type u_1} [Fintype Î¹] : MeasureTheory.Measure.hausdorffMeasure â†‘(Fintype.card Î¹) = MeasureTheory.MeasureSpace.volume
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) : is_IsClosed â†‘Ká—®
{R : Type u} {n : â„•} {M : Fin n.succ â†’ Type w} {Mâ‚‚ : Type wâ‚‚} [Semiring R] [Î  (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid Mâ‚‚] [Î  (i : Fin n.succ), Module R (M i)] [Module R Mâ‚‚] [Î  (i : Fin n.succ), topologicalSpace (M i)] [topologicalSpace Mâ‚‚] (f : ContinuousMultilinearMap R M Mâ‚‚) (m : Î  (i : Fin n), M i.succ) (x y : M 0) : â‡‘f (fin.cons (x + y) m) = â‡‘f (fin.cons x m) + â‡‘f (fin.cons y m)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {f : â„ â†’ E} {C : â„} (hF : DifferentiableOn â„ f (Set.Icc 0 1)) (bound : âˆ€ (x : â„), x âˆˆ Set.Ico 0 1 â†’ âˆ¥derivWithin f (Set.Icc 0 1) xâˆ¥ â‰¤ C) : âˆ¥f 1 - f 0âˆ¥ â‰¤ C
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} {s : Affine.Simplex â„ P (n + 2)} {iâ‚ : Fin (n + 3)} {p : P} (h : âˆ€ (iâ‚‚ : Fin (n + 3)), iâ‚ â‰  iâ‚‚ â†’ p âˆˆ s.monge_plane iâ‚ iâ‚‚) : p = s.monge_point
{Î± : Type u_1} {a b c : Î±} [LinearOrder Î±] [AddCommSemigroup Î±] [HasSub Î±] [HasOrderedSub Î±] [CovariantClass Î± Î± Add.add LE.le] (h : a - b < a - c) : c < b
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] [FiniteDimensional K L] {x : L} : â‡‘LinearMap.det (â‡‘(Algebra.lmul K L) x) = 0 â†” x = 0
{C : Type u} [CategoryTheory.Category C] {Jâ‚ Jâ‚‚ : CategoryTheory.GrothendieckTopology C} : Jâ‚ = Jâ‚‚ â†” âˆ€ (P : Cáµ’áµ– â¥¤ Type (max v u)), CategoryTheory.Presieve.IsSheaf Jâ‚ P â†” CategoryTheory.Presieve.IsSheaf Jâ‚‚ P
{p : â„•} : padicValNat p 1 = 0
{Î± : Type u_1} [topologicalSpace Î±] {s : Set Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] {f g : Î± â†’ Î³} (hF : UpperSemicontinuousOn f s) (hg : UpperSemicontinuousOn g s) (hcont : âˆ€ (x : Î±), x âˆˆ s â†’ ContinuousAt (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : UpperSemicontinuousOn (Î» (z : Î±), f z + g z) s
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : Real.cos (InnerProductGeometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = HasInner.inner x y
{Î± : sort u_1} {p : Î± â†’ Prop} (x : Subtype_ p) : p â†‘x
{Î± : Type u_3} {Î² : Type u_4} [linearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hF : Filter.Tendsto f l Filter.atBot) : Filter.Tendsto (Î» (x : Î²), f x * r) l Filter.atTop
{E : Type u_1} [semiNormedGroup E] {s : Set E} : Metric.Bounded s â†’ (âˆƒ (R : â„), âˆ€ (x : E), x âˆˆ s â†’ âˆ¥xâˆ¥ â‰¤ R)
{X : Type u_1} [topologicalSpace X] [NormalSpace X] {s t : Set X} (hs : is_IsClosed s) (ht : is_IsClosed t) (hD : Disjoint s t) : âˆƒ (f : boundedContinuousFunction X â„), Set.EqOn â‡‘f 0 s âˆ§ Set.EqOn â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ Set.Icc 0 1
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (x : Î±) (H : âˆ€ (y : Î±), y âˆˆ s â†’ (âˆƒ (t : Set Î±) (H : t âŠ† s), x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t)) : IsPreconnected s
{x : Pgame} : x â‰¤ 0 â†” âˆ€ (i : x.left_moves), âˆƒ (j : (x.move_Left i).right_moves), (x.move_Left i).move_Right j â‰¤ 0
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) {r : â„} (hr : 0 < r) : o.oangle x (r â€¢ y) = o.oangle x y
{Î± : Type u} [pseudoMetricSpace Î±] {f : Î± â†’ â„} (K : Nnreal) (h : âˆ€ (x y : Î±), f x â‰¤ f y + â†‘K * HasDist.dist x y) : LipschitzWith K f
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P (n + 2)) {iâ‚ iâ‚‚ : Fin (n + 3)} : s.monge_point âˆˆ s.monge_plane iâ‚ iâ‚‚
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (x : Module.Ray R M) : rayOfNeZero R x.some_Vector _ = x
{Î± : Type u} [t : topologicalSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1} (s : Î¹ â†’ Set Î±) (H : âˆ€ (i : Î¹), is_IsOpen (s i)) : âˆƒ (T : Set Î¹), T.countable âˆ§ (â‹ƒ (i : Î¹) (H : i âˆˆ T), s i) = â‹ƒ (i : Î¹), s i
(p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•) {m : â„•} (hm : n â‰¤ m) : (TruncatedWittVector.truncate hm).comp (TruncatedWittVector.zmodEquivTrunc p m).to_ringHom = (TruncatedWittVector.zmodEquivTrunc p n).to_Ring_hom.comp (Zmod.castHom _ (Zmod(p ^ n)))
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (s : Set Î±) : Continuous (Î» (F : C(Î±, Î²)), ContinuousMap.restrict s F)
{n : Type u_1} {ð•œ : Type u_3} [Field ð•œ] [DecidableEq n] [Fintype n] (M : Matrix n n ð•œ) : âˆƒ (L L' : List (Matrix.TransvectionStruct n ð•œ)) (D : n â†’ ð•œ), ((List.map Matrix.TransvectionStruct.toMatrix L).prod.mul M).mul (List.map Matrix.TransvectionStruct.toMatrix L').prod = Matrix.diagonal D
{m : Type u_2} {n : Type u_3} {Î± : Type v} (M : Matrix m n Î±) (i : m) (j : n) : M.transpose j i = M i j
{G : Type w} [topologicalSpace G] [HasNeg G] [hasAdd G] [HasContinuousAdd G] (g : G) : Continuous (Î» (h : G), g + h + -g)
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [semiNormedGroup Î²] (f : boundedContinuousFunction Î± Î²) [h : Nonempty Î±] : âˆ¥fâˆ¥ = HasInf.inf {C : â„ | âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C}
{M : Type u_1} [AddCommMonoid M] (a b : â„•) (f : â„• â†’ â„• â†’ M) : (Finset.ico a b).sum (Î» (i : â„•), (Finset.ico i b).sum (Î» (j : â„•), f i j)) = (Finset.ico a b).sum (Î» (j : â„•), (Finset.ico a (j + 1)).sum (Î» (i : â„•), f i j))
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : â‡‘(EuclideanGeometry.orthogonalProjection s) â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p) = â‡‘(EuclideanGeometry.orthogonalProjection s) p
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] (s : Submodule K V) : FiniteDimensional.finrank K (V â§¸ s) â‰¤ FiniteDimensional.finrank K V
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] (x : Î± Ã— Î²) : Filter.map Prod.snd (nhdsWithin x (Prod.fst â»Â¹' {x.fst})) = nhds x.snd
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hst : Disjoint (s âˆ© Function.Support f) (t âˆ© Function.Support f)) (hs : (s âˆ© Function.Support f).finite) (ht : (t âˆ© Function.Support f).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [divisionRing K] {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K} (Succ_nth_s_Eq : g.s.nth (n + 1) = Option.some gp) (nth_denom_Eq : g.denominators n = ppredB) (Succ_nth_denom_Eq : g.denominators (n + 1) = predB) : g.denominators (n + 2) = gp.b * predB + gp.a * ppredB
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] (s : Set Î±) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), 1)) = 1
{M : Type u_1} [AddMonoid M] {x : M} : 0 âˆˆ Multiples x
{Î± : Type u_1} [Semigroup Î±] (x y : Î±) : Mul.mul x âˆ˜ Mul.mul y = Mul.mul (x * y)
{n : â„•} (p : Fin (n + 1)) : Set.Range â‡‘(p.succ_above) = {p}á¶œ
{Gâ‚€ : Type u_2} [groupWithZero Gâ‚€] (a : Gâ‚€) : a / (a / a) = a
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} (hF : ClosedEmbedding f) : Filter.Tendsto f (Filter.cocompact Î±) (Filter.cocompact Î²)
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} : ConcaveOn ð•œ s f â†” Convex ð•œ s âˆ§ âˆ€ â¦ƒx y z : ð•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x)
{p : â„} : Summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [AddZeroClass M] [AddCommMonoid N] {f g : Î± â†’â‚€ M} {h : Î± â†’ M â†’ N} (h_Zero : âˆ€ (a : Î±), h a 0 = 0) (h_Add : âˆ€ (a : Î±) (bâ‚ bâ‚‚ : M), h a (bâ‚ + bâ‚‚) = h a bâ‚ + h a bâ‚‚) : (f + g).sum h = f.sum h + g.sum h
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] (x : Î± Ã— Î²) : Filter.map Prod.fst (nhdsWithin x (Prod.snd â»Â¹' {x.snd})) = nhds x.fst
{G : Type u_1} [Group G] {H : Subgroup G} {N : Type u_3} [Group N] (f : N â†’* G) : Subgroup.comap f H.normalizer â‰¤ (Subgroup.comap f H).normalizer
{n : â„•} (c : Composition n) {iâ‚ iâ‚‚ : Fin c.length} (h : iâ‚ â‰  iâ‚‚) : Disjoint (Set.Range â‡‘(c.embedding iâ‚)) (Set.Range â‡‘(c.embedding iâ‚‚))
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : StrictConvexOn ð•œ s f) {x y z : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hxy : x â‰  y) (hz : z âˆˆ OpenSegment ð•œ x y) : f z < Linear_order.max (f x) (f y)
{Î± : Type u_1} {Î² : Type u_3} {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : IsCountablySpanning C) (hD : IsCountablySpanning D) : IsCountablySpanning (Set.image2 HasSetProd.prod C D)
{Î± : Type u} {f g : Filter Î±} (h : âˆ€ (s : Set Î±), sá¶œ âˆˆ f â†” sá¶œ âˆˆ g) : f = g
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {f : M â†’+ N} (hF : âˆ€ (y : â†¥S), IsAddUnit (â‡‘f â†‘y)) {y z : â†¥S} (h : -â‡‘(IsAddUnit.liftRight (f.restrict S) hF) y = -â‡‘(IsAddUnit.liftRight (f.restrict S) hF) z) : â‡‘f â†‘y = â‡‘f â†‘z
(R : Type u) [Ring R] [StrongRankCondition R] {Î¹ : Type v} [Fintype Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), AddCommGroup (M i)] [Î  (i : Î¹), Module R (M i)] [âˆ€ (i : Î¹), Module.Free R (M i)] : Module.rank R (Î  (i : Î¹), M i) = Cardinal.sum (Î» (i : Î¹), Module.rank R (M i))
(n : â„•) : âˆ‘' (i : â„•), Ite (n â‰¤ i) (2â»Â¹ ^ i) 0 = 2 * 2â»Â¹ ^ n
{Î± : Type u_1} [PartialOrder Î±] (c : closureOperator Î±) : c.closed = Set.Range â‡‘c
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S
{a b c m : â„•} (hm : 0 < m) (h : c * a â‰¡ c * b [Mod m]) : a â‰¡ b [Mod m / m.gcd c]
{C : Type uâ‚} [CategoryTheory.Category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚ƒâ‚ Xâ‚ƒâ‚‚ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚ƒâ‚ : Xâ‚ƒâ‚ âŸ¶ Xâ‚ƒâ‚‚} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚ƒâ‚} {vâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚ƒâ‚‚} (s : CategoryTheory.IsPullback hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚) (p : hâ‚â‚ â‰« vâ‚â‚‚ = vâ‚â‚ â‰« hâ‚‚â‚) (t : CategoryTheory.IsPullback hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚) : CategoryTheory.IsPullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚
{J : Type v} {C : Type u} [CategoryTheory.Category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [Nonempty J] {t : CategoryTheory.Limits.Cotrident f} {Z Z' : C} (q : Z âŸ¶ Z') (ht : CategoryTheory.Limits.IsColimit t) (k : t.X âŸ¶ Z) : â†‘(â‡‘(CategoryTheory.Limits.Cotrident.IsColimit.homIso ht Z') (k â‰« q)) = â†‘(â‡‘(CategoryTheory.Limits.Cotrident.IsColimit.homIso ht Z) k) â‰« q
{X Y : Compactum} (f : X âŸ¶ Y) : Continuous â‡‘f
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] {M N : Submodule R A} {C : Î  (r : A), r âˆˆ M * N â†’ Prop} (hm : âˆ€ (m : A) (H : m âˆˆ M) (n : A) (H_1 : n âˆˆ N), C (m * n) _) (ha : âˆ€ (x : A) (hx : x âˆˆ M * N) (y : A) (hy : y âˆˆ M * N), C x hx â†’ C y hy â†’ C (x + y) _) {r : A} (hr : r âˆˆ M * N) : C r hr
{R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [topologicalSpace M] [topologicalSpace Mâ‚‚] [Semiring R] [AddCommMonoid Mâ‚‚] [Module R Mâ‚‚] [AddCommMonoid M] [Module R M] (e : M â‰ƒL[R] Mâ‚‚) : â†‘e.inverse = â†‘(e.symm)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) (h : 0 < p.radius) : âˆƒ (C r : â„) (hC : 0 < C) (hr : 0 < r), âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C * r ^ n
{n : â„•} (i : Fin (n + 1)) : finset.univ.sum (Î» (j : Affine.Simplex.PointsWithCircumcenterIndex n), Affine.Simplex.pointWeightsWithCircumcenter i j) = 1
(k : Type uâ‚) {G : Type uâ‚‚} [Semiring k] [hasMul G] {A : Type uâ‚ƒ} [NonUnitalNonAssocSemiring A] [DistribMulAction k A] {Ï†â‚ Ï†â‚‚ : MonoidAlgebra k G â†’â‚™â‚[k] A} (h : Ï†â‚.to_Mul_hom.comp (MonoidAlgebra.ofMagma k G) = Ï†â‚‚.to_Mul_hom.comp (MonoidAlgebra.ofMagma k G)) : Ï†â‚ = Ï†â‚‚
{F : Type u_3} [Field F] [Fintype F] (hF : ringChar F â‰  2) : âˆƒ (a : F), Â¬IsSquare a
{Î± : Type u_1} {o p : Part Î±} (H : âˆ€ (a : Î±), a âˆˆ o â†” a âˆˆ p) : o = p
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) : hb.oangle x (-x) = â†‘Real.pi
{E : Type u_1} {F : Type u_2} [innerProductSpace â„ E] [innerProductSpace â„ F] {f : E â†’ F} {x : E} {f' : E â†’L[â„] F} (h : HasFderivAt f f' x) : ConformalAt f x â†” âˆƒ (c : â„), 0 < c âˆ§ âˆ€ (u v : E), HasInner.inner (â‡‘f' u) (â‡‘f' v) = c * HasInner.inner u v
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semiNormedGroup Vâ‚] [semiNormedGroup Vâ‚‚] (f g : NormedGroupHom Vâ‚ Vâ‚‚) : âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p) -áµ¥ p âˆˆ (s.direction)á—®
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} : IsExtrOn f s a â†’ IsExtrOn (â‡‘OrderDual.toDual âˆ˜ f) s a
{Î¹ : Type u} {Î± : Type v} [Fintype Î¹] {t : Î¹ â†’ Finset Î±} [DecidableEq Î±] (ht : âˆ€ (s : Finset Î¹), s.card â‰¤ (s.bUnion t).card) : âˆƒ (f : Î¹ â†’ Î±), Function.Injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {E' : Type u_6} [NormedGroup E'] [normedSpace ð•œ E'] {F' : Type u_7} [NormedGroup F'] [normedSpace ð•œ F'] {f : E â†’ F} {g : E' â†’ F'} {x : E} {y : E'} (hF : ContDiffAt ð•œ n f x) (hg : ContDiffAt ð•œ n g y) : ContDiffAt ð•œ n (Prod.map f g) (x, y)
{G : Type u_1} [DivInvMonoid G] [measurableSpace G] [HasMeasurableMul G] (g : G) : Measurable (Î» (h : G), h / g)
{Î± : sort u_1} {k l : â„•} (h : k = l) {f : Fin k â†’ Î±} {g : Fin l â†’ Î±} : f == g â†” âˆ€ (i : Fin k), f i = g âŸ¨â†‘i, _âŸ©
{R : Type u_1} [CommSemiring R] {n : Type u_4} [Fintype n] [DecidableEq n] {Mâ‚ : Type u_5} [AddCommMonoid Mâ‚] [Module R Mâ‚] (vâ‚ : Basis n R Mâ‚) : â‡‘(LinearMap.toMatrix vâ‚ vâ‚) LinearMap.id = 1
{R : Type u} {M : Type v} [CommSemiring R] [AddCommMonoid M] [Module R M] (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = âŠ¤) (x : M) (H : âˆ€ (r : â†¥s), âˆƒ (n : â„•), â†‘r ^ n â€¢ x âˆˆ M') : x âˆˆ M'
{Î± : Type u} [PartialOrder Î±] [OrderTop Î±] {a : Î±} : IsTop a â†’ a = âŠ¤
{R : Type u} [Ring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {M : Type u_1} [AddCommGroup M] [Module R M] (A : Î¹ â†’ Submodule R M) : DirectSum.IsInternal A â†” CompleteLattice.Independent A âˆ§ supr A = âŠ¤
{R : Type x} [Ring R] [NoZeroDivisors R] (u : RË£) : uâ»Â¹ = u â†” u = 1 âˆ¨ u = -1
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] (s : Set A) (li : AlgebraicIndependent R Coe) (t : Finset â†¥s) : AlgebraicIndependent R Coe
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} {c : CategoryTheory.Limits.Fork f f} (h : CategoryTheory.Limits.IsLimit c) : CategoryTheory.IsIso c.Î¹
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [AddCommMonoid Î²] {s : Finset Î±} {t : Finset Î³} {f : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (a : Î±), a âˆˆ s â†’ Î³) (hi : âˆ€ (a : Î±) (ha : a âˆˆ s), i a ha âˆˆ t) (h : âˆ€ (a : Î±) (ha : a âˆˆ s), f a = g (i a ha)) (i_inj : âˆ€ (aâ‚ aâ‚‚ : Î±) (haâ‚ : aâ‚ âˆˆ s) (haâ‚‚ : aâ‚‚ âˆˆ s), i aâ‚ haâ‚ = i aâ‚‚ haâ‚‚ â†’ aâ‚ = aâ‚‚) (i_surj : âˆ€ (b : Î³), b âˆˆ t â†’ (âˆƒ (a : Î±) (ha : a âˆˆ s), b = i a ha)) : s.sum (Î» (x : Î±), f x) = t.sum (Î» (x : Î³), g x)
{Î± : Type u} [pseudoEmetricSpace Î±] : Emetric.diam âˆ… = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s1 s2 : AffineSubspace k P) : â†‘s1 âŠ“ â†‘s2 = â†‘s1 âˆ© â†‘s2
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : ContinuousMultilinearMap ð•œ E G) (m : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
 : Cardinal.mk â†¥Set.Univ = Cardinal.continuum
{Î± : Type u_1} {Î² : Type u_2} {m : measurableSpace Î±} {f : MeasureTheory.Filtration â„• m} {u : â„• â†’ Î± â†’ Î²} [AddCommMonoid Î²] [topologicalSpace Î²] [HasContinuousAdd Î²] (h : MeasureTheory.Adapted f u) : MeasureTheory.ProgMeasurable f u
{a : â„} {l : Filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Univ  {a}), HasDerivAt f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Univ  {a}), HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Univ  {a}), g' x â‰  0) (hfa : Filter.Tendsto f (nhdsWithin a (Set.Univ  {a})) (nhds 0)) (hga : Filter.Tendsto g (nhdsWithin a (Set.Univ  {a})) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), f' x / g' x) (nhdsWithin a (Set.Univ  {a})) l) : Filter.Tendsto (Î» (x : â„), f x / g x) (nhdsWithin a (Set.Univ  {a})) l
{R : Type u} {K : Type v} {L : Type z} {p : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [isScalarTower R K L] [IsSeparable K L] [is_IsDomain R] [NormalizedGcdMonoid R] [IsFractionRing R K] [IsIntegrallyClosed R] {B : powerBasis K L} (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} {Q : Polynomial R} (hQ : â‡‘(Polynomial.aeval B.gen) Q = p â€¢ z) (hzint : IsIntegral R z) (hei : (minpoly R B.gen).is_eisenstein_at (Submodule.span R {p})) : p âˆ£ Q.coeff 0
{Î± : Type u_3} {Î² : Type u_4} [linearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hF : Filter.Tendsto f l Filter.atTop) : Filter.Tendsto (Î» (x : Î²), r * f x) l Filter.atBot
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {G : Î¹ â†’ Type u_5} [Î  (i : Î¹), innerProductSpace ð•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ V) {Î³ : Type u_3} {f : Î³ â†’ Î¹} (hF : Function.Injective f) : OrthogonalFamily ð•œ (Î» (g : Î³), V (f g))
{Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [Semiring Î²] [hasOne Î±] [hasOne Î±â‚‚] {F : Type u_4} [oneHomClass F Î± Î±â‚‚] (f : F) : Finsupp.mapDomain â‡‘f 1 = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] (O : Finset C) : âˆƒ (S : C), âˆ€ {X : C}, X âˆˆ O â†’ Nonempty (X âŸ¶ S)
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : Function.Injective coeFn
(p : â„•) {q : â„š} (hq : q â‰  0) : padicNorm p q = â†‘p ^ -padicValRat p q
{Î± : Type u_2} [DecidableEq Î±] [hasInv Î±] {s : Finset Î±} : s.nonempty â†’ sâ»Â¹.nonempty
{Î± : Type u} [hasAdd Î±] : IsAddHom Id
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (S : Subalgebra R A) : S.to_Submodule * S.to_Submodule = S.to_Submodule
{K : Type u_1} [linearOrderedField K] [floorRing K] {a : K} (b c : K) (fract_a_NeZero : Int.fract a â‰  0) : (â†‘âŒŠaâŒ‹ * b + c) / Int.fract a + b = (b * a + c) / Int.fract a
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) {C : â„} (hF'_GE : âˆ€ (x : â„), x âˆˆ Interior D â†’ C â‰¤ deriv f x) (x : â„) (H : x âˆˆ D) (y : â„) (H_1 : y âˆˆ D) : x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x
{R : Type u_1} {L : Type u_2} [CommRing R] [LieRing L] [lieAlgebra R L] {H : LieSubalgebra R L} {x y : L} (hx : x âˆˆ H.normalizer) (hy : y âˆˆ H) : â…x,yâ† âˆˆ H
{R : Type u_1} {M : Type u_2} [AddCommMonoid M] [CommSemiring R] {S : Set M} (hS : AddSubmonoid.closure S = âŠ¤) : Function.Surjective â‡‘(MvPolynomial.aeval (Î» (s : â†¥S), AddMonoidAlgebra.of' R M â†‘s))
{n : â„•} (w : 0 < n) (h : Â¬Nat.Prime n) : n.min_fac ^ 2 â‰¤ n
{Î± : Type u_1} {f g : Î± â†’ â„} {tâ‚€ : Filter Î±} (hF : âˆ€ (t : Î±), 0 â‰¤ f t) (hft : âˆ€ (t : Î±), f t â‰¤ g t) (g0 : Filter.Tendsto g tâ‚€ (nhds 0)) : Filter.Tendsto f tâ‚€ (nhds 0)
{C : Type u} [CategoryTheory.Category C] {X Y : C} (J : CategoryTheory.GrothendieckTopology C) (f : Y âŸ¶ X) (S : CategoryTheory.Sieve X) (hF : â‡‘S f) : J.covers S f
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} (hF : StrictConcaveOn ð•œ s f) {x y z : ð•œ} (hx : x âˆˆ s) (hz : z âˆˆ s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) < (f y - f x) / (y - x)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (R : D â¥¤ C) [CategoryTheory.Reflective R] [CategoryTheory.Limits.HasColimitsOfSize C] : CategoryTheory.Limits.HasColimitsOfSize D
{G : Type u_1} {H : Type u_2} [AddGroup G] {N : AddSubgroup G} [AddGroup H] {f : G â†’+ H} (hN : N = f.ker) (tH : Add_monoid.is_torsion H) (tN : Add_monoid.is_torsion â†¥N) : Add_monoid.is_torsion G
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [AddCommMonoid M] (s : Finset (Î± Ã— Î²)) (f : Î± Ã— Î² â†’ M) : finsum (Î» (Ab : Î± Ã— Î²), finsum (Î» (h : Ab âˆˆ s), f Ab)) = finsum (Î» (a : Î±), finsum (Î» (b : Î²), finsum (Î» (h : (a, b) âˆˆ s), f (a, b))))
(R : Type u) [Semiring R] [Nontrivial R] [NoZeroDivisors R] {p : â„•} [hp : Char_p R p] (p_NeZero : p â‰  0) : Nat.Prime p
(n : â„•) : (Pgame.powHalf n).numeric
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : HasDist.dist p1 p3 * HasDist.dist p1 p3 = HasDist.dist p1 p2 * HasDist.dist p1 p2 + HasDist.dist p3 p2 * HasDist.dist p3 p2 - 2 * HasDist.dist p1 p2 * HasDist.dist p3 p2 * Real.cos (EuclideanGeometry.angle p1 p2 p3)
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Ring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] [Nonempty Î¹] (f : MultilinearMap R Mâ‚ Mâ‚‚) (p : Î  (i : Î¹), Submodule R (Mâ‚ i)) : â†‘(f.map p).nonempty
{G : Type u_1} [Group G] (H : Subgroup G) {x y : G} : x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topologicalSpace Î±] [uniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [LocallyCompactSpace Î±] : Filter.Tendsto F p (nhds f) â†” TendstoLocallyUniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
{Î± : Type u_1} {Î¹ : Type u_4} {Î¹' : Type u_5} [normedRing Î±] [CompleteSpace Î±] {f : Î¹ â†’ Î±} {g : Î¹' â†’ Î±} (hF : Summable (Î» (x : Î¹), âˆ¥f xâˆ¥)) (hg : Summable (Î» (x : Î¹'), âˆ¥g xâˆ¥)) : (âˆ‘' (x : Î¹), f x) * âˆ‘' (y : Î¹'), g y = âˆ‘' (z : Î¹ Ã— Î¹'), f z.fst * g z.snd
{K : Type u_1} {V : Type u_2} [Field K] [AddCommGroup V] [Module K V] {P : â„™ K V â†’ Prop} (h : âˆ€ (v : V) (h : v â‰  0), P (Projectivization.mk K v h)) (p : â„™ K V) : P p
(p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•) : WittVector.IsPoly p (Î» (R : Type u_1) (_Rcr : CommRing R) (x : WittVector p R), x * â†‘n)
{Î¹ : Type u} {f g : Î¹ â†’ â„} {p q : â„} (hpq : p.is_conjugate_exponent q) (hF : âˆ€ (i : Î¹), 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) (hF_Sum : Summable (Î» (i : Î¹), f i ^ p)) (hg_Sum : Summable (Î» (i : Î¹), g i ^ q)) : Summable (Î» (i : Î¹), f i * g i) âˆ§ âˆ‘' (i : Î¹), f i * g i â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) * (âˆ‘' (i : Î¹), g i ^ q) ^ (1 / q)
{C : Type u} [ð’ž : CategoryTheory.Category C] {X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) [CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)] [CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.prod.fst â‰« f) (CategoryTheory.Limits.prod.snd â‰« g))] : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)
{Î³ : Type w} [LinearOrder Î³] {a b : Î³} {s t : Set Î³} (ha : IsGreatest s a) (hb : IsGreatest t b) : IsGreatest (s âˆª t) (Linear_order.max a b)
(Î¸ : â„‚) (n : â„•) : Polynomial.eval (Complex.cos Î¸) (Polynomial.Chebyshev.u â„‚ n) * Complex.sin Î¸ = Complex.sin ((â†‘n + 1) * Î¸)
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] {f : A â†’â‚[R] B} (hF : Function.Surjective â‡‘f) (hker : f.to_Ring_hom.ker.fg) (hfp : Algebra.FinitePresentation R A) : Algebra.FinitePresentation R B
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} : StrictConcaveOn ð•œ s f â†” Convex ð•œ s âˆ§ âˆ€ â¦ƒx y z : ð•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x)
{Î± : Type u_1} [Semigroup Î±] {a b c : Î±} : a âˆ£ b â†’ b âˆ£ c â†’ a âˆ£ c
{C : Type uâ‚} [CategoryTheory.Category C] (X : C) [h : Î  (Y : C), Unique (X âŸ¶ Y)] : CategoryTheory.Limits.HasInitial C
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [semiNormedGroup Î²] (f : boundedContinuousFunction Î± Î²) (x y : Î±) : HasDist.dist (â‡‘f x) (â‡‘f y) â‰¤ 2 * âˆ¥fâˆ¥
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ hb.oangle x y = 0
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [CompleteSpace â†¥(s.direction)] {ps : Set P} (hnps : ps.nonempty) {p : P} (hps : ps âŠ† â†‘s) (hp : p âˆ‰ s) (hu : âˆƒ! (cccr : P Ã— â„), cccr.fst âˆˆ s âˆ§ âˆ€ (p1 : P), p1 âˆˆ ps â†’ HasDist.dist p1 cccr.fst = cccr.snd) : âˆƒ! (cccrâ‚‚ : P Ã— â„), cccrâ‚‚.fst âˆˆ affineSpan â„ (HasInsert.insert p â†‘s) âˆ§ âˆ€ (p1 : P), p1 âˆˆ HasInsert.insert p ps â†’ HasDist.dist p1 cccrâ‚‚.fst = cccrâ‚‚.snd
(z : UpperHalfPlane) : âˆƒ (g : Matrix.SpecialLinearGroup (Fin 2) â„¤), âˆ€ (g' : Matrix.SpecialLinearGroup (Fin 2) â„¤), (g' â€¢ z).im â‰¤ (g â€¢ z).im
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [CommRing ð•œ] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G] [Module ð•œ E] [Module ð•œ F] [Module ð•œ G] [topologicalSpace E] [topologicalSpace F] [topologicalSpace G] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] [TopologicalAddGroup F] [HasContinuousConstSmul ð•œ F] [TopologicalAddGroup G] [HasContinuousConstSmul ð•œ G] (q : FormalMultilinearSeries ð•œ F G) (p : FormalMultilinearSeries ð•œ E F) (v : Fin 0 â†’ E) (v' : Fin 0 â†’ F) : â‡‘(q.comp p 0) v = â‡‘(q 0) v'
{R : Type u} [Ring R] : Â¬IsField (Polynomial R)
{cd : Fin 2 â†’ â„¤} (hcd : IsCoprime (cd 0) (cd 1)) : Filter.Tendsto (Î» (g : {g // â†‘g 1 = cd}), â‡‘(modular_group.lc_row0 cd) â†‘â†‘g) Filter.cofinite (Filter.cocompact â„)
{Î± : Type u_1} [topologicalSpace Î±] {Î¹ : Type u_2} [hÎ¹ : Nonempty Î¹] [Encodable Î¹] [t2_Space Î±] {s : Î¹ â†’ Set Î±} (hs : âˆ€ (n : Î¹), MeasureTheory.AnalyticSet (s n)) : MeasureTheory.AnalyticSet (â‹‚ (n : Î¹), s n)
{Î± : Type u} (e p : Equiv.perm Î±) : â‡‘(Equiv.perm_congr e) p = e * p * eâ»Â¹
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î²] {f : Î± â†’ Î²} [topologicalSpace Î±] (L : âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (F : Î± â†’ Î²), Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u)) : Continuous f
{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [DecidableRel r] [IsTotal Î± r] [IsTrans Î± r] (l : List Î±) : List.Sorted r (List.insertionSort r l)
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (p : P) : p âˆˆ âŠ¤
(R : Type u_1) {V : Type u_2} {P : Type u_4} [Ring R] [Invertible 2] [AddCommGroup V] [Module R V] [addTorsor V P] (R' : Type u_3) [Ring R'] [Invertible 2] [Module R' V] (x y : P) : midpoint R x y = midpoint R' x y
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ F} {g : F â†’ G} {n : WithTop â„•} (x : E) (hg : ContDiffAt ð•œ n g (f x)) (hF : ContDiffAt ð•œ n f x) : ContDiffAt ð•œ n (g âˆ˜ f) x
{e : â„‚ â†’ â„‚} {e' : â„‚} {z : â„} (h : HasDerivAt e e' â†‘z) : HasDerivAt (Î» (x : â„), (e â†‘x).re) e'.re z
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hs : (s âˆ© Function.MulSupport f).finite) (ht : (t âˆ© Function.MulSupport f).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆ© t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) : 0 = 1 â†” Set.Range â‡‘f = {0}
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] [StrictConvexSpace â„ E] {x y : E} : Â¬SameRay â„ x y â†” âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) {r : â„} (hr : r < 0) : o.oangle x (r â€¢ y) = o.oangle x (-y)
{Î¹ : Type u_1} {E : Type u_3} [semiNormedGroup E] {f : Î¹ â†’ E} (hF : Summable (Î» (i : Î¹), âˆ¥f iâˆ¥)) : âˆ¥âˆ‘' (i : Î¹), f iâˆ¥ â‰¤ âˆ‘' (i : Î¹), âˆ¥f iâˆ¥
{n : â„•} {i : Fin (n + 2)} : SimplexCategoryÎ´ i â‰« SimplexCategoryÎ´ (â‡‘fin.cast_Succ i) = SimplexCategoryÎ´ i â‰« SimplexCategoryÎ´ i.succ
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [topologicalSpace Î²] {f g : Î² â†’ UniformSpace.Completion Î±} (hF : Continuous f) (hg : Continuous g) : Continuous (Î» (x : Î²), HasDist.dist (f x) (g x))
{M : Type u_1} [AddZeroClass M] (s : Set M) {p : Î  (x : M), x âˆˆ AddSubmonoid.closure s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (H1 : p 0 _) (HMul : âˆ€ (x : M) (hx : x âˆˆ AddSubmonoid.closure s) (y : M) (hy : y âˆˆ AddSubmonoid.closure s), p x hx â†’ p y hy â†’ p (x + y) _) {x : M} (hx : x âˆˆ AddSubmonoid.closure s) : p x hx
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : Set.InvOn f g (Function.FixedPoints (f âˆ˜ g)) (Function.FixedPoints (g âˆ˜ f))
{F : Type} [Field F] (q : â„•) [hq : Fact (Nat.Prime q)] [Char_p F q] (g g' : Polynomial F) (m m' : â„•) (h_expand : â‡‘(Polynomial.expand F (q ^ m)) g = â‡‘(Polynomial.expand F (q ^ m')) g') (hg : g.separable) (hg' : g'.separable) : g.nat_degree = g'.nat_degree
{a b c : â„¤} (h : a % b = c) : b âˆ£ a - c
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} {x : Î±} (hx : x âˆˆ s) (Fin : Emetric.hausdorffEdist s t â‰  âŠ¤) : Metric.infDist x t â‰¤ Metric.hausdorffDist s t
{R : Type u} [CommRing R] (S : Submonoid R) {L : Type u} [CommRing L] [Algebra R L] [IsLocalization S L] : Cardinal.mk L â‰¤ Cardinal.mk R
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} [topologicalSpace Î±] (hs : is_IsCompact s) : TendstoLocallyUniformlyOn F f p s â†” TendstoUniformlyOn F f p s
{X : Top} (F : Top.Presheaf (Type v) X) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥X) (sf : Top.Presheaf.SheafConditionEqualizerProducts.piOpens F U) : F.is_compatible U ((F.pi_Opens_iso_sections_family U).hom sf) â†” Top.Presheaf.SheafConditionEqualizerProducts.leftRes F U sf = Top.Presheaf.SheafConditionEqualizerProducts.rightRes F U sf
(n : â„•) : Finset.univ = Finset.cons (fin.last n) (Finset.map fin.cast_succ.to_Embedding Finset.univ) _
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [Module k E] [addTorsor E PE] (f : k â†’ PE) (a b c : k) : ((b - a) / (c - a)) â€¢ slope f a b + ((c - b) / (c - a)) â€¢ slope f b c = slope f a c
(k : Type u_1) {V : Type u_2} (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] : vectorSpan k âˆ… = âŠ¥
{c c' : Î£ (n : â„•), Composition n} : c = c' â†” c.snd.blocks = c'.snd.blocks
{Î± : Type u_1} [Semiring Î±] {m n : â„•} (h : m âˆ£ n) : â†‘m âˆ£ â†‘n
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A B : Matrix n n Î±) : (A.mul B).adjugate = B.adjugate.mul A.adjugate
{M : Type u_4} [groupWithZero M] {f g : â„š â†’*â‚€ M} (same_on_Int : f.comp (Int.castRingHom â„š).to_monoidWithZero_hom = g.comp (Int.castRingHom â„š).to_monoidWithZero_hom) : f = g
{Î² : Type u_1} [CommRing Î²] : fib_rec.char_Poly = Polynomial.x ^ 2 - (Polynomial.x + 1)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (Q : C) (f : CategoryTheory.Over P) : f â‰ˆ â†‘0 â†” f.hom = 0
{Î± : Type u_1} {Î² : Type u_2} (p : Pmf Î±) (f : Î± â†’ Pmf Î²) : p.bind_on_Support (Î» (a : Î±) (_x : a âˆˆ p.support), f a) = p.bind f
{Î± : Type u_1} [GeneralizedBooleanAlgebra Î±] [DecidableRel Disjoint] [DecidableRel LE.le] (u : Î±) (s : Finset Î±) : Uv.IsCompressed u u s
{Î± : Type u_3} {Î² : Type u_4} [linearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto f l Filter.atTop) : Filter.Tendsto (Î» (x : Î²), r * f x) l Filter.atTop
{M : Type u_1} [AddZeroClass M] (S : addSubmonoid M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [is_IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) (h : x â‰  0) : (minpoly A x).coeff 0 â‰  0
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [Preorder Î±] {f : Î± â†’ Set Î²} {g : Î± â†’ Set Î³} (hF : Monotone f) (hg : Monotone g) : Monotone (Î» (x : Î±), f x Ã—Ë¢ g x)
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} {s : Set Î±} (h : is_IsClosed s) : x âˆˆ s â†” Emetric.infEdist x s = 0
{Î¹ : Type u} {Î± : Type v} [DecidableEq Î±] (t : Î¹ â†’ Finset Î±) (h : âˆ€ (s : Finset Î¹), s.card â‰¤ (s.bUnion t).card) (Î¹' : Finset Î¹) : Nonempty â†¥(HallMatchingsOn t Î¹')
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {t : Affine.Triangle â„ P} {iâ‚ iâ‚‚ : Fin 3} {p : P} (hâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hâ‚ : p âˆˆ Affine.Simplex.altitude t iâ‚) (hâ‚‚ : p âˆˆ Affine.Simplex.altitude t iâ‚‚) : p = t.orthocenter
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x y : E) : HasInner.inner x y = (â†‘âˆ¥x + yâˆ¥ ^ 2 - â†‘âˆ¥x - yâˆ¥ ^ 2 + (â†‘âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ ^ 2 - â†‘âˆ¥x + is_R_or_C.I â€¢ yâˆ¥ ^ 2) * is_R_or_C.I) / 4
(p : â„•) {q : â„š} (hq : q â‰  0) : âˆƒ (z : â„¤), padicNorm p q = â†‘p ^ -z
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : HasInner.inner x y = 0 â†” InnerProductGeometry.angle x y = Real.pi / 2
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} (hs : Convex ð•œ s) (hF : âˆ€ {x y z : ð•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)) : ConvexOn ð•œ s f
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [Fintype Î¹] {p : Î¹ â†’ P} (hi : AffineIndependent k p) {sp : AffineSubspace k P} [FiniteDimensional k â†¥(sp.direction)] (hle : affineSpan k (Set.Range p) â‰¤ sp) (hc : Fintype.card Î¹ = FiniteDimensional.finrank k â†¥(sp.direction) + 1) : affineSpan k (Set.Range p) = sp
{Î± : Type u_1} [linearOrderedAddCommGroup Î±] [Archimedean Î±] {a : Î±} (ha : 0 < a) (g : Î±) : âˆƒ! (k : â„¤), k â€¢ a â‰¤ g âˆ§ g < (k + 1) â€¢ a
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f : V â†’â‚—[K] V} : Function.Injective â‡‘f â†” Function.Surjective â‡‘f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q R : C} {f : P âŸ¶ Q} {g : Q âŸ¶ R} (h : CategoryTheory.Exact f g) : (âˆ€ (a : â†¥P), â‡‘g (â‡‘f a) = 0) âˆ§ âˆ€ (b : â†¥Q), â‡‘g b = 0 â†’ (âˆƒ (a : â†¥P), â‡‘f a = b)
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} (incl : s âŠ† t) : Metric.Bounded t â†’ Metric.Bounded s
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] {s : Finset Î±} (hc : s.card â‰¤ 1) {f : Î± â†’ Î²} {b : Î²} (h : s.sum (Î» (x : Î±), f x) = b) (x : Î±) (H : x âˆˆ s) : f x = b
{n : â„•} (p : Fin (n + 1)) (i : Fin n) : â‡‘(p.succ_above) i â‰  p
{Î¹ : Type u_1} {X : Type u_2} [topologicalSpace X] [NormalSpace X] {u : Î¹ â†’ Set X} {s : Set X} (hs : is_IsClosed s) (uo : âˆ€ (i : Î¹), is_IsOpen (u i)) (uf : âˆ€ (x : X), x âˆˆ s â†’ {i : Î¹ | x âˆˆ u i}.finite) (us : s âŠ† â‹ƒ (i : Î¹), u i) : âˆƒ (v : Î¹ â†’ Set X), s âŠ† Set.Union v âˆ§ (âˆ€ (i : Î¹), is_IsOpen (v i)) âˆ§ âˆ€ (i : Î¹), Closure (v i) âŠ† u i
{G : Type u} [AddGroup G] {x : G} (hx : IsOfFinAddOrder x) : IsOfFinAddOrder (-x)
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {X : C} (S : CategoryTheory.Sieve X) : Jâ‚.is_IsClosed (Jâ‚.close S)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [Module ð•œ Î²] [LinearOrder E] {s : Set E} {f : E â†’ Î²} (hs : Convex ð•œ s) (hF : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ð•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)) : ConcaveOn ð•œ s f
{Î± : Type u_1} {P : Set Î± â†’ Prop} {m : Î  (s : Set Î±), P s â†’ Ennreal} {P0 : P âˆ…} {m0 : m âˆ… P0 = 0} {s t : Set Î±} (h : âˆ€ (u : Set Î±), (s âˆ© u).nonempty â†’ (t âˆ© u).nonempty â†’ Â¬P u) : â‡‘(MeasureTheory.inducedOuterMeasure m P0 m0) (s âˆª t) = â‡‘(MeasureTheory.inducedOuterMeasure m P0 m0) s + â‡‘(MeasureTheory.inducedOuterMeasure m P0 m0) t
{n : â„•} (A B : Finset (Fin n)) : (Finset.image (Î» (i : Fin n), â†‘i) A).to_colex < (Finset.image (Î» (i : Fin n), â†‘i) B).to_colex â†” A.to_colex < B.to_colex
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] [Fintype m] [DecidableEq m] (A : Matrix m m Î±) (B : Matrix m n Î±) (C : Matrix n m Î±) (D : Matrix n n Î±) [Invertible A] : (Matrix.fromBlocks A B C D).det = A.det * (D - (C.mul (â…Ÿ A)).mul B).det
{M : Type u_1} [CommMonoid M] (S : Submonoid M) (m : Multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.prod âˆˆ S
{a b : â„•} (hab : a.coprime b) : (a * b).factorization.support = a.factorization.support âˆª b.factorization.support
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : HasDist.dist p3 p1 = HasDist.dist p3 p2) : EuclideanGeometry.angle p3 (midpoint â„ p1 p2) p2 = Real.pi / 2
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] [Nontrivial k] {s : Set P} {p : P} (hp : p âˆˆ s) (w : â†¥s â†’ kË£) : affineSpan k (Set.Range (Î» (q : â†¥s), â‡‘(AffineMap.lineMap p â†‘q) â†‘(w q))) = affineSpan k s
{F : Type u_3} [innerProductSpace â„ F] (x y : F) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” HasInner.inner x y = 0
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Antitone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ico (f n) (f (Order.pred n)))
(p : â„•) [hp : Fact (Nat.Prime p)] : Prime â†‘p â†” p % 4 = 3
{V : Type u_1} [innerProductSpace â„ V] (x y : V) {r : â„} (hr : r < 0) : InnerProductGeometry.angle x (r â€¢ y) = InnerProductGeometry.angle x (-y)
{Î± : Type u} [topologicalSpace Î±] {a : Î±} {p : Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in nhds a, p x) â†” âˆƒ (t : Set Î±), (âˆ€ (x : Î±), x âˆˆ t â†’ p x) âˆ§ is_IsOpen t âˆ§ a âˆˆ t
{G : Type u_1} [Group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : Subgroup G} (h1 : â…â…Hâ‚‚,Hâ‚ƒâ†,Hâ‚â† = âŠ¥) (h2 : â…â…Hâ‚ƒ,Hâ‚â†,Hâ‚‚â† = âŠ¥) : â…â…Hâ‚,Hâ‚‚â†,Hâ‚ƒâ† = âŠ¥
{Î± : Type u} [topologicalSpace Î±] {p : Î± â†’ Prop} {a : Î±} (h : âˆ€á¶  (y : Î±) in nhds a, p y) : âˆ€á¶  (y : Î±) in nhds a, âˆ€á¶  (x : Î±) in nhds y, p x
{Î± : Type u_1} [pseudoEmetricSpace Î±] (C : Ennreal) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (f n) (f (n + 1)) â‰¤ C / 2 ^ n) {a : Î±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) (n : â„•) : HasEdist.edist (f n) a â‰¤ 2 * C / 2 ^ n
(A : Type u_1) (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] : minpoly A 1 = Polynomial.x - 1
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : E â†’ F Ã— G} (hF : ContDiff ð•œ n f) : ContDiff ð•œ n (Î» (x : E), (f x).fst)
(R : Type u_1) [CommRing R] [Fintype R] (p : â„•) [Fact (Nat.Prime p)] : IsUnit â†‘p â†” Â¬p âˆ£ ringChar R
(C : Type u_1) [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.IsIdempotentComplete C â†” âˆ€ (X : C) (p : X âŸ¶ X), p â‰« p = p â†’ CategoryTheory.Limits.HasKernel p
{Î± : Type u_3} [SemilatticeInf Î±] (a : Î±) : Filter.map Coe Filter.atBot = Filter.atBot
{X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X} {eâ‚ eâ‚‚ : X} (hâ‚ : EckmannHilton.IsUnital mâ‚ eâ‚) (hâ‚‚ : EckmannHilton.IsUnital mâ‚‚ eâ‚‚) (Distrib : âˆ€ (a b c d : X), mâ‚ (mâ‚‚ a b) (mâ‚‚ c d) = mâ‚‚ (mâ‚ a c) (mâ‚ b d)) : IsAssociative X mâ‚‚
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : Dense (Closure s) â†’ Dense s
{R : Type u_1} [CommRing R] [is_IsDomain R] (K : Type u_2) [Field K] [Algebra R K] [IsFractionRing R K] : IsIntegrallyClosed R â†” âˆ€ {x : K}, IsIntegral R x â†’ (âˆƒ (y : R), â‡‘(algebraMap R K) y = x)
{C : Type uâ‚} [CategoryTheory.Category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚â‚ƒ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚‚â‚ƒ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚â‚ƒ} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚‚â‚ƒ} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚â‚ƒ : Xâ‚â‚ƒ âŸ¶ Xâ‚‚â‚ƒ} (s : CategoryTheory.IsPullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : CategoryTheory.IsPullback hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚) : CategoryTheory.IsPullback (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : ContinuousMultilinearMap ð•œ E G) : âˆ¥fâˆ¥ = 0 â†” f = 0
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [Semiring R] [AddCommMonoid M] [Module R M] (h : LinearIndependent R v) (f : Î¹' â†’ Î¹) (hF : Function.Injective f) : LinearIndependent R (v âˆ˜ f)
{X : Type u_1} [topologicalSpace X] {Î± : Type u_2} {Î² : Type u_3} (f : X â†’ Î±) (g : Î± â†’ Î²) (h : IsLocallyConstant (g âˆ˜ f)) (inj : Function.Injective g) : IsLocallyConstant f
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) (r : R) (hr : IsUnit r) : Submodule.span R (r â€¢ s) = Submodule.span R s
{Î± : Type u_1} {Î¹ : sort u_3} [conditionallyCompleteLattice Î±] [Nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), f x â‰¤ c) : supr f â‰¤ c
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : IsPreconnected s â†” âˆ€ (u v : Set Î±), is_IsOpen u â†’ is_IsOpen v â†’ s âŠ† u âˆª v â†’ s âˆ© (u âˆ© v) = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} (h : is_is_IsLocalMin f a) : fderiv â„ f a = 0
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) : âˆ¥0âˆ¥ = 0
{ð•œ : Type u_3} {E : Type u_4} [normedField ð•œ] [AddCommGroup E] [normedSpace â„ ð•œ] [Module ð•œ E] [HasScalar â„ E] [isScalarTower â„ ð•œ E] (p : Seminorm ð•œ E) : ConvexOn â„ Set.Univ â‡‘p
(wâ‚ wâ‚‚ pâ‚ pâ‚‚ : Nnreal) : wâ‚ + wâ‚‚ = 1 â†’ pâ‚ ^ â†‘wâ‚ * pâ‚‚ ^ â†‘wâ‚‚ â‰¤ wâ‚ * pâ‚ + wâ‚‚ * pâ‚‚
{Î± : Type u} [t : topologicalSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] {f : Î± â†’ Set Î±} (hF : âˆ€ (x : Î±), f x âˆˆ nhds x) : âˆƒ (s : Set Î±), s.countable âˆ§ (â‹ƒ (x : Î±) (H : x âˆˆ s), f x) = Set.Univ
{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd b = 1) : a âˆ£ c
 : Real.sin (Real.pi / 3) ^ 2 = 3 / 4
{Î± : Type u_1} {râ‚ râ‚‚ : Setoid Î±} : râ‚ = râ‚‚ â†” râ‚.classes = râ‚‚.classes
 : Subgroup.normalClosure {âŸ¨finRotate 5, _âŸ©} = âŠ¤
{R : Type u} {M : Type v} [CommRing R] [Nontrivial R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] (f : M â†’â‚—[R] M) : â‡‘(Polynomial.aeval f) f.charpoly = 0
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {M' : Type u_3} [AddCommGroup M'] [Module R M'] (f : M â‰ƒâ‚—[R] M) (e : M â‰ƒâ‚—[R] M') : â‡‘LinearEquiv.det ((e.symm.trans f).trans e) = â‡‘LinearEquiv.det f
{Î± : Type u_1} {c : Set (Set Î±)} (H : âˆ€ (a : Î±), âˆƒ! (b : Set Î±) (H : b âˆˆ c), a âˆˆ b) {x : Î±} {b b' : Set Î±} (hc : b âˆˆ c) (hb : x âˆˆ b) (hc' : b' âˆˆ c) (hb' : x âˆˆ b') : b = b'
{x y : Pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) : x < y
{R : Type u_1} [nonAssocRing R] [Nontrivial R] (hR : ringChar R â‰  2) : Set.InjOn Coe {0, 1, -1}
{Î¹ : Type u_1} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [AddCommGroup N] {p : Î¹ â†’ AddSubgroup N} (h : CompleteLattice.Independent p) : Function.Injective â‡‘(Dfinsupp.sumAddHom (Î» (i : Î¹), (p i).subtype))
{Î± : Type u} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] : Filter.Tendsto (Î» (r : Î±), râ»Â¹) Filter.atTop (nhdsWithin 0 (Set.Ioi 0))
 : IsCyclic (QuaternionGroup 1)
{n : Type u_3} {Î± : Type v} {Î² : Type w} [hasMul Î±] [hasMul Î²] (f : Î± â†’ Î²) (r : Î±) (A : Matrix n n Î±) (hF : âˆ€ (aâ‚ aâ‚‚ : Î±), f (aâ‚ * aâ‚‚) = f aâ‚ * f aâ‚‚) : (r â€¢ A).map f = f r â€¢ A.map f
{Î· : Type u_2} {Gs : Î· â†’ Type u_3} [Î  (i : Î·), Group (Gs i)] [âˆ€ (i : Î·), group.is_nilpotent (Gs i)] (n : â„•) (h : âˆ€ (i : Î·), group.nilpotency_class (Gs i) â‰¤ n) : group.is_nilpotent (Î  (i : Î·), Gs i)
{Mâ‚€ : Type u_1} [monoidWithZero Mâ‚€] (u : Mâ‚€Ë£) : Ring.inverse â†‘u = â†‘uâ»Â¹
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) (C : â„) {r : Nnreal} (h : âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C) : â†‘r â‰¤ p.radius
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {x : E} {s t : Set E} (h : nhdsWithin x s = nhdsWithin x t) : TangentConeAt ð•œ s x = TangentConeAt ð•œ t x
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} (hF : ConcaveOn ð•œ s f) {x y z : ð•œ} (hx : x âˆˆ s) (hz : z âˆˆ s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x)
{Î± : Type u} [pseudoEmetricSpace Î±] (E : Set Î±) {Î´ : â„} (Î´_Pos : 0 < Î´) : Frontier (Metric.Thickening Î´ E) âŠ† {x : Î± | Emetric.infEdist x E = Ennreal.ofReal Î´}
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {t : Set F} (hs : UniqueDiffOn ð•œ s) (ht : UniqueDiffOn ð•œ t) : UniqueDiffOn ð•œ (s Ã—Ë¢ t)
{Î± : Type u_1} {Î² : Type u_2} [hasMul Î±] [Preorder Î±] [Preorder Î²] [CovariantClass Î± Î± Mul.mul LT.lt] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {f g : Î² â†’ Î±} (hF : Monotone f) (hg : StrictMono g) : StrictMono (Î» (x : Î²), f x * g x)
{Î± : Type u_3} [SemilatticeInf Î±] (a : Î±) : Filter.atBot = Filter.comap Coe Filter.atBot
(R : Type u) [Semiring R] [Nontrivial R] [NoZeroDivisors R] (q : â„•) [hq : ExpChar R q] : Nat.Prime q âˆ¨ q = 1
{S : Type u_1} [Semigroup S] {a b c : S} (hac : Commute a c) (hbc : Commute b c) : Commute (a * b) c
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} : Emetric.hausdorffEdist s (Closure t) = Emetric.hausdorffEdist s t
(x : â„) : LiouvilleWith 1 x
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] (f : G â†’* G') (hF : Function.Surjective â‡‘f) [h : group.is_nilpotent G] : group.nilpotency_class G' â‰¤ group.nilpotency_class G
{Î± : Type u_1} {Î´ : Type u_5} [topologicalSpace Î±] [measurableSpace Î±] [BorelSpace Î±] [measurableSpace Î´] [completeLinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {f : â„• â†’ Î´ â†’ Î±} (hF : âˆ€ (i : â„•), Measurable (f i)) : Measurable (Î» (x : Î´), filter.at_top.limsup (Î» (i : â„•), f i x))
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) {r : â„} : 2 â€¢ hb.oangle x (r â€¢ x) = 0
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [normedSpace ð•œ E] [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {x : E} {f' : E â†’ (E â†’L[ð•œ] G)} (hs : Convex â„ s) {f : E â†’ G} (hder : âˆ€á¶  (y : E) in nhdsWithin x s, HasFderivWithinAt f (f' y) s y) (hcont : ContinuousWithinAt f' s x) : âˆƒ (K : Nnreal) (t : Set E) (H : t âˆˆ nhdsWithin x s), LipschitzOnWith K f t
{M : Type u_6} {N : Type u_7} [hasMul M] [hasMul N] (e : M â‰ƒ* N) (x : M) : â‡‘(e.symm) (â‡‘e x) = x
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [semiNormedGroup E] [normedSpace ð•œ E] {s : Set E} {x' : NormedSpace.Dual ð•œ E} {c : ð•œ} (hc : âˆ€ (z : E), z âˆˆ s â†’ âˆ¥â‡‘x' zâˆ¥ â‰¤ âˆ¥câˆ¥) : câ»Â¹ â€¢ x' âˆˆ NormedSpace.Polar ð•œ s
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
{Î± : Type u_1} [CanonicallyOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b : Î±} [ContravariantClass Î± Î± Add.add LE.le] (h : a â‰¤ b) : b - (b - a) = a
{R : Type u} {L : Type v} [CommRing R] [LieRing L] [lieAlgebra R L] : LieAlgebra.IsNilpotent R â†¥((LieAlgebra.ad R L).range) â†” LieAlgebra.IsNilpotent R L
{P : Type u_2} [metricSpace P] {psâ‚ psâ‚‚ : Set P} (hs : psâ‚ âŠ† psâ‚‚) (hc : EuclideanGeometry.Cospherical psâ‚‚) : EuclideanGeometry.Cospherical psâ‚
 : Real.cos (Real.pi / 6) = Real.sqrt 3 / 2
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [normedSpace ð•œ E] [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ G} {s : Set E} {f' : E â†’ (E â†’L[ð•œ] G)} {C : Nnreal} (hF : âˆ€ (x : E), x âˆˆ s â†’ HasFderivWithinAt f (f' x) s x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥f' xâˆ¥â‚Š â‰¤ C) (hs : Convex â„ s) : LipschitzOnWith C f s
{x : Pgame} : x â‰¤ 0 â†” âˆ€ (i : x.left_moves), (x.move_Left i).lf 0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} : ContDiff ð•œ âŠ¤ f â†” Differentiable ð•œ f âˆ§ ContDiff ð•œ âŠ¤ (Î» (y : E), fderiv ð•œ f y)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] (O : Finset C) (H : Finset (Î£' (X Y : C) (mX : X âˆˆ O) (mY : Y âˆˆ O), X âŸ¶ Y)) {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y} (mf : âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H) : f â‰« CategoryTheory.IsFiltered.toSup O H mY = CategoryTheory.IsFiltered.toSup O H mX
{n : â„•} {E : Type u_1} [NormedGroup E] {f : (Fin n â†’ â„‚) â†’ E} {c : Fin n â†’ â„‚} {R : Fin n â†’ â„} (hF : TorusIntegrable f c R) : TorusIntegrable (-f) c R
{n : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero â†‘â†‘n] [IsCyclotomicExtension {n} K L] (hn : n â‰  2) (hirr : Irreducible (Polynomial.cyclotomic â†‘n K)) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta n K L) = 1
{M : Type u_1} [MulOneClass M] {c : Con M} : Function.Surjective â‡‘(c.mk')
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x : â†¥(NonZeroDivisors R)) : v.int_Valuation_def â†‘x â‰  0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {s : Set E} {f : E â†’ F} {g : E â†’ G} (hF : ContDiffOn ð•œ n f s) (hg : ContDiffOn ð•œ n g s) : ContDiffOn ð•œ n (Î» (x : E), (f x, g x)) s
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {Î¹ : Type u_1} (b : Basis Î¹ R M) [Infinite Î¹] {Îº : Type u_1} (v : Îº â†’ M) (i : LinearIndependent R v) (m : i.maximal) : Cardinal.mk Îº = Cardinal.mk Î¹
{a b : Ennreal} (h : a < b) : AddLeCancellable a
{Î± : sort u_1} (r : Î± â†’ Î± â†’ Prop) : Function.Surjective (Quot.mk r)
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {b : M} [linearOrderedCommRing M] (ht : â†‘(s.card) < t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), â†‘((Finset.filter (Î» (x : Î±), f x = y) s).card) < b
{X : Type u_1} [topologicalSpace X] [CompactSpace X] (A : Subalgebra â„ C(X, â„)) (f : â†¥A) (g : Polynomial â„) : (g.to_Continuous_Map_on (Set.Icc (-âˆ¥fâˆ¥) âˆ¥fâˆ¥)).comp â†‘f.attach_bound âˆˆ A
{E : Type u_2} [semiNormedGroup E] [normedSpace â„ E] (s : Set E) : Metric.diam (â‡‘(convexHull â„) s) = Metric.diam s
{G : Type u_1} [Group G] [hH : group.is_nilpotent G] : group.nilpotency_class (G â§¸ Subgroup.center G) = group.nilpotency_class G - 1
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x y + o.oangle y z + o.oangle z x = 0
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : â‡‘(hb.rotation (hb.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
(n : â„¤) : â‡‘ZmodÏ‡â‚„ â†‘n = Ite (n % 2 = 0) 0 (Ite (n % 4 = 1) 1 (-1))
{X : Type u_1} [topologicalSpace X] {s t : Set X} (ds : discreteTopology â†¥s) (ts : t âŠ† s) : discreteTopology â†¥t
{M : Type u_1} [Monoid M] {x : M} (m : â„•) {n : â„•} (h : x ^ n = 1) : x ^ m = x ^ (m % n)
{Î¹ : Type u} {X : Type v} [topologicalSpace X] {s : Set X} [NormalSpace X] [ParacompactSpace X] (hs : is_IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ (i : Î¹), is_IsOpen (U i)) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : PartitionOfUnity Î¹ X s), f.is_subordinate U
{Fq : Type u_1} [Fintype Fq] [Field Fq] {x y z : Polynomial Fq} {a : â„¤} (hxy : â‡‘Polynomial.cardPowDegree (x - y) < a) (hyz : â‡‘Polynomial.cardPowDegree (y - z) < a) : â‡‘Polynomial.cardPowDegree (x - z) < a
{R : Type u} [Semiring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {M : Type u_1} [AddCommMonoid M] [Module R M] {A : Î¹ â†’ Submodule R M} (h : DirectSum.IsInternal A) : CompleteLattice.Independent A
{x y : Pgame} (r : x.relabelling y) : x.equiv y
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Vâ‚‚ : Type v'} [AddCommGroup Vâ‚‚] [Module K Vâ‚‚] {f : V â†’â‚—[K] Vâ‚‚} (hF : Function.Injective â‡‘f) : FiniteDimensional.finrank K â†¥(f.range) = FiniteDimensional.finrank K V
{Î³ : Type u_1} [NonUnitalNonAssocSemiring Î³] (x : Î³) : IsAddMonoidHom (Î» (y : Î³), x * y)
{R : Type u_1} {E : Type u_2} {F : Type u_3} [AddCommGroup E] [topologicalSpace E] [AddCommGroup F] [topologicalSpace F] [TopologicalAddGroup F] [Ring R] [Module R E] [Module R F] {f : E â†’áµƒ[R] F} : Continuous â‡‘f â†” Continuous â‡‘(f.linear)
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] (a : Î±) [NoMinOrder Î±] : Closure (Set.Iio a) = Set.Iic a
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : â†‘r < p.radius) : âˆƒ (C : Nnreal) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥â‚Š * r ^ n â‰¤ C
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
(Î± : Type u) (Î² : Type u_1) [t : topologicalSpace Î²] [TopologicalSpace.SecondCountableTopology Î²] (f : Î± â†’ Î²) : TopologicalSpace.SecondCountableTopology Î±
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : is_IsClopen s â†’ Frontier s = âˆ…
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s : Set Î±} {b : Î±} (hs : s.nonempty) (h_is_ub : âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ b) (h_b_LE_ub : âˆ€ (ub : Î±), (âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ ub) â†’ b â‰¤ ub) : HasSup.sup s = b
{Î± : Type u_1} {Î² : Type u_2} [measurableSpace Î±] [topologicalSpace Î²] [TopologicalSpace.PseudoMetrizableSpace Î²] [measurableSpace Î²] [BorelSpace Î²] {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hF : âˆ€ (i : â„•), Measurable (f i)) (lim : Filter.Tendsto f Filter.atTop (nhds g)) : Measurable g
{Î± : Type u} [topologicalSpace Î±] {Î¹ : Type u_1} [CompactSpace Î±] {f : Î¹ â†’ Set Î±} (hF : LocallyFinite f) (hne : âˆ€ (i : Î¹), (f i).nonempty) : set.univ.finite
{R : Type u_1} [CommRing R] [is_IsDomain R] (K : Type u_2) [Field K] [Algebra R K] [IsFractionRing R K] : IsIntegrallyClosed R â†” IsIntegralClosure R R K
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : E â†’ F Ã— G} (hF : ContDiff ð•œ n f) : ContDiff ð•œ n (Î» (x : E), (f x).snd)
{R : Type uâ‚} {L : Type uâ‚‚} [CommRing R] [LieRing L] [lieAlgebra R L] [IsNoetherian R L] : LieAlgebra.IsEngelian R L
{R : Type v} [CommRing R] (A : Matrix (Fin 1) (Fin 1) R) : A.det = A 0 0
{Î± : Type u_1} (L : List (List Î±)) {i : â„•} (hi : i < L.length) : List.drop (List.take i (List.map List.length L)).sum (List.take (List.take (i + 1) (List.map List.length L)).sum L.join) = L.nth_LE i hi
{M : Type u_4} [topologicalSpace M] [AddMonoid M] [HasContinuousAdd M] {U : Set M} (hU : U âˆˆ nhds 0) : âˆƒ (V : Set M), is_IsOpen V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U
(n p : â„•) : (Finset.ico 1 (n + 1)).sum (Î» (k : â„•), â†‘k ^ p) = (Finset.range (p + 1)).sum (Î» (i : â„•), bernoulli' i * â†‘((p + 1).choose i) * â†‘n ^ (p + 1 - i) / (â†‘p + 1))
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] [IsNoetherianRing R] : Algebra.FiniteType R A â†” Algebra.FinitePresentation R A
{Î± : Type u_1} [topologicalSpace Î±] [PolishSpace Î±] {s : Set Î±} (hs : is_IsClosed s) : PolishSpace.IsClopenable s
{Î± : Type u} [SemilatticeInf Î±] [OrderTop Î±] {Î¹ : Type u} [Fintype Î¹] (f : Î¹ â†’ Î±) : (âˆ f) = (Fintype.elems Î¹).inf f
{Î± : Type u} {Î² : Type v} [pseudoEmetricSpace Î±] [pseudoEmetricSpace Î²] {f : Î± â†’ Î²} (hF : Isometry f) : UniformInducing f
{Î± : Type u_1} [Preorder Î±] [OrderBot Î±] {a : Î±} : IsAtom a â†’ IsCoatom (â‡‘OrderDual.toDual a)
{Î± : Type u} [hasSsubset Î±] [IsAsymm Î± HasSsubset.Ssubset] {a b : Î±} (h : a âŠ‚ b) : Â¬b âŠ‚ a
{p : â„•} {G : Type u_1} [Group G] {P : Subgroup G} (hP : is_p_Group p â†¥P) : âˆƒ (Q : Sylow p G), P â‰¤ â†‘Q
{M : Type u_1} [Monoid M] : monoid.fg M â†” âˆƒ (S : Set M), Submonoid.closure S = âŠ¤ âˆ§ S.finite
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set â„} [Interval_integral.FTC_Filter b (nhdsWithin b s) (nhdsWithin b t)] (hmeas : StronglyMeasurableAtFilter f (nhdsWithin b t) MeasureTheory.MeasureSpace.volume) (hb : ContinuousWithinAt f t b) : HasDerivWithinAt (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) s b
{C : Type u} [CategoryTheory.Category C] {X Y : C} (i : CategoryTheory.Arrow C) (p : X â‰… Y) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.mk p.hom)
{K : Type u} {V : Type v} {V' : Type v'} [divisionRing K] [AddCommGroup V] [Module K V] [AddCommGroup V'] [Module K V'] (Cond : (Module.rank K V).lift = (Module.rank K V').lift) : Nonempty (V â‰ƒâ‚—[K] V')
 : StrictMono Real.sinh
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹} [uniformSpace Î³] {g : Î² â†’ Î³} (h : TendstoUniformly F f p) (hg : UniformContinuous g) : TendstoUniformly (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ f) p
{a b : â„} : âˆ« (x : â„) in a..b, Real.sin x * Real.cos x = (Real.sin b ^ 2 - Real.sin a ^ 2) / 2
{Î¹ : Type u_1} {X : Type u_2} [topologicalSpace X] [NormalSpace X] {u : Î¹ â†’ Set X} {s : Set X} (v : ShrinkingLemma.PartialRefinement u s) (hs : is_IsClosed s) (i : Î¹) (hi : i âˆ‰ v.carrier) : âˆƒ (v' : ShrinkingLemma.PartialRefinement u s), v < v'
{K : Type u_8} {Kâ‚ : Type u_9} {Vâ‚ : Type u_12} {n : Type u_14} [Field K] [Field Kâ‚] [AddCommGroup Vâ‚] [Module Kâ‚ Vâ‚] {Iâ‚ Iâ‚' : Kâ‚ â†’+* K} {B : Vâ‚ â†’â‚›â‚—[Iâ‚] Vâ‚ â†’â‚›â‚—[Iâ‚'] K} {v : n â†’ Vâ‚} (hvâ‚ : B.is_Ortho v) (hvâ‚‚ : âˆ€ (i : n), Â¬B.is_IsOrtho (v i) (v i)) : LinearIndependent Kâ‚ v
{F : Type u_8} {G : Type u_1} {H : Type u_2} [Group G] [MulOneClass H] [monoidHomClass F G H] (f : F) : Function.Injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 1 â†” a = 1
{n : â„•} (c : Composition n) {j : â„•} (h : j < n) : âˆƒ (i : â„•), j < c.size_Up_to i.succ âˆ§ i < c.length
 : True
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Î¹ : Type w} {s : Finset Î¹} (h : Basis â†¥s K V) : FiniteDimensional K V
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚} (hF : CircleIntegrable f c R) (hw : Complex.abs w < R) : HasSum (Î» (n : â„•), âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z) (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) : hb.oangle 0 x = 0
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {G : C â¥¤ D} {K : CategoryTheory.GrothendieckTopology D} [CategoryTheory.Full G] [CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G) : CategoryTheory.CoverPreserving Hld.induced_topology K G
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), hasZero (Î² i)] {f g : Î â‚€ (i : Î¹), Î² i} : f = g â†” âˆ€ (i : Î¹), â‡‘f i = â‡‘g i
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚} (hD : âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) (hc : ContinuousAt f c) : AnalyticAt â„‚ f c
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : â„•} {i : Fin (n + 1)} : X.Ïƒ i â‰« X.Î´ i.succ = ðŸ™ (X.obj (Opposite.op (SimplexCategory.mk n)))
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (p : P) : Function.Injective (Î» (_x : G), _x +áµ¥ p)
{Î± : Type u} [DecidableEq Î±] (i j : Î±) : Function.involutive (Mul.mul (equiv.swap i j))
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹} [topologicalSpace Î±] [CompactSpace Î±] : TendstoLocallyUniformly F f p â†” TendstoUniformly F f p
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : f' =o[l] g â†’ (Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] g
{Î± : Type u} [orderedSemiring Î±] {a b c d : Î±} [HasExistsAddOfLe Î±] (hab : a < b) (hcd : c < d) : a * d + b * c < a * c + b * d
{Î± : Type u} {L : List (Î± Ã— Bool)} [DecidableEq Î±] : FreeGroup.Red L (FreeGroup.reduce L)
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semiNormedGroup Vâ‚] [semiNormedGroup Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_NormedGroupHom C hâˆ¥ â‰¤ Linear_order.max C 0
{l : Filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in Filter.atTop, HasDerivAt f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in Filter.atTop, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in Filter.atTop, g' x â‰  0) (hftop : Filter.Tendsto f Filter.atTop (nhds 0)) (hgtop : Filter.Tendsto g Filter.atTop (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), f' x / g' x) Filter.atTop l) : Filter.Tendsto (Î» (x : â„), f x / g x) Filter.atTop l
{p : â„•} {R : Type u_1} [hp : Fact (Nat.Prime p)] [CommRing R] (x y : WittVector p R) : â‡‘WittVector.verschiebung (x * â‡‘WittVector.frobenius y) = â‡‘WittVector.verschiebung x * y
{Î± : Type u_1} {m m' : metricSpace Î±} (h : PseudoMetricSpace.toHasDist = PseudoMetricSpace.toHasDist) : m = m'
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [Nonempty Î²] [SemilatticeSup Î²] {s : Î² â†’ Î±} (b : Î² â†’ â„) (h : âˆ€ (n m : Î²), n â‰¤ m â†’ HasDist.dist (s n) (s m) â‰¤ b n) (hâ‚€ : Filter.Tendsto b Filter.atTop (nhds 0)) : CauchySeq s
{p : â„•} [Fact (Nat.Prime p)] {q r : â„š_[p]} : padicNorm_e q â‰  padicNorm_e r â†’ padicNorm_e (q + r) = Linear_order.max (padicNorm_e q) (padicNorm_e r)
{A : Type u_1} {K : Type u_2} [CommRing A] [is_IsDomain A] [UniqueFactorizationMonoid A] [Field K] [Algebra A K] [IsFractionRing A K] {p : Polynomial A} {r : K} (hr : â‡‘(Polynomial.aeval r) p = 0) : â†‘(IsFractionRing.denom A r) âˆ£ p.leading_Coeff
{M : Type u_3} {N : Type u_4} [MulOneClass M] [MulOneClass N] (f : M â†’* N) (a b : M) : â‡‘f (a * b) = â‡‘f a * â‡‘f b
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (hs : is_IsClosed s) : IsPreconnected s â†” âˆ€ (u v : Set Î±), is_IsClosed u â†’ is_IsClosed v â†’ s âŠ† u âˆª v â†’ u âˆ© v = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v
{Î¹ : Type u_1} {ð•œ : Type u_2} [is_R_or_C ð•œ] {E : Type u_3} [innerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), innerProductSpace ð•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ V) [âˆ€ (i : Î¹), CompleteSpace (G i)] (hV' : (â¨† (i : Î¹), (V i).to_LinearMap.range).topological_Closure = âŠ¤) (Wâ‚€ : Î â‚€ (i : Î¹), G i) : â‡‘(â‡‘(hV.linear_Isometry_Equiv hV') (Wâ‚€.sum (Î» (i : Î¹), â‡‘(V i)))) = â‡‘Wâ‚€
(a b : Ennreal) {p q : â„} (hpq : p.is_conjugate_exponent q) : a * b â‰¤ a ^ p / Ennreal.ofReal p + b ^ q / Ennreal.ofReal q
{n : â„•} (a : Fin (n + 1)) : â†‘â†‘a = a
{C : Type u} [CategoryTheory.Category C] {X Y : C} (f : X âŸ¶ Y) (t : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.PushoutCocone.mk (ðŸ™ Y) (ðŸ™ Y) rfl)) : CategoryTheory.Epi f
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : Reflexive r) {x y : Î±} (hr : x â‰  y â†’ r x y) : r x y
{R : Type u} [Ring R] (s : Subring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
{R : Type u_1} (M : Type u_3) [hasZero R] [hasZero M] [smulWithZero R M] (r : R) : r â€¢ 0 = 0
{Î± : Type u_2} {Î² : Type u_3} [SemilatticeInf Î±] [OrderBot Î±] [SemilatticeInf Î²] [OrderBot Î²] {a b : Î±} (f : Î± â‰ƒo Î²) (ha : Disjoint a b) : Disjoint (â‡‘f a) (â‡‘f b)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [SemilatticeInf Î²] {f g : Î± â†’ Î²} (hF : Antitone f) (hg : Antitone g) : Antitone (f âŠ“ g)
(X : AlgebraicGeometry.LocallyRingedSpace (x : â†¥X) : AlgebraicGeometry.StructureSheaf.toStalk â†¥(Opposite.unop (Opposite.op (AlgebraicGeometry.LocallyRingedSpaceÎ“.obj (Opposite.op X)))) (â‡‘(X.to_Î“_spec_SheafedSpace.base) x) â‰« AlgebraicGeometry.PresheafedSpace.stalkMap X.to_Î“_spec_SheafedSpace x = X.Î“_toStalk x
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {Râ‚ Râ‚‚ : â„} {f : â„‚ â†’ E} {c z : â„‚} (hD : DifferentiableOn â„‚ f (Metric.Ball c Râ‚)) (h_maps : Set.MapsTo f (Metric.Ball c Râ‚) (Metric.Ball (f c) Râ‚‚)) (hz : z âˆˆ Metric.Ball c Râ‚) : HasDist.dist (f z) (f c) â‰¤ Râ‚‚ / Râ‚ * HasDist.dist z c
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {X : C} (h : Category_theory.coyoneda.obj (Opposite.op X) â‹™ CategoryTheory.uliftFunctor â‰… F.cocones) (s : CategoryTheory.Limits.Cocone F) : (CategoryTheory.Limits.IsColimit.OfNatIso.colimitCocone h).extend (CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone h s) = s
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_4} [Fintype Î¹] (b : Basis Î¹ R M) : (LinearMap.trace R M).comp (dualTensorHom R M M) = contractLeft R M
{F : Type u_3} [innerProductSpace â„ F] (x y : F) : HasInner.inner (x + y) (x - y) = 0 â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{Î± : Type u_1} [topologicalSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] (m : MeasureTheory.OuterMeasure Î±) {s : Set Î±} (hs : â‡‘m s â‰  0) : âˆƒ (x : Î±) (H : x âˆˆ s), âˆ€ (t : Set Î±), t âˆˆ nhdsWithin x s â†’ 0 < â‡‘m t
{G : Type u_1} [Group G] (H : Subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x / y âˆˆ H
{Î± : Type u_1} {Î² : Type u_2} [AddMonoid Î²] {s : Finset Î±} (f g : Î± â†’ Î²) (comm_ff : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ AddCommute (f x) (f y)) (comm_gg : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ AddCommute (g x) (g y)) (comm_gf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰  y â†’ AddCommute (g x) (f y)) : s.noncomm_Sum (f + g) _ = s.noncomm_Sum f comm_ff + s.noncomm_Sum g comm_gg
(k : Type u_1) (G : Type u_2) [CommSemiring k] [Group G] [Fintype G] [Invertible â†‘(Fintype.card G)] (g : G) : GroupAlgebra.average k G * Finsupp.single g 1 = GroupAlgebra.average k G
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) : â‡‘LinearMap.det â†‘(hb.conj_lie.to_linearEquiv) = -1
 : Irrational goldenRatio
{n : â„¤} : Even n â†’ Even n.nat_Abs
{M : Type u_1} [Monoid M] {x y z : M} : y âˆˆ Powers x â†’ z âˆˆ Powers x â†’ y * z âˆˆ Powers x
{M : Type u_1} [hasMul M] {c d : Con M} (H : âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) : c = d
{n : WithTop â„•} {ð•‚ : Type u_6} [is_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [normedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [normedSpace ð•‚ F'] {f : E' â†’ F'} {f' : E' â†’L[ð•‚] F'} {x : E'} (hF : ContDiffAt ð•‚ n f x) (hF' : HasFderivAt f f' x) (hn : 1 â‰¤ n) : HasStrictFderivAt f f' x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {l : List L} : (âˆ€ (x : L), x âˆˆ l â†’ x âˆˆ S) â†’ l.prod âˆˆ S
{R : Type u} {A : Type v} [CommSemiring R] [Ring A] [Algebra R A] {r : R} {a : A} : r âˆˆ ResolventSet R a â†” IsUnit (resolvent a r)
{Î± : Type u_1} [hasLt Î±] {a b : Î±} (h : a < b) : Â¬a â‹– b â†” âˆƒ (c : Î±), a < c âˆ§ c < b
{Î± : Type u} [Preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b < c) : a < c
(a b : Nnreal) {p q : Nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b â‰¤ a ^ â†‘p / p + b ^ â†‘q / q
 : Cardinal.mk â„ = Cardinal.continuum
(K : Type u) {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {A : Set V} (hA : A.finite) : FiniteDimensional K â†¥(Submodule.span K A)
{Î± : Type u_1} [pseudoMetricSpace Î±] {E' : Type u_2} [NormedGroup E'] [normedSpace â„ E'] [FiniteDimensional â„ E'] {s : Set Î±} {f : Î± â†’ E'} {K : Nnreal} (hF : LipschitzOnWith K f s) : âˆƒ (g : Î± â†’ E'), LipschitzWith (lipschitzExtensionConstant E' * K) g âˆ§ Set.EqOn f g s
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {e e' : localHomeomorph Î± Î²} {f f' : localHomeomorph Î² Î³} (hE : e â‰ˆ e') (hF : f â‰ˆ f') : e.trans f â‰ˆ e'.trans f'
{Î± : Type u_1} {Î¹ : sort u_4} [completeLattice Î±] {b : Î±} {f : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), f i â‰¤ b) (hâ‚‚ : âˆ€ (w : Î±), w < b â†’ (âˆƒ (i : Î¹), w < f i)) : (â¨† (i : Î¹), f i) = b
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {p : P} (hp : p âˆˆ s) {v : V} (hv : v âˆˆ (s.direction)á—®) : â‡‘(EuclideanGeometry.orthogonalProjection s) (v +áµ¥ p) = âŸ¨p, hpâŸ©
{ð•œ : Type u_1} {n : Type u_3} [is_R_or_C ð•œ] [Fintype n] [DecidableEq n] {U : Matrix n n ð•œ} (hU : U âˆˆ Matrix.unitaryGroup n ð•œ) : âˆ¥Uâˆ¥ â‰¤ 1
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} (t : CategoryTheory.Limits.Cofork f g) [CategoryTheory.Mono t.Ï€] : f = g
(ð•‚ : Type u_1) (ð•‚' : Type u_2) (ð”¸ : Type u_3) [Field ð•‚] [Field ð•‚'] [Ring ð”¸] [Algebra ð•‚ ð”¸] [Algebra ð•‚' ð”¸] [topologicalSpace ð”¸] [TopologicalRing ð”¸] : Exp ð•‚ = Exp ð•‚'
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {f' : F} [LinearOrder ð•œ] [OrderClosedTopology ð•œ] {x y : ð•œ} (h : x < y) : HasDerivWithinAt f f' (Set.Ioo x y) x â†’ HasDerivWithinAt f f' (Set.Ioi x) x
{Î± : Type u} {Î¹ : Type u_1} [topologicalSpace Î±] {s : Set Î±} {b : Set Î¹} {c : Î¹ â†’ Set Î±} (hs : is_IsCompact s) (hcâ‚ : âˆ€ (i : Î¹), i âˆˆ b â†’ is_IsOpen (c i)) (hcâ‚‚ : s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ b), c i) : âˆƒ (b' : Set Î¹) (H : b' âŠ† b), b'.finite âˆ§ s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ b'), c i
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) (z : N) (w v : P) : â‡‘(f.lift hg) z * w = v â†” â‡‘g (f.sec z).fst * w = â‡‘g â†‘((f.sec z).snd) * v
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X Y : C} {R : CategoryTheory.Presieve X} {x : CategoryTheory.Presieve.FamilyOfElements P R} (t : x.compatible) {f : Y âŸ¶ X} (hF : R f) : x.sieve_extend f _ = x f hF
(L : List â„•) (h : âˆ€ (i : â„•), i âˆˆ L â†’ 1 â‰¤ i) : L.length â‰¤ L.sum
{R : Type u} [Ring R] (s : Subring R) {l : List R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
{E : Type u_1} [semiNormedGroup E] [normedSpace â„ E] {x y : E} (h : SameRay â„ x y) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f g : V â†’â‚—[K] V} (hfg : f * g = 1) : g * f = 1
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} (hF : HasFpowerSeriesAt f p x) : (Î» (y : E Ã— E), f y.fst - f y.snd - â‡‘(p 1) (Î» (_x : Fin 1), y.fst - y.snd)) =O[nhds (x, x)] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.sndâˆ¥
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) {u : â„• â†’ Î±} {init : Fin E.order â†’ Î±} (h : E.is_solution u) (HEq : âˆ€ (n : Fin E.order), u â†‘n = init n) (n : â„•) : u n = E.mk_sol init n
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {n : â„•} : ContDiff ð•œ â†‘(n + 1) f â†” Differentiable ð•œ f âˆ§ ContDiff ð•œ â†‘n (Î» (y : E), fderiv ð•œ f y)
{R : Type u_2} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] {M : Type u_3} [AddCommGroup M] [Module R M] {Î¹ : Type u_1} [Fintype Î¹] (b : Basis Î¹ R M) (N : Submodule R M) : âˆƒ (n : â„•), Nonempty (Basis (Fin n) R â†¥N)
{Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [AddCommMonoid Î²] (R : Setoid Î±) [DecidableRel Setoid.r] (h : âˆ€ (x : Î±), x âˆˆ s â†’ (Finset.filter (Î» (y : Î±), y â‰ˆ x) s).sum (Î» (a : Î±), f a) = 0) : s.sum (Î» (x : Î±), f x) = 0
{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) {P : Î  (x : CliffordAlgebra Q), x âˆˆ CliffordAlgebra.evenOdd Q 1 â†’ Prop} (hÎ¹ : âˆ€ (v : M), P (â‡‘(CliffordAlgebraÎ¹ Q) v) _) (HAdd : âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1} {hy : y âˆˆ CliffordAlgebra.evenOdd Q 1}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_Mul : âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q 1}, P x hx â†’ P (â‡‘(CliffordAlgebraÎ¹ Q) mâ‚ * â‡‘(CliffordAlgebraÎ¹ Q) mâ‚‚ * x) _) (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q 1) : P x hx
{M : Type u_1} {N : Type u_2} {Î± : Type u_6} {Î² : Type u_7} [HasScalar M Î±] [HasScalar Î² Î±] [SmulCommClass Î² M Î±] (g : N â†’ M) : SmulCommClass Î² N Î±
{m : Type u_1} {A : Type u_3} [Fintype m] [CommRing A] [is_IsDomain A] [DecidableEq m] {M : Matrix m m A} (hM : M.det â‰  0) : M.nondegenerate
{Î± : Type u_1} {Î² : Type u_2} {e e' : LocalEquiv Î± Î²} (h : e â‰ˆ e') : e.symm â‰ˆ e'.symm
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} : Emetric.hausdorffEdist (Closure s) (Closure t) = Emetric.hausdorffEdist s t
{R : Type u} {M : Type v} [Monoid R] [mulAction R M] {p : SubMulAction R M} (m : â†¥p) : MulAction.Stabilizer.submonoid R m = MulAction.Stabilizer.submonoid R â†‘m
{Î± : Type u_2} [DecidableEq Î±] {B : Finset (Finset Î±)} {n : â„•} [Fintype Î±] (h : âˆ€ (a : Î±), (Finset.filter (HasMem.Mem a) B).card â‰¤ n) : B.sum (Î» (s : Finset Î±), s.card) â‰¤ Fintype.card Î± * n
{G : Type u_1} [Group G] {H : Type u_2} [Group H] (f : G â†’* H) (hF1 : f.ker â‰¤ Subgroup.center G) (hH : group.is_nilpotent H) : group.is_nilpotent G
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a b : Î±} : a â‰¤ bâ»Â¹ â†’ b â‰¤ aâ»Â¹
{Î² : Type u_2} [pseudoMetricSpace Î²] {Î± : Type u_1} [metricSpace Î±] {K : Nnreal} {f : Î± â†’ Î²} [ProperSpace Î±] (hK : AntilipschitzWith K f) (f_Cont : Continuous f) (hF : Function.Surjective f) : ProperSpace Î²
{Î± : Type u} [emetricSpace Î±] {s t : TopologicalSpace.Closeds Î±} : HasEdist.edist s t = Emetric.hausdorffEdist â†‘s â†‘t
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) : 0 âˆˆ s
{X : Type u_2} [emetricSpace X] [measurableSpace X] [OpensMeasurableSpace X] (m : Set X â†’ Ennreal) (hcl : âˆ€ (s : Set X), m (Closure s) = m s) (r : Ennreal) : (MeasureTheory.OuterMeasure.mkMetric'.pre m r).trim = MeasureTheory.OuterMeasure.mkMetric'.pre m r
{Î¹ : Type u_1} {R : Type u_2} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] {M : Type u_3} [AddCommGroup M] [Module R M] [Fintype Î¹] (b : Basis Î¹ R M) (N O : Submodule R M) (N_LE_O : N â‰¤ O) : âˆƒ (n o : â„•) (hno : n â‰¤ o) (bO : Basis (Fin o) R â†¥O) (bN : Basis (Fin n) R â†¥N) (a : Fin n â†’ R), âˆ€ (i : Fin n), â†‘(â‡‘bN i) = a i â€¢ â†‘(â‡‘bO (â‡‘(fin.cast_LE hno) i))
{Î± : Type u} [topologicalSpace Î±] [t2_Space Î±] [CompactSpace Î±] [TotallyDisconnectedSpace Î±] {x : Î±} {U : Set Î±} (is_IsOpen : _root_.is_IsOpen U) (memU : x âˆˆ U) : âˆƒ (V : Set Î±) (hV : is_IsClopen V), x âˆˆ V âˆ§ V âŠ† U
{Î± : Type u_1} {n : Type u_2} {m : Type u_3} [hasMul Î±] [AddCommMonoid Î±] (A : Matrix m n Î±) [Fintype n] : A.transpose.has_Orthogonal_cols â†” A.has_Orthogonal_rows
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {E' : Type u_6} [NormedGroup E'] [normedSpace ð•œ E'] {F' : Type u_7} [NormedGroup F'] [normedSpace ð•œ F'] {s : Set E} {t : Set E'} {f : E â†’ F} {g : E' â†’ F'} {p : E Ã— E'} (hF : ContDiffWithinAt ð•œ n f s p.fst) (hg : ContDiffWithinAt ð•œ n g t p.snd) : ContDiffWithinAt ð•œ n (Prod.map f g) (s Ã—Ë¢ t) p
{ð•œ : Type u_1} [is_R_or_C ð•œ] {E : Type u_2} {E' : Type u_3} [innerProductSpace ð•œ E] [innerProductSpace ð•œ E'] (f : E â‰ƒâ‚—áµ¢[ð•œ] E') (K : Submodule ð•œ E) [CompleteSpace â†¥K] (x : E') : â‡‘(reflection (Submodule.map â†‘(f.to_linearEquiv) K)) x = â‡‘f (â‡‘(reflection K) (â‡‘(f.symm) x))
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x y : E} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + HasInner.inner x y + HasInner.inner y x + HasInner.inner y y
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [AddCommGroup Î²] {f : Î± â†’ Î²} (hF : IsAddGroupHom f) : IsAddGroupHom (Î» (a : Î±), -f a)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {tâ‚ tâ‚‚ : Affine.Triangle â„ P} {iâ‚ iâ‚‚ iâ‚ƒ jâ‚ jâ‚‚ jâ‚ƒ : Fin 3} (hiâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hiâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hiâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) (hjâ‚â‚‚ : jâ‚ â‰  jâ‚‚) (hjâ‚â‚ƒ : jâ‚ â‰  jâ‚ƒ) (hjâ‚‚â‚ƒ : jâ‚‚ â‰  jâ‚ƒ) (hâ‚ : tâ‚‚.points jâ‚ = tâ‚.orthocenter) (hâ‚‚ : tâ‚‚.points jâ‚‚ = tâ‚.points iâ‚‚) (hâ‚ƒ : tâ‚‚.points jâ‚ƒ = tâ‚.points iâ‚ƒ) : Affine.Simplex.altitude tâ‚‚ jâ‚‚ = affineSpan â„ {tâ‚.points iâ‚, tâ‚.points iâ‚‚}
{Î± : Type u_1} {G : Type u_4} [completeLattice Î±] [Group G] (fâ‚ fâ‚‚ : G â†’* Î± â‰ƒo Î±) (g : G) : Function.Semiconj (Î» (x : Î±), â¨† (g' : G), â‡‘(â‡‘fâ‚ g')â»Â¹ (â‡‘(â‡‘fâ‚‚ g') x)) â‡‘(â‡‘fâ‚‚ g) â‡‘(â‡‘fâ‚ g)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall f p x r) (h : â†‘r' < r) : âˆƒ (a : â„) (H : a âˆˆ Set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (y : E), y âˆˆ Metric.Ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥f (x + y) - p.partial_Sum n yâˆ¥ â‰¤ C * a ^ n
(p : â„•) [Fact (Nat.Prime p)] {a : â„¤} : Zmod.legendreSym p a = -1 â†” Â¬IsSquare â†‘a
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] {i : Î± â†’ Î²} [topologicalSpace Î³] [t2_Space Î³] {f : Î± â†’ Î³} (di : DenseInducing i) (hF : âˆ€ (b : Î²), âˆƒ (c : Î³), Filter.Tendsto f (Filter.comap i (nhds b)) (nhds c)) (a : Î±) : di.extend f (i a) = f a
{R : Type u} [CommSemiring R] {Î¹ : Type u_1} (s : Finset Î¹) (p : Î¹ â†’ Polynomial R) (x : R) : Polynomial.eval x (s.prod (Î» (j : Î¹), p j)) = s.prod (Î» (j : Î¹), Polynomial.eval x (p j))
{Î± : Type u} [PartialOrder Î±] [OrderBot Î±] {a : Î±} : IsMin a â†’ a = âŠ¥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] {F G : Top.Sheaf C X} (f : F âŸ¶ G) : CategoryTheory.IsIso f â†” âˆ€ (x : â†¥X), CategoryTheory.IsIso ((Top.Presheaf.stalkFunctor C x).map f)
{C : Type uâ‚} [CategoryTheory.Category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚ƒâ‚ Xâ‚ƒâ‚‚ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚ƒâ‚ : Xâ‚ƒâ‚ âŸ¶ Xâ‚ƒâ‚‚} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚ƒâ‚} {vâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚ƒâ‚‚} (s : CategoryTheory.IsPushout hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚) (p : hâ‚‚â‚ â‰« vâ‚‚â‚‚ = vâ‚‚â‚ â‰« hâ‚ƒâ‚) (t : CategoryTheory.IsPushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) : CategoryTheory.IsPushout hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±) : â‡‘f (a + b) = â‡‘f a + â‡‘f b
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) {Î² : Type u_1} (s : Finset Î²) (f : n â†’ Î² â†’ Î±) (i : n) : s.sum (Î» (x : Î²), â‡‘(A.cramer) (Î» (j : n), f j x) i) = â‡‘(A.cramer) (Î» (j : n), s.sum (Î» (x : Î²), f j x)) i
{Î± : Type u} (L : List Î±) {i j : â„•} (hi : i < (List.take j L).length) : (List.take j L).nth_LE i hi = L.nth_LE i _
{Î± : Type u_1} [CircularPreorder Î±] {a b c : Î±} (h : HasBtw.Btw a b c) : Â¬HasSbtw.Sbtw c b a
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : â‡‘(o.rotation (o.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{Î± : Type u_1} {E : Type u_2} [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] {f : Î± â†’ E} : Summable (Î» (x : Î±), âˆ¥f xâˆ¥) â†” Summable f
{M : Type u} [Monoid M] {a : M} {x y : MË£} (h : SemiconjBy a â†‘x â†‘y) : SemiconjBy a â†‘xâ»Â¹ â†‘yâ»Â¹
{M : Type u_2} [AddCommGroup M] {A : Type u_5} [CommRing A] [Module A M] {N : Type u_1} [AddCommGroup N] [Module A N] (f : M â†’â‚—[A] M) (e : M â‰ƒâ‚—[A] N) : â‡‘LinearMap.det (â†‘e.comp (f.comp â†‘(e.symm))) = â‡‘LinearMap.det f
{E : Type u_2} [semiNormedGroup E] [starAddMonoid E] [NormedStarGroup E] : Isometry HasStar.star
{Î¹ : Type u_1} [Fintype Î¹] [DecidableEq Î¹] (t : Matrix.TransvectionStruct Î¹ â„) : MeasureTheory.MeasurePreserving â‡‘(â‡‘Matrix.toLin' t.to_Matrix) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [CompactSpace Î±] [metricSpace Î²] : Continuous coeFn
{T : Type uâ‚} [CategoryTheory.Category T] {X : T} {f g : CategoryTheory.Over X} (k : f âŸ¶ g) [hk : CategoryTheory.Mono k.left] : CategoryTheory.Mono k
{Î± : Type u} {Î² : Type v} (f : Î± â‰ƒ. Î²) (aâ‚‚ : Î±) (h : âˆ€ (aâ‚ : Î±), aâ‚ â‰  aâ‚‚ â†’ â†¥((â‡‘f aâ‚).is_Some)) : Function.Injective â‡‘f
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r r' : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) (hr : r' < r) : (Î» (y : E Ã— E), f y.fst - f y.snd - â‡‘(p 1) (Î» (_x : Fin 1), y.fst - y.snd)) =O[Filter.principal (Emetric.Ball (x, x) r')] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.sndâˆ¥
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {vâ‚ vâ‚‚ : M} (h : vâ‚ âˆˆ MulAction.Orbit â†¥(Units.posSubgroup R) vâ‚‚) : SameRay R vâ‚ vâ‚‚
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasFiniteColimits C] : CategoryTheory.Limits.HasFiniteWidePushouts C
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [CommRing ð•œ] [AddCommGroup E] [AddCommGroup F] [Module ð•œ E] [Module ð•œ F] [topologicalSpace E] [topologicalSpace F] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] [TopologicalAddGroup F] [HasContinuousConstSmul ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {n : â„•} (c : Composition n) (j : Fin n) (v : Fin n â†’ E) (z : E) : p.apply_Composition c (Function.update v j z) = Function.update (p.apply_Composition c v) (c.index j) (â‡‘(p (c.blocks_fun (c.index j))) (Function.update (v âˆ˜ â‡‘(c.embedding (c.index j))) (c.inv_Embedding j) z))
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : (Closure s).nonempty â†’ s.nonempty
{x y : Pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) : x â‰¤ y
{n : â„•} (p : Fin n â†’ Prop) [DecidablePred p] {i : Fin n} (hi : i âˆˆ fin.find p) : p i
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] [t1_Space Î²] {f : Î± â†’ Î²} {a : Î±} {b : Î²} (h : Filter.Tendsto f (nhds a) (nhds b)) : f a = b
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization M S] {Î¹ : Type u_3} [Fintype Î¹] (f : Î¹ â†’ S) : âˆƒ (b : â†¥M), âˆ€ (i : Î¹), IsLocalization.IsInteger R (â†‘b â€¢ f i)
{Î± : Type u} {l : List Î±} : l.nodup â†’ l.sublists'.nodup
{K : Type u_1} {S : Type u_2} [Field K] [CommRing S] [Algebra K S] {R : Type u_3} [CommRing R] [Algebra R S] [Algebra R K] [isScalarTower R K S] {B B' : powerBasis K S} {P : Polynomial R} (h : â‡‘(Polynomial.aeval B.gen) P = B'.gen) (hB : IsIntegral R B.gen) (hmin : minpoly K B.gen = Polynomial.map (algebraMap R K) (minpoly R B.gen)) (i : Fin B.dim) (j : Fin B'.dim) : IsIntegral R (B.basis.to_Matrix â‡‘(B'.basis) i j)
{R : Type u} {S : Type v} [Semiring R] [Semiring S] (f : R â†’+* S) {r : R} : r âˆˆ f.ker â†” â‡‘f r = 0
{K : Type u} [Field K] (s : Subfield K) {Î¹ : Type u_1} {t : Finset Î¹} {f : Î¹ â†’ K} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.sum (Î» (i : Î¹), f i) âˆˆ s
{X : Type u} [Preorder X] {x y : X} (h : x âŸ¶ y) : x â‰¤ y
{n : WithTop â„•} {ð•‚ : Type u_6} [is_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [normedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [normedSpace ð•‚ F'] {f : E' â†’ F'} {x : E'} (hF : ContDiff ð•‚ n f) (hn : 1 â‰¤ n) : HasStrictFderivAt f (fderiv ð•‚ f x) x
{R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) (s : Set Mâ‚‚) : Submodule.span R (â‡‘f â»Â¹' s) â‰¤ Submodule.comap f (Submodule.span Râ‚‚ s)
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) (hF'' : DifferentiableOn â„ (deriv f) (Interior D)) (hF''_nonneg : âˆ€ (x : â„), x âˆˆ Interior D â†’ 0 â‰¤ deriv^[2] f x) : ConvexOn â„ D f
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {R : â„} (h0 : 0 â‰¤ R) {f : â„‚ â†’ E} {c : â„‚} {s : Set â„‚} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball c R  s â†’ DifferentiableAt â„‚ f z) : âˆ® (z : â„‚) in C(c, R), f z = 0
{Î± : Type u} [Ring Î±] : is_RingHom.id
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f g : E â†’ Î²} (hF : StrictConvexOn ð•œ s f) (hg : StrictConvexOn ð•œ s g) : StrictConvexOn ð•œ s (f âŠ” g)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) : 1 âˆˆ S
{Gâ‚€ : Type u_2} [groupWithZero Gâ‚€] (a : Gâ‚€) : a * a * aâ»Â¹ = a
{Î¹ : Type w} {Î¹' : Type u_1} [Fintype Î¹'] [Fintype Î¹] (K : Type u) [Field K] [NumberField K] {b : Basis Î¹ â„š K} {b' : Basis Î¹' â„š K} (h : âˆ€ (i : Î¹) (j : Î¹'), IsIntegral â„¤ (b.to_Matrix â‡‘b' i j)) (h' : âˆ€ (i : Î¹') (j : Î¹), IsIntegral â„¤ (b'.to_Matrix â‡‘b i j)) : Algebra.discr â„š â‡‘b = Algebra.discr â„š â‡‘b'
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p q : FormalMultilinearSeries ð•œ E F) : Linear_order.min p.radius q.radius â‰¤ (p + q).radius
{Î± : Type u_1} (r : Setoid Î±) : setoid.ker Quotient.mk = r
(c : CliffordAlgebra CliffordAlgebraComplex.q) : â‡‘CliffordAlgebraComplex.toComplex (â‡‘CliffordAlgebra.involute c) = â‡‘(starRingEnd â„‚) (â‡‘CliffordAlgebraComplex.toComplex c)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) : p.remove_zero.right_Inv i = p.right_Inv i
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i j : Fin (n + 1)} (H : i â‰¤ j) : X.Ïƒ (â‡‘fin.cast_Succ i) â‰« X.Ïƒ j = X.Ïƒ j.succ â‰« X.Ïƒ i
{Î± : Type u} [orderedSemiring Î±] {a b c d : Î±} [HasExistsAddOfLe Î±] (hab : a â‰¤ b) (hcd : c â‰¤ d) : a * d + b * c â‰¤ a * c + b * d
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) (h_anti : StrictAntiOn (deriv f) (Interior D)) : StrictConcaveOn â„ D f
{n : Type u_5} {R : Type u_8} [topologicalSpace R] [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R] (A : Matrix n n R) (h : ContinuousAt Ring.inverse A.det) : ContinuousAt Inv.inv A
{M : Type u_1} [hasAdd M] (S : AddSubsemigroup M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
{Î± : Type u_1} {Î² : Type u_2} [hasMul Î±] [Preorder Î±] [Preorder Î²] {f g : Î² â†’ Î±} [CovariantClass Î± Î± Mul.mul LE.le] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] (hF : Monotone f) (hg : Monotone g) : Monotone (Î» (x : Î²), f x * g x)
{Î± : Type v} [CanonicallyOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] [ContravariantClass Î± Î± Add.add LE.le] {f : â„• â†’ Î±} (h : Monotone f) (n : â„•) : (Finset.range n).sum (Î» (i : â„•), f (i + 1) - f i) = f n - f 0
{R : Type u_1} [CommRing R] [is_IsDomain R] {a b c : R} (h2 : 2 â‰  0) (ha : a â‰  0) (h : âˆ€ (s : R), discrim a b c â‰  s * s) (x : R) : a * x * x + b * x + c â‰  0
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : Set P} (ho : EuclideanGeometry.OrthocentricSystem s) {p : Fin 3 â†’ P} (hps : Set.Range p âŠ† s) (hpi : Function.Injective p) : AffineIndependent â„ p
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : Vector Î± n) : (Vector.scanl f b v).to_List = List.scanl f b v.to_List
(Î± : Type u_1) [metricSpace Î±] [CompleteSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] [Nonempty Î±] : âˆƒ (f : (â„• â†’ â„•) â†’ Î±), Continuous f âˆ§ Function.Surjective f
{Gâ‚€ : Type u_2} [groupWithZero Gâ‚€] {p : Î  (g : Gâ‚€), g â‰  0 â†’ Prop} : (âˆƒ (g : Gâ‚€) (hg : g â‰  0), p g hg) â†” âˆƒ (g : Gâ‚€Ë£), p â†‘g _
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x : V} (hx : x â‰  0) (Î¸ : Real.Angle) : x = â‡‘(o.rotation Î¸) x â†” Î¸ = 0
(k : Type u_1) {Pâ‚ : Type u_2} {Vâ‚ : Type u_6} [Ring k] [AddCommGroup Vâ‚] [Module k Vâ‚] [addTorsor Vâ‚ Pâ‚] {x y : Pâ‚} (h : Function.Injective bit0) : â‡‘(AffineEquiv.pointReflection k x) y = y â†” y = x
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e e' : localHomeomorph Î± Î²} (hE : e â‰ˆ e') (s : Set Î±) : e.restr s â‰ˆ e'.restr s
{Î± : sort u} {Î² : sort v} {Î³ : sort w} {g : Î² â†’ Î³} (hg : Function.bijective g) : Function.bijective (Function.comp g)
{Î± : Type u_1} [measurableSpace Î±] {Î¹ : Type u_2} [Encodable Î¹] {f : Î¹ â†’ Î± â†’ Ennreal} (h : âˆ€ (i : Î¹), Measurable (f i)) : Measurable (Î» (x : Î±), âˆ‘' (i : Î¹), f i x)
{R : Type u_1} [orderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (u : RË£) (hu : â†‘u < 0) (v : Module.Ray R M) : u â€¢ v = -v
{K : Type u_1} [linearOrderedField K] [floorRing K] {v : K} {q : â„š} (v_Eq_q : v = â†‘q) : {h := â†‘((GeneralizedContinuedFraction.of q).h), s := seq.map (GeneralizedContinuedFraction.Pair.map Coe) (GeneralizedContinuedFraction.of q).s} = GeneralizedContinuedFraction.of v
{M : Type u_1} {Î± : Type u_6} [Monoid M] [mulAction M Î±] [hasMul Î±] (r s : M) (x y : Î±) [isScalarTower M Î± Î±] [SmulCommClass M Î± Î±] : r â€¢ x * s â€¢ y = (r * s) â€¢ (x * y)
{R : Type u} [Semiring R] : AddSubmonoid.closure {p : Polynomial R | âˆƒ (n : â„•) (a : R), p = â‡‘(Polynomial.monomial n) a} = âŠ¤
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (r : R) (n : â„•) : v.int_Valuation_def r â‰¤ â†‘(â‡‘Multiplicative.ofAdd (-â†‘n)) â†” v.as_Ideal ^ n âˆ£ Ideal.span {r}
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) {v : Vector Î± n} : (Vector.scanl f b v).val = List.scanl f b v.val
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {J' : Type uâ‚‚} [CategoryTheory.Category J'] (e : J â‰Œ J') [CategoryTheory.Limits.HasLimitsOfShape J C] : CategoryTheory.Limits.HasLimitsOfShape J' C
{B : Type u} [CategoryTheory.Bicategory B] {a b : B} {f g h i : a âŸ¶ b} [CategoryTheory.Bicategory.LiftHom f] [CategoryTheory.Bicategory.LiftHom g] [CategoryTheory.Bicategory.LiftHom h] (Î· : f âŸ¶ g) (Î¸ : g âŸ¶ h) (Î¹ : h âŸ¶ i) [CategoryTheory.Bicategory.LiftHomâ‚‚ Î·] [CategoryTheory.Bicategory.LiftHomâ‚‚ Î¸] : Î· â‰« Î¸ â‰« Î¹ = (Î· â‰« Î¸) â‰« Î¹
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e : localHomeomorph Î± Î²} {s : Set Î±} {t : Set Î²} : e.is_image s t â†’ e.to_local_equiv.source âˆ© â‡‘e â»Â¹' t = e.to_local_equiv.source âˆ© s
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {x : E} {s : Set E} (h : x âˆ‰ Closure s) : HasFderivWithinAt f f' s x
{M : Type u_1} [hasMul M] {r : M â†’ M â†’ Prop} {c : Con M} (h : âˆ€ (x y : M), r x y â†’ Setoid.r x y) : conGen r â‰¤ c
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type w} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (hu : CategoryTheory.CoverLifting J K G) (â„± : CategoryTheory.Sheaf J A) {X : A} {U : D} {S : CategoryTheory.Sieve U} (hS : S âˆˆ â‡‘K U) {x : CategoryTheory.Presieve.FamilyOfElements ((CategoryTheory.ran G.op).obj â„±.val â‹™ Category_theory.coyoneda.obj (Opposite.op X)) S.arrows} (hx : x.compatible) (y : ((CategoryTheory.ran G.op).obj â„±.val â‹™ Category_theory.coyoneda.obj (Opposite.op X)).obj (Opposite.op U)) (hy : x.is_amalgamation y) : y = CategoryTheory.RanIsSheafOfCoverLifting.gluedSection hu â„± hS hx
(b : â„¤) : b â‰¤ b ^ 2
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a : Î±} {s : Set Î±} (ha : is_is_IsLub s a) (hs : s.nonempty) (sc : is_IsClosed s) : a âˆˆ s
{z : UpperHalfPlane} (hz : z âˆˆ ModularGroup.Fdo) (n : â„¤) : 1 < â‡‘Complex.normSq â†‘(ModularGroup.t ^ n â€¢ z)
{Î± : Type u_1} [normedRing Î±] [CompleteSpace Î±] {f g : â„• â†’ Î±} (hF : Summable (Î» (x : â„•), âˆ¥f xâˆ¥)) (hg : Summable (Î» (x : â„•), âˆ¥g xâˆ¥)) : (âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (Finset.Nat.antidiagonal n).sum (Î» (kl : â„• Ã— â„•), f kl.fst * g kl.snd)
{M : Type u_1} {R : Type u_2} [Monoid M] [NonUnitalNonAssocRing R] [DistribMulAction M R] (k : M) (h : âˆ€ (x : R), k â€¢ x = 0 â†’ x = 0) {a b : R} (h' : k â€¢ a = k â€¢ b) : a = b
{g : Equiv.perm (Fin 5)} (h : 3 âˆˆ g.cycle_type) : (g * g).is_three_Cycle
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.CoproductsDisjoint C] : CategoryTheory.Limits.InitialMonoClass C
{S : Type u_2} [CommRing S] (A : Type u_6) [CommRing A] [is_IsDomain A] [Algebra A S] {M : Submonoid A} [IsLocalization M S] (hM : M â‰¤ NonZeroDivisors A) : is_IsDomain S
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {bâ‚‚ : Basis (Fin 2) â„ V} (hbâ‚‚ : Orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = -bâ‚‚.orientation) : âˆƒ (Î¸ : Real.Angle), bâ‚‚ = b.map (hb.conj_lie.trans (hb.rotation Î¸)).to_linearEquiv
(n : â„•) {R : Type u_1} [linearOrderedCommRing R] {x : R} (hx : 1 < x) : 0 < Polynomial.eval x (Polynomial.cyclotomic n R)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {f g : â„ â†’ E} {x : â„} (f_Diff : âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) (hF : ContinuousAt f x) (hg : ContinuousAt g x) (y : â„) : HasDerivAt f (g y) y
{Î± : Type u_1} [LinearOrder Î±] {A B : Finset Î±} (t : Î±) (hâ‚ : A.to_colex < B.to_colex) (hâ‚‚ : âˆ€ (x : Î±), x âˆˆ B â†’ x < t) (x : Î±) (H : x âˆˆ A) : x < t
{R : Type u} [Ring R] {S : Type v} [Ring S] (f : R â†’+* S) (p : Polynomial S) : p âˆˆ Polynomial.lifts f â†” p âˆˆ Polynomial.liftsRing f
{Î± : Type u_1} [CanonicallyOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b c : Î±} [ContravariantClass Î± Î± Add.add LE.le] (h : a + c < b) : a < b - c
{Î² : Type u} {Î± : Type v} {Î³ : Type w} {s : Finset Î±} [CommMonoid Î²] [DecidableEq Î³] (f : Î³ â†’ Î²) (g : Î± â†’ Î³) : s.prod (Î» (a : Î±), f (g a)) = (Finset.image g s).prod (Î» (b : Î³), f b ^ (Finset.filter (Î» (a : Î±), g a = b) s).card)
{K : Type u} [Field K] {s : Set K} {t : Subfield K} : Subfield.closure s â‰¤ t â†” s âŠ† â†‘t
{Î± : Type u} {Î² : Type v} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hF : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), f x * g x) l Filter.atBot
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : Affine.Simplex â„ P 1) : s.circumcenter = Finset.centroid â„ Finset.univ s.points
{Î² : Type u_2} {f g : Î² â†’ â„} (hg : âˆ€ (b : Î²), 0 â‰¤ g b) (hgf : âˆ€ (b : Î²), g b â‰¤ f b) (hF : Summable f) : Summable g
{Î± : Type u} [metricSpace Î±] [ProperSpace Î±] {s : Set Î±} (hs : is_IsClosed s) {R : Î± â†’ â„} (hR : âˆ€ (x : Î±), x âˆˆ s â†’ 0 < R x) : âˆƒ (Î¹ : Type u) (c : Î¹ â†’ Î±) (r r' : Î¹ â†’ â„), (âˆ€ (i : Î¹), c i âˆˆ s âˆ§ 0 < r i âˆ§ r i < r' i âˆ§ r' i < R (c i)) âˆ§ LocallyFinite (Î» (i : Î¹), Metric.Ball (c i) (r' i)) âˆ§ s âŠ† â‹ƒ (i : Î¹), Metric.Ball (c i) (r i)
{M : Type u_1} [Monoid M] {s t : Set M} (h : s âŠ† t) : monoid.closure s âŠ† monoid.closure t
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (hab : a < b) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : â‡‘(AffineMap.lineMap (f a) (f b)) r < f (â‡‘(AffineMap.lineMap a b) r) â†” slope f (â‡‘(AffineMap.lineMap a b) r) b < slope f a (â‡‘(AffineMap.lineMap a b) r)
{ð•œ : Type u_1} {E : Type u_2} [normedField ð•œ] [hasNorm E] {a : ð•œ} {f : ð•œ â†’ E} (h : Filter.IsBoundedUnder LE.le (nhdsWithin a {a}á¶œ) (HasNorm.norm âˆ˜ f)) : f =o[nhdsWithin a {a}á¶œ] Î» (x : ð•œ), (x - a)â»Â¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasCokernels C] : CategoryTheory.Limits.HasCoequalizers C
{M : Type u_3} {N : Type u_4} [AddZeroClass M] [AddZeroClass N] (f : M â†’+ N) (a b : M) : â‡‘f (a + b) = â‡‘f a + â‡‘f b
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (f : J â†’ C) [CategoryTheory.Limits.HasBiproduct f] {b : CategoryTheory.Limits.Bicone f} (hb : b.is_bilimit) : (hb.is_limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.Biproduct.isLimit f)).inv = CategoryTheory.Limits.biproduct.desc b.Î¹
{R : Type u_2} [CommRing R] [is_IsDomain R] [DecidableEq R] [Fintype R] {p : Polynomial R} (hp : 0 < p.degree) : Fintype.card R â‰¤ p.nat_degree * (Finset.image (Î» (x : R), Polynomial.eval x p) Finset.univ).card
{K : Type u_1} [linearOrderedField K] {a b c : K} (ha : a â‰  0) (h : âˆ€ (x : K), 0 < a * x * x + b * x + c) : discrim a b c < 0
{Î± : Type u} {Î¹ : Type u_1} {s : Set Î¹} (hs : s.finite) {t : Î  (i : Î¹), i âˆˆ s â†’ Set Î±} (ht : âˆ€ (i : Î¹) (H : i âˆˆ s), (t i H).finite) : (â‹ƒ (i : Î¹) (H : i âˆˆ s), t i H).finite
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] {F : Type w} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace ð•œ] [FiniteDimensional ð•œ E] [FiniteDimensional ð•œ F] (Cond : FiniteDimensional.finrank ð•œ E = FiniteDimensional.finrank ð•œ F) : Nonempty (E â‰ƒL[ð•œ] F)
{Î± : Type u} {Î² : Type v} [MulOneClass Î±] [MulOneClass Î²] {f : Î± â†’ Î²} (hF : IsMonoidHom f) (x y : Î±) : f (x * y) = f x * f y
{p a b : â„•} (hpb : p âˆˆ b.factors) (ha : a â‰  0) : p âˆˆ (a * b).factors
{Î± : Type u_1} [HasLe Î±] {a : Î±áµ’áµˆ} : IsMax a â†’ IsMin (â‡‘OrderDual.ofDual a)
{J : Type u} [CategoryTheory.Category J] [CategoryTheory.IsCofiltered J] (F : J â¥¤ Type v) [Î  (j : J), Fintype (F.obj j)] [âˆ€ (j : J), Nonempty (F.obj j)] : F.sections.nonempty
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î²'] [DecidableEq Î³] [DecidableEq Î´] {f : Î± â†’ Î² â†’ Î³} {s : Finset Î±} {t : Finset Î²} {g : Î³ â†’ Î´} {f' : Î²' â†’ Î± â†’ Î´} {g' : Î² â†’ Î²'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' (g' b) a) : Finset.image g (Finset.imageâ‚‚ f s t) = Finset.imageâ‚‚ f' (Finset.image g' t) s
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) [Nontrivial Î²] : â‡‘f 1 â‰  0
{R : Type u_1} {G : Type u_2} [AddCommGroup G] [CommRing R] [Nontrivial R] : Algebra.FiniteType R (AddMonoidAlgebra R G) â†” Add_group.fg G
{E : Type u_2} {ð•œ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] {s : Set E} (hs : Convex ð•œ s) {x y : E} (hx : x âˆˆ s) (hy : x + y âˆˆ Interior s) {t : ð•œ} (ht : t âˆˆ Set.Ioc 0 1) : x + t â€¢ y âˆˆ Interior s
(x : â„‚) : HasDerivAt Complex.sinh (Complex.cosh x) x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} (h : â†‘s.nonempty) : AffineSubspace.directionOfNonempty h = s.direction
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [DecidableEq Î¹] [Î  (i : Î¹), hasZero (Î± i)] {s : Finset Î¹} {f : Î â‚€ (i : Î¹), Î± i} [Î  (i : Î¹), DecidableEq (Î± i)] {t : Î â‚€ (i : Î¹), Finset (Î± i)} (ht : t.support âŠ† s) : f âˆˆ s.dfinsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘f i âˆˆ â‡‘t i
(p : â„•) [hp : Fact (Nat.Prime p)] (q r : â„š) : padicNorm p (q * r) = padicNorm p q * padicNorm p r
{Î± : Type u_1} [Fintype Î±] : Nonempty (Field Î±) â†” IsPrimePow (Fintype.card Î±)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace E] {v : E} (hv : v âˆˆ K) : â‡‘(reflection Ká—®) v = -v
{Î³ : Type w} [Preorder Î³] [OrderTop Î³] (s : Set Î³) : BddAbove s
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} : Emetric.hausdorffEdist s t = Emetric.hausdorffEdist t s
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (v w : E) (H : w âˆˆ K) : HasInner.inner (v - â†‘(â‡‘(orthogonalProjection K) v)) w = 0
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [topologicalSpace Î±] [topologicalSpace Î²] {i : Î± â†’ Î²} [topologicalSpace Î´] {f : Î³ â†’ Î±} {g : Î³ â†’ Î´} {h : Î´ â†’ Î²} {d : Î´} {a : Î±} (di : DenseInducing i) (H : Filter.Tendsto h (nhds d) (nhds (i a))) (comm : h âˆ˜ g = i âˆ˜ f) : Filter.Tendsto f (Filter.comap g (nhds d)) (nhds a)
{Î± : Type u} [HasSubset Î±] [hasSsubset Î±] [isNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {a b : Î±} [IsAntisymm Î± HasSubset.Subset] (hâ‚ : a âŠ† b) (hâ‚‚ : a â‰  b) : a âŠ‚ b
{Î¹ : Type u_1} {X : Type u_2} [topologicalSpace X] [NormalSpace X] {u : Î¹ â†’ Set X} {s : Set X} {c : Set (ShrinkingLemma.PartialRefinement u s)} (hc : IsChain LE.le c) (NE : c.nonempty) (hfin : âˆ€ (x : X), x âˆˆ s â†’ {i : Î¹ | x âˆˆ u i}.finite) (hU : s âŠ† â‹ƒ (i : Î¹), u i) {v : ShrinkingLemma.PartialRefinement u s} (hv : v âˆˆ c) : v â‰¤ ShrinkingLemma.PartialRefinement.chainSup c hc NE hfin hU
{n : Type u_3} [Fintype n] {A : Type u_1} [DecidableEq n] [CommRing A] [is_IsDomain A] {M : Matrix n n A} : M.det â‰  0 â†’ M.nondegenerate
{a : â„} {l : Filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Iio a), DifferentiableAt â„ f x) (hg' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Iio a), deriv g x â‰  0) (hfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0)) (hga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv f x / deriv g x) (nhdsWithin a (Set.Iio a)) l) : Filter.Tendsto (Î» (x : â„), f x / g x) (nhdsWithin a (Set.Iio a)) l
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] {x y : X} {Î³ : Y â†’ Path x y} {f : Y â†’ â„} (hÎ³ : Continuous â†¿Î³) (hF : Continuous f) : Continuous (Î» (t : Y), (Î³ t).extend (f t))
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
{ð•œ : Type u_1} [is_R_or_C ð•œ] [decð•œ : DecidableEq ð•œ] {E : Type u_2} [innerProductSpace ð•œ E] {T : E â†’â‚—[ð•œ] E} (hT : InnerProductSpace.IsSelfAdjoint T) [FiniteDimensional ð•œ E] {n : â„•} (hn : FiniteDimensional.finrank ð•œ E = n) (v : E) (i : Fin n) : â‡‘(hT.diagonalization_Basis hn) (â‡‘T v) i = â†‘(hT.eigenvalues hn i) * â‡‘(hT.diagonalization_Basis hn) v i
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s t : Set Î±} (ht : IsAntichain r t) (h : Maximals r s âŠ† t) (hs : âˆ€ â¦ƒa : Î±â¦„, a âˆˆ t â†’ (âˆƒ (b : Î±) (H : b âˆˆ Maximals r s), r b a)) : Maximals r s = t
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} (hs : is_IsClosed s) (ht : is_IsClosed t) (Fin : Emetric.hausdorffEdist s t â‰  âŠ¤) : Metric.hausdorffDist s t = 0 â†” s = t
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) (z : Î± (fin.last n)) : fin.init (Function.update q (fin.last n) z) = fin.init q
{Î± : Type u} [t : topologicalSpace Î±] {b : Set (Set Î±)} (hb : TopologicalSpace.IsTopologicalBasis b) {s : Set Î±} : Dense s â†” âˆ€ (o : Set Î±), o âˆˆ b â†’ o.nonempty â†’ (o âˆ© s).nonempty
{G : Type u_1} [Group G] {H K : Subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] {E1 E2 : intermediateField K L} (h12 : E1 â‰¤ E2) : E2.fixing_Subgroup â‰¤ E1.fixing_Subgroup
{Î± : Type u} [Preorder Î±] {a b : Î±} (h : a < b) : a â‰  b
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : p -áµ¥ â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p) âˆˆ (s.direction)á—®
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = â†‘Real.pi
(R : Type u_1) (S : Type u_2) [Ring R] [Ring S] [is_IsDomain (R Ã— S)] [Nontrivial R] [Nontrivial S] : False
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} {c : CategoryTheory.Limits.Cofork f g} (i : CategoryTheory.Limits.IsColimit c) : CategoryTheory.Epi c.Ï€
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {M : Type u_6} [CommSemiring R] [AddCommMonoid M] [Module R M] (b : Basis Î¹ R M) (b' : Basis Î¹' R M) [Fintype Î¹'] [Fintype Î¹] [DecidableEq Î¹] : â‡‘(LinearMap.toMatrix b b') LinearMap.id = b'.to_Matrix â‡‘b
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] [denselyOrdered Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhdsWithin a (Set.Ici a) â†” âˆƒ (u : Î±) (H : u âˆˆ Set.Ioi a), Set.Icc a u âŠ† s
{G : Type u_1} {M : Type u_3} [Group G] [Monoid M] [mulAction G M] [SmulCommClass G M M] [isScalarTower G M M] (g : G) (m : MË£) : (g â€¢ m)â»Â¹ = gâ»Â¹ â€¢ mâ»Â¹
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : intermediateField K L) : E.map (AlgHom.id K L) = E
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {f : M â†’+ P} : (AddCon.kerLift f).mrange = f.mrange
{Î¹ : Type u} (f : Î¹ â†’ Cardinal) : BddAbove (Set.Range f)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : hb.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) : o.oangle x x = 0
{K : Type u} {V : Type v} {V' : Type v'} [divisionRing K] [AddCommGroup V] [Module K V] [AddCommGroup V'] [Module K V'] : Nonempty (V â‰ƒâ‚—[K] V') â†” (Module.rank K V).lift = (Module.rank K V').lift
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] [NoMinOrder Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhds a â†” âˆƒ (l u : Î±), a âˆˆ Set.Ioo l u âˆ§ Set.Ioo l u âŠ† s
{Î¹ : Type u_1} {Máµ¢ : Î¹ â†’ Type u_7} [Î  (i : Î¹), AddCommGroup (Máµ¢ i)] [Fintype Î¹] {R : Type u_2} [orderedRing R] [Î  (i : Î¹), Module R (Máµ¢ i)] {Q : Î  (i : Î¹), QuadraticForm R (Máµ¢ i)} (h : (QuadraticForm.pi Q).anisotropic) (i : Î¹) : (Q i).anisotropic
{S : Type u} [hasAdd S] {a x y : S} (h : AddSemiconjBy a x y) : a + x = y + a
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasCokernel f] [CategoryTheory.Epi f] : CategoryTheory.Limits.cokernelÏ€ f = 0
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x z - hb.oangle x y = hb.oangle y z
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {G : Î¹ â†’ Type u_5} [Î  (i : Î¹), innerProductSpace ð•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ V) [CompleteSpace E] (f : Î  (i : Î¹), G i) : Summable (Î» (i : Î¹), â‡‘(V i) (f i)) â†” Summable (Î» (i : Î¹), âˆ¥f iâˆ¥ ^ 2)
{a : â„•} : Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {s1 s2 : AffineSubspace k P} (h : s1 < s2) (hn : â†‘s1.nonempty) : s1.direction < s2.direction
{n : â„•} {E : Type u_1} [NormedGroup E] {f : (Fin n â†’ â„‚) â†’ E} {c : Fin n â†’ â„‚} {R : Fin n â†’ â„} [normedSpace â„‚ E] (hF : TorusIntegrable f c R) : MeasureTheory.IntegrableOn (Î» (Î¸ : Fin n â†’ â„), finset.univ.prod (Î» (i : Fin n), â†‘(R i) * Complex.exp (â†‘(Î¸ i) * Complex.i) * Complex.i) â€¢ f (torusMap c R Î¸)) (Set.Icc 0 (Î» (_x : Fin n), 2 * Real.pi)) MeasureTheory.MeasureSpace.volume
{K : Type u_4} {V : Type u} [Field K] [AddCommGroup V] [Module K V] (p : Submodule K V) (hp : p < âŠ¤) : âˆƒ (f : V â†’â‚—[K] K) (H : f â‰  0), p â‰¤ f.ker
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {n : WithTop â„•} {x : G} (g : G â†’L[ð•œ] E) (hF : ContDiffWithinAt ð•œ n f s (â‡‘g x)) : ContDiffWithinAt ð•œ n (f âˆ˜ â‡‘g) (â‡‘g â»Â¹' s) x
{R : Type u_1} [Semiring R] (P : Polynomial R â†’ Prop) (N : â„•) (P_0 : P 0) (P_C_Mul_Pow : âˆ€ (n : â„•) (r : R), r â‰  0 â†’ n â‰¤ N â†’ P (â‡‘Polynomial.c r * Polynomial.x ^ n)) (P_C_Add : âˆ€ (f g : Polynomial R), f.nat_degree < g.nat_degree â†’ g.nat_degree â‰¤ N â†’ P f â†’ P g â†’ P (f + g)) (f : Polynomial R) : f.nat_degree â‰¤ N â†’ P f
{Î± : Type u_1} {r s : Setoid Î±} : (r âŠ“ s).rel = r.rel âŠ“ s.rel
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [LinearOrder Î²] [succOrder Î²] [IsSuccArchimedean Î²] [Nonempty Î²] {s : Î² â†’ Set Î±} (H : âˆ€ (n : Î²), IsConnected (s n)) (K : âˆ€ (n : Î²), (s n âˆ© s (Order.succ n)).nonempty) : IsConnected (â‹ƒ (n : Î²), s n)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x y : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) (h : â†‘âˆ¥yâˆ¥â‚Š < r) : HasFpowerSeriesOnBall f (p.change_origin y) (x + y) (r - â†‘âˆ¥yâˆ¥â‚Š)
{Î± : Type u} {u : Ultrafilter (Ultrafilter Î±)} {x : Ultrafilter Î±} : â†‘u â‰¤ nhds x â†” x = mjoin u
{Î“ : Type u_4} [Group Î“] {T : Type u_5} [topologicalSpace T] [mulAction Î“ T] [HasContinuousConstSmul Î“ T] : is_is_IsOpenMap Quotient.mk
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) (i : Fin n) (y : Î± (â‡‘fin.cast_Succ i)) : fin.init (Function.update q (â‡‘fin.cast_Succ i) y) = Function.update (fin.init q) i y
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} (h : SameRay R x y) (hx : x â‰  0) (hy : y â‰  0) : âˆƒ (râ‚ râ‚‚ : R), 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y
{Î± : Type u_1} [topologicalSpace Î±] [t2_Space Î±] [measurableSpace Î±] [BorelSpace Î±] {s t : Set Î±} (hs : MeasureTheory.AnalyticSet s) (ht : MeasureTheory.AnalyticSet t) (h : Disjoint s t) : MeasureTheory.MeasurablySeparable s t
{p : â„•} {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime p)] [CommRing R] [CommRing S] (f : R â†’+* S) (x : WittVector p R) : â‡‘(WittVector.map f) (â‡‘WittVector.verschiebung x) = â‡‘WittVector.verschiebung (â‡‘(WittVector.map f) x)
{x y z : â„¤} (k : â„¤) (hk : k â‰  0) : PythagoreanTriple (k * x) (k * y) (k * z) â†” PythagoreanTriple x y z
{Î± : Type u_2} {Î¹ : Type u_5} [CommMonoid Î±] (t : Finset Î¹) (f : Î¹ â†’ Set Î±) (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), i âˆˆ t â†’ g i âˆˆ f i) : t.prod (Î» (i : Î¹), g i) âˆˆ t.prod (Î» (i : Î¹), f i)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [LinearOrder Î²] {f g : Î± â†’ Î²} (hF : Monotone f) (hg : Monotone g) : Monotone (Î» (x : Î±), Linear_order.min (f x) (g x))
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Kâ‚ Kâ‚‚ : Submodule ð•œ E} [FiniteDimensional ð•œ â†¥Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) {n : â„•} (h_dim : FiniteDimensional.finrank ð•œ â†¥Kâ‚ + n = FiniteDimensional.finrank ð•œ â†¥Kâ‚‚) : FiniteDimensional.finrank ð•œ â†¥(Kâ‚á—® âŠ“ Kâ‚‚) = n
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [Module R P] (huniv : âˆ€ {M : Type (max v u)} {N : Type (max u v)} [_inst_4 : AddCommGroup M] [_inst_5 : AddCommGroup N] [_inst_6 : Module R M] [_inst_7 : Module R N] (f : M â†’â‚—[R] N) (g : P â†’â‚—[R] N), Function.Surjective â‡‘f â†’ (âˆƒ (h : P â†’â‚—[R] M), f.comp h = g)) : Module.Projective R P
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [semiNormedGroup Î²] (b : Î²) : âˆ¥BoundedContinuousFunction.const Î± bâˆ¥ â‰¤ âˆ¥bâˆ¥
{n a : â„•} (h : a < n + 1) : â†‘a.val = a
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linearOrderedField ð•œ] [AddCommGroup E] [OrderedAddCommGroup Î²] [Module ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} {t : Finset Î¹} {w : Î¹ â†’ ð•œ} {p : Î¹ â†’ E} (hF : ConcaveOn ð•œ s f) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hâ‚ : t.sum (Î» (i : Î¹), w i) = 1) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : t.sum (Î» (i : Î¹), w i â€¢ f (p i)) â‰¤ f (t.sum (Î» (i : Î¹), w i â€¢ p i))
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} (hs : s.nonempty) (ht : t.nonempty) : Emetric.hausdorffEdist s t â‰¤ Emetric.diam (s âˆª t)
(V : Type u_1) [semiNormedGroup V] (h : âˆƒ (x : V), âˆ¥xâˆ¥ â‰  0) : âˆ¥NormedGroupHom.id Vâˆ¥ = 1
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} {s t : Set Î±} (h : x âˆˆ s) : Emetric.infEdist x t â‰¤ Emetric.hausdorffEdist s t
{C : Type uâ‚} [CategoryTheory.Category C] {J : Type uâ‚‚} [CategoryTheory.Category J] (F : J â¥¤ Cáµ’áµ–) [CategoryTheory.Limits.HasColimit F.left_Op] : CategoryTheory.Limits.HasLimit F
{b m : â„•} (hb : 2 â‰¤ b) : m < b ^ (b.digits m).length
 : Cardinal.ord âˆ˜ Cardinal.aleph = Ordinal.enumOrd {b : Ordinal | b.card.ord = b âˆ§ Ordinal.omega â‰¤ b}
{R : Type u} [Ring R] {p : Polynomial R} (r : R) : Polynomial.eval r (p * (Polynomial.x - â‡‘Polynomial.c r)) = 0
{Î± : Type u} [SemilatticeSup Î±] [OrderBot Î±] {Î¹ : Type u} [Fintype Î¹] (f : Î¹ â†’ Î±) : (âˆ f) = (Fintype.elems Î¹).sup f
{M : Type u_1} [hasAdd M] (s : Set M) {p : Î  (x : M), x âˆˆ AddSubsemigroup.closure s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (HMul : âˆ€ (x : M) (hx : x âˆˆ AddSubsemigroup.closure s) (y : M) (hy : y âˆˆ AddSubsemigroup.closure s), p x hx â†’ p y hy â†’ p (x + y) _) {x : M} (hx : x âˆˆ AddSubsemigroup.closure s) : p x hx
{R : Type u_1} [linearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [FiniteDimensional R M] [Nonempty Î¹] (x : Orientation R M Î¹) (h : Fintype.card Î¹ = FiniteDimensional.finrank R M) : (x.some_Basis h).orientation = x
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [normedSpace ð•œ E'] {n : WithTop â„•} {f : E â†’ E'} {s : Set E} {x : E} : ContMdiffWithinAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') n f s x â†’ ContDiffWithinAt ð•œ n f s x
{Î± : Type u} {Î² : Type v} {f : Î± â‰ƒ. Î²} (h : âˆ€ (a : Î±), â†¥((â‡‘f a).is_Some)) : Function.Injective â‡‘f
(x : â„) : Real.sinh x = (Real.exp x - Real.exp (-x)) / 2
{R : Type u_1} [CommSemiring R] (s : Subsemiring R) {Î¹ : Type u_2} {t : Finset Î¹} {f : Î¹ â†’ R} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.prod (Î» (i : Î¹), f i) âˆˆ s
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [orderedRing ð•œ] [AddCommGroup E] [AddCommGroup F] [Module ð•œ E] [Module ð•œ F] (f : E â†’áµƒ[ð•œ] F) {s : Set F} (hs : Convex ð•œ s) : Convex ð•œ (â‡‘f â»Â¹' s)
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [hasZero M] [CommMonoid N] {s : Finset Î±} {f : Î± â†’ M} {g : Î± â†’ M â†’ N} (hF : âˆ€ (a : Î±), f a â‰  0 â†’ a âˆˆ s) (hg : âˆ€ (a : Î±), g a 0 = 1) : (Finsupp.onFinset s f hF).prod g = s.prod (Î» (a : Î±), g a (f a))
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasFiniteCoproducts C] : CategoryTheory.Limits.HasFiniteBiproducts C
{Î±' : sort w} [DecidableEq Î±'] {Î± : sort u_1} {Î² : sort u_2} (g : Î±' â†’ Î²) {f : Î± â†’ Î±'} {i : Î±'} (a : Î²) (h : âˆ€ (x : Î±), f x â‰  i) : Function.update g i a âˆ˜ f = g âˆ˜ f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {p : E Ã— F} : ContDiffAt ð•œ n Prod.fst p
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] (f : MultilinearMap R Mâ‚ Mâ‚‚) {Î± : Î¹ â†’ Type u_1} (g : Î  (i : Î¹), Î± i â†’ Mâ‚ i) [Fintype Î¹] [Î  (i : Î¹), Fintype (Î± i)] : â‡‘f (Î» (i : Î¹), finset.univ.sum (Î» (j : Î± i), g i j)) = finset.univ.sum (Î» (r : Î  (i : Î¹), Î± i), â‡‘f (Î» (i : Î¹), g i (r i)))
{Î± : sort u_1} {Î² : sort u_2} {sâ‚ : Setoid Î±} {sâ‚‚ : Setoid Î²} {p : Quotient sâ‚ â†’ Quotient sâ‚‚ â†’ Prop} (h : âˆ€ (aâ‚ : Î±) (aâ‚‚ : Î²), p (Quotient.mk' aâ‚) (Quotient.mk' aâ‚‚)) (qâ‚ : Quotient sâ‚) (qâ‚‚ : Quotient sâ‚‚) : p qâ‚ qâ‚‚
{Î± : Type u_1} (f : Î± â†’ Nnreal) : Filter.Tendsto (Î» (s : Finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) Filter.atTop (nhds 0)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} {x : Î±} {s : Set Î±} : ContinuousWithinAt f s x â†’ ContinuousWithinAt f (HasInsert.insert x s) x
(a : â†¥Circle) : â‡‘LinearEquiv.det (â‡‘rotation a).to_linearEquiv = 1
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommGroup E] [HasScalar ð•œ E] {S : ConvexCone ð•œ E} (hS : S.flat) : S.pointed
(K : Type u_1) (L : Type u_2) {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [isScalarTower K L A] (A_alg : Algebra.IsAlgebraic K A) : Algebra.IsAlgebraic L A
{Î± : Type u_1} [topologicalSpace Î±] [PolishSpace Î±] {s : Set Î±} (hs : is_IsClosed s) : PolishSpace â†¥s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q) : Function.Surjective â‡‘f â†’ CategoryTheory.Epi f
{n : â„•} (a : Zmod n) : â†‘â†‘a = a
{E : â„• â†’ Type u_1} {Î± : Type u_2} [pseudoMetricSpace Î±] {f : (Î  (n : â„•), E n) â†’ Î±} : (âˆ€ (x y : Î  (n : â„•), E n), HasDist.dist (f x) (f y) â‰¤ HasDist.dist x y) â†” âˆ€ (x y : Î  (n : â„•), E n) (n : â„•), y âˆˆ PiNat.Cylinder x n â†’ HasDist.dist (f x) (f y) â‰¤ (1 / 2) ^ n
{Î¹ : Type u_1} {E : Type u_3} [semiNormedGroup E] {f : Î¹ â†’ E} {g : Î¹ â†’ Nnreal} {a : Nnreal} (hg : HasSum g a) (h : âˆ€ (i : Î¹), âˆ¥f iâˆ¥â‚Š â‰¤ g i) : âˆ¥âˆ‘' (i : Î¹), f iâˆ¥â‚Š â‰¤ a
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x y : E) (h : HasInner.inner x y = 0) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{Î± : Type u_1} [linearOrderedField Î±] {a b c d : Î±} (hc : c â‰  0) (hD : d â‰  0) : a / c < b / d â†’ (a * d - b * c) / (c * d) < 0
{E : Type u_2} [AddCommGroup E] [Module â„ E] (f : LinearPmap â„ E â„) (N : E â†’ â„) (N_hom : âˆ€ (c : â„), 0 < c â†’ âˆ€ (x : E), N (c â€¢ x) = c * N x) (N_Add : âˆ€ (x y : E), N (x + y) â‰¤ N x + N y) (hF : âˆ€ (x : â†¥(f.domain)), â‡‘f x â‰¤ N â†‘x) : âˆƒ (g : E â†’â‚—[â„] â„), (âˆ€ (x : â†¥(f.domain)), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ€ (x : E), â‡‘g x â‰¤ N x
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) : TendstoLocallyUniformlyOn (Î» (n : â„•) (y : E), p.partial_Sum n (y - x)) f Filter.atTop (Emetric.Ball x r)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} {Fâ‚— : Type u_7} [NormedGroup E] [NormedGroup F] [NormedGroup Fâ‚—] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] [normedSpace ð•œ Fâ‚—] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (f : E â†’sl[Ïƒâ‚â‚‚] F) [CompleteSpace F] (e : E â†’L[ð•œ] Fâ‚—) (h_Dense : DenseRange â‡‘e) {N : Nnreal} (h_e : âˆ€ (x : E), âˆ¥xâˆ¥ â‰¤ â†‘N * âˆ¥â‡‘e xâˆ¥) [RingHomIsometric Ïƒâ‚â‚‚] : âˆ¥f.extend e h_Dense _âˆ¥ â‰¤ â†‘N * âˆ¥fâˆ¥
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a : â„} {s : Set â„} (hintg : âˆ€ (x : â„), x âˆˆ s â†’ IntervalIntegrable f MeasureTheory.MeasureSpace.volume a x) (hcont : Continuous f) : DifferentiableOn â„ (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s
{R : Type u_1} {a : R} [MulZeroClass R] [Nontrivial R] (la : IsRegular a) : a â‰  0
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R) (r : R) : â‡‘(v.valuation) (â‡‘(algebraMap R K) r) = â‡‘(v.int_Valuation) r
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [semiNormedGroup Î²] {f : boundedContinuousFunction Î± Î²} {C : â„} (C0 : 0 â‰¤ C) : âˆ¥fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C
{M : Type u_1} [CommMonoid M] {s t : Set M} {x : M} : x âˆˆ monoid.closure (s âˆª t) â†” âˆƒ (y : M) (H : y âˆˆ monoid.closure s) (z : M) (H : z âˆˆ monoid.closure t), y * z = x
{Î± : Type u} [normedField Î±] {u : â„• â†’ Î±} : IsCauSeq HasNorm.norm u â†” CauchySeq u
{m : Type u_1} {R : Type u_3} [Fintype m] [DecidableEq m] [CommSemiring R] (A : Matrix m m R) : â‡‘((MvPolynomial.eval (Î» (p : m Ã— m), A p.fst p.snd)).map_Matrix) (matrix.mv_Polynomial.x m m R) = A
(R : Type u) [Ring R] (hF : IsField R) (x : R) : x â‰  0 â†’ (âˆƒ! (y : R), x * y = 1)
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {t : CategoryTheory.Limits.Cone F} (h : CategoryTheory.Limits.IsLimit t) (s : CategoryTheory.Limits.Cone F) : âˆƒ! (l : s.X âŸ¶ t.X), âˆ€ (j : J), l â‰« t.Ï€.app j = s.Ï€.app j
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (s : Set (Submodule ð•œ E)) : (â¨… (K : Submodule ð•œ E) (H : K âˆˆ s), Ká—®) = (HasSup.sup s)á—®
{G : Type w} [topologicalSpace G] [HasNeg G] [hasAdd G] [HasContinuousAdd G] [HasContinuousNeg G] (h : G) : Continuous (Î» (g : G), g + h + -g)
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] (e : Râ‚ â‰ƒ+* Râ‚‚) : RingHomInvPair â†‘e â†‘(e.symm)
{Î± : Type u_1} {Î² : Type u_2} [measurableSpace Î±] [measurableSpace Î²] {f : Î² â†’ Î±} (hF : âˆ€ (x y : Î²), f x = f y) : Measurable f
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {bâ‚‚ : Basis (Fin 2) â„ V} (hbâ‚‚ : Orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = bâ‚‚.orientation) : âˆƒ (Î¸ : Real.Angle), bâ‚‚ = b.map (hb.rotation Î¸).to_linearEquiv
{Gâ‚€ : Type u_2} [groupWithZero Gâ‚€] {p : Gâ‚€Ë£ â†’ Prop} : (âˆƒ (g : Gâ‚€Ë£), p g) â†” âˆƒ (g : Gâ‚€) (hg : g â‰  0), p (Units.mk0 g hg)
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] : is_is_IsOpenMap Prod.fst
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} {v : V} {x : k} {s : Set Î¹} {p : Î¹ â†’ P} {b : P} : (âˆƒ (fs : Finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = x), v = â‡‘(fs.weighted_vsub_of_point p b) w) â†” âˆƒ (fs : Finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = x), v = â‡‘(fs.weighted_vsub_of_point (Î» (i : â†¥s), p â†‘i) b) w
{X : Type u_1} [topologicalSpace X] [SequentialSpace X] {s : Set X} : IsSeqClosed s â†’ is_IsClosed s
(K : Type u_1) (L : Type u_2) {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [isScalarTower K L A] {x : A} (A_alg : IsAlgebraic K x) : IsAlgebraic L x
(k : Type u_1) [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) [CharZero k] {n : â„•} (h : s.card = n + 1) : s.sum (Î» (i : Î¹), Finset.centroidWeights k s i) = 1
{Î± : Type u_1} {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [hasZero N] (f : Î± â†’ N) (g : Î± â†’ N â†’ M) {s t : Finset Î±} (h : s âŠ† t) (hg : âˆ€ (a : Î±), g a 0 = 0) : s.sum (Î» (i : Î±), g i (f i)) = t.sum (Î» (i : Î±), g i (â†‘s.indicator f i))
{Î± : Type u_3} [linearOrderedAddCommGroup Î±] : Filter.Tendsto HasAbs.abs Filter.atBot Filter.atTop
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {f : Filter Î±} {g : Filter Î²} {m : Î±' â†’ Î² â†’ Î³} {n : Î± â†’ Î±'} {m' : Î± â†’ Î² â†’ Î´} {n' : Î´ â†’ Î³} (h_leftComm : âˆ€ (a : Î±) (b : Î²), m (n a) b = n' (m' a b)) : Filter.mapâ‚‚ m (Filter.map n f) g = Filter.map n' (Filter.mapâ‚‚ m' f g)
{R : Type u_1} [CommSemiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [Fintype n] [DecidableEq n] [Fintype m] [DecidableEq m] (M : Matrix l m R) (N : Matrix m n R) (x : n â†’ R) : â‡‘(â‡‘Matrix.toLin' (M.mul N)) x = â‡‘(â‡‘Matrix.toLin' M) (â‡‘(â‡‘Matrix.toLin' N) x)
{R : Type u_1} [CommRing R] {n : â„•} (hpos : 0 < n) : Polynomial.cyclotomic n R = (Polynomial.x ^ n - 1) /â‚˜ n.proper_divisors.prod (Î» (i : â„•), Polynomial.cyclotomic i R)
{X : Type u_2} {Y : Type u_3} [emetricSpace X] [emetricSpace Y] [TopologicalSpace.SecondCountableTopology X] {r : Nnreal} {f : X â†’ Y} (hr : 0 < r) (hF : âˆ€ (x : X), âˆƒ (C : Nnreal) (s : Set X) (H : s âˆˆ nhds x), HolderOnWith C r f s) : dimH (Set.Range f) â‰¤ dimH Set.Univ / â†‘r
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] {s : Finset Î±} {f : Î± â†’ Î²} {a : Î±} (hp : s.prod (Î» (x : Î±), f x) = 1) (h1 : âˆ€ (x : Î±), x âˆˆ s â†’ x â‰  a â†’ f x = 1) (x : Î±) (H : x âˆˆ s) : f x = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] : CategoryTheory.Limits.HasEqualizers C
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} : AntitoneOn f s â†’ MonotoneOn (â‡‘OrderDual.toDual âˆ˜ f) s
{Î² : Type u} {Î± : Type v} {s : Finset Î±} [AddCommMonoid Î²] (f : Î± â†’ Î²) {p : Î± â†’ Prop} [DecidablePred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : (Finset.subtype p s).sum (Î» (x : Subtype_ p), f â†‘x) = s.sum (Î» (x : Î±), f x)
{R : Type u_1} [CancelMonoid R] (g : R) : IsRegular g
{Î± : Type u_3} {Î² : Type u_4} {f : Î± â†’ Î²} {k : Filter Î±} {l : Filter Î²} [k.is_countably_generated] : Filter.Tendsto f k l â†” âˆ€ (x : â„• â†’ Î±), Filter.Tendsto x Filter.atTop k â†’ Filter.Tendsto (f âˆ˜ x) Filter.atTop l
{F : Type} [CommSemiring F] {f : Polynomial F} (hF : Polynomial.HasSeparableContraction 1 f) : hf.degree = f.nat_degree
{Î± : Type u_1} {Î² : Type u_2} [AddZeroClass Î±] [AddCommGroup Î²] {f : Î± â†’ Î²} (hF : IsAddMonoidHom f) : IsAddMonoidHom (Î» (a : Î±), -f a)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {i : Î± â†’ Î²} (di : DenseInducing i) [TopologicalSpace.SeparableSpace Î±] : TopologicalSpace.SeparableSpace Î²
{Î± : Type u_1} (L : List Î±) {i : â„•} (hi : i < L.length) : List.drop i (List.take (i + 1) L) = [L.nth_LE i hi]
{M : Type u_3} {N : Type u_4} [hasZero M] [hasZero N] {f g : ZeroHom M N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : o.oangle y (â‡‘(o.rotation (o.oangle x y)) x) = 0
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [succOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Monotone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ioo (f n) (f (Order.succ n)))
 : Disjoint (residual â„) MeasureTheory.Measure_space.volume.ae
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (pâ‚ : Î¹ â†’ P) (pâ‚‚ : P) (h : s.sum (Î» (i : Î¹), w i) = 0) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.weighted_vsub pâ‚) w
{a b : â„•} (ha : a â‰  0) (hb : b â‰  0) : (a * b).factorization = a.factorization + b.factorization
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : (f =o[l] Î» (x : Î±), -g' x) â†’ f =o[l] g'
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] {X Y : C} [CategoryTheory.Simple X] [CategoryTheory.Simple Y] (f : X âŸ¶ Y) : CategoryTheory.IsIso f â†” f â‰  0
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization M S] (s : Finset S) : âˆƒ (b : â†¥M), âˆ€ (a : S), a âˆˆ s â†’ IsLocalization.IsInteger R (â†‘b â€¢ a)
{Î± : Type u_1} {Î¹ : Type u_3} [completeLattice Î±] {s : Finset Î¹} {f : Î¹ â†’ Î±} : CompleteLattice.Independent (f âˆ˜ Coe) â†’ s.sup_indep f
 : Filter.Tendsto â‡‘Complex.normSq (Filter.cocompact â„‚) Filter.atTop
{Î± : Type u} {Î² : Type v} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} [f.ne_IsBot] (h : Filter.Tendsto u f (nhds a)) : f.liminf u = a
{Î± : sort u} {Î² : Î± â†’ sort v} {fâ‚ fâ‚‚ : Î  (x : Î±), Î² x} (h : âˆ€ (x : Î±), fâ‚ x = fâ‚‚ x) : fâ‚ = fâ‚‚
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} (hF : HasFpowerSeriesAt f p x) (n : â„•) : (Î» (y : E), f (x + y) - p.partial_Sum n y) =O[nhds 0] Î» (y : E), âˆ¥yâˆ¥ ^ n
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R M) (f : M â‰ƒâ‚—[R] M) : (e.map f).orientation = -e.orientation â†” â‡‘LinearMap.det â†‘f < 0
{Î± : Type u} [topologicalSpace Î±] : t2_Space Î± â†” âˆ€ {x y : Î±}, (nhds x âŠ“ nhds y).ne_IsBot â†’ x = y
{M : Type u_1} [Monoid M] (P : Submonoid M) : P.fg â†” âˆƒ (S : Set M), Submonoid.closure S = P âˆ§ S.finite
{K : Type u_1} [linearOrderedField K] {v : K} {n : â„•} [floorRing K] (TerminatedAt_n : (GeneralizedContinuedFraction.of v).terminated_at n) : v = (GeneralizedContinuedFraction.of v).convergents n
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {g : Î² â†’ M} (e : Î± â†’ Î²) (hEâ‚€ : Function.bijective e) (hEâ‚ : âˆ€ (x : Î±), f x = g (e x)) : finsum (Î» (i : Î±), f i) = finsum (Î» (j : Î²), g j)
{R : Type u} [Rack R] {a b : Rack.PreEnvelGroup R} : Rack.PreEnvelGroupRel' R a b â†’ Rack.PreEnvelGroupRel R a b
(p : â„•) (a : â„¤) [hp : Fact (Nat.Prime p)] : â†‘(Zmod.legendreSym p a) = â†‘a ^ (p / 2)
{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) (p : Polynomial R) : â‡‘(Polynomial.aeval M) p = â‡‘(Polynomial.aeval M) (p %â‚˜ M.charpoly)
{Î± : Type u_1} [AddCommMonoid Î±] {n : â„•} (f : Affine.Simplex.PointsWithCircumcenterIndex n â†’ Î±) : finset.univ.sum (Î» (i : Affine.Simplex.PointsWithCircumcenterIndex n), f i) = finset.univ.sum (Î» (i : Fin (n + 1)), f (Affine.Simplex.PointsWithCircumcenterIndex.point_Index i)) + f Affine.Simplex.PointsWithCircumcenterIndex.circumcenter_Index
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] [Group Î±] [UniformGroup Î±] {hom : Type u_3} [uniformSpace Î²] [Group Î²] [UniformGroup Î²] [monoidHomClass hom Î± Î²] (f : hom) (hF : ContinuousAt â‡‘f 1) : UniformContinuous â‡‘f
{C : Type u} [CategoryTheory.Category C] {S : Type w} [CategoryTheory.SmallCategory S] (e : C â‰Œ S) : CategoryTheory.EssentiallySmall C
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
{Î± : Type u} [AddGroup Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a : Î±} (h : 0 â‰¤ a) : -a â‰¤ a
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (H : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ (âˆƒ (t : Set Î±) (H : t âŠ† s), x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t)) : IsPreconnected s
{f : â„‚ â†’ â„‚} {z : â„‚} : ConformalAt f z â†” (DifferentiableAt â„‚ f z âˆ¨ DifferentiableAt â„‚ (f âˆ˜ â‡‘(starRingEnd â„‚)) (â‡‘(starRingEnd â„‚) z)) âˆ§ fderiv â„ f z â‰  0
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Î¹ : Type u_1} {s : Set Î¹} [IsNoetherian K V] (b : Basis â†¥s K V) : s.finite
{Î± : Type u_1} [PartialOrder Î±] [OrderBot Î±] {a : Î±} : âŠ¥ â‹– a â†’ IsAtom a
{p : â„•} : padicValNat p 0 = 0
{R : Type u_1} [Semiring R] [Nontrivial R] (n : â„•) : (PowerSeries.x ^ n).order = â†‘n
{G : Type u_1} [Group G] {k : Set G} : k âŠ† â†‘(Subgroup.closure k)
(F : Type u_1) [Field F] (E : Type u_2) [Field E] [Algebra F E] [Fintype E] : âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
{ð’œ : Type u_1} [CategoryTheory.Category ð’œ] [CategoryTheory.Preadditive ð’œ] [CategoryTheory.Limits.HasKernels ð’œ] [CategoryTheory.Limits.HasImages ð’œ] [CategoryTheory.Limits.HasBinaryBiproducts ð’œ] (A B : ð’œ) : CategoryTheory.Exact CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.fst
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [Invertible 2] (p : Fin 2 â†’ P) : Finset.centroid k Finset.univ p = 2â»Â¹ â€¢ (p 1 -áµ¥ p 0) +áµ¥ p 0
{Î± : Type u} [HasSubset Î±] {a b : Î±} [IsRefl Î± HasSubset.Subset] : a = b â†’ a âŠ† b
(R : Type u_1) (M : Type u_2) [Semiring R] [Subsingleton R] [AddCommMonoid M] [Module R M] : Subsingleton M
{R : Type u_1} [Semiring R] (n : â„•) (a : R) (h : a â‰  0) : (â‡‘(PowerSeries.monomial R n) a).order = â†‘n
{M : Type u_2} [AddCommGroup M] {A : Type u_1} [CommRing A] [Module A M] (f : M â‰ƒâ‚—[A] M) : â‡‘LinearMap.det â†‘f * â‡‘LinearMap.det â†‘(f.symm) = 1
(n p : â„•) : (â†‘p + 1) * (Finset.range n).sum (Î» (k : â„•), â†‘k ^ p) = Polynomial.eval â†‘n (Polynomial.bernoulli p.succ) - bernoulli p.succ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) : ((âˆ€ (a : â†¥P), â‡‘g (â‡‘f a) = 0) âˆ§ âˆ€ (b : â†¥Q), â‡‘g b = 0 â†’ (âˆƒ (a : â†¥P), â‡‘f a = b)) â†’ CategoryTheory.Exact f g
{Î“â‚€ : Type u_1} [LinearOrderedCommGroupWithZero Î“â‚€] (Î³ : Î“â‚€) (h : Î³ â‰  0) : {x : Î“â‚€ | x < Î³} âˆˆ nhds 0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] [CompleteSpace ð•œ] {n : WithTop â„•} {f : E â†’ (F â†’L[ð•œ] G)} {s : Set E} [FiniteDimensional ð•œ F] : ContDiffOn ð•œ n f s â†” âˆ€ (y : F), ContDiffOn ð•œ n (Î» (x : E), â‡‘(f x) y) s
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : E â†’ F} {g : E â†’ G} (hF : ContDiff ð•œ n f) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Î» (x : E), (f x, g x))
{R : Type u} {Î¹ : Type w} (s : Finset Î¹) [CommSemiring R] [NoZeroDivisors R] (f : Î¹ â†’ Polynomial R) : (s.prod (Î» (i : Î¹), f i)).leading_Coeff = s.prod (Î» (i : Î¹), (f i).leading_Coeff)
{Î± : Type u_1} {Î² : Type u_2} {e e' : LocalEquiv Î± Î²} (hE : e â‰ˆ e') (s : Set Î²) : e.source âˆ© â‡‘e â»Â¹' s = e'.source âˆ© â‡‘e' â»Â¹' s
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P (n + 2)) : s.monge_point = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (Affine.Simplex.mongePointWeightsWithCircumcenter n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {Î¹ : Type v} {B : Î¹ â†’ C} (hB : âˆ€ (A : C), âˆƒ (i : Î¹), Nonempty (B i âŸ¶ A)) : âˆƒ (T : C), âˆ€ (X : C), Nonempty (T âŸ¶ X)
{Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : Vector Î± 1) : Vector.scanl f b v = b::áµ¥f b v.head::áµ¥Vector.nil
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {a : Î±} {s : Set Î±} (h : f a = 0) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ HasInsert.insert a s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {t : Finset V} (h : FiniteDimensional.finrank K V < t.card) : âˆƒ (f : V â†’ K), t.sum (Î» (e : V), f e â€¢ e) = 0 âˆ§ âˆƒ (x : V) (H : x âˆˆ t), f x â‰  0
{m : Type u_1} {R : Type u_2} [Fintype m] [CommRing R] {M : Matrix m m R} (hM : M.nondegenerate) {v : m â†’ R} (hv : âˆ€ (w : m â†’ R), Matrix.dotProduct v (M.mul_vec w) = 0) : v = 0
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {f g : â„‚ â†’ E} (hfd : DiffContOnCl â„‚ f {z : â„‚ | 0 < z.re}) (hgd : DiffContOnCl â„‚ g {z : â„‚ | 0 < z.re}) (hfexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hgexp : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : Asymptotics.SuperpolynomialDecay Filter.atTop Real.exp (Î» (x : â„), âˆ¥f â†‘x - g â†‘xâˆ¥)) (hfim : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥f (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hgim : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥g (â†‘x * Complex.i)âˆ¥ â‰¤ C) : Set.EqOn f g {z : â„‚ | 0 â‰¤ z.re}
{G : Type w} [topologicalSpace G] [Group G] [TopologicalGroup G] [t2_Space G] (K : TopologicalSpace.PositiveCompacts G) : LocallyCompactSpace G
{Î± : Type u} [Preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a
{Î± : Type u_1} {Î² : Type u_2} (t : Î±) (ts : List Î±) (r : List Î²) (ys : List Î±) (f : List Î± â†’ Î²) : (List.permutationsAux2 t ts r ys f).snd = List.map (Î» (x : List Î±), f (x ++ ts)) (List.permutationsAux2 t List.nil List.nil ys Id).snd ++ r
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹} : TendstoUniformly F f p â†” Filter.Tendsto (Î» (q : Î¹ Ã— Î±), (f q.snd, F q.fst q.snd)) (p.prod âŠ¤) (Uniformity Î²)
{M : Type u_1} {N : Type u_2} {Î± : Type u_6} {Î² : Type u_7} [HasScalar M Î±] [HasScalar M Î²] [HasScalar Î± Î²] [isScalarTower M Î± Î²] (g : N â†’ M) : isScalarTower N Î± Î²
 : fourier_subalgebra.separates_points
(n : â„•) (R : Type u_1) [Ring R] [Nontrivial R] : Polynomial.cyclotomic n R â‰  0
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a : Î±} : -a < 0 â†” 0 < a
{Î± : Type u_1} {Î¹ : Type u_3} [completeLattice Î±] {s : Finset Î¹} {f : Î¹ â†’ Î±} : s.sup_indep f â†’ CompleteLattice.Independent (f âˆ˜ Coe)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} {f : ð•œ â†’ F} {s : Set ð•œ} {x : ð•œ} (hxs : UniqueDiffOn ð•œ s) (hx : x âˆˆ s) : iteratedDerivWithin (n + 1) f s x = iteratedDerivWithin n (derivWithin f s) s x
{R : Type u} [NonAssocSemiring R] {s : Set R} {p : R â†’ Prop} {x : R} (h : x âˆˆ Subsemiring.closure s) (Hs : âˆ€ (x : R), x âˆˆ s â†’ p x) (H0 : p 0) (H1 : p 1) (HAdd : âˆ€ (x y : R), p x â†’ p y â†’ p (x + y)) (HMul : âˆ€ (x y : R), p x â†’ p y â†’ p (x * y)) : p x
{R : Type u_1} {a b : R} [AddSemigroup R] (Ab : IsAddLeftRegular (a + b)) : IsAddLeftRegular b
{Î² : Type u_2} [DecidableEq Î²] (s : Finset Î²) (b : Î²) : Finset.filter (Î» (a : Î²), a = b) s = Ite (b âˆˆ s) {b} âˆ…
{k : Type u_1} {M : Type u_2} [orderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] [ContravariantClass M M Add.add LE.le] {a b : k} {c d : M} (hba : b â‰¤ a) (hdc : d â‰¤ c) : a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D â¥¤ C) [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.CartesianClosed C] [CategoryTheory.Reflective i] (h : Î  (A : C), i â‹™ CategoryTheory.exp A â‹™ CategoryTheory.leftAdjoint i â‹™ i â‰… i â‹™ CategoryTheory.exp A) : CategoryTheory.ExponentialIdeal i
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} {T : addSubmonoid P} {Q : Type u_4} [AddCommMonoid Q] (hg : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) (k : T.localization_Map Q) {x y : M} (h : â‡‘(f.to_Map) x = â‡‘(f.to_Map) y) : â‡‘(k.to_Map) (â‡‘g x) = â‡‘(k.to_Map) (â‡‘g y)
{R : Type u} [Ring R] (s : Subring R) : 1 âˆˆ s
{Î± : Type u_1} [SemiNormedRing Î±] (a : Î±) {n : â„•} (h : 0 < n) : âˆ¥a ^ nâˆ¥ â‰¤ âˆ¥aâˆ¥ ^ n
(p : â„•) {R : Type u_1} [hp : Fact (Nat.Prime p)] [CommRing R] (r : R) (n : â„•) : â‡‘(WittVector.ghostComponent n) (â‡‘(WittVector.teichmuller p) r) = r ^ p ^ n
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {c : â„} {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : asymptotics.is_O_with c l f g' â†’ asymptotics.is_O_with c l f (Î» (x : Î±), -g' x)
{Î± : Type u_1} {R : Type u_2} {l : Filter Î±} {f : Î± â†’ R} {r : R} [linearOrderedSemiring R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto f l Filter.atTop) : Filter.Tendsto (Î» (x : Î±), r * f x) l Filter.atTop
{R : Type u_4} {S : Type u_5} [hasMul R] [hasAdd R] [hasMul S] [hasAdd S] {f g : R â‰ƒ+* S} (h : âˆ€ (x : R), â‡‘f x = â‡‘g x) : f = g
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) (hS : is_IsClosed â†‘S) (m : M) (h : âˆ¥â‡‘(QuotientAddGroup.mk' S) mâˆ¥ = 0) : m âˆˆ S
{J : Type uâ‚} [CategoryTheory.Category J] [Nonempty J] (h : âˆ€ {Î± : Type uâ‚} (F : J â†’ Î±), (âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ F jâ‚ = F jâ‚‚) â†’ âˆ€ (j j' : J), F j = F j') : CategoryTheory.IsConnected J
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [Subsingleton Î¹] (p : Î¹ â†’ P) : AffineIndependent k p
{Râ‚‚ : Type u_5} {Mâ‚‚ : Type u_6} [CommSemiring Râ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {B : BilinForm Râ‚‚ Mâ‚‚} : B.nondegenerate â†” (â‡‘BilinForm.toLin B).ker = âŠ¥
{G : Type u_1} [AddGroup G] {k : Set G} {p : G â†’ G â†’ Prop} {x y : G} (hx : x âˆˆ AddSubgroup.closure k) (hy : y âˆˆ AddSubgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ âˆ€ (y : G), y âˆˆ k â†’ p x y) (H1_Left : âˆ€ (x : G), p 0 x) (H1_Right : âˆ€ (x : G), p x 0) (HMul_Left : âˆ€ (xâ‚ xâ‚‚ y : G), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ + xâ‚‚) y) (HMul_Right : âˆ€ (x yâ‚ yâ‚‚ : G), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ + yâ‚‚)) (Hinv_Left : âˆ€ (x y : G), p x y â†’ p (-x) y) (Hinv_Right : âˆ€ (x y : G), p x y â†’ p x (-y)) : p x y
{R : Type u_1} {S : Type u_2} [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S] (f : R â†’+ S) : (âˆ€ (x y : R), â‡‘f (x * y) = â‡‘f x * â‡‘f y) â†” AddMonoid_hom.mul.comprâ‚‚ f = (AddMonoid_hom.mul.comp f).complâ‚‚ f
{M : Type u_1} [hasAdd M] (r : M â†’ M â†’ Prop) : addConGen r = HasInf.inf {s : AddCon M | âˆ€ (x y : M), r x y â†’ â‡‘s x y}
{Î± : Type u_1} {Î² : Type u_2} [AddSemigroup Î±] [AddCommSemigroup Î²] {f g : Î± â†’ Î²} (hF : IsAddHom f) (hg : IsAddHom g) : IsAddHom (Î» (a : Î±), f a + g a)
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R â†’+* S} [Nontrivial S] {p : Polynomial S} (hlifts : p âˆˆ Polynomial.lifts f) (hp : p.monic) : âˆƒ (q : Polynomial R), Polynomial.map f q = p âˆ§ q.degree = p.degree âˆ§ q.monic
{X : Type u} {Î± : Type v} [topologicalSpace X] [LinearOrder Î±] [topologicalSpace Î±] [OrderClosedTopology Î±] [PreconnectedSpace X] {a b : X} {f g : X â†’ Î±} (hF : Continuous f) (hg : Continuous g) (ha : f a â‰¤ g a) (hb : g b â‰¤ f b) : âˆƒ (x : X), f x = g x
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} (hF : MonotoneOn f s) (hs : s âˆˆ nhdsWithin a (Set.Iic a)) (hfs : âˆ€ (b : Î²), b < f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ Set.Ioo b (f a))) : ContinuousWithinAt f (Set.Iic a) a
{ð•œ : Type u_1} {E : Type u_3} {F : Type u_4} [CommRing ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] [AddCommGroup F] [Module ð•œ F] [topologicalSpace F] [TopologicalAddGroup F] [HasContinuousConstSmul ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {m n : â„•} {v : Fin m â†’ E} {w : Fin n â†’ E} (h1 : m = n) (h2 : âˆ€ (i : â„•) (him : i < m) (hin : i < n), v âŸ¨i, himâŸ© = w âŸ¨i, hinâŸ©) : â‡‘(p m) v = â‡‘(p n) w
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : ContinuousAt f b) : HasDerivAt (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) b
(m n : â„•+) : (m.gcd n).factor_Multiset = m.factor_Multiset âŠ“ n.factor_Multiset
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [Ring ð•œ] [AddCommGroup E] [AddCommGroup F] [Module ð•œ E] [Module ð•œ F] [topologicalSpace E] [topologicalSpace F] [TopologicalAddGroup E] [TopologicalAddGroup F] [HasContinuousConstSmul ð•œ E] [HasContinuousConstSmul ð•œ F] (p : FormalMultilinearSeries ð•œ E F) (n : â„•) : Continuous (p.partial_Sum n)
(Î± : Type u) [Preorder Î±] [Nonempty Î±] [NoMinOrder Î±] : âˆƒ (f : â„• â†’ Î±), StrictAnti f
{M : Type u} [Monoid M] (u : MË£) (x : M) : SemiconjBy â†‘u x (â†‘u * x * â†‘uâ»Â¹)
{Î¹ : Type u} {f g : Î¹ â†’ Nnreal} {A B : Nnreal} {p : â„} (hp : 1 â‰¤ p) (hF : HasSum (Î» (i : Î¹), f i ^ p) (A ^ p)) (hg : HasSum (Î» (i : Î¹), g i ^ p) (B ^ p)) : âˆƒ (C : Nnreal), C â‰¤ A + B âˆ§ HasSum (Î» (i : Î¹), (f i + g i) ^ p) (C ^ p)
{f : Bool â†’ Bool â†’ Bool} (hF : âˆ€ (b b' : Bool), f b b' = f b' b) (hF' : f bool.ff bool.ff = bool.ff) (n m : â„•) : Nat.bitwise f n m = Nat.bitwise f m n
{S : Type v} [CommRing S] (d : â„•) (y : S) : Polynomial.eval (1 + y) (â‡‘(Polynomial.monomial d) (â†‘d + 1)) - Polynomial.eval y (â‡‘(Polynomial.monomial d) (â†‘d + 1)) = (Finset.range (d + 1)).sum (Î» (x_1 : â„•), â†‘((d + 1).choose x_1) * (â†‘x_1 * y ^ (x_1 - 1)))
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a l' : Î±} {s : Set Î±} (hl' : l' < a) : s âˆˆ nhdsWithin a (Set.Iio a) â†” âˆƒ (l : Î±) (H : l âˆˆ Set.Iio a), Set.Ioo l a âŠ† s
{Î± : Type u} {Lâ‚ Lâ‚‚ Lâ‚ƒ : List (Î± Ã— Bool)} : FreeGroup.Red Lâ‚ Lâ‚‚ â†’ FreeGroup.Red Lâ‚ Lâ‚ƒ â†’ Relation.Join FreeGroup.Red Lâ‚‚ Lâ‚ƒ
(Î¹ : Type u_1) [Fintype Î¹] : MeasureTheory.Measure.addHaarMeasure (topological_space.positive_compacts.pi_icc01 Î¹) = MeasureTheory.MeasureSpace.volume
{R : Type u_1} {a b : R} [Semigroup R] (lra : IsLeftRegular a) (lrb : IsLeftRegular b) : IsLeftRegular (a * b)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] : â†‘âŠ¤ = Set.Univ
{J : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.IsConnected J] (r : J â†’ J â†’ Prop) (hr : Equivalence r) (h : âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ r jâ‚ jâ‚‚) (jâ‚ jâ‚‚ : J) : r jâ‚ jâ‚‚
{n k : â„•} : n < k â†’ n.desc_factorial k = 0
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Monotone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ioo (f (Order.pred n)) (f n))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {s : Set E} : UniqueDiffOn ð•œ s â†’ UniqueMdiffOn (modelWithCornersSelf ð•œ E) s
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : â†‘s âˆ© â†‘(AffineSubspace.mk' p (s.direction)á—®) = {EuclideanGeometry.orthogonalProjectionFn s p}
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) (hF'_nonneg : âˆ€ (x : â„), x âˆˆ Interior D â†’ 0 â‰¤ deriv f x) : MonotoneOn f D
{R : Type u_1} [commGroupWithZero R] {f g : â„• â†’ R} (hF : âˆ€ (n : â„•), 0 < n â†’ f n â‰  0) (hg : âˆ€ (n : â„•), 0 < n â†’ g n â‰  0) : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.prod (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.prod (Î» (x : â„• Ã— â„•), g x.snd ^ â‡‘Nat.ArithmeticFunction.moebius x.fst) = f n
{n : â„•} {iâ‚ iâ‚‚ : Fin (n + 1)} (h : iâ‚ â‰  iâ‚‚) : finset.univ.sum (Î» (i : Affine.Simplex.PointsWithCircumcenterIndex n), Affine.Simplex.reflectionCircumcenterWeightsWithCircumcenter iâ‚ iâ‚‚ i) = 1
{X : Type u} [pseudoMetricSpace X] {Î´ : â„} {E : Set X} : Metric.Thickening Î´ E = â‹ƒ (x : X) (H : x âˆˆ E), Metric.Ball x Î´
(R : Type u_3) (M : Type u_4) [AddCommMonoid M] [Ring R] [Fintype R] [Module R M] : Add_monoid.is_torsion M
(ð•œ : Type u_1) {A : Type u_2} [nondiscreteNormedField ð•œ] [normedRing A] [NormedAlgebra ð•œ A] [CompleteSpace A] (a : A) : HasFpowerSeriesOnBall (Î» (z : ð•œ), Ring.inverse (1 - z â€¢ a)) (Î» (n : â„•), ContinuousMultilinearMap.mkPiField ð•œ (Fin n) (a ^ n)) 0 (â†‘âˆ¥aâˆ¥â‚Š)â»Â¹
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] [Nonempty Î²] {f : Î² â†’ Î±} (hF : Continuous f) (hlim : Filter.Tendsto f (Filter.cocompact Î²) Filter.atBot) : âˆƒ (x : Î²), âˆ€ (y : Î²), f y â‰¤ f x
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : InnerProductGeometry.angle x (-y) = Real.pi - InnerProductGeometry.angle x y
{R : Type u_1} [leftCancelSemigroup R] (g : R) : IsLeftRegular g
(S T : Set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] (C : Type w) [CommRing C] [Algebra A C] [Algebra B C] [isScalarTower A B C] [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C] : IsCyclotomicExtension (S âˆª T) A C
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topologicalSpace B] [topologicalSpace F] {Proj : Z â†’ B} [topologicalSpace Z] (h : IsTopologicalFiberBundle F Proj) : is_is_IsOpenMap Proj
{x y z : â„¤} : PythagoreanTriple x y z â†” âˆƒ (k m n : â„¤), (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§ (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2))
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î±] [Fintype Î±] [CommMonoid Î²] {Î´ : Î± â†’ Type u_3} {t : Î  (a : Î±), Finset (Î´ a)} (f : (Î  (a : Î±), a âˆˆ Finset.univ â†’ Î´ a) â†’ Î²) : (finset.univ.pi t).prod (Î» (x : Î  (a : Î±), a âˆˆ Finset.univ â†’ Î´ a), f x) = (Fintype.piFinset t).prod (Î» (x : Î  (a : Î±), Î´ a), f (Î» (a : Î±) (_x : a âˆˆ Finset.univ), x a))
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [PartialOrder Î±] [t : OrderTopology Î±] {f g h : Î² â†’ Î±} {b : Filter Î²} {a : Î±} (hg : Filter.Tendsto g b (nhds a)) (hH : Filter.Tendsto h b (nhds a)) (hgf : g â‰¤ f) (hfh : f â‰¤ h) : Filter.Tendsto f b (nhds a)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryProducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{Î² : Type u_2} [CommMonoid Î²] (f : Fin 0 â†’ Î²) : finset.univ.prod (Î» (i : Fin 0), f i) = 1
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] [Nontrivial E] {x : E} {K : Set E} (hK : is_IsCompact K) (hx : x âˆˆ K) : âˆƒ (y : E) (H : y âˆˆ Frontier K), Metric.infDist x Ká¶œ = HasDist.dist x y
{C : Type uâ‚} [CategoryTheory.SmallCategory C] (P : Cáµ’áµ– â¥¤ Type uâ‚) (j : (P.elements)áµ’áµ–) : (CategoryTheory.coconeOfRepresentable P).Î¹.app j = (CategoryTheory.yonedaSectionsSmall ((CategoryTheory.categoryOfElementsÏ€ P).left_op.obj j) (((CategoryTheory.Functor.const (P.elements)áµ’áµ–).obj (CategoryTheory.coconeOfRepresentable P).X).obj j)).inv (Opposite.unop j).snd
(ð•œ : Type u_1) [nondiscreteNormedField ð•œ] {E : Type u_2} [semiNormedGroup E] [normedSpace ð•œ E] {s : Set E} (s_nhd : s âˆˆ nhds 0) : Metric.Bounded (NormedSpace.Polar ð•œ s)
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {x : ð•œ} {L : Filter ð•œ} {f' : ð•œ â†’L[ð•œ] F} : HasFderivAtFilter f f' x L â†” HasDerivAtFilter f (â‡‘f' 1) x L
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} {c : CategoryTheory.Limits.Cofork f f} (h : CategoryTheory.Limits.IsColimit c) : CategoryTheory.IsIso c.Ï€
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Î± : Type u_1} [topologicalSpace Î±] {x : Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] [HasContinuousAdd Î³] {f g : Î± â†’ Î³} (hF : LowerSemicontinuousAt f x) (hg : LowerSemicontinuousAt g x) : LowerSemicontinuousAt (Î» (z : Î±), f z + g z) x
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasFiniteProducts D] (F : C â¥¤ D) [CategoryTheory.CartesianClosed C] [CategoryTheory.CartesianClosed D] [CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] {A A' : C} (f : A' âŸ¶ A) : CategoryTheory.expComparison F A â‰« CategoryTheory.whiskerLeft F (CategoryTheory.pre (F.map f)) = CategoryTheory.whiskerRight (CategoryTheory.pre f) F â‰« CategoryTheory.expComparison F A'
{Î± : Type u} (L : List Î±) {i j : â„•} (hi : i < L.length) (hj : i < j) : L.nth_LE i hi = (List.take j L).nth_LE i _
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] {F G : Top.Sheaf C X} (f : F âŸ¶ G) [âˆ€ (x : â†¥X), CategoryTheory.IsIso ((Top.Presheaf.stalkFunctor C x).map f)] : CategoryTheory.IsIso f
{Î± : Type u} [pseudoMetricSpace Î±] (x y : Î±) : HasEdist.edist x y = â†‘(HasNndist.nndist x y)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {R : Type u_6} [normedRing R] [NormedAlgebra ð•œ R] [CompleteSpace R] (x : RË£) : HasFderivAt Ring.inverse (-â‡‘(â‡‘(ContinuousLinearMap.lmulLeftRight ð•œ R) â†‘xâ»Â¹) â†‘xâ»Â¹) â†‘x
{m : Type u_2} {n : Type u_3} {Î± : Type v} [hasStar Î±] (M : Matrix m n Î±) (i : m) (j : n) : M.conj_transpose j i = HasStar.star (M i j)
(ð•œ : Type u_1) {E : Type u_2} [normedLinearOrderedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [StrictConvexSpace ð•œ E] (x : E) (r : â„) : StrictConvex ð•œ (Metric.ClosedBall x r)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (h : s.sum (Î» (i : Î¹), w i) = 1) (bâ‚ bâ‚‚ : P) : â‡‘(s.weighted_vsub_of_point p bâ‚) w +áµ¥ bâ‚ = â‡‘(s.weighted_vsub_of_point p bâ‚‚) w +áµ¥ bâ‚‚
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {R : Nnreal} {c : â„‚} {f : â„‚ â†’ E} {s : Set â„‚} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c â†‘R)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball c â†‘R  s â†’ DifferentiableAt â„‚ f z) (hR : 0 < R) : HasFpowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R
{Î± : Type u_1} {E : Î± â†’ Type u_2} {p : Ennreal} [Î  (i : Î±), NormedGroup (E i)] {Î¹ : Type u_3} {l : Filter Î¹} [l.ne_IsBot] [Fact (1 â‰¤ p)] {F : Î¹ â†’ â†¥(Lp E p)} (hF : Metric.Bounded (Set.Range F)) {f : Î  (a : Î±), E a} (hF : Filter.Tendsto (Id (Î» (i : Î¹), â‡‘(F i))) l (nhds f)) : HasMem_â„“p f p
{C : Type u} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryProduct A B] [CategoryTheory.Limits.HasBinaryProduct A' B'] [CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')] (f : A âŸ¶ A') (g : B âŸ¶ B') : F.map (CategoryTheory.Limits.prod.map f g) â‰« CategoryTheory.Limits.prodComparison F A' B' = CategoryTheory.Limits.prodComparison F A B â‰« CategoryTheory.Limits.prod.map (F.map f) (F.map g)
{ð•œ : Type u_1} {E : Type u} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] {s : Set E} : â‡‘(convexHull ð•œ) s = â‹ƒ (t : Finset E) (hss : â†‘t âŠ† s) (hai : AffineIndependent ð•œ Coe), â‡‘(convexHull ð•œ) â†‘t
{G : Type u_1} [Group G] {H : Subgroup G} [DecidableEq G] {R S : Finset G} (hR : â†‘R âˆˆ Subgroup.RightTransversals â†‘H) (hR1 : 1 âˆˆ R) (hS : Subgroup.closure â†‘S = âŠ¤) : Subgroup.closure â†‘(Finset.image (Î» (g : G), âŸ¨g * (â†‘(Subgroup.MemRightTransversals.toFun hR g))â»Â¹, _âŸ©) (R * S)) = âŠ¤
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscreteNormedField ð•‚] [normedCommRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] [CharZero ð•‚] {x y : ð”¸} (hx : x âˆˆ Emetric.Ball 0 (expSeries ð•‚ ð”¸).radius) (hy : y âˆˆ Emetric.Ball 0 (expSeries ð•‚ ð”¸).radius) : Exp ð•‚ (x + y) = Exp ð•‚ x * Exp ð•‚ y
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), IsAddUnit (â‡‘g â†‘y)) (z : N) : â‡‘(f.lift hg) z + â‡‘g â†‘((f.sec z).snd) = â‡‘g (f.sec z).fst
{V : Type u_1} [innerProductSpace â„ V] {x : V} (hx : x â‰  0) : InnerProductGeometry.angle x (-x) = Real.pi
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {a : Î±} {s : Set Î±} (h : f a = 1) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ HasInsert.insert a s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
{R : Type u_1} {M : Type u_2} [topologicalSpace R] [divisionRing R] [HasContinuousSub R] [AddCommGroup M] [topologicalSpace M] [HasContinuousAdd M] [Module R M] [HasContinuousSmul R M] (f : M â†’L[R] R) (hF : f â‰  0) : is_is_IsOpenMap â‡‘f
(n : â„•+) (K : Type w) (L : Type z) [Field K] [Field L] [Algebra K L] [NeZero â†‘â†‘n] [IsCyclotomicExtension {n} K L] : Polynomial.IsSplittingField K L (Polynomial.cyclotomic â†‘n K)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) {X : C} [CategoryTheory.IsIso (h.unit.app X)] : CategoryTheory.inv (L.map (h.unit.app X)) = h.counit.app (L.obj X)
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (M N : Matrix m m R) : (M.mul N).det = (N.mul M).det
{ð•œ : Type u_1} {E : Type u_2} [SemiNormedRing ð•œ] [HasScalar ð•œ E] {s t : Set E} (hs : Balanced ð•œ s) (h : s âŠ† t) : s âŠ† BalancedCore ð•œ t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasFiniteLimits C
{Î± : Type u_1} [topologicalSpace Î±] {s : Set Î±} : MeasureTheory.AnalyticSet s â†” âˆƒ (Î² : Type) (h : topologicalSpace Î²) (h' : PolishSpace Î²) (f : Î² â†’ Î±), Continuous f âˆ§ Set.Range f = s
{M : Type u_1} [Monoid M] {s : Set M} {a : M} (hs : IsSubmonoid s) (h : a âˆˆ s) : Powers a âŠ† s
{C : Type u} [CategoryTheory.Category C] {X Y : C} [CategoryTheory.Limits.HasEqualizers C] {X' : C} (h : X' âŸ¶ X) [CategoryTheory.IsIso h] (f : X âŸ¶ Y) [CategoryTheory.Limits.HasImage f] : CategoryTheory.Limits.imageSubobject (h â‰« f) = CategoryTheory.Limits.imageSubobject f
{Î± : Type u} [Preorder Î±] {a b c : Î±} : a < b â†’ b < c â†’ a < c
{ð•œ : Type u} [hnorm : nondiscreteNormedField ð•œ] {E : Type v} [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul ð•œ E] {F' : Type x} [AddCommGroup F'] [Module ð•œ F'] [topologicalSpace F'] [TopologicalAddGroup F'] [HasContinuousSmul ð•œ F'] [CompleteSpace ð•œ] [t2_Space E] [FiniteDimensional ð•œ E] (f : E â†’â‚—[ð•œ] F') : Continuous â‡‘f
{ð•œ : Type u_1} {E : Type u_4} [semiNormedGroup E] [nondiscreteNormedField ð•œ] [normedSpace ð•œ E] {ð•œ' : Type u_10} [normedField ð•œ'] [NormedAlgebra ð•œ ð•œ'] [normedSpace ð•œ' E] [isScalarTower ð•œ ð•œ' E] : âˆ¥ContinuousLinearMap.lsmul ð•œ ð•œ'âˆ¥ â‰¤ 1
{C : Type u} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryCoproduct A B] [CategoryTheory.Limits.HasBinaryCoproduct A' B'] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')] (f : A âŸ¶ A') (g : B âŸ¶ B') : CategoryTheory.Limits.coprodComparison F A B â‰« F.map (CategoryTheory.Limits.coprod.map f g) = CategoryTheory.Limits.coprod.map (F.map f) (F.map g) â‰« CategoryTheory.Limits.coprodComparison F A' B'
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±} (hs : BddAbove s) (sne : s.nonempty) : HasSup.sup (HasInsert.insert a s) = a âŠ” HasSup.sup s
{Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} : lâ‚ <:+ lâ‚‚ â†’ lâ‚.reverse <+: lâ‚‚.reverse
{G : Type u_1} [AddGroup G] [Fintype G] : Add_monoid.is_torsion G
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (h : Metric.Bounded s) : Metric.Bounded (Closure s)
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Semiring R] [AddCommMonoid N] [Module R N] (p : Î¹ â†’ Submodule R N) : CompleteLattice.Independent p â†” âˆ€ (i : Î¹) (x : â†¥(p i)) (v : Î â‚€ (i : Î¹), â†¥(p i)), â‡‘(â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)) (Dfinsupp.erase i v) = â†‘x â†’ x = 0
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] {s : Set Î²} {f : Î² â†’ Î±} (hF : ContinuousOn f s) (hsc : is_IsClosed s) {xâ‚€ : Î²} (hâ‚€ : xâ‚€ âˆˆ s) (hc : âˆ€á¶  (x : Î²) in Filter.cocompact Î² âŠ“ Filter.principal s, f x â‰¤ f xâ‚€) : âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f y â‰¤ f x
{Î± : Type u} {n : â„•} (f : Fin n â†’ Î±) : (List.ofFn f).length = n
{E : Type u} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] (f g : â„ Ã— â„ â†’ E) (f' g' : â„ Ã— â„ â†’ (â„ Ã— â„ â†’L[â„] E)) (aâ‚ aâ‚‚ bâ‚ bâ‚‚ : â„) (s : Set (â„ Ã— â„)) (hs : s.countable) (Hcf : ContinuousOn f (Set.Interval aâ‚ bâ‚ Ã—Ë¢ Set.Interval aâ‚‚ bâ‚‚)) (Hcg : ContinuousOn g (Set.Interval aâ‚ bâ‚ Ã—Ë¢ Set.Interval aâ‚‚ bâ‚‚)) (Hdf : âˆ€ (x : â„ Ã— â„), x âˆˆ Set.Ioo (Linear_order.min aâ‚ bâ‚) (Linear_order.max aâ‚ bâ‚) Ã—Ë¢ Set.Ioo (Linear_order.min aâ‚‚ bâ‚‚) (Linear_order.max aâ‚‚ bâ‚‚)  s â†’ HasFderivAt f (f' x) x) (Hdg : âˆ€ (x : â„ Ã— â„), x âˆˆ Set.Ioo (Linear_order.min aâ‚ bâ‚) (Linear_order.max aâ‚ bâ‚) Ã—Ë¢ Set.Ioo (Linear_order.min aâ‚‚ bâ‚‚) (Linear_order.max aâ‚‚ bâ‚‚)  s â†’ HasFderivAt g (g' x) x) (Hi : MeasureTheory.IntegrableOn (Î» (x : â„ Ã— â„), â‡‘(f' x) (1, 0) + â‡‘(g' x) (0, 1)) (Set.Interval aâ‚ bâ‚ Ã—Ë¢ Set.Interval aâ‚‚ bâ‚‚) MeasureTheory.MeasureSpace.volume) : âˆ« (x : â„) in aâ‚..bâ‚, âˆ« (y : â„) in aâ‚‚..bâ‚‚, â‡‘(f' (x, y)) (1, 0) + â‡‘(g' (x, y)) (0, 1) = (((âˆ« (x : â„) in aâ‚..bâ‚, g (x, bâ‚‚)) - âˆ« (x : â„) in aâ‚..bâ‚, g (x, aâ‚‚)) + âˆ« (y : â„) in aâ‚‚..bâ‚‚, f (bâ‚, y)) - âˆ« (y : â„) in aâ‚‚..bâ‚‚, f (aâ‚, y)
{Î± : Type u_1} [PartialOrder Î±] {f : Î± â†’ Î±} {p : Î± â†’ Prop} {hF : âˆ€ (x : Î±), x â‰¤ f x} {hfp : âˆ€ (x : Î±), p (f x)} {hmin : âˆ€ â¦ƒx y : Î±â¦„, x â‰¤ y â†’ p y â†’ f x â‰¤ y} {x : Î±} (hx : p x) : x âˆˆ (ClosureOperator.mkâ‚ƒ f p hF hfp hmin).closed
{C : Type uâ‚} [CategoryTheory.Category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚â‚ƒ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚‚â‚ƒ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚â‚ƒ} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚‚â‚ƒ} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚â‚ƒ : Xâ‚â‚ƒ âŸ¶ Xâ‚‚â‚ƒ} (s : CategoryTheory.IsPushout (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)) (p : hâ‚â‚‚ â‰« vâ‚â‚ƒ = vâ‚â‚‚ â‰« hâ‚‚â‚‚) (t : CategoryTheory.IsPushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) : CategoryTheory.IsPushout hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [innerProductSpace ð•œ G] [CompleteSpace E] [CompleteSpace G] [CompleteSpace F] (A : F â†’L[ð•œ] G) (B : E â†’L[ð•œ] F) : â‡‘ContinuousLinearMap.adjoint (A.comp B) = (â‡‘ContinuousLinearMap.adjoint B).comp (â‡‘ContinuousLinearMap.adjoint A)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.FinCategory J] (F : J â¥¤ C) : Nonempty (CategoryTheory.Limits.Cone F)
{Î± : Type u_1} {p : Finset Î± â†’ Prop} [DecidableEq Î±] (s : Finset Î±) (hâ‚ : p âˆ…) (hâ‚‚ : âˆ€ â¦ƒa : Î±â¦„ {s : Finset Î±}, a âˆ‰ s â†’ p s â†’ p (HasInsert.insert a s)) : p s
{s : â„} (h : 0 < s) : MeasureTheory.IntegrableOn (Î» (x : â„), Real.exp (-x) * x ^ (s - 1)) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [normedSpace ð•œ E] [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ G} {C : â„} {s : Set E} {x y : E} (hF : DifferentiableOn ð•œ f s) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderivWithin ð•œ f s xâˆ¥ â‰¤ C) (hs : Convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{Î± : Type u_2} [subtractionMonoid Î±] {a : Î±} : Even a â†’ Even (-a)
{R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (s : R) (x y : A) : x * s â€¢ y = s â€¢ (x * y)
{C : Type u} [CategoryTheory.Category C] {Fâ‚ Fâ‚‚ : Cáµ’áµ– â¥¤ Type v} (Î± : Fâ‚ âŸ¶ Fâ‚‚) : (CategoryTheory.categoryOfElements.map Î±).op â‹™ CategoryTheory.categoryOfElements.toCostructuredArrow Fâ‚‚ = CategoryTheory.categoryOfElements.toCostructuredArrow Fâ‚ â‹™ CategoryTheory.CostructuredArrow.map Î±
{Î± : Type u} {L : List (Î± Ã— Bool)} [DecidableEq Î±] : FreeGroup.reduce (FreeGroup.reduce L) = FreeGroup.reduce L
{R : Type u} {a : R} [Semiring R] {p : Polynomial R} (h : p.leading_Coeff * a â‰  0) : (p * â‡‘Polynomial.c a).nat_degree = p.nat_degree
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] [CategoryTheory.Limits.HasLimitsOfShape J C] (R : D â¥¤ C) [CategoryTheory.Reflective R] : CategoryTheory.Limits.HasLimitsOfShape J D
{R : Type u_1} [CommRing R] (P : Ideal (Polynomial R)) : ((Ideal.Quotient.mk (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.c P))) P)).comp Polynomial.c).comp (Ideal.Quotient.mk (Ideal.comap Polynomial.c P)) = ((Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.c P))) P).quotient_Map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.c P))) Ideal.le_comap_Map).comp ((Ideal.Quotient.mk P).comp Polynomial.c)
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semiNormedGroup E'] [semiNormedGroup F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : f' =O[l] g' â†’ ((Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{Î± : Type u_1} [Preorder Î±] {a b : Î±} : a â©¿ b â†’ â‡‘OrderDual.toDual b â©¿ â‡‘OrderDual.toDual a
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [uniformSpace Î±] [uniformSpace Î²] [LocallyCompactSpace Î±] [CompactSpace Î²] [SeparatedSpace Î²] [uniformSpace Î³] {f : Î± â†’ Î² â†’ Î³} {x : Î±} {U : Set Î±} (hxU : U âˆˆ nhds x) (hU : IsSeparated U) (h : ContinuousOn â†¿f (U Ã—Ë¢ Set.Univ)) : TendstoUniformly f (f x) (nhds x)
{a : â„} {l : Filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhds a, HasDerivAt f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in nhds a, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhds a, g' x â‰  0) (hfa : Filter.Tendsto f (nhds a) (nhds 0)) (hga : Filter.Tendsto g (nhds a) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), f' x / g' x) (nhds a) l) : Filter.Tendsto (Î» (x : â„), f x / g x) (nhdsWithin a (Set.Univ  {a})) l
{p : â„} : Summable (Î» (n : â„•), (â†‘n ^ p)â»Â¹) â†” 1 < p
(x : Pgame) : (x * 1).equiv x
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {f : Filter Î±} {g : Filter Î²} {m : Î± â†’ Î²' â†’ Î³} {n : Î² â†’ Î²'} {m' : Î± â†’ Î² â†’ Î´} {n' : Î´ â†’ Î³} (h_Right_comm : âˆ€ (a : Î±) (b : Î²), m a (n b) = n' (m' a b)) : Filter.mapâ‚‚ m f (Filter.map n g) = Filter.map n' (Filter.mapâ‚‚ m' f g)
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} : Emetric.diam {x} = 0
(R : Type u_1) {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsArtinianRing R] {A : Set M} (hA : A.finite) : IsArtinian R â†¥(Submodule.span R A)
{V : Type u_1} [innerProductSpace â„ V] {x : V} (hx : x â‰  0) : InnerProductGeometry.angle x x = 0
(p n : â„•) : WittVector.IsPoly p (Î» (R : Type u_1) (_Rcr : CommRing R), WittVector.init n)
{R : Type u} {L : Type v} [CommRing R] [LieRing L] [lieAlgebra R L] (M : Type w) [AddCommGroup M] [Module R M] [LieRingModule L M] [lieModule R L M] [LieAlgebra.IsNilpotent R L] [LieModule.IsNilpotent R L M] : LieModule.weightSpace M 0 = âŠ¤
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] [NormalSpace Y] (f : boundedContinuousFunction X â„) (e : C(X, Y)) (hE : ClosedEmbedding â‡‘e) : âˆƒ (g : boundedContinuousFunction Y â„), âˆ¥gâˆ¥ â‰¤ âˆ¥fâˆ¥ / 3 âˆ§ HasDist.dist (g.comp_Continuous e) f â‰¤ 2 / 3 * âˆ¥fâˆ¥
{C : Type u} [CategoryTheory.Category C] (P Q : C) [CategoryTheory.Limits.HasBinaryProduct P Q] [CategoryTheory.Limits.HasBinaryProduct Q P] : (CategoryTheory.Limits.prod.braiding P Q).hom â‰« (CategoryTheory.Limits.prod.braiding Q P).hom = ðŸ™ (P â¨¯ Q)
{Î± : Type u_1} {Î² : Type u_2} (rÎ± : Î± â†’ Î± â†’ Prop) (rÎ² : Î² â†’ Î² â†’ Prop) : Prod.rprod rÎ± rÎ² â‰¤ Relation.TransGen (Relation.GameAdd rÎ± rÎ²)
{E : Type u_3} [semiNormedGroup E] : Filter.Tendsto Neg.neg (Filter.comap HasNorm.norm Filter.atTop) (Filter.comap HasNorm.norm Filter.atTop)
{Î± : Type u} : Nonempty (Field Î±) â†” IsPrimePow (Cardinal.mk Î±)
(x : Pgame) : (x * 0).equiv 0
{Î± : Type u_1} {M : Type u_5} {G : Type u_9} [Group G] [mulAction G Î±] [AddCommMonoid M] (g : G) (f : Î± â†’â‚€ M) (a : Î±) : â‡‘(g â€¢ f) a = â‡‘f (gâ»Â¹ â€¢ a)
 : âˆ€á¶  (x : â„) in residual â„, Liouville x
{S : Type u_1} [AddSemigroup S] {a b c : S} (hac : AddCommute a c) (hbc : AddCommute b c) : AddCommute (a + b) c
{Î¹ : Type u_1} {ð•œ : Type u_2} [is_R_or_C ð•œ] {E : Type u_3} [innerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), innerProductSpace ð•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ V) [âˆ€ (i : Î¹), CompleteSpace (G i)] (hV' : (â¨† (i : Î¹), (V i).to_LinearMap.range).topological_Closure = âŠ¤) (Wâ‚€ : Î â‚€ (i : Î¹), G i) : â‡‘((hV.linear_Isometry_Equiv hV').symm) (Wâ‚€.sum (lp.single 2)) = Wâ‚€.sum (Î» (i : Î¹), â‡‘(V i))
{Î± : sort u_1} {Î² : sort u_2} {sâ‚ : Setoid Î±} {sâ‚‚ : Setoid Î²} {p : Quotient sâ‚ â†’ Quotient sâ‚‚ â†’ Prop} (qâ‚ : Quotient sâ‚) (qâ‚‚ : Quotient sâ‚‚) (h : âˆ€ (aâ‚ : Î±) (aâ‚‚ : Î²), p (Quotient.mk' aâ‚) (Quotient.mk' aâ‚‚)) : p qâ‚ qâ‚‚
(ð•œ : Type v) [is_R_or_C ð•œ] {E : Type u} [NormedGroup E] [normedSpace ð•œ E] {x y : E} : x = y â†” âˆ€ (g : NormedSpace.Dual ð•œ E), â‡‘g x = â‡‘g y
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (u : E) {v : E} (hv : HasInner.inner v u = 0) : v âˆˆ (Submodule.span ð•œ {u})á—®
(x : â„‚) : HasStrictDerivAt Complex.cos (-Complex.sin x) x
(u : â„• â†’ â„) (l : â„) (hmono : Monotone u) (c : â„• â†’ â„) (cone : âˆ€ (k : â„•), 1 < c k) (clim : Filter.Tendsto c Filter.atTop (nhds 1)) (hc : âˆ€ (k : â„•), Filter.Tendsto (Î» (n : â„•), u âŒŠc k ^ nâŒ‹â‚Š / â†‘âŒŠc k ^ nâŒ‹â‚Š) Filter.atTop (nhds l)) : Filter.Tendsto (Î» (n : â„•), u n / â†‘n) Filter.atTop (nhds l)
{E : Type u_1} [AddCommGroup E] [hasNorm E] (C : NormedGroup.Core E) : SemiNormedGroup.Core E
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} [topologicalSpace Î±] (h : TendstoUniformlyOn F f p s) (hc : âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) [p.ne_IsBot] : ContinuousOn f s
{R : Type u_4} {S : Type u_5} [NonAssocSemiring R] [NonAssocSemiring S] (f : R â‰ƒ+* S) : â†‘â†‘f = â†‘f
{n m : SimplexCategory} {f : n âŸ¶ m} : CategoryTheory.Epi f â†” Function.Surjective â‡‘(SimplexCategory.Hom.toOrderHom f)
{Î± : Type u_2} [hasAdd Î±] {a : Î±} : Even a â†’ (âˆƒ (b : Î±), a = bit0 b)
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (p1 p2 : P) (g : G) : p1 -áµ¥ (g +áµ¥ p2) = p1 -áµ¥ p2 - g
{Î± : Type u} [pseudoEmetricSpace Î±] {s t u : Set Î±} : Emetric.hausdorffEdist s u â‰¤ Emetric.hausdorffEdist s t + Emetric.hausdorffEdist t u
{Î± : Type u_1} [pseudoMetricSpace Î±] (r C : â„) (hr : r < 1) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasDist.dist (f n) (f (n + 1)) â‰¤ C * r ^ n) : CauchySeq f
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topologicalSpace B] [topologicalSpace F] (Z : TopologicalFiberBundleCore Î¹ B F) : Continuous Z.proj
{ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [NormedGroup G] [normedSpace ð•œ G] {f : ð•œ â†’ G} {s : Set ð•œ} {C : Nnreal} (hF : âˆ€ (x : ð•œ), x âˆˆ s â†’ DifferentiableAt ð•œ f x) (bound : âˆ€ (x : ð•œ), x âˆˆ s â†’ âˆ¥deriv f xâˆ¥â‚Š â‰¤ C) (hs : Convex â„ s) : LipschitzOnWith C f s
{G : Type u_1} [Group G] (tG : monoid.is_torsion G) (H : Subgroup G) : monoid.is_torsion â†¥H
{p n k : â„•} (hn : 0 < n) : p ^ â‡‘((n.choose k).factorization) p â‰¤ n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] {Y Z : C} (f : Y âŸ¶ Z) (P : CategoryTheory.projectiveResolution Y) (Q : CategoryTheory.projectiveResolution Z) : CategoryTheory.projectiveResolution.lift_f_One f P Q â‰« Q.complex.d 1 0 = P.complex.d 1 0 â‰« CategoryTheory.projectiveResolution.lift_f_Zero f P Q
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (i : Fin r âŠ• Unit) {k : â„•} (hk : k â‰¤ r) : M.mul (List.take k (Matrix.Pivot.listTransvecRow M)).prod i (Sum.inr ()) = M i (Sum.inr ())
{Î¹ : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {la la' : Filter â„} {Lt : Filter Î¹} {a b : â„} {u v : Î¹ â†’ â„} [Interval_integral.FTC_Filter a la la'] (hab : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f la' MeasureTheory.MeasureSpace.volume) (hF : Filter.Tendsto f (la' âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) (hu : Filter.Tendsto u Lt la) (hv : Filter.Tendsto v Lt la) : (Î» (t : Î¹), ((âˆ« (x : â„) in v t..b, f x) - âˆ« (x : â„) in u t..b, f x) + (v t - u t) â€¢ c) =o[Lt] (v - u)
{a : Nnreal} : AddLeCancellable â†‘a
{Î± : Type u} [hasSsubset Î±] [IsIrrefl Î± HasSsubset.Ssubset] {a b : Î±} : a âŠ‚ b â†’ b â‰  a
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [CompleteSpace E] (v : E) : â‡‘(orthogonalProjection (Submodule.span ð•œ {v})á—®) v = 0
{Î± : Type} {f g : (Î± â†’ â„•) â†’ â„•} (df : Dioph.DiophFn f) (dg : Dioph.DiophFn g) : Dioph.DiophFn (Î» (v : Î± â†’ â„•), f v ^ g v)
(R : Type u) (L : Type v) [CommRing R] [LieRing L] [lieAlgebra R L] [LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L] : Subsingleton L
{G : Type u_3} [AddGroup G] (P : AddSubgroup G) : P.fg â†” P.to_Add_submonoid.fg
{R : Type u_1} [CommRing R] (u v w : Fin 3 â†’ R) : Matrix.dotProduct u (â‡‘(â‡‘crossProduct v) w) = Matrix.dotProduct v (â‡‘(â‡‘crossProduct w) u)
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (G : D â¥¤ C) [CategoryTheory.IsRightAdjoint G] : CategoryTheory.SolutionSetCondition G
{R : Type u_1} [CommSemiring R] (x y : R) (n : â„•) : (x + y) ^ n = (Finset.range (n + 1)).sum (Î» (m : â„•), x ^ m * y ^ (n - m) * â†‘(n.choose m))
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {v : E} (hv : v âˆˆ Ká—®) : â‡‘(reflection K) v = -v
{b m : â„•} : m < (b + 2) ^ ((b + 2).digits m).length
{Î± : Type u_1} {r : Setoid Î±} : âˆ… âˆ‰ r.classes
{G : Type u_1} {H : Type u_2} [Group G] {N : Subgroup G} [Group H] {f : G â†’* H} (hF : Function.Surjective â‡‘f) (hN : N = f.ker) (tN : monoid.is_torsion â†¥N) : monoid.is_torsion H â†” monoid.is_torsion G
{p : â„•} (hp : 1 < p) : padicValNat p p = 1
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : f =O[l] g â†” âˆƒ (c : â„), âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥
{p n k : â„•} : â‡‘((n.choose k).factorization) p â‰¤ Nat.log p n
{R : Type u_1} [MulZeroClass R] (h : IsRightRegular 0) : Subsingleton R
{Î± : Type u_1} {s : Multiset Î±} : s.nodup â†’ s.powerset.nodup
{Î± : Type u_1} {M : Type u_5} {R : Type u_11} {S : Type u_12} [hasZero M] [CommSemiring R] [CommSemiring S] (h : R â†’+* S) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ R) : â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
{G : Type u_6} {H : Type u_7} {F : Type u_8} [Group G] [divisionMonoid H] [monoidHomClass F G H] (f : F) (a : G) : â‡‘f aâ»Â¹ = (â‡‘f a)â»Â¹
{Î± : Type u} {Î² : Type v} [CommSemiring Î²] {Î´ : Î± â†’ Type u_1} [DecidableEq Î±] [Î  (a : Î±), DecidableEq (Î´ a)] {s : Finset Î±} {t : Î  (a : Î±), Finset (Î´ a)} {f : Î  (a : Î±), Î´ a â†’ Î²} : s.prod (Î» (a : Î±), (t a).sum (Î» (b : Î´ a), f a b)) = (s.pi t).sum (Î» (p : Î  (a : Î±), a âˆˆ s â†’ Î´ a), s.attach.prod (Î» (x : {x // x âˆˆ s}), f x.val (p x.val _)))
(R : Type u) [CommSemiring R] {M : Type v} [AddCommMonoid M] [Module R M] (g : M â†’â‚—[R] M) (f : (M â†’â‚—[R] M)Ë£) : â‡‘(LinearMap.trace R M) (â†‘f * g * â†‘fâ»Â¹) = â‡‘(LinearMap.trace R M) g
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G H : C â¥¤ D} (e : F â‰… G) (e' : G â‰… H) (hF : CategoryTheory.IsEquivalence F) : CategoryTheory.IsEquivalence.ofIso e' (CategoryTheory.IsEquivalence.ofIso e hF) = CategoryTheory.IsEquivalence.ofIso (e â‰ªâ‰« e') hF
{J : Type v} [CategoryTheory.SmallCategory J] {F : J â¥¤ Type (max v u)} (x : CategoryTheory.Limits.colimit F) : âˆƒ (j : J) (y : F.obj j), CategoryTheory.Limits.colimitÎ¹ F j y = x
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ Mon_) [CategoryTheory.IsFiltered J] {x x' y : Î£ (j : J), â†¥(F.obj j)} (hxx' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F â‹™ CategoryTheory.forget Mon_) x x') : Mon.FilteredColimits.colimitMulAux F x y = Mon.FilteredColimits.colimitMulAux F x' y
{Î± : Type u} [AddGroup Î±] [LinearOrder Î±] [CovariantClass Î± Î± Add.add LE.le] (a : Î±) : Linear_order.max a 0 - Linear_order.max (-a) 0 = a
{a b : â„•} (hab : a.coprime b) : (a * b).factorization = a.factorization + b.factorization
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (p : Î¹ â†’ P) : Finset.centroid k s p = â‡‘(s.affine_combination p) (Finset.centroidWeights k s)
{R : Type u_1} [orderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_4} [Fintype Î¹] [DecidableEq Î¹] [Nontrivial R] (e : Basis Î¹ R M) (w : Î¹ â†’ RË£) : (e.units_Smul w).orientation = (finset.univ.prod (Î» (i : Î¹), w i))â»Â¹ â€¢ e.orientation
(n : â„•) (R : Type u_1) [CommRing R] [is_IsDomain R] : (Polynomial.cyclotomic' n R).roots = (primitiveRoots n R).val
{M : Type u_1} {Î¹ : Type u_2} {R : Type u_3} [DecidableEq M] [AddMonoid M] [DecidableEq Î¹] [AddMonoid Î¹] [CommSemiring R] (f : M â†’+ Î¹) : DirectSum.IsInternal (AddMonoidAlgebra.gradeBy R â‡‘f)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} : Antitone f â†’ Monotone (â‡‘OrderDual.toDual âˆ˜ f)
{Î± : Type u_1} [topologicalSpace Î±] [NonUnitalNonAssocRing Î±] [TopologicalRing Î±] (x : Î±) : Continuous â‡‘(AddMonoidHom.mulRight x)
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {f : â„‚ â†’ E} (hD : DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.i) = 0) : Set.EqOn f 0 {z : â„‚ | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] (X : C) : CategoryTheory.IsPushout 0 (ðŸ™ X) 0 0
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [NormedGroup F] [normedSpace â„ F] {s : Set E} (s_conv : Convex â„ s) {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€ (x : E), x âˆˆ Interior s â†’ HasFderivAt f (f' x) x) {x : E} (xs : x âˆˆ s) (hx : HasFderivWithinAt f' f'' (Interior s) x) {v w : E} (hv : x + v âˆˆ Interior s) (hw : x + v + w âˆˆ Interior s) : (Î» (h : â„), f (x + h â€¢ v + h â€¢ w) - f (x + h â€¢ v) - h â€¢ â‡‘(f' x) w - h ^ 2 â€¢ â‡‘(â‡‘f'' v) w - (h ^ 2 / 2) â€¢ â‡‘(â‡‘f'' w) w) =o[nhdsWithin 0 (Set.Ioi 0)] Î» (h : â„), h ^ 2
{H : Type u_1} [topologicalSpace H] {e : localHomeomorph H H} : e âˆˆ ChartedSpace.Atlas H H â†” e = LocalHomeomorph.refl H
{R : Type u_1} {E : Type u_2} [linearOrderedField R] [AddCommGroup E] [Module R E] (s : Set E) : â‡‘(convexHull R) s = â‹ƒ (t : Finset E) (w : â†‘t âŠ† s), â‡‘(convexHull R) â†‘t
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasFiniteLimits C] : CategoryTheory.Limits.HasFiniteWidePullbacks C
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ Finset.Nat.antidiagonal n â†” x.fst + x.snd = n
{p : â„•} [hp : Fact (Nat.Prime p)] {R : Type u_1} [CommRing R] {S : Type u_2} [Semiring S] {f : Î  (k : â„•), S â†’+* TruncatedWittVector p k R} (f_compat : âˆ€ (kâ‚ kâ‚‚ : â„•) (hk : kâ‚ â‰¤ kâ‚‚), (TruncatedWittVector.truncate hk).comp (f kâ‚‚) = f kâ‚) (g : S â†’+* WittVector p R) (g_compat : âˆ€ (k : â„•), (WittVector.truncate k).comp g = f k) : WittVector.lift (Î» (kâ‚‚ : â„•), f kâ‚‚) f_compat = g
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {a b : â„} {f f' : â„ â†’ â„} {g : â„ â†’ E} (h : âˆ€ (x : â„), x âˆˆ Set.Interval a b â†’ HasDerivAt f (f' x) x) (h' : ContinuousOn f' (Set.Interval a b)) (hg : Continuous g) : âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (x : â„) in f a..f b, g x
{k : Type u_1} {M : Type u_2} [linearOrderedField k] [orderedAddCommMonoid M] [mulActionWithZero k M] (hlt : âˆ€ â¦ƒa b : Mâ¦„ â¦ƒc : kâ¦„, a < b â†’ 0 < c â†’ c â€¢ a â‰¤ c â€¢ b) : OrderedSmul k M
{Î³ : Type u_3} [tÎ³ : topologicalSpace Î³] [PolishSpace Î³] [measurableSpace Î³] [BorelSpace Î³] {Î² : Type u_4} [tÎ² : topologicalSpace Î²] [t2_Space Î²] [measurableSpace Î²] [BorelSpace Î²] {s : Set Î³} {f : Î³ â†’ Î²} (hs : MeasurableSet s) (f_Cont : ContinuousOn f s) (f_inj : Set.InjOn f s) : MeasurableEmbedding (s.restrict f)
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) (h : (Multiset.map (Î» (f : Polynomial R), f.leading_Coeff) t).prod â‰  0) : t.prod.nat_degree = (Multiset.map (Î» (f : Polynomial R), f.nat_degree) t).sum
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} {P : Type uâ‚„} [AddCommGroup V] [addTorsor V P] [Ring k] [Module k V] (b : AffineBasis Î¹ k P) {Î¹' : Type u_1} [Fintype Î¹'] [Fintype Î¹] [DecidableEq Î¹] [Nontrivial k] (p : Î¹' â†’ P) {A : Matrix Î¹ Î¹' k} (hA : A.mul (b.to_Matrix p) = 1) : affineSpan k (Set.Range p) = âŠ¤
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Î¹ : Type w} {s : Set Î¹} (h : Basis â†¥s K V) (hs : s.finite) : FiniteDimensional K V
{Î± : Type u_1} [conditionallyCompleteLattice Î±] (a : Î±) : HasInf.inf {a} = a
(p : â„•) [hp : Fact (Nat.Prime p)] {k : Type u_1} [CommRing k] [Char_p k p] (n : â„•) (x y : WittVector p k) : WittVector.peval (WittVector.polyOfInterest p n) ![Î» (i : â„•), x.coeff i, Î» (i : â„•), y.coeff i] = (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) - x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1)
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {s : Set â„‚} {f : â„‚ â†’ E} {z : â„‚} (hD : DifferentiableOn â„‚ f s) (hz : s âˆˆ nhds z) : AnalyticAt â„‚ f z
{Î± : Type u} [topologicalSpace Î±] [t2_Space Î±] {s : Set Î±} (hs : is_IsCompact s) {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ Set Î±) (hU : âˆ€ (i : Î¹), i âˆˆ t â†’ is_IsOpen (U i)) (hsC : s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i) : âˆƒ (K : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), is_IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (H : i âˆˆ t), K i
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : ConvexOn ð•œ s f) {x y z : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hz : z âˆˆ Segment ð•œ x y) : f z â‰¤ Linear_order.max (f x) (f y)
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {R : â„} {c w : â„‚} {f : â„‚ â†’ E} (h : DiffContOnCl â„‚ f (Metric.Ball c R)) (hw : w âˆˆ Metric.Ball c R) : âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘Real.pi * Complex.i) â€¢ f w
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q) : Function.Injective â‡‘f â†’ âˆ€ (a : â†¥P), â‡‘f a = 0 â†’ a = 0
{ð•œ : Type u} {A : Type v} [Field ð•œ] [Ring A] [Algebra ð•œ A] [Nontrivial A] : Spectrum ð•œ 0 = {0}
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [OrderedAddCommGroup Î²] [HasScalar ð•œ E] [Module ð•œ Î²] {s : Set E} {f : E â†’ Î²} : StrictConvexOn ð•œ s (-f) â†” StrictConcaveOn ð•œ s f
{E : Type u_2} {ð•œ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] {s : Set E} (hs : Convex ð•œ s) {a b : ð•œ} (ha : 0 â‰¤ a) (hb : 0 < b) (hab : a + b = 1) : a â€¢ Closure s + b â€¢ Interior s âŠ† Interior s
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] : (EuclideanGeometry.reflection s).symm = EuclideanGeometry.reflection s
{ð•œ : Type u_1} {E : Type u_2} [SemiNormedRing ð•œ] [HasScalar ð•œ E] [hasZero E] [topologicalSpace E] {sâ‚ sâ‚‚ : Set E} (h : sâ‚ âŠ† sâ‚‚) (hsâ‚‚ : bornology.is_vonN_bounded ð•œ sâ‚‚) : bornology.is_vonN_bounded ð•œ sâ‚
{R : Type u_1} [MulZeroClass R] : IsRegular 0 â†” Subsingleton R
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : f =o[l] g â†” âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ asymptotics.is_O_with c l f g
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} (h_Mono : StrictMonoOn f s) (hs : s âˆˆ nhdsWithin a (Set.Iic a)) (hfs : Set.SurjOn f s (Set.Iio (f a))) : ContinuousWithinAt f (Set.Iic a) a
{X Y : Top} {f g : C(â†¥X, â†¥Y)} (H : f.homotopy g) {xâ‚€ xâ‚ : â†¥X} (p : FundamentalGroupoid.fromTop xâ‚€ âŸ¶ FundamentalGroupoid.fromTop xâ‚) : (fundamental_groupoid.fundamental_groupoid_functor.map g).map p = ContinuousMap.Homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_Map).map (Continuous_map.homotopy.prod_to_Prod_Top_I (ðŸ™ {down := 1}) p) â‰« ContinuousMap.Homotopy.hcast _
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (Î¸ : Real.Angle) : hb.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
{R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [Semiring R] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [semiNormedGroup E] [semiNormedGroup Eâ‚‚] [Module R E] [Module Râ‚‚ Eâ‚‚] {Î¹ : Type u_3} (b : Basis Î¹ R E) {fâ‚ fâ‚‚ : E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚} (h : âˆ€ (i : Î¹), â‡‘fâ‚ (â‡‘b i) = â‡‘fâ‚‚ (â‡‘b i)) : fâ‚ = fâ‚‚
{G : Type u_4} [NormedGroup G] [normedSpace â„ G] {s : Set G} {x y : G} (h : OpenSegment â„ x y âŠ† s) : y - x âˆˆ TangentConeAt â„ s x
{Î± : Type u} [SemilatticeSup Î±] [OrderBot Î±] (x y z : Î±) (f : z âŸ¶ x) (g : z âŸ¶ y) : CategoryTheory.Limits.pushout f g = x âŠ” y
{M : Type u_1} [hasMul M] (c : Con M) : conGen â‡‘c = c
{K : Type u_4} {V : Type u} [divisionRing K] [AddCommGroup V] [Module K V] {x : V} {n : â„•} {v : Fin n â†’ V} (hv : LinearIndependent K v) (hx : x âˆ‰ Submodule.span K (Set.Range v)) : LinearIndependent K (fin.cons x v)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (lâ‚ lâ‚‚ : Î¹ â†’â‚€ ð•œ) : HasInner.inner (â‡‘(Finsupp.total Î¹ E ð•œ v) lâ‚) (â‡‘(Finsupp.total Î¹ E ð•œ v) lâ‚‚) = lâ‚.sum (Î» (i : Î¹) (y : ð•œ), â‡‘(starRingEnd ð•œ) y * â‡‘lâ‚‚ i)
{Î± : Type u_1} [hasAdd Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b c d : Î±} (hâ‚ : a < b) (hâ‚‚ : c < d) : a + c < b + d
(n : â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] : IsCyclotomicExtension {n} A B â†” (âˆƒ (r : B), â‡‘(Polynomial.aeval r) (Polynomial.cyclotomic â†‘n A) = 0) âˆ§ âˆ€ (x : B), x âˆˆ Algebra.adjoin A {b : B | b ^ â†‘n = 1}
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} {a : Î±} : (âˆƒá¶  (x : Î±) in nhds a, x âˆˆ s) â†’ a âˆˆ Closure s
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] : CategoryTheory.Limits.HasFiniteProducts C
{Î± : Type} {d : â„•} {ds : List â„•} (x y : Holor Î± (d :: ds)) (h : x.slice = y.slice) : x = y
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] [FiniteDimensional â„ V] (hD : FiniteDimensional.finrank â„ V = 2) {câ‚ câ‚‚ pâ‚ pâ‚‚ p : P} {râ‚ râ‚‚ : â„} (hc : câ‚ â‰  câ‚‚) (hp : pâ‚ â‰  pâ‚‚) (hpâ‚câ‚ : HasDist.dist pâ‚ câ‚ = râ‚) (hpâ‚‚câ‚ : HasDist.dist pâ‚‚ câ‚ = râ‚) (hpcâ‚ : HasDist.dist p câ‚ = râ‚) (hpâ‚câ‚‚ : HasDist.dist pâ‚ câ‚‚ = râ‚‚) (hpâ‚‚câ‚‚ : HasDist.dist pâ‚‚ câ‚‚ = râ‚‚) (hpcâ‚‚ : HasDist.dist p câ‚‚ = râ‚‚) : p = pâ‚ âˆ¨ p = pâ‚‚
{ð•œ : Type u_1} [normedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Subspace ð•œ E} (hFc : is_IsClosed â†‘F) (hF : âˆƒ (x : E), x âˆ‰ F) {r : â„} (hr : r < 1) : âˆƒ (xâ‚€ : E), xâ‚€ âˆ‰ F âˆ§ âˆ€ (y : E), y âˆˆ F â†’ r * âˆ¥xâ‚€âˆ¥ â‰¤ âˆ¥xâ‚€ - yâˆ¥
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} {ps : Set P} (h : ps âŠ† â†‘s) [Nonempty â†¥s] {n : â„•} [FiniteDimensional â„ â†¥(s.direction)] (hD : FiniteDimensional.finrank â„ â†¥(s.direction) = n) (hc : EuclideanGeometry.Cospherical ps) : âˆƒ (r : â„), âˆ€ (sx : Affine.Simplex â„ P n), Set.Range sx.points âŠ† ps â†’ sx.circumradius = r
{Î± : Type u_1} [hasMul Î±] [HasLe Î±] [ContravariantClass Î± Î± Mul.mul LE.le] {a b c : Î±} (bc : a * b â‰¤ a * c) : b â‰¤ c
{C : Type u} [CategoryTheory.Category C] {X Y : C} (J : CategoryTheory.GrothendieckTopology C) (f : Y âŸ¶ X) (S : CategoryTheory.Sieve X) (h : J.covers S f) {Z : C} (g : Z âŸ¶ Y) : J.covers S (g â‰« f)
{Î± : Type u_1} [AddCommMonoid Î±] {Î² : Type u_2} [Fintype Î²] (s : Set Î²) [DecidablePred (Î» (_x : Î²), _x âˆˆ s)] (f : Î² â†’ Î±) (g : â†¥s â†’ Î±) (w : âˆ€ (x : Î²) (h : x âˆˆ s), f x = g âŸ¨x, hâŸ©) (w' : âˆ€ (x : Î²), x âˆ‰ s â†’ f x = 0) : finset.univ.sum f = finset.univ.sum g
{K : Type u_1} {S : Type u_2} [Field K] [CommRing S] [Algebra K S] (h : powerBasis K S) : (â‡‘(Algebra.leftMulMatrix h.basis) h.gen).charpoly = minpoly K h.gen
(n : â„•) : n.factors.to_Finset = Finset.filter Nat.Prime n.divisors
(R : Type u_1) [CommSemiring R] (M : Type u_4) (N : Type u_5) [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N] : Submodule.span R {t : tensorProduct R M N | âˆƒ (m : M) (n : N), m âŠ—â‚œ[R] n = t} = âŠ¤
{Î± : Type u} [pseudoMetricSpace Î±] : Metric.diam âˆ… = 0
{R : Type u} {S : Type v} [NonAssocSemiring R] [NonAssocSemiring S] {f g : R â†’+* S} {s : Set R} (h : Set.EqOn â‡‘f â‡‘g s) : Set.EqOn â‡‘f â‡‘g â†‘(Subsemiring.closure s)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [TopologicalSpace.SeparableSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} (h : DenseRange f) (h' : Continuous f) : TopologicalSpace.SeparableSpace Î²
{p : â„•} [Fact (Nat.Prime p)] {a : Zmod p} (ha : a â‰  0) : a ^ (p - 1) = 1
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚} [CategoryTheory.Category K] [CategoryTheory.IsPreconnected J] (e : J â‰Œ K) : CategoryTheory.IsPreconnected K
{G : Type w} [topologicalSpace G] [HasNeg G] [hasAdd G] [HasContinuousAdd G] [HasContinuousNeg G] : Continuous (Î» (g : G Ã— G), g.fst + g.snd + -g.fst)
{Î± : Type u_1} [Preorder Î±] {s : Set Î±} : s.ord_connected â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ Set.Icc x y âŠ† s
{G : Type u_1} [Group G] {k : Set G} {p : Î  (x : G), x âˆˆ Subgroup.closure k â†’ Prop} (Hs : âˆ€ (x : G) (h : x âˆˆ k), p x _) (H1 : p 1 _) (HMul : âˆ€ (x : G) (hx : x âˆˆ Subgroup.closure k) (y : G) (hy : y âˆˆ Subgroup.closure k), p x hx â†’ p y hy â†’ p (x * y) _) (Hinv : âˆ€ (x : G) (hx : x âˆˆ Subgroup.closure k), p x hx â†’ p xâ»Â¹ _) {x : G} (hx : x âˆˆ Subgroup.closure k) : p x hx
{K : Type u_4} [normedField K] {Î¾ : K} : Summable (Î» (n : â„•), Î¾ ^ n) â†” âˆ¥Î¾âˆ¥ < 1
{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] : Submodule.torsion R (M â§¸ Submodule.torsion R M) = âŠ¥
{K : Type u} [Field K] (s : Subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
{R : Type u} [Semiring R] {P : Type (max u v)} [AddCommMonoid P] [Module R P] {M : Type (max u v)} [AddCommGroup M] [Module R M] {N : Type u_1} [AddCommGroup N] [Module R N] [h : Module.Projective R P] (f : M â†’â‚—[R] N) (g : P â†’â‚—[R] N) (hF : Function.Surjective â‡‘f) : âˆƒ (h : P â†’â‚—[R] M), f.comp h = g
{Î± : Type u_1} [linearOrderedCommGroup Î±] {n : â„¤} {a b : Î±} (hn : n â‰  0) : a ^ n = b ^ n â†” a = b
{Î± : Type u_1} {m : Type u_3} {n : Type u_4} [nonUnitalSemiring Î±] [starRing Î±] {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} : (Matrix.fromBlocks A B C D).is_hermitian â†” A.is_hermitian âˆ§ B.conj_transpose = C âˆ§ C.conj_transpose = B âˆ§ D.is_hermitian
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [AddZeroClass M] {f : Î± â†’ Î²} (hF : Function.Injective f) (vâ‚ vâ‚‚ : Î² â†’â‚€ M) : Finsupp.comapDomain f (vâ‚ + vâ‚‚) _ = Finsupp.comapDomain f vâ‚ _ + Finsupp.comapDomain f vâ‚‚ _
{M : Type u_1} [hasMul M] {c d : Con M} : c âŠ” d = conGen (Setoid.r âŠ” Setoid.r)
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {f' : F} {x : ð•œ} [PartialOrder ð•œ] : HasDerivWithinAt f f' (Set.Iic x) x â†’ HasDerivWithinAt f f' (Set.Iio x) x
(n : â„•) : â‡‘Multiset.card (Multiset.Nat.antidiagonal n) = n + 1
{Î± : Type u_1} {Î² : Type u_2} {mÎ² : measurableSpace Î²} {m : measurableSpace Î±} (t : â„• â†’ Set Î²) (t_Meas : âˆ€ (n : â„•), MeasurableSet (t n)) (t_disj : Pairwise (Disjoint on t)) (g : â„• â†’ Î² â†’ Î±) (hg : âˆ€ (n : â„•), Measurable (g n)) : âˆƒ (f : Î² â†’ Î±), Measurable f âˆ§ âˆ€ (n : â„•) (x : Î²), x âˆˆ t n â†’ f x = g n x
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall f p x r) (h : â†‘r' < r) : TendstoUniformlyOn (Î» (n : â„•) (y : E), p.partial_Sum n y) (Î» (y : E), f (x + y)) Filter.atTop (Metric.Ball 0 â†‘r')
{Î± : sort u} {Î² : sort v} (e : Î± â‰ƒ Î²) : isEmpty Î± â†” isEmpty Î²
{M : Type u_1} [hasAdd M] {c d : AddCon M} : c âŠ” d = addConGen (Setoid.r âŠ” Setoid.r)
{R : Type u} [NonAssocSemiring R] (M : Submonoid R) : M.subsemiring_Closure = Subsemiring.closure â†‘M
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] : is_HasCompl K Ká—®
{Î± : sort u_1} {Î² : sort u_2} (f : Î± â†’ Î²) (P : Prop) [Decidable P] (a b : Î±) : f (Ite P a b) = Ite P (f a) (f b)
{a b : â„} {g' g : â„ â†’ â„} (hab : a â‰¤ b) (hcont : ContinuousOn g (Set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt g (g' x) (Set.Ioi x) x) (g'Int : MeasureTheory.IntegrableOn g' (Set.Icc a b) MeasureTheory.MeasureSpace.volume) : âˆ« (y : â„) in a..b, g' y = g b - g a
{p : â„•} (hp : 1 < p) : padicNorm p â†‘p = 1 / â†‘p
{R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [Semiring R] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} [RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] [RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] [semiNormedGroup E] [semiNormedGroup Eâ‚‚] [Module R E] [Module Râ‚‚ Eâ‚‚] {Î¹ : Type u_3} (b : Basis Î¹ R E) {fâ‚ fâ‚‚ : E â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚} (h : âˆ€ (i : Î¹), â‡‘fâ‚ (â‡‘b i) = â‡‘fâ‚‚ (â‡‘b i)) : fâ‚ = fâ‚‚
{n : â„•} (R : Type u_1) [Ring R] [Fact (0 < n)] : Coe âˆ˜ Zmod.val = Coe
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f fâ‚ : E â†’ F} {n : WithTop â„•} {p : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n f p s) (hâ‚ : âˆ€ (x : E), x âˆˆ s â†’ fâ‚ x = f x) : HasFtaylorSeriesUpToOn n fâ‚ p s
{E : Type u_3} {F : Type u_4} [semiNormedGroup E] [semiNormedGroup F] (f : E â†’+ F) (C : â„) (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : LipschitzWith C.to_Nnreal â‡‘f
{C : Type uâ‚} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : CategoryTheory.Presieve.IsSheafFor P â‡‘S) {f : S.functor âŸ¶ P} (t : Category_theory.yoneda.obj X âŸ¶ P) (ht : S.functor_inclusion â‰« t = f) : t = h.extend f
{E : Type u_2} [semiNormedGroup E] [normedSpace â„ E] (s : Set E) : Emetric.diam (â‡‘(convexHull â„) s) = Emetric.diam s
(p : Set â†’ Prop) : Class.Iota p âˆˆ Class.Univ
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) (m : M) : âˆ¥â‡‘(QuotientAddGroup.mk' S) mâˆ¥ = 0 â†” m âˆˆ Closure â†‘S
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {F F' : C â¥¤ D} (h : F â‰… F') {Y : D} (hY : Y âˆˆ F.ess_image) : Y âˆˆ F'.ess_image
{K : Type u_1} {L : Type u_2} {M : Type u_3} [Field K] [Field L] [Field M] [Algebra K L] [Algebra K M] {E1 E2 : intermediateField K L} (e : L â‰ƒâ‚[K] M) (h12 : E1 â‰¤ E2) : E1.map e.to_algHom â‰¤ E2.map e.to_algHom
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : f =O[l] g' â†’ (f =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} [Fintype Î¹] {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’ ð•œ) (i : Î¹) : HasInner.inner (finset.univ.sum (Î» (i : Î¹), l i â€¢ v i)) (v i) = â‡‘(starRingEnd ð•œ) (l i)
{n : â„•} (hn : 2 â‰¤ n) : StrictConvexOn â„ (Set.Ici 0) (Î» (x : â„), x ^ n)
{R : Type u_1} {M : Type u_2} {P : Type u_3} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup P] [Module R P] (f : M â†’â‚—[R] P) {s : Submodule R M} (hs1 : (Submodule.map f s).fg) (hs2 : (s âŠ“ f.ker).fg) : s.fg
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {Î¹ : Type w} {p : Î¹ â†’ Submodule K V} (hp : CompleteLattice.Independent p) [Fintype {i // p i â‰  âŠ¥}] : Fintype.card {i // p i â‰  âŠ¥} â‰¤ FiniteDimensional.finrank K V
{Î± : Type u_1} {Î² : Type u_2} [hasMem Î± Î²] {s t : Î²} {a : Î±} : a âˆˆ s â†’ a âˆ‰ t â†’ s â‰  t
{S : Type u_1} [hasAdd S] {a b : S} (h : AddCommute a b) : AddCommute b a
{K : Type u_1} {L : Type u_2} {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [isScalarTower K L A] (L_alg : Algebra.IsAlgebraic K L) (A_alg : Algebra.IsAlgebraic L A) : Algebra.IsAlgebraic K A
{Î± : Type u} : DenseRange Pure.pure
{Î± : Type u} [Semiring Î±] {x y : Î±} (h : Commute x y) (n : â„•) : (Finset.range n).sum (Î» (i : â„•), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {E' : Type u_7} [innerProductSpace ð•œ E'] (f : E â†’â‚—áµ¢[ð•œ] E') (x y : E) : HasInner.inner (â‡‘f x) (â‡‘f y) = HasInner.inner x y
{Y : Type u_2} [topologicalSpace Y] [NormalSpace Y] {s : Set Y} (f : boundedContinuousFunction â†¥s â„) (hs : is_IsClosed s) : âˆƒ (g : boundedContinuousFunction Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ g.restrict s = f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {X Y : C} [CategoryTheory.Simple X] {f : X âŸ¶ Y} [CategoryTheory.Epi f] (w : f â‰  0) : CategoryTheory.IsIso f
{M : Type u_3} [AddMonoid M] (l : List M) : (l.nth 0).get_or_else 0 + l.tail.sum = l.sum
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] : ContinuousMap.compactOpen = â¨… (s : Set Î±) (hs : is_IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen
{A : Type u_1} [normedRing A] [NormedAlgebra â„‚ A] [CompleteSpace A] [starRing A] [CstarRing A] [StarModule â„‚ A] [Nontrivial A] (a : â†¥(selfAdjoint A)) {z : â„‚} (hz : z âˆˆ Spectrum â„‚ â†‘a) : z = â†‘(z.re)
{R : Type u} [Ring R] [RankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {Î¹ : Type u_1} (b : Basis Î¹ R M) {w : Set M} [Fintype â†¥w] (s : Submodule.span R w = âŠ¤) : Cardinal.mk Î¹ â‰¤ â†‘(Fintype.card â†¥w)
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R) (r : R) : â‡‘(v.valuation) (â‡‘(algebraMap R K) r) < 1 â†” v.as_Ideal âˆ£ Ideal.span {r}
{Î± : Type u} [SemilatticeInf Î±] [OrderBot Î±] {a : Î±} : Disjoint a a â†’ a = âŠ¥
{R : Type u_1} [CommRing R] {xâ‚ xâ‚‚ yâ‚ yâ‚‚ n : R} : (xâ‚ ^ 2 + n * xâ‚‚ ^ 2) * (yâ‚ ^ 2 + n * yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - n * xâ‚‚ * yâ‚‚) ^ 2 + n * (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2
{K : Type u_3} {L : Type u_4} [Field K] [Field L] [Algebra K L] (A : Subalgebra K L) (hKL : Algebra.IsAlgebraic K L) : IsField â†¥A
{Î¹ : Type u} (s : Finset Î¹) (f g : Î¹ â†’ Nnreal) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), g i ^ p) ^ (1 / p)
{M : Type u_1} {A : Type u_2} [AddCommMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (f : A â†’ M) (t : Finset A) : (âˆ€ (b : A), b âˆˆ t â†’ f b âˆˆ s) â†’ t.sum (Î» (b : A), f b) âˆˆ s
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {p : P} : â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p) = p â†” p âˆˆ s
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] (e : localHomeomorph Î± Î²) {f : Î³ â†’ Î±} {s : Set Î³} (h : s âŠ† f â»Â¹' e.to_local_equiv.source) : ContinuousOn f s â†” ContinuousOn (â‡‘e âˆ˜ f) s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {s1 s2 : AffineSubspace k P} (h1 : â†‘s1.nonempty) (h2 : â†‘s2.nonempty) (hD : s1.direction âŠ” s2.direction = âŠ¤) : (â†‘s1 âˆ© â†‘s2).nonempty
{Î± : Type u} [HasSubset Î±] [hasSsubset Î±] [isNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {a b c : Î±} [IsTrans Î± HasSubset.Subset] (hâ‚ : a âŠ† b) (hâ‚‚ : b âŠ‚ c) : a âŠ‚ c
{M : Type u_1} {N : Type u_2} [AddZeroClass M] [AddZeroClass N] (h : M â‰ƒ+ N) : IsAddMonoidHom â‡‘h
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {E : Type w} [NormedGroup E] [normedSpace ð•œ E] {f : ð•œ â†’ F} {f' : F} (x : ð•œ) {l : F â†’ E} {l' : F â†’L[ð•œ] E} (hl : HasFderivAt l l' (f x)) (hF : HasDerivAt f f' x) : HasDerivAt (l âˆ˜ f) (â‡‘l' f') x
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (e : m â‰ƒ n) (A : Matrix m m R) : (â‡‘(Matrix.reindex e e) A).det = A.det
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [CompleteSpace E] [CompleteSpace F] (A : E â†’L[ð•œ] F) : â‡‘ContinuousLinearMap.adjoint (â‡‘ContinuousLinearMap.adjoint A) = A
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {s : Set E} {x : E} : UniqueMdiffWithinAt (modelWithCornersSelf ð•œ E) s x â†’ UniqueDiffWithinAt ð•œ s x
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {f : Filter Î±} [IsTrans Î± r] (a : Î±) (h : âˆ€ (s : Set Î±), s âˆˆ f â†’ (âˆƒ (x : Î±) (H : x âˆˆ s), r a x)) : Filter.IsCobounded r f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : E â†’ G} {x : E Ã— F} (hF : ContDiffAt ð•œ n f x.fst) : ContDiffAt ð•œ n (Î» (x : E Ã— F), f x.fst) x
{Î± : Type v} {s : Finset Î±} {M : Type u_1} [AddCommMonoid M] (f : Î± â†’ M) (p : M â†’ Prop) (p_Mul : âˆ€ (a b : M), p a â†’ p b â†’ p (a + b)) (hs_Nonempty : s.nonempty) (p_s : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (s.sum (Î» (x : Î±), f x))
{Î± : Type u_1} [PartialOrder Î±] [OrderTop Î±] {a : Î±} : a â‹– âŠ¤ â†’ IsCoatom a
(ð•œ : Type u_1) [nondiscreteNormedField ð•œ] (E : Type u_2) [NormedGroup E] [normedSpace ð•œ E] : (modelWithCornersSelf ð•œ E).to_LocalEquiv = LocalEquiv.refl E
{Î± : Type v} {s : Finset Î±} {M : Type u_1} [CommMonoid M] (f : Î± â†’ M) (p : M â†’ Prop) (p_Mul : âˆ€ (a b : M), p a â†’ p b â†’ p (a * b)) (hs_Nonempty : s.nonempty) (p_s : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (s.prod (Î» (x : Î±), f x))
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] (X : C) : CategoryTheory.IsPushout (ðŸ™ X) 0 0 0
{a b : â„} (h : a < b) : Cardinal.mk â†¥(Set.Ico a b) = Cardinal.continuum
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {f : Î± â†’ Î²} (hF : Isometry f) (x y : Î±) : HasNndist.nndist (f x) (f y) = HasNndist.nndist x y
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [CompactSpace Î±] [metricSpace Î²] {f g : C(Î±, Î²)} (x : Î±) : HasDist.dist (â‡‘f x) (â‡‘g x) â‰¤ HasDist.dist f g
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [NormedGroup G] [normedSpace ð•œ G] {g : F â†’ G} {f : E â†’ F} {x : E} (hg : AnalyticAt ð•œ g (f x)) (hF : AnalyticAt ð•œ f x) : AnalyticAt ð•œ (g âˆ˜ f) x
{M : Type u_1} {N : Type u_2} [hasAdd M] [hasAdd N] {f g : AddHom M N} {s : Set M} (h : Set.EqOn â‡‘f â‡‘g s) : Set.EqOn â‡‘f â‡‘g â†‘(AddSubsemigroup.closure s)
{Î± : Type u} [pseudoMetricSpace Î±] (s : Set Î±) : Continuous (Î» (x : Î±), Metric.infNndist x s)
(A : Type u_4) (K : Type u_5) [CommRing A] [is_IsDomain A] (L : Type u_6) [Field K] [Field L] [Algebra A K] [Algebra A L] [IsFractionRing A K] (C : Type u_7) [CommRing C] [is_IsDomain C] [Algebra C L] [IsIntegralClosure C A L] [Algebra A C] [isScalarTower A C L] [Algebra K L] [isScalarTower A K L] [FiniteDimensional K L] : IsFractionRing C L
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {ca cb : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb : Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds cb)) : HasStrictFderivAt (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd â„ â„ â„).smul_Right cb - (ContinuousLinearMap.fst â„ â„ â„).smul_Right ca) (a, b)
{ð•œ : Type u_1} {E : Type u_2} [linearOrderedRing ð•œ] [AddCommGroup E] [Module ð•œ E] [denselyOrdered ð•œ] [NoZeroSmulDivisors ð•œ E] {A : Set E} {x : E} : x âˆˆ Set.ExtremePoints ð•œ A â†” x âˆˆ A âˆ§ âˆ€ (xâ‚ : E), xâ‚ âˆˆ A â†’ âˆ€ (xâ‚‚ : E), xâ‚‚ âˆˆ A â†’ x âˆˆ Segment ð•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ¨ xâ‚‚ = x
{k : â„•} {A : Finset â„•} (hâ‚ : âˆ€ {x : â„•}, x âˆˆ A â†’ x < k) : A.sum (Pow.pow 2) < 2 ^ k
{Î± : Type u_1} [CircularPreorder Î±] {a b c : Î±} (h : HasSbtw.Sbtw a b c) : Â¬HasSbtw.Sbtw c b a
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {b : M} [linearOrderedCommRing M] [Nonempty Î²] (hb : Fintype.card Î² â€¢ b â‰¤ â†‘(Fintype.card Î±)) : âˆƒ (y : Î²), b â‰¤ â†‘((Finset.filter (Î» (x : Î±), f x = y) Finset.univ).card)
{n : â„•} (i : Fin (n + 2)) : â‡‘(i.succ.succ_above) 1 = (â‡‘(i.succ_above) 0).succ
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e : localHomeomorph Î± Î²} {s : Set Î±} {t : Set Î²} : e.to_local_equiv.source âˆ© â‡‘e â»Â¹' t = e.to_local_equiv.source âˆ© s â†’ e.is_image s t
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {v : â„ â†’ E â†’ E} {s : â„ â†’ Set E} {K : â„} (hv : âˆ€ (t : â„) (x : E), x âˆˆ s t â†’ âˆ€ (y : E), y âˆˆ s t â†’ HasDist.dist (v t x) (v t y) â‰¤ K * HasDist.dist x y) {f g : â„ â†’ E} {a b Î´ : â„} (hF : ContinuousOn f (Set.Icc a b)) (hF' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (v t (f t)) (Set.Ici t) t) (hfs : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ f t âˆˆ s t) (hg : ContinuousOn g (Set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt g (v t (g t)) (Set.Ici t) t) (hgs : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ g t âˆˆ s t) (ha : HasDist.dist (f a) (g a) â‰¤ Î´) (t : â„) (H : t âˆˆ Set.Icc a b) : HasDist.dist (f t) (g t) â‰¤ Î´ * Real.exp (K * (t - a))
(n : â„•) : Filter.Tendsto (Î» (x : â„), Polynomial.eval x (expNegInvGlue.pAux n) * Real.exp (-xâ»Â¹) / x ^ (2 * n)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [LinearOrder Î²] [denselyOrdered Î²] [NoMinOrder Î²] [NoMaxOrder Î²] [Nonempty Î²] (f : Order.PartialIso Î± Î²) (a : Î±) : âˆƒ (b : Î²), âˆ€ (p : Î± Ã— Î²), p âˆˆ f.val â†’ cmp p.fst a = cmp p.snd b
(p : â„•) [p_Prime : Fact (Nat.Prime p)] {n : â„•} {F : â„• â†’ â„š} (hF : âˆ€ (i : â„•), i < n â†’ 0 < padicValRat p (F i)) (hn0 : (Finset.range n).sum (Î» (i : â„•), F i) â‰  0) : 0 < padicValRat p ((Finset.range n).sum (Î» (i : â„•), F i))
{M : Type u_1} [Monoid M] {x : M} : monoid.closure {x} = Powers x
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [Preorder Î±] [Preorder Î²] [Preorder Î³] {f : Î± â†’ Î² â†’ Î³} {s : Set Î±} {t : Set Î²} (hâ‚€ : âˆ€ (b : Î²), Monotone (Function.swap f b)) (hâ‚ : âˆ€ (a : Î±), Monotone (f a)) : BddAbove s â†’ BddAbove t â†’ BddAbove (Set.image2 f s t)
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] : Fintype.card (Sym2 Î±) = Fintype.card Î± * (Fintype.card Î± + 1) / 2
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [normedSpace ð•œ E] [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ G} {C : â„} {s : Set E} {x y : E} {f' : E â†’ (E â†’L[ð•œ] G)} (hF : âˆ€ (x : E), x âˆˆ s â†’ HasFderivWithinAt f (f' x) s x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥f' xâˆ¥ â‰¤ C) (hs : Convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {X Y : C} (p : X = Y) : F.map_iso (CategoryTheory.eqToIso p) = CategoryTheory.eqToIso _
{Î± : Type u} [topologicalSpace Î±] {Î¹ : Type u_1} [CompactSpace Î±] {f : Î¹ â†’ Set Î±} (hF : LocallyFinite f) : {i : Î¹ | (f i).nonempty}.finite
(n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1
(p' : â„•) (h : LucasLehmer.lucasLehmerResidue (p' + 2) = 0) : orderOf (lucas_lehmer.Ï‰_Unit (p' + 2)) = 2 ^ (p' + 2)
{R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [Ring R] [AddCommGroup M] [AddCommGroup Mâ‚‚] [Module R M] [Module R Mâ‚‚] (f : M â‰ƒâ‚—[R] Mâ‚‚) (p : Submodule R M) : FiniteDimensional.finrank R â†¥(Submodule.map â†‘f p) = FiniteDimensional.finrank R â†¥p
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i j : D.to_glue_data.J) (U : TopologicalSpace.Opens â†¥((D.to_glue_data.U i).carrier)) : D.diagram_over_IsOpen_Ï€ U i â‰« D.Î¹_Inv_AppÏ€_Eq_Map U â‰« D.Î¹_Inv_App U â‰« D.diagram_over_IsOpen_Ï€ U j = D.diagram_over_IsOpen_Ï€ U j
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {s : Finset Î±} : s âˆˆ ð’œ.up_shadow â†” âˆƒ (t : Finset Î±) (H : t âˆˆ ð’œ), t âŠ† s âˆ§ t.card + 1 = s.card
{A : Type u_2} [normedRing A] [NormedAlgebra â„‚ A] [CompleteSpace A] [NormOneClass A] (a : A) : Filter.Tendsto (Î» (n : â„•), â†‘âˆ¥a ^ nâˆ¥â‚Š ^ (1 / â†‘n)) Filter.atTop (nhds (spectralRadius â„‚ a))
{Î± : Type u_1} [PartialOrder Î±] [succOrder Î±] {a b : Î±} [NoMaxOrder Î±] : a â‰  b â†’ Order.succ a â‰  Order.succ b
{K : Type u_1} {n : â„•} {s : Seq (GeneralizedContinuedFraction.Pair K)} [divisionRing K] : GeneralizedContinuedFraction.convergents'_aux s (n + 2) = GeneralizedContinuedFraction.convergents'_aux (GeneralizedContinuedFraction.squashSeq s n) (n + 1)
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] (F : J Ã— K â¥¤ Type v) [CategoryTheory.IsFiltered K] [Fintype J] : Function.Injective (CategoryTheory.Limits.colimitLimitToLimitColimit F)
{R : Type v} [CommRing R] {n : â„•} (A : Matrix (Fin n.succ) (Fin n.succ) R) : A.det = finset.univ.sum (Î» (j : Fin n.succ), (-1) ^ â†‘j * A 0 j * (A.minor Fin.succ â‡‘(j.succ_above)).det)
{Î± : Type u_1} [Preorder Î±] [AddCommSemigroup Î±] [HasSub Î±] [HasOrderedSub Î±] {a b : Î±} : b - (b - a) â‰¤ a
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {a : E} (hF : HasStrictFderivAt f f' a) {c : Nnreal} (hc : Subsingleton E âˆ¨ 0 < c) : âˆƒ (s : Set E) (H : s âˆˆ nhds a), ApproximatesLinearOn f f' s c
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Î¹ â†’ M} [Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [Module R M] [Module R M'] (hv : LinearIndependent R v) {f : M â†’â‚—[R] M'} (hF_inj : Disjoint (Submodule.span R (Set.Range v)) f.ker) : LinearIndependent R (â‡‘f âˆ˜ v)
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [CommMonoid Î²] {s : Finset Î³} {t : Finset Î±} {f : Î³ â†’ Î± â†’ Î²} : (s.product t).prod (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = t.prod (Î» (y : Î±), s.prod (Î» (x : Î³), f x y))
{X : Type u} {Î± : Type v} [topologicalSpace X] [LinearOrder Î±] [topologicalSpace Î±] [OrderClosedTopology Î±] [PreconnectedSpace X] (a b : X) {f : X â†’ Î±} (hF : Continuous f) : Set.Icc (f a) (f b) âŠ† Set.Range f
{K : Type u_1} [Field K] [Invertible 2] {a b c : K} (ha : a â‰  0) {s : K} (h : discrim a b c = s * s) (x : K) : a * x * x + b * x + c = 0 â†” x = (-b + s) / (2 * a) âˆ¨ x = (-b - s) / (2 * a)
{Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£ (a : Î±), Subtype_ (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix m n Î±) (B : Matrix n n Î±) [Invertible B] : (A.mul (â…Ÿ B)).mul B = A
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] : IsBoundedLinearMap ð•œ (Î» (p : ContinuousMultilinearMap ð•œ E F Ã— ContinuousMultilinearMap ð•œ E G), p.fst.prod p.snd)
{Î± : Type uâ‚} {X Y : CategoryTheory.Discrete Î±} (i : X âŸ¶ Y) : X.as = Y.as
{R : Type u} {S : Type v} [Ring R] [Ring S] [is_IsDomain S] (f : R â†’+* S) : f.ker.is_Prime
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : CategoryTheory.Presieve X} {x : CategoryTheory.Presieve.FamilyOfElements P R} (t : x.compatible) : CategoryTheory.Presieve.FamilyOfElements.restrict _ x.sieve_extend = x
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] {f : Î² â†’ Î±} [topologicalSpace Î²] (hF : Inducing f) {s : Set Î±} (hs : TopologicalSpace.IsSeparable s) : TopologicalSpace.IsSeparable (f â»Â¹' s)
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {M : Type u_6} [CommSemiring R] [AddCommMonoid M] [Module R M] (b : Basis Î¹ R M) (b' : Basis Î¹' R M) [DecidableEq Î¹] [Fintype Î¹'] : (b.to_Matrix â‡‘b').mul (b'.to_Matrix â‡‘b) = 1
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : MulOneClass M} {mN : MulOneClass N} [monoidHomClass F M N] (f : F) {x : M} (hx : âˆƒ (y : M), x * y = 1) : âˆƒ (y : N), â‡‘f x * y = 1
{Î± : Type u_3} [SemilatticeSup Î±] (a : Î±) : Filter.map Coe Filter.atTop = Filter.atTop
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {X : C} {S T : CategoryTheory.Sieve X} (h : S â‰¤ T) (hT : Jâ‚.is_IsClosed T) : Jâ‚.close S â‰¤ T
{Î± : Type u_1} {Î¹ : Type u_2} {Î¹' : Type u_3} [completeLattice Î±] {s : Set Î¹'} {g : Î¹' â†’ Set Î¹} {f : Î¹ â†’ Î±} (hs : s.pairwise_Disjoint (Î» (i' : Î¹'), â¨† (i : Î¹) (H : i âˆˆ g i'), f i)) (hg : âˆ€ (i : Î¹'), i âˆˆ s â†’ (g i).pairwise_Disjoint f) : (â‹ƒ (i : Î¹') (H : i âˆˆ s), g i).pairwise_Disjoint f
{x y z : Pgame} (hâ‚ : x < y) (hâ‚‚ : y.lf z) : x.lf z
{R : Type u} {K : Type v} {L : Type z} {p : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [isScalarTower R K L] [IsSeparable K L] [is_IsDomain R] [NormalizedGcdMonoid R] [IsFractionRing R K] [IsIntegrallyClosed R] {B : powerBasis K L} (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z) (hz : p â€¢ z âˆˆ Algebra.adjoin R {B.gen}) (hei : (minpoly R B.gen).is_eisenstein_at (Submodule.span R {p})) : z âˆˆ Algebra.adjoin R {B.gen}
{Î± : Type u_1} [Bornology Î±] {p : Î± â†’ Prop} : Bornology.IsBounded {x : Î± | p x} â†’ BoundedSpace (Subtype_ p)
{Mâ‚€ : Type u_1} [MulZeroOneClass Mâ‚€] : 0 â‰  1 âˆ¨ âˆ€ (a : Mâ‚€), a = 0
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) : s.monge_point âˆˆ affineSpan â„ (Set.Range s.points)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e : Î± â†’ Î²} (de : DenseEmbedding e) [TopologicalSpace.SeparableSpace Î±] : TopologicalSpace.SeparableSpace Î²
{R : Type u_1} {E : Type u_2} [linearOrderedField R] [AddCommGroup E] [Module R E] (t : Finset E) {w : E â†’ R} (hwâ‚€ : âˆ€ (i : E), i âˆˆ t â†’ 0 â‰¤ w i) (hws : 0 < t.sum (Î» (i : E), w i)) : t.center_mass w Id âˆˆ â‡‘(convexHull R) â†‘t
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±} (ho : âˆ€ (s : Î²), s âˆˆ S â†’ is_IsOpen (f s)) (hS : S.countable) (hD : âˆ€ (s : Î²), s âˆˆ S â†’ Dense (f s)) : Dense (â‹‚ (s : Î²) (H : s âˆˆ S), f s)
{Î± : Type u} [topologicalSpace Î±] [t2_Space Î±] {s : Set Î±} (hs : is_IsCompact s) : is_IsClosed s
(S : Type u_1) [Ring S] (a : â„•) : â†‘(a.desc_factorial 2) = â†‘a * (â†‘a - 1)
{R : Type u_1} [CommRing R] : Ideal.IsJacobson R â†” âˆ€ (P : Ideal R), P.is_Prime â†’ P.jacobson = P
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {A B C : Matrix n n Î±} (h : A.mul B = 1) (g : C.mul A = 1) : B = C
{F : Type u_3} [innerProductSpace â„ F] {x y : F} : HasInner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆ¥yâˆ¥ â€¢ x = âˆ¥xâˆ¥ â€¢ y
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {C : â„} (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_Continuous C hâˆ¥ â‰¤ Linear_order.max C 0
(a b : â„) (h : a < b) : (polynomialFunctions UnitInterval).comap' (ContinuousMap.compRightAlgHom â„ (icc_homeo_I a b h).symm.to_Continuous_Map) = polynomialFunctions (Set.Icc a b)
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {f : Î± â†’ Î²} (hF : IsAddGroupHom f) {Î³ : Type u_1} [AddGroup Î³] {g : Î² â†’ Î³} (hg : IsAddGroupHom g) : IsAddGroupHom (g âˆ˜ f)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : â‡‘(orthogonalProjection s.direction) (p -áµ¥ â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p)) = 0
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} (hF : TendstoUniformlyOn F f p s) : UniformCauchySeqOn F p s
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [divisionRing K] {gp ppred Pred : GeneralizedContinuedFraction.Pair K} (Succ_nth_s_Eq : g.s.nth (n + 1) = Option.some gp) (nth_conts_Eq : g.continuants n = ppred) (Succ_nth_conts_Eq : g.continuants (n + 1) = Pred) : g.continuants (n + 2) = {a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b}
{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [DecidableRel r] (a : Î±) (l : List Î±) : List.orderedInsert r a l = List.takeWhile (Î» (b : Î±), Â¬r a b) l ++ a :: List.dropWhile (Î» (b : Î±), Â¬r a b) l
{Î± : Type u_1} [CircularPreorder Î±] {a b c d : Î±} (hbc : HasSbtw.Sbtw a b c) (hcd : HasSbtw.Sbtw a c d) : HasSbtw.Sbtw a b d
{C : Type u} [CategoryTheory.Category C] {X : Top} (F : Top.Presheaf C X) : CategoryTheory.Presheaf.IsSheaf (Opens.grothendieckTopology â†¥X) F â†” F.is_sheaf_Opens_LE_cover
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : f =O[l] g' â†’ (f =O[l] Î» (x : Î±), -g' x)
{M : Type u_3} {N : Type u_4} [hasOne M] [hasOne N] (f : OneHom M N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : ringChar F â‰  2) (a : F) : â†‘({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_Char F a + 1
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [is_R_or_C ð•‚] [normedRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] : HasFderivAt (Exp ð•‚) 1 0
(A : Type u) {B : Type v} {Î¹ : Type w} [CommRing A] [CommRing B] [Algebra A B] [Fintype Î¹] [is_IsDomain A] {b : Î¹ â†’ B} (hli : Â¬LinearIndependent A b) : Algebra.discr A b = 0
{Î± : sort u} {Î² : sort v} [DecidableEq Î±] {v : Î± â†’ Î²} {i j : Î±} (hv : v i = v j) (k : Î±) : v (â‡‘(equiv.swap i j) k) = v k
{Î± : Type u_1} [emetricSpace Î±] {K : Nnreal} {f : Î± â†’ Î±} (hF : ContractingWith K f) {s : Set Î±} (hsc : IsComplete s) (hsf : Set.MapsTo f s s) (hfs : ContractingWith K (Set.MapsTo.restrict f s s hsf)) {x : Î±} (hxs : x âˆˆ s) (hx : HasEdist.edist x (f x) â‰  âŠ¤) {t : Set Î±} (htc : IsComplete t) (htf : Set.MapsTo f t t) (hft : ContractingWith K (Set.MapsTo.restrict f t t htf)) {y : Î±} (hyt : y âˆˆ t) (hy : HasEdist.edist y (f y) â‰  âŠ¤) (hxy : HasEdist.edist x y â‰  âŠ¤) : ContractingWith.efixedPoint' f hsc hsf hfs x hxs hx = ContractingWith.efixedPoint' f htc htf hft y hyt hy
(ð•œ : Type u_1) (E : Type u_2) [orderedSemiring ð•œ] [OrderedAddCommGroup E] [Module ð•œ E] [OrderedSmul ð•œ E] : (ConvexCone.positiveCone ð•œ E).pointed
(N i : â„•) : Polynomial.revAtFun N i = â‡‘(Polynomial.revAt N) i
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î²] {f : Î± â†’. Î²} [Î  (x : Î±), Decidable (f x).dom] {s : Finset Î±} : Finset.pimage f s = Finset.image (Î» (x : {x // x âˆˆ Finset.filter (Î» (x : Î±), (f x).dom) s}), (f â†‘x).get _) (Finset.filter (Î» (x : Î±), (f x).dom) s).attach
{n : â„•} {Î± : Type u_1} (l : List Î±) (c : Composition n) : (l.split_wrt_Composition c).length = c.length
{Î± : Type u_1} {Î¹ : Type u_4} [completeLattice Î±] (s : Î¹ â†’ Î±) : (â¨† (i : Î¹), s i) = â¨† (t : Finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
{Î² : Type u} {Î³ : Type w} [NonAssocSemiring Î²] [NonAssocSemiring Î³] (f : Î² â†’+* Î³) (l : List Î²) : â‡‘f l.sum = (List.map â‡‘f l).sum
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [Fintype Î¹] (p : Î¹ â†’ P) : AffineIndependent k p â†” âˆ€ (w : Î¹ â†’ k), finset.univ.sum (Î» (i : Î¹), w i) = 0 â†’ â‡‘(finset.univ.weighted_vsub p) w = 0 â†’ âˆ€ (i : Î¹), w i = 0
{L : FirstOrder.Language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.embedding M N) (g : L.embedding N P) (h : L.embedding P Q) : (h.comp g).comp f = h.comp (g.comp f)
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} {R : Type u_11} [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : Î± â†’ Î²} (hF : Function.Injective f) (r : R) (v : Î² â†’â‚€ M) : Finsupp.comapDomain f (r â€¢ v) _ = r â€¢ Finsupp.comapDomain f v _
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b c : Î±} : a * b < c â†’ b < aâ»Â¹ * c
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {x : E} {n : WithTop â„•} {p : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n f p s) (hn : 1 â‰¤ n) (hx : s âˆˆ nhds x) : HasFderivAt f (â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (p x 1)) x
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : CategoryTheory.Presieve X} (t : CategoryTheory.Presieve.IsSeparatedFor P R) : (âˆ€ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.compatible â†’ (âˆƒ (t : P.obj (Opposite.op X)), x.is_amalgamation t)) â†’ CategoryTheory.Presieve.IsSheafFor P R
{L : FirstOrder.Language} (K : Set (CategoryTheory.Bundled L.Structure)) {M : Type w} [L.Structure M] [L.countable_Functions] (h : FirstOrder.Language.IsFraisseLimit K M) : FirstOrder.Language.IsFraisse K
{Î± : Type u_1} (n : â„•) (x : Î±) : Function.IsPeriodicPt Id n x
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{ð•œ : Type u_1} {E : Type u_2} [SemiNormedRing ð•œ] [HasScalar ð•œ E] {s t : Set E} (ht : Balanced ð•œ t) (h : s âŠ† t) : BalancedHull ð•œ s âŠ† t
{R : Type u} [Ring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {M : Type u_1} [AddCommGroup M] [Module R M] {A : Î¹ â†’ Submodule R M} (hi : CompleteLattice.Independent A) (hs : supr A = âŠ¤) : DirectSum.IsInternal A
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} [topologicalSpace Î±] (h : TendstoLocallyUniformlyOn F f p s) (hc : âˆ€á¶  (n : Î¹) in p, ContinuousOn (F n) s) [p.ne_IsBot] : ContinuousOn f s
(f : â†¥(MeasureTheory.lp â„‚ 2 haarCircle)) (i : â„¤) : â‡‘(â‡‘(fourier_series.repr) f) i = âˆ« (t : â†¥Circle), â†‘t ^ -i * â‡‘f t âˆ‚haarCircle
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R M) (x : Orientation R M Î¹) : x = e.orientation âˆ¨ x = -e.orientation
{Î± : Type u} [pseudoMetricSpace Î±] : UniformContinuous (Î» (p : UniformSpace.Completion Î± Ã— UniformSpace.Completion Î±), HasDist.dist p.fst p.snd)
{X Y : Top} {f g : C(â†¥X, â†¥Y)} (H : f.homotopy g) {xâ‚€ xâ‚ : â†¥X} (p : FundamentalGroupoid.fromTop xâ‚€ âŸ¶ FundamentalGroupoid.fromTop xâ‚) : (fundamental_groupoid.fundamental_groupoid_functor.map f).map p = ContinuousMap.Homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_Map).map (Continuous_map.homotopy.prod_to_Prod_Top_I (ðŸ™ {down := 0}) p) â‰« ContinuousMap.Homotopy.hcast _
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (M N P : Matrix m m R) : (M.mul (N.mul P)).det = (N.mul (M.mul P)).det
{M : Type u_1} [AddCommMonoid M] (S : addSubmonoid M) (m : Multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.sum âˆˆ S
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (v : E) : orthogonalProjectionFn K v âˆˆ K
 : Irrational goldenConj
{R : Type u1} [CommSemiring R] {M : Type u2} [AddCommMonoid M] [Module R M] {C : ExteriorAlgebra R M â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(algebraMap R (ExteriorAlgebra R M)) r)) (h_grade1 : âˆ€ (x : M), C (â‡‘(ExteriorAlgebraÎ¹ R) x)) (h_Mul : âˆ€ (a b : ExteriorAlgebra R M), C a â†’ C b â†’ C (a * b)) (h_Add : âˆ€ (a b : ExteriorAlgebra R M), C a â†’ C b â†’ C (a + b)) (a : ExteriorAlgebra R M) : C a
{Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [orderedAddCommMonoid N] (f : M â†’ N) (p : M â†’ Prop) (h_Mul : âˆ€ (x y : M), p x â†’ p y â†’ f (x + y) â‰¤ f x + f y) (hp_Mul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (g : Î¹ â†’ M) (s : Finset Î¹) (hs_Nonempty : s.nonempty) (hs : âˆ€ (i : Î¹), i âˆˆ s â†’ p (g i)) : f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
{a b : â„•} (hab : a.coprime b) : a.factors.disjoint b.factors
(G : Type u_1) [AddCommGroup G] : Add_monoid.is_torsion_free (G â§¸ addTorsion G)
(Î¹ : Type u_3) : WellFounded LT.lt
{K : Type u} {V Vâ‚ Vâ‚‚ Vâ‚ƒ : Type v} [Field K] [AddCommGroup V] [Module K V] [AddCommGroup Vâ‚] [Module K Vâ‚] [AddCommGroup Vâ‚‚] [Module K Vâ‚‚] [AddCommGroup Vâ‚ƒ] [Module K Vâ‚ƒ] (db : Vâ‚‚ â†’â‚—[K] V) (eb : Vâ‚ƒ â†’â‚—[K] V) (cd : Vâ‚ â†’â‚—[K] Vâ‚‚) (ce : Vâ‚ â†’â‚—[K] Vâ‚ƒ) (hde : âŠ¤ â‰¤ db.range âŠ” eb.range) (hgd : cd.ker = âŠ¥) (Eq : db.comp cd = eb.comp ce) (Eqâ‚‚ : âˆ€ (d : Vâ‚‚) (e : Vâ‚ƒ), â‡‘db d = â‡‘eb e â†’ (âˆƒ (c : Vâ‚), â‡‘cd c = d âˆ§ â‡‘ce c = e)) : Module.rank K V + Module.rank K Vâ‚ = Module.rank K Vâ‚‚ + Module.rank K Vâ‚ƒ
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {s : Set E} (h : is_IsLocalMinOn f s a) {y : E} (hy : y âˆˆ PosTangentConeAt s a) : 0 â‰¤ â‡‘(fderivWithin â„ f s a) y
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {X Y : C} {f g : X âŸ¶ Y} (h : f = g) (x : â†¥X) : â‡‘f x = â‡‘g x
{Î¹ : Type u} (s : Finset Î¹) (w z : Î¹ â†’ Ennreal) (hw' : s.sum (Î» (i : Î¹), w i) = 1) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), w i * z i) ^ p â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ p)
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Vâ‚‚ : Type v'} [AddCommGroup Vâ‚‚] [Module K Vâ‚‚] [FiniteDimensional K V] [FiniteDimensional K Vâ‚‚] : Nonempty (V â‰ƒâ‚—[K] Vâ‚‚) â†” FiniteDimensional.finrank K V = FiniteDimensional.finrank K Vâ‚‚
{a b : â„¤} (ha : a â‰  0) : IsLeast {n : â„• | 0 < n âˆ§ âˆƒ (x y : â„¤), â†‘n = a * x + b * y} (a.gcd b)
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.MulPosStrictMono Î±] (ha : 1 < a) (hb : 1 â‰¤ b) (b0 : 0 < b) : 1 < a * b
(X : Type u) (Y : Type v) [metricSpace X] [CompactSpace X] [Nonempty X] [metricSpace Y] [CompactSpace Y] [Nonempty Y] {f : Cb X Y} (h : f âˆˆ candidates_b X Y) : Metric.hausdorffDist (Set.Range (Gromov_Hausdorff.optimal_GH_injl X Y)) (Set.Range (Gromov_Hausdorff.optimal_GH_injr X Y)) â‰¤ GromovHausdorff.hD f
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [IsRefl Î± r] [IsAntisymm Î± r] {a b : Î±} : AntisymmRel r a b â†’ a = b
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [CompleteSpace E] [CompleteSpace F] (A : E â†’L[ð•œ] F) (B : F â†’L[ð•œ] E) : A = â‡‘ContinuousLinearMap.adjoint B â†” âˆ€ (x : E) (y : F), HasInner.inner (â‡‘A x) y = HasInner.inner x (â‡‘B y)
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {c : â„} {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : asymptotics.is_O_with c l f (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ asymptotics.is_O_with c l f g'
{M : Type u_3} {N : Type u_4} [Monoid M] [Monoid N] (f : M â†’* N) (l : List M) : â‡‘f l.prod = (List.map â‡‘f l).prod
{n : â„•} {a b : Fin n} : â†‘a â‰¤ â†‘b â†” a â‰¤ b
{Î± : Type u_1} [PartialOrder Î±] [OrderBot Î±] {a : Î±} : IsAtom a â†’ âŠ¥ â‹– a
{Î± : Type u_1} [Preorder Î±] [PredOrder Î±] {a b : Î±} [NoMinOrder Î±] : a < b â†’ Order.pred a < Order.pred b
{K : Type u_1} [linearOrderedField K] [floorRing K] {v : K} : (GeneralizedContinuedFraction.of v).h = â†‘âŒŠvâŒ‹
{p : â„•} [Fact (Nat.Prime p)] {f : CauSeq â„š (padicNorm p)} (hF : Â¬f â‰ˆ 0) : âˆƒ (N : â„•), âˆ€ (m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ padicNorm p (â‡‘f n) = padicNorm p (â‡‘f m)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (h_Int : Algebra.IsIntegral K L) : IsTotallyDisconnected Set.Univ
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {K : J â¥¤ C} {c d : CategoryTheory.Limits.Cocone K} (f : c âŸ¶ d) [i : CategoryTheory.IsIso f.hom] : CategoryTheory.IsIso f
{G : Type u} [AddMonoid G] : IsOfFinAddOrder 0
{R : Type u_1} {a b : R} [AddSemigroup R] (lra : IsAddLeftRegular a) (lrb : IsAddLeftRegular b) : IsAddLeftRegular (a + b)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : r â‰  0) : 2 â€¢ hb.oangle (r â€¢ x) y = 2 â€¢ hb.oangle x y
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : Set P} (ho : EuclideanGeometry.OrthocentricSystem s) {t : Affine.Triangle â„ P} (ht : Set.Range t.points âŠ† s) : s = HasInsert.insert t.orthocenter (Set.Range t.points)
{G : Type u_10} {H : Type u_11} [AddGroup G] [subtractionMonoid H] (h : G â‰ƒ+ H) (x y : G) : â‡‘h (x - y) = â‡‘h x - â‡‘h y
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) [Nontrivial n] : A.adjugate.adjugate = A.det ^ (Fintype.card n - 2) â€¢ A
{Î± : Type u_1} [hasMul Î±] [hasLt Î±] [ContravariantClass Î± Î± Mul.mul LT.lt] {a b c : Î±} (bc : a * b < a * c) : b < c
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {n : WithTop â„•} : ContDiff ð•œ n f â†” (âˆ€ (m : â„•), â†‘m â‰¤ n â†’ Continuous (iteratedDeriv m f)) âˆ§ âˆ€ (m : â„•), â†‘m < n â†’ Differentiable ð•œ (iteratedDeriv m f)
{R : Type u} [Semiring R] (r : R) : Polynomial.x * â‡‘Polynomial.c r = â‡‘Polynomial.c r * Polynomial.x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] {Y Z : C} (f : Y âŸ¶ Z) (P : CategoryTheory.projectiveResolution Y) (Q : CategoryTheory.projectiveResolution Z) : CategoryTheory.projectiveResolution.lift f P Q â‰« Q.Ï€ = P.Ï€ â‰« (chain_complex.singleâ‚€ C).map f
{Î± : Type u_1} {r s : Setoid Î±} : r âŠ” s = EqvGen.setoid (r.rel âŠ” s.rel)
{E : Type u_3} {F : Type u_4} [semiNormedGroup E] [semiNormedGroup F] {f : E â†’ F} {C : Nnreal} : LipschitzWith C f â†’ âˆ€ (x y : E), âˆ¥f x - f yâˆ¥ â‰¤ â†‘C * âˆ¥x - yâˆ¥
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {V : Type u_14} [NormedGroup V] [normedSpace ð•œ V] : Smooth ((modelWithCornersSelf ð•œ ð•œ).prod (modelWithCornersSelf ð•œ V)) (modelWithCornersSelf ð•œ V) (Î» (p : ð•œ Ã— V), p.fst â€¢ p.snd)
{p : Ordinal â†’ Prop} (i : Ordinal) (h : âˆ€ (j : Ordinal), (âˆ€ (k : Ordinal), k < j â†’ p k) â†’ p j) : p i
{F : Type u_3} [innerProductSpace â„ F] {x y : F} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * HasInner.inner x y + âˆ¥yâˆ¥ ^ 2
 : Function.Injective Real.sinh
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {A : Type uâ‚ƒ} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (K : CategoryTheory.GrothendieckTopology D) {L : CategoryTheory.GrothendieckTopology A} {F : C â¥¤ D} (hF : CategoryTheory.CoverPreserving J K F) {G : D â¥¤ A} (hG : CategoryTheory.CoverPreserving K L G) : CategoryTheory.CoverPreserving J L (F â‹™ G)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [addCancelCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [HasScalar ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : StrictConvexOn ð•œ s f) (c : E) : StrictConvexOn ð•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a : Î±} : 0 < -a â†” a < 0
{M : Type u_1} [Group M] (c : Con M) {w x : M} : â‡‘c w x â†’ â‡‘c wâ»Â¹ xâ»Â¹
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} (l : List M) : â‡‘CliffordAlgebra.involute (List.map â‡‘(CliffordAlgebraÎ¹ Q) l).prod = (-1) ^ l.length â€¢ (List.map â‡‘(CliffordAlgebraÎ¹ Q) l).prod
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : IsPreirreducible s â†” âˆ€ (zâ‚ zâ‚‚ : Set Î±), is_IsClosed zâ‚ â†’ is_IsClosed zâ‚‚ â†’ s âŠ† zâ‚ âˆª zâ‚‚ â†’ s âŠ† zâ‚ âˆ¨ s âŠ† zâ‚‚
{R : Type u_1} {M : Type u_9} [Semiring R] [AddCommMonoid M] [Module R M] (p : Submodule R M) : Submodule.map p.subtype âŠ¤ = p
(Î± : sort u_1) [s : Setoid Î±] : Function.Surjective Quotient.mk
{M : Type u_1} [AddZeroClass M] {N : Type u_2} [AddZeroClass N] (f : M â†’+ N) (hF : Function.Surjective â‡‘f) : f.mrange = âŠ¤
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} {s : Set â„‚} {c : â„‚} (hc : s âˆˆ nhds c) (hD : DifferentiableOn â„‚ f (s  {c})) (ho : (Î» (z : â„‚), f z - f c) =o[nhdsWithin c {c}á¶œ] Î» (z : â„‚), (z - c)â»Â¹) : DifferentiableOn â„‚ (Function.update f c (lim (nhdsWithin c {c}á¶œ) f)) s
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) (h : Fintype.card n â‰  1) : A.adjugate.adjugate = A.det ^ (Fintype.card n - 2) â€¢ A
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Ring R] [AddCommGroup N] [Module R N] (p : Î¹ â†’ Submodule R N) : CompleteLattice.Independent p â†” Function.Injective â‡‘(â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype))
{P : Type u_1} [Preorder P] [OrderTop P] {F : Order.Pfilter P} : âŠ¤ âˆˆ F
{G : Type u_1} [Group G] {s t : Set G} (ht : IsNormalSubgroup t) (h : s âŠ† t) : group.normal_Closure s âŠ† t
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : E â†’ FormalMultilinearSeries ð•œ E F} {n : â„•} : HasFtaylorSeriesUpTo â†‘(n + 1) f p â†” (âˆ€ (x : E), (p x 0).uncurry0 = f x) âˆ§ (âˆ€ (x : E), HasFderivAt (Î» (y : E), p y 0) (p x 1).curry_Left x) âˆ§ HasFtaylorSeriesUpTo â†‘n (Î» (x : E), â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (p x 1)) (Î» (x : E), (p x).shift)
{Î± : Type u_1} [linearOrderedSemiring Î±] : Subsingleton (floorSemiring Î±)
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M â†’+ P} (H : c â‰¤ AddCon.ker f) (g : c.quotient â†’+ P) (Hg : g.comp c.mk' = f) : g = c.lift f H
{r : Nnreal} (hr : r < 1) : HasSum (Î» (n : â„•), r ^ n) (1 - r)â»Â¹
{Î¹ : Type u_1} {R : Type u_2} [CommSemiring R] [LinearOrder Î¹] (s : Finset Î¹) (f g : Î¹ â†’ R) : s.prod (Î» (i : Î¹), f i + g i) = s.prod (Î» (i : Î¹), f i) + s.sum (Î» (i : Î¹), g i * (Finset.filter (Î» (_x : Î¹), _x < i) s).prod (Î» (j : Î¹), f j + g j) * (Finset.filter (Î» (j : Î¹), i < j) s).prod (Î» (j : Î¹), f j))
{Î± : Type u} [pseudoEmetricSpace Î±] : (âˆ€ (u : â„• â†’ Î±), CauchySeq u â†’ (âˆƒ (a : Î±), Filter.Tendsto u Filter.atTop (nhds a))) â†’ CompleteSpace Î±
{Î± : Type u} [pseudoEmetricSpace Î±] {Î´â‚ Î´â‚‚ : â„} (hle : Î´â‚ â‰¤ Î´â‚‚) (E : Set Î±) : Metric.Thickening Î´â‚ E âŠ† Metric.Thickening Î´â‚‚ E
{n : â„•} (hpos : 0 < n) {p : â„•} [hprime : Fact (Nat.Prime p)] {a : â„•} (hroot : (Polynomial.cyclotomic n (Zmod p)).is_root (â‡‘(Nat.castRingHom (Zmod p)) a)) : a.coprime p
{Î± : Type u_1} {n : Type u_3} {A : Matrix n n Î±} : (âˆ€ (i j : n), A j i = A i j) â†’ A.is_Symm
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {v : â„ â†’ E â†’ E} {s : â„ â†’ Set E} {K : â„} (hv : âˆ€ (t : â„) (x : E), x âˆˆ s t â†’ âˆ€ (y : E), y âˆˆ s t â†’ HasDist.dist (v t x) (v t y) â‰¤ K * HasDist.dist x y) {f g : â„ â†’ E} {a b : â„} (hF : ContinuousOn f (Set.Icc a b)) (hF' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (v t (f t)) (Set.Ici t) t) (hfs : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ f t âˆˆ s t) (hg : ContinuousOn g (Set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt g (v t (g t)) (Set.Ici t) t) (hgs : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ g t âˆˆ s t) (ha : f a = g a) (t : â„) (H : t âˆˆ Set.Icc a b) : f t = g t
{C : Type u} [CategoryTheory.Category C] {Î¹ : Type u_1} {s : Î¹ â†’ C} [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasFiniteBiproducts C] [âˆ€ (i : Î¹), InvariantBasisNumber (CategoryTheory.End (s i))] (o : CategoryTheory.HomOrthogonal s) {Î± Î² : Type v} [Fintype Î±] [Fintype Î²] {f : Î± â†’ Î¹} {g : Î² â†’ Î¹} (i : (â¨ Î» (a : Î±), s (f a)) â‰… â¨ Î» (b : Î²), s (g b)) : âˆƒ (e : Î± â‰ƒ Î²), âˆ€ (a : Î±), g (â‡‘e a) = f a
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {Râ‚ Râ‚‚ : CategoryTheory.Presieve X} (h : Râ‚ â‰¤ Râ‚‚) {x : CategoryTheory.Presieve.FamilyOfElements P Râ‚‚} : x.compatible â†’ (CategoryTheory.Presieve.FamilyOfElements.restrict h x).compatible
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {f : Filter Î±} {g : Filter Î²} {n : Î³ â†’ Î´} {m' : Î±' â†’ Î² â†’ Î´} {n' : Î± â†’ Î±'} (h_Distrib : âˆ€ (a : Î±) (b : Î²), n (m a b) = m' (n' a) b) : Filter.map n (Filter.mapâ‚‚ m f g) = Filter.mapâ‚‚ m' (Filter.map n' f) g
(n : â„•) : (Finset.range n).sum (Î» (i : â„•), i) * 2 = n * (n - 1)
{Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [CommMonoid M] [orderedCommMonoid N] (f : M â†’ N) (h_Mul : âˆ€ (x y : M), f (x * y) â‰¤ f x * f y) {s : Finset Î¹} (hs : s.nonempty) (g : Î¹ â†’ M) : f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
{Î± : Type u} [hasSsubset Î±] [IsTrans Î± HasSsubset.Ssubset] {a b c : Î±} : a âŠ‚ b â†’ b âŠ‚ c â†’ a âŠ‚ c
(p : â„ Ã— â„) (hp : p.fst < 0) : HasStrictFderivAt (Î» (x : â„ Ã— â„), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) â€¢ ContinuousLinearMap.fst â„ â„ â„ + (p.fst ^ p.snd * Real.log p.fst - Real.exp (Real.log p.fst * p.snd) * Real.sin (p.snd * Real.pi) * Real.pi) â€¢ ContinuousLinearMap.snd â„ â„ â„) p
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] : (âˆ€ (f : â„• â†’o Submodule R M), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘f n = â‡‘f m) â†” IsNoetherian R M
{S : Type u_1} [hasMul S] (a : S) : Commute a a
{C : Type uâ‚} [CategoryTheory.Category C] {X Y Z : C} (p : X = Y) (q : Y âŸ¶ Z) : _.mpr q = CategoryTheory.eqToHom p â‰« q
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a : Î±} : -a < 0 â†” 0 < a
{X : Type u_1} [topologicalSpace X] [NoncompactSpace X] : DenseRange Coe
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linearOrderedField ð•œ] [AddCommGroup E] [OrderedAddCommGroup Î²] [Module ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} {t : Finset Î¹} {w : Î¹ â†’ ð•œ} {p : Î¹ â†’ E} (hF : ConvexOn ð•œ s f) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hâ‚ : 0 < t.sum (Î» (i : Î¹), w i)) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : f (t.center_mass w p) â‰¤ t.center_mass w (f âˆ˜ p)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : hb.oangle (â‡‘(hb.conj_lie) x) (â‡‘(hb.conj_lie) y) = -hb.oangle x y
{K : Type u_1} [linearOrderedField K] [floorRing K] {v : K} {n : â„•} {ifp_n : GeneralizedContinuedFraction.IntFractPair K} (Stream_nth_Eq : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n) (nth_fr_NeZero : ifp_n.fr â‰  0) : (GeneralizedContinuedFraction.of v).s.nth n = Option.some {a := 1, b := â†‘((GeneralizedContinuedFraction.IntFractPair.of (ifp_n.fr)â»Â¹).b)}
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle â„ P) {iâ‚ : Fin 3} : t.orthocenter âˆˆ Affine.Simplex.altitude t iâ‚
{Î± : Type u} [Semigroup Î±] [HasDistribNeg Î±] (a b : Î±) : a âˆ£ -b â†” a âˆ£ b
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = Real.pi) : EuclideanGeometry.angle p2 p1 p3 = 0
{E : Type u_2} [AddCommGroup E] [Module â„ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul â„ E] : PathConnectedSpace E
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
{F : Type u_2} [NormedGroup F] [normedSpace â„ F] {x y : F} (hx : x â‰  0) (hy : y â‰  0) : SameRay â„ x y â†” âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y z : M} (hxy : SameRay R x y) (hyz : SameRay R y z) (hy : y = 0 â†’ x = 0 âˆ¨ z = 0) : SameRay R x z
{ð•œ : Type u} [hnorm : nondiscreteNormedField ð•œ] {t : topologicalSpace ð•œ} (hâ‚ : TopologicalAddGroup ð•œ) (hâ‚‚ : HasContinuousSmul ð•œ ð•œ) (hâ‚ƒ : t2_Space ð•œ) : t = UniformSpace.toTopologicalSpace
{Î± : Type u_1} [completeLattice Î±] {p q : Prop} {s : p â†’ q â†’ Î±} : (â¨… (hâ‚ : p) (hâ‚‚ : q), s hâ‚ hâ‚‚) = â¨… (h : p âˆ§ q), s _ _
{Î² : Type u} {Î³ : Type w} [Semiring Î²] [Semiring Î³] (f : Î² â†’+* Î³) (l : List Î²) : â‡‘f l.prod = (List.map â‡‘f l).prod
{M : Type u_1} [AddGroup M] (c : AddCon M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w - y) (x - z)
{R : Type u} [Semiring R] {P : Polynomial R â†’ Prop} (p : Polynomial R) (h0 : 0 < p.degree) (hC : âˆ€ {a : R}, a â‰  0 â†’ P (â‡‘Polynomial.c a * Polynomial.x)) (hX : âˆ€ {p : Polynomial R}, 0 < p.degree â†’ P p â†’ P (p * Polynomial.x)) (HAdd : âˆ€ {p : Polynomial R} {a : R}, 0 < p.degree â†’ P p â†’ P (p + â‡‘Polynomial.c a)) : P p
{Î± : Type u} (s : Seq Î±) {m n : â„•} (m_LE_n : m â‰¤ n) (TerminatedAt_m : s.terminated_at m) : s.terminated_at n
{k n : â„•} (s : Finset â„•) (hs : AddSalemSpencer â†‘s) (hsn : âˆ€ (x : â„•), x âˆˆ s â†’ x < n) (hsk : s.card = k) : k â‰¤ â‡‘rothNumberNat n
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} : StrictAntiOn f s â†’ StrictMonoOn (f âˆ˜ â‡‘OrderDual.ofDual) s
{Î± : Type u_1} {Î² : Type u_2} [Infinite Î±] [Fintype Î²] (f : Î± â†’ Î²) : âˆƒ (y : Î²), Infinite â†¥(f â»Â¹' {y})
{Î± : Type u_3} (f : Filter Î±) [f.is_countably_generated] [f.ne_IsBot] : âˆƒ (x : â„• â†’ Î±), Filter.Tendsto x Filter.atTop f
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] [t2_Space Î±] {s t : Set Î²} {f g : Î² â†’ Î±} (h : Set.EqOn f g s) (hF : ContinuousOn f t) (hg : ContinuousOn g t) (hst : s âŠ† t) (hts : t âŠ† Closure s) : Set.EqOn f g t
{Î± : Type u_1} [HasLe Î±] {a : Î±áµ’áµˆ} : IsMin a â†’ IsMax (â‡‘OrderDual.ofDual a)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {E : Type u_3} [hasNorm E] {F : Type u_4} [hasNorm F] (e : localHomeomorph Î± Î²) {b : Î²} (hb : b âˆˆ e.to_local_equiv.target) {f : Î² â†’ E} {g : Î² â†’ F} : f =o[nhds b] g â†” (f âˆ˜ â‡‘e) =o[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semiNormedGroup E'] [semiNormedGroup F'] {c : â„} {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : asymptotics.is_O_with c l f' g' â†’ asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥)
{Î± : Type v} {S : Type w} (e : Î± â‰ƒ S) : Small Î±
{G : Type w} [topologicalSpace G] [hasInv G] [hasMul G] [HasContinuousMul G] [HasContinuousInv G] (h : G) : Continuous (Î» (g : G), g * h * gâ»Â¹)
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] {a b : Î±} : aâ»Â¹ < bâ»Â¹ â†’ b < a
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [AddCommMonoid Î²] {s : Finset Î³} {t : Finset Î±} {f : Î³ â†’ Î± â†’ Î²} : (s.product t).sum (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = s.sum (Î» (x : Î³), t.sum (Î» (y : Î±), f x y))
{n : â„•} {E : Type u_1} [NormedGroup E] {f g : (Fin n â†’ â„‚) â†’ E} {c : Fin n â†’ â„‚} {R : Fin n â†’ â„} (hF : TorusIntegrable f c R) (hg : TorusIntegrable g c R) : TorusIntegrable (f + g) c R
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] {F : Type v} [NormedGroup F] [normedSpace â„‚ F] {f : E â†’ F} (hF : Differentiable â„‚ f) (hb : Metric.Bounded (Set.Range f)) : âˆƒ (c : F), f = Function.const E c
{F : Type} [CommSemiring F] {q : â„•} {f : Polynomial F} (hF : Polynomial.HasSeparableContraction q f) : hf.degree âˆ£ f.nat_degree
(Î± : Type u) (Î² : Type v) [Group Î±] [mulAction Î± Î²] [Fintype Î±] [Î  (a : Î±), Fintype â†¥(MulAction.FixedBy Î± Î² a)] [Fintype (Quotient (MulAction.orbitRel Î± Î²))] : finset.univ.sum (Î» (a : Î±), Fintype.card â†¥(MulAction.FixedBy Î± Î² a)) = Fintype.card (Quotient (MulAction.orbitRel Î± Î²)) * Fintype.card Î±
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] [Fintype m] [DecidableEq m] (A : Matrix m n Î±) (B : Matrix n m Î±) : (1 + A.mul B).det = (1 + B.mul A).det
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D â¥¤ C} [CategoryTheory.Reflective i] {A : C} {B : D} (f : i.obj ((CategoryTheory.leftAdjoint i).obj A) âŸ¶ i.obj B) : â‡‘((CategoryTheory.unitCompPartialBijectiveAux A B).symm) f = (CategoryTheory.Adjunction.ofRightAdjoint i).unit.app A â‰« f
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [pseudoMetricSpace Î²] {f g : boundedContinuousFunction Î± Î²} [isEmpty Î±] : HasDist.dist f g = 0
(X : AlgebraicGeometry.LocallyRingedSpace (r : â†¥(AlgebraicGeometry.LocallyRingedSpaceÎ“.obj (Opposite.op X))) (f : (AlgebraicGeometry.Spec.structureSheaf â†¥(AlgebraicGeometry.LocallyRingedSpaceÎ“.obj (Opposite.op X))).val.obj (Opposite.op (PrimeSpectrum.basicOpen r)) âŸ¶ X.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (Opposite.op (X.to_Î“_spec_Map_basicOpen r))) : AlgebraicGeometry.StructureSheaf.toOpen â†¥(AlgebraicGeometry.LocallyRingedSpaceÎ“.obj (Opposite.op X)) (PrimeSpectrum.basicOpen r) â‰« f = X.to_toÎ“_spec_Map_basicOpen r â†” f = X.to_Î“_spec_c_App r
{Î± : Type u} [uniformSpace Î±] {f : Filter Î±} {x : Î±} (adhs : âˆ€ (s : Set (Î± Ã— Î±)), s âˆˆ Uniformity Î± â†’ (âˆƒ (t : Set Î±) (H : t âˆˆ f), t Ã—Ë¢ t âŠ† s âˆ§ âˆƒ (y : Î±), (x, y) âˆˆ s âˆ§ y âˆˆ t)) : f â‰¤ nhds x
{Î± : Type u} {Î² : Type v} [pseudoEmetricSpace Î±] [pseudoEmetricSpace Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±} (h : Isometry f) (hg : Function.RightInverse g f) : Isometry g
(p : â„•) [Fact (Nat.Prime p)] (k : Type u_1) [Field k] [IsAlgClosed k] [Char_p k p] (V : Type u_2) [AddCommGroup V] [WittVector.Isocrystal p k V] (h_dim : FiniteDimensional.finrank (FractionRing (WittVector p k)) V = 1) : âˆƒ (m : â„¤), Nonempty (WittVector.IsocrystalEquiv p k (WittVector.StandardOneDimIsocrystal p k m) V)
{Î± : Type u} [AddCommGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] {a b c : Î±} : b â‰¤ c - a â†’ a + b â‰¤ c
(n : â„•) : finset.univ.sum (Î» (i : Affine.Simplex.PointsWithCircumcenterIndex (n + 2)), Affine.Simplex.mongePointWeightsWithCircumcenter n i) = 1
{Î± : Type u_1} {Î² : Type u_2} [Monoid Î²] {s : Finset Î±} (f g : Î± â†’ Î²) (comm_ff : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ Commute (f x) (f y)) (comm_gg : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ Commute (g x) (g y)) (comm_gf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰  y â†’ Commute (g x) (f y)) : s.noncomm_Prod (f * g) _ = s.noncomm_Prod f comm_ff * s.noncomm_Prod g comm_gg
{R : Type u_1} {M : Type u_2} [CommMonoid M] [CommRing R] [Nontrivial R] : Algebra.FiniteType R (MonoidAlgebra R M) â†” monoid.fg M
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {ca cb : E} {la lb : Filter â„} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f la MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f lb MeasureTheory.MeasureSpace.volume) {s t : Set â„} [Interval_integral.FTC_Filter a (nhdsWithin a s) la] [Interval_integral.FTC_Filter b (nhdsWithin b t) lb] (ha : Filter.Tendsto f (la âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb : Filter.Tendsto f (lb âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds cb)) (hs : UniqueDiffWithinAt â„ s a . "UniqueDiffWithinAt_ici_Iic_Univ") (ht : UniqueDiffWithinAt â„ t b . "UniqueDiffWithinAt_ici_Iic_Univ") : fderivWithin â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (s Ã—Ë¢ t) (a, b) = (ContinuousLinearMap.snd â„ â„ â„).smul_Right cb - (ContinuousLinearMap.fst â„ â„ â„).smul_Right ca
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (h : 0 < r * (b - a)) : â‡‘(AffineMap.lineMap (f a) (f b)) r < f (â‡‘(AffineMap.lineMap a b) r) â†” slope f a b < slope f a (â‡‘(AffineMap.lineMap a b) r)
{Î± : Type u_1} [DecidableEq Î±] {s : Finset Î±} {a b : Î±} (hs : b âˆˆ s) (hsa : b âˆ‰ s.erase a) : b = a
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_4} [Fintype Î¹] [DecidableEq Î¹] (b : Basis Î¹ R M) : LinearMap.trace R M = (contractLeft R M).comp (dualTensorHomEquivOfBasis b).symm.to_Linear_Map
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {s : Set E} {x : E} : mfderivWithin (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f s x = fderivWithin ð•œ f s x
{Î± : Type u_1} {s : Finset Î±} : s.nonempty â†’ 0 < s.card
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {f : Filter Î±} {g : Filter Î²} {n : Î³ â†’ Î´} {m' : Î²' â†’ Î± â†’ Î´} {n' : Î² â†’ Î²'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), n (m a b) = m' (n' b) a) : Filter.map n (Filter.mapâ‚‚ m f g) = Filter.mapâ‚‚ m' (Filter.map n' g) f
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : â„ â†’ E} {f' : E} {x r : â„} (hF : HasDerivWithinAt f f' (Set.Ici x) x) (hr : âˆ¥f'âˆ¥ < r) : âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), âˆ¥z - xâˆ¥â»Â¹ * âˆ¥f z - f xâˆ¥ < r
(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A] [Nontrivial R] {x : A} : IsIntegral R x â†’ IsAlgebraic R x
{X Y : Profinite} (f : X âŸ¶ Y) (bij : Function.bijective â‡‘f) : CategoryTheory.IsIso f
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x : E) (S : Submodule ð•œ E) [CompleteSpace E] [CompleteSpace â†¥S] : âˆ¥xâˆ¥ ^ 2 = âˆ¥â‡‘(orthogonalProjection S) xâˆ¥ ^ 2 + âˆ¥â‡‘(orthogonalProjection Sá—®) xâˆ¥ ^ 2
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b c : Î±} : a â‰¤ c - b â†’ a + b â‰¤ c
{p : â„•} (hp : 1 < p) : padicValInt p â†‘p = 1
(n : â„¤) : â‡‘ZmodÏ‡â‚ˆ' â†‘n = Ite (n % 2 = 0) 0 (Ite (n % 8 = 1 âˆ¨ n % 8 = 3) 1 (-1))
{X : Type u_1} [topologicalSpace X] [NormalSpace X] {s t : Set X} (hs : is_IsClosed s) (ht : is_IsClosed t) (hD : Disjoint s t) {a b : â„} (hle : a â‰¤ b) : âˆƒ (f : boundedContinuousFunction X â„), Set.EqOn â‡‘f (Function.const X a) s âˆ§ Set.EqOn â‡‘f (Function.const X b) t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ Set.Icc a b
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {a b : Î±} (h : a â‰  b) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ {a, b}), f i)) = f a + f b
{Î± : Type u_1} {Î¹ : Type u_2} {Î² : Type u_3} {S : Î¹ â†’ Set Î±} {f : Î  (i : Î¹), â†¥(S i) â†’ Î²} {hF : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), f i âŸ¨x, hxiâŸ© = f j âŸ¨x, hxjâŸ©} {T : Set Î±} (hT' : T = Set.Union S) (Dir : Directed LE.le S) (Op : â†¥T â†’ â†¥T â†’ â†¥T) (opi : Î  (i : Î¹), â†¥(S i) â†’ â†¥(S i) â†’ â†¥(S i)) (hopi : âˆ€ (i : Î¹) (x y : â†¥(S i)), Set.inclusion _ (opi i x y) = Op (Set.inclusion _ x) (Set.inclusion _ y)) (OpÎ² : Î² â†’ Î² â†’ Î²) (h : âˆ€ (i : Î¹) (x y : â†¥(S i)), f i (opi i x y) = OpÎ² (f i x) (f i y)) (x y : â†¥T) : Set.unionLift S f hF T _ (Op x y) = OpÎ² (Set.unionLift S f hF T _ x) (Set.unionLift S f hF T _ y)
(G : Type u_1) [Monoid G] : Â¬monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ IsOfFinOrder g
{Î± : Type u} [topologicalSpace Î±] (s : Set Î±) : Frontier sá¶œ = Frontier s
(n : â„•) (n_big : 4 â‰¤ n) : 4 ^ n < n * n.central_binom
{Î± : Type u_1} {Î² : Type u_2} {f g : Î± â†’. Î²} (H1 : âˆ€ (a : Î±), a âˆˆ f.dom â†” a âˆˆ g.dom) (H2 : âˆ€ (a : Î±) (p : f.dom a) (q : g.dom a), f.fn a p = g.fn a q) : f = g
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_3} (s : Finset Î¹) (f : Î¹ â†’ E) (x : E) : HasInner.inner x (s.sum (Î» (i : Î¹), f i)) = s.sum (Î» (i : Î¹), HasInner.inner x (f i))
{P : Type u â†’ Prop} (ofEquiv : âˆ€ {Î± Î² : Type u}, Î± â‰ƒ Î² â†’ P Î± â†’ P Î²) (h_Empty : P PEmpty) (h_Option : âˆ€ {Î± : Type u} [_inst_1 : Fintype Î±], P Î± â†’ P (Option Î±)) (Î± : Type u) [Fintype Î±] : P Î±
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace F] (p : FormalMultilinearSeries ð•œ E F) (h : 0 < p.radius) : HasFpowerSeriesOnBall p.sum p 0 p.radius
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteCoproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.NormalEpiCategory C] [CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X âŸ¶ Y) (hF : âˆ€ (Z : C) (g : Z âŸ¶ X), g â‰« f = 0 â†’ g = 0) : CategoryTheory.Mono f
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) (init : Fin E.order â†’ Î±) : E.is_solution (E.mk_sol init)
{Î¹ : Type u} {Î± : Type v} [Fintype Î¹] {t : Î¹ â†’ Finset Î±} [DecidableEq Î±] {n : â„•} (hn : Fintype.card Î¹ = n + 1) (ht : âˆ€ (s : Finset Î¹), s.card â‰¤ (s.bUnion t).card) (ih : âˆ€ {Î¹' : Type u} [_inst_3 : Fintype Î¹'] (t' : Î¹' â†’ Finset Î±), Fintype.card Î¹' â‰¤ n â†’ (âˆ€ (s' : Finset Î¹'), s'.card â‰¤ (s'.bUnion t').card) â†’ (âˆƒ (f : Î¹' â†’ Î±), Function.Injective f âˆ§ âˆ€ (x : Î¹'), f x âˆˆ t' x)) (ha : âˆ€ (s : Finset Î¹), s.nonempty â†’ s â‰  Finset.univ â†’ s.card < (s.bUnion t).card) : âˆƒ (f : Î¹ â†’ Î±), Function.Injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {x : E} {n : â„•} : ContDiffWithinAt ð•œ â†‘(n + 1) f s x â†” âˆƒ (u : Set E) (H : u âˆˆ nhdsWithin x (HasInsert.insert x s)) (f' : E â†’ (E â†’L[ð•œ] F)), (âˆ€ (x : E), x âˆˆ u â†’ HasFderivWithinAt f (f' x) u x) âˆ§ ContDiffWithinAt ð•œ â†‘n f' u x
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (t : CategoryTheory.Limits.IsInitial X) (f : Y âŸ¶ X) : CategoryTheory.Epi f
{Î¹ : Type w} {R : Type u} [Ring R] [Nontrivial R] {M : Type v} [AddCommGroup M] [Module R M] {v : Î¹ â†’ M} (i : LinearIndependent R v) : i.maximal â†” âˆ€ (Îº : Type v) (w : Îº â†’ M), LinearIndependent R w â†’ âˆ€ (j : Î¹ â†’ Îº), w âˆ˜ j = v â†’ Function.Surjective j
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : (f =O[l] Î» (x : Î±), -g' x) â†’ f =O[l] g'
{Î± : Type u_1} [Preorder Î±] [Nonempty Î±] [NoMaxOrder Î±] : Infinite Î±
{Î± : Type u_2} {m : Type u_4} {n : Type u_5} {R : Type u_8} [topologicalSpace R] [topologicalSpace Î±] {f : Î± â†’ Matrix m n R} (h : âˆ€ (i : m) (j : n), Continuous (Î» (a : Î±), f a i j)) : Continuous f
{Î± : Type u} [NonUnitalNonAssocRing Î±] (a b c : Î±) : a * (b - c) = a * b - a * c
{Î± : Type u_1} [Preorder Î±] [locallyFiniteOrder Î±] {a b : Î±} : Â¬a < b â†’ Multiset.ioc a b = 0
{Î¹ : Type u} (s : Finset Î¹) (f : Î¹ â†’ Nnreal) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), f i) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), f i ^ p)
{Î± : Type u_1} [pseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±} (huâ‚‚ : âˆ€ (n : â„•), HasDist.dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) {a : Î±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) (n : â„•) : HasDist.dist (f n) a â‰¤ C / 2 ^ n
{Î² : Type u_1} [conditionallyCompleteLattice Î²] {s : Set (WithTop Î²)} (hs : s.nonempty) : is_is_IsLub s (HasSup.sup s)
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {g : Î² â†’ Î±} (hg : Function.Injective g) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ Set.Range g), f i)) = finsum (Î» (j : Î²), f (g j))
{M : Type u_1} [Monoid M] : IsSubmonoid Set.Univ
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {x : E} {s : Set E} (h : HasFderivWithinAt f f' s x) {Î± : Type u_4} (l : Filter Î±) {c : Î± â†’ ð•œ} {d : Î± â†’ E} {v : E} (dtop : âˆ€á¶  (n : Î±) in l, x + d n âˆˆ s) (clim : Filter.Tendsto (Î» (n : Î±), âˆ¥c nâˆ¥) l Filter.atTop) (cdlim : Filter.Tendsto (Î» (n : Î±), c n â€¢ d n) l (nhds v)) : Filter.Tendsto (Î» (n : Î±), c n â€¢ (f (x + d n) - f x)) l (nhds (â‡‘f' v))
{p : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero â†‘â†‘p] {k : â„•} [hpri : Fact (Nat.Prime â†‘p)] [IsCyclotomicExtension {p ^ (k + 1)} K L] (hirr : Irreducible (Polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) {s : â„•} (hs : s â‰¤ k) (htwo : p ^ (k - s + 1) â‰  2) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta (p ^ (k + 1)) K L ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
{q : â„š} {n : â„•} {ifp_n ifp_Succ_n : GeneralizedContinuedFraction.IntFractPair â„š} (Stream_nth_Eq : GeneralizedContinuedFraction.IntFractPair.stream q n = Option.some ifp_n) (Stream_Succ_nth_Eq : GeneralizedContinuedFraction.IntFractPair.stream q (n + 1) = Option.some ifp_Succ_n) : ifp_Succ_n.fr.num < ifp_n.fr.num
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (H : AddSubgroup G) {f : N â†’+ G} (hF : Function.Surjective â‡‘f) : AddSubgroup.comap f H.normalizer = (AddSubgroup.comap f H).normalizer
{Î± : Type u_1} {a b c : Î±} [LinearOrder Î±] [AddCommSemigroup Î±] [HasSub Î±] [HasOrderedSub Î±] : a < b - c â†” c + a < b
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {s : Set E} (h : is_IsLocalMaxOn f s a) {y : E} (hy : y âˆˆ PosTangentConeAt s a) : â‡‘(fderivWithin â„ f s a) y â‰¤ 0
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S T : Set E) : â†‘(IntermediateField.adjoin â†¥(IntermediateField.adjoin F S) T) = â†‘(IntermediateField.adjoin â†¥(IntermediateField.adjoin F T) S)
{Î± : Type u_1} {Î¹ : sort u_4} [completeLattice Î±] (f : Î¹ â†’ Î±) : (â¨† (i : {i // f i â‰  âŠ¥}), f â†‘i) = â¨† (i : Î¹), f i
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] {f : â„ â†’ E} {T : â„} (hF : Function.Periodic f T) (t s : â„) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable f MeasureTheory.MeasureSpace.volume tâ‚ tâ‚‚) : âˆ« (x : â„) in t..s + T, f x = (âˆ« (x : â„) in t..s, f x) + âˆ« (x : â„) in t..t + T, f x
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R â†’+* S} {p : Polynomial S} (r : R) (hp : p âˆˆ Polynomial.lifts f) : â‡‘Polynomial.c (â‡‘f r) * p âˆˆ Polynomial.lifts f
{Î± : Type u_1} {s : Set Î±} : Set.Range Subtype.val = s
{A : Type u_1} [normedRing A] [NormedAlgebra â„‚ A] [CompleteSpace A] [Nontrivial A] (a : A) : (Spectrum â„‚ a).nonempty
{Î± : Type u_1} {Î² : Type u_2} {e : LocalEquiv Î± Î²} {s : Set Î±} {t : Set Î²} : e.is_image s t â†’ e.target âˆ© â‡‘(e.symm) â»Â¹' s = e.target âˆ© t
{R : Type u_1} [Semiring R] (n : â„•) (a : R) [Decidable (a = 0)] : (â‡‘(PowerSeries.monomial R n) a).order = Ite (a = 0) âŠ¤ â†‘n
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {n : â„•} (ht : t.nonempty) (hn : s.card â‰¤ t.card * n) : âˆƒ (y : Î²) (H : y âˆˆ t), (Finset.filter (Î» (x : Î±), f x = y) s).card â‰¤ n
{Î± : Type u} [Preorder Î±] {a b c : Î±} : a < b â†’ b â‰¤ c â†’ a < c
{t : Set Gromov_Hausdorff.GH_Space} {C : â„} {u : â„• â†’ â„} {K : â„• â†’ â„•} (ulim : Filter.Tendsto u Filter.atTop (nhds 0)) (hdiam : âˆ€ (p : Gromov_Hausdorff.GH_Space), p âˆˆ t â†’ Metric.diam Set.Univ â‰¤ C) (hcov : âˆ€ (p : Gromov_Hausdorff.GH_Space), p âˆˆ t â†’ âˆ€ (n : â„•), âˆƒ (s : Set p.rep), Cardinal.mk â†¥s â‰¤ â†‘(K n) âˆ§ Set.Univ âŠ† â‹ƒ (x : p.rep) (H : x âˆˆ s), Metric.Ball x (u n)) : TotallyBounded t
{Î± : Type u_1} {m : measurableSpace Î±} (Î½ : MeasureTheory.Measure Î±) [MeasureTheory.SigmaFinite Î½] {s : Set Î±} (hs : MeasurableSet s) : (Î½.restrict s).rn_deriv Î½ =áµ[Î½] s.indicator 1
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.Limits.HasColimitsOfSize D] [CategoryTheory.CreatesColimitsOfSize F] : CategoryTheory.Limits.HasColimitsOfSize C
{E : Type u_2} [semiNormedGroup E] [normedSpace â„ E] {s t : Set E} {x y : E} (hx : x âˆˆ â‡‘(convexHull â„) s) (hy : y âˆˆ â‡‘(convexHull â„) t) : âˆƒ (x' : E) (H : x' âˆˆ s) (y' : E) (H : y' âˆˆ t), HasDist.dist x y â‰¤ HasDist.dist x' y'
{Î± : Type u_1} [linearOrderedField Î±] [Archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : y < 1) : âˆƒ (n : â„•), y ^ n < x
{Î± : Type u} [Preorder Î±] {s t : Set Î±} (h : BddBelow s) : BddBelow (s âˆ© t)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} {u v : E} (hu : u âˆˆ K) (hv : v âˆˆ Ká—®) : HasInner.inner u v = 0
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) {r : â„} : 2 â€¢ o.oangle x (r â€¢ x) = 0
(p' : â„•) : 2 < LucasLehmer.q (p' + 2)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type uâ‚} [CategoryTheory.Category D] {L : D â¥¤ C} {R : C â¥¤ D} (h : L âŠ£ R) : CategoryTheory.IsFiltered D
{Î± : Type u} {Î² : Type v} [pseudoEmetricSpace Î±] [pseudoEmetricSpace Î²] {f : Î± â†’ Î²} [Subsingleton Î±] : Isometry f
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] (a : Î±) [NoMaxOrder Î±] : Closure (Set.Ioi a) = Set.Ici a
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (P : Cáµ’áµ– â¥¤ A) {X : C} (R : CategoryTheory.Presieve X) : Nonempty (CategoryTheory.Limits.IsLimit (P.map_cone (CategoryTheory.Sieve.generate R).arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), CategoryTheory.Presieve.IsSheafFor (P â‹™ Category_theory.coyoneda.obj E) R
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : Real.sin (InnerProductGeometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = Real.sqrt (HasInner.inner x x * HasInner.inner y y - HasInner.inner x y * HasInner.inner x y)
{n : â„•} (hpos : 0 < n) : Irreducible (Polynomial.cyclotomic n â„¤)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [NormedGroup E] [NormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (f : E â†’sl[Ïƒâ‚â‚‚] F) [RingHomIsometric Ïƒâ‚â‚‚] : âˆ¥fâˆ¥ = 0 â†” f = 0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} : Mdifferentiable (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f â†” Differentiable ð•œ f
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [NormedGroup G] [normedSpace ð•œ G] (q : FormalMultilinearSeries ð•œ F G) (p : FormalMultilinearSeries ð•œ E F) (r : Nnreal) (hr : Summable (Î» (i : Î£ (n : â„•), Composition n), âˆ¥q.comp_along_Composition p i.sndâˆ¥â‚Š * r ^ i.fst)) : â†‘r â‰¤ (q.comp p).radius
{Î± : Type u_1} {Î¹ : Type u_4} [LinearOrder Î±] [DecidableEq Î¹] (f : Î¹ â†’ Î±) {p : Finset Î¹ â†’ Prop} (s : Finset Î¹) (h0 : p âˆ…) (step : âˆ€ (a : Î¹) (s : Finset Î¹), a âˆ‰ s â†’ (âˆ€ (x : Î¹), x âˆˆ s â†’ f x â‰¤ f a) â†’ p s â†’ p (HasInsert.insert a s)) : p s
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hst : Disjoint s t) (hs : (s âˆ© Function.MulSupport f).finite) (ht : (t âˆ© Function.MulSupport f).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [linearOrderedAddCommGroup Î±] [Archimedean Î±] (h : Function.Periodic f c) (hc : 0 < c) (x : Î±) : âˆƒ (y : Î±) (H : y âˆˆ Set.Ico 0 c), f x = f y
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [orderedSemiring ð•œ] [AddCommGroup E] [Module ð•œ E] {p : Î¹ â†’ E} (hc : ConvexIndependent ð•œ p) (s : Set Î¹) : ConvexIndependent ð•œ (Î» (i : â†¥s), p â†‘i)
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (h : InnerProductGeometry.angle x y = 0) : HasInner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{ð•œ : Type u_1} [linearOrderedField ð•œ] [topologicalSpace ð•œ] [OrderTopology ð•œ] [Archimedean ð•œ] : DenseRange Coe
{R : Type u_1} [linearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {x y : M} (h : SameRay R x y) (hy : y â‰  0) : âˆƒ (r : R), 0 â‰¤ r âˆ§ x = r â€¢ y
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} : Metric.hausdorffDist (Closure s) t = Metric.hausdorffDist s t
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 p2 : P) : HasDist.dist p1 (midpoint â„ p1 p2) = HasDist.dist p2 (midpoint â„ p1 p2)
{Î“â‚€ : Type u_3} [linearOrderedCommMonoidWithZero Î“â‚€] [Nontrivial Î“â‚€] {K : Type u_1} [divisionRing K] (v : Valuation K Î“â‚€) {x : K} : â‡‘v x = 0 â†” x = 0
{R : Type u_1} [orderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] [NoZeroSmulDivisors R M] (x : Module.Ray R M) : x â‰  -x
(a : Zmod8) : â‡‘ZmodÏ‡â‚ˆ' a = 0 âˆ¨ â‡‘ZmodÏ‡â‚ˆ' a = 1 âˆ¨ â‡‘ZmodÏ‡â‚ˆ' a = -1
{Î± : Type u_2} {Î² : Type u_3} [linearOrderedField Î±] [linearOrderedField Î²] [Archimedean Î²] : Subsingleton (Î± â‰ƒ+*o Î²)
{Î± : Type u} (L : List Î±) {i j : â„•} (h : j < (List.drop i L).length) : (List.drop i L).nth_LE j h = L.nth_LE (i + j) _
{Î± : Type u_1} [LinearOrder Î±] (a : Î±) : {a}.min' _ = a
{x : â„} (n : â„•) (m : â„¤) (hxr : x ^ n = â†‘m) (hv : Â¬âˆƒ (y : â„¤), x = â†‘y) (hnpos : 0 < n) : Irrational x
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (i0 : Î¹) : vectorSpan k (Set.Range p) = Submodule.span k (Set.Range (Î» (i : Î¹), p i0 -áµ¥ p i))
{X Y : Type u} (f : X âŸ¶ Y) : CategoryTheory.IsIso f â†” Function.bijective f
{X : Type u_1} {Y : Type u_2} [NormedGroup X] [NormedGroup Y] [normedSpace â„ X] [normedSpace â„ Y] {f : X â†’ Y} {x : X} : ConformalAt f x â†” IsConformalMap (fderiv â„ f x)
(f : â„ â†’ â„) {a b : â„} (hab : a < b) (g : â„ â†’ â„) {lfa lga lfb lgb : â„} (hdf : DifferentiableOn â„ f (Set.Ioo a b)) (hdg : DifferentiableOn â„ g (Set.Ioo a b)) (hfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds lfa)) (hga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds lga)) (hfb : Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds lfb)) (hgb : Filter.Tendsto g (nhdsWithin b (Set.Iio b)) (nhds lgb)) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), (lgb - lga) * deriv f c = (lfb - lfa) * deriv g c
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] {p : Î¹ â†’ E} : ConvexIndependent ð•œ p â†” âˆ€ (s : Finset Î¹) (x : Î¹), p x âˆˆ â‡‘(convexHull ð•œ) â†‘(Finset.image p s) â†’ x âˆˆ s
 : Filter.Tendsto Coe Filter.cofinite (Filter.cocompact â„)
{Î· : Type u_5} {f : Î· â†’ Type u_6} [Î  (i : Î·), AddGroup (f i)] [DecidableEq Î·] [Fintype Î·] {H : Î  (i : Î·), AddSubgroup (f i)} {J : AddSubgroup (Î  (i : Î·), f i)} : AddSubgroup.pi Set.Univ H â‰¤ J â†” âˆ€ (i : Î·), AddSubgroup.map (AddMonoidHom.single f i) (H i) â‰¤ J
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [normedSpace ð•œ E'] {n : WithTop â„•} {f : E â†’ E'} : ContDiff ð•œ n f â†’ ContMdiff (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') n f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {s : Set ð•œ} {n : WithTop â„•} {m : â„•} (h : ContDiffOn ð•œ n f s) (hmn : â†‘m â‰¤ n) (hs : UniqueDiffOn ð•œ s) : ContinuousOn (iteratedDerivWithin m f s) s
{Î³ : Type w} [emetricSpace Î³] {s : Set Î³} (hs : is_IsCompact s) : âˆƒ (t : Set Î³) (H : t âŠ† s), t.countable âˆ§ s = Closure t
{M : Type u_1} [MulOneClass M] {S T : Submonoid M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Nontrivial R] [Nonempty Î¹] (e : Basis Î¹ R M) (x : Orientation R M Î¹) (i : Î¹) : â‡‘(e.adjust_to_Orientation x) i = â‡‘e i âˆ¨ â‡‘(e.adjust_to_Orientation x) i = -â‡‘e i
{M : Type u_3} [AddMonoid M] [Preorder M] (L : List M) (h : L.sum < 0) : 0 < L.length
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) (h : â†‘(S.topological_Closure) = Set.Univ) : âˆ¥S.normed_Mkâˆ¥ = 0
{C : Type u} [CategoryTheory.Category C] {X Y : C} (f : X âŸ¶ Y) (t : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.PullbackCone.mk (ðŸ™ X) (ðŸ™ X) rfl)) : CategoryTheory.Mono f
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [Nonempty Î²] [SemilatticeSup Î²] {s : Î² â†’ Î±} (b : Î² â†’ â„) (h : âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ HasDist.dist (s n) (s m) â‰¤ b N) (hâ‚€ : Filter.Tendsto b Filter.atTop (nhds 0)) : CauchySeq s
{x : â„} (hx : 0 â‰¤ x) (y z : â„) : x ^ y * x ^ z â‰¤ x ^ (y + z)
{Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [orderedAddCommMonoid N] (f : M â†’ N) (h_Mul : âˆ€ (x y : M), f (x + y) â‰¤ f x + f y) {s : Finset Î¹} (hs : s.nonempty) (g : Î¹ â†’ M) : f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
(n : â„•) : (n + 2).factors = (n + 2).min_fac :: ((n + 2) / (n + 2).min_fac).factors
{Î± : Type u} [Preorder Î±] {s : Set Î±} {a : Î±} (h : IsGreatest s a) : BddAbove s
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {n : â„•} (hn : Fintype.card Î² * n < Fintype.card Î±) : âˆƒ (y : Î²), n < (Finset.filter (Î» (x : Î±), f x = y) Finset.univ).card
{n m : â„•} (e : Fin n â‰ƒo Fin m) (i : Fin n) : â†‘(â‡‘e i) = â†‘i
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{Î± : Type u_1} {Î¹ : sort u_2} (m : Î¹ â†’ MeasureTheory.OuterMeasure Î±) {s : Set Î±} (hs : s.nonempty) : (â‡‘â¨… (i : Î¹), m i) s = â¨… (t : â„• â†’ Set Î±) (h2 : s âŠ† Set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹), â‡‘(m i) (t n)
{M : Type u_1} [AddMonoid M] : IsAddSubmonoid Set.Univ
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : Set P} (h : s.finite) : FiniteDimensional k â†¥((affineSpan k s).direction)
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} (hF : Function.Injective f) : Function.Injective (Option.map f)
(s : â„) : Filter.Tendsto (Î» (x : â„), Real.exp x / x ^ s) Filter.atTop Filter.atTop
{G : Type u_2} [Group G] : MulAction.FixedPoints (ConjAct G) G = â†‘(Subgroup.center G)
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s t : Set Î±} (hs : BddAbove s) (sne : s.nonempty) (ht : BddAbove t) (tne : t.nonempty) : HasSup.sup (s âˆª t) = HasSup.sup s âŠ” HasSup.sup t
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : EuclideanGeometry.orthogonalProjectionFn s p -áµ¥ p âˆˆ (s.direction)á—®
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] {s : Finset Î±} (f : Î± â†’ Î²) : MulOpposite.op (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), MulOpposite.op (f x))
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} (h : ContinuousWithinAt f s x) : Filter.Tendsto f (nhdsWithin x s) (nhds (f x))
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [DecidableEq Î³] (s : Finset Î±) (t : Finset Î²) (f : Î± Ã— Î² â†’ Finset Î³) : (s.product t).bUnion f = s.bUnion (Î» (a : Î±), t.bUnion (Î» (b : Î²), f (a, b)))
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} : StrictMono f â†’ StrictAnti (â‡‘OrderDual.toDual âˆ˜ f)
{Î± : Type u} [Preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a = b â†’ a â‰¤ c
{Î± : Type u} {Î² : Type v} [AddCommMonoid Î²] (s : Finset Î±) (f : Finset Î± â†’ Î²) : s.powerset.sum (Î» (t : Finset Î±), f t) = (Finset.range (s.card + 1)).sum (Î» (j : â„•), (Finset.powersetLen j s).sum (Î» (t : Finset Î±), f t))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] [CompleteSpace ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [FiniteDimensional ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {a : E} (hF : HasStrictFderivAt f f' a) (hF' : f'.range = âŠ¤) {Î± : Type u_4} {l : Filter Î±} {gâ‚ : Î± â†’ F} {gâ‚‚ : Î± â†’ â†¥(f'.ker)} (hâ‚ : Filter.Tendsto gâ‚ l (nhds (f a))) (hâ‚‚ : Filter.Tendsto gâ‚‚ l (nhds 0)) : Filter.Tendsto (Î» (t : Î±), HasStrictFderivAt.implicitFunction f f' hF hF' (gâ‚ t) (gâ‚‚ t)) l (nhds a)
{Î± : Type u_3} {Î² : Type u_4} [Nonempty Î±] [SemilatticeSup Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Monotone f) : Filter.Tendsto f Filter.atTop Filter.atTop â†” âˆ€ (b : Î²), âˆƒ (a : Î±), b â‰¤ f a
{R : Type uâ‚} [linearOrderedRing R] {a : R} (H : -2 â‰¤ a) (n : â„•) : 1 + â†‘n * a â‰¤ (1 + a) ^ n
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†’ a â‰¤ 1
{Î± : Type u_1} {M : Type u_4} [hasZero M] {s : Set Î±} {f : Î± â†’ M} {a : Î±} (h : s.indicator f a â‰  0) : a âˆˆ s
{R : Type u_1} [commMonoidWithZero R] (f : Nat.ArithmeticFunction R) (hF : f.is_Multiplicative) (g : Nat.ArithmeticFunction R) (hg : g.is_Multiplicative) : f = g â†” âˆ€ (p i : â„•), Nat.Prime p â†’ â‡‘f (p ^ i) = â‡‘g (p ^ i)
{Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [Î  (i : Î¹), AddZeroClass (Î² i)] [AddCommMonoid Î³] (f : Î  (i : Î¹), Î² i â†’+ Î³) (i : Î¹) : (â‡‘Dfinsupp.liftAddHom f).comp (Dfinsupp.singleAddHom Î² i) = f i
{Î± : Type u_1} {R : Type u_2} {l : Filter Î±} {f : Î± â†’ R} {r : R} [linearOrderedRing R] [Archimedean R] (hr : r < 0) (hF : Filter.Tendsto f l Filter.atBot) : Filter.Tendsto (Î» (x : Î±), f x * r) l Filter.atTop
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [Field K] (nth_Part_denom_NeZero : âˆ€ {b : K}, g.partial_denominators.nth n = Option.some b â†’ b â‰  0) : g.convergents (n + 1) = (g.squash_gcf n).convergents n
{R : Type u_1} [CommRing R] [is_IsDomain R] {a b c : R} (h2 : 2 â‰  0) (ha : a â‰  0) (x : R) : a * x * x + b * x + c = 0 â†” discrim a b c = (2 * a * x + b) ^ 2
{K : Type u_1} [linearOrderedField K] [floorRing K] {v : K} {n : â„•} : GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = Option.none â†” GeneralizedContinuedFraction.IntFractPair.stream v n = Option.none âˆ¨ âˆƒ (ifp : GeneralizedContinuedFraction.IntFractPair K), GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp âˆ§ ifp.fr = 0
{Î± : Type u_1} (f : Î± â†’ Î± â†’ Î±) [IsAssociative Î± f] (x y : Î±) : f x âˆ˜ f y = f (f x y)
{Mâ‚€ : Type u_1} [MulZeroClass Mâ‚€] : (Î» (_x : Mâ‚€), _x * 0) = Function.const Mâ‚€ 0
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {f : â„‚ â†’ E} (hD : DiffContOnCl â„‚ f {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : Asymptotics.SuperpolynomialDecay Filter.atTop Real.exp (Î» (x : â„), âˆ¥f â†‘xâˆ¥)) (him : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥f (â†‘x * Complex.i)âˆ¥ â‰¤ C) : Set.EqOn f 0 {z : â„‚ | 0 â‰¤ z.re}
{E : Type u_1} [AddCommGroup E] [Module â„ E] [topologicalSpace E] [HasContinuousSmul â„ E] {F : Type u_2} [AddCommGroup F] [Module â„ F] [topologicalSpace F] [HasContinuousSmul â„ F] [t2_Space F] (f : E â†’+ F) (hF : Continuous â‡‘f) (c : â„) (x : E) : â‡‘f (c â€¢ x) = c â€¢ â‡‘f x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type w} [CategoryTheory.Category J] (K : J â¥¤ C) (F : C â¥¤ D) [CategoryTheory.Limits.HasLimit (K â‹™ F)] [CategoryTheory.CreatesLimit K F] : CategoryTheory.Limits.HasLimit K
(n : â„•) (R : Type u_1) [Ring R] : (Polynomial.cyclotomic n R).monic
{a b : Prop} : Â¬(a âˆ§ b) â†” Â¬a âˆ¨ Â¬b
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {a : Î±} {s : Set Î±} (h : a âˆ‰ s â†’ f a = 0) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ HasInsert.insert a s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
{Î± : Type u_1} {Î² : Type u_2} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {K : Nnreal} {f : Î± â†’ Î²} : AntilipschitzWith K f â†’ âˆ€ (x y : Î±), HasNndist.nndist x y â‰¤ K * HasNndist.nndist (f x) (f y)
(x : â„‚) : HasStrictDerivAt Complex.cosh (Complex.sinh x) x
{M : Type u_1} [Monoid M] (u : MË£) (a : M) : IsUnit (â†‘u * a) â†” IsUnit a
{R : Type u_1} [CommRing R] : Set.SurjOn (Î» (g : Matrix.SpecialLinearGroup (Fin 2) R), â†‘g 1) Set.Univ {cd : Fin 2 â†’ R | IsCoprime (cd 0) (cd 1)}
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{Î± : Type u_1} {Î¹ : Type u_3} {m : measurableSpace Î±} [LinearOrder Î¹] {f : MeasureTheory.Filtration Î¹ m} {Ï„ : Î± â†’ Î¹} [topologicalSpace Î¹] [OrderTopology Î¹] [TopologicalSpace.FirstCountableTopology Î¹] (hÏ„ : MeasureTheory.IsStoppingTime f Ï„) (i : Î¹) (h_is_IsLub : is_is_IsLub (Set.Iio i) i) : MeasurableSet {x : Î± | Ï„ x < i}
{Î± : Type u} {Î² : Type v} [Semiring Î±] [Semiring Î²] {f : Î± â†’ Î²} (hF : IsSemiringHom f) {Î³ : Type u_1} [Semiring Î³] {g : Î² â†’ Î³} (hg : IsSemiringHom g) : IsSemiringHom (g âˆ˜ f)
{Î± : Type u_1} {Î¹ : Type u_3} [completeLattice Î±] [Fintype Î¹] {f : Î¹ â†’ Î±} : CompleteLattice.Independent f â†’ finset.univ.sup_indep f
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : ContinuousAt f a) (hb : ContinuousAt f b) : HasFderivAt (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd â„ â„ â„).smul_Right (f b) - (ContinuousLinearMap.fst â„ â„ â„).smul_Right (f a)) (a, b)
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 2)} : X.Î´ i â‰« X.Î´ (â‡‘fin.cast_Succ i) = X.Î´ i â‰« X.Î´ i.succ
{M : Type u_1} [hasAdd M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : addConGen r â‰¤ addConGen s
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (ð•œ : Type u_3) [divisionRing ð•œ] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Linear ð•œ C] {X Y : C} [CategoryTheory.Simple X] [CategoryTheory.Simple Y] (h : (X â‰… Y) â†’ False) : FiniteDimensional.finrank ð•œ (X âŸ¶ Y) = 0
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (b : n â†’ Î±) (h : IsUnit A.det) : A.det â€¢ Matrix.vecMul b Aâ»Â¹ = â‡‘(A.transpose.cramer) b
{Î± : Type u_1} [LinearOrder Î±] {s : Set Î±} : Â¬BddBelow s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), y < x
{k : â„•} : Fact (Even (Fintype.card (Fin (bit0 k))))
{n : â„•} (hn : n % 2 = 1) : â‡‘ZmodÏ‡â‚„ â†‘n = (-1) ^ (n / 2)
{Î¹ : Type u_1} {Râ‚‚ : Type u_7} {Mâ‚‚ : Type u_8} [CommRing Râ‚‚] [AddCommGroup Mâ‚‚] [Module Râ‚‚ Mâ‚‚] [DecidableEq Î¹] (e : Basis Î¹ Râ‚‚ Mâ‚‚) (w : Î¹ â†’ Râ‚‚Ë£) : e.to_Matrix â‡‘(e.units_Smul w) = Matrix.diagonal (Coe âˆ˜ w)
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} {Î¹ : Type v} (hs : is_IsCompact s) (Z : Î¹ â†’ Set Î±) (hZc : âˆ€ (i : Î¹), is_IsClosed (Z i)) (hsZ : (s âˆ© â‹‚ (i : Î¹), Z i) = âˆ…) : âˆƒ (t : Finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i) = âˆ…
(l : List â„•) (n : â„•) : List.Sorted LE.le (Denumerable.raise l n)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ Mon_) [CategoryTheory.IsFiltered J] (j : J) : 1 = Mon.FilteredColimits.M.mk F âŸ¨j, 1âŸ©
{K : Type u_1} [linearOrderedField K] [floorRing K] {v : K} {n : â„•} {ifp_Succ_n : GeneralizedContinuedFraction.IntFractPair K} (Stream_Succ_nth_Eq : GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = Option.some ifp_Succ_n) : (GeneralizedContinuedFraction.of v).s.nth n = Option.some {a := 1, b := â†‘(ifp_Succ_n.b)}
(ð•œ : Type u_1) {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_3} [LinearOrder Î¹] [OrderBot Î¹] [locallyFiniteOrder Î¹] [IsWellOrder Î¹ LT.lt] [succOrder Î¹] [IsSuccArchimedean Î¹] (f : Î¹ â†’ E) (hâ‚€ : LinearIndependent ð•œ f) : Orthonormal ð•œ (gramSchmidtNormed ð•œ f)
{G : Type u_1} [Group G] {N : Type u_2} [Group N] (f : G â†’* N) (hF : Function.Surjective â‡‘f) : f.range = âŠ¤
{R : Type u_1} {a : R} [MulZeroClass R] [Nontrivial R] (ra : IsRightRegular a) : a â‰  0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {x : E} {n : WithTop â„•} {f : E â†’ F} (hF : ContDiffAt ð•œ n f x) : ContDiffAt ð•œ n (Î» (x : E), -f x) x
{Î± : Type u_1} {Î² : sort u_2} {Î³ : sort u_3} {s : Set Î±} (e : Î² â‰ƒ â†¥s) (v : Î² â†’ Î³) (w : Î± â†’ Î³) (j : Î²) (x : Î³) [DecidableEq Î²] [DecidableEq Î±] [Î  (j : Î±), Decidable (j âˆˆ s)] : (Î» (i : Î±), dite (i âˆˆ s) (Î» (h : i âˆˆ s), Function.update v j x (â‡‘(e.symm) âŸ¨i, hâŸ©)) (Î» (h : i âˆ‰ s), w i)) = Function.update (Î» (i : Î±), dite (i âˆˆ s) (Î» (h : i âˆˆ s), v (â‡‘(e.symm) âŸ¨i, hâŸ©)) (Î» (h : i âˆ‰ s), w i)) â†‘(â‡‘e j) x
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M â†’* P} (H : c â‰¤ Con.ker f) (x : M) : â‡‘(c.lift f H) â†‘x = â‡‘f x
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) {r : â„} : 2 â€¢ o.oangle (r â€¢ x) x = 0
{G : Type u_6} {H : Type u_7} {F : Type u_8} [AddGroup G] [subtractionMonoid H] [addMonoidHomClass F G H] (f : F) (a b : G) : â‡‘f (a + -b) = â‡‘f a + -â‡‘f b
{Î± : Type u} [topologicalSpace Î±] [t2_Space Î±] (h : TopologicalSpace.IsTopologicalBasis {s : Set Î± | is_IsClopen s}) : TotallySeparatedSpace Î±
{Î± : Type uu} (a : Î±) {lâ‚ lâ‚‚ : List Î±} : a :: lâ‚ <+~ a :: lâ‚‚ â†’ lâ‚ <+~ lâ‚‚
{M : Type u_3} {F : Type u_8} {G : Type u_1} [Group G] [Monoid M] [monoidHomClass F G M] {f g : F} {x : G} (h : â‡‘f x = â‡‘g x) : â‡‘f xâ»Â¹ = â‡‘g xâ»Â¹
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} [CompactSpace Î±] : Metric.Bounded s
{X : Type u_2} [emetricSpace X] {mâ‚ mâ‚‚ : Ennreal â†’ Ennreal} (hle : mâ‚ â‰¤á¶ [nhdsWithin 0 (Set.Ici 0)] mâ‚‚) : MeasureTheory.OuterMeasure.mkMetric mâ‚ â‰¤ MeasureTheory.OuterMeasure.mkMetric mâ‚‚
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {A B C : V} {f : A âŸ¶ B} [CategoryTheory.Limits.HasImage f] {g : B âŸ¶ C} [CategoryTheory.Limits.HasKernel g] (w : f â‰« g = 0) {A' B' C' : V} {f' : A' âŸ¶ B'} [CategoryTheory.Limits.HasImage f'] {g' : B' âŸ¶ C'} [CategoryTheory.Limits.HasKernel g'] (w' : f' â‰« g' = 0) (Î± : CategoryTheory.Arrow.mk f âŸ¶ CategoryTheory.Arrow.mk f') [CategoryTheory.Limits.HasImageMap Î±] (Î² : CategoryTheory.Arrow.mk g âŸ¶ CategoryTheory.Arrow.mk g') (p : Î±.right = Î².left) : imageToKernel f g w â‰« CategoryTheory.Limits.kernelSubobjectMap Î² = CategoryTheory.Limits.imageSubobjectMap Î± â‰« imageToKernel f' g' w'
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup V1] [Module k V1] [addTorsor V1 P1] [AddCommGroup V2] [Module k V2] [addTorsor V2 P2] {f g : P1 â†’áµƒ[k] P2} (h : âˆ€ (p : P1), â‡‘f p = â‡‘g p) : f = g
{Î± : Type u_1} [Preorder Î±] [locallyFiniteOrder Î±] {a b : Î±} : Â¬a < b â†’ Finset.ioc a b = âˆ…
{E : Type u_1} [NormedGroup E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} [normedSpace â„‚ E] (hF : CircleIntegrable f c R) : IntervalIntegrable (Î» (Î¸ : â„), deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸)) MeasureTheory.MeasureSpace.volume 0 (2 * Real.pi)
{Î± : Type u_1} (c : Set (Set Î±)) (hc : setoid.is_Partition c) : (setoid.mk_Classes c _).classes = c
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b c : Î±} : b < aâ»Â¹ * c â†’ a * b < c
{Î± : Type u_1} {s t : Set Î±} : Disjoint s t â†’ Disjoint (Filter.principal s) (Filter.principal t)
{Î± : Type u_1} {l : List Î±} : l <+: List.nil â†’ l = List.nil
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [AddZeroClass M] [AddCommMonoid N] {f g : Î± â†’â‚€ M} {h : Î± â†’ M â†’ N} (h_Zero : âˆ€ (a : Î±), a âˆˆ f.support âˆª g.support â†’ h a 0 = 0) (h_Add : âˆ€ (a : Î±), a âˆˆ f.support âˆª g.support â†’ âˆ€ (bâ‚ bâ‚‚ : M), h a (bâ‚ + bâ‚‚) = h a bâ‚ + h a bâ‚‚) : (f + g).sum h = f.sum h + g.sum h
(Î± : Type u) [Semiring Î±] [Nontrivial Î±] : âˆƒ (M : Ideal Î±), M.is_Maximal
{Î± : Type u_1} {Î¹ : sort u_4} [completeLattice Î±] {b : Î±} {f : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), b â‰¤ f i) (hâ‚‚ : âˆ€ (w : Î±), b < w â†’ (âˆƒ (i : Î¹), f i < w)) : (â¨… (i : Î¹), f i) = b
(x : â„) : 0 < Real.cosh x
{n p : â„•} (hp : Nat.Prime p) : multiplicity p (p * (n + 1)).factorial = multiplicity p (p * n).factorial + multiplicity p (n + 1) + 1
{ð•‚ : Type u_1} [nondiscreteNormedField ð•‚] [CompleteSpace ð•‚] [CharZero ð•‚] {x : ð•‚} (hx : x âˆˆ Emetric.Ball 0 (expSeries ð•‚ ð•‚).radius) : HasDerivAt (Exp ð•‚) (Exp ð•‚ x) x
{R : Type u_1} [MulOneClass R] : IsRegular 1
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [Nontrivial k] {p : Î¹ â†’ P} (ha : AffineIndependent k p) : Function.Injective p
{a b c : â„¤} (h : fermat_42 a b c) : âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0
{Î± : Type u_1} {Î² : Type u_2} [hasAdd Î±] [Preorder Î±] [Preorder Î²] [CovariantClass Î± Î± Add.add LT.lt] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {f g : Î² â†’ Î±} (hF : Monotone f) (hg : StrictMono g) : StrictMono (Î» (x : Î²), f x + g x)
(p : â„•) [hp : Fact (Nat.Prime p)] {n i j : â„•} (hi : i < n) (hj : j < p ^ (n - i)) : j - pnat_multiplicity p âŸ¨j + 1, _âŸ© + n = i + j + (n - i - pnat_multiplicity p âŸ¨j + 1, _âŸ©)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {n : â„•} (s : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : â„•} (h : fs.card = m + 1) (i : Fin (m + 1)) : (s.face h).points i = s.points (â‡‘(fs.order_emb_of_Fin h) i)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (p : Î¹ â†’ P) : (s.affine_combination p).linear = s.weighted_vsub p
{Î± : Type u} (ls : List (List Î±)) [DecidableEq Î±] (x : Î±) (hx : âˆ€ (l : List Î±), l âˆˆ ls â†’ x âˆ‰ l) (hls : ls â‰  List.nil) : List.splitOn x ([x].intercalate ls) = ls
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [AddCommMonoid Î²] [AddCommMonoid Î³] (g : Î² â†’+ Î³) (f : Î± â†’ Î²) (s : Finset Î±) : â‡‘g (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), â‡‘g (f x))
{C : Type uâ‚} [CategoryTheory.Category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚ƒâ‚ Xâ‚ƒâ‚‚ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚ƒâ‚ : Xâ‚ƒâ‚ âŸ¶ Xâ‚ƒâ‚‚} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚ƒâ‚} {vâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚ƒâ‚‚} (s : CategoryTheory.IsPullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : CategoryTheory.IsPullback hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚) : CategoryTheory.IsPullback hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚
{Mâ‚€ : Type u_1} [monoidWithZero Mâ‚€] [Nontrivial Mâ‚€] (u : Mâ‚€Ë£) : â†‘u â‰  0
{C : Type u} [CategoryTheory.Category C] (P Q : C) [CategoryTheory.Limits.HasBinaryProduct P Q] : CategoryTheory.Limits.HasBinaryProduct Q P
 : (polynomialFunctions UnitInterval).topological_Closure = âŠ¤
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C â¥¤ D) {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.additive] [CategoryTheory.Limits.PreservesFiniteColimits F] [CategoryTheory.Epi g] (ex : CategoryTheory.Exact f g) : CategoryTheory.Exact (F.map f) (F.map g)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) {p : P} (hr : âˆƒ (r : â„), âˆ€ (i : Fin (n + 1)), HasDist.dist (s.points i) p = r) : â†‘(â‡‘(s.orthogonal_projection_Span) p) = s.circumcenter
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : f (â‡‘(AffineMap.lineMap a b) r) < â‡‘(AffineMap.lineMap (f a) (f b)) r â†” slope f a b < slope f (â‡‘(AffineMap.lineMap a b) r) b
{Î± : Type u} {Î² : Type v} : (Î± â†ª Î²) â†’ (Î² â†ª Î±) â†’ Nonempty (Î± â‰ƒ Î²)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h2 : p2 â‰  p1) (h3 : p3 â‰  p1) : EuclideanGeometry.angle p1 p2 p3 + EuclideanGeometry.angle p2 p3 p1 + EuclideanGeometry.angle p3 p1 p2 = Real.pi
{G : Type u_6} {H : Type u_7} {F : Type u_8} [Group G] [divisionMonoid H] [monoidHomClass F G H] (f : F) (g : G) (n : â„¤) : â‡‘f (g ^ n) = â‡‘f g ^ n
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] {n : Type w} [Nontrivial R] [NoZeroDivisors R] (B : BilinForm R M) (v : Basis n R M) (hO : B.is_Ortho â‡‘v) : B.nondegenerate â†” âˆ€ (i : n), Â¬B.is_IsOrtho (â‡‘v i) (â‡‘v i)
{X : Type u_1} [topologicalSpace X] [CompactSpace X] {Y : Type u_2} [topologicalSpace Y] : IsClosedMap Prod.snd
{n : â„•} : IsPrimePow n â†” âˆƒ! (p : â„•), Nat.Prime p âˆ§ p âˆ£ n
{Î± : Type u} (x : Î±) : Function.IsFixedPt Id x
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {n : WithTop â„•} : ContDiff ð•œ n f â†” HasFtaylorSeriesUpTo n f (ftaylorSeries ð•œ f)
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) (m : M) : â‡‘(CliffordAlgebraÎ¹ Q) m * â‡‘(CliffordAlgebraÎ¹ Q) m = â‡‘(algebraMap R (CliffordAlgebra Q)) (â‡‘Q m)
(ð•œ : Type u_5) (E : Type u_6) [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [Nontrivial E] : NoncompactSpace E
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] : Continuous (Î» (p : ContinuousMultilinearMap ð•œ E G Ã— Î  (i : Î¹), E i), â‡‘(p.fst) p.snd)
{G : Type u_1} [AddCommMonoid G] (tG : Add_monoid.is_torsion G) : Add_comm_monoid.add_torsion G = âŠ¤
{M : Type u_1} [hasAdd M] {c d : AddCon M} (H : âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) : c = d
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] [FiniteDimensional K L] {x : L} : â‡‘(Algebra.norm K) x = 0 â†” x = 0
{x : â„} (h : 0 < x) (h' : x â‰¤ 1) : x - x ^ 3 / 4 < Real.sin x
{Î³ : Type w} [metricSpace Î³] {x y : Î³} : HasNndist.nndist x y = 0 â†” x = y
{K : Type u} [Field K] (s : Subfield K) (m : Multiset K) : (âˆ€ (a : K), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (G : C â¥¤ D) [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G] : CategoryTheory.Limits.HasTerminal D
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} : 0 < a - b â†’ b < a
(p : â„•) [Fact (Nat.Prime p)] (a : â„¤) (ha : â†‘a â‰  0) : Zmod.legendreSym p (a ^ 2) = 1
{Î± : Type u} (S T : Set Î±) : Cardinal.mk â†¥(S âˆª T) â‰¤ Cardinal.mk â†¥S + Cardinal.mk â†¥T
{Î¹ : Type u} (s : Finset Î¹) (f g : Î¹ â†’ Nnreal) {p q : â„} (hpq : p.is_conjugate_exponent q) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
{R : Type u} [CommRing R] {P : Ideal R} (H : P.is_Prime) : is_IsDomain (Polynomial R â§¸ Ideal.map Polynomial.c P)
(G : Type u_1) [Monoid G] (L : Type u_2) [CommRing L] [NoZeroDivisors L] : LinearIndependent L (Î» (f : G â†’* L), â‡‘f)
{Î± : Type u} {s : Set Î±} : s.countable â†’ {t : Set Î± | t.finite âˆ§ t âŠ† s}.countable
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {Î¹ : Type u_1} (b : Basis Î¹ R M) {Îº : Type u_1} (v : Îº â†’ M) (i : LinearIndependent R v) : Cardinal.mk Îº â‰¤ Cardinal.mk Î¹
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) [Invertible A] : â…Ÿ A = Aâ»Â¹
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type w} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (hu : CategoryTheory.CoverLifting J K G) (â„± : CategoryTheory.Sheaf J A) {X : A} {U : D} {S : CategoryTheory.Sieve U} (hS : S âˆˆ â‡‘K U) {x : CategoryTheory.Presieve.FamilyOfElements ((CategoryTheory.ran G.op).obj â„±.val â‹™ Category_theory.coyoneda.obj (Opposite.op X)) S.arrows} (hx : x.compatible) : x.is_amalgamation (CategoryTheory.RanIsSheafOfCoverLifting.gluedSection hu â„± hS hx)
(R : Type u_1) [CommRing R] (M : Type u_2) [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [Nontrivial R] : LinearMap.trace R M = (contractLeft R M).comp (dualTensorHomEquiv R M M).symm.to_Linear_Map
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h0 : 0 < r) (h : â†‘r < p.radius) : âˆƒ (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C / â†‘r ^ n
{ð’ª : Type u} {K : Type v} {Î“ : Type w} [CommRing ð’ª] [is_IsDomain ð’ª] [Field K] [Algebra ð’ª K] [LinearOrderedCommGroupWithZero Î“] (v : Valuation K Î“) (hH : v.integers ð’ª) : ValuationRing ð’ª
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] [DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ Î²) {a : Î±} (h : a âˆˆ s) : (s.erase a).sum (Î» (x : Î±), f x) + f a = s.sum (Î» (x : Î±), f x)
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ âˆ…), f i)) = 1
{Î± : Type u_1} {n : Type u_3} [DecidableEq n] [hasZero Î±] (v : n â†’ Î±) : (Matrix.diagonal v).is_Symm
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {n : WithTop â„•} (e : G â‰ƒL[ð•œ] E) : ContDiffOn ð•œ n (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) â†” ContDiffOn ð•œ n f s
{Î± : Type u_1} {Î¹ : sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : l.has_Basis p s) {V : Set Î±} (hV : V âˆˆ l) : l.has_Basis (Î» (i : Î¹), p i âˆ§ s i âŠ† V) s
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : is_IsCompact s â†” âˆ€ {Î¹ : Type u} (Z : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), is_IsClosed (Z i)) â†’ (s âˆ© â‹‚ (i : Î¹), Z i) = âˆ… â†’ (âˆƒ (t : Finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i) = âˆ…)
{Î± : Type u} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] : Filter.Tendsto (Î» (x : Î±), xâ»Â¹) (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle â„ P) : t.orthocenter = Affine.Simplex.mongePoint t
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {g : Î² â†’ Î³} (hg : Function.Injective g) : Function.Injective (Function.comp g)
(o : Ordinal) : o.to_pgame.numeric
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±} [topologicalSpace Î±] (h : TendstoUniformlyOn F f p s) (hF : ContinuousWithinAt f s x) (hg : Filter.Tendsto g p (nhdsWithin x s)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
{a b : â„} {g' g : â„ â†’ â„} (hab : a â‰¤ b) (hcont : ContinuousOn g (Set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt g (g' x) x) (g'Pos : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ 0 â‰¤ g' x) : MeasureTheory.IntegrableOn g' (Set.Ioc a b) MeasureTheory.MeasureSpace.volume
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) : (s.circumcenter_circumradius.fst âˆˆ affineSpan â„ (Set.Range s.points) âˆ§ âˆ€ (i : Fin (n + 1)), HasDist.dist (s.points i) s.circumcenter_circumradius.fst = s.circumcenter_circumradius.snd) âˆ§ âˆ€ (cccr : P Ã— â„), (cccr.fst âˆˆ affineSpan â„ (Set.Range s.points) âˆ§ âˆ€ (i : Fin (n + 1)), HasDist.dist (s.points i) cccr.fst = cccr.snd) â†’ cccr = s.circumcenter_circumradius
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} (h_Mono : StrictMonoOn f s) (hs : s âˆˆ nhdsWithin a (Set.Iic a)) (hfs : âˆ€ (b : Î²), b < f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ Set.Ico b (f a))) : ContinuousWithinAt f (Set.Iic a) a
(A : Type u_1) (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] : minpoly A 0 = Polynomial.x
{G : Type u_1} [Group G] {Î¹ : sort u_2} (S : Î¹ â†’ Subgroup G) {C : Î  (x : G), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : G) (H : x âˆˆ S i), C x _) (h1 : C 1 _) (HMul : âˆ€ (x y : G) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x * y) _) {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
(x : â„) : Real.arsinh (Real.sinh x) = x
(n : â„•) {a : â„} (h : 2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrtTwoAddSeries (â†‘0 / â†‘1) n) (hâ‚‚ : 1 / 4 ^ n â‰¤ a) : Real.pi < a
{Î± : sort u} {Î² : sort v} {f : Î± â†’ Î²} (hF : Function.Injective f) [Subsingleton Î²] : Subsingleton Î±
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {p : P} (hp : p âˆ‰ s) : HasDist.dist p â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p) â‰  0
(P : â„• â†’ â„• â†’ Prop) (ha : âˆ€ (a : â„•), P (a + 1) (a + 1)) (hb : âˆ€ (b : â„•), P 0 (b + 1)) (hD : âˆ€ (a b : â„•), a < b â†’ P (a + 1) b â†’ P a (b + 1) â†’ P (a + 1) (b + 1)) (a b : â„•) : a < b â†’ P a b
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (p : P) : Function.Injective (Î» (_x : P), _x -áµ¥ p)
{G : Type u_1} [Group G] [hG : group.is_nilpotent G] : Nat.find _ = group.nilpotency_class G
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {p : Î¹ â†’ P} (ha : AffineIndependent k p) : AffineIndependent k (Î» (x : â†¥(Set.Range p)), â†‘x)
{Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : a < b) : Â¬IsMax a
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} {g : â„ â†’ E} (fdiff : DifferentiableOn â„ f (Set.Icc a b)) (gdiff : DifferentiableOn â„ g (Set.Icc a b)) (hderiv : Set.EqOn (derivWithin f (Set.Icc a b)) (derivWithin g (Set.Icc a b)) (Set.Ico a b)) (hi : f a = g a) (y : â„) (H : y âˆˆ Set.Icc a b) : f y = g y
{G : Type u_7} [Group G] (L : List G) : (L.prod)â»Â¹ = (List.map (Î» (x : G), xâ»Â¹) L).reverse.prod
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurableSpace Î±} [topologicalSpace Î²] [TopologicalSpace.PseudoMetrizableSpace Î²] [measurableSpace Î²] [BorelSpace Î²] : MeasureTheory.StronglyMeasurable f â†” Measurable f âˆ§ TopologicalSpace.IsSeparable (Set.Range f)
{n : â„•} : orderOf (QuaternionGroup.a 1) = 2 * n
{Î± : Type u_1} [topologicalSpace Î±] {x : Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] {f g : Î± â†’ Î³} (hF : UpperSemicontinuousAt f x) (hg : UpperSemicontinuousAt g x) (hcont : ContinuousAt (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : UpperSemicontinuousAt (Î» (z : Î±), f z + g z) x
{R : Type u_1} [CommSemiring R] {M : Submonoid R} {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization M S] {g : R â†’+* P} (hg : âˆ€ (y : â†¥M), IsUnit (â‡‘g â†‘y)) (x : R) (y : â†¥M) : â‡‘(IsLocalization.lift hg) (IsLocalization.mk' S x y) = â‡‘g x * â†‘(â‡‘(IsUnit.liftRight (g.to_Monoid_hom.restrict M) hg) y)â»Â¹
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {f : â„‚ â†’ E} (hD : DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.i) = 0) : Set.EqOn f 0 {z : â„‚ | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}
{Î± : Type u_1} {G : Type u_4} [conditionallyCompleteLattice Î±] [Group G] (fâ‚ fâ‚‚ : G â†’* Î± â‰ƒo Î±) (hbdd : âˆ€ (x : Î±), BddAbove (Set.Range (Î» (g : G), â‡‘(â‡‘fâ‚ g)â»Â¹ (â‡‘(â‡‘fâ‚‚ g) x)))) (g : G) : Function.Semiconj (Î» (x : Î±), â¨† (g' : G), â‡‘(â‡‘fâ‚ g')â»Â¹ (â‡‘(â‡‘fâ‚‚ g') x)) â‡‘(â‡‘fâ‚‚ g) â‡‘(â‡‘fâ‚ g)
{R : Type u_1} {A : Type u_2} {M : Type u_3} {N : Type u_4} {P : Type u_5} [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid M] [Module R M] [Module A M] [isScalarTower R A M] [AddCommMonoid N] [Module R N] [AddCommMonoid P] [Module R P] [Module A P] [isScalarTower R A P] : Function.Injective TensorProduct.AlgebraTensorModule.curry
{C : Type u} [CategoryTheory.Category C] {X : C} (i : CategoryTheory.Arrow C) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.mk (ðŸ™ X))
{Î± : Type u} [SemilatticeSup Î±] [Nonempty Î±] (s : Finset Î±) : BddAbove â†‘s
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : (Matrix n n Î±)Ë£) : â†‘Aâ»Â¹ = (â†‘A)â»Â¹
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [OrderedAddCommGroup Î²] [HasScalar ð•œ E] [Module ð•œ Î²] {s : Set E} {f : E â†’ Î²} : ConvexOn ð•œ s (-f) â†” ConcaveOn ð•œ s f
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] {mâ‚ mâ‚‚ : Ennreal â†’ Ennreal} (hle : mâ‚ â‰¤á¶ [nhdsWithin 0 (Set.Ici 0)] mâ‚‚) : MeasureTheory.Measure.mkMetric mâ‚ â‰¤ MeasureTheory.Measure.mkMetric mâ‚‚
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {s : AffineSubspace k P} (h : â†‘s.nonempty) : s.direction = âŠ¤ â†” s = âŠ¤
{G : Type u_1} [AddGroup G] {k : Set G} : k âŠ† â†‘(AddSubgroup.closure k)
{C : Type u} [CategoryTheory.Category C] {A B : C} {f g : A âŸ¶ B} [CategoryTheory.IsReflexivePair f g] : CategoryTheory.IsReflexivePair g f
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M â†’* P} (H : c â‰¤ Con.ker f) : (c.lift f H).comp c.mk' = f
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) : S.normed_mk.ker = S
{Î± : Type u_1} [NonUnitalSemiNormedRing Î±] (x y : Î±) : âˆ¥â‡‘(AddMonoidHom.mulRight x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{R : Type u} [CommRing R] {n : â„•} (u : RË£) (hn : IsUnit â†‘n) : (Polynomial.x ^ n - â‡‘Polynomial.c â†‘u).separable
{Î± : sort u_1} (x : Î±) (h : âˆ€ (y : Î±), y = x) : Subsingleton Î±
{Î± : Type u_1} (L : List (List Î±)) (i : â„•) : List.take (List.take i (List.map List.length L)).sum L.join = (List.take i L).join
{K : Type u_1} {Kâ‚˜ : Type u_2} [Field K] [CommRing Kâ‚˜] {M : Submonoid K} (hM : 0 âˆ‰ M) [Algebra K Kâ‚˜] [IsLocalization M Kâ‚˜] : Function.bijective â‡‘(algebraMap K Kâ‚˜)
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Mâ‚ : Type u_4} [topologicalSpace Mâ‚] [AddCommMonoid Mâ‚] {Mâ‚‚ : Type u_6} [topologicalSpace Mâ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚ Mâ‚] [Module Râ‚‚ Mâ‚‚] [t2_Space Mâ‚‚] {s : Set Mâ‚} (hs : Dense â†‘(Submodule.span Râ‚ s)) {f g : Mâ‚ â†’sl[Ïƒâ‚â‚‚] Mâ‚‚} (h : Set.EqOn â‡‘f â‡‘g s) : f = g
{M : Type u_1} [AddMonoid M] {s : Set M} {a : M} (hs : IsAddSubmonoid s) (h : a âˆˆ s) {n : â„•} : n â€¢ a âˆˆ s
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {x : L} : x âˆˆ S â†’ xâ»Â¹ âˆˆ S
{X : Type u_1} [uniformSpace X] {s : Set X} [(Uniformity X).is_countably_generated] : is_IsCompact s â†” IsSeqCompact s
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (x : Module.Ray R M) : âŸ¦x.some_RayVectorâŸ§ = x
{Î± : Type u_1} [topologicalSpace Î±] {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] [HasContinuousAdd Î³] {f g : Î± â†’ Î³} (hF : LowerSemicontinuous f) (hg : LowerSemicontinuous g) : LowerSemicontinuous (Î» (z : Î±), f z + g z)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
{Î± : Type u_1} {Î² : Type u_2} {f g : Î± â†’ Î²} {m : measurableSpace Î±} {mÎ² : measurableSpace Î²} {p : Î± â†’ Prop} {_x : DecidablePred p} (hp : MeasurableSet {a : Î± | p a}) (hF : Measurable f) (hg : Measurable g) : Measurable (Î» (x : Î±), Ite (p x) (f x) (g x))
{Î± : Type u} [topologicalSpace Î±] (a : Î±) : (nhds a).has_Basis (Î» (s : Set Î±), a âˆˆ s âˆ§ is_IsOpen s) (Î» (s : Set Î±), s)
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [linearOrderedAddCommGroup Î±] [Archimedean Î±] (h : Function.Periodic f c) (hc : 0 < c) (x a : Î±) : âˆƒ (y : Î±) (H : y âˆˆ Set.Ico a (a + c)), f x = f y
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup Vâ‚‚] [Module k Vâ‚‚] [addTorsor Vâ‚‚ Pâ‚‚] {s : Set P} (e : P â‰ƒáµƒ[k] Pâ‚‚) : AffineIndependent k Coe â†” AffineIndependent k Coe
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (X : CategoryTheory.SimplicialObject C) (n : â„•) : algebraic_topology.alternating_face_Map_complex.obj_d X (n + 1) â‰« algebraic_topology.alternating_face_Map_complex.obj_d X n = 0
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {v : E} : â†‘(â‡‘(orthogonalProjection K) v) = v â†” v âˆˆ K
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : (f =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f =O[l] g'
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] (X : C) (h : âˆ€ {Z : C} (f : X âŸ¶ Z) [_inst_3 : CategoryTheory.Epi f], CategoryTheory.IsIso f â†” f â‰  0) : CategoryTheory.Simple X
{R : Type u_1} {S : Type u_2} [euclideanDomain R] [CommRing S] [is_IsDomain S] [Algebra R S] (abv : AbsoluteValue R â„¤) {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] (bS : Basis Î¹ R S) {T : Type u_3} [linearOrderedRing T] (a : S) {y : T} (hy : âˆ€ (k : Î¹), â†‘(â‡‘abv (â‡‘(â‡‘(bS.repr) a) k)) < y) : â†‘(â‡‘abv (â‡‘(Algebra.norm R) a)) < â†‘(ClassGroup.normBound abv bS) * y ^ Fintype.card Î¹
(k : Type u_1) [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) [CharZero k] [Fintype Î¹] {n : â„•} (h : s.card = n + 1) : finset.univ.sum (Î» (i : Î¹), Finset.centroidWeightsIndicator k s i) = 1
{M : Type u_1} [AddMonoid M] {sâ‚ sâ‚‚ : Set M} (isâ‚ : IsAddSubmonoid sâ‚) (isâ‚‚ : IsAddSubmonoid sâ‚‚) : IsAddSubmonoid (sâ‚ âˆ© sâ‚‚)
{M : Type u_1} [hasMul M] {c d : Con M} : Setoid.r = Setoid.r â†” c = d
{Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [Semiring Î²] [hasMul Î±] [hasMul Î±â‚‚] {F : Type u_4} [mulHomClass F Î± Î±â‚‚] (f : F) (x y : MonoidAlgebra Î² Î±) : Finsupp.mapDomain â‡‘f (x * y) = Finsupp.mapDomain â‡‘f x * Finsupp.mapDomain â‡‘f y
{R : Type u_1} [orderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {x y : M} : SameRay R (-x) (-y) â†” SameRay R x y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type uâ‚} [CategoryTheory.Category D] (h : C â‰Œ D) : CategoryTheory.IsFiltered D
{p : Polynomial â„š} (p_irr : Irreducible p) (p_deg : Nat.Prime p.nat_degree) (p_roots1 : Fintype.card â†¥(p.root_Set â„) + 1 â‰¤ Fintype.card â†¥(p.root_Set â„‚)) (p_roots2 : Fintype.card â†¥(p.root_Set â„‚) â‰¤ Fintype.card â†¥(p.root_Set â„) + 3) : Function.bijective â‡‘(Polynomial.Gal.galActionHom p â„‚)
{G : Type u_1} [linearOrderedAddCommGroup G] [Archimedean G] {H : AddSubgroup G} {a : G} (ha : IsLeast {g : G | g âˆˆ H âˆ§ 0 < g} a) : H = AddSubgroup.closure {a}
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{m : â„•} (hm : 0 < m) (k : â„•) : âˆƒ (p : â„•), Liouville.liouvilleNumberInitialTerms â†‘m k = â†‘p / â†‘m ^ k.factorial
{Î± : Type u_1} [HasLe Î±] {a : Î±áµ’áµˆ} : IsBot a â†’ IsTop (â‡‘OrderDual.ofDual a)
{J : Type v} {C : Type u} [CategoryTheory.Category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [Nonempty J] {t : CategoryTheory.Limits.Trident f} (ht : CategoryTheory.Limits.IsLimit t) {Z Z' : C} (q : Z' âŸ¶ Z) (k : Z âŸ¶ t.X) : â†‘(â‡‘(CategoryTheory.Limits.Trident.IsLimit.homIso ht Z') (q â‰« k)) = q â‰« â†‘(â‡‘(CategoryTheory.Limits.Trident.IsLimit.homIso ht Z) k)
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Monotone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ico (f (Order.pred n)) (f n))
{Î² : Type u} {Î³ : Type w} [CommSemiring Î²] [CommSemiring Î³] (f : Î² â†’+* Î³) (s : Multiset Î²) : â‡‘f s.prod = (Multiset.map â‡‘f s).prod
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), Monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : IsOfFinOrder x) (i : Î·) : IsOfFinOrder (x i)
{Î± : Type u_3} {Î² : Type u_4} [linearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto f l Filter.atBot) : Filter.Tendsto (Î» (x : Î²), f x / r) l Filter.atBot
{Î± : Type u} {Î² : Type v} [AddZeroClass Î±] [AddZeroClass Î²] {f : Î± â†’ Î²} (hF : IsAddMonoidHom f) (x y : Î±) : f (x + y) = f x + f y
{F : Type u_3} [innerProductSpace â„ F] {x y : F} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * HasInner.inner x y + âˆ¥yâˆ¥ ^ 2
{E : Type u_2} {ð•œ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] {s : Set E} (hs : Convex ð•œ s) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ Interior s) {t : ð•œ} (ht : t âˆˆ Set.Ioc 0 1) : x + t â€¢ (y - x) âˆˆ Interior s
(ð•œ : Type u_1) [nondiscreteNormedField ð•œ] {n : WithTop â„•} {R : Type u_6} [normedRing R] [NormedAlgebra ð•œ R] [CompleteSpace R] (x : RË£) : ContDiffAt ð•œ n Ring.inverse â†‘x
{K : Type u} [Field K] (s : Subfield K) {x : K} : x âˆˆ s â†’ xâ»Â¹ âˆˆ s
{K : Type u_1} [Field K] (f : Polynomial K) (a : K) (hF' : Polynomial.eval a (â‡‘Polynomial.derivative f) â‰  0) : IsCoprime (Polynomial.x - â‡‘Polynomial.c a) (f /â‚˜ (Polynomial.x - â‡‘Polynomial.c a))
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] {X : Top} (F : Top.Presheaf C X) : F.is_sheaf â†” F.is_sheaf_Unique_gluing
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R x (r â€¢ y)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {T : E â†’â‚—[ð•œ] E} (hT : InnerProductSpace.IsSelfAdjoint T) {V : Submodule ð•œ E} (hV : âˆ€ (v : E), v âˆˆ V â†’ â‡‘T v âˆˆ V) : InnerProductSpace.IsSelfAdjoint (T.restrict hV)
{Î± : Type u} [t : topologicalSpace Î±] {a : Î±} {s : Set Î±} {b : Set (Set Î±)} (hb : TopologicalSpace.IsTopologicalBasis b) : s âˆˆ nhds a â†” âˆƒ (t : Set Î±) (H : t âˆˆ b), a âˆˆ t âˆ§ t âŠ† s
{n : â„•} {i : Fin (n + 1)} : SimplexCategoryÎ´ i.succ â‰« SimplexCategoryÏƒ i = ðŸ™ (SimplexCategory.mk n)
{G : Type u_1} [Group G] (H : Subgroup G) [H.normal] : upperCentralSeriesStep H = Subgroup.comap (QuotientGroup.mk' H) (Subgroup.center (G â§¸ H))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) [FiniteDimensional k â†¥(vectorSpan k s)] : Collinear k s â†” FiniteDimensional.finrank k â†¥(vectorSpan k s) â‰¤ 1
{R : Type u_4} [linearOrderedRing R] (a : R) (h : a â‰  0) : 0 < a ^ 2
{n : â„•} {Î± : Type u_1} {v : Vector Î± n} : v.reverse.to_List = v.to_list.reverse
{R : Type u_1} [Ring R] {M : Type u_2} [AddCommGroup M] [Module R M] {N : Type u_3} [AddCommGroup N] [Module R N] [IsSimpleModule R M] [IsSimpleModule R N] (f : M â†’â‚—[R] N) : Function.bijective â‡‘f âˆ¨ f = 0
{r : â„} (hr : 0 â‰¤ r) (h'r : r < 1) : Filter.Tendsto (Î» (n : â„•), â†‘n * r ^ n) Filter.atTop (nhds 0)
(K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [Module.Finite K L] {R : Type z} [CommRing R] [Algebra R K] [Algebra R L] [isScalarTower R K L] [is_IsDomain R] [IsSeparable K L] [IsIntegrallyClosed R] [IsFractionRing R K] {B : powerBasis K L} (hint : IsIntegral R B.gen) {z : L} (hz : IsIntegral R z) : Algebra.discr K â‡‘(B.basis) â€¢ z âˆˆ Algebra.adjoin R {B.gen}
{Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), metricSpace (E i)] [âˆ€ (i : Î¹), CompleteSpace (E i)] : CompleteSpace (Î£ (i : Î¹), E i)
{F : Type u_8} {G : Type u_1} {H : Type u_2} [Group G] [MulOneClass H] [monoidHomClass F G H] (f : F) : Function.Injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 1 â†’ a = 1
{Î± : Type u_1} {ð•œ : Type u_14} [normedField ð•œ] {l : Filter Î±} {f g : Î± â†’ ð•œ} (hgf : âˆ€ (x : Î±), g x = 0 â†’ f x = 0) : Filter.Tendsto (Î» (x : Î±), f x / g x) l (nhds 0) â†’ f =o[l] g
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {f : â„‚ â†’ E} (hD : DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Iio 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Iio 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.i) = 0) : Set.EqOn f 0 {z : â„‚ | 0 â‰¤ z.re âˆ§ z.im â‰¤ 0}
{X : Type u_1} [topologicalSpace X] {x y : X} {F : Set X} (h : JoinedIn F x y) : Joined âŸ¨x, _âŸ© âŸ¨y, _âŸ©
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurableSpace Î±} {mâ‚‚ : measurableSpace Î²} {f : Î± â†’ Î²} : Measurable f â†’ MeasurableSpace.comap f mâ‚‚ â‰¤ mâ‚
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {s : Set E} [CompleteSpace F] (h : AnalyticOn ð•œ f s) : AnalyticOn ð•œ (fderiv ð•œ f) s
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [Fintype Î¹] (p : Î¹ â†’ P) {n : â„•} (hc : Fintype.card Î¹ = n + 1) : AffineIndependent k p â†” FiniteDimensional.finrank k â†¥(vectorSpan k (Set.Range p)) = n
{Î± : Type u} [AddCommGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] {a b c : Î±} : a + b â‰¤ c â†’ b â‰¤ c - a
{R : Type u} [Ring R] {s : Set R} : s âŠ† â†‘(Subring.closure s)
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {f g : â„‚ â†’ E} (hdf : DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)) (hBf : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hdg : DiffContOnCl â„‚ g (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)) (hBg : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = g â†‘x) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.i) = g (â†‘x * Complex.i)) : Set.EqOn f g {z : â„‚ | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] {b : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.some b) : âˆƒ (z : â„¤), b = â†‘z
(R : Type u_1) [CommRing R] (m k : â„•) : 2 * Polynomial.Chebyshev.t R m * Polynomial.Chebyshev.t R (m + k) = Polynomial.Chebyshev.t R (2 * m + k) + Polynomial.Chebyshev.t R k
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u_3} [CategoryTheory.Category D] [CategoryTheory.Preadditive D] (G : C â¥¤ D) [G.additive] (X : CategoryTheory.SimplicialObject C) (q n : â„•) : (algebraic_topology.dold_kan.HÏƒ q).f n = G.map ((algebraic_topology.dold_kan.HÏƒ q).f n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type uâ‚} [CategoryTheory.Category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) : CategoryTheory.IsCofiltered D
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M â†’* P} (H : c â‰¤ Con.ker f) (g : c.quotient â†’* P) (Hg : g.comp c.mk' = f) : g = c.lift f H
(G : Type u_1) [Group G] (n : â„•) (x : G) : x âˆˆ upperCentralSeries G (n + 1) â†” âˆ€ (y : G), x * y * xâ»Â¹ * yâ»Â¹ âˆˆ upperCentralSeries G n
(p : â„•) [Fact (Nat.Prime p)] (a b : â„¤) : Zmod.legendreSym p (a * b) = Zmod.legendreSym p a * Zmod.legendreSym p b
{V : Type u_9} {K : Type u_10} [Field K] [AddCommGroup V] [Module K V] {B : BilinForm K V} {x : V} (hx : Â¬B.is_IsOrtho x x) : is_HasCompl (Submodule.span K {x}) (B.orthogonal (Submodule.span K {x}))
{R : Type u_1} {a b : R} [Semigroup R] (rra : IsRightRegular a) (rrb : IsRightRegular b) : IsRightRegular (a * b)
(Î± : Type u) [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] [TopologicalSpace.SeparableSpace Î±] [Nontrivial Î±] : âˆƒ (s : Set Î±), s.countable âˆ§ Dense s âˆ§ (âˆ€ (x : Î±), IsBot x â†’ x âˆ‰ s) âˆ§ âˆ€ (x : Î±), IsTop x â†’ x âˆ‰ s
{C : Type uâ‚} [CategoryTheory.Category C] {B A : C} {X : CategoryTheory.Subobject B} (f : A âŸ¶ B) [CategoryTheory.Mono f] (i : â†‘X â‰… A) (w : i.hom â‰« f = X.arrow) : X = CategoryTheory.Subobject.mk f
{C : Type uâ‚} [CategoryTheory.Category C] {J : Type uâ‚‚} [CategoryTheory.Category J] (F : J â¥¤ Cáµ’áµ–) [CategoryTheory.Limits.HasLimit F.left_Op] : CategoryTheory.Limits.HasColimit F
(E : Type u_1) [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] : âˆƒ (Î´ : â„), 0 < Î´ âˆ§ Î´ < 1 âˆ§ âˆ€ (s : Finset E), (âˆ€ (c : E), c âˆˆ s â†’ âˆ¥câˆ¥ â‰¤ 2) â†’ (âˆ€ (c : E), c âˆˆ s â†’ âˆ€ (d : E), d âˆˆ s â†’ c â‰  d â†’ 1 - Î´ â‰¤ âˆ¥c - dâˆ¥) â†’ s.card â‰¤ Besicovitch.multiplicity E
{p k : â„•} (hk : k â‰  0) (hp : Nat.Prime p) : (p ^ k).factors.to_Finset = {p}
{Î± : Type u} [pseudoEmetricSpace Î±] {x y : Î±} {s : Set Î±} (hx : x âˆˆ s) (hy : y âˆˆ s) : HasEdist.edist x y â‰¤ Emetric.diam s
{C : Type uâ‚} [CategoryTheory.Category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚â‚ƒ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚‚â‚ƒ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚â‚ƒ} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚‚â‚ƒ} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚â‚ƒ : Xâ‚â‚ƒ âŸ¶ Xâ‚‚â‚ƒ} (s : CategoryTheory.IsPullback (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)) (p : hâ‚â‚ â‰« vâ‚â‚‚ = vâ‚â‚ â‰« hâ‚‚â‚) (t : CategoryTheory.IsPullback hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚) : CategoryTheory.IsPullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚
{Î± : Type u_1} {c : Set (Set Î±)} (H : âˆ€ (a : Î±), âˆƒ! (b : Set Î±) (H : b âˆˆ c), a âˆˆ b) : c.pairwise_Disjoint Id
{x : â„} (hx : 0 < x) : 0 < expNegInvGlue x
{p : â„•} [hp : Fact (Nat.Prime p)] {k : Type u_1} [Field k] [Char_p k p] [PerfectRing k p] : DiscreteValuationRing (WittVector p k)
(k : Type uâ‚) {G : Type uâ‚‚} [Semiring k] [hasAdd G] {A : Type uâ‚ƒ} [NonUnitalNonAssocSemiring A] [DistribMulAction k A] {Ï†â‚ Ï†â‚‚ : AddMonoidAlgebra k G â†’â‚™â‚[k] A} (h : Ï†â‚.to_Mul_hom.comp (AddMonoidAlgebra.ofMagma k G) = Ï†â‚‚.to_Mul_hom.comp (AddMonoidAlgebra.ofMagma k G)) : Ï†â‚ = Ï†â‚‚
{Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : Finset.filter p s = s
{a b : Cardinal} : Cardinal.aleph_0 â‰¤ a * b â†” a â‰  0 âˆ§ b â‰  0 âˆ§ (Cardinal.aleph_0 â‰¤ a âˆ¨ Cardinal.aleph_0 â‰¤ b)
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {X X' Y Y' Z Z' : C} [CategoryTheory.ExactPairing Y Y'] (f : X âŸ¶ Z âŠ— Y') (g : X' âŸ¶ Z') : â‡‘((CategoryTheory.tensorRightHomEquiv (X' âŠ— X) Y Y' (Z' âŠ— Z)).symm) ((g âŠ— f) â‰« (Î±_ Z' Z Y').inv) = (Î±_ X' X Y).hom â‰« (g âŠ— â‡‘((CategoryTheory.tensorRightHomEquiv X Y Y' Z).symm) f)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [BaireSpace Î±] [Encodable Î²] {f : Î² â†’ Set Î±} (hc : âˆ€ (s : Î²), is_IsClosed (f s)) (hU : (â‹ƒ (s : Î²), f s) = Set.Univ) : Dense (â‹ƒ (s : Î²), Interior (f s))
{Î± : Type u_1} {E : Type u_3} [semiNormedGroup E] {f : Î± â†’ E} {g : Î± â†’ â„} {tâ‚€ : Filter Î±} (h : âˆ€ (n : Î±), âˆ¥f nâˆ¥ â‰¤ g n) (h' : Filter.Tendsto g tâ‚€ (nhds 0)) : Filter.Tendsto f tâ‚€ (nhds 0)
(f : â„• â†’ Nnreal) : Filter.Tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) Filter.atTop (nhds 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (b : CategoryTheory.Limits.BinaryBicone X Y) (Total : b.fst â‰« b.inl + b.snd â‰« b.inr = ðŸ™ b.X) : CategoryTheory.Limits.HasBinaryBiproduct X Y
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} [discreteTopology â†¥s] {x : Î±} (hx : x âˆˆ s) : âˆƒ (U : Set Î±) (H : U âˆˆ nhds x), U âˆ© s = {x}
{Î± : Type u} {Î² : Type v} [completeLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [completeLinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {Î¹ : sort u_1} {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : ContinuousAt f (infi g)) (Mf : Monotone f) (ftop : f âŠ¤ = âŠ¤) : f (infi g) = infi (f âˆ˜ g)
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] [AddGroup Î±] [UniformAddGroup Î±] {hom : Type u_3} [uniformSpace Î²] [discreteTopology Î²] [AddGroup Î²] [UniformAddGroup Î²] [addMonoidHomClass hom Î± Î²] {f : hom} : UniformContinuous â‡‘f â†” is_IsOpen â†‘(â†‘f.ker)
{Î± : Type u} [topologicalSpace Î±] {Z a b : Set Î±} (h : is_IsClopen Z) (cover : Z âŠ† a âˆª b) (ha : is_IsOpen a) (hb : is_IsOpen b) (hab : a âˆ© b = âˆ…) : is_IsClopen (Z âˆ© a)
{Î¹ : Type u_1} {Î± : Type u_2} [hasZero Î±] {s : Finset Î¹} {f : Î¹ â†’â‚€ Î±} {t : Î¹ â†’â‚€ Finset Î±} (ht : t.support âŠ† s) : f âˆˆ s.finsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘f i âˆˆ â‡‘t i
(X : Type u) (Y : Type v) [metricSpace X] [CompactSpace X] [Nonempty X] [metricSpace Y] [CompactSpace Y] [Nonempty Y] : Isometry (Gromov_Hausdorff.optimal_GH_injr X Y)
{Î± : Type u_1} {E : Î± â†’ Type u_2} [Î  (i : Î±), NormedGroup (E i)] {p q : Ennreal} (hpq : p.to_real.is_conjugate_exponent q.to_Real) (f : â†¥(Lp E p)) (g : â†¥(Lp E q)) : Summable (Î» (i : Î±), âˆ¥â‡‘f iâˆ¥ * âˆ¥â‡‘g iâˆ¥) âˆ§ âˆ‘' (i : Î±), âˆ¥â‡‘f iâˆ¥ * âˆ¥â‡‘g iâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥gâˆ¥
{R : Type u_1} [AddLeftCancelSemigroup R] (g : R) : IsAddLeftRegular g
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] (h : âˆ€ (x y : E), âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†’ SameRay â„ x y) : StrictConvexSpace â„ E
{s : â„‚} (hs : 0 < s.re) {X : â„} (hX : 0 â‰¤ X) : (s + 1).partial_gamma X = s * s.partial_gamma X - â†‘(Real.exp (-X)) * â†‘X ^ s
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) (y : E) : HasFpowerSeriesOnBall (Î» (z : E), f (z - y)) p (x + y) r
{Î± : Type u_1} [CanonicallyOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {b c : Î±} [ContravariantClass Î± Î± Add.add LE.le] (h : c â‰¤ b) (a : Î±) : a + b - c = a + (b - c)
(n : â„•) (x : â„) (hx : 0 < x) : HasDerivAt (expNegInvGlue.fAux n) (Polynomial.eval x (expNegInvGlue.pAux (n + 1)) * Real.exp (-xâ»Â¹) / x ^ (2 * (n + 1))) x
{C : Type u} [CategoryTheory.Category C] (F G : CategoryTheory.Discrete PEmpty â¥¤ C) : F = G
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) (p q : Submodule R (CliffordAlgebra Q)) : Submodule.map CliffordAlgebra.reverse (p * q) = Submodule.map CliffordAlgebra.reverse q * Submodule.map CliffordAlgebra.reverse p
{Î¹ : Type u_1} [Fintype Î¹] : StdSimplex â„ Î¹ âŠ† Metric.ClosedBall 0 1
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] : reflection âŠ¥ = LinearIsometryEquiv.neg ð•œ
{E : Type u_1} [AddCommGroup E] [Module â„ E] {s : Set E} {x : E} : gauge s x = HasInf.inf {r âˆˆ Set.Ioi 0 | râ»Â¹ â€¢ x âˆˆ s}
{R : Type u_1} [CommSemiring R] {A : Type u_2} [CommSemiring A] [Algebra R A] {M : Type u_3} [AddCommMonoid M] [Module A M] [Module R M] {D1 D2 : Derivation R A M} (s : Set A) (hs : Algebra.adjoin R s = âŠ¤) (h : Set.EqOn â‡‘D1 â‡‘D2 s) : D1 = D2
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] (d : â„) (s : Set X) : â‡‘(MeasureTheory.Measure.hausdorffMeasure d) s = â¨† (r : Ennreal) (hr : 0 < r), â¨… (t : â„• â†’ Set X) (hts : s âŠ† â‹ƒ (n : â„•), t n) (ht : âˆ€ (n : â„•), Emetric.diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (h : (t n).nonempty), Emetric.diam (t n) ^ d
{x y z : Pgame} (hâ‚ : x â‰¤ y) (hâ‚‚ : y.lf z) : x.lf z
{Î± : Type u} [LinearOrder Î±] {a b c : Î±} : Set.Interval a c âŠ† Set.Interval a b âˆª Set.Interval b c
{R : Type u_1} [linearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [FiniteDimensional R M] (x : Orientation R M Î¹) (f : M â‰ƒâ‚—[R] M) (h : Fintype.card Î¹ = FiniteDimensional.finrank R M) : â‡‘(Orientation.map Î¹ f) x = (â‡‘LinearEquiv.det f)â»Â¹ â€¢ x
{H : Type u_1} [topologicalSpace H] (G : StructureGroupoid H) {M : Type u_2} [topologicalSpace M] [chartedSpace H M] [HasGroupoid M G] {e e' : localHomeomorph M H} (hE : e âˆˆ ChartedSpace.Atlas H M) (hE' : e' âˆˆ ChartedSpace.Atlas H M) : e.symm.trans e' âˆˆ G
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Î± : Type u_1} [Fintype Î±] [Field Î±] : IsPrimePow (Fintype.card Î±)
{ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [NormedGroup G] [normedSpace ð•œ G] {f f' : ð•œ â†’ G} {s : Set ð•œ} {C : Nnreal} (hs : Convex â„ s) (hF : âˆ€ (x : ð•œ), x âˆˆ s â†’ HasDerivWithinAt f (f' x) s x) (bound : âˆ€ (x : ð•œ), x âˆˆ s â†’ âˆ¥f' xâˆ¥â‚Š â‰¤ C) : LipschitzOnWith C f s
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : (-o).oangle x y = -o.oangle x y
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [AddCommMonoid Î±] {f : Î² â†’ Î±} {g : Î³ â†’ Î±} (h_Eq : âˆ€ (u : Finset Î³), âˆƒ (v : Finset Î²), âˆ€ (v' : Finset Î²), v âŠ† v' â†’ (âˆƒ (u' : Finset Î³), u âŠ† u' âˆ§ u'.sum (Î» (x : Î³), g x) = v'.sum (Î» (b : Î²), f b))) : Filter.map (Î» (s : Finset Î²), s.sum (Î» (b : Î²), f b)) Filter.atTop â‰¤ Filter.map (Î» (s : Finset Î³), s.sum (Î» (x : Î³), g x)) Filter.atTop
{G : Type u_3} [Group G] : group.fg G â†” monoid.fg G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q) (x y : â†¥P) : â‡‘f x = â‡‘f y â†’ (âˆƒ (z : â†¥P), â‡‘f z = 0 âˆ§ âˆ€ (R : C) (g : P âŸ¶ R), â‡‘g y = 0 â†’ â‡‘g z = â‡‘g x)
(p : â„•) [p_Prime : Fact (Nat.Prime p)] {q : â„š} (hq : q â‰  0) {k : â„•} : padicValRat p (q ^ k) = â†‘k * padicValRat p q
 : fourier_subalgebra.topological_Closure = âŠ¤
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] (x : ð•œ) {ð•œ' : Type u_1} [nondiscreteNormedField ð•œ'] [NormedAlgebra ð•œ ð•œ'] [normedSpace ð•œ' F] [isScalarTower ð•œ ð•œ' F] {h : ð•œ â†’ ð•œ'} {h' : ð•œ'} {gâ‚ : ð•œ' â†’ F} {gâ‚' : F} (hg : HasDerivAt gâ‚ gâ‚' (h x)) (hH : HasDerivAt h h' x) : HasDerivAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x
{f : â„ â†’ â„} (hF : Differentiable â„ f) (hF'_Mono : StrictMono (deriv f)) : StrictConvexOn â„ Set.Univ f
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚} (hD : âˆ€á¶  (z : â„‚) in nhdsWithin c {c}á¶œ, DifferentiableAt â„‚ f z) (ho : (Î» (z : â„‚), f z - f c) =o[nhdsWithin c {c}á¶œ] Î» (z : â„‚), (z - c)â»Â¹) : Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds (lim (nhdsWithin c {c}á¶œ) f))
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a : Î±} : 0 < -a â†’ a < 0
{E : â„• â†’ Type u_1} [Î  (n : â„•), topologicalSpace (E n)] [âˆ€ (n : â„•), discreteTopology (E n)] {s : Set (Î  (n : â„•), E n)} (hs : is_IsClosed s) (hne : s.nonempty) : âˆƒ (f : (Î  (n : â„•), E n) â†’ Î  (n : â„•), E n), (âˆ€ (x : Î  (n : â„•), E n), x âˆˆ s â†’ f x = x) âˆ§ Set.Range f = s âˆ§ Continuous f
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] [Algebra K S] (pB : powerBasis K S) : â‡‘(Algebra.norm K) pb.gen = (-1) ^ pb.dim * (minpoly K pb.gen).coeff 0
{M : Type u_2} {Î± : sort u_4} [CommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop) (hpâ‚€ : p 1) (hpâ‚ : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) (hpâ‚‚ : âˆ€ (i : Î±), p (f i)) : p (finprod (Î» (i : Î±), f i))
{F : Type u_3} [innerProductSpace â„ F] {K : Set F} (NE : K.nonempty) (hâ‚ : IsComplete K) (hâ‚‚ : Convex â„ K) (u : F) : âˆƒ (v : F) (H : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (w : â†¥K), âˆ¥u - â†‘wâˆ¥
{F : Type u_3} [innerProductSpace â„ F] (x y : F) : HasInner.inner x y = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] [NormedGroup F] [normedSpace â„ F] [measurableSpace E] [BorelSpace E] [TopologicalSpace.SecondCountableTopology F] (f : E â†’ F) (s : Set E) (f' : E â†’ (E â†’L[â„] F)) (hF' : âˆ€ (x : E), x âˆˆ s â†’ HasFderivWithinAt f (f' x) s x) (r : (E â†’L[â„] F) â†’ Nnreal) (rpos : âˆ€ (A : E â†’L[â„] F), r A â‰  0) : âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ (E â†’L[â„] F)), Pairwise (Disjoint on t) âˆ§ (âˆ€ (n : â„•), MeasurableSet (t n)) âˆ§ (s âŠ† â‹ƒ (n : â„•), t n) âˆ§ (âˆ€ (n : â„•), ApproximatesLinearOn f (A n) (s âˆ© t n) (r (A n))) âˆ§ (s.nonempty â†’ âˆ€ (n : â„•), âˆƒ (y : E) (H : y âˆˆ s), A n = f' y)
{B : Type u_2} {F : Type u_3} [topologicalSpace B] [topologicalSpace F] : IsTopologicalFiberBundle F Prod.snd
{p : â„•} (hp : Nat.Prime p) {n : â„•} (hn : 0 < n) : (p ^ n).totient = p ^ (n - 1) * (p - 1)
(X : Top) (T : Type u) : (X.presheaf_to_Type T).is_sheaf
 : Filter.Tendsto (Î» (x : â„), x ^ (1 / x)) Filter.atTop (nhds 1)
(K : Type u) [Field K] (V : Type v) [AddCommGroup V] [Module K V] [FiniteDimensional K V] : (LinearMap.rtensor (Module.Dual K V) (contractLeft K V)).comp ((TensorProduct.assoc K (Module.Dual K V) V (Module.Dual K V)).symm.to_Linear_map.comp (LinearMap.ltensor (Module.Dual K V) (coevaluation K V))) = (TensorProduct.lid K (Module.Dual K V)).symm.to_Linear_map.comp (TensorProduct.rid K (Module.Dual K V)).to_Linear_Map
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²) (h : (Set.Range f).finite) : (â‹ƒ (a : Î±), â†‘(f a)).finite
{Î± : Type u_1} {Î² : Type u_3} [measurableSpace Î±] [measurableSpace Î²] {Î½ : MeasureTheory.Measure Î²} [MeasureTheory.SigmaFinite Î½] {f : Î± Ã— Î² â†’ Ennreal} (hF : Measurable f) : Measurable (Î» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½)
{Î± : Type u_1} [DecidableEq Î±] {s t : Finset Î±} (h : s âŠ† t) : (Finset.ico s t).card = 2 ^ (t.card - s.card) - 1
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [is_IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) : (minpoly A x).coeff 0 = 0 â†” x = 0
{Î¹ : Type u} {f g : Î¹ â†’ â„} {p : â„} (hp : 1 â‰¤ p) (hF : âˆ€ (i : Î¹), 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) {A B : â„} (hA : 0 â‰¤ A) (hB : 0 â‰¤ B) (hfA : HasSum (Î» (i : Î¹), f i ^ p) (A ^ p)) (hgB : HasSum (Î» (i : Î¹), g i ^ p) (B ^ p)) : âˆƒ (C : â„), 0 â‰¤ C âˆ§ C â‰¤ A + B âˆ§ HasSum (Î» (i : Î¹), (f i + g i) ^ p) (C ^ p)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [normedSpace ð•œ E] [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ G} {s : Set E} {x y : E} (hs : Convex â„ s) (hF : DifferentiableOn ð•œ f s) (hF' : âˆ€ (x : E), x âˆˆ s â†’ fderivWithin ð•œ f s x = 0) (hx : x âˆˆ s) (hy : y âˆˆ s) : f x = f y
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (iâ‚€ : Î¹) : vectorSpan k (Set.Range p) = Submodule.span k (Set.Range (Î» (i : {x // x â‰  iâ‚€}), p â†‘i -áµ¥ p iâ‚€))
{C : Type uâ‚} [CategoryTheory.Category C] {Z X Y : C} {c : CategoryTheory.Limits.BinaryCofan X Y} (h : CategoryTheory.Limits.IsColimit c) (t : CategoryTheory.Limits.IsInitial Z) : CategoryTheory.IsPushout (t.to ((CategoryTheory.Limits.pair X Y).obj {as := CategoryTheory.Limits.WalkingPair.left})) (t.to ((CategoryTheory.Limits.pair X Y).obj {as := CategoryTheory.Limits.WalkingPair.right})) c.inl c.inr
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] [Nontrivial R] {Î¹ : Type w} (b : Basis Î¹ R M) {Îº : Type w'} (v : Îº â†’ M) (i : LinearIndependent R v) (m : i.maximal) : (â‹ƒ (k : Îº), â†‘((â‡‘(b.repr) (v k)).support)) = Set.Univ
(C : Type (u+1)) [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] (D : Type (u+1)) [CategoryTheory.Category D] [CategoryTheory.ConcreteCategory D] [CategoryTheory.forgetâ‚‚ C D] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] : CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forgetâ‚‚ C D)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ F} {s : Set E} (g : F â†’L[ð•œ] G) (h : AnalyticOn ð•œ f s) : AnalyticOn ð•œ (â‡‘g âˆ˜ f) s
{ð•œ : Type u_1} [linearOrderedField ð•œ] [topologicalSpace ð•œ] [OrderTopology ð•œ] {s : Set ð•œ} : StrictConvex ð•œ s â†” Convex ð•œ s
{M : Type u_1} [monoidWithZero M] {Ï†â‚ Ï†â‚‚ : â„¤ â†’*â‚€ M} (h_Neg_One : â‡‘Ï†â‚ (-1) = â‡‘Ï†â‚‚ (-1)) (h_Pos : âˆ€ (n : â„•), 0 < n â†’ â‡‘Ï†â‚ â†‘n = â‡‘Ï†â‚‚ â†‘n) : Ï†â‚ = Ï†â‚‚
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasTerminal C] : CategoryTheory.Limits.HasFiniteProducts C
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Pretopology.toGrothendieck C âŠ¥ = âŠ¥
{Î¹ : Type u} (s : Finset Î¹) {f g : Î¹ â†’ â„} {p : â„} (hp : 1 â‰¤ p) (hF : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ g i) : s.sum (Î» (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), g i ^ p) ^ (1 / p)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s1 s2 : AffineSubspace k P) : s1 < s2 â†” s1 â‰¤ s2 âˆ§ âˆƒ (p : P) (H : p âˆˆ s2), p âˆ‰ s1
{Î± : Type u_1} {Î² : Type u_2} {f g : Î± â†’ Î²} {m : measurableSpace Î±} [topologicalSpace Î²] {p : Î± â†’ Prop} {_x : DecidablePred p} (hp : MeasurableSet {a : Î± | p a}) (hF : MeasureTheory.StronglyMeasurable f) (hg : MeasureTheory.StronglyMeasurable g) : MeasureTheory.StronglyMeasurable (Î» (x : Î±), Ite (p x) (f x) (g x))
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s : AffineSubspace k P) : affineSpan k â†‘s = s
{Î± : Type u_1} {n : Type u_4} {m : Type u_5} [hasZero Î±] {A : Matrix m m Î±} {D : Matrix n n Î±} (ha : A.is_diag) (hD : D.is_diag) : (Matrix.fromBlocks A 0 0 D).is_diag
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {b : M} [linearOrderedCommRing M] (hb : Fintype.card Î² â€¢ b < â†‘(Fintype.card Î±)) : âˆƒ (y : Î²), b < â†‘((Finset.filter (Î» (x : Î±), f x = y) Finset.univ).card)
{G : Type u_10} [AddGroup G] (a : G) : â‡‘(Equiv.symm (equiv.add_Right a)) = Î» (x : G), x + -a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (sâ‚‚ : Finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘((Finset.map e sâ‚‚).affine_combination p) w = â‡‘(sâ‚‚.affine_combination (p âˆ˜ â‡‘e)) (w âˆ˜ â‡‘e)
{Î± : Type u} {Î² : Type v} [completeLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [completeLinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {Î¹ : sort u_1} [Nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : ContinuousAt f (infi g)) (Mf : Monotone f) : f (â¨… (i : Î¹), g i) = â¨… (i : Î¹), f (g i)
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î± â†’ Î² Ã— Î³} (hF : Continuous f) : Continuous (Î» (a : Î±), (f a).fst)
{Î± : Type u} [Preorder Î±] {a b : Î±} : a â‰¤ b â†’ Â¬b â‰¤ a â†’ a < b
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Abelian V] {A B C D A' B' C' D' : V} {f : A âŸ¶ B} {g : B âŸ¶ C} {h : C âŸ¶ D} {f' : A' âŸ¶ B'} {g' : B' âŸ¶ C'} {h' : C' âŸ¶ D'} {Î± : A âŸ¶ A'} {Î² : B âŸ¶ B'} {Î³ : C âŸ¶ C'} {Î´ : D âŸ¶ D'} (commâ‚ : Î± â‰« f' = f â‰« Î²) (commâ‚‚ : Î² â‰« g' = g â‰« Î³) (commâ‚ƒ : Î³ â‰« h' = h â‰« Î´) (hfg : CategoryTheory.Exact f g) (hgh : CategoryTheory.Exact g h) (hF'g' : CategoryTheory.Exact f' g') (hÎ± : CategoryTheory.Epi Î±) (hÎ² : CategoryTheory.Mono Î²) (hÎ´ : CategoryTheory.Mono Î´) : CategoryTheory.Mono Î³
{R : Type u_1} [linearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [FiniteDimensional R M] (x : Orientation R M Î¹) (f : M â‰ƒâ‚—[R] M) (h : Fintype.card Î¹ = FiniteDimensional.finrank R M) : â‡‘(Orientation.map Î¹ f) x = x â†” 0 < â‡‘LinearMap.det â†‘f
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Î¹ â†’ Set P) : affineSpan k (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), affineSpan k (s i)
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (u : RË£) (hu : 0 < â†‘u) (v : Module.Ray R M) : u â€¢ v = v
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} {x : Î±} (Fin : Emetric.hausdorffEdist s t â‰  âŠ¤) : Metric.infDist x t â‰¤ Metric.infDist x s + Metric.hausdorffDist s t
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {n : â„•} (s : Affine.Simplex k P n) (i : Fin (n + 1)) : s.face _ = Affine.Simplex.mkOfPoint k (s.points i)
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [pseudoEmetricSpace Î±] [topologicalSpace Î²] [pseudoEmetricSpace Î³] (f : Î± Ã— Î² â†’ Î³) {s : Set Î±} {t : Set Î²} (K : Nnreal) (ha : âˆ€ (a : Î±), a âˆˆ s â†’ ContinuousOn (Î» (y : Î²), f (a, y)) t) (hb : âˆ€ (b : Î²), b âˆˆ t â†’ LipschitzOnWith K (Î» (x : Î±), f (x, b)) s) : ContinuousOn f (s Ã—Ë¢ t)
{Î± : Type u} [DecidableEq Î±] (i j : Î±) : Function.involutive (Î» (_x : Equiv.perm Î±), _x * equiv.swap i j)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (f : C(Î±, Î²)) (x : Î±) : ContinuousAt â‡‘f x
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±} (h : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) â‰  0) : s.nonempty
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x y : E) : â‡‘is_R_or_C.re (HasInner.inner x y) = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
{Î¹ : Type u_1} {Î± : Type u_3} [Preorder Î¹] [LinearOrder Î±] {u : Î¹ â†’ Î±} (h : Monotone u) (H : Â¬BddBelow (Set.Range u)) : Filter.Tendsto u Filter.atBot Filter.atBot
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : Cáµ’áµ–} (f : X âŸ¶ Y) [CategoryTheory.IsIso (Category_theory.coyoneda.map f)] : CategoryTheory.IsIso f
{M : Type u_3} [AddMonoid M] [Preorder M] [CovariantClass M M (Function.swap Add.add) LE.le] [CovariantClass M M Add.add LE.le] {lâ‚ lâ‚‚ : List M} (h : lâ‚ <+ lâ‚‚) (hâ‚ : âˆ€ (a : M), a âˆˆ lâ‚‚ â†’ 0 â‰¤ a) : lâ‚.sum â‰¤ lâ‚‚.sum
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} {T : addSubmonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [AddCommMonoid Q] {k : T.localization_Map Q} (z : N) (u : Q) : â‡‘(f.map hy k) z = u â†” â‡‘(k.to_Map) (â‡‘g (f.sec z).fst) = â‡‘(k.to_Map) (â‡‘g â†‘((f.sec z).snd)) + u
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {n : WithTop â„•} (h : ContDiffOn ð•œ n f s) (hs : UniqueDiffOn ð•œ s) (hn : 1 â‰¤ n) : ContinuousOn (Î» (p : E Ã— E), â‡‘(fderivWithin ð•œ f s p.fst) p.snd) (s Ã—Ë¢ Set.Univ)
{Î± : Type u_1} {Î¹ : Type u_4} [topologicalSpace Î±] {s : Set Î¹} (hs : s.finite) {f : Î¹ â†’ Set Î±} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ is_GÎ´ (f i)) : is_GÎ´ (â‹ƒ (i : Î¹) (H : i âˆˆ s), f i)
{Î± : Type u} [NonUnitalNonAssocRing Î±] (k : Î±) (h : âˆ€ (x : Î±), x * k = 0 â†’ x = 0) : IsRightRegular k
{C : Type uâ‚} [CategoryTheory.Category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {X : C} (R : CategoryTheory.Presieve X) [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Presieve.IsSheafFor P R â†” Nonempty (CategoryTheory.Limits.IsLimit (Category_theory.limits.fork.of_Î¹ (CategoryTheory.Equalizer.forkMap P R) _))
{Î± : Type u_1} [CircularPreorder Î±] {a b c : Î±} (h : HasBtw.Btw a b c) : HasBtw.Btw c a b
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) {râ‚ râ‚‚ : â„} : 2 â€¢ o.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
{Î± : Type u_1} {a b c : Î±} [LinearOrder Î±] [AddCommSemigroup Î±] [HasSub Î±] [HasOrderedSub Î±] (h : a - c < b - c) : a < b
{Î± : Type u} [LinearOrder Î±] (a b : Î±) : Linear_order.min a b = a âˆ§ a â‰¤ b âˆ¨ Linear_order.min a b = b âˆ§ b < a
{x y : Pgame} : x â‰¤ y â†” (âˆ€ (i : x.left_moves), (âˆƒ (i' : y.left_moves), x.move_Left i â‰¤ y.move_Left i') âˆ¨ âˆƒ (j : (x.move_Left i).right_moves), (x.move_Left i).move_Right j â‰¤ y) âˆ§ âˆ€ (j : y.right_moves), (âˆƒ (i : (y.move_Right j).left_moves), x â‰¤ (y.move_Right j).move_Left i) âˆ¨ âˆƒ (j' : x.right_moves), x.move_Right j' â‰¤ y.move_Right j
{R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} [linearOrderedField R] [AddCommGroup E] [Module R E] (s : Finset Î¹) (wâ‚ wâ‚‚ : Î¹ â†’ R) (z : Î¹ â†’ E) (hwâ‚ : s.sum (Î» (i : Î¹), wâ‚ i) = 1) (hwâ‚‚ : s.sum (Î» (i : Î¹), wâ‚‚ i) = 1) (a b : R) (hab : a + b = 1) : a â€¢ s.center_mass wâ‚ z + b â€¢ s.center_mass wâ‚‚ z = s.center_mass (Î» (i : Î¹), a * wâ‚ i + b * wâ‚‚ i) z
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} : StrictConvexOn ð•œ s f â†” Convex ð•œ s âˆ§ âˆ€ â¦ƒx y z : ð•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) < (f z - f y) / (z - y)
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} : Emetric.hausdorffEdist s t = 0 â†” Closure s = Closure t
{Î± : Type u} [topologicalSpace Î±] [LocallyCompactSpace Î±] [t2_Space Î±] (x : Î±) : âˆƒ (U : Set Î±), is_IsOpen U âˆ§ x âˆˆ U âˆ§ is_IsCompact (Closure U)
{Î± : Type u_1} [PartialOrder Î±] {f : Î± â†’ Î±} {p : Î± â†’ Prop} {hF : âˆ€ (x : Î±), x â‰¤ f x} {hfp : âˆ€ (x : Î±), p (f x)} {hmin : âˆ€ â¦ƒx y : Î±â¦„, x â‰¤ y â†’ p y â†’ f x â‰¤ y} {x y : Î±} (hxy : x â‰¤ y) (hy : p y) : â‡‘(ClosureOperator.mkâ‚ƒ f p hF hfp hmin) x â‰¤ y
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {f : M â†’* N} (hF : âˆ€ (y : â†¥S), IsUnit (â‡‘f â†‘y)) {y z : â†¥S} (h : (â‡‘(IsUnit.liftRight (f.restrict S) hF) y)â»Â¹ = (â‡‘(IsUnit.liftRight (f.restrict S) hF) z)â»Â¹) : â‡‘f â†‘y = â‡‘f â†‘z
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [divisionMonoid Î²] (f : Î± â†’* Î²) (g : Î±) (n : â„¤) : â‡‘f (g ^ n) = â‡‘f g ^ n
{Î± : Type u} [topologicalSpace Î±] {f : Filter Î±} (h : âˆƒ (a : Î±), f â‰¤ nhds a) : f â‰¤ nhds (lim f)
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [Module ð•œ E] {s : Set E} (hs : Convex ð•œ s) (z : E) : Convex ð•œ ((Î» (x : E), x + z) â»Â¹' s)
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [LinearOrder Î²] [succOrder Î²] [IsSuccArchimedean Î²] {s : Î² â†’ Set Î±} {t : Set Î²} (ht : t.ord_connected) (H : âˆ€ (n : Î²), n âˆˆ t â†’ IsPreconnected (s n)) (K : âˆ€ (n : Î²), n âˆˆ t â†’ Order.succ n âˆˆ t â†’ (s n âˆ© s (Order.succ n)).nonempty) : IsPreconnected (â‹ƒ (n : Î²) (H : n âˆˆ t), s n)
(R : Type u) (L : Type v) [CommRing R] [LieRing L] [lieAlgebra R L] [LieAlgebra.IsNilpotent R L] : (â¨… (x : L), (â‡‘(LieAlgebra.ad R L) x).maximal_generalized_eigenspace 0) = âŠ¤
{Î± : Type u} {n : â„•} (a : Array n Î±) : a.to_List = List.ofFn a.read
 : Filter.Tendsto Real.log Filter.atTop Filter.atTop
{Î± : Type u} [pseudoMetricSpace Î±] {u : â„• â†’ Î±} (hu : CauchySeq u) : âˆƒ (R : â„) (H : R > 0), âˆ€ (m n : â„•), HasDist.dist (u m) (u n) < R
{R : Type u_1} [CommRing R] (hR : DiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R) [is_IsDomain R] : UniqueFactorizationMonoid R
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] (r : Î± â†’ Î² â†’ Prop) [Î  (a : Î±), Fintype â†¥(Rel.Image r {a})] : (âˆ€ (A : Finset Î±), A.card â‰¤ Fintype.card â†¥(Rel.Image r â†‘A)) â†” âˆƒ (f : Î± â†’ Î²), Function.Injective f âˆ§ âˆ€ (x : Î±), r x (f x)
{K : Type u_1} [linearOrderedField K] [floorRing K] (v : K) : (GeneralizedContinuedFraction.IntFractPair.stream v).is_Seq
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {f : â„ â†’ E} {g : â„ â†’ F} {a b c : â„} (hne : a â‰  b) (hc : c âˆˆ Set.Interval a b) (h_deriv : âˆ€á¶  (x : â„) in nhdsWithin c (Set.Interval a b  {c}), DifferentiableAt â„ f x) (h_infty : Filter.Tendsto (Î» (x : â„), âˆ¥f xâˆ¥) (nhdsWithin c (Set.Interval a b  {c})) Filter.atTop) (hg : deriv f =O[nhdsWithin c (Set.Interval a b  {c})] g) : Â¬IntervalIntegrable g MeasureTheory.MeasureSpace.volume a b
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [Module ð•œ Î²] (f : E â†’â‚—[ð•œ] Î²) {s : Set E} (hs : Convex ð•œ s) : ConvexOn ð•œ s â‡‘f
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : â†‘r < p.radius) : âˆƒ (a : â„) (H : a âˆˆ Set.Ioo 0 1), (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =o[Filter.atTop] Pow.pow a
{Î± : Type u_1} {p : Î± â†’ Prop} (s : Finset {x // p x}) {a : Î±} (h : Â¬p a) : a âˆ‰ Finset.map (Function.Embedding.subtype (Î» (x : Î±), p x)) s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {j j' : C} (f f' : j âŸ¶ j') : f â‰« CategoryTheory.IsFiltered.coeqHom f f' = f' â‰« CategoryTheory.IsFiltered.coeqHom f f'
{p : â„•} [p_Prime : Fact (Nat.Prime p)] {b : â„•} (Dvd : p âˆ£ b) : padicValNat p (b / p) = padicValNat p b - 1
{F : Type u_2} [NormedGroup F] [normedSpace â„ F] {x y : F} : SameRay â„ x y â†” x = 0 âˆ¨ y = 0 âˆ¨ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [Semiring Î±] [AddGroup Î²] (h : Function.Antiperiodic f c) : Function.Periodic f (2 * c)
{R : Type u_2} {M : Type u_3} [AddCommGroup M] [Ring R] [Module R M] {B : BilinForm R M} (hB : B.to_quadratic_form.anisotropic) : B.nondegenerate
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) {p : P} (hp : p âˆˆ affineSpan â„ (Set.Range s.points)) {r : â„} (hr : âˆ€ (i : Fin (n + 1)), HasDist.dist (s.points i) p = r) : r = s.circumradius
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Kâ‚ Kâ‚‚ : Submodule ð•œ E} [FiniteDimensional ð•œ â†¥Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) : FiniteDimensional.finrank ð•œ â†¥Kâ‚ + FiniteDimensional.finrank ð•œ â†¥(Kâ‚á—® âŠ“ Kâ‚‚) = FiniteDimensional.finrank ð•œ â†¥Kâ‚‚
{M : Type u_1} [Monoid M] {Î¹ : sort u_2} {s : Î¹ â†’ Set M} (h : âˆ€ (y : Î¹), IsSubmonoid (s y)) : IsSubmonoid (Set.Inter s)
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), IsAddUnit (â‡‘g â†‘y)) {x y : M} (h : â‡‘(f.to_Map) x = â‡‘(f.to_Map) y) : â‡‘g x = â‡‘g y
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) : Subsemiring.closure â†‘s = s
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (x : M) : SameRay R x x
{Î± : Type u_1} {M : Type u_5} {R : Type u_11} {S : Type u_12} [hasZero M] [Semiring R] [Semiring S] (h : R â†’+* S) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ R) : â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
{Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ Set Î±} (hs : IndexedPartition s) (x : Î±) : â‡‘(hs.out) (hs.proj x) = hs.some (hs.index x)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [SemilatticeSup Î²] {f g : Î± â†’ Î²} (hF : Monotone f) (hg : Monotone g) : Monotone (f âŠ” g)
{Î± : Type u_1} : Subsingleton (Option Î±) â†” isEmpty Î±
{Î¹ : Type u_1} (f g : Î¹ â†’ Cardinal) (H : âˆ€ (i : Î¹), f i < g i) : Cardinal.sum f < Cardinal.prod g
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : 2 â€¢ o.oangle (-x) y = 2 â€¢ o.oangle x y
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {t : CategoryTheory.Limits.Cocone F} (h : CategoryTheory.Limits.IsColimit t) (s : CategoryTheory.Limits.Cocone F) : âˆƒ! (d : t.X âŸ¶ s.X), âˆ€ (j : J), t.Î¹.app j â‰« d = s.Î¹.app j
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [linearOrderedAddCommGroup Î±] [Archimedean Î±] (h : Function.Periodic f c) (hc : 0 < c) (x a : Î±) : âˆƒ (y : Î±) (H : y âˆˆ Set.Ioc a (a + c)), f x = f y
{R : Type u_1} [CommSemiring R] {R' : Type u_2} [Monoid R'] {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N] [DistribMulAction R' M] [DistribMulAction R' N] [TensorProduct.CompatibleSmul R R' M N] (r : R') (m : M) (n : N) : (r â€¢ m) âŠ—â‚œ[R] n = m âŠ—â‚œ[R] (r â€¢ n)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {K : Set (E â†’L[ð•œ] F)} (hK : IsComplete K) : FderivMeasurableAux.D f K âŠ† {x : E | DifferentiableAt ð•œ f x âˆ§ fderiv ð•œ f x âˆˆ K}
{Î± : Type u} [pseudoEmetricSpace Î±] {s : Set Î±} (hs : s.subsingleton) : Emetric.diam s = 0
{K : Type u} [Field K] {Î¹ : sort u_1} [hÎ¹ : Nonempty Î¹] {S : Î¹ â†’ Subfield K} (hS : Directed LE.le S) {x : K} : (x âˆˆ â¨† (i : Î¹), S i) â†” âˆƒ (i : Î¹), x âˆˆ S i
{Î± : Type u_1} {Î² : Type u_2} {m : measurableSpace Î±} {f : MeasureTheory.Filtration â„• m} {u : â„• â†’ Î± â†’ Î²} {Ï„ : Î± â†’ â„•} [AddCommMonoid Î²] [topologicalSpace Î²] [HasContinuousAdd Î²] (hu : MeasureTheory.Adapted f u) (hÏ„ : MeasureTheory.IsStoppingTime f Ï„) : MeasureTheory.Adapted f (MeasureTheory.stoppedProcess u Ï„)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{V : Type u_4} [innerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V) : (âˆ€ (x : V), HasInner.inner (â‡‘T x) x = 0) â†” T = 0
{Î± : Type u_1} {Î² : Type u_2} [t : topologicalSpace Î±] [PolishSpace Î±] [measurableSpace Î±] [BorelSpace Î±] [tÎ² : topologicalSpace Î²] [TopologicalSpace.SecondCountableTopology Î²] [measurableSpace Î²] [BorelSpace Î²] {f : Î± â†’ Î²} (hF : Measurable f) : âˆƒ (t' : topologicalSpace Î±), t' â‰¤ t âˆ§ Continuous f âˆ§ PolishSpace Î±
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹} [topologicalSpace Î±] (h : TendstoUniformly F f p) (hc : âˆ€á¶  (n : Î¹) in p, Continuous (F n)) [p.ne_IsBot] : Continuous f
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [NormedGroup G] [normedSpace ð•œ G] (q : FormalMultilinearSeries ð•œ F G) (p : FormalMultilinearSeries ð•œ E F) (hq : 0 < q.radius) (hp : 0 < p.radius) : âˆƒ (r : Nnreal) (H : r > 0), Summable (Î» (i : Î£ (n : â„•), Composition n), âˆ¥q.comp_along_Composition p i.sndâˆ¥â‚Š * r ^ i.fst)
{R : Type u_1} [Rack R] {x y z : R} : Shelf.act x (Shelf.act y z) = Shelf.act (Shelf.act x y) z â†” Shelf.act x z = z
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) : â‡‘f 0 = 0
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) : 0 = 1 â†” â‡‘f 1 = 0
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) {r : â„} (hr : r â‰  0) : 2 â€¢ o.oangle (r â€¢ x) y = 2 â€¢ o.oangle x y
(z w : â„‚) : Complex.abs (z + w) â‰¤ Complex.abs z + Complex.abs w
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] (a : Î±) {b : Î±} : 0 < b â†’ a - b < a
{a : â„} {l : Filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Iio a), HasDerivAt f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Iio a), HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Iio a), g' x â‰  0) (hfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0)) (hga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), f' x / g' x) (nhdsWithin a (Set.Iio a)) l) : Filter.Tendsto (Î» (x : â„), f x / g x) (nhdsWithin a (Set.Iio a)) l
{G : Type u_1} [Group G] (tG : monoid.is_torsion G) (bounded : (Set.Range (Î» (g : G), orderOf g)).finite) : monoid.exponent_exists G
(ð•œ : Type u_1) [nondiscreteNormedField ð•œ] {E : Type u_2} [semiNormedGroup E] [normedSpace ð•œ E] [ProperSpace ð•œ] (x' : NormedSpace.Dual ð•œ E) (r : â„) : is_IsCompact (â‡‘WeakDual.toNormedDual â»Â¹' Metric.ClosedBall x' r)
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Fintype Î¹] (b : Basis Î¹ R M) (x : Î¹ â†’ R) : â‡‘(b.equiv_fun.symm) x = finset.univ.sum (Î» (i : Î¹), x i â€¢ â‡‘b i)
{Î± : Type u} [pseudoEmetricSpace Î±] {s : Set Î±} (NE : s.nonempty) : Emetric.hausdorffEdist s âˆ… = âŠ¤
{a : Prop} : Â¬Â¬a â†” a
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) {r : â„} : 2 â€¢ hb.oangle (r â€¢ x) x = 0
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} : StrictAnti f â†’ StrictMono (f âˆ˜ â‡‘OrderDual.ofDual)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e e' : localHomeomorph Î± Î²} (h : e â‰ˆ e') : e.to_local_equiv.source = e'.to_local_equiv.source
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F G : J â¥¤ C} [CategoryTheory.Limits.HasColimit F] (Î± : G â‰… F) : CategoryTheory.Limits.HasColimit G
(Î± : Type u) [t : topologicalSpace Î±] [TopologicalSpace.SeparableSpace Î±] [Nonempty Î±] : âˆƒ (u : â„• â†’ Î±), DenseRange u
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [FiniteDimensional ð•œ E] (K : Submodule ð•œ E) : FiniteDimensional.finrank ð•œ â†¥K + FiniteDimensional.finrank ð•œ â†¥Ká—® = FiniteDimensional.finrank ð•œ E
{Î± : Type u_1} {Î¹ : Type u_3} {m : measurableSpace Î±} [Preorder Î¹] {ð’¢ : MeasureTheory.Filtration Î¹ m} {Ï„ Î· : Î± â†’ Î¹} {i : Î¹} {s : Set Î±} [DecidablePred (Î» (_x : Î±), _x âˆˆ s)] (hÏ„_st : MeasureTheory.IsStoppingTime ð’¢ Ï„) (hÎ·_st : MeasureTheory.IsStoppingTime ð’¢ Î·) (hÏ„ : âˆ€ (x : Î±), i â‰¤ Ï„ x) (hÎ· : âˆ€ (x : Î±), i â‰¤ Î· x) (hs : MeasurableSet s) : MeasureTheory.IsStoppingTime ð’¢ (s.piecewise Ï„ Î·)
{V : Type u_1} {P : Type u_2} [NormedGroup V] [normedSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s u : Set P} (hu : is_IsOpen u) (hsu : s âŠ† u) (hne : s.nonempty) (h : AffineIndependent â„ Coe) : âˆƒ (t : Set P), s âŠ† t âˆ§ t âŠ† u âˆ§ AffineIndependent â„ Coe âˆ§ affineSpan â„ t = âŠ¤
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (v : M) {r : R} (h : 0 â‰¤ r) : SameRay R v (r â€¢ v)
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i j k : D.to_glue_data.J) (U : TopologicalSpace.Opens â†¥((D.to_glue_data.U i).carrier)) : D.opens_image_preimage_Map i j U â‰« (D.to_glue_data.f j k).c.app (Opposite.op ((TopologicalSpace.Opens.map (D.to_glue_data.Î¹ j).base).obj (_.functor.obj U))) = (CategoryTheory.Limits.pullback.fst â‰« D.to_glue_data.t j i â‰« D.to_glue_data.f i j).c.app (Opposite.op U) â‰« _.inv_App (Opposite.unop ((TopologicalSpace.Opens.map (CategoryTheory.Limits.pullback.fst â‰« D.to_glue_data.t j i â‰« D.to_glue_data.f i j).base).op.obj (Opposite.op U))) â‰« (D.to_glue_data.V (j, k)).presheaf.map (CategoryTheory.eqToHom _)
{Î± : Type u_1} {E : Type u_3} [semiNormedGroup E] {f : Î± â†’ E} {g : Î± â†’ â„} {tâ‚€ : Filter Î±} (h : âˆ€á¶  (n : Î±) in tâ‚€, âˆ¥f nâˆ¥ â‰¤ g n) (h' : Filter.Tendsto g tâ‚€ (nhds 0)) : Filter.Tendsto f tâ‚€ (nhds 0)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} : StrictMono f â†’ StrictAnti (f âˆ˜ â‡‘OrderDual.ofDual)
(G : Type u_1) [CommGroup G] : monoid.is_torsion_free (G â§¸ torsion G)
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [AddCommMonoid Î²] [AddCommMonoid Î³] (g : Î² â‰ƒ+ Î³) (f : Î± â†’ Î²) (s : Finset Î±) : â‡‘g (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), â‡‘g (f x))
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = Real.pi) : HasDist.dist p1 p2 â‰  0
{G : Type u} [Group G] {x : G} : IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : ContinuousMultilinearMap ð•œ E G) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.sum (Î» (i : Î¹), finset.univ.prod (Î» (j : Î¹), Ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (Linear_order.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
{f : â„‚ â†’ â„‚} {c z : â„‚} {R : â„} (hD : DifferentiableOn â„‚ f (Metric.Ball c R)) (h_maps : Set.MapsTo f (Metric.Ball c R) (Metric.Ball c R)) (hc : f c = c) (hz : z âˆˆ Metric.Ball c R) : HasDist.dist (f z) c â‰¤ HasDist.dist z c
(A : Type w) (B : Type uâ‚) (C : Type u_1) [CommRing A] [CommRing B] [CommRing C] [Algebra A B] [Algebra B C] [Algebra A C] [isScalarTower A B C] [IsNoetherianRing A] (hAC : âŠ¤.fg) (hBC : âŠ¤.fg) (hBCi : Function.Injective â‡‘(algebraMap B C)) : âŠ¤.fg
{Î± : Type u_1} {M : Type u_5} [hasZero M] (a : Î±) : Function.Injective (Finsupp.single a)
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [subtractionMonoid Î²] (f : Î± â†’+ Î²) (a : Î±) : â‡‘f (-a) = -â‡‘f a
(R : Type u) (L : Type v) (M : Type w) [CommRing R] [LieRing L] [lieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [lieModule R L M] : LieModule.IsNilpotent R L M â†” âˆƒ (k : â„•), LieModule.lowerCentralSeries R L M k = âŠ¥
{E : Type u_2} [semiNormedGroup E] [normedSpace â„ E] {s t : Set E} (disj : Disjoint s t) (hsâ‚ : Convex â„ s) (hsâ‚‚ : is_IsCompact s) (htâ‚ : Convex â„ t) (htâ‚‚ : is_IsClosed t) : âˆƒ (u v : Set E), is_IsOpen u âˆ§ is_IsOpen v âˆ§ Convex â„ u âˆ§ Convex â„ v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint u v
{R : Type u} {M : Type v} [CommRing R] [Nontrivial R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] (f : M â†’â‚—[R] M) (k : â„•) : f ^ k = â‡‘(Polynomial.aeval f) (Polynomial.x ^ k %â‚˜ f.charpoly)
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix m n Î±) (B : Matrix n n Î±) [Invertible B] : (A.mul B).mul (â…Ÿ B) = A
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} {s : Set Î±} : x âˆˆ Closure s â†” Emetric.infEdist x s = 0
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [denselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [topologicalSpace Î´] [OrderClosedTopology Î´] {f : Î± â†’ Î´} (hF : Continuous f) (h_Top : Filter.Tendsto f Filter.atBot Filter.atTop) (h_IsBot : Filter.Tendsto f Filter.atTop Filter.atBot) : Function.Surjective f
{Î± : Type u} [topologicalSpace Î±] {s U : Set Î±} (h : U âˆˆ â¨† (x : Î±) (H : x âˆˆ s), nhds x) : âˆƒ (V : Set Î±), s âŠ† V âˆ§ is_IsOpen V âˆ§ V âŠ† U
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [addCancelCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [HasScalar ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : StrictConcaveOn ð•œ s f) (c : E) : StrictConcaveOn ð•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] (x : K) : â‡‘(Algebra.trace K L) (â‡‘(algebraMap K L) x) = FiniteDimensional.finrank K L â€¢ x
{n : â„•} (hpos : 0 < n) : Irreducible (Polynomial.cyclotomic n â„š)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : hb.oangle x (x - y) = hb.oangle (y - x) y
{Î± : Type u_1} {Î² : Type u_3} {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : IsPiSystem C) (hD : IsPiSystem D) : IsPiSystem (Set.image2 HasSetProd.prod C D)
{ð•‚ : Type u_1} [nondiscreteNormedField ð•‚] [CompleteSpace ð•‚] (h : 0 < (expSeries ð•‚ ð•‚).radius) : HasStrictDerivAt (Exp ð•‚) 1 0
{ð•œ : Type u_1} {A : Type u_2} [nondiscreteNormedField ð•œ] [normedRing A] [NormedAlgebra ð•œ A] [CompleteSpace A] {a : A} {r : Nnreal} (hr : â†‘r < (spectralRadius ð•œ a)â»Â¹) : DifferentiableOn ð•œ (Î» (z : ð•œ), Ring.inverse (1 - z â€¢ a)) (Metric.ClosedBall 0 â†‘r)
{Î± : Type u_1} {Î² : Type u_2} {t : Î±} {ts ys : List Î±} {r : List Î²} (f : List Î± â†’ Î²) : (List.permutationsAux2 t List.nil r ys (Î» (x : List Î±), f (x ++ ts))).snd = (List.permutationsAux2 t ts r ys f).snd
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : Relation.Fibration (Relation.GameAdd (Relation.CutExpand r) (Relation.CutExpand r)) (Relation.CutExpand r) (Î» (s : Multiset Î± Ã— Multiset Î±), s.fst + s.snd)
{n p : â„•} : List.count p n.factors = â‡‘(n.factorization) p
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{Î± : Type u} {Î² : Type v} [Preorder Î±] [LinearOrder Î²] {f g : Î± â†’ Î²} (hF : Antitone f) (hg : Antitone g) : Antitone (Î» (x : Î±), Linear_order.min (f x) (g x))
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : (f =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f =o[l] g'
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {s : Set ð•œ} {n : WithTop â„•} (Hcont : âˆ€ (m : â„•), â†‘m â‰¤ n â†’ ContinuousOn (Î» (x : ð•œ), iteratedDerivWithin m f s x) s) (Hdiff : âˆ€ (m : â„•), â†‘m < n â†’ DifferentiableOn ð•œ (Î» (x : ð•œ), iteratedDerivWithin m f s x) s) : ContDiffOn ð•œ n f s
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 : P) {p2 p3 p4 : P} (h : EuclideanGeometry.angle p2 p3 p4 = Real.pi) : EuclideanGeometry.angle p1 p2 p3 = EuclideanGeometry.angle p1 p2 p4
{Î± : Type u_1} {Î¼â‚ Î¼â‚‚ : MeasureTheory.OuterMeasure Î±} (h : âˆ€ (s : Set Î±), s.nonempty â†’ â‡‘Î¼â‚ s = â‡‘Î¼â‚‚ s) : Î¼â‚ = Î¼â‚‚
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [CommMonoid Î²] {s : Finset Î³} {t : Finset Î±} {f : Î³ â†’ Î± â†’ Î²} : (s.product t).prod (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = s.prod (Î» (x : Î³), t.prod (Î» (y : Î±), f x y))
{X : Top} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] (F : Top.Presheaf C X) : F.is_sheaf â†” F.is_sheaf_preservesLimit_Pairwise_intersections
{V : Type u_1} [innerProductSpace â„ V] (x y : V) {r : â„} (hr : r < 0) : InnerProductGeometry.angle (r â€¢ x) y = InnerProductGeometry.angle (-x) y
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (E : D â¥¤ C) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasLimitsOfShape J C] : CategoryTheory.Limits.HasLimitsOfShape J D
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} : Antitone f â†’ Monotone (f âˆ˜ â‡‘OrderDual.ofDual)
{Î± : Type u} [metricSpace Î±] [ProperSpace Î±] {R : Î± â†’ â„} (hR : âˆ€ (x : Î±), 0 < R x) : âˆƒ (Î¹ : Type u) (c : Î¹ â†’ Î±) (r r' : Î¹ â†’ â„), (âˆ€ (i : Î¹), 0 < r i âˆ§ r i < r' i âˆ§ r' i < R (c i)) âˆ§ LocallyFinite (Î» (i : Î¹), Metric.Ball (c i) (r' i)) âˆ§ (â‹ƒ (i : Î¹), Metric.Ball (c i) (r i)) = Set.Univ
{G : Type u} [Group G] [Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G} (hH : Fintype.card â†¥H = p ^ n) : Fintype.card (â†¥(H.normalizer) â§¸ Subgroup.comap H.normalizer.subtype H) â‰¡ Fintype.card (G â§¸ H) [Mod p]
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {s : Set E} {x : E} : MdifferentiableWithinAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f s x â†’ DifferentiableWithinAt ð•œ f s x
{z : â„‚} (hz : 0 < z.re) : ContinuousAt (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.snd) (0, z)
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), IsAddUnit (â‡‘g â†‘y)) (z : N) : â‡‘g â†‘((f.sec z).snd) + â‡‘(f.lift hg) z = â‡‘g (f.sec z).fst
{f : â„• â†’â‚€ â„•} (hF : âˆ€ (p : â„•), p âˆˆ f.support â†’ Nat.Prime p) : (f.prod Pow.pow).factorization = f
(Î¹ : Type u_1) [Fintype Î¹] : is_IsCompact (StdSimplex â„ Î¹)
{X : Type u} {Y : Type v} [metricSpace X] [CompactSpace X] [Nonempty X] [metricSpace Y] [CompactSpace Y] [Nonempty Y] : GromovHausdorff.hD (Gromov_Hausdorff.candidates_b_dist X Y) â‰¤ Metric.diam Set.Univ + 1 + Metric.diam Set.Univ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] {P Q : C} (f : P âŸ¶ Q) : CategoryTheory.Abelian.factorThruImage f â‰« CategoryTheory.Abelian.imageÎ¹ f = f
{Î± : Type u} [Preorder Î±] {s : Set Î±} : Â¬BddAbove s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬y â‰¤ x
{x y z : â„¤} : PythagoreanTriple x y z â†” PythagoreanTriple y x z
{X : Type u_2} [emetricSpace X] {s : Set X} (hs : s.finite) : dimH s = 0
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] {Î¹ : Type u_2} (s : Finset Î¹) (f : Î¹ â†’ Ideal R) (e : Î¹ â†’ â„•) (Prime : âˆ€ (i : Î¹), i âˆˆ s â†’ _root_.prime (f i)) (IsCoprime : âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ i â‰  j â†’ f i â‰  f j) : s.inf (Î» (i : Î¹), f i ^ e i) = s.prod (Î» (i : Î¹), f i ^ e i)
{R : Type u_1} [linearOrderedField R] [floorRing R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : r â‰¤ â†‘b ^ x â†” Int.clog b r â‰¤ x
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (P : Cáµ’áµ– â¥¤ A) {X : C} (S : CategoryTheory.Sieve X) : Nonempty (CategoryTheory.Limits.IsLimit (P.map_cone S.arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), CategoryTheory.Presieve.IsSheafFor (P â‹™ Category_theory.coyoneda.obj E) â‡‘S
{ð•œ : Type u_1} [linearOrderedField ð•œ] {x y : ð•œ} (h : x â‰¤ y) {z : ð•œ} : z âˆˆ Set.Icc x y â†” âˆƒ (a b : ð•œ), 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {A B C : V} (f : A âŸ¶ B) [CategoryTheory.Limits.HasImage f] (g : B âŸ¶ C) [CategoryTheory.Limits.HasKernel g] (w : f â‰« g = 0) [CategoryTheory.Limits.HasCokernel (imageToKernel f g w)] {D : V} {k k' : homology f g w âŸ¶ D} (p : homologyÏ€ f g w â‰« k = homologyÏ€ f g w â‰« k') : k = k'
{G : Type u_1} {H : Type u_2} [AddGroup G] {N : AddSubgroup G} [AddGroup H] {f : G â†’+ H} (hF : Function.Surjective â‡‘f) (hN : N = f.ker) (tN : Add_monoid.is_torsion â†¥N) : Add_monoid.is_torsion H â†” Add_monoid.is_torsion G
{P : â„• â†’ Prop} {m : â„•} (h0 : P m) (h1 : âˆ€ (n : â„•), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„•) : m â‰¤ n â†’ P n
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {p : P} : HasDist.dist p â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p) = 0 â†” p âˆˆ s
{Î± : Type u_2} {Î² : Type u_3} [DecidableEq Î±] [hasVsub Î± Î²] {u : Finset Î±} {s t : Set Î²} : â†‘u âŠ† s -áµ¥ t â†’ (âˆƒ (s' t' : Finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' -áµ¥ t')
{Î± : Type u_1} (P : Î± â†’ Prop) (r : Î± â†’ Î± â†’ Prop) (h : âˆ€ (s : Finset Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ P x) â†’ (âˆƒ (y : Î±), P y âˆ§ âˆ€ (x : Î±), x âˆˆ s â†’ r x y)) : âˆƒ (f : â„• â†’ Î±), (âˆ€ (n : â„•), P (f n)) âˆ§ âˆ€ (m n : â„•), m < n â†’ r (f m) (f n)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [BaireSpace Î±] [Encodable Î²] {f : Î² â†’ Set Î±} (ho : âˆ€ (s : Î²), is_IsOpen (f s)) (hD : âˆ€ (s : Î²), Dense (f s)) : Dense (â‹‚ (s : Î²), f s)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {bâ‚‚ : Basis (Fin 2) â„ V} (hbâ‚‚ : Orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = bâ‚‚.orientation) (Î¸ : Real.Angle) : hb.rotation Î¸ = hbâ‚‚.rotation Î¸
{G : Type u} [AddGroup G] {x : G} : IsOfFinAddOrder (-x) â†” IsOfFinAddOrder x
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] {b : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.some b) : 1 â‰¤ b
{Î± : Type u} [pseudoMetricSpace Î±] (s : Set Î±) : Continuous (Î» (x : Î±), Metric.infDist x s)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) {r : â„} (hx : âˆ¥xâˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : o.oangle y z = 2 â€¢ o.oangle (y - x) (z - x)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) : 2 â€¢ hb.oangle (-x) x = 0
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurableSpace Î±} {mâ‚‚ : measurableSpace Î²} {f : Î± â†’ Î²} : MeasurableSpace.comap f mâ‚‚ â‰¤ mâ‚ â†’ Measurable f
{Î± : Type u_1} [metricSpace Î±] {Î² : Type u} [Nonempty Î²] (p : Besicovitch.TauPackage Î² Î±) (x : Î²) : p.to_ball_package.c x âˆˆ p.Union_Up_to p.last_step
{R : Type u} {S : Type v} [Semiring R] [Semiring S] [Nontrivial S] (f : R â†’+* S) : 1 âˆ‰ f.ker
{Î² : Type u} {Î± : Type v} {s : Finset Î±} [CommMonoid Î²] (f : Î± â†’ Î²) {p : Î± â†’ Prop} [DecidablePred p] : (Finset.subtype p s).prod (Î» (x : Subtype_ p), f â†‘x) = (Finset.filter p s).prod (Î» (x : Î±), f x)
{Î± : Type u} {a b : Î±} [MulZeroClass Î±] [PartialOrder Î±] [ZeroLt.PosMulMono Î±] (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a * b
{X Y S : Top} {f : X âŸ¶ S} {g : Y âŸ¶ S} (Hâ‚ : OpenEmbedding â‡‘f) (Hâ‚‚ : OpenEmbedding â‡‘g) : OpenEmbedding â‡‘(CategoryTheory.Limits.limitÏ€ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s1 s2 : AffineSubspace k P) : s1.direction âŠ” s2.direction â‰¤ (s1 âŠ” s2).direction
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} (hF : Differentiable â„‚ f) (z : â„‚) : AnalyticAt â„‚ f z
(M : Type u_1) (N : Type u_2) (Î± : Type u_3) [HasScalar M Î±] [HasScalar N Î±] [SmulCommClass M N Î±] : SmulCommClass N M Î±
(M : Type u_1) (Î± : Type u_2) [Monoid M] [mulAction M Î±] {Î¹ : sort u_3} {s : Î¹ â†’ Set Î±} : fixingSubmonoid M (â‹ƒ (i : Î¹), s i) = â¨… (i : Î¹), fixingSubmonoid M (s i)
(E : Type u_1) [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] : isEmpty (Besicovitch.SatelliteConfig E (Besicovitch.multiplicity E) (besicovitch.good_Ï„ E))
 : Filter.Tendsto (Î» (N : â„•), FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {x : E} {n : â„•} : ContDiffAt ð•œ â†‘(n + 1) f x â†” âˆƒ (f' : E â†’ (E â†’L[ð•œ] F)), (âˆƒ (u : Set E) (H : u âˆˆ nhds x), âˆ€ (x : E), x âˆˆ u â†’ HasFderivAt f (f' x) x) âˆ§ ContDiffAt ð•œ â†‘n f' x
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.FinitePresentation R A â†’ Algebra.FiniteType R A
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (p : Î¹ â†’ P) (j : Î¹) (wâ‚ wâ‚‚ : Î¹ â†’ k) (hw : âˆ€ (i : Î¹), i â‰  j â†’ wâ‚ i = wâ‚‚ i) : â‡‘(s.weighted_vsub_of_point p (p j)) wâ‚ = â‡‘(s.weighted_vsub_of_point p (p j)) wâ‚‚
{n : â„•} {a b : Fin n} : â†‘a < â†‘b â†” a < b
{G : Type u_1} [Group G] (K : Subgroup G) {k : Set G} : Subgroup.closure k â‰¤ K â†” k âŠ† â†‘K
{Î± : Type u_1} [linearOrderedAddCommGroup Î±] {n : â„¤} {a b : Î±} (hn : n â‰  0) : n â€¢ a = n â€¢ b â†” a = b
(p : â„•) [hp : Fact (Nat.Prime p)] (q r : â„š) : padicNorm p (q / r) = padicNorm p q / padicNorm p r
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) : deriv (Î» (u : â„), âˆ« (x : â„) in u..b, f x) a = -c
{Î³ : Type u_1} [NonUnitalNonAssocSemiring Î³] (x : Î³) : IsAddMonoidHom (Î» (y : Î³), y * x)
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {X Y : C} (f : Y âŸ¶ X) (S : CategoryTheory.Sieve X) : Jâ‚.is_IsClosed S â†’ Jâ‚.is_IsClosed (CategoryTheory.Sieve.pullback f S)
{R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] [RingHomSurjective Ïƒâ‚â‚‚] (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) (s : Set M) (N : Submodule Râ‚‚ Mâ‚‚) : Submodule.map f (Submodule.span R s) â‰¤ N â†” âˆ€ (m : M), m âˆˆ s â†’ â‡‘f m âˆˆ N
{M : Type u_1} [MulOneClass M] {s : Set M} {p : M â†’ M â†’ Prop} {x y : M} (hx : x âˆˆ Submonoid.closure s) (hy : y âˆˆ Submonoid.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ p x y) (H1_Left : âˆ€ (x : M), p 1 x) (H1_Right : âˆ€ (x : M), p x 1) (HMul_Left : âˆ€ (x y z : M), p x z â†’ p y z â†’ p (x * y) z) (HMul_Right : âˆ€ (x y z : M), p z x â†’ p z y â†’ p z (x * y)) : p x y
(M : Type u_1) {Î± : Type u_6} [Monoid M] [mulAction M Î±] (aâ‚ aâ‚‚ : M) : HasScalar.smul aâ‚ âˆ˜ HasScalar.smul aâ‚‚ = HasScalar.smul (aâ‚ * aâ‚‚)
{R : Type u} [Ring R] (s : Subring R) {x : R} : x âˆˆ s â†’ -x âˆˆ s
{Î± : Type u} [PartialOrder Î±] {a b : Î±} : a â‰¤ b â†’ a < b âˆ¨ a = b
 : UniqueDiffOn â„ (Set.Icc 0 1)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f g : E â†’ Î²} (hF : StrictConcaveOn ð•œ s f) (hg : StrictConcaveOn ð•œ s g) : StrictConcaveOn ð•œ s (f âŠ“ g)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall f p x r) (h : â†‘r' < r) : TendstoUniformlyOn (Î» (n : â„•) (y : E), p.partial_Sum n (y - x)) f Filter.atTop (Metric.Ball x â†‘r')
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {Î¹ : Type u_1} (b : Basis Î¹ R M) [Infinite Î¹] {Îº : Type u_1} (v : Îº â†’ M) (i : LinearIndependent R v) : Cardinal.mk Îº â‰¤ Cardinal.mk Î¹
(f : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfI : f a = f b) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), IsExtrOn f (Set.Icc a b) c
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscreteNormedField ð•‚] [normedCommRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] [CharZero ð•‚] {x : ð”¸} (hx : x âˆˆ Emetric.Ball 0 (expSeries ð•‚ ð”¸).radius) : HasFderivAt (Exp ð•‚) (Exp ð•‚ x â€¢ 1) x
{k : Type u_1} {M : Type u_2} [orderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] [CovariantClass M M Add.add LT.lt] [ContravariantClass M M Add.add LT.lt] {a b : k} {c d : M} (hba : b < a) (hdc : d < c) : a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d
{X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X} {eâ‚ eâ‚‚ : X} (hâ‚ : EckmannHilton.IsUnital mâ‚ eâ‚) (hâ‚‚ : EckmannHilton.IsUnital mâ‚‚ eâ‚‚) (Distrib : âˆ€ (a b c d : X), mâ‚ (mâ‚‚ a b) (mâ‚‚ c d) = mâ‚‚ (mâ‚ a c) (mâ‚ b d)) : IsCommutative X mâ‚‚
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {c : â„} {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) g â†’ asymptotics.is_O_with c l f' g
{R : Type u} [Semiring R] {M : Polynomial R â†’ Prop} (p : Polynomial R) (h_Add : âˆ€ (p q : Polynomial R), M p â†’ M q â†’ M (p + q)) (h_monomial : âˆ€ (n : â„•) (a : R), M (â‡‘(Polynomial.monomial n) a)) : M p
{a x : â„} (ha : a < 0) : HasStrictDerivAt (Î» (x : â„), a ^ x) (a ^ x * Real.log a - Real.exp (Real.log a * x) * Real.sin (x * Real.pi) * Real.pi) x
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] [LocallyCompactSpace Î±] (a : Î±) : Continuous (Î» (f : C(Î±, Î²)), â‡‘f a)
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] : {x : Î± | âˆƒ (y : Î±), y < x âˆ§ Set.Ioo y x = âˆ…}.countable
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] (f : MultilinearMap R Mâ‚ Mâ‚‚) [Fintype Î¹] (m m' : Î  (i : Î¹), Mâ‚ i) : â‡‘f (m + m') = finset.univ.sum (Î» (s : Finset Î¹), â‡‘f (s.piecewise m m'))
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hab : a â‰¤ b) (hcont : ContinuousOn f (Set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivWithinAt f (f' x) (Set.Ioi x) x) (f'Int : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : âˆ« (y : â„) in a..b, f' y = f b - f a
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [AddCommMonoid Î±] [topologicalSpace Î±] [t2_Space Î±] [Encodable Î³] (m : Set Î² â†’ Î±) (m0 : m âˆ… = 0) (s : Î³ â†’ Set Î²) : âˆ‘' (i : â„•), m (â‹ƒ (b : Î³) (H : b âˆˆ Encodable.decodeâ‚‚ Î³ i), s b) = âˆ‘' (b : Î³), m (s b)
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Vâ‚‚ : Type v'} [AddCommGroup Vâ‚‚] [Module K Vâ‚‚] (f : V â†’â‚—[K] Vâ‚‚) (w : Function.Injective â‡‘f) [FiniteDimensional K Vâ‚‚] : FiniteDimensional K V
{Î± : Type u_1} {Î¹ : Type u_3} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} [Fintype Î¹] {t : Î¹ â†’ Set Î±} (h : Pairwise (Disjoint on t)) (ht : âˆ€ (i : Î¹), (t i).finite) : finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒ (i : Î¹), t i), f a)) = finsum (Î» (i : Î¹), finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ t i), f a)))
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} (hs : Convex ð•œ s) (hF : âˆ€ {x y z : ð•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x)) : ConcaveOn ð•œ s f
{Î± : Type u_1} [topologicalSpace Î±] [measurableSpace Î±] [OpensMeasurableSpace Î±] {s : Set Î±} (hs : MeasurableSet s) (a : Î±) : (nhdsWithin a s).is_measurably_generated
{G : Type u_10} [AddGroup G] (a : G) : â‡‘(Equiv.symm (equiv.add_Left a)) = Add.add (-a)
{J : Type v} {C : Type u} [CategoryTheory.Category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [Nonempty J] {c : CategoryTheory.Limits.Cone (CategoryTheory.Limits.parallelFamily f)} (i : CategoryTheory.Limits.IsLimit c) : CategoryTheory.Mono (CategoryTheory.Limits.TridentÎ¹ c)
(R : Type u) [Semiring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), AddCommMonoid (M i)] [Î  (i : Î¹), Module R (M i)] (i : Î¹) (c : R) (x : M i) : â‡‘(DirectSum.of M i) (c â€¢ x) = c â€¢ â‡‘(DirectSum.of M i) x
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : MultilinearMap ð•œ E G) (C : â„) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : Continuous â‡‘f
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.Full F] [CategoryTheory.Faithful F] {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.IsIso (F.map f)] : CategoryTheory.IsIso f
{E : Type u} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] (f f' : â„ â†’ E) {a b : â„} {s : Set â„} (hs : s.countable) (Hc : ContinuousOn f (Set.Interval a b)) (hD : âˆ€ (x : â„), x âˆˆ Set.Ioo (Linear_order.min a b) (Linear_order.max a b)  s â†’ HasDerivAt f (f' x) x) (Hi : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : âˆ« (x : â„) in a..b, f' x = f b - f a
{Î± : Type u_1} (l : List Î±) (c : Composition l.length) : (l.split_wrt_Composition c).join = l
{Î± : Type u_1} {Î² : Type u_2} [linearOrderedRing Î±] [floorRing Î±] [topologicalSpace Î±] [OrderTopology Î±] [TopologicalAddGroup Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} (h : ContinuousOn f (Set.Icc 0 1)) (hF : f 0 = f 1) : Continuous (f âˆ˜ Int.fract)
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) (hF'' : âˆ€ (x : â„), x âˆˆ Interior D â†’ 0 < deriv^[2] f x) : StrictConvexOn â„ D f
{Î± : Type u_1} [Preorder Î±] [PredOrder Î±] {a b : Î±} [NoMinOrder Î±] : Order.pred a < Order.pred b â†’ a < b
{Î± : Type u_1} [cancelMonoidWithZero Î±] {a b c : Î±} (ha : a â‰  0) : a * b âˆ£ a * c â†” b âˆ£ c
{K : Type u_1} {S : Type u_2} {T : Type u_3} [Field K] [CommRing S] [CommRing T] [Algebra K S] [Algebra K T] [Algebra S T] [isScalarTower K S T] (hST : Function.Injective â‡‘(algebraMap S T)) {x : S} {y : T} (hx : IsIntegral K x) (h : y = â‡‘(algebraMap S T) x) : minpoly K x = minpoly K y
(M : Type u_1) (N : Type u_2) (Î± : Type u_3) [hasVadd M Î±] [hasVadd N Î±] [VaddCommClass M N Î±] : VaddCommClass N M Î±
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {E : Type u_3} [hasNorm E] {F : Type u_4} [hasNorm F] (e : Î± â‰ƒâ‚œ Î²) {b : Î²} {f : Î² â†’ E} {g : Î² â†’ F} {C : â„} : asymptotics.is_O_with C (nhds b) f g â†” asymptotics.is_O_with C (nhds (â‡‘(e.symm) b)) (f âˆ˜ â‡‘e) (g âˆ˜ â‡‘e)
(F : Type u_1) (E : Type u_2) [Field F] [Field E] [Algebra F E] [FiniteDimensional F E] [IsSeparable F E] : âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
{Î“â‚€ : Type u_1} [LinearOrderedCommGroupWithZero Î“â‚€] (Î³ : Î“â‚€Ë£) : nhds â†‘Î³ = Pure.pure â†‘Î³
{Î± : Type u_1} {p : Î± â†’ Prop} (s : Finset {x // p x}) {a : Î±} (h : a âˆˆ Finset.map (Function.Embedding.subtype (Î» (x : Î±), p x)) s) : p a
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G : C â¥¤ D} (h_obj : âˆ€ (X : C), F.obj X = G.obj X) (h_Map : âˆ€ (X Y : C) (f : X âŸ¶ Y), F.map f = CategoryTheory.eqToHom _ â‰« G.map f â‰« CategoryTheory.eqToHom _) : F = G
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {s : Set Î±} {t : Set Î²} {f : Î± â†’ Î²} (h : Set.MapsTo f s t) (hc : Continuous f) : Set.MapsTo f (Closure s) (Closure t)
(ð•œ : Type u_1) {E : Type u_2} [normedField ð•œ] [normedSpace â„ ð•œ] [semiNormedGroup E] [normedSpace ð•œ E] [Module â„ E] [isScalarTower â„ ð•œ E] : LocallyConvexSpace â„ E
{Î± : Type u} [pseudoMetricSpace Î±] [ProperSpace Î±] {x : Î±} {r : â„} {s : Set Î±} (hs : is_IsClosed s) (h : s âŠ† Metric.Ball x r) : âˆƒ (r' : â„) (H : r' < r), s âŠ† Metric.Ball x r'
{X : Type u} {Y : Type v} [topologicalSpace X] [topologicalSpace Y] {fâ‚€ fâ‚ : C(X, Y)} (F : fâ‚€.homotopy fâ‚) : Continuous â‡‘F
{Î± : Type u} [topologicalSpace Î±] {Î¹ : Type u_1} [Nonempty Î¹] {V : Î¹ â†’ Set Î±} (hV : Directed Superset V) (hV_cpct : âˆ€ (i : Î¹), is_IsCompact (V i)) (hV_IsClosed : âˆ€ (i : Î¹), is_IsClosed (V i)) {U : Set Î±} (hU : âˆ€ (x : Î±), (x âˆˆ â‹‚ (i : Î¹), V i) â†’ U âˆˆ nhds x) : âˆƒ (i : Î¹), V i âŠ† U
(X : Type u_2) [topologicalSpace X] [RegularSpace X] [TopologicalSpace.SecondCountableTopology X] : TopologicalSpace.MetrizableSpace X
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x y : R) : v.int_Valuation_def (x + y) â‰¤ Linear_order.max (v.int_Valuation_def x) (v.int_Valuation_def y)
{M : Type u_1} [hasMul M] {S T : Subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
{Î± : Type u} [t : topologicalSpace Î±] [TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±} {a : Set Î¹} (h : a.pairwise_Disjoint s) (ha : âˆ€ (i : Î¹), i âˆˆ a â†’ is_IsOpen (s i)) (h'a : âˆ€ (i : Î¹), i âˆˆ a â†’ (s i).nonempty) : a.countable
{C : Type uâ‚} [CategoryTheory.Category C] {X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) [CategoryTheory.Limits.HasPullback f g] : CategoryTheory.IsPullback CategoryTheory.Limits.pullback.fst CategoryTheory.Limits.pullback.snd f g
{Î± : Type u_1} {f : Î± â†’ Î±} {x y : Î±} {m n : â„•} (hx : Function.IsPeriodicPt f m x) (hy : Function.IsPeriodicPt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y
{Î± : Type u_1} [CommMonoid Î±] (a b u : Î±) (hu : IsUnit u) : a âˆ£ u * b â†” a âˆ£ b
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.PosMulMono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (a0 : 0 < a) : 1 â‰¤ a * b
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] {ifp_n ifp_Succ_n : GeneralizedContinuedFraction.IntFractPair K} (nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n) (Succ_nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = Option.some ifp_Succ_n) : â†‘(ifp_Succ_n.b) â‰¤ (ifp_n.fr)â»Â¹
{p : â„•} (z : â„¤) (hp : p â‰  1) (hz : z â‰  0) : padicValRat p â†‘z = â†‘((multiplicity â†‘p z).get _)
{Î± : Type u_1} {Î² : Type u_2} (rÎ± : Î± â†’ Î± â†’ Prop) (rÎ² : Î² â†’ Î² â†’ Prop) : Relation.GameAdd rÎ± rÎ² â‰¤ Prod.lex rÎ± rÎ²
{Î± : Type u} [topologicalSpace Î±] {s t : Set Î±} (hs : Dense s) (ht : Dense t) (hso : is_IsOpen s) : Dense (s âˆ© t)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {tâ‚ tâ‚‚ : Affine.Triangle â„ P} (h : Set.Range tâ‚.points = Set.Range tâ‚‚.points) : tâ‚.orthocenter = tâ‚‚.orthocenter
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {bâ‚‚ : Basis (Fin 2) â„ V} (hbâ‚‚ : Orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = bâ‚‚.orientation) (x y : V) : hb.oangle x y = hbâ‚‚.oangle x y
{R : Type u_1} {M : Type u_3} {a : R} [Monoid R] [mulAction R M] {n : â„•} (n0 : 0 < n) : IsSmulRegular M (a ^ n) â†” IsSmulRegular M a
{Î± : Type u_1} [pseudoMetricSpace Î±] (r C : â„) (hr : r < 1) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasDist.dist (f n) (f (n + 1)) â‰¤ C * r ^ n) {a : Î±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) (n : â„•) : HasDist.dist (f n) a â‰¤ C * r ^ n / (1 - r)
{R : Type u_1} [CommRing R] (f : Polynomial R) (r : R) : (â‡‘(Polynomial.taylor r) f).sum (Î» (i : â„•) (a : R), â‡‘Polynomial.c a * (Polynomial.x - â‡‘Polynomial.c r) ^ i) = f
{Î± : Type u_1} {Î¹' : sort u_5} [completeLattice Î±] (s : Î¹' â†’ Î±) : (â¨† (i : Î¹'), s i) = â¨† (t : Finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {y : Î± â†’ Î±} {s : Set Î±} (h : s.pairwise_Disjoint (Î» (x : Î±), Set.Ioo x (y x))) (h' : âˆ€ (x : Î±), x âˆˆ s â†’ x < y x) : s.countable
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [OrderedAddCommGroup Î²] [HasScalar ð•œ E] [Module ð•œ Î²] {s : Set E} {f : E â†’ Î²} : StrictConcaveOn ð•œ s f â†’ StrictConvexOn ð•œ s (-f)
{X : Type u} {Y : Type v} [metricSpace X] [metricSpace Y] : Isometry Sum.inr
{M : Type u} [AddZeroClass M] (a : M) : AddSemiconjBy a 0 0
{X : Type u} [Lattice X] [JordanHolderLattice X] {sâ‚ sâ‚‚ : CompositionSeries X} (hl : sâ‚.length = sâ‚‚.length) (h : âˆ€ (i : Fin (sâ‚.length + 1)), â‡‘sâ‚ i = â‡‘sâ‚‚ (â‡‘(fin.cast _) i)) : sâ‚ = sâ‚‚
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {E : Type uâ‚ƒ} [CategoryTheory.Category E] {F : C â¥¤ D} {G : D â¥¤ E} {H : C â¥¤ E} [â„‹ : CategoryTheory.Faithful H] (h : F â‹™ G â‰… H) : CategoryTheory.Faithful F
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {u v : E} (hvm : v âˆˆ K) (hvo : âˆ€ (w : E), w âˆˆ K â†’ HasInner.inner (u - v) w = 0) : â†‘(â‡‘(orthogonalProjection K) u) = v
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (e e' : localHomeomorph Î± Î²) (h : âˆ€ (x : Î±), â‡‘e x = â‡‘e' x) (hinv : âˆ€ (x : Î²), â‡‘(e.symm) x = â‡‘(e'.symm) x) (hs : e.to_local_equiv.source = e'.to_local_equiv.source) : e = e'
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [Module R P] {Î¹ : Type u_1} (b : Basis Î¹ R P) : Module.Projective R P
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} {f : ð•œ â†’ F} : iteratedDeriv (n + 1) f = iteratedDeriv n (deriv f)
(A B : Finset â„•) : A.sum (Î» (i : â„•), 2 ^ i) â‰¤ B.sum (Î» (i : â„•), 2 ^ i) â†” A.to_colex â‰¤ B.to_colex
{Î± : Type u} {a b : Î±} [MulZeroOneClass Î±] [PartialOrder Î±] [ZeroLt.PosMulMono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (a0 : 0 â‰¤ a) : 1 â‰¤ a * b
(x : â„) (h1 : 0 < x) (h2 : x < Real.pi / 2) : x < Real.tan x
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
{G : Type u} [Group G] [Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] (hdvd : p ^ (n + 1) âˆ£ Fintype.card G) {H : Subgroup G} (hH : Fintype.card â†¥H = p ^ n) : âˆƒ (K : Subgroup G), Fintype.card â†¥K = p ^ (n + 1) âˆ§ H â‰¤ K
{R : Type u_1} [CommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {A : Type u_3} [Semiring A] [Algebra R A] {f g : TensorAlgebra R M â†’â‚[R] A} (w : f.to_Linear_map.comp (TensorAlgebraÎ¹ R) = g.to_Linear_map.comp (TensorAlgebraÎ¹ R)) : f = g
{Î± : Type u_2} {Î² : Type u_3} [linearOrderedField Î±] [Archimedean Î±] [linearOrderedField Î²] : Subsingleton (Î± â‰ƒ+*o Î²)
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (T : Type u_4) [CommRing T] [Algebra R T] (M N : Submonoid R) (h : M â‰¤ N) [IsLocalization M S] [IsLocalization N T] [Algebra S T] [isScalarTower R S T] : IsLocalization (Submonoid.map (algebraMap R S).to_MonoidHom N) T
{Î± : Type u_1} {Î¹ : Type u_2} [Encodable Î¹] [t : topologicalSpace Î±] [p : PolishSpace Î±] (m : Î¹ â†’ topologicalSpace Î±) (hm : âˆ€ (n : Î¹), m n â‰¤ t) (h'm : âˆ€ (n : Î¹), PolishSpace Î±) : âˆƒ (t' : topologicalSpace Î±), (âˆ€ (n : Î¹), t' â‰¤ m n) âˆ§ t' â‰¤ t âˆ§ PolishSpace Î±
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) (z : N) : â‡‘g â†‘((f.sec z).snd) * â‡‘(f.lift hg) z = â‡‘g (f.sec z).fst
{M : Type u_1} [hasMul M] (r : M â†’ M â†’ Prop) : conGen r = HasInf.inf {s : Con M | âˆ€ (x y : M), r x y â†’ â‡‘s x y}
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [Module ð•œ Î²] (f : E â†’â‚—[ð•œ] Î²) {s : Set E} (hs : Convex ð•œ s) : ConcaveOn ð•œ s â‡‘f
{Râ‚ : Type u_1} [Semiring Râ‚] {Mâ‚ : Type u_4} [topologicalSpace Mâ‚] [AddCommMonoid Mâ‚] [Module Râ‚ Mâ‚] [topologicalSpace Râ‚] {f g : Râ‚ â‰ƒL[Râ‚] Mâ‚} (h : â‡‘f 1 = â‡‘g 1) : f = g
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} (h : IsLocalExtr f a) : HasFderivAt f f' a â†’ f' = 0
{M : Type u_3} {N : Type u_4} [hasMul M] [hasMul N] {f g : M â†’â‚™* N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
(X : AlgebraicGeometry.RingedSpace) {U : TopologicalSpace.Opens â†¥X} (f : â†¥(X.to_PresheafedSpace.presheaf.obj (Opposite.op U))) : IsUnit (â‡‘(X.to_PresheafedSpace.presheaf.map (CategoryTheory.homOfLe _).op) f)
{Î¹ : sort u_1} [Nonempty Î¹] {f : Î¹ â†’ Ennreal} {x : Ennreal} (h : x â‰  âŠ¤) : infi f * x = â¨… (i : Î¹), f i * x
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {E' : Type u_7} [innerProductSpace ð•œ E'] {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (f : E â‰ƒâ‚—áµ¢[ð•œ] E') : Orthonormal ð•œ (â‡‘f âˆ˜ v)
{a b : Cardinal} : Cardinal.aleph_0 â‰¤ a * b â†” a â‰  0 âˆ§ Cardinal.aleph_0 â‰¤ b âˆ¨ Cardinal.aleph_0 â‰¤ a âˆ§ b â‰  0
{M : Type u_1} [MulOneClass M] (S : Submonoid M) : 1 âˆˆ S
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {Î¹ : Type w} [Fintype Î¹] (h : Basis Î¹ R M) : Module.rank R M = â†‘(Fintype.card Î¹)
{Î± : Type u_1} [CommSemiring Î±] (t : Tree Î±) (râ‚ râ‚‚ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr râ‚ = tactic.ring2.horner_expr.of_csexpr râ‚‚) : tactic.ring2.csring_expr.eval t râ‚ = tactic.ring2.csring_expr.eval t râ‚‚
{k : Type u_1} {M : Type u_2} [orderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] {a : M} {c : k} (hc : c < 0) : 0 < a â†’ c â€¢ a < 0
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : hb.oangle x y + hb.oangle y x = 0
(A : Type u_2) (K : Type u_3) [CommRing A] [Field K] [is_IsDomain A] [Algebra A K] [IsFractionRing A K] {L : Type u_4} [Field L] [Algebra K L] [FiniteDimensional K L] [Algebra A L] [isScalarTower A K L] (s : Finset L) : âˆƒ (y : A) (H : y â‰  0), âˆ€ (x : L), x âˆˆ s â†’ IsIntegral A (y â€¢ x)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e e' : localHomeomorph Î± Î²} (h : e â‰ˆ e') : Set.EqOn â‡‘(e.symm) â‡‘(e'.symm) e.to_local_equiv.target
{Î± : Type u} [pseudoMetricSpace Î±] (p : Î± â†’ Prop) (x : Î±) (H : âˆƒá¶  (R : â„) in Filter.atTop, âˆ€ (y : Î±), y âˆˆ Metric.ClosedBall x R â†’ p y) (y : Î±) : p y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X âŸ¶ Y) [CategoryTheory.Limits.HasCoequalizer f g] : CategoryTheory.Limits.HasCokernel (f - g)
{x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : Fact (Nat.Prime p)] (hxr : x ^ n = â†‘m) (hv : (multiplicity â†‘p m).get _ % n â‰  0) : Irrational x
{k : Type u_1} {M : Type u_2} [orderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] [ContravariantClass M M Add.add LE.le] {a b : k} {c d : M} (hab : a â‰¤ b) (hcd : c â‰¤ d) : a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d
{R : Type u} [CommRing R] [is_IsDomain R] (hR : DiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R) : DiscreteValuationRing R
(ð•œ : Type u_2) [is_R_or_C ð•œ] (E : Type u_3) [innerProductSpace ð•œ E] [cplt : CompleteSpace E] : âˆƒ (w : Set E) (b : HilbertBasis â†¥w ð•œ E), â‡‘b = Coe
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {s : Set (E Ã— F)} {p : E Ã— F} : ContDiffWithinAt ð•œ n Prod.snd s p
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {Î¹' : Type u_3} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (f : Î¹' â†’ Î¹) (hF : Function.Injective f) : Orthonormal ð•œ (v âˆ˜ f)
(R : Type u) (L : Type v) (M : Type w) [CommRing R] [LieRing L] [lieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [lieModule R L M] [LieModule.IsNilpotent R L M] : (â¨… (x : L), (â‡‘(LieModule.toEndomorphism R L M) x).maximal_generalized_eigenspace 0) = âŠ¤
{R : Type u_1} [NonAssocSemiring R] [Nontrivial R] (hR : ringChar R â‰  2) : 2 â‰  0
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : ContinuousMultilinearMap ð•œ E G) (m : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâˆ¥â‚Š â‰¤ âˆ¥fâˆ¥â‚Š * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥â‚Š)
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] {Vâ‚‚ : Type v'} [AddCommGroup Vâ‚‚] [Module K Vâ‚‚] [FiniteDimensional K V] (f : V â†’â‚—[K] Vâ‚‚) : FiniteDimensional.finrank K â†¥(f.range) + FiniteDimensional.finrank K â†¥(f.ker) = FiniteDimensional.finrank K V
{M : Type u_2} {Î± : sort u_4} [AddCommMonoid M] {f : Î± â†’ M} (p : M â†’ Prop) (hpâ‚€ : p 0) (hpâ‚ : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (hpâ‚‚ : âˆ€ (i : Î±), p (f i)) : p (finsum (Î» (i : Î±), f i))
{Î± : Type u_1} [topologicalSpace Î±] [BaireSpace Î±] {f : â„• â†’ Set Î±} (ho : âˆ€ (n : â„•), is_IsOpen (f n)) (hD : âˆ€ (n : â„•), Dense (f n)) : Dense (â‹‚ (n : â„•), f n)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} (a : Î±) (b : Î²) (i : Î¹) : (Filter.map (Î» (_x : Î±), b) (Filter.principal {a})).coprod (Filter.map Id (Filter.principal {i})) = Filter.principal ({b} Ã—Ë¢ Set.Univ âˆª Set.Univ Ã—Ë¢ {i})
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (Î¸â‚ Î¸â‚‚ : Real.Angle) : (hb.rotation Î¸â‚).trans (hb.rotation Î¸â‚‚) = hb.rotation (Î¸â‚‚ + Î¸â‚)
{C : Type uâ‚} [CategoryTheory.Category C] {Z X Y : C} (f : Z âŸ¶ X) (g : Z âŸ¶ Y) [CategoryTheory.Limits.HasPushout f g] : CategoryTheory.IsPushout f g CategoryTheory.Limits.pushout.inl CategoryTheory.Limits.pushout.inr
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.FiniteType R A â†” âˆƒ (s : Finset A) (f : MvPolynomial {x // x âˆˆ s} R â†’â‚[R] A), Function.Surjective â‡‘f
{X Y : CompHaus} (f : X âŸ¶ Y) (bij : Function.bijective â‡‘f) : CategoryTheory.IsIso f
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (h : s.finite) : Metric.Bounded s
{Î± : Type u_3} {Î² : Type u_4} [linearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto f l Filter.atTop) : Filter.Tendsto (Î» (x : Î²), f x * r) l Filter.atTop
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (pâ‚ : Î¹ â†’ P) (pâ‚‚ : P) (h : s.sum (Î» (i : Î¹), w i) = 1) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.affine_combination pâ‚) w -áµ¥ pâ‚‚
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) : â‡‘LinearEquiv.det hb.conj_lie.to_linearEquiv = -1
{ð•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_8} {Pâ‚‚ : Type u_9} [normedField ð•œ] [semiNormedGroup V] [semiNormedGroup Vâ‚‚] [normedSpace ð•œ V] [normedSpace ð•œ Vâ‚‚] [pseudoMetricSpace P] [pseudoMetricSpace Pâ‚‚] [NormedAddTorsor V P] [NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ð•œ] Pâ‚‚} : Continuous â‡‘(f.linear) â†” Continuous â‡‘f
(k : â„•) {r : â„} (hr : 0 â‰¤ r) (h'r : r < 1) : Filter.Tendsto (Î» (n : â„•), â†‘n ^ k * r ^ n) Filter.atTop (nhds 0)
{Î² : Type u} {Î³ : Type w} [NonAssocSemiring Î²] [NonAssocSemiring Î³] (f : Î² â†’+* Î³) (s : Multiset Î²) : â‡‘f s.sum = (Multiset.map â‡‘f s).sum
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [Preorder Î±] [t : OrderClosedTopology Î±] [topologicalSpace Î²] {f g : Î² â†’ Î±} {s : Set Î²} (hs : is_IsClosed s) (hF : ContinuousOn f s) (hg : ContinuousOn g s) : is_IsClosed {x âˆˆ s | f x â‰¤ g x}
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasStrictDerivAt (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) a
{Î± : Type u} (f : Fin 0 â†’ Î±) : List.ofFn f = List.nil
{K : Type u_1} [linearOrderedField K] {v : K} [floorRing K] (terminates : (GeneralizedContinuedFraction.of v).terminates) : âˆƒ (n : â„•), v = (GeneralizedContinuedFraction.of v).convergents n
{Î± Î² : Type u_1} (e : Î± â‰ƒ Î²) : e.option_congr = EquivFunctor.mapEquiv Option e
{Î± : Type u_1} [CommMonoid Î±] (a b u : Î±) (hu : IsUnit u) : u * a âˆ£ b â†” a âˆ£ b
(ð•œ : Type u_1) {E : Type u_4} [NormedGroup E] [nondiscreteNormedField ð•œ] [normedSpace ð•œ E] (ð•œ' : Type u_12) [normedField ð•œ'] [NormedAlgebra ð•œ ð•œ'] [normedSpace ð•œ' E] [isScalarTower ð•œ ð•œ' E] [Nontrivial E] : âˆ¥ContinuousLinearMap.lsmul ð•œ ð•œ'âˆ¥ = 1
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (f : E â†’L[ð•œ] F) [CompleteSpace F] (surj : Function.Surjective â‡‘f) : âˆƒ (C : â„) (H : C â‰¥ 0), âˆ€ (y : F), âˆƒ (x : E), HasDist.dist (â‡‘f x) y â‰¤ 1 / 2 * âˆ¥yâˆ¥ âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
{q : â„•+} (w : 1 < q) : Fintype.card (LucasLehmer.X q)Ë£ < â†‘q ^ 2
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î±'] [DecidableEq Î³] [DecidableEq Î´] {f : Î± â†’ Î² â†’ Î³} {s : Finset Î±} {t : Finset Î²} {g : Î³ â†’ Î´} {f' : Î±' â†’ Î² â†’ Î´} {g' : Î± â†’ Î±'} (h_Distrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' (g' a) b) : Finset.image g (Finset.imageâ‚‚ f s t) = Finset.imageâ‚‚ f' (Finset.image g' s) t
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {fâ‚‚ : ð•œ â†’ F} {sâ‚‚ : Set ð•œ} {n : â„•} (hs : UniqueDiffOn ð•œ sâ‚‚) : ContDiffOn ð•œ â†‘(n + 1) fâ‚‚ sâ‚‚ â†” DifferentiableOn ð•œ fâ‚‚ sâ‚‚ âˆ§ ContDiffOn ð•œ â†‘n (derivWithin fâ‚‚ sâ‚‚) sâ‚‚
{G : Type u_1} [AddGroup G] {H K : AddSubgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} (F : CategoryTheory.Limits.StrongEpiMonoFactorisation f) {F' : CategoryTheory.Limits.MonoFactorisation f} (hF' : CategoryTheory.Limits.IsImage F') : CategoryTheory.StrongEpi F'.e
{Î± : Type u} [pseudoMetricSpace Î±] (x y : Î±) : HasEdist.edist x y â‰  âŠ¤
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Î¹ â†’ M} [Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [Module R M] [Module R M'] (f : M â†’â‚—[R] M') (hfv : LinearIndependent R (â‡‘f âˆ˜ v)) : LinearIndependent R v
 : Â¬Summable (Î» (n : â„•), (â†‘n)â»Â¹)
(R : Type u) [Semiring R] (p q : â„•) [hp : Char_p R p] [hq : ExpChar R q] : p = q â†” Nat.Prime p
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] (X : C) [IsSimpleOrder (CategoryTheory.Subobject X)] : CategoryTheory.Simple X
{G : Type u_1} [Group G] (Hâ‚ Hâ‚‚ : Subgroup G) (hHâ‚ : Hâ‚.normal) (hHâ‚‚ : Hâ‚‚.normal) (hdis : Disjoint Hâ‚ Hâ‚‚) (x y : G) (hx : x âˆˆ Hâ‚) (hy : y âˆˆ Hâ‚‚) : Commute x y
{R : Type u} [CommSemiring R] {n : â„•} (m : Fin n â†’â‚€ â„•) (f : MvPolynomial (Fin (n + 1)) R) (i : â„•) : MvPolynomial.coeff m ((â‡‘(MvPolynomial.finSuccEquiv R n) f).coeff i) = MvPolynomial.coeff (Finsupp.cons i m) f
(t : â„) : Filter.Tendsto (Î» (x : â„•), (1 + t / â†‘x) ^ x) Filter.atTop (nhds (Real.exp t))
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [AddCommMonoid F] [orderedAddCommMonoid Î²] [Module ð•œ E] [Module ð•œ F] [HasScalar ð•œ Î²] {f : F â†’ Î²} {s : Set F} (hF : ConvexOn ð•œ s f) (g : E â†’â‚—[ð•œ] F) : ConvexOn ð•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
{Î± : Type u_1} {N : Type u_6} [CommMonoid N] {f : Î± â†’ N} (a : Î±) (hF : (Function.MulSupport f).finite) : f a âˆ£ finprod f
{C : Type u} [CategoryTheory.Category C] (F G : C â¥¤ CategoryTheory.Discrete Punit) : F = G
{p : â„•} [hp : Fact (Nat.Prime p)] : WittVector.IsPoly p (Î» (R : Type u_1) (_x : CommRing R), Neg.neg)
{Î± : Type u_1} {Î² : Type u_2} [t : topologicalSpace Î²] [PolishSpace Î²] (f : Î± â‰ƒ Î²) : PolishSpace Î±
{R : Type u} {n : â„•} {M : Fin n.succ â†’ Type v} {Mâ‚‚ : Type vâ‚‚} [Semiring R] [Î  (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid Mâ‚‚] [Î  (i : Fin n.succ), Module R (M i)] [Module R Mâ‚‚] (f : MultilinearMap R M Mâ‚‚) (m : Î  (i : Fin n), M (â‡‘fin.cast_Succ i)) (c : R) (x : M (fin.last n)) : â‡‘f (fin.snoc m (c â€¢ x)) = c â€¢ â‡‘f (fin.snoc m x)
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Vâ‚‚ : Type v'} [AddCommGroup Vâ‚‚] [Module K Vâ‚‚] (f : V â‰ƒâ‚—[K] Vâ‚‚) [FiniteDimensional K V] : FiniteDimensional K Vâ‚‚
(C : Type u) [ð’ž : CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasPushouts C
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [CommGroup Î²] {f : Î± â†’ Î²} (hF : IsGroupHom f) : IsGroupHom (Î» (a : Î±), (f a)â»Â¹)
(R : Type u_1) [CommRing R] [is_IsDomain R] (p : â„•) [Char_p R p] (hp : p â‰  2) : Polynomial.cyclotomic' 2 R = Polynomial.x + 1
{R : Type u_8} [orderedSemiring R] [Nontrivial R] (l : List R) (h : âˆ€ (a : R), a âˆˆ l â†’ 0 < a) : 0 < l.prod
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) {p : P} (hp : p âˆˆ affineSpan â„ (Set.Range s.points)) {r : â„} (hr : âˆ€ (i : Fin (n + 1)), HasDist.dist (s.points i) p = r) : p = s.circumcenter
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} [CategoryTheory.Limits.HasPullbacks C] (K : CategoryTheory.Pretopology C) : CategoryTheory.Presieve.IsSheaf (CategoryTheory.Pretopology.toGrothendieck C K) P â†” âˆ€ {X : C} (R : CategoryTheory.Presieve X), R âˆˆ â‡‘K X â†’ CategoryTheory.Presieve.IsSheafFor P R
{Î± : Type u_3} [SemilatticeSup Î±] [NoMaxOrder Î±] (a : Î±) : Filter.map Coe Filter.atTop = Filter.atTop
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [IsRefl Î± r] : {c : Cardinal | âˆƒ (S : Set Î±), (âˆ€ (a : Î±), âˆƒ (b : Î±) (H : b âˆˆ S), r a b) âˆ§ Cardinal.mk â†¥S = c}.nonempty
{x y : Game} : Â¬x â‰¤ y â†” y.lf x
{C : Type uâ‚} [CategoryTheory.Category C] {Z X Y : C} {f : Z âŸ¶ X} {g : Z âŸ¶ Y} {c : CategoryTheory.Limits.PushoutCocone f g} (h : CategoryTheory.Limits.IsColimit c) : CategoryTheory.IsPushout f g c.inl c.inr
{M : Type u_1} [CommMonoid M] (S : Submonoid M) : Localization.r S = Localization.r' S
{G : Type u_1} [Group G] [topologicalSpace G] [TopologicalGroup G] {H : Subgroup G} (h_1_Int : 1 âˆˆ Interior â†‘H) : is_IsOpen â†‘H
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) {r : â„} (hr : 0 < r) : o.oangle (r â€¢ x) y = o.oangle x y
{R : Type u_1} [CommRing R] (v w : Fin 3 â†’ R) : Matrix.dotProduct v (â‡‘(â‡‘crossProduct v) w) = 0
{G : Type u} [Group G] {N : Subgroup G} [N.normal] (hN : (Nat.card â†¥N).coprime N.index) : âˆƒ (H : Subgroup G), H.is_complement' N
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P (n + 1)) : 0 < s.circumradius
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set â„} [Interval_integral.FTC_Filter b (nhdsWithin b s) (nhdsWithin b t)] (hmeas : StronglyMeasurableAtFilter f (nhdsWithin b t) MeasureTheory.MeasureSpace.volume) (hb : ContinuousWithinAt f t b) (hs : UniqueDiffWithinAt â„ s b . "UniqueDiffWithinAt_ici_Iic_Univ") : derivWithin (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s b = f b
{Î± : Type u_1} (v : Vector Î± 1) : v.to_List = [v.head]
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [conditionallyCompleteLinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] [Nonempty Î³] {f : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : ContinuousAt f (â¨† (i : Î³), g i)) (Mf : Monotone f) (H : BddAbove (Set.Range g)) : f (â¨† (i : Î³), g i) = â¨† (i : Î³), f (g i)
{k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [Semiring k] [AddMonoid G] [Semiring R] {f g : AddMonoidAlgebra k G â†’+* R} (hâ‚€ : âˆ€ (b : k), â‡‘f (Finsupp.single 0 b) = â‡‘g (Finsupp.single 0 b)) (h_of : âˆ€ (a : G), â‡‘f (Finsupp.single a 1) = â‡‘g (Finsupp.single a 1)) : f = g
(a : Zmod8) : â‡‘ZmodÏ‡â‚ˆ a = 0 âˆ¨ â‡‘ZmodÏ‡â‚ˆ a = 1 âˆ¨ â‡‘ZmodÏ‡â‚ˆ a = -1
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] : FiniteDimensional.finrank K V = 1 â†” âˆƒ (v : V) (n : v â‰  0), âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w
{p : â„} : p â‰¤ 0 â†’ Ennreal.ofReal p = 0
(p : â„• â†’ Prop) [DecidablePred p] (i : Infinite â†¥(setOf p)) (n : â„•) : Nat.nth p n = â†‘(â‡‘(Nat.Subtype.orderIsoOfNat (setOf p)) n)
{x : Pgame} (h : 0 â‰¤ x) (j : x.right_moves) : 0 â‰¤ (x.move_Right j).move_Left (Pgame.leftResponse h j)
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : is_IsCompact s â†’ âˆ€ (f : Ultrafilter Î±), â†‘f â‰¤ Filter.principal s â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), â†‘f â‰¤ nhds a)
{Î± : Type u} (f : Î± â†’ Type (max u v)) : Â¬Function.Surjective f
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {s : Set â„} {e : E} {a : â„} {f : â„ â†’ E} (f_Diff : DifferentiableOn â„ f s) (f_lim : ContinuousWithinAt f s a) (hs : s âˆˆ nhdsWithin a (Set.Ioi a)) (f_lim' : Filter.Tendsto (Î» (x : â„), deriv f x) (nhdsWithin a (Set.Ioi a)) (nhds e)) : HasDerivWithinAt f e (Set.Ici a) a
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [CompactSpace Î±] [metricSpace Î²] : Continuous (Î» (p : C(Î±, Î²) Ã— Î±), â‡‘(p.fst) p.snd)
{Î± : Type u_1} {Î¹ : Type u_2} {Î² : Type u_3} {S : Î¹ â†’ Set Î±} {f : Î  (i : Î¹), â†¥(S i) â†’ Î²} {hF : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), f i âŸ¨x, hxiâŸ© = f j âŸ¨x, hxjâŸ©} {T : Set Î±} (hT' : T = Set.Union S) (u : â†¥T â†’ â†¥T) (ui : Î  (i : Î¹), â†¥(S i) â†’ â†¥(S i)) (hui : âˆ€ (i : Î¹) (x : â†¥(S i)), u (Set.inclusion _ x) = Set.inclusion _ (ui i x)) (uÎ² : Î² â†’ Î²) (h : âˆ€ (i : Î¹) (x : â†¥(S i)), f i (ui i x) = uÎ² (f i x)) (x : â†¥T) : Set.unionLift S f hF T _ (u x) = uÎ² (Set.unionLift S f hF T _ x)
{a b p q : â„} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hpq : p.is_conjugate_exponent q) : a * b â‰¤ a ^ p / p + b ^ q / q
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±} (hs : BddBelow s) (sne : s.nonempty) : HasInf.inf (HasInsert.insert a s) = a âŠ“ HasInf.inf s
{M : Type u_1} {N : Type u_2} [MulOneClass M] [MulOneClass N] (h : M â‰ƒ* N) : IsMonoidHom â‡‘h
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (hs : is_IsCompact s) {f : Filter Î±} (hF : âˆ€ (a : Î±), a âˆˆ s â†’ (âˆƒ (t : Set Î±) (H : t âˆˆ nhdsWithin a s), tá¶œ âˆˆ f)) : sá¶œ âˆˆ f
(p : â„•) [hp : Fact (Nat.Prime p)] (n j : â„•) (hj : j < p ^ n) : p ^ (n - pnat_multiplicity p âŸ¨j + 1, _âŸ©) âˆ£ (p ^ n).choose (j + 1)
(b c : â„) (n : â„•) (hb : 0 < b) : Filter.Tendsto (Î» (x : â„), (b * Real.exp x + c) / x ^ n) Filter.atTop Filter.atTop
{Î± : Type u_1} {Î² : Type u_2} [hasMul Î±] [CommGroup Î²] {f : Î± â†’ Î²} (hF : IsMulHom f) : IsMulHom (Î» (a : Î±), (f a)â»Â¹)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) (h : p 1 = â‡‘((Continuous_multilinear_Curry_Fin1 ð•œ E F).symm) â†‘i) : (p.left_Inv i).comp p = FormalMultilinearSeries.id ð•œ E
{x y : Pgame} : x â‰¤ y â†” (âˆ€ (i : x.left_moves), (x.move_Left i).lf y) âˆ§ âˆ€ (j : y.right_moves), x.lf (y.move_Right j)
{M : Type u_1} [Monoid M] (x : M) : IsSubmonoid (Powers x)
{M : Type u} [AddZeroClass M] (x : M) : AddSemiconjBy 0 x x
{R : Type u_1} [linearOrderedField R] [floorRing R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : â†‘b ^ x < r â†” x < Int.clog b r
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {f : Î± â†’ Î²} (hF : IsRingHom f) {Î³ : Type u_1} [Ring Î³] {g : Î² â†’ Î³} (hg : IsRingHom g) : IsRingHom (g âˆ˜ f)
(K : Type u) [Field K] (V : Type v) [AddCommGroup V] [Module K V] [FiniteDimensional K V] : (LinearMap.ltensor V (contractLeft K V)).comp ((TensorProduct.assoc K V (Module.Dual K V) V).to_Linear_map.comp (LinearMap.rtensor V (coevaluation K V))) = (TensorProduct.rid K V).symm.to_Linear_map.comp (TensorProduct.lid K V).to_Linear_Map
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [Nontrivial k] {s : Finset Î¹} {w : Î¹ â†’ k} (h : s.sum (Î» (i : Î¹), w i) = 1) (p : Î¹ â†’ P) : â‡‘(s.affine_combination p) w âˆˆ affineSpan k (Set.Range p)
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {f g : Equiv.perm Î±} (hF : f.is_Cycle) (hg : g.is_Cycle) (h : f.support âŠ† g.support) (h' : âˆ€ (x : Î±), x âˆˆ f.support â†’ â‡‘f x = â‡‘g x) : f = g
{Î± : Type u} [Preorder Î±] {s t : Set Î±} (h : BddBelow t) : BddBelow (s âˆ© t)
{Î± : Type u_1} [DecidableEq Î±] {s t : Finset Î±} (h : s âŠ† t) : (Finset.ioc s t).card = 2 ^ (t.card - s.card) - 1
(C : Type u) [CategoryTheory.Category C] : Nonempty (C â‰Œ CategoryTheory.Discrete Punit) â†” Nonempty C âˆ§ âˆ€ (x y : C), Nonempty (Unique (x âŸ¶ y))
{V : Type u_1} [innerProductSpace â„ V] {x y : V} : InnerProductGeometry.angle x y = 0 â†” x â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ x
{C : Type uâ‚} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasTerminal C] (hA : CategoryTheory.IsSubterminal A) : CategoryTheory.Mono (CategoryTheory.Limits.terminal.from A)
{n : â„¤} : IsUnit n â†’ n.nat_Abs = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type uâ‚} [CategoryTheory.Category D] (L : C â¥¤ D) [CategoryTheory.IsLeftAdjoint L] : CategoryTheory.IsCofiltered D
(ð•‚ : Type u_1) {ð”¸ : Type u_2} {ð”¹ : Type u_3} [is_R_or_C ð•‚] [normedRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [normedRing ð”¹] [NormedAlgebra ð•‚ ð”¹] [CompleteSpace ð”¸] {F : Type u_4} [ringHomClass F ð”¸ ð”¹] (f : F) (hF : Continuous â‡‘f) (x : ð”¸) : â‡‘f (Exp ð•‚ x) = Exp ð•‚ (â‡‘f x)
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y z : M} (hx : SameRay R x z) (hy : SameRay R y z) : SameRay R (x + y) z
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [metricSpace Î²] {f : Î± â†’ Î²} (h : Embedding f) : Isometry f
{Î± : Type u} {Î² : Type v} [pseudoEmetricSpace Î±] [pseudoEmetricSpace Î²] {f : Î± â†’ Î²} (hF : Isometry f) (x y : Î±) : HasEdist.edist (f x) (f y) = HasEdist.edist x y
{R : Type u} [Semiring R] {p : Polynomial R} {n : â„•} (r : R) : p * Polynomial.x ^ n * â‡‘Polynomial.c r = p * â‡‘Polynomial.c r * Polynomial.x ^ n
(p : â„• â†’ Prop) [DecidablePred p] (n : â„•) : Nat.count p n = Fintype.card {k // k < n âˆ§ p k}
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] (b : Basis Î¹ R M) {x y : M} (h : âˆ€ (i : Î¹), â‡‘(â‡‘(b.repr) x) i = â‡‘(â‡‘(b.repr) y) i) : x = y
{ð•œ : Type u_1} {E : Type u_2} [linearOrderedField ð•œ] [OrderedAddCommGroup E] [Module ð•œ E] (S : ConvexCone ð•œ E) (h : âˆ€ (x y : E), x â‰¤ y â†” y - x âˆˆ S) : OrderedSmul ð•œ E
{G : Type u_4} [NormedGroup G] [normedSpace â„ G] {s : Set G} {x y : G} (h : Segment â„ x y âŠ† s) : y - x âˆˆ TangentConeAt â„ s x
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} (hs : s.nonempty) (Fin : Emetric.hausdorffEdist s t â‰  âŠ¤) : t.nonempty
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) [CategoryTheory.IsIso h.counit] : CategoryTheory.Faithful R
{M : Type u_1} [AddCommMonoid M] (S : addSubmonoid M) : AddLocalization.r S = AddLocalization.r' S
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {t : Set (Set Î±)} (h : t.pairwise_Disjoint Id) (htâ‚€ : t.finite) (htâ‚ : âˆ€ (x : Set Î±), x âˆˆ t â†’ x.finite) : finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒâ‚€t), f a)) = finprod (Î» (s : Set Î±), finprod (Î» (H : s âˆˆ t), finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ s), f a))))
{Râ‚‚ : Type u_5} {Mâ‚‚ : Type u_6} [CommSemiring Râ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {Bâ‚‚ : BilinForm Râ‚‚ Mâ‚‚} {Î¹ : Type u_13} (b : Basis Î¹ Râ‚‚ Mâ‚‚) (x y : Mâ‚‚) : (â‡‘(b.repr) x).sum (Î» (i : Î¹) (xi : Râ‚‚), (â‡‘(b.repr) y).sum (Î» (j : Î¹) (yj : Râ‚‚), xi â€¢ yj â€¢ â‡‘Bâ‚‚ (â‡‘b i) (â‡‘b j))) = â‡‘Bâ‚‚ x y
{C : Type u} [CategoryTheory.Category C] {X Y : AlgebraicGeometry.PresheafedSpace C} (f : X âŸ¶ Y) [h : AlgebraicGeometry.PresheafedSpace.IsOpenImmersion f] [h' : CategoryTheory.Epi f.base] : CategoryTheory.IsIso f
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linearOrderedField ð•œ] [AddCommGroup E] [OrderedAddCommGroup Î²] [Module ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} {t : Finset Î¹} {w : Î¹ â†’ ð•œ} {p : Î¹ â†’ E} (hF : ConvexOn ð•œ s f) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hâ‚ : t.sum (Î» (i : Î¹), w i) = 1) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : f (t.sum (Î» (i : Î¹), w i â€¢ p i)) â‰¤ t.sum (Î» (i : Î¹), w i â€¢ f (p i))
{Î² : Type u_2} [CommMonoid Î²] {n : â„•} (f : Fin (n + 1) â†’ Î²) : finset.univ.prod (Î» (i : Fin (n + 1)), f i) = finset.univ.prod (Î» (i : Fin n), f (â‡‘fin.cast_Succ i)) * f (fin.last n)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {la lb : Filter â„} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f la MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f lb MeasureTheory.MeasureSpace.volume) {s t : Set â„} [Interval_integral.FTC_Filter a (nhdsWithin a s) la] [Interval_integral.FTC_Filter b (nhdsWithin b t) lb] (ha : Filter.Tendsto f la (nhds (f a))) (hb : Filter.Tendsto f lb (nhds (f b))) : HasFderivWithinAt (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd â„ â„ â„).smul_Right (f b) - (ContinuousLinearMap.fst â„ â„ â„).smul_Right (f a)) (s Ã—Ë¢ t) (a, b)
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (g : G) (p : P) : g +áµ¥ p -áµ¥ p = g
{n : WithTop â„•} {ð•‚ : Type u_6} [is_R_or_C ð•‚] {F' : Type u_8} [NormedGroup F'] [normedSpace ð•‚ F'] {f : ð•‚ â†’ F'} {x : ð•‚} (hF : ContDiffAt ð•‚ n f x) (hn : 1 â‰¤ n) : HasStrictDerivAt f (deriv f x) x
{ð•œ : Type u_1} [is_R_or_C ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {r : â„} (hr : 0 < r) : NormedSpace.Polar ð•œ (Metric.ClosedBall 0 r) = Metric.ClosedBall 0 râ»Â¹
{R : Type u_1} {Râ‚˜ : Type u_2} [CommRing R] [CommRing Râ‚˜] {M : Submonoid R} (hM : 0 âˆ‰ M) (hR : IsField R) [Algebra R Râ‚˜] [IsLocalization M Râ‚˜] : Function.bijective â‡‘(algebraMap R Râ‚˜)
(p : â„•) (q : â„š) : 0 â‰¤ padicNorm p q
{Î± : Type u_1} {Î² : Type u_2} [SemilatticeInf Î±] [OrderTop Î±] {P : Î± â†’ Prop} {Ptop : P âŠ¤} {Pinf : âˆ€ â¦ƒx y : Î±â¦„, P x â†’ P y â†’ P (x âŠ“ y)} (t : Finset Î²) (f : Î² â†’ {x // P x}) : â†‘(t.inf f) = t.inf (Î» (x : Î²), â†‘(f x))
{Î± : Type u_1} {f g : â„• â†’ Î±} [topologicalSpace Î±] [NonUnitalNonAssocSemiring Î±] [RegularSpace Î±] [TopologicalSemiring Î±] (hF : Summable f) (hg : Summable g) (hfg : Summable (Î» (x : â„• Ã— â„•), f x.fst * g x.snd)) : (âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (Finset.Nat.antidiagonal n).sum (Î» (kl : â„• Ã— â„•), f kl.fst * g kl.snd)
{M : Type u_1} [AddMonoid M] {Î³ : Type u_2} [AddMonoid Î³] {f : M â†’ Î³} (hF : IsAddMonoidHom f) : IsAddSubmonoid (Set.Range f)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hderiv : âˆ€ (x : â„), x âˆˆ Set.Interval a b â†’ HasDerivAt f (f' x) x) (hint : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : âˆ« (y : â„) in a..b, f' y = f b - f a
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [addAction Î± Î²] (g : Î±) (x : Î²) : AddAction.stabilizer Î± (g +áµ¥ x) = AddSubgroup.map (AddEquiv.toAddMonoidHom (â‡‘AddAut.conj g)) (AddAction.stabilizer Î± x)
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {f : Filter Î±} {g : Filter Î²} {n : Î³ â†’ Î´} {m' : Î± â†’ Î²' â†’ Î´} {n' : Î² â†’ Î²'} (h_Distrib : âˆ€ (a : Î±) (b : Î²), n (m a b) = m' a (n' b)) : Filter.map n (Filter.mapâ‚‚ m f g) = Filter.mapâ‚‚ m' f (Filter.map n' g)
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} (R : CategoryTheory.Presieve X) : CategoryTheory.Presieve.IsSheafFor P R â†” CategoryTheory.Presieve.IsSheafFor P â‡‘(CategoryTheory.Sieve.generate R)
{Î± : Type u_1} {Î² : Type u_2} {rÎ± : Î± â†’ Î± â†’ Prop} {rÎ² : Î² â†’ Î² â†’ Prop} (f : Î± â†’ Î²) (fib : Relation.Fibration rÎ± rÎ² f) {a : Î±} (ha : Acc rÎ± a) : Acc rÎ² (f a)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) {fs : Finset (Fin (n + 1))} {m : â„•} (h : fs.card = m + 1) : â†‘(â‡‘((s.face h).orthogonal_projection_Span) s.circumcenter) = (s.face h).circumcenter
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (hab : a < b) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : f (â‡‘(AffineMap.lineMap a b) r) â‰¤ â‡‘(AffineMap.lineMap (f a) (f b)) r â†” slope f a (â‡‘(AffineMap.lineMap a b) r) â‰¤ slope f (â‡‘(AffineMap.lineMap a b) r) b
{S : Type u_1} [hasMul S] {a b : S} (h : Commute a b) : a * b = b * a
(wâ‚ wâ‚‚ zâ‚ zâ‚‚ : Nnreal) (hw' : wâ‚ + wâ‚‚ = 1) {p : â„} (hp : 1 â‰¤ p) : (wâ‚ * zâ‚ + wâ‚‚ * zâ‚‚) ^ p â‰¤ wâ‚ * zâ‚ ^ p + wâ‚‚ * zâ‚‚ ^ p
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {Î¹â‚ : Type u_3} {sâ‚ : Finset Î¹â‚} {wâ‚ : Î¹â‚ â†’ â„} (pâ‚ : Î¹â‚ â†’ P) (hâ‚ : sâ‚.sum (Î» (i : Î¹â‚), wâ‚ i) = 0) {Î¹â‚‚ : Type u_4} {sâ‚‚ : Finset Î¹â‚‚} {wâ‚‚ : Î¹â‚‚ â†’ â„} (pâ‚‚ : Î¹â‚‚ â†’ P) (hâ‚‚ : sâ‚‚.sum (Î» (i : Î¹â‚‚), wâ‚‚ i) = 0) : HasInner.inner (â‡‘(sâ‚.weighted_vsub pâ‚) wâ‚) (â‡‘(sâ‚‚.weighted_vsub pâ‚‚) wâ‚‚) = -sâ‚.sum (Î» (iâ‚ : Î¹â‚), sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚ iâ‚ * wâ‚‚ iâ‚‚ * (HasDist.dist (pâ‚ iâ‚) (pâ‚‚ iâ‚‚) * HasDist.dist (pâ‚ iâ‚) (pâ‚‚ iâ‚‚)))) / 2
{p : â„•} [Fact (Nat.Prime p)] (q r : â„š_[p]) : padicNorm_e (q + r) â‰¤ Linear_order.max (padicNorm_e q) (padicNorm_e r)
 : â‡‘LinearMap.det â†‘(complex.conj_lie.to_linearEquiv) = -1
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {pâ‚ : P} (hpâ‚ : pâ‚ âˆˆ s) (pâ‚‚ : P) : HasDist.dist pâ‚ (â‡‘(EuclideanGeometry.reflection s) pâ‚‚) = HasDist.dist pâ‚ pâ‚‚
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hD : DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Ioi 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz_re : 0 â‰¤ z.re) (hz_im : 0 â‰¤ z.im) : âˆ¥f zâˆ¥ â‰¤ C
{M : Type u_1} {N : Type u_2} [hasAdd M] [hasAdd N] {c : AddCon M} {f : M â†’ N} (H : âˆ€ (x y : M), f (x + y) = f x + f y) (h : AddCon.addKer f H â‰¤ c) (hF : Function.Surjective f) : c.map_gen f = c.map_of_surjective f H h hF
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R â†’+* S} {p : Polynomial S} (hlifts : p âˆˆ Polynomial.lifts f) : âˆƒ (q : Polynomial R), Polynomial.map f q = p âˆ§ q.degree = p.degree
 : Function.Injective Dvd.dvd
{Î± : Type u_1} (s : Multiset Î±) (p : Î± â†’ Prop) [DecidablePred p] : Multiset.count True (Multiset.map p s) = â‡‘Multiset.card (Multiset.filter p s)
{ð•œ : Type u_1} [linearOrderedField ð•œ] [topologicalSpace ð•œ] [OrderTopology ð•œ] {s : Set ð•œ} : StrictConvex ð•œ s â†’ s.ord_connected
{R : Type u_1} [Rack R] (x y : R) : Rack.act (Shelf.act x y) = Rack.act x * Rack.act y * (Rack.act x)â»Â¹
{Î± : Type u} {Î² : Type v} [completeLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [completeLinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {Î¹ : sort u_1} [Nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : ContinuousAt f (supr g)) (Mf : Monotone f) : f (â¨† (i : Î¹), g i) = â¨† (i : Î¹), f (g i)
{Î± : Type u_1} {l : List Î±} : l <:+ List.nil â†’ l = List.nil
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (e : M â‰ƒâ‚—[R] M) (v : Module.Ray R M) : e â€¢ v = â‡‘(Module.Ray.map e) v
{X : Type u_1} [topologicalSpace X] (s : Set X) : SeqClosure s âŠ† Closure s
{M : Type u_1} [AddMonoid M] : Add_monoid.fg M â†” âˆƒ (S : Set M), AddSubmonoid.closure S = âŠ¤ âˆ§ S.finite
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type uâ‚} [CategoryTheory.Category D] (R : C â¥¤ D) [CategoryTheory.IsRightAdjoint R] : CategoryTheory.IsFiltered D
{Î± : Type u} {Î² : Type v} [Setoid Î±] [topologicalSpace Î±] {f : Î² â†’ Î±} (hF : DenseRange f) : DenseRange (Quotient.mk âˆ˜ f)
{Î± : Type u} [metricSpace Î±] (x : â„• â†’ Î±) (H : DenseRange x) : Isometry (KuratowskiEmbedding.embeddingOfSubset x)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
{Î± : Type u} [orderedSemiring Î±] {a b c d : Î±} [HasExistsAddOfLe Î±] (hba : b < a) (hdc : d < c) : a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d
{Î± : Type u} [SemilatticeInf Î±] [Nonempty Î±] {s : Set Î±} (hs : s.finite) : BddBelow s
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} : IsMaxChain r (MaxChain r)
{p : Polynomial â„¤} (hp : p.is_primitive) : Irreducible p â†” Irreducible (Polynomial.map (Int.castRingHom â„š) p)
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {a b : Î±} (p : Î± â†’ Prop) (l : List Î±) (h : List.Chain r a l) (hb : (a :: l).last _ = b) (carries : âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ p y â†’ p x) (final : p b) : p a
{D : Set â„} (hD : Convex â„ D) (hDâ‚‚ : is_IsOpen D) {f : â„ â†’ â„} (hF' : DifferentiableOn â„ f D) (hF'' : âˆ€ (x : â„), x âˆˆ D â†’ deriv^[2] f x < 0) : StrictConcaveOn â„ D f
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} {Î¹ : Type v} (hs : is_IsCompact s) (U : Î¹ â†’ Set Î±) (hUo : âˆ€ (i : Î¹), is_IsOpen (U i)) (hsU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (t : Finset Î¹), s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {a b c : Î±} (h : âˆ€ (a b c : Î±), r a b â†’ r a c â†’ (âˆƒ (d : Î±), Relation.ReflGen r b d âˆ§ Relation.ReflTransGen r c d)) (hab : Relation.ReflTransGen r a b) (hac : Relation.ReflTransGen r a c) : Relation.Join (Relation.ReflTransGen r) b c
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x y : Î±} (h : Metric.Bounded s) (hx : x âˆˆ s) (hy : y âˆˆ s) : HasDist.dist x y â‰¤ Metric.diam s
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), AddCommMonoid (Mâ‚' i)] [Î  (i : Î¹), Module R (Mâ‚' i)] (g : MultilinearMap R Mâ‚' Mâ‚‚) (f : Î  (i : Î¹), Mâ‚ i â‰ƒâ‚—[R] Mâ‚' i) : g.comp_Linear_Map (Î» (i : Î¹), â†‘(f i)) = 0 â†” g = 0
{C : Type u} [CategoryTheory.Category C] {X : Top} (F : Top.Presheaf C X) : F.is_sheaf_Opens_LE_cover â†” F.is_sheaf_Pairwise_intersections
{Î¹ : Type u} {X : Type v} [topologicalSpace X] {s : Set X} [NormalSpace X] (p : (X â†’ â„) â†’ Prop) (h01 : âˆ€ (s t : Set X), is_IsClosed s â†’ is_IsClosed t â†’ Disjoint s t â†’ (âˆƒ (f : C(X, â„)), p â‡‘f âˆ§ Set.EqOn â‡‘f 0 s âˆ§ Set.EqOn â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ Set.Icc 0 1)) (hs : is_IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ (i : Î¹), is_IsOpen (U i)) (hF : LocallyFinite U) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : BumpCovering Î¹ X s), (âˆ€ (i : Î¹), p â‡‘(â‡‘f i)) âˆ§ f.is_subordinate U
{Î± : Type u} [pseudoMetricSpace Î±] [CompleteSpace Î±] {s : â„• â†’ Set Î±} (hs : âˆ€ (n : â„•), is_IsClosed (s n)) (h's : âˆ€ (n : â„•), Metric.Bounded (s n)) (h : âˆ€ (N : â„•), (â‹‚ (n : â„•) (H : n â‰¤ N), s n).nonempty) (h' : Filter.Tendsto (Î» (n : â„•), Metric.diam (s n)) Filter.atTop (nhds 0)) : (â‹‚ (n : â„•), s n).nonempty
{R : Type x} [hasMul R] [hasAdd R] [rightDistribClass R] (a b c : R) : (a + b) * c = a * c + b * c
{F : Type u_3} [innerProductSpace â„ F] (x y : F) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” HasInner.inner x y = 0
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.PosMulMono Î±] (ha : a < 1) (hb : b â‰¤ 1) (a0 : 0 < a) : a * b < 1
{Î± : Type u} [HasSubset Î±] [hasSsubset Î±] [isNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {a b : Î±} (hâ‚ : a âŠ† b) (hâ‚‚ : Â¬b âŠ† a) : a âŠ‚ b
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [CommMonoid M] {s : Set Î±} {t : Set Î²} {f : Î± â†’ M} {g : Î² â†’ M} (e : Î± â†’ Î²) (hEâ‚€ : Set.BijOn e s t) (hEâ‚ : âˆ€ (x : Î±), x âˆˆ s â†’ f x = g (e x)) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ t), g j))
(p : â„•) [hp : Fact (Nat.Prime p)] : WittVector.IsPoly p (Î» (R : Type u_1) (_Rcr : CommRing R), â‡‘WittVector.frobenius)
(p : â„•) [p_Prime : Fact (Nat.Prime p)] {q r : â„š} (hqr : q + r â‰  0) (h : padicValRat p q â‰¤ padicValRat p r) : padicValRat p q â‰¤ padicValRat p (q + r)
{Î± : Type u_1} [HasLe Î±] {a : Î±áµ’áµˆ} : IsTop a â†’ IsBot (â‡‘OrderDual.ofDual a)
{M : Type u_4} [CommMonoid M] {Î¹ : Type u_1} [Subsingleton Î¹] {s : Finset Î¹} {f : Î¹ â†’ M} {b : M} (h : s.prod (Î» (i : Î¹), f i) = b) (i : Î¹) (H : i âˆˆ s) : f i = b
{x : â„} (hx : 0 â‰¤ x) (hx' : x â‰¤ Real.pi / 2) : 2 / Real.pi * x â‰¤ Real.sin x
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (v : â†¥K) : â‡‘(orthogonalProjection K) â†‘v = v
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {p : Î¹ â†’ P} (ha : AffineIndependent k p) (s : Set Î¹) : AffineIndependent k (Î» (i : â†¥s), p â†‘i)
{Î´ : â„} {X : Type u} [pseudoMetricSpace X] {E : Set X} {x : X} : x âˆˆ Metric.Thickening Î´ E â†” âˆƒ (z : X) (H : z âˆˆ E), HasDist.dist x z < Î´
{R : Type v} [Ring R] {L M N K : Module R} {f : L âŸ¶ M} {g : M âŸ¶ N} (w : f â‰« g = 0) {h k : homology f g w âŸ¶ K} (w_1 : âˆ€ (x : â†¥(LinearMap.ker g)), â‡‘h (â‡‘(CategoryTheory.Limits.cokernelÏ€ (imageToKernel f g w)) (â‡‘Module.to_kernelSubobject x)) = â‡‘k (â‡‘(CategoryTheory.Limits.cokernelÏ€ (imageToKernel f g w)) (â‡‘Module.to_kernelSubobject x))) : h = k
{p n : â„•} : padicValRat p â†‘n = â†‘(padicValNat p n)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) : hb.rotation â†‘Real.pi = LinearIsometryEquiv.neg â„
{C : Type uâ‚} [CategoryTheory.Category C] {J : Type uâ‚‚} [CategoryTheory.Category J] [CategoryTheory.Limits.HasColimitsOfShape Jáµ’áµ– C] : CategoryTheory.Limits.HasLimitsOfShape J Cáµ’áµ–
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [is_IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) {y : A} (h : (minpoly A x).is_root y) : â‡‘(algebraMap A B) y = x
{H : Type u} {M : Type u_2} [topologicalSpace H] [topologicalSpace M] [chartedSpace H M] {G : StructureGroupoid H} {e e' : localHomeomorph M H} (hE : e âˆˆ StructureGroupoid.MaximalAtlas M G) (hE' : e' âˆˆ StructureGroupoid.MaximalAtlas M G) : e.symm.trans e' âˆˆ G
{Î± : Type u_1} [HasLe Î±] {a : Î±} : IsMax a â†’ IsMin (â‡‘OrderDual.toDual a)
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] (F : C â¥¤ D) [F.initial] {E : Type u} [CategoryTheory.Category E] {G : D â¥¤ E} [CategoryTheory.Limits.HasLimit (F â‹™ G)] : CategoryTheory.Limits.HasLimit G
{Î± : Type u_1} [topologicalSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] (m : MeasureTheory.OuterMeasure Î±) (s : Set Î±) (hs : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (u : Set Î±) (H : u âˆˆ nhdsWithin x s), â‡‘m u = 0)) : â‡‘m s = 0
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : (âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ asymptotics.is_O_with c l f g) â†’ f =o[l] g
{Î± : Type u_1} {Î¹ : sort u_3} [conditionallyCompleteLinearOrder Î±] {b : Î±} [Nonempty Î¹] {f : Î¹ â†’ Î±} (h : b < supr f) : âˆƒ (i : Î¹), b < f i
(ð•œ : Type u_1) {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace F] (f : E â†’ F) : is_IsOpen {x : E | AnalyticAt ð•œ f x}
{Î± : Type u} [DecidableEq Î±] [Fintype Î±] {P : Equiv.perm Î± â†’ Prop} (f : Equiv.perm Î±) : P 1 â†’ (âˆ€ (f : Equiv.perm Î±) (x y : Î±), x â‰  y â†’ P f â†’ P (equiv.swap x y * f)) â†’ P f
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [denselyOrdered Î±] {a b : Î±} : IsPreconnected (Set.Icc a b)
(f : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfI : f a = f b) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), IsLocalExtr f c
{G : Type u_1} [Group G] (H : Subgroup G) (hnc : NormalizerCondition G) (hmax : IsCoatom H) : H.normal
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} {T : Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [CommMonoid Q] {k : T.localization_Map Q} {A : Type u_5} [CommMonoid A] {U : Submonoid A} {R : Type u_6} [CommMonoid R] (j : U.localization_Map R) {l : P â†’* A} (hl : âˆ€ (w : â†¥T), â‡‘l â†‘w âˆˆ U) (x : N) : â‡‘(k.map hl j) (â‡‘(f.map hy k) x) = â‡‘(f.map _ j) x
{P : Type u_1} [Preorder P] (s t : Order.Pfilter P) (h : â†‘s = â†‘t) : s = t
{Î± : Type u_1} [linearOrderedField Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a
{R : Type u} {M : Type v} {Î¹ : Type w} [Semiring R] [AddCommMonoid M] {Module_M : Module R M} (p : Submodule R M) (x : Î¹ â†’ â†¥p) (s : Finset Î¹) : â†‘(s.sum (Î» (i : Î¹), x i)) = s.sum (Î» (i : Î¹), â†‘(x i))
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] : (reflection K).symm = reflection K
{M : Type u_1} {R : Type u_4} [NonUnitalNonAssocSemiring R] [SetLike M R] [mulMemClass M R] {S : M} {a b : R} (ha : a âˆˆ S) (hb : b âˆˆ AddSubmonoid.closure â†‘S) : a * b âˆˆ AddSubmonoid.closure â†‘S
{Î± : Type u} {Î² : Type v} [PartialOrder Î±] [Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : GaloisConnection l u) (a : Î±) : (âˆƒ (b : Î²), a = u b) â†” a = u (l a)
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] {Î¹ : sort u_2} (p : Î¹ â†’ Submodule R M) {C : Î  (x : M), (x âˆˆ â¨† (i : Î¹), p i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : M) (H : x âˆˆ p i), C x _) (h0 : C 0 _) (HAdd : âˆ€ (x y : M) (hx : x âˆˆ â¨† (i : Î¹), p i) (hy : y âˆˆ â¨† (i : Î¹), p i), C x hx â†’ C y hy â†’ C (x + y) _) {x : M} (hx : x âˆˆ â¨† (i : Î¹), p i) : C x hx
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} (f : Î± â†’ Î² â†’ Î³) (P : Prop) [Decidable P] (a b : Î±) (c d : Î²) : f (Ite P a b) (Ite P c d) = Ite P (f a c) (f b d)
{X : Type u_1} [topologicalSpace X] {x y : X} (Î³ : Path x y) : Continuous Î³.extend
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : StrictConcaveOn ð•œ s f) {x y z : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hxy : x â‰  y) (hz : z âˆˆ OpenSegment ð•œ x y) : Linear_order.min (f x) (f y) < f z
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D â¥¤ C) [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.CartesianClosed C] (h : âˆ€ (B : D) (A : C), (CategoryTheory.exp A).obj (i.obj B) âˆˆ i.ess_image) : CategoryTheory.ExponentialIdeal i
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
{Î± : Type u} {Î¹ : sort x} {f : Î¹ â†’ Î±} [h : Unique Î¹] : Set.Range f = {f Inhabited.default}
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] : 0 < FiniteDimensional.finrank K V â†” Nontrivial V
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ Multiset.Nat.antidiagonal n â†” x.fst + x.snd = n
{Î± : Type u_1} {M : Type u_5} {N : Type u_6} [CommMonoid M] [CommMonoid N] {s : Set Î±} (f : Î± â†’ M) (g : M â†’* N) (hs : s.finite) : â‡‘g (finprod (Î» (j : Î±), finprod (Î» (H : j âˆˆ s), f j))) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), â‡‘g (f i)))
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : x = y â†” hb.oangle x y = 0
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (Î¸ : Real.Angle) : â‡‘LinearEquiv.det (hb.rotation Î¸).to_linearEquiv = 1
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (p1 p2 p3 : P) : p1 -áµ¥ p2 + (p2 -áµ¥ p3) = p1 -áµ¥ p3
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [AddZeroClass M] [CommMonoid N] {f g : Î± â†’â‚€ M} {h : Î± â†’ M â†’ N} (h_Zero : âˆ€ (a : Î±), a âˆˆ f.support âˆª g.support â†’ h a 0 = 1) (h_Add : âˆ€ (a : Î±), a âˆˆ f.support âˆª g.support â†’ âˆ€ (bâ‚ bâ‚‚ : M), h a (bâ‚ + bâ‚‚) = h a bâ‚ * h a bâ‚‚) : (f + g).prod h = f.prod h * g.prod h
{Î¹ : Type u} (f : Î¹ â†’ Ordinal) : BddAbove (Set.Range f)
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (p1 p2 : P) : -(p1 -áµ¥ p2) = p2 -áµ¥ p1
{Î± : Type u_1} {M : Type u_4} [hasOne M] {s : Set Î±} {f : Î± â†’ M} {a : Î±} (h : s.mul_indicator f a â‰  1) : a âˆˆ s
 : Cardinal.ord âˆ˜ Cardinal.aleph' = Ordinal.enumOrd {b : Ordinal | b.card.ord = b}
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {l : Filter Î±} {a : Î±} : IsExtrFilter (â‡‘OrderDual.toDual âˆ˜ f) l a â†’ IsExtrFilter f l a
{n d : â„•} (hnd : d âˆ£ n) : (n / d).totient = (Finset.filter (Î» (k : â„•), n.gcd k = d) (Finset.range n)).card
{Î± : Type u_1} [CancelCommMonoidWithZero Î±] {a b c : Î±} (hc : c â‰  0) : a * c âˆ£ b * c â†” a âˆ£ b
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î²'] [DecidableEq Î³] [DecidableEq Î´] {f : Î± â†’ Î² â†’ Î³} {s : Finset Î±} {t : Finset Î²} {g : Î³ â†’ Î´} {f' : Î± â†’ Î²' â†’ Î´} {g' : Î² â†’ Î²'} (h_Distrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' a (g' b)) : Finset.image g (Finset.imageâ‚‚ f s t) = Finset.imageâ‚‚ f' s (Finset.image g' t)
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [IsPartialOrder Î± r] : âˆƒ (s : Î± â†’ Î± â†’ Prop) (_x : IsLinearOrder Î± s), r â‰¤ s
{S : Type u_1} [Semigroup S] {a b c : S} (hab : Commute a b) (hac : Commute a c) : Commute a (b * c)
(f : Circle_deg1_Lift) (hF : Continuous â‡‘f) : âˆƒ (x : â„), â‡‘f x = x + f.translation_number
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±} (H : IsGreatest s a) : HasSup.sup s = a
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : P) : Collinear k {p}
 : Cardinal.mk â„‚ = Cardinal.continuum
{K : Type u} [Field K] {s : Set K} {p : K â†’ Prop} {x : K} (h : x âˆˆ Subfield.closure s) (Hs : âˆ€ (x : K), x âˆˆ s â†’ p x) (H1 : p 1) (HAdd : âˆ€ (x y : K), p x â†’ p y â†’ p (x + y)) (Hneg : âˆ€ (x : K), p x â†’ p (-x)) (Hinv : âˆ€ (x : K), p x â†’ p xâ»Â¹) (HMul : âˆ€ (x y : K), p x â†’ p y â†’ p (x * y)) : p x
{Î± : Type u_1} [LinearOrder Î±] {s : Finset Î±} {k : â„•} (h : s.card = k) {f : Fin k â†’ Î±} (hfs : âˆ€ (x : Fin k), f x âˆˆ s) (hmono : StrictMono f) : f = â‡‘(s.order_emb_of_Fin h)
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ âˆ…), f i)) = 0
{V : Type u_1} {Î± : Type u_2} [MulZeroOneClass Î±] [Nontrivial Î±] {A : Matrix V V Î±} (h : A.is_adjMatrix) [DecidableEq Î±] : SimpleGraph.adjMatrix Î± h.to_graph = A
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [FiniteDimensional ð•œ E] {K : Submodule ð•œ E} {n : â„•} (h_dim : FiniteDimensional.finrank ð•œ â†¥K + n = FiniteDimensional.finrank ð•œ E) : FiniteDimensional.finrank ð•œ â†¥Ká—® = n
 : PythagoreanTriple 0 0 0
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) (hF'_Mono : StrictMonoOn (deriv f) (Interior D)) : StrictConvexOn â„ D f
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i â‰¤ â‡‘fin.cast_Succ j) : X.Ïƒ j.succ â‰« X.Î´ (â‡‘fin.cast_Succ i) = X.Î´ i â‰« X.Ïƒ j
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] (a b : Î±) : Filter.comap Coe (nhdsWithin b (Set.Iio b)) = Filter.atTop
{R : Type u} [CommSemiring R] [Nontrivial R] {p : Fin 2 â†’ R} (h : IsCoprime (p 0) (p 1)) : p â‰  0
{a b : â„} (m n : â„•) : âˆ« (x : â„) in a..b, Real.sin x ^ m * Real.cos x ^ (2 * n + 1) = âˆ« (u : â„) in Real.sin a..real.sin b, u ^ m * (1 - u ^ 2) ^ n
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) (b : n â†’ Î±) : â‡‘(A.cramer) b = A.adjugate.mul_vec b
(n : â„•) : (n + 1) * (n + 1).central_binom = 2 * (2 * n + 1) * n.central_binom
{Î¹ : Type u_1} {R : Type u_2} {Î± : Type u_3} {S : Type u_4} [SetLike S R] [Monoid R] [AddMonoid Î¹] (A : Î¹ â†’ S) [SetLike.GradedMonoid A] (fÎ¹ : Î± â†’ Î¹) (fA : Î  (a : Î±), â†¥(A (fÎ¹ a))) (l : List Î±) : â†‘(l.dprod fÎ¹ fA) = (List.map (Î» (a : Î±), â†‘(fA a)) l).prod
{C : Type u} [ð’ž : CategoryTheory.Category C] {X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) [CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair Y Z)] [CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair (f â‰« CategoryTheory.Limits.coprod.inl) (g â‰« CategoryTheory.Limits.coprod.inr))] : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) (Î¸ : Real.Angle) : hb.oangle (â‡‘(hb.rotation Î¸) x) x = -Î¸
{Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î²] [topologicalSpace Î³] {Î¹ : Type u_2} {Îº : Type u_3} {f : Î¹ â†’ Î²} {g : Îº â†’ Î³} (hF : DenseRange f) (hg : DenseRange g) : DenseRange (Prod.map f g)
{Î³ : Type w} [SemilatticeInf Î³] (a : Î³) {s : Set Î³} : BddBelow (HasInsert.insert a s) â†” BddBelow s
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” InnerProductGeometry.angle x y = Real.pi / 2
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {Î¹ : Type u_1} (v : Î¹ â†’ M) (i : LinearIndependent R v) (w : Set M) [Fintype â†¥w] (s : Set.Range v â‰¤ â†‘(Submodule.span R w)) : Cardinal.mk Î¹ â‰¤ â†‘(Fintype.card â†¥w)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.preadditiveYoneda â‹™ (CategoryTheory.whiskeringRight Cáµ’áµ– AddCommGroup (Type v)).obj (CategoryTheory.forget AddCommGroup) = CategoryTheory.yoneda
{Î± : Type u} [pseudoEmetricSpace Î±] {Î´ : â„} {s : Set Î±} {x : Î±} : Emetric.infEdist x s â‰¤ Emetric.infEdist x (Metric.Thickening Î´ s) + Ennreal.ofReal Î´
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {Î¹ : Type u_3} {t : Finset Î¹} {f : Î¹ â†’ L} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.sum (Î» (i : Î¹), f i) âˆˆ S
{Î¹ : Type u_1} {E : Type u_3} [semiNormedGroup E] {f : Î¹ â†’ E} (hF : Summable (Î» (i : Î¹), âˆ¥f iâˆ¥â‚Š)) : âˆ¥âˆ‘' (i : Î¹), f iâˆ¥â‚Š â‰¤ âˆ‘' (i : Î¹), âˆ¥f iâˆ¥â‚Š
{a b : Ordinal} (h : b â‰  0) : {o : Ordinal | a < b * Order.succ o}.nonempty
{Î± : Type u_1} [DecidableEq Î±] (P : Finset Î± â†’ Finset Î± â†’ Prop) (Symm : âˆ€ {a b : Finset Î±}, P a b â†’ P b a) (Empty_Right : âˆ€ {a : Finset Î±}, P a âˆ…) (singletons : âˆ€ {a b : Î±}, P {a} {b}) (union_of : âˆ€ {a b c : Finset Î±}, P a c â†’ P b c â†’ P (a âˆª b) c) (a b : Finset Î±) : P a b
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†ª Î²} {s : Finset Î±} : s.nonempty â†’ (Finset.map f s).nonempty
{C : Type u} [CategoryTheory.Category C] (Ps : Set (Cáµ’áµ– â¥¤ Type v)) (J : CategoryTheory.GrothendieckTopology C) (hJ : âˆ€ (P : Cáµ’áµ– â¥¤ Type v), P âˆˆ Ps â†’ CategoryTheory.Presieve.IsSheaf J P) : J â‰¤ CategoryTheory.Sheaf.finestTopology Ps
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] {Î¹ : Type u_1} {f : Î¹ â†’ A} (hF : Function.Injective f) : AlgebraicIndependent R Coe â†’ AlgebraicIndependent R f
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (u : E) {v : E} (hv : HasInner.inner u v = 0) : v âˆˆ (Submodule.span ð•œ {u})á—®
(n : â„•) : (Nat.fib n).coprime (Nat.fib (n + 1))
(k : Type u_1) [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) [CharZero k] (h : s.nonempty) : s.sum (Î» (i : Î¹), Finset.centroidWeights k s i) = 1
{M : Type u_3} [Monoid M] [Preorder M] [CovariantClass M M (Function.swap Mul.mul) LE.le] [CovariantClass M M Mul.mul LE.le] {lâ‚ lâ‚‚ : List M} (h : lâ‚ <+ lâ‚‚) (hâ‚ : âˆ€ (a : M), a âˆˆ lâ‚‚ â†’ 1 â‰¤ a) : lâ‚.prod â‰¤ lâ‚‚.prod
{Î± : Type u} [Group Î±] [Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)] (h : Fintype.card Î± = p) : IsSimpleGroup Î±
(f : Bool â†’ Bool) (x : Bool) : f (f (f x)) = f x
{Î± : Type u} [PartialOrder Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ b = a
{G : Type u_1} [Group G] : NormalizerCondition G â†” âˆ€ (H : Subgroup G), H.normalizer = H â†’ H = âŠ¤
{C : Type u} [CategoryTheory.Category C] (F : Cáµ’áµ– â¥¤ Type v) : (CategoryTheory.categoryOfElements.toCostructuredArrow F).right_Op â‹™ CategoryTheory.categoryOfElements.fromCostructuredArrow F = ðŸ­ F.elements
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (c : Î±) : Metric.Bounded s â†” âˆƒ (r : â„), s âŠ† Metric.ClosedBall c r
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [normedCommRing ð•œ] [AddCommMonoid E] [AddCommMonoid F] [Module ð•œ E] [Module ð•œ F] (B : E â†’â‚—[ð•œ] F â†’â‚—[ð•œ] ð•œ) (s : Set E) : is_IsClosed (B.polar s)
{Î± : Type u} [pseudoEmetricSpace Î±] {Î´ : â„} (Î´_Pos : 0 < Î´) (E : Set Î±) : E âŠ† Metric.Thickening Î´ E
{V : Type u_1} [innerProductSpace â„ V] (x y : V) {r : â„} (hr : 0 < r) : InnerProductGeometry.angle (r â€¢ x) y = InnerProductGeometry.angle x y
{X Y : Type u} (f : X âŸ¶ Y) : CategoryTheory.Mono f â†” Function.Injective f
{Î± : Type u_1} {Î² : Type u_2} [hasAdd Î±] [Preorder Î±] [Preorder Î²] {f g : Î² â†’ Î±} [CovariantClass Î± Î± Add.add LT.lt] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] (hF : StrictMono f) (hg : StrictMono g) : StrictMono (Î» (x : Î²), f x + g x)
{G : Type u} {x : G} {n : â„•} [Fintype G] [Group G] : x ^ n = 1 â†” x ^ n.gcd (Fintype.card G) = 1
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cáµ’áµ– â¥¤ A) : (âˆ€ (E : A), CategoryTheory.Presieve.IsSeparated J (P â‹™ Category_theory.coyoneda.obj (Opposite.op E))) â†” âˆ€ â¦ƒX : Câ¦„ (S : CategoryTheory.Sieve X), S âˆˆ â‡‘J X â†’ âˆ€ (c : CategoryTheory.Limits.Cone (S.arrows.diagram.op â‹™ P)), Subsingleton (c âŸ¶ P.map_cone S.arrows.cocone.op)
{R : Type u_1} [CommSemiring R] {x : R} : HasStar.star x = x
{Î± : Type u_1} [pseudoEmetricSpace Î±] (C : Ennreal) (hC : C â‰  âŠ¤) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (f n) (f (n + 1)) â‰¤ C / 2 ^ n) : CauchySeq f
{R : Type u_1} [Ring R] [topologicalSpace R] [NonarchimedeanRing R] (U : openAddSubgroup R) (r : R) : âˆƒ (V : openAddSubgroup R), r â€¢ â†‘V âŠ† â†‘U
{f : â„ â†’ â„} (hF : Differentiable â„ f) (hF' : âˆ€ (x : â„), deriv f x â‰¤ 0) : Antitone f
{G : Type u_1} {H : Type u_2} [AddGroup G] [AddGroup H] [IsAddCyclic H] (f : G â†’+ H) (hF : f.ker â‰¤ AddSubgroup.center G) (a b : G) : a + b = b + a
{M : Type u_1} [hasAdd M] {r : M â†’ M â†’ Prop} {c : AddCon M} (h : âˆ€ (x y : M), r x y â†’ Setoid.r x y) : addConGen r â‰¤ c
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (w : Î¹ â†’ k) (p : Î¹ â†’ P) {sâ‚ sâ‚‚ : Finset Î¹} (h : sâ‚ âŠ† sâ‚‚) : â‡‘(sâ‚.weighted_vsub p) w = â‡‘(sâ‚‚.weighted_vsub p) (â†‘sâ‚.indicator w)
{Î± : Type u} [pseudoMetricSpace Î±] {f : Î± â†’ â„} {s : Set Î±} {K : Nnreal} (hF : LipschitzOnWith K f s) : âˆƒ (g : Î± â†’ â„), LipschitzWith K g âˆ§ Set.EqOn f g s
{ð•œ : Type u_1} [normedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {c : ð•œ} (hc : 1 < âˆ¥câˆ¥) {R : â„} (hR : âˆ¥câˆ¥ < R) {F : Subspace ð•œ E} (hFc : is_IsClosed â†‘F) (hF : âˆƒ (x : E), x âˆ‰ F) : âˆƒ (xâ‚€ : E), âˆ¥xâ‚€âˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ F â†’ 1 â‰¤ âˆ¥xâ‚€ - yâˆ¥
{p n : â„•} (hp : Nat.Prime p) (HDiv : p âˆ£ n) (R : Type u_1) [CommRing R] : â‡‘(Polynomial.expand R p) (Polynomial.cyclotomic n R) = Polynomial.cyclotomic (n * p) R
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y z : M} (hy : SameRay R x y) (hz : SameRay R x z) : SameRay R x (y + z)
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [divisionRing K] {m : â„•} (m_Lt_n : m < n) : (g.squash_gcf (n + 1)).s.nth m = g.s.nth m
{p : â„•} [hp : Fact (Nat.Prime p)] {n : â„•} (hn : 0 < n) : padicValNat p n = (multiplicity p n).get _
{Î± : sort u_1} {sâ‚ : Setoid Î±} : Function.Surjective Quotient.mk'
{R : Type u_1} {M : Type u_3} [monoidWithZero R] [hasZero M] [mulActionWithZero R M] (h : IsSmulRegular M 0) : Subsingleton M
{M : Type u_1} [Semigroup M] (a : Stream M) (s : Set (Set M)) (sfin : s.finite) (scov : Hindman.FP a âŠ† â‹ƒâ‚€s) : âˆƒ (c : Set M) (H : c âˆˆ s) (b : Stream M), Hindman.FP b âŠ† c
(Î± : Type u_1) [completeLattice Î±] (k : Î±) : CompleteLattice.IsCompactElement k â†” âˆ€ (s : Set Î±), s.nonempty â†’ DirectedOn LE.le s â†’ k â‰¤ HasSup.sup s â†’ (âˆƒ (x : Î±), x âˆˆ s âˆ§ k â‰¤ x)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteCoproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.NormalEpiCategory C] {X Y : C} (f : X âŸ¶ Y) (Z : C) (l : CategoryTheory.Limits.IsLimit (Category_theory.limits.kernel_fork.of_Î¹ 0 _)) : CategoryTheory.Mono f
{Î± : Type u_1} [LinearOrder Î±] [PredOrder Î±] [IsPredArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ Set.Ioc m n â†’ r i (Order.pred i)) (h2 : âˆ€ (i : Î±), i âˆˆ Set.Ioc n m â†’ r (Order.pred i) i) (hnm : n â‰  m) : Relation.TransGen r n m
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [NormedGroup G] [normedSpace ð•œ G] {g : F â†’ G} {f : E â†’ F} {q : FormalMultilinearSeries ð•œ F G} {p : FormalMultilinearSeries ð•œ E F} {x : E} (hg : HasFpowerSeriesAt g q (f x)) (hF : HasFpowerSeriesAt f p x) : HasFpowerSeriesAt (g âˆ˜ f) (q.comp p) x
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = EuclideanGeometry.angle p1 p3 p2) (hpi : EuclideanGeometry.angle p2 p1 p3 â‰  Real.pi) : HasDist.dist p1 p2 = HasDist.dist p1 p3
{p : â„•} [Fact (Nat.Prime p)] {R : Type uâ‚} [CommSemiring R] [Char_p R p] {P : Type uâ‚ƒ} [CommSemiring P] [Char_p P p] [PerfectRing P p] {f : P â†’+* R} (g : P â‰ƒ+* ring.perfection R p) (hfg : â‡‘(Perfection.lift p P R) f = â†‘g) : PerfectionMap p f
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î²] {f : Î± â†’ Î²} [topologicalSpace Î±] (L : âˆ€ (x : Î±) (u : Set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : Set Î±) (H : t âˆˆ nhds x) (F : Î± â†’ Î²), ContinuousAt F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u)) : Continuous f
{q : â„•+} (i : â„•) : â†‘(LucasLehmer.s i) = LucasLehmer.XÏ‰ ^ 2 ^ i + LucasLehmer.XÏ‰b ^ 2 ^ i
{Î± : Type u} [pseudoMetricSpace Î±] (f : â„• â†’ Î±) {m n : â„•} (h : m â‰¤ n) : HasDist.dist (f m) (f n) â‰¤ (Finset.ico m n).sum (Î» (i : â„•), HasDist.dist (f i) (f (i + 1)))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {x : E} {n : WithTop â„•} {s : Set E} {f g : E â†’ F} (hF : ContDiffWithinAt ð•œ n f s x) (hg : ContDiffWithinAt ð•œ n g s x) : ContDiffWithinAt ð•œ n (Î» (x : E), f x + g x) s x
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î±'] [DecidableEq Î³] [DecidableEq Î´] {s : Finset Î±} {t : Finset Î²} {f : Î±' â†’ Î² â†’ Î³} {g : Î± â†’ Î±'} {f' : Î± â†’ Î² â†’ Î´} {g' : Î´ â†’ Î³} (h_leftComm : âˆ€ (a : Î±) (b : Î²), f (g a) b = g' (f' a b)) : Finset.imageâ‚‚ f (Finset.image g s) t = Finset.image g' (Finset.imageâ‚‚ f' s t)
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] {F : Type w} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace ð•œ] [FiniteDimensional ð•œ E] [FiniteDimensional ð•œ F] : Nonempty (E â‰ƒL[ð•œ] F) â†” FiniteDimensional.finrank ð•œ E = FiniteDimensional.finrank ð•œ F
{ð•œ : Type u_1} {E : Type u} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] {s : Set E} {x : E} (hx : x âˆˆ â‡‘(convexHull ð•œ) s) : âˆƒ (Î¹ : Type u) (_x : Fintype Î¹) (z : Î¹ â†’ E) (w : Î¹ â†’ ð•œ) (hss : Set.Range z âŠ† s) (hai : AffineIndependent ð•œ z) (hw : âˆ€ (i : Î¹), 0 < w i), finset.univ.sum (Î» (i : Î¹), w i) = 1 âˆ§ finset.univ.sum (Î» (i : Î¹), w i â€¢ z i) = x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C} [CategoryTheory.Simple Y] {f : X âŸ¶ Y} [CategoryTheory.Mono f] (w : f â‰  0) : CategoryTheory.IsIso f
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] (Î¹ : Type u_1) [Unique Î¹] : FiniteDimensional.finrank K V = 1 â†” Nonempty (Basis Î¹ K V)
(x : Pgame) : (0 + x).equiv x
{Î± : Type u} [pseudoEmetricSpace Î±] (Î´ : â„) {Eâ‚ Eâ‚‚ : Set Î±} (h : Eâ‚ âŠ† Eâ‚‚) : Metric.Cthickening Î´ Eâ‚ âŠ† Metric.Cthickening Î´ Eâ‚‚
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Fintype Î¹] [DecidableEq Î¹] [Î  (i : Î¹), DecidableEq (Î± i)] [Î  (i : Î¹), LinearOrder (Î± i)] {p : (Î  (i : Î¹), Finset (Î± i)) â†’ Prop} (f : Î  (i : Î¹), Finset (Î± i)) (h0 : p (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), Finset (Î± i)) (i : Î¹) (x : Î± i), (âˆ€ (y : Î± i), y âˆˆ g i â†’ y < x) â†’ p g â†’ p (Function.update g i (HasInsert.insert x (g i)))) : p f
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : MultilinearMap ð•œ E G) {C : â„} (hC : 0 â‰¤ C) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ C * â†‘(Fintype.card Î¹) * Linear_order.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (Fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
{G : Type u} {x y : G} [CommMonoid G] (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y)
{Î± : Type u_1} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {s : Finset Î±} (hs : s âˆˆ ð’œ.shadow) : âˆƒ (t : Finset Î±) (H : t âˆˆ ð’œ), s âŠ† t
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : Vector Î± n) (x : Î±) : Vector.scanl f b (x::áµ¥v) = b::áµ¥Vector.scanl f (f b x) v
{ð•œ : Type u_1} [Field ð•œ] {M : Type u_2} [AddCommGroup M] [Module ð•œ M] (c : ð•œ) (f : M â†’â‚—[ð•œ] M) : â‡‘LinearMap.det (c â€¢ f) = c ^ FiniteDimensional.finrank ð•œ M * â‡‘LinearMap.det f
{F : Type u_3} [innerProductSpace â„ F] {x y : F} (hx : âˆ¥xâˆ¥ = 1) (hy : âˆ¥yâˆ¥ = 1) : HasInner.inner x y < 1 â†” x â‰  y
(p : â„•) [hp : Fact (Nat.Prime p)] (z : â„¤) : padicNorm p â†‘z â‰¤ 1
{A : Type u_6} [CommRing A] [is_IsDomain A] {M : Submonoid A} (hM : M â‰¤ NonZeroDivisors A) : is_IsDomain (Localization M)
{Î± : Type u} [NonUnitalNonAssocRing Î±] (a b c : Î±) : (a - b) * c = a * c - b * c
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {f : Filter Î±} {g : Filter Î²} {m : Î± â†’ Î²' â†’ Î³} {n : Î² â†’ Î²'} {m' : Î² â†’ Î± â†’ Î´} {n' : Î´ â†’ Î³} (h_Right_anticomm : âˆ€ (a : Î±) (b : Î²), m a (n b) = n' (m' b a)) : Filter.mapâ‚‚ m f (Filter.map n g) = Filter.map n' (Filter.mapâ‚‚ m' g f)
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {f : Î± â†’ Î²} (H : IsSemiringHom f) : IsRingHom f
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R M) [Nontrivial R] : e.det â‰  0
{Î± : Type u_1} [Preorder Î±] [AddCommMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (X Y : C) [CategoryTheory.Limits.HasBinaryProduct X Y] : CategoryTheory.Limits.HasBinaryBiproduct X Y
{Î¹ : Type u_1} {Î± : Type u_3} [Preorder Î¹] [Preorder Î±] {l : Filter Î¹} {u : Î¹ â†’ Î±} (h : Monotone u) [l.ne_IsBot] (hu : Filter.Tendsto u l Filter.atTop) : Filter.Tendsto u Filter.atTop Filter.atTop
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x : R) (hx : x â‰  0) : v.int_Valuation_def x â‰  0
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] [h : Nontrivial V] : 0 < FiniteDimensional.finrank K V
{ð•œ : Type u_3} [is_R_or_C ð•œ] {n m : â„•} (A B : Matrix (Fin n) (Fin m) ð•œ) (i j : Fin m) : HasInner.inner (A.transpose i) (B.transpose j) = A.conj_transpose.mul B i j
{F : Type u_8} {G : Type u_1} {H : Type u_2} [AddGroup G] [AddZeroClass H] [addMonoidHomClass F G H] (f : F) : Function.Injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 0 â†’ a = 0
{G : Type u_6} {H : Type u_7} {F : Type u_8} [Group G] [divisionMonoid H] [monoidHomClass F G H] (f : F) (a b : G) : â‡‘f (a / b) = â‡‘f a / â‡‘f b
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} {T : Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [CommMonoid Q] {k : T.localization_Map Q} {A : Type u_5} [CommMonoid A] {U : Submonoid A} {R : Type u_6} [CommMonoid R] (j : U.localization_Map R) {l : P â†’* A} (hl : âˆ€ (w : â†¥T), â‡‘l â†‘w âˆˆ U) : (k.map hl j).comp (f.map hy k) = f.map _ j
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] {r : â„} (hr : 0 < r) (x : E) : x +áµ¥ r â€¢ Metric.Ball 0 1 = Metric.Ball x r
{Î± : Type u_1} {G : Type u_4} {s : Set Î±} [SubtractionCommMonoid G] (f g : Î± â†’ G) (hs : s.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i - g i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) - finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), g i))
{Î´ : Type u_1} {Îº : Î´ â†’ Type u_2} [Î  (d : Î´), topologicalSpace (Îº d)] : Filter.coprod (Î» (d : Î´), Filter.cocompact (Îº d)) = Filter.cocompact (Î  (d : Î´), Îº d)
{R : Type u_1} [normedRing R] [CompleteSpace R] : OpenEmbedding Coe
(v : PrimeMultiset) : v.prod.factor_Multiset = v
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] : is_is_IsOpenMap Prod.snd
{Î± : Type u_1} {Î³ : Type u_3} {Î¹ : Type u_2} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {f : Filter Î±} (hF : f.has_Basis p s) {Î² : Î¹ â†’ Type u_4} {pg : Î  (i : Î¹), Î² i â†’ Prop} {sg : Î  (i : Î¹), Î² i â†’ Set Î³} {g : Set Î± â†’ Filter Î³} (hg : âˆ€ (i : Î¹), (g (s i)).has_Basis (pg i) (sg i)) (gm : Monotone g) : (f.lift g).has_Basis (Î» (i : Î£ (i : Î¹), Î² i), p i.fst âˆ§ pg i.fst i.snd) (Î» (i : Î£ (i : Î¹), Î² i), sg i.fst i.snd)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) {r : â„} (hr : 0 â‰¤ r) : hb.oangle (r â€¢ x) x = 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) : Collinear k s â†” âˆƒ (pâ‚€ : P) (v : V), âˆ€ (p : P), p âˆˆ s â†’ (âˆƒ (r : k), p = r â€¢ v +áµ¥ pâ‚€)
{Î± : Type u_1} {S : Finset Î±} {g : Î± â†’ â„•} (hS : âˆ€ (x : Î±), x âˆˆ S â†’ g x â‰  0) : (S.prod g).factorization = S.sum (Î» (x : Î±), (g x).factorization)
{M : Type u_1} [hasAdd M] (r : M â†’ M â†’ Prop) : addConGen â‡‘(addConGen r) = addConGen r
{E : Type u_3} [semiNormedGroup E] (g h : E) : âˆ¥g + hâˆ¥ â‰¤ âˆ¥gâˆ¥ + âˆ¥hâˆ¥
{R : Type u1} [CommSemiring R] {M : Type u2} [AddCommMonoid M] [Module R M] (m : M) : â‡‘(ExteriorAlgebraÎ¹ R) m * â‡‘(ExteriorAlgebraÎ¹ R) m = 0
{F : Type u_1} [NormedGroup F] [normedSpace â„ F] {f : â„ â†’ F} (K : Set F) : {x : â„ | DifferentiableWithinAt â„ f (Set.Ici x) x âˆ§ derivWithin f (Set.Ici x) x âˆˆ K} âŠ† RightDerivMeasurableAux.D f K
(m n k : â„•) : (m + n).choose k = (Finset.Nat.antidiagonal k).sum (Î» (ij : â„• Ã— â„•), m.choose ij.fst * n.choose ij.snd)
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), Group (Gs i)] (tfGs : âˆ€ (i : Î·), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Î  (i : Î·), Gs i)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] : (reflection K).trans (reflection K) = LinearIsometryEquiv.refl ð•œ E
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [NormedGroup G] [normedSpace ð•œ G] {n : â„•} (q : FormalMultilinearSeries ð•œ F G) (p : FormalMultilinearSeries ð•œ E F) (c : Composition n) : âˆ¥q.comp_along_Composition p câˆ¥ â‰¤ âˆ¥q c.lengthâˆ¥ * finset.univ.prod (Î» (i : Fin c.length), âˆ¥p (c.blocks_fun i)âˆ¥)
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] (b : Basis Î¹ R M) (f : M â†’ Î¹ â†’ R) (HAdd : âˆ€ (x y : M), f (x + y) = f x + f y) (hsmul : âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x) (f_Eq : âˆ€ (i : Î¹), f (â‡‘b i) = â‡‘(Finsupp.single i 1)) (x : M) (i : Î¹) : â‡‘(â‡‘(b.repr) x) i = f x i
{K : Type u_1} [linearOrderedField K] {c : ContinuedFraction K} : â†‘c.convergents = â†‘c.convergents'
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {Î¹ : Type u_6} [DecidableEq Î¹] {Mâ‚‚ : Type u_7} [AddCommMonoid Mâ‚‚] [Module R Mâ‚‚] (f : AlternatingMap R M N Î¹) (g : Mâ‚‚ â‰ƒâ‚—[R] M) : f.comp_Linear_Map â†‘g = 0 â†” f = 0
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {v : V} (pâ‚ pâ‚‚ : P) (hv : v â‰  0) (r : â„) : HasDist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ = HasDist.dist pâ‚ pâ‚‚ â†” r = 0 âˆ¨ r = (-2) * HasInner.inner v (pâ‚ -áµ¥ pâ‚‚) / HasInner.inner v v
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a : Î±} : a < 1 â†’ 1 < aâ»Â¹
(R : Type u_1) [CommRing R] {n : â„•} (hn : 2 â‰¤ n) : (Polynomial.cyclotomic n R).coeff 0 = 1
{Î± : Type u} [emetricSpace Î±] : UniformEmbedding TopologicalSpace.NonemptyCompacts.toCloseds
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R) (r : R) : â‡‘(v.valuation) (â‡‘(algebraMap R K) r) â‰¤ 1
{X : Top} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] (F : Top.Presheaf C X) : F.is_sheaf â†” F.is_sheaf_Pairwise_intersections
{Î± : Type u_1} (m : MeasureTheory.OuterMeasure Î±) {s : â„• â†’ Set Î±} (h_Mono : âˆ€ (n : â„•), s n âŠ† s (n + 1)) (h0 : âˆ‘' (k : â„•), â‡‘m (s (k + 1)  s k) â‰  âŠ¤) : â‡‘m (â‹ƒ (n : â„•), s n) = â¨† (n : â„•), â‡‘m (s n)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {v w : E} (h : HasInner.inner v w = 0) : âˆ¥w - vâˆ¥ = âˆ¥w + vâˆ¥
{Î± : Type u_1} [completeLattice Î±] {p q : Prop} {s : p â†’ q â†’ Î±} : (â¨† (hâ‚ : p) (hâ‚‚ : q), s hâ‚ hâ‚‚) = â¨† (h : p âˆ§ q), s _ _
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle y z + hb.oangle x y = hb.oangle x z
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [subtractionMonoid Î²] (f : Î± â†’+ Î²) (g h : Î±) : â‡‘f (g - h) = â‡‘f g - â‡‘f h
{R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} {Î¹' : Type u_5} [linearOrderedField R] [AddCommGroup E] [Module R E] (s : Finset Î¹) (t : Finset Î¹') (ws : Î¹ â†’ R) (zs : Î¹ â†’ E) (wt : Î¹' â†’ R) (zt : Î¹' â†’ E) (hws : s.sum (Î» (i : Î¹), ws i) = 1) (hwt : t.sum (Î» (i : Î¹'), wt i) = 1) (a b : R) (hab : a + b = 1) : a â€¢ s.center_mass ws zs + b â€¢ t.center_mass wt zt = (Finset.map Function.Embedding.inl s âˆª Finset.map Function.Embedding.inr t).center_mass (Sum.elim (Î» (i : Î¹), a * ws i) (Î» (j : Î¹'), b * wt j)) (Sum.elim zs zt)
{R : Type u_1} [NonAssocSemiring R] (f : â„• â†’+* R) : f = Nat.castRingHom R
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : r < 0) : hb.oangle (r â€¢ x) y = hb.oangle (-x) y
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hderiv : âˆ€ (x : â„), x âˆˆ Set.Interval a b â†’ DifferentiableAt â„ f x) (hint : IntervalIntegrable (deriv f) MeasureTheory.MeasureSpace.volume a b) : âˆ« (y : â„) in a..b, deriv f y = f b - f a
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [Nonempty Î±] (h : âˆ€ (c : Set Î±), IsChain r c â†’ c.nonempty â†’ (âˆƒ (ub : Î±), âˆ€ (a : Î±), a âˆˆ c â†’ r a ub)) (Trans : âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) : âˆƒ (m : Î±), âˆ€ (a : Î±), r m a â†’ r a m
{Î± : Type u_1} (a : Î±) (s : Set Î±) [measurableSpace Î±] (hs : MeasurableSet s) : â‡‘((Pmf.pure a).to_measure) s = Ite (a âˆˆ s) 1 0
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Sâ‚ Sâ‚‚ : Submodule K V} [FiniteDimensional K â†¥Sâ‚‚] (hle : Sâ‚ â‰¤ Sâ‚‚) (hD : FiniteDimensional.finrank K â†¥Sâ‚ = FiniteDimensional.finrank K â†¥Sâ‚‚) : Sâ‚ = Sâ‚‚
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : ConcaveOn ð•œ s f) {x y z : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hz : z âˆˆ Segment ð•œ x y) : Linear_order.min (f x) (f y) â‰¤ f z
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} (hs : Metric.Bounded s) (ht : Metric.Bounded t) : Metric.Bounded (s âˆª t)
{Î± : Type u} {Î² : Type v} {F : Type u_1} [NonAssocSemiring Î±] [NonAssocSemiring Î²] [addHomClass F Î± Î²] (f : F) (a : Î±) : â‡‘f (bit0 a) = bit0 (â‡‘f a)
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {f' : F} {x : ð•œ} {s t u : Set ð•œ} (hu : u âˆˆ nhds x) (h : s âˆ© u = t âˆ© u) : HasDerivWithinAt f f' s x â†’ HasDerivWithinAt f f' t x
{Î± : Type u_1} [pseudoMetricSpace Î±] {f : â„• â†’ Î±} (d : â„• â†’ â„) (hF : âˆ€ (n : â„•), HasDist.dist (f n) (f n.succ) â‰¤ d n) (hD : Summable d) : CauchySeq f
 : Â¬BddAbove {p : â„• | Nat.Prime p}
{C : Type (max v u)} [CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {D : Type w} [CategoryTheory.Category D] {K : Type (max v u)} [CategoryTheory.SmallCategory K] [CategoryTheory.Limits.HasLimitsOfShape K D] (F : K â¥¤ CategoryTheory.Sheaf J D) (E : CategoryTheory.Limits.Cone (F â‹™ CategoryTheory.sheafToPresheaf J D)) (hE : CategoryTheory.Limits.IsLimit E) : CategoryTheory.Presheaf.IsSheaf J E.X
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] (f : â„• â†’ R) (g : â„• â†’ M) (n : â„•) : (Finset.range n).sum (Î» (i : â„•), f i â€¢ g i) = f (n - 1) â€¢ (Finset.range n).sum (Î» (i : â„•), g i) - (Finset.range (n - 1)).sum (Î» (i : â„•), (f (i + 1) - f i) â€¢ (Finset.range (i + 1)).sum (Î» (i : â„•), g i))
{B : Type u_3} {S : B} {M : Type u_1} [AddCommMonoid M] [SetLike B M] [addSubmonoidClass B M] (m : Multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.sum âˆˆ S
{ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [NormedGroup G] [normedSpace ð•œ G] {f : ð•œ â†’ G} {s : Set ð•œ} {x y : ð•œ} {C : â„} (hF : DifferentiableOn ð•œ f s) (bound : âˆ€ (x : ð•œ), x âˆˆ s â†’ âˆ¥derivWithin f s xâˆ¥ â‰¤ C) (hs : Convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{Î¹ : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {ca cb : E} {la la' lb lb' : Filter â„} {Lt : Filter Î¹} {a b : â„} {ua ub va vb : Î¹ â†’ â„} [Interval_integral.FTC_Filter a la la'] [Interval_integral.FTC_Filter b lb lb'] (hab : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f la' MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f lb' MeasureTheory.MeasureSpace.volume) (ha_lim : Filter.Tendsto f (la' âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb_lim : Filter.Tendsto f (lb' âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds cb)) (hua : Filter.Tendsto ua Lt la) (hva : Filter.Tendsto va Lt la) (hub : Filter.Tendsto ub Lt lb) (hvb : Filter.Tendsto vb Lt lb) : (Î» (t : Î¹), ((âˆ« (x : â„) in va t..vb t, f x) - âˆ« (x : â„) in ua t..ub t, f x) - ((vb t - ub t) â€¢ cb - (va t - ua t) â€¢ ca)) =o[Lt] Î» (t : Î¹), âˆ¥va t - ua tâˆ¥ + âˆ¥vb t - ub tâˆ¥
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topologicalSpace Î±] [uniformSpace Î²] (f : C(Î±, Î²)) {Î¹ : Type uâ‚ƒ} {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} : Filter.Tendsto F p (nhds f) â†” âˆ€ (K : Set Î±), is_IsCompact K â†’ TendstoUniformlyOn (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p K
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (Fâ‚ Fâ‚‚ : CategoryTheory.MonoOver X â¥¤ CategoryTheory.MonoOver Y) (h : Fâ‚ â‰… Fâ‚‚) : CategoryTheory.Subobject.lower Fâ‚ = CategoryTheory.Subobject.lower Fâ‚‚
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [is_R_or_C ð•‚] [normedRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] : HasStrictFderivAt (Exp ð•‚) 1 0
{Î± : Type u_1} [topologicalSpace Î±] [t1_Space Î±] (x : Î±) [hx : (nhdsWithin x {x}á¶œ).ne_IsBot] {s : Set Î±} (hs : s âˆˆ nhds x) : s.infinite
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] {bâ‚ bâ‚‚ : Basis Î¹ R M} (h : âˆ€ (i : Î¹), â‡‘bâ‚ i = â‡‘bâ‚‚ i) : bâ‚ = bâ‚‚
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚} [CategoryTheory.Category K] (e : J â‰Œ K) [CategoryTheory.IsConnected J] : CategoryTheory.IsConnected K
{E : Type u_2} {ð•œ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] {s : Set E} (hs : Convex ð•œ s) {a b : ð•œ} (ha : 0 â‰¤ a) (hb : 0 < b) (hab : a + b = 1) : a â€¢ s + b â€¢ Interior s âŠ† Interior s
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a : Î±} : aâ»Â¹ < 1 â†’ 1 < a
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] (f : â„‚ â†’ E) (z w : â„‚) (s : Set â„‚) (hs : s.countable) (Hc : ContinuousOn f (Set.Interval z.re w.re Ã—â„‚ Set.Interval z.im w.im)) (hD : âˆ€ (x : â„‚), x âˆˆ Set.Ioo (Linear_order.min z.re w.re) (Linear_order.max z.re w.re) Ã—â„‚ Set.Ioo (Linear_order.min z.im w.im) (Linear_order.max z.im w.im)  s â†’ DifferentiableAt â„‚ f x) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * Complex.i) = 0
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} : CategoryTheory.Presieve.IsSheaf âŠ¥ P
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {Fâ‚ Fâ‚‚ : D â¥¤ C} [âˆ€ (X Y : C), Subsingleton (X âŸ¶ Y)] (hC : CategoryTheory.Skeletal C) (hF : Fâ‚ â‰… Fâ‚‚) : Fâ‚ = Fâ‚‚
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} : IsExtrOn (â‡‘OrderDual.toDual âˆ˜ f) s a â†’ IsExtrOn f s a
{p : â„•} [Fact (Nat.Prime p)] : padicNorm_e 1 = 1
{Î¹ : Type u} (s : Finset Î¹) (w z : Î¹ â†’ Nnreal) (hw' : s.sum (Î» (i : Î¹), w i) = 1) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), w i * z i) â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ p) ^ (1 / p)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} : StrictMonoOn f s â†’ StrictAntiOn (f âˆ˜ â‡‘OrderDual.ofDual) s
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topologicalSpace Î²] (f : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : Set Î±) {c : Set Î²} (hcâ‚ : is_IsCompact c) (hcâ‚‚ : âˆƒ (v : Set Ï„) (H : v âˆˆ f), Closure (Set.image2 Ï• v s) âŠ† c) {n : Set Î²} (hnâ‚ : is_IsOpen n) (hnâ‚‚ : OmegaLimit f Ï• s âŠ† n) : âˆƒ (u : Set Ï„) (H : u âˆˆ f), Closure (Set.image2 Ï• u s) âŠ† n
{G : Type u_1} [Group G] [hG : group.is_nilpotent G] : Nat.find _ = group.nilpotency_class G
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} {s t : Set Î±} {r : Ennreal} (h : x âˆˆ s) (H : Emetric.hausdorffEdist s t < r) : âˆƒ (y : Î±) (H : y âˆˆ t), HasEdist.edist x y < r
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [IsSymm Î± r] {a b : Î±} : r a b â†” r b a
{Î± : Type u} [topologicalSpace Î±] [t2_Space Î±] {Î¹ : Type u_1} [Nonempty Î¹] {V : Î¹ â†’ Set Î±} (hV : Directed Superset V) (hV_cpct : âˆ€ (i : Î¹), is_IsCompact (V i)) {U : Set Î±} (hU : âˆ€ (x : Î±), (x âˆˆ â‹‚ (i : Î¹), V i) â†’ U âˆˆ nhds x) : âˆƒ (i : Î¹), V i âŠ† U
{Î± : Type u} [Infinite Î±] {s : Set Î±} (hF : s.finite) : sá¶œ âˆˆ Filter.hyperfilter Î±
{R : Type u_1} {Râ‚‚ : Type u_3} {M : Type u_9} {Mâ‚‚ : Type u_12} [Semiring R] [Semiring Râ‚‚] [AddCommMonoid M] [AddCommMonoid Mâ‚‚] [Module R M] [Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} (h : âˆ€ (u v : â†¥(f.ker) â†’â‚—[R] M), f.comp u = f.comp v â†’ u = v) : f.ker = âŠ¥
{R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} {s : S} [Monoid S] [HasScalar R M] [HasScalar R S] [mulAction S M] [isScalarTower R S M] (h : a â€¢ s = 1) : IsSmulRegular M s
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (ht : t.nonempty) (hb : t.card â€¢ b â‰¤ s.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²) (H : y âˆˆ t), b â‰¤ (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
{Î± : Type u} [PartialOrder Î±] [OrderBot Î±] {a : Î±} : IsBot a â†’ a = âŠ¥
 : Filter.cofinite = Filter.atTop
{Î± : Type u_1} [linearOrderedAddCommGroup Î±] {x dx y dy : Î±} (h : dy < dx) (hx : 0 < dx) : Nonempty â†¥(Set.Ico x (x + dx)  Set.Ico y (y + dy))
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} (ha : a â‰  0) : char.quadratic_Char F a = -1 â†” Â¬char.quadratic_Char F a = 1
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î±] [Fintype Î±] [AddCommMonoid Î²] {Î´ : Î± â†’ Type u_3} {t : Î  (a : Î±), Finset (Î´ a)} (f : (Î  (a : Î±), a âˆˆ Finset.univ â†’ Î´ a) â†’ Î²) : (finset.univ.pi t).sum (Î» (x : Î  (a : Î±), a âˆˆ Finset.univ â†’ Î´ a), f x) = (Fintype.piFinset t).sum (Î» (x : Î  (a : Î±), Î´ a), f (Î» (a : Î±) (_x : a âˆˆ Finset.univ), x a))
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} (a : Î±) (b : Î²) (i : Î¹) : Filter.map (Prod.map (Î» (_x : Î±), b) Id) ((Filter.principal {a}).coprod (Filter.principal {i})) = Filter.principal ({b} Ã—Ë¢ Set.Univ)
{m : â„} (hm : 1 < m) (k : â„•) : Liouville.liouvilleNumber m = Liouville.liouvilleNumberInitialTerms m k + Liouville.liouvilleNumberTail m k
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) : âˆ¥S.normed_Mkâˆ¥ â‰¤ 1
{k : Type u_1} {M : Type u_2} [orderedSemiring k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] {a : M} {c : k} (hc : 0 < c) : a < 0 â†’ c â€¢ a < 0
{Î± : Type u_2} [Monoid Î±] (m : Î±) : IsSquare m â†’ (âˆƒ (c : Î±), m = c ^ 2)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x : R) : v.int_Valuation_def x â‰¤ 1
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] : CategoryTheory.Limits.HasLimits Cáµ’áµ–
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (sâ‚‚ : Finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (b : P) : â‡‘((Finset.map e sâ‚‚).weighted_vsub_of_point p b) w = â‡‘(sâ‚‚.weighted_vsub_of_point (p âˆ˜ â‡‘e) b) (w âˆ˜ â‡‘e)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Fintype Î¹] [DecidableEq Î¹] [Î  (i : Î¹), DecidableEq (Î± i)] [Î  (i : Î¹), LinearOrder (Î± i)] {p : (Î  (i : Î¹), Finset (Î± i)) â†’ Prop} (f : Î  (i : Î¹), Finset (Î± i)) (h0 : p (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), Finset (Î± i)) (i : Î¹) (x : Î± i), (âˆ€ (y : Î± i), y âˆˆ g i â†’ x < y) â†’ p g â†’ p (Function.update g i (HasInsert.insert x (g i)))) : p f
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} {Î³ : Type u_3} [Î  (a : Î±), CommMonoid (Î² a)] (s : Finset Î³) (g : Î³ â†’ Î  (a : Î±), Î² a) : s.prod (Î» (c : Î³), g c) = Î» (a : Î±), s.prod (Î» (c : Î³), g c a)
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {vâ‚ vâ‚‚ : M} (hvâ‚ : vâ‚ â‰  0) (hvâ‚‚ : vâ‚‚ â‰  0) : rayOfNeZero R vâ‚ hvâ‚ = rayOfNeZero R vâ‚‚ hvâ‚‚ â†” SameRay R vâ‚ vâ‚‚
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] [DecidableEq Î±] (s : Finset Î±) (a : Î±) (b : Î± â†’ Î²) : s.sum (Î» (x : Î±), Ite (x = a) (b x) 0) = Ite (a âˆˆ s) (b a) 0
{R : Type u_1} {M : Type u_2} {Î¹ : Type u_5} [CommRing R] [AddCommGroup M] [Module R M] [Fintype Î¹] (b : Basis Î¹ R M) (f : Î¹ â†’â‚€ R) (i : Î¹) : â‡‘(â‡‘(Finsupp.total Î¹ (Module.Dual R M) R b.coord) f) (â‡‘b i) = â‡‘f i
{R : Type u_1} (câ‚ câ‚‚ : R) : Cardinal.mk (QuaternionAlgebra R câ‚ câ‚‚) = Cardinal.mk R ^ 4
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {s : Set E} {f g : E â†’ F} (hF : ContDiffOn ð•œ n f s) (hg : ContDiffOn ð•œ n g s) : ContDiffOn ð•œ n (Î» (x : E), f x - g x) s
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} (h_Mono : MonotoneOn f s) (hs : s âˆˆ nhds a) (hfs_l : âˆ€ (b : Î²), b < f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ Set.Ioo b (f a))) (hfs_r : âˆ€ (b : Î²), b > f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ Set.Ioo (f a) b)) : ContinuousAt f a
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R M) {v : Î¹ â†’ M} (hli : LinearIndependent R v) (hsp : Submodule.span R (Set.Range v) = âŠ¤) (i : Î¹) : â‡‘(e.det) v â€¢ (Basis.mk hli hsp).coord i = e.det.to_multilinear_map.to_Linear_Map v i
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {s : Finset Î±} (hs : s âˆˆ ð’œ.up_shadow) : âˆƒ (t : Finset Î±) (H : t âˆˆ ð’œ), t âŠ† s
{Î² : Type u} {f g : Î² â†’ Type u} (Î± : Î  (j : Î²), f j âŸ¶ g j) (b : Î²) (x : âˆ Î» (j : Î²), f j) : Category_theory.limits.pi.Ï€ g b (CategoryTheory.Limits.Pi.map Î± x) = Î± b (Category_theory.limits.pi.Ï€ f b x)
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurableSpace Î±} [topologicalSpace Î²] [TopologicalSpace.PseudoMetrizableSpace Î²] [measurableSpace Î²] [BorelSpace Î²] (hF : MeasureTheory.StronglyMeasurable f) : Measurable f
{Î± : Type u_1} {s : Multiset Î±} {x : Multiset Î± Ã— Multiset Î±} : x âˆˆ s.antidiagonal â†” x.fst + x.snd = s
{R : Type u} [Semiring R] {M : Polynomial R â†’ Prop} {f : Polynomial R} (f0 : f.nat_degree â‰  0) (h_C_Add : âˆ€ {a : R} {p : Polynomial R}, M p â†’ M (â‡‘Polynomial.c a + p)) (h_Add : âˆ€ {p q : Polynomial R}, M p â†’ M q â†’ M (p + q)) (h_monomial : âˆ€ {n : â„•} {a : R}, a â‰  0 â†’ n â‰  0 â†’ M (â‡‘(Polynomial.monomial n) a)) : M f
{R : Type u_1} {M : Type u_2} [AddCommMonoid M] [CommRing R] [Nontrivial R] : Algebra.FiniteType R (AddMonoidAlgebra R M) â†” Add_monoid.fg M
{Î± : Type u_1} {Î² : Type u_2} [SemilatticeSup Î±] [OrderBot Î±] {P : Î± â†’ Prop} {Pbot : P âŠ¥} {Psup : âˆ€ â¦ƒx y : Î±â¦„, P x â†’ P y â†’ P (x âŠ” y)} (t : Finset Î²) (f : Î² â†’ {x // P x}) : â†‘(t.sup f) = t.sup (Î» (x : Î²), â†‘(f x))
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Vâ‚‚ : Type v'} [AddCommGroup Vâ‚‚] [Module K Vâ‚‚] [FiniteDimensional K V] [FiniteDimensional K Vâ‚‚] (Cond : FiniteDimensional.finrank K V = FiniteDimensional.finrank K Vâ‚‚) : Nonempty (V â‰ƒâ‚—[K] Vâ‚‚)
{f : â„• â†’ Nnreal} (hF : âˆ€ â¦ƒm n : â„•â¦„, 0 < m â†’ m â‰¤ n â†’ f n â‰¤ f m) : Summable (Î» (k : â„•), 2 ^ k * f (2 ^ k)) â†” Summable f
{F : Type u} [Field F] {n : â„•} (a : F) (hn : â†‘n â‰  0) (ha : a â‰  0) : (Polynomial.x ^ n - â‡‘Polynomial.c a).separable
{Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : a â‰¤ b) : Set.Iio a âŠ† Set.Iio b
{p : â„•} (hp : Nat.Prime p) (n k : â„•) : multiplicity p n â‰¤ multiplicity p (n.choose k) + multiplicity p k
{M : Type u_1} [hasAdd M] {c : AddCon M} {C : c.quotient â†’ Prop} (q : c.quotient) (H : âˆ€ (x : M), C â†‘x) : C q
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [semiNormedGroup Î²] (f : boundedContinuousFunction Î± Î²) (C : Nnreal) : âˆ¥fâˆ¥â‚Š â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥â‚Š â‰¤ C
{Î± : Type u} [AddGroup Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] {a : Î±} (h : 0 < a) : -a < a
{M : Type u_1} [MulOneClass M] (S : Submonoid M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{M : Type u_3} [AddCommGroup M] {Râ‚ : Type u_4} [CommRing Râ‚] [Module Râ‚ M] {Î¹ : Type u_6} [Fintype Î¹] [Invertible 2] (Q : QuadraticForm Râ‚ M) (v : Basis Î¹ Râ‚ M) (hvâ‚‚ : (â‡‘QuadraticForm.associated Q).is_Ortho â‡‘v) : Q.basis_repr v = QuadraticForm.weightedSumSquares Râ‚ (Î» (i : Î¹), â‡‘Q (â‡‘v i))
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : f =o[l] g â†’ âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ asymptotics.is_O_with c l f g
{M : Type u_1} [hasAdd M] {s : Set M} {p : M â†’ M â†’ Prop} {x y : M} (hx : x âˆˆ AddSubsemigroup.closure s) (hy : y âˆˆ AddSubsemigroup.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ p x y) (HMul_Left : âˆ€ (x y z : M), p x z â†’ p y z â†’ p (x + y) z) (HMul_Right : âˆ€ (x y z : M), p z x â†’ p z y â†’ p z (x + y)) : p x y
{x y : Pgame} (ox : x.numeric) (oy : y.numeric) : x â‰¤ y â†” (âˆ€ (i : x.left_moves), x.move_Left i < y) âˆ§ âˆ€ (j : y.right_moves), x < y.move_Right j
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (p : P) : Function.Injective (HasVsub.vsub p)
{R : Type u_1} {M : Type u_2} {N : Type u_3} [hasZero R] [hasZero M] [hasZero N] [HasScalar R M] [HasScalar R N] [NoZeroSmulDivisors R N] (f : M â†’ N) (hF : Function.Injective f) (h0 : f 0 = 0) (hs : âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x) : NoZeroSmulDivisors R M
(f f' : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hff' : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), f' c = (f b - f a) / (b - a)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : P) (direction : Submodule k V) : â†‘(AffineSubspace.mk' p direction).nonempty
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] [IsPredArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ Set.Ioc n m â†’ r (Order.pred i) i) (hmn : n < m) : Relation.TransGen r n m
(p : â„•) [hp : Fact (Nat.Prime p)] (n : â„•) {m : â„•} (hm : n â‰¤ m) : (TruncatedWittVector.zmodEquivTrunc p n).symm.to_Ring_hom.comp (TruncatedWittVector.truncate hm) = (Zmod.castHom _ (Zmod(p ^ n))).comp (TruncatedWittVector.zmodEquivTrunc p m).symm.to_ringHom
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] (e : localHomeomorph Î± Î²) {f : Î³ â†’ Î±} (h : f â»Â¹' e.to_local_equiv.source = Set.Univ) : Continuous f â†” Continuous (â‡‘e âˆ˜ f)
{n : â„•} : Nat.fib (n + 2) = Nat.fib n + Nat.fib (n + 1)
{Î± : Type u_1} {E : Type u_3} [topologicalSpace Î±] [CompactSpace Î±] [NormedGroup E] (f : C(Î±, E)) (x y : Î±) : HasDist.dist (â‡‘f x) (â‡‘f y) â‰¤ 2 * âˆ¥fâˆ¥
{Î± : Type u} {Î² : Type v} [Semiring Î±] [Semiring Î²] {f : Î± â†’ Î²} (hF : IsSemiringHom f) : IsMonoidHom f
{V : Type u_4} [innerProductSpace â„‚ V] (T : V â†’â‚—[â„‚] V) : InnerProductSpace.IsSelfAdjoint T â†” âˆ€ (v : V), â‡‘(starRingEnd â„‚) (HasInner.inner (â‡‘T v) v) = HasInner.inner (â‡‘T v) v
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {sâ‚ sâ‚‚ : AffineSubspace k P} {p : P} (h : p âˆˆ sâ‚ âŠ“ sâ‚‚) : (sâ‚ âŠ“ sâ‚‚).direction = sâ‚.direction âŠ“ sâ‚‚.direction
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} (h : â†‘s.nonempty) : â†‘(s.direction) = â†‘s -áµ¥ â†‘s
{Î± : sort u_1} {p : Î± â†’ Prop} (hp : âˆ€ (a : Î±), Â¬p a) : isEmpty (Subtype_ p)
{F : Type} [Field F] (q : â„•) [hF : ExpChar F q] (f : Polynomial F) [irred : Irreducible f] : Polynomial.HasSeparableContraction q f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (x : E) (hg : ContDiffWithinAt ð•œ n g t (f x)) (hF : ContDiffWithinAt ð•œ n f s x) (st : s âŠ† f â»Â¹' t) : ContDiffWithinAt ð•œ n (g âˆ˜ f) s x
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} : Convex ð•œ s â†’ s.ord_connected
(R : Type u) (M : Type v) (N : Type w) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [AddCommGroup N] [Module R N] [Module.Free R N] : Module.rank R (M Ã— N) = (Module.rank R M).lift + (Module.rank R N).lift
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) (Î¸ : Real.Angle) : â‡‘(hb.rotation Î¸) x = x â†” x = 0 âˆ¨ Î¸ = 0
{A : Type u_2} [normedRing A] [NormedAlgebra â„‚ A] [CompleteSpace A] (a : A) : filter.at_top.limsup (Î» (n : â„•), â†‘âˆ¥a ^ nâˆ¥â‚Š ^ (1 / â†‘n)) â‰¤ spectralRadius â„‚ a
{R : Type u_1} [CommSemiring R] {A : Type u_2} [Semiring A] (P Q : Algebra R A) (w : âˆ€ (r : R), â‡‘(algebraMap R A) r = â‡‘(algebraMap R A) r) : P = Q
{G : Type u_1} [Group G] (h : monoid.exponent_exists G) : monoid.is_torsion G
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {c : â„} {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : asymptotics.is_O_with c l f' g â†’ asymptotics.is_O_with c l (Î» (x : Î±), -f' x) g
{M : Type u_1} [AddZeroClass M] (S : addSubmonoid M) : 0 âˆˆ S
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [LinearOrder Î±] [OrderClosedTopology Î±] [Nonempty Î±] [topologicalSpace Î²] [hasZero Î±] {f : Î² â†’ Î±} (hF : Continuous f) (h : HasCompactSupport f) : BddAbove (Set.Range f)
{Î± : Type u_1} {s : Set Î±} : âŠ¥.is_clique s â†’ s.subsingleton
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {x : E} (hF : HasFderivAt f f' x) (v : E) {Î± : Type u_4} {c : Î± â†’ ð•œ} {l : Filter Î±} (hc : Filter.Tendsto (Î» (n : Î±), âˆ¥c nâˆ¥) l Filter.atTop) : Filter.Tendsto (Î» (n : Î±), c n â€¢ (f (x + (c n)â»Â¹ â€¢ v) - f x)) l (nhds (â‡‘f' v))
{Î± : Type u_1} [measurableSpace Î±] {mâ‚ mâ‚‚ : MeasureTheory.OuterMeasure Î±} {Op : Ennreal â†’ Ennreal} (h : âˆ€ (s : Set Î±), â‡‘mâ‚ s = Op (â‡‘mâ‚‚ s)) (s : Set Î±) : â‡‘(mâ‚.trim) s = Op (â‡‘(mâ‚‚.trim) s)
{R : Type u_2} {M : Type u_3} [AddCommGroup M] [Ring R] [Module R M] [Invertible 2] (Q : QuadraticForm R M) (hB : Q.anisotropic) : (â‡‘QuadraticForm.associated' Q).nondegenerate
{M : Type u_2} [AddCommGroup M] {ð•œ : Type u_1} [Field ð•œ] [Module ð•œ M] (f : M â‰ƒâ‚—[ð•œ] M) : â‡‘LinearMap.det â†‘(f.symm) = (â‡‘LinearMap.det â†‘f)â»Â¹
{Î± : Type u_1} [pseudoEmetricSpace Î±] {Î´Seq : â„• â†’ â„} (Î´Seq_lim : Filter.Tendsto Î´Seq Filter.atTop (nhds 0)) (E : Set Î±) : Filter.Tendsto (Î» (n : â„•), thickenedIndicatorAux (Î´Seq n) E) Filter.atTop (nhds ((Closure E).indicator (Î» (x : Î±), 1)))
{Î± : Type u} [topologicalSpace Î±] [t2_Space Î±] {x y : Î±} (h : x â‰  y) : âˆƒ (u v : Set Î±), is_IsOpen u âˆ§ is_IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ u âˆ© v = âˆ…
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.FiniteType R A â†” âˆƒ (n : â„•) (f : MvPolynomial (Fin n) R â†’â‚[R] A), Function.Surjective â‡‘f
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] {p1 p2 p : P} (h : p -áµ¥ p1 = p -áµ¥ p2) : p1 = p2
{Î± : Type u} [CommSemiring Î±] {p p' ps ps' : Î±} : p = p' â†’ ps = ps' â†’ p + ps = p' + ps'
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} {N : Type u_7} [AddCommMonoid M] [AddCommMonoid N] {f : Î± â†’ Î²} {s : Î± â†’â‚€ M} (h : Î² â†’ M â†’+ N) : (Finsupp.mapDomain f s).sum (Î» (b : Î²) (m : M), â‡‘(h b) m) = s.sum (Î» (a : Î±) (m : M), â‡‘(h (f a)) m)
{a b k : â„•} (h_Ab_IsCoprime : a.coprime b) (hka : k âˆ£ a) (hkb : k âˆ£ b) : k = 1
{Î± : Type u_1} [pseudoMetricSpace Î±] {Î´ : â„} {E : Set Î±} (hE : is_IsCompact E) (hÎ´ : 0 â‰¤ Î´) : Metric.Cthickening Î´ E = â‹ƒ (x : Î±) (H : x âˆˆ E), Metric.ClosedBall x Î´
{Î± : Type u_1} {ð’œ : Finset (Finset Î±)} {A : Finset Î±} {r : â„•} : A âˆˆ ð’œ.slice r â†” A âˆˆ ð’œ âˆ§ A.card = r
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [Fintype Î¹] {p : Î¹ â†’ P} (hi : AffineIndependent k p) {sm : Submodule k V} [FiniteDimensional k â†¥sm] (hle : vectorSpan k (Set.Range p) â‰¤ sm) (hc : Fintype.card Î¹ = FiniteDimensional.finrank k â†¥sm + 1) : vectorSpan k (Set.Range p) = sm
{K : Type u_1} [linearOrderedField K] {v : K} {n : â„•} [floorRing K] {ifp_n : GeneralizedContinuedFraction.IntFractPair K} : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n â†’ v = GeneralizedContinuedFraction.compExactValue ((GeneralizedContinuedFraction.of v).continuants_aux n) ((GeneralizedContinuedFraction.of v).continuants_aux (n + 1)) ifp_n.fr
{C : Type u} [CategoryTheory.Category C] {X Y : C} [CategoryTheory.Limits.HasZeroMorphisms C] (f : X âŸ¶ Y) [CategoryTheory.Limits.HasKernel f] {Z : C} (h : Y âŸ¶ Z) [CategoryTheory.Mono h] : CategoryTheory.Limits.kernelSubobject (f â‰« h) = CategoryTheory.Limits.kernelSubobject f
{M : Type u_1} [AddZeroClass M] {c d : AddCon M} (h : c â‰¤ d) (x : c.quotient) : â‡‘(c.map d h) x = â‡‘(c.lift d.mk' _) x
{G : Type u_3} [Group G] (P : Subgroup G) : P.fg â†” âˆƒ (S : Set G), Subgroup.closure S = P âˆ§ S.finite
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} [DecidableEq Î³] {f f' : Î± â†’ Î² â†’ Î³} {s : Finset Î±} {t : Finset Î²} (h : âˆ€ (a : Î±) (b : Î²), f a b = f' a b) : Finset.imageâ‚‚ f s t = Finset.imageâ‚‚ f' s t
{Î± : Type u_1} {Î² : Type u_2} {e : LocalEquiv Î± Î²} {s : Set Î±} {t : Set Î²} : e.is_image s t â†’ e.source âˆ© â‡‘e â»Â¹' t = e.source âˆ© s
{ð•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [NormedGroup E] [NormedGroup Fâ‚—] [nondiscreteNormedField ð•œ] [normedSpace ð•œ E] [normedSpace ð•œ Fâ‚—] {r : â„} (r_Pos : 0 < r) (c : â„) (f : E â†’â‚—[ð•œ] Fâ‚—) (h : âˆ€ (z : E), z âˆˆ Metric.Ball 0 r â†’ âˆ¥â‡‘f zâˆ¥ â‰¤ c) : âˆƒ (C : â„), âˆ€ (z : E), âˆ¥â‡‘f zâˆ¥ â‰¤ C * âˆ¥zâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [LinearOrder Î±] [topologicalSpace Î³] {a b : Î±} {h : a â‰¤ b} [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] {f : Î³ â†’ â†¥(Set.Icc a b) â†’ Î²} {g : Î³ â†’ Î±} (hF : Continuous â†¿f) (hg : Continuous g) : Continuous (Î» (a_1 : Î³), Set.iccExtend h (f a_1) (g a_1))
{G : Type u_1} [Group G] (H : Subgroup G) : H = âŠ¥ âˆ¨ Nontrivial â†¥H
{R : Type u_1} {G : Type u_4} [Group G] [mulAction G R] (g : G) : IsSmulRegular R g
{Î± : Type u} {Î² : Type v} [hasAdd Î±] [hasAdd Î²] {Î³ : Type u_1} [hasAdd Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³} (hF : IsAddHom f) (hg : IsAddHom g) : IsAddHom (g âˆ˜ f)
{X : Type u_1} {Y : Type u_2} [pseudoEmetricSpace X] [pseudoEmetricSpace Y] {C : Nnreal} {f : X â†’ Y} : LipschitzWith C f â†’ HolderWith C 1 f
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : M (Sum.inr ()) (Sum.inr ()) â‰  0) (i : Fin r) : ((Matrix.Pivot.listTransvecCol M).prod.mul M).mul (Matrix.Pivot.listTransvecRow M).prod (Sum.inl i) (Sum.inr ()) = 0
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] [IsPredArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ Set.Ioc n m â†’ r (Order.pred i) i) (hmn : n â‰¤ m) : Relation.ReflTransGen r n m
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [AddCommMonoid Î²] {s : Finset Î³} {t : Î³ â†’ Finset Î±} {t' : Finset Î±} {s' : Î± â†’ Finset Î³} (h : âˆ€ (x : Î³) (y : Î±), x âˆˆ s âˆ§ y âˆˆ t x â†” x âˆˆ s' y âˆ§ y âˆˆ t') {f : Î³ â†’ Î± â†’ Î²} : s.sum (Î» (x : Î³), (t x).sum (Î» (y : Î±), f x y)) = t'.sum (Î» (y : Î±), (s' y).sum (Î» (x : Î³), f x y))
(C : Type u) [CategoryTheory.Category C] [âˆ€ {J : Type v} {X Y : C} {f : J â†’ (X âŸ¶ Y)}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelFamily f)] : CategoryTheory.Limits.HasWideCoequalizers C
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {f : Filter Î²} {u : Î² â†’ Î±} : (âˆƒ (b : Î±), âˆ€ (x : Î²), r (u x) b) â†’ Filter.IsBoundedUnder r f u
{Î± : Type u_1} [Field Î±] (E : LinearRecurrence Î±) : Module.rank Î± â†¥(E.sol_Space) = â†‘(E.order)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), AddCommMonoid (Mâ‚' i)] [Î  (i : Î¹), Module R (Mâ‚' i)] {Mâ‚'' : Î¹ â†’ Type u_2} [Î  (i : Î¹), AddCommMonoid (Mâ‚'' i)] [Î  (i : Î¹), Module R (Mâ‚'' i)] (g : MultilinearMap R Mâ‚'' Mâ‚‚) (fâ‚ : Î  (i : Î¹), Mâ‚' i â†’â‚—[R] Mâ‚'' i) (fâ‚‚ : Î  (i : Î¹), Mâ‚ i â†’â‚—[R] Mâ‚' i) : (g.comp_Linear_Map fâ‚).comp_Linear_Map fâ‚‚ = g.comp_Linear_Map (Î» (i : Î¹), (fâ‚ i).comp (fâ‚‚ i))
(R : Type u_1) {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K] (p : â„•) [Char_p R p] : Char_p K p
(n : â„•) : iteratedDeriv n (expNegInvGlue.fAux 0) = expNegInvGlue.fAux n
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (ha : ContinuousAt f a) : HasStrictDerivAt (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) a
{Î± : Type u} (p : Î± â†’ Prop) [DecidablePred p] (xs : List Î±) (h : âˆ€ (x : Î±), x âˆˆ xs â†’ Â¬p x) : List.splitOn_p p xs = [xs]
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace E] [CompleteSpace â†¥K] (u v : E) : HasInner.inner â†‘(â‡‘(orthogonalProjection K) u) v = HasInner.inner u â†‘(â‡‘(orthogonalProjection K) v)
{X : Type v} [topologicalSpace X] [LocallyCompactSpace X] [SigmaCompactSpace X] [t2_Space X] {Î¹ : X â†’ Type u} {p : Î  (x : X), Î¹ x â†’ Prop} {B : Î  (x : X), Î¹ x â†’ Set X} (hB : âˆ€ (x : X), (nhds x).has_Basis (p x) (B x)) : âˆƒ (Î± : Type v) (c : Î± â†’ X) (r : Î  (a : Î±), Î¹ (c a)), (âˆ€ (a : Î±), p (c a) (r a)) âˆ§ (â‹ƒ (a : Î±), B (c a) (r a)) = Set.Univ âˆ§ LocallyFinite (Î» (a : Î±), B (c a) (r a))
{G : Type u_1} [Group G] {Î¹ : sort u_2} (S : Î¹ â†’ Subgroup G) {C : G â†’ Prop} {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : G), x âˆˆ S i â†’ C x) (h1 : C 1) (HMul : âˆ€ (x y : G), C x â†’ C y â†’ C (x * y)) : C x
{F : Type u_3} [innerProductSpace â„ F] (x y : F) : HasInner.inner x y * HasInner.inner x y â‰¤ HasInner.inner x x * HasInner.inner y y
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hs : (s âˆ© Function.Support f).finite) (ht : (t âˆ© Function.Support f).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆ© t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] (f : â„‚ â†’ E) (f' : â„‚ â†’ (â„‚ â†’L[â„] E)) (z w : â„‚) (s : Set â„‚) (hs : s.countable) (Hc : ContinuousOn f (Set.Interval z.re w.re Ã—â„‚ Set.Interval z.im w.im)) (hD : âˆ€ (x : â„‚), x âˆˆ Set.Ioo (Linear_order.min z.re w.re) (Linear_order.max z.re w.re) Ã—â„‚ Set.Ioo (Linear_order.min z.im w.im) (Linear_order.max z.im w.im)  s â†’ HasFderivAt f (f' x) x) (Hi : MeasureTheory.IntegrableOn (Î» (z : â„‚), Complex.i â€¢ â‡‘(f' z) 1 - â‡‘(f' z) Complex.i) (Set.Interval z.re w.re Ã—â„‚ Set.Interval z.im w.im) MeasureTheory.MeasureSpace.volume) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * Complex.i) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, Complex.i â€¢ â‡‘(f' (â†‘x + â†‘y * Complex.i)) 1 - â‡‘(f' (â†‘x + â†‘y * Complex.i)) Complex.i
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
{R : Type u_2} {M : Type u_3} [AddCommGroup M] [Ring R] [Module R M] [Invertible 2] {Q : QuadraticForm R M} (hBâ‚ : â‡‘QuadraticForm.associated' Q â‰  0) : âˆƒ (x : M), â‡‘Q x â‰  0
{Î± : Type u} [pseudoEmetricSpace Î±] {x y : Î±} {s t : Set Î±} (xs : x âˆˆ s) (yt : y âˆˆ t) : Emetric.diam (s âˆª t) â‰¤ Emetric.diam s + HasEdist.edist x y + Emetric.diam t
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’sl[Ïƒâ‚â‚‚] F) (M : Nnreal) (hM : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥â‚Š â‰¤ M * âˆ¥xâˆ¥â‚Š) : âˆ¥fâˆ¥â‚Š â‰¤ M
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {f g : â„‚ â†’ E} (hdf : DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Iio 0)) (hBf : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Iio 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hdg : DiffContOnCl â„‚ g (Set.Ioi 0 Ã—â„‚ Set.Iio 0)) (hBg : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Iio 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = g â†‘x) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.i) = g (â†‘x * Complex.i)) : Set.EqOn f g {z : â„‚ | 0 â‰¤ z.re âˆ§ z.im â‰¤ 0}
{M : Type u_4} [groupWithZero M] {f g : â„š â†’*â‚€ M} (same_on_Neg_One : â‡‘f (-1) = â‡‘g (-1)) (same_on_pnat : âˆ€ (n : â„•), 0 < n â†’ â‡‘f â†‘n = â‡‘g â†‘n) : f = g
{Î± : Type u_1} {Î² : Type u_2} (e : LocalEquiv Î± Î²) : e.trans e.symm â‰ˆ LocalEquiv.ofSet e.source
(A : Type u_4) [CommRing A] [is_IsDomain A] {K : Type u_5} [CommRing K] [Algebra A K] [IsFractionRing A K] : is_IsDomain K
{R : Type u_1} [CommRing R] (u v w x : Fin 3 â†’ R) : Matrix.dotProduct (â‡‘(â‡‘crossProduct u) v) (â‡‘(â‡‘crossProduct w) x) = Matrix.dotProduct u w * Matrix.dotProduct v x - Matrix.dotProduct u x * Matrix.dotProduct v w
{Î¹ : Type u} (s : Finset Î¹) (f : Î¹ â†’ Ennreal) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), f i) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), f i ^ p)
{R : Type u} {M : Type v} [Group R] [mulAction R M] {p : SubMulAction R M} (m : â†¥p) : MulAction.stabilizer R m = MulAction.stabilizer R â†‘m
{R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [CommRing R] [AddCommGroup M] [Module R M] [Fintype Î¹] (b : Basis Î¹ R M) : Module.Finite R M
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q) : (âˆ€ (a : â†¥P), â‡‘f a = 0) â†’ f = 0
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Abelian V] {A B C D A' B' C' D' : V} {f : A âŸ¶ B} {g : B âŸ¶ C} {h : C âŸ¶ D} {f' : A' âŸ¶ B'} {g' : B' âŸ¶ C'} {h' : C' âŸ¶ D'} {Î± : A âŸ¶ A'} {Î² : B âŸ¶ B'} {Î³ : C âŸ¶ C'} {Î´ : D âŸ¶ D'} (commâ‚ : Î± â‰« f' = f â‰« Î²) (commâ‚‚ : Î² â‰« g' = g â‰« Î³) (commâ‚ƒ : Î³ â‰« h' = h â‰« Î´) (hgh : CategoryTheory.Exact g h) (hF'g' : CategoryTheory.Exact f' g') (hg'h' : CategoryTheory.Exact g' h') (hÎ± : CategoryTheory.Epi Î±) (hÎ³ : CategoryTheory.Epi Î³) (hÎ´ : CategoryTheory.Mono Î´) : CategoryTheory.Epi Î²
{R : Type u_1} {a b : R} [Semigroup R] (Ab : IsRightRegular (b * a)) : IsRightRegular b
{M : Type u_6} {N : Type u_7} [hasAdd M] [hasAdd N] {f g : M â‰ƒ+ N} (h : âˆ€ (x : M), â‡‘f x = â‡‘g x) : f = g
{b : â„•} (hb : 1 < b) {x y : â„•} (hy : 0 < y) : b ^ x â‰¤ y â†” x â‰¤ Nat.log b y
{Î± : Type u_1} [uniformSpace Î±] [CompactSpace Î±] [SeparatedSpace Î±] : Uniformity Î± = â¨† (x : Î±), nhds (x, x)
{G : Type u_1} [Group G] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime pâ‚)] [hpâ‚‚ : Fact (Nat.Prime pâ‚‚)] (hne : pâ‚ â‰  pâ‚‚) (Hâ‚ Hâ‚‚ : Subgroup G) (hHâ‚ : is_p_Group pâ‚ â†¥Hâ‚) (hHâ‚‚ : is_p_Group pâ‚‚ â†¥Hâ‚‚) : Disjoint Hâ‚ Hâ‚‚
{Î± : Type u_2} [DecidableEq Î±] [HasSub Î±] {u : Finset Î±} {s t : Set Î±} : â†‘u âŠ† s - t â†’ (âˆƒ (s' t' : Finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' - t')
{R : Type u_1} {K : Type u_2} [Semiring R] [CommSemiring K] {b : R} {bi : K} (i : R â†’+* K) (f : Polynomial R) (a : R) (bu : bi * â‡‘i b = 1) : DenomsClearable a b f.nat_degree f i
(H : AddSubgroup â„¤) : âˆƒ (a : â„¤), H = AddSubgroup.closure {a}
{R : Type u} [Semiring R] {p : Polynomial R} : Polynomial.x * p = p * Polynomial.x
{Î± : Type u_1} {n : Type u_4} {m : Type u_5} [hasZero Î±] {A : Matrix m m Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} (h : (Matrix.fromBlocks A 0 C D).is_Symm) (ha : A.is_diag) (hD : D.is_diag) : (Matrix.fromBlocks A 0 C D).is_diag
{R : Type u_1} [CommRing R] (u v w : Fin 3 â†’ R) : â‡‘(â‡‘crossProduct u) (â‡‘(â‡‘crossProduct v) w) + â‡‘(â‡‘crossProduct v) (â‡‘(â‡‘crossProduct w) u) + â‡‘(â‡‘crossProduct w) (â‡‘(â‡‘crossProduct u) v) = 0
{Î¹ : Type u_1} {X : Type u_2} [topologicalSpace X] [NormalSpace X] {u : Î¹ â†’ Set X} {s : Set X} {c : Set (ShrinkingLemma.PartialRefinement u s)} (hc : IsChain LE.le c) {vâ‚ vâ‚‚ : ShrinkingLemma.PartialRefinement u s} (hâ‚ : vâ‚ âˆˆ c) (hâ‚‚ : vâ‚‚ âˆˆ c) {i : Î¹} (hiâ‚ : i âˆˆ vâ‚.carrier) (hiâ‚‚ : i âˆˆ vâ‚‚.carrier) : â‡‘vâ‚ i = â‡‘vâ‚‚ i
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} {ps : Set P} (h : ps âŠ† â†‘s) [Nonempty â†¥s] {n : â„•} [FiniteDimensional â„ â†¥(s.direction)] (hD : FiniteDimensional.finrank â„ â†¥(s.direction) = n) (hc : EuclideanGeometry.Cospherical ps) : âˆƒ (c : P), âˆ€ (sx : Affine.Simplex â„ P n), Set.Range sx.points âŠ† ps â†’ sx.circumcenter = c
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} {f : ð•œ â†’ F} : iteratedFderiv ð•œ n f = â‡‘(ContinuousMultilinearMap.piFieldEquiv ð•œ (Fin n) F) âˆ˜ iteratedDeriv n f
{ð•‚ : Type u_6} [is_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [normedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [normedSpace ð•‚ F'] {f : E' â†’ F'} {x : E'} (hF : ContDiffAt ð•‚ 1 f x) (K : Nnreal) (hK : âˆ¥fderiv ð•‚ f xâˆ¥â‚Š < K) : âˆƒ (t : Set E') (H : t âˆˆ nhds x), LipschitzOnWith K f t
{Î± : Type u} {a b c d : Î±} [Preorder Î±] (hca : c â‰¤ a) (hbd : b â‰¤ d) : a â‰¤ b â†’ c â‰¤ d
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} [DecidableEq Î¹] {V : Î¹ â†’ Submodule ð•œ E} (hV : OrthogonalFamily ð•œ (Î» (i : Î¹), (V i).subtypeâ‚—áµ¢)) (hc : IsComplete â†‘(supr V)) : DirectSum.IsInternal V â†” (supr V)á—® = âŠ¥
{Î± : Type u_1} {l : List Î±} {x : Î±} : List.Duplicate x l â†” [x, x] <+ l
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] {s : Finset Î±} (hc : s.card â‰¤ 1) {f : Î± â†’ Î²} {b : Î²} (h : s.prod (Î» (x : Î±), f x) = b) (x : Î±) (H : x âˆˆ s) : f x = b
{Î± : Type u_1} {m : measurableSpace Î±} (Î½ : MeasureTheory.Measure Î±) [MeasureTheory.SigmaFinite Î½] {f : Î± â†’ Ennreal} (hF : Measurable f) : (Î½.with_density f).rn_deriv Î½ =áµ[Î½] f
{t : â†¥UnitInterval} : 0 â‰¤ t
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} {v : V} (hv : v âˆˆ s.direction) {p : P} (hp : p âˆˆ s) : v +áµ¥ p âˆˆ s
(a : â†¥Circle) : â‡‘LinearMap.det â†‘((â‡‘rotation a).to_linearEquiv) = 1
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} (hF : Continuous f) : Filter.comap f (Filter.cocompact Î²) â‰¤ Filter.cocompact Î±
(Fq F : Type) [Field Fq] [Field F] (Fqt : Type u_1) [Field Fqt] [Algebra (Polynomial Fq) Fqt] [IsFractionRing (Polynomial Fq) Fqt] [Algebra (Ratfunc Fq) F] [Algebra Fqt F] [Algebra (Polynomial Fq) F] [isScalarTower (Polynomial Fq) Fqt F] [isScalarTower (Polynomial Fq) (Ratfunc Fq) F] : FunctionField Fq F â†” FiniteDimensional Fqt F
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} : IsMaxOn (â‡‘OrderDual.toDual âˆ˜ f) s a â†’ IsMinOn f s a
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {a b : Î±} (l : List Î±) (hlâ‚ : List.Chain r a l) (hlâ‚‚ : (a :: l).last _ = b) : Relation.ReflTransGen r a b
{Î± : Type u_1} [CircularPreorder Î±] {a b c : Î±} (habc : HasBtw.Btw a b c) (hcba : Â¬HasBtw.Btw c b a) : HasSbtw.Sbtw a b c
{n : WithTop â„•} {ð•‚ : Type u_6} [is_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [normedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [normedSpace ð•‚ F'] {s : Set E'} {f : E' â†’ F'} {x : E'} {p : E' â†’ FormalMultilinearSeries ð•‚ E' F'} (hF : HasFtaylorSeriesUpToOn n f p s) (hn : 1 â‰¤ n) (hs : s âˆˆ nhds x) : HasStrictFderivAt f (â‡‘(Continuous_multilinear_Curry_Fin1 ð•‚ E' F') (p x 1)) x
{Î± : Type u_1} [DecidableEq Î±] (s : Set Î±) [Fintype â†¥s] {a : Î±} (h : a âˆˆ s) : a âˆˆ Tactic.IntervalCases.setElems s
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î±] [Fintype Î±] [CommSemiring Î²] {Î´ : Î± â†’ Type u_1} [Î  (a : Î±), DecidableEq (Î´ a)] {t : Î  (a : Î±), Finset (Î´ a)} {f : Î  (a : Î±), Î´ a â†’ Î²} : finset.univ.prod (Î» (a : Î±), (t a).sum (Î» (b : Î´ a), f a b)) = (Fintype.piFinset t).sum (Î» (p : Î  (a : Î±), Î´ a), finset.univ.prod (Î» (x : Î±), f x (p x)))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} : ContDiff ð•œ n Prod.fst
(R : Type u_1) {p m : â„•} [Fact (Nat.Prime p)] [Ring R] [Char_p R p] (hm : Â¬p âˆ£ m) {k : â„•} : 0 < k â†’ Polynomial.cyclotomic (p ^ k * m) R = Polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1))
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G : C â¥¤ D} (Î± : F âŸ¶ G) [âˆ€ (X : C), CategoryTheory.Epi (Î±.app X)] : CategoryTheory.Epi Î±
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f : V â†’â‚—[K] V} (hinj : Function.Injective â‡‘f) : Function.Surjective â‡‘f
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.MulPosMono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (b0 : 0 < b) : 1 â‰¤ a * b
{Î± : Type v} [LinearOrder Î±] [topologicalSpace Î±] [OrderClosedTopology Î±] {s : Set Î±} (hs : IsPreconnected s) {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) : Set.Icc a b âŠ† s
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (T : Type u_4) [CommRing T] [Algebra R T] (M N : Submonoid R) (h : M â‰¤ N) [IsLocalization M S] [IsLocalization N T] : isScalarTower R S T
{Î± : Type u_1} {s : Finset Î±} {p : Î± â†’ Prop} [DecidablePred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : Finset.map (Function.Embedding.subtype p) (Finset.subtype p s) = s
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : hb.oangle (-x) (-y) = hb.oangle x y
{Î¹ : Type u_1} {R : Type u_2} {Î± : Type u_3} {S : Type u_4} [SetLike S R] [Monoid R] [AddMonoid Î¹] (A : Î¹ â†’ S) [SetLike.GradedMonoid A] (fÎ¹ : Î± â†’ Î¹) (fA : Î  (a : Î±), â†¥(A (fÎ¹ a))) (l : List Î±) : l.dprod fÎ¹ fA = âŸ¨(List.map (Î» (a : Î±), â†‘(fA a)) l).prod, _âŸ©
{Î± : Type u_1} [AddCommMonoid Î±] [topologicalSpace Î±] {a : Î±} {f : â„• â†’ Î±} (h : HasSum f a) : Filter.Tendsto (Î» (n : â„•), (Finset.range n).sum (Î» (i : â„•), f i)) Filter.atTop (nhds a)
{Î± : Type u_1} [measurableSpace Î±] {s : Set Î±} : MeasurableSet s â†’ (Filter.principal s).is_measurably_generated
(p : â„•) [Fact (Nat.Prime p)] (a : â„¤) (ha : â†‘a â‰  0) : Zmod.legendreSym p a = 1 âˆ¨ Zmod.legendreSym p a = -1
{Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î²] [topologicalSpace Î³] {Îº : Type u_5} {g : Î² â†’ Î³} {f : Îº â†’ Î²} (hg : DenseRange g) (hF : DenseRange f) (cg : Continuous g) : DenseRange (g âˆ˜ f)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X âŸ¶ Y) [CategoryTheory.Limits.HasEqualizer f g] : CategoryTheory.Limits.HasKernel (f - g)
{ð•œ : Type u_1} [linearOrderedField ð•œ] {x y : ð•œ} (h : x < y) {z : ð•œ} : z âˆˆ Set.Ioc x y â†” âˆƒ (a b : ð•œ), 0 â‰¤ a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : AddZeroClass M} {mN : AddZeroClass N} [addMonoidHomClass F M N] (f : F) {x : M} (hx : âˆƒ (y : M), x + y = 0) : âˆƒ (y : N), â‡‘f x + y = 0
{R : Type u1} [CommSemiring R] {M : Type u2} [AddCommMonoid M] [Module R M] : Disjoint (ExteriorAlgebraÎ¹ R).range 1
{F : Type u_3} [innerProductSpace â„ F] {K : Set F} (h : Convex â„ K) {u v : F} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (w : â†¥K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : F), w âˆˆ K â†’ HasInner.inner (u - v) (w - v) â‰¤ 0
{R : Type u_1} [CancelCommMonoidWithZero R] {x y a p : R} {n : â„•} (hp : Prime p) (hx : x * y = a * p ^ n) : âˆƒ (i j : â„•) (b c : R), i + j = n âˆ§ a = b * c âˆ§ x = b * p ^ i âˆ§ y = c * p ^ j
(A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension âˆ… A B] : âŠ¥ = âŠ¤
{Î± : Type u_1} [HasLe Î±] {a : Î±} : IsTop a â†’ IsBot (â‡‘OrderDual.toDual a)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] {x : E} {s : Set E} (hx : x âˆˆ s) (hs : s â‰  Set.Univ) : âˆƒ (y : E) (H : y âˆˆ Frontier s), Metric.infDist x sá¶œ = HasDist.dist x y
{Î± : Type u_1} [pseudoEmetricSpace Î±] (C : Ennreal) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (f n) (f (n + 1)) â‰¤ C / 2 ^ n) {a : Î±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) : HasEdist.edist (f 0) a â‰¤ 2 * C
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} (F : Top.Presheaf C X) (U : TopologicalSpace.Opens â†¥X) (R : CategoryTheory.Presieve U) (hR : CategoryTheory.Sieve.generate R âˆˆ â‡‘(Opens.grothendieckTopology â†¥X) U) : CategoryTheory.Presheaf.forkMap R F â‰« (Top.Presheaf.coveringOfPresieve.firstObjIsoPiOpens F U R).hom = F.map (CategoryTheory.eqToHom _).op â‰« Top.Presheaf.SheafConditionEqualizerProducts.res F (Top.Presheaf.coveringOfPresieve U R)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : EuclideanGeometry.orthogonalProjectionFn s p âˆˆ AffineSubspace.mk' p (s.direction)á—®
{Î± : Type u_1} {G : Type u_4} [SubtractionCommMonoid G] {f g : Î± â†’ G} (hF : (Function.Support f).finite) (hg : (Function.Support g).finite) : finsum (Î» (i : Î±), f i - g i) = finsum (Î» (i : Î±), f i) - finsum (Î» (i : Î±), g i)
{Î± : Type u_2} [Semiring Î±] {a : Î±} : Odd a â†’ (âˆƒ (b : Î±), a = bit1 b)
(p : â„•) [p_Prime : Fact (Nat.Prime p)] {q r : â„•} (hq : q â‰  0) (hr : r â‰  0) : padicValNat p (q * r) = padicValNat p q + padicValNat p r
(f : Circle_deg1_Lift) {x : â„} {n : â„•} {m : â„¤} (h : â‡‘(f ^ n) x = x + â†‘m) (hn : 0 < n) : f.translation_number = â†‘m / â†‘n
{G : Type u_1} [AddGroup G] {Î¹ : Type u_2} (s : Finset Î¹) (f : Î¹ â†’ G) (comm : âˆ€ (x : Î¹), x âˆˆ s â†’ âˆ€ (y : Î¹), y âˆˆ s â†’ AddCommute (f x) (f y)) (K : Î¹ â†’ AddSubgroup G) (hind : CompleteLattice.Independent K) (hmem : âˆ€ (x : Î¹), x âˆˆ s â†’ f x âˆˆ K x) (HEq1 : s.noncomm_Sum f comm = 0) (i : Î¹) (H : i âˆˆ s) : f i = 0
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {a : Î±} {s : Set Î±} (f : Î± â†’ M) (h : a âˆ‰ s) (hs : s.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ HasInsert.insert a s), f i)) = f a * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - 2 * âˆ¥xâˆ¥ * âˆ¥yâˆ¥ * Real.cos (InnerProductGeometry.angle x y)
{Gâ‚€ : Type u_2} [groupWithZero Gâ‚€] (a : Gâ‚€) : a / a * a = a
{M : Type u_3} {N : Type u_4} [hasAdd M] [hasAdd N] {f g : AddHom M N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
{Î± : Type u_1} {Î² : Type u_2} {tâ‚ : topologicalSpace Î±} {tâ‚‚ tâ‚ƒ : topologicalSpace Î²} (hâ‚ : tâ‚‚ â‰¤ tâ‚ƒ) {s : Set Î±} {f : Î± â†’ Î²} (hâ‚‚ : ContinuousOn f s) : ContinuousOn f s
(a : â„) : Cardinal.mk â†¥(Set.Ioi a) = Cardinal.continuum
{G : Type u_1} [AddGroup G] (H : AddSubgroup G) {x : G} : x âˆˆ H â†’ -x âˆˆ H
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] (h : âˆ€ (X : C), CategoryTheory.Mono (CategoryTheory.Limits.initial.to X)) : CategoryTheory.Limits.InitialMonoClass C
{Î± : Type u_2} {Î¹ : Type u_5} [CommMonoid Î±] (t : Finset Î¹) (fâ‚ fâ‚‚ : Î¹ â†’ Set Î±) (hF : âˆ€ {i : Î¹}, i âˆˆ t â†’ fâ‚ i âŠ† fâ‚‚ i) : t.prod (Î» (i : Î¹), fâ‚ i) âŠ† t.prod (Î» (i : Î¹), fâ‚‚ i)
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (K : Type u_2) [Field K] [Algebra R K] [IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R) : Classical.some _ â‰  0
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] {mâ‚ mâ‚‚ : Ennreal â†’ Ennreal} {c : Ennreal} (hc : c â‰  âŠ¤) (h0 : c â‰  0) (hle : mâ‚ â‰¤á¶ [nhdsWithin 0 (Set.Ici 0)] c â€¢ mâ‚‚) : MeasureTheory.Measure.mkMetric mâ‚ â‰¤ c â€¢ MeasureTheory.Measure.mkMetric mâ‚‚
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace E] {v : E} (hv : v âˆˆ K) : â‡‘(orthogonalProjection Ká—®) v = 0
{H : Type u} [topologicalSpace H] (G : StructureGroupoid H) : LocalHomeomorph.refl H âˆˆ StructureGroupoid.MaximalAtlas H G
{M : Type u_1} {N : Type u_2} [MulOneClass M] [MulOneClass N] (h : M â‰ƒ* N) : IsMulHom â‡‘h
(wâ‚ wâ‚‚ zâ‚ zâ‚‚ : Ennreal) (hw' : wâ‚ + wâ‚‚ = 1) {p : â„} (hp : 1 â‰¤ p) : (wâ‚ * zâ‚ + wâ‚‚ * zâ‚‚) ^ p â‰¤ wâ‚ * zâ‚ ^ p + wâ‚‚ * zâ‚‚ ^ p
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {f : M â†’* P} : (Con.kerLift f).mrange = f.mrange
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D â¥¤ C) [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Reflective i] [CategoryTheory.CartesianClosed C] [CategoryTheory.ExponentialIdeal i] (A B : C) : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison (CategoryTheory.leftAdjoint i) A B)
{C : Type uâ‚} [CategoryTheory.Category C] {X : C} (P : Cáµ’áµ– â¥¤ Type w) {S : CategoryTheory.Sieve X} {R : CategoryTheory.Presieve X} (h : â‡‘S â‰¤ R) (Trans : âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X), CategoryTheory.Presieve.IsSheafFor P â‡‘(CategoryTheory.Sieve.pullback f S)) : CategoryTheory.Presieve.IsSheafFor P R
{M : Type u_1} [hasMul M] (c : Con M) {a b : M} : â†‘a = â†‘b â†” â‡‘c a b
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) {l : List R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
(C : Type u) [CategoryTheory.Category C] [âˆ€ {X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)] : CategoryTheory.Limits.HasPushouts C
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [BaireSpace Î±] [Nonempty Î±] [Encodable Î²] {f : Î² â†’ Set Î±} (hc : âˆ€ (s : Î²), is_IsClosed (f s)) (hU : (â‹ƒ (s : Î²), f s) = Set.Univ) : âˆƒ (s : Î²), (Interior (f s)).nonempty
{Î¹ : Type u_1} {ð•œ : Type u_2} [is_R_or_C ð•œ] {E : Type u_3} [innerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), innerProductSpace ð•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ V) [âˆ€ (i : Î¹), CompleteSpace (G i)] (hV' : (â¨† (i : Î¹), (V i).to_LinearMap.range).topological_Closure = âŠ¤) (w : â†¥(Lp G 2)) : â‡‘((hV.linear_Isometry_Equiv hV').symm) w = âˆ‘' (i : Î¹), â‡‘(V i) (â‡‘w i)
{Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hF : Function.IsFixedPt f x) (n : â„•) : Function.IsPeriodicPt f n x
(n : â„•) : (Finset.range (n + 1)).sum (Î» (m : â„•), n.choose m) = 2 ^ n
{Î± : Type u_1} {Î² : Type u_3} [measurableSpace Î±] [measurableSpace Î²] {Î½ : MeasureTheory.Measure Î²} [MeasureTheory.IsFiniteMeasure Î½] {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) : Measurable (Î» (x : Î±), â‡‘Î½ (Prod.mk x â»Â¹' s))
{G : Type u} [Group G] [Fintype G] {p n : â„•} [hp : Fact (Nat.Prime p)] {H : Subgroup G} (hH : Fintype.card â†¥H = p ^ n) : Fintype.card â†¥(H.normalizer) â‰¡ Fintype.card G [Mod p ^ (n + 1)]
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {a b : Î±} {s : Set Î±} (hs : is_IsClosed (s âˆ© Set.Icc a b)) (ha : a âˆˆ s) (hgt : âˆ€ (x : Î±), x âˆˆ s âˆ© Set.Ico a b â†’ âˆ€ (y : Î±), y âˆˆ Set.Ioi x â†’ (s âˆ© Set.Ioc x y).nonempty) : Set.Icc a b âŠ† s
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace ð•œ] {c : ð•œ} (hc : 1 < âˆ¥câˆ¥) {R : â„} (hR : âˆ¥câˆ¥ < R) (h : Â¬FiniteDimensional ð•œ E) : âˆƒ (f : â„• â†’ E), (âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ R) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ 1 â‰¤ âˆ¥f m - f nâˆ¥
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s t : Set Î±} : BddBelow s â†’ BddBelow t â†’ (s âˆ© t).nonempty â†’ HasInf.inf s âŠ” HasInf.inf t â‰¤ HasInf.inf (s âˆ© t)
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
{n : â„•} (R : Type u_1) [Ring R] : Coe âˆ˜ Coe = Coe
(r n : â„•) : (2 * n).choose r â‰¤ n.central_binom
{Î± : Type u_1} {Î² : Type u_2} {p : Pmf Î±} (f : Î  (a : Î±), a âˆˆ p.support â†’ Pmf Î²) (s : Set Î²) [measurableSpace Î²] (hs : MeasurableSet s) : â‡‘((p.bind_on_Support f).to_measure) s = âˆ‘' (a : Î±), â†‘(â‡‘p a) * dite (â‡‘p a = 0) (Î» (h : â‡‘p a = 0), 0) (Î» (h : Â¬â‡‘p a = 0), â‡‘((f a h).to_measure) s)
{Î± : Type u_1} [topologicalSpace Î±] [BaireSpace Î±] {S : Set (Set Î±)} (ho : âˆ€ (s : Set Î±), s âˆˆ S â†’ is_IsOpen s) (hS : S.countable) (hD : âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) : Dense (â‹‚â‚€ S)
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] {F : Type v} [NormedGroup F] [normedSpace â„‚ F] {f : E â†’ F} {z : E} {r : â„} (hD : DiffContOnCl â„‚ f (Metric.Ball z r)) (hz : IsMaxOn (HasNorm.norm âˆ˜ f) (Metric.Ball z r) z) : Set.EqOn (HasNorm.norm âˆ˜ f) (Function.const E âˆ¥f zâˆ¥) (Metric.ClosedBall z r)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' fâ‚' : E â†’L[ð•œ] F} {x : E} {s : Set E} (hF : HasFderivWithinAt f f' s x) (hg : HasFderivWithinAt f fâ‚' s x) : Set.EqOn â‡‘f' â‡‘fâ‚' (TangentConeAt ð•œ s x)
{Î± : Type u_1} {p : Î± â†’ Prop} : Set.Range Coe = {x : Î± | p x}
{R : Type u_1} {a b : R} [AddSemigroup R] : IsAddRegular (a + b) âˆ§ IsAddRegular (b + a) â†” IsAddRegular a âˆ§ IsAddRegular b
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b c : Î±} : -b + a < c â†’ a < b + c
{R : Type uâ‚} [CommRing R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
{Î± : Type u_1} [DecidableEq Î±] (s : Finset Î±) : s.sym2.card = s.card * (s.card + 1) / 2
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [CommMonoid Î±] {g : Î³ â†’ Î²} (hg : Function.Injective g) {f : Î² â†’ Î±} (hF : âˆ€ (x : Î²), x âˆ‰ Set.Range g â†’ f x = 1) : Filter.map (Î» (s : Finset Î³), s.prod (Î» (i : Î³), f (g i))) Filter.atTop = Filter.map (Î» (s : Finset Î²), s.prod (Î» (i : Î²), f i)) Filter.atTop
{Î± : Type u} [t : topologicalSpace Î±] {b : Set (Set Î±)} (hb : TopologicalSpace.IsTopologicalBasis b) {s : Set Î±} {a : Î±} : a âˆˆ Closure s â†” âˆ€ (o : Set Î±), o âˆˆ b â†’ a âˆˆ o â†’ (o âˆ© s).nonempty
(n : â„•) : (Multiset.Nat.antidiagonal n).nodup
(Î± : Type u) {Î² : Type v} [AddGroup Î±] [addAction Î± Î²] (b : Î²) [Fintype Î±] [Fintype â†¥(AddAction.Orbit Î± b)] [Fintype â†¥(AddAction.stabilizer Î± b)] : Fintype.card â†¥(AddAction.Orbit Î± b) * Fintype.card â†¥(AddAction.stabilizer Î± b) = Fintype.card Î±
{R : Type u_1} [orderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {vâ‚ vâ‚‚ : RayVector R M} : -vâ‚ â‰ˆ -vâ‚‚ â†” vâ‚ â‰ˆ vâ‚‚
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderClosedTopology Î±] [Nonempty Î±] {s : Set Î±} (hs : is_IsCompact s) : BddAbove s
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : f =O[l] g â†” âˆƒ (c : â„), asymptotics.is_O_with c l f g
{F : Type u â†’ Type u} [Functor F] [q : Qpf F] {Î± : Type u} (u : F Î± â†’ Î±) (x y : (Qpf.p F).W) : Qpf.Wequiv x y â†’ Qpf.recF u x = Qpf.recF u y
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) (i : Fin (n + 1)) : HasDist.dist (s.points i) s.circumcenter = s.circumradius
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) : s.circumcenter âˆˆ affineSpan â„ (Set.Range s.points)
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] [Nonempty Î²] {f : Î² â†’ Î±} (hF : Continuous f) (hlim : Filter.Tendsto f (Filter.cocompact Î²) Filter.atTop) : âˆƒ (x : Î²), âˆ€ (y : Î²), f x â‰¤ f y
{S : Type u_2} [CommRing S] {K : Type u_6} [Field K] [Algebra K S] {x : S} (hx : IsIntegral K x) : LinearIndependent K (Î» (i : Fin (minpoly K x).nat_degree), x ^ â†‘i)
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hst : Disjoint s t) (hs : s.finite) (ht : t.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
{a b : â„•} (hab : a.coprime b) : Disjoint a.factorization.support b.factorization.support
{K : Type u} [Field K] (s : Subfield K) : Subfield.closure â†‘s = s
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {l : Filter Î±} {a : Î±} : IsMinFilter (â‡‘OrderDual.toDual âˆ˜ f) l a â†’ IsMaxFilter f l a
{R : Type u} [CommRing R] [is_IsDomain R] [DiscreteValuationRing R] (Ï– : R) : Irreducible Ï– â†” LocalRing.maximalIdeal R = Ideal.span {Ï–}
{Î± : Type u} [PartialOrder Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : b = a
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] [NormalSpace Y] (f : boundedContinuousFunction X â„) {e : X â†’ Y} (hE : ClosedEmbedding e) : âˆƒ (g : boundedContinuousFunction Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ â‡‘g âˆ˜ e = â‡‘f
{G : Type u_1} [AddCommGroup G] (K : AddSubgroup G) (g : Multiset G) : (âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.sum âˆˆ K
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) [Fintype Î¹] (p : Î¹ â†’ P) : Finset.centroid k s p = â‡‘(finset.univ.affine_combination p) (Finset.centroidWeightsIndicator k s)
(n : â„•) : Filter.Tendsto (Î» (x : â„), Real.exp x / x ^ n) Filter.atTop Filter.atTop
(m n : â„•) : Nat.fib (m + n + 1) = Nat.fib m * Nat.fib n + Nat.fib (m + 1) * Nat.fib (n + 1)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} {p1 : P} (hp1 : p1 âˆˆ s) (p2 p : P) : p âˆˆ affineSpan k (HasInsert.insert p2 â†‘s) â†” âˆƒ (r : k) (p0 : P) (hp0 : p0 âˆˆ s), p = r â€¢ (p2 -áµ¥ p1) +áµ¥ p0
{Î± : Type u_1} {p : Î  (s : Finset Î±), s.nonempty â†’ Prop} (hâ‚€ : âˆ€ (a : Î±), p {a} _) (hâ‚ : âˆ€ â¦ƒa : Î±â¦„ (s : Finset Î±) (h : a âˆ‰ s) (hs : s.nonempty), p s hs â†’ p (Finset.cons a s h) _) {s : Finset Î±} (hs : s.nonempty) : p s hs
{G : Type u_1} [subNegMonoid G] [measurableSpace G] [HasMeasurableAdd G] (g : G) : Measurable (Î» (h : G), h - g)
{M : Type u_1} [hasMul M] {c d : Con M} (H : Setoid.r = Setoid.r) : c = d
{R : Type u_1} {A : Type u_2} [CommSemiring R] [CommRing A] [Algebra R A] (ð’œ : â„• â†’ Submodule R A) [GradedAlgebra ð’œ] : GaloisConnection (Î» (s : Set A), ProjectiveSpectrum.ZeroLocus ð’œ s) (Î» (t : (Set (ProjectiveSpectrum ð’œ))áµ’áµˆ), â†‘(ProjectiveSpectrum.vanishingIdeal t))
{Î± : Type u_3} {Î² : Type u_4} [Nonempty Î±] [SemilatticeInf Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Monotone f) : Filter.Tendsto f Filter.atBot Filter.atBot â†” âˆ€ (b : Î²), âˆƒ (a : Î±), f a â‰¤ b
{R : Type v} [CommRing R] {n : â„•} (A : Matrix (Fin n.succ) (Fin n.succ) R) : A.det = finset.univ.sum (Î» (i : Fin n.succ), (-1) ^ â†‘i * A i 0 * (A.minor â‡‘(i.succ_above) Fin.succ).det)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type w} [CategoryTheory.Category J] (F : C â¥¤ D) [CategoryTheory.Limits.HasColimitsOfShape J D] [CategoryTheory.CreatesColimitsOfShape J F] : CategoryTheory.Limits.HasColimitsOfShape J C
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {R : â„} {c w : â„‚} {f : â„‚ â†’ E} {s : Set â„‚} (hs : s.countable) (hw : w âˆˆ Metric.Ball c R) (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : âˆ€ (x : â„‚), x âˆˆ Metric.Ball c R  s â†’ DifferentiableAt â„‚ f x) : âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘Real.pi * Complex.i) â€¢ f w
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {a b : Î±} {s : Set Î±} (hs : is_IsClosed (s âˆ© Set.Icc a b)) (ha : a âˆˆ s) (hab : a â‰¤ b) (hgt : âˆ€ (x : Î±), x âˆˆ s âˆ© Set.Ico a b â†’ (s âˆ© Set.Ioc x b).nonempty) : b âˆˆ s
{R : Type u_4} [linearOrderedRing R] (a : R) : 0 â‰¤ a ^ 2
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] {ifp_Succ_n : GeneralizedContinuedFraction.IntFractPair K} (Succ_nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = Option.some ifp_Succ_n) : 1 â‰¤ ifp_Succ_n.b
(R : Type u) [CommSemiring R] {M : Type v} [AddCommMonoid M] [Module R M] {s : Finset M} (b : Basis â†¥s R M) (f : M â†’â‚—[R] M) : â‡‘(LinearMap.trace R M) f = (â‡‘(LinearMap.toMatrix b b) f).trace
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] [Algebra R S] [is_IsDomain S] (H : Algebra.IsIntegral R S) (P : Ideal R) [P_max : P.is_Maximal] (hP : (algebraMap R S).ker â‰¤ P) : âˆƒ (Q : Ideal S), Q.is_Maximal âˆ§ Ideal.comap (algebraMap R S) Q = P
(M : Type u_1) (Î± : Type u_2) [Monoid M] [mulAction M Î±] : GaloisConnection (â‡‘OrderDual.toDual âˆ˜ fixingSubmonoid M) ((Î» (P : Submonoid M), MulAction.FixedPoints â†¥P Î±) âˆ˜ â‡‘OrderDual.ofDual)
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} [measurableSpace Î±] [measurableSpace Î²] [measurableSpace Î³] {Î´ : Type u_7} [measurableSpace Î´] {Î¼a : MeasureTheory.Measure Î±} {Î¼b : MeasureTheory.Measure Î²} {Î¼c : MeasureTheory.Measure Î³} {Î¼d : MeasureTheory.Measure Î´} [MeasureTheory.SigmaFinite Î¼b] [MeasureTheory.SigmaFinite Î¼d] {f : Î± â†’ Î²} {g : Î³ â†’ Î´} (hF : MeasureTheory.MeasurePreserving f Î¼a Î¼b) (hg : MeasureTheory.MeasurePreserving g Î¼c Î¼d) : MeasureTheory.MeasurePreserving (Prod.map f g) (Î¼a.prod Î¼c) (Î¼b.prod Î¼d)
 : Filter.Tendsto Complex.abs (Filter.cocompact â„‚) Filter.atTop
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M â†’+ P} (H : c â‰¤ AddCon.ker f) (x : M) : â‡‘(c.lift f H) â†‘x = â‡‘f x
{n : â„•} (i j : Î£ (a : Composition n), Composition a.length) : i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.snd.blocks = j.snd.blocks
{K : Type u_1} [linearOrderedField K] {a b c : K} (h : âˆ€ (x : K), 0 â‰¤ a * x * x + b * x + c) : discrim a b c â‰¤ 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : P) (direction : Submodule k V) : p âˆˆ AffineSubspace.mk' p direction
{M : Type u_1} [hasMul M] {c : Con M} {C : c.quotient â†’ Prop} (q : c.quotient) (H : âˆ€ (x : M), C â†‘x) : C q
{Î¹ : Type u} {Î³ : Type w} [dec : DecidableEq Î¹] [AddCommMonoid Î³] (S : Î¹ â†’ addSubmonoid Î³) : supr S = (Dfinsupp.sumAddHom (Î» (i : Î¹), (S i).subtype)).mrange
(p : â„•) [hp : Fact (Nat.Prime p)] {q : â„š} (hq : q â‰  0) : padicNorm p q â‰  0
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [Module R P] : Module.Projective R P â†” CategoryTheory.Projective (Module.of R P)
{R : Type u} [Ring R] : CategoryTheory.Limits.HasKernels (Module R)
{R : Type u_1} [normedRing R] [CompleteSpace R] (x : RË£) : ContinuousAt Ring.inverse â†‘x
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
{X : Type u_2} {Y : Type u_3} [emetricSpace X] [emetricSpace Y] {C r : Nnreal} {f : X â†’ Y} (h : HolderWith C r f) (hr : 0 < r) : dimH (Set.Range f) â‰¤ dimH Set.Univ / â†‘r
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s t : Set Î±} (hs : BddAbove s) (ht : BddAbove t) (hst : (s âˆ© t).nonempty) : HasSup.sup (s âˆ© t) â‰¤ HasSup.sup s âŠ“ HasSup.sup t
{P L : Type u} [hasMem P L] [Configuration.Nondegenerate P L] [Fintype P] [Fintype L] (h : Fintype.card L â‰¤ Fintype.card P) : âˆƒ (f : L â†’ P), Function.Injective f âˆ§ âˆ€ (l : L), f l âˆ‰ l
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {M : Matrix n n R} {i j : n} (i_NE_j : i â‰  j) (hij : âˆ€ (k : n), M k i = M k j) : M.det = 0
{G : Type u} {x : G} {n : â„•} [Monoid G] (hn : 0 < n) (hx : x ^ n = 1) (hD : âˆ€ (p : â„•), Nat.Prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) : orderOf x = n
{M : Type u_1} [AddMonoid M] {x : M} : Add_monoid.closure {x} = Multiples x
{Î± : Type u} [pseudoMetricSpace Î±] {x : Î±} {r : â„} : Metric.Bounded (Metric.Sphere x r)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : 2 â€¢ hb.oangle (-x) y = 2 â€¢ hb.oangle x y
{Î± : Type u_1} [uniformSpace Î±] {s : Set (Î± Ã— Î±)} (hs : s âˆˆ Uniformity Î±) : âˆ€á¶  (t : Set (Î± Ã— Î±)) in (Uniformity Î±).small_sets, CompRel t t âŠ† s
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) : hb.rotation 0 = LinearIsometryEquiv.refl â„ V
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasStrictTerminalObjects C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ C) [CategoryTheory.Limits.HasLimit F] (i : J) (H : Î  (j : J), j â‰  i â†’ CategoryTheory.Limits.IsTerminal (F.obj j)) [Subsingleton (i âŸ¶ i)] : CategoryTheory.IsIso (CategoryTheory.Limits.limitÏ€ F i)
{G : Type u_1} [Group G] : IsDescendingCentralSeries (lowerCentralSeries G)
{x : Pgame} (h : x â‰¤ 0) (i : x.left_moves) : (x.move_Left i).move_Right (Pgame.rightResponse h i) â‰¤ 0
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.normal] (h1 : (Fintype.card â†¥N).coprime N.index) (h2 : âˆ€ (G' : Type u) [_inst_4 : Group G'] [_inst_5 : Fintype G'], Fintype.card G' < Fintype.card G â†’ âˆ€ {N' : Subgroup G'} [_inst_6 : N'.normal], (Fintype.card â†¥N').coprime N'.index â†’ (âˆƒ (H' : Subgroup G'), N'.is_complement' H')) (h3 : âˆ€ (H : Subgroup G), Â¬N.is_complement' H) : N.is_commutative
(ð•œ : Type u_1) [nondiscreteNormedField ð•œ] {E : Type u_2} [semiNormedGroup E] [normedSpace ð•œ E] (s : Set E) : is_IsClosed (WeakDual.Polar ð•œ s)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {v : â„ â†’ E â†’ E} {K : Nnreal} (hv : âˆ€ (t : â„), LipschitzWith K (v t)) {f g : â„ â†’ E} {a b : â„} (hF : ContinuousOn f (Set.Icc a b)) (hF' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (v t (f t)) (Set.Ici t) t) (hg : ContinuousOn g (Set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt g (v t (g t)) (Set.Ici t) t) (ha : f a = g a) (t : â„) (H : t âˆˆ Set.Icc a b) : f t = g t
(R : Type u) [Ring R] [StrongRankCondition R] {Î¹ : Type v} : Module.rank R (Î¹ â†’â‚€ R) = (Cardinal.mk Î¹).lift
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {fâ‚‚ : ð•œ â†’ F} {n : â„•} : ContDiff ð•œ â†‘(n + 1) fâ‚‚ â†” Differentiable ð•œ fâ‚‚ âˆ§ ContDiff ð•œ â†‘n (deriv fâ‚‚)
(n : â„•) (R : Type u_1) [CommRing R] : (Polynomial.cyclotomic n R).is_primitive
{Î± : Type u} [topologicalSpace Î±] {s t : Set Î±} (hs : is_IsCompact s) (ht : is_IsOpen t) : is_IsCompact (s  t)
(n : â„¤) : â‡‘ZmodÏ‡â‚ˆ â†‘n = Ite (n % 2 = 0) 0 (Ite (n % 8 = 1 âˆ¨ n % 8 = 7) 1 (-1))
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚} {R : Nnreal} (hF : CircleIntegrable f c â†‘R) (hR : 0 < R) : HasFpowerSeriesOnBall (Î» (w : â„‚), (2 * â†‘Real.pi * Complex.i)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, â†‘R), (z - w)â»Â¹ â€¢ f z) (cauchyPowerSeries f c â†‘R) c â†‘R
{Î± : Type u_1} {s : Set Î±} (p : â†¥s) : â†‘p âˆˆ s
{L : FirstOrder.Language} {M : Type w} [L.Structure M] {S T : L.substructure M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
{Î± : Type u_1} [CircularPreorder Î±] {a b c : Î±} : HasSbtw.Sbtw a b c â†” HasSbtw.Sbtw c a b
{n : â„•} {iâ‚ iâ‚‚ : Fin (n + 3)} (h : iâ‚ â‰  iâ‚‚) : finset.univ.sum (Î» (i : Affine.Simplex.PointsWithCircumcenterIndex (n + 2)), Affine.Simplex.mongePointVsubFaceCentroidWeightsWithCircumcenter iâ‚ iâ‚‚ i) = 0
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) : CategoryTheory.topologyOfClosureOperator Jâ‚.closure_operator _ = Jâ‚
(R : Type u_1) [CommRing R] [is_IsDomain R] : Polynomial.cyclotomic' 1 R = Polynomial.x - 1
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F : J â¥¤ C} [CategoryTheory.Limits.HasColimit F] (c : CategoryTheory.Limits.Cocone F) (j : J) : CategoryTheory.Limits.colimitÎ¹ F j â‰« CategoryTheory.Limits.colimit.desc F c = c.Î¹.app j
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) : p.radius = filter.at_top.liminf (Î» (n : â„•), 1 / â†‘(âˆ¥p nâˆ¥â‚Š ^ (1 / â†‘n)))
{R : Type u_1} [CommRing R] (s : Subring R) {Î¹ : Type u_2} {t : Finset Î¹} {f : Î¹ â†’ R} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.prod (Î» (i : Î¹), f i) âˆˆ s
{n : Type u_3} [Fintype n] {K : Type u_1} [DecidableEq n] [Field K] {M : Matrix n n K} : (âˆƒ (v : n â†’ K) (H : v â‰  0), M.mul_vec v = 0) â†” M.det = 0
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hs : s.finite) (ht : t.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆ© t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x y : Î±} (h : Emetric.diam s â‰  âŠ¤) (hx : x âˆˆ s) (hy : y âˆˆ s) : HasDist.dist x y â‰¤ Metric.diam s
{R : Type u_1} [CommRing R] [CharZero R] : Function.Injective (Î» (n : â„•), Polynomial.cyclotomic n R)
{R : Type u} [Semiring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {M : Type u_1} [AddCommMonoid M] [Module R M] {A : Î¹ â†’ Submodule R M} (h : DirectSum.IsInternal A) : supr A = âŠ¤
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [hasZero M] [CommMonoid N] [DecidableEq Î±] (f : Î± â†’â‚€ M) (a : Î±) (b : Î± â†’ M â†’ N) : f.prod (Î» (x : Î±) (v : M), Ite (x = a) (b x v) 1) = Ite (a âˆˆ f.support) (b a (â‡‘f a)) 1
 : Subgroup.normalClosure {âŸ¨equiv.swap 0 4 * equiv.swap 1 3, _âŸ©} = âŠ¤
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s : Set Î±} {b : Î±} : s.nonempty â†’ (âˆ€ (a : Î±), a âˆˆ s â†’ b â‰¤ a) â†’ (âˆ€ (w : Î±), b < w â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), a < w)) â†’ HasInf.inf s = b
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] : âˆ….up_shadow = âˆ…
{Î± : Type u} [topologicalSpace Î±] {s t : Set Î±} (hs : is_IsCompact s) (ht : is_IsClosed t) : is_IsCompact (s âˆ© t)
{E : Type u} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] {n : â„•} {F : Type u_1} [NormedGroup F] [normedSpace â„ F] [PartialOrder F] [MeasureTheory.MeasureSpace F] [BorelSpace F] (eL : F â‰ƒL[â„] Fin (n + 1) â†’ â„) (hE_Ord : âˆ€ (x y : F), â‡‘eL x â‰¤ â‡‘eL y â†” x â‰¤ y) (hE_vol : MeasureTheory.MeasurePreserving â‡‘eL MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume) (f : Fin (n + 1) â†’ F â†’ E) (f' : Fin (n + 1) â†’ F â†’ (F â†’L[â„] E)) (s : Set F) (hs : s.countable) (a b : F) (hle : a â‰¤ b) (Hc : âˆ€ (i : Fin (n + 1)), ContinuousOn (f i) (Set.Icc a b)) (hD : âˆ€ (x : F), x âˆˆ Interior (Set.Icc a b)  s â†’ âˆ€ (i : Fin (n + 1)), HasFderivAt (f i) (f' i x) x) (DF : F â†’ E) (hDF : âˆ€ (x : F), DF x = finset.univ.sum (Î» (i : Fin (n + 1)), â‡‘(f' i x) (â‡‘(eL.symm) (Pi.single i 1)))) (Hi : MeasureTheory.IntegrableOn DF (Set.Icc a b) MeasureTheory.MeasureSpace.volume) : âˆ« (x : F) in Set.Icc a b, DF x = finset.univ.sum (Î» (i : Fin (n + 1)), (âˆ« (x : Fin n â†’ â„) in Set.Icc (â‡‘eL a âˆ˜ â‡‘(i.succ_above)) (â‡‘eL b âˆ˜ â‡‘(i.succ_above)), f i (â‡‘(eL.symm) (i.insert_nth (â‡‘eL b i) x))) - âˆ« (x : Fin n â†’ â„) in Set.Icc (â‡‘eL a âˆ˜ â‡‘(i.succ_above)) (â‡‘eL b âˆ˜ â‡‘(i.succ_above)), f i (â‡‘(eL.symm) (i.insert_nth (â‡‘eL a i) x)))
{Î± : Type u_1} [topologicalSpace Î±] [BaireSpace Î±] {s t : Set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t) (hsc : Dense s) (htc : Dense t) : Dense (s âˆ© t)
{a b : â„} (m n : â„•) : âˆ« (x : â„) in a..b, Real.sin x ^ (2 * m) * Real.cos x ^ (2 * n) = âˆ« (x : â„) in a..b, ((1 - Real.cos (2 * x)) / 2) ^ m * ((1 + Real.cos (2 * x)) / 2) ^ n
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N' : Type u_5} [AddCommGroup N'] [Module R N'] {Î¹ : Type u_6} [DecidableEq Î¹] [Fintype Î¹] (a : AlternatingMap R M N' Î¹) : â‡‘MultilinearMap.alternatization â†‘a = (Fintype.card Î¹).factorial â€¢ a
{p : â„•} : padicValInt p 0 = 0
{M : Type u_1} [AddZeroClass M] {c : AddCon M} : â†‘0 = 0
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x y : Î±} {t : Set Î±} (xs : x âˆˆ s) (yt : y âˆˆ t) : Metric.diam (s âˆª t) â‰¤ Metric.diam s + HasDist.dist x y + Metric.diam t
{Î± : Type u} {Î² : Type v} [SemilatticeSup Î±] {f : Î± â†’ Î²} {r : Î² â†’ Î² â†’ Prop} (H : âˆ€ â¦ƒi j : Î±â¦„, i â‰¤ j â†’ r (f i) (f j)) : Directed r f
{R : Type u} {Î¹ : Type v} {Mâ‚ : Î¹ â†’ Type wâ‚} {Mâ‚‚ : Type wâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] [Î  (i : Î¹), topologicalSpace (Mâ‚ i)] [topologicalSpace Mâ‚‚] (f : ContinuousMultilinearMap R Mâ‚ Mâ‚‚) {Î± : Î¹ â†’ Type u_1} [Fintype Î¹] (g : Î  (i : Î¹), Î± i â†’ Mâ‚ i) [Î  (i : Î¹), Fintype (Î± i)] : â‡‘f (Î» (i : Î¹), finset.univ.sum (Î» (j : Î± i), g i j)) = finset.univ.sum (Î» (r : Î  (i : Î¹), Î± i), â‡‘f (Î» (i : Î¹), g i (r i)))
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] [Nonempty Î²] [hasOne Î±] {f : Î² â†’ Î±} (hF : Continuous f) (h : HasCompactMulSupport f) : âˆƒ (x : Î²), âˆ€ (y : Î²), f x â‰¤ f y
{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd c = 1) : a âˆ£ b
{Î± : Type u} [pseudoMetricSpace Î±] (a : Î±) : HasNndist.nndist a a = 0
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {f : Î± â†’ Î² â†’ Î³} {s s' : Set Î±} {t t' : Set Î²} (hs : s âŠ† s') (ht : t âŠ† t') : Set.image2 f s t âŠ† Set.image2 f s' t'
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] [DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ Î²) {a : Î±} (h : a âˆˆ s) : (s.erase a).prod (Î» (x : Î±), f x) * f a = s.prod (Î» (x : Î±), f x)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) : âˆ‘' (i : Î¹), âˆ¥HasInner.inner (v i) xâˆ¥ ^ 2 â‰¤ âˆ¥xâˆ¥ ^ 2
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] {s : Set E} (hsâ‚ : Convex â„ s) (hsâ‚‚ : is_IsClosed s) : (â‹‚ (l : E â†’L[â„] â„), {x : E | âˆƒ (y : E) (H : y âˆˆ s), â‡‘l x â‰¤ â‡‘l y}) = s
{M : Type u_3} {N : Type u_4} [AddZeroClass M] [AddZeroClass N] (f : M â†’+ N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
{D : Set â„} (hD : Convex â„ D) (hDâ‚‚ : is_IsOpen D) {f : â„ â†’ â„} (hF' : DifferentiableOn â„ f D) (hF'' : DifferentiableOn â„ (deriv f) D) (hF''_nonneg : âˆ€ (x : â„), x âˆˆ D â†’ 0 â‰¤ deriv^[2] f x) : ConvexOn â„ D f
(Î± : Type u_1) [topologicalSpace Î±] [TopologicalSpace.SeparableSpace Î±] [PartialOrder Î±] : âˆƒ (s : Set Î±), s.countable âˆ§ Dense s âˆ§ (âˆ€ (x : Î±), IsBot x â†’ x âˆˆ s) âˆ§ âˆ€ (x : Î±), IsTop x â†’ x âˆˆ s
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [addCancelCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [HasScalar ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : StrictConvexOn ð•œ s f) (c : E) : StrictConvexOn ð•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) (f : V â‰ƒâ‚—áµ¢[â„] V) : _.oangle x y = hb.oangle (â‡‘(f.symm) x) (â‡‘(f.symm) y)
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] {F : J â¥¤ Profinite} (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) {Î± : Type u_1} (f : LocallyConstant â†¥(C.X) Î±) : âˆƒ (j : J) (g : LocallyConstant â†¥(F.obj j) Î±), f = LocallyConstant.comap â‡‘(C.Ï€.app j) g
{R : Type u_1} [CommRing R] (u v w : Fin 3 â†’ R) : Matrix.dotProduct u (â‡‘(â‡‘crossProduct v) w) = Matrix.det ![u, v, w]
{T : â„} {g : â„ â†’ â„} (hg : Function.Periodic g T) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.MeasureSpace.volume tâ‚ tâ‚‚) (hâ‚€ : 0 < âˆ« (x : â„) in 0..T, g x) (hT : 0 < T) : Filter.Tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) Filter.atBot Filter.atBot
{V : Type u_1} [innerProductSpace â„ V] (x y : V) (h : InnerProductGeometry.angle x y = Real.pi / 2) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] (x : E) : LipschitzWith âˆ¥xâˆ¥â‚Š (Î» (f : E â†’sl[Ïƒâ‚â‚‚] F), â‡‘f x)
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] (s : Submodule K V) : Module.rank K â†¥s â‰¤ 1 â†” âˆƒ (vâ‚€ : V), s â‰¤ Submodule.span K {vâ‚€}
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} (l : List M) : â‡‘CliffordAlgebra.reverse (List.map â‡‘(CliffordAlgebraÎ¹ Q) l).prod = (List.map â‡‘(CliffordAlgebraÎ¹ Q) l).reverse.prod
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 âˆˆ s) : â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p2 -áµ¥ âŸ¨p1, hp1âŸ©) âˆˆ s.direction
{Mâ‚€ : Type u_1} [MulZeroOneClass Mâ‚€] (h : 0 = 1) (a : Mâ‚€) : a = 0
{ð•‚ : Type u_6} [is_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [normedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [normedSpace ð•‚ F'] {f : E' â†’ F'} {x : E'} (hF : ContDiffAt ð•‚ 1 f x) : âˆƒ (K : Nnreal) (t : Set E') (H : t âˆˆ nhds x), LipschitzOnWith K f t
{H : Type u} [topologicalSpace H] {Î± : Type u_5} [topologicalSpace Î±] (e : localHomeomorph Î± H) (h : e.to_local_equiv.source = Set.Univ) (G : StructureGroupoid H) [ClosedUnderRestriction G] : HasGroupoid Î± G
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a l' : Î±} {s : Set Î±} (hl' : l' < a) : s âˆˆ nhdsWithin a (Set.Iic a) â†” âˆƒ (l : Î±) (H : l âˆˆ Set.Iio a), Set.Ioc l a âŠ† s
 : Filter.Tendsto Complex.exp (Filter.comap Complex.re Filter.atBot) (nhds 0)
(n : â„•) (x : â„) (hx : x â‰  0) : HasDerivAt (Î» (x : â„), Polynomial.eval x (expNegInvGlue.pAux n) * Real.exp (-xâ»Â¹) / x ^ (2 * n)) (Polynomial.eval x (expNegInvGlue.pAux (n + 1)) * Real.exp (-xâ»Â¹) / x ^ (2 * (n + 1))) x
{Î± : Type u} [pseudoEmetricSpace Î±] {Î´ : â„} (Î´_Pos : 0 < Î´) (E : Set Î±) : Closure E âŠ† Metric.Thickening Î´ E
{F : Type u_3} [innerProductSpace â„ F] {x y : F} (h : HasInner.inner x y = 0) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
(L : List â„•) : L.tail.sum = L.sum - L.head
{Î± : Type u_1} {Î³ : Type u_2} [measurableSpace Î±] [AddMonoid Î³] {P : MeasureTheory.SimpleFunc Î± Î³ â†’ Prop} (h_ind : âˆ€ (c : Î³) {s : Set Î±} (hs : MeasurableSet s), P (MeasureTheory.SimpleFunc.piecewise s hs (MeasureTheory.SimpleFunc.const Î± c) (MeasureTheory.SimpleFunc.const Î± 0))) (h_Add : âˆ€ â¦ƒf g : MeasureTheory.SimpleFunc Î± Î³â¦„, Disjoint (Function.Support â‡‘f) (Function.Support â‡‘g) â†’ P f â†’ P g â†’ P (f + g)) (f : MeasureTheory.SimpleFunc Î± Î³) : P f
{Î± : Type u_1} [CommMonoid Î±] {Î² : Type u_2} [Fintype Î²] (s : Set Î²) [DecidablePred (Î» (_x : Î²), _x âˆˆ s)] (f : Î² â†’ Î±) (g : â†¥s â†’ Î±) (w : âˆ€ (x : Î²) (h : x âˆˆ s), f x = g âŸ¨x, hâŸ©) (w' : âˆ€ (x : Î²), x âˆ‰ s â†’ f x = 1) : finset.univ.prod f = finset.univ.prod g
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s : Set Î±} {t : Set Î²} {u : Set Î³} (h : âˆ€ (a : Î±) (b : Î²) (c : Î³), g a b c = g' a b c) : Set.image3 g s t u = Set.image3 g' s t u
{Î± : Type u} {L : List (Î± Ã— Bool)} {x : Î±} {b : Bool} : FreeGroup.Red ((x, b) :: L) List.nil â†” FreeGroup.Red L [(x, !b)]
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (e : localHomeomorph Î± Î²) {x : Î²} (h : x âˆˆ e.to_local_equiv.target) : ContinuousAt â‡‘(e.symm) x
{Î± : Type u_1} {Î² : Type u_2} [hasAdd Î±] [Preorder Î±] [Preorder Î²] {f g : Î² â†’ Î±} [CovariantClass Î± Î± Add.add LE.le] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] (hF : Monotone f) (hg : Monotone g) : Monotone (Î» (x : Î²), f x + g x)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : r â‰  0) : 2 â€¢ hb.oangle x (r â€¢ y) = 2 â€¢ hb.oangle x y
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î² â†’ Î³} (hF : Continuous f) : Continuous (Î» (x : Î± Ã— Î²), f x.snd)
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] [uniformSpace Î²] {s : Set Î±} {f : Î± â†’ Î²} (hs : is_IsCompact s) (hs' : IsSeparated s) (hF : ContinuousOn f s) : UniformContinuousOn f s
 : CategoryTheory.Faithful compactumToCompHaus
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] [StrictConvexSpace â„ E] {x y z : E} {r : â„} (hx : x âˆˆ Metric.ClosedBall z r) (hy : y âˆˆ Metric.ClosedBall z r) (hne : x â‰  y) : OpenSegment â„ x y âŠ† Metric.Ball z r
{n m : SimplexCategory} {f : n âŸ¶ m} : CategoryTheory.Mono f â†” Function.Injective â‡‘(SimplexCategory.Hom.toOrderHom f)
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R â†’+* S} {p : Polynomial S} (n : â„•) (h : p âˆˆ Polynomial.lifts f) : Polynomial.erase n p âˆˆ Polynomial.lifts f
{a b c : Prop} : a âˆ§ b âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) : 0 = 1 â†” âˆ€ (x : Î±), â‡‘f x = 0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {fâ‚‚ : ð•œ â†’ F} {sâ‚‚ : Set ð•œ} (hs : UniqueDiffOn ð•œ sâ‚‚) : ContDiffOn ð•œ âŠ¤ fâ‚‚ sâ‚‚ â†” DifferentiableOn ð•œ fâ‚‚ sâ‚‚ âˆ§ ContDiffOn ð•œ âŠ¤ (derivWithin fâ‚‚ sâ‚‚) sâ‚‚
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] [DecidableEq Î±] (s : Finset Î±) {f : Î± â†’ Î²} {a : Î±} (h : f a = 0) : (s.erase a).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
{n : â„•} {E : Type u_1} [NormedGroup E] {f g : (Fin n â†’ â„‚) â†’ E} {c : Fin n â†’ â„‚} {R : Fin n â†’ â„} (hF : TorusIntegrable f c R) (hg : TorusIntegrable g c R) : TorusIntegrable (f - g) c R
{R : Type u_1} {A : Type u_2} [AddZeroClass R] [AddZeroClass A] {P : Unitization R A â†’ Prop} (h : âˆ€ (r : R) (a : A), P (Unitization.inl r + â†‘a)) (x : Unitization R A) : P x
{R : Type u_3} {S : Type u_4} {A : Type u_5} [CommRing R] [CommRing S] [CommRing A] [Algebra R S] [Algebra S A] [Algebra R A] [isScalarTower R S A] (hinj : Function.Injective â‡‘(algebraMap R S)) (A_alg : Algebra.IsAlgebraic R A) : Algebra.IsAlgebraic S A
{R : Type u} [CommRing R] (S : Submonoid R) (L : Type u) [CommRing L] [Algebra R L] [IsLocalization S L] (hS : S â‰¤ NonZeroDivisors R) : Cardinal.mk R = Cardinal.mk L
{Î± : Type u} [uniformSpace Î±] {s : Set Î±} {c : Set (Set Î±)} (hs : is_IsCompact s) (hcâ‚ : âˆ€ (t : Set Î±), t âˆˆ c â†’ is_IsOpen t) (hcâ‚‚ : s âŠ† â‹ƒâ‚€c) : âˆƒ (n : Set (Î± Ã— Î±)) (H : n âˆˆ Uniformity Î±), âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (t : Set Î±) (H : t âˆˆ c), âˆ€ (y : Î±), (x, y) âˆˆ n â†’ y âˆˆ t)
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b c : Î±} : b â‰¤ aâ»Â¹ * c â†’ a * b â‰¤ c
{R : Type u_1} [CommRing R] {P : Ideal (Polynomial R)} (pB : P â‰  âŠ¥) (hP : âˆ€ (x : R), â‡‘Polynomial.c x âˆˆ P â†’ x = 0) : âˆƒ (p : Polynomial R), p âˆˆ P âˆ§ Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.c P)) p â‰  0
{M : Type u_1} [Monoid M] {x : M} : x âˆˆ Powers x
{M : Type u_1} [AddCommGroup M] [Module â„ M] [FiniteDimensional â„ M] (Q : QuadraticForm â„ M) (hQ : (â‡‘QuadraticForm.associated Q).nondegenerate) : âˆƒ (w : Fin (FiniteDimensional.finrank â„ M) â†’ â„), (âˆ€ (i : Fin (FiniteDimensional.finrank â„ M)), w i = -1 âˆ¨ w i = 1) âˆ§ Q.equivalent (QuadraticForm.weightedSumSquares â„ w)
{R : Type v} [CommRing R] {A : Matrix (Fin 0) (Fin 0) R} : A.det = 1
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type w} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (hG : CategoryTheory.CoverLifting J K G) (â„± : CategoryTheory.Sheaf J A) : CategoryTheory.Presheaf.IsSheaf K ((CategoryTheory.ran G.op).obj â„±.val)
 : (Î» (N : â„•), â†‘(â‡‘rothNumberNat N)) =O[Filter.atTop] Î» (N : â„•), â†‘N
(z : UpperHalfPlane) : âˆƒ (g : Matrix.SpecialLinearGroup (Fin 2) â„¤), g â€¢ z âˆˆ ModularGroup.Fd
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set â„} [Interval_integral.FTC_Filter b (nhdsWithin b s) (nhdsWithin b t)] (hmeas : StronglyMeasurableAtFilter f (nhdsWithin b t) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhdsWithin b t âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasDerivWithinAt (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c s b
{R : Type u_1} {G : Type u_2} [CommRing R] [is_IsDomain R] [Group G] [Fintype G] (f : G â†’* R) (hF : f â‰  1) : finset.univ.sum (Î» (g : G), â‡‘f g) = 0
{Î± : Type u_1} [measurableSpace Î±] [topologicalSpace Î±] [OpensMeasurableSpace Î±] {Î² : Type u_2} [topologicalSpace Î²] [TopologicalSpace.PseudoMetrizableSpace Î²] [h : SecondCountableTopologyEither Î± Î²] {f : Î± â†’ Î²} (hF : Continuous f) : MeasureTheory.StronglyMeasurable f
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
{Î± : Type u_1} [CancelCommMonoidWithZero Î±] [UniqueFactorizationMonoid Î±] [normalizationMonoid Î±] [DecidableEq Î±] {x : Î±} {n : â„•} : factorization (x ^ n) = n â€¢ factorization x
{a b : Ereal} : -a â‰¤ b â†” -b â‰¤ a
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] {Mâ‚ : Type v} [AddCommGroup Mâ‚] [Module R Mâ‚] (f : M â‰ƒâ‚—[R] Mâ‚) (p : Submodule R M) : Module.rank R â†¥(Submodule.map â†‘f p) = Module.rank R â†¥p
{K : Type u} [hring : CommRing K] [hdomain : is_IsDomain K] {P : Ratfunc K â†’ Prop} (x : Ratfunc K) (f : âˆ€ (p q : Polynomial K), q â‰  0 â†’ P (â‡‘(algebraMap (Polynomial K) (Ratfunc K)) p / â‡‘(algebraMap (Polynomial K) (Ratfunc K)) q)) : P x
{G : Type w} [topologicalSpace G] [Group G] [TopologicalGroup G] {K V : Set G} (hK : is_IsCompact K) (hV : (Interior V).nonempty) : âˆƒ (t : Finset G), K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g * h) â»Â¹' V
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topologicalSpace Î²] (f : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : Set Î±) [f.ne_IsBot] {c : Set Î²} (hcâ‚ : is_IsCompact c) (hcâ‚‚ : âˆƒ (v : Set Ï„) (H : v âˆˆ f), Closure (Set.image2 Ï• v s) âŠ† c) (hs : s.nonempty) : (OmegaLimit f Ï• s).nonempty
{Î± : Type u} {Î¹ : Type x} [pseudoEmetricSpace Î±] (f : Î¹ â†’ Function.End Î±) (K : Î¹ â†’ Nnreal) (h : âˆ€ (i : Î¹), LipschitzWith (K i) (f i)) (l : List Î¹) : LipschitzWith (List.map K l).prod (List.map f l).prod
{M : Type u_1} [AddMonoid M] (a : M) (u : addUnits M) : IsAddUnit (a + â†‘u) â†” IsAddUnit a
{Î± : Type u_1} [completeLattice Î±] {k : Î±} (hk : CompleteLattice.IsCompactElement k) {s : Set Î±} (hemp : s.nonempty) (hdir : DirectedOn LE.le s) (hbelow : âˆ€ (x : Î±), x âˆˆ s â†’ x < k) : HasSup.sup s < k
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {X Y : C} (f g : X âŸ¶ Y) (w : âˆ€ (x : â†¥X), â‡‘f x = â‡‘g x) : f = g
{Î± : Type u_1} {M : Type u_4} [AddCommMonoid M] (f : Î± â†’ M) {s t : Finset Î±} (h : s âŠ† t) : s.sum (Î» (i : Î±), f i) = t.sum (Î» (i : Î±), â†‘s.indicator f i)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (i : Î¹) : â‡‘((s.erase i).weighted_vsub_of_point p (p i)) w = â‡‘(s.weighted_vsub_of_point p (p i)) w
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : InnerProductGeometry.angle x y = InnerProductGeometry.angle y x
{Î± : Type u_1} {Î² : Type u_2} {r : Setoid Î±} {f : Î± â†’ Î²} (h : setoid.ker f â‰¤ r) (hF : Function.Surjective f) : r.map f = r.map_of_surjective f h hF
(a : Cardinal) : a < 2 ^ a
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [Î  (n : Î²), Encodable (Î¹ n)] (s : Set X) {l : Filter Î²} (r : Î² â†’ Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ Set X) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), Emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, s âŠ† â‹ƒ (i : Î¹ n), t n i) (m : Ennreal â†’ Ennreal) : â‡‘(MeasureTheory.Measure.mkMetric m) s â‰¤ l.liminf (Î» (n : Î²), âˆ‘' (i : Î¹ n), m (Emetric.diam (t n i)))
{g : Matrix.SpecialLinearGroup (Fin 2) â„¤} {z : UpperHalfPlane} (hz : z âˆˆ ModularGroup.Fdo) (hg : g â€¢ z âˆˆ ModularGroup.Fdo) : â†‘g 1 0 = 0
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), AddMonoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : IsOfFinAddOrder x) (i : Î·) : IsOfFinAddOrder (x i)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup Vâ‚‚] [Module k Vâ‚‚] [addTorsor Vâ‚‚ Pâ‚‚] {p : Î¹ â†’ P} (hai : AffineIndependent k p) (f : P â†’áµƒ[k] Pâ‚‚) (hF : Function.Injective â‡‘f) : AffineIndependent k (â‡‘f âˆ˜ p)
{R : Type u_1} [CommRing R] (v w : Fin 3 â†’ R) : Matrix.dotProduct w (â‡‘(â‡‘crossProduct v) w) = 0
{M : Type u_1} [hasAdd M] {Î² : sort u_2} (c : AddCon M) (f : M â†’ Î²) (h : âˆ€ (a b : M), â‡‘c a b â†’ f a = f b) (x : M) : AddCon.liftOn â†‘x f h = f x
 : StrictConvexOn â„ Set.Univ Real.exp
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topologicalSpace Î±] [uniformSpace Î²] (X : Set (C(Î±, Î²) Ã— C(Î±, Î²))) : X âˆˆ ContinuousMap.compactConvergenceUniformity â†” âˆƒ (K : Set Î±) (V : Set (Î² Ã— Î²)) (hK : is_IsCompact K) (hV : V âˆˆ Uniformity Î²), {fg : C(Î±, Î²) Ã— C(Î±, Î²) | âˆ€ (x : Î±), x âˆˆ K â†’ (â‡‘(fg.fst) x, â‡‘(fg.snd) x) âˆˆ V} âŠ† X
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Kâ‚ Kâ‚‚ : Submodule ð•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) : Kâ‚á—®á—® â‰¤ Kâ‚‚á—®á—®
{Î¹ : Type u_1} {Î± : Type u_3} [Preorder Î¹] [LinearOrder Î±] {u : Î¹ â†’ Î±} (h : Monotone u) (H : Â¬BddAbove (Set.Range u)) : Filter.Tendsto u Filter.atTop Filter.atTop
(p : â„•) (G : Type u_1) [Group G] [Fact (Nat.Prime p)] [Fintype (Sylow p G)] : Fintype.card (Sylow p G) â‰¡ 1 [Mod p]
{M : Type u_1} [hasMul M] (c : Con M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w * y) (x * z)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {sâ‚ sâ‚‚ : AffineSubspace k P} {p : P} (hâ‚ : p âˆˆ sâ‚) (hâ‚‚ : p âˆˆ sâ‚‚) : (sâ‚ âŠ“ sâ‚‚).direction = sâ‚.direction âŠ“ sâ‚‚.direction
{Î± : Type u} [AddCommGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b c : Î±} : a < b + c â†’ a - b < c
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î±] [DecidableEq Î²] (f : Î± â†’ Î²) (s : Multiset Î±) (hF : Set.InjOn f {x : Î± | x âˆˆ s}) (x : Î±) (H : x âˆˆ s) : Multiset.count (f x) (Multiset.map f s) = Multiset.count x s
 : â‡‘LinearEquiv.det complex.conj_lie.to_linearEquiv = -1
{C : Type u} [CategoryTheory.Category C] {X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) [CategoryTheory.Limits.HasPullback f g] : CategoryTheory.Limits.HasPullback g f
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x : V} (hx : x â‰  0) (Î¸ : Real.Angle) : â‡‘(o.rotation Î¸) x = x â†” Î¸ = 0
{p n : â„•} : padicValInt p â†‘n = padicValNat p n
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] {M' : Type v'} [AddCommGroup M'] [Module R M'] (f : M â‰ƒâ‚—[R] M') : (Module.rank R M).lift = (Module.rank R M').lift
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {jâ‚ jâ‚‚ kâ‚ kâ‚‚ : C} (fâ‚ : jâ‚ âŸ¶ kâ‚) (gâ‚ : jâ‚ âŸ¶ kâ‚‚) (fâ‚‚ : jâ‚‚ âŸ¶ kâ‚) (gâ‚‚ : jâ‚‚ âŸ¶ kâ‚‚) : âˆƒ (s : C) (Î± : kâ‚ âŸ¶ s) (Î² : kâ‚‚ âŸ¶ s), fâ‚ â‰« Î± = gâ‚ â‰« Î² âˆ§ fâ‚‚ â‰« Î± = gâ‚‚ â‰« Î²
{Î± : Type u_1} [linearOrderedField Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a
{C : CategoryTheory.Groupoid} : ðŸ­ â†¥C = ðŸ™ C
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x : â†¥(NonZeroDivisors R)) : 0 < v.int_Valuation_def â†‘x
{M : Type u_1} [MulOneClass M] (S : Submonoid M) : S = âŠ¥ âˆ¨ âˆƒ (x : M) (H : x âˆˆ S), x â‰  1
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (h : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) â‰  1) : âˆƒ (x : Î±) (H : x âˆˆ s), f x â‰  1
{Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ Set Î±} (hs : IndexedPartition s) (x : hs.quotient) : hs.proj (â‡‘(hs.out) x) = x
{Î± : Type u} [CommGroup Î±] : IsGroupHom Inv.inv
{Î± : Type u} [uniformSpace Î±] {s : Set Î±} (h : TotallyBounded s) : TotallyBounded (Closure s)
 : Filter.Tendsto (Î» (x : â„), x ^ ((-1) / x)) Filter.atTop (nhds 1)
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] [NormalSpace Y] [Nonempty X] (f : boundedContinuousFunction X â„) {e : X â†’ Y} (hE : ClosedEmbedding e) : âˆƒ (g : boundedContinuousFunction Y â„), (âˆ€ (y : Y), âˆƒ (xâ‚ xâ‚‚ : X), â‡‘g y âˆˆ Set.Icc (â‡‘f xâ‚) (â‡‘f xâ‚‚)) âˆ§ â‡‘g âˆ˜ e = â‡‘f
(s : â„) : (Î» (x : â„), Real.exp (-x) * x ^ s) =o[Filter.atTop] Î» (x : â„), Real.exp (-(1 / 2) * x)
{Î± : Type u} [topologicalSpace Î±] {f : Filter Î±} : is_IsClosed {x : Î± | ClusterPt x f}
{Î± : Type u} [Preorder Î±] {a b : Î±} (h : a â‰¤ b) : Â¬b < a
{f : â„• â†’ â„} (hfa : Monotone f) (hF0 : Filter.Tendsto f Filter.atTop (nhds 0)) : âˆƒ (l : â„), Filter.Tendsto (Î» (n : â„•), (Finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i)) Filter.atTop (nhds l)
{Î² : Type u} {Î± : Type v} {s : Finset Î±} {a : Î±} {f : Î± â†’ Î²} [AddCommMonoid Î²] [DecidableEq Î±] (h : f a = 0) : (HasInsert.insert a s).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
{Î± : Type u} [Preorder Î±] {a : Î±} {s t p : Set Î±} (hs : IsGlb s a) (hp : IsGlb p a) (hst : s âŠ† t) (htp : t âŠ† p) : IsGlb t a
{Î± : Type u_1} {Î´ : Type u_5} [topologicalSpace Î±] [measurableSpace Î±] [BorelSpace Î±] [measurableSpace Î´] [completeLinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {f : â„• â†’ Î´ â†’ Î±} (hF : âˆ€ (i : â„•), Measurable (f i)) : Measurable (Î» (x : Î´), filter.at_top.liminf (Î» (i : â„•), f i x))
{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hF : Function.IsFixedPt f x) (hg : Function.IsFixedPt g x) : Function.IsFixedPt (f âˆ˜ g) x
(b m : â„•) (hb : 2 â‰¤ b) : m â‰  0 â†’ b ^ (b.digits m).length â‰¤ b * m
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [normedSpace ð•œ E] [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ G} {C : â„} {s : Set E} {x y : E} (hF : âˆ€ (x : E), x âˆˆ s â†’ DifferentiableAt ð•œ f x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv ð•œ f xâˆ¥ â‰¤ C) (hs : Convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{f : â„ â†’ â„} {a : â„} (h : IsLocalExtr f a) : deriv f a = 0
{G : Type u_1} {H : Type u_2} [Group G] [Group H] [IsCyclic H] (f : G â†’* H) (hF : f.ker â‰¤ Subgroup.center G) (a b : G) : a * b = b * a
{Î± : Type u} [pseudoEmetricSpace Î±] (Î´ : â„) {Eâ‚ Eâ‚‚ : Set Î±} (h : Eâ‚ âŠ† Eâ‚‚) : Metric.Thickening Î´ Eâ‚ âŠ† Metric.Thickening Î´ Eâ‚‚
{R : Type uâ‚} {L : Type uâ‚‚} {M : Type uâ‚„} [CommRing R] [LieRing L] [lieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [lieModule R L M] [IsNoetherian R L] : LieModule.IsNilpotent R L M â†” âˆ€ (x : L), IsNilpotent (â‡‘(LieModule.toEndomorphism R L M) x)
{Î¹ : Type u} {X : Type v} [topologicalSpace X] [ParacompactSpace X] (u : Î¹ â†’ Set X) (uo : âˆ€ (a : Î¹), is_IsOpen (u a)) (uc : (â‹ƒ (i : Î¹), u i) = Set.Univ) : âˆƒ (v : Î¹ â†’ Set X), (âˆ€ (a : Î¹), is_IsOpen (v a)) âˆ§ (â‹ƒ (i : Î¹), v i) = Set.Univ âˆ§ LocallyFinite v âˆ§ âˆ€ (a : Î¹), v a âŠ† u a
(n : â„•) : LinearIndependent â„š (Î» (Î½ : Fin (n + 1)), bernsteinPolynomial â„š n â†‘Î½)
{M : Type u_1} [AddMonoid M] {Î¹ : sort u_2} {s : Î¹ â†’ Set M} (h : âˆ€ (y : Î¹), IsAddSubmonoid (s y)) : IsAddSubmonoid (Set.Inter s)
{Î± : Type u_1} [completeLattice Î±] {a : Î±} {s : Set Î±} : HasInf.inf s âŠ” a â‰¤ â¨… (b : Î±) (H : b âˆˆ s), b âŠ” a
{M : Type u_3} {N : Type u_4} [hasOne M] [hasOne N] {f g : OneHom M N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (pâ‚ pâ‚‚ : P) : HasDist.dist pâ‚ (â‡‘(EuclideanGeometry.reflection s) pâ‚‚) = HasDist.dist (â‡‘(EuclideanGeometry.reflection s) pâ‚) pâ‚‚
{Î¹ : sort u_1} {Î¹' : sort u_2} {Î± : Type u_3} [completeLattice Î±] {s : Î¹ â†’ Î±} (hs : CompleteLattice.Independent s) (f : Î¹' â†’ Î¹) (hF : Function.Injective f) : CompleteLattice.Independent (s âˆ˜ f)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [linearOrderedField ð•œ] [AddCommGroup E] [linearOrderedAddCommGroup Î²] [Module ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : ConcaveOn ð•œ (â‡‘(convexHull ð•œ) s) f) {x : E} (hx : x âˆˆ â‡‘(convexHull ð•œ) s) : âˆƒ (y : E) (H : y âˆˆ s), f y â‰¤ f x
 : Set.Unbounded LT.lt {b : Ordinal | b.card.ord = b}
{Î± : Type u_1} {R : Type u_2} {l : Filter Î±} {f : Î± â†’ R} {r : R} [linearOrderedRing R] [Archimedean R] (hr : r < 0) (hF : Filter.Tendsto f l Filter.atTop) : Filter.Tendsto (Î» (x : Î±), f x * r) l Filter.atBot
{z : UpperHalfPlane} (h : â‡‘Complex.normSq â†‘z < 1) : z.im < (ModularGroup.s â€¢ z).im
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [orderedSemiring ð•œ] [AddCommGroup E] [Module ð•œ E] {Î¹' : Type u_4} (f : Î¹' â†ª Î¹) {p : Î¹ â†’ E} (hc : ConvexIndependent ð•œ p) : ConvexIndependent ð•œ (p âˆ˜ â‡‘f)
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] (f : â„• â†’ R) (g : â„• â†’ M) {m n : â„•} (hmn : m < n) : (Finset.ico m n).sum (Î» (i : â„•), f i â€¢ g i) = f (n - 1) â€¢ (Finset.range n).sum (Î» (i : â„•), g i) - f m â€¢ (Finset.range m).sum (Î» (i : â„•), g i) - (Finset.ico m (n - 1)).sum (Î» (i : â„•), (f (i + 1) - f i) â€¢ (Finset.range (i + 1)).sum (Î» (i : â„•), g i))
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] {s t : Set E} (hsâ‚ : Convex â„ s) (hsâ‚‚ : is_IsCompact s) (htâ‚ : Convex â„ t) (htâ‚‚ : is_IsClosed t) (disj : Disjoint s t) : âˆƒ (f : E â†’L[â„] â„) (u v : â„), (âˆ€ (a : E), a âˆˆ s â†’ â‡‘f a < u) âˆ§ u < v âˆ§ âˆ€ (b : E), b âˆˆ t â†’ v < â‡‘f b
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : Dense (Closure s) â†” Dense s
{M : Type u_1} {F : Type u_2} [Monoid F] (c : F â†’ M â†’ M) (h1 : c 1 = Id) (HMul : âˆ€ (f g : F), c (f * g) = c f âˆ˜ c g) (f : F) (n : â„•) : c (f ^ n) = (c f^[n])
{Î± : Type u_1} {Î² : Type u_2} {e e' : LocalEquiv Î± Î²} (h : âˆ€ (x : Î±), â‡‘e x = â‡‘e' x) (hsymm : âˆ€ (x : Î²), â‡‘(e.symm) x = â‡‘(e'.symm) x) (hs : e.source = e'.source) : e = e'
{ð•œ : Type u_1} {E : Type u_4} [NormedGroup E] [nondiscreteNormedField ð•œ] [normedSpace ð•œ E] [Nontrivial E] : âˆ¥ContinuousLinearMap.id ð•œ Eâˆ¥ = 1
{f : â„ â†’ â„} (hF : Differentiable â„ f) (hF'_Mono : Monotone (deriv f)) : ConvexOn â„ Set.Univ f
{Î± : Type u_1} {Î² : Type u_2} {Gâ‚€ : Type u_3} [groupWithZero Gâ‚€] [topologicalSpace Gâ‚€] [HasContinuousInvâ‚€ Gâ‚€] [HasContinuousMul Gâ‚€] [topologicalSpace Î±] [topologicalSpace Î²] {f g : Î± â†’ Gâ‚€} (h : Î± â†’ Gâ‚€ â†’ Î²) (hF : Continuous f) (hg : Continuous g) (hH : âˆ€ (a : Î±), g a â‰  0 â†’ ContinuousAt â†¿h (a, f a / g a)) (h2h : âˆ€ (a : Î±), g a = 0 â†’ Filter.Tendsto â†¿h ((nhds a).prod âŠ¤) (nhds (h a 0))) : Continuous (Î» (x : Î±), h x (f x / g x))
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a : Î±} : a < 0 â†’ 0 < -a
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {c : â„} {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥) â†’ asymptotics.is_O_with c l f g
(p : â„•) [Fact (Nat.Prime p)] {a : â„¤} (ha0 : â†‘a â‰  0) : Zmod.legendreSym p a = 1 â†” IsSquare â†‘a
(ð•œ : Type u_1) [nondiscreteNormedField ð•œ] {E : Type u_2} [semiNormedGroup E] [normedSpace ð•œ E] [ProperSpace ð•œ] {s : Set E} (s_nhd : s âˆˆ nhds 0) : is_IsCompact (WeakDual.Polar ð•œ s)
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] {f : X â†’ Y} [SequentialSpace X] : Continuous f â†” SeqContinuous f
{Î± : Type u} [Preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b â‰¤ c) : a â‰¤ c
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hD : DiffContOnCl â„‚ f (Set.Ioi 0 Ã—â„‚ Set.Iio 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Ioi 0 Ã—â„‚ Set.Iio 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz_re : 0 â‰¤ z.re) (hz_im : z.im â‰¤ 0) : âˆ¥f zâˆ¥ â‰¤ C
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸ : Real.Angle) : (-o).rotation Î¸ = o.rotation (-Î¸)
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] : OmegaCompletePartialOrder.Continuous' Coe
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {p : Filter Î¹} {c : Î²} : Filter.Tendsto â†¿F (p.prod âŠ¤) (nhds c) â†” TendstoUniformly F (Î» (_x : Î±), c) p
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hi : Irreflexive r) {s : Multiset Î±} : (âˆ€ (a : Î±), a âˆˆ s â†’ Acc (Relation.CutExpand r) {a}) â†’ Acc (Relation.CutExpand r) s
{S : Set Ordinal} (o : Ordinal) : Ordinal.enumOrd S o = HasInf.inf (S âˆ© {b : Ordinal | âˆ€ (c : Ordinal), c < o â†’ Ordinal.enumOrd S c < b})
(n : â„•) : finset.univ.sum (Î» (i : Affine.Simplex.PointsWithCircumcenterIndex n), Affine.Simplex.circumcenterWeightsWithCircumcenter n i) = 1
{Î± : Type u} [pseudoEmetricSpace Î±] (E : Set Î±) {Î´ : â„} : Frontier (Metric.Cthickening Î´ E) âŠ† {x : Î± | Emetric.infEdist x E = Ennreal.ofReal Î´}
(f f' : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfI : f a = f b) (hff' : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), f' c = 0
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} (h : is_is_IsLocalMax f a) (hF : HasFderivAt f f' a) : f' = 0
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topologicalSpace Î±] [uniformSpace Î²] {K : Set Î±} {V : Set (Î² Ã— Î²)} (f : C(Î±, Î²)) (hV : V âˆˆ Uniformity Î²) : âˆƒ (V' : Set (Î² Ã— Î²)) (H : V' âˆˆ Uniformity Î²), V' âŠ† V âˆ§ âˆ€ (g : C(Î±, Î²)), g âˆˆ ContinuousMap.CompactConvNhd K V' f â†’ ContinuousMap.CompactConvNhd K V' g âŠ† ContinuousMap.CompactConvNhd K V f
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {X : C} {S : CategoryTheory.Sieve X} (h : Jâ‚.is_IsClosed S) {Y : C} (f : Y âŸ¶ X) : Jâ‚.covers S f â†” â‡‘S f
 : Real.sin (Real.pi / 3) = Real.sqrt 3 / 2
{X : Compactum} (F : Ultrafilter â†¥X) : F.Lim = X.str F
(p : â„•) (q : â„š) : padicNorm p (-q) = padicNorm p q
{ð•œ : Type u_1} {E : Type u_3} [orderedSemiring ð•œ] [topologicalSpace E] [addCancelCommMonoid E] [HasContinuousAdd E] [Module ð•œ E] {s : Set E} (hs : StrictConvex ð•œ s) (z : E) : StrictConvex ð•œ ((Î» (x : E), z + x) â»Â¹' s)
{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„¤) : m â‰¤ n â†’ P n
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.FinitePresentation R A â†” âˆƒ (Î¹ : Type u_2) (_x : Fintype Î¹) (f : MvPolynomial Î¹ R â†’â‚[R] A), Function.Surjective â‡‘f âˆ§ f.to_Ring_hom.ker.fg
{n : â„•} [Fact (0 < n)] (x : (Zmod n)Ë£) : x ^ n.totient = 1
{Î³ : Type w} [LinearOrder Î³] {a b : Î³} {s t : Set Î³} (ha : IsLeast s a) (hb : IsLeast t b) : IsLeast (s âˆª t) (Linear_order.min a b)
{R : Type u_1} {M : Type u_3} [monoidWithZero R] [hasZero M] [mulActionWithZero R M] : Â¬IsSmulRegular M 0 â†” Nontrivial M
{R : Type u_4} [linearOrderedCommRing R] (a b : R) : 2 * a * b â‰¤ a ^ 2 + b ^ 2
{Î± : Type u} [topologicalSpace Î±] : TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), ConnectedComponent x = {x}
{E : Type u_4} {F : Type u_5} [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] [NormedGroup F] [normedSpace â„ F] [FiniteDimensional â„ F] {f : E â†’ F} (h : ContDiff â„ 1 f) (hEF : FiniteDimensional.finrank â„ E < FiniteDimensional.finrank â„ F) : Dense (Set.Range f)á¶œ
{F : Type u_2} [NormedGroup F] [normedSpace â„ F] {x y : F} (hx : x â‰  0) (hy : y â‰  0) : SameRay â„ x y â†’ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (p : P) : p âˆ‰ âŠ¥
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] [Fintype m] [DecidableEq m] (A : Matrix m n Î±) (B : Matrix n m Î±) : (A.mul B + 1).det = (B.mul A + 1).det
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) : K âŠ“ Ká—® = âŠ¥
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {f : Î± â†’ Î²} (hF : IsAddGroupHom f) : f 0 = 0
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} (hF' : DenseRange f) (hF : Continuous f) {s : Set Î±} (hs : Dense s) {t : Set Î²} (ht : Set.MapsTo f s t) : Dense t
(M N : â„•) : â‡‘rothNumberNat (M + N) â‰¤ â‡‘rothNumberNat M + â‡‘rothNumberNat N
{E : Type u_4} [NormedGroup E] [normedSpace â„ E] {b : â„} {f : â„• â†’ â„} {z : â„• â†’ E} (hfa : Antitone f) (hF0 : Filter.Tendsto f Filter.atTop (nhds 0)) (hzb : âˆ€ (n : â„•), âˆ¥(Finset.range n).sum (Î» (i : â„•), z i)âˆ¥ â‰¤ b) : CauchySeq (Î» (n : â„•), (Finset.range (n + 1)).sum (Î» (i : â„•), f i â€¢ z i))
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} (h : s âŠ† t) : Emetric.diam s â‰¤ Emetric.diam t
(m : â„¤) : ConvexOn â„ (Set.Ioi 0) (Î» (x : â„), x ^ m)
{Î± : Type u_1} [AddSemigroup Î±] [PartialOrder Î±] [CovariantClass Î± Î± Add.add LT.lt] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] [ContravariantClass Î± Î± Add.add LE.le] [ContravariantClass Î± Î± (Function.swap Add.add) LE.le] {a b c d : Î±} (hac : a â‰¤ c) (hbd : b â‰¤ d) : a + b = c + d â†” a = c âˆ§ b = d
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} (h : (s âˆ© t).nonempty) : Metric.diam (s âˆª t) â‰¤ Metric.diam s + Metric.diam t
{Î± : Type u_1} [CommMonoid Î±] (f : â„• â†’ Î±) (n : â„•) : finset.univ.prod (Î» (i : Fin n), f â†‘i) = (Finset.range n).prod (Î» (i : â„•), f i)
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] [Finite : FiniteDimensional K L] : Algebra.IsAlgebraic K L
(Î± : Type u_1) [Fintype Î±] {R : Type u_2} [CommSemiring R] (a b : R) : finset.univ.sum (Î» (s : Finset Î±), a ^ s.card * b ^ (Fintype.card Î± - s.card)) = (a + b) ^ Fintype.card Î±
(n k : â„•) : (n ^ k).factorization = k â€¢ n.factorization
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [DecidableEq Î±] (H : FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚) : FreeGroup.mk Lâ‚ = FreeGroup.mk Lâ‚‚
{M : Type u_3} [Monoid M] [Inhabited M] (l : List M) (h : l â‰  List.nil) : l.head * l.tail.prod = l.prod
{Î± : Type u} [Preorder Î±] {f : â„• â†’ Î±} (hF : Monotone f) (n : â„•) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„•) : f a â‰  x
{M : Type u_1} {N : Type u_2} [MulOneClass M] [MulOneClass N] (h : M â‰ƒ* N) : â‡‘h 1 = 1
(R : Type u_1) [CommRing R] [is_IsDomain R] : Polynomial.cyclotomic' 0 R = 1
{Î± : Type u} {l : List Î±} (hn : l.nodup) : l.cyclic_permutations.nodup
{ð•‚ : Type u_1} [is_R_or_C ð•‚] : HasStrictDerivAt (Exp ð•‚) 1 0
{Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ Ennreal} : s.sum (Î» (a : Î±), f a) < âŠ¤ â†” âˆ€ (a : Î±), a âˆˆ s â†’ f a < âŠ¤
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup Vâ‚‚] [Module k Vâ‚‚] [addTorsor Vâ‚‚ Pâ‚‚] {p : Î¹ â†’ P} (f : P â†’áµƒ[k] Pâ‚‚) (hF : Function.Injective â‡‘f) : AffineIndependent k (â‡‘f âˆ˜ p) â†” AffineIndependent k p
{x : â„} (hx : Liouville x) (p : â„) : LiouvilleWith p x
{n : Type u_1} {ð•œ : Type u_3} [Field ð•œ] [DecidableEq n] [Fintype n] (M : Matrix n n ð•œ) : âˆƒ (L L' : List (Matrix.TransvectionStruct n ð•œ)) (D : n â†’ ð•œ), M = ((List.map Matrix.TransvectionStruct.toMatrix L).prod.mul (Matrix.diagonal D)).mul (List.map Matrix.TransvectionStruct.toMatrix L').prod
(K : Type u) (V : Type v) [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] : â†‘(FiniteDimensional.finrank K V) = Module.rank K V
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {r : Setoid Î²} : setoid.comap f r = setoid.ker (Quotient.mk âˆ˜ f)
(x : â„) : Summable (Î» (n : â„•), x ^ n / â†‘(n.factorial))
{Î± : Type u} [pseudoMetricSpace Î±] (s : Set Î±) : UniformContinuous (Î» (x : Î±), Metric.infNndist x s)
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] : Submodule.torsion R â†¥(Submodule.torsion R M) = âŠ¤
{Î¹ : Type u} {Î± : Type v} [DecidableEq Î±] (t : Î¹ â†’ Finset Î±) : (âˆ€ (s : Finset Î¹), s.card â‰¤ (s.bUnion t).card) â†” âˆƒ (f : Î¹ â†’ Î±), Function.Injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
{n : â„•} (A B : Finset (Fin n)) : (Finset.image (Î» (i : Fin n), â†‘i) A).to_colex â‰¤ (Finset.image (Î» (i : Fin n), â†‘i) B).to_colex â†” A.to_colex â‰¤ B.to_colex
{F : Type u_3} [Field F] [Fintype F] (hF : ringChar F â‰  2) (a : FË£) : IsSquare a â†” a ^ (Fintype.card F / 2) = 1
{G : Type u} {y : G} [Monoid G] {x : G} (h : Commute x y) (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasDerivAt (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c b
{M : Type u} [DivInvMonoid M] (x : M) (z : â„¤) : MulOpposite.op (x ^ z) = MulOpposite.op x ^ z
{X Y : Type u} (f : X âŸ¶ Y) : CategoryTheory.Epi f â†” Function.Surjective f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} (n : â„•) (hs : is_IsOpen s) : Set.EqOn (iteratedFderivWithin ð•œ n f s) (iteratedFderiv ð•œ n f) s
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] {i : D.to_glue_data.J} (U : TopologicalSpace.Opens â†¥((D.to_glue_data.U i).carrier)) : âˆƒ (Eq1 : Opposite.op U = Opposite.op ((TopologicalSpace.Opens.map (CategoryTheory.Limits.colimitÎ¹ D.to_glue_data.diagram.multispan (Opposite.unop (Opposite.op (CategoryTheory.Limits.WalkingMultispan.right i)))).base).obj (_.functor.obj U))), D.Î¹_Inv_App U â‰« D.diagram_over_IsOpen_Ï€ U i = (D.to_glue_data.U i).presheaf.map (CategoryTheory.eqToHom Eq1)
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} : IsMinOn f s a â†’ IsMaxOn (â‡‘OrderDual.toDual âˆ˜ f) s a
{L : FirstOrder.Language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.equiv M N) (g : L.equiv N P) (h : L.equiv P Q) : (h.comp g).comp f = h.comp (g.comp f)
{f : â„‚ â†’ â„‚} {c : â„‚} {Râ‚ Râ‚‚ : â„} (hD : DifferentiableOn â„‚ f (Metric.Ball c Râ‚)) (h_maps : Set.MapsTo f (Metric.Ball c Râ‚) (Metric.Ball (f c) Râ‚‚)) (hâ‚€ : 0 < Râ‚) : Complex.abs (deriv f c) â‰¤ Râ‚‚ / Râ‚
(n : â„•+) (K : Type w) (L : Type z) [Field K] [Field L] [Algebra K L] [NeZero â†‘â†‘n] [IsCyclotomicExtension {n} K L] : Polynomial.IsSplittingField K L (Polynomial.x ^ â†‘n - 1)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {n : WithTop â„•} {p : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpTo n f p) (hn : 1 â‰¤ n) (x : E) : HasFderivAt f (â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (p x 1)) x
{n : â„•} : n.factorization.support = n.factors.to_Finset
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (ð•œ : Type u_3) [Field ð•œ] [IsAlgClosed ð•œ] [CategoryTheory.Linear ð•œ C] [CategoryTheory.Limits.HasKernels C] (X Y : C) [FiniteDimensional ð•œ (X âŸ¶ X)] [CategoryTheory.Simple X] [CategoryTheory.Simple Y] : FiniteDimensional.finrank ð•œ (X âŸ¶ Y) â‰¤ 1
(a : Zmod4) : â‡‘ZmodÏ‡â‚„ a = 0 âˆ¨ â‡‘ZmodÏ‡â‚„ a = 1 âˆ¨ â‡‘ZmodÏ‡â‚„ a = -1
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [IsAntisymm Î± r] {a b : Î±} : r a b â†’ r b a â†’ a = b
{R : Type uâ‚} [CommSemiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2
(n : â„•) (R : Type u_1) [CommRing R] [is_IsDomain R] : (Polynomial.cyclotomic' n R).monic
(R : Type u_1) {M : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) [Semiring S] [HasScalar R S] [Module S M] [isScalarTower R S M] : Submodule.span S â†‘(Submodule.span R s) = Submodule.span S s
{K : Type u_8} {V : Type u_11} [Field K] [AddCommGroup V] [Module K V] {B : V â†’â‚—[K] V â†’â‚—[K] K} {x : V} (hx : Â¬B.is_IsOrtho x x) : is_HasCompl (Submodule.span K {x}) ((Submodule.span K {x}).orthogonal_bilin B)
{R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [topologicalSpace M] [topologicalSpace Mâ‚‚] [Semiring R] [AddCommMonoid Mâ‚‚] [Module R Mâ‚‚] [AddCommMonoid M] [Module R M] (f : M â†’L[R] Mâ‚‚) (h : Â¬âˆƒ (e' : M â‰ƒL[R] Mâ‚‚), â†‘e' = f) : f.inverse = 0
(p : â„•) [Fact (Nat.Prime p)] (a : â„¤) : Zmod.legendreSym p a = Zmod.legendreSym p (a % â†‘p)
(R : Type uâ‚) {L : Type uâ‚‚} [CommRing R] [LieRing L] [lieAlgebra R L] {A : Type uâ‚ƒ} [Ring A] [Algebra R A] {gâ‚ gâ‚‚ : UniversalEnvelopingAlgebra R L â†’â‚[R] A} (h : â†‘gâ‚.comp (UniversalEnvelopingAlgebraÎ¹ R) = â†‘gâ‚‚.comp (UniversalEnvelopingAlgebraÎ¹ R)) : gâ‚ = gâ‚‚
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {f g : ð•œ â†’ ð•œ} {f' a : ð•œ} (hg : ContinuousAt g a) (hF : HasStrictDerivAt f f' (g a)) (hF' : f' â‰  0) (hfg : âˆ€á¶  (y : ð•œ) in nhds a, f (g y) = y) : HasStrictDerivAt g f'â»Â¹ a
(K : Type u) [divisionRing K] : FiniteDimensional.finrank K K = 1
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] {dâ‚ dâ‚‚ : â„} (h : dâ‚ < dâ‚‚) (s : Set X) : â‡‘(MeasureTheory.Measure.hausdorffMeasure dâ‚‚) s = 0 âˆ¨ â‡‘(MeasureTheory.Measure.hausdorffMeasure dâ‚) s = âŠ¤
{F : Type u_3} [innerProductSpace â„ F] {x : F} {r : â„} (hx : x â‰  0) (hr : 0 < r) : HasInner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
{R : Type uâ‚} [linearOrderedRing R] {a : R} (H : -1 â‰¤ a) (n : â„•) : 1 + â†‘n * (a - 1) â‰¤ a ^ n
{Î± : Type u} {Î² : Type v} [AddZeroClass Î±] [AddGroup Î²] {f : Î± â†’ Î²} (hF : IsAddHom f) : IsAddMonoidHom f
{Î± : Type u_1} {Î² : Type u_2} [hasMem Î± Î²] {s : Î²} {a b : Î±} : a âˆˆ s â†’ b âˆ‰ s â†’ a â‰  b
{Î± : Type u} [Preorder Î±] {f : â„• â†’ Î±} (hF : Antitone f) (n : â„•) {x : Î±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : â„•) : f a â‰  x
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) : CategoryTheory.Presieve.IsSheaf Jâ‚ (CategoryTheory.Functor.closedSieves Jâ‚)
(p : â„•) {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime p)] [CommRing R] [CommRing S] (f : R â†’+* S) (r : R) : â‡‘(WittVector.map f) (â‡‘(WittVector.teichmuller p) r) = â‡‘(WittVector.teichmuller p) (â‡‘f r)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (pâ‚‚ : Î¹ â†’ P) (pâ‚ : P) (h : s.sum (Î» (i : Î¹), w i) = 1) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = pâ‚ -áµ¥ â‡‘(s.affine_combination pâ‚‚) w
{r n : â„•} (h : r < n / 2) : n.choose r â‰¤ n.choose (r + 1)
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [Nontrivial k] {p1 : P} {p : Î¹ â†’ P} : p1 âˆˆ affineSpan k (Set.Range p) â†” âˆƒ (s : Finset Î¹) (w : Î¹ â†’ k) (hw : s.sum (Î» (i : Î¹), w i) = 1), p1 = â‡‘(s.affine_combination p) w
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ F} {x : E} {n : WithTop â„•} (g : F â†’L[ð•œ] G) (hF : ContDiffAt ð•œ n f x) : ContDiffAt ð•œ n (â‡‘g âˆ˜ f) x
{Î± : Type u_1} [DecidableEq Î±] {s t : Finset Î±} (h : s âŠ† t) : (Finset.ioo s t).card = 2 ^ (t.card - s.card) - 2
{R : Type u} [Ring R] [RankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {Î¹ : Type u_1} [Fintype Î¹] (b : Basis Î¹ R M) {w : Set M} [Fintype â†¥w] (s : Submodule.span R w = âŠ¤) : Fintype.card Î¹ â‰¤ Fintype.card â†¥w
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : E â†’ G} (hF : ContDiff ð•œ n f) : ContDiff ð•œ n (Î» (x : E Ã— F), f x.fst)
{K : Type u_1} [linearOrderedField K] [floorRing K] {v : K} : (generalized_continued_fraction.int_fract_pair.seq1 v).fst = GeneralizedContinuedFraction.IntFractPair.of v
{Î± : Type u_1} [DecidableEq Î±] (s : Finset Î±) : (Finset.image Quotient.mk s.diag).card = s.card
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {n : â„•} : iteratedFderivWithin ð•œ (n + 1) f s = â‡‘(continuousMultilinearCurryLeftEquiv ð•œ (Î» (i : Fin (n + 1)), E) F) âˆ˜ fderivWithin ð•œ (iteratedFderivWithin ð•œ n f s) s
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b c : Î±} : a < c - b â†’ a + b < c
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {S : Submodule K V} (h : FiniteDimensional.finrank K â†¥S = FiniteDimensional.finrank K V) : S = âŠ¤
{C : Type uâ‚} [CategoryTheory.Category C] {X : C} (P : Cáµ’áµ– â¥¤ Type w) : CategoryTheory.Presieve.IsSheafFor P â‡‘âŠ¤
{Î± : Type uu} (a : Î±) {lâ‚ lâ‚‚ : List Î±} : lâ‚ <+~ lâ‚‚ â†’ a :: lâ‚ <+~ a :: lâ‚‚
{Î± : Type u_1} {Î¹ : sort u_3} [conditionallyCompleteLattice Î±] [Nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), c â‰¤ f x) : c â‰¤ infi f
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) (hF : CategoryTheory.IsEquivalence F) : CategoryTheory.IsEquivalence.ofIso (CategoryTheory.Iso.refl F) hF = hF
{Î± : Type u_1} : HasStar.star 1 = 1
(ð•œ : Type v) [is_R_or_C ð•œ] {E : Type u} [NormedGroup E] [normedSpace ð•œ E] (x : E) (h : x â‰  0) : âˆƒ (g : E â†’L[ð•œ] ð•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {j j' : C} (f f' : j âŸ¶ j') : CategoryTheory.IsCofiltered.eqHom f f' â‰« f = CategoryTheory.IsCofiltered.eqHom f f' â‰« f'
{p x : â„} {r : â„š} (hr : r â‰  0) : LiouvilleWith p (x * â†‘r) â†” LiouvilleWith p x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (w : Î¹ â†’ k) (p : Î¹ â†’ P) {sâ‚ sâ‚‚ : Finset Î¹} (h : sâ‚ âŠ† sâ‚‚) : â‡‘(sâ‚.affine_combination p) w = â‡‘(sâ‚‚.affine_combination p) (â†‘sâ‚.indicator w)
{Râ‚ : Type u_3} {A : Type u_5} {B : Type u_6} [CommSemiring Râ‚] [CommRing A] [CommRing B] [Algebra Râ‚ A] [Algebra Râ‚ B] (f : A â†’â‚[Râ‚] B) : Function.Injective â‡‘(Ideal.kerLiftAlg f)
{L : FirstOrder.Language} {M : Type u_3} [L.Structure M] : FirstOrder.Language.Structure.Fg L M â†” âˆƒ (S : Set M), S.finite âˆ§ â‡‘(FirstOrder.Language.Substructure.closure L) S = âŠ¤
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) (u v : â„• â†’ Î±) (hu : E.is_solution u) (hv : E.is_solution v) : u = v â†” Set.EqOn u v â†‘(Finset.range E.order)
 : Filter.Tendsto Real.exp Filter.atTop Filter.atTop
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f fâ‚ : E â†’ F} {x : E} {n : â„•} (hs : UniqueDiffOn ð•œ s) (hL : âˆ€ (y : E), y âˆˆ s â†’ fâ‚ y = f y) (hx : x âˆˆ s) : iteratedFderivWithin ð•œ n fâ‚ s x = iteratedFderivWithin ð•œ n f s x
{Î± : Type u_1} [topologicalSpace Î±] {s : Set Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] [HasContinuousAdd Î³] {f g : Î± â†’ Î³} (hF : UpperSemicontinuousOn f s) (hg : UpperSemicontinuousOn g s) : UpperSemicontinuousOn (Î» (z : Î±), f z + g z) s
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hi : Irreflexive r) {a : Î±} (hacc : Acc r a) : Acc (Relation.CutExpand r) {a}
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p âˆˆ s) : AffineSubspace.mk' p s.direction = s
{Î¹ : Type u_1} {V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape Î¹} [CategoryTheory.Limits.HasZeroObject V] [CategoryTheory.Limits.HasKernels V] [CategoryTheory.Limits.HasImages V] (C : HomologicalComplex V c) (i : Î¹) (h : C.boundaries i â‰¤ C.cycles i) : (C.boundaries i).of_LE (C.cycles i) h = C.boundaries_to_cycles i
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x y : E} : HasInner.inner x y = â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥ â†” â†‘âˆ¥yâˆ¥ â€¢ x = â†‘âˆ¥xâˆ¥ â€¢ y
{Î± : Type u} {R : Î± â†’ Î± â†’ Prop} {lâ‚ lâ‚‚ lâ‚ƒ : List Î±} (hâ‚ : List.Chain' R (lâ‚ ++ lâ‚‚)) (hâ‚‚ : List.Chain' R (lâ‚‚ ++ lâ‚ƒ)) (hn : lâ‚‚ â‰  List.nil) : List.Chain' R (lâ‚ ++ lâ‚‚ ++ lâ‚ƒ)
{M : Type u_1} [AddCommGroup M] [Module â„‚ M] [FiniteDimensional â„‚ M] (Q : QuadraticForm â„‚ M) (hQ : (â‡‘QuadraticForm.associated Q).nondegenerate) : Q.equivalent (QuadraticForm.weightedSumSquares â„‚ 1)
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] (f : S.localization_Map N) (x : M) (y : â†¥S) : âˆƒ (c : â†¥S), x + â†‘((f.sec (f.mk' x y)).snd) + â†‘c = (f.sec (f.mk' x y)).fst + â†‘y + â†‘c
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) (i : Fin (n + 1)) : s.points i = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (Affine.Simplex.pointWeightsWithCircumcenter i)
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] (v : V) (h : âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w) : FiniteDimensional.finrank K V â‰¤ 1
{Î² : Type u} {Î± : Type v} {s : Finset Î±} {a : Î±} {f : Î± â†’ Î²} [CommMonoid Î²] [DecidableEq Î±] (h : a âˆ‰ s â†’ f a = 1) : (HasInsert.insert a s).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (f : E â†’sl[Ïƒâ‚â‚‚] F) : Isometry â‡‘f â†” âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ = âˆ¥xâˆ¥
(Î¹ : Type u_1) {R : Type u_2} {Î± : Type u_3} [AddMonoid Î¹] [Monoid R] (l : List Î±) (fÎ¹ : Î± â†’ Î¹) (fA : Î± â†’ R) : l.dprod fÎ¹ fA = (List.map fA l).prod
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.FiniteType R A â†” âˆƒ (Î¹ : Type u_2) (_x : Fintype Î¹) (f : MvPolynomial Î¹ R â†’â‚[R] A), Function.Surjective â‡‘f
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} (hF : ClosedEmbedding f) {K : Set Î²} (hK : is_IsCompact K) : is_IsCompact (f â»Â¹' K)
{Mâ‚€ : Type u_1} {Mâ‚€' : Type u_3} [MulZeroOneClass Mâ‚€] [Nontrivial Mâ‚€] [hasZero Mâ‚€'] [hasOne Mâ‚€'] (f : Mâ‚€' â†’ Mâ‚€) (Zero : f 0 = 0) (One : f 1 = 1) : Nontrivial Mâ‚€'
{Î± : Type u_2} {Gâ‚€ : Type u_4} [topologicalSpace Î±] [groupWithZero Gâ‚€] [mulAction Gâ‚€ Î±] [HasContinuousConstSmul Gâ‚€ Î±] {c : Gâ‚€} (hc : c â‰  0) : IsClosedMap (Î» (x : Î±), c â€¢ x)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} {s : Affine.Simplex â„ P n} {p pâ‚ pâ‚‚ : P} {r : â„} (hpâ‚ : pâ‚ âˆˆ affineSpan â„ (HasInsert.insert p (Set.Range s.points))) (hpâ‚‚ : pâ‚‚ âˆˆ affineSpan â„ (HasInsert.insert p (Set.Range s.points))) (hâ‚ : âˆ€ (i : Fin (n + 1)), HasDist.dist (s.points i) pâ‚ = r) (hâ‚‚ : âˆ€ (i : Fin (n + 1)), HasDist.dist (s.points i) pâ‚‚ = r) : pâ‚ = pâ‚‚ âˆ¨ pâ‚ = â‡‘(EuclideanGeometry.reflection (affineSpan â„ (Set.Range s.points))) pâ‚‚
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {Î¹ : Type u_2} {E : Î¹ â†’ Type u_5} [DecidableEq Î¹] [Fintype Î¹] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] : IsBoundedBilinearMap ð•œ (Î» (p : (F â†’L[ð•œ] G) Ã— ContinuousMultilinearMap ð•œ E F), p.fst.comp_ContinuousMultilinearMap p.snd)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} {ps : Set P} (h : ps âŠ† â†‘s) [Nonempty â†¥s] [FiniteDimensional â„ â†¥(s.direction)] : EuclideanGeometry.Cospherical ps â†” âˆƒ (Center : P) (H : Center âˆˆ s) (radius : â„), âˆ€ (p : P), p âˆˆ ps â†’ HasDist.dist p Center = radius
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [is_R_or_C ð•‚] [normedCommRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] {x : ð”¸} : HasFderivAt (Exp ð•‚) (Exp ð•‚ x â€¢ 1) x
{Î² : Type u_4} [LinearOrder Î²] [NoMinOrder Î²] {u : â„• â†’ Î²} (hu : Filter.Tendsto u Filter.atTop Filter.atBot) : âˆƒá¶  (n : â„•) in Filter.atTop, âˆ€ (k : â„•), k < n â†’ u n < u k
{m : Type u} {Î± : Type v} [CommRing Î±] [Fintype m] [DecidableEq m] {M : Matrix m m Î±} (h : IsUnit M) (N : Matrix m m Î±) : ((M.mul N).mul Mâ»Â¹).det = N.det
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] [NormalSpace Y] (f : boundedContinuousFunction X â„) (e : C(X, Y)) (hE : ClosedEmbedding â‡‘e) : âˆƒ (g : boundedContinuousFunction Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ g.comp_Continuous e = f
{Î± : Type u_1} [Semigroup Î±] [PartialOrder Î±] [CovariantClass Î± Î± Mul.mul LT.lt] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] [ContravariantClass Î± Î± Mul.mul LE.le] [ContravariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a b c d : Î±} (hac : a â‰¤ c) (hbd : b â‰¤ d) : a * b = c * d â†” a = c âˆ§ b = d
{M : Type u_1} [hasMul M] {c d : Con M} : Setoid.r = Setoid.r âŠ“ Setoid.r
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {n : â„•} : ContDiffOn ð•œ â†‘(n + 1) f s â†” âˆ€ (x : E), x âˆˆ s â†’ (âˆƒ (u : Set E) (H : u âˆˆ nhdsWithin x (HasInsert.insert x s)) (f' : E â†’ (E â†’L[ð•œ] F)), (âˆ€ (x : E), x âˆˆ u â†’ HasFderivWithinAt f (f' x) u x) âˆ§ ContDiffOn ð•œ â†‘n f' u)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {s : Set E} : MdifferentiableOn (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f s â†’ DifferentiableOn ð•œ f s
{Î± : Type u} (p : Î± â†’ Prop) [DecidablePred p] (xs : List Î±) (h : âˆ€ (x : Î±), x âˆˆ xs â†’ Â¬p x) (HasSep : Î±) (hsep : p HasSep) (as : List Î±) : List.splitOn_p p (xs ++ HasSep :: as) = xs :: List.splitOn_p p as
{Î± : Type u_1} [CommMonoid Î±] {a b : Î±} {u : Î±Ë£} : a âˆ£ â†‘u * b â†” a âˆ£ b
{Î± : Type u_1} [CircularPreorder Î±] {a b c : Î±} (h : HasSbtw.Sbtw a b c) : HasBtw.Btw a b c
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) : s.circumcenter = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (Affine.Simplex.circumcenterWeightsWithCircumcenter n)
(R : Type u_1) {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsNoetherianRing R] {A : Set M} (hA : A.finite) : IsNoetherian R â†¥(Submodule.span R A)
{Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : a â‰¤ b) : Set.Ioi b âŠ† Set.Ici a
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] (s : Set Î±) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), 0)) = 0
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscreteNormedField ð•‚] [normedRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] (h : 0 < (expSeries ð•‚ ð”¸).radius) : HasStrictFderivAt (Exp ð•‚) 1 0
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [CommMonoid Î²] {s : Finset Î±} {t : Finset Î³} {f : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (a : Î±), a âˆˆ s â†’ Î³) (hi : âˆ€ (a : Î±) (ha : a âˆˆ s), i a ha âˆˆ t) (h : âˆ€ (a : Î±) (ha : a âˆˆ s), f a = g (i a ha)) (i_inj : âˆ€ (aâ‚ aâ‚‚ : Î±) (haâ‚ : aâ‚ âˆˆ s) (haâ‚‚ : aâ‚‚ âˆˆ s), i aâ‚ haâ‚ = i aâ‚‚ haâ‚‚ â†’ aâ‚ = aâ‚‚) (i_surj : âˆ€ (b : Î³), b âˆˆ t â†’ (âˆƒ (a : Î±) (ha : a âˆˆ s), b = i a ha)) : s.prod (Î» (x : Î±), f x) = t.prod (Î» (x : Î³), g x)
(X : AlgebraicGeometry.LocallyRingedSpace (r : â†¥(AlgebraicGeometry.LocallyRingedSpaceÎ“.obj (Opposite.op X))) : IsUnit (â‡‘(X.to_toÎ“_spec_Map_basicOpen r) r)
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {f : M â†’+ P} (x : M) : â‡‘(AddCon.kerLift f) â†‘x = â‡‘f x
{n : Type u_1} {p : Type u_2} {ð•œ : Type u_3} [Field ð•œ] [DecidableEq n] [DecidableEq p] [Fintype n] [Fintype p] (M : Matrix p p ð•œ) (e : p â‰ƒ n) (H : âˆƒ (L L' : List (Matrix.TransvectionStruct n ð•œ)) (D : n â†’ ð•œ), ((List.map Matrix.TransvectionStruct.toMatrix L).prod.mul (â‡‘(Matrix.reindexAlgEquiv ð•œ e) M)).mul (List.map Matrix.TransvectionStruct.toMatrix L').prod = Matrix.diagonal D) : âˆƒ (L L' : List (Matrix.TransvectionStruct p ð•œ)) (D : p â†’ ð•œ), ((List.map Matrix.TransvectionStruct.toMatrix L).prod.mul M).mul (List.map Matrix.TransvectionStruct.toMatrix L').prod = Matrix.diagonal D
{C : Type u} [CategoryTheory.Category C] {X Y : AlgebraicGeometry.PresheafedSpace C} (f : X âŸ¶ Y) [CategoryTheory.IsIso f.base] [CategoryTheory.IsIso f.c] : CategoryTheory.IsIso f
(f : StieltjesFunction) {a b : â„} {c d : â„• â†’ â„} (ss : Set.Icc a b âŠ† â‹ƒ (i : â„•), Set.Ioo (c i) (d i)) : Ennreal.ofReal (â‡‘f b - â‡‘f a) â‰¤ âˆ‘' (i : â„•), Ennreal.ofReal (â‡‘f (d i) - â‡‘f (c i))
(F : Type u_1) [Field F] [Fintype F] {a : F} (ha : a â‰  0) : âˆƒ (b : F), â‡‘(Algebra.trace (Zmod(ringChar F)) F) (a * b) â‰  0
{R : Type u} [orderedCommRing R] [starOrderedRing R] [Algebra â„ R] [OrderedSmul â„ R] (Aâ‚€ Aâ‚ Bâ‚€ Bâ‚ : R) (T : is_CHSH_tuple Aâ‚€ Aâ‚ Bâ‚€ Bâ‚) : Aâ‚€ * Bâ‚€ + Aâ‚€ * Bâ‚ + Aâ‚ * Bâ‚€ - Aâ‚ * Bâ‚ â‰¤ 2
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : IsIrreducible s â†” âˆ€ (U : Finset (Set Î±)), (âˆ€ (u : Set Î±), u âˆˆ U â†’ is_IsOpen u) â†’ (âˆ€ (u : Set Î±), u âˆˆ U â†’ (s âˆ© u).nonempty) â†’ (s âˆ© â‹‚â‚€ â†‘U).nonempty
{G : Type u} {x : G} [Fintype G] [Group G] [DecidableEq G] : Finset.image (Î» (i : â„•), x ^ i) (Finset.range (orderOf x)) = â†‘(Subgroup.zpowers x).to_Finset
{M : Type u_1} [AddZeroClass M] {s : Set M} {p : M â†’ Prop} {x : M} (h : x âˆˆ AddSubmonoid.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (H1 : p 0) (HMul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) : p x
{Î± : Type u_1} {f : Î± â†’ Î±} {x y : Î±} {n : â„•} (hx : Function.IsPeriodicPt f n x) (hy : Function.IsPeriodicPt f n y) (hn : 0 < n) (h : f x = f y) : x = y
(G : Type u_1) [CommGroup G] : comm_monoid.torsion G = (torsion G).to_Submonoid
(Î± : Type u_1) [completeLattice Î±] : CompleteLattice.IsSupClosedCompact Î± â†’ CompleteLattice.IsSupFiniteCompact Î±
{Î± : Type u} {Î² : Type v} [CommMonoid Î²] (s : Finset Î±) (f : Finset Î± â†’ Î²) : s.powerset.prod (Î» (t : Finset Î±), f t) = (Finset.range (s.card + 1)).prod (Î» (j : â„•), (Finset.powersetLen j s).prod (Î» (t : Finset Î±), f t))
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [DecidableEq Î±] (H : FreeGroup.Red (FreeGroup.reduce Lâ‚) Lâ‚‚) : FreeGroup.reduce Lâ‚ = Lâ‚‚
{Y : Type u_2} [topologicalSpace Y] [NormalSpace Y] {s : Set Y} (f : C(â†¥s, â„)) (hs : is_IsClosed s) : âˆƒ (g : C(Y, â„)), ContinuousMap.restrict s g = f
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [hasZero M] [AddCommMonoid N] (f : Î± â†’â‚€ M) (y : Î±) (g : Î± â†’ M â†’ N) (hyf : y âˆˆ f.support) : g y (â‡‘f y) + (Finsupp.erase y f).sum g = f.sum g
(cf cg : Nat.Partrec.Code) (a : â„•) : (cf.prec cg).eval (Nat.mkpair a 0) = cf.eval a
{Î± : Type u_2} {Î² : Type u_3} [nonAssocRing Î±] [nonAssocRing Î²] (f : Î± â†’+* Î²) (x : Î±) : â‡‘f (-x) = -â‡‘f x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type w} [CategoryTheory.Category J] (K : J â¥¤ C) (F : C â¥¤ D) [CategoryTheory.Limits.HasColimit (K â‹™ F)] [CategoryTheory.CreatesColimit K F] : CategoryTheory.Limits.HasColimit K
{a b : â„} : âˆ« (x : â„) in a..b, Real.sin x * Real.cos x = (Real.cos a ^ 2 - Real.cos b ^ 2) / 2
{ð•œ : Type u} [nondiscreteNormedField ð•œ] (f : localHomeomorph ð•œ ð•œ) {a f' : ð•œ} (ha : a âˆˆ f.to_local_equiv.target) (hF' : f' â‰  0) (htff' : HasStrictDerivAt â‡‘f f' (â‡‘(f.symm) a)) : HasStrictDerivAt â‡‘(f.symm) f'â»Â¹ a
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace F] [CompleteSpace E] (e : E â‰ƒâ‚—[ð•œ] F) (h : Continuous â‡‘e) : Continuous â‡‘(e.symm)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {f f' : â„ â†’ E} {C : â„} (hF : âˆ€ (x : â„), x âˆˆ Set.Icc 0 1 â†’ HasDerivWithinAt f (f' x) (Set.Icc 0 1) x) (bound : âˆ€ (x : â„), x âˆˆ Set.Ico 0 1 â†’ âˆ¥f' xâˆ¥ â‰¤ C) : âˆ¥f 1 - f 0âˆ¥ â‰¤ C
{n : â„•} [Fact (0 < n)] : Fintype.card (QuaternionGroup n) = 4 * n
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) : s âŠ† â†‘(affineSpan k s)
{n : WithTop â„•} {ð•‚ : Type u_6} [is_R_or_C ð•‚] {F' : Type u_8} [NormedGroup F'] [normedSpace ð•‚ F'] {f : ð•‚ â†’ F'} {f' : F'} {x : ð•‚} (hF : ContDiffAt ð•‚ n f x) (hF' : HasDerivAt f f' x) (hn : 1 â‰¤ n) : HasStrictDerivAt f f' x
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x y + o.oangle y z = o.oangle x z
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup V1] [Module k V1] [addTorsor V1 P1] [AddCommGroup V2] [Module k V2] [addTorsor V2 P2] (f : P1 â†’ P2) (Linear : V1 â†’â‚—[k] V2) (Add : âˆ€ (p : P1) (v : V1), f (v +áµ¥ p) = â‡‘Linear v +áµ¥ f p) : â‡‘{ToFun := f, Linear := Linear, Map_vadd' := Add} = f
{Î± : Type u} [pseudoEmetricSpace Î±] {x y : Î±} {s : Set Î±} (h : y âˆˆ s) : Emetric.infEdist x s â‰¤ HasEdist.edist x y
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {ð•œâ‚ƒ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [NormedGroup E] [NormedGroup F] [NormedGroup G] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [nondiscreteNormedField ð•œâ‚ƒ] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] [normedSpace ð•œâ‚ƒ G] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} {Ïƒâ‚‚â‚ƒ : ð•œâ‚‚ â†’+* ð•œâ‚ƒ} {Ïƒâ‚â‚ƒ : ð•œ â†’+* ð•œâ‚ƒ} [RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [RingHomIsometric Ïƒâ‚â‚‚] (f : F â†’â‚›â‚—áµ¢[Ïƒâ‚‚â‚ƒ] G) {g : E â†’sl[Ïƒâ‚â‚‚] F} : âˆ¥f.to_Continuous_Linear_map.comp gâˆ¥ = âˆ¥gâˆ¥
{p : â„•} [hp_Prime : Fact (Nat.Prime p)] (z : â„¤_[p]) : z - â†‘(â‡‘PadicInt.toZmod z) âˆˆ LocalRing.maximalIdeal â„¤_[p]
{R : Type u_2} {M : Type u_3} [AddCommGroup M] [Ring R] [Module R M] [htwo : Invertible 2] {B : BilinForm R M} (hBâ‚ : B â‰  0) (hBâ‚‚ : B.is_Symm) : âˆƒ (x : M), Â¬B.is_IsOrtho x x
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [FiniteDimensional ð•œ E] {n : â„•} (hn : FiniteDimensional.finrank ð•œ E = n) {Î¹ : Type u_4} [Fintype Î¹] [DecidableEq Î¹] {V : Î¹ â†’ Submodule ð•œ E} (hV : DirectSum.IsInternal V) (a : Fin n) : â‡‘(DirectSum.IsInternal.subordinateOrthonormalBasis hn hV) a âˆˆ V (DirectSum.IsInternal.subordinateOrthonormalBasisIndex hn hV a)
{Î± : Type u_1} [completeLattice Î±] [IsModularLattice Î±] [IsCompactlyGenerated Î±] [IsAtomistic Î±] : IsComplemented Î±
{Î± : Type u} {Î² : Type v} [emetricSpace Î±] [CompleteSpace Î±] [emetricSpace Î²] {f : Î± â†’ Î²} (hF : Isometry f) : ClosedEmbedding f
{C : Type u} [CategoryTheory.Category C] (B : C) : CategoryTheory.Limits.HasTerminal (CategoryTheory.Over B)
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’. Î² âŠ• Î±} (a : Î±) {b : Î²} (hb : Sum.inl b âˆˆ f a) : b âˆˆ f.fix a
(M : Type u_1) {Î± : Type u_6} [Monoid M] [mulAction M Î±] : HasScalar.smul 1 = Id
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] {X : C} (h : Â¬CategoryTheory.Limits.IsZero X) : Nontrivial (CategoryTheory.Subobject X)
{Î± : Type u} {Î² : Type v} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l Filter.atTop) : Filter.Tendsto (Î» (x : Î²), f x * g x) l Filter.atTop
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] (f : X â†’ Y) (h : âˆ€ (x : X), âˆƒ (e : localHomeomorph X Y), x âˆˆ e.to_local_equiv.source âˆ§ âˆ€ (x : X), x âˆˆ e.to_local_equiv.source â†’ f x = â‡‘e x) : IsLocallyHomeomorph f
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] (m : Ennreal â†’ Ennreal) (s : Set X) : â‡‘(MeasureTheory.Measure.mkMetric m) s = â¨† (r : Ennreal) (hr : 0 < r), â¨… (t : â„• â†’ Set X) (h : s âŠ† Set.Union t) (h' : âˆ€ (n : â„•), Emetric.diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (h : (t n).nonempty), m (Emetric.diam (t n))
{G : Type u_1} [CommMonoid G] (tG : monoid.is_torsion G) : comm_monoid.torsion G = âŠ¤
(X : Type u_2) [topologicalSpace X] [RegularSpace X] [TopologicalSpace.SecondCountableTopology X] : âˆƒ (f : X â†’ boundedContinuousFunction â„• â„), Embedding f
{T : Type uâ‚} [CategoryTheory.Category T] {X : T} {f g : CategoryTheory.Over X} (k : f âŸ¶ g) [hk : CategoryTheory.Epi k.left] : CategoryTheory.Epi k
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : 0 < r) : hb.oangle (r â€¢ x) y = hb.oangle x y
{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ z â‰¤ b) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (ub : â„¤), P ub âˆ§ âˆ€ (z : â„¤), P z â†’ z â‰¤ ub
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 0 R = 1
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : EqvGen.setoid (EqvGen.setoid r).rel = EqvGen.setoid r
{K : Type u} [Field K] (s : Subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : HasDist.dist p1 p3 * HasDist.dist p1 p3 = HasDist.dist p1 p2 * HasDist.dist p1 p2 + HasDist.dist p3 p2 * HasDist.dist p3 p2 - 2 * HasDist.dist p1 p2 * HasDist.dist p3 p2 * Real.cos (EuclideanGeometry.angle p1 p2 p3)
{Î± : Type u_2} {Î² : Type u_3} [DecidableEq Î²] [HasScalar Î± Î²] {u : Finset Î²} {s : Set Î±} {t : Set Î²} : â†‘u âŠ† s â€¢ t â†’ (âˆƒ (s' : Finset Î±) (t' : Finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' â€¢ t')
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : IsIrreducible s â†” âˆ€ (Z : Finset (Set Î±)), (âˆ€ (z : Set Î±), z âˆˆ Z â†’ is_IsClosed z) â†’ s âŠ† â‹ƒâ‚€â†‘Z â†’ (âˆƒ (z : Set Î±) (H : z âˆˆ Z), s âŠ† z)
{G : Type u_1} [DivInvMonoid G] (a b : G) : a / b = a * bâ»Â¹
{Î± : Type u_1} {s t : Multiset Î±} : s â‰¤ t â†’ s âŠ† t
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {f : Filter Î±} {a : Î±} [f.ne_IsBot] (h : f â‰¤ nhds a) : f.Liminf = a
{Î± : Type u} [topologicalSpace Î±] {f : â„ â†’ Î±} {c : â„} (hp : Function.Periodic f c) (hc : c â‰  0) (hF : Continuous f) : is_IsCompact (Set.Range f)
(R : Type u_1) [CommRing R] (m n : â„•) : Polynomial.Chebyshev.t R (m * n) = (Polynomial.Chebyshev.t R m).comp (Polynomial.Chebyshev.t R n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasTerminal C] : CategoryTheory.Limits.HasZeroObject C
{Î± : Type u} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] {n : â„•} (hn : 1 â‰¤ n) : Filter.Tendsto (Î» (x : Î±), x ^ -â†‘n) Filter.atTop (nhds 0)
{Î± : Type u_1} {n : Type u_3} {m : Type u_4} {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} : (Matrix.fromBlocks A B C D).is_Symm â†” A.is_Symm âˆ§ B.transpose = C âˆ§ C.transpose = B âˆ§ D.is_Symm
{F : Type u_3} [Field F] [Fintype F] (hF : ringChar F â‰  2) {a : F} (ha : a â‰  0) : a ^ (Fintype.card F / 2) = 1 âˆ¨ a ^ (Fintype.card F / 2) = -1
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_3} {v : Î¹ â†’ E} (hz : âˆ€ (i : Î¹), v i â‰  0) (ho : âˆ€ (i j : Î¹), i â‰  j â†’ HasInner.inner (v i) (v j) = 0) : LinearIndependent ð•œ v
{R : Type u_1} [MulZeroClass R] [nR : Nontrivial R] : Â¬IsLeftRegular 0
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (G : C â¥¤ D) [CategoryTheory.ReflectsIsomorphisms G] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.HasLimits D] [CategoryTheory.Limits.PreservesLimits G] {X : Top} (F : Top.Presheaf C X) : F.is_sheaf â†” Top.Presheaf.IsSheaf (F â‹™ G)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : f =o[l] g â†’ âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
{R : Type u} {S : Type u_1} [Ring R] [Ring S] [IsPrincipalIdealRing R] (f : R â†’+* S) (hF : Function.Surjective â‡‘f) : IsPrincipalIdealRing S
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.SplitMono f] [CategoryTheory.Epi f] : CategoryTheory.IsIso f
{G : Type u_10} [Group G] (a : G) : â‡‘(Equiv.symm (equiv.mul_Right a)) = Î» (x : G), x * aâ»Â¹
(Î± : Type u) [topologicalSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] [RegularSpace Î±] : NormalSpace Î±
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} {r : â„} (hr : 0 â‰¤ r) (H1 : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (y : Î±) (H : y âˆˆ t), HasDist.dist x y â‰¤ r)) (H2 : âˆ€ (x : Î±), x âˆˆ t â†’ (âˆƒ (y : Î±) (H : y âˆˆ s), HasDist.dist x y â‰¤ r)) : Metric.hausdorffDist s t â‰¤ r
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : Set P} (ho : EuclideanGeometry.OrthocentricSystem s) : âˆƒ (r : â„), âˆ€ (t : Affine.Triangle â„ P), Set.Range t.points âŠ† s â†’ Affine.Simplex.circumradius t = r
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhdsWithin a (Set.Iic a) â†” âˆƒ (l : Î±) (H : l âˆˆ Set.Iio a), Set.Ioc l a âŠ† s
{R : Type u} {L : Type v} [CommRing R] [LieRing L] [lieAlgebra R L] : Subsingleton (LieIdeal R â†¥âŠ¥)
{L : FirstOrder.Language} {M : Type w} [L.Structure M] {S : L.substructure M} {s : Set M} : â‡‘(FirstOrder.Language.Substructure.closure L) s â‰¤ S â†” s âŠ† â†‘S
{G : Type u_1} [CommGroup G] (K : Subgroup G) (g : Multiset G) : (âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.prod âˆˆ K
(G : Type u_1) [AddMonoid G] : Â¬Add_monoid.is_torsion G â†” âˆƒ (g : G), Â¬IsOfFinAddOrder g
{n : â„•} {Î± : Type u_1} [Preorder Î±] {f : Fin (n + 1) â†’ Î±} : Monotone f â†” âˆ€ (i : Fin n), f (â‡‘fin.cast_Succ i) â‰¤ f i.succ
{k : Type u_1} {V : Type u_2} [Ring k] [AddCommGroup V] [Module k V] {Î¹ : Type u_3} (s : Finset Î¹) {w : Î¹ â†’ k} {p : Î¹ â†’ V} (hw : s.sum w = 0) : â‡‘(s.weighted_vsub p) w = s.sum (Î» (i : Î¹), w i â€¢ p i)
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [Nontrivial k] (p : Î¹ â†’ P) (j : Î¹) (q : P) : q âˆˆ affineSpan k (Set.Range p) â†” âˆƒ (s : Finset Î¹) (w : Î¹ â†’ k), q = â‡‘(s.weighted_vsub_of_point p (p j)) w +áµ¥ p j
{Î± : Type u} [topologicalSpace Î±] {Z : Set Î±} (h : is_IsClopen Z) : (â‹ƒ (x : Î±) (H : x âˆˆ Z), ConnectedComponent x) = Z
{K : Type u_1} [Field K] [Invertible 2] {a b c : K} (ha : a â‰  0) (h : discrim a b c = 0) (x : K) : a * x * x + b * x + c = 0 â†” x = -b / (2 * a)
{F : Type v} [NormedGroup F] [normedSpace â„‚ F] {c : â„‚} {R C : â„} {f : â„‚ â†’ F} (hR : 0 < R) (hD : DiffContOnCl â„‚ f (Metric.Ball c R)) (hC : âˆ€ (z : â„‚), z âˆˆ Metric.Sphere c R â†’ âˆ¥f zâˆ¥ â‰¤ C) : âˆ¥deriv f câˆ¥ â‰¤ C / R
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) (i : Fin (n + 1)) : HasDist.dist s.circumcenter (s.points i) = s.circumradius
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (g : G) (p1 p2 : P) : g +áµ¥ p1 -áµ¥ p2 = g + (p1 -áµ¥ p2)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) (h : p 1 = â‡‘((Continuous_multilinear_Curry_Fin1 ð•œ E F).symm) â†‘i) (h0 : p 0 = 0) : p.comp (p.right_Inv i) = FormalMultilinearSeries.id ð•œ F
 : â‡‘LinearEquiv.det complex.conj_ae.to_linearEquiv = -1
(p q n : â„•) [Fact (Nat.Prime p)] (hq : q â‰  0) : padicValNat p (q ^ n) = n * padicValNat p q
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (B : Matrix n m Î±) [Invertible A] : A.mul ((â…Ÿ A).mul B) = B
{Î± : Type u} [Lattice Î±] [CommGroup Î±] (a : Î±) (h : 1 â‰¤ a) : aâº = a
{K : Type u_1} [linearOrderedField K] {v : K} [floorRing K] (terminates : (GeneralizedContinuedFraction.of v).terminates) : âˆ€á¶  (n : â„•) in Filter.atTop, v = (GeneralizedContinuedFraction.of v).convergents n
{G : Type u_10} [Group G] (a : G) : â‡‘(Equiv.symm (equiv.mul_Left a)) = Mul.mul aâ»Â¹
{B : Type u_3} {S : B} {M : Type u_1} [CommMonoid M] [SetLike B M] [submonoidClass B M] (m : Multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.prod âˆˆ S
{Î“â‚€ : Type u_1} [LinearOrderedCommGroupWithZero Î“â‚€] : (nhds 0).has_Basis (Î» (_x : Î“â‚€Ë£), True) (Î» (Î³â‚€ : Î“â‚€Ë£), {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
(x : â„‚) : HasStrictDerivAt Complex.sinh (Complex.cosh x) x
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f g : V â†’â‚—[K] V} : f.comp g = LinearMap.id â†” g.comp f = LinearMap.id
{n : â„•} (R : Type u_1) [CommRing R] [is_IsDomain R] : â‡‘(algebraMap (Polynomial R) (Ratfunc R)) (Polynomial.cyclotomic n R) = n.divisors_antidiagonal.prod (Î» (i : â„• Ã— â„•), â‡‘(algebraMap (Polynomial R) (Ratfunc R)) (Polynomial.x ^ i.snd - 1) ^ â‡‘Nat.ArithmeticFunction.moebius i.fst)
{C : Type u} [CategoryTheory.Category C] {P Q : C} (f : P âŸ¶ Q) [CategoryTheory.Epi f] [CategoryTheory.StrongMono f] : CategoryTheory.IsIso f
{P : Type u_1} [SemilatticeSup P] {x y : P} {s : Order.Ideal P} (hx : x âˆˆ s) (hy : y âˆˆ s) : x âŠ” y âˆˆ s
{Î± : Type u_1} [LinearOrder Î±] {r : Î±} {s : Finset Î±} : s.to_colex < {r}.to_colex â†” âˆ€ (x : Î±), x âˆˆ s â†’ x < r
{Î± : Type u_1} {Î² : Type u_2} {e : LocalEquiv Î± Î²} {s : Set Î±} {t : Set Î²} : e.source âˆ© â‡‘e â»Â¹' t = e.source âˆ© s â†’ e.is_image s t
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} : Metric.hausdorffDist s t = Metric.hausdorffDist t s
{C : Type u} [CategoryTheory.Category C] (X : C) : CategoryTheory.Presieve.IsSheaf (CategoryTheory.Sheaf.canonicalTopology C) (Category_theory.yoneda.obj X)
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [subtractionMonoid Î²] (f : Î± â†’+ Î²) (g h : Î±) : â‡‘f (g + -h) = â‡‘f g + -â‡‘f h
{G : Type u} [CategoryTheory.Groupoid G] [IsFreeGroupoid G] (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) [Quiver.Arborescence â†¥T] {a b : IsFreeGroupoid.Generators G} (e : a âŸ¶ b) (H : e âˆˆ Quiver.WideSubquiverSymmetrify T a b) : IsFreeGroupoid.SpanningTree.loopOfHom T (IsFreeGroupoid.of e) = ðŸ™ (root' T)
{Î± : Type u} {Î¹ : Type x} [pseudoMetricSpace Î±] [Fintype Î¹] {f : Î± â†’ Î¹ â†’ â„} {s : Set Î±} {K : Nnreal} (hF : LipschitzOnWith K f s) : âˆƒ (g : Î± â†’ Î¹ â†’ â„), LipschitzWith K g âˆ§ Set.EqOn f g s
(f : â†¥(MeasureTheory.lp â„‚ 2 haarCircle)) : âˆ‘' (i : â„¤), âˆ¥â‡‘(â‡‘(fourier_series.repr) f) iâˆ¥ ^ 2 = âˆ« (t : â†¥Circle), âˆ¥â‡‘f tâˆ¥ ^ 2 âˆ‚haarCircle
{M : Type u_1} [hasMul M] (c : Con M) : Con.mulKer Coe _ = c
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topologicalSpace Î±] [uniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} (h : TendstoLocallyUniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p) : Filter.Tendsto F p (nhds f)
{R : Type u_1} [normedRing R] [CompleteSpace R] (x : RË£) : (Î» (t : R), Ring.inverse (â†‘x + t)) =O[nhds 0] Î» (t : R), 1
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (v : M) {r : R} (h : 0 < r) : SameRay R (r â€¢ v) v
(C : Type uâ‚) [CategoryTheory.Category C] (D : Type uâ‚‚) [CategoryTheory.Category D] (X : C) (Y : D) : ðŸ™ (X, Y) = (ðŸ™ X, ðŸ™ Y)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_3} (l : Î¹ â†’â‚€ ð•œ) (v : Î¹ â†’ E) (x : E) : HasInner.inner (l.sum (Î» (i : Î¹) (a : ð•œ), a â€¢ v i)) x = l.sum (Î» (i : Î¹) (a : ð•œ), â‡‘(starRingEnd ð•œ) a â€¢ HasInner.inner (v i) x)
(n : â„•) : ringChar (Zmod n) = n
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {s : Set Î±} (hs : IsPreconnected s) : s âˆˆ {Set.Icc (HasInf.inf s) (HasSup.sup s), Set.Ico (HasInf.inf s) (HasSup.sup s), Set.Ioc (HasInf.inf s) (HasSup.sup s), Set.Ioo (HasInf.inf s) (HasSup.sup s), Set.Ici (HasInf.inf s), Set.Ioi (HasInf.inf s), Set.Iic (HasSup.sup s), Set.Iio (HasSup.sup s), Set.Univ, âˆ…}
{Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ Ennreal} (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) : (s.sum (Î» (a : Î±), f a)).to_Nnreal = s.sum (Î» (a : Î±), (f a).to_Nnreal)
{Î± : Type u_1} [topologicalSpace Î±] [BaireSpace Î±] {p : Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in residual Î±, p x) â†” âˆƒ (t : Set Î±), is_GÎ´ t âˆ§ Dense t âˆ§ âˆ€ (x : Î±), x âˆˆ t â†’ p x
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : â„•} {i j : Fin (n + 2)} (H : i â‰¤ j) : X.Î´ j.succ â‰« X.Î´ i = X.Î´ (â‡‘fin.cast_Succ i) â‰« X.Î´ j
{G : Type u_1} [Group G] (N H : Subgroup G) [N.normal] : â†‘(N âŠ” H) = â†‘N * â†‘H
{Î± : Type u} {Î² : Type v} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [denselyOrdered Î±] {f : Filter Î²} {u : Î² â†’ Î±} {s : Set Î±} (hs : Dense s) (H : âˆ€ (a : Î±), a âˆˆ s â†’ âˆ€ (b : Î±), b âˆˆ s â†’ a < b â†’ Â¬((âˆƒá¶  (n : Î²) in f, u n < a) âˆ§ âˆƒá¶  (n : Î²) in f, b < u n)) (h : Filter.IsBoundedUnder LE.le f u . "is_bounded_Default") (h' : Filter.IsBoundedUnder GE f u . "is_bounded_Default") : âˆƒ (c : Î±), Filter.Tendsto u f (nhds c)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} : StrictAntiOn f s â†’ StrictMonoOn (â‡‘OrderDual.toDual âˆ˜ f) s
{R : Type u_1} [Ring R] (s : Subring R) {Î¹ : Type u_2} {t : Finset Î¹} {f : Î¹ â†’ R} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.sum (Î» (i : Î¹), f i) âˆˆ s
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {m : measurableSpace Î±} [topologicalSpace Î²] [TopologicalSpace.PseudoMetrizableSpace Î²] [topologicalSpace Î³] [TopologicalSpace.PseudoMetrizableSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : Embedding g) : MeasureTheory.StronglyMeasurable (Î» (x : Î±), g (f x)) â†” MeasureTheory.StronglyMeasurable f
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] (x : K) : â‡‘(Algebra.norm K) (â‡‘(algebraMap K L) x) = x ^ FiniteDimensional.finrank K L
{n m : â„•} (h : Fin n = Fin m) : cast h = â‡‘(fin.cast _)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x y : E) : â‡‘is_R_or_C.im (HasInner.inner x y) = (âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ * âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ - âˆ¥x + is_R_or_C.I â€¢ yâˆ¥ * âˆ¥x + is_R_or_C.I â€¢ yâˆ¥) / 4
(n b : â„•) : (n + 1) / (b + 2) < n + 1
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} (connected_fibers : âˆ€ (t : Î²), IsConnected (f â»Â¹' {t})) (hcl : âˆ€ (T : Set Î²), is_IsClosed T â†” is_IsClosed (f â»Â¹' T)) (t : Î²) : IsConnected (f â»Â¹' ConnectedComponent t)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [CharZero k] {s : Finset Î¹} (p : Î¹ â†’ P) (h : s.card â‰  0) : Finset.centroid k s p âˆˆ affineSpan k (Set.Range p)
{R : Type u_1} {M : Type u_4} {S : Type u_7} [Semiring R] [AddCommMonoid M] [Module R M] (p : Submodule R M) [Semiring S] [HasScalar S R] [Module S M] [isScalarTower S R M] : Submodule.span S â†‘p = Submodule.restrictScalars S p
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {l : List L} : (âˆ€ (x : L), x âˆˆ l â†’ x âˆˆ S) â†’ l.sum âˆˆ S
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : InnerProductGeometry.angle (-x) (-y) = InnerProductGeometry.angle x y
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : CategoryTheory.Presieve X} : (CategoryTheory.Presieve.IsSeparatedFor P R âˆ§ âˆ€ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.compatible â†’ (âˆƒ (t : P.obj (Opposite.op X)), x.is_amalgamation t)) â†” CategoryTheory.Presieve.IsSheafFor P R
{Î² : Type u_2} [DecidableEq Î²] (s : Finset Î²) (b : Î²) : Finset.filter (Eq b) s = Ite (b âˆˆ s) {b} âˆ…
{G : Type u_1} [AddCommGroup G] (B : addGroupFilterBasis G) : UniformAddGroup G
{f g : â„ â†’ â„} {a b : â„} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hgc : ContinuousOn g (Set.Icc a b)) (hle : âˆ€ (x : â„), x âˆˆ Set.Ioc a b â†’ f x â‰¤ g x) (hlt : âˆƒ (c : â„) (H : c âˆˆ Set.Icc a b), f c < g c) : âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} (f g : c.quotient â†’* P) (h : âˆ€ (a : M), â‡‘f â†‘a = â‡‘g â†‘a) : f = g
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : â†‘s âˆ© â†‘(AffineSubspace.mk' p (s.direction)á—®) = {â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p)}
{Î± : Type u_1} {Î² : Type u_2} [emetricSpace Î±] [pseudoEmetricSpace Î²] {f : Î± â†’ Î²} (h : AntilipschitzWith 0 f) : Subsingleton Î±
{R : Type u_1} {a : R} [Semigroup R] (b : R) (ha : IsRightRegular a) : IsRightRegular (b * a) â†” IsRightRegular b
{Î± : Type u} [uniformSpace Î±] {s : Set Î±} {Î¹ : sort u_1} {c : Î¹ â†’ Set Î±} (hs : is_IsCompact s) (hcâ‚ : âˆ€ (i : Î¹), is_IsOpen (c i)) (hcâ‚‚ : s âŠ† â‹ƒ (i : Î¹), c i) : âˆƒ (n : Set (Î± Ã— Î±)) (H : n âˆˆ Uniformity Î±), âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (i : Î¹), {y : Î± | (x, y) âˆˆ n} âŠ† c i)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (Î¸ : Real.Angle) : hb.oangle x y = Î¸ â†” (x â‰  0 âˆ§ y â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(hb.rotation Î¸) x) âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
(n : â„•) [Fact (0 < n)] [Fintype (Zmod n)Ë£] : Fintype.card (Zmod n)Ë£ = n.totient
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] : FiniteDimensional K â†¥âŠ¥
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x y : E} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ ^ 2
{Î± : Type u_1} [GeneralizedBooleanAlgebra Î±] (u v : Î±) : Set.InjOn (Î» (x : Î±), (x âŠ” u)  v) {x : Î± | Disjoint u x âˆ§ v â‰¤ x}
{Î² : Type u_4} [LinearOrder Î²] [NoMaxOrder Î²] {u : â„• â†’ Î²} (hu : Filter.Tendsto u Filter.atTop Filter.atTop) (N : â„•) : âˆƒ (n : â„•) (H : n â‰¥ N), âˆ€ (k : â„•), k < n â†’ u k < u n
{R : Type u_1} [CommRing R] [Top : topologicalSpace R] [TopologicalRing R] {J : Ideal R} : IsAdic J â†” (âˆ€ (n : â„•), is_IsOpen â†‘(J ^ n)) âˆ§ âˆ€ (s : Set R), s âˆˆ nhds 0 â†’ (âˆƒ (n : â„•), â†‘(J ^ n) âŠ† s)
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] {dâ‚ dâ‚‚ : â„} (h : dâ‚ â‰¤ dâ‚‚) (s : Set X) : â‡‘(MeasureTheory.Measure.hausdorffMeasure dâ‚‚) s â‰¤ â‡‘(MeasureTheory.Measure.hausdorffMeasure dâ‚) s
{R : Type x} [NonUnitalNonAssocRing R] {a b : R} (h : Commute a b) : a * a - b * b = (a + b) * (a - b)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {xâ‚€ : E} (hF : HasFderivAt f f' xâ‚€) {C : â„} (hCâ‚€ : 0 â‰¤ C) (hlip : âˆ€á¶  (x : E) in nhds xâ‚€, âˆ¥f x - f xâ‚€âˆ¥ â‰¤ C * âˆ¥x - xâ‚€âˆ¥) : âˆ¥f'âˆ¥ â‰¤ C
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (iâ‚€ : Î¹) : vectorSpan k (Set.Range p) = Submodule.span k (Set.Range (Î» (i : {x // x â‰  iâ‚€}), p iâ‚€ -áµ¥ p â†‘i))
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x : V} (hx : x â‰  0) : o.oangle (-x) x = â†‘Real.pi
{G : Type u} [Group G] {N : Subgroup G} [N.normal] (hN : (Nat.card â†¥N).coprime N.index) : âˆƒ (H : Subgroup G), N.is_complement' H
 : fourier_subalgebra.to_Submodule = Submodule.span â„‚ (Set.Range fourier)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P (n + 2)) (iâ‚ iâ‚‚ : Fin (n + 3)) : s.monge_plane iâ‚ iâ‚‚ = s.monge_plane iâ‚‚ iâ‚
{Î± : Type u_1} [Preorder Î±] [PredOrder Î±] {a : Î±} : Â¬IsMin a â†’ Order.pred a < a
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (H : Subgroup G) (f : G â‰ƒ* N) : Subgroup.map f.to_MonoidHom H.normalizer = (Subgroup.map f.to_MonoidHom H).normalizer
{R : Type u_1} [CommRing R] {a b : R} : a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)
{Î± : Type u_1} [Preorder Î±] {a b : Î±} (h1 : a â‰¤ b) (h2 : b â‰¤ a) : a â©¿ b
{n : Type u_1} {ð•œ : Type u_3} [Field ð•œ] [DecidableEq n] [Fintype n] (P : Matrix n n ð•œ â†’ Prop) (M : Matrix n n ð•œ) (hdiag : âˆ€ (D : n â†’ ð•œ), (Matrix.diagonal D).det = M.det â†’ P (Matrix.diagonal D)) (htransvec : âˆ€ (t : Matrix.TransvectionStruct n ð•œ), P t.to_Matrix) (HMul : âˆ€ (A B : Matrix n n ð•œ), P A â†’ P B â†’ P (A.mul B)) : P M
{Î± : Type u_1} {Î² : Type u_2} [measurableSpace Î±] [topologicalSpace Î²] [TopologicalSpace.PseudoMetrizableSpace Î²] [measurableSpace Î²] [BorelSpace Î²] {Î¹ : Type u_3} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [u.ne_IsBot] [u.is_countably_generated] (hF : âˆ€ (i : Î¹), Measurable (f i)) (lim : Filter.Tendsto f u (nhds g)) : Measurable g
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} {s : Set Î±} (h : x âˆˆ s) : Emetric.infEdist x s = 0
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] : FiniteDimensional.finrank K V â‰¤ 1 â†” âˆƒ (v : V), âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w
{a : â„} {l : Filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhds a, DifferentiableAt â„ f x) (hg' : âˆ€á¶  (x : â„) in nhds a, deriv g x â‰  0) (hfa : Filter.Tendsto f (nhds a) (nhds 0)) (hga : Filter.Tendsto g (nhds a) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv f x / deriv g x) (nhds a) l) : Filter.Tendsto (Î» (x : â„), f x / g x) (nhdsWithin a (Set.Univ  {a})) l
{R : Type u_1} {M : Type u_3} [monoidWithZero R] [hasZero M] [mulActionWithZero R M] : IsSmulRegular M 0 â†” Subsingleton M
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} {P : Type uâ‚„} [AddCommGroup V] [addTorsor V P] [Ring k] [Module k V] (b : AffineBasis Î¹ k P) {Î¹' : Type u_1} [Fintype Î¹'] [Fintype Î¹] [DecidableEq Î¹'] (p : Î¹' â†’ P) {A : Matrix Î¹ Î¹' k} (hA : (b.to_Matrix p).mul A = 1) : AffineIndependent k p
{X : Type u} {Î± : Type v} [topologicalSpace X] [LinearOrder Î±] [topologicalSpace Î±] [OrderClosedTopology Î±] [PreconnectedSpace X] {c : Î±} {f : X â†’ Î±} (hF : Continuous f) (hâ‚ : âˆƒ (a : X), f a â‰¤ c) (hâ‚‚ : âˆƒ (b : X), c â‰¤ f b) : c âˆˆ Set.Range f
{Î± : Type u_1} [pseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±} (huâ‚‚ : âˆ€ (n : â„•), HasDist.dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) : CauchySeq f
{xl xr : Type u_1} {xL : xl â†’ Pgame} {xR : xr â†’ Pgame} {yl yr : Type u_1} {yL : yl â†’ Pgame} {yR : yr â†’ Pgame} : (Pgame.mk xl xr xL xR).lf (Pgame.mk yl yr yL yR) â†” (âˆƒ (i : yl), Pgame.mk xl xr xL xR â‰¤ yL i) âˆ¨ âˆƒ (j : xr), xR j â‰¤ Pgame.mk yl yr yL yR
{G : Type u} {x : G} [Monoid G] : 0 < orderOf x â†” IsOfFinOrder x
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {S T : ConvexCone ð•œ E} (h : â†‘S = â†‘T) : S = T
{Î± : Type u} (s : Set (Set Î±)) : Cardinal.mk â†¥{t : Set Î± | MeasurableSpace.GenerateMeasurable s t} â‰¤ Linear_order.max (Cardinal.mk â†¥s) 2 ^ Cardinal.aleph_0
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (p1 p2 p3 : P) : p1 -áµ¥ p3 - (p2 -áµ¥ p3) = p1 -áµ¥ p2
(p : â„•) [Fact (Nat.Prime p)] (a : â„¤) (ha : â†‘a â‰  0) : Zmod.legendreSym p a ^ 2 = 1
{R : Type u_4} {S : Type u_5} [NonAssocSemiring R] [NonAssocSemiring S] (f : R â‰ƒ+* S) : â†‘f.to_Equiv = â†‘f.to_Equiv
(S : Set â„•+) (K : Type w) [Field K] (C : Type z) [Fintype â†¥S] [CommRing C] [Algebra K C] [is_IsDomain C] [IsCyclotomicExtension S K C] : FiniteDimensional K C
{V : Type u_9} {K : Type u_10} [Field K] [AddCommGroup V] [Module K V] {n : Type w} {B : BilinForm K V} {v : n â†’ V} (hvâ‚ : B.is_Ortho v) (hvâ‚‚ : âˆ€ (i : n), Â¬B.is_IsOrtho (v i) (v i)) : LinearIndependent K v
{Î± : Type u} [Preorder Î±] {a b c : Î±} : b < c â†’ a â‰¤ b â†’ a < c
{R : Type u_1} [MulZeroClass R] (h : IsLeftRegular 0) : Subsingleton R
{R : Type u_1} {G : Type u_2} [CommGroup G] [CommRing R] [Nontrivial R] : Algebra.FiniteType R (MonoidAlgebra R G) â†” group.fg G
{Î± : Type u} [topologicalSpace Î±] [SigmaCompactSpace Î±] {f : Î± â†’ Set Î±} (hF : âˆ€ (x : Î±), f x âˆˆ nhds x) : âˆƒ (s : Set Î±), s.countable âˆ§ (â‹ƒ (x : Î±) (H : x âˆˆ s), f x) = Set.Univ
{A : Type u_1} [AddCommMonoid A] (a b c : A) : c âˆˆ AddSubmonoid.closure {a, b} â†” âˆƒ (m n : â„•), m â€¢ a + n â€¢ b = c
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] [Nontrivial R] {Î¹ : Type w} (b : Basis Î¹ R M) [Infinite Î¹] {Îº : Type w} (v : Îº â†’ M) (i : LinearIndependent R v) (m : i.maximal) : Cardinal.mk Î¹ â‰¤ Cardinal.mk Îº
{Î± : Type u_1} [CanonicallyOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b : Î±} (h : a â‰¤ b) : a - b = 0
(p : â„•) [Fact (Nat.Prime p)] : padicNorm p â†‘p < 1
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Sâ‚ Sâ‚‚ : Submodule K V} [FiniteDimensional K â†¥Sâ‚‚] (h : Sâ‚ â‰¤ Sâ‚‚) : FiniteDimensional K â†¥Sâ‚
{Î“â‚€ : Type u_3} [linearOrderedAddCommMonoidWithTop Î“â‚€] [Nontrivial Î“â‚€] {K : Type u_1} [divisionRing K] (v : addValuation K Î“â‚€) {x : K} : â‡‘v x = âŠ¤ â†” x = 0
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [Preorder Î²] [Preorder Î³] {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : Filter Î±} (hm : âˆ€ (bâ‚ bâ‚‚ : Î²), e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ (c : Î³), âˆƒ (b : Î²), e b â‰¤ c) : Filter.Tendsto (e âˆ˜ f) l Filter.atBot â†” Filter.Tendsto f l Filter.atBot
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {s : Finset Î±} : s âˆˆ ð’œ.up_shadow â†” âˆƒ (a : Î±) (H : a âˆˆ s), s.erase a âˆˆ ð’œ
{Î± : Type u_1} [CancelCommMonoidWithZero Î±] {a : Î±} {f : Multiset Î±} (ha : Irreducible a) (pfa : (âˆ€ (b : Î±), b âˆˆ f â†’ Prime b) âˆ§ Associated f.prod a) : âˆƒ (p : Î±), Associated a p âˆ§ f = {p}
{Î± : Type u} [pseudoEmetricSpace Î±] {Î´â‚ Î´â‚‚ : â„} (hle : Î´â‚ â‰¤ Î´â‚‚) (E : Set Î±) : Metric.Cthickening Î´â‚ E âŠ† Metric.Cthickening Î´â‚‚ E
{K : Type v} [Field K] {p : Polynomial K} : Polynomial.Splits (RingHom.id K) p â†” â‡‘Multiset.card p.roots = p.nat_degree
{R : Type u_1} [CommSemiring R] {n : Type u_4} [Fintype n] [DecidableEq n] : LinearMap.toMatrix (Pi.basisFun R n) (Pi.basisFun R n) = LinearMap.toMatrix'
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} : Mdifferentiable (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f â†’ Differentiable ð•œ f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {x : E} {s : Set E} {t : Set F} {y : F} (hs : UniqueDiffWithinAt ð•œ s x) (ht : UniqueDiffWithinAt ð•œ t y) : UniqueDiffWithinAt ð•œ (s Ã—Ë¢ t) (x, y)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (R : D â¥¤ C) [CategoryTheory.Reflective R] [CategoryTheory.Limits.HasColimitsOfShape J C] : CategoryTheory.Limits.HasColimitsOfShape J D
{M : Type u_1} [AddMonoid M] {N : Type u_2} [AddMonoid N] {f : M â†’ N} (hF : IsAddMonoidHom f) {s : Set N} (hs : IsAddSubmonoid s) : IsAddSubmonoid (f â»Â¹' s)
{Î± : Type u_1} [CanonicallyOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b c : Î±} [ContravariantClass Î± Î± Add.add LE.le] [ContravariantClass Î± Î± Add.add LT.lt] (hca : c â‰¤ a) (h : a - b < a - c) : c < b
{G : Type u_7} [AddGroup G] (L : List G) : -L.sum = (List.map (Î» (x : G), -x) L).reverse.sum
{Î± : Type u_1} [completeLattice Î±] {s : Set Î±} (hs : CompleteLattice.SetIndependent s) : s.pairwise_Disjoint Id
{R : Type u} [Ring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {M : Type u_1} [AddCommGroup M] [Module R M] (A : Î¹ â†’ Submodule R M) {i j : Î¹} (hij : i â‰  j) (h : Set.Univ = {i, j}) : DirectSum.IsInternal A â†” is_HasCompl (A i) (A j)
{Î± : Type u_1} [metricSpace Î±] {K : Nnreal} {f : Î± â†’ Î±} (hF : ContractingWith K f) (g : Î± â†’ Î±) {x y : Î±} (hx : Function.IsFixedPt f x) (hy : Function.IsFixedPt g y) {C : â„} (hfg : âˆ€ (z : Î±), HasDist.dist (f z) (g z) â‰¤ C) : HasDist.dist x y â‰¤ C / (1 - â†‘K)
(X : AlgebraicGeometry.LocallyRingedSpace : Continuous X.to_Î“_spec_fun
{G : Type u_10} {H : Type u_11} [AddGroup G] [subtractionMonoid H] (h : G â‰ƒ+ H) (x : G) : â‡‘h (-x) = -â‡‘h x
{M : Type u_1} {B : Type u_3} [Monoid M] [SetLike B M] [submonoidClass B M] {S : B} {l : List M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ S) : l.prod âˆˆ S
(G : Type u_1) [Monoid G] : Â¬monoid.is_torsion G â†” âˆƒ (g : G), Â¬IsOfFinOrder g
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : â‡‘(AffineMap.lineMap (f a) (f b)) r â‰¤ f (â‡‘(AffineMap.lineMap a b) r) â†” slope f (â‡‘(AffineMap.lineMap a b) r) b â‰¤ slope f a b
{M : Type u_1} [MulOneClass M] {c d : Con M} (h : c â‰¤ d) (x : c.quotient) : â‡‘(c.map d h) x = â‡‘(c.lift d.mk' _) x
{Î± : Type u} [uniformSpace Î±] [(Uniformity Î±).is_countably_generated] (U : â„• â†’ Set (Î± Ã— Î±)) (U_HasMem : âˆ€ (n : â„•), U n âˆˆ Uniformity Î±) (HU : âˆ€ (u : â„• â†’ Î±), (âˆ€ (N m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ (u m, u n) âˆˆ U N) â†’ (âˆƒ (a : Î±), Filter.Tendsto u Filter.atTop (nhds a))) : CompleteSpace Î±
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] [CategoryTheory.Limits.HasInitial C] : CategoryTheory.Limits.HasFiniteCoproducts C
{Î± : Type u} [PartialOrder Î±] {a b : Î±} : a â‰¤ b â†’ b â‰  a â†’ a < b
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [OrderedAddCommGroup Î²] [HasScalar ð•œ E] [Module ð•œ Î²] {s : Set E} {f : E â†’ Î²} : ConcaveOn ð•œ s f â†’ ConvexOn ð•œ s (-f)
(R : Type u) (M : Type v) (N : Type w) [CommRing R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [AddCommGroup N] [Module R N] [Module.Free R N] : Module.rank R (tensorProduct R M N) = (Module.rank R M).lift * (Module.rank R N).lift
{Î± : Type v} [LinearOrder Î±] [topologicalSpace Î±] [OrderClosedTopology Î±] {s : Set Î±} (hs : IsConnected s) {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) : Set.Icc a b âŠ† s
{ð•œ : Type u_1} {E : Type u_4} [semiNormedGroup E] [nondiscreteNormedField ð•œ] [normedSpace ð•œ E] : âˆ¥ContinuousLinearMap.id ð•œ Eâˆ¥ â‰¤ 1
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : f (â‡‘(AffineMap.lineMap a b) r) â‰¤ â‡‘(AffineMap.lineMap (f a) (f b)) r â†” slope f a b â‰¤ slope f (â‡‘(AffineMap.lineMap a b) r) b
{k : Type u_1} {M : Type u_2} [orderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] {a : M} {c : k} (hc : c < 0) : a < 0 â†’ 0 < c â€¢ a
{n a : â„•} (h : a < n + 1) : â†‘â†‘a = a
{R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) (r : R) (y : A) : x * â‡‘(algebraMap R A) r * y = x * y * â‡‘(algebraMap R A) r
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} [CategoryTheory.Limits.HasImages C] (f : X âŸ¶ Y) [CategoryTheory.Mono f] : CategoryTheory.Subobject.exists f = CategoryTheory.Subobject.map f
{a b : Ereal} (h : a â‰¤ -b) : b â‰¤ -a
{G : Type u_3} [AddGroup G] (P : AddSubgroup G) : P.fg â†” âˆƒ (S : Set G), AddSubgroup.closure S = P âˆ§ S.finite
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] : Algebra.IsAlgebraic R A â†” âŠ¤.is_algebraic
{Î± : Type u_1} [DecidableEq Î±] {s : Multiset Î±} : s.nodup â†’ s.dedup = s
{H : Type u_1} [topologicalSpace H] (G : StructureGroupoid H) [ClosedUnderRestriction G] : G.local_invariant_prop G G.is_local_structomorph_within_at
{X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X} {eâ‚ eâ‚‚ : X} (hâ‚ : EckmannHilton.IsUnital mâ‚ eâ‚) (hâ‚‚ : EckmannHilton.IsUnital mâ‚‚ eâ‚‚) (Distrib : âˆ€ (a b c d : X), mâ‚ (mâ‚‚ a b) (mâ‚‚ c d) = mâ‚‚ (mâ‚ a c) (mâ‚ b d)) : eâ‚ = eâ‚‚
(S : Set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ 0 â‰¤ x) : 0 â‰¤ HasSup.sup S
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {n : WithTop â„•} {p : E â†’ FormalMultilinearSeries ð•œ E F} (g : F â†’L[ð•œ] G) (hF : HasFtaylorSeriesUpToOn n f p s) : HasFtaylorSeriesUpToOn n (â‡‘g âˆ˜ f) (Î» (x : E) (k : â„•), g.comp_ContinuousMultilinearMap (p x k)) s
{Î± : Type u_1} [linearOrderedField Î±] [Archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : 1 < y) : âˆƒ (n : â„¤), x âˆˆ Set.Ico (y ^ n) (y ^ (n + 1))
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {Î± : E} {q : Polynomial F} (q_irred : Irreducible q) (q_aeval : â‡‘(Polynomial.aeval Î±) q = 0) (hÎ± : IsSolvableByRad F Î±) : IsSolvable q.gal
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] (e : localHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²} (h : s âŠ† e.to_local_equiv.target) : ContinuousOn f s â†” ContinuousOn (f âˆ˜ â‡‘e) (e.to_local_equiv.source âˆ© â‡‘e â»Â¹' s)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) : Disjoint K Ká—®
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {x : ð•œ} {f' : ð•œ â†’L[ð•œ] F} : HasFderivAt f f' x â†” HasDerivAt f (â‡‘f' 1) x
{L : FirstOrder.Language} {M : Type w} [L.Structure M] {s : Set M} {p : M â†’ Prop} {x : M} (h : x âˆˆ â‡‘(FirstOrder.Language.Substructure.closure L) s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (Hfun : âˆ€ {n : â„•} (f : L.functions n), FirstOrder.Language.ClosedUnder f (setOf p)) : p x
{B : Type u} [CategoryTheory.Bicategory B] {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c) : CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.leftUnitor f).hom g = (CategoryTheory.Bicategory.associator (ðŸ™ a) f g).hom â‰« (CategoryTheory.Bicategory.leftUnitor (f â‰« g)).hom
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (pâ‚ pâ‚‚ : Î¹ â†’ P) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.affine_combination pâ‚) w -áµ¥ â‡‘(s.affine_combination pâ‚‚) w
{Î± : Type u_1} [Preorder Î±] [PredOrder Î±] {a b : Î±} [NoMinOrder Î±] : Order.pred a â‰¤ Order.pred b â†’ a â‰¤ b
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : IsPreconnected s â†” âˆ€ (u v : Set Î±), is_IsClosed u â†’ is_IsClosed v â†’ s âŠ† u âˆª v â†’ s âˆ© (u âˆ© v) = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) (i : Fin n) (y : Î± i.succ) : fin.tail (Function.update q i.succ y) = Function.update (fin.tail q) i y
{C : Type u} [CategoryTheory.Category C] {X Y : AlgebraicGeometry.PresheafedSpace C} {f : X âŸ¶ Y} (H : AlgebraicGeometry.PresheafedSpace.IsOpenImmersion f) (U : TopologicalSpace.Opens â†¥Y) (hU : â†‘U âŠ† Set.Range â‡‘(f.base)) : f.c.app (Opposite.op U) â‰« H.inv_App ((TopologicalSpace.Opens.map f.base).obj U) = Y.presheaf.map (CategoryTheory.eqToHom _).op
{n : â„•} (p : Fin (n + 1)) (i : Fin n) : â‡‘(p.succ_above) i < p â†” â‡‘fin.cast_Succ i < p
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : hb.oangle x (-y) + hb.oangle y (-x) = 0
{Î± : Type u_3} [SemilatticeSup Î±] (a : Î±) : Filter.atTop = Filter.comap Coe Filter.atTop
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {c : â„} {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : asymptotics.is_O_with c l f (Î» (x : Î±), -g' x) â†’ asymptotics.is_O_with c l f g'
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [Fintype Î¹] (p : Î¹ â†’ P) {n : â„•} (hc : Fintype.card Î¹ = n + 1) : FiniteDimensional.finrank k â†¥(vectorSpan k (Set.Range p)) â‰¤ n
{n : â„•} {p : Fin n â†’ Prop} [DecidablePred p] : â†¥((fin.find p).is_Some) â†” âˆƒ (i : Fin n), p i
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) : â†‘(affineSpan k s) = SpanPoints k s
{k : Type uâ‚} {G : Type uâ‚‚} [CommSemiring k] [AddMonoid G] {A : Type uâ‚ƒ} [Semiring A] [Algebra k A] (F : AddMonoidAlgebra k G â†’â‚[k] A) (f : MonoidAlgebra k G) : â‡‘F f = Finsupp.sum f (Î» (a : G) (b : k), b â€¢ â‡‘F (Finsupp.single a 1))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {n : WithTop â„•} {f g : E â†’ ð•œ} (hF : ContDiff ð•œ n f) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Î» (x : E), f x * g x)
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {X : C} (S : CategoryTheory.Sieve X) : S â‰¤ Jâ‚.close S
(n : â„•) : (Finset.range n).sum (Î» (i : â„•), i) = n * (n - 1) / 2
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (f : E â†’sl[Ïƒâ‚â‚‚] F) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ M * âˆ¥xâˆ¥) : âˆ¥fâˆ¥ â‰¤ M
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {x : E} {n : WithTop â„•} {p : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n f p s) (hn : 1 â‰¤ n) (hx : s âˆˆ nhds x) : âˆ€á¶  (y : E) in nhds x, HasFderivAt f (â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (p y 1)) y
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} : a < -b â†’ b < -a
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [CommRing ð•œ] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G] [Module ð•œ E] [Module ð•œ F] [Module ð•œ G] [topologicalSpace E] [topologicalSpace F] [topologicalSpace G] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] [TopologicalAddGroup F] [HasContinuousConstSmul ð•œ F] [TopologicalAddGroup G] [HasContinuousConstSmul ð•œ G] (q : FormalMultilinearSeries ð•œ F G) (p : FormalMultilinearSeries ð•œ E F) (v : Fin 1 â†’ E) : â‡‘(q.comp p 1) v = â‡‘(q 1) (Î» (i : Fin 1), â‡‘(p 1) v)
{Î± : Type u_1} [topologicalSpace Î±] [nonAssocRing Î±] (h : TopologicalSemiring Î±) : TopologicalRing Î±
{Î± : Type u} [PartialOrder Î±] {a b : Î±} (h : a â‰¤ b) : a = b âˆ¨ a < b
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Mâ‚ : Type u_4} [topologicalSpace Mâ‚] [AddCommMonoid Mâ‚] {Mâ‚‚ : Type u_6} [topologicalSpace Mâ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚ Mâ‚] [Module Râ‚‚ Mâ‚‚] [t2_Space Mâ‚‚] {s : Set Mâ‚} {f g : Mâ‚ â†’sl[Ïƒâ‚â‚‚] Mâ‚‚} (h : Set.EqOn â‡‘f â‡‘g s) : Set.EqOn â‡‘f â‡‘g (Closure â†‘(Submodule.span Râ‚ s))
{fâ‚ fâ‚‚ : Circle_deg1_Lift} (hâ‚ : IsUnit fâ‚) (hâ‚‚ : IsUnit fâ‚‚) (h : fâ‚.translation_number = fâ‚‚.translation_number) : âˆƒ (F : Circle_deg1_Lift), Function.Semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
(Î± : Type u) [metricSpace Î±] [TopologicalSpace.SeparableSpace Î±] : Isometry (kuratowskiEmbedding Î±)
{ð•œ : Type u_1} {F : Type u_3} [is_R_or_C ð•œ] [AddCommGroup F] [Module ð•œ F] [c : InnerProductSpace.Core ð•œ F] {x y : F} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + HasInner.inner x y + HasInner.inner y x + HasInner.inner y y
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [metricSpace Î²] [hasZero Î²] {Î¹ : Type u_1} {F : Î¹ â†’ ZeroAtInftyContinuousMap Î± Î²} {f : ZeroAtInftyContinuousMap Î± Î²} {l : Filter Î¹} : Filter.Tendsto F l (nhds f) â†” TendstoUniformly (Î» (i : Î¹), â‡‘(F i)) â‡‘f l
{Î± : Type u_1} [measurableSpace Î±] : Function.Injective MeasureTheory.JordanDecomposition.toSignedMeasure
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {n : WithTop â„•} (e : F â‰ƒL[ð•œ] G) : ContDiffOn ð•œ n (â‡‘e âˆ˜ f) s â†” ContDiffOn ð•œ n f s
{M : Type u_1} [AddMonoid M] {s : Set M} {a : M} (hs : IsAddSubmonoid s) (h : a âˆˆ s) : Multiples a âŠ† s
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} [ProperSpace Î±] (hc : is_IsClosed s) (hb : Metric.Bounded s) : is_IsCompact s
{n : â„•} {Î± : Type u_1} (l : List Î±) (c : Composition n) {i : â„•} (hi : i < (l.split_wrt_Composition c).length) : (l.split_wrt_Composition c).nth_LE i hi = List.drop (c.size_Up_to i) (List.take (c.size_Up_to (i + 1)) l)
{s : â„‚} (hs : 0 < s.re) : MeasureTheory.IntegrableOn (Î» (x : â„), â†‘(Real.exp (-x)) * â†‘x ^ (s - 1)) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [orderedRing ð•œ] [AddCommGroup E] [AddCommGroup F] [Module ð•œ E] [Module ð•œ F] {a b : ð•œ} {x y : E} {f : E â†’áµƒ[ð•œ] F} (h : a + b = 1) : â‡‘f (a â€¢ x + b â€¢ y) = a â€¢ â‡‘f x + b â€¢ â‡‘f y
{M : Type u_1} [Monoid M] {s : Set M} {a : M} (h : a âˆˆ monoid.closure s) : âˆƒ (l : List M), (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) âˆ§ l.prod = a
{Î± : Type u} [Preorder Î±] {a b c : Î±} (hab : a < b) (hbc : b = c) : a < c
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} [Fintype Î¹] {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’ ð•œ) (i : Î¹) : HasInner.inner (v i) (finset.univ.sum (Î» (i : Î¹), l i â€¢ v i)) = l i
{Î± : Type u_1} [CommMonoid Î±] [DecidableRel Dvd.dvd] {a b : Î±} : a âˆ£ b â†’ 0 < multiplicity a b
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r r' : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) (hr : r' < r) : âˆƒ (C : â„), âˆ€ (y : E), y âˆˆ Emetric.Ball x r' â†’ âˆ€ (z : E), z âˆˆ Emetric.Ball x r' â†’ âˆ¥f y - f z - â‡‘(p 1) (Î» (_x : Fin 1), y - z)âˆ¥ â‰¤ C * Linear_order.max âˆ¥y - xâˆ¥ âˆ¥z - xâˆ¥ * âˆ¥y - zâˆ¥
{Î± : Type u_1} [topologicalSpace Î±] {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] [HasContinuousAdd Î³] {f g : Î± â†’ Î³} (hF : UpperSemicontinuous f) (hg : UpperSemicontinuous g) : UpperSemicontinuous (Î» (z : Î±), f z + g z)
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {g : Î² â†’ Î±} (hg : Function.Injective g) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ Set.Range g), f i)) = finprod (Î» (j : Î²), f (g j))
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {Î¹ : Type u_1} {s : Set Î¹} (b : Basis â†¥s R M) (h : Module.rank R M < Cardinal.aleph_0) : s.finite
{p : Real.Angle â†’ Prop} (Î¸ : Real.Angle) (h : âˆ€ (x : â„), p â†‘x) : p Î¸
{Î± : Type u_1} {Î¹ : sort u_3} [conditionallyCompleteLattice Î±] {f : Î¹ â†’ Î±} (H : BddBelow (Set.Range f)) (c : Î¹) : infi f â‰¤ f c
{A : Type u_1} [CommRing A] [Algebra â„š A] : PowerSeries.exp A * â‡‘PowerSeries.evalNegHom (PowerSeries.exp A) = 1
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [divisionRing K] {m : â„•} : m â‰¤ n â†’ g.continuants_aux m = (g.squash_gcf n).continuants_aux m
{n : â„•} {p : Fin n â†’ Prop} [DecidablePred p] {i : Fin n} (hi : i âˆˆ fin.find p) {j : Fin n} (hj : j < i) : Â¬p j
{Î¹a : Type u_7} {Î¹b : Type u_8} [DecidableEq Î¹a] [DecidableEq Î¹b] [Fintype Î¹a] [Fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [CommSemiring R'] [AddCommGroup Nâ‚] [Module R' Nâ‚] [AddCommGroup Nâ‚‚] [Module R' Nâ‚‚] [AddCommMonoid Máµ¢] [Module R' Máµ¢] (a : MultilinearMap R' (Î» (_x : Î¹a), Máµ¢) Nâ‚) (b : MultilinearMap R' (Î» (_x : Î¹b), Máµ¢) Nâ‚‚) : â†‘(â‡‘MultilinearMap.alternatization a).dom_Coprod â†‘(â‡‘MultilinearMap.alternatization b) = finset.univ.sum (Î» (Ïƒa : Equiv.perm Î¹a), finset.univ.sum (Î» (Ïƒb : Equiv.perm Î¹b), â‡‘equiv.perm.sign Ïƒa â€¢ â‡‘equiv.perm.sign Ïƒb â€¢ (MultilinearMap.domDomCongr Ïƒa a).dom_Coprod (MultilinearMap.domDomCongr Ïƒb b)))
{Î± : Type u} {lâ‚ lâ‚‚ : List Î±} (i : â„•) : List.take (lâ‚.length + i) (lâ‚ ++ lâ‚‚) = lâ‚ ++ List.take i lâ‚‚
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} [CategoryTheory.Limits.HasCoequalizer f g] [CategoryTheory.Mono (CategoryTheory.Limits.coequalizerÏ€ f g)] : f = g
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.EnoughProjectives C] [CategoryTheory.Abelian C] {X Y : C} (f : X âŸ¶ Y) : CategoryTheory.Exact (CategoryTheory.Projective.d f) f
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b c : Î±} : a + b â‰¤ c â†’ a â‰¤ c - b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {p : E Ã— F} : ContDiffAt ð•œ n Prod.snd p
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Î± : Type u} [CommSemiring Î±] (x y : Î±) (n : â„•) : (Finset.range n).sum (Î» (i : â„•), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
{Î± : Type u_2} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {m n : â„•} (hð’œ : IsAntichain HasSubset.Subset â†‘ð’œ) : Disjoint (ð’œ.slice m) (Finset.falling n ð’œ).shadow
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {t : Affine.Triangle â„ P} (ho : t.orthocenter âˆ‰ Set.Range t.points) {p : Fin 3 â†’ P} (hps : Set.Range p âŠ† HasInsert.insert t.orthocenter (Set.Range t.points)) (hpi : Function.Injective p) : âˆƒ (c : P) (H : c âˆˆ affineSpan â„ (Set.Range t.points)), âˆ€ (pâ‚ : P), pâ‚ âˆˆ Set.Range p â†’ HasDist.dist pâ‚ c = Affine.Simplex.circumradius t
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) : 1 âˆˆ s
(n p : â„•) : Polynomial.eval â†‘n (Polynomial.bernoulli p.succ) = bernoulli p.succ + (â†‘p + 1) * (Finset.range n).sum (Î» (k : â„•), â†‘k ^ p)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {v : E} (hv : v âˆˆ Ká—®) : â‡‘(orthogonalProjection K) v = 0
(R : Type u_1) [CommRing R] (n : â„•) : (Finset.range (n + 1)).sum (Î» (Î½ : â„•), (n â€¢ Polynomial.x - â†‘Î½) ^ 2 * bernsteinPolynomial R n Î½) = n â€¢ Polynomial.x * (1 - Polynomial.x)
{R : Type u} [euclideanDomain R] [DecidableEq R] (a b : R) : EuclideanDomain.gcd a b = a * EuclideanDomain.gcd_a a b + b * EuclideanDomain.gcd_b a b
{Î± : Type u} [hasMul Î±] : IsMulHom Id
{p x : â„} {r : â„š} (h : LiouvilleWith p x) (hr : r â‰  0) : LiouvilleWith p (x * â†‘r)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (E : D â¥¤ C) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasLimitsOfSize C] : CategoryTheory.Limits.HasLimitsOfSize D
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [Fintype Î¹] (p : Î¹ â†’ P) {n : â„•} (hc : Fintype.card Î¹ = n + 2) : FiniteDimensional.finrank k â†¥(vectorSpan k (Set.Range p)) â‰¤ n â†” Â¬AffineIndependent k p
{Î± : Type u_1} [pseudoEmetricSpace Î±] {f : â„• â†’ Î±} (d : â„• â†’ Nnreal) (hF : âˆ€ (n : â„•), HasEdist.edist (f n) (f n.succ) â‰¤ â†‘(d n)) (hD : Summable d) : CauchySeq f
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : â„•} {i : Fin (n + 2)} : X.Î´ (â‡‘fin.cast_Succ i) â‰« X.Î´ i = X.Î´ i.succ â‰« X.Î´ i
{Î± : Type u} [Semiring Î±] : IsSemiringHom Id
{Î¹ : sort u_1} {f : Î¹ â†’ Ennreal} {x : Ennreal} (h0 : x â‰  0) (h : x â‰  âŠ¤) : infi f * x = â¨… (i : Î¹), f i * x
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set â„} [Interval_integral.FTC_Filter a (nhdsWithin a s) (nhdsWithin a t)] (hmeas : StronglyMeasurableAtFilter f (nhdsWithin a t) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhdsWithin a t âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) (hs : UniqueDiffWithinAt â„ s a . "UniqueDiffWithinAt_ici_Iic_Univ") : derivWithin (Î» (u : â„), âˆ« (x : â„) in u..b, f x) s a = -c
{k : Type uâ‚} {G : Type uâ‚‚} [CommSemiring k] [Monoid G] {A : Type uâ‚ƒ} [Semiring A] [Algebra k A] (F : MonoidAlgebra k G â†’â‚[k] A) (f : MonoidAlgebra k G) : â‡‘F f = Finsupp.sum f (Î» (a : G) (b : k), b â€¢ â‡‘F (Finsupp.single a 1))
{Î± : Type u_1} [CommSemiring Î±] : fib_rec.is_solution (Î» (x : â„•), â†‘(Nat.fib x))
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasImages V] [CategoryTheory.Limits.HasZeroObject V] [CategoryTheory.Preadditive V] [CategoryTheory.Limits.HasKernels V] [CategoryTheory.Limits.HasCokernels V] {Aâ‚ Bâ‚ Câ‚ Aâ‚‚ Bâ‚‚ Câ‚‚ : V} (fâ‚ : Aâ‚ âŸ¶ Bâ‚) (gâ‚ : Bâ‚ âŸ¶ Câ‚) (fâ‚‚ : Aâ‚‚ âŸ¶ Bâ‚‚) (gâ‚‚ : Bâ‚‚ âŸ¶ Câ‚‚) (Î± : Aâ‚ â‰… Aâ‚‚) (Î² : Bâ‚ â‰… Bâ‚‚) (Î³ : Câ‚ â‰… Câ‚‚) (hsqâ‚ : Î±.hom â‰« fâ‚‚ = fâ‚ â‰« Î².hom) (hsqâ‚‚ : Î².hom â‰« gâ‚‚ = gâ‚ â‰« Î³.hom) (h : CategoryTheory.Exact fâ‚ gâ‚) : CategoryTheory.Exact fâ‚‚ gâ‚‚
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] : Module.IsTorsion R â†¥(Submodule.torsion R M)
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] {s : Set Î±} (hs : is_IsCompact s) {t : Set Î²} (ht : is_IsCompact t) {n : Set (Î± Ã— Î²)} (hn : is_IsOpen n) (hp : s Ã—Ë¢ t âŠ† n) : âˆƒ (u : Set Î±) (v : Set Î²), is_IsOpen u âˆ§ is_IsOpen v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ u Ã—Ë¢ v âŠ† n
{Î± : Type u_1} [LinearOrder Î±] [succOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ Set.Ico n m â†’ r i (Order.succ i)) (h2 : âˆ€ (i : Î±), i âˆˆ Set.Ico m n â†’ r (Order.succ i) i) (hnm : n â‰  m) : Relation.TransGen r n m
(b c : â„) (n : â„•) (hb : 0 â‰  b) : Filter.Tendsto (Î» (x : â„), x ^ n / (b * Real.exp x + c)) Filter.atTop (nhds 0)
{Î± : Type u_1} {Î² : Type u_2} [Fintype Î±] [Fintype Î²] (h : Fintype.card Î² < Fintype.card Î±) : isEmpty (Î± â†ª Î²)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) [Nontrivial B] : minpoly A x â‰  1
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semiNormedGroup E'] [semiNormedGroup F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : ((Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f' =o[l] g'
{R : Type u} {M : Type v} {Mâ‚‚ : Type w} {Mâ‚ƒ : Type y} [Ring R] [AddCommGroup M] [AddCommGroup Mâ‚‚] [AddCommGroup Mâ‚ƒ] [Module R M] [Module R Mâ‚‚] [Module R Mâ‚ƒ] {f : M â†’â‚—[R] Mâ‚‚} {g : M â†’â‚—[R] Mâ‚ƒ} (h : f.ker âŠ” g.ker = âŠ¤) : (f.prod g).range = f.range.prod g.range
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set â„} [Interval_integral.FTC_Filter a (nhdsWithin a s) (nhdsWithin a t)] (hmeas : StronglyMeasurableAtFilter f (nhdsWithin a t) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhdsWithin a t âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasDerivWithinAt (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) s a
{ð•‚ : Type u_6} [is_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [normedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [normedSpace ð•‚ F'] [CompleteSpace E'] {f : E' â†’ F'} {f' : E' â‰ƒL[ð•‚] F'} {a : E'} {n : WithTop â„•} (hF : ContDiffAt ð•‚ n f a) (hF' : HasFderivAt f â†‘f' a) (hn : 1 â‰¤ n) : ContDiffAt ð•‚ n (hf.local_Inverse hF' hn) (f a)
{Î² : Type u_2} [topologicalSpace Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hF : Function.Surjective f) : DenseRange f
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Abelian C] [CategoryTheory.HasInjectiveResolutions C] [CategoryTheory.Abelian D] (F : C â¥¤ D) [F.additive] (n : â„•) {X Y : C} (f : Y âŸ¶ X) {P : CategoryTheory.injectiveResolution X} {Q : CategoryTheory.injectiveResolution Y} (g : Q.cocomplex âŸ¶ P.cocomplex) (w : Q.Î¹ â‰« g = (cochain_complex.singleâ‚€ C).map f â‰« P.Î¹) : (F.right_derived n).map f = (F.right_derived_obj_iso n Q).hom â‰« (homologyFunctor D (ComplexShape.up â„•) n).map ((F.map_HomologicalComplex (ComplexShape.up â„•)).map g) â‰« (F.right_derived_obj_iso n P).inv
{R : Type u_1} [Ring R] [StrongRankCondition R] (n : â„•) {m : â„•} (v : Fin m â†’ Fin n â†’ R) : LinearIndependent R v â†’ m â‰¤ n
{Î± : Type u_1} [AddCommGroup Î±] [topologicalSpace Î±] [TopologicalAddGroup Î±] [t2_Space Î±] (f : â„• â†’ Î±) : Filter.Tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) Filter.atTop (nhds 0)
{Î± : Type u_1} [topologicalSpace Î±] {x : Î±} {s : Set Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] {f g : Î± â†’ Î³} (hF : UpperSemicontinuousWithinAt f s x) (hg : UpperSemicontinuousWithinAt g s x) (hcont : ContinuousAt (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : UpperSemicontinuousWithinAt (Î» (z : Î±), f z + g z) s x
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] {n : â„•} (H : âˆ€ (s : Finset A), AlgebraicIndependent R (Î» (i : â†¥s), â†‘i) â†’ s.card â‰¤ n) (s : Set A) : AlgebraicIndependent R Coe â†’ Cardinal.mk â†¥s â‰¤ â†‘n
{Î± : Type u} [uniformSpace Î±] [(Uniformity Î±).is_countably_generated] (H' : âˆ€ (u : â„• â†’ Î±), CauchySeq u â†’ (âˆƒ (a : Î±), Filter.Tendsto u Filter.atTop (nhds a))) : CompleteSpace Î±
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : â‡‘(EuclideanGeometry.reflection s) (â‡‘(EuclideanGeometry.reflection s) p) = p
(n : â„•) : â†‘(n.succ) â€¢ Polynomial.bernoulli n = â‡‘(Polynomial.monomial n) â†‘(n.succ) - (Finset.range n).sum (Î» (k : â„•), â†‘((n + 1).choose k) â€¢ Polynomial.bernoulli k)
{R : Type u_1} {M : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup M] [Module R M] [NoZeroDivisors R] {B : M â†’â‚—[R] M â†’â‚—[R] R} (v : Basis n R M) (hO : B.is_Ortho â‡‘v) (h : âˆ€ (i : n), Â¬B.is_IsOrtho (â‡‘v i) (â‡‘v i)) : B.separating_Left
(R : Type u) [Ring R] [StrongRankCondition R] (m n : Type v) [Fintype m] [Fintype n] : Module.rank R (Matrix m n R) = (Cardinal.mk m * Cardinal.mk n).lift
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
{M : Type u_1} [Semigroup M] [topologicalSpace M] [t2_Space M] (Continuous_mulLeft : âˆ€ (r : M), Continuous (Î» (_x : M), _x * r)) (s : Set M) (snemp : s.nonempty) (s_IsCompact : is_IsCompact s) (s_Add : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ x * y âˆˆ s) : âˆƒ (m : M) (H : m âˆˆ s), m * m = m
{R : Type u_1} [linearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [FiniteDimensional R M] (x : Orientation R M Î¹) (f : M â‰ƒâ‚—[R] M) (h : Fintype.card Î¹ = FiniteDimensional.finrank R M) : â‡‘(Orientation.map Î¹ f) x = -x â†” â‡‘LinearMap.det â†‘f < 0
{Î± : Type u_1} [NonUnitalSemiNormedRing Î±] (x y : Î±) : âˆ¥â‡‘(AddMonoidHom.mulLeft x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{Î± : Type u_1} [LinearOrder Î±] {r s : Î±} : {r}.to_colex < {s}.to_colex â†” r < s
{X : Top} (F : Top.Presheaf (CategoryTheory.Discrete Punit) X) : F.is_sheaf
{Î± : Type u} [topologicalSpace Î±] {s t : Set Î±} (ht : is_IsCompact t) (hs : is_IsClosed s) : is_IsCompact (s âˆ© t)
{n : â„•} [Fact (0 < n)] : Fintype.card (DihedralGroup n) = 2 * n
{Î± : Type u} [topologicalSpace Î±] [LocallyCompactSpace Î±] {K : Set Î±} (hK : is_IsCompact K) : âˆƒ (K' : Set Î±), is_IsCompact K' âˆ§ K âŠ† Interior K'
{Î± : Type u_1} {G : Type u_4} [divisionCommMonoid G] {f g : Î± â†’ G} (hF : (Function.MulSupport f).finite) (hg : (Function.MulSupport g).finite) : finprod (Î» (i : Î±), f i / g i) = finprod (Î» (i : Î±), f i) / finprod (Î» (i : Î±), g i)
{Î² : Type u} {Î± : Type v} {s : Finset Î±} [AddCommMonoid Î²] (f : Î± â†’ Î²) {p : Î± â†’ Prop} [DecidablePred p] : (Finset.subtype p s).sum (Î» (x : Subtype_ p), f â†‘x) = (Finset.filter p s).sum (Î» (x : Î±), f x)
{Î± : Type u_3} {Î² : Type u_4} [SemilatticeSup Î±] [SemilatticeSup Î²] {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b' : Î²) (hF : Monotone f) (gc : âˆ€ (a : Î±) (b : Î²), b â‰¥ b' â†’ (f a â‰¤ b â†” a â‰¤ g b)) (hgi : âˆ€ (b : Î²), b â‰¥ b' â†’ b â‰¤ f (g b)) : Filter.map f Filter.atTop = Filter.atTop
{Î± : Type u} [linearOrderedRing Î±] (a b c : Î±) : 0 â‰¤ a * b âˆ¨ 0 â‰¤ b * c âˆ¨ 0 â‰¤ c * a
{R : Type u_1} {S : Type u_2} (L : Type u_4) [euclideanDomain R] [CommRing S] [is_IsDomain S] [Field L] [algRL : Algebra R L] [Algebra R S] [Algebra S L] [ist : isScalarTower R S L] [Iic : IsIntegralClosure S R L] {abv : AbsoluteValue R â„¤} {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] (bS : Basis Î¹ R S) (adm : abv.is_Admissible) [Infinite R] [DecidableEq R] (h : Algebra.IsAlgebraic R L) (a : S) {b : S} (hb : b â‰  0) : âˆƒ (q : S) (r : R) (H : r âˆˆ ClassGroup.finsetApprox bS adm), â‡‘abv (â‡‘(Algebra.norm R) (r â€¢ a - q * b)) < â‡‘abv (â‡‘(Algebra.norm R) b)
{Î³ : Type w} [SemilatticeSup Î³] {s t : Set Î³} : BddAbove s â†’ BddAbove t â†’ BddAbove (s âˆª t)
{Î³ : Type w} [SemilatticeInf Î³] {s t : Set Î³} : BddBelow (s âˆª t) â†” BddBelow s âˆ§ BddBelow t
{T : Type u} [CategoryTheory.Category T] {X Y : T} (i : X â‰… Y) (p : CategoryTheory.Arrow T) (sq : CategoryTheory.Arrow.mk i.hom âŸ¶ p) : i.inv â‰« sq.left â‰« p.hom = sq.right
{Î± : Type u} [monoidWithZero Î±] (x : Î±) [Invertible x] : Ring.inverse x = â…Ÿ x
(n : â„•+) (A : Type w) (B : Type z) [CommRing A] [CommRing B] [Algebra A B] [IsCyclotomicExtension {n} A B] [is_IsDomain B] [NeZero â†‘â†‘n] : IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) â†‘n
{Î± : Type u_1} [topologicalSpace Î±] {x : Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] {f g : Î± â†’ Î³} (hF : LowerSemicontinuousAt f x) (hg : LowerSemicontinuousAt g x) (hcont : ContinuousAt (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : LowerSemicontinuousAt (Î» (z : Î±), f z + g z) x
(R : Type u) [Ring R] [StrongRankCondition R] {Î¹ : Type v} [Fintype Î¹] : FiniteDimensional.finrank R (Î¹ â†’ R) = Fintype.card Î¹
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {n : â„•} (hn : s.card < t.card * n) : âˆƒ (y : Î²) (H : y âˆˆ t), (Finset.filter (Î» (x : Î±), f x = y) s).card < n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasLimits C
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (pâ‚‚ : Î¹ â†’ P) (pâ‚ : P) (h : s.sum (Î» (i : Î¹), w i) = 0) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = -â‡‘(s.weighted_vsub pâ‚‚) w
(M : Type u_1) (Î± : Type u_2) [Group M] [mulAction M Î±] {s t : Set Î±} : fixingSubgroup M (s âˆª t) = fixingSubgroup M s âŠ“ fixingSubgroup M t
(C : Type u) [CategoryTheory.Category C] [âˆ€ {X Y : C}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)] : CategoryTheory.Limits.HasBinaryProducts C
{X : Type u_1} [tX : topologicalSpace X] {s t : Set X} (ts : t âŠ† s) : Subtype.topologicalSpace = TopologicalSpace.induced (Set.inclusion ts) Subtype.topologicalSpace
{p : â„•} (q : â„š) : padicValRat p (-q) = padicValRat p q
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {s1 s2 : AffineSubspace k P} (h1 : â†‘s1.nonempty) (h2 : â†‘s2.nonempty) (hD : is_HasCompl s1.direction s2.direction) : âˆƒ (p : P), â†‘s1 âˆ© â†‘s2 = {p}
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [orderedRing ð•œ] [AddCommGroup E] [AddCommGroup F] [Module ð•œ E] [Module ð•œ F] {x : E} (f : E â†’áµƒ[ð•œ] F) {s : Set F} (hs : StarConvex ð•œ (â‡‘f x) s) : StarConvex ð•œ x (â‡‘f â»Â¹' s)
{f : â„• â†’ â„} (hfa : Antitone f) (hF0 : Filter.Tendsto f Filter.atTop (nhds 0)) : âˆƒ (l : â„), Filter.Tendsto (Î» (n : â„•), (Finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i)) Filter.atTop (nhds l)
{Î¹ : Type u} {Î³ : Type w} [dec : DecidableEq Î¹] (p : Î¹ â†’ Prop) [DecidablePred p] [AddCommMonoid Î³] (S : Î¹ â†’ addSubmonoid Î³) : (â¨† (i : Î¹) (h : p i), S i) = ((Dfinsupp.sumAddHom (Î» (i : Î¹), (S i).subtype)).comp (Dfinsupp.filterAddMonoidHom (Î» (i : Î¹), â†¥(S i)) p)).mrange
{Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ Â¬p x) : Finset.filter p s = âˆ…
{a b : â„•} (w : a âˆ£ b) (h : b < a) : b = 0
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] : (GeneralizedContinuedFraction.of v).denominators n â‰¤ (GeneralizedContinuedFraction.of v).denominators (n + 1)
{S : Type u_1} [hasAdd S] {a b : S} (h : AddCommute a b) : a + b = b + a
{p : Ennreal} [Fact (1 â‰¤ p)] (hp : p â‰  âŠ¤) : (Submodule.span â„‚ (Set.Range (fourierLp p))).topological_Closure = âŠ¤
{Î± : Type u_1} [HasLe Î±] {s : Set Î±áµ’áµˆ} : IsLowerSet s â†’ IsUpperSet (â‡‘OrderDual.toDual â»Â¹' s)
{Î± : Type u} {Î³ : Type u_1} [topologicalSpace Î³] [t2_Space Î³] [CompactSpace Î³] {f : Î± â†’ Î³} {b : Ultrafilter Î±} {c : Î³} : Ultrafilter.extend f b = c â†” â†‘(Ultrafilter.map f b) â‰¤ nhds c
{n : â„•} (hpos : 0 < n) {p : â„•} [Fact (Nat.Prime p)] {a : â„•} (hroot : (Polynomial.cyclotomic n (Zmod p)).is_root (â‡‘(Nat.castRingHom (Zmod p)) a)) : orderOf (Zmod.unitOfCoprime a _) âˆ£ n
 : fib_rec.is_solution (Pow.pow goldenRatio)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {y : E} {Î± : Type u_3} (l : Filter Î±) {c : Î± â†’ ð•œ} {d : Î± â†’ E} (hc : Filter.Tendsto (Î» (n : Î±), âˆ¥c nâˆ¥) l Filter.atTop) (hD : Filter.Tendsto (Î» (n : Î±), c n â€¢ d n) l (nhds y)) : Filter.Tendsto d l (nhds 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} (F : Top.Presheaf C X) (U : TopologicalSpace.Opens â†¥X) (R : CategoryTheory.Presieve U) : CategoryTheory.Presheaf.secondMap R F â‰« (Top.Presheaf.coveringOfPresieve.secondObjIsoPiInters F U R).hom = (Top.Presheaf.coveringOfPresieve.firstObjIsoPiOpens F U R).hom â‰« Top.Presheaf.SheafConditionEqualizerProducts.rightRes F (Top.Presheaf.coveringOfPresieve U R)
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (hs : s.nonempty) {C : â„} (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ HasDist.dist x y â‰¤ C) : Metric.diam s â‰¤ C
{m : â„} {f : â„• â†’ â„•} (hm : 1 < m) (fi : âˆ€ (i : â„•), i â‰¤ f i) : Summable (Î» (i : â„•), 1 / m ^ f i)
{Î± : Type u} {Î² : Type v} {s : Set Î±} {t : Set Î²} {f : Î± â†’ Î²} {f' : Î² â†’ Î±} (h : Set.InvOn f' f s t) (hF : Set.MapsTo f s t) (hF' : Set.MapsTo f' t s) : Set.BijOn f s t
{Î± : Type u_1} {Î¹ : Type u_3} {Î¹' : Type u_4} [distribLattice Î±] [OrderBot Î±] [DecidableEq Î¹] {s : Finset Î¹'} {g : Î¹' â†’ Finset Î¹} {f : Î¹ â†’ Î±} (hs : s.sup_indep (Î» (i : Î¹'), (g i).sup f)) (hg : âˆ€ (i' : Î¹'), i' âˆˆ s â†’ (g i').sup_indep f) : (s.sup g).sup_indep f
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscreteNormedField ð•‚] [normedRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] [CharZero ð•‚] {x y : ð”¸} (hxy : Commute x y) (hx : x âˆˆ Emetric.Ball 0 (expSeries ð•‚ ð”¸).radius) (hy : y âˆˆ Emetric.Ball 0 (expSeries ð•‚ ð”¸).radius) : Exp ð•‚ (x + y) = Exp ð•‚ x * Exp ð•‚ y
(n a : â„•) (p : â„• â†’ Prop) [DecidablePred p] (pp : Function.Periodic p a) : (Finset.filter p (Finset.ico n (n + a))).card = Nat.count p a
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e : localHomeomorph Î± Î²} {s : Set Î±} {t : Set Î²} : e.is_image s t â†’ e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' (e.to_local_equiv.source âˆ© s) = e.to_local_equiv.target âˆ© t
{K : Type v} [Field K] {P : Polynomial K} (hmo : P.monic) (hP : Polynomial.Splits (RingHom.id K) P) : P.next_Coeff = -P.roots.sum
{Î± : Type u} [pseudoMetricSpace Î±] {x : Î±} {r : â„} : Metric.Bounded (Metric.Ball x r)
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : MultilinearMap ð•œ E G) {C : â„} (hC : 0 â‰¤ C) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ C * finset.univ.sum (Î» (i : Î¹), finset.univ.prod (Î» (j : Î¹), Ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (Linear_order.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
{Î± : Type u_1} {Î² : Type u_2} {e : LocalEquiv Î± Î²} {s : Set Î±} {t : Set Î²} : e.target âˆ© â‡‘(e.symm) â»Â¹' s = e.target âˆ© t â†’ e.is_image s t
(R : Type u_1) [CommRing R] (M : Type u_2) [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [Nontrivial R] : (LinearMap.trace R M).comp (dualTensorHom R M M) = contractLeft R M
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {s : Finset Î±} : s âˆˆ ð’œ.up_shadow â†” âˆƒ (t : Finset Î±) (H : t âˆˆ ð’œ) (a : Î±) (H : a âˆ‰ t), HasInsert.insert a t = s
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (f : Î± â‰ƒâ‚œ Î²) (K : TopologicalSpace.Compacts Î±) : (â‡‘(TopologicalSpace.Compacts.equiv f) K).carrier = â‡‘(f.symm) â»Â¹' K.carrier
{Î± : sort u_1} {Î² : sort u_2} {Î³ : outParam (sort u_3)} [hasCoe Î± Î²] [hasCoeToFun Î² (Î» (_x : Î²), Î³)] (x : Î±) : â‡‘x = â‡‘â†‘x
{a b : â„•} (ha : a â‰  0) (hb : b â‰  0) : (a * b).factors.to_Finset = a.factors.to_Finset âˆª b.factors.to_Finset
{Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : a â‰¤ b) : Set.Ioi b âŠ† Set.Ioi a
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [Module ð•œ Î²] [LinearOrder E] {s : Set E} {f : E â†’ Î²} (hs : Convex ð•œ s) (hF : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ð•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) < a â€¢ f x + b â€¢ f y) : StrictConvexOn ð•œ s f
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} : AntitoneOn f s â†’ MonotoneOn (f âˆ˜ â‡‘OrderDual.ofDual) s
{Î± : Type u_1} [CircularPreorder Î±] {a b c : Î±} (h : HasSbtw.Sbtw a b c) : HasSbtw.Sbtw b c a
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasDerivAt (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) a
{Î± : Type u_1} {R : Type u_2} {l : Filter Î±} {f : Î± â†’ R} {r : R} [linearOrderedRing R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto f l Filter.atBot) : Filter.Tendsto (Î» (x : Î±), f x * r) l Filter.atBot
{n : â„•+} (h1 : n â‰  1) : âˆƒ (k : â„•+), n = k + 1
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {s : Set E} : DifferentiableOn ð•œ f s â†’ MdifferentiableOn (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f s
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] (s : Submodule K V) : FiniteDimensional.finrank K (V â§¸ s) + FiniteDimensional.finrank K â†¥s = FiniteDimensional.finrank K V
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] (e : localHomeomorph Î± Î²) {f : Î² â†’ Î³} {s : Set Î²} {x : Î²} (h : x âˆˆ e.to_local_equiv.target) : ContinuousWithinAt f s x â†” ContinuousWithinAt (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) (â‡‘(e.symm) x)
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B} [Nontrivial A] (hx : IsIntegral A x) : minpoly A x â‰  0
{Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Î± â†’ Set Î²} {x : Î±} {y : Î²} (xs : x âˆˆ s) (ytx : y âˆˆ t x) : y âˆˆ â‹ƒ (x : Î±) (H : x âˆˆ s), t x
(p : â„•) {Idx : Type u_2} [hp : Fact (Nat.Prime p)] (Î¦ : MvPolynomial Idx â„š) (n : â„•) : wittStructureRat p Î¦ n = â‡‘MvPolynomial.c (1 / â†‘p ^ n) * (â‡‘(mv_polynomial.bindâ‚ (Î» (b : Idx), â‡‘(MvPolynomial.rename (Î» (i : â„•), (b, i))) (wittPolynomial p â„š n))) Î¦ - (Finset.range n).sum (Î» (i : â„•), â‡‘MvPolynomial.c (â†‘p ^ i) * wittStructureRat p Î¦ i ^ p ^ (n - i)))
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] [StrictConvexSpace â„ E] {x y z : E} {a b r : â„} (hx : x âˆˆ Metric.ClosedBall z r) (hy : y âˆˆ Metric.ClosedBall z r) (hne : x â‰  y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : a â€¢ x + b â€¢ y âˆˆ Metric.Ball z r
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î± â†’ Î² Ã— Î³} {x : Î±} (hF : ContinuousAt f x) : ContinuousAt (Î» (a : Î±), (f a).snd) x
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup V1] [Module k V1] [addTorsor V1 P1] [AddCommGroup V2] [Module k V2] [addTorsor V2 P2] (f : P1 â†’áµƒ[k] P2) (p : P1) (v : V1) : â‡‘f (v +áµ¥ p) = â‡‘(f.linear) v +áµ¥ â‡‘f p
{R : Type u_1} {Râ‚ : Type u_2} {Râ‚‚ : Type u_3} {Mâ‚ : Type u_6} {Mâ‚‚ : Type u_7} [CommSemiring R] [CommSemiring Râ‚] [AddCommMonoid Mâ‚] [Module Râ‚ Mâ‚] [CommSemiring Râ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {Iâ‚ : Râ‚ â†’+* R} {Iâ‚‚ : Râ‚‚ â†’+* R} {B : Mâ‚ â†’â‚›â‚—[Iâ‚] Mâ‚‚ â†’â‚›â‚—[Iâ‚‚] R} : B.separating_Right â†” B.flip.ker = âŠ¥
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.RegularMono f] [e : CategoryTheory.Epi f] : CategoryTheory.IsIso f
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [innerProductSpace ð•œ G] [FiniteDimensional ð•œ E] [FiniteDimensional ð•œ F] [FiniteDimensional ð•œ G] (A : F â†’â‚—[ð•œ] G) (B : E â†’â‚—[ð•œ] F) : â‡‘LinearMap.adjoint (A.comp B) = (â‡‘LinearMap.adjoint B).comp (â‡‘LinearMap.adjoint A)
{G : Type u_1} [CommGroup G] : group.nilpotency_class G â‰¤ 1
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} : -a < b â†’ -b < a
{F : Type u_3} [innerProductSpace â„ F] {Î¹â‚ : Type u_1} {sâ‚ : Finset Î¹â‚} {wâ‚ : Î¹â‚ â†’ â„} (vâ‚ : Î¹â‚ â†’ F) (hâ‚ : sâ‚.sum (Î» (i : Î¹â‚), wâ‚ i) = 0) {Î¹â‚‚ : Type u_2} {sâ‚‚ : Finset Î¹â‚‚} {wâ‚‚ : Î¹â‚‚ â†’ â„} (vâ‚‚ : Î¹â‚‚ â†’ F) (hâ‚‚ : sâ‚‚.sum (Î» (i : Î¹â‚‚), wâ‚‚ i) = 0) : HasInner.inner (sâ‚.sum (Î» (iâ‚ : Î¹â‚), wâ‚ iâ‚ â€¢ vâ‚ iâ‚)) (sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚‚ iâ‚‚ â€¢ vâ‚‚ iâ‚‚)) = -sâ‚.sum (Î» (iâ‚ : Î¹â‚), sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚ iâ‚ * wâ‚‚ iâ‚‚ * (âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥ * âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥))) / 2
{E : Type u_2} [semiNormedGroup E] [normedSpace â„ E] {s : Set E} (hs : Convex â„ s) : ConvexOn â„ s HasNorm.norm
{Î± : Type u_1} [hasLt Î±] {a b : Î±} : a â‹– b â†’ â‡‘OrderDual.toDual b â‹– â‡‘OrderDual.toDual a
{R S : Type u} [CommRing R] [CommRing S] (M : Submonoid R) (S' : Type u) [CommRing S'] [Algebra S S'] [Algebra R S] [Algebra R S'] [isScalarTower R S S'] [IsLocalization (Submonoid.map â†‘(algebraMap R S) M) S'] (x : S) (s : Finset S') (hx : â‡‘(algebraMap S S') x âˆˆ Algebra.adjoin R â†‘s) : âˆƒ (m : â†¥M), m â€¢ x âˆˆ Algebra.adjoin R â†‘(IsLocalization.finsetIntegerMultiple (Submonoid.map â†‘(algebraMap R S) M) s)
{Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [orderedAddCommMonoid N] (f : M â†’ N) (p : M â†’ Prop) (h_One : f 0 = 0) (h_Mul : âˆ€ (x y : M), p x â†’ p y â†’ f (x + y) â‰¤ f x + f y) (hp_Mul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (g : Î¹ â†’ M) {s : Finset Î¹} (hs : âˆ€ (i : Î¹), i âˆˆ s â†’ p (g i)) : f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] (f : S.localization_Map N) : f.of_addEquiv_of_Dom _ = f
(n : â„•) (R : Type u_1) (hpos : 0 < n) [Ring R] [Nontrivial R] : 0 < (Polynomial.cyclotomic n R).degree
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hst : Disjoint s t) (hs : (s âˆ© Function.Support f).finite) (ht : (t âˆ© Function.Support f).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
{ð•œ : Type u_3} {E : Type u_4} [normedField ð•œ] [AddCommGroup E] [normedSpace â„ ð•œ] [Module ð•œ E] [Module â„ E] [isScalarTower â„ ð•œ E] (p : Seminorm ð•œ E) (x : E) (r : â„) : Convex â„ (p.ball x r)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x y : E} : HasInner.inner (x + y) (x + y) + HasInner.inner (x - y) (x - y) = 2 * (HasInner.inner x x + HasInner.inner y y)
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {X Y : C} (f : Y âŸ¶ X) (S : CategoryTheory.Sieve X) : Jâ‚.close (CategoryTheory.Sieve.pullback f S) = CategoryTheory.Sieve.pullback f (Jâ‚.close S)
{Î± : Type u_2} [Bornology Î±] {s : Set Î±} : Bornology.IsCobounded sá¶œ â†’ Bornology.IsBounded s
{p : â„•} [hp : Fact (Nat.Prime p)] (x : WittVector p (Zmod p)) : â‡‘WittVector.verschiebung x = x * â†‘p
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} {sâ‚ sâ‚‚ : Affine.Simplex â„ P n} (h : Set.Range sâ‚.points = Set.Range sâ‚‚.points) : sâ‚.circumcenter = sâ‚‚.circumcenter
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [is_R_or_C ð•‚] [normedCommRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] {x y : ð”¸} : Exp ð•‚ (x + y) = Exp ð•‚ x * Exp ð•‚ y
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (x : Î± 0) (p : Î  (i : Fin n), Î± i.succ) (z : Î± 0) : Function.update (fin.cons x p) 0 z = fin.cons z p
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Fintype Î¹] [DecidableEq Î¹] [Î  (i : Î¹), DecidableEq (Î± i)] {p : (Î  (i : Î¹), Finset (Î± i)) â†’ Prop} (f : Î  (i : Î¹), Finset (Î± i)) (h0 : p (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), Finset (Î± i)) (i : Î¹) (x : Î± i), x âˆ‰ g i â†’ p g â†’ p (Function.update g i (HasInsert.insert x (g i)))) : p f
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î±] [DecidableEq Î²] (f : Î± â†’ Î²) (s : Multiset Î±) (hF : Function.Injective f) (x : Î±) : Multiset.count (f x) (Multiset.map f s) = Multiset.count x s
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Kâ‚ Kâ‚‚ : Submodule ð•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) : Kâ‚‚á—® â‰¤ Kâ‚á—®
{G : Type u_7} [CommGroup G] (L : List G) (n : â„•) (a : G) : (L.update_nth n a).prod = L.prod * dite (n < L.length) (Î» (hn : n < L.length), (L.nth_LE n hn)â»Â¹ * a) (Î» (hn : Â¬n < L.length), 1)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {p : Î¹ â†’ P} (hp : AffineIndependent k p) (j : Î¹) (w : Î¹ â†’ kË£) : AffineIndependent k (Î» (i : Î¹), â‡‘(AffineMap.lineMap (p j) (p i)) â†‘(w i))
{Î± : Type u_2} [DecidableEq Î±] [hasInv Î±] {s : Finset Î±} : sâ»Â¹.nonempty â†’ s.nonempty
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {E : Type w} [NormedGroup E] [normedSpace ð•œ E] {f : ð•œ â†’ F} {f' : F} (x : ð•œ) {s : Set ð•œ} {l : F â†’ E} {l' : F â†’L[ð•œ] E} {t : Set F} (hl : HasFderivWithinAt l l' t (f x)) (hF : HasDerivWithinAt f f' s x) (hst : Set.MapsTo f s t) : HasDerivWithinAt (l âˆ˜ f) (â‡‘l' f') s x
{Î± : Type u} [pseudoMetricSpace Î±] (x y : Î±) : HasNndist.nndist x y = (HasEdist.edist x y).to_Nnreal
{m : Type u_1} (R : Type u_3) {S : Type u_4} [Fintype m] [DecidableEq m] [CommSemiring R] [CommSemiring S] [Algebra R S] (A : Matrix m m S) : â‡‘((MvPolynomial.aeval (Î» (p : m Ã— m), A p.fst p.snd)).map_Matrix) (matrix.mv_Polynomial.x m m R) = A
{Mâ‚€ : Type u_1} [MulZeroOneClass Mâ‚€] : 0 = 1 â†” Subsingleton Mâ‚€
{c : Cardinal} (h : Cardinal.aleph_0 â‰¤ c) : c * c = c
{E : Type u_1} [NormedGroup E] {a : â„} {f g : â„‚ â†’ E} {l : Filter â„‚} (hBf : âˆƒ (c : â„) (H : c < a) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ l] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hBg : âˆƒ (c : â„) (H : c < a) (B : â„), g =O[Filter.comap Complex.abs Filter.atTop âŠ“ l] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) : âˆƒ (c : â„) (H : c < a) (B : â„), (f - g) =O[Filter.comap Complex.abs Filter.atTop âŠ“ l] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)
{Î± : Type u} {s t : Set Î±} {l : Filter Î±} : (âˆ€á¶  (x : Î±) in l, x âˆˆ s â†” x âˆˆ t) â†’ s =á¶ [l] t
{X Y : CompHaus} (f : X âŸ¶ Y) : IsClosedMap â‡‘f
{G : Type u_10} {H : Type u_11} [Group G] [divisionMonoid H] (h : G â‰ƒ* H) (x y : G) : â‡‘h (x / y) = â‡‘h x / â‡‘h y
{Î± : Type u_1} {Î² : Type u_2} {e e' : LocalEquiv Î± Î²} (h : e â‰ˆ e') : e.source = e'.source
{X : Type u} {Î± : Type v} [topologicalSpace X] [LinearOrder Î±] [topologicalSpace Î±] [OrderClosedTopology Î±] {s : Set X} (hs : IsPreconnected s) {a b : X} (ha : a âˆˆ s) (hb : b âˆˆ s) {f g : X â†’ Î±} (hF : ContinuousOn f s) (hg : ContinuousOn g s) (ha' : f a â‰¤ g a) (hb' : g b â‰¤ f b) : âˆƒ (x : X) (H : x âˆˆ s), f x = g x
{z w : â„‚} (hz : 0 â‰¤ z.re âˆ¨ z.im â‰  0) (hw : 0 < w.re) : ContinuousAt (Î» (x : â„‚), x ^ w) z
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hab : a â‰¤ b) (hcont : ContinuousOn f (Set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) (hint : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : âˆ« (y : â„) in a..b, f' y = f b - f a
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {f : Î± â†’ Î² â†’ Î³} {ta1 ta2 : topologicalSpace Î±} {tb1 tb2 : topologicalSpace Î²} {Tc1 : topologicalSpace Î³} (h : Continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)) : Continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)
{C : Type uâ‚} [CategoryTheory.SmallCategory C] {Pâ‚ Pâ‚‚ : Cáµ’áµ– â¥¤ Type uâ‚} (Î± : Pâ‚ âŸ¶ Pâ‚‚) (j : (Pâ‚.elements)áµ’áµ–) : (CategoryTheory.coconeOfRepresentable Pâ‚).Î¹.app j â‰« Î± = (CategoryTheory.coconeOfRepresentable Pâ‚‚).Î¹.app ((CategoryTheory.categoryOfElements.map Î±).op.obj j)
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] [NormalSpace Y] (f : C(X, â„)) (e : X â†’ Y) (hE : ClosedEmbedding e) : âˆƒ (g : C(Y, â„)), â‡‘g âˆ˜ e = â‡‘f
{p : â„•} (hp : Nat.Prime p) {n b : â„•} : Nat.log p n < b â†’ multiplicity p n.factorial = â†‘((Finset.ico 1 b).sum (Î» (i : â„•), n / p ^ i))
(G : Type u_1) [Group G] : group.is_nilpotent G â†” âˆƒ (n : â„•) (H : â„• â†’ Subgroup G), IsAscendingCentralSeries H âˆ§ H n = âŠ¤
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f g : Î± â†’ M} {s : Set Î±} (hs : s.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i * g i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), g i))
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [FiniteDimensional ð•œ E] (T : E â†’â‚—[ð•œ] E) (x : E) : 0 â‰¤ â‡‘is_R_or_C.re (HasInner.inner x (â‡‘(â‡‘LinearMap.adjoint T * T) x))
(ð•œ : Type u_5) (E : Type u_6) [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [Nontrivial E] (c : â„) : âˆƒ (x : E), c < âˆ¥xâˆ¥
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {s : Set ð•œ} {n : WithTop â„•} (hs : UniqueDiffOn ð•œ s) : ContDiffOn ð•œ n f s â†” (âˆ€ (m : â„•), â†‘m â‰¤ n â†’ ContinuousOn (iteratedDerivWithin m f s) s) âˆ§ âˆ€ (m : â„•), â†‘m < n â†’ DifferentiableOn ð•œ (iteratedDerivWithin m f s) s
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {l : Filter Î±} {a : Î±} : IsMinFilter f l a â†’ IsMaxFilter (â‡‘OrderDual.toDual âˆ˜ f) l a
{B : Type u_3} {S : B} {M : Type u_1} [AddCommMonoid M] [SetLike B M] [addSubmonoidClass B M] {Î¹ : Type u_2} {t : Finset Î¹} {f : Î¹ â†’ M} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.sum (Î» (c : Î¹), f c) âˆˆ S
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] {F : Type v} [NormedGroup F] [normedSpace â„‚ F] [Nontrivial E] [FiniteDimensional â„‚ E] {f : E â†’ F} {U : Set E} (hb : Metric.Bounded U) (hne : U.nonempty) (hD : DiffContOnCl â„‚ f U) : âˆƒ (z : E) (H : z âˆˆ Frontier U), IsMaxOn (HasNorm.norm âˆ˜ f) (Closure U) z
{Î± : Type u_1} [completeLattice Î±] {a : Î±} {s : Set Î±} : (â¨† (b : Î±) (H : b âˆˆ s), b âŠ“ a) â‰¤ HasSup.sup s âŠ“ a
{Î± : Type u_3} [linearOrderedAddCommGroup Î±] : Filter.Tendsto HasAbs.abs Filter.atTop Filter.atTop
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] [AddGroup Î±] [UniformAddGroup Î±] {hom : Type u_3} [uniformSpace Î²] [AddGroup Î²] [UniformAddGroup Î²] [addMonoidHomClass hom Î± Î²] (f : hom) (hF : ContinuousAt â‡‘f 0) : UniformContinuous â‡‘f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (p : P) (s1 s2 : AffineSubspace k P) : p âˆˆ s1 âŠ“ s2 â†” p âˆˆ s1 âˆ§ p âˆˆ s2
(n : â„•) {m : â„} (m1 : 1 < m) : âˆ‘' (i : â„•), 1 / m ^ (i + (n + 1)).factorial < (1 - 1 / m)â»Â¹ * (1 / m ^ (n + 1).factorial)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {v : â„ â†’ E â†’ E} {K : Nnreal} (hv : âˆ€ (t : â„), LipschitzWith K (v t)) {f g : â„ â†’ E} {a b Î´ : â„} (hF : ContinuousOn f (Set.Icc a b)) (hF' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (v t (f t)) (Set.Ici t) t) (hg : ContinuousOn g (Set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt g (v t (g t)) (Set.Ici t) t) (ha : HasDist.dist (f a) (g a) â‰¤ Î´) (t : â„) (H : t âˆˆ Set.Icc a b) : HasDist.dist (f t) (g t) â‰¤ Î´ * Real.exp (â†‘K * (t - a))
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (w : Î¹ â†’ k) (p : Î¹ â†’ P) (b : P) {sâ‚ sâ‚‚ : Finset Î¹} (h : sâ‚ âŠ† sâ‚‚) : â‡‘(sâ‚.weighted_vsub_of_point p b) w = â‡‘(sâ‚‚.weighted_vsub_of_point p b) (â†‘sâ‚.indicator w)
{ð•œ : Type u_1} [is_R_or_C ð•œ] {E : Type u_2} {E' : Type u_3} [innerProductSpace ð•œ E] [innerProductSpace ð•œ E'] (f : E â‰ƒâ‚—áµ¢[ð•œ] E') (K : Submodule ð•œ E) [CompleteSpace â†¥K] : reflection (Submodule.map â†‘(f.to_linearEquiv) K) = f.symm.trans ((reflection K).trans f)
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [hÎ¹ : Î  (n : Î²), Encodable (Î¹ n)] (d : â„) (s : Set X) {l : Filter Î²} (r : Î² â†’ Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ Set X) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), Emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, s âŠ† â‹ƒ (i : Î¹ n), t n i) : â‡‘(MeasureTheory.Measure.hausdorffMeasure d) s â‰¤ l.liminf (Î» (n : Î²), âˆ‘' (i : Î¹ n), Emetric.diam (t n i) ^ d)
(R : Type u) [CommRing R] [is_IsDomain R] [DiscreteValuationRing R] : âˆƒ (Ï– : R), Prime Ï–
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) (m : M) : âˆ¥â‡‘(QuotientAddGroup.mk' S) mâˆ¥ â‰¤ âˆ¥mâˆ¥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q) [CategoryTheory.Mono f] : Function.Injective â‡‘f
{L : FirstOrder.Language} {M : Type w} [L.Structure M] (S : L.substructure M) : â‡‘(FirstOrder.Language.Substructure.closure L) â†‘S = S
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] {F : J â¥¤ Profinite} (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) {U : Set â†¥(C.X)} (hU : is_IsClopen U) : âˆƒ (j : J) (V : Set â†¥(F.obj j)) (hV : is_IsClopen V), U = â‡‘(C.Ï€.app j) â»Â¹' V
{M : Type u_2} [AddCommGroup M] {A : Type u_1} [CommRing A] [Module A M] (f : M â‰ƒâ‚—[A] M) : IsUnit (â‡‘LinearMap.det â†‘f)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) : s -áµ¥ s âŠ† â†‘(vectorSpan k s)
{M : Type u_1} {R : Type u_4} [NonUnitalNonAssocSemiring R] [SetLike M R] [mulMemClass M R] {S : M} {a b : R} (ha : a âˆˆ AddSubmonoid.closure â†‘S) (hb : b âˆˆ AddSubmonoid.closure â†‘S) : a * b âˆˆ AddSubmonoid.closure â†‘S
{Î± : Type u_1} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {s : Finset Î±} : s âˆˆ ð’œ.shadow â†” âˆƒ (t : Finset Î±) (H : t âˆˆ ð’œ), s âŠ† t âˆ§ t.card = s.card + 1
{R : Type u_2} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R] [Nontrivial R] [normalizationMonoid R] [DecidableEq R] [dec_Dvd : DecidableRel Dvd.dvd] {a b : R} (ha : Irreducible a) (hb : b â‰  0) : multiplicity a b = â†‘(Multiset.count (â‡‘normalize a) (UniqueFactorizationMonoid.normalizedFactors b))
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {ps : Set P} (hps : ps âŠ† â†‘s) (p : P) : (âˆƒ (r : â„), âˆ€ (p1 : P), p1 âˆˆ ps â†’ HasDist.dist p1 p = r) â†” âˆƒ (r : â„), âˆ€ (p1 : P), p1 âˆˆ ps â†’ HasDist.dist p1 â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p) = r
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [is_R_or_C ð•‚] [normedCommRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] {Î¹ : Type u_3} (s : Finset Î¹) (f : Î¹ â†’ ð”¸) : Exp ð•‚ (s.sum (Î» (i : Î¹), f i)) = s.prod (Î» (i : Î¹), Exp ð•‚ (f i))
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} {s t : Set Î±} : Emetric.infEdist x (s âˆª t) = Emetric.infEdist x s âŠ“ Emetric.infEdist x t
(x : â„) (h : Real.cos x â‰  0) : deriv (Î» (y : â„), Real.tan y - y) x = 1 / Real.cos x ^ 2 - 1
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (hg : ContDiffOn ð•œ n g t) (hF : ContDiffOn ð•œ n f s) (st : s âŠ† f â»Â¹' t) : ContDiffOn ð•œ n (g âˆ˜ f) s
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {M : Type u_6} [CommSemiring R] [AddCommMonoid M] [Module R M] [Fintype Î¹'] [Fintype Î¹] [DecidableEq Î¹] [DecidableEq Î¹'] (b : Basis Î¹ R M) (v : Î¹' â†’ M) (e : Î¹ â‰ƒ Î¹') : (b.reindex e).to_Matrix v = â‡‘(Matrix.reindexAlgEquiv R e) (b.to_Matrix (v âˆ˜ â‡‘e))
{X : Type u_2} [emetricSpace X] (s : Finset X) : dimH â†‘s = 0
{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hF : Function.IsFixedPt f x) (h : Function.LeftInverse g f) : Function.IsFixedPt g x
{R : Type u} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] [gcdMonoid R] (a b : R) : âˆƒ (x y : R), GcdMonoid.gcd a b = a * x + b * y
(R : Type u_1) [CommRing R] (Î¹ : Type u_2) [Fintype Î¹] : Algebra.FinitePresentation R (MvPolynomial Î¹ R)
{n : â„•} {Î± : Type u_1} [Preorder Î±] {f : Fin (n + 1) â†’ Î±} : StrictAnti f â†” âˆ€ (i : Fin n), f i.succ < f (â‡‘fin.cast_Succ i)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {bâ‚‚ : Basis (Fin 2) â„ V} (hbâ‚‚ : Orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = -bâ‚‚.orientation) (x y : V) : hb.oangle x y = -hbâ‚‚.oangle x y
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : â„ â†’ E} {f' : E} {s : Set â„} {x r : â„} (hF : HasDerivWithinAt f f' s x) (hr : âˆ¥f'âˆ¥ < r) : âˆ€á¶  (z : â„) in nhdsWithin x s, âˆ¥z - xâˆ¥â»Â¹ * âˆ¥f z - f xâˆ¥ < r
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : Setoid Î±} (h : âˆ€ (x y : Î±), r x y â†’ s.rel x y) : EqvGen.setoid r â‰¤ s
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x y : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) (h : y âˆˆ Emetric.Ball x r) : AnalyticAt ð•œ f y
{x : Pgame} : x.lf 0 â†” âˆƒ (j : x.right_moves), âˆ€ (i : (x.move_Right j).left_moves), ((x.move_Right j).move_Left i).lf 0
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) {r : â„} (hr : r < 0) : o.oangle (r â€¢ x) y = o.oangle (-x) y
{Î¹ : Type u_1} {ð•œ : Type u_2} [is_R_or_C ð•œ] {E : Type u_3} [innerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), innerProductSpace ð•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ V) [âˆ€ (i : Î¹), CompleteSpace (G i)] : hV.linear_isometry.to_LinearMap.range = (â¨† (i : Î¹), (V i).to_LinearMap.range).topological_Closure
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸ : Real.Angle) : â‡‘LinearEquiv.det (o.rotation Î¸).to_linearEquiv = 1
{Î± : sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : {a // p a}), q â†‘x _
{G : Type u} [Monoid G] : IsOfFinOrder 1
{n : â„¤} (hn : n â‰  -1) (c w : â„‚) (R : â„) : âˆ® (z : â„‚) in C(c, R), (z - w) ^ n = 0
{M : Type u_3} {N : Type u_4} [hasMul M] [hasMul N] {f g : M â†’â‚™* N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
{Î± : Type u} (s : Set (Set Î±)) : Cardinal.mk â†¥{t : Set Î± | MeasurableSet t} â‰¤ Linear_order.max (Cardinal.mk â†¥s) 2 ^ Cardinal.aleph_0
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semiNormedGroup Vâ‚] [semiNormedGroup Vâ‚‚] (f : NormedGroupHom Vâ‚ Vâ‚‚) (x : Vâ‚) : âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥
{Î± : Type u_1} [Monoid Î±] {a b : Î±} {u : Î±Ë£} : a âˆ£ b * â†‘u â†” a âˆ£ b
 : Orthonormal â„‚ (fourierLp 2)
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {A B : Matrix n n Î±} (h : B.mul A = 1) : Aâ»Â¹ = B
{Mâ‚€ : Type u_1} [MulZeroClass Mâ‚€] : Mul.mul 0 = Function.const Mâ‚€ 0
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] [NoZeroSmulDivisors R M] {v : M} (hv : v â‰  0) {r : R} (hr : r â‰  0) : SameRay R v (r â€¢ v) â†” 0 < r
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {f : E Ã— F â†’ G} (h : IsBoundedBilinearMap ð•œ f) : IsBoundedLinearMap ð•œ (Î» (p : E Ã— F), h.deriv p)
{R : Type u_1} {M : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup M] [Module R M] [NoZeroDivisors R] {B : M â†’â‚—[R] M â†’â‚—[R] R} (v : Basis n R M) (hO : B.is_Ortho â‡‘v) (h : âˆ€ (i : n), Â¬B.is_IsOrtho (â‡‘v i) (â‡‘v i)) : B.separating_Right
{p x : â„} {r : â„š} (hr : r â‰  0) : LiouvilleWith p (â†‘r * x) â†” LiouvilleWith p x
{Î± : Type u_1} [HasSup Î±] [HasInf Î±] (HasSup_comm : âˆ€ (a b : Î±), a âŠ” b = b âŠ” a) (HasSup_assoc : âˆ€ (a b c : Î±), a âŠ” b âŠ” c = a âŠ” (b âŠ” c)) (HasSup_idem : âˆ€ (a : Î±), a âŠ” a = a) (HasInf_comm : âˆ€ (a b : Î±), a âŠ“ b = b âŠ“ a) (HasInf_assoc : âˆ€ (a b c : Î±), a âŠ“ b âŠ“ c = a âŠ“ (b âŠ“ c)) (HasInf_idem : âˆ€ (a : Î±), a âŠ“ a = a) (HasSup_HasInf_self : âˆ€ (a b : Î±), a âŠ” a âŠ“ b = a) (HasInf_HasSup_self : âˆ€ (a b : Î±), a âŠ“ (a âŠ” b) = a) : SemilatticeSup.toPartialOrder Î± = SemilatticeInf.toPartialOrder Î±
{Î± : Type u} (s : Set Î±) : is_IsOpen {u : Ultrafilter Î± | s âˆˆ u}
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {v : V} (p : P) {direction : Submodule k V} (hv : v âˆˆ direction) : v +áµ¥ p âˆˆ AffineSubspace.mk' p direction
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : f' =o[l] g â†’ (Î» (x : Î±), -f' x) =o[l] g
{Î± : Type u} [orderedSemiring Î±] [Nontrivial Î±] : 0 < 1
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [divisionMonoid Î²] (f : Î± â†’* Î²) (g h : Î±) : â‡‘f (g * hâ»Â¹) = â‡‘f g * (â‡‘f h)â»Â¹
{M : Type u_1} [MulOneClass M] {s : Set M} : s âŠ† â†‘(Submonoid.closure s)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {s : Set ð•œ} {n : WithTop â„•} (h : âˆ€ (m : â„•), â†‘m â‰¤ n â†’ DifferentiableOn ð•œ (iteratedDerivWithin m f s) s) : ContDiffOn ð•œ n f s
{Î± : Type u_1} {Î² : Type u_2} {f g : Î± â†’ Î²} {m : measurableSpace Î±} {mÎ² : measurableSpace Î²} [MeasurableSingletonClass Î±] (hF : Measurable f) (h : {x : Î± | f x â‰  g x}.countable) : Measurable g
{Î± : Type u} {Î² : Type v} [hasMul Î±] [hasMul Î²] {Î³ : Type u_1} [hasMul Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³} (hF : IsMulHom f) (hg : IsMulHom g) : IsMulHom (g âˆ˜ f)
{Î± : Type u} {Î² : Type v} [MulOneClass Î±] [MulOneClass Î²] {f : Î± â†’ Î²} (hF : IsMonoidHom f) {Î³ : Type u_1} [MulOneClass Î³] {g : Î² â†’ Î³} (hg : IsMonoidHom g) : IsMonoidHom (g âˆ˜ f)
{M : Type u_1} [hasAdd M] {s : Set M} {S : AddSubsemigroup M} : AddSubsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S
{M : Type u_1} [MulOneClass M] {N : Type u_2} [MulOneClass N] (f : M â†’* N) (hF : Function.Surjective â‡‘f) : f.mrange = âŠ¤
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {Î± : â†¥(solvableByRad F E)} {n : â„•} (hn : n â‰  0) (hÎ± : solvableByRad.P (Î± ^ n)) : solvableByRad.P Î±
{Î± : Type u_1} [GeneralizedBooleanAlgebra Î±] {f d : â„• â†’ Î±} (hdisj : Pairwise (Disjoint on d)) (hsups : partialSups d = partialSups f) : d = disjointed f
{X : Type u_1} {m : Type u_4} {n : Type u_5} {p : Type u_6} {R : Type u_8} [topologicalSpace X] [topologicalSpace R] [Fintype n] [hasMul R] [AddCommMonoid R] [HasContinuousAdd R] [HasContinuousMul R] {A : X â†’ Matrix m n R} {B : X â†’ Matrix n p R} (hA : Continuous A) (hB : Continuous B) : Continuous (Î» (x : X), (A x).mul (B x))
 : Finset.Nat.antidiagonal 0 = {(0, 0)}
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [NonAssocSemiring Î²] [NonAssocSemiring Î³] (g : Î² â†’+* Î³) (f : Î± â†’ Î²) (s : Finset Î±) : â‡‘g (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), â‡‘g (f x))
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) : o.rotation 0 = LinearIsometryEquiv.refl â„ V
{Î± : Type u_3} [SemilatticeInf Î±] (a : Î±) : Filter.atBot = Filter.comap Coe Filter.atBot
{Î± : Type u} {L : List (Î± Ã— Bool)} : FreeGroup.Red List.nil L â†” L = List.nil
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) : 0 âˆˆ S
{Î± : Type u} [completeLattice Î±] {J : Type u} [CategoryTheory.SmallCategory J] (F : J â¥¤ Î±) : CategoryTheory.Limits.limit F = infi F.obj
{M : Type u_3} {N : Type u_4} [hasZero M] [hasZero N] (f : ZeroHom M N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
{M : Type u_3} {S : Type u_4} [subNegMonoid M] [SetLike S M] [hSM : addSubgroupClass S M] {H : S} {x y : M} (hx : x âˆˆ H) (hy : y âˆˆ H) : x - y âˆˆ H
{Î± : Type u_1} [measurableSpace Î±] {f g : Î± â†’ â„} {s : Set Î±} (hF : Measurable f) (hg : Measurable g) (hs : MeasurableSet s) : MeasurableSet (RegionBetween f g s)
{ð•œ : Type u_1} [is_R_or_C ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {x : E} (hx : x â‰  0) : âˆ¥(â†‘âˆ¥xâˆ¥)â»Â¹ â€¢ xâˆ¥ = 1
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a : Î±} : -a < 0 â†” 0 < a
{n m : â„•} (h : n = m) : â‡‘(fin.cast h) = cast _
{m : Type u_2} {n : Type u_3} (R : Type u_11) [CommRing R] [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (e : m â‰ƒ n) (A : Matrix m m R) : (â‡‘(Matrix.reindexAlgEquiv R e) A).det = A.det
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [CompactSpace Î±] [metricSpace Î²] (x : Î±) : Continuous (Î» (f : C(Î±, Î²)), â‡‘f x)
{Î± : sort u_1} {Î³ : sort u_4} {r : Î± â†’ Î± â†’ Prop} (f : Î± â†’ Î³) (h : âˆ€ (aâ‚ aâ‚‚ : Î±), r aâ‚ aâ‚‚ â†’ f aâ‚ = f aâ‚‚) (a : Î±) : Quot.lift f h (Quot.mk r a) = f a
{Î± : Type u} [NonUnitalNonAssocRing Î±] (k : Î±) (h : âˆ€ (x : Î±), k * x = 0 â†’ x = 0) : IsLeftRegular k
{Î± : Type u} {Î² : Type v} [Group Î±] [mulAction Î± Î²] [HasFaithfulSmul Î± Î²] : Function.Injective MulAction.toPerm
(R : Type u_1) {M : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) [Semiring S] [HasScalar R S] [Module S M] [isScalarTower R S M] : â†‘(Submodule.span R s) âŠ† â†‘(Submodule.span S s)
{F : Type u_3} [innerProductSpace â„ F] (x : F) (r : â„) : HasInner.inner (r â€¢ x) x = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} : Filter.Tendsto f lâ‚ lâ‚‚ â†’ lâ‚ â‰¤ Filter.comap f lâ‚‚
{a b : â„} {f f' g : â„ â†’ â„} (h : âˆ€ (x : â„), x âˆˆ Set.Interval a b â†’ HasDerivAt f (f' x) x) (h' : ContinuousOn f' (Set.Interval a b)) (hg : Continuous g) : âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (x : â„) in f a..f b, g x
(k : Type u_1) [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) [CharZero k] [Fintype Î¹] (h : s.nonempty) : finset.univ.sum (Î» (i : Î¹), Finset.centroidWeightsIndicator k s i) = 1
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : AddZeroClass M} {mN : AddZeroClass N} [addMonoidHomClass F M N] (f : F) {x : M} (hx : âˆƒ (y : M), y + x = 0) : âˆƒ (y : N), y + â‡‘f x = 0
{E : Type u_2} {ð•œ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] {s : Set E} (hs : Convex ð•œ s) {a b : ð•œ} (ha : 0 < a) (hb : 0 â‰¤ b) (hab : a + b = 1) : a â€¢ Interior s + b â€¢ s âŠ† Interior s
{Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : a â‰¤ b) : Â¬a â©¿ b â†” âˆƒ (c : Î±), a < c âˆ§ c < b
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (f : G â†’* N) {H K : Subgroup G} (hH : f.ker â‰¤ H) (hK : f.ker â‰¤ K) (hF : Subgroup.map f H = Subgroup.map f K) : H = K
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b c : Î±} : a < b * c â†’ bâ»Â¹ * a < c
(K : Type u) [divisionRing K] {Î¹ : Type v} [Fintype Î¹] : FiniteDimensional.finrank K (Î¹ â†’ K) = Fintype.card Î¹
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] (s : Submodule K V) : FiniteDimensional.finrank K â†¥s â‰¤ FiniteDimensional.finrank K V
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} {s t : Set Î±} : Emetric.infEdist x t â‰¤ Emetric.infEdist x s + Emetric.hausdorffEdist s t
{p : â„•} {R : Type u_1} [hp : Fact (Nat.Prime p)] [CommRing R] (x : WittVector p R) : â‡‘WittVector.frobenius (â‡‘WittVector.verschiebung x) = x * â†‘p
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [normedSpace ð•œ E'] {n : WithTop â„•} {f : E â†’ E'} {s : Set E} {x : E} : ContDiffWithinAt ð•œ n f s x â†’ ContMdiffWithinAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') n f s x
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] {ifp_n : GeneralizedContinuedFraction.IntFractPair K} (nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n) : 0 â‰¤ ifp_n.fr
{G : Type u_1} [Group G] (K : Subgroup G) {l : List G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.prod âˆˆ K
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [denselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [topologicalSpace Î´] [OrderClosedTopology Î´] {f : Î± â†’ Î´} {s : Set Î±} [s.ord_connected] (hs : s.nonempty) (hF : ContinuousOn f s) (hbot : Filter.Tendsto (Î» (x : â†¥s), f â†‘x) Filter.atBot Filter.atTop) (htop : Filter.Tendsto (Î» (x : â†¥s), f â†‘x) Filter.atTop Filter.atBot) : Set.SurjOn f s Set.Univ
{a : â„•} : â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a
{C : Type uâ‚} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : CategoryTheory.Presieve.IsSheafFor P â‡‘S) (tâ‚ tâ‚‚ : Category_theory.yoneda.obj X âŸ¶ P) (ht : S.functor_inclusion â‰« tâ‚ = S.functor_inclusion â‰« tâ‚‚) : tâ‚ = tâ‚‚
{Î± : Type u} [topologicalSpace Î±] {x : Î±} : Dense {x}á¶œ â†” Â¬is_IsOpen {x}
{G : Type u_7} [Group G] (L : List G) : L.reverse.prod = ((List.map (Î» (x : G), xâ»Â¹) L).prod)â»Â¹
{M : Type u_1} [hasMul M] {c d : Con M} {x y : M} : â‡‘(c âŠ“ d) x y â†” â‡‘c x y âˆ§ â‡‘d x y
{ð•œ : Type u} {A : Type v} [Field ð•œ] [Ring A] [Algebra ð•œ A] [Nontrivial A] (k : ð•œ) (a : A) (ha : (Spectrum ð•œ a).nonempty) : Spectrum ð•œ (k â€¢ a) = k â€¢ Spectrum ð•œ a
{f : â„• â†’ â„} (hfa : Monotone f) (hF0 : Filter.Tendsto f Filter.atTop (nhds 0)) : CauchySeq (Î» (n : â„•), (Finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i))
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommGroup E] [HasScalar ð•œ E] {S : ConvexCone ð•œ E} : S.blunt â†’ S.salient
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {g : Î² â†’ Î±} (hg : Set.InjOn g (Function.Support (f âˆ˜ g))) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ Set.Range g), f i)) = finsum (Î» (j : Î²), f (g j))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {n : WithTop â„•} (h : âˆ€ (m : â„•), â†‘m â‰¤ n â†’ Differentiable ð•œ (iteratedDeriv m f)) : ContDiff ð•œ n f
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) : s.monge_point = (â†‘(n + 1) / â†‘(n - 1)) â€¢ (Finset.centroid â„ Finset.univ s.points -áµ¥ s.circumcenter) +áµ¥ s.circumcenter
(R : Type u) [CommRing R] [StrongRankCondition R] (M : Type v) (N : Type w) [AddCommGroup M] [Module R M] [Module.Free R M] [AddCommGroup N] [Module R N] [Module.Free R N] : FiniteDimensional.finrank R (tensorProduct R M N) = FiniteDimensional.finrank R M * FiniteDimensional.finrank R N
{R : Type u} [CommRing R] [is_IsDomain R] {p : Polynomial R} {a : R} {n : â„•} (hzero : p â‰  0) (h : (Polynomial.x - â‡‘Polynomial.c a) ^ n âˆ£ p) : n â‰¤ Polynomial.rootMultiplicity a p
{Î¹ : Type u_1} {Î± : Type u_2} [Fintype Î¹] [DecidableEq Î±] (t : Î¹ â†’ Finset Î±) : (âˆ€ (s : Finset Î¹), s.card â‰¤ (s.bUnion t).card) â†” âˆƒ (f : Î¹ â†’ Î±), Function.Injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
{Î± : Type u_1} {Î² : Type u_2} {e e' : LocalEquiv Î± Î²} (h : e â‰ˆ e') : Set.EqOn â‡‘e â‡‘e' e.source
{ð•œ : Type u_1} [is_R_or_C ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {r : â„} (r_Pos : 0 < r) (c : â„) (f : E â†’â‚—[ð•œ] ð•œ) (h : âˆ€ (z : E), z âˆˆ Metric.ClosedBall 0 r â†’ âˆ¥â‡‘f zâˆ¥ â‰¤ c) (z : E) : âˆ¥â‡‘f zâˆ¥ â‰¤ c / r * âˆ¥zâˆ¥
{Î± : Type u} [emetricSpace Î±] {s : Set Î±} (hs : is_IsClosed s) : is_IsClosed {t : TopologicalSpace.Closeds Î± | â†‘t âŠ† s}
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} (hF : Continuous f) (x : Î±) (y : Î²) (h : f x = y) : Filter.Tendsto f (nhds x) (nhds y)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {n : WithTop â„•} (h : âˆ€ (x : E), x âˆˆ s â†’ (âˆƒ (u : Set E), is_IsOpen u âˆ§ x âˆˆ u âˆ§ ContDiffOn ð•œ n f (s âˆ© u))) : ContDiffOn ð•œ n f s
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} {t : CategoryTheory.Limits.Fork f g} (ht : CategoryTheory.Limits.IsLimit t) {Z Z' : C} (q : Z' âŸ¶ Z) (k : Z âŸ¶ t.X) : â†‘(â‡‘(CategoryTheory.Limits.Fork.IsLimit.homIso ht Z') (q â‰« k)) = q â‰« â†‘(â‡‘(CategoryTheory.Limits.Fork.IsLimit.homIso ht Z) k)
{ð•œ : Type u} [nondiscreteNormedField ð•œ] (f : localHomeomorph ð•œ ð•œ) {a f' : ð•œ} (ha : a âˆˆ f.to_local_equiv.target) (hF' : f' â‰  0) (htff' : HasDerivAt â‡‘f f' (â‡‘(f.symm) a)) : HasDerivAt â‡‘(f.symm) f'â»Â¹ a
{Î± : Type u} [topologicalSpace Î±] [t1_Space Î±] {s : Set Î±} (hs : Dense s) (x : Î±) [(nhdsWithin x {x}á¶œ).ne_IsBot] : Dense (s  {x})
{Î± : Type u_1} [PartialOrder Î±] [OrderTop Î±] {a : Î±} : IsCoatom a â†’ a â‹– âŠ¤
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [PartialOrder Î±] [t : OrderTopology Î±] {f g h : Î² â†’ Î±} {b : Filter Î²} {a : Î±} (hg : Filter.Tendsto g b (nhds a)) (hH : Filter.Tendsto h b (nhds a)) (hgf : âˆ€á¶  (b : Î²) in b, g b â‰¤ f b) (hfh : âˆ€á¶  (b : Î²) in b, f b â‰¤ h b) : Filter.Tendsto f b (nhds a)
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] : (âˆ€ (f : â„• â†’o (Submodule R M)áµ’áµˆ), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘f n = â‡‘f m) â†” IsArtinian R M
{R : Type u_1} [CommSemiring R] {M : Submonoid R} {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization M S] {g : R â†’+* P} (hg : âˆ€ (y : â†¥M), IsUnit (â‡‘g â†‘y)) {x y : R} (h : â‡‘(algebraMap R S) x = â‡‘(algebraMap R S) y) : â‡‘g x = â‡‘g y
{R : Type u_1} {a : R} [cancelMonoidWithZero R] (a0 : a â‰  0) : IsRegular a
{m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n
{A : Type u_1} {B : Type u_2} [CommRing A] [is_IsDomain A] [Ring B] [Algebra A B] {x : B} [is_IsDomain B] (hx : IsIntegral A x) : Irreducible (minpoly A x)
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semiNormedGroup Vâ‚] [semiNormedGroup Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_NormedGroupHom C hâˆ¥ â‰¤ C
{Î¹ : Type u_1} {Î± : Type u_2} {A : Î¹ â†’ Type u_3} [AddMonoid Î¹] [GradedMonoid.Gmonoid A] (l : List Î±) (f : Î± â†’ GradedMonoid A) : (List.map f l).prod = GradedMonoid.mk (l.dprod_Index (Î» (i : Î±), (f i).fst)) (l.dprod (Î» (i : Î±), (f i).fst) (Î» (i : Î±), (f i).snd))
{Î± : Type u_1} {R : Type u_2} {l : Filter Î±} {f : Î± â†’ R} {r : R} [linearOrderedSemiring R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto f l Filter.atTop) : Filter.Tendsto (Î» (x : Î±), f x * r) l Filter.atTop
{Î± : Type u} [HasSubset Î±] {a b : Î±} [IsRefl Î± HasSubset.Subset] : a = b â†’ b âŠ† a
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] [denselyOrdered Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhdsWithin a (Set.Iic a) â†” âˆƒ (l : Î±) (H : l âˆˆ Set.Iio a), Set.Icc l a âŠ† s
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : Polynomial A} (hp : â‡‘(Polynomial.aeval x) p = 0) : minpoly A x âˆ£ p
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î±'] [DecidableEq Î³] [DecidableEq Î´] {f : Î± â†’ Î² â†’ Î³} {s : Finset Î±} {t : Finset Î²} {g : Î³ â†’ Î´} {f' : Î² â†’ Î±' â†’ Î´} {g' : Î± â†’ Î±'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' b (g' a)) : Finset.image g (Finset.imageâ‚‚ f s t) = Finset.imageâ‚‚ f' t (Finset.image g' s)
{Î± : Type u} [Group Î±] : IsGroupHom Id
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] {f : Î² â†’ Î±} (hF : Continuous f) (xâ‚€ : Î²) (h : âˆ€á¶  (x : Î²) in Filter.cocompact Î², f x â‰¤ f xâ‚€) : âˆƒ (x : Î²), âˆ€ (y : Î²), f y â‰¤ f x
{Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Î± â†’ Set Î²} {y : Î²} (h : âˆ€ (x : Î±), x âˆˆ s â†’ y âˆˆ t x) : y âˆˆ â‹‚ (x : Î±) (H : x âˆˆ s), t x
(f : Circle_deg1_Lift) (P : â„ â†’ Prop) (h : âˆ€ (x : â„), x âˆˆ Set.Icc 0 1 â†’ P (â‡‘f x - x)) (x : â„) : P (â‡‘f x - x)
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : Î¹ â†’ P) (s : Finset Î¹) {n : â„•} (hc : s.card = n + 1) : FiniteDimensional.finrank k â†¥(vectorSpan k â†‘(Finset.image p s)) â‰¤ n
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] (e : localHomeomorph Î± Î²) {f : Î³ â†’ Î±} {s : Set Î³} {x : Î³} (hx : f x âˆˆ e.to_local_equiv.source) (h : f â»Â¹' e.to_local_equiv.source âˆˆ nhdsWithin x s) : ContinuousWithinAt f s x â†” ContinuousWithinAt (â‡‘e âˆ˜ f) s x
{Î± : Type u_1} {Î¹ : Type u_2} {f : Î¹ â†’ Î±} : Function.Injective f â†’ Pairwise (NE on f)
{Î± : Type u_1} {n : â„•} (s : Sym Î± n) : Sym.map (Î» (x : Î±), x) s = s
{k : Type u_1} {G : Type u_2} {V : Type u_3} [CommRing k] [Group G] [AddCommGroup V] [Module k V] (Ï : Representation k G V) [Nontrivial k] [Module.Free k V] [Module.Finite k V] : Ï.character 1 = â†‘(FiniteDimensional.finrank k V)
{k : Type u_1} {V1 : Type u_2} {V2 : Type u_4} [Ring k] [AddCommGroup V1] [Module k V1] [AddCommGroup V2] [Module k V2] (f : V1 â†’áµƒ[k] V2) : â‡‘f = â‡‘(f.linear) + Î» (z : V1), â‡‘f 0
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hD : DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Ioi 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Ioi 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz_re : z.re â‰¤ 0) (hz_im : 0 â‰¤ z.im) : âˆ¥f zâˆ¥ â‰¤ C
{L : FirstOrder.Language} {M : Type w} [L.Structure M] {p : M â†’ Prop} (x : M) {s : Set M} (hs : â‡‘(FirstOrder.Language.Substructure.closure L) s = âŠ¤) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (Hfun : âˆ€ {n : â„•} (f : L.functions n), FirstOrder.Language.ClosedUnder f (setOf p)) : p x
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {s : Set E} [CompleteSpace F] (h : AnalyticOn ð•œ f s) (n : â„•) : AnalyticOn ð•œ (iteratedFderiv ð•œ n f) s
{Î± : Type u_1} [Fintype Î±] (p q : Î± â†’ Prop) [Fintype {x // p x}] [Fintype {x // Â¬p x}] [Fintype {x // q x}] [Fintype {x // Â¬q x}] (h : Fintype.card {x // p x} = Fintype.card {x // q x}) : Fintype.card {x // Â¬p x} = Fintype.card {x // Â¬q x}
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : CategoryTheory.Presieve X} {P' : Cáµ’áµ– â¥¤ Type w} (i : P â‰… P') : CategoryTheory.Presieve.IsSheafFor P R â†’ CategoryTheory.Presieve.IsSheafFor P' R
{ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [NormedGroup G] [normedSpace ð•œ G] {f f' : ð•œ â†’ G} {s : Set ð•œ} {x y : ð•œ} {C : â„} (hF : âˆ€ (x : ð•œ), x âˆˆ s â†’ HasDerivWithinAt f (f' x) s x) (bound : âˆ€ (x : ð•œ), x âˆˆ s â†’ âˆ¥f' xâˆ¥ â‰¤ C) (hs : Convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {a : Î±} {s : Set Î±} (f : Î± â†’ M) (h : a âˆ‰ s) (hs : (s âˆ© Function.MulSupport f).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ HasInsert.insert a s), f i)) = f a * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} {s : Set E} (h : is_IsLocalMinOn f s a) (hF : HasFderivWithinAt f f' s a) {y : E} (hy : y âˆˆ PosTangentConeAt s a) : 0 â‰¤ â‡‘f' y
{J : Type u} [Preorder J] [IsDirected J LE.le] (F : Jáµ’áµ– â¥¤ Type v) [Î  (j : Jáµ’áµ–), Fintype (F.obj j)] [âˆ€ (j : Jáµ’áµ–), Nonempty (F.obj j)] : F.sections.nonempty
{M : Type u_1} [Semigroup M] [Nonempty M] (s : Set (Set M)) (sfin : s.finite) (scov : âŠ¤ âŠ† â‹ƒâ‚€s) : âˆƒ (c : Set M) (H : c âˆˆ s) (a : Stream M), Hindman.FP a âŠ† c
{E : Type u_4} [NormedGroup E] [normedSpace â„ E] {b : â„} {f : â„• â†’ â„} {z : â„• â†’ E} (hfa : Monotone f) (hF0 : Filter.Tendsto f Filter.atTop (nhds 0)) (hgb : âˆ€ (n : â„•), âˆ¥(Finset.range n).sum (Î» (i : â„•), z i)âˆ¥ â‰¤ b) : CauchySeq (Î» (n : â„•), (Finset.range (n + 1)).sum (Î» (i : â„•), f i â€¢ z i))
{Î± : Type u} [Semigroup Î±] [HasDistribNeg Î±] (a b : Î±) : -a âˆ£ b â†” a âˆ£ b
{R : Type u_1} [orderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_4} [Fintype Î¹] [DecidableEq Î¹] (e : Basis Î¹ R M) (x : Orientation R M Î¹) (f : M â‰ƒâ‚—[R] M) : â‡‘(Orientation.map Î¹ f) x = (â‡‘LinearEquiv.det f)â»Â¹ â€¢ x
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] : Finset.univ = Finset.map equiv.perm.decompose_option.symm.to_Embedding Finset.univ
{E : Type u_3} [semiNormedGroup E] {f : â„• â†’ E} (g : â„• â†’ â„) (hg : CauchySeq (Î» (n : â„•), (Finset.range n).sum (Î» (i : â„•), g i))) (hF : âˆ€ (i : â„•), âˆ¥f iâˆ¥ â‰¤ g i) : CauchySeq (Î» (n : â„•), (Finset.range n).sum (Î» (i : â„•), f i))
{E : Type u_2} [AddCommGroup E] [Module â„ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul â„ E] [t2_Space E] {s : Set E} (hs : s.finite) : is_IsClosed (â‡‘(convexHull â„) s)
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : M (Sum.inr ()) (Sum.inr ()) â‰  0) : (((Matrix.Pivot.listTransvecCol M).prod.mul M).mul (Matrix.Pivot.listTransvecRow M).prod).is_two_block_Diagonal
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : P) (direction : Submodule k V) : (AffineSubspace.mk' p direction).direction = direction
{Î± : Type u} [Preorder Î±] {a b c : Î±} : b = c â†’ a â‰¤ b â†’ a â‰¤ c
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (h : o.oangle x y = 0) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{Î± : Type u} (xs : List Î±) (x : Î±) [DecidableEq Î±] : [x].intercalate (List.splitOn x xs) = xs
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} {f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F} (hF : Continuous â‡‘f) {x : E} (hx : âˆ¥xâˆ¥ = 0) : âˆ¥â‡‘f xâˆ¥ = 0
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {a b : Î±} (h : Relation.ReflTransGen r a b) : âˆƒ (l : List Î±), List.Chain r a l âˆ§ (a :: l).last _ = b
{K : Type u} [Field K] (s : Subfield K) : 0 âˆˆ s
{A : Type u_1} [CommMonoid A] (a b c : A) : c âˆˆ Submonoid.closure {a, b} â†” âˆƒ (m n : â„•), a ^ m * b ^ n = c
{Î± : Type u_2} {Î¹ : Type u_5} [AddCommMonoid Î±] (t : Finset Î¹) (fâ‚ fâ‚‚ : Î¹ â†’ Set Î±) (hF : âˆ€ {i : Î¹}, i âˆˆ t â†’ fâ‚ i âŠ† fâ‚‚ i) : t.sum (Î» (i : Î¹), fâ‚ i) âŠ† t.sum (Î» (i : Î¹), fâ‚‚ i)
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topologicalSpace B] [topologicalSpace F] {Proj : Z â†’ B} [topologicalSpace Z] (e : TopologicalFiberBundle.Trivialization F Proj) {x : Z} (ex : x âˆˆ e.to_local_homeomorph.to_local_equiv.source) : ContinuousAt Proj x
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {v : n â†’ Î±} : IsUnit (Matrix.diagonal v) â†” IsUnit v
(r : â„) (h : r â‰  0) : r.sign = -1 âˆ¨ r.sign = 1
{a b c : â„¤} (h : fermat_42.minimal a b c) : IsCoprime a b
{Î± : Type u_1} [hasAdd Î±] [hasLt Î±] [ContravariantClass Î± Î± Add.add LT.lt] {a b c : Î±} (bc : a + b < a + c) : b < c
{Î± : Type u} [HasSubset Î±] [hasSsubset Î±] [isNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {a b : Î±} [IsAntisymm Î± HasSubset.Subset] (h : a âŠ† b) : a = b âˆ¨ a âŠ‚ b
{x y : Pgame} : x.lf y â†” (âˆƒ (i : y.left_moves), (âˆ€ (i' : x.left_moves), (x.move_Left i').lf (y.move_Left i)) âˆ§ âˆ€ (j : (y.move_Left i).right_moves), x.lf ((y.move_Left i).move_Right j)) âˆ¨ âˆƒ (j : x.right_moves), (âˆ€ (i : (x.move_Right j).left_moves), ((x.move_Right j).move_Left i).lf y) âˆ§ âˆ€ (j' : y.right_moves), (x.move_Right j).lf (y.move_Right j')
(R : Type u_1) {M : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) [Semiring S] [HasScalar R S] [Module S M] [isScalarTower R S M] : Submodule.span R s â‰¤ Submodule.restrictScalars R (Submodule.span S s)
{Î± : Type u} {Lâ‚ : List (Î± Ã— Bool)} {x : Î± Ã— Bool} : FreeGroup.Red [x] Lâ‚ â†” Lâ‚ = [x]
{Î± : Type u_1} [Lattice Î±] [IsModularLattice Î±] {Î² : Type u_2} {Î³ : Type u_3} [Preorder Î²] [PartialOrder Î³] (hâ‚ : WellFounded GT) (hâ‚‚ : WellFounded GT) (K : Î±) (fâ‚ : Î² â†’ Î±) (fâ‚‚ : Î± â†’ Î²) (gâ‚ : Î³ â†’ Î±) (gâ‚‚ : Î± â†’ Î³) (gci : GaloisCoinsertion fâ‚ fâ‚‚) (gi : GaloisInsertion gâ‚‚ gâ‚) (hF : âˆ€ (a : Î±), fâ‚ (fâ‚‚ a) = a âŠ“ K) (hg : âˆ€ (a : Î±), gâ‚ (gâ‚‚ a) = a âŠ” K) : WellFounded GT
(x : â„‚) : HasStrictDerivAt Complex.sin (Complex.cos x) x
{Î± : Type u_1} {Î¹ : Type u_3} [completeLattice Î±] {t : Î¹ â†’ Î±} (ht : CompleteLattice.Independent t) : Pairwise (Disjoint on t)
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [CommSemiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] (f : MultilinearMap R Mâ‚ Mâ‚‚) [Fintype Î¹] (c : Î¹ â†’ R) (m : Î  (i : Î¹), Mâ‚ i) : â‡‘f (Î» (i : Î¹), c i â€¢ m i) = finset.univ.prod (Î» (i : Î¹), c i) â€¢ â‡‘f m
{m n b : â„•} (hm : m â‰  1) (hn : 0 < n) (hb : Nat.log m n < b) : multiplicity m n = â†‘((Finset.filter (Î» (i : â„•), m ^ i âˆ£ n) (Finset.ico 1 b)).card)
{Î² Î± : Type u_1} (f : Î² â†’ Î±) (w : Cardinal.mk Î± < Cardinal.mk Î²) (w' : Infinite Î±) : âˆƒ (a : Î±), Infinite â†¥(f â»Â¹' {a})
{Î± : Type u} {Î² : Type v} [AddCommGroup Î²] (g h : FreeAbelianGroup Î± â†’+ Î²) (H : âˆ€ (x : Î±), â‡‘g (FreeAbelianGroup.of x) = â‡‘h (FreeAbelianGroup.of x)) : g = h
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] (b : Basis Î¹ R M) (e : Î¹ â‰ƒ Î¹') : Set.Range (â‡‘b âˆ˜ â‡‘(e.symm)) = Set.Range â‡‘b
{K : Type u_1} [linearOrderedField K] {v : K} {n : â„•} [floorRing K] (nth_Stream_Eq_None : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.none) : v = (GeneralizedContinuedFraction.of v).convergents (n - 1)
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : ContinuousMultilinearMap ð•œ E G) (m : Î  (i : Î¹), E i) (h : âˆ¥mâˆ¥ â‰¤ 1) : âˆ¥â‡‘f mâˆ¥ â‰¤ âˆ¥fâˆ¥
{Î± : Type u_1} {m : measurableSpace Î±} (s : Set Î±) : Nonempty {t // s âŠ† t âˆ§ MeasurableSet t}
{Î± : Type u_2} {Î² : Type u_3} : filter.cofinite.coprod Filter.cofinite = Filter.cofinite
{Î± : Type u_1} [uniformSpace Î±] : (Uniformity Î±).has_Basis (Î» (V : Set (Î± Ã— Î±)), V âˆˆ Uniformity Î± âˆ§ is_IsOpen V âˆ§ SymmetricRel V) Id
{Î± : Type u} [Ring Î±] {a b : Î±} : a âˆ£ b + a â†” a âˆ£ b
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [Preorder Î²] {a : Î±} {f : Î± â†’ Î²} (hâ‚ : StrictMonoOn f (Set.Iic a)) (hâ‚‚ : StrictMonoOn f (Set.Ici a)) : StrictMono f
{Î± : Type u_1} [Fintype Î±] [DecidableEq Î±] (h5 : 5 â‰¤ Fintype.card Î±) {f : Equiv.perm Î±} (hF : f.is_three_Cycle) : Subgroup.normalClosure {âŸ¨f, _âŸ©} = âŠ¤
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [linearOrderedAddCommGroup Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l Filter.atTop) : Filter.Tendsto (Î» (x : Î²), f x + g x) l Filter.atTop
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : ringChar F â‰  2) : finset.univ.sum (Î» (a : F), char.quadratic_Char F a) = 0
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) : â‡‘f 1 = 1
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) : Collinear k s â†” Module.rank k â†¥(vectorSpan k s) â‰¤ 1
{Î± : Type u} [topologicalSpace Î±] {s t : Set Î±} (hs : Dense s) (ht : Dense t) (hto : is_IsOpen t) : Dense (s âˆ© t)
{R : Type u_1} {Î¹â‚ : Type u_2} {Î¹â‚‚ : Type u_3} {Î¹â‚ƒ : Type u_4} {Î¹â‚„ : Type u_5} [CommSemiring R] [DecidableEq Î¹â‚] [DecidableEq Î¹â‚‚] [DecidableEq Î¹â‚ƒ] [DecidableEq Î¹â‚„] {Nâ‚ : Type u_6} [AddCommMonoid Nâ‚] [Module R Nâ‚] {Nâ‚‚ : Type u_7} [AddCommMonoid Nâ‚‚] [Module R Nâ‚‚] {N : Type u_8} [AddCommMonoid N] [Module R N] (a : MultilinearMap R (Î» (_x : Î¹â‚), N) Nâ‚) (b : MultilinearMap R (Î» (_x : Î¹â‚‚), N) Nâ‚‚) (Ïƒa : Î¹â‚ â‰ƒ Î¹â‚ƒ) (Ïƒb : Î¹â‚‚ â‰ƒ Î¹â‚„) : MultilinearMap.domDomCongr (Ïƒa.sum_congr Ïƒb) (a.dom_Coprod b) = (MultilinearMap.domDomCongr Ïƒa a).dom_Coprod (MultilinearMap.domDomCongr Ïƒb b)
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x : Î±} (h : s.nonempty) : x âˆˆ Closure s â†” Metric.infDist x s = 0
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
{Ï„ : Type u_1} {Î± : Type u_2} [CanonicallyOrderedAddMonoid Ï„] {Ï• : Ï„ â†’ Î± â†’ Î±} {s : Set Î±} (h : IsFwInvariant Ï• s) : IsInvariant Ï• s
{M : Type u_1} [MulOneClass M] {s : Set M} {S : Submonoid M} : Submonoid.closure s â‰¤ S â†” s âŠ† â†‘S
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {f : M â†’* N} (h : âˆ€ (y : â†¥S), IsUnit (â‡‘f â†‘y)) {y : â†¥S} {z : N} (H : â‡‘f â†‘y * z = 1) : â†‘(â‡‘(IsUnit.liftRight (f.restrict S) h) y)â»Â¹ = z
{Î± : Type u_1} [LinearOrder Î±] {s : Finset Î±} {k : â„•} (h : s.card = k) (hz : 0 < k) : â‡‘(s.order_emb_of_Fin h) âŸ¨k - 1, _âŸ© = s.max' _
{M : Type u} [Monoid M] {a : MË£} {x y : M} (h : SemiconjBy â†‘a x y) : SemiconjBy â†‘aâ»Â¹ y x
(X : AlgebraicGeometry.LocallyRingedSpace : algebraic_geometry.to_specÎ“ (AlgebraicGeometry.LocallyRingedSpaceÎ“.obj (Opposite.op X)) â‰« X.to_Î“_Spec.val.c.app (Opposite.op âŠ¤) = ðŸ™ (AlgebraicGeometry.LocallyRingedSpaceÎ“.obj (Opposite.op X))
{R : Type u_1} [normedRing R] {r : â„} (hr : 1 < r) : Coe =o[Filter.atTop] Î» (n : â„•), r ^ n
{Î± : Type u_1} {Î² : Type u_3} [measurableSpace Î±] [measurableSpace Î²] {Î½ : MeasureTheory.Measure Î²} [MeasureTheory.SigmaFinite Î½] {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) : Measurable (Î» (x : Î±), â‡‘Î½ (Prod.mk x â»Â¹' s))
{Î± : Type u} [pseudoMetricSpace Î±] {Î¹ : Type u_1} {fâ‚ fâ‚‚ : Î¹ â†’ Î±} {p : Filter Î¹} {a : Î±} (hâ‚ : Filter.Tendsto fâ‚ p (nhds a)) (h : Filter.Tendsto (Î» (x : Î¹), HasDist.dist (fâ‚ x) (fâ‚‚ x)) p (nhds 0)) : Filter.Tendsto fâ‚‚ p (nhds a)
{Î± : Type u_1} (f : Î± â†’ Set Î±) : Â¬Function.Surjective f
{E : Type u_1} {X : Type u_2} [innerProductSpace â„ E] [NormedGroup X] [normedSpace â„ X] {n : WithTop â„•} {c g : X â†’ E} {f : Î  (x : X), ContDiffBumpOfInner (c x)} {x : X} (hc : ContDiffAt â„ n c x) (hr : ContDiffAt â„ n (Î» (x : X), (f x).r) x) (hR : ContDiffAt â„ n (Î» (x : X), (f x).R) x) (hg : ContDiffAt â„ n g x) : ContDiffAt â„ n (Î» (x : X), â‡‘(f x) (g x)) x
{Î± : Type u_1} [linearOrderedField Î±] [Archimedean Î±] {x y : Î±} (xpos : 0 < x) (hx : x â‰¤ 1) (ypos : 0 < y) (hy : y < 1) : âˆƒ (n : â„•), y ^ (n + 1) < x âˆ§ x â‰¤ y ^ n
{R : Type u} [Ring R] (s : Subring R) {l : List R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
(K : Type u_1) [is_R_or_C K] (E : Type u_2) [NormedGroup E] [normedSpace K E] [FiniteDimensional K E] : ProperSpace E
{Î¹ : Type u_1} {X : Type u_2} [topologicalSpace X] [NormalSpace X] {u : Î¹ â†’ Set X} (uo : âˆ€ (i : Î¹), is_IsOpen (u i)) (uf : âˆ€ (x : X), {i : Î¹ | x âˆˆ u i}.finite) (uU : (â‹ƒ (i : Î¹), u i) = Set.Univ) : âˆƒ (v : Î¹ â†’ Set X), Set.Union v = Set.Univ âˆ§ (âˆ€ (i : Î¹), is_IsOpen (v i)) âˆ§ âˆ€ (i : Î¹), Closure (v i) âŠ† u i
{Î± : Type u} [pseudoEmetricSpace Î±] {s : Set Î±} {d : Ennreal} (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ HasEdist.edist x y â‰¤ d) : Emetric.diam s â‰¤ d
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) (f : V â‰ƒâ‚—áµ¢[â„] V) : (â‡‘(Orientation.map (Fin 2) f.to_linearEquiv) o).oangle x y = o.oangle (â‡‘(f.symm) x) (â‡‘(f.symm) y)
{Î± : Type u} {s : Set (Set Î±)} : Cardinal.mk â†¥s â‰¤ Cardinal.continuum â†’ Cardinal.mk â†¥{t : Set Î± | MeasurableSet t} â‰¤ Cardinal.continuum
{Î± : Type u_1} [topologicalSpace Î±] {s : Set Î±} (h : is_IsOpen s) : is_GÎ´ s
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {ð•œâ‚ƒ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semiNormedGroup E] [semiNormedGroup F] [semiNormedGroup G] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [nondiscreteNormedField ð•œâ‚ƒ] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] [normedSpace ð•œâ‚ƒ G] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} {Ïƒâ‚‚â‚ƒ : ð•œâ‚‚ â†’+* ð•œâ‚ƒ} {Ïƒâ‚â‚ƒ : ð•œ â†’+* ð•œâ‚ƒ} [RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [RingHomIsometric Ïƒâ‚â‚‚] [RingHomIsometric Ïƒâ‚‚â‚ƒ] (h : F â†’sl[Ïƒâ‚‚â‚ƒ] G) (f : E â†’sl[Ïƒâ‚â‚‚] F) : âˆ¥h.comp fâˆ¥ â‰¤ âˆ¥hâˆ¥ * âˆ¥fâˆ¥
{Î¹ : Type u_1} {E : Type u_3} [semiNormedGroup E] [CompleteSpace E] {f : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : Summable g) (h : âˆ€ (i : Î¹), âˆ¥f iâˆ¥ â‰¤ g i) : Summable f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s t : Set P} (ha : AffineIndependent k (Î» (x : â†¥t), â†‘x)) (hs : s âŠ† t) : AffineIndependent k (Î» (x : â†¥s), â†‘x)
{X : Top} {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥X) : CategoryTheory.Sieve.generate (Top.Presheaf.PresieveOfCovering U) âˆˆ â‡‘(Opens.grothendieckTopology â†¥X) (supr U)
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : MultilinearMap ð•œ E G) {C : â„} (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥f.mk_Continuous C Hâˆ¥ â‰¤ Linear_order.max C 0
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {b : Î²} {l : List Î±} : b âˆˆ List.map f l â†’ (âˆƒ (a : Î±), a âˆˆ l âˆ§ f a = b)
{Î± : Type u_1} {Î¹ : Type u_3} [completeLattice Î±] [Fintype Î¹] {f : Î¹ â†’ Î±} : CompleteLattice.Independent f â†” finset.univ.sup_indep f
{R : Type u_1} {a b : R} [AddSemigroup R] (rra : IsAddRightRegular a) (rrb : IsAddRightRegular b) : IsAddRightRegular (a + b)
{Î± : Type u_1} [uniformSpace Î±] {K U : Set Î±} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K âŠ† U) : âˆƒ (V : Set (Î± Ã— Î±)) (H : V âˆˆ Uniformity Î±), is_IsOpen V âˆ§ âˆ€ (x : Î±), x âˆˆ K â†’ UniformSpace.Ball x V âŠ† U
{Î± : Type u_2} [Group Î±] {s t : Set Î±} : Disjoint s t â†’ 1 âˆ‰ s / t
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {p : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) : ContinuousOn f (Emetric.Ball x r)
{n : â„•} (p : Fin (n + 1)) (i : Fin n) (h : p â‰¤ â‡‘fin.cast_Succ i) : â‡‘(p.succ_above) i = i.succ
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [uniformSpace Î²] [(Uniformity Î²).is_countably_generated] (f : Î± â†’ Î²) : is_GÎ´ {x : Î± | ContinuousAt f x}
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {v : V} {p : Î¹ â†’ P} : v âˆˆ vectorSpan k (Set.Range p) â†” âˆƒ (s : Finset Î¹) (w : Î¹ â†’ k) (h : s.sum (Î» (i : Î¹), w i) = 0), v = â‡‘(s.weighted_vsub p) w
{Î± : Type u_1} {Î² : Type u_2} {l : Filter Î±} {f : Î± â†’ Î²} {lb : Filter Î²} : Filter.Tendsto f l lb â†’ â†‘f.tendsto lb
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} {p0 : P} {s : Set Î¹} {p : Î¹ â†’ P} : (âˆƒ (fs : Finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = 1), p0 = â‡‘(fs.affine_combination p) w) â†” âˆƒ (fs : Finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = 1), p0 = â‡‘(fs.affine_combination (Î» (i : â†¥s), p â†‘i)) w
{a : Ennreal} : AddLeCancellable a â†” a â‰  âŠ¤
{R : Type u} [CommRing R] [is_IsDomain R] {p q : Polynomial R} (a : R) (hzero : p + q â‰  0) : Linear_order.min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) â‰¤ Polynomial.rootMultiplicity a (p + q)
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] [StrictConvexSpace â„ E] {x y z : E} : HasDist.dist x y + HasDist.dist y z = HasDist.dist x z â†” y âˆˆ Segment â„ x z
{ð•œ : Type u_1} {E : Type u_2} [normedLinearOrderedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] {A : Set E} {x : E} : x âˆˆ Set.ExposedPoints ð•œ A â†” IsExposed ð•œ A {x}
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (IH : âˆ€ (M : Matrix (Fin r) (Fin r) ð•œ), âˆƒ (Lâ‚€ Lâ‚€' : List (Matrix.TransvectionStruct (Fin r) ð•œ)) (Dâ‚€ : Fin r â†’ ð•œ), ((List.map Matrix.TransvectionStruct.toMatrix Lâ‚€).prod.mul M).mul (List.map Matrix.TransvectionStruct.toMatrix Lâ‚€').prod = Matrix.diagonal Dâ‚€) (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) : âˆƒ (L L' : List (Matrix.TransvectionStruct (Fin r âŠ• Unit) ð•œ)) (D : Fin r âŠ• Unit â†’ ð•œ), ((List.map Matrix.TransvectionStruct.toMatrix L).prod.mul M).mul (List.map Matrix.TransvectionStruct.toMatrix L').prod = Matrix.diagonal D
{Î± : Type u_1} [Preorder Î±] [hasAdd Î±] [HasSub Î±] [HasOrderedSub Î±] {a b : Î±} : a + b - b â‰¤ a
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} (h : Differentiable â„‚ f) (z : â„‚) {R : Nnreal} (hR : 0 < R) : HasFpowerSeriesOnBall f (cauchyPowerSeries f z â†‘R) z âŠ¤
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [HasLe Î²] {f g : Î± â†’ Î²} {a : Î±} (h : f â‰¤á¶ [nhds a] g) : âˆ€á¶  (y : Î±) in nhds a, f â‰¤á¶ [nhds y] g
{Î± : Type u} [metricSpace Î±] {x y : TopologicalSpace.NonemptyCompacts Î±} : HasDist.dist x y = Metric.hausdorffDist â†‘x â†‘y
{Î± : sort u} {f : Î± â†’ Î±} (h : Function.involutive f) (P : Prop) [Decidable P] (x : Î±) : f (Ite P x (f x)) = Ite (Â¬P) x (f x)
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {mÎ± : measurableSpace Î±} [measurableSpace Î²] [topologicalSpace Î²] [TopologicalSpace.PseudoMetrizableSpace Î²] [TopologicalSpace.SecondCountableTopology Î²] [OpensMeasurableSpace Î²] (hF : Measurable f) : MeasureTheory.StronglyMeasurable f
{R : Type u_1} [CommRing R] [is_IsDomain R] : Prime PowerSeries.x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type w} [CategoryTheory.Category J] (F : C â¥¤ D) [CategoryTheory.Limits.HasLimitsOfShape J D] [CategoryTheory.CreatesLimitsOfShape J F] : CategoryTheory.Limits.HasLimitsOfShape J C
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} : ContDiff ð•œ n Prod.snd
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (x : E) : â‡‘(reflection K) x = x â†” x âˆˆ K
{n n' m : â„•} (i : Fin n') (h : n' = n) : â‡‘(fin.add_Nat m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.add_Nat m) i)
(x : â„) : 0 â‰¤ expNegInvGlue x
{Î± : Type u_1} [canonicallyLinearOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b c : Î±} [ContravariantClass Î± Î± Add.add LE.le] (h : b â‰¤ a) : a - b < a - c â†” c < b
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimits C] : CategoryTheory.Limits.HasColimits Cáµ’áµ–
{M : Type u_1} [hasMul M] {p : M â†’ Prop} (x : M) {s : Set M} (hs : Subsemigroup.closure s = âŠ¤) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (HMul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) : p x
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f1 f2 : Î± â†’â‚€ M} (hD : Disjoint f1.support f2.support) {Î² : Type u_2} [CommMonoid Î²] (g : Î± â†’ M â†’ Î²) : (f1 + f2).prod g = f1.prod g * f2.prod g
{n : â„•} {F : Typevec (n + 1) â†’ Type u} [Mvfunctor F] [q : Mvqpf F] {Î± : Typevec n} (r : Mvqpf.Cofix F Î± â†’ Mvqpf.Cofix F Î± â†’ Prop) (h : âˆ€ (x y : Mvqpf.Cofix F Î±), r x y â†’ Mvfunctor.map (Typevec.id ::: Quot.mk r) x.dest = Mvfunctor.map (Typevec.id ::: Quot.mk r) y.dest) (x y : Mvqpf.Cofix F Î±) : r x y â†’ x = y
(x : PrimeSpectrum Punit) : False
{G : Type u_1} [Group G] [Fintype G] (p : â„•) [hp : Fact (Nat.Prime p)] (hdvd : p âˆ£ Fintype.card G) : âˆƒ (x : G), orderOf x = p
{ð•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [NormedGroup E] [NormedGroup Fâ‚—] [nondiscreteNormedField ð•œ] [normedSpace ð•œ E] [normedSpace ð•œ Fâ‚—] (f : E â†’L[ð•œ] Fâ‚—) (hF : UniformEmbedding â‡‘f) : âˆƒ (K : Nnreal), AntilipschitzWith K â‡‘f
{Î± : Type u} (s : Set Î±) : Cardinal.mk (â†¥ð’«s) = 2 ^ Cardinal.mk â†¥s
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [Module ð•œ Î²] [LinearOrder E] {s : Set E} {f : E â†’ Î²} (hs : Convex ð•œ s) (hF : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ð•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) : ConvexOn ð•œ s f
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] : Even (Finset.filter (Î» (v : V), Odd (G.degree v)) Finset.univ).card
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] (e : localHomeomorph Î± Î²) {f : Î² â†’ Î³} {x : Î²} (h : x âˆˆ e.to_local_equiv.target) : ContinuousAt f x â†” ContinuousAt (f âˆ˜ â‡‘e) (â‡‘(e.symm) x)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace E] [CompleteSpace â†¥K] : ContinuousLinearMap.id ð•œ E = K.subtypeL.comp (orthogonalProjection K) + Ká—®.subtypeL.comp (orthogonalProjection Ká—®)
{M : Type u_1} [AddCommMonoid M] (f s : â„• â†’ M) (h0 : s 0 = 0) (h : âˆ€ (n : â„•), s (n + 1) = s n + f n) (n : â„•) : (Finset.range n).sum (Î» (k : â„•), f k) = s n
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (sâ‚‚ : Finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘((Finset.map e sâ‚‚).weighted_vsub p) w = â‡‘(sâ‚‚.weighted_vsub (p âˆ˜ â‡‘e)) (w âˆ˜ â‡‘e)
{a b : â„•} : a â‹– b â†’ â†‘a â‹– â†‘b
{R : Type u} [Ring R] {M : Module R} {Î¹ : Type u_1} (b : Basis Î¹ R â†¥M) : CategoryTheory.Projective M
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b c : Î±} : a + b < c â†’ a < c - b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {fâ‚‚ : ð•œ â†’ F} {sâ‚‚ : Set ð•œ} {n : â„•} (hs : is_IsOpen sâ‚‚) : ContDiffOn ð•œ â†‘(n + 1) fâ‚‚ sâ‚‚ â†” DifferentiableOn ð•œ fâ‚‚ sâ‚‚ âˆ§ ContDiffOn ð•œ â†‘n (deriv fâ‚‚) sâ‚‚
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : C â¥¤ D) {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.span f f) F] [CategoryTheory.Epi (F.map f)] : CategoryTheory.Epi f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} (hs : is_IsOpen s) : ContDiffOn ð•œ âŠ¤ f s â†” DifferentiableOn ð•œ f s âˆ§ ContDiffOn ð•œ âŠ¤ (Î» (y : E), fderiv ð•œ f y) s
(v w : â„• â†’ â„•) (t : Omega.Nat.Preterm) : (âˆ€ (x : â„•), x < t.fresh_Index â†’ v x = w x) â†’ Omega.Nat.Preterm.val v t = Omega.Nat.Preterm.val w t
{Î± : Type u} [pseudoMetricSpace Î±] (x y : Î±) : HasDist.dist x y = (HasEdist.edist x y).to_Real
(L : FirstOrder.Language) {M : Type w} [Nonempty M] [L.Structure M] (s : Set M) (Îº : Cardinal) (h1 : Cardinal.aleph_0 â‰¤ Îº) (h2 : (Cardinal.mk â†¥s).lift â‰¤ Îº.lift) (h3 : L.card.lift â‰¤ Îº.lift) (h4 : Îº.lift â‰¤ (Cardinal.mk M).lift) : âˆƒ (S : L.elementary_Substructure M), s âŠ† â†‘S âˆ§ (Cardinal.mk â†¥S).lift = Îº.lift
{S : Set Ordinal} (f : Ordinal â†’ Ordinal) (hS : Set.Unbounded LT.lt S) : StrictMono f âˆ§ Set.Range f = S â†” f = Ordinal.enumOrd S
(Ee : List Omega.Ee) (c : Omega.Clause) : (Omega.eqElim Ee c).unsat â†’ c.unsat
{G : Type u_1} [AddGroup G] {N : Type u_2} [AddGroup N] (f : G â†’+ N) (hF : Function.Surjective â‡‘f) : f.range = âŠ¤
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (p : P) : â†‘(affineSpan k {p}) = {p}
{n : â„•} (a : Composition n) (b : Composition a.length) {i j : â„•} (hi : i < b.length) (hj : j < b.blocks_fun âŸ¨i, hiâŸ©) : a.size_Up_to (b.size_Up_to i + j) = (a.gather b).size_Up_to i + (a.sigma_Composition_aux b âŸ¨i, _âŸ©).size_Up_to j
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] {aâ‚ aâ‚‚ aâ‚ƒ : X} {bâ‚ bâ‚‚ bâ‚ƒ : Y} (Î³â‚ : Path aâ‚ aâ‚‚) (Î´â‚ : Path aâ‚‚ aâ‚ƒ) (Î³â‚‚ : Path bâ‚ bâ‚‚) (Î´â‚‚ : Path bâ‚‚ bâ‚ƒ) : (Î³â‚.prod Î³â‚‚).trans (Î´â‚.prod Î´â‚‚) = (Î³â‚.trans Î´â‚).prod (Î³â‚‚.trans Î´â‚‚)
(X : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens â†¥X) (f : â†¥(X.to_PresheafedSpace.presheaf.obj (Opposite.op U))) (h : âˆ€ (x : â†¥U), IsUnit (â‡‘(X.to_PresheafedSpace.presheaf.germ x) f)) : IsUnit f
{R : Type u_1} {a b : R} [Semigroup R] : IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b
{Î± : Type u} {Î² : Type v} [uniformSpace Î±] [SemilatticeSup Î²] {K : Set Î±} (hâ‚ : IsComplete K) {u : Î² â†’ Î±} (hâ‚‚ : âˆ€ (n : Î²), u n âˆˆ K) (hâ‚ƒ : CauchySeq u) : âˆƒ (v : Î±) (H : v âˆˆ K), Filter.Tendsto u Filter.atTop (nhds v)
{Î± : Type u} [t : topologicalSpace Î±] {s : Set (Set Î±)} (h_IsOpen : âˆ€ (u : Set Î±), u âˆˆ s â†’ is_IsOpen u) (h_nhds : âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ is_IsOpen u â†’ (âˆƒ (v : Set Î±) (H : v âˆˆ s), a âˆˆ v âˆ§ v âŠ† u)) : TopologicalSpace.IsTopologicalBasis s
{p q : â„•} [p_Prime : Fact (Nat.Prime p)] [q_Prime : Fact (Nat.Prime q)] (neq : p â‰  q) : padicNorm p â†‘q = 1
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b c : Î±} : bâ»Â¹ * a < c â†’ a < b * c
{M : Type u_1} [hasAdd M] (c : AddCon M) : AddCon.addKer Coe _ = c
{Î± : Type u_1} {Î¹ : Type u_3} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} [Fintype Î¹] {t : Î¹ â†’ Set Î±} (h : Pairwise (Disjoint on t)) (ht : âˆ€ (i : Î¹), (t i).finite) : finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒ (i : Î¹), t i), f a)) = finprod (Î» (i : Î¹), finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ t i), f a)))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {E' : Type u_6} [NormedGroup E'] [normedSpace ð•œ E'] {F' : Type u_7} [NormedGroup F'] [normedSpace ð•œ F'] {f : E â†’ F} {g : E' â†’ F'} (hF : ContDiff ð•œ n f) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Prod.map f g)
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D â¥¤ C} [CategoryTheory.Reflective i] {A : C} [CategoryTheory.SplitMono ((CategoryTheory.Adjunction.ofRightAdjoint i).unit.app A)] : A âˆˆ i.ess_image
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±} [topologicalSpace Î±] (h : ContinuousWithinAt f s x) (hg : Filter.Tendsto g p (nhdsWithin x s)) (hunif : âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : Set Î±) (H : t âˆˆ nhdsWithin x s), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
{Î± : Type u_1} {s : Set Î±} [measurableSpace Î±] (hs : s.infinite) : â‡‘MeasureTheory.Measure.count s = âŠ¤
{C : Type uâ‚} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : Cáµ’áµ– â¥¤ Type vâ‚} (x : S.functor âŸ¶ P) (g : Category_theory.yoneda.obj X âŸ¶ P) : S.functor_inclusion â‰« g = x â†” (â‡‘CategoryTheory.Presieve.natTransEquivCompatibleFamily x).val.is_amalgamation (â‡‘CategoryTheory.yonedaEquiv g)
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f g : Î± â†’ M} {s : Set Î±} (hF : (s âˆ© Function.MulSupport f).finite) (hg : (s âˆ© Function.MulSupport g).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i * g i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), g i))
{Î± : Type u_1} {E : Type u_2} (R : Type u_3) [AddCommGroup E] [divisionRing R] [Monoid Î±] [Module R E] [DistribMulAction Î± E] (n : â„¤) (s : Î±) (x : E) : (â†‘n)â»Â¹ â€¢ s â€¢ x = s â€¢ (â†‘n)â»Â¹ â€¢ x
(R : Type u_1) [hasOne R] [HasNeg R] : Cardinal.mk â†¥Set.Univ = Cardinal.mk R ^ 4
{Î± : Type u_1} [LinearOrder Î±] (s : Finset Î±) (hâ‚‚ : 1 < s.card) : s.min' _ < s.max' _
{X : Type u_1} [topologicalSpace X] (hX : âˆ€ {x y : X}, x â‰  y â†’ (âˆƒ (U : Set X) (h_IsClopen : is_IsClopen U), x âˆˆ U âˆ§ y âˆ‰ U)) : IsTotallyDisconnected Set.Univ
{A : Type u_1} {F : Type u_2} [MulZeroOneClass A] [monoidWithZeroHomClass F â„• A] (f g : F) (h_Pos : âˆ€ {n : â„•}, 0 < n â†’ â‡‘f n = â‡‘g n) : f = g
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ o.oangle x y = 0
{n : â„•} (p : Fin (n + 1)) (i : Fin n) : â‡‘fin.cast_Succ i < p âˆ¨ p â‰¤ â‡‘fin.cast_Succ i
{n : â„•} {i : Fin (n + 1)} (h : 0 < i) : 0 < â‡‘fin.cast_Succ i
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : HasInner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” InnerProductGeometry.angle x y = 0
{M : Type u_1} [commMonoidWithZero M] {p : M} {L : List M} (pp : Prime p) : p âˆ£ L.prod â†” âˆƒ (a : M) (H : a âˆˆ L), p âˆ£ a
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] : âˆ¥0âˆ¥ = 0
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
(X : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens â†¥X) (f : â†¥(X.to_PresheafedSpace.presheaf.obj (Opposite.op U))) (x : â†¥U) (h : IsUnit (â‡‘(X.to_PresheafedSpace.presheaf.germ x) f)) : âˆƒ (V : TopologicalSpace.Opens â†¥X) (i : V âŸ¶ U) (hxV : x.val âˆˆ V), IsUnit (â‡‘(X.to_PresheafedSpace.presheaf.map i.op) f)
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚‚} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J â¥¤ C} (e : K â‰Œ J) [CategoryTheory.Limits.HasColimit (e.functor â‹™ F)] : CategoryTheory.Limits.HasColimit F
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} (hs : s.nonempty) (ht : t.nonempty) (bs : Metric.Bounded s) (bt : Metric.Bounded t) : Emetric.hausdorffEdist s t â‰  âŠ¤
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) {C : â„} (Lt_hF' : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv f x < C) (x : â„) (H : x âˆˆ D) (y : â„) (H_1 : y âˆˆ D) : x < y â†’ f y - f x < C * (y - x)
{X : Type u_1} [topologicalSpace X] {s : Set X} (hs : IsSeqClosed s) {x : â„• â†’ X} (hmem : âˆ€ (n : â„•), x n âˆˆ s) {a : X} (ha : Filter.Tendsto x Filter.atTop (nhds a)) : a âˆˆ s
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {F : C â¥¤ D} {Y Y' : D} (h : Y â‰… Y') (hY : Y âˆˆ F.ess_image) : Y' âˆˆ F.ess_image
{M : Type u_1} [hasAdd M] {p : M â†’ Prop} (x : M) {s : Set M} (hs : AddSubsemigroup.closure s = âŠ¤) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (HMul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) : p x
{M : Type u_3} {N : Type u_4} [MulOneClass M] [MulOneClass N] {f g : M â†’* N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
{A : Type u} {B : Type v} {Î¹ : Type w} [CommRing A] [CommRing B] [Algebra A B] [Fintype Î¹] [DecidableEq Î¹] (b : Î¹ â†’ B) (P : Matrix Î¹ Î¹ A) : Algebra.discr A ((P.map â‡‘(algebraMap A B)).mul_vec b) = P.det ^ 2 * Algebra.discr A b
{Î± : sort u} [DecidableEq Î±] {Î² : sort u_1} (f : Î± â†’ Î²) (a' : Î±) (b : Î²) (a : Î±) : Function.update f a' b a = Ite (a = a') b (f a)
{Î± : Type u_1} {l : Filter Î±} {p : Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in l, p x) â†’ (âˆ€á¶  (s : Set Î±) in l.small_sets, âˆ€ (x : Î±), x âˆˆ s â†’ p x)
{n n' : â„•} (i : Fin n) (h : n.succ = n'.succ) : â‡‘(fin.cast h) i.succ = (â‡‘(fin.cast _) i).succ
{Î¹ : Type v} {Î¹' : Type v'} (f : Î¹ â†’ Cardinal) (f' : Î¹' â†’ Cardinal) (g : Î¹ â†’ Î¹') (h : âˆ€ (i : Î¹), (f i).lift â‰¤ (f' (g i)).lift) : (Cardinal.sup f).lift â‰¤ (Cardinal.sup f').lift
(R : Type u_5) [Semiring R] (M : Type u_1) [AddCommMonoid M] [Module R M] : Function.Surjective â‡‘(Finsupp.total M M R Id)
{X : Type u_1} [topologicalSpace X] [CompactSpace X] (A : Subalgebra â„ C(X, â„)) (w : A.separates_points) (f : C(X, â„)) : f âˆˆ A.topological_Closure
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] [DecidableEq V] : finset.univ.sum (Î» (v : V), G.degree v) = 2 * G.edge_finset.card
{C : Type uâ‚} [CategoryTheory.Category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {X : C} (S : CategoryTheory.Sieve X) (x : CategoryTheory.Equalizer.FirstObj P â‡‘S) : ((CategoryTheory.Equalizer.firstObjEqFamily P â‡‘S).hom x).compatible â†” CategoryTheory.Equalizer.Sieve.firstMap P S x = CategoryTheory.Equalizer.Sieve.secondMap P S x
(Fq F : Type) [Field Fq] [Fintype Fq] [Field F] [Algebra (Polynomial Fq) F] [Algebra (Ratfunc Fq) F] [isScalarTower (Polynomial Fq) (Ratfunc Fq) F] [FunctionField Fq F] [IsSeparable (Ratfunc Fq) F] : FunctionField.classNumber Fq F = 1 â†” IsPrincipalIdealRing â†¥(FunctionField.ringOfIntegers Fq F)
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] {a : Î±} (h : (Set.Iio a).nonempty) : Closure (Set.Iio a) = Set.Iic a
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : Fin 3 â†’ P) : AffineIndependent k p â†” Â¬Collinear k (Set.Range p)
{F : Type u_3} [Field F] [Fintype F] : ringChar F = 2 â†” Fintype.card F % 2 = 0
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] {F : Type v} [NormedGroup F] [normedSpace â„‚ F] {f : E â†’ F} (hF : Differentiable â„‚ f) (hb : Metric.Bounded (Set.Range f)) (z w : E) : f z = f w
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} [CategoryTheory.Limits.HasEqualizer f g] (h : f = g) : CategoryTheory.IsIso (CategoryTheory.Limits.equalizerÎ¹ f g)
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [denselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [topologicalSpace Î´] [OrderClosedTopology Î´] {s : Set Î±} [hs : s.ord_connected] {f : Î± â†’ Î´} (hF : ContinuousOn f s) {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) : Set.SurjOn f s (Set.Interval (f a) (f b))
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} : char.quadratic_Char F a = -1 â†” Â¬IsSquare a
{Î± : Type u_1} [topologicalSpace Î±] [NonUnitalNonAssocRing Î±] [TopologicalRing Î±] (x : Î±) : Continuous â‡‘(AddMonoidHom.mulLeft x)
(p : Prop) [Decidable p] : p âˆ¨ Â¬p
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : â†‘r < p.radius) : âˆƒ (a : â„) (H : a âˆˆ Set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C * a ^ n
{J : Type uâ‚} [CategoryTheory.Category J] [Nonempty J] {jâ‚€ : J} (h : âˆ€ (p : Set J), jâ‚€ âˆˆ p â†’ (âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ (jâ‚ âˆˆ p â†” jâ‚‚ âˆˆ p)) â†’ âˆ€ (j : J), j âˆˆ p) : CategoryTheory.IsConnected J
{M : Type u_1} [AddMonoid M] (s : addSubmonoid M) {l : List M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.sum âˆˆ s
{Î± : Type u_1} {Î² : Type u_2} (p : Pmf Î±) (f : Î± â†’ Pmf Î²) (s : Set Î²) [measurableSpace Î²] (hs : MeasurableSet s) : â‡‘((p.bind f).to_measure) s = âˆ‘' (a : Î±), â†‘(â‡‘p a) * â‡‘((f a).to_measure) s
{G : Type u_1} [Group G] (H : Subgroup G) : 1 âˆˆ H
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type uâ‚} [CategoryTheory.Category D] (h : C â‰Œ D) : CategoryTheory.IsCofiltered D
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x y : E) : is_R_or_C.abs (HasInner.inner x y) * is_R_or_C.abs (HasInner.inner y x) â‰¤ â‡‘is_R_or_C.re (HasInner.inner x x) * â‡‘is_R_or_C.re (HasInner.inner y y)
{a b c m : â„•} (hmc : m.gcd c = 1) (h : a * c â‰¡ b * c [Mod m]) : a â‰¡ b [Mod m]
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] {x : M} {s : Set M} {p : M â†’ Prop} (h : x âˆˆ Submodule.span R s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (H0 : p 0) (H1 : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (H2 : âˆ€ (a : R) (x : M), p x â†’ p (a â€¢ x)) : p x
{Î± : Type u_1} {Î¹ : sort u_3} [conditionallyCompleteLinearOrder Î±] {a : Î±} [Nonempty Î¹] {f : Î¹ â†’ Î±} (h : infi f < a) : âˆƒ (i : Î¹), f i < a
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {x : E} {n : WithTop â„•} (e : G â‰ƒL[ð•œ] E) : ContDiffWithinAt ð•œ n (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) (â‡‘(e.symm) x) â†” ContDiffWithinAt ð•œ n f s x
{M : Type u_6} {N : Type u_7} [hasMul M] [hasMul N] {f g : M â‰ƒ* N} (h : âˆ€ (x : M), â‡‘f x = â‡‘g x) : f = g
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] {L : C â¥¤ D} {R : D â¥¤ C} (Adj : L âŠ£ R) : R.final
(s b : â„) (hb : 0 < b) : Filter.Tendsto (Î» (x : â„), Real.exp (b * x) / x ^ s) Filter.atTop Filter.atTop
{R : Type u} {Î¹ : Type w} (s : Finset Î¹) [CommSemiring R] (f : Î¹ â†’ Polynomial R) (h : s.prod (Î» (i : Î¹), (f i).leading_Coeff) â‰  0) : (s.prod (Î» (i : Î¹), f i)).leading_Coeff = s.prod (Î» (i : Î¹), (f i).leading_Coeff)
{X : Top} {Y : TopologicalSpace.Opens â†¥X} (R : CategoryTheory.Presieve Y) : Top.Presheaf.PresieveOfCoveringAux (Top.Presheaf.coveringOfPresieve Y R) Y = R
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_3} [Fintype Î±] [Fintype Î²] [AddCommMonoid M] (e : Î± â†’ Î²) (hE : Function.bijective e) (f : Î± â†’ M) (g : Î² â†’ M) (h : âˆ€ (x : Î±), f x = g (e x)) : finset.univ.sum (Î» (x : Î±), f x) = finset.univ.sum (Î» (x : Î²), g x)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {x : E} {n : WithTop â„•} (g : F â†’L[ð•œ] G) (hF : ContDiffWithinAt ð•œ n f s x) : ContDiffWithinAt ð•œ n (â‡‘g âˆ˜ f) s x
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] {g1 g2 : G} (p : P) (h : g1 +áµ¥ p = g2 +áµ¥ p) : g1 = g2
{Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î± â†’ Prop) (s : Î² â†’ Î² â†’ Prop) [IsTrichotomous Î± r] [IsIrrefl Î² s] (f : Î± â†’ Î²) (hF : âˆ€ {x y : Î±}, r x y â†’ s (f x) (f y)) : Function.Injective f
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {f f' : Î± â†’ Î² â†’ Î³} {s : Set Î±} {t : Set Î²} (h : âˆ€ (a : Î±) (b : Î²), f a b = f' a b) : Set.image2 f s t = Set.image2 f' s t
{M : Type u_1} [hasAdd M] {c d : AddCon M} (H : c.to_Setoid = d.to_Setoid) : c = d
{C : Type u} [CategoryTheory.Category C] {X Y : C} [CategoryTheory.Limits.HasZeroMorphisms C] (f : X âŸ¶ Y) [CategoryTheory.Limits.HasKernel f] {Z : C} (h : Y âŸ¶ Z) [CategoryTheory.Limits.HasKernel (f â‰« h)] : CategoryTheory.Limits.kernelSubobject f â‰¤ CategoryTheory.Limits.kernelSubobject (f â‰« h)
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f g : V â†’â‚—[K] V} : f * g = 1 â†” g * f = 1
{V : Type u_1} [innerProductSpace â„ V] {x : V} (hx : x â‰  0) : InnerProductGeometry.angle (-x) x = Real.pi
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {p1 p2 : P} (p3 : P) (hp1 : p1 âˆˆ s) (hp2 : p2 âˆˆ s) : HasDist.dist p1 p3 = HasDist.dist p2 p3 â†” HasDist.dist p1 â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p3) = HasDist.dist p2 â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p3)
{M : Type u_1} [AddCommMonoid M] (S : addSubmonoid M) {Î¹ : Type u_2} {t : Finset Î¹} {f : Î¹ â†’ M} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.sum (Î» (c : Î¹), f c) âˆˆ S
{J : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] {Î± : Type uâ‚} (F : J â†’ Î±) (h : âˆ€ (jâ‚ jâ‚‚ : J), (jâ‚ âŸ¶ jâ‚‚) â†’ F jâ‚ = F jâ‚‚) (j j' : J) : F j = F j'
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {x : E} : p.radius - â†‘âˆ¥xâˆ¥â‚Š â‰¤ (p.change_origin x).radius
{R : Type u_1} [commMonoidWithZero R] (n : R) : IsPrimePow n â†” âˆƒ (p : R) (k : â„•), Prime p âˆ§ p ^ (k + 1) = n
(c : â„‚) (R : â„) : Function.Periodic (circleMap c R) (2 * Real.pi)
{Î± : Type u} [pseudoEmetricSpace Î±] (x y z : Î±) : HasEdist.edist x y â‰¤ HasEdist.edist z x + HasEdist.edist z y
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (sâ‚ sâ‚‚ : AffineSubspace â„ P) [Nonempty â†¥sâ‚] [Nonempty â†¥sâ‚‚] [CompleteSpace â†¥(sâ‚.direction)] [CompleteSpace â†¥(sâ‚‚.direction)] (p : P) : â‡‘(EuclideanGeometry.reflection sâ‚) p = â‡‘(EuclideanGeometry.reflection sâ‚‚) p â†” â†‘(â‡‘(EuclideanGeometry.orthogonalProjection sâ‚) p) = â†‘(â‡‘(EuclideanGeometry.orthogonalProjection sâ‚‚) p)
{E : Type u} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] {n : â„•} (a b : Fin (n + 1) â†’ â„) (hle : a â‰¤ b) (f : (Fin (n + 1) â†’ â„) â†’ Fin (n + 1) â†’ E) (f' : (Fin (n + 1) â†’ â„) â†’ ((Fin (n + 1) â†’ â„) â†’L[â„] Fin (n + 1) â†’ E)) (s : Set (Fin (n + 1) â†’ â„)) (hs : s.countable) (Hc : ContinuousOn f (Set.Icc a b)) (hD : âˆ€ (x : Fin (n + 1) â†’ â„), x âˆˆ set.univ.pi (Î» (i : Fin (n + 1)), Set.Ioo (a i) (b i))  s â†’ HasFderivAt f (f' x) x) (Hi : MeasureTheory.IntegrableOn (Î» (x : Fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : Fin (n + 1)), â‡‘(f' x) (Pi.single i 1) i)) (Set.Icc a b) MeasureTheory.MeasureSpace.volume) : âˆ« (x : Fin (n + 1) â†’ â„) in Set.Icc a b, finset.univ.sum (Î» (i : Fin (n + 1)), â‡‘(f' x) (Pi.single i 1) i) = finset.univ.sum (Î» (i : Fin (n + 1)), (âˆ« (x : Fin n â†’ â„) in Set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth (b i) x) i) - âˆ« (x : Fin n â†’ â„) in Set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth (a i) x) i)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : f =o[l] g â†” âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
{Î± : Type u_1} [hasAdd Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b c d : Î±} (hâ‚ : a < b) (hâ‚‚ : c < d) : a + c < b + d
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) (init : Fin E.order â†’ Î±) (n : Fin E.order) : E.mk_sol init â†‘n = init n
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cáµ’áµ– â¥¤ A) [CategoryTheory.Limits.HasProducts A] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Presheaf.IsSheaf J P â†” CategoryTheory.Presheaf.IsSheaf' J P
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} {ps : Set P} (h : ps âŠ† â†‘s) [Nonempty â†¥s] {n : â„•} [FiniteDimensional â„ â†¥(s.direction)] (hD : FiniteDimensional.finrank â„ â†¥(s.direction) = n) (hc : EuclideanGeometry.Cospherical ps) {sxâ‚ sxâ‚‚ : Affine.Simplex â„ P n} (hsxâ‚ : Set.Range sxâ‚.points âŠ† ps) (hsxâ‚‚ : Set.Range sxâ‚‚.points âŠ† ps) : sxâ‚.circumcenter = sxâ‚‚.circumcenter
{Î± : Type u_1} {Î² : Type u_2} [completeLattice Î±] (a : Î±) (f : Î² â†’ Î±) : (â¨… (o : Option Î²), Option.elim a f o) = a âŠ“ â¨… (b : Î²), f b
{M : Type u_6} {N : Type u_7} [hasAdd M] [hasAdd N] (e : M â‰ƒ+ N) (y : N) : â‡‘e (â‡‘(e.symm) y) = y
{Î² : Type u_4} [LinearOrder Î²] [NoMinOrder Î²] {u : â„• â†’ Î²} (hu : Filter.Tendsto u Filter.atTop Filter.atBot) (N : â„•) : âˆƒ (n : â„•) (H : n â‰¥ N), âˆ€ (k : â„•), k < n â†’ u n < u k
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [hasZero M] [CommMonoid N] (f : Î± â†’â‚€ M) (y : Î±) (g : Î± â†’ M â†’ N) (hg : âˆ€ (i : Î±), g i 0 = 1) : g y (â‡‘f y) * (Finsupp.erase y f).prod g = f.prod g
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] {p1 p2 p : P} : p1 -áµ¥ p = p2 -áµ¥ p â†” p1 = p2
{Î± : Type u} [linearOrderedRing Î±] {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Î± : Type u_1} [Subsingleton Î±] (s : Finset Î±) : s.card â‰¤ 1
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] {X Y : C} [CategoryTheory.Simple X] [CategoryTheory.Simple Y] {f : X âŸ¶ Y} (w : f â‰  0) : CategoryTheory.IsIso f
{p : â„•} {G : Type u_1} [Group G] (hG : is_p_Group p G) [hp : Fact (Nat.Prime p)] (Î± : Type u_2) [mulAction G Î±] [Fintype Î±] [Fintype â†¥(MulAction.FixedPoints G Î±)] : Fintype.card Î± â‰¡ Fintype.card â†¥(MulAction.FixedPoints G Î±) [Mod p]
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Simple 0] : False
{R : Type u_1} {a b : R} [AddMonoid R] (h : a + b = 0) : IsAddRightRegular a
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [AddCommGroup Î²] {f g : Î± â†’ Î²} (hF : IsAddGroupHom f) (hg : IsAddGroupHom g) : IsAddGroupHom (Î» (a : Î±), f a + g a)
{G : Type u_1} [Group G] [hN : Nontrivial G] : monoid.is_torsion_free G â†’ Â¬monoid.is_torsion G
{Î¹ : Type u_1} {R : Type u_2} (S : Type u_3) {M : Î¹ â†’ Type u_4} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (M i)] [Î  (i : Î¹), Module R (M i)] [AddCommMonoid N] [Module R N] [Semiring S] [Module S N] [SmulCommClass R S N] (F : Î  (i : Î¹), M i â†’â‚—[R] N) (i : Î¹) (x : M i) : â‡‘(â‡‘(Dfinsupp.lsum S) F) (Dfinsupp.single i x) = â‡‘(F i) x
{Î± : Type u_1} {g g' : GeneralizedContinuedFraction Î±} : g = g' â†” g.h = g'.h âˆ§ g.s = g'.s
{a : â„} {l : Filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Ioi a), HasDerivAt f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Ioi a), HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Ioi a), g' x â‰  0) (hfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds 0)) (hga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), f' x / g' x) (nhdsWithin a (Set.Ioi a)) l) : Filter.Tendsto (Î» (x : â„), f x / g x) (nhdsWithin a (Set.Ioi a)) l
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹} [topologicalSpace Î±] (h : TendstoLocallyUniformly F f p) (hc : âˆ€á¶  (n : Î¹) in p, Continuous (F n)) [p.ne_IsBot] : Continuous f
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization M S] {Î¹ : Type u_3} (s : Finset Î¹) (f : Î¹ â†’ S) : âˆƒ (b : â†¥M), âˆ€ (i : Î¹), i âˆˆ s â†’ IsLocalization.IsInteger R (â†‘b â€¢ f i)
(ð•œ : Type u_1) (E : Type u_2) [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] (v : Fin 1 â†’ E) : â‡‘(FormalMultilinearSeries.id ð•œ E 1) v = v 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X Y : AlgebraicGeometry.PresheafedSpace C} (Î± Î² : X âŸ¶ Y) (hâ‚ : Î± = Î²) (x x' : â†¥X) (hâ‚‚ : x = x') : AlgebraicGeometry.PresheafedSpace.stalkMap Î± x â‰« CategoryTheory.eqToHom _ = CategoryTheory.eqToHom _ â‰« AlgebraicGeometry.PresheafedSpace.stalkMap Î² x'
{Î± : Type u_1} {Î² : Type u_2} [hasAdd Î±] [Preorder Î±] [Preorder Î²] {f g : Î² â†’ Î±} [CovariantClass Î± Î± Add.add LE.le] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] (hF : StrictMono f) (hg : Monotone g) : StrictMono (Î» (x : Î²), f x + g x)
{Î± : Type u_1} [completeLattice Î±] {s : Set Î±} {b : Î±} : (âˆ€ (a : Î±), a âˆˆ s â†’ b â‰¤ a) â†’ (âˆ€ (w : Î±), b < w â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), a < w)) â†’ HasInf.inf s = b
{Î± : Type u_1} {E : Type u_3} [topologicalSpace Î±] [CompactSpace Î±] [NormedGroup E] (f : C(Î±, E)) {C : â„} (C0 : 0 â‰¤ C) : âˆ¥fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] [denselyOrdered Î²] {f : Î± â†’ Î²} (h_Mono : Monotone f) (h_Dense : DenseRange f) : Continuous f
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} (h : s âŠ† t) (ht : Metric.Bounded t) : Metric.diam s â‰¤ Metric.diam t
{Î¹ : sort u_1} {f : Î¹ â†’ Ennreal} {x : Ennreal} (h0 : x â‰  0) (h : x â‰  âŠ¤) : x * infi f = â¨… (i : Î¹), x * f i
{M : Type u_1} {N : Type u_2} [AddZeroClass M] [AddZeroClass N] (h : M â‰ƒ+ N) : IsAddHom â‡‘h
{M : Type u_1} [hasAdd M] (c : AddCon M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w + y) (x + z)
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (hs : TopologicalSpace.IsSeparable s) : TopologicalSpace.SeparableSpace â†¥s
{R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] {n : â„•} (H : âˆ€ (s : Finset M), LinearIndependent R (Î» (i : â†¥s), â†‘i) â†’ s.card â‰¤ n) (s : Set M) : LinearIndependent R Coe â†’ Cardinal.mk â†¥s â‰¤ â†‘n
{R : Type u} [Ring R] {S T : Subring R} (h : âˆ€ (x : R), x âˆˆ S â†” x âˆˆ T) : S = T
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
{Î± : sort u} : WellFounded emptyRelation
{Î± : Type u} {G : Type w} [topologicalSpace G] [hasInv G] [HasContinuousInv G] {f : Î± â†’ G} {l : Filter Î±} {y : G} (h : Filter.Tendsto f l (nhds y)) : Filter.Tendsto (Î» (x : Î±), (f x)â»Â¹) l (nhds yâ»Â¹)
{Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {f : Filter Î±} {l : Filter Î¹} [l.is_countably_generated] (hxy : âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.atTop l â†’ (âˆƒ (ms : â„• â†’ â„•), Filter.Tendsto (Î» (n : â„•), x (ns (ms n))) Filter.atTop f)) : Filter.Tendsto x l f
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f g : Î± â†’ M} {s : Set Î±} (hF : (s âˆ© Function.Support f).finite) (hg : (s âˆ© Function.Support g).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i + g i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), g i))
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (i : Fin r âŠ• Unit) : M.mul (Matrix.Pivot.listTransvecRow M).prod i (Sum.inr ()) = M i (Sum.inr ())
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {z : â„‚} {f : â„‚ â†’ E} (h : DifferentiableAt â„‚ f z) (hF' : deriv f z â‰  0) : ConformalAt f z
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] (a : R) : Module.IsTorsionBy R M a â†” Submodule.torsionBy R M a = âŠ¤
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] (eâ‚ eâ‚‚ : Basis Î¹ R M) : eâ‚.orientation = eâ‚‚.orientation â†” 0 < â‡‘(eâ‚.det) â‡‘eâ‚‚
{Î± : Type u} {l : List Î±} : l.attach.nodup â†’ l.nodup
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {s : Set E} (h : is_IsLocalMaxOn f s a) {y : E} (hy : y âˆˆ PosTangentConeAt s a) (hy' : -y âˆˆ PosTangentConeAt s a) : â‡‘(fderivWithin â„ f s a) y = 0
{A : Type u_1} {K : Type u_2} [CommRing A] [is_IsDomain A] [UniqueFactorizationMonoid A] [Field K] [Algebra A K] [IsFractionRing A K] {p : Polynomial A} {r : K} (hr : â‡‘(Polynomial.aeval r) p = 0) : IsFractionRing.num A r âˆ£ p.coeff 0
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (S : Subalgebra R A) (HS : S.to_submodule.fg) (x : A) (hx : x âˆˆ S) : IsIntegral R x
{R : Type u} [CommRing R] (U V : TopologicalSpace.Opens â†¥(AlgebraicGeometry.PrimeSpectrum.top R)) (iVU : V âŸ¶ U) : AlgebraicGeometry.StructureSheaf.comap (RingHom.id R) U V _ = (AlgebraicGeometry.Spec.structureSheaf R).val.map iVU.op
{M : Type u_1} [AddCommMonoid M] {s t : Set M} {x : M} : x âˆˆ Add_monoid.closure (s âˆª t) â†” âˆƒ (y : M) (H : y âˆˆ Add_monoid.closure s) (z : M) (H : z âˆˆ Add_monoid.closure t), y + z = x
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : âˆ¥x + yâˆ¥ = âˆ¥x - yâˆ¥ â†” InnerProductGeometry.angle x y = Real.pi / 2
{Î± : Type u} [pseudoEmetricSpace Î±] {Î´ : â„} {E : Set Î±} : is_IsOpen (Metric.Thickening Î´ E)
(u : Pnat.XgcdType) (hr : u.r â‰  0) : u.step.v = u.v.swap
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) : s âŠ† SpanPoints k s
{Î± : Type u_1} [Preorder Î±] [succOrder Î±] {a b : Î±} [NoMaxOrder Î±] : Order.succ a < Order.succ b â†’ a < b
{Î± : Type u_1} [GeneralizedBooleanAlgebra Î±] [DecidableRel Disjoint] [DecidableRel LE.le] {s : Finset Î±} {u v a : Î±} (ha : a âˆˆ Uv.compression u v s) (hva : v â‰¤ a) (hvu : v = âŠ¥ â†’ u = âŠ¥) : a âˆˆ s
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {f : â„‚ â†’ E} (hD : DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Ioi 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Ioi 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.i) = 0) : Set.EqOn f 0 {z : â„‚ | z.re â‰¤ 0 âˆ§ 0 â‰¤ z.im}
{Î± : Type u_3} {Î² : Type u_4} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Monotone f) (h : âˆ€ (b : Î²), âˆƒ (a : Î±), b â‰¤ f a) : Filter.Tendsto f Filter.atTop Filter.atTop
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} : Differentiable ð•œ f â†’ Mdifferentiable (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f
{Î± : Type u_1} [linearOrderedField Î±] {a : Î±} (a2 : 2 â‰¤ a) : (1 - 1 / a)â»Â¹ â‰¤ 2
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (R : D â¥¤ C) [CategoryTheory.Limits.HasLimitsOfSize C] [CategoryTheory.Reflective R] : CategoryTheory.Limits.HasLimitsOfSize D
(ð•œ : Type v) [is_R_or_C ð•œ] {E : Type u} [NormedGroup E] [normedSpace ð•œ E] [Nontrivial E] (x : E) : âˆƒ (g : E â†’L[ð•œ] ð•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
{R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} {s : S} [HasScalar R M] [HasScalar R S] [HasScalar S M] [isScalarTower R S M] (ra : IsSmulRegular M a) (rs : IsSmulRegular M s) : IsSmulRegular M (a â€¢ s)
{G : Type u} [Group G] (H : Subgroup G) (h : Subsingleton (G â§¸ H)) : H = âŠ¤
{Î± : Type u_1} {n : Type u_3} {m : Type u_4} {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} (hA : A.is_Symm) (hBC : B.transpose = C) (hD : D.is_Symm) : (Matrix.fromBlocks A B C D).is_Symm
{M : Type u_1} [Semigroup M] {a : Stream M} {m : M} (hm : m âˆˆ Hindman.FP a) : âˆƒ (n : â„•), âˆ€ (m' : M), m' âˆˆ Hindman.FP (stream.drop n a) â†’ m * m' âˆˆ Hindman.FP a
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : hb.oangle x y = Î¸ â†” âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(hb.rotation Î¸) x
{ð•œ : Type u_1} {E : Type u_2} [linearOrderedField ð•œ] [OrderedAddCommGroup E] [Module ð•œ E] {s : Set E} (hs : Convex ð•œ s) : IsLeast {t : ConvexCone ð•œ E | s âŠ† â†‘t} (Convex.toCone s hs)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} {f : ð•œ â†’ F} {s : Set ð•œ} {x : ð•œ} {m : Fin n â†’ ð•œ} : â‡‘(iteratedFderivWithin ð•œ n f s x) m = finset.univ.prod (Î» (i : Fin n), m i) â€¢ iteratedDerivWithin n f s x
(c : â„‚) : â‡‘CliffordAlgebraComplex.ofComplex (â‡‘(starRingEnd â„‚) c) = â‡‘CliffordAlgebra.involute (â‡‘CliffordAlgebraComplex.ofComplex c)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (f : V â‰ƒâ‚—áµ¢[â„] V) : âˆƒ (Î¸ : Real.Angle), f = hb.rotation Î¸ âˆ¨ f = hb.conj_lie.trans (hb.rotation Î¸)
{Î¹ : Type u} (s : Finset Î¹) (w z : Î¹ â†’ Nnreal) (hw' : s.sum (Î» (i : Î¹), w i) = 1) : s.prod (Î» (i : Î¹), z i ^ â†‘(w i)) â‰¤ s.sum (Î» (i : Î¹), w i * z i)
{x : â„} (lx : Liouville x) : Transcendental â„¤ x
{f : â„ â†’ â„} {a b : â„} (hfi : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (h : âˆ€ (x : â„), 0 < f x) (hab : a < b) : 0 < âˆ« (x : â„) in a..b, f x
{A B C D B' D' : semiNormedGroup} {fab : A âŸ¶ B} {fbd : B âŸ¶ D} {fac : A âŸ¶ C} {fcd : C âŸ¶ D} {h : fab â‰« fbd = fac â‰« fcd} {fbb' : B âŸ¶ B'} {fdd' : D âŸ¶ D'} {condb : fab â‰« fbb' = 0} {condd : fcd â‰« fdd' = 0} {g : B' âŸ¶ D'} (h' : fbb' â‰« g = fbd â‰« fdd') : SemiNormedGroup.explicit_Cokernel_Desc condb â‰« g = SemiNormedGroup.explicit_cokernel.map h â‰« SemiNormedGroup.explicit_Cokernel_Desc condd
{R : Type u_1} [Semiring R] (p : Polynomial R) : â‡‘Polynomial.toLaurent p = Finsupp.mapDomain Coe p.to_Finsupp
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [NormedGroup F] [normedSpace â„ F] {f : E â†’ F} {p : E â†’ FormalMultilinearSeries â„ E F} {s : Set E} {x : E} (hF : HasFtaylorSeriesUpToOn 1 f p (HasInsert.insert x s)) (hs : Convex â„ s) : âˆƒ (K : Nnreal) (t : Set E) (H : t âˆˆ nhdsWithin x s), LipschitzOnWith K f t
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] {m : M} {s : Set M} : m âˆˆ Submodule.span R s â†” âˆƒ (c : M â†’â‚€ R), â†‘(c.support) âŠ† s âˆ§ c.sum (Î» (mi : M) (r : R), r â€¢ mi) = m
{X : Type u_1} {Y : Type u_2} {f : X â†’ Y} (hF : Function.Injective f) : TopologicalSpace.induced f âŠ¥ = âŠ¥
{Î± : Type u_1} {f : Î± â†’ Ennreal} (hF : âˆ‘' (x : Î±), f x â‰  âŠ¤) : Filter.Tendsto (Î» (s : Finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) Filter.atTop (nhds 0)
(ð•œ : Type u_1) (E : Type u_2) [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] {n : â„•} (h : n â‰  1) : FormalMultilinearSeries.id ð•œ E n = 0
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [topologicalSpace Î±] [pseudoMetricSpace Î²] [pseudoMetricSpace Î³] {G : Î² â†’ Î³} {C : Nnreal} (H : LipschitzWith C G) : LipschitzWith C (BoundedContinuousFunction.comp G H)
{Î“ : Type u_1} [Inhabited Î“] (l : Turing.ListBlank Î“) : Turing.ListBlank.cons l.head l.tail = l
{G : Type u_1} [AddGroup G] {H : AddSubgroup G} {N : Type u_3} [AddGroup N] (f : N â†’+ G) : AddSubgroup.comap f H.normalizer â‰¤ (AddSubgroup.comap f H).normalizer
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {v : â„ â†’ E â†’ E} {s : â„ â†’ Set E} {K : â„} (hv : âˆ€ (t : â„) (x : E), x âˆˆ s t â†’ âˆ€ (y : E), y âˆˆ s t â†’ HasDist.dist (v t x) (v t y) â‰¤ K * HasDist.dist x y) {f g f' g' : â„ â†’ E} {a b Îµf Îµg Î´ : â„} (hF : ContinuousOn f (Set.Icc a b)) (hF' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' t) (Set.Ici t) t) (f_bound : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDist.dist (f' t) (v t (f t)) â‰¤ Îµf) (hfs : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ f t âˆˆ s t) (hg : ContinuousOn g (Set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDerivWithinAt g (g' t) (Set.Ici t) t) (g_bound : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ HasDist.dist (g' t) (v t (g t)) â‰¤ Îµg) (hgs : âˆ€ (t : â„), t âˆˆ Set.Ico a b â†’ g t âˆˆ s t) (ha : HasDist.dist (f a) (g a) â‰¤ Î´) (t : â„) (H : t âˆˆ Set.Icc a b) : HasDist.dist (f t) (g t) â‰¤ gronwallBound Î´ K (Îµf + Îµg) (t - a)
{M : Type u_1} [hasAdd M] {c d : AddCon M} {x y : M} : â‡‘(c âŠ“ d) x y â†” â‡‘c x y âˆ§ â‡‘d x y
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] (hfp : Algebra.FinitePresentation R A) (e : A â‰ƒâ‚[R] B) : Algebra.FinitePresentation R B
{Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), Monoid (M i)] (w : FreeProduct.Word M) (h : w â‰  FreeProduct.Word.empty) : âˆƒ (i j : Î¹) (w' : FreeProduct.Neword M i j), w'.to_Word = w
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i â‰¤ â‡‘fin.cast_Succ j) : X.Î´ (â‡‘fin.cast_Succ i) â‰« X.Ïƒ j.succ = X.Ïƒ j â‰« X.Î´ i
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {n : WithTop â„•} (hF : IsBoundedLinearMap ð•œ f) : ContDiff ð•œ n f
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] (ht : âˆ€ (y : Î²), y âˆ‰ t â†’ 0 â‰¤ (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)) (hb : s.sum (Î» (x : Î±), w x) < t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) < b
{A : Type u_1} [CommRing A] [Algebra â„š A] (k : â„•) : PowerSeries.exp A ^ k = â‡‘(PowerSeries.rescale â†‘k) (PowerSeries.exp A)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â‰ƒL[ð•œ] F} {g : F â†’ E} {a : F} (hg : ContinuousAt g a) (hF : HasStrictFderivAt f â†‘f' (g a)) (hfg : âˆ€á¶  (y : F) in nhds a, f (g y) = y) : HasStrictFderivAt g â†‘(f'.symm) a
(X : Type u) [metricSpace X] [CompactSpace X] [Nonempty X] (Y : Type v) [metricSpace Y] [CompactSpace Y] [Nonempty Y] : âˆƒ (Î¦ : X â†’ â†¥(Lp (Î» (n : â„•), â„) âŠ¤)) (Î¨ : Y â†’ â†¥(Lp (Î» (n : â„•), â„) âŠ¤)), Isometry Î¦ âˆ§ Isometry Î¨ âˆ§ Gromov_Hausdorff.GH_dist X Y = Metric.hausdorffDist (Set.Range Î¦) (Set.Range Î¨)
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Vâ‚‚ : Type v'} [AddCommGroup Vâ‚‚] [Module K Vâ‚‚] (f : V â†’â‚—[K] Vâ‚‚) (w : Function.Surjective â‡‘f) [FiniteDimensional K V] : FiniteDimensional K Vâ‚‚
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [NormedGroup F] [normedSpace â„ F] {x : E} {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€ (y : E), HasFderivAt f (f' y) y) (hx : HasFderivAt f' f'' x) (v w : E) : â‡‘(â‡‘f'' v) w = â‡‘(â‡‘f'' w) v
{Î± : Type u_1} {Î¹' : sort u_5} [completeLattice Î±] (s : Î¹' â†’ Î±) : (â¨… (i : Î¹'), s i) = â¨… (t : Finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {f : V â‰ƒâ‚—áµ¢[â„] V} (hD : â‡‘LinearMap.det â†‘(f.to_linearEquiv) < 0) : âˆƒ (Î¸ : Real.Angle), f = hb.conj_lie.trans (hb.rotation Î¸)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {X Y : C} (f g : X âŸ¶ Y) : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [AddZeroClass M] [CommMonoid N] {f g : Î± â†’â‚€ M} {h : Î± â†’ M â†’ N} (h_Zero : âˆ€ (a : Î±), h a 0 = 1) (h_Add : âˆ€ (a : Î±) (bâ‚ bâ‚‚ : M), h a (bâ‚ + bâ‚‚) = h a bâ‚ * h a bâ‚‚) : (f + g).prod h = f.prod h * g.prod h
{R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring Râ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {s : Set M} {f g : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (H : Set.EqOn â‡‘f â‡‘g s) : Set.EqOn â‡‘f â‡‘g â†‘(Submodule.span R s)
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] {p1 p2 p : P} (h : p1 -áµ¥ p = p2 -áµ¥ p) : p1 = p2
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) {u : â„• â†’ Î±} {init : Fin E.order â†’ Î±} (h : E.is_solution u) (HEq : âˆ€ (n : Fin E.order), u â†‘n = init n) : u = E.mk_sol init
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = Real.pi) : HasDist.dist p1 p3 = HasDist.dist p1 p2 + HasDist.dist p3 p2
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {s : Set E} {x : E} : MdifferentiableWithinAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f s x â†” DifferentiableWithinAt ð•œ f s x
{M : Type u} [Monoid M] (x : M) (n : â„•) : MulOpposite.op (x ^ n) = MulOpposite.op x ^ n
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±} (h : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) â‰  0) : âˆƒ (x : Î±) (H : x âˆˆ s), f x â‰  0
{b x c : Ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c â‰¤ x â†” c â‰¤ Ordinal.log b x
(G : Type u_1) [Group G] : group.is_nilpotent G â†” âˆƒ (n : â„•) (H : â„• â†’ Subgroup G), IsDescendingCentralSeries H âˆ§ H n = âŠ¥
{Î² : Type u} {Î± : Type v} {s : Finset Î±} {a : Î±} {f : Î± â†’ Î²} [CommMonoid Î²] [DecidableEq Î±] (h : f a = 1) : (HasInsert.insert a s).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
 : Function.Injective Fin
{R : Type u} [commSemigroup R] [starSemigroup R] (x y : R) : HasStar.star (x * y) = HasStar.star x * HasStar.star y
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] {f : Î² â†’ Î±} {l : Filter Î²} {s : Set Î²} {a : Î±} (h : âˆ€ (x : Î²), x âˆ‰ s â†’ f x = a) : Filter.Tendsto f (l âŠ“ Filter.principal s) (nhds a) â†” Filter.Tendsto f l (nhds a)
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] (s : Set R) : Submodule.torsionBySet R M s = Submodule.torsionBySet R M â†‘(Ideal.span s)
{V : Type u_1} [NormedGroup V] [Nontrivial V] : âˆ¥NormedGroupHom.id Vâˆ¥ = 1
{R K : Type u} [CommRing R] [Field K] [Algebra R K] [IsAlgClosed K] {Î¹ : Type u} (v : Î¹ â†’ K) [Nontrivial R] (hv : IsTranscendenceBasis R v) (hR : Cardinal.mk R â‰¤ Cardinal.aleph_0) (hK : Cardinal.aleph_0 < Cardinal.mk K) : Cardinal.mk K = Cardinal.mk Î¹
{M : Type u_1} [MulOneClass M] (c : Con M) : Con.ker c.mk' = c
{k : Type u_1} {M : Type u_2} [orderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] [CovariantClass M M Add.add LT.lt] [ContravariantClass M M Add.add LT.lt] {a b : k} {c d : M} (hab : a < b) (hcd : c < d) : a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d
{Î± : Type u_1} [uniformSpace Î±] : (â¨† (x : Î±), nhds (x, x)) â‰¤ Uniformity Î±
{X : Type u_2} [emetricSpace X] (m : Set X â†’ Ennreal) : (MeasureTheory.OuterMeasure.mkMetric' m).is_metric
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {f : M â†’* N} (h : âˆ€ (y : â†¥S), IsUnit (â‡‘f â†‘y)) {xâ‚ xâ‚‚ : M} {yâ‚ yâ‚‚ : â†¥S} : â‡‘f xâ‚ * â†‘(â‡‘(IsUnit.liftRight (f.restrict S) h) yâ‚)â»Â¹ = â‡‘f xâ‚‚ * â†‘(â‡‘(IsUnit.liftRight (f.restrict S) h) yâ‚‚)â»Â¹ â†” â‡‘f (xâ‚ * â†‘yâ‚‚) = â‡‘f (xâ‚‚ * â†‘yâ‚)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {f : E â†’ F} (hF : ContDiff ð•œ n f) : ContDiff ð•œ n (Î» (x : E), -f x)
{A : Type u_1} {R : Type u_2} (K : Type u_3) [CommRing A] [is_IsDomain A] [NormalizedGcdMonoid A] [Field K] [CommRing R] [is_IsDomain R] [Algebra A K] [IsFractionRing A K] [Algebra K R] [Algebra A R] [isScalarTower A K R] {x : R} (hx : IsIntegral A x) {P : Polynomial A} (hprim : P.is_primitive) (hroot : â‡‘(Polynomial.aeval x) P = 0) : minpoly A x âˆ£ P
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [FiniteDimensional â„ â†¥(s.direction)] (hD : FiniteDimensional.finrank â„ â†¥(s.direction) = 2) {câ‚ câ‚‚ pâ‚ pâ‚‚ p : P} (hcâ‚s : câ‚ âˆˆ s) (hcâ‚‚s : câ‚‚ âˆˆ s) (hpâ‚s : pâ‚ âˆˆ s) (hpâ‚‚s : pâ‚‚ âˆˆ s) (hps : p âˆˆ s) {râ‚ râ‚‚ : â„} (hc : câ‚ â‰  câ‚‚) (hp : pâ‚ â‰  pâ‚‚) (hpâ‚câ‚ : HasDist.dist pâ‚ câ‚ = râ‚) (hpâ‚‚câ‚ : HasDist.dist pâ‚‚ câ‚ = râ‚) (hpcâ‚ : HasDist.dist p câ‚ = râ‚) (hpâ‚câ‚‚ : HasDist.dist pâ‚ câ‚‚ = râ‚‚) (hpâ‚‚câ‚‚ : HasDist.dist pâ‚‚ câ‚‚ = râ‚‚) (hpcâ‚‚ : HasDist.dist p câ‚‚ = râ‚‚) : p = pâ‚ âˆ¨ p = pâ‚‚
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {Î¹ : Type u_6} [DecidableEq Î¹] (f : AlternatingMap R M N Î¹) : f.comp_Linear_Map LinearMap.id = f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {s : Set E} {g : F â†’ G} {f : E â†’ F} (hg : ContDiff ð•œ n g) (hF : ContDiffOn ð•œ n f s) : ContDiffOn ð•œ n (g âˆ˜ f) s
{n : â„•} (u v : Î£ (c : Composition n), Î  (i : Fin c.length), Composition (c.blocks_fun i)) : u = v â†” List.ofFn (Î» (i : Fin u.fst.length), (u.snd i).blocks) = List.ofFn (Î» (i : Fin v.fst.length), (v.snd i).blocks)
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ List.Nat.antidiagonal n â†” x.fst + x.snd = n
{a b : â„} : IntervalIntegrable (Î» (x : â„), xâ»Â¹) MeasureTheory.MeasureSpace.volume a b â†” a = b âˆ¨ 0 âˆ‰ Set.Interval a b
(ð•œ : Type u_1) [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] (x : E) : extChartAt (modelWithCornersSelf ð•œ E) x = LocalEquiv.refl E
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {f : â„ â†’ E} {g : â„ â†’ F} {a b : â„} (l : Filter â„) [l.ne_IsBot] [Filter.TendstoIxxClass Set.Icc l l] (hl : Set.Interval a b âˆˆ l) (hD : âˆ€á¶  (x : â„) in l, DifferentiableAt â„ f x) (hF : Filter.Tendsto (Î» (x : â„), âˆ¥f xâˆ¥) l Filter.atTop) (hfg : deriv f =O[l] g) : Â¬IntervalIntegrable g MeasureTheory.MeasureSpace.volume a b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} [CompleteSpace E] (f : localHomeomorph E F) {fâ‚€' : E â‰ƒL[ð•œ] F} {a : F} (ha : a âˆˆ f.to_local_equiv.target) (hFâ‚€' : HasFderivAt â‡‘f â†‘fâ‚€' (â‡‘(f.symm) a)) (hF : ContDiffAt ð•œ n â‡‘f (â‡‘(f.symm) a)) : ContDiffAt ð•œ n â‡‘(f.symm) a
(Î± : Type u_1) [hasZero Î±] [hasOne Î±] (n : â„•) : Matrix.circulant (Î» (i : Fin n), Ite (â†‘i = 0) 1 0) = 1
{m : Type u_1} {R : Type u_2} [Fintype m] [CommRing R] {M : Matrix m m R} (hM : M.nondegenerate) {v : m â†’ R} (hv : v â‰  0) : âˆƒ (w : m â†’ R), Matrix.dotProduct v (M.mul_vec w) â‰  0
{R : Type u_4} [normedRing R] [CompleteSpace R] (x : R) (h : âˆ¥xâˆ¥ < 1) : âˆ¥âˆ‘' (n : â„•), x ^ nâˆ¥ â‰¤ âˆ¥1âˆ¥ - 1 + (1 - âˆ¥xâˆ¥)â»Â¹
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [rÎ± : NonAssocSemiring Î±] [rÎ² : NonAssocSemiring Î²] {rÎ³ : NonAssocSemiring Î³} {Î´ : Type u_1} {rÎ´ : NonAssocSemiring Î´} (f : Î± â†’+* Î²) (g : Î² â†’+* Î³) (h : Î³ â†’+* Î´) : (h.comp g).comp f = h.comp (g.comp f)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {sâ‚ sâ‚‚ : Set P} (h : sâ‚ âŠ† sâ‚‚) : affineSpan k sâ‚ â‰¤ affineSpan k sâ‚‚
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsArtinian R M] (f : M â†’â‚—[R] M) (s : Function.Injective â‡‘f) : Function.bijective â‡‘f
{M : Type u} [Monoid M] (a : M) : a ^ 2 = a * a
{Î± : Type u_1} {E : Type u_2} (R : Type u_3) [AddCommGroup E] [divisionRing R] [Monoid Î±] [Module R E] [DistribMulAction Î± E] (n : â„•) (s : Î±) (x : E) : (â†‘n)â»Â¹ â€¢ s â€¢ x = s â€¢ (â†‘n)â»Â¹ â€¢ x
{R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] {Î¹ : Type u_1} {f : Î¹ â†’ M} (hF : Function.Injective f) : LinearIndependent R Coe â†’ LinearIndependent R f
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [Fintype Î¹] (p : Î¹ â†’ P) {n : â„•} (hc : Fintype.card Î¹ = n + 2) : AffineIndependent k p â†” Â¬FiniteDimensional.finrank k â†¥(vectorSpan k (Set.Range p)) â‰¤ n
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] [RegularSpace Y] {f : X â†’ Y} {A B : Set X} (hB : B âŠ† Closure A) (hF : âˆ€ (x : X), x âˆˆ B â†’ (âˆƒ (y : Y), Filter.Tendsto f (nhdsWithin x A) (nhds y))) : ContinuousOn (extendFrom A f) B
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] {s : Set M} {p : Î  (x : M), x âˆˆ Submodule.span R s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (H0 : p 0 _) (H1 : âˆ€ (x : M) (hx : x âˆˆ Submodule.span R s) (y : M) (hy : y âˆˆ Submodule.span R s), p x hx â†’ p y hy â†’ p (x + y) _) (H2 : âˆ€ (a : R) (x : M) (hx : x âˆˆ Submodule.span R s), p x hx â†’ p (a â€¢ x) _) {x : M} (hx : x âˆˆ Submodule.span R s) : p x hx
{ð•œ : Type u_1} {E : Type u_3} [normedField ð•œ] [AddCommGroup E] [Module ð•œ E] {A : Set E} [topologicalSpace E] [HasContinuousSmul ð•œ E] (hA : A âˆˆ nhds 0) : Absorbent ð•œ A
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {b : E Ã— F â†’ G} {n : WithTop â„•} (hb : IsBoundedBilinearMap ð•œ b) : ContDiff ð•œ n b
{M : Type u_1} [hasAdd M] {c d : AddCon M} (H : Setoid.r = Setoid.r) : c = d
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimitsOfSize C] : CategoryTheory.Limits.HasColimitsOfSize C
(n : â„•) (x : â„) : HasDerivAt (expNegInvGlue.fAux n) (expNegInvGlue.fAux (n + 1) x) x
(R : Type u_1) {p n : â„•} [hp : Fact (Nat.Prime p)] [Ring R] [Char_p R p] (hn : Â¬p âˆ£ n) : Polynomial.cyclotomic (n * p) R = Polynomial.cyclotomic n R ^ (p - 1)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hb : ContinuousAt f a) : deriv (Î» (u : â„), âˆ« (x : â„) in u..b, f x) a = -f a
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {x : E} {n : WithTop â„•} {f g : E â†’ F} (hF : ContDiffAt ð•œ n f x) (hg : ContDiffAt ð•œ n g x) : ContDiffAt ð•œ n (Î» (x : E), f x - g x) x
{a b : â„} (m n : â„•) : âˆ« (x : â„) in a..b, Real.sin x ^ (2 * m + 1) * Real.cos x ^ n = âˆ« (u : â„) in Real.cos b..real.cos a, u ^ n * (1 - u ^ 2) ^ m
{Î¹ : Type u} {Î± : Type v} [Fintype Î¹] {t : Î¹ â†’ Finset Î±} [DecidableEq Î±] {n : â„•} (hn : Fintype.card Î¹ = n + 1) (ht : âˆ€ (s : Finset Î¹), s.card â‰¤ (s.bUnion t).card) (ih : âˆ€ {Î¹' : Type u} [_inst_3 : Fintype Î¹'] (t' : Î¹' â†’ Finset Î±), Fintype.card Î¹' â‰¤ n â†’ (âˆ€ (s' : Finset Î¹'), s'.card â‰¤ (s'.bUnion t').card) â†’ (âˆƒ (f : Î¹' â†’ Î±), Function.Injective f âˆ§ âˆ€ (x : Î¹'), f x âˆˆ t' x)) (s : Finset Î¹) (hs : s.nonempty) (hns : s â‰  Finset.univ) (hus : s.card = (s.bUnion t).card) : âˆƒ (f : Î¹ â†’ Î±), Function.Injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] {a : Î±} : 0 â‰¤ -a â†’ a â‰¤ 0
{ð•œâ‚‚ : Type u_2} {ð•œâ‚ƒ : Type u_3} {F : Type u_6} {G : Type u_8} [NormedGroup F] [NormedGroup G] [nondiscreteNormedField ð•œâ‚‚] [nondiscreteNormedField ð•œâ‚ƒ] [normedSpace ð•œâ‚‚ F] [normedSpace ð•œâ‚ƒ G] {Ïƒâ‚‚â‚ƒ : ð•œâ‚‚ â†’+* ð•œâ‚ƒ} {ð•œâ‚‚' : Type u_10} [nondiscreteNormedField ð•œâ‚‚'] {F' : Type u_11} [NormedGroup F'] [normedSpace ð•œâ‚‚' F'] {Ïƒâ‚‚' : ð•œâ‚‚' â†’+* ð•œâ‚‚} {Ïƒâ‚‚'' : ð•œâ‚‚ â†’+* ð•œâ‚‚'} {Ïƒâ‚‚â‚ƒ' : ð•œâ‚‚' â†’+* ð•œâ‚ƒ} [RingHomInvPair Ïƒâ‚‚' Ïƒâ‚‚''] [RingHomInvPair Ïƒâ‚‚'' Ïƒâ‚‚'] [RingHomCompTriple Ïƒâ‚‚' Ïƒâ‚‚â‚ƒ Ïƒâ‚‚â‚ƒ'] [RingHomCompTriple Ïƒâ‚‚'' Ïƒâ‚‚â‚ƒ' Ïƒâ‚‚â‚ƒ] [RingHomIsometric Ïƒâ‚‚â‚ƒ] [RingHomIsometric Ïƒâ‚‚'] [RingHomIsometric Ïƒâ‚‚''] [RingHomIsometric Ïƒâ‚‚â‚ƒ'] (f : F â†’sl[Ïƒâ‚‚â‚ƒ] G) (g : F' â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚‚'] F) : âˆ¥f.comp g.to_Linear_isometry.to_ContinuousLinearMapâˆ¥ = âˆ¥fâˆ¥
{n m : â„•} (h : n = m) (i : Fin n) : â†‘(â‡‘(fin.cast h) i) = â†‘i
{Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [Î  (i : Î¹), AddZeroClass (Î² i)] [AddCommMonoid Î³] (f : Î  (i : Î¹), Î² i â†’+ Î³) (i : Î¹) (x : Î² i) : â‡‘(â‡‘Dfinsupp.liftAddHom f) (Dfinsupp.single i x) = â‡‘(f i) x
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} (h_Mono : StrictMonoOn f s) (hs : s âˆˆ nhdsWithin a (Set.Ici a)) (hfs : Set.SurjOn f s (Set.Ioi (f a))) : ContinuousWithinAt f (Set.Ici a) a
{R : Type u} [Ring R] (s : Subring R) : 0 âˆˆ s
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) {r : â„} (hx : âˆ¥xâˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : hb.oangle y z = 2 â€¢ hb.oangle (y - x) (z - x)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] : â†‘âŠ¥ = âˆ…
{Î± : Type u_1} [commSemigroup Î±] {a b : Î±} (c : Î±) (h : c * a = b) : a âˆ£ b
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [isScalarTower R A B] (H : Function.Injective â‡‘(algebraMap A B)) {x : A} (h : IsIntegral R (â‡‘(algebraMap A B) x)) : IsIntegral R x
{M : Type u} [MulOneClass M] (x : M) : SemiconjBy 1 x x
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (h : Function.Injective â‡‘(algebraMap R A)) [CharZero R] : CharZero A
{Î± : Type u_1} {Î² : Type u_2} [AddCommMonoid Î±] [topologicalSpace Î±] [t2_Space Î±] [completeLattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (R : Î± â†’ Î± â†’ Prop) (m_supr : âˆ€ (s : â„• â†’ Î²), R (m (â¨† (i : â„•), s i)) (âˆ‘' (i : â„•), m (s i))) (sâ‚ sâ‚‚ : Î²) : R (m (sâ‚ âŠ” sâ‚‚)) (m sâ‚ + m sâ‚‚)
{C : Type u} [CategoryTheory.Category C] {X Y X' : C} (h : X' âŸ¶ X) (f : X âŸ¶ Y) [CategoryTheory.Limits.HasImage f] [CategoryTheory.Limits.HasImage (h â‰« f)] : CategoryTheory.Limits.imageSubobject (h â‰« f) â‰¤ CategoryTheory.Limits.imageSubobject f
{Râ‚ Râ‚‚ : â„} {c z : â„‚} {f : â„‚ â†’ â„‚} (hD : DifferentiableOn â„‚ f (Metric.Ball c Râ‚)) (h_maps : Set.MapsTo f (Metric.Ball c Râ‚) (Metric.Ball (f c) Râ‚‚)) (hz : z âˆˆ Metric.Ball c Râ‚) : âˆ¥dslope f c zâˆ¥ â‰¤ Râ‚‚ / Râ‚
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.MulPosMono Î±] (ha : a â‰¤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{R : Type u} [CommSemiring R] (p q : Polynomial R) : â‡‘Polynomial.derivative (Polynomial.evalâ‚‚ Polynomial.c q p) = Polynomial.evalâ‚‚ Polynomial.c q (â‡‘Polynomial.derivative p) * â‡‘Polynomial.derivative q
{R : Type u} [Ring R] {Î“â‚€ : Type v} [LinearOrderedCommGroupWithZero Î“â‚€] (v : Valuation R Î“â‚€) : RingSubgroupsBasis (Î» (Î³ : Î“â‚€Ë£), v.lt_AddSubgroup Î³)
{X : Type u_1} [topologicalSpace X] {x y : X} : Inseparable x y â†’ nhds x = nhds y
{R : Type u_1} [CommSemiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [Fintype n] [Fintype m] [DecidableEq n] {Mâ‚ : Type u_5} {Mâ‚‚ : Type u_6} [AddCommMonoid Mâ‚] [AddCommMonoid Mâ‚‚] [Module R Mâ‚] [Module R Mâ‚‚] (vâ‚ : Basis n R Mâ‚) (vâ‚‚ : Basis m R Mâ‚‚) {Mâ‚ƒ : Type u_7} [AddCommMonoid Mâ‚ƒ] [Module R Mâ‚ƒ] (vâ‚ƒ : Basis l R Mâ‚ƒ) [Fintype l] [DecidableEq m] (A : Matrix l m R) (B : Matrix m n R) (x : Mâ‚) : â‡‘(â‡‘(Matrix.toLin vâ‚ vâ‚ƒ) (A.mul B)) x = â‡‘(â‡‘(Matrix.toLin vâ‚‚ vâ‚ƒ) A) (â‡‘(â‡‘(Matrix.toLin vâ‚ vâ‚‚) B) x)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (pâ‚ pâ‚‚ : Î¹ â†’ P) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.weighted_vsub pâ‚) w - â‡‘(s.weighted_vsub pâ‚‚) w
(A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension {1} A B] : âŠ¥ = âŠ¤
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop) (hpâ‚€ : p 1) (hpâ‚ : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) (hpâ‚‚ : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)))
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set â„} [Interval_integral.FTC_Filter a (nhdsWithin a s) (nhdsWithin a t)] (hmeas : StronglyMeasurableAtFilter f (nhdsWithin a t) MeasureTheory.MeasureSpace.volume) (ha : ContinuousWithinAt f t a) (hs : UniqueDiffWithinAt â„ s a . "UniqueDiffWithinAt_ici_Iic_Univ") : derivWithin (Î» (u : â„), âˆ« (x : â„) in u..b, f x) s a = -f a
{Î± : Type u_1} [topologicalSpace Î±] {x : Î±} {s : Set Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] {f g : Î± â†’ Î³} (hF : LowerSemicontinuousWithinAt f s x) (hg : LowerSemicontinuousWithinAt g s x) (hcont : ContinuousAt (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : LowerSemicontinuousWithinAt (Î» (z : Î±), f z + g z) s x
(s : Set Cardinal) : BddAbove s â†” Small â†¥s
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] (P Q : Module R M) (w : âˆ€ (r : R) (m : M), r â€¢ m = r â€¢ m) : P = Q
{Î± : Type u} [PartialOrder Î±] [DecidableRel LE.le] {a b : Î±} (hab : a â‰¤ b) : a = b âˆ¨ a < b
{A : Type u_2} [AddMonoid A] {x y : A} : y âˆˆ AddSubmonoid.closure {x} â†” âˆƒ (n : â„•), n â€¢ x = y
{Î± : Type u} {a b : Î±} [MulZeroClass Î±] [Preorder Î±] [ZeroLt.PosMulStrictMono Î±] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) : LinearIndependent ð•œ v
{Î± : Type u_1} {Î² : Type u_2} {Gâ‚€ : Type u_3} [groupWithZero Gâ‚€] [topologicalSpace Gâ‚€] [HasContinuousInvâ‚€ Gâ‚€] [HasContinuousMul Gâ‚€] [topologicalSpace Î±] [topologicalSpace Î²] {a : Î±} {f g : Î± â†’ Gâ‚€} (h : Î± â†’ Gâ‚€ â†’ Î²) (hF : ContinuousAt f a) (hg : ContinuousAt g a) (hH : g a â‰  0 â†’ ContinuousAt â†¿h (a, f a / g a)) (h2h : g a = 0 â†’ Filter.Tendsto â†¿h ((nhds a).prod âŠ¤) (nhds (h a 0))) : ContinuousAt (Î» (x : Î±), h x (f x / g x)) a
{Î¹ : sort u_1} {Î± : Type u_2} {Î² : Type u_3} [completeLattice Î±] [completeLattice Î²] (f : Î± â‰ƒo Î²) {a : Î¹ â†’ Î±} (ha : CompleteLattice.Independent a) : CompleteLattice.Independent (â‡‘f âˆ˜ a)
{C : Type u} [CategoryTheory.Category C] {F : C â¥¤ C} {A : CategoryTheory.Endofunctor.Algebra F} (h : CategoryTheory.Limits.IsInitial A) : CategoryTheory.IsIso A.str
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] [Algebra R S] {Î¹ : Type w} [Fintype Î¹] (b : Basis Î¹ R S) (x : R) : â‡‘(Algebra.trace R S) (â‡‘(algebraMap R S) x) = Fintype.card Î¹ â€¢ x
{R : Type u_1} {M : Type u_2} [CommMonoid M] [CommSemiring R] {S : Set M} (hS : Submonoid.closure S = âŠ¤) : Function.Surjective â‡‘(MvPolynomial.aeval (Î» (s : â†¥S), â‡‘(MonoidAlgebra.of R M) â†‘s))
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [FiniteDimensional ð•œ E] [FiniteDimensional ð•œ F] (A : E â†’â‚—[ð•œ] F) (x : E) (y : F) : HasInner.inner (â‡‘(â‡‘LinearMap.adjoint A) y) x = HasInner.inner y (â‡‘A x)
{Gâ‚ : Type u_2} {Gâ‚‚ : Type u_3} [Group Gâ‚] [Group Gâ‚‚] [group.is_nilpotent Gâ‚] [group.is_nilpotent Gâ‚‚] : group.nilpotency_class (Gâ‚ Ã— Gâ‚‚) = Linear_order.max (group.nilpotency_class Gâ‚) (group.nilpotency_class Gâ‚‚)
{Î¹ : Type u} (s : Finset Î¹) (f g : Î¹ â†’ Ennreal) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), g i ^ p) ^ (1 / p)
{Î± : Type u} [pseudoMetricSpace Î±] (x y : Î±) : HasDist.dist x y = â†‘(HasNndist.nndist x y)
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] : {x : Î± | âˆƒ (y : Î±), x < y âˆ§ Set.Ioo x y = âˆ…}.countable
{R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] {m : â„•} (x : M) (v : Fin m â†’ M) (hli : LinearIndependent R v) (x_IsOrtho : âˆ€ (c : R) (y : â†¥(Submodule.span R (Set.Range v))), c â€¢ x + â†‘y = 0 â†’ c = 0) : LinearIndependent R (fin.cons x v)
{M : Type u_1} [AddZeroClass M] {s : Set M} : s âŠ† â†‘(AddSubmonoid.closure s)
{Î± : Type u} [Monoid Î±] (f : â„• â†’ Î±) (n : â„•) : (List.map f (List.range n.succ)).prod = f 0 * (List.map (Î» (i : â„•), f i.succ) (List.range n)).prod
(ð•œ : Type u_1) [nondiscreteNormedField ð•œ] (ð•œ' : Type u_2) [normedRing ð•œ'] [NormedAlgebra ð•œ ð•œ'] : IsBoundedBilinearMap ð•œ (Î» (p : ð•œ' Ã— ð•œ'), â‡‘(â‡‘(ContinuousLinearMap.lmulLeftRight ð•œ ð•œ') p.fst) p.snd)
{E : Type u_2} {ð•œ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] {s : Set E} (hs : Convex ð•œ s) {a b : ð•œ} (ha : 0 < a) (hb : 0 â‰¤ b) (hab : a + b = 1) : a â€¢ Interior s + b â€¢ Closure s âŠ† Interior s
{s : â„‚} (hs : 0 < s.re) : (s + 1).Gamma_integral = s * s.Gamma_integral
{Î± : Type u} [orderedSemiring Î±] [Nontrivial Î±] : 0 < 2
{Î± : Type u} {l : List Î±} : l.nodup â†’ l.attach.nodup
{X Y Z : Type u} (f : X âŸ¶ Y) {g h : Y âŸ¶ Z} (w : f â‰« g = f â‰« h) (t : CategoryTheory.Limits.IsLimit (Category_theory.limits.fork.of_Î¹ f w)) (y : Y) (hy : g y = h y) : âˆƒ! (x : X), f x = y
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {n : â„•} : iteratedFderiv ð•œ (n + 1) f = â‡‘(continuousMultilinearCurryLeftEquiv ð•œ (Î» (i : Fin (n + 1)), E) F) âˆ˜ fderiv ð•œ (iteratedFderiv ð•œ n f)
{Î± : Type u_1} {Î¹ : Type u_4} [topologicalSpace Î±] [Encodable Î¹] {s : Î¹ â†’ Set Î±} (hs : âˆ€ (i : Î¹), is_GÎ´ (s i)) : is_GÎ´ (â‹‚ (i : Î¹), s i)
(m : Type u_1) (R : Type u_3) [DecidableEq m] [Fintype m] [CommRing R] [Nontrivial R] : (matrix.mv_Polynomial.x m m R).det â‰  0
{Î± : Type u_1} [DecidableEq Î±] (s : Finset Î±) : (Finset.image Quotient.mk s.off_diag).card = s.card.choose 2
{C : Type u} [CategoryTheory.Category C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ C) [CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.functor F.obj)] [CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.functor (Î» (f : Î£ (p : J Ã— J), p.fst âŸ¶ p.snd), F.obj f.fst.fst))] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasColimit F
{ð•œ : Type u_1} {E : Type u_2} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] {p : FormalMultilinearSeries ð•œ ð•œ E} {x : ð•œ} (h : HasFpowerSeriesAt 0 p x) : p = 0
{M : Type u_1} [Monoid M] {sâ‚ sâ‚‚ : Set M} (isâ‚ : IsSubmonoid sâ‚) (isâ‚‚ : IsSubmonoid sâ‚‚) : IsSubmonoid (sâ‚ âˆ© sâ‚‚)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : â‡‘(Polynomial.aeval x) (minpoly A x) = 0
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hst : s âŠ† t) (ht : t.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t  s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
{Mâ‚€ : Type u_1} [cancelMonoidWithZero Mâ‚€] {a b : Mâ‚€} (hâ‚ : b â‰  1) (hâ‚‚ : b * a = a) : a = 0
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] : FiniteDimensional.finrank K V = 0 â†” Subsingleton V
{R : Type u_1} {M : Type u_2} [CommMonoid M] [CommRing R] [Nontrivial R] [h : Algebra.FiniteType R (MonoidAlgebra R M)] : monoid.fg M
{M : Type u_1} {N : Type u_2} [hasMul M] [hasMul N] {c : Con M} {d : Con N} {C : c.quotient â†’ d.quotient â†’ Prop} (p : c.quotient) (q : d.quotient) (H : âˆ€ (x : M) (y : N), C â†‘x â†‘y) : C p q
{Î± : Type u_1} [pseudoMetricSpace Î±] {x : Î±} {E : Set Î±} (hx : x âˆˆ E) (Î´ : â„) : Metric.ClosedBall x Î´ âŠ† Metric.Cthickening Î´ E
{V : Type uâ‚} [Quiver V] {C : Type u_1} [CategoryTheory.Category C] {F G : CategoryTheory.Paths V â¥¤ C} (h_obj : F.obj = G.obj) (h : âˆ€ (a b : V) (e : a âŸ¶ b), F.map e.to_Path = CategoryTheory.eqToHom _ â‰« G.map e.to_Path â‰« CategoryTheory.eqToHom _) : F = G
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [NormedGroup F] [normedSpace â„ F] {s : Set E} (s_conv : Convex â„ s) {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€ (x : E), x âˆˆ Interior s â†’ HasFderivAt f (f' x) x) {x : E} (xs : x âˆˆ s) (hx : HasFderivWithinAt f' f'' (Interior s) x) {v w : E} (h4v : x + 4 â€¢ v âˆˆ Interior s) (h4w : x + 4 â€¢ w âˆˆ Interior s) : (Î» (h : â„), f (x + h â€¢ (2 â€¢ v + 2 â€¢ w)) + f (x + h â€¢ (v + w)) - f (x + h â€¢ (2 â€¢ v + w)) - f (x + h â€¢ (v + 2 â€¢ w)) - h ^ 2 â€¢ â‡‘(â‡‘f'' v) w) =o[nhdsWithin 0 (Set.Ioi 0)] Î» (h : â„), h ^ 2
{ð•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [NormedGroup E] [NormedGroup Fâ‚—] [nondiscreteNormedField ð•œ] [normedSpace ð•œ E] [normedSpace ð•œ Fâ‚—] (c : E â†’L[ð•œ] ð•œ) (f : Fâ‚—) : âˆ¥c.smul_Right fâˆ¥â‚Š = âˆ¥câˆ¥â‚Š * âˆ¥fâˆ¥â‚Š
{Î± : Type u_6} {Î² : Type u_7} [hasMul Î²] [HasScalar Î± Î²] [isScalarTower Î± Î² Î²] (r : Î±) (x y : Î²) : r â€¢ x * y = r â€¢ (x * y)
{C : Type uâ‚} [CategoryTheory.Category C] {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} {c : CategoryTheory.Limits.PullbackCone f g} (h : CategoryTheory.Limits.IsLimit c) : CategoryTheory.IsPullback c.fst c.snd f g
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [AddCommMonoid M] {s : Set Î±} {t : Set Î²} (f : Î± â†’ Î² â†’ M) (hs : s.finite) (ht : t.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ t), f i j)))) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ t), finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i j))))
{E : Type u_1} {F : Type u_2} {ð•œ : Type u_3} {ð•œâ‚‚ : Type u_4} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] {Î¹ : Type u_5} [CompleteSpace E] {g : Î¹ â†’ (E â†’sl[Ïƒâ‚â‚‚] F)} (h : âˆ€ (x : E), âˆƒ (C : â„), âˆ€ (i : Î¹), âˆ¥â‡‘(g i) xâˆ¥ â‰¤ C) : âˆƒ (C' : â„), âˆ€ (i : Î¹), âˆ¥g iâˆ¥ â‰¤ C'
{B : Type u} [Quiver B] {a b c : B} (p : Quiver.Path a b) {f g : CategoryTheory.FreeBicategory.Hom b c} (Î· : f âŸ¶ g) : CategoryTheory.Bicategory.whiskerLeft ((CategoryTheory.FreeBicategory.preinclusion B).map {as := p}) Î· â‰« (CategoryTheory.FreeBicategory.normalizeIso p g).hom = (CategoryTheory.FreeBicategory.normalizeIso p f).hom â‰« (CategoryTheory.FreeBicategory.preinclusion B).mapâ‚‚ (CategoryTheory.eqToHom _)
{R : Type u} [CommRing R] (U V : TopologicalSpace.Opens â†¥(AlgebraicGeometry.PrimeSpectrum.top R)) (hUV : U = V) : AlgebraicGeometry.StructureSheaf.comap (RingHom.id R) U V _ = CategoryTheory.eqToHom _
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] (s : Submodule K V) : s.fg â†” FiniteDimensional K â†¥s
{Î± : Type u_1} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {s : Finset Î±} : s âˆˆ ð’œ.shadow â†” âˆƒ (t : Finset Î±) (H : t âˆˆ ð’œ) (a : Î±) (H : a âˆˆ t), t.erase a = s
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x : Î±} (h : x âˆˆ s) : Metric.infDist x s = 0
{C : Type u} [CategoryTheory.Category C] {F : C â¥¤ C} {Aâ‚€ Aâ‚ : CategoryTheory.Endofunctor.Algebra F} (f : Aâ‚€ âŸ¶ Aâ‚) [CategoryTheory.IsIso f.f] : CategoryTheory.IsIso f
{G : Type u_1} [Group G] {k : Set G} {p : G â†’ G â†’ Prop} {x y : G} (hx : x âˆˆ Subgroup.closure k) (hy : y âˆˆ Subgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ âˆ€ (y : G), y âˆˆ k â†’ p x y) (H1_Left : âˆ€ (x : G), p 1 x) (H1_Right : âˆ€ (x : G), p x 1) (HMul_Left : âˆ€ (xâ‚ xâ‚‚ y : G), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ * xâ‚‚) y) (HMul_Right : âˆ€ (x yâ‚ yâ‚‚ : G), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ * yâ‚‚)) (Hinv_Left : âˆ€ (x y : G), p x y â†’ p xâ»Â¹ y) (Hinv_Right : âˆ€ (x y : G), p x y â†’ p x yâ»Â¹) : p x y
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_glue_data.J) (U : TopologicalSpace.Opens â†¥((CategoryTheory.Limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier)) : âˆƒ (Eq1 : (TopologicalSpace.Opens.map (D.to_glue_data.t k i).base).op.obj (Opposite.op (_.open_functor.obj U)) = Opposite.op (_.open_functor.obj (Opposite.unop ((TopologicalSpace.Opens.map (D.to_glue_data.t' k i j).base).op.obj (Opposite.op U))))), _.inv_App U â‰« (D.to_glue_data.t k i).c.app (Opposite.op (_.open_functor.obj U)) â‰« (D.to_glue_data.V (k, i)).presheaf.map (CategoryTheory.eqToHom Eq1) = (D.to_glue_data.t' k i j).c.app (Opposite.op U) â‰« _.inv_App (Opposite.unop ((TopologicalSpace.Opens.map (D.to_glue_data.t' k i j).base).op.obj (Opposite.op U)))
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] [RegularSpace Y] {f : X â†’ Y} {A : Set X} (hA : Dense A) (hF : âˆ€ (x : X), âˆƒ (y : Y), Filter.Tendsto f (nhdsWithin x A) (nhds y)) : Continuous (extendFrom A f)
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_glue_data.J) (U : TopologicalSpace.Opens â†¥((CategoryTheory.Limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier)) : _.inv_App U â‰« (D.to_glue_data.t k i).c.app (Opposite.op (_.open_functor.obj U)) = (D.to_glue_data.t' k i j).c.app (Opposite.op U) â‰« _.inv_App (Opposite.unop ((TopologicalSpace.Opens.map (D.to_glue_data.t' k i j).base).op.obj (Opposite.op U))) â‰« (D.to_glue_data.V (k, i)).presheaf.map (CategoryTheory.eqToHom _)
{C : Type uâ‚} [CategoryTheory.Category C] {X : C} (P : Cáµ’áµ– â¥¤ Type w) {S : CategoryTheory.Sieve X} {R : CategoryTheory.Presieve X} (h : â‡‘S â‰¤ R) (hS : CategoryTheory.Presieve.IsSheafFor P â‡‘S) (Trans : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, R f â†’ CategoryTheory.Presieve.IsSeparatedFor P â‡‘(CategoryTheory.Sieve.pullback f S)) : CategoryTheory.Presieve.IsSheafFor P R
{R : Type u_1} {a b : R} [AddSemigroup R] (Ab : IsAddRegular (a + b)) (ba : IsAddRegular (b + a)) : IsAddRegular a âˆ§ IsAddRegular b
(S : Set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] : IsCyclotomicExtension S A B â†” (âˆ€ (a : â„•+), a âˆˆ S â†’ (âˆƒ (r : B), â‡‘(Polynomial.aeval r) (Polynomial.cyclotomic â†‘a A) = 0)) âˆ§ Algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1} = âŠ¤
{X : Type u_1} {Y : Type u_2} [pseudoEmetricSpace X] [pseudoEmetricSpace Y] {C r : Nnreal} {f : X â†’ Y} {s : Set X} (hF : HolderOnWith C r f s) (h0 : 0 < r) : UniformContinuousOn f s
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} : -a < -b â†’ b < a
{Î± : Type u_1} : WellFounded LT.lt
{M : Type u_1} [hasAdd M] (c : AddCon M) {x y z : M} : â‡‘c x y â†’ â‡‘c y z â†’ â‡‘c x z
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} {s : Finset Î¹} (hv : Orthonormal ð•œ v) : s.sum (Î» (i : Î¹), âˆ¥HasInner.inner (v i) xâˆ¥ ^ 2) â‰¤ âˆ¥xâˆ¥ ^ 2
{R : Type u} [CommSemiring R] (r : R) : â‡‘Polynomial.c r = â‡‘(algebraMap R (Polynomial R)) r
{Î± : Type u_2} {Î² : Type u_3} [linearOrderedField Î±] [linearOrderedField Î²] [Archimedean Î²] : Subsingleton (Î± â†’+*o Î²)
{x n : â„•} (h : x.coprime n) : x ^ n.totient â‰¡ 1 [Mod n]
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] {f : â„ â†’ E} {T : â„} (hF : Function.Periodic f T) (t s : â„) : âˆ« (x : â„) in t..t + T, f x = âˆ« (x : â„) in s..s + T, f x
{Î± : Type u} [Preorder Î±] {s : Set Î±} : Â¬BddBelow s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬x â‰¤ y
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (a b c p : P) (h : EuclideanGeometry.angle b p c = Real.pi) : HasDist.dist a b ^ 2 * HasDist.dist c p + HasDist.dist a c ^ 2 * HasDist.dist b p = HasDist.dist b c * (HasDist.dist a p ^ 2 + HasDist.dist b p * HasDist.dist c p)
{Î± : Type u_1} {Î² : Type u_2} [completeLattice Î±] {f : Filter Î²} : f.limsup (Î» (x : Î²), âŠ¥) = âŠ¥
{M : Type u_1} [hasMul M] {c : Con M} (x y : M) : â†‘(x * y) = â†‘x * â†‘y
{Î± : Type u} {Î² : Type v} [CommSemiring Î²] (f g : Î± â†’ Î²) (s : Finset Î±) : s.prod (Î» (a : Î±), f a + g a) = s.powerset.sum (Î» (t : Finset Î±), t.prod (Î» (a : Î±), f a) * (s  t).prod (Î» (a : Î±), g a))
{n : â„•} (h_Odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0
{n : â„•} {x : Fin (n + 1)} : Function.Injective â‡‘(x.succ_above)
{L : FirstOrder.Language} {T : L.Theory} : T.is_satisfiable â†” T.is_finitely_satisfiable
{E : Type u} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] {n : â„•} (a b : Fin (n + 1) â†’ â„) (hle : a â‰¤ b) (f : Fin (n + 1) â†’ (Fin (n + 1) â†’ â„) â†’ E) (f' : Fin (n + 1) â†’ (Fin (n + 1) â†’ â„) â†’ ((Fin (n + 1) â†’ â„) â†’L[â„] E)) (s : Set (Fin (n + 1) â†’ â„)) (hs : s.countable) (Hc : âˆ€ (i : Fin (n + 1)), ContinuousOn (f i) (Set.Icc a b)) (hD : âˆ€ (x : Fin (n + 1) â†’ â„), x âˆˆ set.univ.pi (Î» (i : Fin (n + 1)), Set.Ioo (a i) (b i))  s â†’ âˆ€ (i : Fin (n + 1)), HasFderivAt (f i) (f' i x) x) (Hi : MeasureTheory.IntegrableOn (Î» (x : Fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : Fin (n + 1)), â‡‘(f' i x) (Pi.single i 1))) (Set.Icc a b) MeasureTheory.MeasureSpace.volume) : âˆ« (x : Fin (n + 1) â†’ â„) in Set.Icc a b, finset.univ.sum (Î» (i : Fin (n + 1)), â‡‘(f' i x) (Pi.single i 1)) = finset.univ.sum (Î» (i : Fin (n + 1)), (âˆ« (x : Fin n â†’ â„) in Set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f i (i.insert_nth (b i) x)) - âˆ« (x : Fin n â†’ â„) in Set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f i (i.insert_nth (a i) x))
{V : Type u} {K : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] [hK : Invertible 2] {B : BilinForm K V} (hBâ‚‚ : B.is_Symm) : âˆƒ (v : Basis (Fin (FiniteDimensional.finrank K V)) K V), B.is_Ortho â‡‘v
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : EuclideanGeometry.angle p1 p2 p3 â‰¤ Real.pi
{Î± : Type u_1} [Preorder Î±] [AddCommSemigroup Î±] [HasSub Î±] [HasOrderedSub Î±] {a b c : Î±} [CovariantClass Î± Î± Add.add LE.le] : a + b - c â‰¤ a + (b - c)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) : hb.oangle (-x) y = hb.oangle x y + â†‘Real.pi
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} : b < a â†’ 0 < a - b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (hg : ContDiffOn ð•œ n g t) (hF : ContDiffOn ð•œ n f s) : ContDiffOn ð•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t)
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x : Î±} : 0 â‰¤ Metric.infDist x s
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topologicalSpace B] [topologicalSpace F] {Proj : Z â†’ B} [topologicalSpace Z] [conditionallyCompleteLinearOrder B] [OrderTopology B] (h : IsTopologicalFiberBundle F Proj) (a b : B) : âˆƒ (e : TopologicalFiberBundle.Trivialization F Proj), Set.Icc a b âŠ† e.base_Set
{M : Type u_1} [CancelCommMonoidWithZero M] {q : Associates M} {n : â„•} (hn : n â‰  0) {c : Fin (n + 1) â†’ Associates M} (hâ‚ : StrictMono c) (hâ‚‚ : âˆ€ {r : Associates M}, r â‰¤ q â†” âˆƒ (i : Fin (n + 1)), r = c i) (hq : q â‰  0) : Irreducible (c 1)
{Î± : Type u_1} {Î² : Type u_2} [hasMul Î±] [Preorder Î±] [Preorder Î²] {f g : Î² â†’ Î±} [CovariantClass Î± Î± Mul.mul LE.le] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] (hF : StrictMono f) (hg : Monotone g) : StrictMono (Î» (x : Î²), f x * g x)
(Î± : Type u_1) [topologicalSpace Î±] [PolishSpace Î±] [Nonempty Î±] : âˆƒ (f : (â„• â†’ â„•) â†’ Î±), Continuous f âˆ§ Function.Surjective f
{R : Type u} [Semiring R] {p q : Polynomial R} : p * q = p.support.sum (Î» (i : â„•), q.sum (Î» (j : â„•) (a : R), â‡‘(Polynomial.monomial (i + j)) (p.coeff i * a)))
{R : Type u_1} [CommSemiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} [AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P] [Module R M] [Module R N] [Module R P] {g h : tensorProduct R M N â†’â‚—[R] P} (H : (TensorProduct.mk R M N).comprâ‚‚ g = (TensorProduct.mk R M N).comprâ‚‚ h) : g = h
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s u : Set E} {f : E â†’ F} {x : E} {n : â„•} (hu : is_IsOpen u) (hs : UniqueDiffOn ð•œ (s âˆ© u)) (hx : x âˆˆ s âˆ© u) : iteratedFderivWithin ð•œ n f (s âˆ© u) x = iteratedFderivWithin ð•œ n f s x
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {K : Nnreal} {s : Set Î±} {f : Î± â†’ Î²} : (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ HasDist.dist (f x) (f y) â‰¤ â†‘K * HasDist.dist x y) â†’ LipschitzOnWith K f s
 : Â¬IsField â„¤
{Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [CommMonoid M] [orderedCommMonoid N] (f : M â†’ N) (p : M â†’ Prop) (h_One : f 1 = 1) (h_Mul : âˆ€ (x y : M), p x â†’ p y â†’ f (x * y) â‰¤ f x * f y) (hp_Mul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) (g : Î¹ â†’ M) {s : Finset Î¹} (hs : âˆ€ (i : Î¹), i âˆˆ s â†’ p (g i)) : f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} (h : is_is_IsLocalMax f a) : fderiv â„ f a = 0
{Î± : Type u_1} [Preorder Î±] [BoundedOrder Î±] [IsSimpleOrder Î±] {a b : Î±} (h : a < b) : a = âŠ¥
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} {x1 : Î±} {b1 : Bool} {x2 : Î±} {b2 : Bool} (H1 : (x1, b1) â‰  (x2, b2)) (H2 : FreeGroup.Red ((x1, b1) :: Lâ‚) ((x2, b2) :: Lâ‚‚)) : FreeGroup.Red Lâ‚ ((x1, !b1) :: (x2, b2) :: Lâ‚‚)
{Î± : Type u_1} {Î¹ : sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : l.has_Basis p s) {q : Î¹ â†’ Prop} (hq : âˆ€ (i : Î¹), p i â†’ (âˆƒ (j : Î¹), p j âˆ§ q j âˆ§ s j âŠ† s i)) : l.has_Basis (Î» (i : Î¹), p i âˆ§ q i) s
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cáµ’áµ– â¥¤ A) [CategoryTheory.Limits.HasPullbacks C] (s : A â¥¤ Type (max vâ‚ uâ‚)) [CategoryTheory.Limits.HasLimits A] [CategoryTheory.Limits.PreservesLimits s] [CategoryTheory.ReflectsIsomorphisms s] : CategoryTheory.Presheaf.IsSheaf J P â†” CategoryTheory.Presheaf.IsSheaf J (P â‹™ s)
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [succOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Antitone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ico (f (Order.succ n)) (f n))
{C : Type uâ‚} [CategoryTheory.Category C] {A T : C} (hT : CategoryTheory.Limits.IsTerminal T) [CategoryTheory.Mono (hT.from A)] : CategoryTheory.IsSubterminal A
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] : Module.rank K V â‰¤ 1 â†” âˆƒ (vâ‚€ : V), âˆ€ (v : V), âˆƒ (r : K), r â€¢ vâ‚€ = v
{Î¹ : Type u_1} {E : Type u_3} [semiNormedGroup E] {f : Î¹ â†’ E} {g : Î¹ â†’ â„} {a : â„} (hg : HasSum g a) (h : âˆ€ (i : Î¹), âˆ¥f iâˆ¥ â‰¤ g i) : âˆ¥âˆ‘' (i : Î¹), f iâˆ¥ â‰¤ a
{Î± : Type u} [topologicalSpace Î±] [LocallyCompactSpace Î±] (x : Î±) : âˆƒ (K : Set Î±), is_IsCompact K âˆ§ K âˆˆ nhds x
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [normedSpace ð•œ E] [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ G} {s : Set E} {C : Nnreal} (hF : âˆ€ (x : E), x âˆˆ s â†’ DifferentiableAt ð•œ f x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv ð•œ f xâˆ¥â‚Š â‰¤ C) (hs : Convex â„ s) : LipschitzOnWith C f s
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {x : E} {n : WithTop â„•} {f g : E â†’ F} (hF : ContDiffAt ð•œ n f x) (hg : ContDiffAt ð•œ n g x) : ContDiffAt ð•œ n (Î» (x : E), f x + g x) x
{f : â„ â†’ â„} {a b l : â„} (hab : a < b) (hfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds l)) (hfb : Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds l)) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), deriv f c = 0
(k : Type u_1) [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) [CharZero k] [Fintype Î¹] (h : s.card â‰  0) : finset.univ.sum (Î» (i : Î¹), Finset.centroidWeightsIndicator k s i) = 1
{X : Type u} [Lattice X] [JordanHolderLattice X] {sâ‚ sâ‚‚ : CompositionSeries X} (h : âˆ€ (x : X), x âˆˆ sâ‚ â†” x âˆˆ sâ‚‚) : sâ‚ = sâ‚‚
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) {s : Set Î¹} {i : Î¹} (hi : i âˆ‰ s) {l : Î¹ â†’â‚€ ð•œ} (hl : l âˆˆ Finsupp.supported ð•œ ð•œ s) : HasInner.inner (â‡‘(Finsupp.total Î¹ E ð•œ v) l) (v i) = 0
{M : Type u_3} [Monoid M] (l : List M) : (l.nth 0).get_or_else 1 * l.tail.prod = l.prod
{Î± : Type u} {Î² : Type v} [emetricSpace Î±] [pseudoEmetricSpace Î²] {f : Î± â†’ Î²} (hF : Isometry f) : UniformEmbedding f
{K : Type u} [hfield : Field K] {L : Type u_1} [Field L] (f : K â†’+* L) (a : L) {x y : Ratfunc K} (hx : Polynomial.evalâ‚‚ f a x.denom â‰  0) (hy : Polynomial.evalâ‚‚ f a y.denom â‰  0) : Ratfunc.eval f a (x * y) = Ratfunc.eval f a x * Ratfunc.eval f a y
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
{C : Type u_1} [CategoryTheory.Category C] (P : CategoryTheory.Idempotents.Karoubi C) : ðŸ™ P = P.decomp_Id_i â‰« P.decomp_Id_p
{n : â„•} {Î± : Type u_1} {v : Vector Î± (n + 1)} : v.last = v.nth (fin.last n)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] [topologicalSpace Î´] {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î³ â†’ Î´} (deâ‚ : DenseInducing eâ‚) (deâ‚‚ : DenseInducing eâ‚‚) : DenseInducing (Î» (p : Î± Ã— Î³), (eâ‚ p.fst, eâ‚‚ p.snd))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] : IsBoundedBilinearMap ð•œ (Î» (p : (E â†’L[ð•œ] ð•œ) Ã— F), p.fst.smul_Right p.snd)
{X : Type v} [topologicalSpace X] [LocallyCompactSpace X] [SigmaCompactSpace X] [t2_Space X] {Î¹ : X â†’ Type u} {p : Î  (x : X), Î¹ x â†’ Prop} {B : Î  (x : X), Î¹ x â†’ Set X} {s : Set X} (hs : is_IsClosed s) (hB : âˆ€ (x : X), x âˆˆ s â†’ (nhds x).has_Basis (p x) (B x)) : âˆƒ (Î± : Type v) (c : Î± â†’ X) (r : Î  (a : Î±), Î¹ (c a)), (âˆ€ (a : Î±), c a âˆˆ s âˆ§ p (c a) (r a)) âˆ§ (s âŠ† â‹ƒ (a : Î±), B (c a) (r a)) âˆ§ LocallyFinite (Î» (a : Î±), B (c a) (r a))
{Î± : Type u_1} {Î² : Type u_2} [Infinite Î²] (f : Î± â†’ Finset Î²) (w : (â‹ƒ (a : Î±), â†‘(f a)) = âŠ¤) : Cardinal.mk Î² â‰¤ Cardinal.mk â†¥(Set.Range f)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [FiniteDimensional ð•œ E] [FiniteDimensional ð•œ F] (A : E â†’â‚—[ð•œ] F) : â‡‘LinearMap.adjoint (â‡‘LinearMap.adjoint A) = A
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {s : Set E} : MdifferentiableOn (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f s â†” DifferentiableOn ð•œ f s
(n a b : â„•) : n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ List.ico a b
{Î± : Type u_1} {m m' : pseudoMetricSpace Î±} (h : PseudoMetricSpace.toHasDist = PseudoMetricSpace.toHasDist) : m = m'
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : E â†’ F Ã— G} {x : E} (hF : ContDiffAt ð•œ n f x) : ContDiffAt ð•œ n (Î» (x : E), (f x).snd) x
{f : â„• â†’ â„} (h_nonneg : âˆ€ (n : â„•), 0 â‰¤ f n) (h_Mono : âˆ€ â¦ƒm n : â„•â¦„, 0 < m â†’ m â‰¤ n â†’ f n â‰¤ f m) : Summable (Î» (k : â„•), 2 ^ k * f (2 ^ k)) â†” Summable f
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 p4 p5 : P} (hapc : EuclideanGeometry.angle p1 p5 p3 = Real.pi) (hbpd : EuclideanGeometry.angle p2 p5 p4 = Real.pi) : EuclideanGeometry.angle p1 p5 p2 = EuclideanGeometry.angle p3 p5 p4
{E : Type u_2} [AddCommGroup E] [Module â„ E] (s : ConvexCone â„ E) (f : LinearPmap â„ E â„) (nonneg : âˆ€ (x : â†¥(f.domain)), â†‘x âˆˆ s â†’ 0 â‰¤ â‡‘f x) (Dense : âˆ€ (y : E), âˆƒ (x : â†¥(f.domain)), â†‘x + y âˆˆ s) (hdom : f.domain â‰  âŠ¤) : âˆƒ (g : LinearPmap â„ E â„), f < g âˆ§ âˆ€ (x : â†¥(g.domain)), â†‘x âˆˆ s â†’ 0 â‰¤ â‡‘g x
{R : Type u_4} {S : Type u_5} [NonAssocSemiring R] [NonAssocSemiring S] (f : R â‰ƒ+* S) : â†‘f.to_MonoidHom = â†‘f.to_MonoidHom
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasFiniteWidePullbacks C] {B : C} : CategoryTheory.Limits.HasFiniteProducts (CategoryTheory.Over B)
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [semiNormedGroup Î²] (f : boundedContinuousFunction Î± Î²) : âˆ¥fâˆ¥ = HasInf.inf {C : â„ | 0 â‰¤ C âˆ§ âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C}
{Î± : Type u_1} [pseudoMetricSpace Î±] (C : â„) {f : â„• â†’ Î±} (huâ‚‚ : âˆ€ (n : â„•), HasDist.dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) {a : Î±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) : HasDist.dist (f 0) a â‰¤ C
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {x : E} {s t : Set E} (ht : t âˆˆ nhds x) : TangentConeAt ð•œ (s âˆ© t) x = TangentConeAt ð•œ s x
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} {y : Î±} {r : â„} (h : y âˆˆ t) (H : Metric.hausdorffDist s t < r) (Fin : Emetric.hausdorffEdist s t â‰  âŠ¤) : âˆƒ (x : Î±) (H : x âˆˆ s), HasDist.dist x y < r
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] {X Y : C} [CategoryTheory.Simple Y] {f : X âŸ¶ Y} [CategoryTheory.Limits.HasImage f] (w : f â‰  0) : CategoryTheory.Epi f
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semiNormedGroup E'] [semiNormedGroup F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : f' =o[l] g' â†’ ((Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{n : â„•} [Fact (0 < n)] (i : Zmod(2 * n)) : orderOf (QuaternionGroup.a i) = 2 * n / (2 * n).gcd i.val
{n : â„•} {fs : Finset (Fin (n + 1))} (h : fs.nonempty) : finset.univ.sum (Î» (i : Affine.Simplex.PointsWithCircumcenterIndex n), Affine.Simplex.centroidWeightsWithCircumcenter fs i) = 1
{M : Type u_1} [hasAdd M] {c d : AddCon M} : c â‰¤ d â†” âˆ€ {x y : M}, â‡‘c x y â†’ â‡‘d x y
{Î± : Type u} [MulOneClass Î±] : IsMonoidHom Id
(ð•œ : Type u) [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace ð•œ] {r : â„} (rpos : 0 < r) (h : is_IsCompact (Metric.ClosedBall 0 r)) : FiniteDimensional ð•œ E
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s : Set Î±} {a b : Î±} (hs : BddAbove s) (ha : a âˆˆ s) (h : b < a) : b < HasSup.sup s
{Î¹a : Type u_7} {Î¹b : Type u_8} [DecidableEq Î¹a] [DecidableEq Î¹b] [Fintype Î¹a] [Fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [CommSemiring R'] [AddCommGroup Nâ‚] [Module R' Nâ‚] [AddCommGroup Nâ‚‚] [Module R' Nâ‚‚] [AddCommMonoid Máµ¢] [Module R' Máµ¢] (a : MultilinearMap R' (Î» (_x : Î¹a), Máµ¢) Nâ‚) (b : MultilinearMap R' (Î» (_x : Î¹b), Máµ¢) Nâ‚‚) : â‡‘MultilinearMap.alternatization (a.dom_Coprod b) = (â‡‘MultilinearMap.alternatization a).dom_Coprod (â‡‘MultilinearMap.alternatization b)
(x : Pgame) : (x + 0).equiv x
(R : Type u) [Semiring R] : StrongRankCondition R â†” âˆ€ (n : â„•) (f : (Fin (n + 1) â†’ R) â†’â‚—[R] Fin n â†’ R), Â¬Function.Injective â‡‘f
(p : â„•) [Fact (Nat.Prime p)] : padicNorm p â†‘p = 1 / â†‘p
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) [Invertible A] : A.mul (â…Ÿ A) = 1
{Î± : Type u_1} [DecidableEq Î±] {U V : Finset Î±} (hUV : U.card = V.card) (A : Finset Î±) : (Uv.compress U V A).card = A.card
{R : Type u_1} [CommSemiring R] (r : R) : â‡‘LaurentPolynomial.c r = â‡‘(algebraMap R (LaurentPolynomial R)) r
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (p1 : P) (g : G) (p2 : P) : p1 = g +áµ¥ p2 â†” p1 -áµ¥ p2 = g
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [isScalarTower R A B] (hA : Algebra.IsIntegral R A) (hB : Algebra.IsIntegral A B) : Algebra.IsIntegral R B
{Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [Fintype Î¹] [Preorder Î¹'] [IsDirected Î¹' LE.le] [Nonempty Î¹'] {s : Î¹ â†’ Î¹' â†’ Set Î±} (hs : âˆ€ (i : Î¹), Monotone (s i)) : (â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) = â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {K : Type uâ‚} [CategoryTheory.Category K] (F : J â¥¤ C) (G : K â¥¤ C) (h : F.cocones â‰… G.cocones) [CategoryTheory.Limits.HasColimit F] : CategoryTheory.Limits.HasColimit G
{Î± : Type u} [Infinite Î±] {s : Set Î±} (hF : s.finite) : s âˆ‰ Filter.hyperfilter Î±
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1
{G : Type u} [Monoid G] {H : Type v} [Monoid H] (f : G â†’* H) {x : G} (h : IsOfFinOrder x) : IsOfFinOrder (â‡‘f x)
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] {l : Filter Î²} {f : Î² â†’ Î± Ã— Î±} (h : Filter.Tendsto f l (Uniformity Î±)) : Filter.Tendsto (Î» (x : Î²), ((f x).snd, (f x).fst)) l (Uniformity Î±)
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {f : Filter Î±} {g : Filter Î²} {m : Î±' â†’ Î² â†’ Î³} {n : Î± â†’ Î±'} {m' : Î² â†’ Î± â†’ Î´} {n' : Î´ â†’ Î³} (h_Left_anticomm : âˆ€ (a : Î±) (b : Î²), m (n a) b = n' (m' b a)) : Filter.mapâ‚‚ m (Filter.map n f) g = Filter.map n' (Filter.mapâ‚‚ m' g f)
(u : â„¤Ë£) : u ^ 2 = 1
{G : Type w} [topologicalSpace G] [AddGroup G] [TopologicalAddGroup G] {K U : Set G} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K âŠ† U) : âˆƒ (V : Set G) (H : V âˆˆ nhds 0), K + V âŠ† U
{b x : Ordinal} (h : 1 < b) : {o : Ordinal | x < b ^ o}.nonempty
{p : â„•} [Fact (Nat.Prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [denselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [topologicalSpace Î´] [OrderClosedTopology Î´] {f : Î± â†’ Î´} (hF : Continuous f) (h_Top : Filter.Tendsto f Filter.atTop Filter.atTop) (h_IsBot : Filter.Tendsto f Filter.atBot Filter.atBot) : Function.Surjective f
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {f g : â„‚ â†’ E} (hdf : DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Ioi 0)) (hBf : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Ioi 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hdg : DiffContOnCl â„‚ g (Set.Iio 0 Ã—â„‚ Set.Ioi 0)) (hBg : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Ioi 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = g â†‘x) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * Complex.i) = g (â†‘x * Complex.i)) : Set.EqOn f g {z : â„‚ | z.re â‰¤ 0 âˆ§ 0 â‰¤ z.im}
{R : Type u} [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] (p : Polynomial R) : â‡‘(Polynomial.mapAlg R S) p = Polynomial.map (algebraMap R S) p
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (pâ‚‚ : Î¹ â†’ P) (pâ‚ b : P) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = s.sum (Î» (i : Î¹), w i) â€¢ (pâ‚ -áµ¥ b) - â‡‘(s.weighted_vsub_of_point pâ‚‚ b) w
{S : Type u_1} [hasMul S] {a b : S} (h : Commute a b) : Commute b a
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) (h : (Multiset.map Polynomial.leadingCoeff t).prod â‰  0) : t.prod.leading_Coeff = (Multiset.map Polynomial.leadingCoeff t).prod
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {S T : ConvexCone ð•œ E} : â†‘S = â†‘T â†” S = T
{x y z : Pgame} (hâ‚ : x.lf y) (hâ‚‚ : y < z) : x.lf z
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.RegularEpi f] [m : CategoryTheory.Mono f] : CategoryTheory.IsIso f
{Î³ : Type u_3} [tÎ³ : topologicalSpace Î³] [PolishSpace Î³] [measurableSpace Î³] [BorelSpace Î³] {s : Set Î³} : PolishSpace.IsClopenable s â†” MeasurableSet s
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] (a b : Î±) : Filter.comap Coe (nhdsWithin a (Set.Ioi a)) = Filter.atBot
(n : â„•+) (S : Set â„•+) (K : Type w) (L : Type z) [Field K] [Field L] [Algebra K L] [NeZero â†‘â†‘n] [IsCyclotomicExtension S K L] (hS : n âˆˆ S) : Polynomial.Splits (algebraMap K L) (Polynomial.cyclotomic â†‘n K)
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x y : R) : v.int_Valuation_def (x * y) = v.int_Valuation_def x * v.int_Valuation_def y
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topologicalSpace Î²] (f : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : Set Î±) (y : Î²) : y âˆˆ OmegaLimit f Ï• s â†” âˆ€ (n : Set Î²), n âˆˆ nhds y â†’ (âˆƒá¶  (t : Ï„) in f, (s âˆ© Ï• t â»Â¹' n).nonempty)
{Î± : Type u_1} [topologicalSpace Î±] {x : Î±} {s : Set Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] [HasContinuousAdd Î³] {f g : Î± â†’ Î³} (hF : LowerSemicontinuousWithinAt f s x) (hg : LowerSemicontinuousWithinAt g s x) : LowerSemicontinuousWithinAt (Î» (z : Î±), f z + g z) s x
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚} (hF : CircleIntegrable f c R) (hw : Complex.abs w < R) : HasSum (Î» (n : â„•), â‡‘(cauchyPowerSeries f c R n) (Î» (_x : Fin n), w)) ((2 * â†‘Real.pi * Complex.i)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : Set Î±} [IsRefl Î± r] : s.pairwise r â†’ âˆ€ â¦ƒa : Î±â¦„, a âˆˆ s â†’ âˆ€ â¦ƒb : Î±â¦„, b âˆˆ s â†’ r a b
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x y : E) : is_R_or_C.abs (HasInner.inner x y / (â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥)) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : ð•œ), r â‰  0 âˆ§ y = r â€¢ x
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a : Î±} : -a < 0 â†’ 0 < a
{M : Type u_1} [Monoid M] {s : Set M} : s âŠ† monoid.closure s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasCoproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasColimits C
{G : Type u_7} [AddCommGroup G] (L : List G) (n : â„•) (a : G) : (L.update_nth n a).sum = L.sum + dite (n < L.length) (Î» (hn : n < L.length), -L.nth_LE n hn + a) (Î» (hn : Â¬n < L.length), 0)
{ð•œ : Type u_1} [linearOrderedField ð•œ] {s : Set ð•œ} {f : ð•œ â†’ ð•œ} (hs : Convex ð•œ s) (hF : âˆ€ {x y z : ð•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) < (f z - f y) / (z - y)) : StrictConvexOn ð•œ s f
{M : Type u_1} {N : Type u_2} [hasMul M] [hasMul N] {c : Con M} {f : M â†’ N} (H : âˆ€ (x y : M), f (x * y) = f x * f y) (h : Con.mulKer f H â‰¤ c) (hF : Function.Surjective f) : c.map_gen f = c.map_of_surjective f H h hF
(M : Type u_1) (Î± : Type u_2) [Group M] [mulAction M Î±] {Î¹ : sort u_3} {s : Î¹ â†’ Set Î±} : fixingSubgroup M (â‹ƒ (i : Î¹), s i) = â¨… (i : Î¹), fixingSubgroup M (s i)
{G : Type u_1} [Group G] [topologicalSpace G] [TopologicalGroup G] [t2_Space G] {Kâ‚€ : TopologicalSpace.PositiveCompacts G} : â‡‘(MeasureTheory.Measure.Haar.haarContent Kâ‚€) Kâ‚€.to_Compacts = 1
{Î³ : Type w} [SemilatticeSup Î³] {s t : Set Î³} : BddAbove (s âˆª t) â†” BddAbove s âˆ§ BddAbove t
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†’ 1 â‰¤ a
(n p : â„•) : (Finset.range n).sum (Î» (k : â„•), â†‘k ^ p) = (Finset.range (p + 1)).sum (Î» (i : â„•), bernoulli i * â†‘((p + 1).choose i) * â†‘n ^ (p + 1 - i) / (â†‘p + 1))
{A : Type u_3} [Semiring A] [Algebra â„ A] (f : â„‚ â†’â‚[â„] A) (x : â„) : â‡‘f â†‘x = â‡‘(algebraMap â„ A) x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] : âŠ¤ âˆˆ FixedByFinite K L
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) {Î¹ : Type u_1} {t : Finset Î¹} {f : Î¹ â†’ R} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.sum (Î» (i : Î¹), f i) âˆˆ s
{Î± : Type u_1} {M : Type u_5} [hasZero M] {f g : Î± â†’â‚€ M} : f = g â†” âˆ€ (a : Î±), â‡‘f a = â‡‘g a
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {i : Î± â†’ Î²} [t2_Space Î²] (di : DenseInducing i) (hD : Dense (Set.Range i)á¶œ) {s : Set Î±} (hs : is_IsCompact s) : Interior s = âˆ…
{C : Type u} [CategoryTheory.Category C] {X : Top} [CategoryTheory.Limits.HasProducts C] (F : Top.Presheaf C X) : F.is_sheaf â†” F.is_sheaf_Opens_LE_cover
{Î± : Type u_1} (L L' : List (List Î±)) : L = L' â†” L.join = L'.join âˆ§ List.map List.length L = List.map List.length L'
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {x : E} {n : WithTop â„•} (h : ContDiffAt ð•œ n f x) (hn : 1 â‰¤ n) : DifferentiableAt ð•œ f x
{Î± : Type u} [pseudoEmetricSpace Î±] (Î´ : â„) : Metric.Cthickening Î´ âˆ… = âˆ…
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] (F : C â¥¤ D) [F.final] {E : Type u} [CategoryTheory.Category E] {G : D â¥¤ E} [CategoryTheory.Limits.HasColimit (F â‹™ G)] : CategoryTheory.Limits.HasColimit G
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (p : E) : â‡‘(reflection K) p = bit0 â†‘(â‡‘(orthogonalProjection K) p) - p
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {ca cb : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb : Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds cb)) : HasFderivAt (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd â„ â„ â„).smul_Right cb - (ContinuousLinearMap.fst â„ â„ â„).smul_Right ca) (a, b)
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} (h : is_is_IsLocalMin f a) (hF : HasFderivAt f f' a) : f' = 0
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} : IsMaxOn f s a â†’ IsMinOn (â‡‘OrderDual.toDual âˆ˜ f) s a
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) : Ká—® = â¨… (v : â†¥K), (â‡‘innerSL â†‘v).ker
{C : Type u} {A : Type u_1} [CategoryTheory.Category C] [AddCommMonoid A] [CategoryTheory.HasShift C A] {X Y : C} (f : X âŸ¶ Y) (i j : A) : (CategoryTheory.shiftFunctor C j).map ((CategoryTheory.shiftFunctor C i).map f) = (CategoryTheory.shiftComm X i j).hom â‰« (CategoryTheory.shiftFunctor C i).map ((CategoryTheory.shiftFunctor C j).map f) â‰« (CategoryTheory.shiftComm Y j i).hom
{Î± : Type u_1} [LinearOrder Î±] [PredOrder Î±] [IsPredArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ Set.Ioc m n â†’ r i (Order.pred i)) (h2 : âˆ€ (i : Î±), i âˆˆ Set.Ioc n m â†’ r (Order.pred i) i) : Relation.ReflTransGen r n m
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’sl[Ïƒâ‚â‚‚] F) : LipschitzWith âˆ¥fâˆ¥â‚Š â‡‘f
{Î± : Type u_1} (r : Setoid Î±) : EqvGen.setoid Setoid.r = r
{Î± : Type u} [pseudoEmetricSpace Î±] (Î´ : â„) (E : Set Î±) : Metric.Thickening Î´ E âŠ† Metric.Cthickening Î´ E
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [semiNormedGroup Î²] [starAddMonoid Î²] [NormedStarGroup Î²] (f : boundedContinuousFunction Î± Î²) : â‡‘(HasStar.star f) = HasStar.star â‡‘f
(x : CliffordAlgebra CliffordAlgebraComplex.q) : â‡‘CliffordAlgebra.reverse x = x
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : âˆ€ (x : â„), x âˆˆ Interior D â†’ 0 < deriv f x) : StrictMonoOn f D
{J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] (F : J â¥¤ Top) (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) (T : Î  (j : J), Set (Set â†¥(F.obj j))) (hT : âˆ€ (j : J), TopologicalSpace.IsTopologicalBasis (T j)) (Univ : âˆ€ (i : J), Set.Univ âˆˆ T i) (Inter : âˆ€ (i : J) (U1 U2 : Set â†¥(F.obj i)), U1 âˆˆ T i â†’ U2 âˆˆ T i â†’ U1 âˆ© U2 âˆˆ T i) (compat : âˆ€ (i j : J) (f : i âŸ¶ j) (V : Set â†¥(F.obj j)), V âˆˆ T j â†’ â‡‘(F.map f) â»Â¹' V âˆˆ T i) : TopologicalSpace.IsTopologicalBasis {U : Set â†¥(C.X) | âˆƒ (j : J) (V : Set â†¥(F.obj j)), V âˆˆ T j âˆ§ U = â‡‘(C.Ï€.app j) â»Â¹' V}
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {v : Set E} [FiniteDimensional ð•œ E] (hv : Orthonormal ð•œ Coe) : (âˆ€ (u : Set E), u âŠ‡ v â†’ Orthonormal ð•œ Coe â†’ u = v) â†” âˆƒ (b : Basis â†¥v ð•œ E), â‡‘b = Coe
{Î“â‚€ : Type u_1} [LinearOrderedCommGroupWithZero Î“â‚€] (Î³ : Î“â‚€) (h : Î³ â‰  0) : nhds Î³ = Pure.pure Î³
{Î¹ : Type u_1} {R : Type u_2} [CommRing R] [LinearOrder Î¹] (s : Finset Î¹) (f : Î¹ â†’ R) : s.prod (Î» (i : Î¹), 1 - f i) = 1 - s.sum (Î» (i : Î¹), f i * (Finset.filter (Î» (_x : Î¹), _x < i) s).prod (Î» (j : Î¹), 1 - f j))
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) {X : D} [CategoryTheory.IsIso (h.counit.app X)] : CategoryTheory.inv (R.map (h.counit.app X)) = h.unit.app (R.obj X)
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f f' : â„‚ â†’ E} {c : â„‚} {R : â„} (hR : 0 â‰¤ R) (h : âˆ€ (z : â„‚), z âˆˆ Metric.Sphere c R â†’ HasDerivWithinAt f (f' z) (Metric.Sphere c R) z) : âˆ® (z : â„‚) in C(c, R), f' z = 0
(C : Type u) [CategoryTheory.Category C] [âˆ€ {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)] : CategoryTheory.Limits.HasPullbacks C
{n k : â„•} (h : k â‰¤ n) : n.desc_factorial k = n.factorial / (n - k).factorial
{Î± : Type u} {Î² : Type v} [DecidableEq Î±] [AddCommMonoid Î²] {s : Finset Î±} {x : Î±} (h : x âˆ‰ s) (f : Finset Î± â†’ Î²) : (HasInsert.insert x s).powerset.sum (Î» (a : Finset Î±), f a) = s.powerset.sum (Î» (a : Finset Î±), f a) + s.powerset.sum (Î» (t : Finset Î±), f (HasInsert.insert x t))
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x y : E) (hx0 : x â‰  0) (hy0 : y â‰  0) : is_R_or_C.abs (HasInner.inner x y) = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆƒ (r : ð•œ), r â‰  0 âˆ§ y = r â€¢ x
{Î± : Type u_1} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {s : Finset Î±} : s âˆˆ ð’œ.shadow â†” âˆƒ (a : Î±) (H : a âˆ‰ s), HasInsert.insert a s âˆˆ ð’œ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q) : â‡‘f 0 = 0
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {f : Î± â†’ Î²} (hF : IsGroupHom f) {Î³ : Type u_1} [Group Î³] {g : Î² â†’ Î³} (hg : IsGroupHom g) : IsGroupHom (g âˆ˜ f)
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] (f : MultilinearMap R Mâ‚ Mâ‚‚) {Î± : Î¹ â†’ Type u_1} (g : Î  (i : Î¹), Î± i â†’ Mâ‚ i) (A : Î  (i : Î¹), Finset (Î± i)) [Fintype Î¹] : â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (Fintype.piFinset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
(Î“â‚€ : Type u_1) [LinearOrderedCommGroupWithZero Î“â‚€] (x : Î“â‚€) {s : Set Î“â‚€} (s_in : s âˆˆ LinearOrderedCommGroupWithZero.nhdsFun Î“â‚€ x) : âˆƒ (t : Set Î“â‚€) (H : t âˆˆ LinearOrderedCommGroupWithZero.nhdsFun Î“â‚€ x), t âŠ† s âˆ§ âˆ€ (y : Î“â‚€), y âˆˆ t â†’ s âˆˆ LinearOrderedCommGroupWithZero.nhdsFun Î“â‚€ y
{E : Type u_2} {ð•œ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] {s : Set E} (hs : Convex ð•œ s) {x y : E} (hx : x âˆˆ Closure s) (hy : y âˆˆ Interior s) {t : ð•œ} (ht : t âˆˆ Set.Ioc 0 1) : x + t â€¢ (y - x) âˆˆ Interior s
{A : Type u_4} {K : Type u_5} {C : Type u_6} [CommRing A] [is_IsDomain A] [Field K] [Algebra A K] [IsFractionRing A K] [CommRing C] [Algebra A C] [Algebra K C] [isScalarTower A K C] : Algebra.IsAlgebraic A C â†” Algebra.IsAlgebraic K C
{K : Type u_1} [CommRing K] [is_IsDomain K] {p : Polynomial K} (hroots : â‡‘Multiset.card p.roots = p.nat_degree) : â‡‘Polynomial.c p.leading_Coeff * (Multiset.map (Î» (a : K), Polynomial.x - â‡‘Polynomial.c a) p.roots).prod = p
{Î± : Type u} {Î² : Type v} [Preorder Î±] [SemilatticeInf Î²] {f g : Î± â†’ Î²} (hF : Monotone f) (hg : Monotone g) : Monotone (f âŠ“ g)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [AddCommMonoid Î±] [topologicalSpace Î±] [t2_Space Î±] [Encodable Î³] [completeLattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (R : Î± â†’ Î± â†’ Prop) (m_supr : âˆ€ (s : â„• â†’ Î²), R (m (â¨† (i : â„•), s i)) (âˆ‘' (i : â„•), m (s i))) (s : Î³ â†’ Î²) : R (m (â¨† (b : Î³), s b)) (âˆ‘' (b : Î³), m (s b))
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {s t : CategoryTheory.Limits.Cocone F} (P : CategoryTheory.Limits.IsColimit s) (Q : CategoryTheory.Limits.IsColimit t) (f : s âŸ¶ t) : CategoryTheory.IsIso f
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s : Set P) : affineSpan k s = HasInf.inf {s' : AffineSubspace k P | s âŠ† â†‘s'}
{Î± : Type u_1} {n : Type u_4} [is_R_or_C Î±] [Fintype n] [DecidableEq n] {A : Matrix n n Î±} : A.is_hermitian â†” InnerProductSpace.IsSelfAdjoint (â‡‘((PiLp.linearEquiv Î± (Î» (_x : n), Î±)).symm.conj) (â‡‘Matrix.toLin' A))
{Î± : Type u} [pseudoMetricSpace Î±] (x y : Î±) : HasDist.dist â†‘x â†‘y = HasDist.dist x y
{Î± : Type u_1} {Î² : Type u_2} {rÎ± : Î± â†’ Î± â†’ Prop} {rÎ² : Î² â†’ Î² â†’ Prop} (hÎ± : WellFounded rÎ±) (hÎ² : WellFounded rÎ²) : WellFounded (Relation.GameAdd rÎ± rÎ²)
{R : Type u_1} {S : Type u_4} [CommRing R] [CommRing S] (p : Polynomial R) (x : S) [Algebra R S] (h : â‡‘(Polynomial.aeval x) p = 0) : IsIntegral R (p.leading_Coeff â€¢ x)
{n : â„•} (hpos : 0 < n) (R : Type u_1) [CommRing R] : n.divisors.prod (Î» (i : â„•), Polynomial.cyclotomic i R) = Polynomial.x ^ n - 1
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) : âˆƒ (L L' : List (Matrix.TransvectionStruct (Fin r âŠ• Unit) ð•œ)), (((List.map Matrix.TransvectionStruct.toMatrix L).prod.mul M).mul (List.map Matrix.TransvectionStruct.toMatrix L').prod).is_two_block_Diagonal
{k : Type u_1} {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {s : Finset Î¹} (p : Î¹ â†’ P) (h : â†‘(s.card) â‰  0) : Finset.centroid k s p âˆˆ affineSpan k (Set.Range p)
{Î± : Type u_1} (f : Finpartition Set.Univ) : setoid.is_Partition â†‘(f.parts)
{n : â„•} {Î² : Type u_1} (q : Fin (n + 2) â†’ Î²) : fin.tail (fin.init q) = fin.init (fin.tail q)
(f : Circle_deg1_Lift) {x : â„} {m : â„¤} (h : â‡‘f x = x + â†‘m) : f.translation_number = â†‘m
{ð•‚ : Type u_1} [is_R_or_C ð•‚] : HasDerivAt (Exp ð•‚) 1 0
{Î± : Type u} {Î² : Type v} [uniformSpace Î±] [SemilatticeSup Î²] [CompleteSpace Î±] {u : Î² â†’ Î±} (H : CauchySeq u) : âˆƒ (x : Î±), Filter.Tendsto u Filter.atTop (nhds x)
{a b r : â„} (h : -1 < r) : IntervalIntegrable (Î» (x : â„), x ^ r) MeasureTheory.MeasureSpace.volume a b
{ð•œ : Type u_1} [is_R_or_C ð•œ] [DecidableEq ð•œ] {n : Type u_2} [Fintype n] [DecidableEq n] {A : Matrix n n ð•œ} (hA : A.is_hermitian) : hA.eigenvector_Matrix_inv.mul A = (Matrix.diagonal (Coe âˆ˜ hA.eigenvalues)).mul hA.eigenvector_Matrix_Inv
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] [Nonempty V] : âˆƒ (v : V), G.min_degree = G.degree v
{S : Type u_1} [AddSemigroup S] {a b c : S} (hab : AddCommute a b) (hac : AddCommute a c) : AddCommute a (b + c)
{Î± : Type u_1} {l l' : List Î±} : l <+ l' â†” âˆƒ (f : Fin l.length â†ªo Fin l'.length), âˆ€ (ix : Fin l.length), l.nth_LE â†‘ix _ = l'.nth_LE â†‘(â‡‘f ix) _
{R S : CommRing} (f : R âŸ¶ S) (p : PrimeSpectrum â†¥S) : (AlgebraicGeometry.StructureSheaf.stalkIso â†¥R (â‡‘(PrimeSpectrum.comap f) p)).hom â‰« Localization.localRingHom (â‡‘(PrimeSpectrum.comap f) p).as_Ideal p.as_Ideal f rfl â‰« (AlgebraicGeometry.StructureSheaf.stalkIso â†¥S p).inv = AlgebraicGeometry.PresheafedSpace.stalkMap (AlgebraicGeometry.Spec.sheafedSpaceMap f) p
{R : Type u} [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] {p : Polynomial S} (r : R) (hp : p âˆˆ Polynomial.lifts (algebraMap R S)) : r â€¢ p âˆˆ Polynomial.lifts (algebraMap R S)
{M : Type u_1} {B : Type u_3} [AddMonoid M] [SetLike B M] [addSubmonoidClass B M] {S : B} {l : List M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ S) : l.sum âˆˆ S
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B â†’ Type u_5} [Semiring R] [Î  (x : B), AddCommMonoid (E x)] [Î  (x : B), Module R (E x)] [topologicalSpace F] [AddCommMonoid F] [Module R F] [topologicalSpace B] [topologicalSpace (Bundle.TotalSpace E)] (e e' : TopologicalVectorBundle.Trivialization R F E) {b : B} (hb : b âˆˆ e.to_fiber_Bundle_trivialization.base_Set âˆ© e'.to_fiber_Bundle_trivialization.base_Set) (y : F) : â‡‘(e.coord_change e' b) y = (â‡‘e' (â‡‘(e.to_fiber_Bundle_trivialization.to_local_homeomorph.symm) (b, y))).snd
 : Function.Surjective Real.sinh
{Î± : Type u_1} [topologicalSpace Î±] [BaireSpace Î±] {s : Set Î±} : s âˆˆ residual Î± â†” âˆƒ (t : Set Î±) (H : t âŠ† s), is_GÎ´ t âˆ§ Dense t
{Î± : Type u} [topologicalSpace Î±] {f : Filter Î±} {a : Î±} : f â‰¤ nhds a â†” âˆ€ (s : Set Î±), a âˆˆ s â†’ is_IsOpen s â†’ s âˆˆ f
{R : Type u} [CommSemiring R] {n : â„•} (hn : 0 < n) : Function.Injective â‡‘(Polynomial.expand R n)
{Î± : Type u} [CommSemiring Î±] {p p' ps ps' : Î±} : p = p' â†’ ps = ps' â†’ p * ps = p' * ps'
{Î± : Type u_1} {n : Type u_4} [AddGroup n] {v : n â†’ Î±} : (Matrix.circulant v).is_Symm â†” âˆ€ (i : n), v (-i) = v i
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} {f : ð•œ â†’ F} {x : ð•œ} {m : Fin n â†’ ð•œ} : â‡‘(iteratedFderiv ð•œ n f x) m = finset.univ.prod (Î» (i : Fin n), m i) â€¢ iteratedDeriv n f x
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] [StrictConvexSpace â„ E] {x y : E} : SameRay â„ x y â†” âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (X Y : C) [CategoryTheory.Limits.HasBinaryBiproduct X Y] {b : CategoryTheory.Limits.BinaryBicone X Y} (hb : b.is_bilimit) : (hb.is_limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)).inv = CategoryTheory.Limits.biprod.desc b.inl b.inr
{M : Type u_1} [hasAdd M] {c d : AddCon M} : Setoid.r = Setoid.r â†” c = d
{R : Type u} {n : â„•} {M : Fin n.succ â†’ Type v} {Mâ‚‚ : Type vâ‚‚} [Semiring R] [Î  (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid Mâ‚‚] [Î  (i : Fin n.succ), Module R (M i)] [Module R Mâ‚‚] (f : MultilinearMap R M Mâ‚‚) (m : Î  (i : Fin n), M i.succ) (c : R) (x : M 0) : â‡‘f (fin.cons (c â€¢ x) m) = c â€¢ â‡‘f (fin.cons x m)
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (h : InnerProductGeometry.angle x y = 0) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{Î¹ : Type u_1} {x : â„•} {s : Î¹ â†’ â„•} {t : Finset Î¹} : (âˆ€ (i : Î¹), i âˆˆ t â†’ x.coprime (s i)) â†’ x.coprime (t.prod (Î» (i : Î¹), s i))
{K : Type u_1} [linearOrderedField K] {a : K} (H : 1 < a) (n : â„•) : â†‘n â‰¤ (a ^ n - 1) / (a - 1)
{Î± : Type u} {Î² : Type v} [omegaCompletePartialOrder Î±] [omegaCompletePartialOrder Î²] (câ‚€ : OmegaCompletePartialOrder.Chain (Î± â†’ð’„ Î²)) (câ‚ : OmegaCompletePartialOrder.Chain Î±) (z : Î²) : (âˆ€ (i j : â„•), â‡‘(â‡‘câ‚€ i) (â‡‘câ‚ j) â‰¤ z) â†” âˆ€ (i : â„•), â‡‘(â‡‘câ‚€ i) (â‡‘câ‚ i) â‰¤ z
{Î± : Type u_1} [Preorder Î±] {f : Î± â†’ Î±} (h : Id â‰¤ f) (n : â„•) : Id â‰¤ (f^[n])
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linearOrderedField ð•œ] [AddCommGroup E] [linearOrderedAddCommGroup Î²] [Module ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} {t : Finset Î¹} {w : Î¹ â†’ ð•œ} {p : Î¹ â†’ E} (h : ConcaveOn ð•œ s f) (hwâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hwâ‚ : 0 < t.sum (Î» (i : Î¹), w i)) (hp : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : âˆƒ (i : Î¹) (H : i âˆˆ t), f (p i) â‰¤ f (t.center_mass w p)
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0
{ð•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_8} {Pâ‚‚ : Type u_9} [normedField ð•œ] [semiNormedGroup V] [semiNormedGroup Vâ‚‚] [normedSpace ð•œ V] [normedSpace ð•œ Vâ‚‚] [pseudoMetricSpace P] [pseudoMetricSpace Pâ‚‚] [NormedAddTorsor V P] [NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ð•œ] Pâ‚‚} : is_is_IsOpenMap â‡‘(f.linear) â†” is_is_IsOpenMap â‡‘f
{K L : Type} [Field K] [Field L] [IsAlgClosed K] [IsAlgClosed L] [CharZero K] [CharZero L] (hK : Cardinal.aleph_0 < Cardinal.mk K) (hKL : Cardinal.mk K = Cardinal.mk L) : K â‰ƒ+* L
{R : Type u_1} [CommRing R] {M : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] {Râ‚˜ : Type u_4} {Sâ‚˜ : Type u_5} [CommRing Râ‚˜] [CommRing Sâ‚˜] [Algebra R Râ‚˜] [IsLocalization M Râ‚˜] [Algebra S Sâ‚˜] [IsLocalization (Algebra.algebraMapSubmonoid S M) Sâ‚˜] {x : S} (p : Polynomial R) (hp : â‡‘(Polynomial.aeval x) p = 0) (hM : p.leading_Coeff âˆˆ M) : (IsLocalization.map Sâ‚˜ (algebraMap R S) _).is_integral_elem (â‡‘(algebraMap S Sâ‚˜) x)
{Î± : Type u} [HasSubset Î±] [hasSsubset Î±] [isNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {a b : Î±} [IsAntisymm Î± HasSubset.Subset] (h : a âŠ† b) : a âŠ‚ b âˆ¨ a = b
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.HasColimits C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] {X Y : AlgebraicGeometry.SheafedSpace C} (f : X âŸ¶ Y) (hF : OpenEmbedding â‡‘(f.base)) [H : âˆ€ (x : â†¥X), CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.stalkMap f x)] : AlgebraicGeometry.SheafedSpace.IsOpenImmersion f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {s : Set E} {f g : E â†’ F} (hF : ContDiffOn ð•œ n f s) (hg : ContDiffOn ð•œ n g s) : ContDiffOn ð•œ n (Î» (x : E), f x + g x) s
{n : â„•} {x y : Fin (n + 1)} : x.succ_above = y.succ_above â†” x = y
{ð•œ : Type u_1} {M : Type u_2} [divisionRing ð•œ] [AddCommMonoid M] [topologicalSpace M] [t1_Space M] [Module ð•œ M] [HasContinuousConstSmul ð•œ M] (c : ð•œ) : IsClosedMap (Î» (x : M), c â€¢ x)
{Î± : Type u} {Î² : Type v} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} (hinf : f.liminf u = a) (hsup : f.limsup u = a) (h : Filter.IsBoundedUnder LE.le f u . "is_bounded_Default") (h' : Filter.IsBoundedUnder GE f u . "is_bounded_Default") : Filter.Tendsto u f (nhds a)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (Kâ‚ Kâ‚‚ : Submodule ð•œ E) : Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—®
{Î± : Type u_1} {ix : Fin 1} (x : Î±) : (x::áµ¥Vector.nil).nth ix = x
{Î± : Type u} (s : Set (Set Î±)) (i : (quotient.out (Cardinal.aleph 1).ord).Î±) : Cardinal.mk â†¥(MeasurableSpace.GenerateMeasurableRec s i) â‰¤ Linear_order.max (Cardinal.mk â†¥s) 2 ^ Cardinal.aleph_0
{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : â†¥(Algebra.adjoin R s) â†’ Prop} (Hs : âˆ€ (x : A) (h : x âˆˆ s), p âŸ¨x, _âŸ©) (Halg : âˆ€ (r : R), p (â‡‘(algebraMap R â†¥(Algebra.adjoin R s)) r)) (HAdd : âˆ€ (x y : â†¥(Algebra.adjoin R s)), p x â†’ p y â†’ p (x + y)) (HMul : âˆ€ (x y : â†¥(Algebra.adjoin R s)), p x â†’ p y â†’ p (x * y)) (x : â†¥(Algebra.adjoin R s)) : p x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (E : C â¥¤ D) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasColimitsOfSize D] : CategoryTheory.Limits.HasColimitsOfSize C
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : o.oangle x y = Î¸ â†” âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(o.rotation Î¸) x
{f f' : â„ â†’ â„} {a b l : â„} (hab : a < b) (hfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds l)) (hfb : Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds l)) (hff' : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), f' c = 0
{a b c : â„¤} (h : fermat_42 a b c) : âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0 âˆ§ a0 % 2 = 1
{R : Type u_1} [Rack R] {G : Type u_2} [Group G] (f : ShelfHom R (Quandle.Conj G)) {a b : Rack.PreEnvelGroup R} : Rack.PreEnvelGroupRel' R a b â†’ Rack.toEnvelGroup.mapAux f a = Rack.toEnvelGroup.mapAux f b
{Î± : Type u_1} [isEmpty Î±] : Fintype.card Î± = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) [DecidableEq Î¹] (w : Î¹ â†’ k) (p : Î¹ â†’ P) (i : Î¹) : â‡‘((HasInsert.insert i s).weighted_vsub_of_point p (p i)) w = â‡‘(s.weighted_vsub_of_point p (p i)) w
{F : Type u_3} [innerProductSpace â„ F] (x y : F) : HasInner.inner x y = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
{R : Type u_1} [CommSemiring R] {m : Type u_3} {n : Type u_4} [Fintype n] [Fintype m] [DecidableEq n] : Matrix.toLin (Pi.basisFun R n) (Pi.basisFun R m) = Matrix.toLin'
{n : â„¤} : Odd n â†’ Odd n.nat_Abs
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] [Algebra K S] [Nontrivial S] (pB : powerBasis K S) : â‡‘(Algebra.trace K S) pb.gen = -(minpoly K pb.gen).next_Coeff
{R : Type u_1} {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K] [is_IsDomain R] [IsPrincipalIdealRing R] : Fintype.card (ClassGroup R K) = 1
{x y : pSet} : x.equiv y â†” x.to_Set = y.to_Set
{Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ Ennreal} : s.sum (Î» (x : Î±), f x) = âŠ¤ â†” âˆƒ (a : Î±) (H : a âˆˆ s), f a = âŠ¤
{Î± : Type u} {Î² : Type v} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l Filter.atTop) : Filter.Tendsto (Î» (x : Î²), f x * g x) l Filter.atBot
{R : Type u_1} [Monoid R] (a : RË£) : IsRegular â†‘a
{Î± : Type u_1} [hasLt Î±] {a b : Î±} [denselyOrdered Î±] : Â¬a â‹– b
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 1)} : X.Î´ (â‡‘fin.cast_Succ i) â‰« X.Ïƒ i = ðŸ™ (X.obj (SimplexCategory.mk n))
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] : (EuclideanGeometry.orthogonalProjection s).linear = â†‘(orthogonalProjection s.direction)
{Î± : Type u_1} [pseudoMetricSpace Î±] [ProperSpace Î±] (x : Î±) (r : â„) : is_IsCompact (Metric.Sphere x r)
{M : Type u_1} [hasAdd M] {c d : AddCon M} : Setoid.r = Setoid.r âŠ“ Setoid.r
{M : Type u_1} [Group M] (c : Con M) (n : â„¤) {w x : M} : â‡‘c w x â†’ â‡‘c (w ^ n) (x ^ n)
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] [denselyOrdered Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhdsWithin a (Set.Ioi a) â†” âˆƒ (u : Î±) (H : u âˆˆ Set.Ioi a), Set.Ioc a u âŠ† s
{Î± : Type u_1} {s : Finset Î±} {a : Î±} [DecidableEq Î±] : (HasInsert.insert a s).card = Ite (a âˆˆ s) s.card (s.card + 1)
(R : Type u_1) [orderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (v : M) (h : v â‰  0) : -rayOfNeZero R v h = rayOfNeZero R (-v) _
{K : Type u} [Field K] (s : Subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} (ha : a â‰  0) : char.quadratic_Char F a = 1 â†” IsSquare a
{R : Type u_1} {a : R} [AddMonoid R] (ua : IsAddUnit a) : IsAddRegular a
(L : List â„•) : L.head â‰¤ L.sum
{M : Type u_1} [Monoid M] {Î¹ : Type u_2} [hÎ¹ : Nonempty Î¹] {s : Î¹ â†’ Set M} (hs : âˆ€ (i : Î¹), IsSubmonoid (s i)) (Directed : âˆ€ (i j : Î¹), âˆƒ (k : Î¹), s i âŠ† s k âˆ§ s j âŠ† s k) : IsSubmonoid (â‹ƒ (i : Î¹), s i)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semiNormedGroup E] [semiNormedGroup F] [semiNormedGroup G] {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} (hF : Filter.Tendsto f l (nhds 0)) (hg : Filter.IsBoundedUnder LE.le l (HasNorm.norm âˆ˜ g)) (Op : E â†’ F â†’ G) (h_Op : âˆ€ (x : E) (y : F), âˆ¥Op x yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥) : Filter.Tendsto (Î» (x : Î±), Op (f x) (g x)) l (nhds 0)
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : â„ â†’ E} {f' : E} {x r : â„} (hF : HasDerivWithinAt f f' (Set.Ici x) x) (hr : âˆ¥f'âˆ¥ < r) : âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), (z - x)â»Â¹ * (âˆ¥f zâˆ¥ - âˆ¥f xâˆ¥) < r
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_glue_data.J) (U : TopologicalSpace.Opens â†¥((D.to_glue_data.V (i, j)).carrier)) : _.inv_App U â‰« (D.to_glue_data.f i k).c.app (Opposite.op (_.open_functor.obj U)) = Category_theory.limits.pullback.fst.c.app (Opposite.op U) â‰« _.inv_App (Opposite.unop ((TopologicalSpace.Opens.map Category_theory.limits.pullback.fst.base).op.obj (Opposite.op U))) â‰« (D.to_glue_data.V (i, k)).presheaf.map (CategoryTheory.eqToHom _)
{M : Type u_1} [AddZeroClass M] {s : Set M} {S : addSubmonoid M} : AddSubmonoid.closure s â‰¤ S â†” s âŠ† â†‘S
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : (Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] g â†’ f' =O[l] g
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {x y : M} (e : M â‰ƒâ‚—[R] N) : SameRay R (â‡‘e x) (â‡‘e y) â†” SameRay R x y
{Î¹ : Type u_1} {M : Type u_4} [orderedAddCommMonoid M] {s : Finset Î¹} {f : Î¹ â†’ WithTop M} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) : s.sum (Î» (i : Î¹), f i) < âŠ¤
{Î± : Type u_1} [conditionallyCompleteLinearOrder Î±] {s : Set Î±} {b : Î±} (hs : s.nonempty) (hb : HasInf.inf s < b) : âˆƒ (a : Î±) (H : a âˆˆ s), a < b
{Î± : Type u_1} [emetricSpace Î±] {K : Nnreal} {f : Î± â†’ Î±} (hF : ContractingWith K f) {s : Set Î±} (hs : Set.MapsTo f s s) : ContractingWith K (Set.MapsTo.restrict f s s hs)
{E : Type u_2} [AddCommGroup E] [Module â„ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul â„ E] {s : Set E} (hs : s.finite) : is_IsCompact (â‡‘(convexHull â„) s)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {ca cb : E} {la lb : Filter â„} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set â„} [Interval_integral.FTC_Filter a (nhdsWithin a s) la] [Interval_integral.FTC_Filter b (nhdsWithin b t) lb] (hmeas_a : StronglyMeasurableAtFilter f la MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f lb MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (la âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb : Filter.Tendsto f (lb âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds cb)) : HasFderivWithinAt (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd â„ â„ â„).smul_Right cb - (ContinuousLinearMap.fst â„ â„ â„).smul_Right ca) (s Ã—Ë¢ t) (a, b)
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : Vector Î± n) (i : Fin n) : (Vector.scanl f b v).nth i.succ = f ((Vector.scanl f b v).nth (â‡‘fin.cast_Succ i)) (v.nth i)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [semiNormedGroup E] [normedSpace ð•œ E] : UniformSpace.toTopologicalSpace â‰¤ WeakDual.topologicalSpace ð•œ E
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} (hs : UniqueDiffOn ð•œ s) : ContDiffOn ð•œ âŠ¤ f s â†” DifferentiableOn ð•œ f s âˆ§ ContDiffOn ð•œ âŠ¤ (Î» (y : E), fderivWithin ð•œ f s y) s
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {f : Î± â†’ Î²} (hF : IsRingHom f) : f 0 = 0
{G : Type u_1} [Group G] {N : Type u_3} [Group N] {f g : G â†’* N} {s : Set G} (h : Set.EqOn â‡‘f â‡‘g s) : Set.EqOn â‡‘f â‡‘g â†‘(Subgroup.closure s)
{Î± : Type u_1} {Î¹ : sort u_3} [conditionallyCompleteLattice Î±] {b : Î±} [Nonempty Î¹] {f : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), b â‰¤ f i) (hâ‚‚ : âˆ€ (w : Î±), b < w â†’ (âˆƒ (i : Î¹), f i < w)) : (â¨… (i : Î¹), f i) = b
(Î± : Type u) {Î² : Type v} [Group Î±] [mulAction Î± Î²] (b : Î²) [Fintype Î±] [Fintype â†¥(MulAction.Orbit Î± b)] [Fintype â†¥(MulAction.stabilizer Î± b)] : Fintype.card â†¥(MulAction.Orbit Î± b) * Fintype.card â†¥(MulAction.stabilizer Î± b) = Fintype.card Î±
{Î¹ : sort u_1} [Nonempty Î¹] {f : Î¹ â†’ Ennreal} {x : Ennreal} (h : x â‰  âŠ¤) : x * infi f = â¨… (i : Î¹), x * f i
{Î± : Type u} {m : â„•} (x : Î±) (u : Fin m.succ â†’ Î±) : Matrix.vecCons x u 1 = Matrix.vecHead u
{Î± : Type u_1} {Î¹ : Type u_3} [distribLattice Î±] [OrderBot Î±] {s : Finset Î¹} {f : Î¹ â†’ Î±} : â†‘s.pairwise_Disjoint f â†’ s.sup_indep f
{Î± : Type u_1} {Î² : Type u_2} [Nontrivial Î±] {f : Î± â†’ Î²} (hF : Function.Injective f) : Nontrivial Î²
{y : â„} (hy : 0 < y) : Filter.Tendsto (Î» (x : â„), x ^ -y) Filter.atTop (nhds 0)
{G : Type u_1} {P : Type u_2} [AddCommGroup G] [addTorsor G P] (p1 p2 p3 : P) : p3 -áµ¥ p2 - (p3 -áµ¥ p1) = p1 -áµ¥ p2
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.normal] (hN : (Fintype.card â†¥N).coprime N.index) : âˆƒ (H : Subgroup G), H.is_complement' N
{f : â„ â†’ â„} (hF : Differentiable â„ f) (hF' : âˆ€ (x : â„), 0 â‰¤ deriv f x) : Monotone f
{Î± : Type u_1} [hasLt Î±] [DecidableEq Î±] (A B : Finset Î±) : (A  B).to_colex < (B  A).to_colex â†” A.to_colex < B.to_colex
(r n : â„•) : n.choose r â‰¤ n.choose (n / 2)
{R : Type u} [CommSemiring R] [Nontrivial R] (h : âˆ€ (a b : R), a âˆˆ Nonunits R â†’ b âˆˆ Nonunits R â†’ a + b âˆˆ Nonunits R) : LocalRing R
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) {p : P} {r : â„} (hr : âˆ€ (i : Fin (n + 1)), HasDist.dist (s.points i) p = r) : â†‘(â‡‘(s.orthogonal_projection_Span) p) = s.circumcenter
{Î± : Type u} [AddZeroClass Î±] : is_AddMonoidHom.id
{M : Type u_1} [CommGroup M] (f : â„• â†’ M) (n : â„•) : (Finset.range n).prod (Î» (i : â„•), f (i + 1) * (f i)â»Â¹) = f n * (f 0)â»Â¹
{f : â„• â†’ â„•} (hF : Function.Injective f) : Filter.Tendsto f Filter.atTop Filter.atTop
{C : Type u} [CategoryTheory.Category C] (P : Cáµ’áµ– â¥¤ Type v) [P.representable] : CategoryTheory.Presieve.IsSheaf (CategoryTheory.Sheaf.canonicalTopology C) P
{Î± : Type u_1} (n : â„•) (s : Finset Î±) : (Finset.powersetLen n s).card = s.card.choose n
(R : Type u) (M : Type v) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] : Module.rank R M = Cardinal.mk (Module.Free.ChooseBasisIndex R M)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {s : Set ð•œ} {n : WithTop â„•} {m : â„•} (h : ContDiffOn ð•œ n f s) (hmn : â†‘m < n) (hs : UniqueDiffOn ð•œ s) : DifferentiableOn ð•œ (iteratedDerivWithin m f s) s
{k : Type u_1} {V1 : Type u_2} {V2 : Type u_4} [Ring k] [AddCommGroup V1] [Module k V1] [AddCommGroup V2] [Module k V2] (f : V1 â†’áµƒ[k] V2) : â‡‘(f.linear) = â‡‘f - Î» (z : V1), â‡‘f 0
{Î± : Type u_1} (v : Vector Î± 1) : v.tail = Vector.nil
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] {F : Type v} [NormedGroup F] [normedSpace â„‚ F] {f : E â†’ F} (hF : Differentiable â„‚ f) (hb : Metric.Bounded (Set.Range f)) : âˆƒ (c : F), âˆ€ (z : E), f z = c
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’ ð•œ) {s : Finset Î¹} {i : Î¹} (hi : i âˆˆ s) : HasInner.inner (v i) (s.sum (Î» (i : Î¹), l i â€¢ v i)) = l i
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} : Metric.hausdorffDist s (Closure t) = Metric.hausdorffDist s t
{R : Type u_1} [CommSemiring R] (M : Submonoid R) (S : Type u_2) [CommSemiring S] [Algebra R S] [IsLocalization M S] (J : Ideal S) : J.is_Prime â†” (Ideal.comap (algebraMap R S) J).is_Prime âˆ§ Disjoint â†‘M â†‘(Ideal.comap (algebraMap R S) J)
{X : Top} (F : Top.Presheaf (Type v) X) (Fsh : F.is_sheaf) : F.is_sheaf_Unique_gluing
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] (ht : âˆ€ (y : Î²), y âˆ‰ t â†’ (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) â‰¤ 0) (hb : t.card â€¢ b < s.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²) (H : y âˆˆ t), b < (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
{E : Type u_2} {ð•œ : Type u_3} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul ð•œ E] {s : Set E} (hs : Convex ð•œ s) : Convex ð•œ (Closure s)
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] {Î¹ : sort u_2} (p : Î¹ â†’ Submodule R M) {C : M â†’ Prop} {x : M} (hx : x âˆˆ â¨† (i : Î¹), p i) (hp : âˆ€ (i : Î¹) (x : M), x âˆˆ p i â†’ C x) (h0 : C 0) (HAdd : âˆ€ (x y : M), C x â†’ C y â†’ C (x + y)) : C x
{Î± : Type u_1} [LinearOrder Î±] (A B : Finset Î±) : (A  B).to_colex â‰¤ (B  A).to_colex â†” A.to_colex â‰¤ B.to_colex
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e : localHomeomorph Î± Î²} {s : Set Î±} {t : Set Î²} : e.is_image s t â†’ e.to_local_equiv.source âˆ© â‡‘e â»Â¹' (e.to_local_equiv.target âˆ© t) = e.to_local_equiv.source âˆ© s
{R : Type u_1} {Î¹ : Type u_2} {Mâ‚‚ : Type u_4} {Mâ‚ƒ : Type u_5} [CommSemiring R] [AddCommMonoid Mâ‚‚] [AddCommMonoid Mâ‚ƒ] [Module R Mâ‚‚] [Module R Mâ‚ƒ] [DecidableEq Î¹] [Fintype Î¹] {f g : MultilinearMap R (Î» (i : Î¹), Mâ‚‚) Mâ‚ƒ} {Î¹â‚ : Type u_3} (e : Basis Î¹â‚ R Mâ‚‚) (h : âˆ€ (v : Î¹ â†’ Î¹â‚), â‡‘f (Î» (i : Î¹), â‡‘e (v i)) = â‡‘g (Î» (i : Î¹), â‡‘e (v i))) : f = g
{K : Type u} [hfield : Field K] {L : Type u_1} [Field L] (f : K â†’+* L) (a : L) {x y : Ratfunc K} (hx : Polynomial.evalâ‚‚ f a x.denom â‰  0) (hy : Polynomial.evalâ‚‚ f a y.denom â‰  0) : Ratfunc.eval f a (x + y) = Ratfunc.eval f a x + Ratfunc.eval f a y
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (hs : is_IsCompact s) {f : Filter Î±} (hF : âˆ€ (a : Î±), a âˆˆ s â†’ sá¶œ âˆˆ nhds a âŠ“ f) : sá¶œ âˆˆ f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] (F : Top.Presheaf C X) (x : â†¥X) (t : â†¥(F.stalk x)) : âˆƒ (U : TopologicalSpace.Opens â†¥X) (m : x âˆˆ U) (s : â†¥(F.obj (Opposite.op U))), â‡‘(F.germ âŸ¨x, mâŸ©) s = t
{Î± : Type u_1} {A B : Finset Î±} (i : â„•) (hâ‚ : i + B.card â‰¤ A.card) (hâ‚‚ : B âŠ† A) : âˆƒ (C : Finset Î±), B âŠ† C âˆ§ C âŠ† A âˆ§ C.card = i + B.card
(ð•œ : Type u) [nondiscreteNormedField ð•œ] (E : Type v) [NormedGroup E] [normedSpace ð•œ E] [ProperSpace ð•œ] [FiniteDimensional ð•œ E] : ProperSpace E
{Î± : Type u_2} [AddMonoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = 2 â€¢ c) â†’ Even m
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : ConvexOn ð•œ s f) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) {a b : ð•œ} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) : f (a â€¢ x + b â€¢ y) â‰¤ Linear_order.max (f x) (f y)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} {u v : E} (hu : u âˆˆ K) (hv : v âˆˆ Ká—®) : HasInner.inner v u = 0
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s : Set Î±} (hb : BddBelow s) (ha : BddAbove s) (NE : s.nonempty) : HasInf.inf s â‰¤ HasSup.sup s
{C : Type uâ‚} [CategoryTheory.Category C] {P X Y Z : C} {fst : P âŸ¶ X} {Snd : P âŸ¶ Y} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} (w : CategoryTheory.CommSq fst Snd f g) (h : CategoryTheory.Limits.IsLimit w.cone) : CategoryTheory.IsPullback fst Snd f g
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] (a : Î±) {b : Î±} : 0 â‰¤ b â†’ a - b â‰¤ a
{n : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [IsCyclotomicExtension {n} K L] (hirr : Irreducible (Polynomial.cyclotomic â†‘n K)) [NeZero â†‘â†‘n] : FiniteDimensional.finrank K L = â†‘n.totient
{R : Type u} {L : Type v} {M : Type w} [CommRing R] [LieRing L] [lieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [lieModule R L M] {Nâ‚ : LieSubmodule R L M} (h : Nâ‚.centralizer = Nâ‚) (k : â„•) : LieSubmodule.ucs k âŠ¥ â‰¤ Nâ‚
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (H : Subgroup G) {f : N â†’* G} (hF : Function.Surjective â‡‘f) : Subgroup.comap f H.normalizer = (Subgroup.comap f H).normalizer
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M â†’+ P} (H : c â‰¤ AddCon.ker f) (x : M) : â‡‘(c.lift f H) (â‡‘(c.mk') x) = â‡‘f x
{V : Type u_1} [innerProductSpace â„ V] (x : V) : InnerProductGeometry.angle x 0 = Real.pi / 2
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚‚} [CategoryTheory.Category K] (F : J â¥¤ K) {jâ‚ jâ‚‚ : J} (h : CategoryTheory.Zigzag jâ‚ jâ‚‚) : CategoryTheory.Zigzag (F.obj jâ‚) (F.obj jâ‚‚)
(R : Type u_1) [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {C : Module.Ray R M â†’ Prop} (h : âˆ€ (v : M) (hv : v â‰  0), C (rayOfNeZero R v hv)) (x : Module.Ray R M) : C x
{p x : â„} (h : LiouvilleWith p x) (hp : 1 < p) : Irrational x
{R : Type u_1} [AddZeroClass R] : IsAddRegular 0
(M : Type u_1) (Î± : Type u_2) [Group M] [mulAction M Î±] : GaloisConnection (â‡‘OrderDual.toDual âˆ˜ fixingSubgroup M) ((Î» (P : Subgroup M), MulAction.FixedPoints â†¥P Î±) âˆ˜ â‡‘OrderDual.ofDual)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) : AffineIndependent k p â†” âˆ€ (s : Finset Î¹) (w : Î¹ â†’ k), s.sum (Î» (i : Î¹), w i) = 0 â†’ â‡‘(s.weighted_vsub p) w = 0 â†’ âˆ€ (i : Î¹), i âˆˆ s â†’ w i = 0
{R : Type u_1} [MulZeroClass R] [Nontrivial R] : Â¬IsRegular 0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {x : E} {n : WithTop â„•} (h : ContDiffWithinAt ð•œ n f s x) (hn : 1 â‰¤ n) : DifferentiableWithinAt ð•œ f (HasInsert.insert x s) x
{Î± : Type u} [topologicalSpace Î±] [LocallyCompactSpace Î±] [t2_Space Î±] {K : Set Î±} (hK : is_IsCompact K) : âˆƒ (V : Set Î±), is_IsOpen V âˆ§ K âŠ† V âˆ§ is_IsCompact (Closure V)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} [p.ne_IsBot] (hF : UniformCauchySeqOn F p s) (hF' : âˆ€ (x : Î±), x âˆˆ s â†’ Filter.Tendsto (Î» (n : Î¹), F n x) p (nhds (f x))) : TendstoUniformlyOn F f p s
{Î± : Type u} [pseudoEmetricSpace Î±] {x : Î±} {s : Set Î±} : Emetric.infEdist x (Closure s) = Emetric.infEdist x s
{Î± : Type u_1} {Î¹ : Type u_2} (s : Î¹ â†’ Set Î±) : (â¨… (i : Î¹), Filter.principal (s i)).has_Basis (Î» (t : Set Î¹), t.finite) (Î» (t : Set Î¹), â‹‚ (i : Î¹) (H : i âˆˆ t), s i)
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {c : â„‚} {R : â„} (h0 : 0 < R) {f : â„‚ â†’ E} {y : E} {s : Set â„‚} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c R  {c})) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball c R  {c}  s â†’ DifferentiableAt â„‚ f z) (hy : Filter.Tendsto f (nhdsWithin c {c}á¶œ) (nhds y)) : âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = (2 * â†‘Real.pi * Complex.i) â€¢ y
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
{p q r : Prop} (hâ‚ : Implies p q) (hâ‚‚ : Implies q r) : Implies p r
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra R A] [Algebra R B] (f : A â‰ƒâ‚[R] B) : (integralClosure R A).map â†‘f = integralClosure R B
{Î± : Type u} [PartialOrder Î±] [DecidableRel LE.le] {a b : Î±} (hab : a â‰¤ b) : a < b âˆ¨ a = b
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topologicalSpace Î±] [uniformSpace Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {p : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} (hÎ± : âˆ€ (x : Î±), âˆƒ (n : Set Î±), is_IsCompact n âˆ§ n âˆˆ nhds x) (h : Filter.Tendsto F p (nhds f)) : TendstoLocallyUniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} : a - b < 0 â†’ a < b
(k : Type u_1) [divisionRing k] {Î¹ : Type u_4} (s : Finset Î¹) (i : Î¹) : Finset.centroidWeights k s i = (â†‘(s.card))â»Â¹
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [normedSpace ð•œ E'] {n : WithTop â„•} {f : E â†’ E'} {x : E} : ContMdiffAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') n f x â†’ ContDiffAt ð•œ n f x
{Î± : Type u} [Preorder Î±] {a b c : Î±} (hab : a â‰¤ b) (hbc : b = c) : a â‰¤ c
(m : â„¤) {n : â„¤} (hn : 0 < n) : (âˆƒ (k : â„¤), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m
{F : Type v} [NormedGroup F] [normedSpace â„‚ F] [CompleteSpace F] {R : â„} {c : â„‚} {f : â„‚ â†’ F} (hR : 0 < R) (hF : DiffContOnCl â„‚ f (Metric.Ball c R)) : deriv f c = (2 * â†‘Real.pi * Complex.i)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - c) ^ -2 â€¢ f z
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {Î¹ : Type u_6} [DecidableEq Î¹] {Mâ‚‚ : Type u_7} [AddCommMonoid Mâ‚‚] [Module R Mâ‚‚] (f : Mâ‚‚ â†’â‚—[R] M) (hF : Function.Surjective â‡‘f) : Function.Injective (Î» (g : AlternatingMap R M N Î¹), g.comp_Linear_Map f)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) [CategoryTheory.IsIso h.unit] : CategoryTheory.Faithful L
{Mâ‚ : Type u_3} {Mâ‚‚ : Type u_4} [AddCommGroup Mâ‚] [AddCommGroup Mâ‚‚] {R : Type u_1} [orderedRing R] [Module R Mâ‚] [Module R Mâ‚‚] {Qâ‚ : QuadraticForm R Mâ‚} {Qâ‚‚ : QuadraticForm R Mâ‚‚} (h : (Qâ‚.prod Qâ‚‚).anisotropic) : Qâ‚.anisotropic âˆ§ Qâ‚‚.anisotropic
(m : â„•+) (p : Nat.Primes) (k : â„•) : â†‘p ^ k âˆ£ m â†” k â‰¤ Multiset.count p m.factor_Multiset
{R : Type} [CommRing R] [CharZero R] {d : â„¤} (r : {r // r * r = â†‘d}) (hD : âˆ€ (n : â„¤), d â‰  n * n) : Function.Injective â‡‘(â‡‘Zsqrtd.lift r)
(V : Type u_2) {P : Type u_3} [semiNormedGroup V] [pseudoMetricSpace P] [NormedAddTorsor V P] (x y : P) : HasDist.dist x y = âˆ¥x -áµ¥ yâˆ¥
{ð•œ : Type u} [nondiscreteNormedField ð•œ] (p : Polynomial ð•œ) (x : ð•œ) : HasStrictDerivAt (Î» (x : ð•œ), Polynomial.eval x p) (Polynomial.eval x (â‡‘Polynomial.derivative p)) x
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] (v : PicardLindelof E) [CompleteSpace E] : âˆƒ (f : â„ â†’ E), f â†‘(v.tâ‚€) = v.xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ Set.Icc v.t_min v.t_max â†’ HasDerivWithinAt f (â‡‘v t (f t)) (Set.Icc v.t_min v.t_max) t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (X Y : C) [CategoryTheory.Limits.HasBinaryCoproduct X Y] : CategoryTheory.Limits.HasBinaryBiproduct X Y
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (e : localHomeomorph Î± Î²) {x : Î±} (h : x âˆˆ e.to_local_equiv.source) : ContinuousAt â‡‘e x
{Î± : Type u} (f : Filter Î±) [h : f.ne_IsBot] : âˆƒ (u : Ultrafilter Î±), â†‘u â‰¤ f
{R : Type u} {M : Type v} {Mâ‚‚ : Type w} {Mâ‚ƒ : Type y} [Semiring R] [AddCommMonoid M] [AddCommMonoid Mâ‚‚] [AddCommMonoid Mâ‚ƒ] [Module R M] [Module R Mâ‚‚] [Module R Mâ‚ƒ] {f g : M Ã— Mâ‚‚ â†’â‚—[R] Mâ‚ƒ} (hl : f.comp (LinearMap.inl R M Mâ‚‚) = g.comp (LinearMap.inl R M Mâ‚‚)) (hr : f.comp (LinearMap.inr R M Mâ‚‚) = g.comp (LinearMap.inr R M Mâ‚‚)) : f = g
(C : Type u) [CategoryTheory.Category C] [âˆ€ {X Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)] : CategoryTheory.Limits.HasBinaryCoproducts C
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {A B : Matrix n n R} (c : n â†’ R) (k : n) (hk : c k = 0) (A_Eq : âˆ€ (i j : n), A i j = B i j + c i * B k j) : A.det = B.det
{n : â„•} {p q : â„• Ã— â„•} (hp : p âˆˆ Finset.Nat.antidiagonal n) (hq : q âˆˆ Finset.Nat.antidiagonal n) : p = q â†” p.fst = q.fst
{n : â„•} [hpos : Fact (0 < n)] (i : Zmod(2 * n)) : orderOf (QuaternionGroup.xa i) = 4
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] [Fintype Î±] [DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ Î²) : s.sum (Î» (i : Î±), f i) + sá¶œ.sum (Î» (i : Î±), f i) = finset.univ.sum (Î» (i : Î±), f i)
{R : Type u_1} {a b : R} [AddCommSemigroup R] : IsAddRegular (a + b) â†” IsAddRegular a âˆ§ IsAddRegular b
{Î± : Type u} [topologicalSpace Î±] {s U : Set Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) : âˆƒ (V : Set Î±), s âŠ† V âˆ§ is_IsOpen V âˆ§ V âŠ† U
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : is_IsCompact s â†” âˆ€ {Î¹ : Type u} (U : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), is_IsOpen (U i)) â†’ (s âŠ† â‹ƒ (i : Î¹), U i) â†’ (âˆƒ (t : Finset Î¹), s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
{Î± : Type u} {s t : Set Î±} {l : Filter Î±} : s =á¶ [l] t â†’ (âˆ€á¶  (x : Î±) in l, x âˆˆ s â†” x âˆˆ t)
{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hfg : Function.IsFixedPt (f âˆ˜ g) x) (hg : Function.IsFixedPt g x) : Function.IsFixedPt f x
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) (Î¸ : Real.Angle) : o.oangle (â‡‘(o.rotation Î¸) x) (â‡‘(o.rotation Î¸) y) = o.oangle x y
{S : Set Ordinal} (hS : Set.Unbounded LT.lt S) {o : Ordinal} : {x : Ordinal | x âˆˆ S âˆ§ âˆ€ (c : Ordinal), c < o â†’ Ordinal.enumOrd S c < x}.nonempty
{R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N] [AddCommGroup P] [Module R P] [IsNoetherian R M] [IsNoetherian R P] (f : M â†’â‚—[R] N) (g : N â†’â‚—[R] P) (hF : Function.Injective â‡‘f) (hg : Function.Surjective â‡‘g) (h : f.range = g.ker) : IsNoetherian R N
{R : Type u_1} [CommRing R] {G : Module R} {x y : CategoryTheory.Over G} (h : CategoryTheory.Abelian.PseudoEqual G x y) : LinearMap.range x.hom = LinearMap.range y.hom
{M : Type u_2} [AddCommGroup M] {ð•œ : Type u_1} [Field ð•œ] [Module ð•œ M] (f : M â†’â‚—[ð•œ] M) (hF : â‡‘LinearMap.det f â‰  1) : FiniteDimensional ð•œ M
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) {l : List Î±} {n : â„•} (H : n < l.length) : f (l.nth_LE n H) = (List.map f l).nth_LE n _
(ð•œ : Type u_5) (ð•œ' : Type u_6) [normedField ð•œ] [SemiNormedRing ð•œ'] [NormedAlgebra ð•œ ð•œ'] [NormOneClass ð•œ'] : Isometry â‡‘(algebraMap ð•œ ??')
(x y z : Pgame) : (x * (y + z)).equiv (x * y + x * z)
{Î± : Type u_1} {Î¹ : sort u_4} {s : Set Î±} {t : Î¹ â†’ Set Î±} (i : Î¹) (h : s âŠ† t i) : s âŠ† â‹ƒ (i : Î¹), t i
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {E : Type uâ‚ƒ} [CategoryTheory.Category E] {F : C â¥¤ D} {G : D â¥¤ E} {H : C â¥¤ E} [â„‹ : CategoryTheory.Faithful H] (h : F â‹™ G = H) : CategoryTheory.Faithful F
{y : â„} (hy : 0 < y) : Filter.Tendsto (Î» (x : â„), x ^ y) Filter.atTop Filter.atTop
{a b : â„¤} (w : a âˆ£ b) (h : b.nat_Abs < a.nat_Abs) : b = 0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} (hn : 2 â‰¤ n + 1) (p : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) {r a C : â„} (hr : 0 â‰¤ r) (ha : 0 â‰¤ a) (hC : 0 â‰¤ C) (hp : âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C * r ^ n) : (Finset.ico 1 (n + 1)).sum (Î» (k : â„•), a ^ k * âˆ¥p.right_Inv i kâˆ¥) â‰¤ âˆ¥â†‘(i.symm)âˆ¥ * a + âˆ¥â†‘(i.symm)âˆ¥ * C * (Finset.ico 2 (n + 1)).sum (Î» (k : â„•), (r * (Finset.ico 1 n).sum (Î» (j : â„•), a ^ j * âˆ¥p.right_Inv i jâˆ¥)) ^ k)
(f : C(â†¥UnitInterval, â„)) : Filter.Tendsto (Î» (n : â„•), bernsteinApproximation n f) Filter.atTop (nhds f)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {n : WithTop â„•} {p : E â†’ FormalMultilinearSeries ð•œ E F} (hF : HasFtaylorSeriesUpToOn n f p s) {g : E â†’ G} {q : E â†’ FormalMultilinearSeries ð•œ E G} (hg : HasFtaylorSeriesUpToOn n g q s) : HasFtaylorSeriesUpToOn n (Î» (y : E), (f y, g y)) (Î» (y : E) (k : â„•), (p y k).prod (q y k)) s
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x : Î±} : Metric.infDist x (Closure s) = Metric.infDist x s
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [DecidableEq Î±] (H : FreeGroup.Red Lâ‚ Lâ‚‚) : FreeGroup.reduce Lâ‚ = FreeGroup.reduce Lâ‚‚
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] {a b : Î±} : a < bâ»Â¹ â†’ b < aâ»Â¹
{m n : â„•} : (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n
{n : â„•} : (fin.last n).succ_above = fin.cast_Succ
 : ConvexOn â„ Set.Univ Real.exp
{X : Type u_2} {Y : Type u_3} [topologicalSpace X] [topologicalSpace Y] [TopologicalSpace.MetrizableSpace Y] {f : X â†’ Y} (hF : Embedding f) : TopologicalSpace.MetrizableSpace X
{K : Type u_1} [linearOrderedField K] [floorRing K] {v : K} {n : â„•} {ifp_Succ_n : GeneralizedContinuedFraction.IntFractPair K} : GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = Option.some ifp_Succ_n â†” âˆƒ (ifp_n : GeneralizedContinuedFraction.IntFractPair K), GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n âˆ§ ifp_n.fr â‰  0 âˆ§ GeneralizedContinuedFraction.IntFractPair.of (ifp_n.fr)â»Â¹ = ifp_Succ_n
{F : Type} [Field F] (q : â„•) {f : Polynomial F} (hF : Polynomial.HasSeparableContraction q f) [hF : ExpChar F q] (g : Polynomial F) (hg : Polynomial.IsSeparableContraction q f g) : g.nat_degree = hf.degree
{n : â„•} {Î± : Type u_1} {v : Vector Î± (n + 1)} : v.reverse.head = v.last
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) {râ‚ râ‚‚ : â„} (hrâ‚ : 0 â‰¤ râ‚) (hrâ‚‚ : 0 â‰¤ râ‚‚) : o.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
(G : Pgame) [G.impartial] : G.equiv (nim G.grundy_value)
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (H : AddSubgroup G) (f : G â‰ƒ+ N) : AddSubgroup.map f.to_Add_MonoidHom H.normalizer = (AddSubgroup.map f.to_Add_MonoidHom H).normalizer
{C : Type uâ‚} [CategoryTheory.Category C] {Z X Y P : C} {f : Z âŸ¶ X} {g : Z âŸ¶ Y} {inl_ : X âŸ¶ P} {inr_ : Y âŸ¶ P} (w : CategoryTheory.CommSq f g inl_ inr_) (h : CategoryTheory.Limits.IsColimit w.cocone) : CategoryTheory.IsPushout f g inl_ inr_
{Î± : Type u} [Preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] (not_TerminatedAt_n : Â¬(GeneralizedContinuedFraction.of v).terminated_at n) : (GeneralizedContinuedFraction.of v).numerators n * (GeneralizedContinuedFraction.of v).denominators (n + 1) - (GeneralizedContinuedFraction.of v).denominators n * (GeneralizedContinuedFraction.of v).numerators (n + 1) = (-1) ^ (n + 1)
{Î± : Type u} [AddGroup Î±] : IsAddGroupHom Id
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup V1] [Module k V1] [addTorsor V1 P1] [AddCommGroup V2] [Module k V2] [addTorsor V2 P2] (f : P1 â†’áµƒ[k] P2) (p1 p2 : P1) : â‡‘(f.linear) (p1 -áµ¥ p2) = â‡‘f p1 -áµ¥ â‡‘f p2
{M : Type u_1} [CommMonoid M] {s : Set M} (hs : IsSubmonoid s) (m : Multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
{ð•œ : Type u} [hnorm : nondiscreteNormedField ð•œ] {E : Type v} [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul ð•œ E] (l : E â†’â‚—[ð•œ] ð•œ) (hl : is_IsClosed â†‘(l.ker)) : Continuous â‡‘l
{a : â„} {l : Filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Ioi a), DifferentiableAt â„ f x) (hg' : âˆ€á¶  (x : â„) in nhdsWithin a (Set.Ioi a), deriv g x â‰  0) (hfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds 0)) (hga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv f x / deriv g x) (nhdsWithin a (Set.Ioi a)) l) : Filter.Tendsto (Î» (x : â„), f x / g x) (nhdsWithin a (Set.Ioi a)) l
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type uâ‚‚} [CategoryTheory.Category D] [CategoryTheory.Abelian D] (F : C â¥¤ D) (G : D â¥¤ C) [G.preserves_Zero_morphisms] (i : F â‹™ G â‰… ðŸ­ C) (Adj : G âŠ£ F) : CategoryTheory.Limits.HasCokernels C
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x y : E} : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * â‡‘is_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] (F : J â¥¤ Type u) [hF : Î  (j : J), Fintype (F.obj j)] [hne : âˆ€ (j : J), Nonempty (F.obj j)] : F.sections.nonempty
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : EuclideanGeometry.orthogonalProjectionFn s p âˆˆ s
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [linearOrderedAddCommGroup Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l Filter.atBot) : Filter.Tendsto (Î» (x : Î²), f x + g x) l Filter.atBot
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = Real.pi) : EuclideanGeometry.angle p2 p3 p1 = 0
{R : Type u_1} [orderedSemiring R] [Nontrivial R] : CharZero R
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : ContinuousAt f a) (hb : ContinuousAt f b) : HasStrictFderivAt (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd â„ â„ â„).smul_Right (f b) - (ContinuousLinearMap.fst â„ â„ â„).smul_Right (f a)) (a, b)
{R : Type u_3} {S : Type u_4} {A : Type u_5} [CommRing R] [CommRing S] [CommRing A] [Algebra R S] [Algebra S A] [Algebra R A] [isScalarTower R S A] (hinj : Function.Injective â‡‘(algebraMap R S)) {x : A} (A_alg : IsAlgebraic R x) : IsAlgebraic S x
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] {gp : GeneralizedContinuedFraction.Pair K} (nth_s_Eq : (GeneralizedContinuedFraction.of v).s.nth n = Option.some gp) : gp.a = 1 âˆ§ âˆƒ (z : â„¤), gp.b = â†‘z
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (w : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘(âˆ….weighted_vsub p) w = 0
{A : Type u_5} [CommRing A] {m : Type u_6} {n : Type u_7} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] {M : Matrix n m A} {N M' : Matrix m n A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : (M.mul N).det = (N.mul M).det
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Nontrivial R] (e : Basis Î¹ R M) (i : Î¹) : (e.units_Smul (Function.update 1 i (-1))).orientation = -e.orientation
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D â¥¤ C} [CategoryTheory.Reflective i] {A : C} (h : A âˆˆ i.ess_image) : CategoryTheory.IsIso ((CategoryTheory.Adjunction.ofRightAdjoint i).unit.app A)
{Mâ‚€ : Type u_1} [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€] {a b : Mâ‚€} : 0 = a * b â†” a = 0 âˆ¨ b = 0
{Î± : Type u_1} : vector.nil.tail = Vector.nil
{ð•œ : Type u_1} {Î± : Type u_2} [linearOrderedField ð•œ] [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {r : â„•} (hr : r â‰  0) (hð’œ : Set.Sized r â†‘ð’œ) : â†‘(ð’œ.card) / â†‘((Fintype.card Î±).choose r) â‰¤ â†‘(ð’œ.shadow.card) / â†‘((Fintype.card Î±).choose (r - 1))
{Î± : Type u} : DenseInducing Pure.pure
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [divisionMonoid Î²] (f : Î± â†’* Î²) (a : Î±) : â‡‘f aâ»Â¹ = (â‡‘f a)â»Â¹
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] [IsPredArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ Set.Ioc m n â†’ r i (Order.pred i)) (hnm : m â‰¤ n) : Relation.ReflTransGen r n m
 : expNegInvGlue.fAux 0 = expNegInvGlue
(k : â„•) {b : â„} (hb : 0 < b) : (Î» (x : â„), x ^ k) =o[Filter.atTop] Î» (x : â„), Real.exp (b * x)
{R : Type u_1} [CommGroup R] {f g : â„• â†’ R} : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.prod (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.prod (Î» (x : â„• Ã— â„•), g x.snd ^ â‡‘Nat.ArithmeticFunction.moebius x.fst) = f n
{Râ‚‚ : Type u_5} {Mâ‚‚ : Type u_6} [CommSemiring Râ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {Bâ‚‚ Fâ‚‚ : BilinForm Râ‚‚ Mâ‚‚} {Î¹ : Type u_13} (b : Basis Î¹ Râ‚‚ Mâ‚‚) (h : âˆ€ (i j : Î¹), â‡‘Bâ‚‚ (â‡‘b i) (â‡‘b j) = â‡‘Fâ‚‚ (â‡‘b i) (â‡‘b j)) : Bâ‚‚ = Fâ‚‚
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : InnerProductGeometry.angle (-x) y = Real.pi - InnerProductGeometry.angle x y
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] (v : V) (n : v â‰  0) (h : âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w) : FiniteDimensional.finrank K V = 1
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {f g : Equiv.perm Î±} (hF : f.is_Cycle) (hg : g.is_Cycle) (h : âˆ€ (x : Î±), x âˆˆ f.support âˆ© g.support â†’ â‡‘f x = â‡‘g x) {x : Î±} (hx : â‡‘f x = â‡‘g x) (hx' : x âˆˆ f.support) : f = g
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {f : Î± â†’ Î²} {x : Î±} (hF : IsRingHom f) : f (-x) = -f x
(F : Type u_1) [Field F] (E : Type u_2) [Field E] [Algebra F E] [Fintype F] [FiniteDimensional F E] : âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 p2 : P) : EuclideanGeometry.angle p1 p1 p2 = Real.pi / 2
{Î± : Type u_1} {A B : Set (Finset Î±)} {r : â„•} : Set.Sized r A âˆ§ Set.Sized r B â†’ Set.Sized r (A âˆª B)
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {f : M â†’+ P} (x : M) : â‡‘(AddCon.ker f) x = â‡‘f â»Â¹' {â‡‘f x}
{n : â„•} (i : Zmod n) : orderOf (DihedralGroup.sr i) = 2
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [HasScalar ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : ConvexOn ð•œ s f) (c : E) : ConvexOn ð•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
{Î± : Type u} (s : Set (Set Î±)) : {t : Set Î± | MeasurableSpace.GenerateMeasurable s t} = â‹ƒ (i : (quotient.out (Cardinal.aleph 1).ord).Î±), MeasurableSpace.GenerateMeasurableRec s i
{x : â„} : (âˆ€ (p : â„), LiouvilleWith p x) â†” Liouville x
{M : Type u_1} {A : Type u_2} [CommMonoid M] {s : Set M} (hs : IsSubmonoid s) (f : A â†’ M) (t : Finset A) : (âˆ€ (b : A), b âˆˆ t â†’ f b âˆˆ s) â†’ t.prod (Î» (b : A), f b) âˆˆ s
{Î± : sort u} {Î² : sort v} : Function.Injective coeFn
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x z - o.oangle y z = o.oangle x y
{Î± : Type u} [t : topologicalSpace Î±] {B : Set (Set Î±)} (hB : TopologicalSpace.IsTopologicalBasis B) {u : Set Î±} (ou : is_IsOpen u) : u = â‹ƒâ‚€{s âˆˆ B | s âŠ† u}
{Î± : Type u_1} [Preorder Î±] [succOrder Î±] {a b : Î±} [NoMaxOrder Î±] : Order.succ a â‰¤ Order.succ b â†’ a â‰¤ b
{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B] [Subsingleton (Subalgebra R A)] : Subsingleton (A â†’â‚[R] B)
{m n : â„•} : m âˆ£ n + m â†” m âˆ£ n
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {t : Finset V} (h : FiniteDimensional.finrank K V + 1 < t.card) : âˆƒ (f : V â†’ K), t.sum (Î» (e : V), f e â€¢ e) = 0 âˆ§ t.sum (Î» (e : V), f e) = 0 âˆ§ âˆƒ (x : V) (H : x âˆˆ t), f x â‰  0
{Î¹ : Type w} {Î¹' : Type w'} {R : Type u} [Ring R] [InvariantBasisNumber R] {M : Type v} [AddCommGroup M] [Module R M] (v : Basis Î¹ R M) (v' : Basis Î¹' R M) : (Cardinal.mk Î¹).lift = (Cardinal.mk Î¹').lift
{R : Type u_1} [normedRing R] {x : R} (h : âˆ¥xâˆ¥ < 1) : Filter.Tendsto (Î» (n : â„•), x ^ n) Filter.atTop (nhds 0)
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [is_IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) : Prime (minpoly A x)
{L : FirstOrder.Language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] {f g : L.hom M N} {s : Set M} (h : Set.EqOn â‡‘f â‡‘g s) : Set.EqOn â‡‘f â‡‘g â†‘(â‡‘(FirstOrder.Language.Substructure.closure L) s)
{Î± : Type u_1} [uniformSpace Î±] : (Uniformity Î±).has_Basis (Î» (V : Set (Î± Ã— Î±)), V âˆˆ Uniformity Î± âˆ§ is_IsOpen V) Id
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} : 0 â‰¤ a - b â†’ b â‰¤ a
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} {T : Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [CommMonoid Q] {k : T.localization_Map Q} (z : N) (u : Q) : â‡‘(f.map hy k) z = u â†” â‡‘(k.to_Map) (â‡‘g (f.sec z).fst) = â‡‘(k.to_Map) (â‡‘g â†‘((f.sec z).snd)) * u
{p : â„• â†’ Prop} [DecidablePred p] {n : â„•} : p n â†’ Nat.count p (n + 1) = Nat.count p n + 1
{Î± : Type u_1} [Preorder Î±] {a b : Î±áµ’áµˆ} : b â©¿ a â†’ â‡‘OrderDual.ofDual a â©¿ â‡‘OrderDual.ofDual b
{M : Type u_1} [AddMonoid M] {s t : Set M} (h : s âŠ† t) : Add_monoid.closure s âŠ† Add_monoid.closure t
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î²] [topologicalSpace Î³] [t2_Space Î³] {f : Î± â†’ Î²} (hfd : DenseRange f) {g h : Î² â†’ Î³} (hg : Continuous g) (hH : Continuous h) (H : g âˆ˜ f = h âˆ˜ f) : g = h
(K : Type u_1) [Field K] [NumberField K] : Â¬IsField â†¥(NumberField.ringOfIntegers K)
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {R : Nnreal} {c : â„‚} {f : â„‚ â†’ E} (hF : DiffContOnCl â„‚ f (Metric.Ball c â†‘R)) (hR : 0 < R) : HasFpowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R
(a b : â„•) : a - b.succ = a - b - 1
{X : Type u_1} {Y : Type u_2} [tY : topologicalSpace Y] [discreteTopology Y] {f : X â†’ Y} (hF : Function.Injective f) : discreteTopology X
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : M (Sum.inr ()) (Sum.inr ()) â‰  0) (i : Fin r) : M.mul (Matrix.Pivot.listTransvecRow M).prod (Sum.inr ()) (Sum.inl i) = 0
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {f : Filter Î±} [IsTrans Î± r] [f.ne_IsBot] : Filter.IsBounded r f â†’ Filter.IsCobounded (Flip r) f
{c : â„} (h1 : 0 < c) (h2 : c < 1 / 2) : Function.Injective (Cardinal.cantorFunction c)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) : o.rotation â†‘Real.pi = LinearIsometryEquiv.neg â„
(R : Type u_1) [CommRing R] (m n : â„•) : Polynomial.dickson 1 1 (m * n) = (Polynomial.dickson 1 1 m).comp (Polynomial.dickson 1 1 n)
{Î± : Type u} [LinearOrder Î±] (a b : Î±) : Linear_order.max a b = a âˆ§ b â‰¤ a âˆ¨ Linear_order.max a b = b âˆ§ a < b
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [CommMonoid Î²] {s : Finset Î³} {t : Î³ â†’ Finset Î±} {t' : Finset Î±} {s' : Î± â†’ Finset Î³} (h : âˆ€ (x : Î³) (y : Î±), x âˆˆ s âˆ§ y âˆˆ t x â†” x âˆˆ s' y âˆ§ y âˆˆ t') {f : Î³ â†’ Î± â†’ Î²} : s.prod (Î» (x : Î³), (t x).prod (Î» (y : Î±), f x y)) = t'.prod (Î» (y : Î±), (s' y).prod (Î» (x : Î³), f x y))
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s1 s2 : AffineSubspace k P) : s1 â‰¤ s2 â†” âˆ€ (p : P), p âˆˆ s1 â†’ p âˆˆ s2
{G : Type u_1} [Group G] {p : â„•} [Fact (Nat.Prime p)] {N : Subgroup G} [N.normal] [Fintype (Sylow p â†¥N)] (P : Sylow p â†¥N) : (Subgroup.map N.subtype â†‘P).normalizer âŠ” N = âŠ¤
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Semiring R] [AddCommMonoid N] [Module R N] [Î  (m : R), Decidable (m â‰  0)] (p : Î¹ â†’ Submodule R N) {v : Î¹ â†’ N} (hv : âˆ€ (i : Î¹), v i âˆˆ p i) : (â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)).comp ((Dfinsupp.mapRange.linearMap (Î» (i : Î¹), LinearMap.toSpanSingleton R â†¥(p i) âŸ¨v i, _âŸ©)).comp (finsuppLequivDfinsupp R).to_Linear_Map) = Finsupp.total Î¹ N R v
{Î± : Type u_1} [pseudoEmetricSpace Î±] (r C : Ennreal) (hr : r < 1) (hC : C â‰  âŠ¤) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (f n) (f (n + 1)) â‰¤ C * r ^ n) : CauchySeq f
{R : Type u} [Ring R] {s : Set R} {t : Subring R} : Subring.closure s â‰¤ t â†” s âŠ† â†‘t
{Î± : Type u} [pseudoMetricSpace Î±] [ProperSpace Î±] {x : Î±} {r : â„} {s : Set Î±} (hr : 0 < r) (hs : is_IsClosed s) (h : s âŠ† Metric.Ball x r) : âˆƒ (r' : â„) (H : r' âˆˆ Set.Ioo 0 r), s âŠ† Metric.Ball x r'
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [FiniteDimensional ð•œ E] [FiniteDimensional ð•œ F] (A : E â†’â‚—[ð•œ] F) (x : E) (y : F) : HasInner.inner x (â‡‘(â‡‘LinearMap.adjoint A) y) = HasInner.inner (â‡‘A x) y
(ð•œ : Type u_1) {E : Type u_2} [normedLinearOrderedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [normedSpace â„ E] [LinearMap.CompatibleSmul E E ð•œ â„] (h : StrictConvex ð•œ (Metric.ClosedBall 0 1)) : StrictConvexSpace ð•œ E
{R : Type u_2} {M : Type u_3} [AddCommGroup M] [Ring R] [Module R M] {Q : QuadraticForm R M} : Q.to_fun = â‡‘Q
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasEqualizers C] {X Y : C} {f : X âŸ¶ Y} (h : f = 0) [CategoryTheory.Limits.HasImage f] : CategoryTheory.Limits.imageÎ¹ f = 0
{G : Type u_1} [Group G] (H N : Subgroup G) [N.normal] : â†‘(H âŠ” N) = â†‘H * â†‘N
{K : Type u_1} {n : â„•} {s : Seq (GeneralizedContinuedFraction.Pair K)} [divisionRing K] (TerminatedAt_Succ_n : s.terminated_at (n + 1)) : GeneralizedContinuedFraction.squashSeq s n = s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (h : s.sum (Î» (i : Î¹), w i) = 1) (b : P) : â‡‘(s.affine_combination p) w = â‡‘(s.weighted_vsub_of_point p b) w +áµ¥ b
{Î± : Type u_1} {Î² : Type u_2} {rÎ± : Î± â†’ Î± â†’ Prop} {rÎ² : Î² â†’ Î² â†’ Prop} {a : Î±} {b : Î²} (ha : Acc rÎ± a) (hb : Acc rÎ² b) : Acc (Relation.GameAdd rÎ± rÎ²) (a, b)
{Î¹ : Type u_1} {X : Type u_2} [topologicalSpace X] [NormalSpace X] {u : Î¹ â†’ Set X} (uo : âˆ€ (i : Î¹), is_IsOpen (u i)) (uf : âˆ€ (x : X), {i : Î¹ | x âˆˆ u i}.finite) (uU : (â‹ƒ (i : Î¹), u i) = Set.Univ) : âˆƒ (v : Î¹ â†’ Set X), Set.Union v = Set.Univ âˆ§ (âˆ€ (i : Î¹), is_IsClosed (v i)) âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
{C : Type uâ‚} [CategoryTheory.Category C] {T : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] (D : J â¥¤ T.algebra) [CategoryTheory.Limits.HasLimit (D â‹™ T.forget)] : CategoryTheory.Limits.HasLimit D
(t : â„) : Filter.Tendsto (Î» (x : â„), (1 + t / x) ^ x) Filter.atTop (nhds (Real.exp t))
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) (hF'_nonpos : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv f x â‰¤ 0) : AntitoneOn f D
{Î± : sort u} {f : Î± â†’ Î±} (h : Function.involutive f) {x y : Î±} : f x = y â†” x = f y
{n : â„•} [Fact (0 < n)] (a : Zmod n) : â†‘(a.val) = a
{n : â„•} (h : n â‰  0) (d : â„•) : âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [Mod n]
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] {bâ‚ bâ‚‚ : Basis Î¹ R M} (h : âˆ€ (x : M) (i : Î¹), â‡‘(â‡‘(bâ‚.repr) x) i = â‡‘(â‡‘(bâ‚‚.repr) x) i) : bâ‚ = bâ‚‚
{f : â„ â†’ â„} {f' a : â„} (h : is_is_IsLocalMin f a) (hF : HasDerivAt f f' a) : f' = 0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {s : Set E} [CompleteSpace F] (h : AnalyticOn ð•œ f s) {n : WithTop â„•} : ContDiffOn ð•œ n f s
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] {L : C â¥¤ D} {R : D â¥¤ C} (Adj : L âŠ£ R) : L.initial
{Mâ‚€ : Type u_6} [monoidWithZero Mâ‚€] [Nontrivial Mâ‚€] [NoZeroDivisors Mâ‚€] {L : List Mâ‚€} : L.prod = 0 â†” 0 âˆˆ L
{G : Type u_1} [AddGroup G] (tG : Add_monoid.is_torsion G) (H : AddSubgroup G) : Add_monoid.is_torsion â†¥H
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{ð•œ : Type u_1} [linearOrderedField ð•œ] {x y : ð•œ} (h : x < y) {z : ð•œ} : z âˆˆ Set.Ioo x y â†” âˆƒ (a b : ð•œ), 0 < a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n m : â„•} (n_LE_m : n â‰¤ m) (TerminatedAt_n : g.terminated_at n) : g.terminated_at m
{M : Type u_1} [Monoid M] {s : Set M} {a : M} (hs : IsSubmonoid s) (h : a âˆˆ s) {n : â„•} : a ^ n âˆˆ s
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {s : Set E} {x : E} {f' : TangentSpace (modelWithCornersSelf ð•œ E) x â†’L[ð•œ] TangentSpace (modelWithCornersSelf ð•œ E') (f x)} : HasFderivWithinAt f f' s x â†’ HasMfderivWithinAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f s x f'
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : Set P} {s1 : AffineSubspace k P} (h : s âŠ† â†‘s1) : SpanPoints k s âŠ† â†‘s1
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] (hb : Fintype.card Î² â€¢ b < finset.univ.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²), b < (Finset.filter (Î» (x : Î±), f x = y) Finset.univ).sum (Î» (x : Î±), w x)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [CompactSpace Î±] [metricSpace Î²] {f g : C(Î±, Î²)} {C : â„} (C0 : 0 â‰¤ C) : HasDist.dist f g â‰¤ C â†” âˆ€ (x : Î±), HasDist.dist (â‡‘f x) (â‡‘g x) â‰¤ C
{R : Type u_1} [CommRing R] (u v w : Fin 3 â†’ R) : â‡‘(â‡‘crossProduct u) (â‡‘(â‡‘crossProduct v) w) = â‡‘(â‡‘crossProduct (â‡‘(â‡‘crossProduct u) v)) w + â‡‘(â‡‘crossProduct v) (â‡‘(â‡‘crossProduct u) w)
{Î± : Type u} [pseudoMetricSpace Î±] (p : Î± â†’ Prop) (x : Î±) (H : âˆƒá¶  (R : â„) in Filter.atTop, âˆ€ (y : Î±), y âˆˆ Metric.Ball x R â†’ p y) (y : Î±) : p y
{Î± : Type u_1} [HasLe Î±] {s : Set Î±áµ’áµˆ} : IsUpperSet s â†’ IsLowerSet (â‡‘OrderDual.toDual â»Â¹' s)
{R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) (r : R) (y : A) : x * (â‡‘(algebraMap R A) r * y) = â‡‘(algebraMap R A) r * (x * y)
{R : Type u_5} [CommRing R] [is_IsDomain R] {k l : â„•} (h : k â‰  l) : Disjoint (primitiveRoots k R) (primitiveRoots l R)
{R : Type u_1} [rightCancelSemigroup R] (g : R) : IsRightRegular g
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (hs : is_IsCompact s) {e : â„} (hE : 0 < e) : âˆƒ (t : Set Î±) (H : t âŠ† s), t.finite âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), Metric.Ball x e
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [DecidableEq Î¹] [Î  (i : Î¹), LinearOrder (Î± i)] (x y x' y' : Î  (i : Î¹), Î± i) : Set.Icc x y  set.univ.pi (Î» (i : Î¹), Set.Ioo (x' i) (y' i)) âŠ† (â‹ƒ (i : Î¹), Set.Icc x (Function.update y i (x' i))) âˆª â‹ƒ (i : Î¹), Set.Icc (Function.update x i (y' i)) y
{Î± : Type u} [uniformSpace Î±] {f : Filter Î±} {x : Î±} (hF : Cauchy f) (adhs : ClusterPt x f) : f â‰¤ nhds x
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] : Function.Injective equiv.perm.cycle_Factors_Finset
{Î± : Type u_1} [Monoid Î±] {a : Î±} {u : Î±Ë£} : â†‘u âˆ£ a
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {b : M} [linearOrderedCommRing M] [Nonempty Î²] (hb : â†‘(Fintype.card Î±) â‰¤ Fintype.card Î² â€¢ b) : âˆƒ (y : Î²), â†‘((Finset.filter (Î» (x : Î±), f x = y) Finset.univ).card) â‰¤ b
{Î± : Type u_2} [DecidableEq Î±] {s : Finset Î±} {B : Finset (Finset Î±)} {n : â„•} (h : âˆ€ (a : Î±), a âˆˆ s â†’ (Finset.filter (HasMem.Mem a) B).card = n) : B.sum (Î» (t : Finset Î±), (s âˆ© t).card) = s.card * n
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] (hF : âˆ€ (y : Î²), y âˆ‰ t â†’ (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) â‰¤ 0) (ht : t.nonempty) (hb : t.card â€¢ b â‰¤ s.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²) (H : y âˆˆ t), b â‰¤ (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] (p : E) : â‡‘(reflection K) (â‡‘(reflection K) p) = p
{p : â„•} : Summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (h : âˆ€ {Î¹ : Type u} (Z : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), is_IsClosed (Z i)) â†’ (s âˆ© â‹‚ (i : Î¹), Z i) = âˆ… â†’ (âˆƒ (t : Finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i) = âˆ…)) : is_IsCompact s
{G : Type w} [topologicalSpace G] [Group G] [TopologicalGroup G] {K U : Set G} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K âŠ† U) : âˆƒ (V : Set G) (H : V âˆˆ nhds 1), V * K âŠ† U
{Î± : Type u_1} [Preorder Î±] [Nonempty Î±] [NoMinOrder Î±] : Infinite Î±
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace ð•œ] [FiniteDimensional ð•œ E] {n : â„•} {f : E â†’ F} : ContDiff ð•œ â†‘(n + 1) f â†” Differentiable ð•œ f âˆ§ âˆ€ (y : E), ContDiff ð•œ â†‘n (Î» (x : E), â‡‘(fderiv ð•œ f x) y)
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] [Fintype m] [DecidableEq m] (A : Matrix m m Î±) (B : Matrix m n Î±) (C : Matrix n m Î±) (D : Matrix n n Î±) [Invertible D] : (Matrix.fromBlocks A B C D).det = D.det * (A - (B.mul (â…Ÿ D)).mul C).det
{R : Type u} {M : Type v} [CommRing R] [Nontrivial R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] (f : M â†’â‚—[R] M) (p : Polynomial R) : â‡‘(Polynomial.aeval f) p = â‡‘(Polynomial.aeval f) (p %â‚˜ f.charpoly)
{X : Top} (F : Top.Presheaf (Type v) X) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥X) (sf : Top.Presheaf.SheafConditionEqualizerProducts.piOpens F U) (s : F.obj (Opposite.op (supr U))) : F.is_gluing U ((F.pi_Opens_iso_sections_family U).hom sf) s â†” Top.Presheaf.SheafConditionEqualizerProducts.res F U s = sf
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) (hF'_Mono : MonotoneOn (deriv f) (Interior D)) : ConvexOn â„ D f
{f : â„• â†’ â„} (hfa : Antitone f) (hF0 : Filter.Tendsto f Filter.atTop (nhds 0)) : CauchySeq (Î» (n : â„•), (Finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i))
{Î± : Type u} [nonUnitalCommRing Î±] {b c x : Î±} (h : x * x - b * x + c = 0) : âˆƒ (y : Î±), y * y - b * y + c = 0 âˆ§ x + y = b âˆ§ x * y = c
{Î² : Type u_2} [OrderedAddCommGroup Î²] [Module â„ Î²] [OrderedSmul â„ Î²] {f : â„ â†’ Î²} {a b : â„} (a_Lt_b : a < b) (h_is_IsLocalMin : is_IsLocalMinOn f (Set.Icc a b) a) (h_conv : ConvexOn â„ (Set.Icc a b) f) : IsMinOn f (Set.Icc a b) a
{Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), Monoid (M i)] {N : Type u_3} [Monoid N] (f g : FreeProduct M â†’* N) (h : âˆ€ (i : Î¹), f.comp FreeProduct.of = g.comp FreeProduct.of) : f = g
{M : Type u_1} [hasMul M] {c d : Con M} : (âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) â†” c = d
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_3} (l : Î¹ â†’â‚€ ð•œ) (v : Î¹ â†’ E) (x : E) : HasInner.inner x (l.sum (Î» (i : Î¹) (a : ð•œ), a â€¢ v i)) = l.sum (Î» (i : Î¹) (a : ð•œ), a â€¢ HasInner.inner x (v i))
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) (m : M) : 0 â‰¤ âˆ¥â‡‘(QuotientAddGroup.mk' S) mâˆ¥
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x y : E} : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * â‡‘is_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (f : localHomeomorph E F) {f' : E â‰ƒL[ð•œ] F} {a : F} (ha : a âˆˆ f.to_local_equiv.target) (htff' : HasFderivAt â‡‘f â†‘f' (â‡‘(f.symm) a)) : HasFderivAt â‡‘(f.symm) â†‘(f'.symm) a
{Î± : Type u_1} (r : Setoid Î±) : setoid.mk_Classes r.classes setoid.classes_eqv_Classes = r
{Î± : Type u_1} {Î² : Type u_3} [measurableSpace Î±] [measurableSpace Î²] {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : MeasurableSpace.generateFrom C = _inst_1) (hD : MeasurableSpace.generateFrom D = _inst_3) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) : MeasurableSpace.generateFrom (Set.image2 HasSetProd.prod C D) = Prod.measurableSpace
(a : â„) : Cardinal.mk â†¥(Set.Ici a) = Cardinal.continuum
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} (h : SameRay R x y) : SameRay R y x
{p : Polynomial â„š} (p_irr : Irreducible p) (p_deg : Nat.Prime p.nat_degree) (p_roots : Fintype.card â†¥(p.root_Set â„‚) = Fintype.card â†¥(p.root_Set â„) + 2) : Function.bijective â‡‘(Polynomial.Gal.galActionHom p â„‚)
{M : Type u_6} {N : Type u_7} [hasAdd M] [hasAdd N] (e : M â‰ƒ+ N) (x : M) : â‡‘(e.symm) (â‡‘e x) = x
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] [NormedGroup G] [normedSpace ð•œ G] {n : â„•} (p : FormalMultilinearSeries ð•œ E F) (c : Composition n) (f : ContinuousMultilinearMap ð•œ (Î» (i : Fin c.length), F) G) (v : Fin n â†’ E) : âˆ¥â‡‘(ContinuousMultilinearMap.compAlongComposition p c f) vâˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.prod (Î» (i : Fin c.length), âˆ¥p (c.blocks_fun i)âˆ¥) * finset.univ.prod (Î» (i : Fin n), âˆ¥v iâˆ¥)
{Î± : Type u_1} [linearOrderedField Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b â†” b < a
{ð•œ : Type u_1} {E : Type u_2} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] {s : Set E} : Convex ð•œ s â†” âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ âˆ€ â¦ƒa b : ð•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 < a + b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ s
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x : E} : âˆ¥â‡‘innerSL xâˆ¥ = âˆ¥xâˆ¥
{Î± : Type u_2} [Preorder Î±] [NoMaxOrder Î±] : Filter.atTop â‰¤ Filter.cofinite
{p : â„•} [hp_Prime : Fact (Nat.Prime p)] {R : Type u_1} [NonAssocSemiring R] {f : Î  (k : â„•), R â†’+* Zmod(p ^ k)} (f_compat : âˆ€ (k1 k2 : â„•) (hk : k1 â‰¤ k2), (Zmod.castHom _ (Zmod(p ^ k1))).comp (f k2) = f k1) (n : â„•) : (PadicInt.toZmodPow n).comp (PadicInt.lift f_compat) = f n
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] {p : Î± â†’ Prop} {s : Finset {x // p x}} {f : {x // p x} â†’ Î²} {g : Î± â†’ Î²} (h : âˆ€ (x : {x // p x}), x âˆˆ s â†’ g â†‘x = f x) : (Finset.map (Function.Embedding.subtype (Î» (x : Î±), p x)) s).prod (Î» (x : Î±), g x) = s.prod (Î» (x : {x // p x}), f x)
{Î± : Type u_2} {Î¹ : Type u_5} [AddCommMonoid Î±] [Fintype Î¹] (f : Î¹ â†’ Set Î±) (a : Î±) : a âˆˆ finset.univ.sum (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), g i âˆˆ f i), finset.univ.sum (Î» (i : Î¹), g i) = a
{R : Type u_1} [Semiring R] (r : R) (f : Polynomial R) (n : â„•) : (â‡‘(Polynomial.taylor r) f).coeff n = Polynomial.eval r (â‡‘(Polynomial.hasseDeriv n) f)
{p : â„• â†’ Prop} : (âˆƒ (x : â„•), p x) â†’ WellFounded (Nat.Upto.Gt p)
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] [NormedGroup F] [normedSpace â„ F] [TopologicalSpace.SecondCountableTopology F] (f : E â†’ F) (s : Set E) (f' : E â†’ (E â†’L[â„] F)) (hF' : âˆ€ (x : E), x âˆˆ s â†’ HasFderivWithinAt f (f' x) s x) (r : (E â†’L[â„] F) â†’ Nnreal) (rpos : âˆ€ (A : E â†’L[â„] F), r A â‰  0) : âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ (E â†’L[â„] F)), (âˆ€ (n : â„•), is_IsClosed (t n)) âˆ§ (s âŠ† â‹ƒ (n : â„•), t n) âˆ§ (âˆ€ (n : â„•), ApproximatesLinearOn f (A n) (s âˆ© t n) (r (A n))) âˆ§ (s.nonempty â†’ âˆ€ (n : â„•), âˆƒ (y : E) (H : y âˆˆ s), A n = f' y)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (hG : CategoryTheory.CompatiblePreserving K G) (â„± : CategoryTheory.SheafOfTypes K) {Z : C} {T : CategoryTheory.Presieve Z} {x : CategoryTheory.Presieve.FamilyOfElements (G.op â‹™ â„±.val) T} (h : x.compatible) : (CategoryTheory.Presieve.FamilyOfElements.functorPushforward G x).compatible
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} {C : â„} (hF : ContinuousOn f (Set.Icc a b)) (hF' : âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ C) (x : â„) (H : x âˆˆ Set.Icc a b) : âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
{Î± : Type u} [Preorder Î±] [OrderTop Î±] {a b : Î±} (h : a < b) : a â‰  âŠ¤
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M â†’* P} (h : c â‰¤ Con.ker f) (hF : Function.Surjective â‡‘f) : Function.Surjective â‡‘(c.lift f h)
{Î± : Type u_1} {f g : Î± â†’ â„} {tâ‚€ : Filter Î±} (hF : âˆ€á¶  (t : Î±) in tâ‚€, 0 â‰¤ f t) (hft : âˆ€á¶  (t : Î±) in tâ‚€, f t â‰¤ g t) (g0 : Filter.Tendsto g tâ‚€ (nhds 0)) : Filter.Tendsto f tâ‚€ (nhds 0)
{Î¹ : Type u} {f g : Î¹ â†’ Nnreal} {p q : â„} (hpq : p.is_conjugate_exponent q) (hF : Summable (Î» (i : Î¹), f i ^ p)) (hg : Summable (Î» (i : Î¹), g i ^ q)) : Summable (Î» (i : Î¹), f i * g i) âˆ§ âˆ‘' (i : Î¹), f i * g i â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) * (âˆ‘' (i : Î¹), g i ^ q) ^ (1 / q)
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Î¹ : Type w} [Fintype Î¹] (h : Basis Î¹ K V) : FiniteDimensional K V
{Î± : Type u_1} {s : Set Î±} : s.pairwise âŠ¥ â†’ s.subsingleton
{R : Type u_1} [normedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„} (h : âˆ¥râ‚âˆ¥ < râ‚‚) : (Î» (n : â„•), â†‘n ^ k * râ‚ ^ n) =o[Filter.atTop] Î» (n : â„•), râ‚‚ ^ n
{Î± : Type u} {lâ‚ lâ‚‚ : List Î±} {n : â„•} : List.drop n (lâ‚ ++ lâ‚‚) = List.drop n lâ‚ ++ List.drop (n - lâ‚.length) lâ‚‚
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [Semiring R] [AddCommMonoid M] [Module R M] [Fintype Î¹] : LinearIndependent R v â†” (â‡‘(LinearMap.lsum R (Î» (i : Î¹), R) â„•) (Î» (i : Î¹), Linear_map.id.smul_Right (v i))).ker = âŠ¥
{C : Type u} [CategoryTheory.Category C] {X : C} {S R : CategoryTheory.Sieve X} (J : CategoryTheory.GrothendieckTopology C) (rj : R âˆˆ â‡‘J X) (sj : S âˆˆ â‡‘J X) : R âŠ“ S âˆˆ â‡‘J X
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.HasTerminal C] (h : CategoryTheory.Mono (CategoryTheory.Limits.initial.to (âŠ¤_ C))) : CategoryTheory.Limits.InitialMonoClass C
{p : â„•} [Fact (Nat.Prime p)] : WittVector.IsPolyâ‚‚ p (Î» (_x : Type u_1) (_x_1 : CommRing _x), Add.add)
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {a : Î±} {s : Set Î±} (h : a âˆ‰ s â†’ f a = 1) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ HasInsert.insert a s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {l : Filter Î±} {a : Î±} : IsExtrFilter f l a â†’ IsExtrFilter (â‡‘OrderDual.toDual âˆ˜ f) l a
{R : Type u_1} [Semiring R] {x y : R} (h : Commute x y) (n : â„•) : (x + y) ^ n = (Finset.range (n + 1)).sum (Î» (m : â„•), x ^ m * y ^ (n - m) * â†‘(n.choose m))
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] [IsPredArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ Set.Ioc m n â†’ r i (Order.pred i)) (hnm : m < n) : Relation.TransGen r n m
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] (f : S.localization_Map N) (x : M) (y : â†¥S) : âˆƒ (c : â†¥S), x * â†‘((f.sec (f.mk' x y)).snd) * â†‘c = (f.sec (f.mk' x y)).fst * â†‘y * â†‘c
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {v : Set E} (hv : Orthonormal ð•œ Coe) : (âˆ€ (u : Set E), u âŠ‡ v â†’ Orthonormal ð•œ Coe â†’ u = v) â†” (Submodule.span ð•œ v)á—® = âŠ¥
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : MultilinearMap ð•œ E G) (hF : Continuous â‡‘f) : âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : ringChar F â‰  2) : âˆƒ (a : F), char.quadratic_Char F a = -1
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x y : E) : â‡‘is_R_or_C.re (HasInner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
{G : Type u_1} [AddGroup G] (H : AddSubgroup G) : 0 âˆˆ H
{Î± : Type u_1} (A : Finset Î±) (i : â„•) (hâ‚ : i â‰¤ A.card) : âˆƒ (B : Finset Î±), B âŠ† A âˆ§ B.card = i
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.additive] [CategoryTheory.EnoughProjectives C] {X Y : C} (f : X âŸ¶ Y) (P : CategoryTheory.projectiveResolution X) (Q : CategoryTheory.projectiveResolution Y) : (F.left_derived 0).map f â‰« CategoryTheory.Abelian.Functor.leftDerivedZeroToSelfApp F Q = CategoryTheory.Abelian.Functor.leftDerivedZeroToSelfApp F P â‰« F.map f
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [topologicalSpace Î±] [pseudoMetricSpace Î²] [pseudoMetricSpace Î³] {G : Î² â†’ Î³} {C : Nnreal} (H : LipschitzWith C G) : Continuous (BoundedContinuousFunction.comp G H)
{M : Type u_1} {N : Type u_2} [Preorder M] [hasAdd M] [HasSub M] [HasOrderedSub M] [PartialOrder N] [hasAdd N] [HasSub N] [HasOrderedSub N] (e : M â‰ƒo N) (h_Add : âˆ€ (a b : M), â‡‘e (a + b) = â‡‘e a + â‡‘e b) (a b : M) : â‡‘e (a - b) = â‡‘e a - â‡‘e b
{X : Top} (U : TopologicalSpace.Opens â†¥X) (R : CategoryTheory.Presieve U) (hR : CategoryTheory.Sieve.generate R âˆˆ â‡‘(Opens.grothendieckTopology â†¥X) U) : supr (Top.Presheaf.coveringOfPresieve U R) = U
{Î± Î² : Type u} (e : Î± â‰ƒ Î²) : Cardinal.mk Î± = Cardinal.mk Î²
(u : â„• â†’ â„) (l : â„) (hmono : Monotone u) (hlim : âˆ€ (a : â„), 1 < a â†’ (âˆƒ (c : â„• â†’ â„•), (âˆ€á¶  (n : â„•) in Filter.atTop, â†‘(c (n + 1)) â‰¤ a * â†‘(c n)) âˆ§ Filter.Tendsto c Filter.atTop Filter.atTop âˆ§ Filter.Tendsto (Î» (n : â„•), u (c n) / â†‘(c n)) Filter.atTop (nhds l))) : Filter.Tendsto (Î» (n : â„•), u n / â†‘n) Filter.atTop (nhds l)
{ð•œ : Type u_1} {E : Type u_3} [orderedSemiring ð•œ] [topologicalSpace E] [addCancelCommMonoid E] [HasContinuousAdd E] [Module ð•œ E] {s : Set E} (hs : StrictConvex ð•œ s) (z : E) : StrictConvex ð•œ ((Î» (x : E), x + z) â»Â¹' s)
{Î± : Type u} [topologicalSpace Î±] : DenseRange stoneCechUnit
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : Set P} {p1 p2 : P} (hp1 : p1 âˆˆ s) (hp2 : p2 âˆˆ s) : p1 -áµ¥ p2 âˆˆ vectorSpan k s
{x y : Pgame} (h : x.fuzzy y) : x.lf y
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) p) âˆˆ s
{G : Type u_1} [Group G] [isFreeGroup G] {H : Type u_2} [Group H] (f : IsFreeGroup.Generators G â†’ H) : âˆƒ! (F : G â†’* H), âˆ€ (a : IsFreeGroup.Generators G), â‡‘F (IsFreeGroup.of a) = f a
{Î± : Type u_1} {Î¹ : Type u_3} {Î¹' : Type u_4} [distribLattice Î±] [OrderBot Î±] [DecidableEq Î¹] {s : Finset Î¹'} {g : Î¹' â†’ Finset Î¹} {f : Î¹ â†’ Î±} (hs : s.sup_indep (Î» (i : Î¹'), (g i).sup f)) (hg : âˆ€ (i' : Î¹'), i' âˆˆ s â†’ (g i').sup_indep f) : (s.bUnion g).sup_indep f
{Î± : Type u_1} [CanonicallyOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b c : Î±} [ContravariantClass Î± Î± Add.add LE.le] [ContravariantClass Î± Î± Add.add LT.lt] (hâ‚ : b â‰¤ a) (hâ‚‚ : c â‰¤ a) : a - b < a - c â†” c < b
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {T : E â†’L[ð•œ] E} (hT : InnerProductSpace.IsSelfAdjoint â†‘T) (x : E) : â†‘(T.re_apply_inner_self x) = HasInner.inner (â‡‘T x) x
{Î± : Type u_1} {Î² : Type u_2} {e e' : LocalEquiv Î± Î²} (h : e â‰ˆ e') : e.target = e'.target
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) (z : N) (v : P) : â‡‘(f.lift hg) z = v â†” â‡‘g (f.sec z).fst = â‡‘g â†‘((f.sec z).snd) * v
(Î¹ : Type u_1) [Fintype Î¹] : Metric.Bounded (StdSimplex â„ Î¹)
{Î± : Type u_1} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hs : s.finite) (ht : t.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆ© t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S : Set E) {K : Subfield E} (hF : Set.Range â‡‘(algebraMap F E) âŠ† â†‘K) (HS : S âŠ† â†‘K) : (IntermediateField.adjoin F S).to_Subfield â‰¤ K
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) (u : â„• â†’ Î±) : E.is_solution u â†” u âˆˆ E.sol_Space
(R : Type u) [CommRing R] [is_IsDomain R] (n : â„•) : is_IsDomain (MvPolynomial (Fin n) R)
{Î± : Type u_1} [uniformSpace Î±] {s : Set (Î± Ã— Î±)} (hs : s âˆˆ Uniformity Î±) : âˆƒ (t : Set (Î± Ã— Î±)) (H : t âˆˆ Uniformity Î±), SymmetricRel t âˆ§ CompRel t t âŠ† s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘(s.affine_combination p) w = â‡‘(s.weighted_vsub_of_point p (Classical.choice AddTorsor.nonempty)) w +áµ¥ Classical.choice AddTorsor.nonempty
{n m : â„•} (h : n = m) : (fin.cast h).to_Equiv = equiv.cast _
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {C : â„} (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ HasDist.dist x y â‰¤ C) : Emetric.diam s â‰¤ Ennreal.ofReal C
{J : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.IsConnected J] (jâ‚ jâ‚‚ : J) : CategoryTheory.Zigzag jâ‚ jâ‚‚
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : Real.cos (InnerProductGeometry.angle x y) = HasInner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {E : Type u_3} [hasNorm E] {F : Type u_4} [hasNorm F] (e : Î± â‰ƒâ‚œ Î²) {b : Î²} {f : Î² â†’ E} {g : Î² â†’ F} : f =o[nhds b] g â†” (f âˆ˜ â‡‘e) =o[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (h : TotallyBounded s) : Metric.Bounded s
{Î± : Type u_1} {Î² : Type u_2} {mÎ² : measurableSpace Î²} {m : measurableSpace Î±} {f : â„• â†’ Î± â†’ Î²} {p : â„• â†’ Î± â†’ Prop} [Î  (n : â„•), DecidablePred (p n)] (hF : âˆ€ (n : â„•), Measurable (f n)) (hp : âˆ€ (n : â„•), MeasurableSet {x : Î± | p n x}) (h : âˆ€ (x : Î±), âˆƒ (n : â„•), p n x) : Measurable (Î» (x : Î±), f (Nat.find _) x)
{E : Type u_1} {Î² : Type u_2} [AddCommGroup E] [topologicalSpace E] [Module â„ E] [TopologicalAddGroup E] [HasContinuousSmul â„ E] [OrderedAddCommGroup Î²] [Module â„ Î²] [OrderedSmul â„ Î²] {f : E â†’ Î²} {a : E} (h_is_IsLocalMin : is_is_IsLocalMin f a) (h_conv : ConvexOn â„ Set.Univ f) (x : E) : f a â‰¤ f x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G : C â¥¤ D} (Î± : F âŸ¶ G) [âˆ€ (X : C), CategoryTheory.IsIso (Î±.app X)] : CategoryTheory.IsIso Î±
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) : 2 â€¢ hb.oangle x (-x) = 0
{Î± : Type u_1} [linearOrderedRing Î±] : Subsingleton (floorRing Î±)
(N : â„•) {j : â„} (hj : 0 < j) {c : â„} (hc : 1 < c) : (Finset.filter (Î» (i : â„•), j < c ^ i) (Finset.range N)).sum (Î» (i : â„•), 1 / (c ^ i) ^ 2) â‰¤ c ^ 3 * (c - 1)â»Â¹ / j ^ 2
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (lâ‚ lâ‚‚ : Î¹ â†’â‚€ ð•œ) : HasInner.inner (â‡‘(Finsupp.total Î¹ E ð•œ v) lâ‚) (â‡‘(Finsupp.total Î¹ E ð•œ v) lâ‚‚) = lâ‚‚.sum (Î» (i : Î¹) (y : ð•œ), â‡‘(starRingEnd ð•œ) (â‡‘lâ‚ i) * y)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteCoproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.NormalEpiCategory C] {X Y Z : C} (a : X âŸ¶ Y) (b : X âŸ¶ Z) [CategoryTheory.Epi a] [CategoryTheory.Epi b] : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span a b)
{n m : â„•} (h : âˆ€ (i : â„•), n.test_bit i = m.test_bit i) : n = m
{Î± : Type u} {Î² : Type v} [uniformSpace Î±] [SemilatticeSup Î²] {u : Î² â†’ Î±} (hu : CauchySeq u) {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : Filter Î¹} [p.ne_IsBot] (hF : Filter.Tendsto f p Filter.atTop) {a : Î±} (ha : Filter.Tendsto (u âˆ˜ f) p (nhds a)) : Filter.Tendsto u Filter.atTop (nhds a)
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (h : IsUnit A.det) : A.mul Aâ»Â¹ = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] (h : âˆ€ (A : C) (f : A âŸ¶ âŠ¥_ C), CategoryTheory.IsIso f) : CategoryTheory.Limits.HasStrictInitialObjects C
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p âˆˆ s) (v : V) : v âˆˆ s.direction â†” âˆƒ (p2 : P) (H : p2 âˆˆ s), v = p2 -áµ¥ p
{f : â„• â†’ â„} (hF : âˆ€ (i : â„•), 0 â‰¤ f i) (r : â„) : HasSum f r â†” Filter.Tendsto (Î» (n : â„•), (Finset.range n).sum (Î» (i : â„•), f i)) Filter.atTop (nhds r)
{Î± : Type u} {Î² : Type v} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hF : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), f x * g x) l Filter.atTop
{Î¹ : Type u_1} {Î± : Type u_2} [completeLattice Î±] {t : Î¹ â†’ Î±} (ht : CompleteLattice.Independent t) {x : Î¹} {y : Set Î¹} (hx : x âˆ‰ y) : Disjoint (t x) (â¨† (i : Î¹) (H : i âˆˆ y), t i)
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] (S : Finset M) : CompleteLattice.IsCompactElement (Submodule.span R â†‘S)
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.PosMulStrictMono Î±] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
{Î± : Type u_1} [LinearOrder Î±] (a : Î±) (i : Fin 1) : â‡‘({a}.order_emb_of_Fin _) i = a
{Î± : Type u} [Preorder Î±] {s : Set Î±} {a : Î±} (h : IsGlb s a) : BddBelow s
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {f : Filter Î±} : Filter.IsBounded r f â†” âˆƒ (s : Set Î±) (H : s âˆˆ f.sets) (b : Î±), s âŠ† {x : Î± | r x b}
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] {F : Type v} [NormedGroup F] [normedSpace â„‚ F] [Nontrivial E] {f g : E â†’ F} {U : Set E} (hU : Metric.Bounded U) (hF : DiffContOnCl â„‚ f U) (hg : DiffContOnCl â„‚ g U) (hfg : Set.EqOn f g (Frontier U)) : Set.EqOn f g U
{Î± : Type u_1} {E : Type u_3} [NormedGroup E] [topologicalSpace Î±] {f : Î± â†’ E} : HasCompactSupport f â†’ HasCompactSupport (Î» (x : Î±), âˆ¥f xâˆ¥)
(p : â„•) : padicNorm p 1 = 1
{G : Type u_1} [subNegMonoid G] (a b : G) : a - b = a + -b
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) (p : Submodule R (CliffordAlgebra Q)) (n : â„•) : Submodule.map CliffordAlgebra.reverse (p ^ n) = Submodule.map CliffordAlgebra.reverse p ^ n
{Î± : sort u_1} {Î² : sort u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£' (a : Î±), Subtype_ (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {B : C} : CategoryTheory.Limits.HasBinaryProducts (CategoryTheory.Over B)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] (s : Finset E) (hs : âˆ€ (c : E), c âˆˆ s â†’ âˆ¥câˆ¥ â‰¤ 2) (h : âˆ€ (c : E), c âˆˆ s â†’ âˆ€ (d : E), d âˆˆ s â†’ c â‰  d â†’ 1 â‰¤ âˆ¥c - dâˆ¥) : s.card â‰¤ 5 ^ FiniteDimensional.finrank â„ E
{a b c : â„¤} : fermat_42.minimal a b c â†’ fermat_42.minimal a b (-c)
{R : Type u_1} [CommRing R] (S : Submonoid R) {P : Type u_2} [CommRing P] [Algebra R P] [loc : IsLocalization S P] (x : P) (hx : IsIntegral R x) : IsFractional S (Algebra.adjoin R {x}).to_Submodule
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [Ring k] [AddCommGroup V1] [Module k V1] [addTorsor V1 P1] [AddCommGroup V2] [Module k V2] [addTorsor V2 P2] [AddCommGroup V3] [Module k V3] [addTorsor V3 P3] (f : P2 â†’áµƒ[k] P3) (g : P1 â†’áµƒ[k] P2) (p : P1) : â‡‘(f.comp g) p = â‡‘f (â‡‘g p)
{Î± : Type u_1} [LinearOrder Î±] {r : Î±} {s : Finset Î±} : {r}.to_colex â‰¤ s.to_colex â†” âˆƒ (x : Î±) (H : x âˆˆ s), r â‰¤ x
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : â†‘r < p.radius) : (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =o[Filter.atTop] Î» (_x : â„•), 1
{k : Type u_1} {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : Set P} (h : AffineIndependent k (Î» (p : â†¥s), â†‘p)) : âˆƒ (t : Set P), s âŠ† t âˆ§ AffineIndependent k (Î» (p : â†¥t), â†‘p) âˆ§ affineSpan k t = âŠ¤
{Î± : Type u_1} [completeLattice Î±] {s : Set Î±} (hs : CompleteLattice.SetIndependent s) {x : Î±} {y : Set Î±} (hx : x âˆˆ s) (hy : y âŠ† s) (hxy : x âˆ‰ y) : Disjoint x (HasSup.sup y)
{Î± : Type u} [Group Î±] (g : GroupTopology Î±) : Continuous Inv.inv
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [AddCommMonoid F] [orderedAddCommMonoid Î²] [Module ð•œ E] [Module ð•œ F] [HasScalar ð•œ Î²] {f : F â†’ Î²} {s : Set F} (hF : ConcaveOn ð•œ s f) (g : E â†’â‚—[ð•œ] F) : ConcaveOn ð•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
(R : Type u_1) {p n : â„•} [hp : Fact (Nat.Prime p)] [Ring R] [Char_p R p] (hn : p âˆ£ n) : Polynomial.cyclotomic (n * p) R = Polynomial.cyclotomic n R ^ p
{R : Type u_1} [CommRing R] {Râ‚˜ : Type u_3} {Sâ‚˜ : Type u_4} [CommRing Râ‚˜] [CommRing Sâ‚˜] (P : Ideal (Polynomial R)) (pX : Polynomial R) (hpX : pX âˆˆ P) [Algebra (R â§¸ Ideal.comap Polynomial.c P) Râ‚˜] [IsLocalization.Away (Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.c P)) pX).leading_Coeff Râ‚˜] [Algebra (Polynomial R â§¸ P) Sâ‚˜] [IsLocalization (Submonoid.map â†‘(P.quotient_Map Polynomial.c LE_rfl) (Submonoid.powers (Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.c P)) pX).leading_Coeff)) Sâ‚˜] : (IsLocalization.map Sâ‚˜ (P.quotient_Map Polynomial.c LE_rfl) _).is_integral
{C : Type u} [CategoryTheory.Category C] {X Y Z : C} {f g : X âŸ¶ Y} (w : f = g) (h : Y âŸ¶ Z) : f â‰« h = g â‰« h
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {F : Type v} [NormedGroup F] [normedSpace ð•œ F] {f : ð•œ â†’ F} {f' : F} {x : ð•œ} [PartialOrder ð•œ] : HasDerivWithinAt f f' (Set.Ioi x) x â†’ HasDerivWithinAt f f' (Set.Ici x) x
{Î± : Type u_1} {E : Î± â†’ Type u_2} {p : Ennreal} [Î  (i : Î±), NormedGroup (E i)] [Fact (1 â‰¤ p)] {F : â„• â†’ â†¥(Lp E p)} (hF : CauchySeq F) {f : â†¥(Lp E p)} (hF : Filter.Tendsto (Id (Î» (i : â„•), â‡‘(F i))) Filter.atTop (nhds â‡‘f)) : Filter.Tendsto F Filter.atTop (nhds f)
{E : Type u_3} [semiNormedGroup E] (u v : E) : âˆ¥vâˆ¥ â‰¤ âˆ¥uâˆ¥ + âˆ¥u - vâˆ¥
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) (hF'' : DifferentiableOn â„ (deriv f) (Interior D)) (hF''_nonpos : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv^[2] f x â‰¤ 0) : ConcaveOn â„ D f
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M â†’* P} (H : c â‰¤ Con.ker f) (x : M) : â‡‘(c.lift f H) (â‡‘(c.mk') x) = â‡‘f x
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : Î± â†’ Î² â†’ Î³) (s : Set Î±) (t : Set Î²) : Set.image2 f s t = â‹ƒ (i : Î±) (H : i âˆˆ s) (j : Î²) (H : j âˆˆ t), {f i j}
{Î± : Type u_1} [LinearOrder Î±] (s : Set Î±) (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆ€ (z : Î±), z âˆˆ s â†’ x â‰¤ y â†’ y â‰¤ z â†’ x = y âˆ¨ y = z) : s.finite
{p : â„•} [Fact (Nat.Prime p)] {f : PadicSeq p} (hF : Â¬f â‰ˆ 0) (v1 v3 : â„•) : padicNorm p (â‡‘f (PadicSeq.stationaryPoint hF)) = padicNorm p (â‡‘f (Linear_order.max v1 (Linear_order.max (PadicSeq.stationaryPoint hF) v3)))
{f f' : â„ â†’ â„} {s : Set â„} (hs : Convex â„ s) (hF : âˆ€ (x : â„), x âˆˆ s â†’ HasDerivAt f (f' x) x) {m : â„} (hF' : âˆ€ (x : â„), x âˆˆ s â†’ f' x â‰  m) : (âˆ€ (x : â„), x âˆˆ s â†’ f' x < m) âˆ¨ âˆ€ (x : â„), x âˆˆ s â†’ m < f' x
{G : Type u_1} [Group G] (tG : monoid.is_torsion_free G) (H : Subgroup G) : monoid.is_torsion_free â†¥H
{n : â„•} : Finset.univ = Finset.map equiv.perm.decompose_fin.symm.to_Embedding Finset.univ
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linearOrderedField ð•œ] [AddCommGroup E] [linearOrderedAddCommGroup Î²] [Module ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} {t : Finset Î¹} {w : Î¹ â†’ ð•œ} {p : Î¹ â†’ E} (h : ConvexOn ð•œ s f) (hwâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hwâ‚ : 0 < t.sum (Î» (i : Î¹), w i)) (hp : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : âˆƒ (i : Î¹) (H : i âˆˆ t), f (t.center_mass w p) â‰¤ f (p i)
{a p k : â„•} (pp : Nat.Prime p) (hâ‚ : Â¬a âˆ£ p ^ k) (hâ‚‚ : a âˆ£ p ^ (k + 1)) : a = p ^ (k + 1)
{G : Type u_1} [Group G] (H : Subgroup G) [hG : group.is_nilpotent G] : group.nilpotency_class â†¥H â‰¤ group.nilpotency_class G
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {Lâ‚ Lâ‚‚ : C â¥¤ D} {Râ‚ Râ‚‚ : D â¥¤ C} (Adjâ‚ : Lâ‚ âŠ£ Râ‚) (Adjâ‚‚ : Lâ‚‚ âŠ£ Râ‚‚) (f : Lâ‚‚ âŸ¶ Lâ‚) [CategoryTheory.IsIso (â‡‘(CategoryTheory.transferNatTransSelf Adjâ‚ Adjâ‚‚) f)] : CategoryTheory.IsIso f
{C : Type uâ‚} [CategoryTheory.Category C] {B A : C} {X : CategoryTheory.Subobject B} (f : A âŸ¶ B) [CategoryTheory.Mono f] (i : A â‰… â†‘X) (w : i.hom â‰« X.arrow = f) : CategoryTheory.Subobject.mk f = X
(R : CommRing) : algebraic_geometry.identity_toÎ“_Spec.app (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (Opposite.op R)) â‰« algebraic_geometry.Spec.to_LocallyRingedSpace.map (algebraic_geometry.Spec_Î“_identity.inv.app R).op = ðŸ™ ((ðŸ­ AlgebraicGeometry.LocallyRingedSpace).obj (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (Opposite.op R)))
{C : Type uâ‚} [CategoryTheory.Category C] {X : C} (P : Cáµ’áµ– â¥¤ Type w) : CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.Singleton (ðŸ™ X))
(x : â„‚) : HasDerivAt Complex.cosh (Complex.sinh x) x
{M : Type u_3} {N : Type u_4} [hasOne M] [hasOne N] {f g : OneHom M N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
{Î± : Type u} [topologicalSpace Î±] {x : Î±} : Coe â»Â¹' {â†‘x} = ConnectedComponent x
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [wo : IsWellOrder Î± r] {s : Set (Set Î±)} (hâ‚ : Set.Unbounded r (â‹ƒâ‚€s)) (hâ‚‚ : Cardinal.mk â†¥s < StrictOrder.cof r) : âˆƒ (x : Set Î±) (H : x âˆˆ s), Set.Unbounded r x
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} {c : CategoryTheory.Limits.Fork f g} (h : CategoryTheory.Limits.IsLimit c) [CategoryTheory.Epi c.Î¹] : CategoryTheory.IsIso c.Î¹
(p : â„•) [p_Prime : Fact (Nat.Prime p)] {q r : â„š} (hq : q â‰  0) (hr : r â‰  0) : padicValRat p (q / r) = padicValRat p q - padicValRat p r
{ð•œ : Type u} [hnorm : nondiscreteNormedField ð•œ] {E : Type v} [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul ð•œ E] (l : E â†’â‚—[ð•œ] ð•œ) : Continuous â‡‘l â†” is_IsClosed â†‘(l.ker)
{R : Type v} [CommRing R] (A : Matrix (Fin 3) (Fin 3) R) : A.det = A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 + A 0 2 * A 1 0 * A 2 1 - A 0 2 * A 1 1 * A 2 0
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : C â¥¤ D) {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan f f) F] [CategoryTheory.Mono (F.map f)] : CategoryTheory.Mono f
{Mâ‚€ : Type u_1} [MulZeroOneClass Mâ‚€] [Nontrivial Mâ‚€] : 0 â‰  1
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : CategoryTheory.Presieve X} {x : CategoryTheory.Presieve.FamilyOfElements P â‡‘(CategoryTheory.Sieve.generate R)} (t : x.compatible) : (CategoryTheory.Presieve.FamilyOfElements.restrict _ x).sieve_extend = x
{C : Type u} [CategoryTheory.Category C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) [CategoryTheory.StrongMono (f â‰« g)] : CategoryTheory.StrongMono f
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [divisionRing R] [divisionRing S] [Module R E] [Module S E] (r : â„š) (x : E) : â†‘r â€¢ x = â†‘r â€¢ x
(n : â„•) (R : Type u_1) [Ring R] [Nontrivial R] : (Polynomial.cyclotomic n R).degree = â†‘(n.totient)
{a b : â„} {g' g : â„ â†’ â„} (hcont : ContinuousOn g (Set.Interval a b)) (hderiv : âˆ€ (x : â„), x âˆˆ Set.Ioo (Linear_order.min a b) (Linear_order.max a b) â†’ HasDerivAt g (g' x) x) (hpos : âˆ€ (x : â„), x âˆˆ Set.Ioo (Linear_order.min a b) (Linear_order.max a b) â†’ 0 â‰¤ g' x) : IntervalIntegrable g' MeasureTheory.MeasureSpace.volume a b
(ð•œ : Type u_1) [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (f : E â†’ F) [measurableSpace E] [OpensMeasurableSpace E] {K : Set (E â†’L[ð•œ] F)} (hK : IsComplete K) : MeasurableSet {x : E | DifferentiableAt ð•œ f x âˆ§ fderiv ð•œ f x âˆˆ K}
{R : Type u} [CommSemiring R] [NoZeroDivisors R] (t : Multiset (Polynomial R)) : t.prod.leading_Coeff = (Multiset.map (Î» (f : Polynomial R), f.leading_Coeff) t).prod
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] (X : C) : CategoryTheory.IsPullback 0 0 (ðŸ™ X) 0
{p n r b : â„•} (hp : Nat.Prime p) (hbn : Nat.log p n < b) : p ^ r âˆ£ n.factorial â†” r â‰¤ (Finset.ico 1 b).sum (Î» (i : â„•), n / p ^ i)
(n : â„•) : (List.Nat.antidiagonal n).length = n + 1
{Î± : Type u_1} [Preorder Î±] {f g : Î± â†’ Î±} (hF : Monotone f) (h : f â‰¤ g) (n : â„•) : f^[n] â‰¤ (g^[n])
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [linearOrderedAddCommGroup Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hF : Filter.Tendsto f l Filter.atTop) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), f x + g x) l Filter.atTop
{Î± : Type u_1} {s : Finset Î±} (p : Î± â†’ Prop) [DecidablePred p] : Finset.map (Function.Embedding.subtype p) (Finset.subtype p s) = Finset.filter p s
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M â†’+ P} (h : c â‰¤ AddCon.ker f) (hF : Function.Surjective â‡‘f) : Function.Surjective â‡‘(c.lift f h)
{Î± : Type u_1} {Î² : Type u_3} [measurableSpace Î±] [measurableSpace Î²] : IsPiSystem (Set.image2 HasSetProd.prod {s : Set Î± | MeasurableSet s} {t : Set Î² | MeasurableSet t})
{E : Type u_1} [innerProductSpace â„ E] {n : â„•} (hn : 0 < n) (h : FiniteDimensional.finrank â„ E = n) (x : Orientation â„ E (Fin n)) : Orthonormal â„ â‡‘(Orientation.finOrthonormalBasis hn h x)
(C : Type u) [CategoryTheory.Category C] [âˆ€ {X Y : C} {f g : X âŸ¶ Y}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)] : CategoryTheory.Limits.HasEqualizers C
{M : Type u_1} [AddZeroClass M] {Î¹ : sort u_2} (S : Î¹ â†’ addSubmonoid M) {C : M â†’ Prop} {x : M} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : M), x âˆˆ S i â†’ C x) (h1 : C 0) (HMul : âˆ€ (x y : M), C x â†’ C y â†’ C (x + y)) : C x
{n : â„¤} (hn : n â‰  0) (z : â†¥Circle) : â‡‘(fourier n) (â‡‘expMapCircle ((â†‘n)â»Â¹ * Real.pi) * z) = -â‡‘(fourier n) z
{Î² : Type u_1} [conditionallyCompleteLattice Î²] {s : Set (WithTop Î²)} (hs : BddBelow s) : IsGlb s (HasInf.inf s)
{n : â„•} (p : Fin (n + 2)) (i : Fin (n + 1)) (h : 0 < i) : 0 < â‡‘(p.succ_above) i
{C : Type u} [CategoryTheory.Category C] {X Y Z : C} (f : X âŸ¶ Y) {g h : Y âŸ¶ Z} (w : g = h) : f â‰« g = f â‰« h
{Î± : Type u} {Î² : Type v} [SemilatticeInf Î±] {r : Î² â†’ Î² â†’ Prop} {f : Î± â†’ Î²} (hF : âˆ€ (aâ‚ aâ‚‚ : Î±), aâ‚ â‰¤ aâ‚‚ â†’ r (f aâ‚‚) (f aâ‚)) : Directed r f
(R : Type u) [Ring R] [StrongRankCondition R] (m : Type v) (n : Type w) [Fintype m] [Fintype n] : Module.rank R (Matrix m n R) = (Cardinal.mk m).lift * (Cardinal.mk n).lift
{n : Type u_3} {Î± : Type v} {Î² : Type w} [hasMul Î±] [hasMul Î²] (f : Î± â†’ Î²) (r : Î±) (A : Matrix n n Î±) (hF : âˆ€ (aâ‚ aâ‚‚ : Î±), f (aâ‚ * aâ‚‚) = f aâ‚ * f aâ‚‚) : (MulOpposite.op r â€¢ A).map f = MulOpposite.op (f r) â€¢ A.map f
{b : â„•} (hb : 1 < b) {x y : â„•} : x â‰¤ b ^ y â†” Nat.clog b x â‰¤ y
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : MulOneClass M} {mN : MulOneClass N} [monoidHomClass F M N] (f : F) {x : M} (hx : âˆƒ (y : M), y * x = 1) : âˆƒ (y : N), y * â‡‘f x = 1
{Î± : Type u} [pseudoEmetricSpace Î±] {Î´ : â„} {E : Set Î±} : is_IsClosed (Metric.Cthickening Î´ E)
{X : Type u_1} [topologicalSpace X] : discreteTopology X â†” nhds = Pure.pure
{K : Type u_1} [linearOrderedField K] [floorRing K] {v : K} (terminates : (GeneralizedContinuedFraction.of v).terminates) : âˆƒ (q : â„š), v = â†‘q
(X : AlgebraicGeometry.LocallyRingedSpace (r : â†¥(AlgebraicGeometry.LocallyRingedSpaceÎ“.obj (Opposite.op X))) : X.to_Î“_spec_fun â»Â¹' (PrimeSpectrum.basicOpen r).val = (X.to_RingedSpace.basic_IsOpen r).val
{Î¹ : Type w} [Fintype Î¹] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [Module.Finite K L] [IsSeparable K L] (b : Basis Î¹ K L) : Algebra.discr K â‡‘b â‰  0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (pâ‚ pâ‚‚ : Î¹ â†’ P) (b : P) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.weighted_vsub_of_point pâ‚ b) w - â‡‘(s.weighted_vsub_of_point pâ‚‚ b) w
{G : Type u_6} {H : Type u_7} {F : Type u_8} [AddGroup G] [subtractionMonoid H] [addMonoidHomClass F G H] (f : F) (a : G) : â‡‘f (-a) = -â‡‘f a
{ð•œ : Type u} [nondiscreteNormedField ð•œ] (x : ð•œ) {ð•œ' : Type u_1} [nondiscreteNormedField ð•œ'] [NormedAlgebra ð•œ ð•œ'] {h : ð•œ â†’ ð•œ'} {hâ‚‚ : ð•œ' â†’ ð•œ'} {h' hâ‚‚' : ð•œ'} (hHâ‚‚ : HasDerivAt hâ‚‚ hâ‚‚' (h x)) (hH : HasDerivAt h h' x) : HasDerivAt (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x
{M : Type u_1} [CommMonoid M] (S : Submonoid M) {Î¹ : Type u_2} {t : Finset Î¹} {f : Î¹ â†’ M} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.prod (Î» (c : Î¹), f c) âˆˆ S
{J : Type v} {C : Type u} [CategoryTheory.Category C] {B : C} (F : CategoryTheory.Discrete J â¥¤ CategoryTheory.Over B) [CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)] : CategoryTheory.Limits.HasLimit F
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] [uniformSpace Î²] [SeparatedSpace Î±] {f : Î± â†’ Î²} (hF : UniformInducing f) : UniformEmbedding f
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [RegularSpace Î±] [NonUnitalNonAssocSemiring Î±] [TopologicalSemiring Î±] {f : Î² â†’ Î±} {g : Î³ â†’ Î±} (hF : Summable f) (hg : Summable g) (hfg : Summable (Î» (x : Î² Ã— Î³), f x.fst * g x.snd)) : (âˆ‘' (x : Î²), f x) * âˆ‘' (y : Î³), g y = âˆ‘' (z : Î² Ã— Î³), f z.fst * g z.snd
{Î³ : Type u_3} [tÎ³ : topologicalSpace Î³] [PolishSpace Î³] {Î² : Type u_1} [topologicalSpace Î²] [t2_Space Î²] [measurableSpace Î²] [BorelSpace Î²] {f : Î³ â†’ Î²} (f_Cont : Continuous f) (f_inj : Function.Injective f) : MeasurableSet (Set.Range f)
{ð•œ : Type u_1} [is_R_or_C ð•œ] {E : Type u_2} [innerProductSpace ð•œ E] [CompleteSpace E] {T : E â†’L[ð•œ] E} (hT : InnerProductSpace.IsSelfAdjoint â†‘T) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0) (hextr : IsLocalExtrOn T.re_apply_inner_self (Metric.Sphere 0 âˆ¥xâ‚€âˆ¥) xâ‚€) : Module.End.HasEigenvector â†‘T â†‘((Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) xâ‚€) xâ‚€
(p : â„•) [hp : Fact (Nat.Prime p)] (q r : â„š) : padicNorm p (q + r) â‰¤ padicNorm p q + padicNorm p r
{Î± : Type u} {Î² : Type v} [Preorder Î²] {f : Î± â†’ Î²} {l : Filter Î±} {a : Î±} : IsMaxFilter f l a â†’ IsMinFilter (â‡‘OrderDual.toDual âˆ˜ f) l a
{f : â„ â†’ â„} {a b : â„} (h0 : 0 < b) (h1 : ContinuousOn f (Set.Ici a)) (h2 : f =O[Filter.atTop] Î» (x : â„), Real.exp (-b * x)) : MeasureTheory.IntegrableOn f (Set.Ioi a) MeasureTheory.MeasureSpace.volume
 : MeasureTheory.Measure.addHaarMeasure topological_space.positive_compacts.Icc01 = MeasureTheory.MeasureSpace.volume
(R : Type u_1) [CommRing R] : Algebra.FinitePresentation R R
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Antitone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ioo (f n) (f (Order.pred n)))
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±} (hF : Set.EqOn f 0 s) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) = 0
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] (f : S.localization_Map N) (z : N) : f.mk' (f.sec z).fst (f.sec z).snd = z
(Î± : Type u) [Preorder Î±] [Nonempty Î±] [NoMaxOrder Î±] : âˆƒ (f : â„• â†’ Î±), StrictMono f
{Î± : Type u} [Preorder Î±] [OrderBot Î±] {a b : Î±} (h : a < b) : b â‰  âŠ¥
{Î± : Type u_1} {Î² : Type u_2} {l : Filter Î±} {f g : Î± â†’ Î²} : f =á¶ [l] g â†’ â†‘f = â†‘g
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) : o.oangle x (-y) = o.oangle x y + â†‘Real.pi
{R : Type u} [CommRing R] (S : Submonoid R) {L : Type u} [CommRing L] [Algebra R L] [IsLocalization S L] [Fintype R] : Function.Surjective â‡‘(algebraMap R L)
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [AddCommMonoid Î²] {s : Finset Î±} {t : Finset Î³} {f : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (a : Î±), a âˆˆ s â†’ Î³) (hi : âˆ€ (a : Î±) (ha : a âˆˆ s), i a ha âˆˆ t) (h : âˆ€ (a : Î±) (ha : a âˆˆ s), f a = g (i a ha)) (j : Î  (a : Î³), a âˆˆ t â†’ Î±) (hj : âˆ€ (a : Î³) (ha : a âˆˆ t), j a ha âˆˆ s) (IsLeftInv : âˆ€ (a : Î±) (ha : a âˆˆ s), j (i a ha) _ = a) (IsRightInv : âˆ€ (a : Î³) (ha : a âˆˆ t), i (j a ha) _ = a) : s.sum (Î» (x : Î±), f x) = t.sum (Î» (x : Î³), g x)
{Î± : sort u} {C : Î± â†’ sort v} {r : Î± â†’ Î± â†’ Prop} (hwf : WellFounded r) (F : Î  (x : Î±), (Î  (y : Î±), r y x â†’ C y) â†’ C x) (x : Î±) : hwf.fix F x = F x (Î» (y : Î±) (h : r y x), hwf.fix F y)
(a : â†¥Circle) : â‡‘(LinearMap.toMatrix complex.basis_One_I complex.basis_One_I) â†‘((â‡‘rotation a).to_linearEquiv) = â‡‘(Matrix.planeConformalMatrix â†‘a.re â†‘a.im _)
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (r : R) : v.int_Valuation_def r < 1 â†” v.as_Ideal âˆ£ Ideal.span {r}
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.normal] (hN : (Fintype.card â†¥N).coprime N.index) : âˆƒ (H : Subgroup G), N.is_complement' H
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] (a : A) (hF : Function.Injective â‡‘(algebraMap A B)) : minpoly A (â‡‘(algebraMap A B) a) = Polynomial.x - â‡‘Polynomial.c a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {n : â„•} (s : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : â„•} (h : fs.card = m + 1) : (s.face h).points = s.points âˆ˜ â‡‘(fs.order_emb_of_Fin h)
{Î± : Type u_2} [divisionMonoid Î±] {a : Î±} : IsSquare a â†’ IsSquare aâ»Â¹
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [is_R_or_C ð•‚] [normedRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] {Î¹ : Type u_3} (s : Finset Î¹) (f : Î¹ â†’ ð”¸) (h : âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ Commute (f i) (f j)) : Exp ð•‚ (s.sum (Î» (i : Î¹), f i)) = s.noncomm_Prod (Î» (i : Î¹), Exp ð•‚ (f i)) _
{Î± : Type u_1} {ð’œ : Finset (Finset Î±)} {r : â„•} : Set.Sized r â†‘(ð’œ.slice r)
{Î± : Type u_1} {s : Finset Î±} {f : Î± â†’ Ennreal} (h : âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) : s.prod (Î» (a : Î±), f a) < âŠ¤
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [Module k E] [addTorsor E PE] (f : k â†’ PE) (a b c : k) (h : a â‰  c) : â‡‘(AffineMap.lineMap (slope f a b) (slope f b c)) ((c - b) / (c - a)) = slope f a c
{R : Type u_1} [Ring R] {E : Type u_2} [AddCommGroup E] [Module R E] {F : Type u_3} [AddCommGroup F] [Module R F] (f g : LinearPmap R E F) (h : Disjoint f.domain g.domain) (x : â†¥(f.domain)) (y : â†¥(g.domain)) (hxy : â†‘x = â†‘y) : â‡‘f x = â‡‘g y
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [CharZero k] {s : Finset Î¹} (p : Î¹ â†’ P) {n : â„•} (h : s.card = n + 1) : Finset.centroid k s p âˆˆ affineSpan k (Set.Range p)
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (p1 p2 : P) : p1 âˆˆ affineSpan k {p2} â†” p1 = p2
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 1 R = Polynomial.x - 1
{Î± : Type u_1} {Î³ : Type u_3} [topologicalSpace Î±] [measurableSpace Î±] [OpensMeasurableSpace Î±] [topologicalSpace Î³] [measurableSpace Î³] [BorelSpace Î³] {f g : Î± â†’ Î³} {s : Set Î±} [Î  (j : Î±), Decidable (j âˆˆ s)] (hF : ContinuousOn f s) (hg : ContinuousOn g sá¶œ) (hs : MeasurableSet s) : Measurable (s.piecewise f g)
(p : â„•) : padicNorm p 0 = 0
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} {R : Type u_11} [Semiring R] [AddCommMonoid M] [AddCommMonoid N] [DistribMulAction R M] [DistribMulAction R N] {f g : (Î± â†’â‚€ M) â†’+[R] N} (h : âˆ€ (a : Î±), f.comp (Finsupp.DistribMulActionHom.single a) = g.comp (Finsupp.DistribMulActionHom.single a)) : f = g
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (f : M â†’â‚—[R] M) [hfg : Module.Finite R M] (f_surj : Function.Surjective â‡‘f) : Function.Injective â‡‘f
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x : Î±} (hx : x âˆˆ Closure s) : Metric.infDist x s = 0
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {p1 p2 : P} (h : p1 â‰  p2) : EuclideanGeometry.angle p1 p2 p1 = 0
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] {Mâ‚ : Type v} [AddCommGroup Mâ‚] [Module R Mâ‚] (f : M â‰ƒâ‚—[R] Mâ‚) : Module.rank R M = Module.rank R Mâ‚
{Î± : Type u_1} [LinearOrder Î±] {a b c d : Î±} (hâ‚ : Linear_order.min a b < Linear_order.max c d) (hâ‚‚ : Linear_order.min c d < Linear_order.max a b) : Set.Icc a b âˆª Set.Icc c d = Set.Icc (Linear_order.min a c) (Linear_order.max b d)
{Î± : Type u} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] : {s : Set Î± | IsPreconnected s} âŠ† Set.Range (Function.uncurry Set.Icc) âˆª Set.Range (Function.uncurry Set.Ico) âˆª Set.Range (Function.uncurry Set.Ioc) âˆª Set.Range (Function.uncurry Set.Ioo) âˆª (Set.Range Set.Ici âˆª Set.Range Set.Ioi âˆª Set.Range Set.Iic âˆª Set.Range Set.Iio âˆª {Set.Univ, âˆ…})
{R : Type v} [CommRing R] {n : â„•} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R} (c : Fin n â†’ R) (A_Zero : âˆ€ (i : Fin (n + 1)), A i 0 = B i 0) (A_Succ : âˆ€ (i : Fin (n + 1)) (j : Fin n), A i j.succ = B i j.succ + c j * A i (â‡‘fin.cast_Succ j)) : A.det = B.det
{Î¹ : Type u} {f g : Î¹ â†’ â„} {p : â„} (hp : 1 â‰¤ p) (hF : âˆ€ (i : Î¹), 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) (hF_Sum : Summable (Î» (i : Î¹), f i ^ p)) (hg_Sum : Summable (Î» (i : Î¹), g i ^ p)) : Summable (Î» (i : Î¹), (f i + g i) ^ p) âˆ§ (âˆ‘' (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) + (âˆ‘' (i : Î¹), g i ^ p) ^ (1 / p)
{Î± : Type u} [pseudoMetricSpace Î±] {x : Î±} {r : â„} (h : 0 â‰¤ r) : Metric.diam (Metric.Ball x r) â‰¤ 2 * r
{n : â„•} : Function.Injective Fin.succ_above
{R : Type u_1} [Semiring R] (f : LaurentPolynomial R) (m n : â„¤) : f * LaurentPolynomial.t m * LaurentPolynomial.t n = f * LaurentPolynomial.t (m + n)
{Î± : Type u_1} [LinearOrder Î±] {s : Finset Î±} {k : â„•} (h : s.card = k) {f : Fin k â†ªo Î±} (hfs : âˆ€ (x : Fin k), â‡‘f x âˆˆ s) : f = s.order_emb_of_Fin h
{Î± : Type u_1} [CircularPreorder Î±] {a b c : Î±} (h : HasSbtw.Sbtw a b c) : HasSbtw.Sbtw c a b
{G : Type u_1} [Group G] (H : Subgroup G) [H.normal] [h : group.is_nilpotent G] : group.nilpotency_class (G â§¸ H) â‰¤ group.nilpotency_class G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} (F : Top.Presheaf C X) {x : â†¥X} {Y : C} {fâ‚ fâ‚‚ : F.stalk x âŸ¶ Y} (ih : âˆ€ (U : TopologicalSpace.Opens â†¥X) (hxU : x âˆˆ U), F.germ âŸ¨x, hxUâŸ© â‰« fâ‚ = F.germ âŸ¨x, hxUâŸ© â‰« fâ‚‚) : fâ‚ = fâ‚‚
{ð•œ : Type u_1} {_x : Ring ð•œ} {E : Type u_2} [semiNormedGroup E] {_x_1 : Module ð•œ E} {s : Submodule ð•œ E} (x : â†¥s) : âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
{ð•œ : Type u_1} {E : Type u_2} [orderedRing ð•œ] [AddCommGroup E] [Module ð•œ E] {K : Geometry.SimplicialComplex ð•œ E} {s t : Finset E} (hs : s âˆˆ K.faces) (ht : t âˆˆ K.faces) : Disjoint (â‡‘(convexHull ð•œ) â†‘s) (â‡‘(convexHull ð•œ) â†‘t) âˆ¨ âˆƒ (u : Finset E) (H : u âˆˆ K.faces), â‡‘(convexHull ð•œ) â†‘s âˆ© â‡‘(convexHull ð•œ) â†‘t = â‡‘(convexHull ð•œ) â†‘u
{G : Type u} [Group G] [Fintype G] (p : â„•) {n m : â„•} [hp : Fact (Nat.Prime p)] (hdvd : p ^ m âˆ£ Fintype.card G) (H : Subgroup G) (hH : Fintype.card â†¥H = p ^ n) (hnm : n â‰¤ m) : âˆƒ (K : Subgroup G), Fintype.card â†¥K = p ^ m âˆ§ H â‰¤ K
{A : Type u_4} (K : Type u_5) [CommRing A] [is_IsDomain A] (L : Type u_6) [Field K] [Field L] [Algebra A K] [IsFractionRing A K] [Algebra A L] [Algebra K L] [isScalarTower A K L] [FiniteDimensional K L] : IsFractionRing â†¥(integralClosure A L) L
{Î± : Type u_1} {Î² : Type u_2} {m : measurableSpace Î±} [topologicalSpace Î²] {f : Î± â†’ Î²} (hF : âˆ€ (x y : Î±), f x = f y) : MeasureTheory.StronglyMeasurable f
{f : â„ â†’ â„} (hF : Differentiable â„ f) (hF'_anti : Antitone (deriv f)) : ConcaveOn â„ Set.Univ f
(j : â„•) : Â¬algebraic_topology.dold_kan.c.rel 0 j
{k : Type u_1} {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [CharZero k] {n : â„•} (s : Affine.Simplex k P n) {fsâ‚ fsâ‚‚ : Finset (Fin (n + 1))} {mâ‚ mâ‚‚ : â„•} (hâ‚ : fsâ‚.card = mâ‚ + 1) (hâ‚‚ : fsâ‚‚.card = mâ‚‚ + 1) : Finset.centroid k fsâ‚ s.points = Finset.centroid k fsâ‚‚ s.points â†” fsâ‚ = fsâ‚‚
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (a b : F) : char.quadratic_Char F (a * b) = char.quadratic_Char F a * char.quadratic_Char F b
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} {T : addSubmonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [AddCommMonoid Q] {k : T.localization_Map Q} (z : N) : â‡‘(f.map hy k) z + â‡‘(k.to_Map) (â‡‘g â†‘((f.sec z).snd)) = â‡‘(k.to_Map) (â‡‘g (f.sec z).fst)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (i0 : Î¹) : vectorSpan k (Set.Range p) = Submodule.span k (Set.Range (Î» (i : Î¹), p i -áµ¥ p i0))
{Î± : Type u} [pseudoEmetricSpace Î±] {s : Set Î±} : Isometry Coe
{Î± : Type u_1} {R : Type u_2} [CommSemiring R] (a b : R) (s : Finset Î±) : s.powerset.sum (Î» (t : Finset Î±), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card
{K : Type u} [Field K] (s : Subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
{Î± : Type u_1} [hasAdd Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b c d : Î±} (hâ‚ : a < b) (hâ‚‚ : c < d) : a + c < b + d
{Î± : Type u} [hasSsubset Î±] [IsIrrefl Î± HasSsubset.Ssubset] {a b : Î±} : a âŠ‚ b â†’ a â‰  b
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] : âŠ¤.direction = âŠ¤
{R : Type u_1} {a b : R} [Monoid R] (h : a * b = 1) : IsRightRegular a
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurableSpace Î±} {mâ‚‚ : measurableSpace Î²} {f : Î± â†’ Î²} : Measurable f â†’ mâ‚‚ â‰¤ MeasurableSpace.map f mâ‚
{Î± : Type u_1} {E : Type u_3} {F'' : Type u_10} [hasNorm E] [NormedGroup F''] {f : Î± â†’ E} {g'' : Î± â†’ F''} (h : f =O[Filter.cofinite] g'') : âˆƒ (C : â„) (H : C > 0), âˆ€ â¦ƒx : Î±â¦„, g'' x â‰  0 â†’ âˆ¥f xâˆ¥ â‰¤ C * âˆ¥g'' xâˆ¥
{R : Type u_1} [normedRing R] [CompleteSpace R] (x : RË£) : (Î» (t : R), Ring.inverse (â†‘x + t) - â†‘xâ»Â¹ + â†‘xâ»Â¹ * t * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ 2
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [Module ð•œ E] {x z : E} {s : Set E} (hs : StarConvex ð•œ (x + z) s) : StarConvex ð•œ x ((Î» (x : E), x + z) â»Â¹' s)
{F : Type u_1} [Field F] {p : Polynomial F} {E : Type u_2} [Field E] [Algebra F E] [Fact (Polynomial.Splits (algebraMap F E) p)] (Ï• : E â‰ƒâ‚[F] E) (x : â†¥(p.root_Set E)) : â†‘(â‡‘(Polynomial.Gal.restrict p E) Ï• â€¢ x) = â‡‘Ï• â†‘x
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Î¹ : Type u_1} [Fintype Î¹] {b : Î¹ â†’ V} : LinearIndependent K b â†” Fintype.card Î¹ = Set.finrank K (Set.Range b)
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : Real.sin (InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = Real.sin (InnerProductGeometry.angle x y)
{R : Type u_1} [hasMul R] {a : R} : IsRightRegular a â†” IsSmulRegular R (MulOpposite.op a)
{Î¹ : Type u_1} {E : Type u_2} [Fintype Î¹] [NormedGroup E] [normedSpace â„ E] (b : AffineBasis Î¹ â„ E) : Interior (â‡‘(convexHull â„) (Set.Range b.points)) = {x : E | âˆ€ (i : Î¹), 0 < â‡‘(b.coord i) x}
{Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {u : Î± â†’ Set Î²} {x : Î±} (xs : x âˆˆ s) : u x âŠ† â‹ƒ (x : Î±) (H : x âˆˆ s), u x
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) (v : E) : v âˆˆ Ká—® â†” âˆ€ (u : E), u âˆˆ K â†’ HasInner.inner u v = 0
{M : Type u_1} [hasAdd M] (c : AddCon M) {a b : M} : â†‘a = â†‘b â†” â‡‘c a b
{G : Type u} [Fintype G] [LeftCancelMonoid G] (x : G) : 0 < orderOf x
{Î± : Type u_1} {Î¹ : sort u_4} {s : Î¹ â†’ Set Î±} {t : Set Î±} (i : Î¹) (h : s i âŠ† t) : (â‹‚ (i : Î¹), s i) âŠ† t
{Î± : Type u} (s : Set Î±) : Subsingleton â†¥s â†” s.subsingleton
(R : Type u_2) {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] (n : â„•) (b : M) : n â€¢ b = â†‘n â€¢ b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : E â†’ F Ã— G} {x : E} (hF : ContDiffAt ð•œ n f x) : ContDiffAt ð•œ n (Î» (x : E), (f x).fst) x
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {Râ‚ Râ‚‚ : â„} {f : â„‚ â†’ E} {c z : â„‚} (hD : DifferentiableOn â„‚ f (Metric.Ball c Râ‚)) (h_maps : Set.MapsTo f (Metric.Ball c Râ‚) (Metric.Ball (f c) Râ‚‚)) (hz : z âˆˆ Metric.Ball c Râ‚) : âˆ¥dslope f c zâˆ¥ â‰¤ Râ‚‚ / Râ‚
{Î± : Type u_1} [measurableSpace Î±] (mâ‚ mâ‚‚ : MeasureTheory.OuterMeasure Î±) : (mâ‚ âŠ” mâ‚‚).trim = mâ‚.trim âŠ” mâ‚‚.trim
{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ b â‰¤ z) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (lb : â„¤), P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z
{f : Polynomial â„‚} (hF : 0 < f.degree) : âˆƒ (z : â„‚), f.is_root z
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {p : Î¹ â†’ P} (hi : AffineIndependent k p) {s : Finset Î¹} {n : â„•} (hc : s.card = n + 1) : FiniteDimensional.finrank k â†¥(vectorSpan k â†‘(Finset.image p s)) = n
{Î± : Type u_1} {ð•œ : Type u_14} [normedField ð•œ] {l : Filter Î±} {u v : Î± â†’ ð•œ} (h : u =O[l] v) : u / v * v =á¶ [l] u
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} [discreteTopology â†¥s] {x : Î±} (hx : x âˆˆ s) : âˆƒ (U : Set Î±) (H : U âˆˆ nhdsWithin x {x}á¶œ), Disjoint U s
{Î± : Type u} [SemilatticeInf Î±] [Nonempty Î±] (s : Finset Î±) : BddBelow â†‘s
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] {p1 p2 : P} : p1 -áµ¥ p2 = 0 â†” p1 = p2
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {f : Î± â†’ Î²} {x y : Î±} (hF : IsRingHom f) : f (x - y) = f x - f y
{Î± : sort u} {Î±' : sort w} [DecidableEq Î±] [DecidableEq Î±'] {Î² : sort u_1} (g : Î±' â†’ Î²) {f : Î± â†’ Î±'} (hF : Function.Injective f) (i : Î±) (a : Î²) : Function.update g (f i) a âˆ˜ f = Function.update (g âˆ˜ f) i a
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {f : Î± â†’ Î²} {s : Set Î±} {a : Î±} (h_Mono : MonotoneOn f s) (hs : s âˆˆ nhdsWithin a (Set.Ici a)) (hfs : âˆ€ (b : Î²), b > f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ Set.Ioo (f a) b)) : ContinuousWithinAt f (Set.Ici a) a
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (f : J â†’ C) [CategoryTheory.Limits.HasBiproduct f] {b : CategoryTheory.Limits.Bicone f} (hb : b.is_bilimit) : (hb.is_limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.Biproduct.isLimit f)).hom = CategoryTheory.Limits.biproduct.lift b.Ï€
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {f g : â„‚ â†’ E} (hdf : DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0)) (hBf : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hdg : DiffContOnCl â„‚ g (Set.Iio 0 Ã—â„‚ Set.Iio 0)) (hBg : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = g â†‘x) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * Complex.i) = g (â†‘x * Complex.i)) : Set.EqOn f g {z : â„‚ | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}
{F : Type u_2} [NormedGroup F] {f : â„ â†’ F} {a b c : â„} (hF : (Î» (x : â„), (x - c)â»Â¹) =O[nhdsWithin c {c}á¶œ] f) (hne : a â‰  b) (hc : c âˆˆ Set.Interval a b) : Â¬IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} {c : CategoryTheory.Limits.Fork f g} (i : CategoryTheory.Limits.IsLimit c) : CategoryTheory.Mono c.Î¹
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M â†’+ P} (H : c â‰¤ AddCon.ker f) : (c.lift f H).comp c.mk' = f
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [hasZero M] [AddCommMonoid N] [AddCommMonoid P] (h : N â†’+ P) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ N) : â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
(a : Zmod8) : â‡‘ZmodÏ‡â‚ˆ' a = â‡‘ZmodÏ‡â‚„ â†‘a * â‡‘ZmodÏ‡â‚ˆ a
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscreteNormedField R] [NormedGroup F] [normedSpace R F] [topologicalSpace B] {Î¹ : Type u_6} (Z : TopologicalVectorBundleCore R B F Î¹) : Continuous Z.proj
{Î± : Type u_1} {Î² : Type u_2} [Infinite Î±] [Fintype Î²] (f : Î± â†’ Î²) : âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y
{F : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [NonAssocSemiring Î±] [NonAssocSemiring Î²] [ringHomClass F Î± Î²] (f : F) (a : Î±) : â‡‘f (bit1 a) = bit1 (â‡‘f a)
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} {x : Î±} {r : â„} (h : x âˆˆ s) (H : Metric.hausdorffDist s t < r) (Fin : Emetric.hausdorffEdist s t â‰  âŠ¤) : âˆƒ (y : Î±) (H : y âˆˆ t), HasDist.dist x y < r
{Î± : Type u_1} [CancelCommMonoidWithZero Î±] [UniqueFactorizationMonoid Î±] {a p : Associates Î±} (hp : Irreducible p) [Î  (n : â„•), Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n) : a = p ^ Nat.find _
{R : Type u_1} [Semiring R] (s : Subsemiring R) {l : List R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] (f g : E â†’sl[Ïƒâ‚â‚‚] F) : âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ AddMon) [CategoryTheory.IsFiltered J] (x y : Î£ (j : J), â†¥(F.obj j)) (k : J) (f : x.fst âŸ¶ k) (g : y.fst âŸ¶ k) : AddMon.FilteredColimits.M.mk F x + AddMon.FilteredColimits.M.mk F y = AddMon.FilteredColimits.M.mk F âŸ¨k, â‡‘(F.map f) x.snd + â‡‘(F.map g) y.sndâŸ©
{G : Type u_1} [AddGroup G] [hN : Nontrivial G] : Add_monoid.is_torsion_free G â†’ Â¬Add_monoid.is_torsion G
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] (e : localHomeomorph Î± Î²) (s : Set Î²) : e.to_local_equiv.source âˆ© â‡‘e â»Â¹' Interior s = e.to_local_equiv.source âˆ© Interior (â‡‘e â»Â¹' s)
{G : Type u_10} {H : Type u_11} [Group G] [divisionMonoid H] (h : G â‰ƒ* H) (x : G) : â‡‘h xâ»Â¹ = (â‡‘h x)â»Â¹
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} {r : R} (h : SameRay R x y) (hr : 0 â‰¤ r) : SameRay R (r â€¢ x) y
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : o.oangle (â‡‘(o.rotation (o.oangle x y)) x) y = 0
{Î± : Type u_1} [uniformSpace Î±] : (Uniformity Î±).has_Basis (Î» (V : Set (Î± Ã— Î±)), V âˆˆ Uniformity Î±) Closure
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {Î¹ : Type w} (h : Basis Î¹ K V) : â†‘(FiniteDimensional.finrank K V) = Cardinal.mk Î¹
{Î± : Type u_1} {M : Type u_5} [hasZero M] : Function.Injective coeFn
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (hâ‚€ : r â‰  0) {a : â„} (ha : a âˆˆ Set.Ioo (-1) 1) (hp : (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =O[Filter.atTop] Pow.pow a) : â†‘r < p.radius
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (x : Î± (fin.last n)) (p : Î  (i : Fin n), Î± (â‡‘fin.cast_Succ i)) (z : Î± (fin.last n)) : Function.update (fin.snoc p x) (fin.last n) z = fin.snoc p z
{Î± : Type u} [topologicalSpace Î±] [LocallyCompactSpace Î±] [RegularSpace Î±] {K U : Set Î±} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K âŠ† U) : âˆƒ (V : Set Î±), is_IsOpen V âˆ§ K âŠ† V âˆ§ Closure V âŠ† U âˆ§ is_IsCompact (Closure V)
(K : Type u_1) [Field K] [IsAlgClosed K] (S : Set â„•+) : IsCyclotomicExtension S K K
{Î± : Type u} [HasSubset Î±] [IsTrans Î± HasSubset.Subset] {a b c : Î±} : a âŠ† b â†’ b âŠ† c â†’ a âŠ† c
(f : Circle_deg1_Lift) (x : â„) : Filter.Tendsto (Î» (n : â„•), (â‡‘(f ^ n) x - x) / â†‘n) Filter.atTop (nhds f.translation_number)
{Î± : Type u_1} {Î¹ : sort u_3} [conditionallyCompleteLattice Î±] {b : Î±} [Nonempty Î¹] {f : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), f i â‰¤ b) (hâ‚‚ : âˆ€ (w : Î±), w < b â†’ (âˆƒ (i : Î¹), w < f i)) : (â¨† (i : Î¹), f i) = b
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f g : E â†’ Î²} (hF : ConcaveOn ð•œ s f) (hg : ConcaveOn ð•œ s g) : ConcaveOn ð•œ s (f âŠ“ g)
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [hasZero M] [AddCommMonoid N] (f : Î± â†’â‚€ M) (y : Î±) (g : Î± â†’ M â†’ N) (hg : âˆ€ (i : Î±), g i 0 = 0) : g y (â‡‘f y) + (Finsupp.erase y f).sum g = f.sum g
{C : Type u} [CategoryTheory.Category C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) [CategoryTheory.StrongMono f] [CategoryTheory.StrongMono g] : CategoryTheory.StrongMono (f â‰« g)
{X : Type u_2} [emetricSpace X] {mâ‚ mâ‚‚ : Ennreal â†’ Ennreal} {c : Ennreal} (hc : c â‰  âŠ¤) (h0 : c â‰  0) (hle : mâ‚ â‰¤á¶ [nhdsWithin 0 (Set.Ici 0)] c â€¢ mâ‚‚) : MeasureTheory.OuterMeasure.mkMetric mâ‚ â‰¤ c â€¢ MeasureTheory.OuterMeasure.mkMetric mâ‚‚
{Î± : Type u_1} [measurableSpace Î±] {Î¹ : Type u_2} {f : Î¹ â†’ Î± â†’ Ennreal} {g : Î± â†’ Ennreal} (u : Filter Î¹) [u.ne_IsBot] [u.is_countably_generated] (hF : âˆ€ (i : Î¹), Measurable (f i)) (lim : Filter.Tendsto f u (nhds g)) : Measurable g
{M : Type u} [Monoid M] {F : Type v} [divisionRing F] [mulSemiringAction M F] (x : M) (m : F) : x â€¢ mâ»Â¹ = (x â€¢ m)â»Â¹
{Î± : Type u_1} [pseudoEmetricSpace Î±] {f : â„• â†’ Î±} (d : â„• â†’ Ennreal) (hF : âˆ€ (n : â„•), HasEdist.edist (f n) (f n.succ) â‰¤ d n) {a : Î±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) (n : â„•) : HasEdist.edist (f n) a â‰¤ âˆ‘' (m : â„•), d (n + m)
{C : Type u} [CategoryTheory.Category C] (F : Cáµ’áµ– â¥¤ Type v) : (CategoryTheory.categoryOfElements.fromCostructuredArrow F).right_Op â‹™ CategoryTheory.categoryOfElements.toCostructuredArrow F = ðŸ­ (CategoryTheory.CostructuredArrow CategoryTheory.yoneda F)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) : 2 â€¢ o.oangle x (-x) = 0
{M : Type u_1} [monoidWithZero M] {f g : â„¤ â†’*â‚€ M} (h_Neg_One : â‡‘f (-1) = â‡‘g (-1)) (h_Nat : f.comp int.of_Nat_hom.to_monoidWithZero_hom = g.comp int.of_Nat_hom.to_monoidWithZero_hom) : f = g
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semiNormedGroup Vâ‚] [semiNormedGroup Vâ‚‚] (f : NormedGroupHom Vâ‚ Vâ‚‚) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ M * âˆ¥xâˆ¥) : âˆ¥fâˆ¥ â‰¤ M
{V : Type u_1} [innerProductSpace â„ V] (x : V) : InnerProductGeometry.angle 0 x = Real.pi / 2
{n : â„•} {Î± : Type u_1} [Preorder Î±] {f g : Fin n â†’ Î±} (hF : StrictMono f) (hg : StrictMono g) (h : Set.Range f = Set.Range g) : f = g
{R : Type u_1} [Fintype R] [CommRing R] [IsReduced R] [Char_p R 2] (a : R) : IsSquare a
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : f =O[l] g' â†” âˆ€á¶  (c : â„) in Filter.atTop, âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g' xâˆ¥
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_3} (K : Î¹ â†’ Submodule ð•œ E) : (â¨… (i : Î¹), (K i)á—®) = (supr K)á—®
{R : Type u} {K : Type v} {L : Type z} {p : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [isScalarTower R K L] [IsSeparable K L] [is_IsDomain R] [NormalizedGcdMonoid R] [IsFractionRing R K] [IsIntegrallyClosed R] {B : powerBasis K L} (hp : Prime p) (hBint : IsIntegral R B.gen) {n : â„•} {z : L} (hzint : IsIntegral R z) (hz : p ^ n â€¢ z âˆˆ Algebra.adjoin R {B.gen}) (hei : (minpoly R B.gen).is_eisenstein_at (Submodule.span R {p})) : z âˆˆ Algebra.adjoin R {B.gen}
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] {f : Î² â†’ Î±} : Metric.Bounded (Set.Range f) â†” âˆƒ (C : â„), âˆ€ (x y : Î²), HasDist.dist (f x) (f y) â‰¤ C
{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) (k : â„•) : M ^ k = â‡‘(Polynomial.aeval M) (Polynomial.x ^ k %â‚˜ M.charpoly)
{Î± : Type u_1} [LinearOrder Î±] [DecidableEq Î±] {p : Finset Î± â†’ Prop} (s : Finset Î±) (h0 : p âˆ…) (step : âˆ€ (a : Î±) (s : Finset Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ a < x) â†’ p s â†’ p (HasInsert.insert a s)) : p s
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteCoproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.NormalEpiCategory C] {X Y : C} (f g : X âŸ¶ Y) : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair f g)
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [FiniteDimensional k V] [Fintype Î¹] {p : Î¹ â†’ P} (hi : AffineIndependent k p) : affineSpan k (Set.Range p) = âŠ¤ â†” Fintype.card Î¹ = FiniteDimensional.finrank k V + 1
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 p2 : P) (hp1p2 : p1 â‰  p2) : EuclideanGeometry.angle p1 (midpoint â„ p1 p2) p2 = Real.pi
(M : Type u_1) (Î± : Type u_2) [Monoid M] [mulAction M Î±] {P Q : Submonoid M} : MulAction.FixedPoints â†¥(P âŠ” Q) Î± = MulAction.FixedPoints â†¥P Î± âˆ© MulAction.FixedPoints â†¥Q Î±
{M : Type u_1} [groupWithZero M] : Set.Center MË£ = Coe â»Â¹' Set.Center M
{Î± : Type u} {n : â„•} (f : Fin n â†’ Î±) (i : â„•) : (List.ofFn f).nth i = List.ofFnNthVal f i
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x y : E} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ ^ 2
{F : Type u_3} [innerProductSpace â„ F] (x y : F) : HasInner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ x
{Î¹ : Type u} {X : Type v} [topologicalSpace X] {s : Set X} [NormalSpace X] [ParacompactSpace X] (p : (X â†’ â„) â†’ Prop) (h01 : âˆ€ (s t : Set X), is_IsClosed s â†’ is_IsClosed t â†’ Disjoint s t â†’ (âˆƒ (f : C(X, â„)), p â‡‘f âˆ§ Set.EqOn â‡‘f 0 s âˆ§ Set.EqOn â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ Set.Icc 0 1)) (hs : is_IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ (i : Î¹), is_IsOpen (U i)) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : BumpCovering Î¹ X s), (âˆ€ (i : Î¹), p â‡‘(â‡‘f i)) âˆ§ f.is_subordinate U
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’. Î² âŠ• Î±} (a a' : Î±) (ha' : Sum.inr a' âˆˆ f a) : f.fix a = f.fix a'
{Î± : Type u_1} [topologicalSpace Î±] [t2_Space Î±] {f : Î± â†’ Î±} (hF : Continuous f) : is_IsClosed (Function.FixedPoints f)
{s : Set â„} : IsPreconnected s â†’ Convex â„ s
{fâ‚ fâ‚‚ : Circle_deg1_LiftË£} (h : â†‘fâ‚.translation_number = â†‘fâ‚‚.translation_number) : âˆƒ (F : Circle_deg1_Lift), Function.Semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] (f : M â†’+ P) {x y : M} : â‡‘(AddCon.ker f) x y â†” â‡‘f x = â‡‘f y
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {X Y : C} (p : X = Y) : F.map (CategoryTheory.eqToHom p) = CategoryTheory.eqToHom _
{Î± : Type u_3} [SemilatticeSup Î±] (a : Î±) : Filter.atTop = Filter.comap Coe Filter.atTop
{Î± : Type u_1} [normedRing Î±] [CompleteSpace Î±] {f g : â„• â†’ Î±} (hF : Summable (Î» (x : â„•), âˆ¥f xâˆ¥)) (hg : Summable (Î» (x : â„•), âˆ¥g xâˆ¥)) : (âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (Finset.range (n + 1)).sum (Î» (k : â„•), f k * g (n - k))
 : Filter.Tendsto (Î» (n : â„•), (Finset.range n).sum (Î» (i : â„•), 1 / (â†‘i + 1))) Filter.atTop Filter.atTop
{M : Type u_1} [CancelCommMonoidWithZero M] [DecidableEq M] [UniqueFactorizationMonoid M] [Unique MË£] (x : M) : UniqueFactorizationMonoid.factors x = UniqueFactorizationMonoid.normalizedFactors x
{Î± : sort u_1} {Î² : Type u_2} {Î³ : sort u_3} [DecidableEq Î²] (g : Î² â†’ Î³) {f : Î± â†’ Î²} {i : Î²} (a : Î³) (h : i âˆ‰ Set.Range f) : Function.update g i a âˆ˜ f = g âˆ˜ f
{ð•‚ : Type u_1} {ð”¸ : Type u_2} {ð”¹ : Type u_3} [nondiscreteNormedField ð•‚] [normedRing ð”¸] [normedRing ð”¹] [NormedAlgebra ð•‚ ð”¸] [NormedAlgebra ð•‚ ð”¹] [CompleteSpace ð”¸] {F : Type u_4} [ringHomClass F ð”¸ ð”¹] (f : F) (hF : Continuous â‡‘f) (x : ð”¸) (hx : x âˆˆ Emetric.Ball 0 (expSeries ð•‚ ð”¸).radius) : â‡‘f (Exp ð•‚ x) = Exp ð•‚ (â‡‘f x)
{s : Set â„} : Convex â„ s â†’ IsPreconnected s
{Î± : Type u_3} {Î² : Type u_4} [Nonempty Î±] [SemilatticeSup Î±] [Preorder Î²] {f : Î± â†’ Î²} : Filter.Tendsto f Filter.atTop Filter.atTop â†” âˆ€ (b : Î²), âˆƒ (i : Î±), âˆ€ (a : Î±), i â‰¤ a â†’ b â‰¤ f a
{R : Type u} [NonAssocSemiring R] {S T : Subsemiring R} (h : âˆ€ (x : R), x âˆˆ S â†” x âˆˆ T) : S = T
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] {v : â„ â†’ E â†’ E} {t_min tâ‚€ t_max : â„} (htâ‚€ : tâ‚€ âˆˆ Set.Icc t_min t_max) (xâ‚€ : E) {C R : â„} (hR : 0 â‰¤ R) {L : Nnreal} (Hlip : âˆ€ (t : â„), t âˆˆ Set.Icc t_min t_max â†’ LipschitzOnWith L (v t) (Metric.ClosedBall xâ‚€ R)) (Hcont : âˆ€ (x : E), x âˆˆ Metric.ClosedBall xâ‚€ R â†’ ContinuousOn (Î» (t : â„), v t x) (Set.Icc t_min t_max)) (Hnorm : âˆ€ (t : â„), t âˆˆ Set.Icc t_min t_max â†’ âˆ€ (x : E), x âˆˆ Metric.ClosedBall xâ‚€ R â†’ âˆ¥v t xâˆ¥ â‰¤ C) (HMul_LE : C * Linear_order.max (t_max - tâ‚€) (tâ‚€ - t_min) â‰¤ R) : âˆƒ (f : â„ â†’ E), f tâ‚€ = xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ Set.Icc t_min t_max â†’ HasDerivWithinAt f (v t (f t)) (Set.Icc t_min t_max) t
{s : Set â„} (h : Metric.Bounded s) : Metric.diam s = HasSup.sup s - HasInf.inf s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {jâ‚ jâ‚‚ jâ‚ƒ kâ‚ kâ‚‚ l : C} (fâ‚ : jâ‚ âŸ¶ kâ‚) (fâ‚‚ : jâ‚‚ âŸ¶ kâ‚) (fâ‚ƒ : jâ‚‚ âŸ¶ kâ‚‚) (fâ‚„ : jâ‚ƒ âŸ¶ kâ‚‚) (gâ‚ : jâ‚ âŸ¶ l) (gâ‚‚ : jâ‚ƒ âŸ¶ l) : âˆƒ (s : C) (Î± : kâ‚ âŸ¶ s) (Î² : l âŸ¶ s) (Î³ : kâ‚‚ âŸ¶ s), fâ‚ â‰« Î± = gâ‚ â‰« Î² âˆ§ fâ‚‚ â‰« Î± = fâ‚ƒ â‰« Î³ âˆ§ fâ‚„ â‰« Î³ = gâ‚‚ â‰« Î²
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] [DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ Î²) {a : Î±} (h : a âˆˆ s) : f a * (s.erase a).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topologicalSpace B] [topologicalSpace F] (Z : TopologicalFiberBundleCore Î¹ B F) : IsTopologicalFiberBundle F Z.proj
{Î± : Type u_1} [HasLe Î±] {a b : Î±} : b â‰¤ a â†’ â‡‘OrderDual.toDual a â‰¤ â‡‘OrderDual.toDual b
{Î± : Type u} [pseudoMetricSpace Î±] (x y : UniformSpace.Completion Î±) (h : HasDist.dist x y = 0) : x = y
{Î² : Type v} {Î´ : Type u_2} [topologicalSpace Î²] [topologicalSpace Î´] {Î± : Type u_1} {Î³ : Type u_3} (f : Î± â†’ Î²) (g : Î³ â†’ Î´) : Prod.topologicalSpace = TopologicalSpace.induced (Î» (p : Î± Ã— Î³), (f p.fst, g p.snd)) Prod.topologicalSpace
(x : Pgame) : (0 * x).equiv 0
{Î± : Type u} {Î² : Î± â†’ Type u} [Î  (a : Î±), Fintype (Î² a)] : Cardinal.mk (W_type Î²) â‰¤ Linear_order.max (Cardinal.mk Î±) Cardinal.aleph_0
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] {x : E} {s : Set E} (hs : s âˆˆ nhds x) : âˆƒ (f : E â†’ â„), f =á¶ [nhds x] 1 âˆ§ (âˆ€ (y : E), f y âˆˆ Set.Icc 0 1) âˆ§ ContDiff â„ âŠ¤ f âˆ§ HasCompactSupport f âˆ§ Tsupport f âŠ† s
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {v : M} (h : v â‰  0) {r : R} (hr : 0 < r) (hrv : r â€¢ v â‰  0) : rayOfNeZero R (r â€¢ v) hrv = rayOfNeZero R v h
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (H : CategoryTheory.CoverDense K G) [CategoryTheory.Full G] {â„± : Dáµ’áµ– â¥¤ Type v} {â„±' : CategoryTheory.SheafOfTypes K} (Î± : G.op â‹™ â„± âŸ¶ G.op â‹™ â„±'.val) {X : D} (x : â„±.obj (Opposite.op X)) : (CategoryTheory.CoverDense.Types.pushforwardFamily H Î± x).compatible
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhdsWithin a (Set.Ioi a) â†” âˆƒ (u : Î±) (H : u âˆˆ Set.Ioi a), Set.Ioo a u âŠ† s
{Î¹ : Type u_1} {R : Type u_8} [canonicallyOrderedCommSemiring R] [Nontrivial R] [DecidableEq R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) : s.prod (Î» (i : Î¹), f i) < âŠ¤
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R M) (w : Î¹ â†’ RË£) : â‡‘(e.det) â‡‘(e.units_Smul w) = finset.univ.prod (Î» (i : Î¹), â†‘(w i))
(H : Type u) (M : Type u_2) [topologicalSpace H] [topologicalSpace M] [chartedSpace H M] [LocallyCompactSpace H] : LocallyCompactSpace M
{a b : Prop} : Â¬(a âˆ¨ b) â†” Â¬a âˆ§ Â¬b
{g : Matrix.SpecialLinearGroup (Fin 2) â„¤} {z : UpperHalfPlane} (hz : z âˆˆ ModularGroup.Fdo) (hg : g â€¢ z âˆˆ ModularGroup.Fdo) : z = g â€¢ z
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] [DecidableEq Î±] (s : Finset Î±) (a : Î±) (b : Î± â†’ Î²) : s.prod (Î» (x : Î±), Ite (x = a) (b x) 1) = Ite (a âˆˆ s) (b a) 1
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] [NoZeroDivisors A] (h : Function.Injective â‡‘(algebraMap R A)) : NoZeroSmulDivisors R A
{Î¹ : Type v} (f : Î¹ â†’ Cardinal) : (Cardinal.sup f).lift = Cardinal.sup (Î» (i : Î¹), (f i).lift)
{X Y Z : AlgebraicGeometry.Scheme} (ð’° : X.open_cover) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) [âˆ€ (i : ð’°.J), CategoryTheory.Limits.HasPullback (ð’°.map i â‰« f) g] (i : ð’°.J) : CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst â‰« algebraic_geometry.Scheme.pullback.p2 ð’° f g) _ â‰« (AlgebraicGeometry.Scheme.Pullback.gluing ð’° f g).Î¹ i = CategoryTheory.Limits.pullback.fst
{Î± : Type u_1} (L : List (List Î±)) {i j : â„•} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : L.join.nth_LE ((List.take i (List.map List.length L)).sum + j) _ = (L.nth_LE i hi).nth_LE j hj
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : (Î» (x : Î±), -f' x) =O[l] g â†’ f' =O[l] g
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {Lâ‚ Lâ‚‚ : C â¥¤ D} {Râ‚ Râ‚‚ : D â¥¤ C} (Adjâ‚ : Lâ‚ âŠ£ Râ‚) (Adjâ‚‚ : Lâ‚‚ âŠ£ Râ‚‚) (f : Râ‚ âŸ¶ Râ‚‚) [CategoryTheory.IsIso (â‡‘((CategoryTheory.transferNatTransSelf Adjâ‚ Adjâ‚‚).symm) f)] : CategoryTheory.IsIso f
{x y : Game} : Â¬x.lf y â†” y â‰¤ x
{Î± : Type u_1} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {r : â„•} (hð’œ : Set.Sized r â†‘ð’œ) : Set.Sized (r - 1) â†‘(ð’œ.shadow)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {K' : Submodule ð•œ E} [CompleteSpace â†¥K'] (h : K = K') (u : E) : â†‘(â‡‘(orthogonalProjection K) u) = â†‘(â‡‘(orthogonalProjection K') u)
{M : Type u_1} [AddMonoid M] {s : Set M} (hs : IsAddSubmonoid s) {l : List M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : P) (ps : Set P) : affineSpan k (HasInsert.insert p â†‘(affineSpan k ps)) = affineSpan k (HasInsert.insert p ps)
{k : Type u_1} {G : Type u_2} {V : Type u_3} [CommRing k] [Group G] [AddCommGroup V] [Module k V] (Ï : Representation k G V) (g h : G) : Ï.character (h * g * hâ»Â¹) = Ï.character g
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : Set P} (h : s.finite) : FiniteDimensional k â†¥(vectorSpan k s)
{Î± : Type u_1} [measurableSpace Î±] (mâ‚ mâ‚‚ : MeasureTheory.OuterMeasure Î±) : (mâ‚ + mâ‚‚).trim = mâ‚.trim + mâ‚‚.trim
{Î± : Type u_1} {Î² : Type u_2} {s : Finset Î±} {t : Finset Î²} (hc : t.card < s.card) {f : Î± â†’ Î²} (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) : âˆƒ (x : Î±) (H : x âˆˆ s) (y : Î±) (H : y âˆˆ s), x â‰  y âˆ§ f x = f y
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsArtinian R M] (f : M â†’â‚—[R] M) (s : Function.Injective â‡‘f) : Function.Surjective â‡‘f
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X : CategoryTheory.SimplicialObject C} (q : â„•) : (algebraic_topology.dold_kan.HÏƒ q).f 0 = 0
{Î± : Type u_1} {Î² : Type u_2} {s sâ‚ : Set Î±} {t tâ‚ : Set Î²} : s Ã—Ë¢ t âŠ† sâ‚ Ã—Ë¢ tâ‚ â†” s âŠ† sâ‚ âˆ§ t âŠ† tâ‚ âˆ¨ s = âˆ… âˆ¨ t = âˆ…
{R : Type u_1} {S : Type u_2} [CommSemiring R] [CommSemiring S] [H : LocalRing S] (f : R â†’+* S) [IsLocalRingHom f] : LocalRing R
{f : â„• â†’â‚€ â„•} (hF : 0 âˆ‰ f.support) : 0 < f.prod Pow.pow
(s : â„) (hs : 1 < s) : MeasureTheory.IntegrableOn (Î» (x : â„), âˆ¥Real.exp (-x) * Real.log x * x ^ (s - 1)âˆ¥) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [AddCommMonoid Î²] {s : Finset Î³} {t : Finset Î±} {f : Î³ â†’ Î± â†’ Î²} : (s.product t).sum (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = t.sum (Î» (y : Î±), s.sum (Î» (x : Î³), f x y))
{z : UpperHalfPlane} (h : 1 < â‡‘Complex.normSq â†‘z) : â‡‘Complex.normSq â†‘(ModularGroup.s â€¢ z) < 1
{A : Type u_1} [normedRing A] [NormedAlgebra â„‚ A] [CompleteSpace A] [starRing A] [CstarRing A] [StarModule â„‚ A] [Nontrivial A] {a : A} (ha : a âˆˆ selfAdjoint A) {z : â„‚} (hz : z âˆˆ Spectrum â„‚ a) : z = â†‘(z.re)
{R : Type u_1} {M : Type u_9} {Î¹ : Type u_17} [Semiring R] [AddCommMonoid M] [Module R M] [Fintype Î¹] [DecidableEq Î¹] (f : (Î¹ â†’ R) â†’â‚—[R] M) (x : Î¹ â†’ R) : â‡‘f x = finset.univ.sum (Î» (i : Î¹), x i â€¢ â‡‘f (Î» (j : Î¹), Ite (i = j) 1 0))
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} [topologicalSpace Î±] (L : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : Set Î±) (H : t âˆˆ nhdsWithin x s) (F : Î± â†’ Î²), ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u)) : ContinuousOn f s
{Î± : Type u_1} [topologicalSpace Î±] [BaireSpace Î±] {S : Set (Set Î±)} (ho : âˆ€ (s : Set Î±), s âˆˆ S â†’ is_GÎ´ s) (hS : S.countable) (hD : âˆ€ (s : Set Î±), s âˆˆ S â†’ Dense s) : Dense (â‹‚â‚€ S)
{R : Type u_2} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R] [Nontrivial R] [normalizationMonoid R] [DecidableEq R] {p x : R} (hp : Irreducible p) (hnorm : â‡‘normalize p = p) {n : â„•} (hle : p ^ n âˆ£ x) (hlt : Â¬p ^ (n + 1) âˆ£ x) : Multiset.count p (UniqueFactorizationMonoid.normalizedFactors x) = n
{Î± : Type u_1} [PartialOrder Î±] {f : Î± â†’ Î±} {p : Î± â†’ Prop} {hF : âˆ€ (x : Î±), x â‰¤ f x} {hfp : âˆ€ (x : Î±), p (f x)} {hmin : âˆ€ â¦ƒx y : Î±â¦„, x â‰¤ y â†’ p y â†’ f x â‰¤ y} (x : Î±) : p (â‡‘(ClosureOperator.mkâ‚ƒ f p hF hfp hmin) x)
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (e : n â‰ƒ m) (A : Matrix m m R) : (A.minor â‡‘e â‡‘e).det = A.det
{X : Type u_2} [emetricSpace X] [measurableSpace X] [BorelSpace X] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [hÎ¹ : Î  (n : Î²), Fintype (Î¹ n)] (s : Set X) {l : Filter Î²} (r : Î² â†’ Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ Set X) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), Emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, s âŠ† â‹ƒ (i : Î¹ n), t n i) (m : Ennreal â†’ Ennreal) : â‡‘(MeasureTheory.Measure.mkMetric m) s â‰¤ l.liminf (Î» (n : Î²), finset.univ.sum (Î» (i : Î¹ n), m (Emetric.diam (t n i))))
{ð•œ : Type u_1} [normedField ð•œ] [CompleteSpace ð•œ] {r : ð•œ} (hr : âˆ¥râˆ¥ < 1) : âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : â‡‘fin.cast_Succ j < i) : X.Ïƒ (â‡‘fin.cast_Succ j) â‰« X.Î´ i.succ = X.Î´ i â‰« X.Ïƒ j
{k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [Semiring k] [AddMonoid G] [Semiring R] {f g : AddMonoidAlgebra k G â†’+* R} (hâ‚ : f.comp AddMonoidAlgebra.singleZeroRingHom = g.comp AddMonoidAlgebra.singleZeroRingHom) (h_of : â†‘f.comp (AddMonoidAlgebra.of k G) = â†‘g.comp (AddMonoidAlgebra.of k G)) : f = g
{R : Type u_1} {a : R} [MulZeroClass R] [Nontrivial R] (la : IsLeftRegular a) : a â‰  0
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s t : Set Î±} (hs : BddBelow s) (sne : s.nonempty) (ht : BddBelow t) (tne : t.nonempty) : HasInf.inf (s âˆª t) = HasInf.inf s âŠ“ HasInf.inf t
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {c : â„} {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : asymptotics.is_O_with c l f' g â†’ asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) g
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Semiring R] [AddCommMonoid N] [Module R N] (p : Î¹ â†’ Prop) [DecidablePred p] (S : Î¹ â†’ Submodule R N) : (â¨† (i : Î¹) (h : p i), S i) = ((â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (S i).subtype)).comp (Dfinsupp.filterLinearMap R (Î» (i : Î¹), â†¥(S i)) p)).range
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {aâ‚ aâ‚‚ : Î±} {bâ‚ bâ‚‚ : Î²} (qâ‚ : Path.Homotopic.Quotient aâ‚ aâ‚‚) (qâ‚‚ : Path.Homotopic.Quotient bâ‚ bâ‚‚) : Path.Homotopic.projLeft (Path.Homotopic.prod qâ‚ qâ‚‚) = qâ‚
{Î¹ : Type u_1} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [AddCommGroup N] (p : Î¹ â†’ AddSubgroup N) : CompleteLattice.Independent p â†” Function.Injective â‡‘(Dfinsupp.sumAddHom (Î» (i : Î¹), (p i).subtype))
{G : Type u_7} [CommGroup G] (L : List G) : (L.prod)â»Â¹ = (List.map (Î» (x : G), xâ»Â¹) L).prod
(Î± : Type u_1) : Subsingleton Î± âˆ¨ Nontrivial Î±
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s1 s2 : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 âˆˆ s1) (hp2 : p2 âˆˆ s2) : (s1 âŠ” s2).direction = s1.direction âŠ” s2.direction âŠ” Submodule.span k {p2 -áµ¥ p1}
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {X : C} (h : Category_theory.yoneda.obj X â‹™ CategoryTheory.uliftFunctor â‰… F.cones) (s : CategoryTheory.Limits.Cone F) : (CategoryTheory.Limits.IsLimit.OfNatIso.limitCone h).extend (CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone h s) = s
{Fq : Type u_1} [Fintype Fq] [Ring Fq] {d m : â„•} (hm : Fintype.card Fq ^ d â‰¤ m) (b : Polynomial Fq) (A : Fin m.succ â†’ Polynomial Fq) (hA : âˆ€ (i : Fin m.succ), (A i).degree < b.degree) : âˆƒ (iâ‚€ iâ‚ : Fin m.succ), iâ‚€ â‰  iâ‚ âˆ§ (A iâ‚ - A iâ‚€).degree < â†‘(b.nat_degree - d)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s u : Set E} {f : E â†’ F} {x : E} {n : â„•} (hu : u âˆˆ nhds x) (hs : UniqueDiffOn ð•œ s) (xs : x âˆˆ s) : iteratedFderivWithin ð•œ n f (s âˆ© u) x = iteratedFderivWithin ð•œ n f s x
 : ContMdiff (modelWithCornersSelf â„ â„) (modelWithCornersSelf â„ (EuclideanSpace â„ (Fin 1))) âŠ¤ â‡‘expMapCircle
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : ringChar F â‰  2) {a : F} (ha : a â‰  0) : char.quadratic_Char F a = Ite (a ^ (Fintype.card F / 2) = 1) 1 (-1)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {x : E} {n : WithTop â„•} {f : E â†’ ð•œ} {g : E â†’ F} (hF : ContDiffAt ð•œ n f x) (hg : ContDiffAt ð•œ n g x) : ContDiffAt ð•œ n (Î» (x : E), f x â€¢ g x) x
{R : Type u} {S : Type v} [NonAssocSemiring R] [NonAssocSemiring S] (f : R â†’+* S) (hF : Function.Surjective â‡‘f) : f.srange = âŠ¤
(ð•‚ : Type u_1) (ð•‚' : Type u_2) (ð”¸ : Type u_3) [Field ð•‚] [Field ð•‚'] [Ring ð”¸] [Algebra ð•‚ ð”¸] [Algebra ð•‚' ð”¸] [topologicalSpace ð”¸] [TopologicalRing ð”¸] (n : â„•) (x : ð”¸) : â‡‘(expSeries ð•‚ ð”¸ n) (Î» (_x : Fin n), x) = â‡‘(expSeries ð•‚' ð”¸ n) (Î» (_x : Fin n), x)
{E : Type u_1} {F : Type u_2} [innerProductSpace â„ E] [innerProductSpace â„ F] (f : E â†’L[â„] F) : IsConformalMap f â†” âˆƒ (c : â„), 0 < c âˆ§ âˆ€ (u v : E), HasInner.inner (â‡‘f u) (â‡‘f v) = c * HasInner.inner u v
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {f : Filter Î±} {g : Filter Î²} {n : Î³ â†’ Î´} {m' : Î² â†’ Î±' â†’ Î´} {n' : Î± â†’ Î±'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), n (m a b) = m' b (n' a)) : Filter.map n (Filter.mapâ‚‚ m f g) = Filter.mapâ‚‚ m' g (Filter.map n' f)
{p n : â„•} (n_big : 2 < n) (p_LE_n : p â‰¤ n) (big : 2 * n < 3 * p) : â‡‘(n.central_binom.factorization) p = 0
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [DecidableEq Î¹] [Î  (i : Î¹), LinearOrder (Î± i)] (x y z : Î  (i : Î¹), Î± i) : Set.Icc x z  set.univ.pi (Î» (i : Î¹), Set.Ioc (y i) (z i)) âŠ† â‹ƒ (i : Î¹), Set.Icc x (Function.update z i (y i))
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (h : InnerProductGeometry.angle x y = Real.pi) : âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} : Monotone f â†’ Antitone (â‡‘OrderDual.toDual âˆ˜ f)
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (u : RË£) (v : Module.Ray R M) : uâ»Â¹ â€¢ v = u â€¢ v
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] {s : Set Î²} : is_IsCompact s â†’ s.nonempty â†’ âˆ€ {f : Î² â†’ Î±}, ContinuousOn f s â†’ (âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f y â‰¤ f x)
{Î± : Type u_1} [topologicalSpace Î±] [PolishSpace Î±] {s : Set Î±} (hs : is_IsOpen s) : PolishSpace â†¥s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] {X : C} (f : 0 âŸ¶ X) : f = 0
{R : Type u_1} [CommRing R] {câ‚ câ‚‚ : R} (c : CliffordAlgebra (CliffordAlgebraQuaternion.q câ‚ câ‚‚)) : â‡‘CliffordAlgebraQuaternion.toQuaternion (â‡‘CliffordAlgebra.involute (â‡‘CliffordAlgebra.reverse c)) = â‡‘QuaternionAlgebra.conj (â‡‘CliffordAlgebraQuaternion.toQuaternion c)
(p : â„•) (a : Zmod p) (ha : a ^ (p - 1) = 1) (hD : âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) : Nat.Prime p
{X Y : Profinite} (f : X âŸ¶ Y) : IsClosedMap â‡‘f
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semiNormedGroup Vâ‚] [semiNormedGroup Vâ‚‚] (f : NormedGroupHom Vâ‚ Vâ‚‚) : LipschitzWith âŸ¨âˆ¥fâˆ¥, _âŸ© â‡‘f
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (h : Â¬Metric.Bounded s) : Metric.diam s = 0
{R : Type u_1} {S : Type u_2} [CommRing R] [is_IsDomain R] [CommRing S] {L : Type u_3} [Field L] [Algebra R S] [Algebra S L] [Algebra R L] [isScalarTower R S L] [IsIntegralClosure S R L] (h : Algebra.IsAlgebraic R L) (inj : Function.Injective â‡‘(algebraMap R L)) (a : S) {b : S} (hb : b â‰  0) : âˆƒ (c : S) (d : R) (H : d â‰  0), d â€¢ a = b * c
{Î± : Type u_2} [Bornology Î±] {s : Set Î±} : Bornology.IsBounded s â†’ Bornology.IsCobounded sá¶œ
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] {a : Î±} (h : (Set.Ioi a).nonempty) : Closure (Set.Ioi a) = Set.Ici a
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : StrictConvexOn ð•œ s f) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hxy : x â‰  y) {a b : ð•œ} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : f (a â€¢ x + b â€¢ y) < Linear_order.max (f x) (f y)
{Î± : Type v} {s : Finset Î±} {M : Type u_1} [CommMonoid M] (f : Î± â†’ M) (p : M â†’ Prop) (p_Mul : âˆ€ (a b : M), p a â†’ p b â†’ p (a * b)) (p_One : p 1) (p_s : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (s.prod (Î» (x : Î±), f x))
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linearOrderedField ð•œ] [AddCommGroup E] [OrderedAddCommGroup Î²] [Module ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f : E â†’ Î²} {t : Finset Î¹} {w : Î¹ â†’ ð•œ} {p : Î¹ â†’ E} (hF : ConcaveOn ð•œ s f) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hâ‚ : 0 < t.sum (Î» (i : Î¹), w i)) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : t.center_mass w (f âˆ˜ p) â‰¤ f (t.center_mass w p)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} : StrictAnti f â†’ StrictMono (â‡‘OrderDual.toDual âˆ˜ f)
{G : Type u_3} [AddGroup G] : Add_group.fg G â†” Add_monoid.fg G
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚‚} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J â¥¤ C} [CategoryTheory.Limits.HasLimit F] {E : K â¥¤ J} [CategoryTheory.Limits.HasLimit (E â‹™ F)] (s : CategoryTheory.Limits.LimitCone (E â‹™ F)) (t : CategoryTheory.Limits.LimitCone F) : CategoryTheory.Limits.limit.pre F E = (CategoryTheory.Limits.limit.isoLimitCone t).hom â‰« s.is_limit.lift (CategoryTheory.Limits.Cone.whisker E t.cone) â‰« (CategoryTheory.Limits.limit.isoLimitCone s).inv
{G : Type w} [topologicalSpace G] [Group G] [TopologicalGroup G] {M : Type u_1} {hom : Type u_2} [MulOneClass M] [topologicalSpace M] [HasContinuousMul M] [monoidHomClass hom G M] (f : hom) (hF : ContinuousAt â‡‘f 1) : Continuous â‡‘f
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) (m : M) : â‡‘(S.normed_Mk) m = â‡‘(QuotientAddGroup.mk' S) m
{Î± : Type u_1} {n : Type u_4} {m : Type u_5} [MulZeroClass Î±] {A : Matrix m m Î±} {B : Matrix n n Î±} (hA : A.is_diag) (hB : B.is_diag) : (Matrix.kroneckerMap Mul.mul A B).is_diag
{ð•‚ : Type u_1} [nondiscreteNormedField ð•‚] [CompleteSpace ð•‚] (h : 0 < (expSeries ð•‚ ð•‚).radius) : HasDerivAt (Exp ð•‚) 1 0
{Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [Fintype Î¹] [Preorder Î¹'] [IsDirected Î¹' (Function.swap LE.le)] [Nonempty Î¹'] {s : Î¹ â†’ Î¹' â†’ Set Î±} (hs : âˆ€ (i : Î¹), Antitone (s i)) : (â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) = â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
{G : Type u_1} [AddGroup G] {Î¹ : sort u_2} (S : Î¹ â†’ AddSubgroup G) {C : Î  (x : G), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : G) (H : x âˆˆ S i), C x _) (h1 : C 0 _) (HMul : âˆ€ (x y : G) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x + y) _) {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
{Î± : Type u} {Î² : Type v} {t : Set Î²} {f : Î± â†’ Î²} (h : âˆ€ (x : Î±), f x âˆˆ t) : Function.Injective f â†’ Function.Injective (Set.codRestrict f t h)
{V : Type u} {G : SimpleGraph V} [DecidableEq V] {u v w : V} (p : G.walk v w) (h : u âˆˆ p.support) : (p.take_until u h).append (p.drop_until u h) = p
{G : Type u_1} [Group G] {Î¹ : Type u_2} (s : Finset Î¹) (f : Î¹ â†’ G) (comm : âˆ€ (x : Î¹), x âˆˆ s â†’ âˆ€ (y : Î¹), y âˆˆ s â†’ Commute (f x) (f y)) (K : Î¹ â†’ Subgroup G) (hind : CompleteLattice.Independent K) (hmem : âˆ€ (x : Î¹), x âˆˆ s â†’ f x âˆˆ K x) (HEq1 : s.noncomm_Prod f comm = 1) (i : Î¹) (H : i âˆˆ s) : f i = 1
(u : Pnat.XgcdType) : u.r + (u.bp + 1) * u.q = u.ap + 1
{Î² Î± : Type u} (f : Î² â†’ Î±) (hâ‚ : Cardinal.aleph_0 â‰¤ Cardinal.mk Î²) (hâ‚‚ : Cardinal.mk Î± < (Cardinal.mk Î²).ord.cof) : âˆƒ (a : Î±), Cardinal.mk â†¥(f â»Â¹' {a}) = Cardinal.mk Î²
{Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [CommMonoid M] [orderedCommMonoid N] (f : M â†’ N) (p : M â†’ Prop) (h_Mul : âˆ€ (x y : M), p x â†’ p y â†’ f (x * y) â‰¤ f x * f y) (hp_Mul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) (g : Î¹ â†’ M) (s : Finset Î¹) (hs_Nonempty : s.nonempty) (hs : âˆ€ (i : Î¹), i âˆˆ s â†’ p (g i)) : f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (h : s.finite) : Metric.Bounded s
{R : Type u} [Semiring R] [NoZeroDivisors R] [Nontrivial R] (l : List (Polynomial R)) : l.prod.degree = (List.map Polynomial.degree l).sum
(f : Type uâ‚€ â†’ Type uâ‚) [EquivFunctor f] {Î± Î² Î³ : Type uâ‚€} (Ab : Î± â‰ƒ Î²) (bc : Î² â‰ƒ Î³) : (EquivFunctor.mapEquiv f Ab).trans (EquivFunctor.mapEquiv f bc) = EquivFunctor.mapEquiv f (ab.trans bc)
{R : Type u_1} (M : Type u_3) [Monoid R] [mulAction R M] : IsSmulRegular M 1
{C : Type u} [CategoryTheory.Category C] (s : Set (CategoryTheory.GrothendieckTopology C)) : IsGlb s (HasInf.inf s)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {m n : WithTop â„•} {f : E â†’ F} (hF : ContDiff ð•œ n f) (hmn : m + 1 â‰¤ n) : ContDiff ð•œ m (Î» (p : E Ã— E), â‡‘(fderiv ð•œ f p.fst) p.snd)
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [hasZero M] [CommMonoid N] [CommMonoid P] (h : N â†’* P) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ N) : â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
{Î± : Type u_1} {l : Filter Î±} {f : Î± â†’ â„} : ((Î» (x : Î±), 1) =O[l] Î» (x : Î±), Real.exp (f x)) â†” Filter.IsBoundedUnder GE l f
{L : FirstOrder.Language} (T : L.Theory) (Îº : Cardinal) (M : Type w') [L.Structure M] [M âŠ¨ T] [Infinite M] : âˆƒ (N : T.Model), Îº.lift â‰¤ Cardinal.mk â†¥N
{E : Type u_1} [semiNormedGroup E] {s : AddSubgroup E} (x : â†¥s) : âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
{E : Type u_1} [semiNormedGroup E] [normedSpace â„ E] (p : Subspace â„ E) (f : â†¥p â†’L[â„] â„) : âˆƒ (g : E â†’L[â„] â„), (âˆ€ (x : â†¥p), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {r : Setoid Î±} (f : Î± â†’ Î²) (H : âˆ€ (x y : Î±), r.rel x y â†’ f x = f y) (h : Function.Injective (Quotient.lift f H)) : setoid.ker f = r
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} (hs : is_IsClosed s) (ht : is_IsClosed t) : Emetric.hausdorffEdist s t = 0 â†” s = t
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [IsRefl Î± r] {x y : Î±} : x â‰  y â†’ r x y â†” r x y
(Î“â‚€ : Type u_1) [LinearOrderedCommGroupWithZero Î“â‚€] : Pure.pure â‰¤ LinearOrderedCommGroupWithZero.nhdsFun Î“â‚€
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} : Function.Injective2 fin.cons
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle (-x) y + o.oangle (-y) z + o.oangle (-z) x = â†‘Real.pi
{G : Type u_2} [Group G] {a b : G} : a = b â†’ a / b = 1
{Î± : Type u} [Preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b < c â†’ a < c
{Vâ‚ : Type u_1} {Vâ‚‚ : Type u_2} [NormedGroup Vâ‚] [NormedGroup Vâ‚‚] {f : NormedGroupHom Vâ‚ Vâ‚‚} : âˆ¥fâˆ¥ = 0 â†” f = 0
{Î± : Type u} [AddCommGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b c : Î±} : a - b < c â†’ a < b + c
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] {F : Type u_6} [Field F] [Algebra K S] [Algebra K F] [Nontrivial S] (pB : powerBasis K S) (hF : Polynomial.Splits (algebraMap K F) (minpoly K pb.gen)) : â‡‘(algebraMap K F) (â‡‘(Algebra.trace K S) pb.gen) = (Polynomial.map (algebraMap K F) (minpoly K pb.gen)).roots.sum
{M : Type u_1} [AddZeroClass M] (S : addSubmonoid M) : S = âŠ¥ âˆ¨ âˆƒ (x : M) (H : x âˆˆ S), x â‰  0
{t : â„‚} {s1 s2 x : â„} (ht1 : s1 â‰¤ t.re) (ht2 : t.re â‰¤ s2) (hx : 0 < x) : âˆ¥dGammaIntegrand t xâˆ¥ â‰¤ dGammaIntegrandReal s1 x + dGammaIntegrandReal s2 x
{M : Type u_1} [MulOneClass M] (s : Set M) {p : Î  (x : M), x âˆˆ Submonoid.closure s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (H1 : p 1 _) (HMul : âˆ€ (x : M) (hx : x âˆˆ Submonoid.closure s) (y : M) (hy : y âˆˆ Submonoid.closure s), p x hx â†’ p y hy â†’ p (x * y) _) {x : M} (hx : x âˆˆ Submonoid.closure s) : p x hx
(R : Type u) [Ring R] [StrongRankCondition R] {Î¹ : Type v} [Fintype Î¹] : FiniteDimensional.finrank R (Î¹ â†’â‚€ R) = Fintype.card Î¹
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} (hâ‚€ : f = g) {c : CategoryTheory.Limits.Fork f g} (h : CategoryTheory.Limits.IsLimit c) : CategoryTheory.IsIso c.Î¹
{R : Type u} [Semiring R] [NoZeroDivisors R] {pâ‚ pâ‚‚ qâ‚ qâ‚‚ : Polynomial R} (hpâ‚ : pâ‚ â‰  0) (hqâ‚ : qâ‚ â‰  0) (hpâ‚‚ : pâ‚‚ â‰  0) (hqâ‚‚ : qâ‚‚ â‰  0) (h_Eq : pâ‚ * qâ‚‚ = pâ‚‚ * qâ‚) : â†‘(pâ‚.nat_degree) - â†‘(qâ‚.nat_degree) = â†‘(pâ‚‚.nat_degree) - â†‘(qâ‚‚.nat_degree)
{Î¹ : Type v} (f : Î¹ â†’ Cardinal) (t : Cardinal) (w : âˆ€ (i : Î¹), (f i).lift â‰¤ t) : (Cardinal.sup f).lift â‰¤ t
{Î± : Type u} [topologicalSpace Î±] {x : Î±} {s : Set Î±} : ClusterPt x (Filter.principal s) â†” âˆ€ (U : Set Î±), U âˆˆ nhds x â†’ (U âˆ© s).nonempty
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {n : â„•} (hn : Fintype.card Î± < Fintype.card Î² * n) : âˆƒ (y : Î²), (Finset.filter (Î» (x : Î±), f x = y) Finset.univ).card < n
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), hasZero (Î² i)] : Function.Injective coeFn
{G : Type u_1} [Group G] [topologicalSpace G] [NonarchimedeanGroup G] {U : Set (G Ã— G)} (hU : U âˆˆ nhds 1) : âˆƒ (V : OpenSubgroup G), â†‘V Ã—Ë¢ â†‘V âŠ† U
{M : Type u_1} [AddZeroClass M] {Î¹ : sort u_2} (S : Î¹ â†’ addSubmonoid M) {C : Î  (x : M), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : M) (H : x âˆˆ S i), C x _) (h1 : C 0 _) (HMul : âˆ€ (x y : M) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x + y) _) {x : M} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] {Î¹ : Type u_3} {p : Î¹ â†’ Submodule R M} {m : M} : (m âˆˆ â¨† (i : Î¹), p i) â†” âˆƒ (s : Finset Î¹), m âˆˆ â¨† (i : Î¹) (H : i âˆˆ s), p i
{Mâ‚€ : Type u_6} [monoidWithZero Mâ‚€] {L : List Mâ‚€} (h : 0 âˆˆ L) : L.prod = 0
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R M) (f : AlternatingMap R M R Î¹) : f = â‡‘f â‡‘e â€¢ e.det
{P : Type u_1} [SemilatticeInf P] {x y : P} {F : Order.Pfilter P} (hx : x âˆˆ F) (hy : y âˆˆ F) : x âŠ“ y âˆˆ F
{M : Type u_1} [hasMul M] (c : Con M) {x y : M} : â‡‘c x y â†’ â‡‘c y x
{E : Type u_1} {F : Type u_2} [NormedGroup E] [normedSpace â„ E] [NormedGroup F] [normedSpace â„ F] {s : Set E} (s_conv : Convex â„ s) (hne : (Interior s).nonempty) {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€ (x : E), x âˆˆ Interior s â†’ HasFderivAt f (f' x) x) {x : E} (xs : x âˆˆ s) (hx : HasFderivWithinAt f' f'' (Interior s) x) (v w : E) : â‡‘(â‡‘f'' v) w = â‡‘(â‡‘f'' w) v
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : Set.BijOn g (Function.FixedPoints (f âˆ˜ g)) (Function.FixedPoints (g âˆ˜ f))
{R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [topologicalSpace M] [topologicalSpace Mâ‚‚] [Ring R] [AddCommGroup M] [TopologicalAddGroup M] [Module R M] [AddCommGroup Mâ‚‚] [Module R Mâ‚‚] (e : M â‰ƒL[R] Mâ‚‚) (f : M â†’L[R] Mâ‚‚) : f.inverse = (Ring.inverse (â†‘(e.symm).comp f)).comp â†‘(e.symm)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸ : Real.Angle) : (o.rotation Î¸).symm = o.rotation (-Î¸)
{e : â„‚ â†’ â„‚} {e' : â„‚} {z : â„} (h : HasStrictDerivAt e e' â†‘z) : HasStrictDerivAt (Î» (x : â„), (e â†‘x).re) e'.re z
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] : ContDiff ð•œ âŠ¤ â‡‘(equiv.prod_assoc E F G)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (f : E â†’L[ð•œ] F) [CompleteSpace F] [CompleteSpace E] (surj : Function.Surjective â‡‘f) : âˆƒ (C : â„) (H : C > 0), âˆ€ (y : F), âˆƒ (x : E), â‡‘f x = y âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
{R : Type u_4} {S : Type u_5} [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S] (f : R â‰ƒ+* S) : â‡‘f 0 = 0
{n : â„•} : finSuccEquiv' 0 = finSuccEquiv n
{R : Type u} [CommSemiring R] [starRing R] (x : R) : â‡‘(starRingEnd R) (â‡‘(starRingEnd R) x) = x
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M â†’* P} {T : Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [CommMonoid Q] {k : T.localization_Map Q} (z : N) : â‡‘(k.to_Map) (â‡‘g â†‘((f.sec z).snd)) * â‡‘(f.map hy k) z = â‡‘(k.to_Map) (â‡‘g (f.sec z).fst)
{C : Type u} [CategoryTheory.Category C] {X : C} {S R : CategoryTheory.Sieve X} (J : CategoryTheory.GrothendieckTopology C) (Hss : S â‰¤ R) (sjx : S âˆˆ â‡‘J X) : R âˆˆ â‡‘J X
{K : Type u} [Field K] (s : Subfield K) {l : List K} : (âˆ€ (x : K), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {n : â„•} {s1 s2 : Affine.Simplex k P n} (h : âˆ€ (i : Fin (n + 1)), s1.points i = s2.points i) : s1 = s2
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : intermediateField K L) [FiniteDimensional K â†¥E] : is_IsClosed â†‘(E.fixing_Subgroup)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p b : P) : â‡‘(s.weighted_vsub_of_point (Î» (_x : Î¹), p) b) w = s.sum (Î» (i : Î¹), w i) â€¢ (p -áµ¥ b)
(k n : â„•) : (List.Nat.antidiagonalTuple k n).nodup
{Î± : Type u_1} [LinearOrder Î±] {s : Finset Î±} {k : â„•} (h : s.card = k) (hz : 0 < k) : â‡‘(s.order_emb_of_Fin h) âŸ¨0, hzâŸ© = s.min' _
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} (Fin : Emetric.hausdorffEdist s t â‰  âŠ¤) : Metric.hausdorffDist s t = 0 â†” Closure s = Closure t
{Î± : Type u} : Function.Injective FreeGroup.of
{Mâ‚€ : Type u_1} [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€] {a b : Mâ‚€} : a * b = 0 â†” b * a = 0
{Î± : Type u_1} [LinearOrder Î±] {A B : Finset Î±} (h : A âŠ† B) : A.to_colex â‰¤ B.to_colex
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [linearOrderedRing Î±] [floorRing Î±] [topologicalSpace Î±] [OrderTopology Î±] [TopologicalAddGroup Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î² â†’ Î± â†’ Î³} (h : ContinuousOn (Function.uncurry f) (Set.Univ Ã—Ë¢ Set.Icc 0 1)) (hF : âˆ€ (s : Î²), f s 0 = f s 1) : Continuous (Î» (st : Î² Ã— Î±), f st.fst (Int.fract st.snd))
{R : Type u_1} {S : Type u_2} [euclideanDomain R] [CommRing S] [is_IsDomain S] [Algebra R S] {abv : AbsoluteValue R â„¤} {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] (bS : Basis Î¹ R S) (adm : abv.is_Admissible) [Infinite R] [DecidableEq R] (a : S) {b : R} (hb : b â‰  0) : âˆƒ (q : S) (r : R) (H : r âˆˆ ClassGroup.finsetApprox bS adm), â‡‘abv (â‡‘(Algebra.norm R) (r â€¢ a - b â€¢ q)) < â‡‘abv (â‡‘(Algebra.norm R) (â‡‘(algebraMap R S) b))
{Î± : Type u_1} [Monoid Î±] {a b u : Î±} (hu : IsUnit u) : a * u âˆ£ b â†” a âˆ£ b
{p : â„•} (hp : 1 < p) : padicNorm p â†‘p < 1
{R : Type u} {A' : Type u_1} {B' : Type u_2} [CommSemiring A'] [Semiring B'] [CommSemiring R] [Algebra R A'] [Algebra R B'] {f g : Polynomial A' â†’â‚[R] B'} (hâ‚ : f.comp (IsScalarTower.toAlgHom R A' (Polynomial A')) = g.comp (IsScalarTower.toAlgHom R A' (Polynomial A'))) (hâ‚‚ : â‡‘f Polynomial.x = â‡‘g Polynomial.x) : f = g
{Î± : Type u} [SemilatticeSup Î±] {Î² : Type u_1} [Preorder Î²] {f g : Î± â†’ Î²} (hF : Monotone f) (hg : Antitone g) (h : f â‰¤ g) (m n : Î±) : f m â‰¤ g n
{R : Type u_1} [CommRing R] {p : â„•} (hp : Nat.Prime p) : Polynomial.cyclotomic p R = (Finset.range p).sum (Î» (i : â„•), Polynomial.x ^ i)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [cs : CompleteSpace E] {f : E â†’ F} {f' : E â‰ƒL[ð•œ] F} {a : E} (hF : HasStrictFderivAt f â†‘f' a) {g : F â†’ E} (hg : âˆ€á¶  (x : E) in nhds a, g (f x) = x) : HasStrictFderivAt g â†‘(f'.symm) (f a)
{C : Type u} [CategoryTheory.Category C] {P Q : C} (f : P âŸ¶ Q) [CategoryTheory.Mono f] [CategoryTheory.StrongEpi f] : CategoryTheory.IsIso f
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {M : Type u_6} [CommSemiring R] [AddCommMonoid M] [Module R M] (b : Basis Î¹ R M) (b' : Basis Î¹' R M) {Î¹'' : Type u_3} [Fintype Î¹'] (b'' : Î¹'' â†’ M) : (b.to_Matrix â‡‘b').mul (b'.to_Matrix b'') = b.to_Matrix b''
{G : Type u_1} [AddGroup G] {k : Set G} {p : Î  (x : G), x âˆˆ AddSubgroup.closure k â†’ Prop} (Hs : âˆ€ (x : G) (h : x âˆˆ k), p x _) (H1 : p 0 _) (HMul : âˆ€ (x : G) (hx : x âˆˆ AddSubgroup.closure k) (y : G) (hy : y âˆˆ AddSubgroup.closure k), p x hx â†’ p y hy â†’ p (x + y) _) (Hinv : âˆ€ (x : G) (hx : x âˆˆ AddSubgroup.closure k), p x hx â†’ p (-x) _) {x : G} (hx : x âˆˆ AddSubgroup.closure k) : p x hx
{Î¹ : Type u_1} {V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape Î¹} (C : HomologicalComplex V c) {i i' j : Î¹} (rij : c.rel i j) (rij' : c.rel i' j) : CategoryTheory.eqToHom _ â‰« C.d i' j = C.d i j
{K : Type u_1} [linearOrderedField K] [floorRing K] (v : K) (n : â„•) : âˆƒ (q : â„š), (GeneralizedContinuedFraction.of v).convergents n = â†‘q
{Î¹ : Type u} (s : Finset Î¹) (f g : Î¹ â†’ Ennreal) {p q : â„} (hpq : p.is_conjugate_exponent q) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hD : DiffContOnCl â„‚ f {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[Filter.comap Complex.abs Filter.atTop âŠ“ Filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), Real.exp (B * Complex.abs z ^ c)) (hre : Filter.Tendsto (Î» (x : â„), f â†‘x) Filter.atTop (nhds 0)) (him : âˆ€ (x : â„), âˆ¥f (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz : 0 â‰¤ z.re) : âˆ¥f zâˆ¥ â‰¤ C
{R : Type u_1} {M : Type u_3} {a : R} [Monoid R] [mulAction R M] (n : â„•) (ra : IsSmulRegular M a) : IsSmulRegular M (a ^ n)
{R : Type uâ‚} {L : Type uâ‚‚} [CommRing R] [LieRing L] [lieAlgebra R L] [IsNoetherian R L] : LieAlgebra.IsNilpotent R L â†” âˆ€ (x : L), IsNilpotent (â‡‘(LieAlgebra.ad R L) x)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) : hb.oangle (-x) x = â†‘Real.pi
(ð•œ : Type u_1) (E : Type u_2) [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] {n : â„•} (h : n = 1) (v : Fin n â†’ E) : â‡‘(FormalMultilinearSeries.id ð•œ E n) v = v âŸ¨0, _âŸ©
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} (h : â†‘s.nonempty) (v : V) : v âˆˆ s.direction â†” âˆƒ (p1 : P) (H : p1 âˆˆ s) (p2 : P) (H : p2 âˆˆ s), v = p1 -áµ¥ p2
{R : Type u_4} [normedRing R] [CompleteSpace R] (x : R) (h : âˆ¥xâˆ¥ < 1) : Summable (Î» (n : â„•), x ^ n)
{Î± : Type u_1} {Î² : Type u_2} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {K : Nnreal} {f : Î± â†’ Î²} : (âˆ€ (x y : Î±), HasNndist.nndist x y â‰¤ K * HasNndist.nndist (f x) (f y)) â†’ AntilipschitzWith K f
(R : Type u) [Semiring R] [Nontrivial R] (p q : â„•) [Char_p R p] [ExpChar R q] : q = 1 â†” p = 0
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {s : Set P} (hs : s.nonempty) : affineSpan k s = âŠ¤ â†” vectorSpan k s = âŠ¤
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : Set Î±} (hc : IsChain r c) : âˆƒ (M : Set Î±), IsMaxChain r M âˆ§ c âŠ† M
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [CommSemiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] (f : MultilinearMap R Mâ‚ Mâ‚‚) (c : Î¹ â†’ R) (m : Î  (i : Î¹), Mâ‚ i) (s : Finset Î¹) : â‡‘f (s.piecewise (Î» (i : Î¹), c i â€¢ m i) m) = s.prod (Î» (i : Î¹), c i) â€¢ â‡‘f m
{E : Type u_1} [AddCommGroup E] [Module â„ E] {s : Set E} (x : E) : 0 â‰¤ gauge s x
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : CategoryTheory.Presieve X} {x : CategoryTheory.Presieve.FamilyOfElements P R} (hx : x.compatible) : x.sieve_extend.compatible
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (h : is_IsClosed s) : Interior (Frontier s) = âˆ…
{R : Type u_1} [CommRing R] (s : Subring R) (m : Multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
{L : FirstOrder.Language} {M : Type u_3} [L.Structure M] : FirstOrder.Language.Structure.Cg L M â†” âˆƒ (S : Set M), S.countable âˆ§ â‡‘(FirstOrder.Language.Substructure.closure L) S = âŠ¤
{s : â„‚} (hs : 1 < s.re) : MeasureTheory.IntegrableOn (Î» (x : â„), â†‘(Real.exp (-x)) * â†‘(Real.log x) * â†‘x ^ (s - 1)) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume âˆ§ HasDerivAt Complex.gammaIntegral (âˆ« (x : â„) in Set.Ioi 0, â†‘(Real.exp (-x)) * â†‘(Real.log x) * â†‘x ^ (s - 1)) s
{C : Type u} [CategoryTheory.Category C] {X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) [CategoryTheory.Limits.HasPushout f g] : CategoryTheory.Limits.HasPushout g f
{Î± : Type u} {Î² : Type v} [emetricSpace Î±] [pseudoEmetricSpace Î²] {f : Î± â†’ Î²} (hF : Isometry f) : Embedding f
{M : Type u_3} {N : Type u_4} [Monoid M] [Monoid N] (f : M â†’* Náµáµ’áµ–) (l : List M) : MulOpposite.unop (â‡‘f l.prod) = (List.map (MulOpposite.unop âˆ˜ â‡‘f) l).reverse.prod
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] [innerProductSpace ð•œ F] [CompleteSpace E] [CompleteSpace F] (A : E â†’L[ð•œ] F) (x : E) (y : F) : HasInner.inner x (â‡‘(â‡‘ContinuousLinearMap.adjoint A) y) = HasInner.inner (â‡‘A x) y
{R : Type u_2} {Î“â‚€ : Type u_3} [CommRing R] [linearOrderedCommMonoidWithZero Î“â‚€] (v : Valuation R Î“â‚€) {J : Ideal R} (hJ : J â‰¤ v.supp) : (v.on_quot hJ).supp = Ideal.map (Ideal.Quotient.mk J) v.supp
{Î± : Type u_1} [LinearOrder Î±] {k l : â„•} {s : Finset Î±} {i : Fin k} {j : Fin l} {h : s.card = k} {h' : s.card = l} : â‡‘(s.order_emb_of_Fin h) i = â‡‘(s.order_emb_of_Fin h') j â†” â†‘i = â†‘j
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {x : E} {n : WithTop â„•} {s : Set E} {f : E â†’ F} {g : E â†’ G} (hF : ContDiffWithinAt ð•œ n f s x) (hg : ContDiffWithinAt ð•œ n g s x) : ContDiffWithinAt ð•œ n (Î» (x : E), (f x, g x)) s x
 : (Submodule.span â„‚ (Set.Range fourier)).topological_Closure = âŠ¤
{Î± : Type u} {Î² : Type v} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l Filter.atBot) : Filter.Tendsto (Î» (x : Î²), f x * g x) l Filter.atBot
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasFiniteProducts C] : CategoryTheory.Limits.HasFiniteBiproducts C
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), IsAddUnit (â‡‘g â†‘y)) (z : N) (w v : P) : â‡‘(f.lift hg) z + w = v â†” â‡‘g (f.sec z).fst + w = â‡‘g â†‘((f.sec z).snd) + v
{R : Type u_1} {M : Type u_3} {a b : R} [HasScalar R M] [hasMul R] [isScalarTower R R M] : IsSmulRegular M (a * b) âˆ§ IsSmulRegular M (b * a) â†” IsSmulRegular M a âˆ§ IsSmulRegular M b
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) (hF'' : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv^[2] f x < 0) : StrictConcaveOn â„ D f
{Î± : Type u_1} {m : Type u_3} {n : Type u_4} [nonUnitalSemiring Î±] [starRing Î±] {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} (hA : A.is_hermitian) (hBC : B.conj_transpose = C) (hD : D.is_hermitian) : (Matrix.fromBlocks A B C D).is_hermitian
(K : Type u) {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] {Vâ‚‚ : Type v'} [AddCommGroup Vâ‚‚] [Module K Vâ‚‚] (f : V â†’â‚—[K] Vâ‚‚) (p : Submodule K V) [FiniteDimensional K â†¥p] : FiniteDimensional.finrank K â†¥(Submodule.map f p) â‰¤ FiniteDimensional.finrank K â†¥p
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] {p1 p2 p : P} : p -áµ¥ p1 = p -áµ¥ p2 â†” p1 = p2
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) (x y : M â§¸ S) : âˆ¥x + yâˆ¥ â‰¤ âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D â¥¤ C} [CategoryTheory.IsRightAdjoint i] (A : C) [CategoryTheory.IsIso ((CategoryTheory.Adjunction.ofRightAdjoint i).unit.app A)] : A âˆˆ i.ess_image
{Î± : Type u} [SemilatticeInf Î±] [OrderTop Î±] (x y : Î±) : (x â¨¯ y) = x âŠ“ y
{Î± : Type u_1} (L : List (List Î±)) (c : Composition L.join.length) (h : List.map List.length L = c.blocks) : L.join.split_wrt_Composition c = L
{Î± : Type u_1} {n : Type u_4} {R : Type u_5} [HasSub n] [HasScalar R Î±] (k : R) (v : n â†’ Î±) : Matrix.circulant (k â€¢ v) = k â€¢ Matrix.circulant v
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} (v : V) {p : P} (hp : p âˆˆ s) : v +áµ¥ p âˆˆ s â†” v âˆˆ s.direction
(R : Type u_1) {S : Type u_2} {M : Type u_3} [Semiring R] [Semiring S] [AddCommMonoid M] [HasScalar R S] [Module S M] [Module R M] [isScalarTower R S M] (h : IsNoetherian R M) : IsNoetherian S M
{J : Type uâ‚} [CategoryTheory.Category J] [Nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), âˆƒ (l : List J), List.Chain CategoryTheory.Zag jâ‚ l âˆ§ (jâ‚ :: l).last _ = jâ‚‚) : CategoryTheory.IsConnected J
{ð•œ : Type u_1} {X : Type u_2} [is_R_or_C ð•œ] [topologicalSpace X] [CompactSpace X] (A : Subalgebra ð•œ C(X, ð•œ)) (hA : A.separates_points) (hA' : ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ A)) : A.topological_Closure = âŠ¤
{Î± : Type u_1} [uniformSpace Î±] {s : Set Î±} : is_IsOpen s â†” âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (V : Set (Î± Ã— Î±)) (H : V âˆˆ Uniformity Î±), UniformSpace.Ball x V âŠ† s)
{ð•œ : Type u_3} [Field ð•œ] (n : Type) [Fintype n] [DecidableEq n] (M : Matrix n n ð•œ) : âˆƒ (L L' : List (Matrix.TransvectionStruct n ð•œ)) (D : n â†’ ð•œ), ((List.map Matrix.TransvectionStruct.toMatrix L).prod.mul M).mul (List.map Matrix.TransvectionStruct.toMatrix L').prod = Matrix.diagonal D
{k : Type u_1} {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [CharZero k] {n : â„•} (s : Affine.Simplex k P n) {fsâ‚ fsâ‚‚ : Finset (Fin (n + 1))} {mâ‚ mâ‚‚ : â„•} (hâ‚ : fsâ‚.card = mâ‚ + 1) (hâ‚‚ : fsâ‚‚.card = mâ‚‚ + 1) : Finset.centroid k Finset.univ (s.face hâ‚).points = Finset.centroid k Finset.univ (s.face hâ‚‚).points â†” fsâ‚ = fsâ‚‚
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M â†’* P} (H : c â‰¤ Con.ker f) : (c.lift f H).mrange = f.mrange
{Î± : Type u} [pseudoMetricSpace Î±] (s : Set Î±) : UniformContinuous (Î» (x : Î±), Metric.infDist x s)
{R : Type u_1} (S : Type u_2) [CommRing R] [CommRing S] (y : R) [Algebra R S] [IsLocalization.Away y S] [H : Ideal.IsJacobson R] (J : Ideal S) : J.is_Maximal â†” (Ideal.comap (algebraMap R S) J).is_Maximal âˆ§ y âˆ‰ Ideal.comap (algebraMap R S) J
{Xâ‚ Xâ‚‚ Y : Top} {f : C(â†¥Xâ‚, â†¥Y)} {g : C(â†¥Xâ‚‚, â†¥Y)} {xâ‚€ xâ‚ : â†¥Xâ‚} {xâ‚‚ xâ‚ƒ : â†¥Xâ‚‚} {p : Path xâ‚€ xâ‚} {q : Path xâ‚‚ xâ‚ƒ} (hfg : âˆ€ (t : â†¥UnitInterval), â‡‘f (â‡‘p t) = â‡‘g (â‡‘q t)) : (fundamental_groupoid.fundamental_groupoid_functor.map f).map âŸ¦pâŸ§ == (fundamental_groupoid.fundamental_groupoid_functor.map g).map âŸ¦qâŸ§
{Î± : Type u_1} {c : Set (Set Î±)} (H : âˆ€ (a : Î±), âˆƒ! (b : Set Î±) (H : b âˆˆ c), a âˆˆ b) {s : Set Î±} {y : Î±} (hs : s âˆˆ c) (hy : y âˆˆ s) : s = {x : Î± | (setoid.mk_Classes c H).rel x y}
{F : Type u_1} [NormedGroup F] [normedSpace â„ F] (f : â„ â†’ F) {K : Set F} (hK : IsComplete K) : MeasurableSet {x : â„ | DifferentiableWithinAt â„ f (Set.Ici x) x âˆ§ derivWithin f (Set.Ici x) x âˆˆ K}
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {X Y : C} (g : X âŸ¶ Y) (fâ‚ fâ‚‚ : CategoryTheory.Subobject Y) : (CategoryTheory.Subobject.pullback g).obj (fâ‚ âŠ“ fâ‚‚) = (CategoryTheory.Subobject.pullback g).obj fâ‚ âŠ“ (CategoryTheory.Subobject.pullback g).obj fâ‚‚
{Î² : Type u} {Î³ : Type w} [Semiring Î²] [Semiring Î³] (f : Î² â†’+* Î³áµáµ’áµ–) (l : List Î²) : MulOpposite.unop (â‡‘f l.prod) = (List.map (MulOpposite.unop âˆ˜ â‡‘f) l).reverse.prod
{o : Ordinal} : Ordinal.Principal Mul.mul o â†” o â‰¤ 2 âˆ¨ âˆƒ (a : Ordinal), o = Ordinal.omega ^ Ordinal.omega ^ a
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (v : V) : G.degree v â‰¤ G.max_degree
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (h : b.orientation = o) (Î¸ : â„) : o.rotation â†‘Î¸ = hb.rotation â†‘Î¸
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) (m : Multiset L) : (âˆ€ (a : L), a âˆˆ m â†’ a âˆˆ S) â†’ m.prod âˆˆ S
{R : Type u} [CommRing R] [is_IsDomain R] [UniqueFactorizationMonoid R] (hâ‚ : âˆƒ (p : R), Irreducible p) (hâ‚‚ : âˆ€ â¦ƒp q : Râ¦„, Irreducible p â†’ Irreducible q â†’ Associated p q) : DiscreteValuationRing R
{Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {g : Î± â†’ Î²} (h : Function.Semiconj g fa fb) : Set.MapsTo g (Function.FixedPoints fa) (Function.FixedPoints fb)
(R : Type u) [CommRing R] [is_IsDomain R] [DiscreteValuationRing R] : âˆƒ (Ï– : R), Irreducible Ï–
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
{Î± : Type u_1} [topologicalSpace Î±] [t0_Space Î±] [CompactSpace Î±] {S : Set Î±} (hS : is_IsClosed S) (hne : S.nonempty) : âˆƒ (x : Î±), x âˆˆ S âˆ§ is_IsClosed {x}
(N : â„•) {j : â„} (hj : 0 < j) {c : â„} (hc : 1 < c) : (Finset.filter (Î» (i : â„•), j < â†‘âŒŠc ^ iâŒ‹â‚Š) (Finset.range N)).sum (Î» (i : â„•), 1 / â†‘âŒŠc ^ iâŒ‹â‚Š ^ 2) â‰¤ c ^ 5 * (c - 1)â»Â¹ ^ 3 / j ^ 2
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {Î¹ : Type u_1} (v : Î¹ â†’ M) (i : LinearIndependent R v) (w : Set M) [Fintype â†¥w] (s : Submodule.span R w = âŠ¤) : Cardinal.mk Î¹ â‰¤ â†‘(Fintype.card â†¥w)
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a b : Î±} : aâ»Â¹ â‰¤ b â†’ bâ»Â¹ â‰¤ a
{Î¹ : Type u} (s : Finset Î¹) {f g : Î¹ â†’ â„} {p q : â„} (hpq : p.is_conjugate_exponent q) (hF : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ g i) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (p : P) : vectorSpan k {p} = âŠ¥
{Î± : Type u} {a b : Î±} [MulZeroOneClass Î±] [PartialOrder Î±] [ZeroLt.PosMulMono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (a0 : 0 â‰¤ a) : a * b â‰¤ 1
{Î± : Type u_1} {Î² : Type u_2} [AddCommMonoid Î±] [topologicalSpace Î±] {f : Î² â†’ Î±} {s : Finset Î²} (hF : âˆ€ (b : Î²), b âˆ‰ s â†’ f b = 0) : HasSum f (s.sum (Î» (b : Î²), f b))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {x : E} {n : WithTop â„•} {p : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n f p s) (hn : 1 â‰¤ n) (hx : s âˆˆ nhds x) : DifferentiableAt ð•œ f x
{Î± : Type u_1} {n : Type u_4} [Semiring Î±] [Fintype n] [AddGroup n] (v w : n â†’ Î±) : (Matrix.circulant v).mul (Matrix.circulant w) = Matrix.circulant ((Matrix.circulant v).mul_vec w)
{M : Type u_1} [AddCommMonoid M] {S : addSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), IsAddUnit (â‡‘g â†‘y)) (z : N) (v : P) : â‡‘(f.lift hg) z = v â†” â‡‘g (f.sec z).fst = â‡‘g â†‘((f.sec z).snd) + v
{M : Type u_1} [semiNormedGroup M] {S : AddSubgroup M} (x : M â§¸ S) : âˆ¥-xâˆ¥ = âˆ¥xâˆ¥
{Î± : Type u_1} {Î² : Type u_2} [AddZeroClass Î±] [AddZeroClass Î²] (f g : Î±áµáµ’áµ– â†’+ Î²) (h : f.comp MulOpposite.op_AddEquiv.toAddMonoidHom = g.comp MulOpposite.op_AddEquiv.toAddMonoidHom) : f = g
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [pseudoMetricSpace Î²] : Continuous (Î» (p : boundedContinuousFunction Î± Î² Ã— Î±), â‡‘(p.fst) p.snd)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {u v : E} (hv : v âˆˆ K) (hvo : u - v âˆˆ Ká—®) : â†‘(â‡‘(orthogonalProjection K) u) = v
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Î¹ â†’ M} [Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [Module R M] [Module R M'] (hv : LinearIndependent R v) (f : M â†’â‚—[R] M') (hF_inj : f.ker = âŠ¥) : LinearIndependent R (â‡‘f âˆ˜ v)
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (x y : E) : is_R_or_C.abs (HasInner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{Î¹ : Type u_1} {S : Type u_3} {R : Type u_4} [DecidableEq Î¹] [AddMonoid Î¹] [CommSemiring S] [Semiring R] [Algebra S R] (A : Î¹ â†’ Submodule S R) [SetLike.GradedMonoid A] : (â¨† (i : Î¹), A i) = (DirectSum.coeAlgHom A).range.to_Submodule
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x y : E} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ ^ 2
{R : Type u} [Semiring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {M : Type u_1} [AddCommMonoid M] [Module R M] {A : Î¹ â†’ Submodule R M} {i j : Î¹} (hij : i â‰  j) (h : Set.Univ = {i, j}) (hi : DirectSum.IsInternal A) : is_HasCompl (A i) (A j)
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} [CategoryTheory.Limits.HasCoequalizer f g] (h : f = g) : CategoryTheory.IsIso (CategoryTheory.Limits.coequalizerÏ€ f g)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : ContinuousAt f a) (hb : ContinuousAt f b) : fderiv â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (a, b) = (ContinuousLinearMap.snd â„ â„ â„).smul_Right (f b) - (ContinuousLinearMap.fst â„ â„ â„).smul_Right (f a)
(a : â„) {b : â„} (h : 0 < b) : MeasureTheory.IntegrableOn (Î» (x : â„), Real.exp (-b * x)) (Set.Ioi a) MeasureTheory.MeasureSpace.volume
{K : Type u_1} [Field K] (n : â„•) : Polynomial.Splits (RingHom.id K) (Polynomial.cyclotomic' n K)
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} {R : CategoryTheory.Presieve X} (f : Y âŸ¶ X) [CategoryTheory.SplitEpi f] (hF : R f) : CategoryTheory.Sieve.generate R = âŠ¤
{Î± : Type u_1} {Î¹' : sort u_5} (s : Î¹' â†’ Set Î±) : (â‹‚ (i : Î¹'), s i) = â‹‚ (t : Finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
{Î± : Type u_1} {n : â„•} (v : Vector Î± n) : Vector.map Id v = v
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (hfp : Algebra.FinitePresentation R A) (Î¹ : Type u_3) [Fintype Î¹] : Algebra.FinitePresentation R (MvPolynomial Î¹ A)
{Î± : Type u} (s : Set Î±) [h : Fintype â†¥s] : s.finite
(p : â„•) [p_Prime : Fact (Nat.Prime p)] {q : â„š} {n d : â„¤} (hqz : q â‰  0) (qdf : q = Rat.mk n d) : padicValRat p q = â†‘((multiplicity â†‘p n).get _) - â†‘((multiplicity â†‘p d).get _)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} (F : Top.Presheaf C X) (U : TopologicalSpace.Opens â†¥X) (R : CategoryTheory.Presieve U) (f : Î£ (V : TopologicalSpace.Opens â†¥X), {f // R f}) : (Top.Presheaf.coveringOfPresieve.firstObjIsoPiOpens F U R).hom â‰« Category_theory.limits.pi.Ï€ (Î» (i : Î£ (V : TopologicalSpace.Opens â†¥X), {f // R f}), F.obj (Opposite.op (Top.Presheaf.coveringOfPresieve U R i))) f = Category_theory.limits.pi.Ï€ (Î» (f : Î£ (V : TopologicalSpace.Opens â†¥X), {f // R f}), F.obj (Opposite.op f.fst)) f
{G : Type u_1} [Group G] [hG : group.is_nilpotent G] : Nat.find _ = group.nilpotency_class G
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} {s : Set E} (h : is_IsLocalMinOn f s a) (hF : HasFderivWithinAt f f' s a) {y : E} (hy : y âˆˆ PosTangentConeAt s a) (hy' : -y âˆˆ PosTangentConeAt s a) : â‡‘f' y = 0
{F : Type u_3} [innerProductSpace â„ F] {x y : F} : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * HasInner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {y : L} : y âˆˆ S â†’ âˆ€ {x : K}, x â€¢ y âˆˆ S
(J : Type u_1) (C : Type u_2) [CategoryTheory.Category J] [CategoryTheory.Category C] : CategoryTheory.Idempotents.toKaroubi (J â¥¤ C) â‹™ CategoryTheory.Idempotents.karoubiFunctorCategoryEmbedding J C = (CategoryTheory.whiskeringRight J C (CategoryTheory.Idempotents.Karoubi C)).obj (CategoryTheory.Idempotents.toKaroubi C)
{Î± : Type u_1} [CommSemiring Î±] (t : Tree Î±) (r : tactic.ring2.csring_expr) : (tactic.ring2.horner_expr.of_csexpr r).is_cs âˆ§ tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r) = tactic.ring2.csring_expr.eval t r
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (wâ‚ wâ‚‚ : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘(s.weighted_vsub p) wâ‚ +áµ¥ â‡‘(s.affine_combination p) wâ‚‚ = â‡‘(s.affine_combination p) (wâ‚ + wâ‚‚)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 âˆˆ s) : (affineSpan k (HasInsert.insert p2 â†‘s)).direction = Submodule.span k {p2 -áµ¥ p1} âŠ” s.direction
{Î± : Type u} {Î² : Type v} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l Filter.atBot) : Filter.Tendsto (Î» (x : Î²), f x * g x) l Filter.atTop
{s : Set â„‚} : s.countable â†’ (Complex.exp â»Â¹' s).countable
{Î± : Type u_1} {n : Type u_4} [hasZero Î±] [DecidableEq n] (A : Matrix n n Î±) : A.is_diag â†” Matrix.diagonal A.diag = A
{Î± : Type u_1} {E : Î± â†’ Type u_2} {p : Ennreal} [Î  (i : Î±), NormedGroup (E i)] {Î¹ : Type u_3} {l : Filter Î¹} [l.ne_IsBot] [Fact (1 â‰¤ p)] {C : â„} {F : Î¹ â†’ â†¥(Lp E p)} (hCF : âˆ€á¶  (k : Î¹) in l, âˆ¥F kâˆ¥ â‰¤ C) {f : â†¥(Lp E p)} (hF : Filter.Tendsto (Id (Î» (i : Î¹), â‡‘(F i))) l (nhds â‡‘f)) : âˆ¥fâˆ¥ â‰¤ C
{M : Type u_3} {N : Type u_4} [AddZeroClass M] [AddZeroClass N] (f : M â†’+ N) : â‡‘f 0 = 0
{E : Type u_1} [innerProductSpace â„ E] {n : â„•} [Fact (FiniteDimensional.finrank â„ E = n + 1)] : ContMdiff (modelWithCornersSelf â„ (EuclideanSpace â„ (Fin n))) (modelWithCornersSelf â„ (EuclideanSpace â„ (Fin n))) âŠ¤ (Î» (x : â†¥(Metric.Sphere 0 1)), -x)
{M : Type u_1} [Monoid M] {s : Set M} (hs : IsSubmonoid s) {l : List M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
{G : Type u_7} [AddGroup G] (L : List G) : L.reverse.sum = -(List.map (Î» (x : G), -x) L).sum
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} {f : ð•œ â†’ F} : iteratedDeriv (n + 1) f = deriv (iteratedDeriv n f)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [AddCommMonoid Î±] [topologicalSpace Î±] [t2_Space Î±] [Encodable Î³] [completeLattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (s : Î³ â†’ Î²) : âˆ‘' (i : â„•), m (â¨† (b : Î³) (H : b âˆˆ Encodable.decodeâ‚‚ Î³ i), s b) = âˆ‘' (b : Î³), m (s b)
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {f : Î± â†’ Î²} (hF : IsGroupHom f) : f 1 = 1
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {p : E â†’ FormalMultilinearSeries ð•œ E F} {n : â„•} : HasFtaylorSeriesUpToOn â†‘(n + 1) f p s â†” (âˆ€ (x : E), x âˆˆ s â†’ (p x 0).uncurry0 = f x) âˆ§ (âˆ€ (x : E), x âˆˆ s â†’ HasFderivWithinAt (Î» (y : E), p y 0) (p x 1).curry_Left s x) âˆ§ HasFtaylorSeriesUpToOn â†‘n (Î» (x : E), â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (p x 1)) (Î» (x : E), (p x).shift) s
{Î± : Type u} [Subsingleton Î±] (l : Filter Î±) [l.ne_IsBot] : l = âŠ¤
(t : â„) : Filter.Tendsto (Î» (x : â„), x * Real.log (1 + t / x)) Filter.atTop (nhds t)
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î± â†’ Î² Ã— Î³} (hF : Continuous f) : Continuous (Î» (a : Î±), (f a).snd)
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] {a : Î±} : -a â‰¤ 0 â†’ 0 â‰¤ a
{G : Type u_1} [Group G] {x y : G} : y âˆˆ Subgroup.closure {x} â†” âˆƒ (n : â„¤), x ^ n = y
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : EqvGen.setoid r = HasInf.inf {s : Setoid Î± | âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ s.rel x y}
{G : Type u_1} [AddGroup G] (K : AddSubgroup G) {l : List G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.sum âˆˆ K
{Î± : Type u_1} [CancelCommMonoidWithZero Î±] [WfDvdMonoid Î±] [gcdMonoid Î±] : UniqueFactorizationMonoid Î±
(C : Type u) [CategoryTheory.Category C] : CategoryTheory.EssentiallySmall C â†” Small (CategoryTheory.Skeleton C) âˆ§ CategoryTheory.LocallySmall C
{a b c : â„¤} (h1 : a % b = c) (h2 : (a - c).nat_Abs < b.nat_Abs) : a = c
{R : Type u_1} [Semiring R] [Nontrivial R] : power_series.X.order = 1
{M : Type u_2} [AddCommGroup M] {A : Type u_1} [CommRing A] [Module A M] (f : M â‰ƒâ‚—[A] M) : â‡‘LinearMap.det â†‘(f.symm) * â‡‘LinearMap.det â†‘f = 1
{n : â„•} {i : Fin (n + 1)} : SimplexCategoryÎ´ (â‡‘fin.cast_Succ i) â‰« SimplexCategoryÏƒ i = ðŸ™ (SimplexCategory.mk n)
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type w} (J : CategoryTheory.GrothendieckTopology C) {P' : Cáµ’áµ– â¥¤ Type w} (i : P â‰… P') (h : CategoryTheory.Presieve.IsSheaf J P) : CategoryTheory.Presieve.IsSheaf J P'
{T : Type u} [CategoryTheory.Category T] (i : CategoryTheory.Arrow T) {X Y : T} (p : X â‰… Y) (sq : i âŸ¶ CategoryTheory.Arrow.mk p.hom) : i.hom â‰« sq.right â‰« p.inv = sq.left
{n : â„•} {a : Cardinal} (h : n â‰  0) : n â€¢ a < Cardinal.aleph_0 â†” a < Cardinal.aleph_0
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] {f g : Î± â†’ Î²} {a : Î±} (h : f =á¶ [nhds a] g) : âˆ€á¶  (y : Î±) in nhds a, f =á¶ [nhds y] g
(X : Type u) (Y : Type v) [metricSpace X] [CompactSpace X] [Nonempty X] [metricSpace Y] [CompactSpace Y] [Nonempty Y] : Isometry (Gromov_Hausdorff.optimal_GH_injl X Y)
{Î± : Type u_2} {Î¹ : Type u_5} [AddCommMonoid Î±] (t : Finset Î¹) (f : Î¹ â†’ Set Î±) (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), i âˆˆ t â†’ g i âˆˆ f i) : t.sum (Î» (i : Î¹), g i) âˆˆ t.sum (Î» (i : Î¹), f i)
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b c : Î±} : a + b < c â†’ b < -a + c
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] {F : Type v} [NormedGroup F] [normedSpace â„‚ F] {f : E â†’ F} {s : Set E} {z w : E} (hD : DiffContOnCl â„‚ f s) (hz : IsMaxOn (HasNorm.norm âˆ˜ f) s z) (HSub : Metric.Ball z (HasDist.dist w z) âŠ† s) : âˆ¥f wâˆ¥ = âˆ¥f zâˆ¥
{Î¹ : Type u_1} {R : Type u_3} {K : Type u_4} {M : Type u_5} {v : Î¹ â†’ M} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring K] [smulWithZero R K] [Module K M] [isScalarTower R K M] (hinj : Function.Injective (Î» (r : R), r â€¢ 1)) (li : LinearIndependent K v) : LinearIndependent R v
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {x : E} {s : Set E} : StarConvex ð•œ x s â†” âˆ€ â¦ƒa b : ð•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ {x} + b â€¢ s âŠ† s
{E : Type u_1} {F : Type u_2} [innerProductSpace â„ E] [innerProductSpace â„ F] {f : E â†’ F} {x : E} : ConformalAt f x â†” âˆƒ (c : â„), 0 < c âˆ§ âˆ€ (u v : E), HasInner.inner (â‡‘(fderiv â„ f x) u) (â‡‘(fderiv â„ f x) v) = c * HasInner.inner u v
{E : Type u} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] (f f' : â„ â†’ E) {a b : â„} (hle : a â‰¤ b) {s : Set â„} (hs : s.countable) (Hc : ContinuousOn f (Set.Icc a b)) (hD : âˆ€ (x : â„), x âˆˆ Set.Ioo a b  s â†’ HasDerivAt f (f' x) x) (Hi : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : âˆ« (x : â„) in a..b, f' x = f b - f a
{V : Type u_1} [innerProductSpace â„ V] {x y : V} : InnerProductGeometry.angle x y = Real.pi â†” x â‰  0 âˆ§ âˆƒ (r : â„), r < 0 âˆ§ y = r â€¢ x
{C : Type uâ‚} [CategoryTheory.Category C] {T : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] {D : J â¥¤ T.algebra} (c : CategoryTheory.Limits.Cocone (D â‹™ T.forget)) (t : CategoryTheory.Limits.IsColimit c) [CategoryTheory.Limits.PreservesColimit (D â‹™ T.forget) â†‘T] (j : J) : â†‘T.map (c.Î¹.app j) â‰« CategoryTheory.Monad.ForgetCreatesColimits.lambda c t = (D.obj j).a â‰« c.Î¹.app j
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization M S] (a : S) : âˆƒ (b : â†¥M), IsLocalization.IsInteger R (a * â‡‘(algebraMap R S) â†‘b)
{Î± : Type u_1} [CircularPreorder Î±] {a b c : Î±} : HasBtw.Btw a b c â†” HasBtw.Btw c a b
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) : Function.Surjective â‡‘(S.normed_Mk)
{n : â„•} : orderOf (DihedralGroup.r 1) = n
{Î± : Type u_1} {Î² : Type u_2} [Nontrivial Î²] {f : Î± â†’ Î²} (hF : Function.Surjective f) : Nontrivial Î±
{Î± : Type u_1} [CancelCommMonoidWithZero Î±] [gcdMonoid Î±] {m n k : Î±} (H : k âˆ£ m * n) : âˆƒ (dâ‚ : Î±) (hDâ‚ : dâ‚ âˆ£ m) (dâ‚‚ : Î±) (hDâ‚‚ : dâ‚‚ âˆ£ n), k = dâ‚ * dâ‚‚
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : Dense s â†’ Dense (Closure s)
{Î± : Type u_1} (s : Finset Î±) : s.powerset.card = 2 ^ s.card
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscreteNormedField ð•‚] [normedCommRing ð”¸] [NormedAlgebra ð•‚ ð”¸] [CompleteSpace ð”¸] [CharZero ð•‚] {x : ð”¸} (hx : x âˆˆ Emetric.Ball 0 (expSeries ð•‚ ð”¸).radius) : HasStrictFderivAt (Exp ð•‚) (Exp ð•‚ x â€¢ 1) x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasKernel f] [CategoryTheory.Mono f] : CategoryTheory.Limits.kernelÎ¹ f = 0
{Î± : Type u_1} [Monoid Î±] {a u : Î±} (hu : IsUnit u) : u âˆ£ a
{Î± : Type u_1} {Î´ : Type u_5} [topologicalSpace Î±] [measurableSpace Î±] [BorelSpace Î±] [measurableSpace Î´] [completeLinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_2} {Î¹' : Type u_3} {f : Î¹ â†’ Î´ â†’ Î±} {u : Filter Î¹} (hF : âˆ€ (i : Î¹), Measurable (f i)) {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set Î¹} (hu : u.has_countable_Basis p s) (hs : âˆ€ (i : Î¹'), (s i).countable) : Measurable (Î» (x : Î´), u.limsup (Î» (i : Î¹), f i x))
(S : Set â„•+) (K : Type w) (L : Type z) [Field K] [Field L] [Algebra K L] [h : NumberField K] [Fintype â†¥S] [IsCyclotomicExtension S K L] : NumberField L
{R : Type u_1} {A : Type u_2} [CommSemiring R] [CommSemiring A] [Algebra R A] (S T : Subalgebra R A) : S.to_Submodule * T.to_Submodule = (S âŠ” T).to_Submodule
{R : Type u_1} [orderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {x : M} [NoZeroSmulDivisors R M] (h : SameRay R x (-x)) : x = 0
{n : â„•} {Î± : Type u_1} [Preorder Î±] {f : Fin (n + 1) â†’ Î±} : Antitone f â†” âˆ€ (i : Fin n), f i.succ â‰¤ f (â‡‘fin.cast_Succ i)
(M : Type u_1) [monoidWithZero M] : IsSquare 0
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] (h : Module.rank K V < Cardinal.aleph_0) : (Basis.OfVectorSpaceIndex K V).finite
{R : Type u_1} {a : R} [Monoid R] {n : â„•} (n0 : 0 < n) : IsRegular (a ^ n) â†” IsRegular a
{C : Type uâ‚} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Mono (CategoryTheory.Limits.terminal.from A)] : CategoryTheory.IsSubterminal A
{X : Top} {T : â†¥X â†’ Type v} (P : Top.LocalPredicate T) (x : â†¥X) (w : âˆ€ (t : T x), âˆƒ (U : TopologicalSpace.OpenNhds x) (f : Î  (y : â†¥(U.val)), T â†‘y) (h : P.to_prelocal_predicate.pred f), f âŸ¨x, _âŸ© = t) : Function.Surjective (Top.stalkToFiber P x)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Fintype Î¹] [DecidableEq Î¹] [Î  (i : Î¹), DecidableEq (Î± i)] (r : Î  (i : Î¹), Î± i â†’ Finset (Î± i) â†’ Prop) (H_ex : âˆ€ (i : Î¹) (s : Finset (Î± i)), s.nonempty â†’ (âˆƒ (x : Î± i) (H : x âˆˆ s), r i x (s.erase x))) {p : (Î  (i : Î¹), Finset (Î± i)) â†’ Prop} (f : Î  (i : Î¹), Finset (Î± i)) (h0 : p (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), Finset (Î± i)) (i : Î¹) (x : Î± i), r i x (g i) â†’ p g â†’ p (Function.update g i (HasInsert.insert x (g i)))) : p f
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} {s : Set E} (h : is_IsLocalMaxOn f s a) (hF : HasFderivWithinAt f f' s a) {y : E} (hy : y âˆˆ PosTangentConeAt s a) : â‡‘f' y â‰¤ 0
{J : Type uâ‚} [CategoryTheory.Category J] [Nonempty J] (h : âˆ€ {Î± : Type uâ‚} (F : J â¥¤ CategoryTheory.Discrete Î±) (j j' : J), F.obj j = F.obj j') : CategoryTheory.IsConnected J
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {A B : C} (f : A âŸ¶ B) (F : C â¥¤ D) [CategoryTheory.IsIso (F.map f)] [CategoryTheory.ReflectsIsomorphisms F] : CategoryTheory.IsIso f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup Vâ‚‚] [Module k Vâ‚‚] [addTorsor Vâ‚‚ Pâ‚‚] {p : Î¹ â†’ P} (f : P â†’áµƒ[k] Pâ‚‚) (hai : AffineIndependent k (â‡‘f âˆ˜ p)) : AffineIndependent k p
{R : Type u} [NonAssocSemiring R] {s : Set R} {t : Subsemiring R} : Subsemiring.closure s â‰¤ t â†” s âŠ† â†‘t
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] {s t : Set E} (hsâ‚ : Convex â„ s) (hsâ‚‚ : is_IsOpen s) (ht : Convex â„ t) (disj : Disjoint s t) : âˆƒ (f : E â†’L[â„] â„) (u : â„), (âˆ€ (a : E), a âˆˆ s â†’ â‡‘f a < u) âˆ§ âˆ€ (b : E), b âˆˆ t â†’ u â‰¤ â‡‘f b
{ð•œ : Type u_1} {E : Type u_2} [normedField ð•œ] [semiNormedGroup E] [normedSpace ð•œ E] {x : E} {s : Set E} (hs : Metric.Bounded s) {u : Set E} (hu : u âˆˆ nhds x) : âˆ€á¶  (r : ð•œ) in nhds 0, {x} + r â€¢ s âŠ† u
{R : Type u_1} [normedRing R] [CompleteSpace R] (x : RË£) (n : â„•) : âˆ€á¶  (t : R) in nhds 0, Ring.inverse (â†‘x + t) = (Finset.range n).sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹ + (-â†‘xâ»Â¹ * t) ^ n * Ring.inverse (â†‘x + t)
{Î± : Type u} [topologicalSpace Î±] [t1_Space Î±] [âˆ€ (x : Î±), (nhdsWithin x {x}á¶œ).ne_IsBot] {s : Set Î±} (hs : Dense s) (t : Finset Î±) : Dense (s  â†‘t)
{ð•œ : Type u_1} [Field ð•œ] {M : Type u_2} [AddCommGroup M] [Module ð•œ M] : â‡‘LinearMap.det 0 = 0 ^ FiniteDimensional.finrank ð•œ M
{Î± : Type u_1} {m : Set Î± â†’ Ennreal} {m_Empty : m âˆ… = 0} {s t : Set Î±} (h : âˆ€ (u : Set Î±), (s âˆ© u).nonempty â†’ (t âˆ© u).nonempty â†’ m u = âŠ¤) : â‡‘(MeasureTheory.OuterMeasure.ofFunction m m_Empty) (s âˆª t) = â‡‘(MeasureTheory.OuterMeasure.ofFunction m m_Empty) s + â‡‘(MeasureTheory.OuterMeasure.ofFunction m m_Empty) t
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (G : C â¥¤ D) [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) G] : CategoryTheory.Limits.HasInitial D
{M : Type u_1} [AddZeroClass M] {c : AddCon M} : Function.Surjective â‡‘(c.mk')
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.additive] [CategoryTheory.EnoughInjectives C] {X Y : C} (f : X âŸ¶ Y) (P : CategoryTheory.injectiveResolution X) (Q : CategoryTheory.injectiveResolution Y) : F.map f â‰« CategoryTheory.Abelian.Functor.rightDerivedZeroToSelfAppInv F Q = CategoryTheory.Abelian.Functor.rightDerivedZeroToSelfAppInv F P â‰« (F.right_derived 0).map f
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s t : Set Î±} (ht : IsAntichain r t) (h : Minimals r s âŠ† t) (hs : âˆ€ â¦ƒa : Î±â¦„, a âˆˆ t â†’ (âˆƒ (b : Î±) (H : b âˆˆ Minimals r s), r a b)) : Minimals r s = t
{G : Type u_1} [Group G] (s : Set G) : IsSubgroup (group.normal_Closure s)
{Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {x : Î±} (hx : Function.IsFixedPt fa x) {g : Î± â†’ Î²} (h : Function.Semiconj g fa fb) : Function.IsFixedPt fb (g x)
{K : Type u_1} [linearOrderedField K] {a : K} (H : 1 < a) (n : â„•) : â†‘n â‰¤ a ^ n / (a - 1)
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î±'] [DecidableEq Î³] [DecidableEq Î´] {s : Finset Î±} {t : Finset Î²} {f : Î±' â†’ Î² â†’ Î³} {g : Î± â†’ Î±'} {f' : Î² â†’ Î± â†’ Î´} {g' : Î´ â†’ Î³} (h_Left_anticomm : âˆ€ (a : Î±) (b : Î²), f (g a) b = g' (f' b a)) : Finset.imageâ‚‚ f (Finset.image g s) t = Finset.image g' (Finset.imageâ‚‚ f' t s)
{C : Type uâ‚} [CategoryTheory.Category C] {B Aâ‚ Aâ‚‚ : C} (f : Aâ‚ âŸ¶ B) (g : Aâ‚‚ âŸ¶ B) [CategoryTheory.Mono f] [CategoryTheory.Mono g] (i : Aâ‚ â‰… Aâ‚‚) (w : i.hom â‰« g = f) : CategoryTheory.Subobject.mk f = CategoryTheory.Subobject.mk g
{Î± : Type u_1} [Order.Frame Î±] {s : Set Î±} : s.pairwise_Disjoint Id â†’ CompleteLattice.SetIndependent s
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {ps : Set P} {n : â„•} [FiniteDimensional â„ V] (hD : FiniteDimensional.finrank â„ V = n) (hc : EuclideanGeometry.Cospherical ps) : âˆƒ (c : P), âˆ€ (sx : Affine.Simplex â„ P n), Set.Range sx.points âŠ† ps â†’ sx.circumcenter = c
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topologicalSpace Î²] (f : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : Set Î±) [t2_Space Î²] {c : Set Î²} (hcâ‚ : is_IsCompact c) (hcâ‚‚ : âˆ€á¶  (t : Ï„) in f, Set.MapsTo (Ï• t) s c) {n : Set Î²} (hnâ‚ : is_IsOpen n) (hnâ‚‚ : OmegaLimit f Ï• s âŠ† n) : âˆƒ (u : Set Ï„) (H : u âˆˆ f), Closure (Set.image2 Ï• u s) âŠ† n
{Î± : Type u_1} [GeneralizedBooleanAlgebra Î±] [DecidableRel Disjoint] [DecidableRel LE.le] {s : Finset Î±} {u v a : Î±} : a âˆˆ Uv.compression u v s â†” a âˆˆ s âˆ§ Uv.compress u v a âˆˆ s âˆ¨ a âˆ‰ s âˆ§ âˆƒ (b : Î±) (H : b âˆˆ s), Uv.compress u v b = a
{ð•œ : Type u_1} {E : Type u_4} [semiNormedGroup E] [nondiscreteNormedField ð•œ] [normedSpace ð•œ E] (h : âˆƒ (x : E), âˆ¥xâˆ¥ â‰  0) : âˆ¥ContinuousLinearMap.id ð•œ Eâˆ¥ = 1
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : E â†’ â„} {a : E} {s : Set E} (h : is_IsLocalMinOn f s a) {y : E} (hy : y âˆˆ PosTangentConeAt s a) (hy' : -y âˆˆ PosTangentConeAt s a) : â‡‘(fderivWithin â„ f s a) y = 0
{n : â„•} {F : Typevec (n + 1) â†’ Type u} [Mvfunctor F] [q : Mvqpf F] {Î± : Typevec n} {Î² : Type u_1} (Q : Î² â†’ Prop) (u v : Î² â†’ Mvqpf.Cofix F Î±) (h : âˆ€ (x : Î²), Q x â†’ (âˆƒ (a : (Mvqpf.p F).A) (f' : ((Mvqpf.p F).drop.B a).arrow Î±) (fâ‚€ fâ‚ : (Mvqpf.p F).last.B a â†’ Mvqpf.Cofix F Î±), (u x).dest = Mvqpf.abs âŸ¨a, (Mvqpf.p F).append_contents f' fâ‚€âŸ© âˆ§ (v x).dest = Mvqpf.abs âŸ¨a, (Mvqpf.p F).append_contents f' fâ‚âŸ© âˆ§ âˆ€ (i : (Mvqpf.p F).last.B a), âˆƒ (x' : Î²), Q x' âˆ§ fâ‚€ i = u x' âˆ§ fâ‚ i = v x')) (x : Î²) : Q x â†’ u x = v x
{R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) (li : LinearIndependent R Coe) (t : Finset â†¥s) : LinearIndependent R Coe
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (wâ‚ wâ‚‚ : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘(s.affine_combination p) wâ‚ -áµ¥ â‡‘(s.affine_combination p) wâ‚‚ = â‡‘(s.weighted_vsub p) (wâ‚ - wâ‚‚)
{C : Type u} [CategoryTheory.Category C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) [CategoryTheory.StrongEpi (f â‰« g)] : CategoryTheory.StrongEpi g
{p : â„‚ Ã— â„‚} (hp_fst : 0 < p.fst.re âˆ¨ p.fst.im â‰  0) : ContinuousAt (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.snd) p
 : Real.cos (Real.pi / 3) = 1 / 2
(n : â„•) (p : Fin (n + 1)) : Finset.univ = Finset.cons p (Finset.map p.succ_above.to_Embedding Finset.univ) _
{E : Type u_1} {F : Type u_2} [innerProductSpace â„ E] [innerProductSpace â„ F] {f : E â†’ F} {x : E} {f' : E â†’L[â„] F} (h : HasFderivAt f f' x) (H : ConformalAt f x) (u v : E) : InnerProductGeometry.angle (â‡‘f' u) (â‡‘f' v) = InnerProductGeometry.angle u v
{A : Type u_1} [CommRing A] [Algebra â„š A] (a b : A) : â‡‘(PowerSeries.rescale a) (PowerSeries.exp A) * â‡‘(PowerSeries.rescale b) (PowerSeries.exp A) = â‡‘(PowerSeries.rescale (a + b)) (PowerSeries.exp A)
(a b : â„•) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
{k : Type u_1} {l : Type u_2} {m : Type u_3} {n : Type u_4} {Î± : Type v} [Fintype n] [Fintype k] [DecidableEq n] [DecidableEq k] [DecidableEq m] [Semiring Î±] (a : m) (b : n) (c : k) (M : Matrix k l Î±) : (Pequiv.single a b).to_matrix.mul ((Pequiv.single b c).to_matrix.mul M) = (Pequiv.single a c).to_matrix.mul M
{Î± : Type u} {Î¹ : Type v} [metricSpace Î±] [ProperSpace Î±] {c : Î¹ â†’ Î±} {s : Set Î±} {r : Î¹ â†’ â„} (hr : âˆ€ (i : Î¹), 0 < r i) (hs : is_IsClosed s) (uf : âˆ€ (x : Î±), x âˆˆ s â†’ {i : Î¹ | x âˆˆ Metric.Ball (c i) (r i)}.finite) (us : s âŠ† â‹ƒ (i : Î¹), Metric.Ball (c i) (r i)) : âˆƒ (r' : Î¹ â†’ â„), (s âŠ† â‹ƒ (i : Î¹), Metric.Ball (c i) (r' i)) âˆ§ âˆ€ (i : Î¹), r' i âˆˆ Set.Ioo 0 (r i)
{G : Type u_1} [Group G] (fâ‚ fâ‚‚ : G â†’* Circle_deg1_Lift) (h : âˆ€ (g : G), (â‡‘fâ‚ g).translation_number = (â‡‘fâ‚‚ g).translation_number) : âˆƒ (F : Circle_deg1_Lift), âˆ€ (g : G), Function.Semiconj â‡‘F â‡‘(â‡‘fâ‚ g) â‡‘(â‡‘fâ‚‚ g)
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [AddCommMonoid M] [DecidableEq Î±] [DecidableEq Î²] (s : Finset (Î± Ã— Î²)) (f : Î± Ã— Î² â†’ M) : finsum (Î» (Ab : Î± Ã— Î²), finsum (Î» (h : Ab âˆˆ s), f Ab)) = finsum (Î» (a : Î±), finsum (Î» (b : Î²), finsum (Î» (h : b âˆˆ Finset.image Prod.snd (Finset.filter (Î» (Ab : Î± Ã— Î²), ab.fst = a) s)), f (a, b))))
{G : Type u_1} [AddGroup G] {H : AddSubgroup G} {N : Type u_3} [AddGroup N] (f : G â†’+ N) : AddSubgroup.map f H.normalizer â‰¤ (AddSubgroup.map f H).normalizer
{Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hF : Function.Injective f) : Filter.comap f Filter.cofinite = Filter.cofinite
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_3} [Fintype Î±] [Fintype Î²] [CommMonoid M] (e : Î± â†’ Î²) (hE : Function.bijective e) (f : Î± â†’ M) (g : Î² â†’ M) (h : âˆ€ (x : Î±), f x = g (e x)) : finset.univ.prod (Î» (x : Î±), f x) = finset.univ.prod (Î» (x : Î²), g x)
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup V1] [Module k V1] [addTorsor V1 P1] [AddCommGroup V2] [Module k V2] [addTorsor V2 P2] (f : P1 â†’áµƒ[k] P2) : f.to_fun = â‡‘f
{Î± : Type u_1} [pseudoMetricSpace Î±] (r C : â„) (hr : r < 1) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasDist.dist (f n) (f (n + 1)) â‰¤ C * r ^ n) {a : Î±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) : HasDist.dist (f 0) a â‰¤ C / (1 - r)
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (H : CategoryTheory.CoverDense K G) [CategoryTheory.Full G] [CategoryTheory.Faithful G] : CategoryTheory.CompatiblePreserving K G
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {A B C : Matrix n n Î±} (h : B.mul A = 1) (g : C.mul A = 1) : B = C
{ð•œ : Type u} {G : Type wG} {G' : Type wG'} [nondiscreteNormedField ð•œ] [NormedGroup G] [normedSpace ð•œ G] [NormedGroup G'] [normedSpace ð•œ G'] {k n : â„•} (f : MultilinearMap ð•œ (Î» (i : Fin n), G) G') (s : Finset (Fin n)) (hk : s.card = k) (z : G) {C : â„} (H : âˆ€ (m : Fin n â†’ G), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Fin n), âˆ¥m iâˆ¥)) (v : Fin k â†’ G) : âˆ¥â‡‘(f.restr s hk z) vâˆ¥ â‰¤ C * âˆ¥zâˆ¥ ^ (n - k) * finset.univ.prod (Î» (i : Fin k), âˆ¥v iâˆ¥)
(k : Type uâ‚) {G : Type uâ‚‚} [Semiring k] [hasAdd G] {A : Type uâ‚ƒ} [NonUnitalNonAssocSemiring A] [DistribMulAction k A] {Ï†â‚ Ï†â‚‚ : AddMonoidAlgebra k G â†’â‚™â‚[k] A} (h : âˆ€ (x : G), â‡‘Ï†â‚ (Finsupp.single x 1) = â‡‘Ï†â‚‚ (Finsupp.single x 1)) : Ï†â‚ = Ï†â‚‚
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {Î¹ : Type u_2} [DecidableEq Î¹] {E : Î¹ â†’ Type u_3} [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] {s : Î  (i : Î¹), Set (E i)} {x : Î  (i : Î¹), E i} {i : Î¹} (hi : âˆ€ (j : Î¹), j â‰  i â†’ x j âˆˆ Closure (s j)) : Set.MapsTo â‡‘(LinearMap.single i) (TangentConeAt ð•œ (s i) (x i)) (TangentConeAt ð•œ (set.univ.pi s) x)
(R : Type u_1) (M : Type u_2) [Ring R] [topologicalSpace R] [topologicalSpace M] [AddCommGroup M] [HasContinuousAdd M] [Module R M] [HasContinuousSmul R M] [Nontrivial M] [(nhdsWithin 0 {0}á¶œ).ne_IsBot] [NoZeroSmulDivisors R M] (x : M) : (nhdsWithin x {x}á¶œ).ne_IsBot
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : (Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] g â†’ f' =o[l] g
{Î¹ : Type u_1} {ð•œ : Type u_2} [is_R_or_C ð•œ] {E : Type u_3} [innerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), innerProductSpace ð•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ V) [âˆ€ (i : Î¹), CompleteSpace (G i)] (hV' : (â¨† (i : Î¹), (V i).to_LinearMap.range).topological_Closure = âŠ¤) {i : Î¹} (x : G i) : â‡‘((hV.linear_Isometry_Equiv hV').symm) (lp.single 2 i x) = â‡‘(V i) x
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [Ring R] [AddCommGroup M] [Module R M] {hli : LinearIndependent R v} {hsp : Submodule.span R (Set.Range v) = âŠ¤} {i j : Î¹} (h : j â‰  i) : â‡‘((Basis.mk hli hsp).coord i) (v j) = 0
{X Y : Top} {f g : C(â†¥X, â†¥Y)} (H : f.homotopy g) (x : â†¥X) : âŸ¦H.eval_at xâŸ§ = ContinuousMap.Homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_Map).map (Continuous_map.homotopy.prod_to_Prod_Top_I Unit_interval.uhpath01 (ðŸ™ x)) â‰« ContinuousMap.Homotopy.hcast _
{M : Type u_1} [AddZeroClass M] (S : addSubmonoid M) : AddSubmonoid.closure â†‘S = S
{Î¹ : Type w} [Fintype Î¹] (K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [Module.Finite K L] [IsAlgClosed E] (b : Î¹ â†’ L) [DecidableEq Î¹] [IsSeparable K L] (e : Î¹ â‰ƒ (L â†’â‚[K] E)) : â‡‘(algebraMap K E) (Algebra.discr K b) = (Algebra.embeddingsMatrixReindex K E b e).det ^ 2
(C : Type u) [ð’ž : CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasPullbacks C
{H : Type u_1} [topologicalSpace H] [LocallyCompactSpace H] [t2_Space H] [TotallyDisconnectedSpace H] : TopologicalSpace.IsTopologicalBasis {s : Set H | is_IsClopen s}
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [pseudoMetricSpace Î²] {f g : boundedContinuousFunction Î± Î²} (x : Î±) : HasDist.dist (â‡‘f x) (â‡‘g x) â‰¤ HasDist.dist f g
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimitsOfSize C] : CategoryTheory.Limits.HasLimitsOfSize C
{M : Type u_1} {N : Type u_2} [AddZeroClass M] [AddZeroClass N] {c : AddCon M} {f : N â†’+ M} : AddCon.comap â‡‘f _ c = AddCon.ker (c.mk'.comp f)
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) : v.int_Valuation_def 0 = 0
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s t : Set Î±} (hst : Disjoint s t) (hs : s.finite) (ht : t.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
{Î± : Type u_1} {a b c : Î±} [LinearOrder Î±] [AddCommSemigroup Î±] [HasSub Î±] [HasOrderedSub Î±] : a < b - c â†” a + c < b
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle â„ P) : t.orthocenter âˆˆ affineSpan â„ (Set.Range t.points)
(a : â„) : Cardinal.mk â†¥(Set.Iic a) = Cardinal.continuum
{K : Type u_1} {n : â„•} {s : Seq (GeneralizedContinuedFraction.Pair K)} [divisionRing K] {gp_n gp_Succ_n : GeneralizedContinuedFraction.Pair K} (s_nth_Eq : s.nth n = Option.some gp_n) (s_Succ_nth_Eq : s.nth (n + 1) = Option.some gp_Succ_n) : (GeneralizedContinuedFraction.squashSeq s n).nth n = Option.some {a := gp_n.a, b := gp_n.b + gp_Succ_n.a / gp_Succ_n.b}
(T : Type u) [topologicalSpace T] : CategoryTheory.Pretopology.toGrothendieck (TopologicalSpace.Opens T) (Opens.pretopology T) = Opens.grothendieckTopology T
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] {s : Set Î²} (hs : is_IsCompact s) (NE_s : s.nonempty) {f : Î² â†’ Î±} (hF : ContinuousOn f s) : âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f x â‰¤ f y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] {X : C} (f : X âŸ¶ 0) : f = 0
{n : â„•} {l : Multiset â„•} (hl : l.sum = n) {i : â„•} (hi : i â‰  0) : Multiset.count i (Nat.Partition.ofSums n l hl).parts = Multiset.count i l
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) (h : âˆ€ (X : C), CategoryTheory.Presieve.IsSheaf J (Category_theory.yoneda.obj X)) : CategoryTheory.Sheaf.Subcanonical J
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {Î¹2 : Type u_5} (f : Î¹2 â†ª Î¹) {p : Î¹ â†’ P} (ha : AffineIndependent k p) : AffineIndependent k (p âˆ˜ â‡‘f)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) : deriv (Î» (u : â„), âˆ« (x : â„) in a..u, f x) b = c
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [hasZero M] [AddCommMonoid N] [AddCommMonoid P] (h : N â‰ƒ+ P) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ N) : â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
{M : Type u_1} [hasMul M] (c : Con M) (x : M) : â‡‘c x x
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [DecidableEq Î²] [Preorder Î²] {f : Î± â†’ Î²} (hâ‚ : StrictMono f) (A B : Finset Î±) : (Finset.image f A).to_colex < (Finset.image f B).to_colex â†” A.to_colex < B.to_colex
{ð•œ : Type u_3} {E : Type u_4} [normedField ð•œ] [AddCommGroup E] [Module ð•œ E] (p : Seminorm ð•œ E) {r : â„} {x : E} (hpr : â‡‘p x < r) : Absorbent ð•œ (p.ball x r)
{K : Type u_1} {V : Type u_2} [Field K] [AddCommGroup V] [Module K V] (n : â„•) [Fact (FiniteDimensional.finrank K V = n + 1)] : FiniteDimensional K V
{Î± : Type u} [Preorder Î±] {a b : Î±} : a < b â†’ a â‰¤ b
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [CommMonoid Î²] [CommMonoid Î³] (g : Î² â‰ƒ* Î³) (f : Î± â†’ Î²) (s : Finset Î±) : â‡‘g (s.prod (Î» (x : Î±), f x)) = s.prod (Î» (x : Î±), â‡‘g (f x))
{l : Filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in Filter.atBot, HasDerivAt f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in Filter.atBot, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in Filter.atBot, g' x â‰  0) (hfbot : Filter.Tendsto f Filter.atBot (nhds 0)) (hgbot : Filter.Tendsto g Filter.atBot (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), f' x / g' x) Filter.atBot l) : Filter.Tendsto (Î» (x : â„), f x / g x) Filter.atBot l
{M : Type u_4} [AddCommMonoid M] {Î¹ : Type u_1} [Subsingleton Î¹] {s : Finset Î¹} {f : Î¹ â†’ M} {b : M} (h : s.sum (Î» (i : Î¹), f i) = b) (i : Î¹) (H : i âˆˆ s) : f i = b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] [CompleteSpace ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [FiniteDimensional ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {a : E} (hF : HasStrictFderivAt f f' a) (hF' : f'.range = âŠ¤) : âˆ€á¶  (p : F Ã— â†¥(f'.ker)) in nhds (f a, 0), f (HasStrictFderivAt.implicitFunction f f' hF hF' p.fst p.snd) = p.fst
{x : â„} (h : 0 < x) : Real.sin x < x
{R : Type u_1} [addCancelMonoid R] (g : R) : IsAddRegular g
{ð•œ : Type u_4} {E : Type u_5} [linearOrderedField ð•œ] [topologicalSpace E] [AddCommMonoid E] [Module ð•œ E] {s : Set E} (hsâ‚€ : is_IsClosed s) (hsâ‚ : StrictConvex ð•œ s) : AddSalemSpencer (Frontier s)
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] {S : Set M} {x : M} (hx : x âˆˆ Submodule.span R S) : âˆƒ (T : Finset M), â†‘T âŠ† S âˆ§ x âˆˆ Submodule.span R â†‘T
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q) [CategoryTheory.Epi f] : Function.Surjective â‡‘f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s1 s2 : AffineSubspace k P) : s1 â‰¤ s2 â†” â†‘s1 âŠ† â†‘s2
{A : Type u_1} [AddMonoid A] {f g : â„¤ â†’+ A} (h1 : â‡‘f 1 = â‡‘g 1) : f = g
{Î± : Type u_1} [linearOrderedAddCommGroup Î±] {n : â„¤} (hn : n â‰  0) : Function.Injective (Î» (_x : Î±), n â€¢ _x)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
{Î± : Type u} [pseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„} (hp : Function.Periodic f c) (hc : c â‰  0) (hF : Continuous f) : Metric.Bounded (Set.Range f)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x y + hb.oangle y z = hb.oangle x z
{R : Type u_1} {E : Type u_2} [linearOrderedField R] [AddCommGroup E] [Module R E] (s : Set E) : â‡‘(convexHull R) s = {x : E | âˆƒ (Î¹ : Type u') (t : Finset Î¹) (w : Î¹ â†’ R) (z : Î¹ â†’ E) (hwâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hwâ‚ : t.sum (Î» (i : Î¹), w i) = 1) (hz : âˆ€ (i : Î¹), i âˆˆ t â†’ z i âˆˆ s), t.center_mass w z = x}
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a : Î±} : 1 < aâ»Â¹ â†’ a < 1
{G : Type u_1} [Group G] {s : Set G} {N : Subgroup G} [N.normal] (h : s âŠ† â†‘N) : Subgroup.normalClosure s â‰¤ N
(n : â„•) (R : Type u_1) [Ring R] [Nontrivial R] : (Polynomial.cyclotomic n R).nat_degree = n.totient
(a : â„) : Cardinal.mk â†¥(Set.Iio a) = Cardinal.continuum
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {s : Set Î±} : DirectedOn r s â†’ Directed r Coe
(R : Type u) [Ring R] [StrongRankCondition R] (m n : Type v) [Fintype m] [Fintype n] : FiniteDimensional.finrank R (Matrix m n R) = Fintype.card m * Fintype.card n
{Î± : Type u_1} (t : Set (Set Î±)) (Î´ : Set Î± â†’ â„) (Ï„ : â„) (hÏ„ : 1 < Ï„) (Î´nonneg : âˆ€ (a : Set Î±), a âˆˆ t â†’ 0 â‰¤ Î´ a) (R : â„) (Î´LE : âˆ€ (a : Set Î±), a âˆˆ t â†’ Î´ a â‰¤ R) (hne : âˆ€ (a : Set Î±), a âˆˆ t â†’ a.nonempty) : âˆƒ (u : Set (Set Î±)) (H : u âŠ† t), u.pairwise_Disjoint Id âˆ§ âˆ€ (a : Set Î±), a âˆˆ t â†’ (âˆƒ (b : Set Î±) (H : b âˆˆ u), (a âˆ© b).nonempty âˆ§ Î´ a â‰¤ Ï„ * Î´ b)
{R : Type u} [CommSemiring R] (s : Multiset (Polynomial R)) (x : R) : Polynomial.eval x s.prod = (Multiset.map (Polynomial.eval x) s).prod
{Î± : Type u_1} {Î² : Type u_2} {r : Setoid Î±} {f : Î± â†’ Î²} (H : r â‰¤ setoid.ker f) (g : Quotient r â†’ Î²) (Hg : f = g âˆ˜ Quotient.mk) : Quotient.lift f H = g
{m : Type u_2} {n : Type u_3} (R : Type u_11) [CommRing R] [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (e : m â‰ƒ n) (M : Matrix m m R) : (â‡‘(Matrix.reindexLinearEquiv R R e e) M).det = M.det
{ð•œ : Type u_1} {E : Type u_3} [orderedSemiring ð•œ] [topologicalSpace E] [AddCommMonoid E] [Module ð•œ E] {s : Set E} (h : is_IsOpen s) (hs : Convex ð•œ s) : StrictConvex ð•œ s
{R : Type u_1} [MulZeroClass R] : IsRightRegular 0 â†” Subsingleton R
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [normedSpace ð•œ E'] {n : WithTop â„•} {f : E â†’ E'} : ContMdiff (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') n f â†’ ContDiff ð•œ n f
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] {f : Î² â†’ Î±} (hF : Continuous f) (xâ‚€ : Î²) (h : âˆ€á¶  (x : Î²) in Filter.cocompact Î², f xâ‚€ â‰¤ f x) : âˆƒ (x : Î²), âˆ€ (y : Î²), f x â‰¤ f y
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C â¥¤ D} (H : CategoryTheory.CoverDense K G) [CategoryTheory.Full G] {â„± : Dáµ’áµ– â¥¤ A} {â„±' : CategoryTheory.Sheaf K A} (Î± : â„± âŸ¶ â„±'.val) : H.sheaf_hom (CategoryTheory.whiskerLeft G.op Î±) = Î±
{xl xr : Type u_1} {xL : xl â†’ Pgame} {xR : xr â†’ Pgame} {yl yr : Type u_1} {yL : yl â†’ Pgame} {yR : yr â†’ Pgame} : Pgame.mk xl xr xL xR â‰¤ Pgame.mk yl yr yL yR â†” (âˆ€ (i : xl), (xL i).lf (Pgame.mk yl yr yL yR)) âˆ§ âˆ€ (j : yr), (Pgame.mk xl xr xL xR).lf (yR j)
{Î± : Type u_1} [completeLattice Î±] [IsModularLattice Î±] [IsCompactlyGenerated Î±] (h : HasSup.sup {a : Î± | IsAtom a} = âŠ¤) : IsComplemented Î±
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) : s.points_with_circumcenter Affine.Simplex.PointsWithCircumcenterIndex.circumcenter_Index = s.circumcenter
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) (m : Multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
{p : â„•} (hp : Nat.Prime p) {n : â„¤} (hpn : IsCoprime n â†‘p) : n ^ (p - 1) â‰¡ 1 [Zmod â†‘p]
{Î± : Type v} {s : Finset Î±} {M : Type u_1} [AddCommMonoid M] (f : Î± â†’ M) (p : M â†’ Prop) (p_Mul : âˆ€ (a b : M), p a â†’ p b â†’ p (a + b)) (p_One : p 0) (p_s : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (s.sum (Î» (x : Î±), f x))
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [Fintype Î¹] (p : Î¹ â†’ P) {n : â„•} (hc : Fintype.card Î¹ = n + 1) : AffineIndependent k p â†” n â‰¤ FiniteDimensional.finrank k â†¥(vectorSpan k (Set.Range p))
(R : Type u_1) (A : Type u_2) (M : Type u_3) [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid M] [Module R M] [Module A M] [isScalarTower R A M] (X : Set M) (hsur : Function.Surjective â‡‘(algebraMap R A)) : Submodule.span R X = Submodule.restrictScalars R (Submodule.span A X)
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (A : Matrix n n R) : (-A).det = (-1) ^ Fintype.card n â€¢ A.det
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : 0 â‰¤ InnerProductGeometry.angle x y
{Î± : Type u} [NonUnitalNonAssocRing Î±] {a b c d e : Î±} : a * e + c = b * e + d â†’ (a - b) * e + c = d
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {n : â„•} (hs : UniqueDiffOn ð•œ s) : ContDiffOn ð•œ â†‘(n + 1) f s â†” DifferentiableOn ð•œ f s âˆ§ ContDiffOn ð•œ â†‘n (Î» (y : E), fderivWithin ð•œ f s y) s
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (T : Type u_4) [CommRing T] [Algebra R T] [Algebra S T] [isScalarTower R S T] [IsLocalization M S] (p : Ideal S) [Hp : p.is_Prime] [IsLocalization.AtPrime T p] : IsLocalization.AtPrime T (Ideal.comap (algebraMap R S) p)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) (hxy : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) (hxz : âˆ¥xâˆ¥ = âˆ¥zâˆ¥) : o.oangle y z = 2 â€¢ o.oangle (y - x) (z - x)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {p : FormalMultilinearSeries ð•œ E F} {r : Ennreal} {f : E â†’ F} {x : E} [CompleteSpace F] (h : HasFpowerSeriesOnBall f p x r) : HasFpowerSeriesOnBall (fderiv ð•œ f) (â†‘(Continuous_multilinear_Curry_Fin1 ð•œ E F).comp_FormalMultilinearSeries (p.change_origin_series 1)) x r
{Î± : Type u_1} [conditionallyCompleteLinearOrder Î±] {s : Set Î±} {b : Î±} (hs : s.nonempty) (hb : b < HasSup.sup s) : âˆƒ (a : Î±) (H : a âˆˆ s), b < a
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasStrictDerivAt (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c b
(k : Type u_1) {V : Type u_2} (P : Type u_3) [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] : Collinear k âˆ…
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {x : E} {n : â„•} (hs : UniqueDiffOn ð•œ s) (hx : x âˆˆ s) : iteratedFderivWithin ð•œ (n + 1) f s x = (â‡‘(continuousMultilinearCurryRightEquiv' ð•œ n E F) âˆ˜ iteratedFderivWithin ð•œ n (Î» (y : E), fderivWithin ð•œ f s y) s) x
{X : Type u_2} {Y : Type u_3} [emetricSpace X] [emetricSpace Y] [TopologicalSpace.SecondCountableTopology X] {f : X â†’ Y} (hF : âˆ€ (x : X), âˆƒ (C : Nnreal) (s : Set X) (H : s âˆˆ nhds x), LipschitzOnWith C f s) : dimH (Set.Range f) â‰¤ dimH Set.Univ
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {s : Set E} : UniqueMdiffOn (modelWithCornersSelf ð•œ E) s â†’ UniqueDiffOn ð•œ s
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [CommRing R] {xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2 + xâ‚… ^ 2 + xâ‚† ^ 2 + xâ‚‡ ^ 2 + xâ‚ˆ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2 + yâ‚… ^ 2 + yâ‚† ^ 2 + yâ‚‡ ^ 2 + yâ‚ˆ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„ - xâ‚… * yâ‚… - xâ‚† * yâ‚† - xâ‚‡ * yâ‚‡ - xâ‚ˆ * yâ‚ˆ) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ + xâ‚… * yâ‚† - xâ‚† * yâ‚… - xâ‚‡ * yâ‚ˆ + xâ‚ˆ * yâ‚‡) ^ 2 + (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚ + xâ‚… * yâ‚‡ + xâ‚† * yâ‚ˆ - xâ‚‡ * yâ‚… - xâ‚ˆ * yâ‚†) ^ 2 + (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚ + xâ‚… * yâ‚ˆ - xâ‚† * yâ‚‡ + xâ‚‡ * yâ‚† - xâ‚ˆ * yâ‚…) ^ 2 + (xâ‚ * yâ‚… - xâ‚‚ * yâ‚† - xâ‚ƒ * yâ‚‡ - xâ‚„ * yâ‚ˆ + xâ‚… * yâ‚ + xâ‚† * yâ‚‚ + xâ‚‡ * yâ‚ƒ + xâ‚ˆ * yâ‚„) ^ 2 + (xâ‚ * yâ‚† + xâ‚‚ * yâ‚… - xâ‚ƒ * yâ‚ˆ + xâ‚„ * yâ‚‡ - xâ‚… * yâ‚‚ + xâ‚† * yâ‚ - xâ‚‡ * yâ‚„ + xâ‚ˆ * yâ‚ƒ) ^ 2 + (xâ‚ * yâ‚‡ + xâ‚‚ * yâ‚ˆ + xâ‚ƒ * yâ‚… - xâ‚„ * yâ‚† - xâ‚… * yâ‚ƒ + xâ‚† * yâ‚„ + xâ‚‡ * yâ‚ - xâ‚ˆ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚ˆ - xâ‚‚ * yâ‚‡ + xâ‚ƒ * yâ‚† + xâ‚„ * yâ‚… - xâ‚… * yâ‚„ - xâ‚† * yâ‚ƒ + xâ‚‡ * yâ‚‚ + xâ‚ˆ * yâ‚) ^ 2
(R : Type u_2) (M : Type u_5) [Semiring R] [AddCommMonoid M] [Module R M] [hasOne M] [CharZero M] : CharZero R
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LE.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
{M : Type u_1} [AddMonoid M] (P : addSubmonoid M) : P.fg â†” âˆƒ (S : Set M), AddSubmonoid.closure S = P âˆ§ S.finite
{Î¹ : Type u_6} [DecidableEq Î¹] {Î¹â‚ : Type u_7} [Fintype Î¹] {R' : Type u_8} {Nâ‚ : Type u_9} {Nâ‚‚ : Type u_10} [CommSemiring R'] [AddCommMonoid Nâ‚] [AddCommMonoid Nâ‚‚] [Module R' Nâ‚] [Module R' Nâ‚‚] {f g : AlternatingMap R' Nâ‚ Nâ‚‚ Î¹} (e : Basis Î¹â‚ R' Nâ‚) (h : âˆ€ (v : Î¹ â†’ Î¹â‚), Function.Injective v â†’ â‡‘f (Î» (i : Î¹), â‡‘e (v i)) = â‡‘g (Î» (i : Î¹), â‡‘e (v i))) : f = g
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {a b : Î±} (p : Î± â†’ Prop) (l : List Î±) (h : List.Chain r a l) (hb : (a :: l).last _ = b) (carries : âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ p y â†’ p x) (final : p b) (i : Î±) (H : i âˆˆ a :: l) : p i
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : ContinuousMultilinearMap ð•œ E G) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ M * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥fâˆ¥ â‰¤ M
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasImages V] [CategoryTheory.Limits.HasZeroObject V] [CategoryTheory.Preadditive V] [CategoryTheory.Limits.HasKernels V] [CategoryTheory.Limits.HasCokernels V] {A B C : V} (f : A âŸ¶ B) (g : B âŸ¶ C) : CategoryTheory.Exact f g â†” âˆƒ (w : f â‰« g = 0), Nonempty (homology f g w â‰… 0)
{C : Type uâ‚} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasBinaryProduct A A] [CategoryTheory.IsIso (CategoryTheory.Limits.diag A)] : CategoryTheory.IsSubterminal A
{C : Type uâ‚} [CategoryTheory.Category C] {A : C} (hA : CategoryTheory.IsSubterminal A) [CategoryTheory.Limits.HasBinaryProduct A A] : CategoryTheory.IsIso (CategoryTheory.Limits.diag A)
(G : Type u) (F : Type v) [Group G] [Field F] [Fintype G] [mulSemiringAction G F] [HasFaithfulSmul G F] : Function.bijective (MulSemiringAction.toAlgHom â†¥(FixedPoints.subfield G F) F)
(p : â„•) [Fact (Nat.Prime p)] (R : Type uâ‚) [CommSemiring R] [Char_p R p] [PerfectRing R p] : PerfectionMap p (RingHom.id R)
(R : Type u_1) {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K] [CharZero R] : CharZero K
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {u v z : E} (hv : v âˆˆ K) (hz : z âˆˆ Ká—®) (hu : u = v + z) : â†‘(â‡‘(orthogonalProjection K) u) = v
{Î± : Type u} [pseudoMetricSpace Î±] {s t u : Set Î±} (Fin : Emetric.hausdorffEdist t u â‰  âŠ¤) : Metric.hausdorffDist s u â‰¤ Metric.hausdorffDist s t + Metric.hausdorffDist t u
{Î± : Type u_1} [topologicalSpace Î±] {s : Set Î±} {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] {f g : Î± â†’ Î³} (hF : LowerSemicontinuousOn f s) (hg : LowerSemicontinuousOn g s) (hcont : âˆ€ (x : Î±), x âˆˆ s â†’ ContinuousAt (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : LowerSemicontinuousOn (Î» (z : Î±), f z + g z) s
(s : â„‚) (h2 : s â‰  0) : (s + 1).Gamma = s * s.Gamma
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {f : M â†’* P} (x : M) : â‡‘(Con.ker f) x = â‡‘f â»Â¹' {â‡‘f x}
(R : Type u) [Ring R] [StrongRankCondition R] {Î¹ : Type v} [Fintype Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), AddCommGroup (M i)] [Î  (i : Î¹), Module R (M i)] [âˆ€ (i : Î¹), Module.Free R (M i)] [âˆ€ (i : Î¹), Module.Finite R (M i)] : FiniteDimensional.finrank R (Î  (i : Î¹), M i) = finset.univ.sum (Î» (i : Î¹), FiniteDimensional.finrank R (M i))
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommGroup E] [Module ð•œ E] {s : Set E} : ConvexIndependent ð•œ (Î» (x : â†¥s), â†‘x) â†” âˆ€ (x : E), x âˆˆ s â†’ x âˆ‰ â‡‘(convexHull ð•œ) (s  {x})
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
{Î± : Type u} {Î² : Type v} [Preorder Î±] [SemilatticeSup Î²] {f g : Î± â†’ Î²} (hF : Antitone f) (hg : Antitone g) : Antitone (f âŠ” g)
{Î± : Type u_1} [uniformSpace Î±] {s : Set Î±} {U : Set (Î± Ã— Î±)} (hs : Dense s) (hU : U âˆˆ Uniformity Î±) : (â‹ƒ (x : Î±) (H : x âˆˆ s), UniformSpace.Ball x U) = Set.Univ
{R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring Râ‚‚] [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {s : Set M} {f g : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (hv : Submodule.span R s = âŠ¤) (h : Set.EqOn â‡‘f â‡‘g s) : f = g
 : Irrational (Real.sqrt 2)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Fintype Î¹] : Filter.coprod (Î» (i : Î¹), Filter.cofinite) = Filter.cofinite
{R : Type u} {S : Type v} [Ring R] [Ring S] (f : R â†’+* S) (hF : Function.Surjective â‡‘f) : f.range = âŠ¤
{Î± : Type u_1} {Î² : Type u_2} [Fintype Î±] [completeLattice Î²] (f : Î± â†’ Î²) : finset.univ.inf f = infi f
{C : Type uâ‚} [CategoryTheory.Category C] {J : Type uâ‚‚} [CategoryTheory.Category J] [CategoryTheory.Limits.HasLimitsOfShape Jáµ’áµ– C] : CategoryTheory.Limits.HasColimitsOfShape J Cáµ’áµ–
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topologicalSpace Î±] [uniformSpace Î²] : ContinuousMap.compactOpen = ContinuousMap.compactConvergenceTopology
{Î± : Type u} [Preorder Î±] {f : â„¤ â†’ Î±} (hF : Monotone f) (n : â„¤) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„¤) : f a â‰  x
{Î± : Type u_1} [topologicalSpace Î±] {Î¹ : Type u_2} [Encodable Î¹] {s : Î¹ â†’ Set Î±} (hs : âˆ€ (n : Î¹), MeasureTheory.AnalyticSet (s n)) : MeasureTheory.AnalyticSet (â‹ƒ (n : Î¹), s n)
{A : Type u_5} [CommRing A] {m : Type u_6} {n : Type u_7} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] {M : Matrix m n A} {M' : Matrix n m A} {N : Matrix n n A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : ((M.mul N).mul M').det = N.det
{o : Ordinal} {f : Î  (b : Ordinal), b < o â†’ Ordinal â†’ Ordinal} (H : âˆ€ (i : Ordinal) (hi : i < o), Ordinal.IsNormal (f i hi)) : Set.Unbounded LT.lt (â‹‚ (i : Ordinal) (hi : i < o), Function.FixedPoints (f i hi))
{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) (n : Zmod2) {P : Î  (x : CliffordAlgebra Q), x âˆˆ CliffordAlgebra.evenOdd Q n â†’ Prop} (hr : âˆ€ (v : CliffordAlgebra Q) (h : v âˆˆ (CliffordAlgebraÎ¹ Q).range ^ n.val), P v _) (HAdd : âˆ€ {x y : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q n} {hy : y âˆˆ CliffordAlgebra.evenOdd Q n}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_Mul : âˆ€ (mâ‚ mâ‚‚ : M) {x : CliffordAlgebra Q} {hx : x âˆˆ CliffordAlgebra.evenOdd Q n}, P x hx â†’ P (â‡‘(CliffordAlgebraÎ¹ Q) mâ‚ * â‡‘(CliffordAlgebraÎ¹ Q) mâ‚‚ * x) _) (x : CliffordAlgebra Q) (hx : x âˆˆ CliffordAlgebra.evenOdd Q n) : P x hx
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C â¥¤ D} (H : CategoryTheory.CoverDense K G) [CategoryTheory.Full G] {â„± â„±' : CategoryTheory.Sheaf K A} (Î± : â„± âŸ¶ â„±') (i : CategoryTheory.IsIso (CategoryTheory.whiskerLeft G.op Î±.val)) : CategoryTheory.IsIso Î±
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] [IsNoetherian R M] {s : Set M} (hi : LinearIndependent R Coe) : s.finite
{Î± : Type u} {f : Ultrafilter Î±} {p : Î± â†’ Prop} : (âˆƒá¶  (x : Î±) in â†‘f, p x) â†’ (âˆ€á¶  (x : Î±) in â†‘f, p x)
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} {P : Type uâ‚„} [AddCommGroup V] [addTorsor V P] [CommRing k] [Module k V] [DecidableEq Î¹] [Fintype Î¹] (b bâ‚‚ : AffineBasis Î¹ k P) (x : P) : Matrix.vecMul (â‡‘(b.coords) x) (b.to_Matrix bâ‚‚.points)â»Â¹ = â‡‘(bâ‚‚.coords) x
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} [decÎ¹ : DecidableEq Î¹] {v : Î¹ â†’ E} : Orthonormal ð•œ v â†” âˆ€ (i j : Î¹), HasInner.inner (v i) (v j) = Ite (i = j) 1 0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] (f : E â†’L[ð•œ] F â†’L[ð•œ] G) : Continuous (Function.uncurry (Î» (x : E) (y : F), â‡‘(â‡‘f x) y))
{q : â„š} (q_Pos : 0 < q) : (GeneralizedContinuedFraction.IntFractPair.of qâ»Â¹).fr.num < q.num
{Î± : Type u_1} [hasLt Î±] {a b : Î±} (h : a < b) : Â¬a â‹– b â†’ (âˆƒ (c : Î±), a < c âˆ§ c < b)
{Î± : Type u_1} [linearOrderedField Î±] {a b : Î±} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b â†” b < a
{R : Type u_1} [normedRing R] (k : â„•) {r : â„} (hr : 1 < r) : (Î» (n : â„•), â†‘n ^ k) =o[Filter.atTop] Î» (n : â„•), r ^ n
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s t : Set P) : affineSpan k (s âˆª t) = affineSpan k s âŠ” affineSpan k t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] {P Q : C} (f : P âŸ¶ Q) : CategoryTheory.Abelian.coimageÏ€ f â‰« CategoryTheory.Abelian.factorThruCoimage f = f
{Î± : Type u} [emetricSpace Î±] [CompleteSpace Î±] : is_IsClosed (Set.Range TopologicalSpace.NonemptyCompacts.toCloseds)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) (Î¸ : Real.Angle) : x = â‡‘(o.rotation Î¸) x â†” x = 0 âˆ¨ Î¸ = 0
{Î¹ : Type w} [Fintype Î¹] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [Module.Finite K L] {R : Type z} [CommRing R] [Algebra R K] [Algebra R L] [isScalarTower R K L] {b : Î¹ â†’ L} (h : âˆ€ (i : Î¹), IsIntegral R (b i)) : IsIntegral R (Algebra.discr K b)
{ð•œ : Type u_3} [is_R_or_C ð•œ] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {H : Type u_5} [NormedGroup H] [normedSpace ð•œ H] {f : G â†’ H} {f' : G â†’ (G â†’L[ð•œ] H)} {x : G} (hder : âˆ€á¶  (y : G) in nhds x, HasFderivAt f (f' y) y) (hcont : ContinuousAt f' x) : HasStrictFderivAt f (f' x) x
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) [Nontrivial Î²] : Nontrivial Î±
{ð•œ : Type u_3} {E : Type u_4} [SemiNormedRing ð•œ] [AddCommGroup E] [Module ð•œ E] (p : Seminorm ð•œ E) (x y : E) : â‡‘p x â‰¤ â‡‘p y + â‡‘p (x - y)
{Î² Î± : Type u} (f : Î² â†’ Î±) (w : Cardinal.mk Î± < Cardinal.mk Î²) (w' : Cardinal.aleph_0 â‰¤ Cardinal.mk Î±) : âˆƒ (a : Î±), Cardinal.mk Î± < Cardinal.mk â†¥(f â»Â¹' {a})
{Î± : sort u_1} (hH : Î±) {Î² : Prop} (x : Tactic.CalculatedProp Î² hH . "derive_elementwise_proof") : Î²
{R : Type u} [Semiring R] {p : Polynomial R} {n : â„•} : p.degree â‰¤ â†‘n â†’ p.nat_degree â‰¤ n
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [orderedSemiring ð•œ] [AddCommGroup E] [Module ð•œ E] {p : Î¹ â†’ E} (hc : ConvexIndependent ð•œ p) : Function.Injective p
{Î± : Type u} [completeLattice Î±] {J : Type u} [CategoryTheory.SmallCategory J] (F : J â¥¤ Î±) : CategoryTheory.Limits.colimit F = supr F.obj
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f g : Î± â†’ M} {s : Set Î±} (hs : s.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i + g i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), g i))
{E : Type u} [NormedGroup E] [normedSpace â„ E] {f : â„ â†’ E} {f' : E} {s : Set â„} {x r : â„} (hF : HasDerivWithinAt f f' s x) (hr : âˆ¥f'âˆ¥ < r) : âˆ€á¶  (z : â„) in nhdsWithin x s, âˆ¥z - xâˆ¥â»Â¹ * (âˆ¥f zâˆ¥ - âˆ¥f xâˆ¥) < r
{m : Type u} {Î± : Type v} [CommRing Î±] [Fintype m] [DecidableEq m] (u v : m â†’ Î±) : (1 + (Matrix.col u).mul (Matrix.row v)).det = 1 + Matrix.dotProduct v u
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.PosMulStrictMono Î±] (ha : a â‰¤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) : 0 â‰¤ s.circumradius
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [CommMonoid Î²] [CommMonoid Î³] (g : Î² â†’* Î³) (f : Î± â†’ Î²) (s : Finset Î±) : â‡‘g (s.prod (Î» (x : Î±), f x)) = s.prod (Î» (x : Î±), â‡‘g (f x))
{C : Type u} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryProduct A B] [CategoryTheory.Limits.HasBinaryProduct A' B'] [CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')] (f : A âŸ¶ A') (g : B âŸ¶ B') [CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)] [CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A' B')] : CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B) â‰« F.map (CategoryTheory.Limits.prod.map f g) = CategoryTheory.Limits.prod.map (F.map f) (F.map g) â‰« CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A' B')
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {s : Set P} (h : affineSpan k s = âŠ¤) : vectorSpan k s = âŠ¤
{Î± : Type u_1} [pseudoEmetricSpace Î±] {Î´Seq : â„• â†’ â„} (Î´Seq_Pos : âˆ€ (n : â„•), 0 < Î´Seq n) (Î´Seq_lim : Filter.Tendsto Î´Seq Filter.atTop (nhds 0)) (E : Set Î±) : Filter.Tendsto (Î» (n : â„•), â‡‘(thickenedIndicator _ E)) Filter.atTop (nhds ((Closure E).indicator (Î» (x : Î±), 1)))
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle â„ P) (i : Fin 3) : affineSpan â„ {t.orthocenter, t.points i} â‰¤ Affine.Simplex.altitude t i
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {E' : Type u_4} [NormedGroup E'] [normedSpace ð•œ E'] {F' : Type u_5} [NormedGroup F'] [normedSpace ð•œ F'] {s : Set E} {t : Set E'} {f : E â†’ F} {g : E' â†’ F'} (hF : ContDiffOn ð•œ n f s) (hg : ContDiffOn ð•œ n g t) : ContDiffOn ð•œ n (Prod.map f g) (s Ã—Ë¢ t)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : F â†’ G} (hF : ContDiff ð•œ n f) : ContDiff ð•œ n (Î» (x : E Ã— F), f x.snd)
{Î± : Type u_1} [DecidableEq Î±] {s : Finset Î±} : s.nonempty â†’ s.sym2.nonempty
{M : Type u_4} [topologicalSpace M] [Monoid M] [HasContinuousMul M] {U : Set M} (hU : U âˆˆ nhds 1) : âˆƒ (V : Set M), is_IsOpen V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscreteNormedField ð•œ] [NormedGroup E] [normedSpace ð•œ E] [NormedGroup F] [normedSpace ð•œ F] {p : FormalMultilinearSeries ð•œ E F} {x : E} (h : HasFpowerSeriesAt 0 p x) (n : â„•) (y : E) : â‡‘(p n) (Î» (i : Fin n), y) = 0
{Î± : Type u} {Î² : Type v} [pseudoMetricSpace Î±] [pseudoMetricSpace Î²] {K : Nnreal} {f : Î± â†’ Î²} : LipschitzWith K f â†’ âˆ€ (x y : Î±), HasDist.dist (f x) (f y) â‰¤ â†‘K * HasDist.dist x y
(R : Type u) [Ring R] [StrongRankCondition R] {Î¹ : Type v} [Fintype Î¹] (M : Î¹ â†’ Type w) [Î  (i : Î¹), AddCommGroup (M i)] [Î  (i : Î¹), Module R (M i)] [âˆ€ (i : Î¹), Module.Free R (M i)] [âˆ€ (i : Î¹), Module.Finite R (M i)] : FiniteDimensional.finrank R (DirectSum Î¹ (Î» (i : Î¹), M i)) = finset.univ.sum (Î» (i : Î¹), FiniteDimensional.finrank R (M i))
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [orderedAddCommMonoid Î²] [Module ð•œ E] [HasScalar ð•œ Î²] {s : Set E} {f : E â†’ Î²} (hF : ConcaveOn ð•œ s f) (c : E) : ConcaveOn ð•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] [denselyOrdered Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhdsWithin a (Set.Iic a) â†” âˆƒ (l : Î±), l < a âˆ§ Set.Icc l a âŠ† s
{p a b : â„•} (hab : a.coprime b) (hpb : p âˆˆ b.factors) : â‡‘((a * b).factorization) p = â‡‘(b.factorization) p
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] {x : B} (hx : IsIntegral A x) : 0 < (minpoly A x).degree
{g : â„‚ â†’L[â„] â„‚} : IsConformalMap g â†” ((âˆƒ (Map : â„‚ â†’L[â„‚] â„‚), ContinuousLinearMap.restrictScalars â„ Map = g) âˆ¨ âˆƒ (Map : â„‚ â†’L[â„‚] â„‚), ContinuousLinearMap.restrictScalars â„ Map = g.comp â†‘Complex.conjCle) âˆ§ g â‰  0
{Î± : Type u_1} [HasLe Î±] {a : Î±} : IsMin a â†’ IsMax (â‡‘OrderDual.toDual a)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle (-x) y + hb.oangle (-y) z + hb.oangle (-z) x = â†‘Real.pi
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : Real.sin (InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = 0
(m n : â„•) : Nat.fib (m.gcd n) = (Nat.fib m).gcd (Nat.fib n)
{p : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero â†‘â†‘p] [hpri : Fact (Nat.Prime â†‘p)] [hcyc : IsCyclotomicExtension {p} K L] (hirr : Irreducible (Polynomial.cyclotomic â†‘p K)) (h : p â‰  2) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta p K L - 1) = â†‘p
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [hasNorm E] [semiNormedGroup F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : f =o[l] g' â†’ (f =o[l] Î» (x : Î±), -g' x)
(x : â„) : Real.sqrt (1 + Real.sinh x ^ 2) = Real.cosh x
{Î± : Type u_1} [completeLattice Î±] {a : Î±} {s : Set Î±} : (â¨† (b : Î±) (H : b âˆˆ s), a âŠ“ b) â‰¤ a âŠ“ HasSup.sup s
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) (x : M â§¸ S) : 0 â‰¤ âˆ¥xâˆ¥
{Î± : Type u} {f g : Î± â†’ Î±} (h : Function.Commute f g) : Set.BijOn g (Function.FixedPoints (f âˆ˜ g)) (Function.FixedPoints (f âˆ˜ g))
{i : â„•} {f g : â„• â†’ â„} (h0 : âˆ€ (b : â„•), 0 â‰¤ f b) (h : âˆ€ (b : â„•), f b â‰¤ g b) (hi : f i < g i) (hg : Summable g) : âˆ‘' (n : â„•), f n < âˆ‘' (n : â„•), g n
{Î± : Type u} [topologicalSpace Î±] {S U Z : Set Î±} (hZ : IsPreirreducible Z) (hU : U.nonempty) (hU' : is_IsOpen U) (hâ‚ : U âŠ† S) (hâ‚‚ : S âŠ† Z) : IsIrreducible S
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] [t1_Space Î²] {f : Î± â†’ Î²} {a : Î±} {b : Î²} (h : Filter.Tendsto f (nhds a) (nhds b)) : ContinuousAt f a
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) {Î² : Type u_1} (s : Finset Î²) (f : Î² â†’ n â†’ Î±) : s.sum (Î» (x : Î²), â‡‘(A.cramer) (f x)) = â‡‘(A.cramer) (s.sum (Î» (x : Î²), f x))
{M : Type u_3} {N : Type u_4} [hasAdd M] [hasAdd N] (f : AddHom M N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
(p : â„•) [Fact (Nat.Prime p)] (hp : p â‰  2) : Zmod.legendreSym p (-1) = â‡‘ZmodÏ‡â‚„ â†‘p
{J : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] (p : Set J) {jâ‚€ : J} (h0 : jâ‚€ âˆˆ p) (h1 : âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ (jâ‚ âˆˆ p â†” jâ‚‚ âˆˆ p)) (j : J) : j âˆˆ p
{Î± : Type u} [MulOneClass Î±] [HasDistribNeg Î±] (a : Î±) : a * -1 = -a
{G : Type u_1} [Group G] [topologicalSpace G] [TopologicalGroup G] [t2_Space G] {Kâ‚€ : TopologicalSpace.PositiveCompacts G} (g : G) (K : TopologicalSpace.Compacts G) : â‡‘(MeasureTheory.Measure.Haar.haarContent Kâ‚€) (TopologicalSpace.Compacts.map (Î» (b : G), g * b) _ K) = â‡‘(MeasureTheory.Measure.Haar.haarContent Kâ‚€) K
{Î± : Type u} [orderedSemiring Î±] [Nontrivial Î±] : 0 < 3
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} {C : â„} (hF : âˆ€ (x : â„), x âˆˆ Set.Icc a b â†’ HasDerivWithinAt f (f' x) (Set.Icc a b) x) (bound : âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ C) (x : â„) (H : x âˆˆ Set.Icc a b) : âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
{Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ Set Î±} (hs : IndexedPartition s) (x : hs.quotient) : hs.index (quotient.out' x) = hs.index (â‡‘(hs.out) x)
{n : â„•} {iâ‚ iâ‚‚ : Fin (n + 3)} (h : iâ‚ â‰  iâ‚‚) : Affine.Simplex.mongePointVsubFaceCentroidWeightsWithCircumcenter iâ‚ iâ‚‚ = Affine.Simplex.mongePointWeightsWithCircumcenter n - Affine.Simplex.centroidWeightsWithCircumcenter {iâ‚, iâ‚‚}á¶œ
{Î± : Type u_1} [LinearOrder Î±] (a : Î±) : {a}.max' _ = a
{f : â„• â†’. â„•} : Nat.Partrec f â†” âˆƒ (c : Nat.Partrec.Code), c.eval = f
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {aâ‚ aâ‚‚ aâ‚ƒ : Î±} {bâ‚ bâ‚‚ bâ‚ƒ : Î²} (qâ‚ : Path.Homotopic.Quotient aâ‚ aâ‚‚) (qâ‚‚ : Path.Homotopic.Quotient bâ‚ bâ‚‚) (râ‚ : Path.Homotopic.Quotient aâ‚‚ aâ‚ƒ) (râ‚‚ : Path.Homotopic.Quotient bâ‚‚ bâ‚ƒ) : (Path.Homotopic.prod qâ‚ qâ‚‚).comp (Path.Homotopic.prod râ‚ râ‚‚) = Path.Homotopic.prod (qâ‚.comp râ‚) (qâ‚‚.comp râ‚‚)
{C : Type uâ‚} [CategoryTheory.Category C] {X Y Z : C} {c : CategoryTheory.Limits.BinaryFan X Y} (h : CategoryTheory.Limits.IsLimit c) (t : CategoryTheory.Limits.IsTerminal Z) : CategoryTheory.IsPullback c.fst c.snd (t.from ((CategoryTheory.Limits.pair X Y).obj {as := CategoryTheory.Limits.WalkingPair.left})) (t.from ((CategoryTheory.Limits.pair X Y).obj {as := CategoryTheory.Limits.WalkingPair.right}))
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] [LocallyCompactSpace Î±] : Continuous (Î» (p : C(Î±, Î²) Ã— Î±), â‡‘(p.fst) p.snd)
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : Real.cos (InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = -Real.cos (InnerProductGeometry.angle x y)
{R : Type u_1} {a : R} [AddSemigroup R] (b : R) (ha : IsAddLeftRegular a) : IsAddLeftRegular (a + b) â†” IsAddLeftRegular b
{Î± : Type u} [pseudoMetricSpace Î±] (B : â„• â†’ â„) (hB : âˆ€ (n : â„•), 0 < B n) (H : âˆ€ (u : â„• â†’ Î±), (âˆ€ (N n m : â„•), N â‰¤ n â†’ N â‰¤ m â†’ HasDist.dist (u n) (u m) < B N) â†’ (âˆƒ (x : Î±), Filter.Tendsto u Filter.atTop (nhds x))) : CompleteSpace Î±
{E : Type u_2} [semiNormedGroup E] [normedSpace â„ E] {s : Set E} {x : E} (hx : x âˆˆ â‡‘(convexHull â„) s) (y : E) : âˆƒ (x' : E) (H : x' âˆˆ s), HasDist.dist x y â‰¤ HasDist.dist x' y
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f g : ContinuousMultilinearMap ð•œ E G) : âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
{G : Type w} [topologicalSpace G] [hasInv G] [hasMul G] [HasContinuousMul G] (g : G) : Continuous (Î» (h : G), g * h * gâ»Â¹)
{Î± : Type u_1} [metricSpace Î±] (t : Set (Set Î±)) (R : â„) (ht : âˆ€ (s : Set Î±), s âˆˆ t â†’ (âˆƒ (x : Î±) (r : â„), s = Metric.ClosedBall x r âˆ§ r â‰¤ R)) : âˆƒ (u : Set (Set Î±)) (H : u âŠ† t), u.pairwise_Disjoint Id âˆ§ âˆ€ (a : Set Î±), a âˆˆ t â†’ (âˆƒ (x : Î±) (r : â„), Metric.ClosedBall x r âˆˆ u âˆ§ a âŠ† Metric.ClosedBall x (5 * r))
{ð•œ : Type u_1} [linearOrderedField ð•œ] {x y : ð•œ} (h : x < y) {z : ð•œ} : z âˆˆ Set.Ico x y â†” âˆƒ (a b : ð•œ), 0 < a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
{R : Type uâ‚} [Monoid R] [HasDistribNeg R] (a : R) : (-a) ^ 2 = a ^ 2
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] [NoZeroDivisors R] [Nontrivial R] : NoZeroSmulDivisors R M â†” Submodule.torsion R M = âŠ¥
{E : â„• â†’ Type u_1} [Î  (n : â„•), topologicalSpace (E n)] [âˆ€ (n : â„•), discreteTopology (E n)] {x y : Î  (n : â„•), E n} {s : Set (Î  (n : â„•), E n)} (hs : is_IsClosed s) (hne : s.nonempty) (H : PiNat.longestPrefix x s < PiNat.firstDiff x y) (xs : x âˆ‰ s) (ys : y âˆ‰ s) : PiNat.Cylinder x (PiNat.longestPrefix x s) = PiNat.Cylinder y (PiNat.longestPrefix y s)
{Î± : Type u_1} {Î² : Type u_2} {e e' : LocalEquiv Î± Î²} (hE : e â‰ˆ e') (s : Set Î±) : e.restr s â‰ˆ e'.restr s
{R : Type x} [CommRing R] (a b : R) : a * a - b * b = (a + b) * (a - b)
{Mâ‚€ : Type u_1} {Mâ‚€' : Type u_3} [hasMul Mâ‚€] [hasZero Mâ‚€] [hasMul Mâ‚€'] [hasZero Mâ‚€'] [NoZeroDivisors Mâ‚€'] (f : Mâ‚€ â†’ Mâ‚€') (hF : Function.Injective f) (Zero : f 0 = 0) (Mul : âˆ€ (x y : Mâ‚€), f (x * y) = f x * f y) : NoZeroDivisors Mâ‚€
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] [LocallyCompactSpace Î±] [LocallyCompactSpace Î²] : Continuous ContinuousMap.uncurry
{Î± : Type u_1} {n : Type u_4} [AddGroup n] {v : n â†’ Î±} (h : (Matrix.circulant v).is_Symm) (i : n) : v (-i) = v i
{Î± : Type u} {a : Set Î±} (h : a.finite) : {b : Set Î± | b âŠ† a}.finite
{Î± : Type u_1} {Î¹ : sort u_2} [Nonempty Î¹] (m : Î¹ â†’ MeasureTheory.OuterMeasure Î±) (s : Set Î±) : (â‡‘â¨… (i : Î¹), m i) s = â¨… (t : â„• â†’ Set Î±) (h2 : s âŠ† Set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹), â‡‘(m i) (t n)
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] (c : AddCon M) (f : M â†’+ P) (H : c â‰¤ AddCon.ker f) (h : Function.Injective â‡‘(c.lift f H)) : AddCon.ker f = c
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {A B C : Matrix n n Î±} (h : A.mul B = 1) (g : A.mul C = 1) : B = C
{Î± : Type u} (f : Filter Î±) [h : f.ne_IsBot] : âˆƒ (u : Ultrafilter Î±), â†‘u â‰¤ f
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {x y : V} (h : hb.oangle x y = 0) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{G : Type u_1} [topologicalSpace G] [Group G] [TopologicalGroup G] (N : Subgroup G) [N.normal] : N.topological_closure.normal
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [Ring R] [AddCommGroup M] [Module R M] : LinearIndependent R v â†’ Function.Injective â‡‘(Finsupp.total Î¹ M R v)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {s1 s2 : AffineSubspace k P} (h : s1 < s2) : âˆƒ (p : P) (H : p âˆˆ s2), p âˆ‰ s1
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {f : Î± â†’ Î²} {s : Set Î±} : MonotoneOn f s â†’ AntitoneOn (â‡‘OrderDual.toDual âˆ˜ f) s
(K : Type u) [divisionRing K] {n : â„•} : FiniteDimensional.finrank K (Fin n â†’ K) = n
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (p : P) : p -áµ¥ p = 0
{Î± : Type u_1} [hasMul Î±] [Preorder Î±] [CovariantClass Î± Î± Mul.mul LE.le] [CovariantClass Î± Î± (Function.swap Mul.mul) LT.lt] {a b c d : Î±} (hâ‚ : a < b) (hâ‚‚ : c < d) : a * c < b * d
{Î± : Type u} [pseudoMetricSpace Î±] [Preorder Î±] [CompactIccSpace Î±] {s : Set Î±} (hâ‚ : BddAbove s) (hâ‚‚ : BddBelow s) : Metric.Bounded s
{M : Type u_1} [AddMonoid M] {x : M} (m : â„•) {n : â„•} (h : n â€¢ x = 0) : m â€¢ x = (m % n) â€¢ x
{F : Type u_3} [innerProductSpace â„ F] {x y : F} : HasInner.inner (x - y) (x - y) = HasInner.inner x x - 2 * HasInner.inner x y + HasInner.inner y y
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] [CompleteSpace F] [CompleteSpace E] (g : E â†’â‚—[ð•œ] F) (hg : âˆ€ (u : â„• â†’ E) (x : E) (y : F), Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (â‡‘g âˆ˜ u) Filter.atTop (nhds y) â†’ y = â‡‘g x) : Continuous â‡‘g
{C : Type u} [CategoryTheory.Category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) (R S : CategoryTheory.Sieve X) (hR : CategoryTheory.Presieve.IsSheafFor P â‡‘R) (hR' : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, â‡‘S f â†’ CategoryTheory.Presieve.IsSeparatedFor P â‡‘(CategoryTheory.Sieve.pullback f R)) (hS : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, â‡‘R f â†’ CategoryTheory.Presieve.IsSheafFor P â‡‘(CategoryTheory.Sieve.pullback f S)) : CategoryTheory.Presieve.IsSheafFor P â‡‘S
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {c : â„} {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : asymptotics.is_O_with c l f g â†” âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] (f : MultilinearMap R Mâ‚ Mâ‚‚) {Î± : Î¹ â†’ Type u_1} (g : Î  (i : Î¹), Î± i â†’ Mâ‚ i) (A : Î  (i : Î¹), Finset (Î± i)) [Fintype Î¹] {n : â„•} (h : finset.univ.sum (Î» (i : Î¹), (A i).card) = n) : â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (Fintype.piFinset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} {c : CategoryTheory.Limits.Cofork f g} (h : CategoryTheory.Limits.IsColimit c) [CategoryTheory.Mono c.Ï€] : CategoryTheory.IsIso c.Ï€
{M : Type u_3} {N : Type u_4} [AddMonoid M] [AddMonoid N] (f : M â†’+ N) (l : List M) : â‡‘f l.sum = (List.map â‡‘f l).sum
{Î± : Type u_1} (P : Î± â†’ Prop) (r : Î± â†’ Î± â†’ Prop) [IsSymm Î± r] (h : âˆ€ (s : Finset Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ P x) â†’ (âˆƒ (y : Î±), P y âˆ§ âˆ€ (x : Î±), x âˆˆ s â†’ r x y)) : âˆƒ (f : â„• â†’ Î±), (âˆ€ (n : â„•), P (f n)) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ r (f m) (f n)
(p : â„•) [Fact (Nat.Prime p)] (x : (Zmod p)Ë£) : (âˆƒ (y : (Zmod p)Ë£), y ^ 2 = x) â†” x ^ (p / 2) = 1
{B : Type u} [Quiver B] {a b c : B} (p : Quiver.Path a b) {f g : CategoryTheory.FreeBicategory.Hom b c} (Î· : f âŸ¶ g) : CategoryTheory.FreeBicategory.normalizeAux p f = CategoryTheory.FreeBicategory.normalizeAux p g
{r : â„} (tr : Transcendental â„š r) : Irrational r
{E : Type u_2} [AddCommGroup E] [Module â„ E] (s : ConvexCone â„ E) (f : LinearPmap â„ E â„) (nonneg : âˆ€ (x : â†¥(f.domain)), â†‘x âˆˆ s â†’ 0 â‰¤ â‡‘f x) (Dense : âˆ€ (y : E), âˆƒ (x : â†¥(f.domain)), â†‘x + y âˆˆ s) : âˆƒ (g : E â†’â‚—[â„] â„), (âˆ€ (x : â†¥(f.domain)), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ€ (x : E), x âˆˆ s â†’ 0 â‰¤ â‡‘g x
{Î± : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : Î± â†’ M} {s : Set Î±} (p : M â†’ Prop) (hpâ‚€ : p 0) (hpâ‚ : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (hpâ‚‚ : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)))
{M : Type u_1} [AddMonoid M] {x y z : M} : y âˆˆ Multiples x â†’ z âˆˆ Multiples x â†’ y + z âˆˆ Multiples x
{n : â„•} {E : Type u_1} [NormedGroup E] (a : E) (c : Fin n â†’ â„‚) (R : Fin n â†’ â„) : TorusIntegrable (Î» (_x : Fin n â†’ â„‚), a) c R
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) (Î¸ : Real.Angle) : hb.oangle (â‡‘(hb.rotation Î¸) x) (â‡‘(hb.rotation Î¸) y) = hb.oangle x y
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {x : E} {r : ð•œ} (hx : x â‰  0) (hr : r â‰  0) : is_R_or_C.abs (HasInner.inner x (r â€¢ x)) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [hasZero M] [AddCommMonoid N] [DecidableEq Î±] (f : Î± â†’â‚€ M) (a : Î±) (b : Î± â†’ M â†’ N) : f.sum (Î» (x : Î±) (v : M), Ite (x = a) (b x v) 0) = Ite (a âˆˆ f.support) (b a (â‡‘f a)) 0
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) {r : â„} (hr : 0 â‰¤ r) : hb.oangle x (r â€¢ x) = 0
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
{R : Type u_1} [linearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {x y : M} (h : SameRay R x y) (hx : x â‰  0) : âˆƒ (r : R), 0 â‰¤ r âˆ§ r â€¢ x = y
{L : FirstOrder.Language} (M : Type w') [L.Structure M] [im : Infinite M] (Îº : Cardinal) (h1 : L.card.lift â‰¤ Îº.lift) (h2 : (Cardinal.mk M).lift â‰¤ Îº.lift) : âˆƒ (N : CategoryTheory.Bundled L.Structure), Nonempty (L.elementary_Embedding M â†¥N) âˆ§ Cardinal.mk â†¥N = Îº.lift
{Î± : Type u} {Î² : Type v} : (Cardinal.mk Î±).lift â‰¤ (Cardinal.mk Î²).lift â†” Nonempty (Î± â†ª Î²)
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} : Metric.hausdorffDist âˆ… s = 0
{K : Type v} {V : Type w} [Field K] [AddCommGroup V] [Module K V] (f : Module.End K V) : CompleteLattice.Independent f.eigenspace
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (P : Cáµ’áµ– â¥¤ A) {X : C} (S : CategoryTheory.Sieve X) : (âˆ€ (c : CategoryTheory.Limits.Cone (S.arrows.diagram.op â‹™ P)), Subsingleton (c âŸ¶ P.map_cone S.arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), CategoryTheory.Presieve.IsSeparatedFor (P â‹™ Category_theory.coyoneda.obj E) â‡‘S
(L : List â„•) : L.head + L.tail.sum = L.sum
{a b : â„•} (ha : a â‰  0) (hb : b â‰  0) : (a * b).factors ~ a.factors ++ b.factors
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semiNormedGroup E] [semiNormedGroup F] [nondiscreteNormedField ð•œ] [nondiscreteNormedField ð•œâ‚‚] [normedSpace ð•œ E] [normedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’sl[Ïƒâ‚â‚‚] F) (x : E) : âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.PosMulStrictMono Î±] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
{Î¹ : Type u} (s : Finset Î¹) {f : Î¹ â†’ â„} {p : â„} (hp : 1 â‰¤ p) (hF : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ f i) : s.sum (Î» (i : Î¹), f i) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), f i ^ p)
{M : Type u_2} [AddCommGroup M] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] {A : Type u_5} [CommRing A] [Module A M] {Îº : Type u_6} [Fintype Îº] [DecidableEq Îº] (b : Basis Î¹ A M) (c : Basis Îº A M) (f : M â†’â‚—[A] M) : (â‡‘(LinearMap.toMatrix b b) f).det = (â‡‘(LinearMap.toMatrix c c) f).det
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [IsRefl Î± r] [IsTrans Î± r] {s : Set Î±} (h : s.partially_well_ordered_on r) : {l : List Î± | âˆ€ (x : Î±), x âˆˆ l â†’ x âˆˆ s}.partially_well_ordered_on (list.sublist_forallâ‚‚ r)
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] [CategoryTheory.HasProjectiveResolutions C] [CategoryTheory.Preadditive D] [CategoryTheory.Limits.HasZeroObject D] [CategoryTheory.Limits.HasEqualizers D] [CategoryTheory.Limits.HasCokernels D] [CategoryTheory.Limits.HasImages D] [CategoryTheory.Limits.HasImageMaps D] (F : C â¥¤ D) [F.additive] (n : â„•) {X Y : C} (f : X âŸ¶ Y) {P : CategoryTheory.projectiveResolution X} {Q : CategoryTheory.projectiveResolution Y} (g : P.complex âŸ¶ Q.complex) (w : g â‰« Q.Ï€ = P.Ï€ â‰« (chain_complex.singleâ‚€ C).map f) : (F.left_derived n).map f = (F.left_derived_obj_iso n P).hom â‰« (homologyFunctor D (ComplexShape.down â„•) n).map ((F.map_HomologicalComplex (ComplexShape.down â„•)).map g) â‰« (F.left_derived_obj_iso n Q).inv
{n : â„•} {Î² : Type u_1} (a : Î²) (q : Fin n â†’ Î²) (b : Î²) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b
{m n : â„•} (hmn : m.coprime n) : Squarefree (m * n) â†” Squarefree m âˆ§ Squarefree n
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 : P) {p2 p3 p4 : P} (h : EuclideanGeometry.angle p2 p3 p4 = Real.pi) : EuclideanGeometry.angle p1 p3 p2 + EuclideanGeometry.angle p1 p3 p4 = Real.pi
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚‚} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J â¥¤ C} [CategoryTheory.Limits.HasColimit F] {E : K â¥¤ J} [CategoryTheory.Limits.HasColimit (E â‹™ F)] (s : CategoryTheory.Limits.ColimitCocone (E â‹™ F)) (t : CategoryTheory.Limits.ColimitCocone F) : CategoryTheory.Limits.colimit.pre F E = (CategoryTheory.Limits.colimit.isoColimitCocone s).hom â‰« s.is_colimit.desc (CategoryTheory.Limits.Cocone.whisker E t.cocone) â‰« (CategoryTheory.Limits.colimit.isoColimitCocone t).inv
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasCoproducts C] : CategoryTheory.Limits.HasFiniteCoproducts C
{R : Type u_4} {S : Type u_5} [hasMul R] [hasAdd R] [hasMul S] [hasAdd S] (e : R â‰ƒ+* S) (x y : R) : â‡‘e (x * y) = â‡‘e x * â‡‘e y
{Î± : Type u} (s : Seq Î±) {aâ‚™ : Î±} {n m : â„•} (m_LE_n : m â‰¤ n) (s_nth_Eq_Some : s.nth n = Option.some aâ‚™) : âˆƒ (aâ‚˜ : Î±), s.nth m = Option.some aâ‚˜
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {f : Î± â†’ â„} (K : â„) (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + K * HasDist.dist x y) : LipschitzOnWith K.to_Nnreal f s
{n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n
{Î± : Type u} [uniformSpace Î±] (h : IsComplete Set.Univ) : CompleteSpace Î±
{Î± : Type u_1} [Preorder Î±] [locallyFiniteOrder Î±] {a b : Î±} : Â¬a < b â†’ Multiset.ico a b = 0
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] (f : MultilinearMap R Mâ‚ Mâ‚‚) (m m' : Î  (i : Î¹), Mâ‚ i) (t : Finset Î¹) : â‡‘f (t.piecewise (m + m') m') = t.powerset.sum (Î» (s : Finset Î¹), â‡‘f (s.piecewise m m'))
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î± â†’ Î³} {x : Î± Ã— Î²} (hF : ContinuousAt f x.fst) : ContinuousAt (Î» (x : Î± Ã— Î²), f x.fst) x
{p : â„•} (hp : Nat.Prime p) {R : Type u_1} [CommRing R] [is_IsDomain R] {n m : â„•} (hmn : m â‰¤ n) (h : Irreducible (Polynomial.cyclotomic (p ^ n) R)) : Irreducible (Polynomial.cyclotomic (p ^ m) R)
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] : 0 < FiniteDimensional.finrank K V â†” âˆƒ (x : V), x â‰  0
{Î¹ : Type u_1} {R : Type u_3} [Ring R] {M : Type u_2} [AddCommGroup M] [Module R M] {v : Î¹ â†’ M} (li : LinearIndependent R v) (c d : R) (i j : Î¹) (hc : c â‰  0) (h : c â€¢ v i = d â€¢ v j) : i = j
{Î± : Type u} [SemilatticeInf Î±] [OrderTop Î±] {x y z : Î±} (f : x âŸ¶ z) (g : y âŸ¶ z) : CategoryTheory.Limits.pullback f g = x âŠ“ y
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [BaireSpace Î±] {S : Set Î²} {f : Î  (x : Î²), x âˆˆ S â†’ Set Î±} (ho : âˆ€ (s : Î²) (H : s âˆˆ S), is_GÎ´ (f s H)) (hS : S.countable) (hD : âˆ€ (s : Î²) (H : s âˆˆ S), Dense (f s H)) : Dense (â‹‚ (s : Î²) (H : s âˆˆ S), f s H)
{Î± : Type u_1} [metricSpace Î±] {Î² : Type u} [Nonempty Î²] (p : Besicovitch.TauPackage Î² Î±) {i : Ordinal} (hi : i < p.last_step) {N : â„•} (hN : isEmpty (Besicovitch.SatelliteConfig Î± N p.Ï„)) : p.color i < N
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) : Summable (Î» (i : Î¹), âˆ¥HasInner.inner (v i) xâˆ¥ ^ 2)
{X : Type u_1} [topologicalSpace X] [SequentialSpace X] {s : Set X} {a : X} : a âˆˆ Closure s â†” âˆƒ (x : â„• â†’ X), (âˆ€ (n : â„•), x n âˆˆ s) âˆ§ Filter.Tendsto x Filter.atTop (nhds a)
{R : Type u} {S : Type v} [Ring R] [Ring S] {f g : R â†’+* S} {s : Set R} (h : Set.EqOn â‡‘f â‡‘g s) : Set.EqOn â‡‘f â‡‘g â†‘(Subring.closure s)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) {i : Î¹} (his : i âˆˆ s) (hwi : w i = 1) (hw0 : âˆ€ (i2 : Î¹), i2 âˆˆ s â†’ i2 â‰  i â†’ w i2 = 0) : â‡‘(s.affine_combination p) w = p i
{Î± : Type u} [pseudoEmetricSpace Î±] {f : â„• â†’ Î±} (n : â„•) {d : â„• â†’ Ennreal} (hD : âˆ€ {k : â„•}, k < n â†’ HasEdist.edist (f k) (f (k + 1)) â‰¤ d k) : HasEdist.edist (f 0) (f n) â‰¤ (Finset.range n).sum (Î» (i : â„•), d i)
{T : â„} {g : â„ â†’ â„} (hg : Function.Periodic g T) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.MeasureSpace.volume tâ‚ tâ‚‚) (hâ‚€ : 0 < âˆ« (x : â„) in 0..T, g x) (hT : 0 < T) : Filter.Tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) Filter.atTop Filter.atTop
{p : â„•} [p_Prime : Fact (Nat.Prime p)] {a : â„¤} : multiplicity.Finite â†‘p a â†” a â‰  0
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : HasInner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥) â†” InnerProductGeometry.angle x y = Real.pi
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} (ha : a â‰  0) : char.quadratic_Char F a ^ 2 = 1
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] (g : G â†’L[ð•œ] E) : IsBoundedLinearMap ð•œ (Î» (f : ContinuousMultilinearMap ð•œ (Î» (i : Î¹), E) F), f.comp_ContinuousLinearMap (Î» (_x : Î¹), g))
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] {ifp_n : GeneralizedContinuedFraction.IntFractPair K} (nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n) : 0 â‰¤ ifp_n.fr âˆ§ ifp_n.fr < 1
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) : IsUnit A â†” IsUnit A.det
{Î± : Type u_1} (f : Set Î± â†’ Î±) : Â¬Function.Injective f
{R : Type u_2} [CommRing R] [is_IsDomain R] [Fintype R] {f g : Polynomial R} (hF2 : f.degree = 2) (hg2 : g.degree = 2) (hR : Fintype.card R % 2 = 1) : âˆƒ (a b : R), Polynomial.eval a f + Polynomial.eval b g = 0
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} {sâ‚ sâ‚‚ : Affine.Simplex â„ P n} (h : Set.Range sâ‚.points = Set.Range sâ‚‚.points) : sâ‚.monge_point = sâ‚‚.monge_point
{Î± : Type u_1} [Preorder Î±] [succOrder Î±] {a : Î±} : Â¬IsMax a â†’ a < Order.succ a
{R : Type u_4} {S : Type u_5} [Semiring R] [Semiring S] (f : R â‰ƒ+* Sáµáµ’áµ–) (l : List R) : MulOpposite.unop (â‡‘f l.prod) = (List.map (MulOpposite.unop âˆ˜ â‡‘f) l).reverse.prod
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] {f : X â†’ Y} [SequentialSpace X] : SeqContinuous f â†’ Continuous f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {m n : WithTop â„•} {s : Set E} {f : E â†’ F} (hF : ContDiffOn ð•œ n f s) (hs : UniqueDiffOn ð•œ s) (hmn : m + 1 â‰¤ n) : ContDiffOn ð•œ m (Î» (p : E Ã— E), â‡‘(fderivWithin ð•œ f s p.fst) p.snd) (s Ã—Ë¢ Set.Univ)
(G : Type u_1) [AddMonoid G] : Â¬Add_monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  0 âˆ§ IsOfFinAddOrder g
{G : Type u} [Fintype G] [addLeftCancelMonoid G] (x : G) : 0 < addOrderOf x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘(s.weighted_vsub p) w = s.sum (Î» (i : Î¹), w i â€¢ (p i -áµ¥ Classical.choice AddTorsor.nonempty))
{M : Type u_1} [hasMul M] (s : Set M) {p : Î  (x : M), x âˆˆ Subsemigroup.closure s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (HMul : âˆ€ (x : M) (hx : x âˆˆ Subsemigroup.closure s) (y : M) (hy : y âˆˆ Subsemigroup.closure s), p x hx â†’ p y hy â†’ p (x * y) _) {x : M} (hx : x âˆˆ Subsemigroup.closure s) : p x hx
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} (hs : s.nonempty) (bs : Metric.Bounded s) (ht : t.nonempty) (bt : Metric.Bounded t) : Metric.hausdorffDist s t â‰¤ Metric.diam (s âˆª t)
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topologicalSpace Î²] (f : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (x : Î±) (y : Î²) : y âˆˆ OmegaLimit f Ï• {x} â†” MapClusterPt y f (Î» (t : Ï„), Ï• t x)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
{M : Type u_1} [hasMul M] {s : Set M} : s âŠ† â†‘(Subsemigroup.closure s)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [linearOrderedAddCommMonoid Î²] [HasScalar ð•œ E] [Module ð•œ Î²] [OrderedSmul ð•œ Î²] {s : Set E} {f g : E â†’ Î²} (hF : ConvexOn ð•œ s f) (hg : ConvexOn ð•œ s g) : ConvexOn ð•œ s (f âŠ” g)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semiNormedGroup E] [semiNormedGroup F] [semiNormedGroup G] {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} (hF : Filter.Tendsto f l (nhds 0)) (hg : Filter.IsBoundedUnder LE.le l (HasNorm.norm âˆ˜ g)) (Op : E â†’ F â†’ G) (h_Op : âˆƒ (A : â„), âˆ€ (x : E) (y : F), âˆ¥Op x yâˆ¥ â‰¤ A * âˆ¥xâˆ¥ * âˆ¥yâˆ¥) : Filter.Tendsto (Î» (x : Î±), Op (f x) (g x)) l (nhds 0)
(m : â„•) : padicValRat m 0 = 0
{M : Type u_1} [hasAdd M] {c : AddCon M} (x y : M) : â†‘(x + y) = â†‘x + â†‘y
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] (f : C(Î± Ã— Î², Î³)) : Continuous f.curry'
{E : Type u_1} [AddCommGroup E] [Module â„ E] {s : Set E} : gauge s 0 = 0
{Î± : Type u_1} {Î² : Type u_2} {Î´ : Type u_4} [AddCommMonoid Î±] [topologicalSpace Î±] [t2_Space Î±] [completeLattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (R : Î± â†’ Î± â†’ Prop) (m_supr : âˆ€ (s : â„• â†’ Î²), R (m (â¨† (i : â„•), s i)) (âˆ‘' (i : â„•), m (s i))) (s : Î´ â†’ Î²) (t : Finset Î´) : R (m (â¨† (d : Î´) (H : d âˆˆ t), s d)) (t.sum (Î» (d : Î´), m (s d)))
{Î± : Type u} {Î² : Type v} : (Cardinal.mk Î±).lift = (Cardinal.mk Î²).lift â†” Nonempty (Î± â‰ƒ Î²)
{Î± : Type u_1} [CancelCommMonoidWithZero Î±] [UniqueFactorizationMonoid Î±] [normalizationMonoid Î±] [DecidableEq Î±] {n : Î±} : (factorization n).support = (UniqueFactorizationMonoid.normalizedFactors n).to_Finset
{Î± : Type u_2} [DecidableEq Î±] [hasDiv Î±] {u : Finset Î±} {s t : Set Î±} : â†‘u âŠ† s / t â†’ (âˆƒ (s' t' : Finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' / t')
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : InnerProductGeometry.angle x (x - y) = InnerProductGeometry.angle y (y - x)
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S T : Set E) : â†‘(IntermediateField.adjoin â†¥(IntermediateField.adjoin F S) T) = IntermediateField.adjoin F (S âˆª T)
{R : Type u_1} [Semiring R] {x y : R} (h : Commute x y) (n : â„•) : (x + y) ^ n = (Finset.Nat.antidiagonal n).sum (Î» (m : â„• Ã— â„•), n.choose m.fst â€¢ (x ^ m.fst * y ^ m.snd))
{Î± : sort u_1} {sâ‚ : Setoid Î±} {p : Quotient sâ‚ â†’ Prop} (q : Quotient sâ‚) (h : âˆ€ (a : Î±), p (Quotient.mk' a)) : p q
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Ring R] [AddCommGroup N] [Module R N] {p : Î¹ â†’ Submodule R N} (h : CompleteLattice.Independent p) : Function.Injective â‡‘(â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype))
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : NonAssocSemiring Î±} {rÎ² : NonAssocSemiring Î²} (f : Î± â†’+* Î²) (a b : Î±) : â‡‘f (a * b) = â‡‘f a * â‡‘f b
{Î± : Type u_1} (L : List (List Î±)) {i j : â„•} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : (List.take i (List.map List.length L)).sum + j < (List.take (i + 1) (List.map List.length L)).sum
{Î± : sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆƒ (x : Î±) (h : p x), q x h) â†” âˆƒ (x : {a // p a}), q â†‘x _
{p : â„•} [Fact (Nat.Prime p)] (x : Zmod p) : x ^ p = x
{M : Type u_1} {N : Type u_2} [hasAdd M] [hasAdd N] {c : AddCon M} {d : AddCon N} {C : c.quotient â†’ d.quotient â†’ Prop} (p : c.quotient) (q : d.quotient) (H : âˆ€ (x : M) (y : N), C â†‘x â†‘y) : C p q
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurableSpace Î±} [topologicalSpace Î²] [TopologicalSpace.PseudoMetrizableSpace Î²] (u : Filter Î¹) [u.ne_IsBot] [u.is_countably_generated] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hF : âˆ€ (i : Î¹), MeasureTheory.StronglyMeasurable (f i)) (lim : Filter.Tendsto f u (nhds g)) : MeasureTheory.StronglyMeasurable g
{Î± : Type u} (p : Î± â†’ Prop) [DecidablePred p] (as : List Î±) : (List.zipWith Append.append (List.splitOn_p p as) (List.map (Î» (x : Î±), [x]) (List.filter p as) ++ [List.nil])).join = as
{M : Type u_1} [hasAdd M] (c : AddCon M) (x : M) : â‡‘c x x
{Î± : Type u_1} [CanonicallyOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b c : Î±} (h : c â‰¤ b) (h2 : a - c < b - c) : a < b
(S : Set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ 0) : HasSup.sup S â‰¤ 0
{Î± : Type u} [topologicalSpace Î±] {s t : Set Î±} (H : IsPreconnected s) (Kst : s âŠ† t) (Ktcs : t âŠ† Closure s) : IsPreconnected t
{X : Type u_2} [emetricSpace X] [TopologicalSpace.SecondCountableTopology X] (s : Set X) : (â¨† (x : X), (nhdsWithin x s).small_sets.limsup dimH) = dimH s
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} {S : Type u_3} [Monoid S] [DistribMulAction S M] [SmulCommClass R S M] (h : SameRay R x y) (s : S) : SameRay R (s â€¢ x) (s â€¢ y)
{G : Type u_6} {H : Type u_7} {F : Type u_8} [AddGroup G] [subtractionMonoid H] [addMonoidHomClass F G H] (f : F) (a b : G) : â‡‘f (a - b) = â‡‘f a - â‡‘f b
{Î± : Type u} {Î¹ : Type v} [metricSpace Î±] [ProperSpace Î±] {c : Î¹ â†’ Î±} {s : Set Î±} {r : Î¹ â†’ â„} (hs : is_IsClosed s) (uf : âˆ€ (x : Î±), x âˆˆ s â†’ {i : Î¹ | x âˆˆ Metric.Ball (c i) (r i)}.finite) (us : s âŠ† â‹ƒ (i : Î¹), Metric.Ball (c i) (r i)) : âˆƒ (r' : Î¹ â†’ â„), (s âŠ† â‹ƒ (i : Î¹), Metric.Ball (c i) (r' i)) âˆ§ âˆ€ (i : Î¹), r' i < r i
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {f : Î± â†’ Î²} (hF : IsAddGroupHom f) : IsAddMonoidHom f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P âŸ¶ Q) : (âˆ€ (a : â†¥P), â‡‘f a = 0 â†’ a = 0) â†’ CategoryTheory.Mono f
(V : Type u_1) [semiNormedGroup V] : âˆ¥NormedGroupHom.id Vâˆ¥ â‰¤ 1
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.IsIso (Category_theory.yoneda.map f)] : CategoryTheory.IsIso f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {s1 s2 : AffineSubspace k P} (h : s1 â‰¤ s2) : s1.direction â‰¤ s2.direction
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) {bâ‚‚ : Basis (Fin 2) â„ V} (hbâ‚‚ : Orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = -bâ‚‚.orientation) (Î¸ : Real.Angle) : hb.rotation Î¸ = hbâ‚‚.rotation (-Î¸)
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) (h_anti : AntitoneOn (deriv f) (Interior D)) : ConcaveOn â„ D f
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WidePullbackShape J) C] {B : C} : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete J) (CategoryTheory.Over B)
 : ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars â„ fourierSubalgebra)
{Î± : Type u_1} [topologicalSpace Î±] {S : Set (Set Î±)} (h : âˆ€ (s : Set Î±), s âˆˆ S â†’ is_GÎ´ s) (hS : S.countable) : is_GÎ´ (â‹‚â‚€ S)
{Î¹ : Type u_3} {Ï‡ : Î¹ â†’ Type u_4} [Î  (i : Î¹), topologicalSpace (Ï‡ i)] {as bs cs : Î  (i : Î¹), Ï‡ i} (Î³â‚€ : Î  (i : Î¹), Path (as i) (bs i)) (Î³â‚ : Î  (i : Î¹), Path (bs i) (cs i)) : (Path.pi Î³â‚€).trans (Path.pi Î³â‚) = Path.pi (Î» (i : Î¹), (Î³â‚€ i).trans (Î³â‚ i))
{Î± : Type u_1} {n : Type u_3} {A : Matrix n n Î±} : A.is_Symm â†” âˆ€ (i j : n), A j i = A i j
{Î± J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.FinCategory J] [SemilatticeSup Î±] [OrderBot Î±] (F : J â¥¤ Î±) : CategoryTheory.Limits.colimit F = finset.univ.sup F.obj
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {X Y Z X' Y' Z' : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [CategoryTheory.Limits.HasKernel g] (w : f â‰« g = 0) (f' : X' âŸ¶ Y') (g' : Y' âŸ¶ Z') [CategoryTheory.Limits.HasKernel g'] (w' : f' â‰« g' = 0) (p : X âŸ¶ X') (q : Y âŸ¶ Y') (r : Z âŸ¶ Z') (hâ‚ : f â‰« q = p â‰« f') (hâ‚‚ : g â‰« r = q â‰« g') : CategoryTheory.Limits.kernel.lift g f w â‰« CategoryTheory.Limits.kernel.map g g' q r hâ‚‚ = p â‰« CategoryTheory.Limits.kernel.lift g' f' w'
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurableSpace Î±} {mâ‚‚ : measurableSpace Î²} {f : Î± â†’ Î²} : mâ‚‚ â‰¤ MeasurableSpace.map f mâ‚ â†’ Measurable f
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [pseudoEmetricSpace Î±] [topologicalSpace Î²] [pseudoEmetricSpace Î³] (f : Î± Ã— Î² â†’ Î³) (K : Nnreal) (ha : âˆ€ (a : Î±), Continuous (Î» (y : Î²), f (a, y))) (hb : âˆ€ (b : Î²), LipschitzWith K (Î» (x : Î±), f (x, b))) : Continuous f
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {R : Nnreal} {c : â„‚} {f : â„‚ â†’ E} (hD : DifferentiableOn â„‚ f (Metric.ClosedBall c â†‘R)) (hR : 0 < R) : HasFpowerSeriesOnBall f (cauchyPowerSeries f c â†‘R) c â†‘R
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} (f : X âŸ¶ Y) [CategoryTheory.IsIso f.op] : CategoryTheory.IsIso f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} {F G : Top.Presheaf C X} (Î± : F â‰… G) (h : F.is_sheaf) : G.is_sheaf
{Î¹ : Type u_1} {ð•œ : Type u_2} {F : Type u_3} [Fintype Î¹] [Semiring ð•œ] [topologicalSpace ð•œ] [AddCommMonoid F] [Module ð•œ F] [topologicalSpace F] [HasContinuousAdd F] [HasContinuousSmul ð•œ F] (f : (Î¹ â†’ ð•œ) â†’â‚—[ð•œ] F) : Continuous â‡‘f
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] {s : Set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurableSpace E] [BorelSpace E] (hs : MeasurableSet s) (hF' : âˆ€ (x : E), x âˆˆ s â†’ HasFderivWithinAt f (f' x) s x) (hF : Set.InjOn f s) : MeasurableEmbedding (s.restrict f)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (X Y : C) : CategoryTheory.IsIso (CategoryTheory.Limits.kernelÎ¹ 0)
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} : a - b â‰¤ 0 â†’ a â‰¤ b
{Î± : Type u_1} [PartialOrder Î±] [succOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ Set.Ico m n â†’ r (Order.succ i) i) (hmn : m < n) : Relation.TransGen r n m
(n : â„•) (n_Pos : 0 < n) : 4 ^ n â‰¤ 2 * n * n.central_binom
{R : Type u} {Î¹ : Type v} {Mâ‚ : Î¹ â†’ Type wâ‚} {Mâ‚‚ : Type wâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (Mâ‚ i)] [AddCommMonoid Mâ‚‚] [Î  (i : Î¹), Module R (Mâ‚ i)] [Module R Mâ‚‚] [Î  (i : Î¹), topologicalSpace (Mâ‚ i)] [topologicalSpace Mâ‚‚] (f : ContinuousMultilinearMap R Mâ‚ Mâ‚‚) [Fintype Î¹] (m m' : Î  (i : Î¹), Mâ‚ i) : â‡‘f (m + m') = finset.univ.sum (Î» (s : Finset Î¹), â‡‘f (s.piecewise m m'))
{Î± : Type u} [topologicalSpace Î±] (x : Î±) [(nhdsWithin x {x}á¶œ).ne_IsBot] : Closure {x}á¶œ = Set.Univ
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [linearOrderedField ð•œ] [AddCommGroup E] [AddCommGroup F] [orderedAddCommMonoid Î²] [Module ð•œ E] [Module ð•œ F] [HasScalar ð•œ Î²] {f : F â†’ Î²} (g : E â†’áµƒ[ð•œ] F) {s : Set F} (hF : ConcaveOn ð•œ s f) : ConcaveOn ð•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
{p : â„•} : padicValRat p 1 = 0
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {A B C : V} (f : A âŸ¶ B) [CategoryTheory.Limits.HasImage f] (g : B âŸ¶ C) [CategoryTheory.Limits.HasKernel g] (w : f â‰« g = 0) (h : CategoryTheory.Limits.imageSubobject f â‰¤ CategoryTheory.Limits.kernelSubobject g) : (CategoryTheory.Limits.imageSubobject f).of_LE (CategoryTheory.Limits.kernelSubobject g) h = imageToKernel f g w
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {f : Î± â†’ Î² â†’ Î³} (hF : Function.Injective2 f) (a : Î±) : Function.Injective (f a)
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {f : Î± â†’ Î²} (hF : IsGroupHom f) : IsMonoidHom f
{n : â„•} (hn : Even n) (h : n â‰  0) : StrictConvexOn â„ Set.Univ (Î» (x : â„), x ^ n)
{R : Type u} [CommRing R] [IsNoetherianRing R] : IsNoetherianRing (Polynomial R)
{D : Set â„} (hD : Convex â„ D) {f : â„ â†’ â„} (hF : ContinuousOn f D) (hF' : DifferentiableOn â„ f (Interior D)) {C : â„} (LE_hF' : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv f x â‰¤ C) (x : â„) (H : x âˆˆ D) (y : â„) (H_1 : y âˆˆ D) : x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)
{R : Type u_1} [hasMul R] {a : R} : IsLeftRegular a â†” IsSmulRegular R a
{R : Type u_1} {Î± : Type u_2} {Î² : Type u_4} {Î³ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {l' : Type u_14} {m' : Type u_15} {n' : Type u_16} [CommSemiring R] [Fintype m] [Fintype m'] [NonUnitalNonAssocSemiring Î±] [NonUnitalNonAssocSemiring Î²] [NonUnitalNonAssocSemiring Î³] [Module R Î±] [Module R Î²] [Module R Î³] (f : Î± â†’â‚—[R] Î² â†’â‚—[R] Î³) (h_comm : âˆ€ (a b : Î±) (a' b' : Î²), â‡‘(â‡‘f (a * b)) (a' * b') = â‡‘(â‡‘f a) a' * â‡‘(â‡‘f b) b') (A : Matrix l m Î±) (B : Matrix m n Î±) (A' : Matrix l' m' Î²) (B' : Matrix m' n' Î²) : â‡‘(â‡‘(Matrix.kroneckerMapBilinear f) (A.mul B)) (A'.mul B') = (â‡‘(â‡‘(Matrix.kroneckerMapBilinear f) A) A').mul (â‡‘(â‡‘(Matrix.kroneckerMapBilinear f) B) B')
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [SemilatticeSup Î±] [OrderBot Î±] (s : Finset Î²) (t : Finset Î³) (f : Î² Ã— Î³ â†’ Î±) : (s.product t).sup f = s.sup (Î» (i : Î²), t.sup (Î» (i' : Î³), f (i, i')))
{A : Type u_2} [CommRing A] [is_IsDomain A] (h : IsDedekindDomainInv A) : IsDedekindDomain A
{Î¹ : Type u_1} {Î± : Type u_3} [Preorder Î¹] [Preorder Î±] {l : Filter Î¹} {u : Î¹ â†’ Î±} (h : Monotone u) [l.ne_IsBot] (hu : Filter.Tendsto u l Filter.atBot) : Filter.Tendsto u Filter.atBot Filter.atBot
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {vâ‚ vâ‚‚ : RayVector R M} : vâ‚ â‰ˆ vâ‚‚ â†” SameRay R â†‘vâ‚ â†‘vâ‚‚
{Î± : Type u} [orderedSemiring Î±] [Nontrivial Î±] : 0 < 4
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [AddCommMonoid M] {g : Î² â†’ M} (e : Î± â†’ Î²) (hEâ‚€ : Function.bijective e) : finsum (Î» (i : Î±), g (e i)) = finsum (Î» (j : Î²), g j)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : 0 â‰¤ EuclideanGeometry.angle p1 p2 p3
(n : â„•) : n.choose 2 = n * (n - 1) / 2
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace E] [CompleteSpace â†¥K] (w : E) : w = â†‘(â‡‘(orthogonalProjection K) w) + â†‘(â‡‘(orthogonalProjection Ká—®) w)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {s1 s2 : AffineSubspace k P} (h1 : â†‘s1.nonempty) (h2 : â†‘s2.nonempty) (hE : â†‘s1 âˆ© â†‘s2 = âˆ…) : s1.direction âŠ” s2.direction < (s1 âŠ” s2).direction
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (e : C â‰Œ D) (Y : D) : e.unit.app (e.inverse.obj Y) â‰« e.inverse.map (e.counit.app Y) = ðŸ™ (e.inverse.obj Y)
{Î± : Type u} [Preorder Î±] {a b c : Î±} : b = c â†’ a < b â†’ a < c
(R : Type u) (M : Type v) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] : â†‘(FiniteDimensional.finrank R M) = Module.rank R M
{Y : Type u_2} [topologicalSpace Y] [NormalSpace Y] {s : Set Y} (f : C(â†¥s, â„)) {t : Set â„} [t.ord_connected] (ht : âˆ€ (x : â†¥s), â‡‘f x âˆˆ t) (hne : t.nonempty) (hs : is_IsClosed s) : âˆƒ (g : C(Y, â„)), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ ContinuousMap.restrict s g = f
{p : Ereal Ã— Ereal} (h : p.fst â‰  âŠ¤ âˆ¨ p.snd â‰  âŠ¥) (h' : p.fst â‰  âŠ¥ âˆ¨ p.snd â‰  âŠ¤) : ContinuousAt (Î» (p : Ereal Ã— Ereal), p.fst + p.snd) p
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} (h : TendstoUniformlyOn F f p s) (g : Î³ â†’ Î±) : TendstoUniformlyOn (Î» (n : Î¹), F n âˆ˜ g) (f âˆ˜ g) p (g â»Â¹' s)
{Î± : Type u} [topologicalSpace Î±] (x : Î±) [(nhdsWithin x {x}á¶œ).ne_IsBot] : Dense {x}á¶œ
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) : fin.snoc (fin.init q) (q (fin.last n)) = q
{R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (r : R) (x y : A) : r â€¢ x * y = r â€¢ (x * y)
 : Â¬Small Ordinal
{Î± : Type u} [pseudoEmetricSpace Î±] (E : Set Î±) : Closure E = â‹‚ (Î´ : â„) (h : 0 < Î´), Metric.Cthickening Î´ E
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [OrderedAddCommGroup Î²] [HasScalar ð•œ E] [Module ð•œ Î²] {s : Set E} {f : E â†’ Î²} : StrictConvexOn ð•œ s f â†’ StrictConcaveOn ð•œ s (-f)
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {s : Submodule K V} (h : s < âŠ¤) : FiniteDimensional.finrank K â†¥s < FiniteDimensional.finrank K V
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {f : â„ â†’ E} {a b : â„} {f' g : â„ â†’ E} (derivf : âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt f (f' x) (Set.Ici x) x) (derivg : âˆ€ (x : â„), x âˆˆ Set.Ico a b â†’ HasDerivWithinAt g (f' x) (Set.Ici x) x) (fcont : ContinuousOn f (Set.Icc a b)) (gcont : ContinuousOn g (Set.Icc a b)) (hi : f a = g a) (y : â„) (H : y âˆˆ Set.Icc a b) : f y = g y
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (hn : x â‰  y) (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : o.oangle y x = â†‘Real.pi - 2 â€¢ o.oangle (y - x) y
{R : Type u_1} {a : R} [AddSemigroup R] (b : R) (ha : IsAddRightRegular a) : IsAddRightRegular (b + a) â†” IsAddRightRegular b
{Î± : Type u_1} {G : Type u_5} [topologicalSpace G] [AddCommGroup G] [TopologicalAddGroup G] {f : Î± â†’ G} (hF : Summable f) : Filter.Tendsto f Filter.cofinite (nhds 0)
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] (f : â„‚ â†’ E) (z w : â„‚) (hD : DifferentiableOn â„ f (Set.Interval z.re w.re Ã—â„‚ Set.Interval z.im w.im)) (Hi : MeasureTheory.IntegrableOn (Î» (z : â„‚), Complex.i â€¢ â‡‘(fderiv â„ f z) 1 - â‡‘(fderiv â„ f z) Complex.i) (Set.Interval z.re w.re Ã—â„‚ Set.Interval z.im w.im) MeasureTheory.MeasureSpace.volume) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * Complex.i) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, Complex.i â€¢ â‡‘(fderiv â„ f (â†‘x + â†‘y * Complex.i)) 1 - â‡‘(fderiv â„ f (â†‘x + â†‘y * Complex.i)) Complex.i
(ð•œ : Type u) [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace ð•œ] {r : â„} (rpos : 0 < r) {c : E} (h : is_IsCompact (Metric.ClosedBall c r)) : FiniteDimensional ð•œ E
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {f : Î± â†’ Î²} (hF : IsAddGroupHom f) : Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0
(m : â„•) {n : â„•} (hn : 0 < n) : (âˆƒ (k : â„•), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} {f : ð•œ â†’ F} {s : Set ð•œ} : iteratedDerivWithin n f s = â‡‘((ContinuousMultilinearMap.piFieldEquiv ð•œ (Fin n) F).symm) âˆ˜ iteratedFderivWithin ð•œ n f s
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î²} (hF : Continuous f) : f â»Â¹' Interior s âŠ† Interior (f â»Â¹' s)
{Î± : Type u_1} {Î² : Type u_2} [AddCommGroup Î±] [topologicalSpace Î±] [TopologicalAddGroup Î±] {f : Î² â†’ Î±} [t2_Space Î±] [DecidableEq Î²] (hF : Summable f) (b : Î²) : âˆ‘' (n : Î²), f n = f b + âˆ‘' (n : Î²), Ite (n = b) 0 (f n)
{R : Type u} [Ring R] (a : R) {n : â„•} (h : n â‰  0) : (Polynomial.x ^ n - â‡‘Polynomial.c a).monic
{K : Type u_1} {v : K} {n : â„•} [linearOrderedField K] [floorRing K] (hyp : n = 0 âˆ¨ Â¬(GeneralizedContinuedFraction.of v).terminated_at (n - 1)) : â†‘(Nat.fib (n + 1)) â‰¤ (GeneralizedContinuedFraction.of v).denominators n
{Î± : Type u} {Î² : Type v} [completeLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [completeLinearOrder Î²] [topologicalSpace Î²] [OrderTopology Î²] {Î¹ : sort u_1} {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : ContinuousAt f (supr g)) (Mf : Monotone f) (fbot : f âŠ¥ = âŠ¥) : f (â¨† (i : Î¹), g i) = â¨† (i : Î¹), f (g i)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] [âˆ€ (X Y : C), Subsingleton (X âŸ¶ Y)] (hC : CategoryTheory.Skeletal C) : CategoryTheory.Skeletal (D â¥¤ C)
{K : Type u} [hring : CommRing K] [hdomain : is_IsDomain K] {P : Ratfunc K â†’ Prop} (x : Ratfunc K) (f : âˆ€ (p q : Polynomial K), q â‰  0 â†’ P (Ratfunc.mk p q)) : P x
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Semiring R] [AddCommMonoid N] [Module R N] (p : Î¹ â†’ Submodule R N) : supr p = (â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)).range
{Î± : Type u_1} [PartialOrder Î±] [succOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ Set.Ico m n â†’ r (Order.succ i) i) (hmn : m â‰¤ n) : Relation.ReflTransGen r n m
{X : Type u_1} [topologicalSpace X] [NormalSpace X] (c : Urysohns.CU X) : Continuous c.lim
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {n : â„•} [Nonempty Î²] (hn : Fintype.card Î² * n â‰¤ Fintype.card Î±) : âˆƒ (y : Î²), n â‰¤ (Finset.filter (Î» (x : Î±), f x = y) Finset.univ).card
 : (Î» (n : â„•), â†‘(Nat.fib n)) = Î» (n : â„•), (goldenRatio ^ n - goldenConj ^ n) / Real.sqrt 5
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {f : Î± â†’ Î²} (hi : Inducing f) (ho : is_IsOpen (Set.Range f)) : is_is_IsOpenMap f
{Î± : Type u_3} [SemilatticeInf Î±] [NoMinOrder Î±] (a : Î±) : Filter.map Coe Filter.atBot = Filter.atBot
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] [h : group.is_nilpotent G] (f : G â‰ƒ* G') : group.is_nilpotent G'
{A : Type u_1} (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] (a : A) : minpoly A (â‡‘(algebraMap A B) a) = Polynomial.x - â‡‘Polynomial.c a
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} {r : Ennreal} (H1 : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (y : Î±) (H : y âˆˆ t), HasEdist.edist x y â‰¤ r)) (H2 : âˆ€ (x : Î±), x âˆˆ t â†’ (âˆƒ (y : Î±) (H : y âˆˆ s), HasEdist.edist x y â‰¤ r)) : Emetric.hausdorffEdist s t â‰¤ r
{R : Type u} [CommSemiring R] (l : List (Polynomial R)) (x : R) : Polynomial.eval x l.prod = (List.map (Polynomial.eval x) l).prod
{F : Type v} [NormedGroup F] [normedSpace â„‚ F] {f : â„‚ â†’ F} (hF : Differentiable â„‚ f) (hb : Metric.Bounded (Set.Range f)) (z w : â„‚) : f z = f w
{n : Type u_4} [DecidableEq n] (v : n â†’ â„) : (Matrix.diagonal v).is_hermitian
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {E : Type u_5} [CategoryTheory.Category E] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {L : CategoryTheory.GrothendieckTopology E} {F : C â¥¤ D} (hu : CategoryTheory.CoverLifting J K F) {G : D â¥¤ E} (hv : CategoryTheory.CoverLifting K L G) : CategoryTheory.CoverLifting J L (F â‹™ G)
{Î± : Type u_1} {Î² : Type u_2} [measurableSpace Î±] [measurableSpace Î²] (f : MeasureTheory.SimpleFunc Î± Î²) : Measurable â‡‘f
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasFiniteProducts D] (F : C â¥¤ D) {L : D â¥¤ C} [CategoryTheory.CartesianClosed C] [CategoryTheory.CartesianClosed D] [CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] (h : L âŠ£ F) (A : C) [i : CategoryTheory.IsIso (CategoryTheory.expComparison F A)] : CategoryTheory.IsIso (CategoryTheory.frobeniusMorphism F h A)
 : StrictMono (Î» (n : â„•), Nat.fib (n + 2))
{M : Type u_6} {N : Type u_7} [hasMul M] [hasMul N] (f : M â‰ƒ* N) (x y : M) : â‡‘f (x * y) = â‡‘f x * â‡‘f y
{k : Type u_1} {G : Type u_2} {V : Type u_3} [CommSemiring k] [Group G] [AddCommMonoid V] [Module k V] (Ï : Representation k G V) [Fintype G] [Invertible â†‘(Fintype.card G)] (v : V) : â‡‘(Ï.average_Map) v âˆˆ Ï.invariants
{Î² : Type u} {Î± : Type v} [CommSemiring Î²] {s : Finset Î±} {i : Î±} {f g h : Î± â†’ Î²} (hi : i âˆˆ s) (h1 : g i + h i = f i) (h2 : âˆ€ (j : Î±), j âˆˆ s â†’ j â‰  i â†’ g j = f j) (h3 : âˆ€ (j : Î±), j âˆˆ s â†’ j â‰  i â†’ h j = f j) : s.prod (Î» (i : Î±), g i) + s.prod (Î» (i : Î±), h i) = s.prod (Î» (i : Î±), f i)
{Î± : Type u_1} {n : â„•} {s t : Finset Î±} : s âˆˆ Finset.powersetLen n t â†” s âŠ† t âˆ§ s.card = n
{Î± : Type u_1} {Î¹ : Type u_4} (s : Î¹ â†’ Set Î±) : (â‹ƒ (i : Î¹), s i) = â‹ƒ (t : Finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
{G : Type u_1} [AddGroup G] (h : Add_monoid.exponent_exists G) : Add_monoid.is_torsion G
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {sâ‚ : Setoid Î±} {sâ‚‚ : Setoid Î²} {sâ‚ƒ : Setoid Î³} {p : Quotient sâ‚ â†’ Quotient sâ‚‚ â†’ Quotient sâ‚ƒ â†’ Prop} (qâ‚ : Quotient sâ‚) (qâ‚‚ : Quotient sâ‚‚) (qâ‚ƒ : Quotient sâ‚ƒ) (h : âˆ€ (aâ‚ : Î±) (aâ‚‚ : Î²) (aâ‚ƒ : Î³), p (Quotient.mk' aâ‚) (Quotient.mk' aâ‚‚) (Quotient.mk' aâ‚ƒ)) : p qâ‚ qâ‚‚ qâ‚ƒ
{R : Type u} {S : Type v} {A : Type w} [CommSemiring R] [CommSemiring S] [Semiring A] [Algebra R S] [Algebra S A] [Algebra R A] (h : algebraMap R A = (algebraMap S A).comp (algebraMap R S)) : isScalarTower R S A
{R : Type u_1} [linearOrderedField R] [floorRing R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : â†‘b ^ x â‰¤ r â†” x â‰¤ Int.log b r
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] (v : E) : âˆƒ (y : E) (H : y âˆˆ K) (z : E) (H : z âˆˆ Ká—®), v = y + z
{M : Type u_1} {N : Type u_2} [hasMul M] [hasMul N] {f g : M â†’â‚™* N} {s : Set M} (h : Set.EqOn â‡‘f â‡‘g s) : Set.EqOn â‡‘f â‡‘g â†‘(Subsemigroup.closure s)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (f : localHomeomorph E F) {f' : E â‰ƒL[ð•œ] F} {a : F} (ha : a âˆˆ f.to_local_equiv.target) (htff' : HasStrictFderivAt â‡‘f â†‘f' (â‡‘(f.symm) a)) : HasStrictFderivAt â‡‘(f.symm) â†‘(f'.symm) a
{ð•œ : Type u_1} {E : Type u_2} [orderedSemiring ð•œ] [AddCommGroup E] [Module ð•œ E] {s t : Set E} (hc : ConvexIndependent ð•œ (Î» (x : â†¥t), â†‘x)) (hs : s âŠ† t) : ConvexIndependent ð•œ (Î» (x : â†¥s), â†‘x)
{Î± : Type u} [topologicalSpace Î±] [t0_Space Î±] {s : Set Î±} (hfin : s.finite) (hne : s.nonempty) (ho : is_IsOpen s) : âˆƒ (x : Î±) (H : x âˆˆ s), is_IsOpen {x}
{Î± : Type u} [DecidableEq Î±] [Fintype Î±] {P : Equiv.perm Î± â†’ Prop} (f : Equiv.perm Î±) : P 1 â†’ (âˆ€ (f : Equiv.perm Î±) (x y : Î±), x â‰  y â†’ P f â†’ P (f * equiv.swap x y)) â†’ P f
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] {e : localHomeomorph Î± Î²} {s : Set Î±} {t : Set Î²} : e.to_local_equiv.source âˆ© â‡‘e â»Â¹' (e.to_local_equiv.target âˆ© t) = e.to_local_equiv.source âˆ© s â†’ e.is_image s t
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} [hasCoe Î± Î²] [hasCoe_t Î² Î³] (a : Î±) : â†‘a = â†‘â†‘a
{Î± : Type u} [pseudoMetricSpace Î±] {x : Î±} : Metric.infDist x âˆ… = 0
{Î± : Type u_1} [linearOrderedRing Î±] [Archimedean Î±] {x y : Î±} (hx : 1 â‰¤ x) (hy : 1 < y) : âˆƒ (n : â„•), y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [CommMonoid M] {f : Î± â†’ M} {g : Î² â†’ Î±} (hg : Set.InjOn g (Function.MulSupport (f âˆ˜ g))) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ Set.Range g), f i)) = finprod (Î» (j : Î²), f (g j))
(K : Type u) (V : Type v) [divisionRing K] [AddCommGroup V] [Module K V] [IsNoetherian K V] : Module.rank K V < Cardinal.aleph_0
{a b c : â„¤} : fermat_42.minimal a b c â†’ fermat_42.minimal b a c
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] {a b : â„} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (h : âˆ€ (x y : E), âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥yâˆ¥ â‰¤ 1 â†’ x â‰  y â†’ âˆ¥a â€¢ x + b â€¢ yâˆ¥ < 1) : StrictConvexSpace â„ E
(n : â„•) (z : â„‚) : (Complex.cos z + Complex.sin z * Complex.i) ^ n = Complex.cos (â†‘n * z) + Complex.sin (â†‘n * z) * Complex.i
{C : Type uâ‚} [CategoryTheory.SmallCategory C] {â„° : Type uâ‚‚} [CategoryTheory.Category â„°] (A : C â¥¤ â„°) (P : Cáµ’áµ– â¥¤ Type uâ‚) (Eâ‚ Eâ‚‚ : â„°) (g : Eâ‚ âŸ¶ Eâ‚‚) {c : CategoryTheory.Limits.Cocone ((CategoryTheory.categoryOfElementsÏ€ P).left_Op â‹™ A)} (t : CategoryTheory.Limits.IsColimit c) (k : c.X âŸ¶ Eâ‚) : â‡‘(CategoryTheory.ColimitAdj.restrictYonedaHomEquiv A P Eâ‚‚ t) (k â‰« g) = â‡‘(CategoryTheory.ColimitAdj.restrictYonedaHomEquiv A P Eâ‚ t) k â‰« (CategoryTheory.ColimitAdj.restrictedYoneda A).map g
{L : FirstOrder.Language} {M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_6} [L.Structure M] [L.Structure N] [L.Structure P] [L.Structure Q] (f : L.elementary_Embedding M N) (g : L.elementary_Embedding N P) (h : L.elementary_Embedding P Q) : (h.comp g).comp f = h.comp (g.comp f)
{M : Type u_2} [AddCommGroup M] {A : Type u_1} [CommRing A] [Module A M] (f : M â†’â‚—[A] M) (hF : IsUnit f) : IsUnit (â‡‘LinearMap.det f)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] (s : Set P) : (affineSpan k s).direction = vectorSpan k s
{Î± : Type u} [PartialOrder Î±] [OrderTop Î±] {a : Î±} : IsMax a â†’ a = âŠ¤
{Î± : Type u_1} [pseudoEmetricSpace Î±] {f : â„• â†’ Î±} (d : â„• â†’ Ennreal) (hF : âˆ€ (n : â„•), HasEdist.edist (f n) (f n.succ) â‰¤ d n) {a : Î±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) : HasEdist.edist (f 0) a â‰¤ âˆ‘' (m : â„•), d m
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (h : âˆ€ {Î¹ : Type u} (U : Î¹ â†’ Set Î±), (âˆ€ (i : Î¹), is_IsOpen (U i)) â†’ (s âŠ† â‹ƒ (i : Î¹), U i) â†’ (âˆƒ (t : Finset Î¹), s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i)) : is_IsCompact s
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x - y âˆˆ S
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] [CompleteSpace E] {f : â„ â†’ E} {T : â„} (hF : Function.Periodic f T) (hT : 0 < T) (t s : â„) : âˆ« (x : â„) in t..t + T, f x = âˆ« (x : â„) in s..s + T, f x
{G : Type u_1} [AddGroup G] (H : AddSubgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x - y âˆˆ H
{u : â„• â†’ â„} (h : Subadditive u) (hbdd : BddBelow (Set.Range (Î» (n : â„•), u n / â†‘n))) : Filter.Tendsto (Î» (n : â„•), u n / â†‘n) Filter.atTop (nhds h.lim)
{Î± : Type u_1} {M : Type u_5} {N : Type u_6} [AddCommMonoid M] [AddCommMonoid N] {s : Set Î±} {f : Î± â†’ M} (g : M â†’+ N) (hâ‚€ : (s âˆ© Function.Support f).finite) : â‡‘g (finsum (Î» (j : Î±), finsum (Î» (H : j âˆˆ s), f j))) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), â‡‘g (f i)))
{Î³ : Type w} [Preorder Î³] [OrderBot Î³] (s : Set Î³) : BddBelow s
{Î± : Type u} [pseudoMetricSpace Î±] {s t u : Set Î±} (Fin : Emetric.hausdorffEdist s t â‰  âŠ¤) : Metric.hausdorffDist s u â‰¤ Metric.hausdorffDist s t + Metric.hausdorffDist t u
{Î± : Type u_2} [DecidableEq Î±] {B : Finset (Finset Î±)} {n : â„•} [Fintype Î±] (h : âˆ€ (a : Î±), n â‰¤ (Finset.filter (HasMem.Mem a) B).card) : Fintype.card Î± * n â‰¤ B.sum (Î» (s : Finset Î±), s.card)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle y z + o.oangle x y = o.oangle x z
{T : â„} {g : â„ â†’ â„} (hg : Function.Periodic g T) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.MeasureSpace.volume tâ‚ tâ‚‚) (hâ‚€ : âˆ€ (x : â„), 0 < g x) (hT : 0 < T) : Filter.Tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) Filter.atTop Filter.atTop
{Î± : Type u} (s : Finset Î±) : â†‘s.finite
{M : Type u_3} {N : Type u_4} [Monoid M] [Monoid N] {F : Type u_1} [monoidHomClass F M Náµáµ’áµ–] (f : F) (l : List M) : MulOpposite.unop (â‡‘f l.prod) = (List.map (MulOpposite.unop âˆ˜ â‡‘f) l).reverse.prod
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {X : C} (h : Category_theory.coyoneda.obj (Opposite.op X) â‹™ CategoryTheory.uliftFunctor â‰… F.cocones) {Y : C} (f : X âŸ¶ Y) : CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom h f = (CategoryTheory.Limits.IsColimit.OfNatIso.colimitCocone h).extend f
{M : Type u_2} (R : Type u_5) [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) : Submodule.span R s = (Finsupp.total â†¥s M R Coe).range
{R : Type u} {S : Type v} [CommSemiring R] [LocalRing R] [CommSemiring S] [LocalRing S] (f : R â†’+* S) [IsLocalRingHom f] (a : R) (h : a âˆˆ LocalRing.maximalIdeal R) : â‡‘f a âˆˆ LocalRing.maximalIdeal S
{Mâ‚€ : Type u_1} [MulZeroOneClass Mâ‚€] : 0 = 1 â†’ Subsingleton Mâ‚€
{Î± : Type u} (L : List Î±) {i j : â„•} (h : i + j < L.length) : L.nth_LE (i + j) h = (List.drop i L).nth_LE j _
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {n : WithTop â„•} {s : Set (E Ã— F)} {p : E Ã— F} : ContDiffWithinAt ð•œ n Prod.fst s p
{G : Type u_3} [Group G] : group.fg G â†” âˆƒ (S : Set G), Subgroup.closure S = âŠ¤ âˆ§ S.finite
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {x : E} : DifferentiableAt ð•œ f x â†’ MdifferentiableAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f x
(R : Type u_1) (M : Type u_4) [Semiring R] [AddCommMonoid M] [Module R M] (x : M) : Submodule.span R {x} = (LinearMap.toSpanSingleton R M x).range
{m n : â„•} : Even (m ^ n) â†” Even m âˆ§ n â‰  0
{F : Type u_3} [innerProductSpace â„ F] [FiniteDimensional â„ F] : Subgroup.closure (Set.Range (Î» (v : F), reflection (Submodule.span â„ {v})á—®)) = âŠ¤
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : o.oangle x (x - y) = o.oangle (y - x) y
{R : Type u_1} [nonAssocRing R] [Nontrivial R] (hR : ringChar R â‰  2) : -1 â‰  1
{E : Type u_1} [AddCommGroup E] [starAddMonoid E] [Module â„‚ E] [StarModule â„‚ E] (x : E) : â†‘(â‡‘StarModule.re x) + Complex.i â€¢ â†‘(â‡‘StarModule.im x) = x
{Î± : Type u} [Group Î±] [HasLe Î±] [CovariantClass Î± Î± Mul.mul LE.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
{Î± : Type u_1} {Î¹ : sort u_3} [conditionallyCompleteLattice Î±] {f g : Î¹ â†’ Î±} (B : BddBelow (Set.Range f)) (H : âˆ€ (x : Î¹), f x â‰¤ g x) : infi f â‰¤ infi g
{Î± : Type u_2} [DecidableEq Î±] {B : Finset (Finset Î±)} {n : â„•} [Fintype Î±] (h : âˆ€ (a : Î±), (Finset.filter (HasMem.Mem a) B).card = n) : B.sum (Î» (s : Finset Î±), s.card) = Fintype.card Î± * n
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {e e' : LocalEquiv Î± Î²} {f f' : LocalEquiv Î² Î³} (hE : e â‰ˆ e') (hF : f â‰ˆ f') : e.trans f â‰ˆ e'.trans f'
{Î± : Type u_1} [CanonicallyOrderedAddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {a b c : Î±} [ContravariantClass Î± Î± Add.add LE.le] (h : c â‰¤ b) : a < b - c â†” c + a < b
{Î± : Type u} [topologicalSpace Î±] [t1_Space Î±] [âˆ€ (x : Î±), (nhdsWithin x {x}á¶œ).ne_IsBot] {s : Set Î±} (hs : Dense s) {t : Set Î±} (ht : t.finite) : Dense (s  t)
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} {x : Î±} [topologicalSpace Î±] (hx : x âˆˆ s) (L : âˆ€ (u : Set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : Set Î±) (H : t âˆˆ nhdsWithin x s) (F : Î± â†’ Î²), ContinuousWithinAt F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u)) : ContinuousWithinAt f s x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {s : Finset Î¹} {w : Î¹ â†’ k} (h : s.sum (Î» (i : Î¹), w i) = 0) (p : Î¹ â†’ P) : â‡‘(s.weighted_vsub p) w âˆˆ vectorSpan k (Set.Range p)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [orderedSemiring ð•œ] [AddCommMonoid E] [OrderedAddCommGroup Î²] [HasScalar ð•œ E] [Module ð•œ Î²] {s : Set E} {f : E â†’ Î²} : StrictConcaveOn ð•œ s (-f) â†” StrictConvexOn ð•œ s f
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [normedSpace â„ E] {f : â„ â†’ E} {ca cb : E} {a b : â„} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds a âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb : Filter.Tendsto f (nhds b âŠ“ MeasureTheory.Measure_space.volume.ae) (nhds cb)) : fderiv â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (a, b) = (ContinuousLinearMap.snd â„ â„ â„).smul_Right cb - (ContinuousLinearMap.fst â„ â„ â„).smul_Right ca
{Î± : Type u} {a b : Î±} [MulZeroClass Î±] [Preorder Î±] [ZeroLt.MulPosStrictMono Î±] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
{Î± : Type u_1} [conditionallyCompleteLattice Î±] (a : Î±) : HasSup.sup {a} = a
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (f : Î± â†’ Î²) {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] [Nonempty Î²] (hb : finset.univ.sum (Î» (x : Î±), w x) â‰¤ Fintype.card Î² â€¢ b) : âˆƒ (y : Î²), (Finset.filter (Î» (x : Î±), f x = y) Finset.univ).sum (Î» (x : Î±), w x) â‰¤ b
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] [denselyOrdered Î±] {a : Î±} {s : Set Î±} : s âˆˆ nhdsWithin a (Set.Ici a) â†” âˆƒ (u : Î±), a < u âˆ§ Set.Icc a u âŠ† s
{ð•œ : Type u_1} {F : Type u_3} [is_R_or_C ð•œ] [AddCommGroup F] [Module ð•œ F] [c : InnerProductSpace.Core ð•œ F] (x y : F) : is_R_or_C.abs (HasInner.inner x y) * is_R_or_C.abs (HasInner.inner y x) â‰¤ â‡‘is_R_or_C.re (HasInner.inner x x) * â‡‘is_R_or_C.re (HasInner.inner y y)
{Î± : Type u_1} [LinearOrder Î±] [PredOrder Î±] [IsPredArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (hr : Reflexive r) (h1 : âˆ€ (i : Î±), i âˆˆ Set.Ioc m n â†’ r i (Order.pred i)) (h2 : âˆ€ (i : Î±), i âˆˆ Set.Ioc n m â†’ r (Order.pred i) i) : Relation.TransGen r n m
{R : Type v} [CommRing R] {n : Type u_1} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) : A.det = A Inhabited.default Inhabited.default
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X âŸ¶ Y} (hâ‚€ : f = g) {c : CategoryTheory.Limits.Cofork f g} (h : CategoryTheory.Limits.IsColimit c) : CategoryTheory.IsIso c.Ï€
{x : â„} (hx : 0 â‰¤ x) : x + 1 â‰¤ Real.exp x
(p : â„•) [hp : Fact (Nat.Prime p)] {q r : â„š} (hne : padicNorm p q â‰  padicNorm p r) : padicNorm p (q + r) = Linear_order.max (padicNorm p q) (padicNorm p r)
 : fib_rec.is_solution (Pow.pow goldenConj)
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) (h : â†‘(S.topological_Closure) â‰  Set.Univ) : âˆ¥S.normed_Mkâˆ¥ = 1
{G : Type u_1} [Group G] (H : â„• â†’ Subgroup G) (hH : IsAscendingCentralSeries H) (n : â„•) : H n â‰¤ upperCentralSeries G n
{G : Type w} [topologicalSpace G] [AddGroup G] [TopologicalAddGroup G] {M : Type u_1} {hom : Type u_2} [AddZeroClass M] [topologicalSpace M] [HasContinuousAdd M] [addMonoidHomClass hom G M] (f : hom) (hF : ContinuousAt â‡‘f 0) : Continuous â‡‘f
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] [LocallyCompactSpace Î±] [t2_Space Î±] [t2_Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [l.ne_IsBot] (F : Î¹ â†’ C(Î±, Î²)) : (âˆƒ (f : C(Î±, Î²)), Filter.Tendsto F l (nhds f)) â†” âˆ€ (s : Set Î±), is_IsCompact s â†’ (âˆƒ (f : C(â†¥s, Î²)), Filter.Tendsto (Î» (i : Î¹), ContinuousMap.restrict s (F i)) l (nhds f))
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {s : Set E} (hscomp : is_IsCompact s) (hAconv : Convex â„ s) : Closure (â‡‘(convexHull â„) (Set.ExtremePoints â„ s)) = s
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscreteNormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), normedSpace ð•œ (E i)] [NormedGroup G] [normedSpace ð•œ G] (f : MultilinearMap ð•œ E G) {C : â„} (hC : 0 â‰¤ C) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥f.mk_Continuous C Hâˆ¥ â‰¤ C
{Î± : Type u} {Î² : Type v} [linearOrderedField Î±] [topologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hF : Filter.Tendsto f l Filter.atTop) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), f x * g x) l Filter.atTop
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) : hb.conj_lie.symm = hb.conj_lie
{Î¹ : Type u} {f g : Î¹ â†’ â„} {p q : â„} (hpq : p.is_conjugate_exponent q) {A B : â„} (hA : 0 â‰¤ A) (hB : 0 â‰¤ B) (hF : âˆ€ (i : Î¹), 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) (hF_Sum : HasSum (Î» (i : Î¹), f i ^ p) (A ^ p)) (hg_Sum : HasSum (Î» (i : Î¹), g i ^ q) (B ^ q)) : âˆƒ (C : â„), 0 â‰¤ C âˆ§ C â‰¤ A * B âˆ§ HasSum (Î» (i : Î¹), f i * g i) C
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} : Transitive (CategoryTheory.Abelian.PseudoEqual P)
{L : FirstOrder.Language} {M : Type w} [L.Structure M] {s : Set M} : s âŠ† â†‘(â‡‘(FirstOrder.Language.Substructure.closure L) s)
{g : Matrix.SpecialLinearGroup (Fin 2) â„¤} (z : UpperHalfPlane) {p : Fin 2 â†’ â„¤} (hp : IsCoprime (p 0) (p 1)) (hg : â†‘g 1 = p) : â†‘(g â€¢ z) = â†‘(â‡‘(modular_group.lc_row0 p) â†‘â†‘g) / (â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2) + (â†‘(p 1) * â†‘z - â†‘(p 0)) / ((â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2) * (â†‘(p 0) * â†‘z + â†‘(p 1)))
{B : Type u_3} {S : B} {M : Type u_1} [CommMonoid M] [SetLike B M] [submonoidClass B M] {Î¹ : Type u_2} {t : Finset Î¹} {f : Î¹ â†’ M} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.prod (Î» (c : Î¹), f c) âˆˆ S
(f : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfd : DifferentiableOn â„ f (Set.Ioo a b)) (g : â„ â†’ â„) (hgc : ContinuousOn g (Set.Icc a b)) (hgd : DifferentiableOn â„ g (Set.Ioo a b)) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), (g b - g a) * deriv f c = (f b - f a) * deriv g c
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) (hp : 0 < p.radius) : 0 < (p.right_Inv i).radius
{A : Type u_2} [CommRing A] [is_IsDomain A] : IsDedekindDomain A â†” IsDedekindDomainInv A
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] (v : V) (nz : v â‰  0) : FiniteDimensional.finrank K V = 1 â†” Submodule.span K {v} = âŠ¤
{V : Type u_1} [innerProductSpace â„ V] (x y : V) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” InnerProductGeometry.angle x y = Real.pi / 2
{M : Type u_1} [hasMul M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : conGen r â‰¤ conGen s
(X : AlgebraicGeometry.LocallyRingedSpace (r : â†¥(AlgebraicGeometry.LocallyRingedSpaceÎ“.obj (Opposite.op X))) : X.to_Î“_spec_Map_basicOpen r = X.to_RingedSpace.basic_IsOpen r
{Î± : Type u} {a b : Î±} [MulZeroOneClass Î±] [PartialOrder Î±] [ZeroLt.MulPosMono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (b0 : 0 â‰¤ b) : 1 â‰¤ a * b
{n : â„•} (hn : Even n) : ConvexOn â„ Set.Univ (Î» (x : â„), x ^ n)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {n : â„•} (hs : is_IsOpen s) : ContDiffOn ð•œ â†‘(n + 1) f s â†” DifferentiableOn ð•œ f s âˆ§ ContDiffOn ð•œ â†‘n (Î» (y : E), fderiv ð•œ f y) s
{Î± : Type u_1} [DecidableEq Î±] {s t u : Multiset Î±} : s - t â‰¤ u â†” s â‰¤ u + t
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [topologicalSpace Î²] [LocallyCompactSpace Î±] : Continuous coeFn
{Î± : Type u} [topologicalSpace Î±] [RegularSpace Î±] {x y : Î±} (h : x â‰  y) : âˆƒ (Uâ‚ : Set Î±) (H : Uâ‚ âˆˆ nhds x) (Vâ‚ : Set Î±) (H : Vâ‚ âˆˆ nhds x) (Uâ‚‚ : Set Î±) (H : Uâ‚‚ âˆˆ nhds y) (Vâ‚‚ : Set Î±) (H : Vâ‚‚ âˆˆ nhds y), is_IsClosed Vâ‚ âˆ§ is_IsClosed Vâ‚‚ âˆ§ is_IsOpen Uâ‚ âˆ§ is_IsOpen Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Uâ‚ âˆ© Uâ‚‚ = âˆ…
{Î± : Type u_1} [commSemigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ c * b
{Gâ‚€ : Type u_1} {Gâ‚€' : Type u_2} [groupWithZero Gâ‚€] [groupWithZero Gâ‚€'] (f : Gâ‚€ â†’*â‚€ Gâ‚€') (x : Gâ‚€) (n : â„¤) : â‡‘f (x ^ n) = â‡‘f x ^ n
{Î± : Type u} {Î² : Type v} {Î³ : Type w} [Preorder Î±] [Preorder Î²] [Preorder Î³] {f : Î± â†’ Î² â†’ Î³} {s : Set Î±} {t : Set Î²} (hâ‚€ : âˆ€ (b : Î²), Monotone (Function.swap f b)) (hâ‚ : âˆ€ (a : Î±), Monotone (f a)) : BddBelow s â†’ BddBelow t â†’ BddBelow (Set.image2 f s t)
{p : â„• â†’ Prop} [DecidablePred p] {n : â„•} : Â¬p n â†’ Nat.count p (n + 1) = Nat.count p n
{M : Type u_1} [Group M] (c : Con M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w / y) (x / z)
{Î± : Type u} [AddCommGroup Î±] : IsAddGroupHom Neg.neg
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [Module k E] [addTorsor E PE] (f : k â†’ PE) (a b r : k) : â‡‘(AffineMap.lineMap (slope f (â‡‘(AffineMap.lineMap a b) r) b) (slope f a (â‡‘(AffineMap.lineMap a b) r))) r = slope f a b
 : âˆƒ (f : Nat.Partrec.Code â†’ â„• â†’ Nat.Partrec.Code), Computableâ‚‚ f âˆ§ âˆ€ (c : Nat.Partrec.Code) (n x : â„•), (f c n).eval x = c.eval (Nat.mkpair n x)
{k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] [Fintype Î¹] {p : Î¹ â†’ P} (hi : AffineIndependent k p) {n : â„•} (hc : Fintype.card Î¹ = n + 1) : FiniteDimensional.finrank k â†¥(vectorSpan k (Set.Range p)) = n
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} : FreeGroup.Red Lâ‚ Lâ‚‚ â†’ Lâ‚‚ <+ Lâ‚
(p q : â„•) [Fact (Nat.Prime p)] [Fact (Nat.Prime q)] (hp1 : p â‰  2) (hq1 : q â‰  2) (hpq : p â‰  q) : Zmod.legendreSym q â†‘p * Zmod.legendreSym p â†‘q = (-1) ^ (p / 2 * (q / 2))
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] [topologicalSpace Y] [NormalSpace Y] (f : C(X, â„)) {t : Set â„} {e : X â†’ Y} [hs : t.ord_connected] (hF : âˆ€ (x : X), â‡‘f x âˆˆ t) (hne : t.nonempty) (hE : ClosedEmbedding e) : âˆƒ (g : C(Y, â„)), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ â‡‘g âˆ˜ e = â‡‘f
{K : Type u} {A : Type v} [Field K] [Ring A] [Algebra K A] {x : A} : IsAlgebraic K x â†” IsIntegral K x
{Î± : Type u_1} [measurableSpace Î±] [MeasurableSingletonClass Î±] {s : Set Î±} (u t : Set Î±) (hs : s.finite) : â‡‘(ProbabilityTheory.condCount (s âˆ© u)) t * â‡‘(ProbabilityTheory.condCount s) u + â‡‘(ProbabilityTheory.condCount (s âˆ© uá¶œ)) t * â‡‘(ProbabilityTheory.condCount s) uá¶œ = â‡‘(ProbabilityTheory.condCount s) t
{Î± : Type u_1} [Semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ b * c
{R : Type u_1} [linearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {vâ‚ vâ‚‚ : M} (h : SameRay R vâ‚ vâ‚‚) : âˆƒ (u : M) (a b : R), 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ vâ‚ = a â€¢ u âˆ§ vâ‚‚ = b â€¢ u
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {n : â„•} (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (hn : t.card * n < s.card) : âˆƒ (y : Î²) (H : y âˆˆ t), n < (Finset.filter (Î» (x : Î±), f x = y) s).card
{Î± : Type u} [Preorder Î±] {a : Î±} {s t p : Set Î±} (hs : is_is_IsLub s a) (hp : is_is_IsLub p a) (hst : s âŠ† t) (htp : t âŠ† p) : is_is_IsLub t a
(n : â„•) (R : Type u_1) [Ring R] : Polynomial.map (Int.castRingHom R) (Polynomial.cyclotomic n â„¤) = Polynomial.cyclotomic n R
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : ringChar F = 2) {a : F} (ha : a â‰  0) : char.quadratic_Char F a = 1
{R : Type u} {Î¹ : Type w} (s : Finset Î¹) [CommSemiring R] [NoZeroDivisors R] (f : Î¹ â†’ Polynomial R) (h : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  0) : (s.prod (Î» (i : Î¹), f i)).nat_degree = s.sum (Î» (i : Î¹), (f i).nat_degree)
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {f g : â„ â†’ E} {x : â„} (f_Diff : âˆ€ (y : â„), y â‰  x â†’ HasDerivAt f (g y) y) (hF : ContinuousAt f x) (hg : ContinuousAt g x) : HasDerivAt f (g x) x
{E : Type u_2} [NormedGroup E] [normedSpace â„ E] {r : â„} (hr : 0 â‰¤ r) (x : E) : x +áµ¥ r â€¢ Metric.ClosedBall 0 1 = Metric.ClosedBall x r
(n k : â„•) : n.asc_factorial k = (n + k).factorial / n.factorial
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) {râ‚ râ‚‚ : â„} : 2 â€¢ hb.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
{V : Type u} [Fintype V] {G : SimpleGraph V} [DecidableRel G.adj] {v w : V} (h : G.adj v w) : Fintype.card â†¥(G.common_neighbors v w) < G.degree v
{R : Type u} [CommRing R] {n : Type w} [DecidableEq n] [Fintype n] (M : Matrix n n R) : â‡‘(Polynomial.aeval M) M.charpoly = 0
(C : Type u_1) [CategoryTheory.Category C] : CategoryTheory.IsIdempotentComplete C â†” âˆ€ (X : C) (p : X âŸ¶ X), p â‰« p = p â†’ CategoryTheory.Limits.HasEqualizer (ðŸ™ X) p
(ð•œ : Type v) [is_R_or_C ð•œ] {E : Type u} [NormedGroup E] [normedSpace ð•œ E] (x : E) : âˆƒ (g : E â†’L[ð•œ] ð•œ), âˆ¥gâˆ¥ â‰¤ 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
{Î± : Type u} [pseudoEmetricSpace Î±] (E : Set Î±) : Closure E = â‹‚ (Î´ : â„) (h : 0 < Î´), Metric.Thickening Î´ E
{R : Type u} [Semiring R] {a b : AddMonoidAlgebra R â„•} : {toFinsupp := a} = {toFinsupp := b} â†” a = b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {n : WithTop â„•} {f : F â†’ G} {x : E Ã— F} (hF : ContDiffAt ð•œ n f x.snd) : ContDiffAt ð•œ n (Î» (x : E Ã— F), f x.snd) x
(n : â„•) : Finset.univ = Finset.cons 0 (Finset.map {ToFun := Fin.succ n, inj' := _} Finset.univ) _
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : Vector Î± n) : (Vector.scanl f b v).head = b
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [succOrder Î±] [IsSuccArchimedean Î±] [LinearOrder Î²] {f : Î± â†’ Î²} (hF : Monotone f) (m n : Î±) : (â‹ƒ (i : Î±) (H : i âˆˆ Set.Ico m n), Set.Ioc (f i) (f (Order.succ i))) = Set.Ioc (f m) (f n)
{n m : â„•} (h : n â‰  m) : IsCoprime (Polynomial.cyclotomic n â„š) (Polynomial.cyclotomic m â„š)
{Î¹ : Type u} (s : Finset Î¹) (w z : Î¹ â†’ Nnreal) (hw' : s.sum (Î» (i : Î¹), w i) = 1) (n : â„•) : s.sum (Î» (i : Î¹), w i * z i) ^ n â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ n)
{R : Type u_4} {S : Type u_5} [NonAssocSemiring R] [NonAssocSemiring S] (f : R â‰ƒ+* S) : â†‘f.to_Add_MonoidHom = â†‘f.to_Add_MonoidHom
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (h : IsUnit A.det) : Aâ»Â¹.mul A = 1
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x : Î±} {r : â„} (hs : s.nonempty) : Metric.infDist x s < r â†” âˆƒ (y : Î±) (H : y âˆˆ s), HasDist.dist x y < r
{M : Type u_1} [AddCommMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (m : Multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R â†’+* S} {s : S} (h : s âˆˆ Set.Range â‡‘f) : â‡‘Polynomial.c s âˆˆ Polynomial.lifts f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] (s1 s2 : AffineSubspace k P) : (s1 âŠ“ s2).direction â‰¤ s1.direction âŠ“ s2.direction
{p : â„•} (hp : 1 < p) : padicValRat p â†‘p = 1
{Î± : Type u} {lâ‚ lâ‚‚ : List Î±} {n : â„•} : List.take n (lâ‚ ++ lâ‚‚) = List.take n lâ‚ ++ List.take (n - lâ‚.length) lâ‚‚
 : Set.InjOn Nat.factorization {x : â„• | x â‰  0}
{M : Type u_1} [AddZeroClass M] (S : addSubmonoid M) : S = âŠ¥ âˆ¨ Nontrivial â†¥S
{ð•œ : Type u_1} {E : Type u_2} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] {x : E} {s : Set E} : StarConvex ð•œ x s â†” âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ âˆ€ â¦ƒa b : ð•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 < a + b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ s
{F : Type u_3} [innerProductSpace â„ F] {x y : F} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * HasInner.inner x y + âˆ¥yâˆ¥ ^ 2
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] [Fintype Î±] [DecidableEq Î±] (s : Finset Î±) (f : Î± â†’ Î²) : s.prod (Î» (i : Î±), f i) * sá¶œ.prod (Î» (i : Î±), f i) = finset.univ.prod (Î» (i : Î±), f i)
{Î± : Type uu} {r : Î± â†’ Î± â†’ Prop} [DecidableRel r] {l : List Î±} (h : List.Sorted r l) : List.insertionSort r l = l
{Î± : Type u} [HasSubset Î±] {a b : Î±} [IsAntisymm Î± HasSubset.Subset] (h : a âŠ† b) (h' : b âŠ† a) : b = a
{x k l : â„•} (w : 1 < x) : x ^ k âˆ£ x ^ l â†” k â‰¤ l
{Î± : Type u_1} [isEmpty Î±] : Finset.univ = âˆ…
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topologicalSpace B] [topologicalSpace F] {Proj : Z â†’ B} [topologicalSpace Z] [Nonempty F] (h : IsTopologicalFiberBundle F Proj) : Function.Surjective Proj
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (M N P : Matrix m m R) : ((M.mul N).mul P).det = ((M.mul P).mul N).det
{Î± : Type u} {Î² : Type v} [Group Î±] [mulAction Î± Î²] (g : Î±) (x : Î²) : MulAction.stabilizer Î± (g â€¢ x) = Subgroup.map (MulEquiv.toMonoidHom (â‡‘MulAut.conj g)) (MulAction.stabilizer Î± x)
{n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : â‡‘fin.cast_Succ j < i) : SimplexCategoryÎ´ i.succ â‰« SimplexCategoryÏƒ (â‡‘fin.cast_Succ j) = SimplexCategoryÏƒ j â‰« SimplexCategoryÎ´ i
{ð•œ : Type u_3} {E : Type u_4} [normedField ð•œ] [semiNormedGroup E] [normedSpace ð•œ E] {r : â„} : Balanced ð•œ (Metric.Ball 0 r)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹} (h : TendstoUniformly F f p) (x : Î±) : Filter.Tendsto (Î» (n : Î¹), F n x) p (nhds (f x))
{K : Type u} [Field K] {S T : Subfield K} (h : âˆ€ (x : K), x âˆˆ S â†” x âˆˆ T) : S = T
{Î± : Type u_3} {Î² : Type u_4} [linearOrderedField Î±] {l : Filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto f l Filter.atBot) : Filter.Tendsto (Î» (x : Î²), f x * r) l Filter.atBot
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] [âˆ€ {X Y : C} (f : X âŸ¶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)] : CategoryTheory.Limits.HasImages C
{R : Type u} {Aâ‚ : Type v} {Aâ‚‚ : Type w} [CommSemiring R] [Semiring Aâ‚] [Semiring Aâ‚‚] [Algebra R Aâ‚] [Algebra R Aâ‚‚] (e : Aâ‚ â‰ƒâ‚[R] Aâ‚‚) : â†‘â†‘e = â†‘â†‘e
{M : Type u_1} [AddZeroClass M] (c : AddCon M) : AddCon.ker c.mk' = c
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ Mon_) [CategoryTheory.IsFiltered J] (x y : Î£ (j : J), â†¥(F.obj j)) (k : J) (f : x.fst âŸ¶ k) (g : y.fst âŸ¶ k) : Mon.FilteredColimits.M.mk F x * Mon.FilteredColimits.M.mk F y = Mon.FilteredColimits.M.mk F âŸ¨k, â‡‘(F.map f) x.snd * â‡‘(F.map g) y.sndâŸ©
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} {x : Î±} (h : is_IsClosed s) (hs : s.nonempty) : x âˆ‰ s â†” 0 < Metric.infDist x s
(cf cg : Nat.Partrec.Code) (a k : â„•) : (cf.prec cg).eval (Nat.mkpair a k.succ) = (cf.prec cg).eval (Nat.mkpair a k) >>= Î» (ih : â„•), cg.eval (Nat.mkpair a (Nat.mkpair k ih))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {F : Type u_2} [NormedGroup F] [normedSpace ð•œ F] {n : â„•} {f : ð•œ â†’ F} : iteratedDeriv n f = â‡‘((ContinuousMultilinearMap.piFieldEquiv ð•œ (Fin n) F).symm) âˆ˜ iteratedFderiv ð•œ n f
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] {f : Î± â†’ Î² Ã— Î³} {x : Î±} (hF : ContinuousAt f x) : ContinuousAt (Î» (a : Î±), (f a).fst) x
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topologicalSpace B] [topologicalSpace F] {Proj : Z â†’ B} [topologicalSpace Z] [Nonempty F] (h : IsTopologicalFiberBundle F Proj) : quotientMap Proj
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] {a b : Î±} (hab : a â‰  b) : Closure (Set.Ioo a b) = Set.Icc a b
{M : Type u_3} {N : Type u_4} [MulZeroOneClass M] [MulZeroOneClass N] {f g : M â†’*â‚€ N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
{Î± : Type u_1} [hasLt Î±] {a b : Î±} {o : Ordering} : o.compares b a â†’ o.swap.compares a b
{Î± : Type u} [Group Î±] (g : GroupTopology Î±) : Continuous (Î» (p : Î± Ã— Î±), p.fst * p.snd)
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} : Metric.Bounded (s âˆª t) â†” Metric.Bounded s âˆ§ Metric.Bounded t
{X : Type u} [Preorder X] {x y : X} (h : x âŸ¶ y) : x â‰¤ y
{V : Type u} [Quiver V] (r : V) [Quiver.RootedConnected r] {a : V} (p : Quiver.Path r a) : (Quiver.shortestPath r a).length â‰¤ p.length
{ð•œ : Type u_1} [is_R_or_C ð•œ] {m : Type u_5} {n : Type u_6} [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (A : Matrix m n ð•œ) : â‡‘Matrix.toLin' A.conj_transpose = â‡‘LinearMap.adjoint (â‡‘Matrix.toLin' A)
{Î± : Type u} [pseudoMetricSpace Î±] {x y : Î±} : Metric.infDist x {y} = HasDist.dist x y
{R : Type u_1} {a b : R} [Semigroup R] (Ab : IsRegular (a * b)) (ba : IsRegular (b * a)) : IsRegular a âˆ§ IsRegular b
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [succOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Monotone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ico (f n) (f (Order.succ n)))
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.MulPosStrictMono Î±] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
{Î± : Type u_1} [hasLt Î±] {a b : Î±} : b < a â†’ â‡‘OrderDual.toDual a < â‡‘OrderDual.toDual b
{Î± : Type u} [AddGroup Î±] [hasLt Î±] [CovariantClass Î± Î± (Function.swap Add.add) LT.lt] {a b : Î±} : a < b â†’ a - b < 0
(R : Type u_1) [hasOne R] [HasNeg R] : Cardinal.mk (Quaternion R) = Cardinal.mk R ^ 4
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î²'] [DecidableEq Î³] [DecidableEq Î´] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²' â†’ Î³} {g : Î² â†’ Î²'} {f' : Î± â†’ Î² â†’ Î´} {g' : Î´ â†’ Î³} (h_Right_comm : âˆ€ (a : Î±) (b : Î²), f a (g b) = g' (f' a b)) : Finset.imageâ‚‚ f s (Finset.image g t) = Finset.image g' (Finset.imageâ‚‚ f' s t)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) : hb.oangle y x = -hb.oangle x y
{f : â„ â†’ â„} {a : â„} (h : is_is_IsLocalMin f a) : deriv f a = 0
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] {n : Type w} [Nontrivial R] {B : BilinForm R M} {v : Basis n R M} (h : B.is_Ortho â‡‘v) (hB : B.nondegenerate) (i : n) : Â¬B.is_IsOrtho (â‡‘v i) (â‡‘v i)
{Î¹ : Type u_1} {Râ‚‚ : Type u_7} {Mâ‚‚ : Type u_8} [CommRing Râ‚‚] [AddCommGroup Mâ‚‚] [Module Râ‚‚ Mâ‚‚] [DecidableEq Î¹] (e : Basis Î¹ Râ‚‚ Mâ‚‚) {w : Î¹ â†’ Râ‚‚} (hw : âˆ€ (i : Î¹), IsUnit (w i)) : e.to_Matrix â‡‘(e.is_Unit_Smul hw) = Matrix.diagonal w
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) {x : L} : x âˆˆ S â†’ -x âˆˆ S
{a b : Prop} (hâ‚ : a â†’ b) (hâ‚‚ : Â¬b) : Â¬a
{Î± : Type u_2} [Bornology Î±] {s : Set Î±} : Bornology.IsCobounded s â†’ Bornology.IsBounded sá¶œ
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [is_R_or_C ð•œ] [normedSpace ð•œ E] [NormedGroup G] [normedSpace ð•œ G] {f : E â†’ G} {s : Set E} {C : Nnreal} (hF : DifferentiableOn ð•œ f s) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderivWithin ð•œ f s xâˆ¥â‚Š â‰¤ C) (hs : Convex â„ s) : LipschitzOnWith C f s
{M : Type u} [MulOneClass M] (a : M) : SemiconjBy a 1 1
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G : C â¥¤ D} (Î± : F âŸ¶ G) [âˆ€ (X : C), CategoryTheory.Mono (Î±.app X)] : CategoryTheory.Mono Î±
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {f : M â†’* N} (h : âˆ€ (y : â†¥S), IsUnit (â‡‘f â†‘y)) (y : â†¥S) (w z : N) : w * â†‘(â‡‘(IsUnit.liftRight (f.restrict S) h) y)â»Â¹ = z â†” w = â‡‘f â†‘y * z
{K : Type u} [Field K] (s : Subfield K) : 1 âˆˆ s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] (O : Finset C) : âˆƒ (S : C), âˆ€ {X : C}, X âˆˆ O â†’ Nonempty (S âŸ¶ X)
{Î± : Type u_1} {Î² : Type u_2} {Op : Î² â†’ Î² â†’ Î²} [hc : IsCommutative Î² Op] [ha : IsAssociative Î² Op] {f : Î± â†’ Î²} {b : Î²} {s : Finset Î±} {g : Î± â†’ Î²} (hb : Op b b = b) (p : Î± â†’ Prop) [DecidablePred p] : Finset.fold Op b (Î» (i : Î±), Ite (p i) (f i) (g i)) s = Op (Finset.fold Op b f (Finset.filter p s)) (Finset.fold Op b g (Finset.filter (Î» (i : Î±), Â¬p i) s))
{F : Type u_1} [Field F] [Fintype F] : IsSquare (-1) â†” Fintype.card F % 4 â‰  3
(f : â†¥(MeasureTheory.lp â„‚ 2 haarCircle)) : HasSum (Î» (i : â„¤), â‡‘(â‡‘(fourier_series.repr) f) i â€¢ fourierLp 2 i) f
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [divisionRing K] : g.convergents' (n + 1) = (g.squash_gcf n).convergents' n
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {Î¹ : Type u_1} (b : Basis Î¹ R M) (h : Module.rank R M < Cardinal.aleph_0) : Nonempty (Fintype Î¹)
{E : Type u} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {c : â„‚} {r R : â„} (h0 : 0 < r) (hle : r â‰¤ R) {f : â„‚ â†’ E} {s : Set â„‚} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c R  Metric.Ball c r)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball c R  Metric.ClosedBall c r  s â†’ DifferentiableAt â„‚ f z) : âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) (i : Fin (n + 1)) : s.points_with_circumcenter (Affine.Simplex.PointsWithCircumcenterIndex.point_Index i) = s.points i
{C : Type uâ‚} [CategoryTheory.Category C] (X : Type vâ‚) [CategoryTheory.Limits.HasProductsOfShape X C] : CategoryTheory.Limits.HasCoproductsOfShape X Cáµ’áµ–
{Î± : Type u_1} [topologicalSpace Î±] {Î³ : Type u_4} [linearOrderedAddCommMonoid Î³] [topologicalSpace Î³] [OrderTopology Î³] {f g : Î± â†’ Î³} (hF : LowerSemicontinuous f) (hg : LowerSemicontinuous g) (hcont : âˆ€ (x : Î±), ContinuousAt (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : LowerSemicontinuous (Î» (z : Î±), f z + g z)
{Î² : Type u_2} [emetricSpace Î²] {a : Î²} {r : Ennreal} (x y : â†¥(Emetric.Ball a r)) : HasEdist.edist x.val y.val â‰  âŠ¤
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] {a b c : Î±} : a + b â‰¤ c â†’ b â‰¤ -a + c
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} (H : IsTotallySeparated s) : IsTotallyDisconnected s
{ð•œ : Type u_1} {E : Type u_2} [normedField ð•œ] [AddCommGroup E] [Module ð•œ E] [topologicalSpace E] [HasContinuousSmul ð•œ E] (x : E) : bornology.is_vonN_bounded ð•œ {x}
{Î± : Type u_1} [linearOrderedField Î±] {a b : Î±} (ha : a < 0) (hb : b < 0) : 1 / a â‰¤ 1 / b â†” b â‰¤ a
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [hasZero M] [AddCommMonoid N] {s : Finset Î±} {f : Î± â†’ M} {g : Î± â†’ M â†’ N} (hF : âˆ€ (a : Î±), f a â‰  0 â†’ a âˆˆ s) (hg : âˆ€ (a : Î±), g a 0 = 0) : (Finsupp.onFinset s f hF).sum g = s.sum (Î» (a : Î±), g a (f a))
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [topologicalSpace Î²] {s : Set Î±} {t : Set Î²} : is_IsOpen (s Ã—Ë¢ t) â†” is_IsOpen s âˆ§ is_IsOpen t âˆ¨ s = âˆ… âˆ¨ t = âˆ…
{Î± : Type u_1} {Î¹ : Type u_2} {Î² : Type u_3} {S : Î¹ â†’ Set Î±} {f : Î  (i : Î¹), â†¥(S i) â†’ Î²} {hF : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), f i âŸ¨x, hxiâŸ© = f j âŸ¨x, hxjâŸ©} {T : Set Î±} {hT : T âŠ† Set.Union S} (c : â†¥T) (ci : Î  (i : Î¹), â†¥(S i)) (hci : âˆ€ (i : Î¹), â†‘(ci i) = â†‘c) (cÎ² : Î²) (h : âˆ€ (i : Î¹), f i (ci i) = cÎ²) : Set.unionLift S f hF T hT c = cÎ²
{G : Type u_1} [AddGroup G] {k : Set G} {p : G â†’ Prop} {x : G} (h : x âˆˆ AddSubgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ p x) (H1 : p 0) (HMul : âˆ€ (x y : G), p x â†’ p y â†’ p (x + y)) (Hinv : âˆ€ (x : G), p x â†’ p (-x)) : p x
{X : Top} (F : Top.Presheaf (Type v) X) : F.is_sheaf â†” F.is_sheaf_Unique_gluing
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (X Y : C) : CategoryTheory.IsIso (CategoryTheory.Limits.cokernelÏ€ 0)
{Î± : Type u_1} {Î¹ : Type u_4} (s : Î¹ â†’ Set Î±) : (â‹‚ (i : Î¹), s i) = â‹‚ (t : Finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
{Î± : Type u} {Î² : Type v} [pseudoEmetricSpace Î±] [pseudoEmetricSpace Î²] {K : Nnreal} {f : Î± â†’ Î²} (hF : LipschitzWith K f) : UniformContinuous f
{E : Type u_1} [NormedGroup E] [normedSpace â„ E] {F : Type u_2} [NormedGroup F] [normedSpace â„ F] [FiniteDimensional â„ F] {s : Set E} {f : E â†’ F} {f' : E â‰ƒL[â„] F} {c : Nnreal} (hF : ApproximatesLinearOn f â†‘f' s c) (hc : Subsingleton E âˆ¨ lipschitzExtensionConstant F * c < âˆ¥â†‘(f'.symm)âˆ¥â‚Šâ»Â¹) : âˆƒ (g : E â‰ƒâ‚œ F), Set.EqOn f â‡‘g s
{R : Type u_1} [CommRing R] (v w : Fin 3 â†’ R) : -â‡‘(â‡‘crossProduct v) w = â‡‘(â‡‘crossProduct w) v
(p : â„•) [p_Prime : Fact (Nat.Prime p)] {nâ‚ nâ‚‚ dâ‚ dâ‚‚ : â„¤} (hnâ‚ : nâ‚ â‰  0) (hnâ‚‚ : nâ‚‚ â‰  0) (hDâ‚ : dâ‚ â‰  0) (hDâ‚‚ : dâ‚‚ â‰  0) : padicValRat p (Rat.mk nâ‚ dâ‚) â‰¤ padicValRat p (Rat.mk nâ‚‚ dâ‚‚) â†” âˆ€ (n : â„•), â†‘p ^ n âˆ£ nâ‚ * dâ‚‚ â†’ â†‘p ^ n âˆ£ nâ‚‚ * dâ‚
{R : Type u} [CommSemiring R] [starRing R] (x : R) : â‡‘(starRingEnd R) (â‡‘(starRingEnd R) x) = x
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} {f' : E â†’L[ð•œ] F} {s : Set E} {c : Nnreal} : ApproximatesLinearOn f f' s c â†’ LipschitzOnWith c (f - â‡‘f') s
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {n : WithTop â„•} (h : ContDiffOn ð•œ n f s) (hs : UniqueDiffOn ð•œ s) : HasFtaylorSeriesUpToOn n f (ftaylorSeriesWithin ð•œ f s) s
{Î± : Type u_1} (L : List (List Î±)) {i j : â„•} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : (List.take i (List.map List.length L)).sum + j < L.join.length
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semiNormedGroup E'] [semiNormedGroup F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : ((Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f' =O[l] g'
{ð•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [NormedGroup E] [NormedGroup Fâ‚—] [nondiscreteNormedField ð•œ] [normedSpace ð•œ E] [normedSpace ð•œ Fâ‚—] (c : E â†’L[ð•œ] ð•œ) (f : Fâ‚—) : âˆ¥c.smul_Right fâˆ¥ = âˆ¥câˆ¥ * âˆ¥fâˆ¥
(p : â„•) [p_Prime : Fact (Nat.Prime p)] {q r : â„š} (hq : q â‰  0) (hr : r â‰  0) : padicValRat p (q * r) = padicValRat p q + padicValRat p r
{Î“â‚€ : Type u_1} [LinearOrderedCommGroupWithZero Î“â‚€] (Î³ : Î“â‚€) (h : Î³ â‰  0) : {Î³} âˆˆ nhds Î³
{K : Type v} {V : Type w} [Field K] [AddCommGroup V] [Module K V] [IsAlgClosed K] [FiniteDimensional K V] [Nontrivial V] (f : Module.End K V) : âˆƒ (c : K), f.has_eigenvalue c
{X : Type u} [metricSpace X] [CompactSpace X] [Nonempty X] {Y : Type v} [metricSpace Y] [CompactSpace Y] [Nonempty Y] : Gromov_Hausdorff.to_GH_Space X = Gromov_Hausdorff.to_GH_Space Y â†” Nonempty (X â‰ƒáµ¢ Y)
{Î± : Type u} : TopologicalSpace.induced Pure.pure Ultrafilter.topologicalSpace = âŠ¥
(p : â„•) : â†‘(mersenne p) = 0
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {X Y Z : C} [CategoryTheory.HasRightDual X] [CategoryTheory.HasRightDual Y] [CategoryTheory.HasRightDual Z] {f : X âŸ¶ Y} {g : Y âŸ¶ Z} : (f â‰« g)á˜ = gá˜ â‰« fá˜
{Î± : Type u} [pseudoEmetricSpace Î±] : Isometry Id
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [CommMonoid Î²] {s : Finset Î±} {t : Finset Î³} {f : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (a : Î±), a âˆˆ s â†’ Î³) (hi : âˆ€ (a : Î±) (ha : a âˆˆ s), i a ha âˆˆ t) (h : âˆ€ (a : Î±) (ha : a âˆˆ s), f a = g (i a ha)) (j : Î  (a : Î³), a âˆˆ t â†’ Î±) (hj : âˆ€ (a : Î³) (ha : a âˆˆ t), j a ha âˆˆ s) (IsLeftInv : âˆ€ (a : Î±) (ha : a âˆˆ s), j (i a ha) _ = a) (IsRightInv : âˆ€ (a : Î³) (ha : a âˆˆ t), i (j a ha) _ = a) : s.prod (Î» (x : Î±), f x) = t.prod (Î» (x : Î³), g x)
{K : Type u_1} {V : Type u_2} [Field K] [Ring V] [Algebra K V] {s : Subalgebra K V} (h : FiniteDimensional K â†¥(s.to_Submodule)) : FiniteDimensional K â†¥s
{Î± : Type u_1} (l : List Î±) (c : Composition l.length) : List.map List.length (l.split_wrt_Composition c) = c.blocks
(u : Pnat.XgcdType) (hr : u.r â‰  0) : sizeof u.step < sizeof u
(A : Type u_4) (K : Type u_5) (C : Type u_6) [CommRing A] [is_IsDomain A] [Field K] [Algebra A K] [IsFractionRing A K] [CommRing C] [Algebra A C] [Algebra K C] [isScalarTower A K C] {x : C} : IsAlgebraic A x â†” IsAlgebraic K x
{k : Type u_1} {E : Type u_2} [linearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k â†’ E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : â‡‘(AffineMap.lineMap (f a) (f b)) r < f (â‡‘(AffineMap.lineMap a b) r) â†” slope f (â‡‘(AffineMap.lineMap a b) r) b < slope f a b
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (sâ‚‚ : Finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (p : Î¹ â†’ P) : Finset.centroid k (Finset.map e sâ‚‚) p = Finset.centroid k sâ‚‚ (p âˆ˜ â‡‘e)
{G : Type u} [Monoid G] (H : Submonoid G) (x : â†¥H) : IsOfFinOrder x â†” IsOfFinOrder â†‘x
{Î± : Type u_1} {Î² : Type u_2} [conditionallyCompleteLinearOrder Î±] [topologicalSpace Î±] [OrderTopology Î±] [topologicalSpace Î²] {s : Set Î²} {f : Î² â†’ Î±} (hF : ContinuousOn f s) (hsc : is_IsClosed s) {xâ‚€ : Î²} (hâ‚€ : xâ‚€ âˆˆ s) (hc : âˆ€á¶  (x : Î²) in Filter.cocompact Î² âŠ“ Filter.principal s, f xâ‚€ â‰¤ f x) : âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f x â‰¤ f y
{Î± : Type u_1} {c : Set (Set Î±)} (hu : â‹ƒâ‚€c = Set.Univ) (H : c.pairwise_Disjoint Id) (a : Î±) : âˆƒ! (b : Set Î±) (H : b âˆˆ c), a âˆˆ b
{G : Type u_4} [NormedGroup G] [normedSpace â„ G] {s : Set G} (conv : Convex â„ s) (hs : (Interior s).nonempty) {x : G} (hx : x âˆˆ Closure s) : UniqueDiffWithinAt â„ s x
{a k : â„•} (h0 : 0 < a) (h1 : a < k) (n : â„•) : (k + n).prime_counting' â‰¤ k.prime_counting' + a.totient * (n / a + 1)
{cb : CharBuffer} {n n' val : â„•} (h : Parser.nat cb n = ParseResult.done n' val) (hn : n' â‰¤ Buffer.size cb) (k : â„•) (hk : k < n') : n â‰¤ k â†’ '0' â‰¤ Buffer.read cb âŸ¨k, _âŸ© âˆ§ Buffer.read cb âŸ¨k, _âŸ© â‰¤ '9'
{Î± : Type u_1} {râ‚ râ‚‚ : Setoid Î±} : râ‚ = râ‚‚ â†” âˆ€ (x : Î±), {y : Î± | râ‚.rel x y} = {y : Î± | râ‚‚.rel x y}
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {E : Type v} [NormedGroup E] [normedSpace ð•œ E] [CompleteSpace ð•œ] {c : ð•œ} (hc : 1 < âˆ¥câˆ¥) {R : â„} (hR : âˆ¥câˆ¥ < R) (h : Â¬FiniteDimensional ð•œ E) (s : Finset E) : âˆƒ (x : E), âˆ¥xâˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ s â†’ 1 â‰¤ âˆ¥y - xâˆ¥
(R : Type u) (M : Type v) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] : Module.rank R M < Cardinal.aleph_0
{Î± : Type u_3} [orderedSemiring Î±] {n : â„•} (hn : 1 â‰¤ n) : Filter.Tendsto (Î» (x : Î±), x ^ n) Filter.atTop Filter.atTop
{Î± : Type u_1} {Î¹' : sort u_5} (s : Î¹' â†’ Set Î±) : (â‹ƒ (i : Î¹'), s i) = â‹ƒ (t : Finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
{R : Type u_1} [AddCommGroup R] {f g : â„• â†’ R} : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.sum (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.sum (Î» (x : â„• Ã— â„•), â‡‘Nat.ArithmeticFunction.moebius x.fst â€¢ g x.snd) = f n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasBinaryBiproducts C] (P Q : C) : (CategoryTheory.Limits.biprod.braiding P Q).hom â‰« (CategoryTheory.Limits.biprod.braiding Q P).hom = ðŸ™ (P âŠž Q)
{f : â„‚ â†’ â„‚} {c : â„‚} {R : â„} (hD : DifferentiableOn â„‚ f (Metric.Ball c R)) (h_maps : Set.MapsTo f (Metric.Ball c R) (Metric.Ball c R)) (hc : f c = c) (hâ‚€ : 0 < R) : Complex.abs (deriv f c) â‰¤ 1
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (f : R â†’+* S) (n : â„•) : Polynomial.x ^ n âˆˆ Polynomial.lifts f
{C : Type uâ‚} [CategoryTheory.Category C] (T : CategoryTheory.Monad C) {A B : T.algebra} (f : A âŸ¶ B) [CategoryTheory.IsIso f.f] : CategoryTheory.IsIso f
{R : Type u} [CommRing R] {p q : Polynomial R} (hmonic : q.monic) (hdegree : q.degree â‰¤ p.degree) : (p /â‚˜ q).leading_Coeff = p.leading_Coeff
{R : Type u} [NonAssocSemiring R] {s : Set R} : s âŠ† â†‘(Subsemiring.closure s)
{p a b : â„•} (hab : a.coprime b) (hpa : p âˆˆ a.factors) : â‡‘((a * b).factorization) p = â‡‘(a.factorization) p
{m n : â„•+} : m.factor_Multiset â‰¤ n.factor_Multiset â†” m âˆ£ n
{Mâ‚€ : Type u_1} [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€] {a b : Mâ‚€} : a * b = 0 â†” a = 0 âˆ¨ b = 0
{ð•œ : Type u_3} {E : Type u_4} [SemiNormedRing ð•œ] [AddCommGroup E] [Module ð•œ E] (p : Seminorm ð•œ E) (x y : E) : â‡‘p y â‰¤ â‡‘p x + â‡‘p (x - y)
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) {râ‚ râ‚‚ : â„} (hrâ‚ : 0 â‰¤ râ‚) (hrâ‚‚ : 0 â‰¤ râ‚‚) : hb.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [normedSpace ð•œ G] {s : Set E} {f : E â†’ F} {x : E} {n : WithTop â„•} (e : F â‰ƒL[ð•œ] G) : ContDiffWithinAt ð•œ n (â‡‘e âˆ˜ f) s x â†” ContDiffWithinAt ð•œ n f s x
(x : â„) : Real.sinh (Real.arsinh x) = x
{M : Type u_3} [AddMonoid M] [Preorder M] (L : List M) (h : 0 < L.sum) : 0 < L.length
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {V : Î¹ â†’ Submodule ð•œ E} (hV : OrthogonalFamily ð•œ (Î» (i : Î¹), (V i).subtypeâ‚—áµ¢)) : CompleteLattice.Independent V
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_3} (s : Finset Î¹) (f : Î¹ â†’ E) (x : E) : HasInner.inner (s.sum (Î» (i : Î¹), f i)) x = s.sum (Î» (i : Î¹), HasInner.inner (f i) x)
{G : Type u_1} [Group G] [topologicalSpace G] [NonarchimedeanGroup G] {H : Type u_2} [Group H] [topologicalSpace H] [TopologicalGroup H] (f : G â†’* H) (emb : OpenEmbedding â‡‘f) : NonarchimedeanGroup H
{p : â„•} {z : â„¤} : padicValRat p â†‘z = â†‘(padicValInt p z)
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] (s : Submodule R M) : s.fg â†” CompleteLattice.IsCompactElement s
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.swap Mul.mul) LE.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [Î  (i : Î¹), AddCommMonoid (Î² i)] : â‡‘Dfinsupp.liftAddHom (Dfinsupp.singleAddHom Î²) = AddMonoidHom.id (Î â‚€ (i : Î¹), Î² i)
{X : Type u_1} {Y : Type u_2} [pseudoEmetricSpace X] [pseudoEmetricSpace Y] {C : Nnreal} {f : X â†’ Y} {s : Set X} : LipschitzOnWith C f s â†’ HolderOnWith C 1 f s
{Î² : Type u} {Î± : Type v} {Î³ : Type w} {s : Finset Î±} [AddCommMonoid Î²] [DecidableEq Î³] (f : Î³ â†’ Î²) (g : Î± â†’ Î³) : s.sum (Î» (a : Î±), f (g a)) = (Finset.image g s).sum (Î» (b : Î³), (Finset.filter (Î» (a : Î±), g a = b) s).card â€¢ f b)
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.MulPosMono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b â‰¤ 1
{Gâ‚€ : Type u_2} {Gâ‚€' : Type u_4} [groupWithZero Gâ‚€] [groupWithZero Gâ‚€'] (f : Gâ‚€ â†’*â‚€ Gâ‚€') (a : Gâ‚€) : â‡‘f aâ»Â¹ = (â‡‘f a)â»Â¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] (P Q : C) : (CategoryTheory.Limits.coprod.braiding P Q).hom â‰« (CategoryTheory.Limits.coprod.braiding Q P).hom = ðŸ™ (P â¨¿ Q)
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (Î¸ : Real.Angle) : â‡‘LinearMap.det â†‘((o.rotation Î¸).to_linearEquiv) = 1
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {K : J â¥¤ C} {c d : CategoryTheory.Limits.Cone K} (f : c âŸ¶ d) [i : CategoryTheory.IsIso f.hom] : CategoryTheory.IsIso f
{Î± : Type u} {Î² : Type v} [Preorder Î±] [PartialOrder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : GaloisConnection l u) (b : Î²) : (âˆƒ (a : Î±), b = l a) â†” b = l (u b)
{Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [Fintype Î¹] [Preorder Î¹'] [IsDirected Î¹' (Function.swap LE.le)] [Nonempty Î¹'] {s : Î¹ â†’ Î¹' â†’ Set Î±} (hs : âˆ€ (i : Î¹), Monotone (s i)) : (â‹‚ (j : Î¹'), â‹ƒ (i : Î¹), s i j) = â‹ƒ (i : Î¹), â‹‚ (j : Î¹'), s i j
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), AddGroup (Gs i)] (tfGs : âˆ€ (i : Î·), Add_monoid.is_torsion_free (Gs i)) : Add_monoid.is_torsion_free (Î  (i : Î·), Gs i)
{V : Type u_1} (Î± : Type u_2) (G : SimpleGraph V) [DecidableRel G.adj] [hasZero Î±] [hasOne Î±] : (SimpleGraph.adjMatrix Î± G).is_adjMatrix
{C : Type uâ‚} [CategoryTheory.Category C] {X Y : C} {f : X âŸ¶ Y} [CategoryTheory.SplitEpi f] [CategoryTheory.Epi (CategoryTheory.section_ f)] : CategoryTheory.IsIso f
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (a : F) : char.quadratic_Char F a = 0 â†” a = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p âˆˆ s) (p2 : P) : p -áµ¥ p2 âˆˆ s.direction â†” p2 âˆˆ s
{Î± : Type u_1} [Semigroup Î±] {a b : Î±} (c : Î±) (h : a * c = b) : a âˆ£ b
{Î± : Type u} [topologicalSpace Î±] {s t : Set Î±} (hs : is_IsCompact s) (ht : is_IsClosed t) (h : t âŠ† s) : is_IsCompact t
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {f : Î± â†’ Î² â†’ Î³} {ta1 ta2 : topologicalSpace Î±} {tb1 tb2 : topologicalSpace Î²} {Tc1 : topologicalSpace Î³} (h : Continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)) : Continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)
{M : Type u_3} {N : Type u_4} [MulOneClass M] [MulOneClass N] (f : M â†’* N) : â‡‘f 1 = 1
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : addTorsor G P] (p1 p2 : P) : p1 -áµ¥ p2 +áµ¥ p2 = p1
(P L : Type u) [hasMem P L] [Configuration.HasLines P L] [Fintype P] [Fintype L] : Fintype.card P â‰¤ Fintype.card L
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] {Î¹ : Type u_4} (s : Finset Î¹) (w : Î¹ â†’ k) (pâ‚ : Î¹ â†’ P) (pâ‚‚ b : P) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.weighted_vsub_of_point pâ‚ b) w - s.sum (Î» (i : Î¹), w i) â€¢ (pâ‚‚ -áµ¥ b)
{Î± : Type u} {s : Set Î±} (hs : s.nonempty) : s.countable â†” âˆƒ (f : â„• â†’ â†¥s), Function.Surjective f
{ð•‚ : Type u_1} [nondiscreteNormedField ð•‚] [CompleteSpace ð•‚] [CharZero ð•‚] {x : ð•‚} (hx : x âˆˆ Emetric.Ball 0 (expSeries ð•‚ ð•‚).radius) : HasStrictDerivAt (Exp ð•‚) (Exp ð•‚ x) x
{Î± : Type u_1} {Î² : Type u_2} [topologicalSpace Î±] [BaireSpace Î±] {S : Set Î²} {f : Î² â†’ Set Î±} (hc : âˆ€ (s : Î²), s âˆˆ S â†’ is_IsClosed (f s)) (hS : S.countable) (hU : (â‹ƒ (s : Î²) (H : s âˆˆ S), f s) = Set.Univ) : Dense (â‹ƒ (s : Î²) (H : s âˆˆ S), Interior (f s))
{n : â„•} {p : Fin n} {i : Fin (n + 1)} (h : i â‰  â‡‘fin.cast_Succ p) : â‡‘((â‡‘fin.cast_Succ p).succ_above) (p.pred_above i) = i
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] (p : P) : â‡‘(EuclideanGeometry.reflection s) p = p â†” p âˆˆ s
{Î± : Type u_1} (a : Î±) [Subsingleton Î±] : Fintype.card Î± = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasWidePullbacks C] {B : C} : CategoryTheory.Limits.HasProducts (CategoryTheory.Over B)
{F : Type u_3} [innerProductSpace â„ F] (x y : F) : HasInner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = -1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), r < 0 âˆ§ y = r â€¢ x
{G : Type u} {x y : G} [AddCommMonoid G] (hx : IsOfFinAddOrder x) (hy : IsOfFinAddOrder y) : IsOfFinAddOrder (x + y)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) [Nontrivial B] : Â¬IsUnit (minpoly A x)
{Î± : Type u} {Î¹ : sort x} {f : Î¹ â†’ Filter Î±} [Nonempty Î¹] (hD : Directed GE f) (hb : âˆ€ (i : Î¹), (f i).ne_IsBot) : (infi f).ne_IsBot
{M : Type u_5} [AddCommGroup M] (h : Module â„¤ M) (n : â„¤) (x : M) : n â€¢ x = n â€¢ x
{R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} [linearOrderedField R] [AddCommGroup E] [Module R E] (s : Finset Î¹) (hs : s.nonempty) (p : Î¹ â†’ E) : Finset.centroid R s p = s.center_mass (Finset.centroidWeights R s) p
{Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : b < a) : Â¬IsMin a
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topologicalSpace Î±] [topologicalSpace Î²] [topologicalSpace Î³] (e : localHomeomorph Î± Î²) {f : Î³ â†’ Î±} {x : Î³} (h : f â»Â¹' e.to_local_equiv.source âˆˆ nhds x) : ContinuousAt f x â†” ContinuousAt (â‡‘e âˆ˜ f) x
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} : b â‰¤ a â†’ 0 â‰¤ a - b
{X : Type u_1} [topologicalSpace X] {a b : X} (Î³ : Path a b) : Continuous (Î» (x : â„ Ã— â„ Ã— â†¥UnitInterval), â‡‘(Î³.truncate x.fst x.snd.fst) x.snd.snd)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {x : E} : mfderiv (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f x = fderiv ð•œ f x
{Î± : Type u} [pseudoMetricSpace Î±] {s : â„• â†’ Set Î±} (h0 : IsComplete (s 0)) (hs : âˆ€ (n : â„•), is_IsClosed (s n)) (h's : âˆ€ (n : â„•), Metric.Bounded (s n)) (h : âˆ€ (N : â„•), (â‹‚ (n : â„•) (H : n â‰¤ N), s n).nonempty) (h' : Filter.Tendsto (Î» (n : â„•), Metric.diam (s n)) Filter.atTop (nhds 0)) : (â‹‚ (n : â„•), s n).nonempty
{G : Type w} [topologicalSpace G] [Group G] [TopologicalGroup G] {K U : Set G} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K âŠ† U) : âˆƒ (V : Set G) (H : V âˆˆ nhds 1), K * V âŠ† U
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediateField K L) (x : K) : â‡‘(algebraMap K L) x âˆˆ S
{Î± : Type u_1} [DecidableEq Î±] (xs : List Î±) (x d d' : Î±) (x_HasMem : x âˆˆ xs) (x_NE : x â‰  xs.last _) : xs.next_or x d = xs.next_or x d'
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [Ring R] [AddCommGroup M] [Module R M] {hli : LinearIndependent R v} {hsp : Submodule.span R (Set.Range v) = âŠ¤} (i : Î¹) : â‡‘((Basis.mk hli hsp).coord i) (v i) = 1
{Î± : Type u_1} [Preorder Î±] [locallyFiniteOrder Î±] {a b : Î±} : Â¬a â‰¤ b â†’ Multiset.icc a b = 0
{M : Type u_3} {N : Type u_4} [AddZeroClass M] [AddZeroClass N] {f g : M â†’+ N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
{V : Type u_1} [innerProductSpace â„ V] {P : Type u_2} [metricSpace P] [NormedAddTorsor V P] {a b c d p : P} (h : EuclideanGeometry.Cospherical {a, b, c, d}) (hab : a â‰  b) (hcd : c â‰  d) (hapb : EuclideanGeometry.angle a p b = 0) (hcpd : EuclideanGeometry.angle c p d = 0) : HasDist.dist a p * HasDist.dist b p = HasDist.dist c p * HasDist.dist d p
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [succOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Antitone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ioo (f (Order.succ n)) (f n))
(p : Nat.Primes) : â†‘p.factor_Multiset = PrimeMultiset.ofPrime p
{M : Type u_1} [hasMul M] (r : M â†’ M â†’ Prop) : conGen â‡‘(conGen r) = conGen r
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [Module.Finite K L] [IsAlgClosed E] (pB : powerBasis K L) [IsSeparable K L] (e : Fin pb.dim â‰ƒ (L â†’â‚[K] E)) : â‡‘(algebraMap K E) (Algebra.discr K â‡‘(pb.basis)) = finset.univ.prod (Î» (i : Fin pb.dim), (Finset.filter (Î» (j : Fin pb.dim), i < j) Finset.univ).prod (Î» (j : Fin pb.dim), -((â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) * (â‡‘(â‡‘e i) pb.gen - â‡‘(â‡‘e j) pb.gen))))
{S : Type u_2} [CommRing S] {K : Type u_6} [Field K] [Algebra K S] (pB : powerBasis K S) : FiniteDimensional K S
{Î± : Type u} [AddCommGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b c : Î±} : b < c - a â†’ a + b < c
{M : Type u_1} [AddMonoid M] {s : Set M} {a : M} (h : a âˆˆ Add_monoid.closure s) : âˆƒ (l : List M), (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) âˆ§ l.sum = a
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [denselyOrdered Î±] [Nontrivial Î±] {s : Set Î±} : Dense s â†” âˆ€ (a b : Î±), a < b â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), a < c âˆ§ c < b)
{ð•œ : Type u_1} {E : Type u} [linearOrderedField ð•œ] [AddCommGroup E] [Module ð•œ E] [DecidableEq E] {t : Finset E} (h : Â¬AffineIndependent ð•œ Coe) {x : E} (m : x âˆˆ â‡‘(convexHull ð•œ) â†‘t) : âˆƒ (y : â†¥â†‘t), x âˆˆ â‡‘(convexHull ð•œ) â†‘(t.erase â†‘y)
{Î± : Type u_1} [linearOrderedField Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ < b â†” bâ»Â¹ < a
{E : Type u_4} {F : Type u_5} [NormedGroup E] [normedSpace â„ E] [FiniteDimensional â„ E] [NormedGroup F] [normedSpace â„ F] {f : E â†’ F} (h : ContDiff â„ 1 f) : dimH (Set.Range f) â‰¤ â†‘(FiniteDimensional.finrank â„ E)
{p a b : â„•} (hpa : p âˆˆ a.factors) (hb : b â‰  0) : p âˆˆ (a * b).factors
{Î± : Type u_1} [Group Î±] [Fintype Î±] (s : Subgroup Î±) [Fintype â†¥s] : Fintype.card â†¥s âˆ£ Fintype.card Î±
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} (F : Top.Presheaf C X) (U : TopologicalSpace.Opens â†¥X) (R : CategoryTheory.Presieve U) : CategoryTheory.Presheaf.firstMap R F â‰« (Top.Presheaf.coveringOfPresieve.secondObjIsoPiInters F U R).hom = (Top.Presheaf.coveringOfPresieve.firstObjIsoPiOpens F U R).hom â‰« Top.Presheaf.SheafConditionEqualizerProducts.leftRes F (Top.Presheaf.coveringOfPresieve U R)
{Î± : Type u} {Î¹ : Type v} [metricSpace Î±] [ProperSpace Î±] {c : Î¹ â†’ Î±} {r : Î¹ â†’ â„} (uf : âˆ€ (x : Î±), {i : Î¹ | x âˆˆ Metric.Ball (c i) (r i)}.finite) (uU : (â‹ƒ (i : Î¹), Metric.Ball (c i) (r i)) = Set.Univ) : âˆƒ (r' : Î¹ â†’ â„), (â‹ƒ (i : Î¹), Metric.Ball (c i) (r' i)) = Set.Univ âˆ§ âˆ€ (i : Î¹), r' i < r i
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [IsIrrefl Î± r] : {c : Cardinal | âˆƒ (S : Set Î±), Set.Unbounded r S âˆ§ Cardinal.mk â†¥S = c}.nonempty
(R : Type u_2) {M : Type u_5} [Ring R] [AddCommGroup M] [Module R M] (n : â„¤) (b : M) : n â€¢ b = â†‘n â€¢ b
{Î± : Type u_1} {Î³ : Type u_3} {Î¹ : sort u_2} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {f : Filter Î±} (hF : f.has_Basis p s) {Î² : Î¹ â†’ Type u_4} {pg : Î  (i : Î¹), Î² i â†’ Prop} {sg : Î  (i : Î¹), Î² i â†’ Set Î³} {g : Set Î± â†’ Filter Î³} (hg : âˆ€ (i : Î¹), (g (s i)).has_Basis (pg i) (sg i)) (gm : Monotone g) {s_1 : Set Î³} : s_1 âˆˆ f.lift g â†” âˆƒ (i : Î¹) (hi : p i) (x : Î² i) (hx : pg i x), sg i x âŠ† s_1
(R : Type u) [Ring R] [StrongRankCondition R] {Î¹ : Type u} : Module.rank R (Î¹ â†’â‚€ R) = Cardinal.mk Î¹
{Î± : Type u_1} [completeLattice Î±] {k : Î±} (h : CompleteLattice.IsCompactElement k) : IsCoatomic â†¥(Set.Iic k)
{Î± : Type u_1} [Fintype Î±] {ð’œ : Finset (Finset Î±)} {r : â„•} : Set.Sized r â†‘ð’œ â†’ ð’œ âŠ† Finset.powersetLen r Finset.univ
{M : Type u_1} [hasMul M] {s : Set M} {p : M â†’ M â†’ Prop} {x y : M} (hx : x âˆˆ Subsemigroup.closure s) (hy : y âˆˆ Subsemigroup.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ p x y) (HMul_Left : âˆ€ (x y z : M), p x z â†’ p y z â†’ p (x * y) z) (HMul_Right : âˆ€ (x y z : M), p z x â†’ p z y â†’ p z (x * y)) : p x y
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : addTorsor V P] : affineSpan k âˆ… = âŠ¥
{Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [Fintype Î¹] [Preorder Î¹'] [IsDirected Î¹' LE.le] [Nonempty Î¹'] {s : Î¹ â†’ Î¹' â†’ Set Î±} (hs : âˆ€ (i : Î¹), Antitone (s i)) : (â‹‚ (j : Î¹'), â‹ƒ (i : Î¹), s i j) = â‹ƒ (i : Î¹), â‹‚ (j : Î¹'), s i j
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : Set P} (hs : EuclideanGeometry.Cospherical s) {p : Fin 3 â†’ P} (hps : Set.Range p âŠ† s) (hpi : Function.Injective p) : AffineIndependent â„ p
{R : Type u_1} [MulZeroClass R] : Â¬IsLeftRegular 0 â†” Nontrivial R
{Î± : Type u} [pseudoMetricSpace Î±] {s : Set Î±} (h : is_IsCompact s) : Metric.Bounded s
{Î± : Type} {d : â„•} {ds : List â„•} [Ring Î±] (x : Holor Î± (d :: ds)) : (Finset.range d).attach.sum (Î» (i : {x // x âˆˆ Finset.range d}), (Holor.unitVec d â†‘i).mul (x.slice â†‘i _)) = x
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 1)} : X.Î´ i.succ â‰« X.Ïƒ i = ðŸ™ (X.obj (SimplexCategory.mk n))
{C : Type uâ‚} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) : CategoryTheory.CoverPreserving J J (ðŸ­ C)
{Î± : Type u} [SemilatticeSup Î±] [Nonempty Î±] {s : Set Î±} (hs : s.finite) : BddAbove s
{R : Type u} [CommSemiring R] [NoZeroDivisors R] (t : Multiset (Polynomial R)) [Nontrivial R] : t.prod.degree = (Multiset.map (Î» (f : Polynomial R), f.degree) t).sum
{C : Type u} [CategoryTheory.Category C] [âˆ€ (X Y : C), Subsingleton (X âŸ¶ Y)] : CategoryTheory.EssentiallySmall C â†” Small (CategoryTheory.Skeleton C)
{Î± : sort u_1} (P : Prop) [Decidable P] (x : Â¬P â†’ Î±) (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (Î» (h : P), y _) x
{R : Type u} [Ring R] (s : Subring R) : Subring.closure â†‘s = s
{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : A â†’ A â†’ Prop} {a b : A} (ha : a âˆˆ Algebra.adjoin R s) (hb : b âˆˆ Algebra.adjoin R s) (Hs : âˆ€ (x : A), x âˆˆ s â†’ âˆ€ (y : A), y âˆˆ s â†’ p x y) (Halg : âˆ€ (râ‚ râ‚‚ : R), p (â‡‘(algebraMap R A) râ‚) (â‡‘(algebraMap R A) râ‚‚)) (Halg_Left : âˆ€ (r : R) (x : A), x âˆˆ s â†’ p (â‡‘(algebraMap R A) r) x) (Halg_Right : âˆ€ (r : R) (x : A), x âˆˆ s â†’ p x (â‡‘(algebraMap R A) r)) (HAdd_Left : âˆ€ (xâ‚ xâ‚‚ y : A), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ + xâ‚‚) y) (HAdd_Right : âˆ€ (x yâ‚ yâ‚‚ : A), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ + yâ‚‚)) (HMul_Left : âˆ€ (xâ‚ xâ‚‚ y : A), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ * xâ‚‚) y) (HMul_Right : âˆ€ (x yâ‚ yâ‚‚ : A), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ * yâ‚‚)) : p a b
{Î± : Type u} (f : Filter Î±) : (â¨† (g : Ultrafilter Î±) (hg : â†‘g â‰¤ f), â†‘g) = f
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (h : InnerProductGeometry.angle x (x - y) = InnerProductGeometry.angle y (y - x)) (hpi : InnerProductGeometry.angle x y â‰  Real.pi) : âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{R S : Type u} [CommRing R] [CommRing S] (M : Submonoid R) (R' : Type u) [CommRing R'] [Algebra R R'] [Algebra R' S] [Algebra R S] [isScalarTower R R' S] [IsLocalization M R'] (s : Set S) (x : S) (hx : x âˆˆ Submodule.span R' s) : âˆƒ (t : â†¥M), t â€¢ x âˆˆ Submodule.span R s
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w} [CategoryTheory.Category D] [CategoryTheory.ConcreteCategory D] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)] [âˆ€ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.cover X)áµ’áµ– D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)] [Î  (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (J.cover X)áµ’áµ– (CategoryTheory.forget D)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget D)] (P : Cáµ’áµ– â¥¤ D) : CategoryTheory.Presheaf.IsSheaf J (J.plus_obj (J.plus_obj P))
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] (p : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) : p.remove_zero.left_Inv i = p.left_Inv i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} (F : Top.Presheaf C X) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥X) (s : CategoryTheory.Limits.Fork (Top.Presheaf.SheafConditionEqualizerProducts.leftRes F U) (Top.Presheaf.SheafConditionEqualizerProducts.rightRes F U)) : s.Î¹ â‰« Top.Presheaf.PresieveOfCovering.piOpensToFirstObj F U â‰« Top.Presheaf.PresieveOfCovering.firstObjToPiOpens F U = s.Î¹
{k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G â†’+* R} (hâ‚ : âˆ€ (b : k), â‡‘f (Finsupp.single 1 b) = â‡‘g (Finsupp.single 1 b)) (h_of : âˆ€ (a : G), â‡‘f (Finsupp.single a 1) = â‡‘g (Finsupp.single a 1)) : f = g
{Î± : Type u_1} {Î¹ : sort u_3} [conditionallyCompleteLattice Î±] {f g : Î¹ â†’ Î±} (B : BddAbove (Set.Range g)) (H : âˆ€ (x : Î¹), f x â‰¤ g x) : supr f â‰¤ supr g
{M : Type u_1} [AddGroup M] (c : AddCon M) (n : â„¤) {w x : M} : â‡‘c w x â†’ â‡‘c (n â€¢ w) (n â€¢ x)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [normedSpace ð•œ E'] {n : WithTop â„•} {f : E â†’ E'} {s : Set E} : ContDiffOn ð•œ n f s â†’ ContMdiffOn (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') n f s
{Î± : Type u_6} {Î² : Type u_7} [hasMul Î²] [HasScalar Î± Î²] [SmulCommClass Î± Î² Î²] (s : Î±) (x y : Î²) : x * s â€¢ y = s â€¢ (x * y)
{Î± : Type u_1} [PartialOrder Î±] (c : closureOperator Î±) : _.closure_operator = c
(Î± : Type u_1) [completeLattice Î±] : WellFounded GT â†’ CompleteLattice.IsSupClosedCompact Î±
{K : Type u} {V : Type v} [divisionRing K] [AddCommGroup V] [Module K V] (h : 0 < FiniteDimensional.finrank K V) : Nontrivial V
{X : Type u_2} [emetricSpace X] {s : Set X} (h : s.subsingleton) : dimH s = 0
{Î± : Type u} [topologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {a b : Î±} (hab : a < b) (s : Set Î±) : [s âˆˆ nhdsWithin a (Set.Ioi a), s âˆˆ nhdsWithin a (Set.Ioc a b), s âˆˆ nhdsWithin a (Set.Ioo a b), âˆƒ (u : Î±) (H : u âˆˆ Set.Ioc a b), Set.Ioo a u âŠ† s, âˆƒ (u : Î±) (H : u âˆˆ Set.Ioi a), Set.Ioo a u âŠ† s].tfae
{Î¹ : Type w} [Fintype Î¹] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [Module.Finite K L] [IsSeparable K L] (b : Basis Î¹ K L) : IsUnit (Algebra.discr K â‡‘b)
{E : Type u_2} [semiNormedGroup E] [normedSpace â„ E] {r : â„} (hr : 0 < r) : r â€¢ Metric.Ball 0 1 = Metric.Ball 0 r
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’â‚€ ð•œ) (i : Î¹) : HasInner.inner (v i) (â‡‘(Finsupp.total Î¹ E ð•œ v) l) = â‡‘l i
{Î± : sort u_1} (P : Prop) [Decidable P] (a b : Î±) : Ite (Â¬P) a b = Ite P b a
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : Set Î±} (h : IsChain r s) : IsChain (Flip r) s
{Î± : Type u} [pseudoEmetricSpace Î±] {s t : Set Î±} {r : Ennreal} (H1 : âˆ€ (x : Î±), x âˆˆ s â†’ Emetric.infEdist x t â‰¤ r) (H2 : âˆ€ (x : Î±), x âˆˆ t â†’ Emetric.infEdist x s â‰¤ r) : Emetric.hausdorffEdist s t â‰¤ r
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N' : Type u_5} [AddCommGroup N'] [Module R N'] {Î¹ : Type u_6} [DecidableEq Î¹] {N'â‚‚ : Type u_7} [AddCommGroup N'â‚‚] [Module R N'â‚‚] [Fintype Î¹] (g : N' â†’â‚—[R] N'â‚‚) (f : MultilinearMap R (Î» (_x : Î¹), M) N') : â‡‘MultilinearMap.alternatization (g.comp_MultilinearMap f) = â‡‘(g.comp_AlternatingMap) (â‡‘MultilinearMap.alternatization f)
{Î± : Type u_1} {Î² : Type u_2} [uniformSpace Î±] [metricSpace Î²] {f : Î± â†’ Î²} (h : UniformEmbedding f) : Isometry f
{Î± : Type u_1} {ð•œ : Type u_14} [normedField ð•œ] {l : Filter Î±} {f g : Î± â†’ ð•œ} (hgf : âˆ€á¶  (x : Î±) in l, g x = 0 â†’ f x = 0) : Filter.Tendsto (Î» (x : Î±), f x / g x) l (nhds 0) â†’ f =o[l] g
{Î± : Type u_2} [Fintype Î±] {ð’œ : Finset (Finset Î±)} (hð’œ : IsAntichain HasSubset.Subset â†‘ð’œ) : ð’œ.card â‰¤ (Fintype.card Î±).choose (Fintype.card Î± / 2)
{Î± : Type u_2} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {r : â„•} (hð’œ : Set.Sized r â†‘ð’œ) : ð’œ.card * r â‰¤ ð’œ.shadow.card * (Fintype.card Î± - r + 1)
{a : Ennreal} : a - âŠ¤ = 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] {s : Set P} {p : P} {v : V} (hp : p âˆˆ SpanPoints k s) (hv : v âˆˆ vectorSpan k s) : v +áµ¥ p âˆˆ SpanPoints k s
{Î± : Type u} [t : topologicalSpace Î±] [TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±} {a : Set Î¹} (h : a.pairwise_Disjoint s) (ha : âˆ€ (i : Î¹), i âˆˆ a â†’ (Interior (s i)).nonempty) : a.countable
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {X Y : C} (f : X âŸ¶ Y) (i : Function.Injective â‡‘f) : CategoryTheory.Mono f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [addTorsor V P] : Function.Injective Coe
{R : Type u_1} {G : Type u_2} [CommRing R] [is_IsDomain R] [Group G] [Fintype G] (f : G â†’* R) (hF : Function.Injective â‡‘f) : IsCyclic G
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (ht : t.nonempty) (hb : s.sum (Î» (x : Î±), w x) â‰¤ t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) â‰¤ b
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] (s : AffineSubspace â„ P) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] : Function.involutive â‡‘(EuclideanGeometry.reflection s)
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x) = Real.pi
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P n) (fs : Finset (Fin (n + 1))) : Finset.centroid â„ fs s.points = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (Affine.Simplex.centroidWeightsWithCircumcenter fs)
{ð•œ : Type u_1} {Î± : Type u_2} [linearOrderedField ð•œ] {ð’œ : Finset (Finset Î±)} [Fintype Î±] (hð’œ : IsAntichain HasSubset.Subset â†‘ð’œ) : (Finset.range (Fintype.card Î± + 1)).sum (Î» (r : â„•), â†‘((ð’œ.slice r).card) / â†‘((Fintype.card Î±).choose r)) â‰¤ 1
{Î± : Type u_1} {l : List Î±} {x : Î±} : List.Duplicate x l â†” âˆƒ (n : â„•) (hn : n < l.length) (m : â„•) (hm : m < l.length) (h : n < m), x = l.nth_LE n hn âˆ§ x = l.nth_LE m hm
{Î± : Type u} [Group Î±] [hasLt Î±] [CovariantClass Î± Î± Mul.mul LT.lt] {a b c : Î±} : bâ»Â¹ * a < c â†’ a < b * c
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} [IsTrichotomous Î± r] [IsIrrefl Î² s] (f : r â†’r s) : Function.Injective â‡‘f
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (E : C â¥¤ D) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasColimitsOfShape J D] : CategoryTheory.Limits.HasColimitsOfShape J C
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [divisionRing K] {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K} (Succ_nth_s_Eq : g.s.nth (n + 1) = Option.some gp) (nth_Num_Eq : g.numerators n = ppredA) (Succ_nth_Num_Eq : g.numerators (n + 1) = predA) : g.numerators (n + 2) = gp.b * predA + gp.a * ppredA
{K : Type u} [Field K] (s : Subfield K) (m : Multiset K) : (âˆ€ (a : K), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [hasNorm F] [semiNormedGroup E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : Filter Î±} : f' =O[l] g â†’ (Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] g
{Î± : Type u_2} [AddGroup Î±] {s t : Set Î±} : Disjoint s t â†’ 0 âˆ‰ s - t
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semiNormedGroup Vâ‚] [semiNormedGroup Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_NormedGroupHom C hâˆ¥ â‰¤ Linear_order.max C 0
{Î± : Type u_1} [semiNormedGroup Î±] {r C : â„} {f : â„• â†’ Î±} (hr : r < 1) (hF : âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ C * r ^ n) : CauchySeq (Î» (s : Finset â„•), s.sum (Î» (x : â„•), f x))
{F : Type u_3} [innerProductSpace â„ F] {x y : F} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * HasInner.inner x y + âˆ¥yâˆ¥ ^ 2
(f : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfd : DifferentiableOn â„ f (Set.Ioo a b)) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), deriv f c = (f b - f a) / (b - a)
{Î± : Type u_1} [conditionallyCompleteLattice Î±] {s : Set Î±} {a b : Î±} : BddBelow s â†’ a âˆˆ s â†’ a < b â†’ HasInf.inf s < b
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C â¥¤ D) {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.additive] [CategoryTheory.Limits.PreservesFiniteLimits F] [CategoryTheory.Mono f] (ex : CategoryTheory.Exact f g) : CategoryTheory.Exact (F.map f) (F.map g)
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} {ps : Set P} (h : ps âŠ† â†‘s) [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] : EuclideanGeometry.Cospherical ps â†” âˆƒ (Center : P) (H : Center âˆˆ s) (radius : â„), âˆ€ (p : P), p âˆˆ ps â†’ HasDist.dist p Center = radius
{Î± : Type u} {a b : Î±} [MulOneClass Î±] [hasZero Î±] [Preorder Î±] [ZeroLt.MulPosStrictMono Î±] (ha : a < 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b < 1
{Î± : Type u_1} [PartialOrder Î±] (c : closureOperator Î±) : c = ClosureOperator.mkâ‚ƒ â‡‘c c.closed _ _ _
{Î± : Type u_1} {Î² : Type u_2} (t : Î±) (ts : List Î±) (r : List Î²) (ys : List Î±) (f : List Î± â†’ Î²) : (List.permutationsAux2 t ts List.nil ys f).snd ++ r = (List.permutationsAux2 t ts r ys f).snd
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} [Nonempty â†¥s] [CompleteSpace â†¥(s.direction)] {pâ‚ : P} (pâ‚‚ : P) (r : â„) (hpâ‚ : pâ‚ âˆˆ s) : â‡‘(EuclideanGeometry.reflection s) (r â€¢ (pâ‚‚ -áµ¥ â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) pâ‚‚)) +áµ¥ pâ‚) = -(r â€¢ (pâ‚‚ -áµ¥ â†‘(â‡‘(EuclideanGeometry.orthogonalProjection s) pâ‚‚))) +áµ¥ pâ‚
{E : Type u_1} [NormedGroup E] [normedSpace â„‚ E] [CompleteSpace E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚} (hF : CircleIntegrable f c R) (hw : Complex.abs w < R) : (cauchyPowerSeries f c R).sum w = (2 * â†‘Real.pi * Complex.i)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z
{R : Type u_1} {S : Type u_2} {M : Type u_3} {Î¹ : Type u_4} [CommSemiring R] [Semiring S] [AddCommMonoid M] [Algebra R S] [Module R M] [Module S M] [isScalarTower R S M] (hinj : Function.Injective â‡‘(algebraMap R S)) {v : Î¹ â†’ M} (li : LinearIndependent S v) : LinearIndependent R v
{ð•œ : Type u_1} {F : Type u_3} [is_R_or_C ð•œ] [AddCommGroup F] [Module ð•œ F] [c : InnerProductSpace.Core ð•œ F] (x y : F) : is_R_or_C.abs (HasInner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{n : â„•} [Fact (0 < n)] (i : Zmod n) : orderOf (DihedralGroup.r i) = n / n.gcd i.val
{Î± : Type u_2} {Gâ‚€ : Type u_6} [groupWithZero Gâ‚€] [mulAction Gâ‚€ Î±] [topologicalSpace Î±] [HasContinuousConstSmul Gâ‚€ Î±] {c : Gâ‚€} {s : Set Î±} {x : Î±} (hs : s âˆˆ nhds x) (hc : c â‰  0) : c â€¢ s âˆˆ nhds (c â€¢ x)
{M : Type u_1} [Monoid M] {N : Type u_2} [Monoid N] {f : M â†’ N} (hF : IsMonoidHom f) {s : Set N} (hs : IsSubmonoid s) : IsSubmonoid (f â»Â¹' s)
(f f' : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hff' : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt f (f' x) x) (g g' : â„ â†’ â„) (hgc : ContinuousOn g (Set.Icc a b)) (hgg' : âˆ€ (x : â„), x âˆˆ Set.Ioo a b â†’ HasDerivAt g (g' x) x) : âˆƒ (c : â„) (H : c âˆˆ Set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {Î¹ : Type u_3} {s : Finset Î¹} {wâ‚ wâ‚‚ : Î¹ â†’ â„} (p : Î¹ â†’ P) (hâ‚ : s.sum (Î» (i : Î¹), wâ‚ i) = 1) (hâ‚‚ : s.sum (Î» (i : Î¹), wâ‚‚ i) = 1) : HasDist.dist (â‡‘(s.affine_combination p) wâ‚) (â‡‘(s.affine_combination p) wâ‚‚) * HasDist.dist (â‡‘(s.affine_combination p) wâ‚) (â‡‘(s.affine_combination p) wâ‚‚) = -s.sum (Î» (iâ‚ : Î¹), s.sum (Î» (iâ‚‚ : Î¹), (wâ‚ - wâ‚‚) iâ‚ * (wâ‚ - wâ‚‚) iâ‚‚ * (HasDist.dist (p iâ‚) (p iâ‚‚) * HasDist.dist (p iâ‚) (p iâ‚‚)))) / 2
{Î± : Type u_1} [linearOrderedField Î±] {a b c d : Î±} (hc : c â‰  0) (hD : d â‰  0) : (a * d - b * c) / (c * d) < 0 â†’ a / c < b / d
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [linearOrderedField K] (s_Pos : âˆ€ {gp : GeneralizedContinuedFraction.Pair K} {m : â„•}, m < n â†’ g.s.nth m = Option.some gp â†’ 0 < gp.a âˆ§ 0 < gp.b) : g.convergents n = g.convergents' n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryCoproducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{Î± : Type u} {Î¹ : sort x} {f : Î¹ â†’ Î±} : Function.Surjective f â†’ Set.Range f = Set.Univ
{M : Type u_1} [hasMul M] {s : Set M} {p : M â†’ Prop} {x : M} (h : x âˆˆ Subsemigroup.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (HMul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) : p x
(p : â„•) [p_Prime : Fact (Nat.Prime p)] {q r : â„š} (hqr : q + r â‰  0) : Linear_order.min (padicValRat p q) (padicValRat p r) â‰¤ padicValRat p (q + r)
{R : Type u_1} [linearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Nontrivial R] [Nonempty Î¹] (e : Basis Î¹ R M) (x : Orientation R M Î¹) : (e.adjust_to_Orientation x).orientation = x
{R : Type u_1} [CommRing R] [Fintype R] (p : â„•) [Fact (Nat.Prime p)] : p âˆ£ ringChar R â†” p âˆ£ Fintype.card R
{Î± : Type u} [topologicalSpace Î±] [LocallyCompactSpace Î±] {x : Î±} {U : Set Î±} (hU : is_IsOpen U) (hx : x âˆˆ U) : âˆƒ (K : Set Î±), is_IsCompact K âˆ§ x âˆˆ Interior K âˆ§ K âŠ† U
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasFiniteProducts D] (F : C â¥¤ D) {L : D â¥¤ C} [CategoryTheory.CartesianClosed C] [CategoryTheory.CartesianClosed D] [CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] (h : L âŠ£ F) (A : C) [i : CategoryTheory.IsIso (CategoryTheory.frobeniusMorphism F h A)] : CategoryTheory.IsIso (CategoryTheory.expComparison F A)
{Î± : Type u_1} {Î² : Type u_2} {Op : Î² â†’ Î² â†’ Î²} [hc : IsCommutative Î² Op] [ha : IsAssociative Î² Op] {f : Î± â†’ Î²} {b : Î²} {s : Finset Î±} [IsIdempotent Î² Op] {g : Î± â†’ Î²} (p : Î± â†’ Prop) [DecidablePred p] : Finset.fold Op b (Î» (i : Î±), Ite (p i) (f i) (g i)) s = Op (Finset.fold Op b f (Finset.filter p s)) (Finset.fold Op b g (Finset.filter (Î» (i : Î±), Â¬p i) s))
(R : Type u) [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] (p : Polynomial S) : p âˆˆ Polynomial.lifts (algebraMap R S) â†” p âˆˆ (Polynomial.mapAlg R S).range
{R : Type u_1} [orderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {x y : M} : SameRay R x y â†’ SameRay R (-x) (-y)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [hasNorm E] [hasNorm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : (âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)) â†’ f =o[l] g
{R : Type u_2} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R] {a b c : R} (ha : a â‰  0) : (âˆ€ {d : R}, d âˆ£ a â†’ d âˆ£ c â†’ Â¬Prime d) â†’ a âˆ£ b * c â†’ a âˆ£ b
(ð•œ : Type u_1) {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] {Î¹ : Type u_3} [LinearOrder Î¹] [OrderBot Î¹] [locallyFiniteOrder Î¹] [IsWellOrder Î¹ LT.lt] [succOrder Î¹] [IsSuccArchimedean Î¹] (f : Î¹ â†’ E) (n : Î¹) (hâ‚€ : LinearIndependent ð•œ f) : gramSchmidt ð•œ f n â‰  0
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (h : b.orientation = o) (x y : V) : o.oangle x y = hb.oangle x y
{ð•œ : Type u} [nondiscreteNormedField ð•œ] {f g : ð•œ â†’ ð•œ} {f' a : ð•œ} (hg : ContinuousAt g a) (hF : HasDerivAt f f' (g a)) (hF' : f' â‰  0) (hfg : âˆ€á¶  (y : ð•œ) in nhds a, f (g y) = y) : HasDerivAt g f'â»Â¹ a
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] [Algebra R S] {Î¹ : Type w} [Fintype Î¹] (b : Basis Î¹ R S) (x : R) : â‡‘(Algebra.norm R) (â‡‘(algebraMap R S) x) = x ^ Fintype.card Î¹
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} {Râ‚ƒ : Type u_3} [Semiring Râ‚] [Semiring Râ‚‚] [Semiring Râ‚ƒ] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Ïƒâ‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ} {Ïƒâ‚â‚ƒ : Râ‚ â†’+* Râ‚ƒ} [RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [RingHomSurjective Ïƒâ‚â‚‚] [RingHomSurjective Ïƒâ‚‚â‚ƒ] : RingHomSurjective Ïƒâ‚â‚ƒ
{Gâ‚€ : Type u_2} [groupWithZero Gâ‚€] (a : Gâ‚€) : aâ»Â¹ * a * a = a
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] {a : Î±} : 0 â‰¤ -a â†” a â‰¤ 0
{Î± : Type u_1} {M : Type u_5} {N : Type u_6} [AddCommMonoid M] [AddCommMonoid N] {s : Set Î±} (f : Î± â†’ M) (g : M â†’+ N) (hs : s.finite) : â‡‘g (finsum (Î» (j : Î±), finsum (Î» (H : j âˆˆ s), f j))) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), â‡‘g (f i)))
{Î± : Type u_1} {Î² : Type u_2} [hasAdd Î±] [AddCommGroup Î²] {f : Î± â†’ Î²} (hF : IsAddHom f) : IsAddHom (Î» (a : Î±), -f a)
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [CommMonoid M] (s : Finset (Î± Ã— Î²)) (f : Î± Ã— Î² â†’ M) : finprod (Î» (Ab : Î± Ã— Î²), finprod (Î» (h : Ab âˆˆ s), f Ab)) = finprod (Î» (a : Î±), finprod (Î» (b : Î²), finprod (Î» (h : (a, b) âˆˆ s), f (a, b))))
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] (a : R) : Module.IsTorsionBy R â†¥(Submodule.torsionBy R M a) a
{Î± : Type u} (l : List Î±) (n k : â„•) (hk : k < l.length) : (l.rotate n).nth_LE ((l.length - n % l.length + k) % l.length) _ = l.nth_LE k hk
{Î± : Type u} [pseudoMetricSpace Î±] {s t : Set Î±} {x : Î±} (h : s âŠ† t) (hs : s.nonempty) : Metric.infDist x t â‰¤ Metric.infDist x s
{G : Type u_1} [CommGroup G] (K : Subgroup G) {Î¹ : Type u_2} {t : Finset Î¹} {f : Î¹ â†’ G} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ K) : t.prod (Î» (c : Î¹), f c) âˆˆ K
{M : Type u_1} [hasMul M] (c : Con M) {x y z : M} : â‡‘c x y â†’ â‡‘c y z â†’ â‡‘c x z
(n : â„•) : (Finset.Nat.antidiagonal n).card = n + 1
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [LinearOrder Î±] [OrderClosedTopology Î±] [Nonempty Î±] [topologicalSpace Î²] [hasOne Î±] {f : Î² â†’ Î±} (hF : Continuous f) (h : HasCompactMulSupport f) : BddAbove (Set.Range f)
{Î± : Type u} {Î² : Type v} [pseudoEmetricSpace Î±] [pseudoEmetricSpace Î²] {K : Nnreal} {f : Î± â†’ Î²} (hF : LipschitzWith K f) : Continuous f
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [normedSpace ð•œ E'] {f : E â†’ E'} {x : E} {f' : TangentSpace (modelWithCornersSelf ð•œ E) x â†’L[ð•œ] TangentSpace (modelWithCornersSelf ð•œ E') (f x)} : HasFderivAt f f' x â†’ HasMfderivAt (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f x f'
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] {a b : Î±} [NoMinOrder Î±] : a â‰  b â†’ Order.pred a â‰  Order.pred b
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {n : WithTop â„•} [CompleteSpace ð•œ] (f : localHomeomorph ð•œ ð•œ) {fâ‚€' a : ð•œ} (hâ‚€ : fâ‚€' â‰  0) (ha : a âˆˆ f.to_local_equiv.target) (hFâ‚€' : HasDerivAt â‡‘f fâ‚€' (â‡‘(f.symm) a)) (hF : ContDiffAt ð•œ n â‡‘f (â‡‘(f.symm) a)) : ContDiffAt ð•œ n â‡‘(f.symm) a
{R : Type u_1} [normedRing R] [CompleteSpace R] (x : RË£) (n : â„•) : (Î» (t : R), Ring.inverse (â†‘x + t) - (Finset.range n).sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ n
{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [innerProductSpace ð•œ E] (K : Submodule ð•œ E) (h : IsComplete â†‘K) (u : E) : âˆƒ (v : E) (H : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥
{Î± : Type u_1} {P : Set Î± â†’ Prop} {m : Î  (s : Set Î±), P s â†’ Ennreal} {P0 : P âˆ…} {m0 : m âˆ… P0 = 0} (PU : âˆ€ â¦ƒf : â„• â†’ Set Î±â¦„, (âˆ€ (i : â„•), P (f i)) â†’ P (â‹ƒ (i : â„•), f i)) (msU : âˆ€ â¦ƒf : â„• â†’ Set Î±â¦„ (hm : âˆ€ (i : â„•), P (f i)), m (â‹ƒ (i : â„•), f i) _ â‰¤ âˆ‘' (i : â„•), m (f i) _) (m_Mono : âˆ€ â¦ƒsâ‚ sâ‚‚ : Set Î±â¦„ (hsâ‚ : P sâ‚) (hsâ‚‚ : P sâ‚‚), sâ‚ âŠ† sâ‚‚ â†’ m sâ‚ hsâ‚ â‰¤ m sâ‚‚ hsâ‚‚) (s : Set Î±) : MeasurableSet s â†” âˆ€ (t : Set Î±), P t â†’ â‡‘(MeasureTheory.inducedOuterMeasure m P0 m0) (t âˆ© s) + â‡‘(MeasureTheory.inducedOuterMeasure m P0 m0) (t  s) â‰¤ â‡‘(MeasureTheory.inducedOuterMeasure m P0 m0) t
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x : V) : hb.oangle x x = 0
{Î± : Type u} (r s : Î± â†’ Î± â†’ Prop) [isNonstrictStrictOrder Î± r s] {a b : Î±} : s a b â†” r a b âˆ§ Â¬r b a
{Î± : Type u} [topologicalSpace Î±] {s t : Set Î±} (hs : IsPreconnected s) (ht : is_IsClopen t) (hne : (s âˆ© t).nonempty) : s âŠ† t
{Î± : Type u} [AddCommGroup Î±] [hasLt Î±] [CovariantClass Î± Î± Add.add LT.lt] {a b c : Î±} : a + b < c â†’ b < c - a
{Î² : Type u} {Î± : Type v} {Î³ : Type w} [CommSemiring Î²] [CommSemiring Î³] (g : Î² â†’+* Î³) (f : Î± â†’ Î²) (s : Finset Î±) : â‡‘g (s.prod (Î» (x : Î±), f x)) = s.prod (Î» (x : Î±), â‡‘g (f x))
{Î± : Type u} [AddMonoid Î±] (f : â„• â†’ Î±) (n : â„•) : (List.map f (List.range n.succ)).sum = f 0 + (List.map (Î» (i : â„•), f i.succ) (List.range n)).sum
{Î± : Type u_1} {Î² : Type u_3} [measurableSpace Î±] [measurableSpace Î²] {Î½ : MeasureTheory.Measure Î²} [MeasureTheory.SigmaFinite Î½] {f : Î± â†’ Î² â†’ Ennreal} (hF : Measurable (Function.uncurry f)) : Measurable (Î» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½)
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [Module.Finite K L] [IsAlgClosed E] (pB : powerBasis K L) [IsSeparable K L] (e : Fin pb.dim â‰ƒ (L â†’â‚[K] E)) : â‡‘(algebraMap K E) (Algebra.discr K â‡‘(pb.basis)) = (-1) ^ (FiniteDimensional.finrank K L * (FiniteDimensional.finrank K L - 1) / 2) * finset.univ.prod (Î» (i : Fin pb.dim), (Finset.filter (Î» (j : Fin pb.dim), i < j) Finset.univ).prod (Î» (j : Fin pb.dim), (â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) * (â‡‘(â‡‘e i) pb.gen - â‡‘(â‡‘e j) pb.gen)))
{R : Type uâ‚} [orderedSemiring R] {a : R} (Hsq : 0 â‰¤ a * a) (Hsq' : 0 â‰¤ (1 + a) * (1 + a)) (H : 0 â‰¤ 2 + a) (n : â„•) : 1 + â†‘n * a â‰¤ (1 + a) ^ n
(M : Type u_1) (Î± : Type u_2) [Group M] [mulAction M Î±] {Î¹ : sort u_3} {P : Î¹ â†’ Subgroup M} : MulAction.FixedPoints â†¥(supr P) Î± = â‹‚ (i : Î¹), MulAction.FixedPoints â†¥(P i) Î±
{R : Type u} [Ring R] (s : Subring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
 : â‡‘MeasureTheory.MeasureSpace.volume (â‹ƒ (p : â„) (hp : 2 < p), {x : â„ | LiouvilleWith p x}) = 0
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : Real.cos (InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = -1
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cáµ’áµ– â¥¤ A) : CategoryTheory.Presheaf.IsSheaf J P â†” âˆ€ â¦ƒX : Câ¦„ (S : CategoryTheory.Sieve X), S âˆˆ â‡‘J X â†’ Nonempty (CategoryTheory.Limits.IsLimit (P.map_cone S.arrows.cocone.op))
{Î± : Type u} [AddGroup Î±] [HasLe Î±] [CovariantClass Î± Î± Add.add LE.le] [CovariantClass Î± Î± (Function.swap Add.add) LE.le] {a b : Î±} : -a â‰¤ b â†’ -b â‰¤ a
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {f : E â†’ F} (K : Set (E â†’L[ð•œ] F)) : {x : E | DifferentiableAt ð•œ f x âˆ§ fderiv ð•œ f x âˆˆ K} âŠ† FderivMeasurableAux.D f K
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryBiproducts C] (X : C) [CategoryTheory.Simple X] : CategoryTheory.Indecomposable X
{V : Type u_1} [innerProductSpace â„ V] {x y : V} (h : InnerProductGeometry.angle x y = Real.pi) : HasInner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
(x : Pgame) : (1 * x).equiv x
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} (f : c.quotient â†’* P) : c.lift (f.comp c.mk') _ = f
{Î± : Type u_1} {râ‚ râ‚‚ : Setoid Î±} : râ‚ = râ‚‚ â†” râ‚.rel = râ‚‚.rel
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [orderedSemiring ð•œ] [AddCommGroup E] [Module ð•œ E] {p : Î¹ â†’ E} (hc : ConvexIndependent ð•œ p) : ConvexIndependent ð•œ (Î» (x : â†¥(Set.Range p)), â†‘x)
{R : Type u_1} [addRightCancelSemigroup R] (g : R) : IsAddRightRegular g
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x y : V) : o.oangle x (-y) + o.oangle y (-x) = 0
{Î± : Type u_1} {E : Î± â†’ Type u_2} {p : Ennreal} [Î  (i : Î±), NormedGroup (E i)] [Fact (1 â‰¤ p)] : UniformContinuous Coe
{Î± : Type u} {Î² : Type v} {M : Type w} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linearOrderedCancelAddCommMonoid M] (hF : âˆ€ (y : Î²), y âˆ‰ t â†’ 0 â‰¤ (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)) (ht : t.nonempty) (hb : s.sum (Î» (x : Î±), w x) â‰¤ t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), (Finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) â‰¤ b
{Î± : Type u} {Î² : Type v} [topologicalSpace Î±] [LinearOrder Î±] [OrderClosedTopology Î±] [Nonempty Î±] [topologicalSpace Î²] [hasZero Î±] {f : Î² â†’ Î±} (hF : Continuous f) (h : HasCompactSupport f) : BddBelow (Set.Range f)
{ð•œ : Type u_1} [nondiscreteNormedField ð•œ] {E : Type u_2} [NormedGroup E] [normedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [normedSpace ð•œ F] {s : Set E} {f : E â†’ F} {x : E} {n : WithTop â„•} {p : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n f p s) {m : â„•} (hmn : â†‘m â‰¤ n) (hs : UniqueDiffOn ð•œ s) (hx : x âˆˆ s) : p x m = iteratedFderivWithin ð•œ m f s x
{Î± : Type u_1} [linearOrderedField Î±] {a b c : Î±} (hb : 0 â‰¤ b) (hc : 0 â‰¤ c) (h : a â‰¤ c * b) : a / b â‰¤ c
{Ï„ : Type u_1} [AddMonoid Ï„] [topologicalSpace Ï„] [HasContinuousAdd Ï„] {Î± : Type u_2} [topologicalSpace Î±] (Ï• : Flow Ï„ Î±) {Î² : Type u_3} [topologicalSpace Î²] {t : Î² â†’ Ï„} (ht : Continuous t) {f : Î² â†’ Î±} (hF : Continuous f) : Continuous (Î» (x : Î²), â‡‘Ï• (t x) (f x))
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] {s : Finset Î±} {t : Finset Î²} {f : Î± â†’ Î²} {n : â„•} (hF : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (ht : t.nonempty) (hn : t.card * n â‰¤ s.card) : âˆƒ (y : Î²) (H : y âˆˆ t), n â‰¤ (Finset.filter (Î» (x : Î±), f x = y) s).card
{R : Type u_2} {M : Type u_3} {N : Type u_4} [CommSemiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N] {m : Type u_1} {n : Type u_5} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] (bM : Basis m R M) (bN : Basis n R N) (j : m) (i : n) : â‡‘(LinearMap.toMatrix bM bN) (â‡‘(dualTensorHom R M N) (bM.coord j âŠ—â‚œ[R] â‡‘bN i)) = Matrix.stdBasisMatrix i j 1
(n : â„•) (Î¸ : â„‚) : Complex.sin ((â†‘n + 1) * Î¸) = Polynomial.eval (Complex.cos Î¸) (Polynomial.Chebyshev.u â„‚ n) * Complex.sin Î¸
{Î± : Type u} [topologicalSpace Î±] [t2_Space Î±] [CompactSpace Î±] (x : Î±) : ConnectedComponent x = â‹‚ (Z : {Z // is_IsClopen Z âˆ§ x âˆˆ Z}), â†‘Z
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {Î¹ : Type u_4} [Invertible 2] (p : Î¹ â†’ P) (iâ‚ iâ‚‚ : Î¹) : Finset.centroid k {iâ‚, iâ‚‚} p = 2â»Â¹ â€¢ (p iâ‚‚ -áµ¥ p iâ‚) +áµ¥ p iâ‚
{G : Type u_1} [AddGroup G] (K : AddSubgroup G) {k : Set G} : AddSubgroup.closure k â‰¤ K â†” k âŠ† â†‘K
{R : Type u_1} {M : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup M] [Module R M] [NoZeroDivisors R] {B : M â†’â‚—[R] M â†’â‚—[R] R} (v : Basis n R M) (hO : B.is_Ortho â‡‘v) (h : âˆ€ (i : n), Â¬B.is_IsOrtho (â‡‘v i) (â‡‘v i)) : B.nondegenerate
{V : Type u_1} [innerProductSpace â„ V] {b : Basis (Fin 2) â„ V} (hb : Orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : r < 0) : hb.oangle x (r â€¢ y) = hb.oangle x (-y)
{R : Type u1} [CommSemiring R] {M : Type u2} [AddCommMonoid M] [Module R M] {A : Type u_1} [Semiring A] [Algebra R A] {f g : ExteriorAlgebra R M â†’â‚[R] A} (h : f.to_Linear_map.comp (ExteriorAlgebraÎ¹ R) = g.to_Linear_map.comp (ExteriorAlgebraÎ¹ R)) : f = g
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {s : AffineSubspace â„ P} {p1 p2 : P} (hp1 : p1 âˆˆ s) (hp2 : p2 âˆˆ s) (r1 r2 : â„) {v : V} (hv : v âˆˆ (s.direction)á—®) : HasDist.dist (r1 â€¢ v +áµ¥ p1) (r2 â€¢ v +áµ¥ p2) * HasDist.dist (r1 â€¢ v +áµ¥ p1) (r2 â€¢ v +áµ¥ p2) = HasDist.dist p1 p2 * HasDist.dist p1 p2 + (r1 - r2) * (r1 - r2) * (âˆ¥vâˆ¥ * âˆ¥vâˆ¥)
{Î³ : Type u_3} [tÎ³ : topologicalSpace Î³] [PolishSpace Î³] [measurableSpace Î³] [BorelSpace Î³] {Î² : Type u_4} [tÎ² : topologicalSpace Î²] [t2_Space Î²] [measurableSpace Î²] [BorelSpace Î²] {f : Î³ â†’ Î²} [TopologicalSpace.SecondCountableTopology Î²] (f_Meas : Measurable f) (f_inj : Function.Injective f) : MeasurableEmbedding f
 : Cardinal.mk â†¥Set.Univ = Cardinal.continuum
{R : Type x} [hasMul R] [hasAdd R] [leftDistribClass R] (a b c : R) : a * (b + c) = a * b + a * c
{Î± : Type u_1} [linearOrderedField Î±] {m n : â„•} : â†‘(m / n) â‰¤ â†‘m / â†‘n
{V : Type u_1} [innerProductSpace â„ V] [hD2 : Fact (FiniteDimensional.finrank â„ V = 2)] (o : Orientation â„ V (Fin 2)) (x : V) {r : â„} (hr : 0 â‰¤ r) : o.oangle (r â€¢ x) x = 0
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {f : Î± â†’ Î²} (hF : Monotone f) : Pairwise (Disjoint on Î» (n : Î±), Set.Ioc (f (Order.pred n)) (f n))
{V : Type u_1} {P : Type u_2} [innerProductSpace â„ V] [metricSpace P] [NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P (n + 2)) {iâ‚ iâ‚‚ : Fin (n + 3)} : (s.monge_plane iâ‚ iâ‚‚).direction = (Submodule.span â„ {s.points iâ‚ -áµ¥ s.points iâ‚‚})á—® âŠ“ vectorSpan â„ (Set.Range s.points)
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] (f : M â†’+ P) : Function.Injective â‡‘(AddCon.kerLift f)
{Î± : Type u} [topologicalSpace Î±] {s : Set Î±} : s.nonempty â†’ (Closure s).nonempty
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [CommMonoid M] [DecidableEq Î±] [DecidableEq Î²] (s : Finset (Î± Ã— Î²)) (f : Î± Ã— Î² â†’ M) : finprod (Î» (Ab : Î± Ã— Î²), finprod (Î» (h : Ab âˆˆ s), f Ab)) = finprod (Î» (a : Î±), finprod (Î» (b : Î²), finprod (Î» (h : b âˆˆ Finset.image Prod.snd (Finset.filter (Î» (Ab : Î± Ã— Î²), ab.fst = a) s)), f (a, b))))
{X : Type u_1} {Y : Type u_2} [topologicalSpace X] {f : X â†’ Y} (hF : IsLocallyConstant f) {s : Set X} (hs : IsPreconnected s) {x y : X} (hx : x âˆˆ s) (hy : y âˆˆ s) : f x = f y
{Î¹ : Type u_1} {R : Type u_8} [canonicallyOrderedCommSemiring R] {f g h : Î¹ â†’ R} {s : Finset Î¹} {i : Î¹} (hi : i âˆˆ s) (h2i : g i + h i â‰¤ f i) (hgf : âˆ€ (j : Î¹), j âˆˆ s â†’ j â‰  i â†’ g j â‰¤ f j) (hhf : âˆ€ (j : Î¹), j âˆˆ s â†’ j â‰  i â†’ h j â‰¤ f j) : s.prod (Î» (i : Î¹), g i) + s.prod (Î» (i : Î¹), h i) â‰¤ s.prod (Î» (i : Î¹), f i)
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {x y : M} (f : M â†’â‚—[R] N) (h : SameRay R x y) : SameRay R (â‡‘f x) (â‡‘f y)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [divisionRing k] [AddCommGroup V] [Module k V] [addTorsor V P] {pâ‚ pâ‚‚ : P} (h : pâ‚ â‰  pâ‚‚) : AffineIndependent k ![pâ‚, pâ‚‚]
{Î± : Type u_1} [Preorder Î±] [locallyFiniteOrder Î±] {a b : Î±} : Â¬a < b â†’ Finset.ico a b = âˆ…
{M : Type u_1} [Monoid M] (a : M) (u : MË£) : IsUnit (a * â†‘u) â†” IsUnit a
{Î± : Type u} {Î² : Type v} [DecidableEq Î±] [CommMonoid Î²] {s : Finset Î±} {x : Î±} (h : x âˆ‰ s) (f : Finset Î± â†’ Î²) : (HasInsert.insert x s).powerset.prod (Î» (a : Finset Î±), f a) = s.powerset.prod (Î» (a : Finset Î±), f a) * s.powerset.prod (Î» (t : Finset Î±), f (HasInsert.insert x t))
{Î± : Type u} [topologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ Set Î±) (hZd : Directed Superset Z) (hZn : âˆ€ (i : Î¹), (Z i).nonempty) (hZc : âˆ€ (i : Î¹), is_IsCompact (Z i)) (hZcl : âˆ€ (i : Î¹), is_IsClosed (Z i)) : (â‹‚ (i : Î¹), Z i).nonempty
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} {P : Type uâ‚„} [AddCommGroup V] [addTorsor V P] [CommRing k] [Module k V] [DecidableEq Î¹] [Fintype Î¹] (b bâ‚‚ : AffineBasis Î¹ k P) (x : P) : (b.to_Matrix bâ‚‚.points).det â€¢ â‡‘(bâ‚‚.coords) x = â‡‘((b.to_Matrix bâ‚‚.points).transpose.cramer) (â‡‘(b.coords) x)
{M : Type u_1} [semiNormedGroup M] (S : AddSubgroup M) (m : M) : âˆ¥â†‘mâˆ¥ â‰¤ âˆ¥mâˆ¥
