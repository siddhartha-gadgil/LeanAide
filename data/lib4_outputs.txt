{Î± : Type u} [PseudoMetricSpace Î±] (x y z : Î±) : HasNndist.nndist x z â‰¤ HasNndist.nndist x y + HasNndist.nndist y z
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] : IsNoetherian K v â†” module.rank K v < Cardinal.aleph0
{Î± : Type u_2} [DecidableEq Î±] {S : Finset Î±} {B : Finset (Finset Î±)} {n : â„•} (h : âˆ€ (A : Î±), A âˆˆ S â†’ (Finset.Filter (HasMem.Mem A) B).Card â‰¤ n) : B.Sum (Î» (t : Finset Î±), (S âˆ© t).Card) â‰¤ S.Card * n
{R : Type u_1} {n : â„•} {m : Fin n â†’ Type u_3} {mâ‚‚ : Type u_4} [CommSemiring R] [AddCommMonoid mâ‚‚] [Î  (i : Fin n), AddCommMonoid (m i)] [Î  (i : Fin n), module R (m i)] [module R mâ‚‚] {F g : MultilinearMap R m mâ‚‚} {Î¹â‚ : Fin n â†’ Type u_2} (e : Î  (i : Fin n), Basis (Î¹â‚ i) R (m i)) (h : âˆ€ (v : Î  (i : Fin n), Î¹â‚ i), â‡‘F (Î» (i : Fin n), â‡‘(e i) (v i)) = â‡‘g (Î» (i : Fin n), â‡‘(e i) (v i))) : F = g
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] (F : top.sheaf C x) (U : TopologicalSpace.Opens â†¥x) (S t : â†¥(F.val.obj (Opposite.Op U))) (h : âˆ€ (x : â†¥U), â‡‘(F.val.germ x) S = â‡‘(F.val.germ x) t) : S = t
{G : Type u_7} [AddGroup G] (L : List G) (i : â„•) (P : i < L.length) : (List.Drop (i + 1) L).Sum = -L.nth_LE i P + (List.Drop i L).Sum
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} : A - B < 0 â†” A < B
{ð•œ : Type u_1} {ð• : Type u_2} {E : Type u_3} [NormedField ð•œ] [NormedRing ð•] [NormedSpace ð•œ ð•] [AddCommGroup E] [module ð•œ E] [SmulWithZero ð• E] [IsScalarTower ð•œ ð• E] {S : set E} (hs : Balanced ð• S) {A : ð•} {B : ð•œ} (h : âˆ¥Aâˆ¥ â‰¤ âˆ¥Bâˆ¥) : A â€¢ S âŠ† B â€¢ S
{C : Type u} [CategoryTheory.Category C] (i P : CategoryTheory.Arrow C) (h : CategoryTheory.Limits.IsInitial i.Left) : CategoryTheory.HasLiftingProperty i P â†” âˆ€ {e : i.Right âŸ¶ P.Right}, âˆƒ (l : i.Right âŸ¶ P.Left), l â‰« P.hom = e
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [ZeroLt.PosMulMono Î±] (ha : A â‰¤ 1) (hb : B â‰¤ 1) (A0 : 0 < A) : A * B â‰¤ 1
(R : Type u_1) [CommRing R] {n m : â„•} (hpos : 0 < n) (hm : m âˆ£ n) (hdiff : m â‰  n) : Polynomial.x ^ m - 1 âˆ£ n.proper_divisors.Prod (Î» (i : â„•), Polynomial.cyclotomic i R)
{m : Type u_6} {N : Type u_7} [has_Mul m] [has_Mul N] (e : m â‰ƒ* N) (y : N) : â‡‘e (â‡‘(e.Symm) y) = y
(P : â„•) : WittVector.IsPoly P (Î» (R : Type u_1) (_Rcr : CommRing R), witt_Vector.verschiebung_fun)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : E â†’ F} (g : F â†’L[ð•œ] G) (hF : ContDiff ð•œ n F) : ContDiff ð•œ n (Î» (x : E), â‡‘g (F x))
{R : Type u_1} [AddMonoid R] (A : AddUnits R) : IsAddRegular â†‘A
{Î± : Type u_1} [TopologicalSpace Î±] (S : set (set Î±)) (hS : âˆ€ (S : â†¥S), IsOpen â†‘S) [hS' : âˆ€ (S : â†¥S), QuasiSober â†¥S] (hS'' : â‹ƒâ‚€S = âŠ¤) : QuasiSober Î±
{Î± : Type u_1} {n : Type u_4} [has_Zero Î±] [Subsingleton n] (A : Matrix n n Î±) : A.IsDiag
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set â„} [IntervalIntegral.FTC_Filter B (nhds_within B S) (nhds_within B t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within B t) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds_within B t âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) (hs : UniqueDiffWithinAt â„ S B . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (Î» (u : â„), âˆ« (x : â„) in A..u, F x) S B = C
{C : Type uâ‚} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} : â‡‘S (ðŸ™ x) â†” S = âŠ¤
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : HasDist.dist P1 P3 * HasDist.dist P1 P3 = HasDist.dist P1 P2 * HasDist.dist P1 P2 + HasDist.dist P3 P2 * HasDist.dist P3 P2 â†” EuclideanGeometry.angle P1 P2 P3 = Real.Pi / 2
{m : Type u_2} [AddCommGroup m] {ð•œ : Type u_1} [Field ð•œ] [module ð•œ m] {F : m â†’â‚—[ð•œ] m} (hF : â‡‘LinearMap.det F = 0) : âŠ¥ < F.Ker
{m : Type u_2} {n : Type u_3} {R : Type u_7} [Fintype n] [Fintype m] [NonUnitalSemiring R] (v : m â†’ R) (A : Matrix m n R) (W : n â†’ R) : Matrix.dot_Product v (A.Mul_vec W) = Matrix.dot_Product (Matrix.vec_Mul v A) W
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type uâ‚‚} [CategoryTheory.Category D] [CategoryTheory.Abelian D] (F : C â¥¤ D) (G : D â¥¤ C) [G.preserves_Zero_morphisms] (i : F â‹™ G â‰… ðŸ­ C) [CategoryTheory.Limits.PreservesFiniteLimits G] : CategoryTheory.Limits.HasKernels C
{v : Type u} (G : SimpleGraph v) {v W : v} : G.Adj v W â†” v â‰  W âˆ§ âˆƒ (e : Sym2 v) (h : e âˆˆ G.edge_set), v âˆˆ e âˆ§ W âˆˆ e
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [module ð•œ E] {S : set E} : S.Nonempty â†’ (â‡‘(Convex_hull ð•œ) S).Nonempty
{G : Type u_1} [AddGroup G] [Fintype G] (P : â„•) [hp : Fact (Nat.Prime P)] (hdvd : P âˆ£ Fintype.Card G) : âˆƒ (x : G), Add_order_of x = P
{Î± : Type u} [HasSubset Î±] [HasSsubset Î±] [IsNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {A B C : Î±} [IsTrans Î± HasSubset.Subset] (hâ‚ : A âŠ‚ B) (hâ‚‚ : B âŠ† C) : A âŠ‚ C
{R : Type u} {S : Type v} [CommRing R] [CommRing S] (F : R â†’+* S) : Function.Injective â‡‘(F.Ker_Lift)
{G : Type u_1} [AddCommGroup G] (F : â„• â†’ G) (n : â„•) : (Finset.Range n).Sum (Î» (i : â„•), F (i + 1) - F i) = F n - F 0
{m : Type u_2} [AddCommGroup m] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] {A : Type u_5} [CommRing A] [module A m] (B : Basis Î¹ A m) (F : m â†’â‚—[A] m) : â‡‘(LinearMap.det_aux (Trunc.Mk B)) F = (â‡‘(Linear_Map.to_Matrix B B) F).det
{Î± : Type u_1} {l l' : List Î±} : l <+ l' â†” âˆƒ (F : â„• â†ªo â„•), âˆ€ (ix : â„•), l.nth ix = l'.nth (â‡‘F ix)
{C : Type u} [CategoryTheory.Category C] {x Y Z : C} {i : CategoryTheory.Arrow C} {F : x âŸ¶ Y} {g : Y âŸ¶ Z} (hF : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.Mk F)) (hg : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.Mk g)) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.Mk (F â‰« g))
{Î± : Type u_1} [has_LT Î±] {A B : Î±áµ’áµˆ} : B < A â†’ â‡‘order_dual.of_dual A < â‡‘order_dual.of_dual B
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e e' : LocalHomeomorph Î± Î²} (h : e â‰ˆ e') : e.to_local_Equiv.Target = e'.to_local_Equiv.Target
{Î± : Type u} [TopologicalSpace Î±] [SigmaCompactSpace Î±] {F : Î± â†’ set Î±} {S : set Î±} (hs : IsClosed S) (hF : âˆ€ (x : Î±), x âˆˆ S â†’ F x âˆˆ nhds_within x S) : âˆƒ (t : set Î±) (h : t âŠ† S), t.countable âˆ§ S âŠ† â‹ƒ (x : Î±) (h : x âˆˆ t), F x
{R : Type u_1} {G : Type u_2} [CommRing R] [IsDomain R] [Group G] [Fintype G] (F : G â†’* R) [Decidable (F = 1)] : Finset.Univ.Sum (Î» (g : G), â‡‘F g) = Ite (F = 1) â†‘(Fintype.Card G) 0
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] {C : Type u} [CategoryTheory.Category C] (F : J Ã— K â¥¤ C) [CategoryTheory.Limits.HasLimits_of_shape J C] [CategoryTheory.Limits.HasColimits_of_shape K C] (j : J) (k : K) : CategoryTheory.Limits.ColimitÎ¹ (CategoryTheory.Curry.obj (CategoryTheory.Prod.Swap K J â‹™ F) â‹™ CategoryTheory.Limits.lim) k â‰« CategoryTheory.Limits.Colimit_Limit_to_Limit_Colimit F â‰« CategoryTheory.Limits.LimitÏ€ (CategoryTheory.Curry.obj F â‹™ CategoryTheory.Limits.colim) j = CategoryTheory.Limits.LimitÏ€ ((CategoryTheory.Curry.obj (CategoryTheory.Prod.Swap K J â‹™ F)).obj k) j â‰« CategoryTheory.Limits.ColimitÎ¹ ((CategoryTheory.Curry.obj F).obj j) k
{B : â„} (A x : â„) (h2 : 0 < B) : âˆ« (x : â„) in A..x, Real.Exp (-B * x) â‰¤ Real.Exp (-B * A) / B
{F : Type u_1} {K : Type u_2} {L : Type u_3} [Field F] [Field K] [Field L] [Algebra F K] [Algebra F L] (S : Finset K) : (âˆ€ (x : K), x âˆˆ S â†’ IsIntegral F x âˆ§ Polynomial.Splits (Algebra_Map F L) (minpoly F x)) â†’ Nonempty (â†¥(Algebra.Adjoin F â†‘S) â†’â‚[F] L)
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B C : Î±} : A - C < B â†’ A < B + C
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hst : S âŠ† t) (ht : (t âˆ© Function.MulSupport F).Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ t  S), F i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ t), F i))
{R : Type u_1} [Semiring R] (x y : DualNumber R) : (x * y).Snd = TrivSqZeroExt.fst x * TrivSqZeroExt.Snd y + TrivSqZeroExt.fst y * TrivSqZeroExt.Snd x
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A u' : Î±} {S : set Î±} (hu' : A < u') : S âˆˆ nhds_within A (set.ioi A) â†” âˆƒ (u : Î±) (h : u âˆˆ set.ioi A), set.Ioo A u âŠ† S
{Î² : Type u_4} [LinearOrder Î²] [NoMaxOrder Î²] {u : â„• â†’ Î²} (hu : Filter.Tendsto u Filter.at_top Filter.at_top) : âˆƒá¶  (n : â„•) in Filter.at_top, âˆ€ (k : â„•), k < n â†’ u k < u n
{Î“â‚€ : Type u_1} [Linear_ordered_comm_Group_with_Zero Î“â‚€] (Î³ : Î“â‚€Ë£) : {x : Î“â‚€ | x < â†‘Î³} âˆˆ nhds 0
{Î² : Type u_2} {F g : Î² â†’ Nnreal} {r : Nnreal} (hgf : âˆ€ (B : Î²), g B â‰¤ F B) (hfr : has_Sum F r) : âˆƒ (P : Nnreal) (h : P â‰¤ r), has_Sum g P
(C : Turing.ToPartrec.Code) (k k' : Turing.ToPartrec.Cont) (v : List â„•) : Turing.ToPartrec.step_Normal C (k.then k') v = (Turing.ToPartrec.step_Normal C k v).then k'
{C : Type uâ‚} [CategoryTheory.Category C] {t : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] [CategoryTheory.Limits.PreservesColimitsOfShape J â†‘t] (D : J â¥¤ t.Algebra) [CategoryTheory.Limits.HasColimit (D â‹™ t.Forget)] : CategoryTheory.Limits.HasColimit D
{R : Type u_1} {Î¹ : Type u_4} [Linear_ordered_Field R] [Fintype Î¹] {F : Î¹ â†’ R} (hF : F âˆˆ StdSimplex R Î¹) (x : Î¹) : F x âˆˆ set.icc 0 1
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] (Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚) (Ïƒâ‚‚â‚ : Râ‚‚ â†’+* Râ‚) [RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} [CategoryTheory.Limits.HasEqualizer F g] [CategoryTheory.Epi (CategoryTheory.Limits.EqualizerÎ¹ F g)] : F = g
{Î± : Type u} [PseudoMetricSpace Î±] (x : Î±) : Emetric.Ball x âŠ¤ = set.Univ
{Î± : Type u_1} (P : Pmf Î±) {S t : set Î±} (h : S âˆ© P.Support âŠ† t) : â‡‘(P.to_OuterMeasure) S â‰¤ â‡‘(P.to_OuterMeasure) t
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] : 0 â‰¤ (GeneralizedContinuedFraction.of v).denominators n
{n : WithTop â„•} {ð•‚ : Type u_6} [_R_or_C ð•‚] {F' : Type u_8} [NormedGroup F'] [NormedSpace ð•‚ F'] {F : ð•‚ â†’ F'} {x : ð•‚} (hF : ContDiff ð•‚ n F) (hn : 1 â‰¤ n) : HasStrictDerivAt F (deriv F x) x
{P q x : â„} (h : LiouvilleWith P x) (hle : q â‰¤ P) : LiouvilleWith q x
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (S : set P) : P âˆˆ S â†’ P âˆˆ SpanPoints k S
{Î± : Type u_1} [CompleteLattice Î±] [IsCompactlyGenerated Î±] {A : Î±} {S : set Î±} : A âŠ“ HasSup.Sup S = â¨† (t : Finset Î±) (h : â†‘t âŠ† S), A âŠ“ t.Sup Id
{C : Type u_1} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) : CategoryTheory.CoverLifting J J (ðŸ­ C)
{Î¹ : Type u_1} {x : Î¹ â†’ Type u_2} [Î  (i : Î¹), TopologicalSpace (x i)] {as bs : Î  (i : Î¹), x i} (i : Î¹) (Paths : Î  (i : Î¹), Path.Homotopic.Quotient (as i) (bs i)) : Path.Homotopic.Proj i (Path.Homotopic.Pi Paths) = Paths i
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle â„ P) : t.orthocenter = 3 â€¢ (Finset.centroid â„ Finset.Univ t.points -áµ¥ Affine.Simplex.circumcenter t) +áµ¥ Affine.Simplex.circumcenter t
{Î± : Type u_1} [has_LT Î±] {A B : Î±} (h : A < B) : Â¬A â‹– B â†’ (âˆƒ (C : Î±), A < C âˆ§ C < B)
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î± â†’ Î³} (hF : Continuous F) : Continuous (Î» (x : Î± Ã— Î²), F x.fst)
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [rÎ± : non_unital_non_assoc_Semiring Î±] [rÎ² : non_unital_non_assoc_Semiring Î²] {rÎ³ : non_unital_non_assoc_Semiring Î³} {Î´ : Type u_1} {rÎ´ : non_unital_non_assoc_Semiring Î´} (F : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) (h : Î³ â†’â‚™+* Î´) : (h.Comp g).Comp F = h.Comp (g.Comp F)
(Î“â‚€ : Type u_1) [Linear_ordered_comm_Group_with_Zero Î“â‚€] : Directed Ge (Î» (Î³â‚€ : Î“â‚€Ë£), Filter.principal {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
(n : â„•) {A : â„} (h : Real.sqrt_two_Add_series (â†‘0 / â†‘1) n â‰¤ 2 - (A / 2 ^ (n + 1)) ^ 2) : A < Real.Pi
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x : C} (P : x âŸ¶ x) (hp : P â‰« P = P) : (ðŸ™ x - P) â‰« (ðŸ™ x - P) = ðŸ™ x - P
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hst : S âŠ† t) (ht : t.Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ t  S), F i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ t), F i))
{Î± : Type u_1} {Î² : Type u_4} [PartialOrder Î±] [PartialOrder Î²] {u : Î² â†’ Î±} (l : LowerAdjoint u) : l.IsClosed = set.Range (u âˆ˜ â‡‘l)
{G : Type u} [Group G] [Fintype G] {P n : â„•} [hp : Fact (Nat.Prime P)] (hdvd : P ^ (n + 1) âˆ£ Fintype.Card G) {h : Subgroup G} (hH : Fintype.Card â†¥h = P ^ n) : P ^ (n + 1) âˆ£ Fintype.Card â†¥(h.Normalizer)
{E : Type u_1} {Î² : Type u_2} [AddCommGroup E] [TopologicalSpace E] [module â„ E] [topological_AddGroup E] [has_Continuous_Smul â„ E] [ordered_AddCommGroup Î²] [module â„ Î²] [OrderedSmul â„ Î²] {S : set E} {F : E â†’ Î²} {A : E} (A_in_S : A âˆˆ S) (h_localmax : IsLocalMaxOn F S A) (h_conc : ConcaveOn â„ S F) : IsMaxOn F S A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {x : E} {n : â„•} : iterated_fderiv ð•œ (n + 1) F x = (â‡‘(Continuous_multilinear_Curry_Right_Equiv' ð•œ n E F) âˆ˜ iterated_fderiv ð•œ n (Î» (y : E), fderiv ð•œ F y)) x
{Î¹ : Type u_1} {R : Type u_2} [CommRing R] [LinearOrder Î¹] (S : Finset Î¹) (F g : Î¹ â†’ R) : S.Prod (Î» (i : Î¹), F i - g i) = S.Prod (Î» (i : Î¹), F i) - S.Sum (Î» (i : Î¹), g i * (Finset.Filter (Î» (_x : Î¹), _x < i) S).Prod (Î» (j : Î¹), F j - g j) * (Finset.Filter (Î» (j : Î¹), i < j) S).Prod (Î» (j : Î¹), F j))
(P : â„•) [Fact (Nat.Prime P)] (A : â„¤) : Zmod.legendre_Sym P A = 0 â†” â†‘A = 0
(i j : â„•) (h : j + 1 = i) : AlgebraicTopology.DoldKan.C.Rel i j
{Î± : Type u_1} [MetricSpace Î±] {K : Nnreal} {F : Î± â†’ Î±} (hF : ContractingWith K F) [Nonempty Î±] [CompleteSpace Î±] : Function.IsFixedPt F (ContractingWith.fixed_point F hF)
{Î± : Type u_1} [has_Mul Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A B C D : Î±} (hâ‚ : A < B) (hâ‚‚ : C < D) : A * C < B * D
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F g : Î± â†’ m} (hF : (Function.MulSupport F).Finite) (hg : (Function.MulSupport g).Finite) : finprod (Î» (i : Î±), F i * g i) = finprod (Î» (i : Î±), F i) * finprod (Î» (i : Î±), g i)
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} : 0 â‰¤ metric.Hausdorff_dist S t
{K : Type u} [Field K] (S : Subfield K) {l : List K} : (âˆ€ (x : K), x âˆˆ l â†’ x âˆˆ S) â†’ l.Sum âˆˆ S
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (u : E) {v : E} (hv : v âˆˆ (Submodule.Span ð•œ {u})á—®) : HasInner.inner u v = 0
{R : Type u_1} {A : R} [CancelMonoidWithZero R] [Nontrivial R] : IsRegular A â†” A â‰  0
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {A : Î±} {S : set Î±} (F : Î± â†’ m) (h : A âˆ‰ S) (hs : (S âˆ© Function.Support F).Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ HasInsert.Insert A S), F i)) = F A + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i))
{Î± : Type u_1} {n : Type u_4} [has_Zero Î±] [DecidableEq n] {A : Matrix n n Î±} (h : A.IsDiag) : Matrix.Diagonal A.diag = A
{R : Type u_1} [CommRing R] [IsDomain R] {F : Polynomial R} {P : Ideal R} (hP : P.Prime) (hfl : F.leading_Coeff âˆ‰ P) (hfP : âˆ€ (n : â„•), â†‘n < F.degree â†’ F.Coeff n âˆˆ P) (hfd0 : 0 < F.degree) (h0 : F.Coeff 0 âˆ‰ P ^ 2) (hu : F._primitive) : Irreducible F
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x : Î±} (h : S.Nonempty) : Emetric.Inf_edist x S â‰  âŠ¤
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {xâ‚ xâ‚‚ y z : v} (hxâ‚yne : xâ‚ â‰  y) (hxâ‚zne : xâ‚ â‰  z) (hxâ‚‚yne : xâ‚‚ â‰  y) (hxâ‚‚zne : xâ‚‚ â‰  z) {r : â„} (hxâ‚ : âˆ¥xâ‚âˆ¥ = r) (hxâ‚‚ : âˆ¥xâ‚‚âˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : 2 â€¢ o.oangle (y - xâ‚) (z - xâ‚) = 2 â€¢ o.oangle (y - xâ‚‚) (z - xâ‚‚)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = Real.Pi) : HasDist.dist P3 P2 â‰  0
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [module ð•œ Î²] [LinearOrder E] {S : set E} {F : E â†’ Î²} (hs : Convex ð•œ S) (hF : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ S â†’ y âˆˆ S â†’ x < y â†’ âˆ€ â¦ƒA B : ð•œâ¦„, 0 < A â†’ 0 < B â†’ A + B = 1 â†’ A â€¢ F x + B â€¢ F y < F (A â€¢ x + B â€¢ y)) : strict_ConcaveOn ð•œ S F
{m : Type u_1} [AddZeroClass m] {P : m â†’ Prop} (x : m) {S : set m} (hs : AddSubmonoid.Closure S = âŠ¤) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (h1 : P 0) (HMul : âˆ€ (x y : m), P x â†’ P y â†’ P (x + y)) : P x
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (hx : x â‰  0) (hy : y â‰  0) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” InnerProductGeometry.angle x y = 0
{D : set â„} (hD : Convex â„ D) (hDâ‚‚ : IsOpen D) {F : â„ â†’ â„} (hF' : DifferentiableOn â„ F D) (hF'' : âˆ€ (x : â„), x âˆˆ D â†’ 0 < deriv^[2] F x) : strict_Convex_on â„ D F
{r P : Nnreal} : â†‘(r - P) = â†‘r - â†‘P
{G : Type u_1} [Group G] (h : â„• â†’ Subgroup G) (hH : IsDescendingCentralSeries h) (n : â„•) : lower_central_series G n â‰¤ h n
(P : â„•) [P_Prime : Fact (Nat.Prime P)] (q : â„š) : padic_val_rat P qâ»Â¹ = -padic_val_rat P q
{k : Type u_1} {v : Type u_2} [Ring k] [AddCommGroup v] [module k v] {Î¹ : Type u_4} (S : Finset Î¹) (P : Î¹ â†’ v) (W : Î¹ â†’ k) (hw : S.Sum (Î» (i : Î¹), W i) = 1) : â‡‘(S.affine_combination P) W = S.Sum (Î» (i : Î¹), W i â€¢ P i)
{Î± : Type u} [Preorder Î±] {F : â„¤ â†’ Î±} (hF : Antitone F) (n : â„¤) {x : Î±} (h1 : F (n + 1) < x) (h2 : x < F n) (A : â„¤) : F A â‰  x
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} {C : â„‚} {R C : â„} (hR : 0 < R) (hc : Continuous_on F (Metric.Sphere C R)) (hF : âˆ€ (z : â„‚), z âˆˆ Metric.Sphere C R â†’ âˆ¥F zâˆ¥ â‰¤ C) (hlt : âˆƒ (z : â„‚) (h : z âˆˆ Metric.Sphere C R), âˆ¥F zâˆ¥ < C) : âˆ¥âˆ® (z : â„‚) in C(C, R), F zâˆ¥ < 2 * Real.Pi * R * C
{Î± : Type u_1} [MeasurableSpace Î±] {F : â„• â†’ Î± â†’ Ennreal} {g : Î± â†’ Ennreal} (hF : âˆ€ (i : â„•), Measurable (F i)) (lim : Filter.Tendsto F Filter.at_top (nhds g)) : Measurable g
{Î¹ : Type u} {F g : Î¹ â†’ Nnreal} {A B : Nnreal} {P q : â„} (hpq : P.IsConjugateExponent q) (hF : has_Sum (Î» (i : Î¹), F i ^ P) (A ^ P)) (hg : has_Sum (Î» (i : Î¹), g i ^ q) (B ^ q)) : âˆƒ (C : Nnreal), C â‰¤ A * B âˆ§ has_Sum (Î» (i : Î¹), F i * g i) C
{Î± : Type u_1} {Î² : Type u_2} {la : Filter Î±} {lb : Filter Î²} {F : Î± â†’ set Î²} : Filter.Tendsto F la lb.Small_sets â†” âˆ€ (t : set Î²), t âˆˆ lb â†’ (âˆ€á¶  (x : Î±) in la, F x âŠ† t)
(R : Type u_1) [CommRing R] [local_Ring R] (q : â„•) [Char_R_q : Char_P R q] : q = 0 âˆ¨ Prime_Pow q
(x y : Pgame) : x < y âˆ¨ x.Equiv y âˆ¨ y < x âˆ¨ x.Fuzzy y
{m : Type u_1} [MulOneClass m] (S : Submonoid m) : S = âŠ¥ âˆ¨ Nontrivial â†¥S
{R : Type u_1} {A : R} [Monoid R] (n : â„•) (rla : IsLeftRegular A) : IsLeftRegular (A ^ n)
{G : Type u_1} [Group G] (h : Subgroup G) {x : G} : x âˆˆ h â†’ xâ»Â¹ âˆˆ h
(ð•œ : Type u_1) (E : Type u_2) [OrderedSemiring ð•œ] [ordered_AddCommGroup E] [module ð•œ E] [OrderedSmul ð•œ E] : (Convex_cone.PositiveCone ð•œ E).salient
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S u : set E} {F : E â†’ F} {x : E} {n : â„•} (hu : u âˆˆ nhds_within x S) (hs : UniqueDiffOn ð•œ S) (xs : x âˆˆ S) : iterated_fderiv_within ð•œ n F (S âˆ© u) x = iterated_fderiv_within ð•œ n F S x
{C : Type uâ‚} [CategoryTheory.Category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {x : C} (S : CategoryTheory.Sieve x) : CategoryTheory.Presieve.IsSheafFor P â‡‘S â†” Nonempty (CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofÎ¹ (CategoryTheory.Equalizer.fork_Map P â‡‘S) _))
{x : Type u} {Y : Type v} [Preorder x] [Preorder Y] (F : x â¥¤ Y) : Monotone F.obj
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {mâ‚ : Type u_4} [TopologicalSpace mâ‚] [AddCommMonoid mâ‚] {mâ‚‚ : Type u_6} [TopologicalSpace mâ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚ mâ‚] [module Râ‚‚ mâ‚‚] [Ring_hom_surjective Ïƒâ‚â‚‚] [TopologicalSpace Râ‚] [TopologicalSpace Râ‚‚] [has_Continuous_Smul Râ‚ mâ‚] [has_Continuous_Add mâ‚] [has_Continuous_Smul Râ‚‚ mâ‚‚] [has_Continuous_Add mâ‚‚] {F : mâ‚ â†’sl[Ïƒâ‚â‚‚] mâ‚‚} (hF' : DenseRange â‡‘F) {S : Submodule Râ‚ mâ‚} (hs : S.topological_Closure = âŠ¤) : (Submodule.Map â†‘F S).topological_Closure = âŠ¤
{Î± : Type u_1} {Î¹ : sort u_4} {Î¹' : sort u_5} {S : Î¹ â†’ Î¹' â†’ set Î±} : (â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), S i j) âŠ† â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), S i j
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [CommMonoid m] {g : Î² â†’ m} (e : Î± â†’ Î²) (hEâ‚€ : Function.Bijective e) : finprod (Î» (i : Î±), g (e i)) = finprod (Î» (j : Î²), g j)
 : Real.cos (Real.Pi / 6) ^ 2 = 3 / 4
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î² â†’ Î³} {x : Î± Ã— Î²} (hF : Continuous_at F x.Snd) : Continuous_at (Î» (x : Î± Ã— Î²), F x.Snd) x
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {B : power_Basis S A} (hB : IsIntegral R B.gen) [IsDomain S] (hmin : minpoly S B.gen = Polynomial.Map (Algebra_Map R S) (minpoly R B.gen)) (n : â„•) (i : Fin B.dim) : IsIntegral R (â‡‘(â‡‘(B.Basis.repr) (B.gen ^ n)) i)
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] [Nonempty Î²] [has_One Î±] {F : Î² â†’ Î±} (hF : Continuous F) (h : HasCompactMulSupport F) : âˆƒ (x : Î²), âˆ€ (y : Î²), F y â‰¤ F x
{m : Type u_1} {Îº : Type u_2} [AddCommMonoid m] (S : Finset m) [Fintype Îº] (C : m â†’ Îº) : âˆƒ (A : â„•) (h : A > 0) (B : m) (C : Îº), âˆ€ (S : m), S âˆˆ S â†’ C (A â€¢ S + B) = C
{R : Type u_1} {A : R} [Monoid R] {n : â„•} (n0 : 0 < n) : IsRightRegular (A ^ n) â†” IsRightRegular A
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : LocalHomeomorph Î± Î²) {B : Î²} (hb : B âˆˆ e.to_local_Equiv.Target) {F : Î² â†’ E} {g : Î² â†’ F} : F =O[nhds B] g â†” (F âˆ˜ â‡‘e) =O[nhds (â‡‘(e.Symm) B)] (g âˆ˜ â‡‘e)
(A : Type u_2) (K : Type u_3) [CommRing A] [Field K] [IsDomain A] [Algebra A K] [_fraction_Ring A K] (L : Type u_4) [Field L] [Algebra K L] [Finite_dimensional K L] [Algebra A L] [IsScalarTower A K L] : âˆƒ (S : Finset L) (B : Basis â†¥S K L), âˆ€ (x : â†¥S), IsIntegral A (â‡‘B x)
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {F : m â†’* P} (x : m) : â‡‘(Con.Ker_Lift F) â†‘x = â‡‘F x
{Î± : Type u_1} {S : set (set Î±)} (hs : IsPiSystem S) : MeasurableSpace.generate_from S = (MeasurableSpace.DynkinSystem.generate S).to_MeasurableSpace _
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup vâ‚‚] [module k vâ‚‚] [AddTorsor vâ‚‚ Pâ‚‚] {P : Î¹ â†’ P} (e : P â‰ƒáµƒ[k] Pâ‚‚) : AffineIndependent k (â‡‘e âˆ˜ P) â†” AffineIndependent k P
{Î± : Type u_1} {Î² : Type u_2} [conditionally_CompleteLattice Î±] [SemilatticeSup Î²] {F g : Î² â†’ Î±} (h : Antitone (Î» (n : Î²), set.icc (F n) (g n))) (h' : âˆ€ (n : Î²), F n â‰¤ g n) : (â¨† (n : Î²), F n) âˆˆ â‹‚ (n : Î²), set.icc (F n) (g n)
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) : S.normed_Mk._Quotient
{C : Type u} [CategoryTheory.Category C] {A B R : C} {F g : R âŸ¶ A} {q : A âŸ¶ B} (h : CategoryTheory.IsKernelPair q F g) : CategoryTheory.IsReflexivePair F g
{Î± : Type u} [PseudoEmetricSpace Î±] (F : â„• â†’ Î±) {m n : â„•} (h : m â‰¤ n) : HasEdist.edist (F m) (F n) â‰¤ (Finset.Ico m n).Sum (Î» (i : â„•), HasEdist.edist (F i) (F (i + 1)))
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {F : Î± â†’ Î² â†’ Î³} (hF : Function.Injective2 F) (B : Î²) : Function.Injective (Î» (A : Î±), F A B)
{Î± : Type u_1} (F : Î± â†’ Î±) (x : Î±) : Function.IsPeriodicPt F 0 x
{Î± : Type u_3} {Î² : Type u_4} [Linear_ordered_Field Î±] {l : Filter Î²} {F : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (Î» (x : Î²), F x / r) l Filter.at_top
{R : Type u_2} {Î“â‚€ : Type u_3} {Î“'â‚€ : Type u_4} [Linear_ordered_AddCommMonoid_WithTop Î“â‚€] [Linear_ordered_AddCommMonoid_WithTop Î“'â‚€] [Ring R] {vâ‚ : AddValuation R Î“â‚€} {vâ‚‚ : AddValuation R Î“'â‚€} {S : Type u_1} [Ring S] (F : S â†’+* R) (h : vâ‚._Equiv vâ‚‚) : (AddValuation.comap F vâ‚)._Equiv (AddValuation.comap F vâ‚‚)
{G : Type u_4} [NormedGroup G] [NormedSpace â„ G] {S : set G} (conv : Convex â„ S) (hs : (Interior S).Nonempty) : UniqueDiffOn â„ S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] {F : J â†’ C} [CategoryTheory.Limits.HasBiproduct F] : Finset.Univ.Sum (Î» (j : J), CategoryTheory.Limits.biproductÏ€ F j â‰« CategoryTheory.Limits.biproductÎ¹ F j) = ðŸ™ (â¨ F)
{Î± : Type u_1} [Preorder Î±] [OrderTop Î±] {A : Î±} : IsCoatom A â†’ IsAtom (â‡‘order_dual.to_dual A)
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {F : Î± â†’ Î²} : Isometry F â†” âˆ€ (x y : Î±), HasDist.dist (F x) (F y) = HasDist.dist x y
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {E' : Type u_7} [InnerProductSpace ð•œ E'] {v : Basis Î¹ ð•œ E} (hv : Orthonormal ð•œ â‡‘v) (F : E â‰ƒâ‚—áµ¢[ð•œ] E') : Orthonormal ð•œ â‡‘(v.Map F.to_Linear_Equiv)
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) {x y : m} (h : â‡‘(F.to_Map) x = â‡‘(F.to_Map) y) : â‡‘g x = â‡‘g y
{Î± : Type u_1} {Î² : Type u_2} [Nontrivial Î±] {F : Î± â†’ Î²} (hF : Function.Injective F) (y : Î²) : âˆƒ (x : Î±), F x â‰  y
{Î± : Type u_1} [semi_NormedRing Î±] [NormOneClass Î±] (A : Î±) (n : â„•) : âˆ¥A ^ nâˆ¥ â‰¤ âˆ¥Aâˆ¥ ^ n
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds_within A (set.ici A) â†” âˆƒ (u : Î±) (h : u âˆˆ set.ioi A), set.Ico A u âŠ† S
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {S : set E} {x y : E} {F' : E â†’ (E â†’L[â„] â„)} (hF : âˆ€ (x : E), x âˆˆ S â†’ HasFderivWithinAt F (F' x) S x) (hs : Convex â„ S) (xs : x âˆˆ S) (ys : y âˆˆ S) : âˆƒ (z : E) (h : z âˆˆ Segment â„ x y), F y - F x = â‡‘(F' z) (y - x)
(P : â„•) [hp : Fact (Nat.Prime P)] {q r : â„š} : padic_norm P (q + r) â‰¤ LinearOrder.max (padic_norm P q) (padic_norm P r)
{R : Type u_1} [CommRing R] : IsOpen_Map â‡‘(Prime_Spectrum.comap Polynomial.C)
{Î± : Type u} {G : Type u_1} [Group G] (F g : free_Group Î± â†’* G) (h : âˆ€ (A : Î±), â‡‘F (free_Group.of A) = â‡‘g (free_Group.of A)) : F = g
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {F : Filter Î±} {A : Î±} (hl : Filter._bounded has_LE.LE F) (hg : Filter._bounded Ge F) (hs : F.limsup = A) (hi : F.liminf = A) : F â‰¤ nhds A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {n : WithTop â„•} (hF : ContDiff_on ð•œ n F S) (g : G â†’L[ð•œ] E) : ContDiff_on ð•œ n (F âˆ˜ â‡‘g) (â‡‘g â»Â¹' S)
{m : Type u_1} [AddMonoid m] (x : m) : _Add_Submonoid (Multiples x)
{A B C : â„} : IntervalIntegrable (Î» (x : â„), (x - C)â»Â¹) MeasureTheory.MeasureSpace.Volume A B â†” A = B âˆ¨ C âˆ‰ set.Interval A B
{Î± : Type u_1} {m : set Î± â†’ Ennreal} {S t : set Î±} (h : âˆ€ (u : set Î±), (S âˆ© u).Nonempty â†’ (t âˆ© u).Nonempty â†’ m u = âŠ¤) : â‡‘(MeasureTheory.OuterMeasure.bounded_by m) (S âˆª t) = â‡‘(MeasureTheory.OuterMeasure.bounded_by m) S + â‡‘(MeasureTheory.OuterMeasure.bounded_by m) t
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv F x < 0) : StrictAntiOn F D
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] {F : Filter Î²} {g : Î² â†’ Î±} (h : âˆƒ (A : Î±), Filter.Tendsto g F (nhds A)) : Filter.Tendsto g F (nhds (lim F g))
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [Ring R] [AddCommGroup N] [module R N] [NoZeroSmulDivisors R N] (P : Î¹ â†’ Submodule R N) (hp : CompleteLattice.Independent P) {v : Î¹ â†’ N} (hv : âˆ€ (i : Î¹), v i âˆˆ P i) (hv' : âˆ€ (i : Î¹), v i â‰  0) : LinearIndependent R v
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {n : WithTop â„•} {S : set E} {F g : E â†’ ð•œ} (hF : ContDiff_on ð•œ n F S) (hg : ContDiff_on ð•œ n g S) : ContDiff_on ð•œ n (Î» (x : E), F x * g x) S
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} (IsOpenMap : IsOpen_Map F) (Cont : Continuous F) (surj : Function.Surjective F) : QuotientMap F
{m : Type u_1} [has_Mul m] (S : Subsemigroup m) {x y : m} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] [Algebra R S] [IsDomain S] (h : Algebra.IsIntegral R S) (P : Ideal R) [P.Prime] (hP : (Algebra_Map R S).Ker â‰¤ P) : âˆƒ (q : Ideal S), q.Prime âˆ§ Ideal.comap (Algebra_Map R S) q = P
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i : D.to_GlueData.J) (U : TopologicalSpace.Opens â†¥((D.to_GlueData.U i).carrier)) : D.Diagram_over_IsOpen_Ï€ U i â‰« D.Î¹_Inv_App_Ï€_Eq_Map U â‰« D.Î¹_Inv_App U = ðŸ™ (CategoryTheory.Limits.Limit(D.Diagram_over_IsOpen U))
{ð•œ : Type u_1} [_R_or_C ð•œ] {F : Type u_2} [semi_NormedGroup F] [NormedSpace ð•œ F] [NormedSpace â„ F] [IsScalarTower â„ ð•œ F] (fr : F â†’L[â„] â„) (x : F) : âˆ¥â‡‘(fr.to_Linear_Map.extend_toð•œ') xâˆ¥ â‰¤ âˆ¥frâˆ¥ * âˆ¥xâˆ¥
{Î¹ : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] (hs : IsClosed S) (U : Î¹ â†’ set x) (ho : âˆ€ (i : Î¹), IsOpen (U i)) (hF : locally_Finite U) (hU : S âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (F : BumpCovering Î¹ x S), F._subordinate U
{Î± : Type u_1} {n : Type u_4} {m : Type u_5} [has_Zero Î±] {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} : (Matrix.from_blocks A B C D).IsDiag â†” A.IsDiag âˆ§ B = 0 âˆ§ C = 0 âˆ§ D.IsDiag
 : set.Unbounded has_LT.LT {B : Ordinal | B.Card.Ord = B âˆ§ Ordinal.omega â‰¤ B}
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} (h : IsLocalExtr F A) : fderiv â„ F A = 0
{Î± : Type u} [TopologicalSpace Î±] {S : set (Î± Ã— Î±)} {x : Î±} (hx : S âˆˆ nhds (x, x)) : âˆƒ (U : set Î±), IsOpen U âˆ§ x âˆˆ U âˆ§ U Ã—Ë¢ U âŠ† S
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Abelian C] [CategoryTheory.HasInjectiveResolutions C] [CategoryTheory.Abelian D] {F G : C â¥¤ D} [F.Additive] [G.Additive] (Î± : F âŸ¶ G) (n : â„•) {x : C} (P : CategoryTheory.InjectiveResolution x) : (CategoryTheory.Nat_Trans.Right_derived Î± n).App x = (F.Right_derived_obj_iso n P).hom â‰« (homology_Functor D (ComplexShape.Up â„•) n).Map ((CategoryTheory.Nat_Trans.Map_homological_Complex Î± (ComplexShape.Up â„•)).App P.cocomplex) â‰« (G.Right_derived_obj_iso n P).Inv
{h : Type u_1} {m : Type u_2} [TopologicalSpace h] [TopologicalSpace m] [ChartedSpace h m] {h' : Type u_3} {m' : Type u_4} [TopologicalSpace h'] [TopologicalSpace m'] [ChartedSpace h' m'] {G : StructureGroupoid h} {G' : StructureGroupoid h'} {e e' : LocalHomeomorph m h} {F F' : LocalHomeomorph m' h'} {P : (h â†’ h') â†’ set h â†’ h â†’ Prop} {g : m â†’ m'} {S : set m} {x : m} (hG : G.LocalInvariantProp G' P) (hE : e âˆˆ StructureGroupoid.MaximalAtlas m G) (xe : x âˆˆ e.to_local_Equiv.Source) (hE' : e' âˆˆ StructureGroupoid.MaximalAtlas m G) (xe' : x âˆˆ e'.to_local_Equiv.Source) (hF : F âˆˆ StructureGroupoid.MaximalAtlas m' G') (xf : g x âˆˆ F.to_local_Equiv.Source) (hF' : F' âˆˆ StructureGroupoid.MaximalAtlas m' G') (xf' : g x âˆˆ F'.to_local_Equiv.Source) (hgs : Continuous_within_at g S x) (h : P (â‡‘F âˆ˜ g âˆ˜ â‡‘(e.Symm)) (e.to_local_Equiv.Target âˆ© â‡‘(e.Symm) â»Â¹' (S âˆ© g â»Â¹' F.to_local_Equiv.Source)) (â‡‘e x)) : P (â‡‘F' âˆ˜ g âˆ˜ â‡‘(e'.Symm)) (e'.to_local_Equiv.Target âˆ© â‡‘(e'.Symm) â»Â¹' (S âˆ© g â»Â¹' F'.to_local_Equiv.Source)) (â‡‘e' x)
{P : â„•} (hp : Nat.Prime P) {R : Type u_1} [CommRing R] [IsDomain R] {n : â„•} (hn : n â‰  0) (h : Irreducible (Polynomial.cyclotomic (P ^ n) R)) : Irreducible (Polynomial.cyclotomic P R)
{Î² : Type u} {Î± : Type v} {S : Finset Î±} [CommMonoid Î²] (F : Î± â†’ Î²) {P : Î± â†’ Prop} [Decidable_Pred P] (h : âˆ€ (x : Î±), x âˆˆ S â†’ P x) : (Finset.Subtype P S).Prod (Î» (x : Subtype P), F â†‘x) = S.Prod (Î» (x : Î±), F x)
{Î± : Type u_3} {Î² : Type u_4} [Linear_ordered_Field Î±] {l : Filter Î²} {F : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (Î» (x : Î²), F x * r) l Filter.at_IsBot
{m : Type u_3} {N : Type u_4} [has_Zero m] [has_Zero N] {F g : ZeroHom m N} (h : F = g) (x : m) : â‡‘F x = â‡‘g x
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] : Function.involutive â‡‘(reflection K)
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (N : Submonoid S) (t : Type u_4) [CommRing t] [Algebra R t] [Algebra S t] [IsScalarTower R S t] [IsLocalization m S] [IsLocalization N t] : IsLocalization (IsLocalization.Localization_Localization_Submodule m N) t
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R m) (x : Orientation R m Î¹) : x â‰  e.Orientation â†” x = -e.Orientation
{B : â„•} {l : List â„•} (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < B + 2) : Nat.of_digits (B + 2) l < (B + 2) ^ l.length
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (t : CategoryTheory.Limits.IsTerminal x) (F : x âŸ¶ Y) : CategoryTheory.Mono F
{G : Type u} [Group G] [Fintype G] (P : â„•) {n : â„•} [Fact (Nat.Prime P)] (hdvd : P ^ n âˆ£ Fintype.Card G) : âˆƒ (K : Subgroup G), Fintype.Card â†¥K = P ^ n
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} {t : Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) {q : Type u_4} [CommMonoid q] {k : t.Localization_Map q} (z : N) : â‡‘(F.Map hy k) z * â‡‘(k.to_Map) (â‡‘g â†‘((F.sec z).Snd)) = â‡‘(k.to_Map) (â‡‘g (F.sec z).fst)
{Î± : Type u_1} [cancel_CommMonoid_with_Zero Î±] [dec_irr : Î  (P : Associates Î±), Decidable (Irreducible P)] [Unique_factorization_Monoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {P A : Associates Î±} (hp : Irreducible P) {n : â„•} (h : A âˆ£ P ^ n) : A = P ^ P.count A.Factors
{n : â„•} (P : Fin (n + 1)) (i : Fin n) : P < â‡‘(P.Succ_above) i â†” P â‰¤ â‡‘Fin.cast_Succ i
{Î± : Type u_1} [AddCommMonoid Î±] (m m N : â„•) (F : (Î£ (n : â„•), Fin n â†’ â„•) â†’ Î±) (g : (Î£ (n : â„•), Composition n) â†’ Î±) (h : âˆ€ (e : Î£ (n : â„•), Fin n â†’ â„•) (hE : e âˆˆ FormalMultilinearSeries.Comp_partial_Sum_Source m m N), F e = g (FormalMultilinearSeries.Comp_change_of_variables m m N e hE)) : (FormalMultilinearSeries.Comp_partial_Sum_Source m m N).Sum (Î» (e : Î£ (n : â„•), Fin n â†’ â„•), F e) = (FormalMultilinearSeries.Comp_partial_Sum_Target m m N).Sum (Î» (e : Î£ (n : â„•), Composition n), g e)
{K : Type u} [Field K] (S : Subfield K) {x : K} : x âˆˆ S â†’ -x âˆˆ S
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} {t : Add_Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) {q : Type u_4} [AddCommMonoid q] {k : t.Localization_Map q} {A : Type u_5} [AddCommMonoid A] {U : Add_Submonoid A} {R : Type u_6} [AddCommMonoid R] (j : U.Localization_Map R) {l : P â†’+ A} (hl : âˆ€ (W : â†¥t), â‡‘l â†‘W âˆˆ U) (x : N) : â‡‘(k.Map hl j) (â‡‘(F.Map hy k) x) = â‡‘(F.Map _ j) x
{Î± : Type u_1} {Î´ : Type u_5} [TopologicalSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±] [MeasurableSpace Î´] [complete_LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_2} {Î¹' : Type u_3} {F : Î¹ â†’ Î´ â†’ Î±} {u : Filter Î¹} (hF : âˆ€ (i : Î¹), Measurable (F i)) {P : Î¹' â†’ Prop} {S : Î¹' â†’ set Î¹} (hu : u.has_countable_Basis P S) (hs : âˆ€ (i : Î¹'), (S i).countable) : Measurable (Î» (x : Î´), u.liminf (Î» (i : Î¹), F i x))
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : hb.oangle (-x) y + hb.oangle (-y) x = 0
{Î± : Type u} [PseudoEmetricSpace Î±] (Î´ : â„) (E : set Î±) : Closure E âŠ† Metric.Cthickening Î´ E
(R : Type u_1) [Ring R] : Algebra_Map â„¤ R = Int.cast_Ring_hom R
{Î¹ : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] (hs : IsClosed S) (U : Î¹ â†’ set x) (ho : âˆ€ (i : Î¹), IsOpen (U i)) (hF : locally_Finite U) (hU : S âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (F : PartitionOfUnity Î¹ x S), F._subordinate U
{n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3
{Gâ‚€ : Type u_2} [Group_with_Zero Gâ‚€] (A : Gâ‚€) : A * Aâ»Â¹ * A = A
(ð•œ : Type u_1) (E : Type u_2) [_R_or_C ð•œ] [InnerProductSpace ð•œ E] : GaloisConnection Submodule.Orthogonal Submodule.Orthogonal
{m : Type u_1} [has_Add m] {S : set m} : S âŠ† â†‘(Add_Subsemigroup.Closure S)
 : Dense {x : â„ | Liouville x}
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {B : m} [Linear_ordered_CommRing m] (ht : t.Nonempty) (hb : â†‘(S.Card) â‰¤ t.Card â€¢ B) : âˆƒ (y : Î²) (h : y âˆˆ t), â†‘((Finset.Filter (Î» (x : Î±), F x = y) S).Card) â‰¤ B
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] (h : âˆ€ (x : E), module.rank F â†¥FâŸ®xâŸ¯ = 1) : âŠ¥ = âŠ¤
{Î± : Type u_1} {r : Setoid Î±} {x y : Î±} : Quotient.Mk' x = Quotient.Mk' y â†” r.Rel x y
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : F =o[l] g' â†’ (F =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {u : â„• â†’ E} {l : E} (h : Filter.Tendsto u Filter.at_top (nhds l)) : Filter.Tendsto (Î» (n : â„•), (â†‘n)â»Â¹ â€¢ (Finset.Range n).Sum (Î» (i : â„•), u i)) Filter.at_top (nhds l)
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A u' : Î±} {S : set Î±} (hu' : A < u') : S âˆˆ nhds_within A (set.ici A) â†” âˆƒ (u : Î±) (h : u âˆˆ set.ioi A), set.Ico A u âŠ† S
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x y + hb.oangle y z + hb.oangle z x = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : EuclideanGeometry.angle P1 P2 P3 = EuclideanGeometry.angle P3 P2 P1
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] (y : R) [Algebra R S] [IsLocalization.Away y S] [h : Ideal._jacobson R] : Ideal._jacobson S
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [CharZero k] {S : Finset Î¹} (P : Î¹ â†’ P) (h : S.Nonempty) : Finset.centroid k S P âˆˆ affine_Span k (set.Range P)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) (h : S.Sum (Î» (i : Î¹), W i) = 0) (Bâ‚ Bâ‚‚ : P) : â‡‘(S.weighted_vsub_of_point P Bâ‚) W = â‡‘(S.weighted_vsub_of_point P Bâ‚‚) W
(R : Type u_1) [CommRing R] (m : Type u_2) [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [Nontrivial R] : â‡‘(LinearMap.trace R m) 1 = â†‘(Finite_dimensional.finrank R m)
{Î± : Type u_1} {Î² : Type u_2} [MulOneClass Î±] [comm_Group Î²] {F : Î± â†’ Î²} (hF : _Monoid_hom F) : _Monoid_hom (Î» (A : Î±), (F A)â»Â¹)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace F] (P : FormalMultilinearSeries ð•œ E F) {x y : E} (h : â†‘âˆ¥xâˆ¥â‚Š + â†‘âˆ¥yâˆ¥â‚Š < P.radius) : (P.change_origin x).Sum y = P.Sum (x + y)
{G : Type u} [CategoryTheory.groupoid G] [IsFreeGroupoid G] {A B : G} : Nonempty (A âŸ¶ B) â†’ Nonempty (Quiver.Path (symgen A) (symgen B))
{K : Type u_4} {v : Type u} {v' : Type u_8} [Field K] [AddCommGroup v] [AddCommGroup v'] [module K v] [module K v'] {P : Submodule K v} (F : â†¥P â†’â‚—[K] v') : âˆƒ (g : v â†’â‚—[K] v'), g.Comp P.Subtype = F
(R : Type u) [Semiring R] (q : â„•) [hp : Char_P R 0] [hq : ExpChar R q] : q = 1
{Î± : Type u_3} {Î² : Type u_4} [Linear_ordered_Field Î±] {l : Filter Î²} {F : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (Î» (x : Î²), r * F x) l Filter.at_top
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {S : set Î±} {P : Filter Î¹} [UniformSpace Î³] {g : Î² â†’ Î³} (h : TendstoUniformlyOn F F P S) (hg : uniform_Continuous g) : TendstoUniformlyOn (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ F) P S
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {S : set E} {x : E} {F' : TangentSpace (model_with_corners_self ð•œ E) x â†’L[ð•œ] TangentSpace (model_with_corners_self ð•œ E') (F x)} : HasMfderivWithinAt (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F S x F' â†’ HasFderivWithinAt F F' S x
{n : â„•} {i j : Fin (n + 1)} (h : i â‰¤ j) : SimplexCategoryÏƒ (â‡‘Fin.cast_Succ i) â‰« SimplexCategoryÏƒ j = SimplexCategoryÏƒ j.Succ â‰« SimplexCategoryÏƒ i
{R : Type u_1} {S : Type u_4} [CommRing R] [CommRing S] (F : R â†’+* S) (P : Polynomial R) (x : S) (h : Polynomial.Evalâ‚‚ F x P = 0) : F.IsIntegral_elem (â‡‘F P.leading_Coeff * x)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â‰ƒL[ð•œ] F} {g : F â†’ E} {A : F} (hg : Continuous_at g A) (hF : HasFderivAt F â†‘F' (g A)) (hfg : âˆ€á¶  (y : F) in nhds A, F (g y) = y) : HasFderivAt g â†‘(F'.Symm) A
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B C D : Î±} (hc : C â‰  0) (hD : D â‰  0) : A / C â‰¤ B / D â†’ (A * D - B * C) / (C * D) â‰¤ 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : Â¬S1 â‰¤ S2 â†” âˆƒ (P : P) (h : P âˆˆ S1), P âˆ‰ S2
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) : v.Int_Valuation_def 1 = 1
{Î± : Type u_1} [CommMonoid Î±] {A B : Î±} {u : Î±Ë£} : â†‘u * A âˆ£ B â†” A âˆ£ B
{m : Type u_1} {R : Type u_4} [non_unital_non_assoc_Semiring R] [set_like m R] [MulMemClass m R] {S : m} {A B : R} (ha : A âˆˆ AddSubmonoid.Closure â†‘S) (hb : B âˆˆ S) : A * B âˆˆ AddSubmonoid.Closure â†‘S
(z : â„‚) : â†‘(z.re) = (z + â‡‘(Star_Ring_end â„‚) z) / 2
{m : Type u_2} {n : Type u_3} {R : Type u_7} {Î± : Type v} [HasStar R] [HasStar Î±] [HasScalar R Î±] [Star_module R Î±] (C : R) (m : Matrix m n Î±) : (C â€¢ m).Conj_transpose = HasStar.Star C â€¢ m.Conj_transpose
{n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : i â‰¤ â‡‘Fin.cast_Succ j) : SimplexCategoryÎ´ (â‡‘Fin.cast_Succ i) â‰« SimplexCategoryÏƒ j.Succ = SimplexCategoryÏƒ j â‰« SimplexCategoryÎ´ i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] (F : J â†’ C) [CategoryTheory.Limits.HasProduct F] : CategoryTheory.Limits.HasBiproduct F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace F] [CompleteSpace E] (g : E â†’â‚—[ð•œ] F) (hg : IsClosed â†‘(g.graph)) : Continuous â‡‘g
{ð•œ : Type u_1} {E : Type u_2} [NormedField ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [has_Continuous_Smul ð•œ E] : â‹ƒâ‚€set_of (Bornology._vonN_bounded ð•œ) = set.Univ
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {A : Î±} : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ {A}), F i)) = F A
{R : Type u_1} [NormedRing R] [CompleteSpace R] : IsOpen {x : R | IsUnit x}
{m : Type u_1} {N : Type u_2} [MulOneClass m] [MulOneClass N] {F g : m â†’* N} {S : set m} (h : set.Eq_on â‡‘F â‡‘g S) : set.Eq_on â‡‘F â‡‘g â†‘(Submonoid.Closure S)
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [_R_or_C ð•‚] [NormedRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] {x y : ð”¸} (hxy : Commute x y) : Exp ð•‚ (x + y) = Exp ð•‚ x * Exp ð•‚ y
{m : Type u_3} {N : Type u_4} [MulZeroOneClass m] [MulZeroOneClass N] {F g : m â†’*â‚€ N} (h : F = g) (x : m) : â‡‘F x = â‡‘g x
{R : Type u_1} {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [_fraction_Ring R K] [IsDomain R] [IsDedekindDomain R] [Fintype (class_Group R K)] : Fintype.Card (class_Group R K) = 1 â†” _principal_Ideal_Ring R
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] {A : Î±} : 1 < Aâ»Â¹ â†” A < 1
{Î± : Type u} [Ring Î±] {A B : Î±} : A âˆ£ A + B â†” A âˆ£ B
{Î¹ : Type W} {R : Type u} [Ring R] [RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {J : set m} (v : Basis Î¹ R m) (hJ : Submodule.Span R J = âŠ¤) : Cardinal.Mk â†¥(set.Range â‡‘v) â‰¤ Cardinal.Mk â†¥J
{R : Type u} [Ring R] {S : set R} {P : R â†’ Prop} {x : R} (h : x âˆˆ Subring.Closure S) (Hs : âˆ€ (x : R), x âˆˆ S â†’ P x) (h0 : P 0) (h1 : P 1) (HAdd : âˆ€ (x y : R), P x â†’ P y â†’ P (x + y)) (Hneg : âˆ€ (x : R), P x â†’ P (-x)) (HMul : âˆ€ (x y : R), P x â†’ P y â†’ P (x * y)) : P x
{P : Prop} (A : Erased P) : P
{Î± : Type u_1} {Î¹ : Type u_4} [LinearOrder Î±] [DecidableEq Î¹] (F : Î¹ â†’ Î±) {P : Finset Î¹ â†’ Prop} (S : Finset Î¹) (h0 : P âˆ…) (step : âˆ€ (A : Î¹) (S : Finset Î¹), A âˆ‰ S â†’ (âˆ€ (x : Î¹), x âˆˆ S â†’ F A â‰¤ F x) â†’ P S â†’ P (HasInsert.Insert A S)) : P S
{m : Type u_1} [AddMonoid m] {Î¹ : Type u_2} [hÎ¹ : Nonempty Î¹] {S : Î¹ â†’ set m} (hs : âˆ€ (i : Î¹), _Add_Submonoid (S i)) (Directed : âˆ€ (i j : Î¹), âˆƒ (k : Î¹), S i âŠ† S k âˆ§ S j âŠ† S k) : _Add_Submonoid (â‹ƒ (i : Î¹), S i)
{Î± : Type u_1} {Î¹ : Type u_2} {Î¹' : Type u_3} [Lattice Î±] [OrderBot Î±] {S : set Î¹'} {g : Î¹' â†’ Finset Î¹} {F : Î¹ â†’ Î±} (hs : S.Pairwise_Disjoint (Î» (i' : Î¹'), (g i').Sup F)) (hg : âˆ€ (i : Î¹'), i âˆˆ S â†’ â†‘(g i).Pairwise_Disjoint F) : (â‹ƒ (i : Î¹') (h : i âˆˆ S), â†‘(g i)).Pairwise_Disjoint F
{G : Type u_1} [div_Inv_Monoid G] (A B : G) : A / B = A * Bâ»Â¹
(x : â„¤) : â†‘(x.Nat_Abs) ^ 2 = x ^ 2
(R : Type u) (m : Type v) [CommRing R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] (N : Type v) [AddCommGroup N] [module R N] [module.free R N] : module.rank R (TensorProduct R m N) = module.rank R m * module.rank R N
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} (h : HasInner.inner x y = 0) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R (r â€¢ x) y
{C : Type u} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryCoproduct A B] [CategoryTheory.Limits.HasBinaryCoproduct A' B'] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')] (F : A âŸ¶ A') (g : B âŸ¶ B') [CategoryTheory.IsIso (CategoryTheory.Limits.Coprod_comparison F A B)] [CategoryTheory.IsIso (CategoryTheory.Limits.Coprod_comparison F A' B')] : CategoryTheory.Inv (CategoryTheory.Limits.Coprod_comparison F A B) â‰« CategoryTheory.Limits.Coprod.Map (F.Map F) (F.Map g) = F.Map (CategoryTheory.Limits.Coprod.Map F g) â‰« CategoryTheory.Inv (CategoryTheory.Limits.Coprod_comparison F A' B')
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {x Y Z : C} (A : x âŸ¶ Z) (B : Y âŸ¶ Z) [CategoryTheory.Mono A] [CategoryTheory.Mono B] : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan A B)
{Î± : Type u} {Î² : Type v} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {F : Filter Î²} {u : Î² â†’ Î±} {A : Î±} (hinf : A â‰¤ F.liminf u) (hsup : F.limsup u â‰¤ A) (h : Filter._bounded_under has_LE.LE F u . "_bounded_Default") (h' : Filter._bounded_under Ge F u . "_bounded_Default") : Filter.Tendsto u F (nhds A)
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (t : CategoryTheory.Limits.IsInitial x) (F g : x âŸ¶ Y) : F = g
{m : Type u_5} [AddCommMonoid m] (h : module â„• m) (n : â„•) (x : m) : n â€¢ x = n â€¢ x
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {x : ð•œ} {S : set ð•œ} (hx : x âˆˆ S) : Star_Convex ð•œ x S â†’ S.Ord_connected
{ð•œ : Type u_1} {E : Type u_2} [semi_NormedRing ð•œ] [AddCommGroup E] [module ð•œ E] {t t' : TopologicalSpace E} (h : t â‰¤ t') {S : set E} (hs : Bornology._vonN_bounded ð•œ S) : Bornology._vonN_bounded ð•œ S
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {F : Î± â†’ Î²} (hF : Isometry F) (x y : Î±) : HasDist.dist (F x) (F y) = HasDist.dist x y
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (F : E â†’L[ð•œ] F) [CompleteSpace F] [CompleteSpace E] (surj : Function.Surjective â‡‘F) : IsOpen_Map â‡‘F
 : Real.sin (Real.Pi / 6) = 1 / 2
{C : Type uâ‚} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : CategoryTheory.Presieve.IsSheafFor P â‡‘S) (F : S.Functor âŸ¶ P) : S.Functor_inclusion â‰« h.extend F = F
(q : â„š) : (GeneralizedContinuedFraction.of q).terminates
{R : Type v} [CommRing R] {n : â„•} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R} (C : Fin n â†’ R) (A_Zero : âˆ€ (j : Fin (n + 1)), A 0 j = B 0 j) (A_Succ : âˆ€ (i : Fin n) (j : Fin (n + 1)), A i.Succ j = B i.Succ j + C i * A (â‡‘Fin.cast_Succ i) j) : A.det = B.det
{E : Type u} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] (F g : â„ Ã— â„ â†’ E) (F' g' : â„ Ã— â„ â†’ (â„ Ã— â„ â†’L[â„] E)) (A B : â„ Ã— â„) (hle : A â‰¤ B) (S : set (â„ Ã— â„)) (hs : S.countable) (Hcf : Continuous_on F (set.icc A B)) (Hcg : Continuous_on g (set.icc A B)) (Hdf : âˆ€ (x : â„ Ã— â„), x âˆˆ set.Ioo A.fst B.fst Ã—Ë¢ set.Ioo A.Snd B.Snd  S â†’ HasFderivAt F (F' x) x) (Hdg : âˆ€ (x : â„ Ã— â„), x âˆˆ set.Ioo A.fst B.fst Ã—Ë¢ set.Ioo A.Snd B.Snd  S â†’ HasFderivAt g (g' x) x) (Hi : MeasureTheory.IntegrableOn (Î» (x : â„ Ã— â„), â‡‘(F' x) (1, 0) + â‡‘(g' x) (0, 1)) (set.icc A B) MeasureTheory.MeasureSpace.Volume) : âˆ« (x : â„ Ã— â„) in set.icc A B, â‡‘(F' x) (1, 0) + â‡‘(g' x) (0, 1) = (((âˆ« (x : â„) in A.fst..B.fst, g (x, B.Snd)) - âˆ« (x : â„) in A.fst..B.fst, g (x, A.Snd)) + âˆ« (y : â„) in A.Snd..B.Snd, F (B.fst, y)) - âˆ« (y : â„) in A.Snd..B.Snd, F (A.fst, y)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {E' : Type u_6} [NormedGroup E'] [NormedSpace ð•œ E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace ð•œ F'] {F : E â†’ F} {g : E' â†’ F'} {P : E Ã— E'} (hF : ContDiff_at ð•œ n F P.fst) (hg : ContDiff_at ð•œ n g P.Snd) : ContDiff_at ð•œ n (Prod.Map F g) P
{E : Type u_2} {ð•œ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] {S : set E} (hs : Convex ð•œ S) {x y : E} (hx : x âˆˆ Closure S) (hy : x + y âˆˆ Interior S) {t : ð•œ} (ht : t âˆˆ set.ioc 0 1) : x + t â€¢ y âˆˆ Interior S
{Î± : Type u} {S : set Î±} : S.countable â†” âˆƒ (F : Î± â†’ â„•), set.inj_on F S
{Î± : Type u_1} {Î³ : Type u_3} [TopologicalSpace Î±] [MeasurableSpace Î±] [Opens_MeasurableSpace Î±] [TopologicalSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³] {F : Î± â†’ Î³} (hF : Continuous F) : Measurable F
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (q n m : â„•) (hnm : AlgebraicTopology.DoldKan.C.Rel m n) {x Y : CategoryTheory.SimplicialObject C} (F : x âŸ¶ Y) : F.App (Opposite.Op (SimplexCategory.Mk n)) â‰« AlgebraicTopology.DoldKan.hÏƒ' q n m hnm = AlgebraicTopology.DoldKan.hÏƒ' q n m hnm â‰« F.App (Opposite.Op (SimplexCategory.Mk m))
(R L : Type u) [CommRing R] [CommRing L] [IsDomain L] [Algebra R L] [NoZeroSmulDivisors R L] (halg : Algebra.IsAlgebraic R L) : Cardinal.Mk L â‰¤ LinearOrder.max (Cardinal.Mk R) Cardinal.aleph0
{Î± : Type u} {Î² : Type v} (F : Î± â†’ Î²) (g : Î² â†’ Î±) : set.maps_to F (Function.FixedPoints (g âˆ˜ F)) (Function.FixedPoints (F âˆ˜ g))
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_biproducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {Sâ‚ Sâ‚‚ : AffineSubspace â„ P} [Nonempty â†¥Sâ‚] [CompleteSpace â†¥(Sâ‚.direction)] (hle : Sâ‚ â‰¤ Sâ‚‚) {P : P} (hp : P âˆˆ Sâ‚‚) : â‡‘(EuclideanGeometry.reflection Sâ‚) P âˆˆ Sâ‚‚
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B C : Î±} : B < -A + C â†’ A + B < C
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {n : WithTop â„•} (h : ContDiff ð•œ n F) (hn : 1 â‰¤ n) : Continuous (Î» (P : E Ã— E), â‡‘(fderiv ð•œ F P.fst) P.Snd)
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] [DiscreteTopology Î±] {F : Î± â†’ Î² â†’ Î³} (hF : âˆ€ (A : Î±), Continuous (F A)) : Continuous (Function.uncurry F)
(m : Type u_1) (Î± : Type u_2) [Monoid m] [MulAction m Î±] {Î¹ : sort u_3} {P : Î¹ â†’ Submonoid m} : MulAction.FixedPoints â†¥(supr P) Î± = â‹‚ (i : Î¹), MulAction.FixedPoints â†¥(P i) Î±
{K : Type u_1} {n : â„•} {S : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] {m : â„•} (m_LT_n : m < n) : (GeneralizedContinuedFraction.squash_Seq S n).nth m = S.nth m
{ð•œ : Type u_1} {E : Type u_2} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] {Pâ‚ Pâ‚‚ : FormalMultilinearSeries ð•œ ð•œ E} {F : ð•œ â†’ E} {x : ð•œ} (hâ‚ : HasFpowerSeriesAt F Pâ‚ x) (hâ‚‚ : HasFpowerSeriesAt F Pâ‚‚ x) : Pâ‚ = Pâ‚‚
(P q r : â„•+) : 1 < ADE_inequality.Sum_Inv {P, q, r} â†” ADE_inequality.Admissible {P, q, r}
{Î± : Type u_3} {Î² : Type u_4} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Monotone F) (h : âˆ€ (B : Î²), âˆƒ (A : Î±), F A â‰¤ B) : Filter.Tendsto F Filter.at_IsBot Filter.at_IsBot
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : F â†’ G} {x : E} {y : F} (hF : ContDiff_at ð•œ n F y) : ContDiff_at ð•œ n (Î» (x : E Ã— F), F x.Snd) (x, y)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : hb.oangle x (â‡‘(hb.rotation Î¸) y) = hb.oangle x y + Î¸
{J : Type v} {C : Type u} [CategoryTheory.Category C] {x Y : C} {F : J â†’ (x âŸ¶ Y)} [Nonempty J] {C : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.parallel_family F)} (i : CategoryTheory.Limits.IsColimit C) : CategoryTheory.Epi (C.Î¹.App CategoryTheory.Limits.WalkingParallelFamily.One)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P (n + 1)) (i : Fin (n + 2)) : Finite_dimensional.finrank â„ â†¥((S.altitude i).direction) = 1
(x y : Pgame) : (x * y).Equiv (y * x)
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [DenselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [TopologicalSpace Î´] [order_IsClosed_topology Î´] {F : Î± â†’ Î´} {S : set Î±} [S.Ord_connected] (hs : S.Nonempty) (hF : Continuous_on F S) (hbot : Filter.Tendsto (Î» (x : â†¥S), F â†‘x) Filter.at_IsBot Filter.at_IsBot) (htop : Filter.Tendsto (Î» (x : â†¥S), F â†‘x) Filter.at_top Filter.at_top) : set.surj_on F S set.Univ
{E : Type u_1} [InnerProductSpace â„ E] {n : â„•} [Fact (Finite_dimensional.finrank â„ E = n + 1)] : Cont_mdiff (model_with_corners_self â„ (EuclideanSpace â„ (Fin n))) (model_with_corners_self â„ E) âŠ¤ Coe
(P : â„ Ã— â„) (hp : 0 < P.fst) : HasStrictFderivAt (Î» (x : â„ Ã— â„), x.fst ^ x.Snd) ((P.Snd * P.fst ^ (P.Snd - 1)) â€¢ Continuous_Linear_Map.fst â„ â„ â„ + (P.fst ^ P.Snd * Real.log P.fst) â€¢ Continuous_Linear_Map.Snd â„ â„ â„) P
{Î± : Type u_1} [normed_DivisionRing Î±] {A : Î±} (ha : A â‰  0) : Filter.Tendsto (has_Mul.Mul A) (Filter.comap HasNorm.norm Filter.at_top) (Filter.comap HasNorm.norm Filter.at_top)
{Î± : Type u_1} [has_Mul Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {B C : Î±} (bc : B < C) (A : Î±) : A * B < A * C
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x z - hb.oangle y z = hb.oangle x y
(A : Type u_4) [CommRing A] [IsDomain A] {L : Type u_6} [Field L] [Algebra A L] (C : Type u_7) [CommRing C] [IsDomain C] [Algebra C L] [IsIntegral_Closure C A L] [Algebra A C] [IsScalarTower A C L] (alg : Algebra.IsAlgebraic A L) (inj : âˆ€ (x : A), â‡‘(Algebra_Map A L) x = 0 â†’ x = 0) : _fraction_Ring C L
{Î± : Type u} [Preorder Î±] (A : Î±) : A â‰¤ A
{F : Type u_3} [InnerProductSpace â„ F] (x y : F) : HasInner.inner x y â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{E : Type u_1} {PE : Type u_2} [NormedGroup E] [NormedSpace â„ E] [MetricSpace PE] [NormedAddTorsor E PE] {F : Type u_3} {PF : Type u_4} [NormedGroup F] [NormedSpace â„ F] [MetricSpace PF] [NormedAddTorsor F PF] (F : PE â‰ƒáµ¢ PF) (x y : PE) : â‡‘F (midpoint â„ x y) = midpoint â„ (â‡‘F x) (â‡‘F y)
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [DivisionRing R] [DivisionRing S] [module R E] [module S E] (n : â„•) (x : E) : (â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B : Î±} (ha : A < 1) (hb : B < 1) : A * B < 1
(k : Type u_1) (G : Type u_2) [CommSemiring k] [Group G] [Fintype G] [Invertible â†‘(Fintype.Card G)] (g : G) : Finsupp.single g 1 * Group_Algebra.average k G = Group_Algebra.average k G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] (x : C) : CategoryTheory.Simple x â†” IsSimpleOrder (CategoryTheory.Subobject x)
{Î± : Type u_1} [semi_NormedRing Î±] (A : Î±) {n : â„•} : 0 < n â†’ âˆ¥A ^ nâˆ¥â‚Š â‰¤ âˆ¥Aâˆ¥â‚Š ^ n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x âŸ¶ Y) [CategoryTheory.Limits.HasBinaryBiproduct x x] : F + g = CategoryTheory.Limits.biprod.Lift (ðŸ™ x) (ðŸ™ x) â‰« CategoryTheory.Limits.biprod.Desc F g
{Î± : Type u_1} {Î² : Type u_2} (F : Î± â†’ Î²) : Function.Injective F â†” Setoid.Ker F = âŠ¥
{Î± : Type u_1} {G : Type u_4} {S : set Î±} [division_CommMonoid G] (F g : Î± â†’ G) (hs : S.Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i / g i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) / finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), g i))
{Î± : Type u_1} [PseudoMetricSpace Î±] (x y : Î±) : HasEdist.edist x y < âŠ¤
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (F : R â†’+* S) (r : R) : â‡‘Polynomial.C (â‡‘F r) âˆˆ Polynomial.lifts F
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} : Monotone (set.image F)
{k : Type u_1} {K : Type u_2} [Field k] [_alg_IsClosed k] [Field K] {F : K â†’+* k} (P : Polynomial K) : Polynomial.Splits F P
{Î± : Type u_1} {Î¹ : Type u_3} [CompleteLattice Î±] [Fintype Î¹] {F : Î¹ â†’ Î±} : Finset.Univ.Sup_indep F â†’ CompleteLattice.Independent F
{Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} : lâ‚ <+: lâ‚‚ â†’ lâ‚.reverse <:+ lâ‚‚.reverse
 : Filter.Tendsto (Î» (x : â„), Real.Exp (-x)) Filter.at_top (nhds 0)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’â‚€ ð•œ) (i : Î¹) : HasInner.inner (â‡‘(Finsupp.Total Î¹ E ð•œ v) l) (v i) = â‡‘(Star_Ring_end ð•œ) (â‡‘l i)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall F P x r) (h : â†‘r' < r) : âˆƒ (A : â„) (h : A âˆˆ set.Ioo 0 1) (C : â„) (h : C > 0), âˆ€ (y : E), y âˆˆ Metric.Ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥F (x + y) - P.partial_Sum n yâˆ¥ â‰¤ C * (A * (âˆ¥yâˆ¥ / â†‘r')) ^ n
{R : Type u_1} [NormedRing R] [CompleteSpace R] : IsOpen_Map Coe
{ð•‚ : Type u_1} [_R_or_C ð•‚] {x : ð•‚} : HasStrictDerivAt (Exp ð•‚) (Exp ð•‚ x) x
{n : â„•} {l : List â„•} (hâ‚ : l.Prod = n) (hâ‚‚ : âˆ€ (P : â„•), P âˆˆ l â†’ Nat.Prime P) : l ~ n.Factors
{Î± : Type u} [Preorder Î±] {x y : Î±} (h : x = y) : y â‰¤ x
 : Â¬set.Univ.countable
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {n : WithTop â„•} (h : ContDiff ð•œ n F) (hn : 1 â‰¤ n) : Differentiable ð•œ F
{S : Type u} [Semigroup S] {A B x y z : S} (ha : SemiconjBy A y z) (hb : SemiconjBy B x y) : SemiconjBy (A * B) x z
{ð•œ : Type u_1} {E : Type u_2} [semi_NormedRing ð•œ] [HasScalar ð•œ E] [has_Zero E] [TopologicalSpace E] {Sâ‚ Sâ‚‚ : set E} (hsâ‚ : Bornology._vonN_bounded ð•œ Sâ‚) (hsâ‚‚ : Bornology._vonN_bounded ð•œ Sâ‚‚) : Bornology._vonN_bounded ð•œ (Sâ‚ âˆª Sâ‚‚)
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] {F : Type v} [NormedGroup F] [NormedSpace â„‚ F] [Nontrivial E] {F g : E â†’ F} {U : set E} (hU : Metric.Bounded U) (hF : Diff_Cont_on_cl â„‚ F U) (hg : Diff_Cont_on_cl â„‚ g U) (hfg : set.Eq_on F g (Frontier U)) : set.Eq_on F g (Closure U)
{R : Type u} [Semiring R] (r : R) (n : â„•) : Polynomial.x ^ n * â‡‘Polynomial.C r = â‡‘Polynomial.C r * Polynomial.x ^ n
{ð•œ : Type u_1} {E : Type u_3} [NormedField ð•œ] [AddCommGroup E] [module ð•œ E] {A : set E} (hA : Balanced ð•œ A) : Absorbs ð•œ A A
{v : Type u_9} {K : Type u_10} [Field K] [AddCommGroup v] [module K v] (B : BilinForm K v) (Bâ‚ : B.nondegenerate) (Bâ‚‚ : B.IsRefl) {x : v} (hx : Â¬B.IsOrtho x x) : (B.Restrict (B.Orthogonal (Submodule.Span K {x}))).nondegenerate
{Î± : sort u_1} {Î² : sort u_2} {F : Î± â†’ Î²} (hF : Function.Bijective F) (B : Î²) : âˆƒ! (A : Î±), F A = B
{Î± : Type u} [Preorder Î±] {A B : Î±} : A = B â†’ A â‰¤ B
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : HasDist.dist P1 P2 = HasDist.dist P1 P3) : EuclideanGeometry.angle P1 P2 P3 = EuclideanGeometry.angle P1 P3 P2
{x y z : â„¤} (h : PythagoreanTriple x y z) (k : â„¤) : PythagoreanTriple (k * x) (k * y) (k * z)
{Î± : Type u_1} {Î¹ : sort u_3} [conditionally_CompleteLattice Î±] {F : Î¹ â†’ Î±} (h : BddAbove (set.Range F)) (C : Î¹) : F C â‰¤ supr F
{C : Type u} [CategoryTheory.Category_struct C] {x Y : CategoryTheory.LocallyDiscrete C} {F g : x âŸ¶ Y} (Î· : F âŸ¶ g) : F = g
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F : Type u_2} [NormedGroup F] [NormedSpace â„ F] {F : E â†’ F} {S : set E} {x : E} {F' : E â†’L[â„] F} (F_Diff : DifferentiableOn â„ F S) (S_conv : Convex â„ S) (S_IsOpen : IsOpen S) (F_Cont : âˆ€ (y : E), y âˆˆ Closure S â†’ Continuous_within_at F S y) (h : Filter.Tendsto (Î» (y : E), fderiv â„ F y) (nhds_within x S) (nhds F')) : HasFderivWithinAt F F' (Closure S) x
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {Î¹ : Type u_3} [hne : Nonempty Î¹] [Fintype Î¹] {P : Î¹ â†’ P} (ha : AffineIndependent â„ P) : âˆƒ! (cccr : P Ã— â„), cccr.fst âˆˆ affine_Span â„ (set.Range P) âˆ§ âˆ€ (i : Î¹), HasDist.dist (P i) cccr.fst = cccr.Snd
{Î± : Type u_1} [PartialOrder Î±] [SuccOrder Î±] {A : Î±} : IsMax A â†’ Order.Succ A = A
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} (P : Î¹ â†’ P) (i1 : Î¹) : AffineIndependent k P â†” LinearIndependent k (Î» (i : {x // x â‰  i1}), P â†‘i -áµ¥ P i1)
{Î¹ : Type u_1} {Î± : Type u_2} {E : Type u_3} [semi_NormedGroup E] {F : Î¹ â†’ E} (hF : Summable (Î» (A : Î¹), âˆ¥F Aâˆ¥)) {S : Î± â†’ Finset Î¹} {P : Filter Î±} [P.Ne_IsBot] (hs : Filter.Tendsto S P Filter.at_top) {A : E} (ha : Filter.Tendsto (Î» (B : Î±), (S B).Sum (Î» (i : Î¹), F i)) P (nhds A)) : has_Sum F A
{Î± : Type u_1} {m : Type u_5} [has_Zero m] {F g : Î± â†’â‚€ m} (h : F = g) (A : Î±) : â‡‘F A = â‡‘g A
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {x : Î±} {P : Filter Î¹} {g : Î¹ â†’ Î±} [TopologicalSpace Î±] (h : TendstoUniformly F F P) (hF : Continuous_at F x) (hg : Filter.Tendsto g P (nhds x)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) P (nhds (F x))
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.IsPreconnected J] {x Y : C} (Î± : (CategoryTheory.Functor.Const J).obj x âŸ¶ (CategoryTheory.Functor.Const J).obj Y) (j j' : J) : Î±.App j = Î±.App j'
{Î² Î± : Type u} (F : Î² â†’ Î±) (Î¸ : Cardinal) (hÎ¸ : Î¸ â‰¤ Cardinal.Mk Î²) (hâ‚ : Cardinal.aleph0 â‰¤ Î¸) (hâ‚‚ : Cardinal.Mk Î± < Î¸.Ord.cof) : âˆƒ (A : Î±), Î¸ â‰¤ Cardinal.Mk â†¥(F â»Â¹' {A})
{F : Type u_1} [Field F] (P q : Polynomial F) : Function.Injective â‡‘(Polynomial.Gal.Restrict_Prod P q)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} [DecidableEq Î¹] [Finite_dimensional ð•œ E] {v : Î¹ â†’ Submodule ð•œ E} (hV : OrthogonalFamily ð•œ (Î» (i : Î¹), (v i).Subtypeâ‚—áµ¢)) : direct_Sum._internal v â†” (supr v)á—® = âŠ¥
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] {F : Type W} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace ð•œ] {Î¹ : Type u_1} [Fintype Î¹] (v : Basis Î¹ ð•œ E) : âˆƒ (C : Nnreal) (h : C > 0), âˆ€ {u : E â†’L[ð•œ] F} (m : Nnreal), (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥â‚Š â‰¤ m) â†’ âˆ¥uâˆ¥â‚Š â‰¤ C * m
{x : Type u} [Lattice x] [jordan_holder_Lattice x] (S : Composition_series x) (x : x) (hm : jordan_holder_Lattice.IsMaximal x S.top) (hb : S.IsBot â‰¤ x) : âˆƒ (t : Composition_series x), t.IsBot = S.IsBot âˆ§ t.length + 1 = S.length âˆ§ âˆƒ (htx : t.top = x), S.Equivalent (t.snoc S.top _)
(F : Type u) (K : Type v) (A : Type W) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [module K A] [module F A] [IsScalarTower F K A] [Finite_dimensional F K] : Finite_dimensional.finrank F K * Finite_dimensional.finrank K A = Finite_dimensional.finrank F A
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscrete_NormedField ð•‚] [NormedRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] (h : 0 < (Exp_series ð•‚ ð”¸).radius) : HasFderivAt (Exp ð•‚) 1 0
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] {B : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.Some B) : B * (GeneralizedContinuedFraction.of v).denominators n â‰¤ (GeneralizedContinuedFraction.of v).denominators (n + 1)
{G : Type u} [Group G] [Fintype G] {P n : â„•} [hp : Fact (Nat.Prime P)] (hdvd : P ^ (n + 1) âˆ£ Fintype.Card G) {h : Subgroup G} (hH : Fintype.Card â†¥h = P ^ n) : P âˆ£ Fintype.Card (â†¥(h.Normalizer) â§¸ Subgroup.comap h.Normalizer.Subtype h)
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F â‰  2) {A : F} (ha : A â‰  0) : IsSquare A â†” A ^ (Fintype.Card F / 2) = 1
(k : Type u_1) [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) : Finset.centroid_weights k S = Function.Const Î¹ (â†‘(S.Card))â»Â¹
{x y : SimplexCategory {F : x âŸ¶ y} : CategoryTheory.Mono F â†’ x.len â‰¤ y.len
(n : â„•) : (1 + n).Pred = n
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [LinearOrder Î²] [SuccOrder Î²] [IsSuccArchimedean Î²] {S : Î² â†’ set Î±} (h : âˆ€ (n : Î²), IsPreconnected (S n)) (K : âˆ€ (n : Î²), (S n âˆ© S (Order.Succ n)).Nonempty) : IsPreconnected (â‹ƒ (n : Î²), S n)
(P n : â„•) : witt_Polynomial P (Zmod (P ^ (n + 1))) (n + 1) = â‡‘(mv_Polynomial.expand P) (witt_Polynomial P (Zmod (P ^ (n + 1))) n)
{Î± : Type u} [PseudoMetricSpace Î±] {S : â„• â†’ Î±} : Cauchy_Seq S â†” âˆƒ (B : â„• â†’ â„), (âˆ€ (n : â„•), 0 â‰¤ B n) âˆ§ (âˆ€ (n m N : â„•), N â‰¤ n â†’ N â‰¤ m â†’ HasDist.dist (S n) (S m) â‰¤ B N) âˆ§ Filter.Tendsto B Filter.at_top (nhds 0)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ Mon_) [CategoryTheory.IsFiltered J] {x y y' : Î£ (j : J), â†¥(F.obj j)} (hyy' : CategoryTheory.Limits.types.filtered_Colimit.Rel (F â‹™ CategoryTheory.Forget Mon_) y y') : Mon_.FilteredColimits.Colimit_Mul_aux F x y = Mon_.FilteredColimits.Colimit_Mul_aux F x y'
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} [t2_Space Î±] [ProperSpace Î±] : IsCompact S â†” IsClosed S âˆ§ Metric.Bounded S
(x : â„‚) : HasDerivAt Complex.sin (Complex.cos x) x
{P : â„‚ Ã— â„‚} (hâ‚ : 0 â‰¤ P.fst.re âˆ¨ P.fst.im â‰  0) (hâ‚‚ : 0 < P.Snd.re) : Continuous_at (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.Snd) P
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F â‰  2) : Char.quadratic_Char F (-1) = â‡‘Zmod.Ï‡â‚„ â†‘(Fintype.Card F)
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (x : Î± 0) (P : Î  (i : Fin n), Î± i.Succ) (i : Fin n) (y : Î± i.Succ) : Fin.Cons x (Function.update P i y) = Function.update (Fin.Cons x P) i.Succ y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.Fin_Category J] (F : J â¥¤ C) : Nonempty (CategoryTheory.Limits.Cocone F)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (A : CategoryTheory.Over P) : â†‘A = 0 â†” A.hom = 0
{R : Type u} [CommRing R] {P : Ideal R} (h : P.Prime) : (Ideal.Map Polynomial.C P).Prime
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [AddCommGroup Î²] {F g : Î± â†’ Î²} (hF : _AddGroup_hom F) (hg : _AddGroup_hom g) : _AddGroup_hom (Î» (A : Î±), F A - g A)
{A B C : Prop} : A âˆ§ (B âˆ¨ C) â†” A âˆ§ B âˆ¨ A âˆ§ C
{R : â„} {C W : â„‚} {S : set â„‚} (hs : S.countable) (hw : W âˆˆ Metric.Ball C R) {F : â„‚ â†’ â„‚} (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball C R  S â†’ Differentiable_at â„‚ F z) : âˆ® (z : â„‚) in C(C, R), F z / (z - W) = 2 * â†‘Real.Pi * Complex.i * F W
{Î± : Type u_1} {P : Î± â†’ Prop} : Antitone (Î» (S : set Î±), âˆ€ (x : Î±), x âˆˆ S â†’ P x)
{Î± : Type u} [Preorder Î±] {A B C : Î±} : B < C â†’ A < B â†’ A < C
{Î± : Type u} [TopologicalSpace Î±] (x : Î±) (C : set (set Î±)) (h1 : âˆ€ (S : set Î±), S âˆˆ C â†’ x âˆˆ S) (h2 : âˆ€ (S : set Î±), S âˆˆ C â†’ IsPreconnected S) : IsPreconnected (â‹ƒâ‚€C)
{m : Type u_1} [MulOneClass m] (S : Submonoid m) : Submonoid.Closure â†‘S = S
(ð•œ : Type v) [_R_or_C ð•œ] {E : Type u} [NormedGroup E] [NormedSpace ð•œ E] (x : E) {m : â„} (hMp : 0 â‰¤ m) (hM : âˆ€ (F : NormedSpace.dual ð•œ E), âˆ¥â‡‘F xâˆ¥ â‰¤ m * âˆ¥Fâˆ¥) : âˆ¥xâˆ¥ â‰¤ m
{A B C : Prop} : (A âˆ¨ B) âˆ§ C â†” A âˆ§ C âˆ¨ B âˆ§ C
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] : (Filter.cocompact Î±).Coprod (Filter.cocompact Î²) = Filter.cocompact (Î± Ã— Î²)
{G : Type u_1} {S : set G} [Group G] : _Normal_Subgroup (Group.Normal_Closure S)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {n : WithTop â„•} : ContDiff ð•œ n Id
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B C : Î±} : A < B + C â†’ A - C < B
{Î± : Type u} [PseudoMetricSpace Î±] (F : â„• â†’ Î±) (n : â„•) : HasDist.dist (F 0) (F n) â‰¤ (Finset.Range n).Sum (Î» (i : â„•), HasDist.dist (F i) (F (i + 1)))
{Î± : Type u} [Preorder Î±] {A B C : Î±} : A â‰¤ B â†’ B â‰¤ C â†’ A â‰¤ C
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.Mono F] [CategoryTheory.SplitEpi F] : CategoryTheory.IsIso F
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] [LocallyCompactSpace (Î± Ã— Î²)] : Continuous Continuous_Map.Curry
{x y z : â„¤} (h : PythagoreanTriple x y z) (h_IsCoprime : x.Gcd y = 1) (h_parity : x % 2 = 1) (h_Pos : 0 < z) : âˆƒ (m n : â„¤), x = m ^ 2 - n ^ 2 âˆ§ y = 2 * m * n âˆ§ z = m ^ 2 + n ^ 2 âˆ§ m.Gcd n = 1 âˆ§ (m % 2 = 0 âˆ§ n % 2 = 1 âˆ¨ m % 2 = 1 âˆ§ n % 2 = 0) âˆ§ 0 â‰¤ m
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] : K âŠ” Ká—® = âŠ¤
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (m N : Submonoid R) [IsLocalization m S] (h : m â‰¤ N) (h' : âˆ€ (x : â†¥N), âˆƒ (m : R), m * â†‘x âˆˆ m) : IsLocalization N S
{R : Type u} {n : â„•} {m : Fin n.Succ â†’ Type v} {mâ‚‚ : Type vâ‚‚} [Semiring R] [Î  (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid mâ‚‚] [Î  (i : Fin n.Succ), module R (m i)] [module R mâ‚‚] (F : MultilinearMap R m mâ‚‚) (m : Î  (i : Fin n), m (â‡‘Fin.cast_Succ i)) (x y : m (Fin.Last n)) : â‡‘F (Fin.snoc m (x + y)) = â‡‘F (Fin.snoc m x) + â‡‘F (Fin.snoc m y)
{Î± : Type u} {A B : Î±} [MulZeroOneClass Î±] [PartialOrder Î±] [Zero_LT.Mul_Pos_Mono Î±] (ha : A â‰¤ 1) (hb : B â‰¤ 1) (B0 : 0 < B) : A * B â‰¤ 1
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) {P : Polynomial A} (pmonic : P.monic) (hp : â‡‘(Polynomial.aeval x) P = 0) : (minpoly A x).degree â‰¤ P.degree
{P : â„•} [Fact (Nat.Prime P)] {F : padic_Seq P} (hF : Â¬F â‰ˆ 0) (v2 v3 : â„•) : padic_norm P (â‡‘F (padic_Seq.stationary_point hF)) = padic_norm P (â‡‘F (LinearOrder.max (padic_Seq.stationary_point hF) (LinearOrder.max v2 v3)))
{m : Type u_3} {N : Type u_4} [MulZeroOneClass m] [MulZeroOneClass N] (F : m â†’*â‚€ N) {x y : m} (h : x = y) : â‡‘F x = â‡‘F y
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : â„•} {Sâ‚ Sâ‚‚ : Affine.Simplex k P n} (h : set.Range Sâ‚.points = set.Range Sâ‚‚.points) : Finset.centroid k Finset.Univ Sâ‚.points = Finset.centroid k Finset.Univ Sâ‚‚.points
{Î± : Type u_1} {Î² : Type u_2} (F : Î± â†’ Î²) (P : RegularExpression Î±) : (RegularExpression.Map F P).Matches = â‡‘(Language.Map F) P.Matches
(S : set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ 0 â‰¤ x) : 0 â‰¤ HasInf.Inf S
(Î± : Type u) [MetricSpace Î±] [TopologicalSpace.IsSeparable_Space Î±] : âˆƒ (F : Î± â†’ â†¥(Lp (Î» (n : â„•), â„) âŠ¤)), Isometry F
{L : FirstOrder.Language} {m : Type W} [L.structure m] (S : set m) {P : Î  (x : m), x âˆˆ â‡‘(FirstOrder.Language.Substructure.Closure L) S â†’ Prop} (Hs : âˆ€ (x : m) (h : x âˆˆ S), P x _) (Hfun : âˆ€ {n : â„•} (F : L.Functions n), FirstOrder.Language.IsClosed_under F {x : m | âˆƒ (hx : x âˆˆ â‡‘(FirstOrder.Language.Substructure.Closure L) S), P x hx}) {x : m} (hx : x âˆˆ â‡‘(FirstOrder.Language.Substructure.Closure L) S) : P x hx
{Î± : Type u_1} {Î² : Type u_2} [CompleteLattice Î±] {F : Filter Î²} {u : Î² â†’ Î±} : F.liminf u = â¨† (S : set Î²) (h : S âˆˆ F), â¨… (A : Î²) (h : A âˆˆ S), u A
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} {P : Type u_8} [has_Zero m] [CommMonoid N] [CommMonoid P] (h : N â‰ƒ* P) (F : Î± â†’â‚€ m) (g : Î± â†’ m â†’ N) : â‡‘h (F.Prod g) = F.Prod (Î» (A : Î±) (B : m), â‡‘h (g A B))
{Î± : Type u} [Preorder Î±] {S t : set Î±} (h : BddAbove t) : BddAbove (S âˆ© t)
{G : Type u_1} [Group G] {k : set G} {P : G â†’ Prop} {x : G} (h : x âˆˆ Subgroup.Closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ P x) (Hk_Inv : âˆ€ (x : G), x âˆˆ k â†’ P xâ»Â¹) (h1 : P 1) (HMul : âˆ€ (x y : G), P x â†’ P y â†’ P (x * y)) : P x
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {S : set Y} (F : bounded_Continuous_Function â†¥S â„) (hs : IsClosed S) {t : set â„} [t.Ord_connected] (hF : âˆ€ (x : â†¥S), â‡‘F x âˆˆ t) (hne : t.Nonempty) : âˆƒ (g : bounded_Continuous_Function Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ g.Restrict S = F
{n : â„•} {Î± : Type u_1} [Preorder Î±] {F g : Fin n â†ªo Î±} (h : set.Range â‡‘F = set.Range â‡‘g) : F = g
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (h : IsPreconnected S) : IsPreconnected (Closure S)
(A B : Finset â„•) : A.Sum (Î» (i : â„•), 2 ^ i) < B.Sum (Î» (i : â„•), 2 ^ i) â†” A.to_colex < B.to_colex
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [Finite_dimensional ð•œ E] (t : E â†’â‚—[ð•œ] E) : InnerProductSpace.IsSelfAdjoint (â‡‘LinearMap.Adjoint t * t)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : strict_ConcaveOn ð•œ S F) {x y : E} (hx : x âˆˆ S) (hy : y âˆˆ S) (hxy : x â‰  y) {A B : ð•œ} (ha : 0 < A) (hb : 0 < B) (hab : A + B = 1) : LinearOrder.min (F x) (F y) < F (A â€¢ x + B â€¢ y)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {C : â„} {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : Asymptotics._O_with C l F g â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥F xâˆ¥ â‰¤ C * âˆ¥g xâˆ¥)
{R : Type u_1} {S : Type u_2} [conditionally_complete_LinearOrder R] (S : Finset S) (F : S â†’ Tropical (WithTop R)) : Tropical.untrop (S.Sum (Î» (i : S), F i)) = â¨… (i : â†¥S), Tropical.untrop (F â†‘i)
{Î¹ : Type u_1} {ð•œ : Type u_3} [_R_or_C ð•œ] {E : Type u_4} [InnerProductSpace ð•œ E] {E' : Type u_5} [InnerProductSpace ð•œ E'] [Fintype Î¹] (v : Basis Î¹ ð•œ E) (hv : Orthonormal ð•œ â‡‘v) (F : E â‰ƒâ‚—áµ¢[ð•œ] E') : ((v.Map F.to_Linear_Equiv).to_Orthonormal_Basis _).repr = F.Symm.Trans (v.to_Orthonormal_Basis hv).repr
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} {R : Type u_11} [Monoid R] [AddMonoid m] [AddCommMonoid N] [Distrib_MulAction R m] {g : Î± â†’â‚€ m} {B : R} {h : Î± â†’ m â†’+ N} : (B â€¢ g).Sum (Î» (A : Î±), â‡‘(h A)) = g.Sum (Î» (i : Î±) (C : m), â‡‘(h i) (B â€¢ C))
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} {Pâ‚€ : P} (h : Pâ‚€ âˆˆ S) : Collinear k S â†” âˆƒ (v : v), âˆ€ (P : P), P âˆˆ S â†’ (âˆƒ (r : k), P = r â€¢ v +áµ¥ Pâ‚€)
{R : Type u} [Field R] (P : Polynomial R) : (Multiset.Map (Î» (A : R), Polynomial.x - â‡‘Polynomial.C A) P.roots).Prod âˆ£ P
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [DenselyOrdered Î±] {A B : Î±} {S : set Î±} (hs : IsClosed (S âˆ© set.icc A B)) (ha : A âˆˆ S) (hgt : âˆ€ (x : Î±), x âˆˆ S âˆ© set.Ico A B â†’ S âˆˆ nhds_within x (set.ioi x)) : set.icc A B âŠ† S
{A : Type u_2} [NormedRing A] [normed_Algebra â„‚ A] [CompleteSpace A] [NormOneClass A] (A : A) : Filter.Tendsto (Î» (n : â„•), Ennreal.of_Real (âˆ¥A ^ nâˆ¥ ^ (1 / â†‘n))) Filter.at_top (nhds (spectral_radius â„‚ A))
{P : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero â†‘â†‘P] {k : â„•} [hpri : Fact (Nat.Prime â†‘P)] [IsCyclotomicExtension {P ^ (k + 1)} K L] (hirr : Irreducible (Polynomial.cyclotomic â†‘(P ^ (k + 1)) K)) (h : P â‰  2) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta (P ^ (k + 1)) K L - 1) = â†‘P
{F : Type u} [Field F] {n : â„•} : (Polynomial.x ^ n - 1).IsSeparable â†” â†‘n â‰  0
{x y : Pgame} (ox : x.Numeric) (oy : y.Numeric) : x < y â†” (âˆƒ (i : y.Left_moves), x â‰¤ y.move_Left i) âˆ¨ âˆƒ (j : x.Right_moves), x.move_Right j â‰¤ y
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {F' : F} [LinearOrder ð•œ] [order_IsClosed_topology ð•œ] {x y : ð•œ} (h : x < y) : HasDerivWithinAt F F' (set.ioi x) x â†’ HasDerivWithinAt F F' (set.Ioo x y) x
{Î± : Type u} [PartialOrder Î±] {A B : Î±} : A â‰¤ B â†’ B â‰¤ A â†’ A = B
(F F' : â„ â†’ â„) {A B : â„} (hab : A < B) (g g' : â„ â†’ â„) {lfa lga lfb lgb : â„} (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivAt F (F' x) x) (hgg' : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivAt g (g' x) x) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds lfa)) (hga : Filter.Tendsto g (nhds_within A (set.ioi A)) (nhds lga)) (hfb : Filter.Tendsto F (nhds_within B (set.Iio B)) (nhds lfb)) (hgb : Filter.Tendsto g (nhds_within B (set.Iio B)) (nhds lgb)) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), (lgb - lga) * F' C = (lfb - lfa) * g' C
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : Dense S â†’ âˆ€ (U : set Î±), IsOpen U â†’ U.Nonempty â†’ (U âˆ© S).Nonempty
{v : Type u_1} [CategoryTheory.Category v] {Aâ‚ Bâ‚ Câ‚ Aâ‚‚ Bâ‚‚ Câ‚‚ Aâ‚ƒ Bâ‚ƒ Câ‚ƒ : v} {Fâ‚ : Aâ‚ âŸ¶ Bâ‚} {gâ‚ : Bâ‚ âŸ¶ Câ‚} {Fâ‚‚ : Aâ‚‚ âŸ¶ Bâ‚‚} {gâ‚‚ : Bâ‚‚ âŸ¶ Câ‚‚} {Fâ‚ƒ : Aâ‚ƒ âŸ¶ Bâ‚ƒ} {gâ‚ƒ : Bâ‚ƒ âŸ¶ Câ‚ƒ} {Î±â‚ : CategoryTheory.Arrow.Mk Fâ‚ âŸ¶ CategoryTheory.Arrow.Mk Fâ‚‚} {Î²â‚ : CategoryTheory.Arrow.Mk gâ‚ âŸ¶ CategoryTheory.Arrow.Mk gâ‚‚} {Î±â‚‚ : CategoryTheory.Arrow.Mk Fâ‚‚ âŸ¶ CategoryTheory.Arrow.Mk Fâ‚ƒ} {Î²â‚‚ : CategoryTheory.Arrow.Mk gâ‚‚ âŸ¶ CategoryTheory.Arrow.Mk gâ‚ƒ} (Pâ‚ : Î±â‚.Right = Î²â‚.Left) (Pâ‚‚ : Î±â‚‚.Right = Î²â‚‚.Left) : (Î±â‚ â‰« Î±â‚‚).Right = (Î²â‚ â‰« Î²â‚‚).Left
{x : Pgame} : 0 â‰¤ x â†” âˆ€ (j : x.Right_moves), âˆƒ (i : (x.move_Right j).Left_moves), 0 â‰¤ (x.move_Right j).move_Left i
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [CommMonoid Î±] {F : Î² â†’ Î±} {g : Î³ â†’ Î±} (h_Eq : âˆ€ (u : Finset Î³), âˆƒ (v : Finset Î²), âˆ€ (v' : Finset Î²), v âŠ† v' â†’ (âˆƒ (u' : Finset Î³), u âŠ† u' âˆ§ u'.Prod (Î» (x : Î³), g x) = v'.Prod (Î» (B : Î²), F B))) : Filter.Map (Î» (S : Finset Î²), S.Prod (Î» (B : Î²), F B)) Filter.at_top â‰¤ Filter.Map (Î» (S : Finset Î³), S.Prod (Î» (x : Î³), g x)) Filter.at_top
{R : Type u_1} {m : Type u_2} [OrderedSemiring R] [ordered_AddCommMonoid m] [SmulWithZero R m] [OrderedSmul R m] {A : m} {C : R} (hc : 0 < C) : 0 < A â†’ 0 < C â€¢ A
{S : set Ordinal} (hS : set.Unbounded has_LT.LT S) (A : Ordinal) : (S âˆ© set.ici A).Nonempty
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Finite_dimensional R m] (xâ‚ xâ‚‚ : Orientation R m Î¹) (h : Fintype.Card Î¹ = Finite_dimensional.finrank R m) : xâ‚ â‰  xâ‚‚ â†” xâ‚ = -xâ‚‚
{S : Type u} [Add_Semigroup S] {A B x y z : S} (ha : Add_SemiconjBy A y z) (hb : Add_SemiconjBy B x y) : Add_SemiconjBy (A + B) x z
{Î± : Type u} : Dense_Embedding has_pure.pure
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (F : E â†’L[ð•œ] F) : IsBoundedLinearMap ð•œ â‡‘F
{k : Type u_1} [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) (h : â†‘(S.Card) â‰  0) : S.Sum (Î» (i : Î¹), Finset.centroid_weights k S i) = 1
{P : â„•} (hp : Nat.Prime P) : P.factorization = Finsupp.single P 1
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S1 S2 : AffineSubspace k P} (hD : S1.direction = S2.direction) (hn : (â†‘S1 âˆ© â†‘S2).Nonempty) : S1 = S2
{G : Type u_7} [AddCommGroup G] (L : List G) : -L.Sum = (List.Map (Î» (x : G), -x) L).Sum
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : o.oangle (-x) y = o.oangle x (-y)
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (B : n â†’ Î±) (h : IsUnit A.det) : A.det â€¢ Aâ»Â¹.Mul_vec B = â‡‘(A.cramer) B
{Î¹ : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {l l' : Filter â„} {LT : Filter Î¹} {A : â„} [IntervalIntegral.FTC_Filter A l l'] (hfm : StronglyMeasurableAtFilter F l' MeasureTheory.MeasureSpace.Volume) (hF : Filter.Tendsto F (l' âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) {u v : Î¹ â†’ â„} (hu : Filter.Tendsto u LT l) (hv : Filter.Tendsto v LT l) : (Î» (t : Î¹), (âˆ« (x : â„) in u t..v t, F x) - (v t - u t) â€¢ C) =o[LT] (v - u)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (F : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : E), âˆ¥â‡‘F xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥F.Mk_Continuous C hâˆ¥ â‰¤ C
{m : Type u_1} [has_Add m] (S : Add_Subsemigroup m) : Add_Subsemigroup.Closure â†‘S = S
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [OrderedSemiring ð•œ] [AddCommGroup E] [module ð•œ E] {P : Î¹ â†’ E} (hi : Function.Injective P) : Convex_Independent ð•œ (Î» (x : â†¥(set.Range P)), â†‘x) â†” Convex_Independent ð•œ P
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {S : set E} (hscomp : IsCompact S) (hsnemp : S.Nonempty) : (set.ExtremePoints â„ S).Nonempty
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (A B C : P) : HasDist.dist A B ^ 2 + HasDist.dist A C ^ 2 = 2 * (HasDist.dist A (midpoint â„ B C) ^ 2 + (HasDist.dist B C / 2) ^ 2)
{m : Type u_1} {N : Type u_2} [MulOneClass m] [MulOneClass N] {C : Con m} {F : N â†’* m} : Con.comap â‡‘F _ C = Con.Ker (C.Mk'.Comp F)
(R : Type u_1) {S : Type u_2} {m : Type u_3} [CommRing R] [Ring S] [AddCommGroup m] [Algebra R S] [module S m] [module R m] [IsScalarTower R S m] (h : IsArtinian R m) : IsArtinian S m
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] : ContDiff ð•œ âŠ¤ â‡‘((Equiv.Prod_assoc E F G).Symm)
{R : Type u_1} [CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] : Disjoint (tensor_Algebra.Î¹ R).Range 1
(P : â„ Ã— â„) (hp : P.fst â‰  0) {n : WithTop â„•} : ContDiff_at â„ n (Î» (P : â„ Ã— â„), P.fst ^ P.Snd) P
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (F : C(Î±, Î²)) : Continuous â‡‘F
{Î± : Type u} [Preorder Î±] {A B : Î±} (h : A < B) : Â¬B â‰¤ A
{m : Type u_1} [AddMonoid m] (u : AddUnits m) (A : m) : IsAddUnit (â†‘u + A) â†” IsAddUnit A
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} (ha : A < 0) (hb : B â‰¤ 0) : A + B < 0
{Î± : Type u} [PseudoEmetricSpace Î±] (Î´ : â„) : Metric.Thickening Î´ âˆ… = âˆ…
{Î± : Type u} {F : Filter Î±} {Î² : Type v} {S : Î² â†’ set Î±} ( : Finset Î²) : (â‹‚ (i : Î²) (h : i âˆˆ ), S i) âˆˆ F â†” âˆ€ (i : Î²), i âˆˆ  â†’ S i âˆˆ F
{C : Type uâ‚} [CategoryTheory.Category C] {x Y Z : C} (P : x âŸ¶ Y) (q : Z = Y) : _.mpr P = P â‰« CategoryTheory.Eq_to_hom _
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : hb.oangle (â‡‘(hb.rotation (hb.oangle x y)) x) y = 0
{m : Type u_1} [AddMonoid m] {S : set m} : S âŠ† AddMonoid.Closure S
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] (oi : Î± â‰ƒo Î²) : GaloisConnection â‡‘oi â‡‘(oi.Symm)
{R : Type u_1} {m : Type u_2} [Ring R] [TopologicalSpace R] [TopologicalSpace m] [AddCommGroup m] [has_Continuous_Add m] [module R m] [has_Continuous_Smul R m] [(nhds_within 0 {x : R | IsUnit x}).Ne_IsBot] (S : Submodule R m) (hs : (Interior â†‘S).Nonempty) : S = âŠ¤
{t : â„} {g : â„ â†’ â„} (hg : Function.Periodic g t) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.MeasureSpace.Volume tâ‚ tâ‚‚) (hâ‚€ : âˆ€ (x : â„), 0 < g x) (hT : 0 < t) : Filter.Tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) Filter.at_IsBot Filter.at_IsBot
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommGroup Î²] [HasScalar ð•œ E] [module ð•œ Î²] {S : set E} {F : E â†’ Î²} : Convex_on ð•œ S F â†’ ConcaveOn ð•œ S (-F)
{Î± : Type u} [TopologicalSpace Î±] (Z : â„• â†’ set Î±) (hZd : âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) (hZn : âˆ€ (i : â„•), (Z i).Nonempty) (hZ0 : IsCompact (Z 0)) (hZcl : âˆ€ (i : â„•), IsClosed (Z i)) : (â‹‚ (i : â„•), Z i).Nonempty
{R : Type u_1} [CommSemiring R] (m : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] [IsLocalization m S] (z : S) : â‡‘(Algebra_Map R S) (IsLocalization.sec m z).fst = â‡‘(Algebra_Map R S) â†‘((IsLocalization.sec m z).Snd) * z
{R : Type u_1} {A B : R} [comm_Semigroup R] : IsRegular (A * B) â†” IsRegular A âˆ§ IsRegular B
{Î· : Type u_5} {F : Î· â†’ Type u_6} [Î  (i : Î·), Group (F i)] [DecidableEq Î·] [Fintype Î·] {h : Î  (i : Î·), Subgroup (F i)} {J : Subgroup (Î  (i : Î·), F i)} : Subgroup.Pi set.Univ h â‰¤ J â†” âˆ€ (i : Î·), Subgroup.Map (Monoid_hom.single F i) (h i) â‰¤ J
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S : set Î±} (hF : set.Eq_on F 1 S) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) = 1
(k : Type u_1) {v : Type u_2} (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (S : AffineSubspace k P) : P âˆˆ â†‘S â†” P âˆˆ S
{Î“â‚€ : Type u_1} [Linear_ordered_comm_Group_with_Zero Î“â‚€] (Î³ : Î“â‚€Ë£) : {â†‘Î³} âˆˆ nhds â†‘Î³
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} {r : â„} (hr : 0 â‰¤ r) (h1 : âˆ€ (x : Î±), x âˆˆ S â†’ metric.Inf_dist x t â‰¤ r) (h2 : âˆ€ (x : Î±), x âˆˆ t â†’ metric.Inf_dist x S â‰¤ r) : metric.Hausdorff_dist S t â‰¤ r
{R : Type u_1} {Râ‚ : Type u_2} {Râ‚‚ : Type u_3} {mâ‚ : Type u_6} {mâ‚‚ : Type u_7} [CommSemiring R] [CommSemiring Râ‚] [AddCommMonoid mâ‚] [module Râ‚ mâ‚] [CommSemiring Râ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚‚ mâ‚‚] {iâ‚ : Râ‚ â†’+* R} {iâ‚‚ : Râ‚‚ â†’+* R} {B : mâ‚ â†’â‚›â‚—[iâ‚] mâ‚‚ â†’â‚›â‚—[iâ‚‚] R} : B.separating_Left â†” B.Ker = âŠ¥
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {ps : set P} {n : â„•} [Finite_dimensional â„ v] (hD : Finite_dimensional.finrank â„ v = n) (hc : EuclideanGeometry.Cospherical ps) {sxâ‚ sxâ‚‚ : Affine.Simplex â„ P n} (hsxâ‚ : set.Range sxâ‚.points âŠ† ps) (hsxâ‚‚ : set.Range sxâ‚‚.points âŠ† ps) : sxâ‚.circumcenter = sxâ‚‚.circumcenter
{Î± : Type u_1} {P : Prop} {q : Î± â†’ Prop} : P â†’ âˆ€ (x : Î±), q x â†” âˆ€ (x : Î±), P â†’ q x
{m : Type u_1} [AddMonoid m] (C : Add_Con m) (n : â„•) {W x : m} : â‡‘C W x â†’ â‡‘C (n â€¢ W) (n â€¢ x)
{R : Type u} {N : Type z} [Semiring R] [AddCommMonoid N] [module R N] {P : Type v} [AddCommMonoid P] [module R P] (h : module.free R P) (e : P â‰ƒâ‚—[R] N) : module.free R N
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] {A B : Î±} (hab : A â‰  B) : Closure (set.Ico A B) = set.icc A B
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] (O : Finset C) (h : Finset (Î£' (x Y : C) (mX : x âˆˆ O) (mY : Y âˆˆ O), x âŸ¶ Y)) {x Y : C} (mX : x âˆˆ O) (mY : Y âˆˆ O) {F : x âŸ¶ Y} (mf : âŸ¨x, âŸ¨Y, âŸ¨mX, âŸ¨mY, FâŸ©âŸ©âŸ©âŸ© âˆˆ h) : CategoryTheory.IsCofiltered.Inf_to O h mX â‰« F = CategoryTheory.IsCofiltered.Inf_to O h mY
{Î± : Type u_1} {Î² : Type u_2} [AddCommGroup Î±] [UniformSpace Î±] [uniform_AddGroup Î±] [t1_Space Î±] (F : Î² â†’ Î±) : Filter.Tendsto (Î» (S : Finset Î²), âˆ‘' (B : {x // x âˆ‰ S}), F â†‘B) Filter.at_top (nhds 0)
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (h : Function.Injective â‡‘(Algebra_Map R A)) (P : â„•) [Char_P R P] : Char_P A P
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 : P} (h : P1 -áµ¥ P2 = 0) : P1 = P2
{G : Type u_1} [AddGroup G] [hN : Nontrivial G] : AddMonoid._torsion G â†’ Â¬AddMonoid._torsion_free G
{Î± : Type u} {Î² : Type v} {Î³ : Type W} [TopologicalSpace Î±] [PseudoMetricSpace Î²] [PseudoMetricSpace Î³] {G : Î² â†’ Î³} {C : Nnreal} (h : LipschitzWith C G) : uniform_Continuous (bounded_Continuous_Function.Comp G h)
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} (A B : m) : â‡‘(clifford_Algebra.Î¹ q) A * â‡‘(clifford_Algebra.Î¹ q) B + â‡‘(clifford_Algebra.Î¹ q) B * â‡‘(clifford_Algebra.Î¹ q) A = â‡‘(Algebra_Map R (clifford_Algebra q)) (QuadraticForm.polar â‡‘q A B)
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] (F : m â†’* P) : Function.Injective â‡‘(Con.Ker_Lift F)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] {S t : intermediate_Field K L} (h : âˆ€ (x : L), x âˆˆ S â†” x âˆˆ t) : S = t
{R : Type u} {L : Type v} {L' : Type Wâ‚‚} [CommRing R] [lie_Ring L] [lie_Algebra R L] [lie_Ring L'] [lie_Algebra R L'] (F : L â†’â‚—â…Râ† L') {iâ‚ iâ‚‚ : lie_Ideal R L} : lie_Ideal.Map F â…iâ‚,iâ‚‚â† â‰¤ â…lie_Ideal.Map F iâ‚,lie_Ideal.Map F iâ‚‚â†
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : IsClosed (Frontier S)
{G : Type u_1} [Group G] (h : Subgroup G) : h = âŠ¥ âˆ¨ âˆƒ (x : G) (h : x âˆˆ h), x â‰  1
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {F : E Ã— F â†’ G} (h : IsBoundedBilinearMap ð•œ F) : Continuous F
{Î± : Type u} [PseudoMetricSpace Î±] {F : â„• â†’ Î±} {m n : â„•} (hmn : m â‰¤ n) {D : â„• â†’ â„} (hD : âˆ€ {k : â„•}, m â‰¤ k â†’ k < n â†’ HasDist.dist (F k) (F (k + 1)) â‰¤ D k) : HasDist.dist (F m) (F n) â‰¤ (Finset.Ico m n).Sum (Î» (i : â„•), D i)
{A : Type u_4} [CommRing A] [IsDomain A] {L : Type u_6} [Field L] [Algebra A L] (alg : Algebra.IsAlgebraic A L) (inj : âˆ€ (x : A), â‡‘(Algebra_Map A L) x = 0 â†’ x = 0) : _fraction_Ring â†¥(integral_Closure A L) L
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [NormedGroup G] [NormedSpace ð•œ G] (q : FormalMultilinearSeries ð•œ F G) (P : FormalMultilinearSeries ð•œ E F) (N : â„•) (z : E) : q.partial_Sum N ((Finset.Ico 1 N).Sum (Î» (i : â„•), â‡‘(P i) (Î» (j : Fin i), z))) = (FormalMultilinearSeries.Comp_partial_Sum_Target 0 N N).Sum (Î» (i : Î£ (n : â„•), Composition n), â‡‘(q.Comp_along_Composition P i.Snd) (Î» (j : Fin i.fst), z))
{Î± : sort u_1} (P : Prop) [Decidable P] (A B : Î±) : dite P (Î» (h : P), A) (Î» (h : Â¬P), B) = Ite P A B
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {P : Filter Î¹} (h : TendstoUniformly F F P) (g : Î³ â†’ Î±) : TendstoUniformly (Î» (n : Î¹), F n âˆ˜ g) (F âˆ˜ g) P
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F : x âŸ¶ Y} {F F' : CategoryTheory.Limits.MonoFactorisation F} (hI : F.i = F'.i) (hm : F.m = CategoryTheory.Eq_to_hom hI â‰« F'.m) : F = F'
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : Affine.Simplex â„ P 0) (i : Fin 1) : S.circumcenter = S.points i
{m : Type u_1} [Nonempty m] [Semigroup m] [TopologicalSpace m] [CompactSpace m] [t2_Space m] (Continuous_Mul_Left : âˆ€ (r : m), Continuous (Î» (_x : m), _x * r)) : âˆƒ (m : m), m * m = m
{R : Type u_1} (m : Type u_3) [Monoid R] [MulAction R m] (A : RË£) : IsSmulRegular m â†‘A
{cb : CharBuffer} {n n' val : â„•} (h : Parser.Nat cb n = ParseResult.done n' val) (hn : n' < Buffer.size cb) : '0' â‰¤ Buffer.read cb âŸ¨n', hnâŸ© â†’ '9' < Buffer.read cb âŸ¨n', hnâŸ©
{Î± : Type u} {F g : Î± â†’ Î±} (h : Function.Commute F g) : set.bij_on F (Function.FixedPoints (F âˆ˜ g)) (Function.FixedPoints (F âˆ˜ g))
{F : Type u_3} [InnerProductSpace â„ F] (K : Submodule â„ F) {u v : F} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (W : â†¥â†‘K), âˆ¥u - â†‘Wâˆ¥) â†” âˆ€ (W : F), W âˆˆ K â†’ HasInner.inner (u - v) W = 0
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {l : Filter Î±} {A : Î±} : IsMax_Filter (â‡‘order_dual.to_dual âˆ˜ F) l A â†’ IsMin_Filter F l A
{m : Type u_1} {n : Type u_2} [Fintype m] [Fintype n] {R : Type v} [Field R] : Finite_dimensional.finrank R (Matrix m n R) = Fintype.Card m * Fintype.Card n
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {x : E} (hF : HasStrictFderivAt F F' x) (K : Nnreal) (hK : âˆ¥F'âˆ¥â‚Š < K) : âˆƒ (S : set E) (h : S âˆˆ nhds x), LipschitzOnWith K F S
(n : â„•+) : n.factor_Multiset.Prod = n
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B : Î±} (ha : A < 1) (hb : B < 1) : A * B < 1
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] (x : C) : CategoryTheory.IsPullback 0 0 0 (ðŸ™ x)
{m : Type u_1} [Monoid m] (C : Con m) (n : â„•) {W x : m} : â‡‘C W x â†’ â‡‘C (W ^ n) (x ^ n)
{Î± : Type u_1} {m : Type u_5} [has_Zero m] {B : m} (h : B â‰  0) : Function.Injective (Î» (A : Î±), Finsupp.single A B)
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} {F : x âŸ¶ Y} [CategoryTheory.SplitMono F] [CategoryTheory.Mono (CategoryTheory.retraction F)] : CategoryTheory.IsIso F
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [Î  (i : Î¹), has_Zero (Î² i)] {i j : Î¹} {xi : Î² i} {xj : Î² j} (h : âŸ¨i, xiâŸ© = âŸ¨j, xjâŸ©) : Dfinsupp.single i xi = Dfinsupp.single j xj
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {m : Matrix n n R} {i j : n} (i_Ne_j : i â‰  j) (hij : m i = m j) : m.det = 0
(r : Ennreal) : âˆ‘' (n : â„•), r ^ n = (1 - r)â»Â¹
{P : â„•} [Fact (Nat.Prime P)] : WittVector.IsPolyâ‚‚ P (Î» (_x : Type u_1) (_x_1 : CommRing _x), has_Mul.Mul)
{R : Type u_2} {Î“â‚€ : Type u_3} [Ring R] [Linear_ordered_CommMonoid_with_Zero Î“â‚€] {vâ‚ vâ‚‚ : Valuation R Î“â‚€} : vâ‚ = vâ‚‚ â†” âˆ€ (r : R), â‡‘vâ‚ r = â‡‘vâ‚‚ r
(R : Type u) (L : Type v) [CommRing R] [lie_Ring L] [lie_Algebra R L] (h : LieSubalgebra R L) [lie_Algebra.IsNilpotent R â†¥h] (h : lie_Algebra.Zero_root_Subalgebra R L h = h) : h._cartan_Subalgebra
{Î± : Type u_1} {ð’œ : Finset (Finset Î±)} {r : â„•} : ð’œ.Slice r âŠ† ð’œ
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : A â‰¤ 0) (hb : B â‰¤ 0) : A + B â‰¤ 0
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x : v} (hx : x â‰  0) (Î¸ : Real.Angle) : o.oangle (â‡‘(o.rotation Î¸) x) x = -Î¸
{G : Type u_3} [AddGroup G] : AddGroup.fg G â†” âˆƒ (S : set G), Add_Subgroup.Closure S = âŠ¤ âˆ§ S.Finite
(A B C : â„) (hb : 0 â‰  B) : Filter.Tendsto (Î» (x : â„), x ^ (A / (B * x + C))) Filter.at_top (nhds 1)
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {x y : m} : SameRay R (-x) (-y) â†’ SameRay R x y
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {Câ‚ Câ‚‚ Pâ‚ Pâ‚‚ : P} (hcâ‚ : HasDist.dist Pâ‚ Câ‚ = HasDist.dist Pâ‚‚ Câ‚) (hcâ‚‚ : HasDist.dist Pâ‚ Câ‚‚ = HasDist.dist Pâ‚‚ Câ‚‚) : HasInner.inner (Câ‚‚ -áµ¥ Câ‚) (Pâ‚‚ -áµ¥ Pâ‚) = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {P : Î¹ â†’ P} (hi : AffineIndependent k P) {S : Finset Î¹} {sp : AffineSubspace k P} [Finite_dimensional k â†¥(sp.direction)] (hle : affine_Span k â†‘(Finset.image P S) â‰¤ sp) (hc : S.Card = Finite_dimensional.finrank k â†¥(sp.direction) + 1) : affine_Span k â†‘(Finset.image P S) = sp
{Î± : Type u_1} {Î² : Type u_2} [AddCommGroup Î±] [UniformSpace Î±] [CompleteSpace Î±] {F : Î² â†’ Î±} : Summable F â†” Cauchy_Seq (Î» (S : Finset Î²), S.Sum (Î» (B : Î²), F B))
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} {v : v} {S : set Î¹} {P : Î¹ â†’ P} : (âˆƒ (fs : Finset Î¹) (hfs : â†‘fs âŠ† S) (W : Î¹ â†’ k) (hw : fs.Sum (Î» (i : Î¹), W i) = 0), v = â‡‘(fs.weighted_vsub P) W) â†” âˆƒ (fs : Finset â†¥S) (W : â†¥S â†’ k) (hw : fs.Sum (Î» (i : â†¥S), W i) = 0), v = â‡‘(fs.weighted_vsub (Î» (i : â†¥S), P â†‘i)) W
{Î± : Type u} {Î² : Type v} {S : set Î²} (hs : S.Subsingleton) {F : Î± â†’ Î²} (hF : Function.Injective F) : (F â»Â¹' S).Subsingleton
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] : IsNoetherian R m â†” âˆ€ (S : Submodule R m), S.fg
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {S : set Î±} (hs : IsConnected S) (hb : BddBelow S) (ha : BddAbove S) : set.Ioo (HasInf.Inf S) (HasSup.Sup S) âŠ† S
{Î¹ : Type u_1} {R : Type u_3} {A : Type u_5} {x : Î¹ â†’ A} [CommRing R] [CommRing A] [Algebra R A] {K : Type u_2} [CommRing K] [Algebra R K] [Algebra K A] [IsScalarTower R K A] (hinj : Function.Injective â‡‘(Algebra_Map R K)) (ai : AlgebraicIndependent K x) : AlgebraicIndependent R x
{n : WithTop â„•} {ð•‚ : Type u_6} [_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [NormedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace ð•‚ F'] {F : E' â†’ F'} {x : E'} (hF : ContDiff_at ð•‚ n F x) (hn : 1 â‰¤ n) : HasStrictFderivAt F (fderiv ð•‚ F x) x
{A B C : Prop} : A âˆ¨ B âˆ§ C â†” (A âˆ¨ B) âˆ§ (A âˆ¨ C)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [NormedSpace ð•œ E'] {n : WithTop â„•} {F : E â†’ E'} {S : set E} : Cont_mdiff_on (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') n F S â†’ ContDiff_on ð•œ n F S
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_3} [Fintype Î±] [Fintype Î²] [CommMonoid m] (e : Î± â‰ƒ Î²) (F : Î± â†’ m) (g : Î² â†’ m) (h : âˆ€ (x : Î±), F x = g (â‡‘e x)) : Finset.Univ.Prod (Î» (x : Î±), F x) = Finset.Univ.Prod (Î» (x : Î²), g x)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : A < 1) (hb : B < 1) : A * B < 1
{Î± : Type uu} [DecidableEq Î±] {lâ‚ lâ‚‚ : List Î±} : lâ‚ <+~ lâ‚‚ â†” âˆ€ (x : Î±), x âˆˆ lâ‚ â†’ List.count x lâ‚ â‰¤ List.count x lâ‚‚
{Î¹ : Type u_1} {m : Type u_4} [ordered_AddCommMonoid m] {S : Finset Î¹} {F : Î¹ â†’ WithTop m} : S.Sum (Î» (i : Î¹), F i) < âŠ¤ â†” âˆ€ (i : Î¹), i âˆˆ S â†’ F i < âŠ¤
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {xâ‚ xâ‚‚ y z : v} (hxâ‚yne : xâ‚ â‰  y) (hxâ‚zne : xâ‚ â‰  z) (hxâ‚‚yne : xâ‚‚ â‰  y) (hxâ‚‚zne : xâ‚‚ â‰  z) {r : â„} (hxâ‚ : âˆ¥xâ‚âˆ¥ = r) (hxâ‚‚ : âˆ¥xâ‚‚âˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : 2 â€¢ hb.oangle (y - xâ‚) (z - xâ‚) = 2 â€¢ hb.oangle (y - xâ‚‚) (z - xâ‚‚)
{A : Type u_1} (B : Type u_2) [Ring A] [Ring B] [IsDomain B] (e : A â‰ƒ+* B) : IsDomain A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {S : set E} {F : E â†’ ð•œ} {g : E â†’ F} (hF : ContDiff_on ð•œ n F S) (hg : ContDiff_on ð•œ n g S) : ContDiff_on ð•œ n (Î» (x : E), F x â€¢ g x) S
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : AffineSubspace k P) : S.direction = Vector_Span k â†‘S
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] (F : â„‚ â†’ E) (F' : â„‚ â†’ (â„‚ â†’L[â„] E)) (z W : â„‚) (Hc : Continuous_on F (set.Interval z.re W.re Ã—â„‚ set.Interval z.im W.im)) (hD : âˆ€ (x : â„‚), x âˆˆ set.Ioo (LinearOrder.min z.re W.re) (LinearOrder.max z.re W.re) Ã—â„‚ set.Ioo (LinearOrder.min z.im W.im) (LinearOrder.max z.im W.im) â†’ HasFderivAt F (F' x) x) (Hi : MeasureTheory.IntegrableOn (Î» (z : â„‚), Complex.i â€¢ â‡‘(F' z) 1 - â‡‘(F' z) Complex.i) (set.Interval z.re W.re Ã—â„‚ set.Interval z.im W.im) MeasureTheory.MeasureSpace.Volume) : (((âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(W.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(W.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(z.re) + â†‘y * Complex.i) = âˆ« (x : â„) in z.re..W.re, âˆ« (y : â„) in z.im..W.im, Complex.i â€¢ â‡‘(F' (â†‘x + â†‘y * Complex.i)) 1 - â‡‘(F' (â†‘x + â†‘y * Complex.i)) Complex.i
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] {A : K} (nth_Part_Num_Eq : (GeneralizedContinuedFraction.of v).partial_numerators.nth n = Option.Some A) : A = 1
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {B : m} [Linear_ordered_CommRing m] (hb : â†‘(Fintype.Card Î±) < Fintype.Card Î² â€¢ B) : âˆƒ (y : Î²), â†‘((Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Card) < B
{Î± : Type u} [Preorder Î±] {A B : Î±} (h : A < B) : Â¬B < A
{Î± : Type u_1} {E : Î± â†’ Type u_2} {P : Ennreal} [Î  (i : Î±), NormedGroup (E i)] [DecidableEq Î±] [Fact (1 â‰¤ P)] (hp : P â‰  âŠ¤) (F : â†¥(Lp E P)) : has_Sum (Î» (i : Î±), Lp.single P i (â‡‘F i)) F
{G : Type u} {y : G} [AddMonoid G] {x : G} (h : Add_Commute x y) (hx : _of_Fin_Add_order x) (hy : _of_Fin_Add_order y) : _of_Fin_Add_order (x + y)
(Î¸ : â„‚) (n : â„•) : Polynomial.Eval (Complex.cos Î¸) (Polynomial.Chebyshev.t â„‚ n) = Complex.cos (â†‘n * Î¸)
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R m) (F : m â‰ƒâ‚—[R] m) : (e.Map F).Orientation = e.Orientation â†” 0 < â‡‘LinearMap.det â†‘F
{A : Type u_1} [CommRing A] [Algebra â„š A] (t : A) : PowerSeries.Mk (Î» (n : â„•), â‡‘(Polynomial.aeval t) ((1 / â†‘(n.factorial)) â€¢ Polynomial.bernoulli n)) * (PowerSeries.Exp A - 1) = PowerSeries.x * â‡‘(PowerSeries.rescale t) (PowerSeries.Exp A)
{P : â„•+} {k : â„•} [hp : Fact (Nat.Prime â†‘P)] : IsIntegral_Closure (cyclotomic_Ring (P ^ k) â„¤ â„š) â„¤ (cyclotomic_Field (P ^ k) â„š)
{Î± : Type u_1} [DecidableEq Î±] (A : Î±) : Derangements.Equiv.RemoveNone.fiber (Option.Some A) = {F : Equiv.perm Î± | Function.FixedPoints â‡‘F âŠ† {A}}
{m : Type u_1} [has_Add m] {S t : Add_Subsemigroup m} (h : âˆ€ (x : m), x âˆˆ S â†” x âˆˆ t) : S = t
{m : Type u} [Monoid m] {x y : m} (hxy : x âˆ£ y) {n : â„•} (hn : n â‰  0) : x âˆ£ y ^ n
{Î± : Type u_1} {Î² : Type u_2} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {K : Nnreal} {F : Î± â†’ Î²} : AntilipschitzWith K F â†’ âˆ€ (x y : Î±), HasDist.dist x y â‰¤ â†‘K * HasDist.dist (F x) (F y)
{Î± : Type u} {Î¹ : Type v} [MetricSpace Î±] [ProperSpace Î±] {C : Î¹ â†’ Î±} {r : Î¹ â†’ â„} (hr : âˆ€ (i : Î¹), 0 < r i) (uf : âˆ€ (x : Î±), {i : Î¹ | x âˆˆ Metric.Ball (C i) (r i)}.Finite) (uU : (â‹ƒ (i : Î¹), Metric.Ball (C i) (r i)) = set.Univ) : âˆƒ (r' : Î¹ â†’ â„), (â‹ƒ (i : Î¹), Metric.Ball (C i) (r' i)) = set.Univ âˆ§ âˆ€ (i : Î¹), r' i âˆˆ set.Ioo 0 (r i)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {x : E} {F' : TangentSpace (model_with_corners_self ð•œ E) x â†’L[ð•œ] TangentSpace (model_with_corners_self ð•œ E') (F x)} : HasMfderivAt (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F x F' â†’ HasFderivAt F F' x
{G : Type u_1} [AddGroup G] (tG : AddMonoid._torsion_free G) (h : Add_Subgroup G) : AddMonoid._torsion_free â†¥h
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x y : Î±} : metric.Inf_dist x S â‰¤ metric.Inf_dist y S + HasDist.dist x y
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} {t : Add_Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) {q : Type u_4} [AddCommMonoid q] {k : t.Localization_Map q} {A : Type u_5} [AddCommMonoid A] {U : Add_Submonoid A} {R : Type u_6} [AddCommMonoid R] (j : U.Localization_Map R) {l : P â†’+ A} (hl : âˆ€ (W : â†¥t), â‡‘l â†‘W âˆˆ U) : (k.Map hl j).Comp (F.Map hy k) = F.Map _ j
{Î± : Type u_1} [Preorder Î±] [BoundedOrder Î±] [IsSimpleOrder Î±] {A B : Î±} (h : A < B) : B = âŠ¤
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (hab : A < B) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : F (â‡‘(affine_Map.line_Map A B) r) < â‡‘(affine_Map.line_Map (F A) (F B)) r â†” slope F A (â‡‘(affine_Map.line_Map A B) r) < slope F (â‡‘(affine_Map.line_Map A B) r) B
{A : Type u_1} {R : Type u_2} (K : Type u_3) [CommRing A] [IsDomain A] [normalized_Gcd_Monoid A] [Field K] [CommRing R] [IsDomain R] [Algebra A K] [_fraction_Ring A K] [Algebra K R] [Algebra A R] [IsScalarTower A K R] {x : R} (hx : IsIntegral A x) : minpoly K x = Polynomial.Map (Algebra_Map A K) (minpoly A x)
{R : Type u_1} {m : Type u_3} {A B : R} [Monoid R] [MulAction R m] (h : A * B = 1) : IsSmulRegular m B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : E â†’ G} {x : E} {y : F} (hF : ContDiff_at ð•œ n F x) : ContDiff_at ð•œ n (Î» (x : E Ã— F), F x.fst) (x, y)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {F g : E â†’ F} (hF : ContDiff ð•œ n F) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Î» (x : E), F x - g x)
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {C : â„} (hâ‚€ : 0 â‰¤ C) (h : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ HasDist.dist x y â‰¤ C) : Metric.diam S â‰¤ C
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {x : E} {n : WithTop â„•} {F : E â†’ F} {g : E â†’ G} (hF : ContDiff_at ð•œ n F x) (hg : ContDiff_at ð•œ n g x) : ContDiff_at ð•œ n (Î» (x : E), (F x, g x)) x
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] : IsNoetherian K v â†” module.Finite K v
(R : Type u) [Ring R] [strong_RankCondition R] (m n : Type u) [Fintype m] [Fintype n] : module.rank R (Matrix m n R) = Cardinal.Mk m * Cardinal.Mk n
{Î± : Type u} [PartialOrder Î±] {A B : Î±} : A â‰¤ B â†’ A â‰  B â†’ A < B
{mâ‚€ : Type u_1} [Mul_Zero_class mâ‚€] [no_Zero_divisors mâ‚€] {A B : mâ‚€} : A * B â‰  0 â†” B * A â‰  0
{Î± : Type u_1} [PartialOrder Î±] [SuccOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ico n m â†’ r i (Order.Succ i)) (hnm : n < m) : Relation.TransGen r n m
{A : Type u_1} {K : Type u_2} [CommRing A] [IsDomain A] [Unique_factorization_Monoid A] [Field K] [Algebra A K] [_fraction_Ring A K] {P : Polynomial A} (hp : P.monic) {r : K} (hr : â‡‘(Polynomial.aeval r) P = 0) : IsLocalization._integer A r
(ð•œ : Type u_1) {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {v : E} (W : E) : â†‘(â‡‘(Orthogonal_projection (Submodule.Span ð•œ {v})) W) = (HasInner.inner v W / â†‘âˆ¥vâˆ¥ ^ 2) â€¢ v
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] [DenselyOrdered Î²] {F : Î± â†’ Î²} (h_Mono : Monotone F) (h_surj : Function.Surjective F) : Continuous F
{Î± : Type u} {S : set Î±} : S.Finite âˆ¨ S.Infinite
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace ð•œ] (S : Submodule ð•œ E) [Finite_dimensional ð•œ â†¥S] : IsComplete â†‘S
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} (ha : 0 â‰¤ A) (hb : 0 < B) : 0 < A + B
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] [Nontrivial E] {x : E} {r : â„} : (Metric.Sphere x r).Nonempty â†” 0 â‰¤ r
{Î¹ : Type u_1} {N : Type u_5} [ordered_AddCommMonoid N] {F g : Î¹ â†’ N} {S : Finset Î¹} (h : âˆ€ (i : Î¹), i âˆˆ S â†’ F i â‰¤ g i) : S.Sum (Î» (i : Î¹), F i) â‰¤ S.Sum (Î» (i : Î¹), g i)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (lâ‚ lâ‚‚ : Î¹ â†’ ð•œ) (S : Finset Î¹) : HasInner.inner (S.Sum (Î» (i : Î¹), lâ‚ i â€¢ v i)) (S.Sum (Î» (i : Î¹), lâ‚‚ i â€¢ v i)) = S.Sum (Î» (i : Î¹), â‡‘(Star_Ring_end ð•œ) (lâ‚ i) * lâ‚‚ i)
{G : Type u_1} [AddGroup G] (g1 g2 : G) : g1 -áµ¥ g2 = g1 - g2
{P : Type u_2} [MetricSpace P] (ps : set P) : EuclideanGeometry.Cospherical ps â†” âˆƒ (Center : P) (radius : â„), âˆ€ (P : P), P âˆˆ ps â†’ HasDist.dist P Center = radius
{Î± : Type u_1} [TopologicalSpace Î±] {S : set Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] [has_Continuous_Add Î³] {F g : Î± â†’ Î³} (hF : LowerSemicontinuousOn F S) (hg : LowerSemicontinuousOn g S) : LowerSemicontinuousOn (Î» (z : Î±), F z + g z) S
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {P : Polynomial A} (pnz : P â‰  0) (hp : â‡‘(Polynomial.aeval x) P = 0) : (minpoly A x).degree â‰¤ P.degree
{Î± : Type u} {Î² : Type v} [PseudoEmetricSpace Î±] [PseudoEmetricSpace Î²] {F : Î± â†’ Î²} (hF : Isometry F) : Continuous F
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Finite_dimensional k v] {S : set P} (hi : AffineIndependent k Coe) : S.Finite
{Î¹ : Type u_1} {E : Type u_3} [semi_NormedGroup E] [CompleteSpace E] {F : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : Summable g) (h : âˆ€á¶  (i : Î¹) in Filter.cofinite, âˆ¥F iâˆ¥ â‰¤ g i) : Summable F
{Î± : Type u} [AddCommGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B C : Î±} : A - B â‰¤ C â†’ A â‰¤ B + C
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} : metric.Hausdorff_dist S S = 0
{K : Type u} [Field K] {S : set K} : S âŠ† â†‘(Subfield.Closure S)
{Î¹ : Type u_1} {R : Type u_4} [DecidableEq Î¹] [AddMonoid Î¹] [Semiring R] (A : Î¹ â†’ Add_Submonoid R) [set_like.graded_Monoid A] (i : Î¹) (x : â†¥(A i)) : â‡‘(direct_Sum.Coe_Ring_hom A) (â‡‘(direct_Sum.of (Î» (i : Î¹), â†¥(A i)) i) x) = â†‘x
{Î± Î² : Type u} (r : Î± â†’ Î± â†’ Prop) [wo : IsWellOrder Î± r] (S : Î² â†’ set Î±) (hâ‚ : set.Unbounded r (â‹ƒ (x : Î²), S x)) (hâ‚‚ : Cardinal.Mk Î² < StrictOrder.cof r) : âˆƒ (x : Î²), set.Unbounded r (S x)
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F G : J â¥¤ C} [CategoryTheory.Limits.HasLimit F] (Î± : F â‰… G) : CategoryTheory.Limits.HasLimit G
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : â‡‘(EuclideanGeometry.reflection S) P = â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P) -áµ¥ P +áµ¥ â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P)
{n : â„•} (P : Fin (n + 1)) (i : Fin n) (h : â‡‘Fin.cast_Succ i < P) : â‡‘(P.Succ_above) i = â‡‘Fin.cast_Succ i
{G : Type u_1} [AddGroup G] (h N : Add_Subgroup G) [N.Normal] : â†‘(h âŠ” N) = â†‘h + â†‘N
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {t : set (set Î±)} (h : t.Pairwise_Disjoint Id) (htâ‚€ : t.Finite) (htâ‚ : âˆ€ (x : set Î±), x âˆˆ t â†’ x.Finite) : finsum (Î» (A : Î±), finsum (Î» (h : A âˆˆ â‹ƒâ‚€t), F A)) = finsum (Î» (S : set Î±), finsum (Î» (h : S âˆˆ t), finsum (Î» (A : Î±), finsum (Î» (h : A âˆˆ S), F A))))
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (Î¸â‚ Î¸â‚‚ : Real.Angle) : (o.rotation Î¸â‚).Trans (o.rotation Î¸â‚‚) = o.rotation (Î¸â‚‚ + Î¸â‚)
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : F =O[l] g' â†” âˆ€á¶  (C : â„) in Filter.at_top, Asymptotics._O_with C l F g'
{Î± : Type u_1} [LinearOrder Î±] {S : set Î±} : Â¬BddAbove S â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (h : y âˆˆ S), x < y
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {A B : Matrix n n Î±} (h : A.Mul B = 1) : Aâ»Â¹ = B
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.Forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.Forget C)] {x : top} (F : top.sheaf C x) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥x) (v : TopologicalSpace.Opens â†¥x) (iUV : Î  (i : Î¹), U i âŸ¶ v) (hcover : v â‰¤ supr U) (sf : Î  (i : Î¹), â†¥(F.val.obj (Opposite.Op (U i)))) (h : F.val._compatible U sf) : âˆƒ! (S : â†¥(F.val.obj (Opposite.Op v))), âˆ€ (i : Î¹), â‡‘(F.val.Map (iUV i).Op) S = sf i
(n k : â„•) : n.factorial * n.asc_factorial k = (n + k).factorial
{Î± : Type u_1} {Î² : Type u_2} [MeasurableSpace Î±] [MeasurableSpace Î²] (e : Î± â‰ƒáµ Î²) : Measurable_Embedding â‡‘e
{F : Type u_3} [InnerProductSpace â„ F] (x : F) (r : â„) : HasInner.inner x (r â€¢ x) = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : hb.oangle (â‡‘(hb.rotation Î¸) x) y = hb.oangle x y - Î¸
 : CategoryTheory.EssSurj Compactum_to_CompHaus
{D : set â„} (hD : Convex â„ D) (hDâ‚‚ : IsOpen D) {F : â„ â†’ â„} (hF' : DifferentiableOn â„ F D) (hF'' : DifferentiableOn â„ (deriv F) D) (hF''_nonpos : âˆ€ (x : â„), x âˆˆ D â†’ deriv^[2] F x â‰¤ 0) : ConcaveOn â„ D F
{k : Type u_1} {K : Type u_2} [Field k] [_alg_IsClosed k] [Field K] {F : k â†’+* K} (P : Polynomial k) : Polynomial.Splits F P
{k : Type u_1} {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Finite_dimensional k v] [Fintype Î¹] {P : Î¹ â†’ P} (hi : AffineIndependent k P) (hc : Fintype.Card Î¹ = Finite_dimensional.finrank k v + 1) : Vector_Span k (set.Range P) = âŠ¤
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (q : C) (A : â†¥P) : â‡‘0 A = 0
{E : Type u_1} {F : Type u_2} {ð•œ : Type u_3} {ð•œâ‚‚ : Type u_4} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [Ring_hom_isometric Ïƒâ‚â‚‚] {Î¹ : Type u_5} [CompleteSpace E] {g : Î¹ â†’ (E â†’sl[Ïƒâ‚â‚‚] F)} (h : âˆ€ (x : E), (â¨† (i : Î¹), â†‘âˆ¥â‡‘(g i) xâˆ¥â‚Š) < âŠ¤) : (â¨† (i : Î¹), â†‘âˆ¥g iâˆ¥â‚Š) < âŠ¤
{G : Type u_1} [AddGroup G] {x y : G} : y âˆˆ Add_Subgroup.Closure {x} â†” âˆƒ (n : â„¤), n â€¢ x = y
{G : Type u_1} [AddGroup G] (h : Add_Subgroup G) {x y : G} : x âˆˆ h â†’ y âˆˆ h â†’ x + y âˆˆ h
{m : Type u_1} [MulOneClass m] {C : Con m} : â†‘1 = 1
{R : Type u_1} [Mul_Zero_class R] (h : IsRegular 0) : Subsingleton R
{C : Type u} [CategoryTheory.Category C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ C) [CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.Functor F.obj)] [CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.Functor (Î» (F : Î£ (P : J Ã— J), P.fst âŸ¶ P.Snd), F.obj F.fst.Snd))] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasLimit F
{Î· : Type u_2} [Fintype Î·] {Gs : Î· â†’ Type u_3} [Î  (i : Î·), Group (Gs i)] [âˆ€ (i : Î·), Group.IsNilpotent (Gs i)] : Group.nilpotency_class (Î  (i : Î·), Gs i) = Finset.Univ.Sup (Î» (i : Î·), Group.nilpotency_class (Gs i))
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A : Î±} : Aâ»Â¹ < 1 â†” 1 < A
{P : â„•} (hp : Nat.Prime P) (n : â„•) : (P ^ (n + 1)).Totient = P ^ n * (P - 1)
{Î± : Type u} [PseudoEmetricSpace Î±] {F : â„• â†’ Î±} {m n : â„•} (hmn : m â‰¤ n) {D : â„• â†’ Ennreal} (hD : âˆ€ {k : â„•}, m â‰¤ k â†’ k < n â†’ HasEdist.edist (F k) (F (k + 1)) â‰¤ D k) : HasEdist.edist (F m) (F n) â‰¤ (Finset.Ico m n).Sum (Î» (i : â„•), D i)
{R : Type u_4} {S : Type u_5} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R â‰ƒ+* S) : â‡‘F 1 = 1
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {ps : set P} {n : â„•} [Finite_dimensional â„ v] (hD : Finite_dimensional.finrank â„ v = n) (hc : EuclideanGeometry.Cospherical ps) {sxâ‚ sxâ‚‚ : Affine.Simplex â„ P n} (hsxâ‚ : set.Range sxâ‚.points âŠ† ps) (hsxâ‚‚ : set.Range sxâ‚‚.points âŠ† ps) : sxâ‚.circumradius = sxâ‚‚.circumradius
 : List.Nat.antidiagonal 0 = [(0, 0)]
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : A < 1) (hb : B â‰¤ 1) : A * B < 1
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D â¥¤ C} [CategoryTheory.Reflective i] (x : C) : (CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App (i.obj ((CategoryTheory.IsLeftAdjoint i).obj x)) = i.Map ((CategoryTheory.IsLeftAdjoint i).Map ((CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App x))
 : Multiset.Nat.antidiagonal 0 = {(0, 0)}
{Î± : Type u} [TopologicalSpace Î±] [t2_Space Î±] {K U v : set Î±} (hK : IsCompact K) (hU : IsOpen U) (hV : IsOpen v) (h2K : K âŠ† U âˆª v) : âˆƒ (Kâ‚ Kâ‚‚ : set Î±), IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† v âˆ§ K = Kâ‚ âˆª Kâ‚‚
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] (A_Int : Algebra.IsIntegral R A) (x : B) (hx : IsIntegral A x) : IsIntegral R x
{x y : Pgame} (ox : x.Numeric) (oy : y.Numeric) : x < y â†” (âˆƒ (i : y.Left_moves), (âˆ€ (i' : x.Left_moves), x.move_Left i' < y.move_Left i) âˆ§ âˆ€ (j : (y.move_Left i).Right_moves), x < (y.move_Left i).move_Right j) âˆ¨ âˆƒ (j : x.Right_moves), (âˆ€ (i : (x.move_Right j).Left_moves), (x.move_Right j).move_Left i < y) âˆ§ âˆ€ (j' : y.Right_moves), x.move_Right j < y.move_Right j'
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [Add_cancel_CommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [HasScalar ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : strict_ConcaveOn ð•œ S F) (C : E) : strict_ConcaveOn ð•œ ((Î» (z : E), C + z) â»Â¹' S) (F âˆ˜ Î» (z : E), C + z)
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] [Group Î±] [uniform_Group Î±] {hom : Type u_3} [UniformSpace Î²] [DiscreteTopology Î²] [Group Î²] [uniform_Group Î²] [Monoid_hom_class hom Î± Î²] {F : hom} : uniform_Continuous â‡‘F â†” IsOpen â†‘(â†‘F.Ker)
{Î± : sort u_1} {Sâ‚ : Setoid Î±} {P : Quotient Sâ‚ â†’ Prop} (h : âˆ€ (A : Î±), P (Quotient.Mk' A)) (q : Quotient Sâ‚) : P q
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] {F : Type v} [NormedGroup F] [NormedSpace â„‚ F] [Nontrivial E] {F : E â†’ F} {U : set E} (hU : Metric.Bounded U) (hD : Diff_Cont_on_cl â„‚ F U) {C : â„} (hC : âˆ€ (z : E), z âˆˆ Frontier U â†’ âˆ¥F zâˆ¥ â‰¤ C) {z : E} (hz : z âˆˆ Closure U) : âˆ¥F zâˆ¥ â‰¤ C
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.IsEquivalence F] : CategoryTheory.EssSurj F
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (v : E) : v - â†‘(â‡‘(Orthogonal_projection K) v) âˆˆ Ká—®
{Î± : Type u_1} {Î¹' : sort u_5} {F : Filter Î±} [h : F._countably_generated] {P : Î¹' â†’ Prop} {S : Î¹' â†’ set Î±} (hs : F.has_Basis P S) : âˆƒ (x : â„• â†’ Î¹'), (âˆ€ (i : â„•), P (x i)) âˆ§ F.has_Antitone_Basis (Î» (i : â„•), S (x i))
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [HasScalar ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : Convex_on ð•œ S F) (C : E) : Convex_on ð•œ ((Î» (z : E), C + z) â»Â¹' S) (F âˆ˜ Î» (z : E), z + C)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {S : set E} {x : E} : UniqueDiffWithinAt ð•œ S x â†’ UniqueMdiffWithinAt (model_with_corners_self ð•œ E) S x
{C : Type u} [CategoryTheory.Category C] {x Y : C} (J : CategoryTheory.GrothendieckTopology C) (F : Y âŸ¶ x) (S R : CategoryTheory.Sieve x) (h : J.Covers S F) : (âˆ€ {Z : C} (g : Z âŸ¶ x), â‡‘S g â†’ J.Covers R g) â†’ J.Covers R F
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] {F : Type W} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace ð•œ] {x : Type u_1} [TopologicalSpace x] [Finite_dimensional ð•œ E] {F : x â†’ (E â†’L[ð•œ] F)} {S : set x} : Continuous_on F S â†” âˆ€ (y : E), Continuous_on (Î» (x : x), â‡‘(F x) y) S
{Î± : Type u} [PseudoMetricSpace Î±] {x : Î±} {r : â„} : Metric.Bounded (metric.IsClosed_ball x r)
{A : â„•} (A1 : 1 < A) {x y : â„•} (hp : x * x - D A1 * y * y = 1) : âˆƒ (n : â„•), x = Pell.xn A1 n âˆ§ y = Pell.yn A1 n
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hr : WellFounded r) : WellFounded (Relation.CutExpand r)
{vâ‚ : Type u_2} {vâ‚‚ : Type u_3} [semi_NormedGroup vâ‚] [semi_NormedGroup vâ‚‚] : âˆ¥0âˆ¥ = 0
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {F : Î± â†’ Î²} (hF : _Group_hom F) : Function.Injective F â†” âˆ€ (A : Î±), F A = 1 â†’ A = 1
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (A : Matrix m m R) (B : Matrix m n R) (D : Matrix n n R) : (Matrix.from_blocks A B 0 D).det = A.det * D.det
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), Group (Gs i)] (h K : Î  (i : Î·), Subgroup (Gs i)) : â…Subgroup.Pi set.Univ h,Subgroup.Pi set.Univ Kâ† â‰¤ Subgroup.Pi set.Univ (Î» (i : Î·), â…h i,K iâ†)
{Î± : Type u_1} {r : Setoid Î±} (A : Î±) : âˆƒ! (B : set Î±) (h : B âˆˆ r.Classes), A âˆˆ B
{R : Type u} [CommRing R] [IsDomain R] (A : R) (n : â„•) : Polynomial.root_multiplicity A ((Polynomial.x - â‡‘Polynomial.C A) ^ n) = n
{ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedGroup G] [NormedSpace ð•œ G] {F : ?? â†’ G} (hF : Differentiable ð•œ F) (hF' : âˆ€ (x : ð•œ), deriv F x = 0) (x y : ð•œ) : F x = F y
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} : metric.Hausdorff_dist S âˆ… = 0
{Î± : Type u_1} {Î² : Type u_2} [CompleteLattice Î±] {F : Filter Î²} {u : Î² â†’ Î±} : F.limsup u = â¨… (S : set Î²) (h : S âˆˆ F), â¨† (A : Î²) (h : A âˆˆ S), u A
{cb : CharBuffer} {n n' val : â„•} (h : Parser.Nat cb n = ParseResult.done n' val) : val = Nat.of_digits 10 (List.Map (Î» (C : Char), C.ToNat - '0'.ToNat) (List.take (n' - n) (List.Drop n (Buffer.to_List cb))).reverse)
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {x : ð•œ} {S : set ð•œ} {F' : ð•œ â†’L[ð•œ] F} : HasFderivWithinAt F F' S x â†” HasDerivWithinAt F (â‡‘F' 1) S x
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} {Î¹ : Type v} (hs : IsCompact S) (Z : Î¹ â†’ set Î±) (hZc : âˆ€ (i : Î¹), IsClosed (Z i)) (hsZ : âˆ€ (t : Finset Î¹), (S âˆ© â‹‚ (i : Î¹) (h : i âˆˆ t), Z i).Nonempty) : (S âˆ© â‹‚ (i : Î¹), Z i).Nonempty
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) (v : E) : v âˆˆ Ká—® â†” âˆ€ (u : E), u âˆˆ K â†’ HasInner.inner v u = 0
{R : Type u_1} [CommRing R] [Ideal._jacobson R] (P : Ideal (Polynomial R)) [hP : P.IsMaximal] : ((Ideal.Quotient.Mk P).Comp Polynomial.C).IsIntegral
{A B : â„} {g' g : â„ â†’ â„} (hab : A â‰¤ B) (hcont : Continuous_on g (set.icc A B)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivWithinAt g (g' x) (set.ioi x) x) (g'Pos : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ 0 â‰¤ g' x) : MeasureTheory.IntegrableOn g' (set.ioc A B) MeasureTheory.MeasureSpace.Volume
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} {v3 : Type u_6} {P3 : Type u_7} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] [AddCommGroup v3] [module k v3] [AddTorsor v3 P3] (F : P2 â†’áµƒ[k] P3) (g : P1 â†’áµƒ[k] P2) : â‡‘(F.Comp g) = â‡‘F âˆ˜ â‡‘g
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] {S t : set E} (hsâ‚ : Convex â„ S) (hsâ‚‚ : IsClosed S) (htâ‚ : Convex â„ t) (htâ‚‚ : IsCompact t) (disj : Disjoint S t) : âˆƒ (F : E â†’L[â„] â„) (u v : â„), (âˆ€ (A : E), A âˆˆ S â†’ â‡‘F A < u) âˆ§ u < v âˆ§ âˆ€ (B : E), B âˆˆ t â†’ v < â‡‘F B
{Î± : Type u_3} {Î² : Type u_4} [Preorder Î²] {F : Î² â†’ Finset Î±} (h : Monotone F) (h' : âˆ€ (x : Î±), âˆƒ (n : Î²), x âˆˆ F n) : Filter.Tendsto F Filter.at_top Filter.at_top
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : 1 / A â‰¤ 1 / B â†” B â‰¤ A
{Î± : Type u_1} (L : List (List Î±)) (i : â„•) : List.Drop (List.take i (List.Map List.length L)).Sum L.Join = (List.Drop i L).Join
{R : Type u} [non_assoc_Semiring R] {S : set R} {P : R â†’ R â†’ Prop} {x y : R} (hx : x âˆˆ Subsemiring.Closure S) (hy : y âˆˆ Subsemiring.Closure S) (Hs : âˆ€ (x : R), x âˆˆ S â†’ âˆ€ (y : R), y âˆˆ S â†’ P x y) (h0_Left : âˆ€ (x : R), P 0 x) (h0_Right : âˆ€ (x : R), P x 0) (h1_Left : âˆ€ (x : R), P 1 x) (h1_Right : âˆ€ (x : R), P x 1) (HAdd_Left : âˆ€ (xâ‚ xâ‚‚ y : R), P xâ‚ y â†’ P xâ‚‚ y â†’ P (xâ‚ + xâ‚‚) y) (HAdd_Right : âˆ€ (x yâ‚ yâ‚‚ : R), P x yâ‚ â†’ P x yâ‚‚ â†’ P x (yâ‚ + yâ‚‚)) (HMul_Left : âˆ€ (xâ‚ xâ‚‚ y : R), P xâ‚ y â†’ P xâ‚‚ y â†’ P (xâ‚ * xâ‚‚) y) (HMul_Right : âˆ€ (x yâ‚ yâ‚‚ : R), P x yâ‚ â†’ P x yâ‚‚ â†’ P x (yâ‚ * yâ‚‚)) : P x y
{Î± : Type u} (S : set Î±) : IsClosed {u : Ultrafilter Î± | S âˆˆ u}
{Î± : Type u} [TopologicalSpace Î±] [SigmaCompactSpace Î±] {Î¹ : Type u_1} {F : Î¹ â†’ set Î±} (hF : locally_Finite F) (hne : âˆ€ (i : Î¹), (F i).Nonempty) : set.Univ.countable
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F = 2) (A : F) : IsSquare A
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {P1 : P} {P : Î¹ â†’ P} (h : P1 âˆˆ affine_Span k (set.Range P)) : âˆƒ (S : Finset Î¹) (W : Î¹ â†’ k) (hw : S.Sum (Î» (i : Î¹), W i) = 1), P1 = â‡‘(S.affine_combination P) W
{n : Type u_3} [Fintype n] {A : Type u_1} [DecidableEq n] [CommRing A] [IsDomain A] {m : Matrix n n A} : m.nondegenerate â†’ m.det â‰  0
 : â‡‘MeasureTheory.MeasureSpace.Volume {x : â„ | Liouville x} = 0
(k : Type uâ‚) {G : Type uâ‚‚} [Semiring k] [has_Mul G] {A : Type uâ‚ƒ} [non_unital_non_assoc_Semiring A] [Distrib_MulAction k A] {Ï†â‚ Ï†â‚‚ : Monoid_Algebra k G â†’â‚™â‚[k] A} (h : âˆ€ (x : G), â‡‘Ï†â‚ (Finsupp.single x 1) = â‡‘Ï†â‚‚ (Finsupp.single x 1)) : Ï†â‚ = Ï†â‚‚
{m : Type u_1} [MulOneClass m] {S : set m} {P : m â†’ Prop} {x : m} (h : x âˆˆ Submonoid.Closure S) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (h1 : P 1) (HMul : âˆ€ (x y : m), P x â†’ P y â†’ P (x * y)) : P x
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) â‰  0) : âˆƒ (L L' : List (Matrix.TransvectionStruct (Fin r âŠ• Unit) ð•œ)), (((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod)._two_block_Diagonal
{m : Type u_1} [Monoid m] {S t : set m} (ht : _Submonoid t) (h : S âŠ† t) : Monoid.Closure S âŠ† t
(A : â„¤) : â†‘(A.Nat_Abs) â‰¤ A ^ 2
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {S : set (E Ã— F)} : ContDiff_on ð•œ n Prod.fst S
{Î± : Type u_1} [LinearOrder Î±] [SuccOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ set.Ico n m â†’ r i (Order.Succ i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.Ico m n â†’ r (Order.Succ i) i) : Relation.refl_Trans_gen r n m
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [normed_CommRing ð•œ] [AddCommMonoid E] [AddCommMonoid F] [module ð•œ E] [module ð•œ F] (B : E â†’â‚—[ð•œ] F â†’â‚—[ð•œ] ð•œ) : GaloisConnection (â‡‘order_dual.to_dual âˆ˜ B.polar) (B.Flip.polar âˆ˜ â‡‘order_dual.of_dual)
{Î± : Type u_2} [Bornology Î±] {S : set Î±} : Bornology._bounded Sá¶œ â†’ Bornology._cobounded S
{n : Type u_3} {Î± : Type v} [Fintype n] [NonUnitalSemiring Î±] [Star_Ring Î±] (m N : Matrix n n Î±) : HasStar.Star (m.Mul N) = (HasStar.Star N).Mul (HasStar.Star m)
(C : Type u) [CategoryTheory.Category C] [âˆ€ {J : Type v} {x Y : C} {F : J â†’ (x âŸ¶ Y)}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallel_family F)] : CategoryTheory.Limits.HasWideEqualizers C
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] [IsDomain Î²] (e : Î± â‰ƒ+* Î²) : IsDomain Î±
{m : â„¤} (hmâ‚€ : m â‰  0) (hmâ‚ : m â‰  1) : strict_Convex_on â„ (set.ioi 0) (Î» (x : â„), x ^ m)
{l : Filter â„} {F g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in Filter.at_top, Differentiable_at â„ F x) (hg' : âˆ€á¶  (x : â„) in Filter.at_top, deriv g x â‰  0) (hftop : Filter.Tendsto F Filter.at_top (nhds 0)) (hgtop : Filter.Tendsto g Filter.at_top (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv F x / deriv g x) Filter.at_top l) : Filter.Tendsto (Î» (x : â„), F x / g x) Filter.at_top l
(m : Type u_1) (Î± : Type u_2) [Monoid m] [MulAction m Î±] {S t : set Î±} : fixing_Submonoid m (S âˆª t) = fixing_Submonoid m S âŠ“ fixing_Submonoid m t
{R : Type u_1} {m : Type u_2} [Linear_OrderedSemiring R] [ordered_AddCommMonoid m] [MulAction_with_Zero R m] (hR : âˆ€ {C : R}, C â‰  0 â†’ IsUnit C) (hlt : âˆ€ â¦ƒA B : mâ¦„ â¦ƒC : Râ¦„, A < B â†’ 0 < C â†’ C â€¢ A â‰¤ C â€¢ B) : OrderedSmul R m
{Î± : Type u} [HasSsubset Î±] [IsIrrefl Î± HasSsubset.Ssubset] {A : Î±} : Â¬A âŠ‚ A
{x : Type u} [MetricSpace x] [CompactSpace x] [Nonempty x] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] {Î³ : Type W} [MetricSpace Î³] {Î¦ : x â†’ Î³} {Î¨ : Y â†’ Î³} (ha : Isometry Î¦) (hb : Isometry Î¨) : GromovHausdorff.GH_dist x Y â‰¤ metric.Hausdorff_dist (set.Range Î¦) (set.Range Î¨)
{Î± : Type u} [PseudoMetricSpace Î±] {x : Î±} {u : set Î±} (hu : u âˆˆ nhds x) : âˆ€á¶  (r : â„) in nhds 0, metric.IsClosed_ball x r âŠ† u
{m : Type u_3} [Monoid m] [Preorder m] (L : List m) (h : 1 < L.Prod) : 0 < L.length
{G : Type u_7} [Group G] (L : List G) (i : â„•) (P : i < L.length) : (List.Drop (i + 1) L).Prod = (L.nth_LE i P)â»Â¹ * (List.Drop i L).Prod
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [MeasurableSpace Î²] [TopologicalSpace Î²] [TopologicalSpace.metrizable_Space Î²] [BorelSpace Î²] [TopologicalSpace.SecondCountableTopology Î²] : MeasureTheory.strongly_Measurable F â†” Measurable F
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (h : 0 < r * (B - A)) : â‡‘(affine_Map.line_Map (F A) (F B)) r â‰¤ F (â‡‘(affine_Map.line_Map A B) r) â†” slope F A B â‰¤ slope F A (â‡‘(affine_Map.line_Map A B) r)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B : Î±} (ha : A â‰¤ 1) (hb : B < 1) : A * B < 1
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {S : set E} {x : E} : Differentiable_within_at ð•œ F S x â†’ MdifferentiableWithinAt (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F S x
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (Î¸ : Real.Angle) : o.oangle x y = Î¸ â†” (x â‰  0 âˆ§ y â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(o.rotation Î¸) x) âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} (g : F â†’L[ð•œ] G) (h : HasFpowerSeriesOnBall F P x r) : HasFpowerSeriesOnBall (â‡‘g âˆ˜ F) (g.Comp_FormalMultilinearSeries P) x r
{Î± : Type u} [TopologicalSpace Î±] {F : Filter Î±} {A : Î±} {S : set Î±} (h : A âˆˆ S) (o : IsOpen S) (sf : Filter.principal S â‰¤ F) : nhds A â‰¤ F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {A : E} (hF : HasStrictFderivAt F F' A) (hF' : F'.Range = âŠ¤) (hker : F'.Ker.IsClosed_complemented) : âˆ€á¶  (x : E) in nhds A, HasStrictFderivAt.implicit_Function_of_complemented F F' hF hF' hker (F x) (â‡‘(HasStrictFderivAt.implicit_to_LocalHomeomorph_of_complemented F F' hF hF' hker) x).Snd = x
{n : â„•} {E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : (Fin (n + 1) â†’ â„‚) â†’ E} {C : Fin (n + 1) â†’ â„‚} {R : Fin (n + 1) â†’ â„} (hF : TorusIntegrable F C R) : âˆ¯ (x : Fin (n + 1) â†’ â„‚) in t(C, R), F x = âˆ® (x : â„‚) in C(C 0, R 0), âˆ¯ (y : Fin n â†’ â„‚) in t(C âˆ˜ Fin.Succ, R âˆ˜ Fin.Succ), F (Fin.Cons x y)
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {C : â„} {F : â„‚ â†’ E} {z : â„‚} (hD : Diff_Cont_on_cl â„‚ F (set.Iio 0 Ã—â„‚ set.Iio 0)) (hB : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.Iio 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥F â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥F (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz_re : z.re â‰¤ 0) (hz_im : z.im â‰¤ 0) : âˆ¥F zâˆ¥ â‰¤ C
{Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} : lâ‚ <:+: lâ‚‚ â†’ lâ‚.reverse <:+: lâ‚‚.reverse
{Î± : Type u} [non_unital_Ring Î±] {A B C : Î±} (h : A âˆ£ B) : A âˆ£ B + C â†” A âˆ£ C
{x : Type u_1} [TopologicalSpace x] [NormalSpace x] {S t : set x} (hs : IsClosed S) (ht : IsClosed t) (hD : Disjoint S t) : âˆƒ (F : C(x, â„)), set.Eq_on â‡‘F 0 S âˆ§ set.Eq_on â‡‘F 1 t âˆ§ âˆ€ (x : x), â‡‘F x âˆˆ set.icc 0 1
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : (SpanPoints k S).Nonempty â†” S.Nonempty
{Î± : Type u} {l : List Î±} : l.sublists'.Nodup â†’ l.Nodup
{R : Type u_1} [Ring R] (S : Subring R) (m : Multiset R) : (âˆ€ (A : R), A âˆˆ m â†’ A âˆˆ S) â†’ m.Sum âˆˆ S
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {x Y : C} (F : x âŸ¶ Y) (S : Function.Surjective â‡‘F) : CategoryTheory.Epi F
{ð•œ : Type u_1} {E : Type u_3} [NormedField ð•œ] [AddCommGroup E] [module ð•œ E] {A : set E} [TopologicalSpace E] [has_Continuous_Smul ð•œ E] (hA : Balanced ð•œ A) : Balanced ð•œ (0 âˆª Interior A)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [NormedSpace â„ E] : IsBoundedBilinearMap â„ (Î» (P : E Ã— E), HasInner.inner P.fst P.Snd)
{Î± : Type u} [Lattice Î±] [AddCommGroup Î±] (A : Î±) (h : 0 â‰¤ A) : Aâº = A
{Î± : Type u} [PseudoEmetricSpace Î±] {x y : Î±} : Emetric.Inf_edist x {y} = HasEdist.edist x y
(n : â„•) {R : Type u_1} {S : Type u_2} [Ring R] [Ring S] (F : R â†’+* S) : Polynomial.Map F (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S
{Î¹ : Type u_1} {R : Type u_8} [ordered_CommSemiring R] {F g : Î¹ â†’ R} {S : Finset Î¹} (h0 : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ F i) (h1 : âˆ€ (i : Î¹), i âˆˆ S â†’ F i â‰¤ g i) : S.Prod (Î» (i : Î¹), F i) â‰¤ S.Prod (Î» (i : Î¹), g i)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x âŸ¶ Y) [CategoryTheory.Limits.HasCokernel (F - g)] : CategoryTheory.Limits.HasCoequalizer F g
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) {u v : E} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (W : â†¥â†‘K), âˆ¥u - â†‘Wâˆ¥) â†” âˆ€ (W : E), W âˆˆ K â†’ HasInner.inner (u - v) W = 0
{Î± : Type u} {Î² : Type v} [MulOneClass Î±] [Group Î²] {F : Î± â†’ Î²} (hF : _Mul_hom F) : _Monoid_hom F
{Î± : Type u} [TopologicalSpace Î±] {Î¹ : Type u_1} {F : Î¹ â†’ set Î±} (hF : locally_Finite F) {S : set Î±} (hs : IsCompact S) : {i : Î¹ | (F i âˆ© S).Nonempty}.Finite
{S : set â„} (h : Metric.Bounded S) : Emetric.diam S = Ennreal.of_Real (HasSup.Sup S - HasInf.Inf S)
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B C : Î±} : A < B + C â†’ -B + A < C
(Î± : Type u) [t : TopologicalSpace Î±] [TopologicalSpace.IsSeparable_Space Î±] [Nonempty Î±] : DenseRange (TopologicalSpace.Dense_Seq Î±)
{Î± : Type u} [PseudoMetricSpace Î±] (S : set Î±) : LipschitzWith 1 (Î» (x : Î±), metric.Inf_nndist x S)
{C : Type uâ‚} [CategoryTheory.Category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {x : C} (R : CategoryTheory.Presieve x) [CategoryTheory.Limits.HasPullbacks C] (x : CategoryTheory.Equalizer.FirstObj P R) : ((CategoryTheory.Equalizer.FirstObj_Eq_family P R).hom x).compatible â†” CategoryTheory.Equalizer.Presieve.first_Map P R x = CategoryTheory.Equalizer.Presieve.second_Map P R x
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {P1 : P} (P2 : P) (hp1 : P1 âˆˆ S) : â†‘(âŸ¨P1, hp1âŸ© -áµ¥ â‡‘(EuclideanGeometry.Orthogonal_projection S) P2) âˆˆ S.direction
{R : Type u_1} [Ring R] {F g : â„• â†’ R} : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.Sum (Î» (i : â„•), F i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.Sum (Î» (x : â„• Ã— â„•), â†‘(â‡‘Nat.ArithmeticFunction.moebius x.fst) * g x.Snd) = F n
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_NormedField R] [NormedGroup F] [NormedSpace R F] [TopologicalSpace B] {Î¹ : Type u_6} (Z : TopologicalVectorBundleCore R B F Î¹) : IsOpen_Map Z.Proj
{R : Type u_1} {S : Type u_2} {m : Type u_3} {A : R} [HasScalar R m] [HasScalar R S] [HasScalar S m] [IsScalarTower R S m] (B : S) (ha : IsSmulRegular m A) : IsSmulRegular m (A â€¢ B) â†” IsSmulRegular m B
{Î² : Type u_2} [CommMonoid Î²] {n : â„•} (F : Fin (n + 1) â†’ Î²) : Finset.Univ.Prod (Î» (i : Fin (n + 1)), F i) = F 0 * Finset.Univ.Prod (Î» (i : Fin n), F i.Succ)
{G : Type u_1} [AddCommMonoid G] : AddMonoid._torsion â†¥(AddCommMonoid.Add_torsion G)
(ð•œ : Type u_1) [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (F : E â†’ F) [MeasurableSpace E] [Opens_MeasurableSpace E] [CompleteSpace F] : Measurable_set {x : E | Differentiable_at ð•œ F x}
{ð•œ : Type u_3} {E : Type u_4} [NormedField ð•œ] [semi_NormedGroup E] [NormedSpace ð•œ E] {r : â„} {x : E} (hx : âˆ¥xâˆ¥ < r) : Absorbent ð•œ (Metric.Ball x r)
{Î± : Type u} [TopologicalSpace Î±] : TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), (ConnectedComponent x).Subsingleton
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (i : Fin r âŠ• Unit) : (Matrix.Pivot.List_transvec_col m).Prod.Mul m (Sum.inr_ ()) i = m (Sum.inr_ ()) i
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S : set Î±} (h : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) â‰  1) : S.Nonempty
{Î¹ : Type u_1} {x : â„•} {S : Î¹ â†’ â„•} {t : Finset Î¹} : (âˆ€ (i : Î¹), i âˆˆ t â†’ (S i).IsCoprime x) â†’ (t.Prod (Î» (i : Î¹), S i)).IsCoprime x
 : Â¬set.Univ.countable
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_3} [Fintype Î±] [Fintype Î²] [AddCommMonoid m] (e : Î± â‰ƒ Î²) (F : Î± â†’ m) (g : Î² â†’ m) (h : âˆ€ (x : Î±), F x = g (â‡‘e x)) : Finset.Univ.Sum (Î» (x : Î±), F x) = Finset.Univ.Sum (Î» (x : Î²), g x)
{m : Type u_3} [Monoid m] (L : List m) (h : L.Prod â‰  1) : 0 < L.length
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) {r : â„} (hr : 0 < r) : InnerProductGeometry.angle x (r â€¢ y) = InnerProductGeometry.angle x y
{Î± : Type u_1} {ð’œ : Finset (Finset Î±)} {Aâ‚ Aâ‚‚ : Finset Î±} {râ‚ râ‚‚ : â„•} (hâ‚ : Aâ‚ âˆˆ ð’œ.Slice râ‚) (hâ‚‚ : Aâ‚‚ âˆˆ ð’œ.Slice râ‚‚) : râ‚ â‰  râ‚‚ â†’ Aâ‚ â‰  Aâ‚‚
{ð•œ : Type u_1} {E : Type u_2} [normed_Linear_ordered_Field ð•œ] [NormedGroup E] [NormedSpace ð•œ E] {A B : set E} (hAB : IsExposed ð•œ A B) : âˆƒ (l : E â†’L[ð•œ] ð•œ) (A : ð•œ), B = {x âˆˆ A | A â‰¤ â‡‘l x}
(K : Type u_1) [Field K] [Fintype K] [Fintype KË£] (i : â„•) : Finset.Univ.Sum (Î» (x : KË£), â†‘x ^ i) = Ite (Fintype.Card K - 1 âˆ£ i) (-1) 0
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] {P : Î± â†’ Prop} {S : Finset {x // P x}} {F : {x // P x} â†’ Î²} {g : Î± â†’ Î²} (h : âˆ€ (x : {x // P x}), x âˆˆ S â†’ g â†‘x = F x) : (Finset.Map (Function.Embedding.Subtype (Î» (x : Î±), P x)) S).Sum (Î» (x : Î±), g x) = S.Sum (Î» (x : {x // P x}), F x)
{G : Type u_1} [Group G] (K : Subgroup G) : Subgroup.Closure â†‘K = K
{Î± : Type u} [TopologicalSpace Î±] [t2_Space Î±] [CompactSpace Î±] : TotallyDisconnectedSpace Î± â†” TotallySeparatedSpace Î±
{F : â„ â†’ â„} {F' A : â„} (h : IsLocalMax F A) (hF : HasDerivAt F F' A) : F' = 0
{F : Type u_1} [NormedGroup F] [NormedSpace â„ F] (F : â„ â†’ F) [CompleteSpace F] : Measurable_set {x : â„ | Differentiable_within_at â„ F (set.ioi x) x}
{Î² : Type u_2} {F g : Î² â†’ Nnreal} (hgf : âˆ€ (B : Î²), g B â‰¤ F B) : Summable F â†’ Summable g
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [NormedGroup F] [NormedSpace â„ F] {S : set E} (S_conv : Convex â„ S) {F : E â†’ F} {F' : E â†’ (E â†’L[â„] F)} {F'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€ (x : E), x âˆˆ Interior S â†’ HasFderivAt F (F' x) x) {x : E} (xs : x âˆˆ S) (hx : HasFderivWithinAt F' F'' (Interior S) x) {v W : E} (h4v : x + 4 â€¢ v âˆˆ Interior S) (h4W : x + 4 â€¢ W âˆˆ Interior S) : â‡‘(â‡‘F'' W) v = â‡‘(â‡‘F'' v) W
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] (P : Polynomial ð•œ) (x : ð•œ) : HasDerivAt (Î» (x : ð•œ), Polynomial.Eval x P) (Polynomial.Eval x (â‡‘Polynomial.derivative P)) x
{Î± : Type u_1} [PartialOrder Î±] (C : Closure_operator Î±) (x : Î±) : x â‰¤ â‡‘C x
{R : Type u_2} {Î“â‚€ : Type u_3} {Î“'â‚€ : Type u_4} [Ring R] [Linear_ordered_CommMonoid_with_Zero Î“â‚€] [Linear_ordered_CommMonoid_with_Zero Î“'â‚€] {vâ‚ : Valuation R Î“â‚€} {vâ‚‚ : Valuation R Î“'â‚€} {S : Type u_1} [Ring S] (F : S â†’+* R) (h : vâ‚._Equiv vâ‚‚) : (Valuation.comap F vâ‚)._Equiv (Valuation.comap F vâ‚‚)
(n : â„•+) (S : set â„•+) (K : Type W) (L : Type z) [Field K] [Field L] [Algebra K L] [Ne_Zero â†‘â†‘n] [h : IsCyclotomicExtension S K L] (hS : n âˆˆ S) : Polynomial.Splits (Algebra_Map K L) (Polynomial.x ^ â†‘n - 1)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P : P) (h : S.Sum (Î» (i : Î¹), W i) = 0) : â‡‘(S.weighted_vsub (Î» (_x : Î¹), P)) W = 0
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [LinearOrder Î±] [order_IsClosed_topology Î±] [Nonempty Î±] [TopologicalSpace Î²] [has_One Î±] {F : Î² â†’ Î±} (hF : Continuous F) (h : HasCompactMulSupport F) : BddBelow (set.Range F)
{Î± : Type u} {Î² : Type v} {F : Î± â†’ Î²} (h : Function.Injective F) (S : set Î±) : set.inj_on F S
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (m : Matrix n n R) : m.transpose.det = m.det
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] (F : S.Localization_Map N) : F.of_Mul_Equiv_of_Dom _ = F
{k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [Semiring k] [MulOneClass G] [Semiring R] {F g : Monoid_Algebra k G â†’+* R} (hâ‚ : F.Comp Monoid_Algebra.single_One_Ring_hom = g.Comp Monoid_Algebra.single_One_Ring_hom) (h_of : â†‘F.Comp (Monoid_Algebra.of k G) = â†‘g.Comp (Monoid_Algebra.of k G)) : F = g
(Î± : Type u) [UniformSpace Î±] [(Uniformity Î±)._countably_generated] [TopologicalSpace.IsSeparable_Space Î±] : TopologicalSpace.SecondCountableTopology Î±
(R : Type u_1) [CommRing R] (m : Type u_2) [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [Nontrivial R] : â‡‘(LinearMap.trace R m) LinearMap.Id = â†‘(Finite_dimensional.finrank R m)
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : Aâ»Â¹ < Bâ»Â¹ â†” B < A
{Î± : Type u_1} {r S : Î± â†’ Î± â†’ Prop} (h : âˆ€ (x y : Î±), r x y â†’ S x y) : EqvGen.Setoid r â‰¤ EqvGen.Setoid S
{P : â„•} [Fact (Nat.Prime P)] {F : padic_Seq P} (hF : Â¬F â‰ˆ 0) (v1 v2 : â„•) : padic_norm P (â‡‘F (padic_Seq.stationary_point hF)) = padic_norm P (â‡‘F (LinearOrder.max v1 (LinearOrder.max v2 (padic_Seq.stationary_point hF))))
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] {A B : Î±} (ha : A < 1) (hb : B â‰¤ 1) : A * B < 1
{Î± : Type u_1} [has_LE Î±] {S : set Î±} : _upper_set S â†’ _lower_set (â‡‘order_dual.of_dual â»Â¹' S)
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] [DecidableEq Î±] (S : Finset Î±) (F : Î± â†’ Î²) {A : Î±} (h : A âˆˆ S) : F A + (S.erase A).Sum (Î» (x : Î±), F x) = S.Sum (Î» (x : Î±), F x)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {A : Type uâ‚ƒ} [CategoryTheory.Category A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (hGâ‚ : CategoryTheory.CompatiblePreserving K G) (hGâ‚‚ : CategoryTheory.CoverPreserving J K G) (â„± : CategoryTheory.sheaf K A) : CategoryTheory.Presheaf.IsSheaf J (G.Op â‹™ â„±.val)
{Î± : Type u_1} [TopologicalSpace Î±] {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] {F g : Î± â†’ Î³} (hF : UpperSemicontinuous F) (hg : UpperSemicontinuous g) (hcont : âˆ€ (x : Î±), Continuous_at (Î» (P : Î³ Ã— Î³), P.fst + P.Snd) (F x, g x)) : UpperSemicontinuous (Î» (z : Î±), F z + g z)
{Î± : Type u_1} {n : Type u_2} {m : Type u_3} [has_Mul Î±] [AddCommMonoid Î±] (A : Matrix m n Î±) [Fintype m] : A.transpose.has_Orthogonal_rows â†” A.has_Orthogonal_cols
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} (t : CategoryTheory.Limits.Fork F g) [CategoryTheory.Epi t.Î¹] : F = g
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [NormedGroup F] [NormedSpace â„ F] {F : E â†’ F} {P : E â†’ FormalMultilinearSeries â„ E F} {S : set E} {x : E} (hF : HasFtaylorSeriesUpToOn 1 F P (HasInsert.Insert x S)) (hs : Convex â„ S) (K : Nnreal) (hK : âˆ¥P x 1âˆ¥â‚Š < K) : âˆƒ (t : set E) (h : t âˆˆ nhds_within x S), LipschitzOnWith K F t
(A B : â„•) {C : â„•} (hc : 0 < C) : C * A / (C * B) = A / B
{S : set â„•} (hs : S.Infinite) {k : â„•} (hk : 0 < k) : âˆƒ (m : â„•) (h : m âˆˆ S) (n : â„•) (h : n âˆˆ S), m < n âˆ§ m â‰¡ n [Mod k]
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {x x' Y Y' Z Z' : C} [CategoryTheory.ExactPairing Y Y'] (F : x âŸ¶ Y âŠ— Z) (g : x' âŸ¶ Z') : â‡‘((CategoryTheory.tensor_Left_hom_Equiv (x âŠ— x') Y Y' (Z âŠ— Z')).Symm) ((F âŠ— g) â‰« (Î±_ Y Z Z').hom) = (Î±_ Y' x x').Inv â‰« (â‡‘((CategoryTheory.tensor_Left_hom_Equiv x Y Y' Z).Symm) F âŠ— g)
{C : Type uâ‚} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} {P : Cáµ’áµ– â¥¤ Type vâ‚} : CategoryTheory.Presieve.IsSheafFor P â‡‘S â†” CategoryTheory.Presieve.YonedaSheafCondition P S
(P : â„•) [hp : Fact (Nat.Prime P)] {q r : â„š} : padic_norm P (q - r) â‰¤ LinearOrder.max (padic_norm P q) (padic_norm P r)
(Î± : Type u) (Î² : Type v) [AddGroup Î±] [AddAction Î± Î²] [Fintype Î±] [Î  (A : Î±), Fintype â†¥(AddAction.FixedBy Î± Î² A)] [Fintype (Quotient (AddAction.Orbit_Rel Î± Î²))] : Finset.Univ.Sum (Î» (A : Î±), Fintype.Card â†¥(AddAction.FixedBy Î± Î² A)) = Fintype.Card (Quotient (AddAction.Orbit_Rel Î± Î²)) * Fintype.Card Î±
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : S1 < S2 â†” â†‘S1 âŠ‚ â†‘S2
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] : âˆ¥Orthogonal_projection Kâˆ¥ â‰¤ 1
{Î¹ : Type u_1} {R : Type u_8} [ordered_CommSemiring R] {S : Finset Î¹} {i : Î¹} {F g h : Î¹ â†’ R} (hi : i âˆˆ S) (h2i : g i + h i â‰¤ F i) (hgf : âˆ€ (j : Î¹), j âˆˆ S â†’ j â‰  i â†’ g j â‰¤ F j) (hhf : âˆ€ (j : Î¹), j âˆˆ S â†’ j â‰  i â†’ h j â‰¤ F j) (hg : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ g i) (hH : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ h i) : S.Prod (Î» (i : Î¹), g i) + S.Prod (Î» (i : Î¹), h i) â‰¤ S.Prod (Î» (i : Î¹), F i)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (r : â„) (v : v) (Pâ‚ Pâ‚‚ : P) : HasDist.dist (r â€¢ v +áµ¥ Pâ‚) Pâ‚‚ * HasDist.dist (r â€¢ v +áµ¥ Pâ‚) Pâ‚‚ = HasInner.inner v v * r * r + 2 * HasInner.inner v (Pâ‚ -áµ¥ Pâ‚‚) * r + HasInner.inner (Pâ‚ -áµ¥ Pâ‚‚) (Pâ‚ -áµ¥ Pâ‚‚)
{m : Type u_1} [Nonempty m] [Add_Semigroup m] [TopologicalSpace m] [CompactSpace m] [t2_Space m] (Continuous_Mul_Left : âˆ€ (r : m), Continuous (Î» (_x : m), _x + r)) : âˆƒ (m : m), m + m = m
 : IsTrivialTopologicalFiberBundle â„ Complex.re
{k : â„•} (n : â„•) (hpos : 0 < k) : âˆƒ (P : â„•), Nat.Prime P âˆ§ n â‰¤ P âˆ§ P â‰¡ 1 [Mod k]
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) {P1 : P} (P2 : P) (r : â„) (hp : P1 âˆˆ affine_Span â„ (set.Range S.points)) : â‡‘(S.Orthogonal_projection_Span) (r â€¢ (P2 -áµ¥ â†‘(â‡‘(S.Orthogonal_projection_Span) P2)) +áµ¥ P1) = âŸ¨P1, hpâŸ©
 : IsTrivialTopologicalFiberBundle â„ Complex.im
{m : Type u_1} [has_Mul m] {C D : Con m} (h : C.to_Setoid = D.to_Setoid) : C = D
{R : Type u} {L : Type v} [CommRing R] [lie_Ring L] [lie_Algebra R L] (m : Type W) [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] [Nontrivial m] [lie_Algebra.IsNilpotent R L] [lie_module.IsNilpotent R L m] : lie_module._weight âŠ¤ m 0
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTopologicalFiberBundle F Prod.fst
{x : Type u} {Y : Type v} [Preorder x] [Preorder Y] {L : x â¥¤ Y} {R : Y â¥¤ x} (Adj : L âŠ£ R) : GaloisConnection L.obj R.obj
{Î± : Type u_1} [TopologicalSpace Î±] [BaireSpace Î±] {S : set (set Î±)} (hc : âˆ€ (S : set Î±), S âˆˆ S â†’ IsClosed S) (hS : S.countable) (hU : â‹ƒâ‚€S = set.Univ) : Dense (â‹ƒ (S : set Î±) (h : S âˆˆ S), Interior S)
{S : Type u} [Semigroup S] {A x y x' y' : S} (h : SemiconjBy A x y) (h' : SemiconjBy A x' y') : SemiconjBy A (x * x') (y * y')
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : 2 â€¢ o.oangle x (-y) = 2 â€¢ o.oangle x y
{Î¹ : Type u_1} {ð•œ : Type u_2} [_R_or_C ð•œ] {E : Type u_3} [InnerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), InnerProductSpace ð•œ (G i)] {v : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ v) [âˆ€ (i : Î¹), CompleteSpace (G i)] (hV' : (â¨† (i : Î¹), (v i).to_LinearMap.Range).topological_Closure = âŠ¤) (W : â†¥(Lp G 2)) : has_Sum (Î» (i : Î¹), â‡‘(v i) (â‡‘W i)) (â‡‘((hV.Linear_Isometry_Equiv hV').Symm) W)
{R : Type u_1} [Semiring R] {m : laurent_Polynomial R â†’ Prop} (P : laurent_Polynomial R) (h_Add : âˆ€ (P q : laurent_Polynomial R), m P â†’ m q â†’ m (P + q)) (h_C_Mul_t : âˆ€ (n : â„¤) (A : R), m (â‡‘laurent_Polynomial.C A * laurent_Polynomial.t n)) : m P
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’ ð•œ) {S : Finset Î¹} {i : Î¹} (hi : i âˆˆ S) : HasInner.inner (S.Sum (Î» (i : Î¹), l i â€¢ v i)) (v i) = â‡‘(Star_Ring_end ð•œ) (l i)
{R : Type u} [Ring R] {Î¹ : sort u_1} [hÎ¹ : Nonempty Î¹] {S : Î¹ â†’ Subring R} (hS : Directed has_LE.LE S) {x : R} : (x âˆˆ â¨† (i : Î¹), S i) â†” âˆƒ (i : Î¹), x âˆˆ S i
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (hp1P2 : P1 â‰  P2) (hp3P2 : P3 â‰  P2) : HasDist.dist P1 P3 = HasDist.dist P1 P2 + HasDist.dist P3 P2 â†” EuclideanGeometry.angle P1 P2 P3 = Real.Pi
(R : Type u_1) (m : Type u_2) [Semiring R] [Nontrivial m] [AddCommMonoid m] [module R m] : Nontrivial R
{Î± : Type u} {Î² : Type v} [Preorder Î±] [LinearOrder Î²] {F g : Î± â†’ Î²} (hF : Antitone F) (hg : Antitone g) : Antitone (Î» (x : Î±), LinearOrder.max (F x) (g x))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) (h : P 1 = â‡‘((Continuous_multilinear_Curry_Fin1 ð•œ E F).Symm) â†‘i) : P.Left_Inv i = P.Right_Inv i
{Î± : Type u} {Î² : Type v} {F : Î± â†’ Î²} {g : Î² â†’ Î±} (hF : Function.Injective F) (hg : Function.Injective g) : âˆƒ (h : Î± â†’ Î²), Function.Bijective h
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A B : Î±} (ha : A â‰¤ 1) (hb : B â‰¤ 1) : A * B â‰¤ 1
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] (S t : Submodule K v) [Finite_dimensional K â†¥S] [Finite_dimensional K â†¥t] : Finite_dimensional.finrank K â†¥(S âŠ” t) + Finite_dimensional.finrank K â†¥(S âŠ“ t) = Finite_dimensional.finrank K â†¥S + Finite_dimensional.finrank K â†¥t
{R : Type u_1} [cancel_CommMonoid_with_Zero R] {Î± : Type u_2} [DecidableEq Î±] {x y A : R} {S : Finset Î±} {P : Î± â†’ R} (hp : âˆ€ (i : Î±), i âˆˆ S â†’ Prime (P i)) (hx : x * y = A * S.Prod (Î» (i : Î±), P i)) : âˆƒ (t u : Finset Î±) (B C : R), t âˆª u = S âˆ§ Disjoint t u âˆ§ A = B * C âˆ§ x = B * t.Prod (Î» (i : Î±), P i) âˆ§ y = C * u.Prod (Î» (i : Î±), P i)
{G : Type W} [TopologicalSpace G] [AddGroup G] [topological_AddGroup G] {K v : set G} (hK : IsCompact K) (hV : (Interior v).Nonempty) : âˆƒ (t : Finset G), K âŠ† â‹ƒ (g : G) (h : g âˆˆ t), (Î» (h : G), g + h) â»Â¹' v
{P n k B : â„•} (hp : Nat.Prime P) (hkn : k â‰¤ n) (hnb : Nat.log P n < B) : multiplicity P (n.choose k) = â†‘((Finset.Filter (Î» (i : â„•), P ^ i â‰¤ k % P ^ i + (n - k) % P ^ i) (Finset.Ico 1 B)).Card)
{m : Type u_1} [has_Mul m] {S : set m} {S : Subsemigroup m} : Subsemigroup.Closure S â‰¤ S â†” S âŠ† â†‘S
{Î² : Type u} {Î± : Type v} {S : Finset Î±} {F : Î± â†’ Î²} [CommMonoid Î²] (R : Setoid Î±) [Decidable_Rel Setoid.r] (h : âˆ€ (x : Î±), x âˆˆ S â†’ (Finset.Filter (Î» (y : Î±), y â‰ˆ x) S).Prod (Î» (A : Î±), F A) = 1) : S.Prod (Î» (x : Î±), F x) = 1
{Î± : Type u_1} {r : Setoid Î±} {x : Î±} {B : set Î±} (hc : B âˆˆ r.Classes) (hb : x âˆˆ B) {B' : set Î±} (hc' : B' âˆˆ r.Classes) (hb' : x âˆˆ B') : B = B'
{Î± : sort u_1} {A A' : Î±} {Î² : sort u_2} (y : Î²) (h : A = A') : Eq.rec y h = y
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} : free_Group.red.step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [HasScalar ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : ConcaveOn ð•œ S F) (C : E) : ConcaveOn ð•œ ((Î» (z : E), C + z) â»Â¹' S) (F âˆ˜ Î» (z : E), C + z)
{ð•œ : Type u_1} {E : Type u_3} {F : Type u_4} [ordered_Ring ð•œ] [TopologicalSpace E] [TopologicalSpace F] [AddCommGroup E] [AddCommGroup F] [module ð•œ E] [module ð•œ F] {S : set F} (hs : strict_Convex ð•œ S) {F : E â†’áµƒ[ð•œ] F} (hF : Continuous â‡‘F) (hfinj : Function.Injective â‡‘F) : strict_Convex ð•œ (â‡‘F â»Â¹' S)
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} (ha : A â‰  0) : Char.quadratic_Char F A = 1 âˆ¨ Char.quadratic_Char F A = -1
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] : Orthogonal_projection âŠ¥ = 0
{R : Type u_1} {A : R} [Semigroup R] (B : R) (ha : IsLeftRegular A) : IsLeftRegular (A * B) â†” IsLeftRegular B
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B C : Î±} : A * B â‰¤ C â†’ B â‰¤ Aâ»Â¹ * C
(x y : â„•) : â†‘(x.Gcd y) = â†‘x * x.Gcd_A y + â†‘y * x.Gcd_B y
(ð•œ : Type u_1) {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_3} [LinearOrder Î¹] [OrderBot Î¹] [locally_Finite_order Î¹] [IsWellOrder Î¹ has_LT.LT] (F : Î¹ â†’ E) {A B : Î¹} (hâ‚€ : A â‰  B) : HasInner.inner (gram_schmidt ð•œ F A) (gram_schmidt ð•œ F B) = 0
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Sâ‚ Sâ‚‚ : set P} (h : Sâ‚ âŠ† Sâ‚‚) : Vector_Span k Sâ‚ â‰¤ Vector_Span k Sâ‚‚
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) (z : N) : â‡‘(F.Lift hg) z * â‡‘g â†‘((F.sec z).Snd) = â‡‘g (F.sec z).fst
{A B : Ereal} (h : -A â‰¤ B) : -B â‰¤ A
{x : Type u_1} [TopologicalSpace x] [SequentialSpace x] {S : set x} : _Seq_IsClosed S â†” IsClosed S
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {xâ‚€ : E} (hF : HasFderivAt F F' xâ‚€) {S : set E} (hs : S âˆˆ nhds xâ‚€) {C : Nnreal} (hlip : LipschitzOnWith C F S) : âˆ¥F'âˆ¥ â‰¤ â†‘C
{R : Type u_1} [CommRing R] {A B : R} : A ^ 4 + 4 * B ^ 4 = ((A - B) ^ 2 + B ^ 2) * ((A + B) ^ 2 + B ^ 2)
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) [Invertible A] : (â…Ÿ A).Mul A = 1
{K : Type u} [Field K] (S : Subfield K) {Î¹ : Type u_1} {t : Finset Î¹} {F : Î¹ â†’ K} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Prod (Î» (i : Î¹), F i) âˆˆ S
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (F : C(Î±, Î²)) {x y : Î±} (h : x = y) : â‡‘F x = â‡‘F y
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Pos_Mul_StrictMono Î±] (ha : 1 â‰¤ A) (hb : 1 < B) (A0 : 0 < A) : 1 < A * B
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [CompleteSpace E] [CompleteSpace F] (A : E â†’L[ð•œ] F) (x : E) (y : F) : HasInner.inner (â‡‘(â‡‘Continuous_LinearMap.Adjoint A) y) x = HasInner.inner y (â‡‘A x)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {Î¹ : Type W} {B : Finset Î¹} (h : Basis â†¥B K v) : Finite_dimensional.finrank K v = B.Card
{n n' : â„•} (m : â„•) (i : Fin n') (h : n' = n) : â‡‘(Fin.Nat_Add m) (â‡‘(Fin.cast h) i) = â‡‘(Fin.cast _) (â‡‘(Fin.Nat_Add m) i)
{m : Type u_3} {N : Type u_4} [MulOneClass m] [MulOneClass N] (F : m â†’* N) {x y : m} (h : x = y) : â‡‘F x = â‡‘F y
{Î± : Type u_1} [MeasurableSpace Î±] {F : â„• â†’ Î± â†’ Nnreal} {g : Î± â†’ Nnreal} (hF : âˆ€ (i : â„•), Measurable (F i)) (lim : Filter.Tendsto F Filter.at_top (nhds g)) : Measurable g
{x : Pgame} : x.lf 0 â†” âˆƒ (j : x.Right_moves), x.move_Right j â‰¤ 0
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : F' =O[l] g â†’ (Î» (x : Î±), -F' x) =O[l] g
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} : Monotone F â†’ Antitone (F âˆ˜ â‡‘order_dual.of_dual)
(ð•‚ : Type u_1) (ð”¸ : Type u_2) [_R_or_C ð•‚] [NormedRing ð”¸] [normed_Algebra ð•‚ ð”¸] : (Exp_series ð•‚ ð”¸).radius = âŠ¤
{K : Type u} {L : Type v} [Field K] [Field L] {F g : K â†’+* L} {S : set K} (h : set.Eq_on â‡‘F â‡‘g S) : set.Eq_on â‡‘F â‡‘g â†‘(Subfield.Closure S)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Sâ‚ Sâ‚‚ : AffineSubspace k P} {P : P} (hâ‚ : P âˆˆ Sâ‚) (hâ‚‚ : P âˆˆ Sâ‚‚) : Sâ‚ = Sâ‚‚ â†” Sâ‚.direction = Sâ‚‚.direction
{R : Type u_2} [cancel_CommMonoid_with_Zero R] [Unique_factorization_Monoid R] {A B C : R} (ha : A â‰  0) (no_Factors : âˆ€ {D : R}, D âˆ£ A â†’ D âˆ£ B â†’ Â¬Prime D) : A âˆ£ B * C â†’ A âˆ£ C
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S : set P} [Nontrivial P] : affine_Span k S = âŠ¤ â†” Vector_Span k S = âŠ¤
{C : Type u} [CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} (hJ : CategoryTheory.sheaf.Subcanonical J) (P : Cáµ’áµ– â¥¤ Type v) [P.representable] : CategoryTheory.Presieve._sheaf J P
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : Dense S â†” âˆ€ (U : set Î±), IsOpen U â†’ U.Nonempty â†’ (U âˆ© S).Nonempty
{Î± : Type u_2} {Î² : Type u_3} [DecidableEq Î²] [HasVadd Î± Î²] {u : Finset Î²} {S : set Î±} {t : set Î²} : â†‘u âŠ† S +áµ¥ t â†’ (âˆƒ (S' : Finset Î±) (t' : Finset Î²), â†‘S' âŠ† S âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† S' +áµ¥ t')
(ð•œ : Type u_1) {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {v : E} (hv : âˆ¥vâˆ¥ = 1) (W : E) : â†‘(â‡‘(Orthogonal_projection (Submodule.Span ð•œ {v})) W) = HasInner.inner v W â€¢ v
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [ZeroLt.PosMulMono Î±] (ha : 1 < A) (hb : 1 â‰¤ B) (A0 : 0 < A) : 1 < A * B
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hst : S âŠ† t) (ht : (t âˆ© Function.Support F).Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ t  S), F i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ t), F i))
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {v : set E} [Finite_dimensional ð•œ E] (hv : Orthonormal ð•œ Coe) : âˆƒ (u : set E) (h : u âŠ‡ v) (B : Basis â†¥u ð•œ E), Orthonormal ð•œ â‡‘B âˆ§ â‡‘B = Coe
(S : set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ 0) : HasInf.Inf S â‰¤ 0
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Kâ‚ Kâ‚‚ : Submodule ð•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) [CompleteSpace â†¥Kâ‚] : Kâ‚ âŠ” Kâ‚á—® âŠ“ Kâ‚‚ = Kâ‚‚
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} {ps : set P} (h : ps âŠ† â†‘S) [Nonempty â†¥S] {n : â„•} [Finite_dimensional â„ â†¥(S.direction)] (hD : Finite_dimensional.finrank â„ â†¥(S.direction) = n) (hc : EuclideanGeometry.Cospherical ps) {sxâ‚ sxâ‚‚ : Affine.Simplex â„ P n} (hsxâ‚ : set.Range sxâ‚.points âŠ† ps) (hsxâ‚‚ : set.Range sxâ‚‚.points âŠ† ps) : sxâ‚.circumradius = sxâ‚‚.circumradius
{Î± : sort u} {Î² : sort v} {Î³ : sort W} {g : Î² â†’ Î³} (hg : Function.Surjective g) : Function.Surjective (Function.Comp g)
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {F' : F} {x : ð•œ} [PartialOrder ð•œ] : HasDerivWithinAt F F' (set.ici x) x â†’ HasDerivWithinAt F F' (set.ioi x) x
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] : EuclideanGeometry.Cospherical âˆ…
{Î± : Type v} [LinearOrder Î±] {xâ‚ xâ‚‚ yâ‚ yâ‚‚ : Î±} (h : Disjoint (set.Ico xâ‚ xâ‚‚) (set.Ico yâ‚ yâ‚‚)) (hx : xâ‚ < xâ‚‚) (h2 : xâ‚‚ âˆˆ set.Ico yâ‚ yâ‚‚) : yâ‚ = xâ‚‚
{R : Type u_1} [CommRing R] [IsDomain R] : (Ideal.Span {PowerSeries.x}).Prime
{F : Type u_1} [Field F] (P : Polynomial F) (E : Type u_2) [Field E] [Algebra F E] [Fact (Polynomial.Splits (Algebra_Map F E) P)] : Function.Injective â‡‘(Polynomial.Gal.Gal_action_hom P E)
{Î± : Type u_1} [MeasurableSpace Î±] (S : MeasureTheory.SignedMeasure Î±) : S.to_JordanDecomposition.to_SignedMeasure = S
(C : Type u) [CategoryTheory.Category C] [âˆ€ {x Y : C} {F g : x âŸ¶ Y}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.ParallelPair F g)] : CategoryTheory.Limits.HasCoequalizers C
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P : P} (hp : P âˆˆ S) (P2 : P) : P2 -áµ¥ P âˆˆ S.direction â†” P2 âˆˆ S
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) â‰  0) (i : Fin r) : (Matrix.Pivot.List_transvec_col m).Prod.Mul m (Sum.inl_ i) (Sum.inr_ ()) = 0
{P n : â„•} (h : 2 * n < P) : â‡‘(n.central_binom.factorization) P = 0
{G : Type u} [Group G] (A x : G) : SemiconjBy A x (A * x * Aâ»Â¹)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {S : set â„} {e : E} {A : â„} {F : â„ â†’ E} (F_Diff : DifferentiableOn â„ F S) (F_lim : Continuous_within_at F S A) (hs : S âˆˆ nhds_within A (set.Iio A)) (F_lim' : Filter.Tendsto (Î» (x : â„), deriv F x) (nhds_within A (set.Iio A)) (nhds e)) : HasDerivWithinAt F e (set.Iic A) A
{R : Type u_1} [Semiring R] (F : laurent_Polynomial R) {q : laurent_Polynomial R â†’ Prop} (is_qf : âˆ€ (F : Polynomial R), q (â‡‘Polynomial.to_laurent F)) (QT : âˆ€ (F : laurent_Polynomial R), q (F * laurent_Polynomial.t 1) â†’ q F) : q F
{k : Type u_1} {G : Type u_2} {v : Type u_3} [CommSemiring k] [Group G] [AddCommMonoid v] [module k v] (Ï : Representation k G v) [Fintype G] [Invertible â†‘(Fintype.Card G)] (v : v) (hv : v âˆˆ Ï.invariants) : â‡‘(Ï.average_Map) v = v
{G : Type u_3} [Group G] (P : Subgroup G) : P.fg â†” P.to_Submonoid.fg
{ð•œ : Type u_1} {E : Type u_2} [ordered_Ring ð•œ] [AddCommGroup E] [module ð•œ E] {K : Geometry.SimplicialComplex ð•œ E} {S t : Finset E} (hs : S âˆˆ K.Faces) (ht : t âˆˆ K.Faces) : â‡‘(Convex_hull ð•œ) â†‘S âŠ† â‡‘(Convex_hull ð•œ) â†‘t â†” S âŠ† t
{J : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] {Î± : Type uâ‚} (F : J â¥¤ CategoryTheory.Discrete Î±) (j j' : J) : F.obj j = F.obj j'
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [DenselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [TopologicalSpace Î´] [order_IsClosed_topology Î´] {S : set Î±} [hs : S.Ord_connected] {F : Î± â†’ Î´} (hF : Continuous_on F S) {A B : Î±} (ha : A âˆˆ S) (hb : B âˆˆ S) : set.surj_on F S (set.icc (F A) (F B))
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {x Y Z : C} [CategoryTheory.HasLeftDual x] [CategoryTheory.HasLeftDual Y] [CategoryTheory.HasLeftDual Z] {F : x âŸ¶ Y} {g : Y âŸ¶ Z} : á˜(F â‰« g) = á˜g â‰« á˜F
{Î³ : Type W} [SemilatticeSup Î³] {A B : Î³} {S t : set Î³} (hs : IsLub S A) (ht : IsLub t B) : IsLub (S âˆª t) (A âŠ” B)
{K : Type u} [hfield : Field K] (P : Polynomial K) {q : Polynomial K} (hq : q â‰  0) : â‡‘Polynomial.C ((q / Gcd_Monoid.Gcd P q).leading_Coeff)â»Â¹ * (P / Gcd_Monoid.Gcd P q) âˆ£ P
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} (P : Î¹ â†’ P) : AffineIndependent k P â†” âˆ€ (S1 S2 : Finset Î¹) (W1 W2 : Î¹ â†’ k), S1.Sum (Î» (i : Î¹), W1 i) = 1 â†’ S2.Sum (Î» (i : Î¹), W2 i) = 1 â†’ â‡‘(S1.affine_combination P) W1 = â‡‘(S2.affine_combination P) W2 â†’ â†‘S1.indicator W1 = â†‘S2.indicator W2
{R : Type u_1} {m : Type u_2} {N : Type u_3} {P : Type u_4} [Ring R] [AddCommGroup m] [module R m] [AddCommGroup N] [module R N] [AddCommGroup P] [module R P] (F : m â†’â‚—[R] N) (g : N â†’â‚—[R] P) (hF1 : F.Ker.fg) (hF2 : g.Ker.fg) (hsur : Function.Surjective â‡‘F) : (g.Comp F).Ker.fg
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : o.oangle (â‡‘(o.rotation Î¸) x) y = o.oangle x y - Î¸
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {C : F} : ContDiff ð•œ n (Î» (x : E), C)
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] [Nontrivial Î±] {S : set Î±} [TopologicalSpace.IsSeparable_Space â†¥S] (hs : Dense S) : âˆƒ (t : set Î±) (h : t âŠ† S), t.countable âˆ§ Dense t âˆ§ (âˆ€ (x : Î±), _IsBot x â†’ x âˆ‰ t) âˆ§ âˆ€ (x : Î±), _top x â†’ x âˆ‰ t
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [CommRing ð•œ] [AddCommGroup E] [AddCommGroup F] [module ð•œ E] [module ð•œ F] [TopologicalSpace E] [TopologicalSpace F] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] [topological_AddGroup F] [has_Continuous_Const_Smul ð•œ F] (q : FormalMultilinearSeries ð•œ E F) (P : FormalMultilinearSeries ð•œ E E) : q.Comp P 0 = q 0
{mâ‚€ : Type u_1} [Mul_Zero_class mâ‚€] [no_Zero_divisors mâ‚€] {A B : mâ‚€} : A * B â‰  0 â†” A â‰  0 âˆ§ B â‰  0
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [dec_E : DecidableEq E] {S : set E} : Orthonormal ð•œ Coe â†” âˆ€ (v : E), v âˆˆ S â†’ âˆ€ (W : E), W âˆˆ S â†’ HasInner.inner v W = Ite (v = W) 1 0
{m : Type u_1} [has_Add m] {S : set m} {P : m â†’ Prop} {x : m} (h : x âˆˆ Add_Subsemigroup.Closure S) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (HMul : âˆ€ (x y : m), P x â†’ P y â†’ P (x + y)) : P x
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [subtraction_Monoid Î²] (F : Î± â†’+ Î²) (g : Î±) (n : â„¤) : â‡‘F (n â€¢ g) = n â€¢ â‡‘F g
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : A < 1) (hb : B < 1) : A * B < 1
{Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [Semiring Î²] [has_Add Î±] [has_Add Î±â‚‚] {F : Type u_4} [Add_hom_class F Î± Î±â‚‚] (F : F) (x y : AddMonoid_Algebra Î² Î±) : Finsupp.Map_IsDomain â‡‘F (x * y) = Finsupp.Map_IsDomain â‡‘F x * Finsupp.Map_IsDomain â‡‘F y
{Î± : Type u_2} [DecidableEq Î±] [has_Mul Î±] {u : Finset Î±} {S t : set Î±} : â†‘u âŠ† S * t â†’ (âˆƒ (S' t' : Finset Î±), â†‘S' âŠ† S âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† S' * t')
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [Fintype Î¹] (P : Î¹ â†’ P) : AffineIndependent k P â†” âˆ€ (W1 W2 : Î¹ â†’ k), Finset.Univ.Sum (Î» (i : Î¹), W1 i) = 1 â†’ Finset.Univ.Sum (Î» (i : Î¹), W2 i) = 1 â†’ â‡‘(Finset.Univ.affine_combination P) W1 = â‡‘(Finset.Univ.affine_combination P) W2 â†’ W1 = W2
{Î¹ : Type u} {Î³ : Type W} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] {Î´ : Type u_1} [Î  (i : Î¹), AddZeroClass (Î² i)] [AddCommMonoid Î³] [AddCommMonoid Î´] (g : Î³ â†’+ Î´) (F : Î  (i : Î¹), Î² i â†’+ Î³) : g.Comp (â‡‘Dfinsupp.Lift_Add_hom F) = â‡‘Dfinsupp.Lift_Add_hom (Î» (A : Î¹), g.Comp (F A))
{ð•œ : Type u_1} {E : Type u_2} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] {F : ð•œ â†’ E} {r : Ennreal} {x : ð•œ} {P : FormalMultilinearSeries ð•œ ð•œ E} (h : HasFpowerSeriesOnBall F P x r) (h' : âˆ€ (r' : Nnreal), 0 < r' â†’ (âˆƒ (P' : FormalMultilinearSeries ð•œ ð•œ E), HasFpowerSeriesOnBall F P' x â†‘r')) : HasFpowerSeriesOnBall F P x âŠ¤
(R : Type u_1) [CommSemiring R] (x : Type u_2) {C : free_Algebra R x â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(Algebra_Map R (free_Algebra R x)) r)) (h_grade1 : âˆ€ (x : x), C (free_Algebra.Î¹ R x)) (h_Mul : âˆ€ (A B : free_Algebra R x), C A â†’ C B â†’ C (A * B)) (h_Add : âˆ€ (A B : free_Algebra R x), C A â†’ C B â†’ C (A + B)) (A : free_Algebra R x) : C A
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {C : â„} {F' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : Asymptotics._O_with C l (Î» (x : Î±), âˆ¥F' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ Asymptotics._O_with C l F' g'
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z â†’ B} [TopologicalSpace Z] {B' : Type u_5} [TopologicalSpace B'] (h : IsTopologicalFiberBundle F Proj) {F : B' â†’ B} (hF : Continuous F) : IsTopologicalFiberBundle F (Î» (x : â†¥{P : B' Ã— Z | F P.fst = Proj P.Snd}), â†‘x.fst)
{Î± : Type u} [PseudoMetricSpace Î±] {F : â„• â†’ Î±} (n : â„•) {D : â„• â†’ â„} (hD : âˆ€ {k : â„•}, k < n â†’ HasDist.dist (F k) (F (k + 1)) â‰¤ D k) : HasDist.dist (F 0) (F n) â‰¤ (Finset.Range n).Sum (Î» (i : â„•), D i)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {x : E} {n : WithTop â„•} {F g : E â†’ ð•œ} (hF : ContDiff_at ð•œ n F x) (hg : ContDiff_at ð•œ n g x) : ContDiff_at ð•œ n (Î» (x : E), F x * g x) x
{Î± : Type u_1} [LinearOrder Î±] [DenselyOrdered Î±] [NoMinOrder Î±] [NoMaxOrder Î±] [nonem : Nonempty Î±] (lo hi : Finset Î±) (lo_LT_hi : âˆ€ (x : Î±), x âˆˆ lo â†’ âˆ€ (y : Î±), y âˆˆ hi â†’ x < y) : âˆƒ (m : Î±), (âˆ€ (x : Î±), x âˆˆ lo â†’ x < m) âˆ§ âˆ€ (y : Î±), y âˆˆ hi â†’ m < y
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) â‰  0) (i : Fin r) : ((Matrix.Pivot.List_transvec_col m).Prod.Mul m).Mul (Matrix.Pivot.List_transvec_row m).Prod (Sum.inr_ ()) (Sum.inl_ i) = 0
{K : Type u_1} [Field K] [Invertible 2] {A B C : K} (ha : A â‰  0) (h : âˆƒ (S : K), discrim A B C = S * S) : âˆƒ (x : K), A * x * x + B * x + C = 0
{R : Type v} [CommRing R] {n : â„•} (A : Matrix (Fin n.Succ) (Fin n.Succ) R) (j : Fin n.Succ) : A.det = Finset.Univ.Sum (Î» (i : Fin n.Succ), (-1) ^ (â†‘i + â†‘j) * A i j * (A.minor â‡‘(i.Succ_above) â‡‘(j.Succ_above)).det)
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {A B : Î±} (h : A â‰  B) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ {A, B}), F i)) = F A * F B
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} [Ring R] [AddCommGroup m] [module R m] [Nontrivial R] (B : Basis Î¹ R m) : _.Maximal
{R : Type u_1} {A B : R} [Semigroup R] (Ab : IsLeftRegular (A * B)) : IsLeftRegular B
{E : Type u_1} [AddCommGroup E] [module â„ E] {S : set E} {x : E} (Absorbs : Absorbent â„ S) : {r : â„ | 0 < r âˆ§ x âˆˆ r â€¢ S}.Nonempty
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Mul_Pos_StrictMono Î±] (ha : A < 1) (hb : B < 1) (B0 : 0 < B) : A * B < 1
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsNoetherian R m] (F : m â†’â‚—[R] m) (S : Function.Surjective â‡‘F) : Function.Bijective â‡‘F
{n : â„•} {A B : Fin n} {x : Fin (n + 1)} : â‡‘(x.Succ_above) A = â‡‘(x.Succ_above) B â†” A = B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ F} {F' : E â†’L[ð•œ] F} (x : E) {g : F â†’ G} {g' : F â†’L[ð•œ] G} (hg : HasStrictFderivAt g g' (F x)) (hF : HasStrictFderivAt F F' x) : HasStrictFderivAt (Î» (x : E), g (F x)) (g'.Comp F') x
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] {F : Type v} [NormedGroup F] [NormedSpace â„‚ F] {F : E â†’ F} {C : E} (hD : âˆ€á¶  (z : E) in nhds C, Differentiable_at â„‚ F z) (hc : IsLocalMax (HasNorm.norm âˆ˜ F) C) : âˆ€á¶  (y : E) in nhds C, âˆ¥F yâˆ¥ = âˆ¥F Câˆ¥
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : (Î» (n : â„•), âˆ¥P nâˆ¥ * â†‘r ^ n) =O[Filter.at_top] Î» (n : â„•), 1) : â†‘r â‰¤ P.radius
{R : Type u} [Ring R] {S : set R} {P : R â†’ R â†’ Prop} {A B : R} (ha : A âˆˆ Subring.Closure S) (hb : B âˆˆ Subring.Closure S) (Hs : âˆ€ (x : R), x âˆˆ S â†’ âˆ€ (y : R), y âˆˆ S â†’ P x y) (h0_Left : âˆ€ (x : R), P 0 x) (h0_Right : âˆ€ (x : R), P x 0) (h1_Left : âˆ€ (x : R), P 1 x) (h1_Right : âˆ€ (x : R), P x 1) (Hneg_Left : âˆ€ (x y : R), P x y â†’ P (-x) y) (Hneg_Right : âˆ€ (x y : R), P x y â†’ P x (-y)) (HAdd_Left : âˆ€ (xâ‚ xâ‚‚ y : R), P xâ‚ y â†’ P xâ‚‚ y â†’ P (xâ‚ + xâ‚‚) y) (HAdd_Right : âˆ€ (x yâ‚ yâ‚‚ : R), P x yâ‚ â†’ P x yâ‚‚ â†’ P x (yâ‚ + yâ‚‚)) (HMul_Left : âˆ€ (xâ‚ xâ‚‚ y : R), P xâ‚ y â†’ P xâ‚‚ y â†’ P (xâ‚ * xâ‚‚) y) (HMul_Right : âˆ€ (x yâ‚ yâ‚‚ : R), P x yâ‚ â†’ P x yâ‚‚ â†’ P x (yâ‚ * yâ‚‚)) : P A B
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {F' : F} {x : ð•œ} [PartialOrder ð•œ] : HasDerivWithinAt F F' (set.Iio x) x â†’ HasDerivWithinAt F F' (set.Iic x) x
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {C : â„} {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : Asymptotics._O_with C l F g' â†’ Asymptotics._O_with C l F (Î» (x : Î±), âˆ¥g' xâˆ¥)
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] [Nontrivial R] {Î¹ : Type W} (B : Basis Î¹ R m) [Infinite Î¹] {Îº : Type W'} (v : Îº â†’ m) (i : LinearIndependent R v) (m : i.Maximal) : (Cardinal.Mk Î¹).Lift â‰¤ (Cardinal.Mk Îº).Lift
{m : Type u_1} [Add_Semigroup m] [TopologicalSpace m] [t2_Space m] (Continuous_Mul_Left : âˆ€ (r : m), Continuous (Î» (_x : m), _x + r)) (S : set m) (snemp : S.Nonempty) (S_IsCompact : IsCompact S) (S_Add : âˆ€ (x : m), x âˆˆ S â†’ âˆ€ (y : m), y âˆˆ S â†’ x + y âˆˆ S) : âˆƒ (m : m) (h : m âˆˆ S), m + m = m
{R : Type u_1} [CommRing R] {S : Submonoid R} {P : Type u_2} [CommRing P] [Algebra R P] : â†‘1 = IsLocalization.Coe_Submodule P âŠ¤
{Î± : Type v} [LinearOrder Î±] [TopologicalSpace Î±] [order_IsClosed_topology Î±] {S : set Î±} (hs : IsPreconnected S) (hb : Â¬BddBelow S) (ha : Â¬BddAbove S) : S = set.Univ
{Î± : Type u} [PseudoMetricSpace Î±] (S : set Î±) : LipschitzWith 1 (Î» (x : Î±), metric.Inf_dist x S)
{G : Type u_1} [Group G] [Fintype G] : Monoid._torsion G
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {S : set E} (hs : Orthonormal ð•œ Coe) : âˆƒ (W : set E) (h : W âŠ‡ S), Orthonormal ð•œ Coe âˆ§ âˆ€ (u : set E), u âŠ‡ W â†’ Orthonormal ð•œ Coe â†’ u = W
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {x : E} {n : WithTop â„•} {P : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n F P S) (hn : 1 â‰¤ n) (hx : x âˆˆ S) : HasFderivWithinAt F (â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (P x 1)) S x
{Î± : Type u_2} {Î¹ : Type u_5} [AddCommMonoid Î±] (t : Finset Î¹) (F : Î¹ â†’ set Î±) (A : Î±) : A âˆˆ t.Sum (Î» (i : Î¹), F i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ {i : Î¹}, i âˆˆ t â†’ g i âˆˆ F i), t.Sum (Î» (i : Î¹), g i) = A
{Î± : Type u} [Infinite Î±] : Nonempty (Field Î±)
(n A : â„•) : Finset.image (Î» (_x : â„•), _x % A) (Finset.Ico n (n + A)) = Finset.Range A
{n : â„•} {A B : Fin n} : A â‹– B â†’ â†‘A â‹– â†‘B
{x : Type u} {mâ‚ mâ‚‚ : x â†’ x â†’ x} {eâ‚ eâ‚‚ : x} (hâ‚ : EckmannHilton.IsUnital mâ‚ eâ‚) (hâ‚‚ : EckmannHilton.IsUnital mâ‚‚ eâ‚‚) (Distrib : âˆ€ (A B C D : x), mâ‚ (mâ‚‚ A B) (mâ‚‚ C D) = mâ‚‚ (mâ‚ A C) (mâ‚ B D)) : mâ‚ = mâ‚‚
{G : Type u_1} [Group G] : Group.IsNilpotent G â†” âˆƒ (n : â„•), lower_central_series G n = âŠ¥
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A : Î±} : Aâ»Â¹ < 1 â†” 1 < A
(t : Type u) [TopologicalSpace t] : CategoryTheory.Pretopology.of_grothendieck (TopologicalSpace.Opens t) (Opens.GrothendieckTopology t) = Opens.pretopology t
{Î± : Type u_1} [LinearOrder Î±] [SuccOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (hr : Reflexive r) (h1 : âˆ€ (i : Î±), i âˆˆ set.Ico n m â†’ r i (Order.Succ i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.Ico m n â†’ r (Order.Succ i) i) : Relation.TransGen r n m
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) (B : n â†’ Î±) : A.Mul_vec (â‡‘(A.cramer) B) = A.det â€¢ B
{ð•œ : Type u_3} {E : Type u_4} [semi_NormedRing ð•œ] [AddCommGroup E] [module ð•œ E] (P : Seminorm ð•œ E) (r : â„) : Balanced ð•œ (P.ball 0 r)
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} : metric.Hausdorff_dist (Closure S) (Closure t) = metric.Hausdorff_dist S t
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {C : â„} {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : Asymptotics._O_with C l (Î» (x : Î±), -F' x) g â†’ Asymptotics._O_with C l F' g
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} : Monotone_on F S â†’ Antitone_on (F âˆ˜ â‡‘order_dual.of_dual) S
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} (ha : 0 < A) (hb : 0 â‰¤ B) : 0 < A + B
(z : â„‚) : â†‘(z.im) = (z - â‡‘(Star_Ring_end â„‚) z) / (2 * Complex.i)
{Î¹ : Type u} (S : Finset Î¹) (W z : Î¹ â†’ â„) (hw : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ W i) (hw' : S.Sum (Î» (i : Î¹), W i) = 1) (hz : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ z i) : S.Prod (Î» (i : Î¹), z i ^ W i) â‰¤ S.Sum (Î» (i : Î¹), W i * z i)
{Î± : Type u_1} {P : Finset Î± â†’ Prop} [DecidableEq Î±] (S : Finset Î±) (hâ‚ : P âˆ…) (hâ‚‚ : âˆ€ {A : Î±} {S : Finset Î±}, A âˆˆ S â†’ S âŠ† S â†’ A âˆ‰ S â†’ P S â†’ P (HasInsert.Insert A S)) : P S
{Î± : Type u} [Preorder Î±] {A B C : Î±} : B < C â†’ A = B â†’ A < C
(n : â„•) (P : â„• â†’ â„) (hp : âˆ€ (k : â„•), 0 â‰¤ P k) {r A : â„} (hr : 0 â‰¤ r) (ha : 0 â‰¤ A) : (Finset.Ico 2 (n + 1)).Sum (Î» (k : â„•), A ^ k * {C : Composition k | 1 < C.length}.to_Finset.Sum (Î» (C : Composition k), r ^ C.length * Finset.Univ.Prod (Î» (j : Fin C.length), P (C.blocks_fun j)))) â‰¤ (Finset.Ico 2 (n + 1)).Sum (Î» (j : â„•), r ^ j * (Finset.Ico 1 n).Sum (Î» (k : â„•), A ^ k * P k) ^ j)
(l : List â„•) (n : â„•) : List.Sorted has_LT.LT (Denumerable.raise' l n)
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚‚} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J â¥¤ C} (e : K â‰Œ J) [CategoryTheory.Limits.HasLimit (e.Functor â‹™ F)] : CategoryTheory.Limits.HasLimit F
{Î± : Type u} {Î² : Type v} [Fintype Î²] (r : Î± â†’ Î² â†’ Prop) [Î  (A : Î±), Decidable_Pred (r A)] : (âˆ€ (A : Finset Î±), A.Card â‰¤ (Finset.Filter (Î» (B : Î²), âˆƒ (A : Î±) (h : A âˆˆ A), r A B) Finset.Univ).Card) â†” âˆƒ (F : Î± â†’ Î²), Function.Injective F âˆ§ âˆ€ (x : Î±), r x (F x)
{Î± : Type u} {F : Î± â†’ Î±} {x : Î±} (hF : Function.IsFixedPt F x) : F x = x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] [CategoryTheory.Limits.HasPullbacks C] {P q R : C} {F : P âŸ¶ R} {g : q âŸ¶ R} {P : â†¥P} {q : â†¥q} : â‡‘F P = â‡‘g q â†’ (âˆƒ (S : â†¥(CategoryTheory.Limits.pullback F g)), â‡‘CategoryTheory.Limits.pullback.fst S = P âˆ§ â‡‘CategoryTheory.Limits.pullback.Snd S = q)
{Î± : Type u} {l : List Î±} : l.sublists.Nodup â†’ l.Nodup
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (v : m) {r : R} (h : 0 â‰¤ r) : SameRay R (r â€¢ v) v
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {g : Î² â†’ m} (e : Î± â†’ Î²) (hEâ‚€ : Function.Bijective e) (hEâ‚ : âˆ€ (x : Î±), F x = g (e x)) : finprod (Î» (i : Î±), F i) = finprod (Î» (j : Î²), g j)
{K : Type u} {v vâ‚ : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [AddCommGroup vâ‚] [module K vâ‚] (Cond : module.rank K v = module.rank K vâ‚) : Nonempty (v â‰ƒâ‚—[K] vâ‚)
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : RË£) : âˆ€á¶  (t : R) in nhds 0, Ring.Inverse (â†‘x + t) = Ring.Inverse (1 + â†‘xâ»Â¹ * t) * â†‘xâ»Â¹
{E : Type u_2} [semi_NormedGroup E] [NormedSpace â„ E] : Convex_on â„ set.Univ HasNorm.norm
 : GoldenRatioâ»Â¹ = -golden_Conj
{Î± : Type u_3} {Î² : Type u_4} [Preorder Î²] {F : Î² â†’ Finset Î±} (h : Monotone F) (h' : âˆ€ (x : Î±), âˆƒ (n : Î²), x âˆˆ F n) : Filter.Tendsto F Filter.at_top Filter.at_top
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] (F : â„‚ â†’ E) (z W : â„‚) (Hc : Continuous_on F (set.Interval z.re W.re Ã—â„‚ set.Interval z.im W.im)) (hD : DifferentiableOn â„‚ F (set.Ioo (LinearOrder.min z.re W.re) (LinearOrder.max z.re W.re) Ã—â„‚ set.Ioo (LinearOrder.min z.im W.im) (LinearOrder.max z.im W.im))) : (((âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(W.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(W.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(z.re) + â†‘y * Complex.i) = 0
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] {A B : Î±} {h : A â‰¤ B} [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] {F : â†¥(set.icc A B) â†’ Î²} (hF : Continuous F) : Continuous (set.icc_extend h F)
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S : set Î±} {A : Î±} (h : IsLeast S A) : HasInf.Inf S = A
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsNoetherian R m] (F : m â†’â‚—[R] m) (S : Function.Surjective â‡‘F) : Function.Injective â‡‘F
{R : Type u} {m : Type v} [CommRing R] [Nontrivial R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] (F : m â†’â‚—[R] m) {Î¹ : Type W} [Fintype Î¹] (B : Basis Î¹ R m) : (â‡‘(Linear_Map.to_Matrix B B) F).charpoly = F.charpoly
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R â†’+* S} {S : S} (n : â„•) (h : S âˆˆ set.Range â‡‘F) : â‡‘(Polynomial.monomial n) S âˆˆ Polynomial.lifts F
{Gâ‚€ : Type u_2} [Group_with_Zero Gâ‚€] (A : Gâ‚€) : A * A / A = A
{ð•œ : Type u_1} {E : Type u_3} [NormedField ð•œ] [AddCommGroup E] [module ð•œ E] {A : set E} [TopologicalSpace E] [has_Continuous_Smul ð•œ E] (hA : Balanced ð•œ A) (h : 0 âˆˆ Interior A) : Balanced ð•œ (Interior A)
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * HasInner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{m : Type u_3} [AddMonoid m] [Inhabited m] (l : List m) (h : l â‰  List.Nil) : l.head + l.tail.Sum = l.Sum
{P k : â„•} (hp : Nat.Prime P) : (P ^ k).factorization = Finsupp.single P k
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {tâ‚ tâ‚‚ : Affine.Triangle â„ P} {iâ‚ iâ‚‚ iâ‚ƒ jâ‚ jâ‚‚ jâ‚ƒ : Fin 3} (hiâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hiâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hiâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) (hjâ‚â‚‚ : jâ‚ â‰  jâ‚‚) (hjâ‚â‚ƒ : jâ‚ â‰  jâ‚ƒ) (hjâ‚‚â‚ƒ : jâ‚‚ â‰  jâ‚ƒ) (hâ‚ : tâ‚‚.points jâ‚ = tâ‚.orthocenter) (hâ‚‚ : tâ‚‚.points jâ‚‚ = tâ‚.points iâ‚‚) (hâ‚ƒ : tâ‚‚.points jâ‚ƒ = tâ‚.points iâ‚ƒ) : tâ‚‚.orthocenter = tâ‚.points iâ‚
{Î¹ : Type u} {F g : Î¹ â†’ Nnreal} {P : â„} (hp : 1 â‰¤ P) (hF : Summable (Î» (i : Î¹), F i ^ P)) (hg : Summable (Î» (i : Î¹), g i ^ P)) : Summable (Î» (i : Î¹), (F i + g i) ^ P) âˆ§ (âˆ‘' (i : Î¹), (F i + g i) ^ P) ^ (1 / P) â‰¤ (âˆ‘' (i : Î¹), F i ^ P) ^ (1 / P) + (âˆ‘' (i : Î¹), g i ^ P) ^ (1 / P)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {x : Î±} {P : Filter Î¹} {g : Î¹ â†’ Î±} [TopologicalSpace Î±] (h : Continuous_at F x) (hg : Filter.Tendsto g P (nhds x)) (hunif : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : set Î±) (h : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in P, âˆ€ (y : Î±), y âˆˆ t â†’ (F y, F n y) âˆˆ u)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) P (nhds (F x))
{R : Type u_1} {m : Type u_3} {A B : R} [comm_Semigroup R] [HasScalar R m] [IsScalarTower R R m] : IsSmulRegular m (A * B) â†” IsSmulRegular m A âˆ§ IsSmulRegular m B
{Î± : Type u_1} [Monoid Î±] {P q : Î±} (hp : Irreducible P) (hq : Irreducible q) : P âˆ£ q â†’ q âˆ£ P
{R : Type u_1} {S : Type u_2} [CommRing R] [Nontrivial R] [CommRing S] [IsDomain S] [Algebra R S] (h : Algebra.IsIntegral R S) (hRS : Function.Injective â‡‘(Algebra_Map R S)) (hS : _Field S) : _Field R
{Î± : Type u_1} {Î¹ : Type u_4} [CompleteLattice Î±] (S : Î¹ â†’ Î±) : (â¨… (i : Î¹), S i) = â¨… (t : Finset Î¹) (i : Î¹) (h : i âˆˆ t), S i
{R : Type u} [Ring R] (S : Subring R) {x y : R} (hx : x âˆˆ S) (hy : y âˆˆ S) : x - y âˆˆ S
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {S t : Convex_cone ð•œ E} (h : âˆ€ (x : E), x âˆˆ S â†” x âˆˆ t) : S = t
{P n k : â„•} (P_Large : n < P ^ 2) : â‡‘((n.choose k).factorization) P â‰¤ 1
{R : Type u} [Ring R] {L m N : module R} (F : L âŸ¶ m) [CategoryTheory.Limits.HasImage F] (g : â†‘(CategoryTheory.Limits.image_Subobject F) âŸ¶ N) [CategoryTheory.Limits.HasCokernel g] {x y : â†¥N} (l : â†¥L) (W : x = y + â‡‘g (â‡‘(CategoryTheory.Limits.FactorThruImage_Subobject F) l)) : â‡‘(CategoryTheory.Limits.CokernelÏ€ g) x = â‡‘(CategoryTheory.Limits.CokernelÏ€ g) y
{Î± : Type u} [PseudoEmetricSpace Î±] (F : â„• â†’ Î±) (n : â„•) : HasEdist.edist (F 0) (F n) â‰¤ (Finset.Range n).Sum (Î» (i : â„•), HasEdist.edist (F i) (F (i + 1)))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {x : E} {n : WithTop â„•} {S : set E} {F g : E â†’ F} (hF : ContDiff_within_at ð•œ n F S x) (hg : ContDiff_within_at ð•œ n g S x) : ContDiff_within_at ð•œ n (Î» (x : E), F x - g x) S x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (h_Int : Algebra.IsIntegral K L) : t2_Space (L â‰ƒâ‚[K] L)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [Ring_hom_isometric Ïƒâ‚â‚‚] (F : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) (hF : Continuous â‡‘F) : âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (x : E), âˆ¥â‡‘F xâˆ¥ â‰¤ C * âˆ¥xâˆ¥
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (e : LocalHomeomorph Î± Î²) (h : e.to_local_Equiv.Source = set.Univ) : IsOpen_Embedding â‡‘e
 : âˆƒ (Î± Î² : Type) (iÎ± : TopologicalSpace Î±) (iÎ² : TopologicalSpace Î²), CompactSpace Î± âˆ§ t1_Space Î² âˆ§ âˆƒ (F : Î± â‰ƒ Î²), Continuous â‡‘F âˆ§ Â¬Continuous â‡‘(F.Symm)
{G : Type u_1} {h : Type u_2} [Group G] [Group h] {F : G â†’* h} (hF : Function.Surjective â‡‘F) (tG : Monoid._torsion G) : Monoid._torsion h
{G : Type u_1} {h : Type u_2} [AddGroup G] [AddGroup h] {F : G â†’+ h} (hF : Function.Surjective â‡‘F) (tG : AddMonoid._torsion G) : AddMonoid._torsion h
{Î± : Type u} [Group Î±] [Fintype Î±] {P : â„•} [hp : Fact (Nat.Prime P)] (h : Fintype.Card Î± = P) : IsCyclic Î±
{m : Type u_1} [AddZeroClass m] {S t : Add_Submonoid m} (h : âˆ€ (x : m), x âˆˆ S â†” x âˆˆ t) : S = t
{Î± : Type u} [TopologicalSpace Î±] {S U : set Î±} (hS : IsPreirreducible S) (hU : IsOpen U) (h : (S âˆ© U).Nonempty) : S âŠ† Closure (S âˆ© U)
{l : Type u_1} {m : Type u_2} {Î± : Type v} [has_Zero Î±] [DecidableEq m] [DecidableEq l] (D : m â†’ Î±) (e : l â†’ m) (hE : Function.Injective e) : (Matrix.Diagonal D).minor e e = Matrix.Diagonal (D âˆ˜ e)
{mâ‚€ : Type u_1} [CancelMonoidWithZero mâ‚€] {A B : mâ‚€} (hâ‚ : B â‰  1) (hâ‚‚ : A * B = A) : A = 0
{A B : Cardinal} (ha : Cardinal.aleph0 â‰¤ A) (hb : Cardinal.aleph0 â‰¤ B) : A * B = LinearOrder.max A B
{E : Type u_1} {Î² : Type u_2} [AddCommGroup E] [TopologicalSpace E] [module â„ E] [topological_AddGroup E] [has_Continuous_Smul â„ E] [ordered_AddCommGroup Î²] [module â„ Î²] [OrderedSmul â„ Î²] {F : E â†’ Î²} {A : E} (h_IsLocalMax : IsLocalMax F A) (h_conc : ConcaveOn â„ set.Univ F) (x : E) : F x â‰¤ F A
(S : â„) {B : â„} (hb : 0 < B) : (Î» (x : â„), x ^ S) =o[Filter.at_top] Î» (x : â„), Real.Exp (B * x)
{C : Type u} [CategoryTheory.Category C] {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.Limits.HasImage F] : (CategoryTheory.Limits.image.Mono_factorisation F).e = CategoryTheory.Limits.FactorThruImage F
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] : âŠ¥.fixing_Subgroup = âŠ¤
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G : C â¥¤ D} (h_obj : âˆ€ (x : C), F.obj x = G.obj x) (h_Map : âˆ€ (x Y : C) (F : x âŸ¶ Y), F.Map F == G.Map F) : F = G
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : bounded_Continuous_Function x â„) {t : set â„} {e : x â†’ Y} [hs : t.Ord_connected] (hF : âˆ€ (x : x), â‡‘F x âˆˆ t) (hne : t.Nonempty) (hE : IsClosed_Embedding e) : âˆƒ (g : bounded_Continuous_Function Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ â‡‘g âˆ˜ e = â‡‘F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q R : C} (F : P âŸ¶ q) (g : q âŸ¶ R) : â‡‘g âˆ˜ â‡‘F = â‡‘(F â‰« g)
{R : Type uâ‚} [CommRing R] (A B : R) : (A - B) ^ 2 = A ^ 2 - 2 * A * B + B ^ 2
{Î¹ : Type u_1} {x : Î¹ â†’ Type u_2} [Î  (i : Î¹), TopologicalSpace (x i)] {as bs cs : Î  (i : Î¹), x i} (Î³â‚€ : Î  (i : Î¹), Path.Homotopic.Quotient (as i) (bs i)) (Î³â‚ : Î  (i : Î¹), Path.Homotopic.Quotient (bs i) (cs i)) : (Path.Homotopic.Pi Î³â‚€).Comp (Path.Homotopic.Pi Î³â‚) = Path.Homotopic.Pi (Î» (i : Î¹), (Î³â‚€ i).Comp (Î³â‚ i))
{P : â„•} {G : Type u_1} [Group G] (hG : _P_Group P G) [hp : Fact (Nat.Prime P)] (Î± : Type u_2) [MulAction G Î±] [Fintype Î±] [Fintype â†¥(MulAction.FixedPoints G Î±)] (hpÎ± : Â¬P âˆ£ Fintype.Card Î±) : (MulAction.FixedPoints G Î±).Nonempty
{ð•œ : Type u_1} {E : Type u_2} [ordered_Ring ð•œ] [AddCommGroup E] [module ð•œ E] (q : AffineSubspace ð•œ E) : Convex ð•œ â†‘q
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization m S] (A : S) : âˆƒ (B : â†¥m), IsLocalization._integer R (â†‘B â€¢ A)
{A B C : â„•} (h : A % C = B % C) : (A - B) % C = 0
 : Fact (Finite_dimensional.finrank â„ â„‚ = 2)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : intermediate_Field K L) [Finite_dimensional K â†¥E] : IsOpen â†‘(E.fixing_Subgroup)
{m : Type u_1} [AddCommMonoid m] (F : â„• â†’ â„• â†’ m) (n : â„•) : (Finset.Nat.antidiagonal n).Sum (Î» (ij : â„• Ã— â„•), F ij.fst ij.Snd) = (Finset.Range n.Succ).Sum (Î» (k : â„•), F k (n - k))
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] [Nonempty v] (k : â„•) (h : âˆ€ (v : v), k â‰¤ G.degree v) : k â‰¤ G.min_degree
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ AddMon) [CategoryTheory.IsFiltered J] {x y y' : Î£ (j : J), â†¥(F.obj j)} (hyy' : CategoryTheory.Limits.types.filtered_Colimit.Rel (F â‹™ CategoryTheory.Forget AddMon) y y') : AddMon.FilteredColimits.Colimit_Add_aux F x y = AddMon.FilteredColimits.Colimit_Add_aux F x y'
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] (F : â„‚ â†’ E) (z W : â„‚) (h : DifferentiableOn â„‚ F (set.Interval z.re W.re Ã—â„‚ set.Interval z.im W.im)) : (((âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(W.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(W.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(z.re) + â†‘y * Complex.i) = 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q R : C} (F : P âŸ¶ q) (g : q âŸ¶ R) (A : â†¥P) : â‡‘(F â‰« g) A = â‡‘g (â‡‘F A)
{n : â„•} {Î± : Type u_1} {v W : Vector Î± n} (h : âˆ€ (m : Fin n), v.nth m = W.nth m) : v = W
{R : Type u} [Field R] [Star_Ring R] (x y : R) : HasStar.Star (x / y) = HasStar.Star x / HasStar.Star y
{G : Type u} [AddMonoid G] {h : Type v} [AddMonoid h] (F : G â†’+ h) {x : G} (h : _of_Fin_Add_order x) : _of_Fin_Add_order (â‡‘F x)
(k : Type u_1) [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) : Finset.centroid_weights_indicator k S = â†‘S.indicator (Finset.centroid_weights k S)
{Î± : Type u_1} [CompleteLattice Î±] {A : Î±} {S : set Î±} : A âŠ” HasInf.Inf S â‰¤ â¨… (B : Î±) (h : B âˆˆ S), A âŠ” B
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {R : â„} {C W : â„‚} {F : â„‚ â†’ E} (hD : DifferentiableOn â„‚ F (metric.IsClosed_ball C R)) (hw : W âˆˆ Metric.Ball C R) : âˆ® (z : â„‚) in C(C, R), (z - W)â»Â¹ â€¢ F z = (2 * â†‘Real.Pi * Complex.i) â€¢ F W
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.Forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.Forget C)] {x : top} (F : top.sheaf C x) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥x) (sf : Î  (i : Î¹), â†¥(F.val.obj (Opposite.Op (U i)))) (h : F.val._compatible U sf) : âˆƒ! (S : â†¥(F.val.obj (Opposite.Op (supr U)))), F.val._gluing U sf S
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î² â†’ Î³} {x : Î±} {y : Î²} (hF : Continuous_at F y) : Continuous_at (Î» (x : Î± Ã— Î²), F x.Snd) (x, y)
{Î± : Type u_1} {l : Filter Î±} {P : Î± â†’ Prop} : (âˆ€á¶  (S : set Î±) in l.Small_sets, âˆ€ (x : Î±), x âˆˆ S â†’ P x) â†’ (âˆ€á¶  (x : Î±) in l, P x)
{k : Type u_1} {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {P : Î¹ â†’ P} (hi : AffineIndependent k P) {S : Finset Î¹} {sm : Submodule k v} [Finite_dimensional k â†¥sm] (hle : Vector_Span k â†‘(Finset.image P S) â‰¤ sm) (hc : S.Card = Finite_dimensional.finrank k â†¥sm + 1) : Vector_Span k â†‘(Finset.image P S) = sm
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} : Metric.Bounded S â†” Emetric.diam S â‰  âŠ¤
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {x : E} : MdifferentiableAt (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F x â†” Differentiable_at ð•œ F x
{Î± : Type u_1} {l l' : List Î±} (F : â„• â†ªo â„•) (hF : âˆ€ (ix : â„•), l.nth ix = l'.nth (â‡‘F ix)) : l <+ l'
{x : Type u_1} [TopologicalSpace x] [CompactSpace x] (A : Subalgebra â„ C(x, â„)) (W : A.separates_points) : A.topological_Closure = âŠ¤
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x z - o.oangle x y = o.oangle y z
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : affine_Span k set.Univ = âŠ¤
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} (hF : Convex_on ð•œ S F) {x y z : ð•œ} (hx : x âˆˆ S) (hz : z âˆˆ S) (hxy : x < y) (hyz : y < z) : (F y - F x) / (y - x) â‰¤ (F z - F y) / (z - y)
(A B : â„) : (Polynomial_Functions (set.icc A B)).topological_Closure = âŠ¤
(A B : â„) (F : C(â†¥(set.icc A B), â„)) : F âˆˆ (Polynomial_Functions (set.icc A B)).topological_Closure
{R : Type u_1} {E : Type u_2} [Linear_ordered_Field R] [AddCommGroup E] [module R E] {Î¹ : Type u_3} (B : affine_Basis Î¹ R E) : â‡‘(Convex_hull R) (set.Range B.points) = {x : E | âˆ€ (i : Î¹), 0 â‰¤ â‡‘(B.coord i) x}
{Î± : Type u} {P : Î± â†’ Prop} {A : Î±} (h : A âˆˆ {x : Î± | P x}) : P A
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) (z : Î± 0) : Fin.tail (Function.update q 0 z) = Fin.tail q
{Î± : Type u_1} [DecidableEq Î±] : Monotone Finset.shadow
(R : Type u_1) (A : Type u_2) [CommSemiring R] : Pi.Const_Ring_hom A R = Algebra_Map R (A â†’ R)
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x : C} {R : CategoryTheory.Presieve x} : CategoryTheory.Presieve.IsSheafFor P R â†’ CategoryTheory.Presieve.IsSeparated_for P R
{G : Type u_6} {h : Type u_7} {F : Type u_8} [AddGroup G] [subtraction_Monoid h] [AddMonoid_hom_class F G h] (F : F) (n : â„¤) (g : G) : â‡‘F (n â€¢ g) = n â€¢ â‡‘F g
(n : â„•) : â†‘(n.Totient) = â†‘n * n.Factors.to_Finset.Prod (Î» (P : â„•), 1 - (â†‘P)â»Â¹)
{E : Type u_1} [AddCommGroup E] [module â„ E] (P : Seminorm â„ E) : gauge (P.ball 0 1) = â‡‘P
{F : Type u_3} [InnerProductSpace â„ F] {x : F} {r : â„} (hx : x â‰  0) (hr : r < 0) : HasInner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = -1
{R : Type u_1} {Î± : Type u_2} (G : SimpleGraph Î±) [has_Zero R] [has_One R] [DecidableEq Î±] [Decidable_Rel G.Adj] {A : Î±} {e : Sym2 Î±} : SimpleGraph.inc_Matrix R G A e = Ite (e âˆˆ G.incidence_set A) 1 0
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (B : Matrix n m Î±) [Invertible A] : (â…Ÿ A).Mul (A.Mul B) = B
(P : â„•) [hp : Fact (Nat.Prime P)] {q : â„š} (h : padic_norm P q = 0) : q = 0
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : o.oangle (-x) (-y) = o.oangle x y
{Î± : Type u} [Preorder Î±] [NoMaxOrder Î±] (A : Î±) : âˆƒ (F : â„• â†’ Î±), StrictMono F âˆ§ F 0 = A
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S : set Î±} {B : Î±} (hs : S.Nonempty) (h : âˆ€ (A : Î±), A âˆˆ S â†’ A â‰¤ B) (h' : âˆ€ (W : Î±), W < B â†’ (âˆƒ (A : Î±) (h : A âˆˆ S), W < A)) : HasSup.Sup S = B
(P : Polynomial â„š) : (P.root_set â„‚).to_Finset.Card = (P.root_set â„).to_Finset.Card + (â‡‘(Polynomial.Gal.Gal_action_hom P â„‚) (â‡‘(Polynomial.Gal.Restrict P â„‚) (alg_Equiv.Restrict_scalars â„š Complex.Conj_ae))).Support.Card
(z : UpperHalfPlane) : Filter.Tendsto (Î» (P : Fin 2 â†’ â„¤), â‡‘Complex.norm_sq (â†‘(P 0) * â†‘z + â†‘(P 1))) Filter.cofinite Filter.at_top
{P : â„•} [hp : Fact (Nat.Prime P)] : WittVector.IsPoly P (Î» (R : Type u_1) (_Rcr : CommRing R), â‡‘witt_Vector.verschiebung)
{Î¹ : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] [ParacompactSpace x] (hs : IsClosed S) (U : Î¹ â†’ set x) (ho : âˆ€ (i : Î¹), IsOpen (U i)) (hU : S âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (F : BumpCovering Î¹ x S), F._subordinate U
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {x Y : C} (g : Y âŸ¶ x) [CategoryTheory.Mono g] (Fâ‚ Fâ‚‚ : CategoryTheory.Subobject Y) : (CategoryTheory.Subobject.Map g).obj (Fâ‚ âŠ“ Fâ‚‚) = (CategoryTheory.Subobject.Map g).obj Fâ‚ âŠ“ (CategoryTheory.Subobject.Map g).obj Fâ‚‚
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ AddMon) [CategoryTheory.IsFiltered J] (j : J) : 0 = AddMon.FilteredColimits.m.Mk F âŸ¨j, 0âŸ©
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x : Î±} (h : IsClosed S) (hs : S.Nonempty) : x âˆˆ S â†” metric.Inf_dist x S = 0
{ð•œ : Type u_1} {x : Type u_2} [_R_or_C ð•œ] [TopologicalSpace x] {A : Subalgebra ð•œ C(x, ð•œ)} (hA : A.separates_points) (hA' : Continuous_Map.Conj_invariant_Subalgebra (Subalgebra.Restrict_scalars â„ A)) : ((Subalgebra.Restrict_scalars â„ A).comap' (AlgHom.Comp_Left_Continuous â„ _R_or_C.of_Real_am _R_or_C.Continuous_of_Real)).separates_points
{x : Type u} {Y : Type v} [MetricSpace x] [MetricSpace Y] : Isometry Sum.inl_
(S B : â„) (hb : 0 < B) : Filter.Tendsto (Î» (x : â„), x ^ S * Real.Exp (-B * x)) Filter.at_top (nhds 0)
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} [ProperSpace Î±] (h : Metric.Bounded S) : IsCompact (Closure S)
{ð•œ : Type u_1} [NormedField ð•œ] [CompleteSpace ð•œ] {r : ð•œ} (hr : âˆ¥râˆ¥ < 1) : has_Sum (Î» (n : â„•), â†‘n * r ^ n) (r / (1 - r) ^ 2)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x y : E) : â‡‘_R_or_C.re (HasInner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 4
{Î± : Type u} [PartialOrder Î±] {A B : Î±} (hab : A â‰¤ B) (hba : Â¬A < B) : A = B
{Î± : Type u} {Î² : Type v} {S : set Î±} {F : Î± â†’ Î²} : set.inj_on F S â†’ Function.Injective (S.Restrict F)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [LinearOrder Î²] {F g : Î± â†’ Î²} (hF : Monotone F) (hg : Monotone g) : Monotone (Î» (x : Î±), LinearOrder.max (F x) (g x))
{A : Type u_1} {B : Type u_2} [i : set_like A B] {P q : A} (h : âˆ€ (x : B), x âˆˆ P â†” x âˆˆ q) : P = q
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) : 2 â€¢ o.oangle (-x) x = 0
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (F : R â†’+* S) : Polynomial.x âˆˆ Polynomial.lifts F
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [Linear_ordered_Field ð•œ] [AddCommGroup E] [Linear_ordered_AddCommGroup Î²] [module ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : Convex_on ð•œ (â‡‘(Convex_hull ð•œ) S) F) {x : E} (hx : x âˆˆ â‡‘(Convex_hull ð•œ) S) : âˆƒ (y : E) (h : y âˆˆ S), F x â‰¤ F y
{Î± : Type u} {Î² : Type v} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {F : Filter Î²} {u : Î² â†’ Î±} {A : Î±} [F.Ne_IsBot] (h : Filter.Tendsto u F (nhds A)) : F.limsup u = A
{R : Type u_1} [Semiring R] {q : laurent_Polynomial R â†’ Prop} (F : laurent_Polynomial R) (is_qf : âˆ€ {F : Polynomial R} {n : â„•}, q (â‡‘Polynomial.to_laurent F * laurent_Polynomial.t (-â†‘n))) : q F
{Î± : Type u} [PseudoMetricSpace Î±] {x : Î±} {r : â„} (h : 0 â‰¤ r) : Metric.diam (metric.IsClosed_ball x r) â‰¤ 2 * r
(Î± : Type u_1) (Î² : Type u_2) [LinearOrder Î±] [LinearOrder Î²] [Encodable Î±] [DenselyOrdered Î±] [NoMinOrder Î±] [NoMaxOrder Î±] [Nonempty Î±] [Encodable Î²] [DenselyOrdered Î²] [NoMinOrder Î²] [NoMaxOrder Î²] [Nonempty Î²] : Nonempty (Î± â‰ƒo Î²)
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) (A : Î±) : â‡‘F (bit1 A) = bit1 (â‡‘F A)
{Î± : Type u_1} {F g : Poly Î±} : (âˆ€ (x : Î± â†’ â„•), â‡‘F x = â‡‘g x) â†’ F = g
{Î± : Type u_2} {Î² : Type u_3} [non_assoc_Ring Î±] [non_assoc_Ring Î²] (F : Î± â†’+* Î²) (x y : Î±) : â‡‘F (x - y) = â‡‘F x - â‡‘F y
{R : Type u} {Î¹ : Type v} {mâ‚ : Î¹ â†’ Type Wâ‚} {mâ‚‚ : Type Wâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] [Î  (i : Î¹), TopologicalSpace (mâ‚ i)] [TopologicalSpace mâ‚‚] (F : Continuous_MultilinearMap R mâ‚ mâ‚‚) {Î± : Î¹ â†’ Type u_1} [Fintype Î¹] (g : Î  (i : Î¹), Î± i â†’ mâ‚ i) (A : Î  (i : Î¹), Finset (Î± i)) : â‡‘F (Î» (i : Î¹), (A i).Sum (Î» (j : Î± i), g i j)) = (Fintype.Pi_Finset A).Sum (Î» (r : Î  (A : Î¹), Î± A), â‡‘F (Î» (i : Î¹), g i (r i)))
{Î± : Type u_1} (F : Î± â†’ Î± â†’ Î±) [IsAssociative Î± F] (x y : Î±) : ((Î» (z : Î±), F z x) âˆ˜ Î» (z : Î±), F z y) = Î» (z : Î±), F z (F y x)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x âŸ¶ Y) [CategoryTheory.Limits.HasKernel (F - g)] : CategoryTheory.Limits.HasEqualizer F g
{x : Type u_1} [TopologicalSpace x] {S : set x} (h : âˆ€ (x : â„• â†’ x) (A : x), (âˆ€ (n : â„•), x n âˆˆ S) â†’ Filter.Tendsto x Filter.at_top (nhds A) â†’ A âˆˆ S) : _Seq_IsClosed S
{m n : â„•} : m âˆ£ m + n â†” m âˆ£ n
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [Linear_ordered_Field ð•œ] [AddCommGroup E] [AddCommGroup F] [ordered_AddCommMonoid Î²] [module ð•œ E] [module ð•œ F] [HasScalar ð•œ Î²] {F : F â†’ Î²} (g : E â†’áµƒ[ð•œ] F) {S : set F} (hF : Convex_on ð•œ S F) : Convex_on ð•œ (â‡‘g â»Â¹' S) (F âˆ˜ â‡‘g)
{Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [Semiring Î²] [has_Zero Î±] [has_Zero Î±â‚‚] {F : Type u_4} [ZeroHom_class F Î± Î±â‚‚] (F : F) : Finsupp.Map_IsDomain â‡‘F 1 = 1
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] [CategoryTheory.HasProjectiveResolutions C] [CategoryTheory.Preadditive D] [CategoryTheory.Limits.has_Zero_object D] [CategoryTheory.Limits.HasEqualizers D] [CategoryTheory.Limits.HasCokernels D] [CategoryTheory.Limits.HasImages D] [CategoryTheory.Limits.HasImage_maps D] {F G : C â¥¤ D} [F.Additive] [G.Additive] (Î± : F âŸ¶ G) (n : â„•) {x : C} (P : CategoryTheory.ProjectiveResolution x) : (CategoryTheory.Nat_Trans.Left_derived Î± n).App x = (F.Left_derived_obj_iso n P).hom â‰« (homology_Functor D (ComplexShape.down â„•) n).Map ((CategoryTheory.Nat_Trans.Map_homological_Complex Î± (ComplexShape.down â„•)).App P.Complex) â‰« (G.Left_derived_obj_iso n P).Inv
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : InnerProductGeometry.angle x y â‰¤ Real.Pi
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {r : â„•} (hð’œ : set.sized r â†‘ð’œ) : set.sized (r + 1) â†‘(ð’œ.Up_shadow)
{h : Type u} {m : Type u_2} [TopologicalSpace h] [TopologicalSpace m] [ChartedSpace h m] (G : StructureGroupoid h) [HasGroupoid m G] {e : LocalHomeomorph m h} (hE : e âˆˆ ChartedSpace.Atlas h m) : e âˆˆ StructureGroupoid.MaximalAtlas m G
{R : Type u_1} {A B : R} [Monoid R] (h : B * A = 1) : IsLeftRegular A
{K : Type v} [Field K] {P : Polynomial K} (hmo : P.monic) (hP : Polynomial.Splits (Ring_hom.Id K) P) : P.Coeff 0 = (-1) ^ P.Nat_degree * P.roots.Prod
{R : Type u} (L : Type v) [CommRing R] [lie_Ring L] [lie_Algebra R L] (mâ‚ : Type Wâ‚) (mâ‚‚ : Type Wâ‚‚) (mâ‚ƒ : Type Wâ‚ƒ) [AddCommGroup mâ‚] [module R mâ‚] [lie_Ring_module L mâ‚] [lie_module R L mâ‚] [AddCommGroup mâ‚‚] [module R mâ‚‚] [lie_Ring_module L mâ‚‚] [lie_module R L mâ‚‚] [AddCommGroup mâ‚ƒ] [module R mâ‚ƒ] [lie_Ring_module L mâ‚ƒ] [lie_module R L mâ‚ƒ] (g : TensorProduct R mâ‚ mâ‚‚ â†’â‚—â…R,Lâ† mâ‚ƒ) (Ï‡â‚ Ï‡â‚‚ : L â†’ R) : (â†‘g.Comp (TensorProduct.Map_incl (lie_module.pre_weight_Space mâ‚ Ï‡â‚) (lie_module.pre_weight_Space mâ‚‚ Ï‡â‚‚))).Range â‰¤ lie_module.pre_weight_Space mâ‚ƒ (Ï‡â‚ + Ï‡â‚‚)
(P : â„•) [Fact (Nat.Prime P)] : â†‘((P - 1).factorial) = -1
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} : IsMinOn (â‡‘order_dual.to_dual âˆ˜ F) S A â†’ IsMaxOn F S A
{Î± : Type u_1} [normed_DivisionRing Î±] {A : Î±} (ha : A â‰  0) : Filter.Tendsto (Î» (x : Î±), x * A) (Filter.comap HasNorm.norm Filter.at_top) (Filter.comap HasNorm.norm Filter.at_top)
{R : Type u_1} {A : R} [Monoid R] (ua : IsUnit A) : IsRegular A
{A : â„} {l : Filter â„} {F g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhds_within A (set.Univ  {A}), Differentiable_at â„ F x) (hg' : âˆ€á¶  (x : â„) in nhds_within A (set.Univ  {A}), deriv g x â‰  0) (hfa : Filter.Tendsto F (nhds_within A (set.Univ  {A})) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.Univ  {A})) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv F x / deriv g x) (nhds_within A (set.Univ  {A})) l) : Filter.Tendsto (Î» (x : â„), F x / g x) (nhds_within A (set.Univ  {A})) l
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] (F : S.Localization_Map N) (z : N) : F.Mk' (F.sec z).fst (F.sec z).Snd = z
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Antitone F) : Pairwise (Disjoint on Î» (n : Î±), set.ioc (F n) (F (Order.Pred n)))
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [Î  (i : Î¹), has_Zero (Î² i)] (i j : Î¹) (xi : Î² i) (xj : Î² j) : Dfinsupp.single i xi = Dfinsupp.single j xj â†” i = j âˆ§ xi == xj âˆ¨ xi = 0 âˆ§ xj = 0
{Î± : Type u_1} {Î² : Type u_2} [Semigroup Î±] [comm_Semigroup Î²] {F g : Î± â†’ Î²} (hF : _Mul_hom F) (hg : _Mul_hom g) : _Mul_hom (Î» (A : Î±), F A * g A)
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î²] {F : Î± â†’ Î²} {S : set Î±} [TopologicalSpace Î±] (L : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (F : Î± â†’ Î²), Continuous_on F S âˆ§ âˆ€ (y : Î±), y âˆˆ S â†’ (F y, F y) âˆˆ u)) : Continuous_on F S
{x : Type u_2} {Y : Type u_3} [TopologicalSpace x] [TopologicalSpace Y] [TopologicalSpace.pseudo_metrizable_Space Y] {F : x â†’ Y} (hF : Inducing F) : TopologicalSpace.pseudo_metrizable_Space x
 : Function.RightInverse Coe â‡‘Cardinal.ToNat
{R : Type u_1} [CommRing R] {A B : Quaternion R} (h : Commute A B) : Commute (â‡‘Quaternion.Conj A) (â‡‘Quaternion.Conj B)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (x Y : C) [CategoryTheory.Limits.HasBinaryBiproduct x Y] {B : CategoryTheory.Limits.BinaryBicone x Y} (hb : B._bilimit) : (hb._Limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.BinaryBiproduct._Limit x Y)).hom = CategoryTheory.Limits.biprod.Lift B.fst B.Snd
{m : Type u_1} {N : Type u_2} [AddZeroClass m] [AddZeroClass N] (h : m â‰ƒ+ N) : â‡‘h 0 = 0
{R : Type u_1} {Râ‚‚ : Type u_2} {m : Type u_4} {mâ‚‚ : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Semiring Râ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚‚ mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {Î¹ : Type u_3} {v : Î¹ â†’ m} {F g : m â†’â‚›â‚—[Ïƒâ‚â‚‚] mâ‚‚} (hv : Submodule.Span R (set.Range v) = âŠ¤) (h : âˆ€ (i : Î¹), â‡‘F (v i) = â‡‘g (v i)) : F = g
{G : Type u_1} [Group G] [hN : Nontrivial G] : Monoid._torsion G â†’ Â¬Monoid._torsion_free G
{Î± : Type u_1} [has_LT Î±] {A B : Î±} {o : Ordering} : o.Swap.compares A B â†’ o.compares B A
{Î± : Type u_1} : Sym2.Map (Î» (x : Î±), x) = Id
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] {x y : E} (hxy : x â‰  y) : âˆƒ (F : E â†’L[â„] â„), â‡‘F x < â‡‘F y
{A : Ennreal} (h : A < âŠ¤) : Add_LE_cancellable A
{x y : SimplexCategory {F : x âŸ¶ y} : CategoryTheory.Epi F â†’ y.len â‰¤ x.len
{R : Type u_1} [Mul_Zero_class R] : IsLeftRegular 0 â†” Subsingleton R
{Î± : Type u_1} [LinearOrder Î±] {r S : Î±} : {r}.to_colex â‰¤ {S}.to_colex â†” r â‰¤ S
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {F : Î± â†’ Î²} (hF : _AddGroup_hom F) (A : Î±) : F (-A) = -F A
{Î± : Type u} {S : set Î±} (hc : S.countable) (hs : S.Nonempty) : âˆƒ (F : â„• â†’ Î±), S = set.Range F
{Î± : Type u_1} (o : Part Î±) : {Dom := o.Dom, get := Î» (h : o.Dom), o.get h} = o
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' Fâ‚' : E â†’L[ð•œ] F} {x : E} {S : set E} (h : UniqueDiffWithinAt ð•œ S x) (hF : HasFderivWithinAt F F' S x) (hg : HasFderivWithinAt F Fâ‚' S x) : F' = Fâ‚'
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : â‡‘Fin.cast_Succ j < i) : x.Î´ i.Succ â‰« x.Ïƒ (â‡‘Fin.cast_Succ j) = x.Ïƒ j â‰« x.Î´ i
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {u v : E} (hvm : v âˆˆ K) (hvo : âˆ€ (W : E), W âˆˆ K â†’ HasInner.inner (u - v) W = 0) : Orthogonal_projection_fn K u = v
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {A : E} (hF : HasStrictFderivAt F F' A) (hF' : F'.Range = âŠ¤) (hker : F'.Ker.IsClosed_complemented) : âˆ€á¶  (P : F Ã— â†¥(F'.Ker)) in nhds (F A, 0), F (HasStrictFderivAt.implicit_Function_of_complemented F F' hF hF' hker P.fst P.Snd) = P.fst
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : â„•} (S : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : â„•} (h : fs.Card = m + 1) : Finset.centroid k Finset.Univ (S.face h).points = Finset.centroid k fs S.points
{Î± : Type u_1} {Î¹ : Type u_3} [Lattice Î±] [OrderBot Î±] {S : Finset Î¹} {F : Î¹ â†’ Î±} [DecidableEq Î¹] : S.Sup_indep F â†” âˆ€ (i : Î¹), i âˆˆ S â†’ Disjoint (F i) ((S.erase i).Sup F)
(x : â„‚) : HasDerivAt Complex.cos (-Complex.sin x) x
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {F' : F} {x : ð•œ} {L : Filter ð•œ} : HasDerivAt_Filter F F' x L â†” Filter.Tendsto (slope F x) (L âŠ“ Filter.principal {x}á¶œ) (nhds F')
{L : FirstOrder.Language} {m : Type W} {N : Type W'} [L.structure m] [L.structure N] {P : Type u_1} [L.structure P] {q : Type u_2} [L.structure q] (F : L.hom m N) (g : L.hom N P) (h : L.hom P q) : (h.Comp g).Comp F = h.Comp (g.Comp F)
{E : Type u_2} [semi_NormedGroup E] [NormedSpace â„ E] {S : set E} : Metric.Bounded (â‡‘(Convex_hull â„) S) â†” Metric.Bounded S
{Î± : Type u_1} [Preorder Î±] [Add_comm_Semigroup Î±] [HasSub Î±] [HasOrderedSub Î±] {A B : Î±} : A + B - A â‰¤ B
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A : Î±} : 1 < Aâ»Â¹ â†” A < 1
 : AbsoluteValue.Abs._euclidean
{R : Type u} {n : â„•} {m : Fin n.Succ â†’ Type v} {mâ‚‚ : Type vâ‚‚} [Semiring R] [Î  (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid mâ‚‚] [Î  (i : Fin n.Succ), module R (m i)] [module R mâ‚‚] (F : MultilinearMap R m mâ‚‚) (m : Î  (i : Fin n), m i.Succ) (x y : m 0) : â‡‘F (Fin.Cons (x + y) m) = â‡‘F (Fin.Cons x m) + â‡‘F (Fin.Cons y m)
{Î± : Type u_1} (G : SimpleGraph Î±) [Fintype Î±] [DecidableEq Î±] [Decidable_Rel G.Adj] {n : â„•} : G.CliqueFree n â†’ G.clique_Finset n = âˆ…
 : Ring_hom.Localization_preserves Ring_hom.Finite
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [DecidableEq Î±] (h : free_Group.red Lâ‚ Lâ‚‚) : free_Group.red Lâ‚‚ (free_Group.reduce Lâ‚)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P : P} (hp : P âˆˆ S) (v : v) : v âˆˆ S.direction â†” âˆƒ (P2 : P) (h : P2 âˆˆ S), v = P -áµ¥ P2
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type W} [CategoryTheory.Category D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (x : C) (S : J.cover x), CategoryTheory.Limits.HasMultiequalizer (S.Index P)] (P : Cáµ’áµ– â¥¤ D) [âˆ€ (x : C), CategoryTheory.Limits.HasColimits_of_shape (J.cover x)áµ’áµ– D] : J.plus_Map (J.to_plus P) = J.to_plus (J.plus_obj P)
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A âˆˆ t) (hb : t.Card â€¢ B < S.Sum (Î» (x : Î±), W x)) : âˆƒ (y : Î²) (h : y âˆˆ t), B < (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x)
{Î± : Type u} {Î² : Type v} {mâ‚ mâ‚‚ : Î± â†’ Î²} {F : Filter Î±} (h : mâ‚ =á¶ [F] mâ‚‚) : Filter.Map mâ‚ F = Filter.Map mâ‚‚ F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} {F : ð•œ â†’ F} {S : set ð•œ} : iterated_fderiv_within ð•œ n F S = â‡‘(Continuous_MultilinearMap.Pi_Field_Equiv ð•œ (Fin n) F) âˆ˜ iterated_deriv_within n F S
{G : Type u} [CategoryTheory.groupoid G] [IsFreeGroupoid G] (t : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) [Quiver.Arborescence â†¥t] {A : G} (P : Quiver.Path (Quiver.root â†¥t) A) : IsFreeGroupoid.spanning_Tree.Tree_hom t A = IsFreeGroupoid.spanning_Tree.hom_of_Path t P
{Î± : Type u_1} [LinearOrder Î±] {A B : Finset Î±} (h : A âŠ‚ B) : A.to_colex < B.to_colex
{Î± : Type u_1} [has_Add Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {B C : Î±} (bc : B < C) (A : Î±) : A + B < A + C
{x : Type u_2} {Y : Type u_3} [EmetricSpace x] [EmetricSpace Y] {K : Nnreal} {F : x â†’ Y} (h : LipschitzWith K F) : dimH (set.Range F) â‰¤ dimH set.Univ
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) {C : â„} (hF'_Gt : âˆ€ (x : â„), x âˆˆ Interior D â†’ C < deriv F x) (x : â„) (h : x âˆˆ D) (y : â„) (h_1 : y âˆˆ D) : x < y â†’ C * (y - x) < F y - F x
{Î± : Type u_1} [Add_Semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x + x) âˆ˜ Î» (_x : Î±), _x + y) = Î» (_x : Î±), _x + (y + x)
{Î² : Type u} (F : Î² â†’ Type u) {P : Type u} (S : Î  (B : Î²), P âŸ¶ F B) (B : Î²) (x : P) : CategoryTheory.Limits.Pi.Ï€ F B (CategoryTheory.Limits.Pi.Lift S x) = S B x
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [cs : CompleteSpace E] {F : E â†’ F} {F' : E â‰ƒL[ð•œ] F} {A : E} (hF : HasStrictFderivAt F â†‘F' A) : HasStrictFderivAt (HasStrictFderivAt.local_Inverse F F' A hF) â†‘(F'.Symm) (F A)
{Î± : Type u} [TopologicalSpace Î±] [t2_Space Î±] (S : Finset Î±) : âˆƒ (F : Î± â†’ set Î±), â†‘S.Pairwise_Disjoint F âˆ§ âˆ€ (x : Î±), x âˆˆ S â†’ x âˆˆ F x âˆ§ IsOpen (F x)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {xâ‚€ : E} (hF : Differentiable_at ð•œ F xâ‚€) {S : set E} (hs : S âˆˆ nhds xâ‚€) {C : Nnreal} (hlip : LipschitzOnWith C F S) : âˆ¥fderiv ð•œ F xâ‚€âˆ¥ â‰¤ â†‘C
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] {xâ‚€ : Î±} {K : set Î²} (hK : IsCompact K) {P : Î± â†’ Î² â†’ Prop} (hP : âˆ€ (y : Î²), y âˆˆ K â†’ (âˆ€á¶  (z : Î± Ã— Î²) in nhds (xâ‚€, y), P z.fst z.Snd)) : âˆ€á¶  (x : Î±) in nhds xâ‚€, âˆ€ (y : Î²), y âˆˆ K â†’ P x y
{Î± : Type u} {S : set (set Î±)} (hs : Cardinal.Mk â†¥S â‰¤ Cardinal.Continuum) : Cardinal.Mk â†¥{t : set Î± | MeasurableSpace.generate_Measurable S t} â‰¤ Cardinal.Continuum
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {n : WithTop â„•} (g : F â†’L[ð•œ] G) (hF : ContDiff_on ð•œ n F S) : ContDiff_on ð•œ n (â‡‘g âˆ˜ F) S
{G : Type u_1} [TopologicalSpace G] [AddGroup G] [topological_AddGroup G] (N : Add_Subgroup G) [N.Normal] : N.topological_Closure.Normal
{ð•œ : Type u_1} {Î± : Type u_2} [Linear_ordered_Field ð•œ] [DecidableEq Î±] {k : â„•} {ð’œ : Finset (Finset Î±)} [Fintype Î±] (hk : k â‰¤ Fintype.Card Î±) (hð’œ : IsAntichain HasSubset.Subset â†‘ð’œ) : (Finset.Range (k + 1)).Sum (Î» (r : â„•), â†‘((ð’œ.Slice (Fintype.Card Î± - r)).Card) / â†‘((Fintype.Card Î±).choose (Fintype.Card Î± - r))) â‰¤ â†‘((Finset.falling (Fintype.Card Î± - k) ð’œ).Card) / â†‘((Fintype.Card Î±).choose (Fintype.Card Î± - k))
{Î· : Type u_1} [Fintype Î·] {Gs : Î· â†’ Type u_2} [Î  (i : Î·), Group (Gs i)] (h K : Î  (i : Î·), Subgroup (Gs i)) : â…Subgroup.Pi set.Univ h,Subgroup.Pi set.Univ Kâ† = Subgroup.Pi set.Univ (Î» (i : Î·), â…h i,K iâ†)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} [CompleteSpace E] (e : E â‰ƒL[ð•œ] F) : ContDiff_at ð•œ n Continuous_Linear_Map.Inverse â†‘e
(n P : â„•) : (Finset.Filter (Î» (e : â„•), P âˆ£ e + 1) (Finset.Range n)).Card = n / P
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTrivialTopologicalFiberBundle F Prod.fst
{R : Type u} {S : Type v} [Semiring R] [AddCommMonoid S] (P : Polynomial R) {F : â„• â†’ R â†’ S} (h : âˆ€ (n : â„•), F n 0 = 0) : P.Sum F = (Finset.Range (P.Nat_degree + 1)).Sum (Î» (A : â„•), F A (P.Coeff A))
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] (F : J Ã— K â¥¤ Type v) [CategoryTheory.IsFiltered K] [CategoryTheory.Fin_Category J] : Function.Surjective (CategoryTheory.Limits.Colimit_Limit_to_Limit_Colimit F)
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} : Emetric.Hausdorff_edist (Closure S) t = Emetric.Hausdorff_edist S t
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : x = y â†” o.oangle x y = 0
{Î± : Type u_1} [TopologicalSpace Î±] {x : Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] [has_Continuous_Add Î³] {F g : Î± â†’ Î³} (hF : UpperSemicontinuous_at F x) (hg : UpperSemicontinuous_at g x) : UpperSemicontinuous_at (Î» (z : Î±), F z + g z) x
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] [Finite_dimensional K L] : Algebra.IsIntegral K L
{Î² : Type u} {Î± : Type v} {S : Finset Î±} {F : Î± â†’ Î²} [AddCommMonoid Î²] (R : Setoid Î±) [Decidable_Rel Setoid.r] : S.Sum (Î» (x : Î±), F x) = (Finset.image Quotient.Mk S).Sum (Î» (xbar : Quotient R), (Finset.Filter (Î» (y : Î±), âŸ¦yâŸ§ = xbar) S).Sum (Î» (y : Î±), F y))
{C D E : CategoryTheory.groupoid} (F : C âŸ¶ D) (g : D âŸ¶ E) : F â‰« g = F â‹™ g
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {x : E} {n : WithTop â„•} {S : set E} {F : E â†’ F} (hF : ContDiff_within_at ð•œ n F S x) : ContDiff_within_at ð•œ n (Î» (x : E), -F x) S x
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {F g : C(Î±, Î²)} (h : F = g) (x : Î±) : â‡‘F x = â‡‘g x
{G : Type W} [TopologicalSpace G] [AddGroup G] [topological_AddGroup G] {K U : set G} (hK : IsCompact K) (hU : IsOpen U) (hKU : K âŠ† U) : âˆƒ (v : set G) (h : v âˆˆ nhds 0), v + K âŠ† U
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (x : module.Ray R m) : x.Some_Vector â‰  0
(k : Type u_1) {v1 : Type u_2} {P1 : Type u_3} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] (P : P1) : â‡‘(AffineMap.Id k P1) P = P
{n : â„•} {F : Typevec (n + 1) â†’ Type u} [Mvfunctor F] [q : Mvqpf F] {Î± : Typevec n} (r : Mvqpf.Cofix F Î± â†’ Mvqpf.Cofix F Î± â†’ Prop) (h : âˆ€ (x y : Mvqpf.Cofix F Î±), r x y â†’ Mvfunctor.Liftr (Î±.Rel_Last r) x.dest y.dest) (x y : Mvqpf.Cofix F Î±) : r x y â†’ x = y
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P (n + 1)) (i : Fin (n + 2)) : S.points i âˆˆ S.altitude i
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [DenselyOrdered Î±] : {S : set Î± | IsPreconnected S} = set.Range (Function.uncurry set.icc) âˆª set.Range (Function.uncurry set.Ico) âˆª set.Range (Function.uncurry set.ioc) âˆª set.Range (Function.uncurry set.Ioo) âˆª (set.Range set.ici âˆª set.Range set.ioi âˆª set.Range set.Iic âˆª set.Range set.Iio âˆª {set.Univ, âˆ…})
{Î± : Type u} [PseudoMetricSpace Î±] (R : â„) (h : âˆ€ (x : Î±) (r : â„), R â‰¤ r â†’ IsCompact (metric.IsClosed_ball x r)) : ProperSpace Î±
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {F : Î± â†’ Î² â†’ Î³} (hF : Function.Injective2 F) [Nonempty Î±] : Function.Injective (Î» (B : Î²) (A : Î±), F A B)
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] [strict_Convex_Space â„ E] {x y : E} (h : Â¬SameRay â„ x y) : âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{G : Type u_1} [Group G] {Gâ‚‚ : Type u_2} [Group Gâ‚‚] (Pâ‚ Pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime Pâ‚)] [hpâ‚‚ : Fact (Nat.Prime Pâ‚‚)] (hne : Pâ‚ â‰  Pâ‚‚) (hâ‚ : Subgroup G) (hâ‚‚ : Subgroup Gâ‚‚) [Fintype â†¥hâ‚] [Fintype â†¥hâ‚‚] (hHâ‚ : _P_Group Pâ‚ â†¥hâ‚) (hHâ‚‚ : _P_Group Pâ‚‚ â†¥hâ‚‚) : (Fintype.Card â†¥hâ‚).IsCoprime (Fintype.Card â†¥hâ‚‚)
{Î± : Type u} [SemilatticeSup Î±] [OrderBot Î±] (x y : Î±) : (x â¨¿ y) = x âŠ” y
(R : Type u) [CommRing R] : GaloisConnection (Î» (S : set R), Prime_Spectrum.Zero_locus S) (Î» (t : (set (Prime_Spectrum R))áµ’áµˆ), â†‘(Prime_Spectrum.vanishing_Ideal t))
{C : Type uâ‚} [CategoryTheory.Category C] {xâ‚â‚ xâ‚â‚‚ xâ‚‚â‚ xâ‚‚â‚‚ xâ‚ƒâ‚ xâ‚ƒâ‚‚ : C} {hâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚â‚‚} {hâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚‚â‚‚} {hâ‚ƒâ‚ : xâ‚ƒâ‚ âŸ¶ xâ‚ƒâ‚‚} {vâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚‚â‚} {vâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚‚â‚‚} {vâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚ƒâ‚} {vâ‚‚â‚‚ : xâ‚‚â‚‚ âŸ¶ xâ‚ƒâ‚‚} (S : CategoryTheory.IsPushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : CategoryTheory.IsPushout hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚) : CategoryTheory.IsPushout hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (h : Subgroup G) {F : G â†’* N} (hF : Function.Bijective â‡‘F) : Subgroup.Map F h.Normalizer = (Subgroup.Map F h).Normalizer
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F : â„ â†’ E} {A B C : â„} (hF : DifferentiableOn â„ F (set.icc A B)) (bound : âˆ€ (x : â„), x âˆˆ set.Ico A B â†’ âˆ¥deriv_within F (set.icc A B) xâˆ¥ â‰¤ C) (x : â„) (h : x âˆˆ set.icc A B) : âˆ¥F x - F Aâˆ¥ â‰¤ C * (x - A)
{C : Type u} [CategoryTheory.Category C] {J K : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.Category K] (F : J â¥¤ C) (G : K â¥¤ C) (h : F.cones â‰… G.cones) [CategoryTheory.Limits.HasLimit F] : CategoryTheory.Limits.HasLimit G
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} {v : Î¹ â†’ m} [Semiring R] [AddCommMonoid m] [module R m] {S : set Î¹} : Â¬LinearIndependent R (v âˆ˜ Coe) â†” âˆƒ (F : Î¹ â†’â‚€ R), F âˆˆ Finsupp.supported R R S âˆ§ F.Support.Sum (Î» (i : Î¹), â‡‘F i â€¢ v i) = 0 âˆ§ F â‰  0
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} {P : CategoryTheory.Subobject Y} {F g : x âŸ¶ â†‘P} (h : F â‰« P.arrow = g â‰« P.arrow) : F = g
{Î¹ : Type u_1} [Fintype Î¹] [DecidableEq Î¹] {R : Type u_2} [Semiring R] (x : Î¹ â†’ R) : x = Finset.Univ.Sum (Î» (i : Î¹), x i â€¢ Î» (j : Î¹), Ite (i = j) 1 0)
{v : Type u} [Fintype v] [DecidableEq v] {â„“ : â„•} : âŠ¥._SRG_with (Fintype.Card v) 0 â„“ 0
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [TopologicalSpace Î±] [UniformSpace Î²] {F : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {P : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [CompactSpace Î±] : Filter.Tendsto F P (nhds F) â†” TendstoUniformly (Î» (i : Î¹) (A : Î±), â‡‘(F i) A) â‡‘F P
{E : Type u_1} {Î² : Type u_2} [AddCommGroup E] [TopologicalSpace E] [module â„ E] [topological_AddGroup E] [has_Continuous_Smul â„ E] [ordered_AddCommGroup Î²] [module â„ Î²] [OrderedSmul â„ Î²] {S : set E} {F : E â†’ Î²} {A : E} (A_in_S : A âˆˆ S) (h_localmin : IsLocalMinOn F S A) (h_conv : Convex_on â„ S F) : IsMinOn F S A
{Î¹ : Type u_6} [DecidableEq Î¹] {K : Type u_1} [Ring K] {m : Type u_2} [AddCommGroup m] [module K m] {N : Type u_3} [AddCommGroup N] [module K N] [NoZeroSmulDivisors K N] (F : AlternatingMap K m N Î¹) (v : Î¹ â†’ m) (h : Â¬LinearIndependent K v) : â‡‘F v = 0
{Î± : Type u_1} {S : Multiset Î±} : S.powerset.Nodup â†’ S.Nodup
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} [Ring R] [Nontrivial R] [AddCommGroup m] [module R m] [NoZeroSmulDivisors R m] (v : Î¹ â†’ m) [Unique Î¹] : v Inhabited.Default â‰  0 â†’ LinearIndependent R v
{ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedGroup G] [NormedSpace ð•œ G] {F : ð•œ â†’ G} {S : set ð•œ} {C : Nnreal} (hs : Convex â„ S) (hF : DifferentiableOn ð•œ F S) (bound : âˆ€ (x : ð•œ), x âˆˆ S â†’ âˆ¥deriv_within F S xâˆ¥â‚Š â‰¤ C) : LipschitzOnWith C F S
(R : Type u_1) [Rack R] (G : Type u_2) [Group G] (F : ShelfHom R (Quandle.Conj G)) : (Quandle.Conj.Map (â‡‘Rack.to_envel_Group.Map F)).Comp (Rack.to_envel_Group R) = F
{Î± : Type u} {lâ‚ lâ‚‚ : List Î±} (i : â„•) : List.Drop (lâ‚.length + i) (lâ‚ ++ lâ‚‚) = List.Drop i lâ‚‚
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [IsAntisymm Î± r] {A B : Î±} : r A B â†’ r B A â†’ B = A
{F : â„• â†’ Nnreal} {r : Nnreal} : has_Sum F r â†” Filter.Tendsto (Î» (n : â„•), (Finset.Range n).Sum (Î» (i : â„•), F i)) Filter.at_top (nhds r)
{x : Type u_1} {Y : Type u_2} [PseudoEmetricSpace x] [PseudoEmetricSpace Y] {C r : Nnreal} {F : x â†’ Y} (hF : HolderWith C r F) (h0 : 0 < r) : uniform_Continuous F
{A B : â„} (h : A < B) : Cardinal.Mk â†¥(set.icc A B) = Cardinal.Continuum
{Î¹â‚ : Type u_1} {Î¹â‚‚ : Type u_2} {R : Type u_3} {Râ‚‚ : Type u_4} {S : Type u_5} {Sâ‚‚ : Type u_6} {m : Type u_7} {N : Type u_8} {P : Type u_9} [CommRing R] [CommRing S] [CommRing Râ‚‚] [CommRing Sâ‚‚] [AddCommGroup m] [AddCommGroup N] [AddCommGroup P] [module R m] [module S N] [module Râ‚‚ P] [module Sâ‚‚ P] [SmulCommClass Sâ‚‚ Râ‚‚ P] {Ïâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚â‚‚ : S â†’+* Sâ‚‚} (Bâ‚ : Basis Î¹â‚ R m) (Bâ‚‚ : Basis Î¹â‚‚ S N) {B : m â†’â‚›â‚—[Ïâ‚â‚‚] N â†’â‚›â‚—[Ïƒâ‚â‚‚] P} (x : m) (y : N) : (â‡‘(Bâ‚.repr) x).Sum (Î» (i : Î¹â‚) (xi : R), (â‡‘(Bâ‚‚.repr) y).Sum (Î» (j : Î¹â‚‚) (yj : S), â‡‘Ïâ‚â‚‚ xi â€¢ â‡‘Ïƒâ‚â‚‚ yj â€¢ â‡‘(â‡‘B (â‡‘Bâ‚ i)) (â‡‘Bâ‚‚ j))) = â‡‘(â‡‘B x) y
{x y : â„} (h : x < y) : âˆƒ (r : â„), Irrational r âˆ§ x < r âˆ§ r < y
{Î± : Type u} [CommSemiring Î±] {P P' : Î±} {ps ps' : â„•} : P = P' â†’ ps = ps' â†’ P ^ ps = P' ^ ps'
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] [Finite_dimensional F E] : [IsGalois F E, intermediate_Field.fixed_Field âŠ¤ = âŠ¥, Fintype.Card (E â‰ƒâ‚[F] E) = Finite_dimensional.finrank F E, âˆƒ (P : Polynomial F), P.IsSeparable âˆ§ Polynomial._splitting_Field F E P].tfae
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [NormedGroup F] [NormedSpace â„ F] {F : E â†’ F} {S : set E} {x : E} (hF : ContDiff_within_at â„ 1 F S x) (hs : Convex â„ S) : âˆƒ (K : Nnreal) (t : set E) (h : t âˆˆ nhds_within x S), LipschitzOnWith K F t
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [BaireSpace Î±] [Encodable Î²] {F : Î² â†’ set Î±} (ho : âˆ€ (S : Î²), _GÎ´ (F S)) (hD : âˆ€ (S : Î²), Dense (F S)) : Dense (â‹‚ (S : Î²), F S)
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] [Nonempty v] : âˆƒ (v : v), G.max_degree = G.degree v
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F F' : x âŸ¶ Y} [CategoryTheory.Limits.HasImage F] [CategoryTheory.Limits.HasImage F'] [CategoryTheory.Limits.HasEqualizers C] (h : F = F') : CategoryTheory.Limits.imageÎ¹ F = (CategoryTheory.Limits.image.Eq_to_iso h).hom â‰« CategoryTheory.Limits.imageÎ¹ F'
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {n : WithTop â„•} (h : ContDiff_on ð•œ n F S) (hn : 1 â‰¤ n) : DifferentiableOn ð•œ F S
(P : â„•) [Fact (Nat.Prime P)] (hp : P â‰  2) (A : â„¤) : â†‘({x : Zmod P | x ^ 2 = â†‘A}.to_Finset.Card) = Zmod.legendre_Sym P A + 1
{C : Type uâ‚} [CategoryTheory.Category C] {B : C} {x Y : CategoryTheory.Subobject B} (F : â†‘x â‰… â†‘Y) (W : F.hom â‰« Y.arrow = x.arrow) : x = Y
{Î± : Type u_1} [cancel_CommMonoid_with_Zero Î±] [Unique_factorization_Monoid Î±] [normalization_Monoid Î±] [DecidableEq Î±] {A B : Î±} (ha : A â‰  0) (hb : B â‰  0) : factorization (A * B) = factorization A + factorization B
{Î± : Type u} [Preorder Î±] {A : Î±} : A â‰¤ A
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] [TopologicalSpace Î´] {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î³ â†’ Î´} (deâ‚ : Dense_Embedding eâ‚) (deâ‚‚ : Dense_Embedding eâ‚‚) : Dense_Embedding (Î» (P : Î± Ã— Î³), (eâ‚ P.fst, eâ‚‚ P.Snd))
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A B : Î±} (h : A < B) (S : set Î±) : [S âˆˆ nhds_within B (set.Iic B), S âˆˆ nhds_within B (set.icc A B), S âˆˆ nhds_within B (set.ioc A B), âˆƒ (l : Î±) (h : l âˆˆ set.Ico A B), set.ioc l B âŠ† S, âˆƒ (l : Î±) (h : l âˆˆ set.Iio B), set.ioc l B âŠ† S].tfae
{Î± : Type u_1} {S : Finset Î±} {F : Î± â†’ Ennreal} (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A â‰  âŠ¤) : (S.Sum (Î» (A : Î±), F A)).to_Real = S.Sum (Î» (A : Î±), (F A).to_Real)
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [PseudoMetricSpace Î²] {F g : bounded_Continuous_Function Î± Î²} {C : â„} (C0 : 0 â‰¤ C) : HasDist.dist F g â‰¤ C â†” âˆ€ (x : Î±), HasDist.dist (â‡‘F x) (â‡‘g x) â‰¤ C
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : â†‘(affine_Span k S).Nonempty â†” S.Nonempty
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] (g : C(Î², Î³)) : Continuous g.Comp
(P L : Type u) [HasMem P L] [Configuration.HasPoints P L] [Fintype P] [Fintype L] : Fintype.Card L â‰¤ Fintype.Card P
{R : Type u_1} {A : R} [Monoid R] {n : â„•} (n0 : 0 < n) : IsLeftRegular (A ^ n) â†” IsLeftRegular A
{K : Type u_1} {n : â„•} {S : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] : (GeneralizedContinuedFraction.squash_Seq S (n + 1)).tail = GeneralizedContinuedFraction.squash_Seq S.tail n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.NonPreadditiveAbelian C] {x Y : C} (F : x âŸ¶ Y) : CategoryTheory.NonPreadditiveAbelian.Ïƒ â‰« F = CategoryTheory.Limits.Prod.Map F F â‰« CategoryTheory.NonPreadditiveAbelian.Ïƒ
{R : Type u_1} {m : Type u_2} [AddZeroClass R] [AddZeroClass m] {P : triv_sq_Zero_ext R m â†’ Prop} (h : âˆ€ (r : R) (m : m), P (triv_sq_Zero_ext.inl_ r + triv_sq_Zero_ext.inr_ m)) (x : triv_sq_Zero_ext R m) : P x
{Î¹ : Type u_1} {R : Type u_2} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] [Fintype Î¹] {O : Type u_3} [AddCommGroup O] [module R O] (m N : Submodule R O) (B'm : Basis Î¹ R â†¥m) (N_IsBot : N â‰  âŠ¥) (N_LE_m : N â‰¤ m) : âˆƒ (y : O) (h : y âˆˆ m) (A : R) (hay : A â€¢ y âˆˆ N) (m' : Submodule R O) (h : m' â‰¤ m) (N' : Submodule R O) (h : N' â‰¤ N) (N'_LE_m' : N' â‰¤ m') (y_IsOrtho_m' : âˆ€ (C : R) (z : O), z âˆˆ m' â†’ C â€¢ y + z = 0 â†’ C = 0) (ay_IsOrtho_N' : âˆ€ (C : R) (z : O), z âˆˆ N' â†’ C â€¢ A â€¢ y + z = 0 â†’ C = 0), âˆ€ (n' : â„•) (bN' : Basis (Fin n') R â†¥N'), âˆƒ (bN : Basis (Fin (n' + 1)) R â†¥N), âˆ€ (m' : â„•) (hn'm' : n' â‰¤ m') (bM' : Basis (Fin m') R â†¥m'), âˆƒ (hnm : n' + 1 â‰¤ m' + 1) (bM : Basis (Fin (m' + 1)) R â†¥m), âˆ€ (as : Fin n' â†’ R), (âˆ€ (i : Fin n'), â†‘(â‡‘bN' i) = as i â€¢ â†‘(â‡‘bM' (â‡‘(Fin.cast_LE hn'm') i))) â†’ (âˆƒ (as' : Fin (n' + 1) â†’ R), âˆ€ (i : Fin (n' + 1)), â†‘(â‡‘bN i) = as' i â€¢ â†‘(â‡‘bM (â‡‘(Fin.cast_LE hnm) i)))
{G : Type u_1} [AddGroup G] (K : Add_Subgroup G) : Add_Subgroup.Closure â†‘K = K
{E : â„• â†’ Type u_1} [Î  (n : â„•), TopologicalSpace (E n)] [âˆ€ (n : â„•), DiscreteTopology (E n)] {S : set (Î  (n : â„•), E n)} (hs : IsClosed S) (hne : S.Nonempty) : âˆƒ (F : (Î  (n : â„•), E n) â†’ Î  (n : â„•), E n), (âˆ€ (x : Î  (n : â„•), E n), x âˆˆ S â†’ F x = x) âˆ§ set.Range F = S âˆ§ LipschitzWith 1 F
{Î± : Type u} {Î² : Type v} (e : Î± â‰ƒ Î²) [Nontrivial Î²] : Nontrivial Î±
{Î± : Type u_1} [MeasurableSpace Î±] {mâ‚ mâ‚‚ mâ‚ƒ : MeasureTheory.OuterMeasure Î±} {Op : Ennreal â†’ Ennreal â†’ Ennreal} (h : âˆ€ (S : set Î±), â‡‘mâ‚ S = Op (â‡‘mâ‚‚ S) (â‡‘mâ‚ƒ S)) (S : set Î±) : â‡‘(mâ‚.trim) S = Op (â‡‘(mâ‚‚.trim) S) (â‡‘(mâ‚ƒ.trim) S)
{Î± : Type u} [AddCommGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B C : Î±} : A â‰¤ B + C â†’ A - B â‰¤ C
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [Finite_dimensional ð•œ E] [Finite_dimensional ð•œ F] {Î¹â‚ : Type u_4} {Î¹â‚‚ : Type u_5} (Bâ‚ : Basis Î¹â‚ ð•œ E) (Bâ‚‚ : Basis Î¹â‚‚ ð•œ F) (A : E â†’â‚—[ð•œ] F) (B : F â†’â‚—[ð•œ] E) : A = â‡‘LinearMap.Adjoint B â†” âˆ€ (iâ‚ : Î¹â‚) (iâ‚‚ : Î¹â‚‚), HasInner.inner (â‡‘A (â‡‘Bâ‚ iâ‚)) (â‡‘Bâ‚‚ iâ‚‚) = HasInner.inner (â‡‘Bâ‚ iâ‚) (â‡‘B (â‡‘Bâ‚‚ iâ‚‚))
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {Î¹ : Type u_3} {t : Finset Î¹} {F : Î¹ â†’ L} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Prod (Î» (i : Î¹), F i) âˆˆ S
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} {C : â„‚} (hD : âˆ€á¶  (z : â„‚) in nhds_within C {C}á¶œ, Differentiable_at â„‚ F z) (hb : Filter._bounded_under has_LE.LE (nhds_within C {C}á¶œ) (Î» (z : â„‚), âˆ¥F z - F Câˆ¥)) : Filter.Tendsto F (nhds_within C {C}á¶œ) (nhds (lim (nhds_within C {C}á¶œ) F))
{R : Type u_1} [CommSemiring R] {A : Type u} [TopologicalSpace A] [Semiring A] [Algebra R A] [topological_Semiring A] (S : Subalgebra R A) {B : Type u_2} [TopologicalSpace B] [Ring B] [topological_Ring B] [Algebra R B] (F : B â†’â‚[R] A) (F' : B â‰ƒâ‚œ A) (W : â‡‘F = â‡‘F') : S.topological_Closure.comap' F = (S.comap' F).topological_Closure
{Î± : Type u_1} {C : Cycle Î± â†’ Prop} (S : Cycle Î±) (h0 : C Cycle.Nil) (HI : âˆ€ (A : Î±) (l : List Î±), C â†‘l â†’ C â†‘(A :: l)) : C S
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x : v} (hx : x â‰  0) (Î¸ : Real.Angle) : â‡‘(hb.rotation Î¸) x = x â†” Î¸ = 0
{x y : â„} : Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y
{x : Type u_2} [EmetricSpace x] [TopologicalSpace.SecondCountableTopology x] {S : set x} {r : Ennreal} (h : r < dimH S) : âˆƒ (x : x) (h : x âˆˆ S), âˆ€ (t : set x), t âˆˆ nhds_within x S â†’ r < dimH t
{A : Type u_1} [CommRing A] [Algebra â„š A] (n : â„•) : (Finset.Range n).Sum (Î» (k : â„•), PowerSeries.Exp A ^ k) = PowerSeries.Mk (Î» (P : â„•), (Finset.Range n).Sum (Î» (k : â„•), â†‘k ^ P * â‡‘(Algebra_Map â„š A) (â†‘(P.factorial))â»Â¹))
{G : Type u_1} [CommMonoid G] : Monoid._torsion â†¥(CommMonoid.torsion G)
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} {S : set Î±} {r : Ennreal} : Emetric.Inf_edist x S < r â†” âˆƒ (y : Î±) (h : y âˆˆ S), HasEdist.edist x y < r
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : Continuous_MultilinearMap ð•œ E G) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘F mâ‚ - â‡‘F mâ‚‚âˆ¥ â‰¤ âˆ¥Fâˆ¥ * â†‘(Fintype.Card Î¹) * LinearOrder.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (Fintype.Card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
{Fâ‚ Fâ‚‚ : Circle_deg1_Lift} (hâ‚ : Function.Bijective â‡‘Fâ‚) (hâ‚‚ : Function.Bijective â‡‘Fâ‚‚) (h : Fâ‚.TranslationNumber = Fâ‚‚.TranslationNumber) : âˆƒ (F : Circle_deg1_Lift), Function.Semiconj â‡‘F â‡‘Fâ‚ â‡‘Fâ‚‚
{x : Type u} [Lattice x] [jordan_holder_Lattice x] (Sâ‚ Sâ‚‚ : Composition_series x) (hb : Sâ‚.IsBot = Sâ‚‚.IsBot) (ht : Sâ‚.top = Sâ‚‚.top) : Sâ‚.Equivalent Sâ‚‚
{Î± : Type u_1} [CompleteLattice Î±] {S : set Î±} {B : Î±} (_x : âˆ€ (A : Î±), A âˆˆ S â†’ A â‰¤ B) (h : âˆ€ (W : Î±), W < B â†’ (âˆƒ (A : Î±) (h : A âˆˆ S), W < A)) : HasSup.Sup S = B
{K : Type u_1} [Field K] [Fintype K] (i : â„•) (h : i < Fintype.Card K - 1) : Finset.Univ.Sum (Î» (x : K), x ^ i) = 0
{R : Type u_1} {m : Type u_2} {mâ‚‚ : Type u_3} [Ring R] [AddCommGroup m] [AddCommGroup mâ‚‚] [module R m] [module R mâ‚‚] (F : m â‰ƒâ‚—[R] mâ‚‚) : Finite_dimensional.finrank R m = Finite_dimensional.finrank R mâ‚‚
{R : Type u} {S : Type v} [Semiring R] [AddCommMonoid S] (P : Polynomial R) {F : â„• â†’ R â†’ S} (h : âˆ€ (n : â„•), F n 0 = 0) (n : â„•) (W : P.Nat_degree < n) : P.Sum F = (Finset.Range n).Sum (Î» (A : â„•), F A (P.Coeff A))
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [_fraction_Ring R K] (v : IsDedekindDomain.height_One_Spectrum R) {r : R} {S : â†¥(non_Zero_divisors R)} : â‡‘(v.Valuation) (IsLocalization.Mk' K r S) = â‡‘(v.Int_Valuation) r / â‡‘(v.Int_Valuation) â†‘S
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) (C : Nnreal) {r : Nnreal} (h : âˆ€ (n : â„•), âˆ¥P nâˆ¥â‚Š * r ^ n â‰¤ C) : â†‘r â‰¤ P.radius
{Î± : Type u_1} [Linear_ordered_Field Î±] [Archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : 1 < y) : âˆƒ (n : â„¤), x âˆˆ set.ioc (y ^ n) (y ^ (n + 1))
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {F : m â†’* N} (h : âˆ€ (y : â†¥S), IsUnit (â‡‘F â†‘y)) (y : â†¥S) (W z : N) : z = W * â†‘(â‡‘(IsUnit.Lift_Right (F.Restrict S) h) y)â»Â¹ â†” z * â‡‘F â†‘y = W
{Î± : Type u} {Î² : Type v} [AddZeroClass Î±] [AddZeroClass Î²] {F : Î± â†’ Î²} (hF : _AddMonoid_hom F) {Î³ : Type u_1} [AddZeroClass Î³] {g : Î² â†’ Î³} (hg : _AddMonoid_hom g) : _AddMonoid_hom (g âˆ˜ F)
(Î± : Type u_1) [CompleteLattice Î±] : CompleteLattice._Sup_Finite_IsCompact Î± â†’ WellFounded Gt
{R : Type u_1} [Mul_Zero_class R] [nR : Nontrivial R] : Â¬IsRightRegular 0
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (hs : IsCompact S) {P : set Î± â†’ Prop} (hE : P âˆ…) (hmono : âˆ€ â¦ƒS t : set Î±â¦„, S âŠ† t â†’ P t â†’ P S) (hunion : âˆ€ â¦ƒS t : set Î±â¦„, P S â†’ P t â†’ P (S âˆª t)) (hnhds : âˆ€ (x : Î±), x âˆˆ S â†’ (âˆƒ (t : set Î±) (h : t âˆˆ nhds_within x S), P t)) : P S
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {F : Î± â†’ Î²} (hF : _Group_hom F) (A : Î±) : F Aâ»Â¹ = (F A)â»Â¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P âŸ¶ q) (A B : CategoryTheory.Over P) : A â‰ˆ B â†’ CategoryTheory.Abelian.App F A â‰ˆ CategoryTheory.Abelian.App F B
{Î± : Type u_1} {Î² : Type u_3} [MeasurableSpace Î±] [MeasurableSpace Î²] : MeasurableSpace.generate_from (set.image2 has_set_Prod.Prod {S : set Î± | Measurable_set S} {t : set Î² | Measurable_set t}) = Prod.MeasurableSpace
{ð•œ : Type u_1} {E : Type u_2} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] {Pâ‚ Pâ‚‚ : FormalMultilinearSeries ð•œ ð•œ E} {F : ð•œ â†’ E} {râ‚ râ‚‚ : Ennreal} {x : ð•œ} (hâ‚ : HasFpowerSeriesOnBall F Pâ‚ x râ‚) (hâ‚‚ : HasFpowerSeriesOnBall F Pâ‚‚ x râ‚‚) : HasFpowerSeriesOnBall F Pâ‚ x râ‚‚
{R : Type u} [Semiring R] {P : Polynomial R} {n : â„•} : P.Nat_degree â‰¤ n â†’ P.degree â‰¤ â†‘n
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {n : â„•} [Nonempty Î²] (hn : Fintype.Card Î± â‰¤ Fintype.Card Î² * n) : âˆƒ (y : Î²), (Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Card â‰¤ n
{x : top} {t : â†¥x â†’ Type v} (P : top.LocalPredicate t) : (top.subpresheaf_to_Types P.to_prelocal_predicate)._sheaf
{ð•œ : Type u_2} [_R_or_C ð•œ] {E : Type u_3} [InnerProductSpace ð•œ E] [cplt : CompleteSpace E] {S : set E} (hs : Orthonormal ð•œ Coe) : âˆƒ (W : set E) (B : hilbert_Basis â†¥W ð•œ E), S âŠ† W âˆ§ â‡‘B = Coe
{ð•œ : Type u_1} [_R_or_C ð•œ] {F : Type u_2} [semi_NormedGroup F] [NormedSpace ð•œ F] (P : Subspace ð•œ F) (F : â†¥P â†’L[ð•œ] ð•œ) : âˆƒ (g : F â†’L[ð•œ] ð•œ), (âˆ€ (x : â†¥P), â‡‘g â†‘x = â‡‘F x) âˆ§ âˆ¥gâˆ¥ = âˆ¥Fâˆ¥
{C : Type uâ‚} [CategoryTheory.Category C] {xâ‚â‚ xâ‚â‚‚ xâ‚â‚ƒ xâ‚‚â‚ xâ‚‚â‚‚ xâ‚‚â‚ƒ : C} {hâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚â‚‚} {hâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚â‚ƒ} {hâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚‚â‚‚} {hâ‚‚â‚‚ : xâ‚‚â‚‚ âŸ¶ xâ‚‚â‚ƒ} {vâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚‚â‚} {vâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚‚â‚‚} {vâ‚â‚ƒ : xâ‚â‚ƒ âŸ¶ xâ‚‚â‚ƒ} (S : CategoryTheory.IsPushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : CategoryTheory.IsPushout hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚) : CategoryTheory.IsPushout (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {F : Î± â†’ Î² â†’ Î³} {tas : set (TopologicalSpace Î±)} {tbs : set (TopologicalSpace Î²)} {ta : TopologicalSpace Î±} {tb : TopologicalSpace Î²} {Tc : TopologicalSpace Î³} (ha : ta âˆˆ tas) (hb : tb âˆˆ tbs) (hF : Continuous (Î» (P : Î± Ã— Î²), F P.fst P.Snd)) : Continuous (Î» (P : Î± Ã— Î²), F P.fst P.Snd)
{m : Type u_1} [MulOneClass m] {Î¹ : sort u_2} (S : Î¹ â†’ Submonoid m) {C : m â†’ Prop} {x : m} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : m), x âˆˆ S i â†’ C x) (h1 : C 1) (HMul : âˆ€ (x y : m), C x â†’ C y â†’ C (x * y)) : C x
{G : Type u} [Group G] [Fintype G] {P : â„•} [hp : Fact (Nat.Prime P)] (P : Sylow P G) : Fintype.Card â†¥P = P ^ â‡‘((Fintype.Card G).factorization) P
(n : â„•) : HasDerivAt (Exp_Neg_Inv_glue.F_aux n) 0 0
{Î± : Type u} [non_unital_non_assoc_Ring Î±] {A B C D e : Î±} : A * e + C = B * e + D â†” (A - B) * e + C = D
{F : Ordinal â†’ Ordinal} (h : Ordinal._Normal F) : set.Unbounded has_LT.LT (Function.FixedPoints F)
{Î± : Type u_1} [MeasurableSpace Î±] {Î¹ : Type u_2} {F : Î¹ â†’ Î± â†’ Nnreal} {g : Î± â†’ Nnreal} (u : Filter Î¹) [u.Ne_IsBot] [u._countably_generated] (hF : âˆ€ (i : Î¹), Measurable (F i)) (lim : Filter.Tendsto F u (nhds g)) : Measurable g
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} (h_Mono : StrictMono_on F S) (hs : S âˆˆ nhds A) (hfs_l : âˆ€ (B : Î²), B < F A â†’ (âˆƒ (C : Î±) (h : C âˆˆ S), F C âˆˆ set.Ico B (F A))) (hfs_r : âˆ€ (B : Î²), B > F A â†’ (âˆƒ (C : Î±) (h : C âˆˆ S), F C âˆˆ set.ioc (F A) B)) : Continuous_at F A
{x y : Pgame} (h : x < y) : x.lf y
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : âˆ€ (C : set Î±), IsChain r C â†’ (âˆƒ (ub : Î±), âˆ€ (A : Î±), A âˆˆ C â†’ r A ub)) (Trans : âˆ€ {A B C : Î±}, r A B â†’ r B C â†’ r A C) : âˆƒ (m : Î±), âˆ€ (A : Î±), r m A â†’ r A m
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] [t2_Space Î±] {S : set Î²} {F g : Î² â†’ Î±} (h : set.Eq_on F g S) (hF : Continuous F) (hg : Continuous g) : set.Eq_on F g (Closure S)
{Î± : Type u} [PseudoEmetricSpace Î±] {x y : Î±} {S : set Î±} : Emetric.Inf_edist x S â‰¤ Emetric.Inf_edist y S + HasEdist.edist x y
{m : Type u_1} [AddGroup m] (C : Add_Con m) {W x : m} : â‡‘C W x â†’ â‡‘C (-W) (-x)
{R : Type u_1} {A : R} [Monoid R] (n : â„•) (rra : IsRightRegular A) : IsRightRegular (A ^ n)
{E : Type u_2} {ð•œ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] {S : set E} (hs : Convex ð•œ S) : Convex ð•œ (Interior S)
{Î² : Type v} [PseudoEmetricSpace Î²] {Î± : Type u} [EmetricSpace Î±] {F : Î± â†’ Î²} (h : Isometry F) : Function.Injective F
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : hb.oangle (-x) y = hb.oangle x (-y)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {S : set (E Ã— F)} : ContDiff_on ð•œ n Prod.Snd S
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} {x : Î±} : x âˆˆ Closure S â†” âˆƒ (u : Ultrafilter Î±), S âˆˆ u âˆ§ â†‘u â‰¤ nhds x
 : Filter.Tendsto (Î» (k : â„•), (Finset.Range k).Sum (Î» (i : â„•), (-1) ^ i / (2 * â†‘i + 1))) Filter.at_top (nhds (Real.Pi / 4))
{h : Type u_1} [TopologicalSpace h] {x : h} : ChartedSpace.chart_at h x = LocalHomeomorph.refl h
{R : Type u_1} [CommRing R] {xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ) ^ 2 + (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚) ^ 2
{R : Type u_1} {A B : R} [AddMonoid R] (h : B + A = 0) : _Add_Left_regular A
{G : Type u_1} [AddGroup G] (tG : AddMonoid._torsion G) (bounded : (set.Range (Î» (g : G), Add_order_of g)).Finite) : AddMonoid.exponent_exists G
{Î± : Type u} [Preorder Î±] {S : set Î±} {A : Î±} (h : IsLeast S A) : BddBelow S
(P : â„•) [Fact (Nat.Prime P)] (R : Type uâ‚) [CommSemiring R] [Char_P R P] : PerfectionMap P (Perfection.Coeff R P 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] {x : C} (Y : CategoryTheory.Subobject x) : CategoryTheory.Simple â†‘Y â†” IsAtom Y
{Î¹ : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {lb lb' : Filter â„} {LT : Filter Î¹} {A B : â„} {u v : Î¹ â†’ â„} [IntervalIntegral.FTC_Filter B lb lb'] (hab : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F lb' MeasureTheory.MeasureSpace.Volume) (hF : Filter.Tendsto F (lb' âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) (hu : Filter.Tendsto u LT lb) (hv : Filter.Tendsto v LT lb) : (Î» (t : Î¹), ((âˆ« (x : â„) in A..v t, F x) - âˆ« (x : â„) in A..u t, F x) - (v t - u t) â€¢ C) =o[LT] (v - u)
{Î± : Type u} [canonically_ordered_CommSemiring Î±] [Nontrivial Î±] : 0 < 1
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace ð•œ] (S : Submodule ð•œ E) [Finite_dimensional ð•œ â†¥S] : IsClosed â†‘S
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (Î¸ : Real.Angle) : (hb.rotation Î¸).Symm = hb.rotation (-Î¸)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : set P} (ho : EuclideanGeometry.OrthocentricSystem S) {P : Fin 3 â†’ P} (hps : set.Range P âŠ† S) (hpi : Function.Injective P) : affine_Span â„ (set.Range P) = affine_Span â„ S
{G : Type u_2} [AddGroup G] {A B : G} : A = B â†’ A - B = 0
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v W : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (hw : âˆ€ (i : Î¹), W i = v i âˆ¨ W i = -v i) : Orthonormal ð•œ W
 : Function.Bijective Real.sinh
{Î± : Type u} [HasSubset Î±] [HasSsubset Î±] [IsNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {A B : Î±} [IsAntisymm Î± HasSubset.Subset] (hâ‚ : A â‰  B) (hâ‚‚ : A âŠ† B) : A âŠ‚ B
(P : â„•) [Fact (Nat.Prime P)] {A : Zmod P} (ha : A â‰  0) : IsSquare A â†” A ^ (P / 2) = 1
{Î³ : Type W} [SemilatticeSup Î³] (A : Î³) {S : set Î³} : BddAbove (HasInsert.Insert A S) â†” BddAbove S
{Î± : Type u_2} [DecidableEq Î±] {S : Finset Î±} {B : Finset (Finset Î±)} {n : â„•} (h : âˆ€ (A : Î±), A âˆˆ S â†’ n â‰¤ (Finset.Filter (HasMem.Mem A) B).Card) : S.Card * n â‰¤ B.Sum (Î» (t : Finset Î±), (S âˆ© t).Card)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {P : P} (hp : P âˆˆ S) {v : v} (hv : v âˆˆ (S.direction)á—®) : â‡‘(EuclideanGeometry.reflection S) (v +áµ¥ P) = -v +áµ¥ P
{R : Type u_1} {K : Type u_2} [Ring R] [Field K] (F : R â†’+* K) (hF : Function.Surjective â‡‘F) : F.Ker.IsMaximal
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {vâ‚‚ : Type v'} [AddCommGroup vâ‚‚] [module K vâ‚‚] [h : Finite_dimensional K v] (F : v â†’â‚—[K] vâ‚‚) (hF : F.Range = âŠ¤) : Finite_dimensional K vâ‚‚
{vâ‚ : Type u_2} {vâ‚‚ : Type u_3} [semi_NormedGroup vâ‚] [semi_NormedGroup vâ‚‚] (F : vâ‚ â†’+ vâ‚‚) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : vâ‚), âˆ¥â‡‘F xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥F.Mk_NormedGroup_hom C hâˆ¥ â‰¤ C
{ð•œ : Type u_3} {E : Type u_4} [NormedField ð•œ] [AddCommGroup E] [module ð•œ E] (P : Seminorm ð•œ E) {r : â„} (hr : 0 < r) : Absorbent ð•œ (P.ball 0 r)
{R : Type uâ‚} [Monoid R] [has_Distrib_Neg R] : (-1) ^ 2 = 1
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x y : E} (hx : âˆ¥xâˆ¥ = 1) (hy : âˆ¥yâˆ¥ = 1) : HasInner.inner x y = 1 â†” x = y
{Î± : Type u} [Preorder Î±] {A B C : Î±} : B â‰¤ C â†’ A < B â†’ A < C
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) {r : â„} (hr : 0 < r) : hb.oangle x (r â€¢ y) = hb.oangle x y
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {k : S.Localization_Map P} (z : N) : â‡‘(k.Lift _) (â‡‘(F.Lift _) z) = z
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} [TopologicalSpace Î²] [Preorder Î¹] {u : Î¹ â†’ Î± â†’ Î²} {F : MeasureTheory.Filtration Î¹ m} [TopologicalSpace Î¹] [TopologicalSpace.metrizable_Space Î¹] [MeasurableSpace Î¹] [TopologicalSpace.SecondCountableTopology Î¹] [Opens_MeasurableSpace Î¹] [TopologicalSpace.metrizable_Space Î²] (h : MeasureTheory.Adapted F u) (hu_Cont : âˆ€ (x : Î±), Continuous (Î» (i : Î¹), u i x)) : MeasureTheory.prog_Measurable F u
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P) âˆˆ AffineSubspace.Mk' P (S.direction)á—®
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : LocalHomeomorph Î± Î²) {B : Î²} (hb : B âˆˆ e.to_local_Equiv.Target) {F : Î² â†’ E} {g : Î² â†’ F} {C : â„} : Asymptotics._O_with C (nhds B) F g â†” Asymptotics._O_with C (nhds (â‡‘(e.Symm) B)) (F âˆ˜ â‡‘e) (g âˆ˜ â‡‘e)
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} {r : R} (h : SameRay R x y) (hr : 0 â‰¤ r) : SameRay R x (r â€¢ y)
{G : Type u_1} [AddGroup G] {k : set G} {P : G â†’ Prop} {x : G} (h : x âˆˆ Add_Subgroup.Closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ P x) (Hk_Inv : âˆ€ (x : G), x âˆˆ k â†’ P (-x)) (h1 : P 0) (HMul : âˆ€ (x y : G), P x â†’ P y â†’ P (x + y)) : P x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) (m : Multiset L) : (âˆ€ (A : L), A âˆˆ m â†’ A âˆˆ S) â†’ m.Sum âˆˆ S
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} : Convex_on ð•œ S F â†” Convex ð•œ S âˆ§ âˆ€ â¦ƒx y z : ð•œâ¦„, x âˆˆ S â†’ z âˆˆ S â†’ x < y â†’ y < z â†’ (F y - F x) / (y - x) â‰¤ (F z - F y) / (z - y)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x : v} (hx : x â‰  0) (Î¸ : Real.Angle) : hb.oangle x (â‡‘(hb.rotation Î¸) x) = Î¸
{Î± : Type u} [TopologicalSpace Î±] {S t : set Î±} (hs : IsPreconnected S) (ht : IsClopen t) : Disjoint S t âˆ¨ S âŠ† t
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {n : WithTop â„•} {P : E â†’ FormalMultilinearSeries ð•œ E F} (hF : HasFtaylorSeriesUpToOn n F P S) (g : G â†’L[ð•œ] E) : HasFtaylorSeriesUpToOn n (F âˆ˜ â‡‘g) (Î» (x : G) (k : â„•), (P (â‡‘g x) k).Comp_Continuous_Linear_Map (Î» (_x : Fin k), g)) (â‡‘g â»Â¹' S)
{R : Type u_1} [CommRing R] {m : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] (Râ‚˜ : Type u_4) (Sâ‚˜ : Type u_5) [CommRing Râ‚˜] [CommRing Sâ‚˜] [Algebra R Râ‚˜] [IsLocalization m Râ‚˜] [Algebra S Sâ‚˜] [IsLocalization (Algebra.Algebra_Map_Submonoid S m) Sâ‚˜] (hRS : Function.Injective â‡‘(Algebra_Map R S)) (hM : Algebra.Algebra_Map_Submonoid S m â‰¤ non_Zero_divisors S) : Function.Injective â‡‘(Algebra_Map Râ‚˜ Sâ‚˜)
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] (S : Type u_3) [CommMonoid S] [Distrib_MulAction S m] [SmulCommClass S R m] : module._torsion' â†¥(Submodule.torsion' R m S) S
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {F' : E â†’L[â„] â„} {S : set E} (h : IsLocalMaxOn F S A) (hF : HasFderivWithinAt F F' S A) {y : E} (hy : y âˆˆ Pos_TangentConeAt S A) (hy' : -y âˆˆ Pos_TangentConeAt S A) : â‡‘F' y = 0
{Î² : Type u} {Î± : Type v} {S : Finset Î±} {F : Î± â†’ Î²} [CommMonoid Î²] (R : Setoid Î±) [Decidable_Rel Setoid.r] : S.Prod (Î» (x : Î±), F x) = (Finset.image Quotient.Mk S).Prod (Î» (xbar : Quotient R), (Finset.Filter (Î» (y : Î±), âŸ¦yâŸ§ = xbar) S).Prod (Î» (y : Î±), F y))
{m : Type u_1} [has_Mul m] {N : Type u_2} [has_Mul N] (F : m â†’â‚™* N) (hF : Function.Surjective â‡‘F) : F.srange = âŠ¤
(F : â„ â†’ â„) {A B : â„} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfI : F A = F B) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), deriv F C = 0
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Limits.HasBinaryProducts C
(n : â„•) (R : Type u_1) [CommRing R] [IsDomain R] : Polynomial.cyclotomic' n R â‰  0
{Î± : Type u} [Preorder Î±] {S t : set Î±} (h : BddAbove S) : BddAbove (S âˆ© t)
{Î± : Type u_1} [UniformSpace Î±] (x : Î±) : nhds (x, x) â‰¤ Uniformity Î±
{Î± : Type u_2} {Î¹ : Type u_5} [CommMonoid Î±] (t : Finset Î¹) (F : Î¹ â†’ set Î±) (A : Î±) : A âˆˆ t.Prod (Î» (i : Î¹), F i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ {i : Î¹}, i âˆˆ t â†’ g i âˆˆ F i), t.Prod (Î» (i : Î¹), g i) = A
{ð•œ : Type u_1} {A : Type u_2} [_R_or_C ð•œ] [NormedRing A] [normed_Algebra ð•œ A] [CompleteSpace A] (A : A) {z : ð•œ} (hz : z âˆˆ Spectrum ð•œ A) : Exp ð•œ z âˆˆ Spectrum ð•œ (Exp ð•œ A)
(n : â„•) : â†‘n.Numeric
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {P : E â†’ FormalMultilinearSeries ð•œ E F} {n : â„•} : HasFtaylorSeriesUpToOn (â†‘n + 1) F P S â†” HasFtaylorSeriesUpToOn â†‘n F P S âˆ§ (âˆ€ (x : E), x âˆˆ S â†’ HasFderivWithinAt (Î» (y : E), P y n) (P x n.Succ).Curry_Left S x) âˆ§ Continuous_on (Î» (x : E), P x (n + 1)) S
{n : WithTop â„•} : ContDiff â„ n Exp_Neg_Inv_glue
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : o.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {x y : Î±} : (Setoid.Ker F).Rel x y â†” x âˆˆ F â»Â¹' {F y}
{P : â„•} : padic_val_Int P 1 = 0
{S : Type u_2} [CommRing S] {K : Type u_4} {F : Type u_6} [Field K] [Field F] [Algebra K F] [Algebra K S] (pB : power_Basis K S) (hF : Polynomial.Splits (Algebra_Map K F) (minpoly K pB.gen)) : â‡‘(Algebra_Map K F) (â‡‘(Algebra.norm K) pB.gen) = (Polynomial.Map (Algebra_Map K F) (minpoly K pB.gen)).roots.Prod
{A B : Ordinal} : {o : Ordinal | A â‰¤ B + o}.Nonempty
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] {r : â„} (hr : 0 â‰¤ r) : r â€¢ metric.IsClosed_ball 0 1 = metric.IsClosed_ball 0 r
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {P1 : P} (P2 : P) (r : â„) (hp : P1 âˆˆ S) : â‡‘(EuclideanGeometry.Orthogonal_projection S) (r â€¢ (P2 -áµ¥ â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P2)) +áµ¥ P1) = âŸ¨P1, hpâŸ©
(k : Type u_1) {v1 : Type u_2} (P1 : Type u_3) [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] : â‡‘(AffineMap.Id k P1) = Id
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] (k : â„•) (h : âˆ€ (v : v), G.degree v â‰¤ k) : G.max_degree â‰¤ k
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e e' : LocalHomeomorph Î± Î²} (h : e â‰ˆ e') : e.Symm â‰ˆ e'.Symm
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E1 E2 : intermediate_Field K L) (h1 : Finite_dimensional K â†¥E1) (h2 : Finite_dimensional K â†¥E2) : Finite_dimensional K â†¥(E1 âŠ” E2)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (u : E) {v : E} (hv : v âˆˆ (Submodule.Span ð•œ {u})á—®) : HasInner.inner v u = 0
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 2 R = Polynomial.x + 1
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : A < 1) (hb : B â‰¤ 1) : A * B < 1
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommGroup Î²] [HasScalar ð•œ E] [module ð•œ Î²] {S : set E} {F : E â†’ Î²} : ConcaveOn ð•œ S (-F) â†” Convex_on ð•œ S F
(G : Type u_1) [AddCommGroup G] : AddCommMonoid.Add_torsion G = (Add_torsion G).to_Add_Submonoid
{Î± : Type u} [PseudoMetricSpace Î±] : Isometry Coe
{Î³ : Type u_3} [tÎ³ : TopologicalSpace Î³] [PolishSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³] {Î² : Type u_4} [tÎ² : TopologicalSpace Î²] [t2_Space Î²] [MeasurableSpace Î²] [BorelSpace Î²] {F : Î³ â†’ Î²} (F_Cont : Continuous F) (F_inj : Function.Injective F) : Measurable_Embedding F
{R : Type u_1} [CommSemiring R] (m : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization m S] (j k : S â†’ P) (hj1 : j 1 = 1) (hk1 : k 1 = 1) (hjm : âˆ€ (A B : S), j (A * B) = j A * j B) (hkm : âˆ€ (A B : S), k (A * B) = k A * k B) (h : âˆ€ (A : R), j (â‡‘(Algebra_Map R S) A) = k (â‡‘(Algebra_Map R S) A)) : j = k
{Î± : Type u} [TopologicalSpace Î±] {S : set (set Î±)} (K : Directed_on HasSubset.Subset S) (h : âˆ€ (S : set Î±), S âˆˆ S â†’ IsPreconnected S) : IsPreconnected (â‹ƒâ‚€S)
{Î± : Type u_1} [Lattice Î±] [_modular_Lattice Î±] {Î² : Type u_2} {Î³ : Type u_3} [PartialOrder Î²] [Preorder Î³] (hâ‚ : WellFounded has_LT.LT) (hâ‚‚ : WellFounded has_LT.LT) (K : Î±) (Fâ‚ : Î² â†’ Î±) (Fâ‚‚ : Î± â†’ Î²) (gâ‚ : Î³ â†’ Î±) (gâ‚‚ : Î± â†’ Î³) (gci : GaloisCoinsertion Fâ‚ Fâ‚‚) (gi : GaloisInsertion gâ‚‚ gâ‚) (hF : âˆ€ (A : Î±), Fâ‚ (Fâ‚‚ A) = A âŠ“ K) (hg : âˆ€ (A : Î±), gâ‚ (gâ‚‚ A) = A âŠ” K) : WellFounded has_LT.LT
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] {A : Î±} : IsMin A â†’ Order.Pred A = A
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) : t.Prod.degree â‰¤ (Multiset.Map Polynomial.degree t).Sum
{m : Type u_1} [has_Add m] {C D : Add_Con m} : (âˆ€ (x y : m), â‡‘C x y â†” â‡‘D x y) â†” C = D
(F : Type u) (K A : Type v) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [module K A] [module F A] [IsScalarTower F K A] : module.rank F K * module.rank K A = module.rank F A
{m : Type u_1} [CommMonoid m] (F S : â„• â†’ m) (h0 : S 0 = 1) (h : âˆ€ (n : â„•), S (n + 1) = S n * F n) (n : â„•) : (Finset.Range n).Prod (Î» (k : â„•), F k) = S n
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [DecidableEq Î±] (h : free_Group.Mk Lâ‚ = free_Group.Mk Lâ‚‚) : free_Group.reduce Lâ‚ = free_Group.reduce Lâ‚‚
{Î± : Type u} [PseudoEmetricSpace Î±] {P : Î± â†’ Prop} (x y : Subtype P) : HasEdist.edist x y = HasEdist.edist â†‘x â†‘y
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] {A B : Î±} (hab : A â‰  B) : Closure (set.ioc A B) = set.icc A B
{n : â„•} {P : Fin n â†’ Prop} [Decidable_Pred P] : Fin.Find P = Option.None â†” âˆ€ (i : Fin n), Â¬P i
{A : Type u_2} {K : Type u_3} [CommRing A] [Field K] [IsDomain A] [IsDedekindDomain A] [Algebra A K] [_fraction_Ring A K] {J : Ideal A} (hJ : J â‰  âŠ¤) {Î¹ : Type u_1} (S : Finset Î¹) (F : Î¹ â†’ K) {j : Î¹} (hjs : j âˆˆ S) (hjf : F j â‰  0) : âˆƒ (A : K), (âˆ€ (i : Î¹), i âˆˆ S â†’ IsLocalization._integer A (A * F i)) âˆ§ âˆƒ (i : Î¹) (h : i âˆˆ S), A * F i âˆ‰ â†‘J
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Mul_Pos_Mono Î±] (ha : 1 â‰¤ A) (hb : 1 < B) (B0 : 0 < B) : 1 < A * B
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x : v} (hx : x â‰  0) : o.oangle x (-x) = â†‘Real.Pi
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [NormedSpace ð•œ E'] {n : WithTop â„•} {F : E â†’ E'} {x : E} : ContDiff_at ð•œ n F x â†’ Cont_mdiff_at (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') n F x
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [DivisionRing K] (TerminatedAt_n : g.TerminatedAt n) : g.squash_gcf n = g
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} (P : Î¹ â†’ P) (i : Î¹) : Finset.centroid k {i} P = P i
{Î¹ : Type u_1} {m : Type u_4} {N : Type u_5} [CommMonoid m] [ordered_CommMonoid N] (F : m â†’ N) (h_One : F 1 = 1) (h_Mul : âˆ€ (x y : m), F (x * y) â‰¤ F x * F y) (S : Finset Î¹) (g : Î¹ â†’ m) : F (S.Prod (Î» (i : Î¹), g i)) â‰¤ S.Prod (Î» (i : Î¹), F (g i))
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] {F : Type W} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace ð•œ] {F : E â†’â‚—[ð•œ] F} (hF : F.Ker = âŠ¥) [Finite_dimensional ð•œ E] : IsClosed_Embedding â‡‘F
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [SuccOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Monotone F) : Pairwise (Disjoint on Î» (n : Î±), set.ioc (F n) (F (Order.Succ n)))
{n : â„•} (P i : Fin n) : P.Pred_above (â‡‘((â‡‘Fin.cast_Succ P).Succ_above) i) = i
{F : Type u_8} {G : Type u_1} {h : Type u_2} [AddGroup G] [AddZeroClass h] [AddMonoid_hom_class F G h] (F : F) : Function.Injective â‡‘F â†” âˆ€ (A : G), â‡‘F A = 0 â†” A = 0
{Î± : Type u_1} {C : set (set Î±)} (h : âˆ€ (A : Î±), âˆƒ! (B : set Î±) (h : B âˆˆ C), A âˆˆ B) {y : Î±} : {x : Î± | (Setoid.Mk_Classes C h).Rel x y} âˆˆ C
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore Î¹ B F) (i j : Î¹) : (Z.local_triv_as_local_Equiv i).Symm.Trans (Z.local_triv_as_local_Equiv j) â‰ˆ (Z.triv_change i j).to_local_Equiv
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {C : â„} {F : â„‚ â†’ E} {z : â„‚} (hD : Diff_Cont_on_cl â„‚ F {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : Filter._bounded_under has_LE.LE Filter.at_top (Î» (x : â„), âˆ¥F â†‘xâˆ¥)) (him : âˆ€ (x : â„), âˆ¥F (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz : 0 â‰¤ z.re) : âˆ¥F zâˆ¥ â‰¤ C
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] [strict_Convex_Space â„ E] {x y : E} {A B r : â„} (hx : âˆ¥xâˆ¥ â‰¤ r) (hy : âˆ¥yâˆ¥ â‰¤ r) (hne : x â‰  y) (ha : 0 < A) (hb : 0 < B) (hab : A + B = 1) : âˆ¥A â€¢ x + B â€¢ yâˆ¥ < r
{m : Type u_1} [Monoid m] {x y : m} : y âˆˆ Submonoid.Closure {x} â†” âˆƒ (n : â„•), x ^ n = y
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} : 0 â‰¤ Metric.diam S
{G : Type u_1} [AddGroup G] [TopologicalSpace G] [topological_AddGroup G] {h : Add_Subgroup G} (h_1_Int : 0 âˆˆ Interior â†‘h) : IsOpen â†‘h
{Î± : Type u_1} [Bornology Î±] {S : set Î±} : Bornology._bounded S â†’ BoundedSpace â†¥S
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {P : P} {ps : set P} (h : P âˆˆ affine_Span k ps) : affine_Span k (HasInsert.Insert P ps) = affine_Span k ps
{R : Type u} [comm_Group R] [Star_Semigroup R] (x y : R) : HasStar.Star (x / y) = HasStar.Star x / HasStar.Star y
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] [NoZeroSmulDivisors R m] {v : m} (hv : v â‰  0) {r : R} (hr : r â‰  0) : SameRay R (r â€¢ v) v â†” 0 < r
{R : Type u_1} {m : Type u_3} [Monoid_with_Zero R] [has_Zero m] [MulAction_with_Zero R m] [sM : Subsingleton m] : IsSmulRegular m 0
{F : Type} [CommSemiring F] {q : â„•} {F g : Polynomial F} (hF : Polynomial._IsSeparable_contraction q F g) : âˆƒ (m : â„•), g.Nat_degree * q ^ m = F.Nat_degree
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {x : C} (S : CategoryTheory.Sieve x) : Jâ‚.IsClosed S â†” Jâ‚.close S = S
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {x Y Z : C} (F : x âŸ¶ Y) (g : Y âŸ¶ Z) : CategoryTheory.Exact F g â†” CategoryTheory.Limits.image_Subobject F = CategoryTheory.Limits.Kernel_Subobject g
{Î¹ : Type u_2} {R : Type u_3} [DecidableEq Î¹] [AddMonoid Î¹] [CommSemiring R] : direct_Sum._internal (AddMonoid_Algebra.grade R)
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (h : Add_Subgroup G) {F : G â†’+ N} (hF : Function.Bijective â‡‘F) : Add_Subgroup.Map F h.Normalizer = (Add_Subgroup.Map F h).Normalizer
{Î± : Type u_2} [DecidableEq Î±] [has_Add Î±] {u : Finset Î±} {S t : set Î±} : â†‘u âŠ† S + t â†’ (âˆƒ (S' t' : Finset Î±), â†‘S' âŠ† S âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† S' + t')
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {x Y : C} (F : x âŸ¶ Y) (Z : C) (l : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.Cokernel_cofork.ofÏ€ 0 _)) : CategoryTheory.Epi F
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTrivialTopologicalFiberBundle F Prod.Snd
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {A : Î±} {S : set Î±} (F : Î± â†’ m) (h : A âˆ‰ S) (hs : S.Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ HasInsert.Insert A S), F i)) = F A + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i))
(R : Type u) [Semiring R] [Nontrivial R] (P : â„•) [hp : Char_P R P] [hq : ExpChar R 1] : P = 0
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : RË£) : (Î» (t : R), Ring.Inverse (â†‘x + t) - â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥
{m : Type u_1} [Monoid m] {x : m} : 1 âˆˆ Powers x
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [AddCommMonoid Î±] {g : Î³ â†’ Î²} (hg : Function.Injective g) {F : Î² â†’ Î±} (hF : âˆ€ (x : Î²), x âˆ‰ set.Range g â†’ F x = 0) : Filter.Map (Î» (S : Finset Î³), S.Sum (Î» (i : Î³), F (g i))) Filter.at_top = Filter.Map (Î» (S : Finset Î²), S.Sum (Î» (i : Î²), F i)) Filter.at_top
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : HasDist.dist P3 P1 = HasDist.dist P3 P2) : EuclideanGeometry.angle P3 (midpoint â„ P1 P2) P1 = Real.Pi / 2
{R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} [Linear_ordered_Field R] [AddCommGroup E] [module R E] {S : set E} {t : Finset Î¹} {W : Î¹ â†’ R} {z : Î¹ â†’ E} (hs : Convex R S) : (âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ W i) â†’ 0 < t.Sum (Î» (i : Î¹), W i) â†’ (âˆ€ (i : Î¹), i âˆˆ t â†’ z i âˆˆ S) â†’ t.Center_mass W z âˆˆ S
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] {mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), AddCommMonoid (mâ‚' i)] [Î  (i : Î¹), module R (mâ‚' i)] (F : Î  (i : Î¹), mâ‚ i â†’â‚—[R] mâ‚' i) (hF : âˆ€ (i : Î¹), Function.Surjective â‡‘(F i)) : Function.Injective (Î» (g : MultilinearMap R mâ‚' mâ‚‚), g.Comp_Linear_Map F)
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : âŠ¥.direction = âŠ¥
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x y : E} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ ^ 2
(Î± : Type u) [PseudoEmetricSpace Î±] [SigmaCompactSpace Î±] : TopologicalSpace.SecondCountableTopology Î±
{ð•‚ : Type u_1} [_R_or_C ð•‚] {x : ð•‚} : HasDerivAt (Exp ð•‚) (Exp ð•‚ x) x
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_at F A) : HasDerivAt (Î» (u : â„), âˆ« (x : â„) in u..B, F x) (-F A) A
(R : Type u) (L : Type v) (m : Type W) [CommRing R] [lie_Ring L] [lie_Algebra R L] [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] {N : lie_Submodule R L m} (hâ‚ : N â‰¤ lie_module.max_triv_Submodule R L m) (hâ‚‚ : lie_module.IsNilpotent R L (m â§¸ N)) : lie_module.IsNilpotent R L m
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x : v} (hx : x â‰  0) (Î¸ : Real.Angle) : x = â‡‘(hb.rotation Î¸) x â†” Î¸ = 0
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [AddCommMonoid Î±] [TopologicalSpace Î±] [has_Continuous_Add Î±] [RegularSpace Î±] {F : Î² Ã— Î³ â†’ Î±} {g : Î² â†’ Î±} {A : Î±} (ha : has_Sum F A) (hF : âˆ€ (B : Î²), has_Sum (Î» (C : Î³), F (B, C)) (g B)) : has_Sum g A
{Î± : Type u} [Preorder Î±] {A B C : Î±} : B â‰¤ C â†’ A â‰¤ B â†’ A â‰¤ C
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.Preadditive_coyoneda â‹™ (CategoryTheory.whiskering_Right C AddCommGroup (Type v)).obj (CategoryTheory.Forget AddCommGroup) = CategoryTheory.coyoneda
{Î± : Type u_1} (F : Poly Î±) : _Poly â‡‘F
{Î± : Type u} {Î² : Î± â†’ Type u} {Îº : Cardinal} (hÎº : Cardinal.Sum (Î» (A : Î±), Îº ^ Cardinal.Mk (Î² A)) â‰¤ Îº) : Cardinal.Mk (W_Type Î²) â‰¤ Îº
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasInitial C] : CategoryTheory.Limits.has_Zero_object C
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {F g : E â†’ F} (hF : ContDiff ð•œ n F) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Î» (x : E), F x + g x)
(P : â„•) [hp : Fact (Nat.Prime P)] (A : Zmod P) (hap : A â‰  0) : Multiset.Map (Î» (x : â„•), (A * â†‘x).val_min_Abs.Nat_Abs) (Finset.Ico 1 (P / 2).Succ).val = Multiset.Map (Î» (A : â„•), A) (Finset.Ico 1 (P / 2).Succ).val
{Î± : Type u_1} [TopologicalSpace Î±] {ð•œ : Type u_5} [TopologicalSpace ð•œ] [Field ð•œ] [topological_Ring ð•œ] {S : Subalgebra ð•œ C(Î±, ð•œ)} (h : S.separates_points) : â†‘S.SeparatesPointsStrongly
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (N : Submonoid S) (t : Type u_4) [CommRing t] [Algebra R t] [Algebra S t] [IsScalarTower R S t] [IsLocalization m S] [IsLocalization N t] (h : âˆ€ (x : S), IsUnit x â†’ x âˆˆ N) : IsLocalization (Submonoid.comap (Algebra_Map R S).to_Monoid_hom N) t
{Ï„ : Type u_1} {Î± : Type u_2} [canonically_ordered_AddMonoid Ï„] {Ï• : Ï„ â†’ Î± â†’ Î±} {S : set Î±} : IsFwInvariant Ï• S â†” IsInvariant Ï• S
{Î± : Type u} [PseudoEmetricSpace Î±] {S : set Î±} : Emetric.Hausdorff_edist S S = 0
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [Finite_dimensional ð•œ E] [Finite_dimensional ð•œ F] (A : E â†’â‚—[ð•œ] F) (B : F â†’â‚—[ð•œ] E) : A = â‡‘LinearMap.Adjoint B â†” âˆ€ (x : E) (y : F), HasInner.inner (â‡‘A x) y = HasInner.inner x (â‡‘B y)
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hb : Finset.Univ.Sum (Î» (x : Î±), W x) < Fintype.Card Î² â€¢ B) : âˆƒ (y : Î²), (Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Sum (Î» (x : Î±), W x) < B
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = â†‘Real.Pi
{R : Type u_4} {S : Type u_5} [has_Mul R] [has_Add R] [has_Mul S] [has_Add S] (e : R â‰ƒ+* S) (x y : R) : â‡‘e (x + y) = â‡‘e x + â‡‘e y
{m : Type u_3} {F : Type u_8} {G : Type u_1} [AddGroup G] [AddMonoid m] [AddMonoid_hom_class F G m] {F g : F} {x : G} (h : â‡‘F x = â‡‘g x) : â‡‘F (-x) = â‡‘g (-x)
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] {l : Filter Î²} {Fâ‚ Fâ‚‚ Fâ‚ƒ : Î² â†’ Î±} (hâ‚â‚‚ : Filter.Tendsto (Î» (x : Î²), (Fâ‚ x, Fâ‚‚ x)) l (Uniformity Î±)) (hâ‚‚â‚ƒ : Filter.Tendsto (Î» (x : Î²), (Fâ‚‚ x, Fâ‚ƒ x)) l (Uniformity Î±)) : Filter.Tendsto (Î» (x : Î²), (Fâ‚ x, Fâ‚ƒ x)) l (Uniformity Î±)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} [CategoryTheory.Limits.HasBinaryBiproduct x Y] : CategoryTheory.Limits.biprod.fst â‰« CategoryTheory.Limits.biprod.inl_ + CategoryTheory.Limits.biprod.Snd â‰« CategoryTheory.Limits.biprod.inr_ = ðŸ™ (x âŠž Y)
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] [Finite_dimensional F E] (h : âˆ€ (x : E), Finite_dimensional.finrank F â†¥FâŸ®xâŸ¯ â‰¤ 1) : âŠ¥ = âŠ¤
(n : â„•) : âˆƒ (P : â„•), n â‰¤ P âˆ§ Nat.Prime P
{Î± : Type u} [Mul_Zero_class Î±] [has_Distrib_Neg Î±] : -0 = 0
{R : Type u} {A : Type W} [CommSemiring R] [Semiring A] [Algebra R A] (r : R) (x : A) : â‡‘(Algebra_Map R A) r * x = x * â‡‘(Algebra_Map R A) r
{Î± : Type u_1} {C : set (set Î±)} (hc : Setoid._Partition C) {S : set Î±} (h : S âˆˆ C) : S.Nonempty
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] {F : Type W} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace ð•œ] {Î¹ : Type u_1} [Fintype Î¹] (v : Basis Î¹ ð•œ E) : âˆƒ (C : â„) (h : C > 0), âˆ€ {u : E â†’L[ð•œ] F} {m : â„}, 0 â‰¤ m â†’ (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥ â‰¤ m) â†’ âˆ¥uâˆ¥ â‰¤ C * m
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] [Nonempty v] : G.max_degree < Fintype.Card v
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {x : C} (h : CategoryTheory.yoneda.obj x â‹™ CategoryTheory.ulift_Functor â‰… F.cones) {Y : C} (F : Y âŸ¶ x) : CategoryTheory.Limits.IsLimit.of_Nat_iso.cone_of_hom h F = (CategoryTheory.Limits.IsLimit.of_Nat_iso.Limit_cone h).extend F
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] [UniformSpace Î²] [SeparatedSpace Î±] {S : set Î±} {F : Î± â†’ Î²} (hs : IsCompact S) (hF : Continuous_on F S) : uniform_Continuous_on F S
{A B C : â„¤} (h : fermat_42 A B C) : âˆƒ (A0 B0 C0 : â„¤), fermat_42.Minimal A0 B0 C0
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} {t : Add_Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) {q : Type u_4} [AddCommMonoid q] {k : t.Localization_Map q} (z : N) : â‡‘(k.to_Map) (â‡‘g â†‘((F.sec z).Snd)) + â‡‘(F.Map hy k) z = â‡‘(k.to_Map) (â‡‘g (F.sec z).fst)
{Î² : Type u_2} [CommMonoid Î²] {n : â„•} (F : Fin (n + 1) â†’ Î²) (x : Fin (n + 1)) : Finset.Univ.Prod (Î» (i : Fin (n + 1)), F i) = F x * Finset.Univ.Prod (Î» (i : Fin n), F (â‡‘(x.Succ_above) i))
{n : â„•} {A : Cardinal} : n â€¢ A < Cardinal.aleph0 â†” n = 0 âˆ¨ A < Cardinal.aleph0
{Î± : Type u} {Î¹ : sort x} {F : Î¹ â†’ Filter Î±} [hn : Nonempty Î±] (hD : Directed Ge F) (hb : âˆ€ (i : Î¹), (F i).Ne_IsBot) : (infi F).Ne_IsBot
{Î± : Type u_3} {Î² : Type u_4} [Linear_ordered_Field Î±] {l : Filter Î²} {F : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (Î» (x : Î²), r * F x) l Filter.at_IsBot
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (v : m) {r : R} (h : 0 < r) : SameRay R v (r â€¢ v)
{Î± : Type u} {Î² : Type v} {F : Î± â†’ Î²} {A : Filter Î±} {Bâ‚ Bâ‚‚ : Filter Î²} (hF : Filter.Tendsto F A Bâ‚) [A.Ne_IsBot] (hb : Disjoint Bâ‚ Bâ‚‚) : Â¬Filter.Tendsto F A Bâ‚‚
{S : Type u_1} [has_Add S] (A : S) : Add_Commute A A
{A : Type u_2} [CommRing A] [IsDomain A] [IsDedekindDomain A] {P : Ideal A} (hP : P â‰  âŠ¥) : Prime P â†” P.Prime
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {B : m} [Linear_ordered_CommRing m] (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A âˆˆ t) (ht : t.Card â€¢ B < â†‘(S.Card)) : âˆƒ (y : Î²) (h : y âˆˆ t), B < â†‘((Finset.Filter (Î» (x : Î±), F x = y) S).Card)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (Î¸ : Real.Angle) : â‡‘LinearMap.det â†‘((hb.rotation Î¸).to_Linear_Equiv) = 1
(P : â„•) [Fact (Nat.Prime P)] (A : (Zmod P)Ë£) : A ^ (P - 1) = 1
{Î± : Type u} {l : List Î±} : l.Nodup â†’ l.sublists.Nodup
(R : CommRing) (m : Submonoid â†¥R) (x : Prime_Spectrum (Localization m)) : CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.stalk_Map (AlgebraicGeometry.spec.to_PresheafedSpace.Map (CommRing.of_hom (Algebra_Map â†¥R (Localization m))).Op) x)
 : Filter.Tendsto Real.Exp (nhds 0) (nhds 1)
{m : Type u_1} [Monoid m] {Î³ : Type u_2} [Monoid Î³] {F : m â†’ Î³} (hF : _Monoid_hom F) : _Submonoid (set.Range F)
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B C : Î±} : B â‰¤ -A + C â†’ A + B â‰¤ C
{F : Nat.Partrec.Code â†’ Nat.Partrec.Code} (hF : Computable F) : âˆƒ (C : Nat.Partrec.Code), (F C).Eval = C.Eval
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {F : E â†’ ð•œ} {g : E â†’ F} (hF : ContDiff ð•œ n F) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Î» (x : E), F x â€¢ g x)
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S t : set Î±} (sne : S.Nonempty) (tne : t.Nonempty) (hst : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ t â†’ x â‰¤ y) : (UpperBounds S âˆ© LowerBounds t).Nonempty
{r : Nnreal} : âŠ¤ - â†‘r = âŠ¤
{R : Type u_1} {m : Type u_3} [Monoid_with_Zero R] [has_Zero m] [MulAction_with_Zero R m] [nM : Nontrivial m] : Â¬IsSmulRegular m 0
{Î± : Type u_1} [generalized_boolean_Algebra Î±] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] {S : Finset Î±} {u v A : Î±} (ha : A âˆˆ Uv.Compression u v S) (hva : v â‰¤ A) (hua : Disjoint u A) : (A âŠ” u)  v âˆˆ S
{Î± : Type u} [HasSubset Î±] {A B : Î±} [IsAntisymm Î± HasSubset.Subset] (h : A âŠ† B) (h' : B âŠ† A) : A = B
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P1 P2 : P} (hp1 : P1 âˆˆ S) (hp2 : P2 âˆˆ S) : P1 -áµ¥ P2 âˆˆ S.direction
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : o.oangle y x = -o.oangle x y
{J : Type uâ‚} [CategoryTheory.Category J] [Nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), CategoryTheory.Zigzag jâ‚ jâ‚‚) : CategoryTheory.IsConnected J
{P : â„•} {G : Type u_1} [Group G] (hG : _P_Group P G) [hp : Fact (Nat.Prime P)] (Î± : Type u_2) [MulAction G Î±] [Fintype Î±] [Fintype â†¥(MulAction.FixedPoints G Î±)] (hpÎ± : P âˆ£ Fintype.Card Î±) {A : Î±} (ha : A âˆˆ MulAction.FixedPoints G Î±) : âˆƒ (B : Î±), B âˆˆ MulAction.FixedPoints G Î± âˆ§ A â‰  B
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (hx : x â‰  0) (hy : y â‰  0) : o.oangle (-x) y = o.oangle x y + â†‘Real.Pi
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {P : Î¹ â†’ P} (ha : AffineIndependent k (Î» (x : â†¥(set.Range P)), â†‘x)) (hi : Function.Injective P) : AffineIndependent k P
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {x Y Z x' Y' Z' : C} (F : x âŸ¶ Y) [CategoryTheory.Limits.HasCokernel F] (g : Y âŸ¶ Z) (W : F â‰« g = 0) (F' : x' âŸ¶ Y') [CategoryTheory.Limits.HasCokernel F'] (g' : Y' âŸ¶ Z') (W' : F' â‰« g' = 0) (P : x âŸ¶ x') (q : Y âŸ¶ Y') (r : Z âŸ¶ Z') (hâ‚ : F â‰« q = P â‰« F') (hâ‚‚ : g â‰« r = q â‰« g') : CategoryTheory.Limits.Cokernel.Map F F' P q hâ‚ â‰« CategoryTheory.Limits.Cokernel.Desc F' g' W' = CategoryTheory.Limits.Cokernel.Desc F g W â‰« r
{Î± : Type u_2} [AddMonoid Î±] (m : Î±) : Even m â†’ (âˆƒ (C : Î±), m = 2 â€¢ C)
(R : Type u) [non_assoc_Ring R] (P : â„•) [hc : Char_P R P] [Fintype R] : P â‰  0
(R : Type u) [Ring R] [strong_RankCondition R] {Î¹ : Type v} (m : Î¹ â†’ Type W) [Î  (i : Î¹), AddCommGroup (m i)] [Î  (i : Î¹), module R (m i)] [âˆ€ (i : Î¹), module.free R (m i)] : module.rank R (direct_Sum Î¹ (Î» (i : Î¹), m i)) = Cardinal.Sum (Î» (i : Î¹), module.rank R (m i))
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : Finset P} {P : P} (hp : P âˆˆ S) : Vector_Span k â†‘S = Submodule.Span k â†‘(Finset.image (Î» (_x : P), _x -áµ¥ P) (S.erase P))
(R : Type u) (m : Type v) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] (N : Type v) [AddCommGroup N] [module R N] [module.free R N] : module.rank R (m Ã— N) = module.rank R m + module.rank R N
{R : Type u_1} [Monoid_with_Zero R] {F : Nat.ArithmeticFunction R} : F.Multiplicative â†” â‡‘F 1 = 1 âˆ§ âˆ€ {m n : â„•}, m â‰  0 â†’ n â‰  0 â†’ m.IsCoprime n â†’ â‡‘F (m * n) = â‡‘F m * â‡‘F n
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] (C : Con m) (F : m â†’* P) (h : C â‰¤ Con.Ker F) (h : Function.Injective â‡‘(C.Lift F h)) : Con.Ker F = C
{n : â„•} {E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : (Fin (n + 1) â†’ â„‚) â†’ E} {C : Fin (n + 1) â†’ â„‚} {R : Fin (n + 1) â†’ â„} (hF : TorusIntegrable F C R) (i : Fin (n + 1)) : âˆ¯ (x : Fin (n + 1) â†’ â„‚) in t(C, R), F x = âˆ® (x : â„‚) in C(C i, R i), âˆ¯ (y : Fin n â†’ â„‚) in t(C âˆ˜ â‡‘(i.Succ_above), R âˆ˜ â‡‘(i.Succ_above)), F (i.Insert_nth x y)
{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), n â‰¤ m â†’ P n â†’ P (n - 1)) (n : â„¤) : n â‰¤ m â†’ P n
{Î± : Type u} [HasSubset Î±] [HasSsubset Î±] [IsNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {A B : Î±} (h : A âŠ‚ B) : Â¬B âŠ† A
(S : â„) : (Î» (x : â„), x ^ S) =o[Filter.at_top] Real.Exp
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {P : Filter Î¹} {S : set Î±} : TendstoUniformlyOn F F P S â†” Filter.Tendsto (Î» (q : Î¹ Ã— Î±), (F q.Snd, F q.fst q.Snd)) (P.Prod (Filter.principal S)) (Uniformity Î²)
{R : Type u_1} [CommSemiring R] (m : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] [IsLocalization m S] (z : S) : z * â‡‘(Algebra_Map R S) â†‘((IsLocalization.sec m z).Snd) = â‡‘(Algebra_Map R S) (IsLocalization.sec m z).fst
{x : Type u_2} [EmetricSpace x] [TopologicalSpace.SecondCountableTopology x] (S : set x) : (â¨† (x : x) (h : x âˆˆ S), (nhds_within x S).Small_sets.limsup dimH) = dimH S
{R : Type u} {A : R} [Semiring R] {P : Polynomial R} (h : A * P.leading_Coeff â‰  0) : (â‡‘Polynomial.C A * P).Nat_degree = P.Nat_degree
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] (F : Equiv.perm Î±) {x : Î±} : (F.Cycle_of x)._Cycle â†” â‡‘F x â‰  x
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [Linear_ordered_AddCommGroup Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hF : Filter.Tendsto F l Filter.at_IsBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), F x + g x) l Filter.at_IsBot
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : ConcaveOn ð•œ S F) {x y : E} (hx : x âˆˆ S) (hy : y âˆˆ S) {A B : ð•œ} (ha : 0 â‰¤ A) (hb : 0 â‰¤ B) (hab : A + B = 1) : LinearOrder.min (F x) (F y) â‰¤ F (A â€¢ x + B â€¢ y)
(R : Type u_1) [Rack R] (G : Type u_2) [Group G] (F : ShelfHom R (Quandle.Conj G)) (g : Rack.envel_Group R â†’* G) (h : F = (Quandle.Conj.Map g).Comp (Rack.to_envel_Group R)) : g = â‡‘Rack.to_envel_Group.Map F
{K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero 2] {k : â„•} (hk : 2 â‰¤ k) [IsCyclotomicExtension {2 ^ k} K L] (hirr : Irreducible (Polynomial.cyclotomic (2 ^ k) K)) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {F : Î± â†’ Î²} (hF : âˆ€ (x y : Î±), F (x + y) = F x + F y) : _AddGroup_hom F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {g : F â†’ G} {F : E â†’ F} (hg : ContDiff ð•œ n g) (hF : ContDiff ð•œ n F) : ContDiff ð•œ n (g âˆ˜ F)
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (hab : A < B) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : â‡‘(affine_Map.line_Map (F A) (F B)) r â‰¤ F (â‡‘(affine_Map.line_Map A B) r) â†” slope F (â‡‘(affine_Map.line_Map A B) r) B â‰¤ slope F A (â‡‘(affine_Map.line_Map A B) r)
{x : top} (F : top.Presheaf (Type v) x) (Fsh : F._sheaf_Unique_gluing) : F._sheaf
{ð•œ : Type u_3} [_R_or_C ð•œ] {n m : â„•} (A B : Matrix (Fin n) (Fin m) ð•œ) (i j : Fin n) : HasInner.inner (A i) (B j) = B.Mul A.Conj_transpose j i
{m : Type u_1} [AddZeroClass m] {S : set m} {P : m â†’ m â†’ Prop} {x y : m} (hx : x âˆˆ AddSubmonoid.Closure S) (hy : y âˆˆ AddSubmonoid.Closure S) (Hs : âˆ€ (x : m), x âˆˆ S â†’ âˆ€ (y : m), y âˆˆ S â†’ P x y) (h1_Left : âˆ€ (x : m), P 0 x) (h1_Right : âˆ€ (x : m), P x 0) (HMul_Left : âˆ€ (x y z : m), P x z â†’ P y z â†’ P (x + y) z) (HMul_Right : âˆ€ (x y z : m), P z x â†’ P z y â†’ P z (x + y)) : P x y
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (hs : IsCompact S) (U : Î¹ â†’ set Î±) (hUo : âˆ€ (i : Î¹), IsOpen (U i)) (hsU : S âŠ† â‹ƒ (i : Î¹), U i) (hdU : Directed HasSubset.Subset U) : âˆƒ (i : Î¹), S âŠ† U i
{Î± : Type u_1} [UniformSpace Î±] : (Uniformity Î±).has_Basis (Î» (S : set (Î± Ã— Î±)), S âˆˆ Uniformity Î± âˆ§ symmetric_Rel S) Id
{ð•œ : Type u_1} {E : Type u_3} [OrderedSemiring ð•œ] [TopologicalSpace E] [AddCommGroup E] [module ð•œ E] [has_Continuous_Add E] {S : set E} (hs : strict_Convex ð•œ S) (x : E) : strict_Convex ð•œ (x +áµ¥ S)
{v : Type u_1} [InnerProductSpace â„ v] {P : Type u_2} [MetricSpace P] [NormedAddTorsor v P] {A B C D P : P} (h : EuclideanGeometry.Cospherical {A, B, C, D}) (hapc : EuclideanGeometry.angle A P C = Real.Pi) (hbpd : EuclideanGeometry.angle B P D = Real.Pi) : HasDist.dist A B * HasDist.dist C D + HasDist.dist B C * HasDist.dist D A = HasDist.dist A C * HasDist.dist B D
{R : Type u_1} [Linear_ordered_Field R] [FloorRing R] {B : â„•} (hb : 1 < B) {x : â„¤} {r : R} (hr : 0 < r) : r < â†‘B ^ x â†” Int.log B r < x
{Î± : Type u_1} [TopologicalSpace Î±] [PolishSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±] {S : set Î±} (hs : Measurable_set S) : PolishSpace._clopenable S
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} {v : Î¹ â†’ m} [Ring R] [AddCommGroup m] [module R m] {hli : LinearIndependent R v} {hsp : Submodule.Span R (set.Range v) = âŠ¤} {i j : Î¹} : â‡‘((Basis.Mk hli hsp).coord i) (v j) = Ite (j = i) 1 0
{P n : â„•} (h_Pos : 0 < â‡‘(n.central_binom.factorization) P) : P â‰¤ 2 * n
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {R : â„} {C W : â„‚} {F : â„‚ â†’ E} {S : set â„‚} (hs : S.countable) (hw : W âˆˆ Metric.Ball C R) (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : âˆ€ (x : â„‚), x âˆˆ Metric.Ball C R  S â†’ Differentiable_at â„‚ F x) : (2 * â†‘Real.Pi * Complex.i)â»Â¹ â€¢ âˆ® (z : â„‚) in C(C, R), (z - W)â»Â¹ â€¢ F z = F W
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [LinearOrder Î²] [SuccOrder Î²] [IsSuccArchimedean Î²] {S : Î² â†’ set Î±} {t : set Î²} (hnt : t.Nonempty) (ht : t.Ord_connected) (h : âˆ€ (n : Î²), n âˆˆ t â†’ IsConnected (S n)) (K : âˆ€ (n : Î²), n âˆˆ t â†’ Order.Succ n âˆˆ t â†’ (S n âˆ© S (Order.Succ n)).Nonempty) : IsConnected (â‹ƒ (n : Î²) (h : n âˆˆ t), S n)
{R : Type v} [CommRing R] (A : Matrix (Fin 2) (Fin 2) R) : A.det = A 0 0 * A 1 1 - A 0 1 * A 1 0
(R : Type u_3) (m : Type u_4) [AddCommMonoid m] [Semiring R] [module R m] (tr : AddMonoid._torsion R) : AddMonoid._torsion m
{Î± : Type u} [TopologicalSpace Î±] {P : Î± â†’ Prop} {A : Î±} (h : âˆ€á¶  (y : Î±) in nhds A, P y) : P A
{G : Type u_1} [Group G] (h : Group.IsNilpotent (G â§¸ Subgroup.Center G)) : Group.IsNilpotent G
{G : Type u_1} [hG : Group G] [hF : Fintype G] {P : â„•} [hp : Fact (Nat.Prime P)] (h : _P_Group P G) : Group.IsNilpotent G
{P : Type u_2} [MetricSpace P] (P : P) : EuclideanGeometry.Cospherical {P}
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] (v : K) : (GeneralizedContinuedFraction.of v).terminates â†” âˆƒ (q : â„š), v = â†‘q
{E : Type u_1} {PE : Type u_2} [NormedGroup E] [NormedSpace â„ E] [MetricSpace PE] [NormedAddTorsor E PE] {x y : PE} (e : PE â‰ƒáµ¢ PE) : â‡‘e x = x â†’ â‡‘e y = y â†’ â‡‘e (midpoint â„ x y) = midpoint â„ x y
(S t : set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension t A B] (hS : S âŠ† t) : IsCyclotomicExtension S A â†¥(Algebra.Adjoin A {B : B | âˆƒ (A : â„•+), A âˆˆ S âˆ§ B ^ â†‘A = 1})
{R : Type u_1} (m : Type u_3) {A : R} [Monoid R] [MulAction R m] (ua : IsUnit A) : IsSmulRegular m A
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {t : Affine.Triangle â„ P} (ho : t.orthocenter âˆ‰ set.Range t.points) {P : Fin 3 â†’ P} (hps : set.Range P âŠ† HasInsert.Insert t.orthocenter (set.Range t.points)) (hpi : Function.Injective P) : (âˆƒ (iâ‚ iâ‚‚ iâ‚ƒ jâ‚‚ jâ‚ƒ : Fin 3), iâ‚ â‰  iâ‚‚ âˆ§ iâ‚ â‰  iâ‚ƒ âˆ§ iâ‚‚ â‰  iâ‚ƒ âˆ§ (âˆ€ (i : Fin 3), i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ) âˆ§ P iâ‚ = t.orthocenter âˆ§ jâ‚‚ â‰  jâ‚ƒ âˆ§ t.points jâ‚‚ = P iâ‚‚ âˆ§ t.points jâ‚ƒ = P iâ‚ƒ) âˆ¨ set.Range P = set.Range t.points
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] (S : set m) (h : S.Finite) : CompleteLattice.IsCompact_element (Submodule.Span R S)
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : WellFounded r) (S : set Î±) : S.Nonempty â†’ (âˆƒ (A : Î±) (h : A âˆˆ S), âˆ€ (x : Î±), x âˆˆ S â†’ Â¬r x A)
{E : Type u_1} [InnerProductSpace â„ E] {Î¹ : Type u_2} [Fintype Î¹] [DecidableEq Î¹] [Nonempty Î¹] {e : Basis Î¹ â„ E} (h : Orthonormal â„ â‡‘e) (x : Orientation â„ E Î¹) : Orthonormal â„ â‡‘(e.adjust_to_Orientation x)
{Î± : Type u_1} {E' : Type u_6} {E'' : Type u_9} [semi_NormedGroup E'] [NormedGroup E''] {F' : Î± â†’ E'} {l : Filter Î±} {C : E''} (hc : C â‰  0) : (Î» (x : Î±), C) =O[l] F' â†” âˆƒ (B : â„), 0 < B âˆ§ âˆ€á¶  (x : Î±) in l, B â‰¤ âˆ¥F' xâˆ¥
{G : Type u} {n : â„•} [Fintype G] [Add_Left_cancel_Monoid G] (x : G) : Add_order_of (n â€¢ x) = Add_order_of x / (Add_order_of x).Gcd n
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] [CompleteSpace ð•œ] {F F' : ð•œ â†’ ð•œ} (hF : âˆ€ (x : ð•œ), HasStrictDerivAt F (F' x) x) (h0 : âˆ€ (x : ð•œ), F' x â‰  0) : IsOpen_Map F
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] {P : Ideal R} {P : Ideal S} [Algebra R S] [Algebra (R â§¸ P) (S â§¸ P)] [IsScalarTower R (R â§¸ P) (S â§¸ P)] (h : Function.Injective â‡‘(Algebra_Map (R â§¸ P) (S â§¸ P))) : Ideal.comap (Algebra_Map R S) P = P
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {k : S.Localization_Map P} (z : N) : â‡‘(k.Lift _) (â‡‘(F.Lift _) z) = z
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {F : Î± â†’ Î²} {x : Î±} {r : â„} (hr : 0 < r) (K : â„) (h : âˆ€ (y : Î±), HasDist.dist y x < r â†’ HasDist.dist (F y) (F x) â‰¤ K * HasDist.dist y x) : Continuous_at F x
{Î± : Type u_1} {Î² : Type u_2} (F : Î± â†’ Î²) : Function.Injective (Quotient.Lift F _)
{ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedGroup G] [NormedSpace ð•œ G] {F : ð•œ â†’ G} {S : set ð•œ} {x y : ð•œ} {C : â„} (hF : âˆ€ (x : ð•œ), x âˆˆ S â†’ Differentiable_at ð•œ F x) (bound : âˆ€ (x : ð•œ), x âˆˆ S â†’ âˆ¥deriv F xâˆ¥ â‰¤ C) (hs : Convex â„ S) (xs : x âˆˆ S) (ys : y âˆˆ S) : âˆ¥F y - F xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{m : Type u_2} [AddCommGroup m] {ð•œ : Type u_1} [Field ð•œ] [module ð•œ m] {F : m â†’â‚—[ð•œ] m} (hF : â‡‘LinearMap.det F = 0) : F.Range < âŠ¤
{Î± : Type u_1} {Î² : Type u_2} [PseudoEmetricSpace Î±] [Nonempty Î²] [SemilatticeSup Î²] {S : Î² â†’ Î±} : Cauchy_Seq S â†” âˆƒ (B : Î² â†’ Ennreal), (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ HasEdist.edist (S n) (S m) â‰¤ B N) âˆ§ Filter.Tendsto B Filter.at_top (nhds 0)
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] (F : Î² â†’ Î±) (l : Filter Î²) : Filter.Tendsto (Î» (x : Î²), (F x, F x)) l (Uniformity Î±)
{Î´ : Type u_1} [Fintype Î´] {Îº : Î´ â†’ Type u_2} {t : Î  (D : Î´), set (Îº D)} (ht : âˆ€ (D : Î´), (t D).Finite) : (set.Univ.Pi t).Finite
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] (F : m â†’* P) {x y : m} : â‡‘(Con.Ker F) x y â†” â‡‘F x = â‡‘F y
{C : Type u} [CategoryTheory.Category C] {Jâ‚ Jâ‚‚ : CategoryTheory.GrothendieckTopology C} (h : CategoryTheory.Presieve._sheaf Jâ‚ (CategoryTheory.Functor.IsClosed_sieves Jâ‚‚)) : Jâ‚ â‰¤ Jâ‚‚
(E : Type u_1) [AddCommGroup E] : Subsingleton (module â„š E)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) (Î¸ : Real.Angle) : x = â‡‘(hb.rotation Î¸) x â†” x = 0 âˆ¨ Î¸ = 0
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : IsConnected S â†” âˆ€ (U : Finset (set Î±)), (âˆ€ (u v : set Î±), u âˆˆ U â†’ v âˆˆ U â†’ (S âˆ© (u âˆ© v)).Nonempty â†’ u = v) â†’ (âˆ€ (u : set Î±), u âˆˆ U â†’ IsOpen u) â†’ S âŠ† â‹ƒâ‚€â†‘U â†’ (âˆƒ (u : set Î±) (h : u âˆˆ U), S âŠ† u)
{G : Type u_1} [AddCommGroup G] (K : Add_Subgroup G) {Î¹ : Type u_2} {t : Finset Î¹} {F : Î¹ â†’ G} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ K) : t.Sum (Î» (C : Î¹), F C) âˆˆ K
(ð•œ : Type u_1) {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_3} [LinearOrder Î¹] [OrderBot Î¹] [locally_Finite_order Î¹] [IsWellOrder Î¹ has_LT.LT] (F : Î¹ â†’ E) (n : Î¹) : gram_schmidt ð•œ F n = F n - (Finset.Iio n).Sum (Î» (i : Î¹), â†‘(â‡‘(Orthogonal_projection (Submodule.Span ð•œ {gram_schmidt ð•œ F i})) (F n)))
(n : â„•) : (List.Nat.antidiagonal n).Nodup
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {P : FormalMultilinearSeries ð•œ E F} [CompleteSpace F] : Continuous_on P.Sum (Emetric.Ball 0 P.radius)
{Î± J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.Fin_Category J] [SemilatticeInf Î±] [OrderTop Î±] (F : J â¥¤ Î±) : CategoryTheory.Limits.Limit F = Finset.Univ.Inf F.obj
{Î± : Type u_1} [semi_NormedRing Î±] [NormOneClass Î±] (A : Î±) (n : â„•) : âˆ¥A ^ nâˆ¥â‚Š â‰¤ âˆ¥Aâˆ¥â‚Š ^ n
{G : Type u_1} [CategoryTheory.groupoid G] [IsFreeGroupoid G] {x : Type v} [Group x] (F g : G â¥¤ CategoryTheory.SingleObj x) (h : âˆ€ (A B : IsFreeGroupoid.Generators G) (e : A âŸ¶ B), F.Map (IsFreeGroupoid.of e) = g.Map (IsFreeGroupoid.of e)) : F = g
(n : â„•) {R : Type u_1} [Linear_ordered_CommRing R] {x : R} (hx : 1 â‰¤ x) : 0 â‰¤ Polynomial.Eval x (Polynomial.cyclotomic n R)
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (l : List (Matrix n n Î±)) : (l.Prod)â»Â¹ = (List.Map has_Inv.Inv l.reverse).Prod
{R : Type u} [Semiring R] {P : Ideal R} (hmax : âˆ€ (m : Ideal R), P < m â†’ Â¬m.IsMaximal) (J : Ideal R) (hPJ : P < J) : J = âŠ¤
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (P : Cáµ’áµ– â¥¤ A) [CategoryTheory.Limits.HasPullbacks C] (K : CategoryTheory.Pretopology C) : CategoryTheory.Presheaf.IsSheaf (CategoryTheory.Pretopology.to_grothendieck C K) P â†” âˆ€ â¦ƒx : Câ¦„ (R : CategoryTheory.Presieve x), R âˆˆ â‡‘K x â†’ Nonempty (CategoryTheory.Limits.IsLimit (P.Map_cone (CategoryTheory.Sieve.generate R).Arrows.Cocone.Op))
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] {S : Finset Î±} {F : Î± â†’ Î²} {A : Î±} (hp : S.Sum (Î» (x : Î±), F x) = 0) (h1 : âˆ€ (x : Î±), x âˆˆ S â†’ x â‰  A â†’ F x = 0) (x : Î±) (h : x âˆˆ S) : F x = 0
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [DivisionRing R] [DivisionRing S] [module R E] [module S E] (n : â„¤) (x : E) : (â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x
{E : Type u_3} {F : Type u_4} [semi_NormedGroup E] [semi_NormedGroup F] (F : E â†’+ F) (C : â„) (h : âˆ€ (x : E), âˆ¥â‡‘F xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : Continuous â‡‘F
{Î± : Type u} [PseudoEmetricSpace Î±] {Î´â‚ Î´â‚‚ : â„} (Î´â‚‚_Pos : 0 < Î´â‚‚) (hlt : Î´â‚ < Î´â‚‚) (E : set Î±) : Metric.Cthickening Î´â‚ E âŠ† Metric.Thickening Î´â‚‚ E
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] (F : Î± â†’ C(Î², Î³)) (h : Continuous (Function.uncurry (Î» (x : Î±) (y : Î²), â‡‘(F x) y))) : Continuous F
{Î± : Type u} [TopologicalSpace Î±] [LocallyCompactSpace Î±] [RegularSpace Î±] {K U : set Î±} (hK : IsCompact K) (hU : IsOpen U) (hKU : K âŠ† U) : âˆƒ (K' : set Î±), IsCompact K' âˆ§ K âŠ† Interior K' âˆ§ K' âŠ† U
(n : â„•+) (x : â„‚Ë£) : x âˆˆ roots_of_unity n â„‚ â†” âˆƒ (i : â„•) (h : i < â†‘n), Complex.Exp (2 * â†‘Real.Pi * Complex.i * (â†‘i / â†‘n)) = â†‘x
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : Fin 3 â†’ P) : Collinear k (set.Range P) â†” Â¬AffineIndependent k P
{Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {tâ‚ƒ : TopologicalSpace Î²} (hâ‚ : tâ‚‚ â‰¤ tâ‚) {S : set Î±} {F : Î± â†’ Î²} (hâ‚‚ : Continuous_on F S) : Continuous_on F S
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} (h_Mono : StrictMono_on F S) (hs : S âˆˆ nhds_within A (set.ici A)) (hfs : âˆ€ (B : Î²), B > F A â†’ (âˆƒ (C : Î±) (h : C âˆˆ S), F C âˆˆ set.ioc (F A) B)) : Continuous_within_at F (set.ici A) A
{C : Type u} [CategoryTheory.Category C] {x Y Z : AlgebraicGeometry.PresheafedSpace C} (Î± : x âŸ¶ Y) (Î² : Y âŸ¶ Z) (U : (TopologicalSpace.Opens â†¥(Z.carrier))áµ’áµ–) : (Î± â‰« Î²).C.App U = Î².C.App U â‰« Î±.C.App (Opposite.Op ((TopologicalSpace.Opens.Map Î².Base).obj (Opposite.Unop U)))
{n k : â„•} : k â‰¤ n â†’ (n - k).factorial * n.Desc_factorial k = n.factorial
{A B : â„} (h : A < B) : Cardinal.Mk â†¥(set.Ioo A B) = Cardinal.Continuum
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î± â†’ Î³} {x : Î±} {y : Î²} (hF : Continuous_at F x) : Continuous_at (Î» (x : Î± Ã— Î²), F x.fst) (x, y)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} {F : ð•œ â†’ F} {S : set ð•œ} {x : ð•œ} (hxs : UniqueDiffWithinAt ð•œ S x) : iterated_deriv_within (n + 1) F S x = deriv_within (iterated_deriv_within n F S) S x
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [Finite_dimensional ð•œ E] {n : â„•} (hn : Finite_dimensional.finrank ð•œ E = n) {Î¹ : Type u_4} [Fintype Î¹] [DecidableEq Î¹] {v : Î¹ â†’ Submodule ð•œ E} (hV : direct_Sum._internal v) (hV' : OrthogonalFamily ð•œ (Î» (i : Î¹), (v i).Subtypeâ‚—áµ¢)) : Orthonormal ð•œ â‡‘(direct_Sum._internal.subordinate_Orthonormal_Basis hn hV)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) : TendstoLocallyUniformlyOn (Î» (n : â„•) (y : E), P.partial_Sum n y) (Î» (y : E), F (x + y)) Filter.at_top (Emetric.Ball 0 r)
{Î± : Type u} [EmetricSpace Î±] : Continuous (Î» (P : Î± Ã— TopologicalSpace.Closeds Î±), Emetric.Inf_edist P.fst â†‘(P.Snd))
(R : Type u) [Semiring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {m : Î¹ â†’ Type W} [Î  (i : Î¹), AddCommMonoid (m i)] [Î  (i : Î¹), module R (m i)] (S : Finset Î¹) (C : R) (x : Î  (i : â†¥â†‘S), m i.val) : â‡‘(direct_Sum.Mk m S) (C â€¢ x) = C â€¢ â‡‘(direct_Sum.Mk m S) x
{Î± : Type u_1} [PseudoEmetricSpace Î±] (r C : Ennreal) {F : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (F n) (F (n + 1)) â‰¤ C * r ^ n) {A : Î±} (ha : Filter.Tendsto F Filter.at_top (nhds A)) (n : â„•) : HasEdist.edist (F n) A â‰¤ C * r ^ n / (1 - r)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (Pâ‚ Pâ‚‚ : P) : Collinear k {Pâ‚, Pâ‚‚}
{Î± : Type u_1} [DecidableEq Î±] : âˆ….shadow = âˆ…
{R : Type u_1} {S : Type u_2} {m : Type u_3} {S : S} [HasScalar R m] [HasScalar R S] [HasScalar S m] [IsScalarTower R S m] (A : R) (Ab : IsSmulRegular m (A â€¢ S)) : IsSmulRegular m S
{Î± : Type u_1} [semi_NormedGroup Î±] {r C : â„} {F : â„• â†’ Î±} (hr : r < 1) (hF : âˆ€ (n : â„•), âˆ¥F nâˆ¥ â‰¤ C * r ^ n) {A : Î±} (ha : has_Sum F A) (n : â„•) : âˆ¥(Finset.Range n).Sum (Î» (x : â„•), F x) - Aâˆ¥ â‰¤ C * r ^ n / (1 - r)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ AddMon) [CategoryTheory.IsFiltered J] {x x' y : Î£ (j : J), â†¥(F.obj j)} (hxx' : CategoryTheory.Limits.types.filtered_Colimit.Rel (F â‹™ CategoryTheory.Forget AddMon) x x') : AddMon.FilteredColimits.Colimit_Add_aux F x y = AddMon.FilteredColimits.Colimit_Add_aux F x' y
{m : Type u_3} [Monoid m] [Preorder m] (L : List m) (h : L.Prod < 1) : 0 < L.length
{Î± : Type u_1} [TopologicalSpace Î±] {S t : set Î±} (hs : _GÎ´ S) (ht : _GÎ´ t) : _GÎ´ (S âˆª t)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) : o.oangle 0 x = 0
(n : â„•) : n.Totient = n / n.Factors.to_Finset.Prod (Î» (P : â„•), P) * n.Factors.to_Finset.Prod (Î» (P : â„•), P - 1)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) {r : â„} (hr : 0 â‰¤ r) : o.oangle x (r â€¢ x) = 0
{C : Type u} [CategoryTheory.Category C] {A B : C} {F g : A âŸ¶ B} [CategoryTheory.IsCoreflexivePair F g] : CategoryTheory.IsCoreflexivePair g F
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (G : set A) (hG : âˆ€ (x : A), x âˆˆ G â†’ IsIntegral R x) (x : A) (h : x âˆˆ Subring.Closure G) : IsIntegral R x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.Limits.HasLimits_of_size D] [CategoryTheory.CreatesLimitsOfSize F] : CategoryTheory.Limits.HasLimits_of_size C
 : Â¬Summable (Î» (n : â„•), 1 / â†‘n)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] [CategoryTheory.Limits.has_Zero_object C] {x Y : C} (F : x âŸ¶ Y) (hF : âˆ€ (Z : C) (g : Y âŸ¶ Z), F â‰« g = 0 â†’ g = 0) : CategoryTheory.Epi F
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {mâ‚ : Type u_4} [TopologicalSpace mâ‚] [AddCommMonoid mâ‚] {mâ‚‚ : Type u_6} [TopologicalSpace mâ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚ mâ‚] [module Râ‚‚ mâ‚‚] [Ring_hom_surjective Ïƒâ‚â‚‚] [TopologicalSpace Râ‚] [TopologicalSpace Râ‚‚] [has_Continuous_Smul Râ‚ mâ‚] [has_Continuous_Add mâ‚] [has_Continuous_Smul Râ‚‚ mâ‚‚] [has_Continuous_Add mâ‚‚] (F : mâ‚ â†’sl[Ïƒâ‚â‚‚] mâ‚‚) (S : Submodule Râ‚ mâ‚) : Submodule.Map â†‘F S.topological_Closure â‰¤ (Submodule.Map â†‘F S).topological_Closure
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {S : set E} : Convex ð•œ S â†” âˆ€ â¦ƒA B : ð•œâ¦„, 0 â‰¤ A â†’ 0 â‰¤ B â†’ A + B = 1 â†’ A â€¢ S + B â€¢ S âŠ† S
{m : Type u_1} [has_Add m] {N : Type u_2} [has_Add N] (F : Add_hom m N) (hF : Function.Surjective â‡‘F) : F.srange = âŠ¤
{Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), MetricSpace (E i)] (i : Î¹) : Isometry (Sigma.Mk i)
(x : â„) : Real.cosh x = (Real.Exp x + Real.Exp (-x)) / 2
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} : A â‰¤ -B â†’ B â‰¤ -A
{Î± : Type u} [PartialOrder Î±] {A B : Î±} (h : A â‰¤ B) : B = A âˆ¨ A < B
(n : â„•) : â†‘(Nat.fib n) = (GoldenRatio ^ n - golden_Conj ^ n) / Real.sqrt 5
{S : set â„•} (hb : 0 âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) (n : â„•) : n âˆˆ S
{E : Type u_1} [InnerProductSpace â„ E] {C : E} (F : ContDiff_bump_of_inner C) (x : E) : 0 â‰¤ â‡‘F x
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] {A : set x} {F : x â†’ Y} {x : x} (h : âˆƒ (y : Y), Filter.Tendsto F (nhds_within x A) (nhds y)) : Filter.Tendsto F (nhds_within x A) (nhds (extend_from A F x))
(R : Type u) (m : Type v) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] : Finite_dimensional.finrank R m = Fintype.Card (module.free.choose_Basis_Index R m)
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} : -A â‰¤ -B â†’ B â‰¤ A
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {P : Polynomial A} (pmonic : P.monic) (hp : â‡‘(Polynomial.aeval x) P = 0) (pmin : âˆ€ (q : Polynomial A), q.monic â†’ â‡‘(Polynomial.aeval x) q = 0 â†’ P.degree â‰¤ q.degree) : P = minpoly A x
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (i : Fin r âŠ• Unit) {k : â„•} (hk : k â‰¤ r) : (List.Drop k (Matrix.Pivot.List_transvec_col m)).Prod.Mul m (Sum.inr_ ()) i = m (Sum.inr_ ()) i
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {Fâ‚‚ : ð•œ â†’ F} {Sâ‚‚ : set ð•œ} (hs : IsOpen Sâ‚‚) : ContDiff_on ð•œ âŠ¤ Fâ‚‚ Sâ‚‚ â†” DifferentiableOn ð•œ Fâ‚‚ Sâ‚‚ âˆ§ ContDiff_on ð•œ âŠ¤ (deriv Fâ‚‚) Sâ‚‚
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] [DecidableEq Î±] (S : Finset Î±) {F : Î± â†’ Î²} {A : Î±} (h : F A = 1) : (S.erase A).Prod (Î» (x : Î±), F x) = S.Prod (Î» (x : Î±), F x)
{G : Type u_1} [Group G] {S : set G} {x C : G} : x âˆˆ Group.conjugates_of_set S â†’ C * x * Câ»Â¹ âˆˆ Group.conjugates_of_set S
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B C : Î±} : A â‰¤ B * C â†’ Bâ»Â¹ * A â‰¤ C
{R : Type u_1} [non_assoc_Ring R] [Nontrivial R] [no_Zero_divisors R] (hR : Ring_Char R â‰  2) {A : R} : -A = A â†” A = 0
{G : Type u_1} [AddGroup G] {Î¹ : sort u_2} (S : Î¹ â†’ Add_Subgroup G) {C : G â†’ Prop} {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : G), x âˆˆ S i â†’ C x) (h1 : C 0) (HMul : âˆ€ (x y : G), C x â†’ C y â†’ C (x + y)) : C x
{n : Type u_1} {ð•œ : Type u_3} [Field ð•œ] [DecidableEq n] [Fintype n] (P : Matrix n n ð•œ â†’ Prop) (m : Matrix n n ð•œ) (hMdet : m.det â‰  0) (hdiag : âˆ€ (D : n â†’ ð•œ), (Matrix.Diagonal D).det â‰  0 â†’ P (Matrix.Diagonal D)) (htransvec : âˆ€ (t : Matrix.TransvectionStruct n ð•œ), P t.to_Matrix) (HMul : âˆ€ (A B : Matrix n n ð•œ), A.det â‰  0 â†’ B.det â‰  0 â†’ P A â†’ P B â†’ P (A.Mul B)) : P m
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {B : power_Basis S A} (hB : IsIntegral R B.gen) [IsDomain S] {x : A} (hx : âˆ€ (i : Fin B.dim), IsIntegral R (â‡‘(â‡‘(B.Basis.repr) x) i)) (hmin : minpoly S B.gen = Polynomial.Map (Algebra_Map R S) (minpoly R B.gen)) (n : â„•) (i : Fin B.dim) : IsIntegral R (â‡‘(â‡‘(B.Basis.repr) (x ^ n)) i)
{R : Type u} {Î¹ : Type v} {mâ‚ : Î¹ â†’ Type Wâ‚} {mâ‚‚ : Type Wâ‚‚} [DecidableEq Î¹] [CommSemiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] [Î  (i : Î¹), TopologicalSpace (mâ‚ i)] [TopologicalSpace mâ‚‚] (F : Continuous_MultilinearMap R mâ‚ mâ‚‚) [Fintype Î¹] (C : Î¹ â†’ R) (m : Î  (i : Î¹), mâ‚ i) : â‡‘F (Î» (i : Î¹), C i â€¢ m i) = Finset.Univ.Prod (Î» (i : Î¹), C i) â€¢ â‡‘F m
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} (ha : A â‰  0) : Char.quadratic_Char F (A ^ 2) = 1
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} [DiscreteTopology â†¥S] {x : Î±} (hx : x âˆˆ S) : nhds_within x S = has_pure.pure x
{Î± : Type u_1} [canonically_Linear_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B C : Î±} (ha : Add_LE_cancellable A) (hb : Add_LE_cancellable B) (h : B â‰¤ A) : A - B < A - C â†” C < B
{A : Type u_4} [CommRing A] [IsDomain A] {K : Type u_5} [Field K] {L : Type u_7} [Field L] [Algebra A K] [_fraction_Ring A K] {g : A â†’+* L} (hg : Function.Injective â‡‘g) (x : A) : â‡‘(_fraction_Ring.Lift hg) (â‡‘(Algebra_Map A K) x) = â‡‘g x
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : o.oangle x y + o.oangle y x = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Sâ‚ Sâ‚‚ : AffineSubspace k P} (hD : Sâ‚.direction = Sâ‚‚.direction) (hn : â†‘Sâ‚.Nonempty) (hle : Sâ‚ â‰¤ Sâ‚‚) : Sâ‚ = Sâ‚‚
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.Forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.Forget C)] {x : top} (F : top.sheaf C x) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥x) (v : TopologicalSpace.Opens â†¥x) (iUV : Î  (i : Î¹), U i âŸ¶ v) (hcover : v â‰¤ supr U) (S t : â†¥(F.val.obj (Opposite.Op v))) (h : âˆ€ (i : Î¹), â‡‘(F.val.Map (iUV i).Op) S = â‡‘(F.val.Map (iUV i).Op) t) : S = t
{Î± : Type u_1} {o P : Part Î±} (h1 : o.Dom â†” P.Dom) (h2 : âˆ€ (hâ‚ : o.Dom) (hâ‚‚ : P.Dom), o.get hâ‚ = P.get hâ‚‚) : o = P
{Î± : Type u_1} {Î² : Type u_2} (F : Î² â†’ Î± â†’ Î²) (B : Î²) : Vector.scanl F B Vector.Nil = B::áµ¥Vector.Nil
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [LinearOrder Î²] {F : Î± â†’ Î²} (hâ‚ : StrictMono F) (A B : Finset Î±) : (Finset.image F A).to_colex â‰¤ (Finset.image F B).to_colex â†” A.to_colex â‰¤ B.to_colex
{Î± : Type u} [PseudoEmetricSpace Î±] {S : set Î±} : Continuous (Î» (x : Î±), Emetric.Inf_edist x S)
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B C D : Î±} (hc : C â‰  0) (hD : D â‰  0) : (A * D - B * C) / (C * D) â‰¤ 0 â†’ A / C â‰¤ B / D
{Î± : Type u_1} [TopologicalSpace Î±] {U : set Î±} {hU : IsOpen U} : â†‘âŸ¨U, hUâŸ© = U
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î²] {F : Î± â†’ Î²} {x : Î±} [TopologicalSpace Î±] (L : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : set Î±) (h : t âˆˆ nhds x) (F : Î± â†’ Î²), Continuous_at F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (F y, F y) âˆˆ u)) : Continuous_at F x
{x : Type u_1} [TopologicalSpace x] [Infinite x] [DiscreteTopology x] : Â¬Continuous â‡‘(CofiniteTopology.of.Symm)
{ð•œ : Type u_3} [_R_or_C ð•œ] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {F F' : ð•œ â†’ G} {x : ð•œ} (hder : âˆ€á¶  (y : ð•œ) in nhds x, HasDerivAt F (F' y) y) (hcont : Continuous_at F' x) : HasStrictDerivAt F (F' x) x
{n : â„•} (A : Fin (n + 1)) : â†‘(A.val) = A
{g : Equiv.perm (Fin 5)} (ha : g âˆˆ alternating_Group (Fin 5)) (h1 : g â‰  1) (h2 : âˆ€ (n : â„•), n âˆˆ g.Cycle_Type â†’ n = 2) : IsConj (Equiv.Swap 0 4 * Equiv.Swap 1 3) g
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore Î¹ B F) : IsOpen_Map Z.Proj
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {K : Nnreal} {S : set Î±} {F : Î± â†’ Î²} : LipschitzOnWith K F S â†’ âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ HasDist.dist (F x) (F y) â‰¤ â†‘K * HasDist.dist x y
{m : Type u_1} [has_Mul m] {Î² : sort u_2} (C : Con m) (F : m â†’ Î²) (h : âˆ€ (A B : m), â‡‘C A B â†’ F A = F B) (x : m) : Con.Lift_on â†‘x F h = F x
{R : Type u_1} [CommRing R] {Câ‚ Câ‚‚ : R} (q : Quaternion_Algebra R Câ‚ Câ‚‚) : â‡‘clifford_Algebra_Quaternion.of_Quaternion (â‡‘Quaternion_Algebra.Conj q) = â‡‘clifford_Algebra.involute (â‡‘clifford_Algebra.reverse (â‡‘clifford_Algebra_Quaternion.of_Quaternion q))
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} (hs : Convex ð•œ S) (hF : âˆ€ {x y z : ð•œ}, x âˆˆ S â†’ z âˆˆ S â†’ x < y â†’ y < z â†’ (F z - F y) / (z - y) < (F y - F x) / (y - x)) : strict_ConcaveOn ð•œ S F
{Î± : Type u_1} {Î¹ : sort u_4} {l : Filter Î±} {P : Î¹ â†’ Prop} {S : Î¹ â†’ set Î±} {t : set Î±} (hl : l.has_Basis P S) : t âˆˆ l â†” âˆƒ (i : Î¹) (hi : P i), S i âŠ† t
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} {Î³ : Type u_3} [Î  (A : Î±), AddCommMonoid (Î² A)] (S : Finset Î³) (g : Î³ â†’ Î  (A : Î±), Î² A) : S.Sum (Î» (C : Î³), g C) = Î» (A : Î±), S.Sum (Î» (C : Î³), g C A)
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (x : Î± (Fin.Last n)) (P : Î  (i : Fin n), Î± (â‡‘Fin.cast_Succ i)) (i : Fin n) (y : Î± (â‡‘Fin.cast_Succ i)) : Fin.snoc (Function.update P i y) x = Function.update (Fin.snoc P x) (â‡‘Fin.cast_Succ i) y
{x : Type u} [MetricSpace x] [CompactSpace x] [Nonempty x] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : metric.Hausdorff_dist (set.Range (GromovHausdorff.optimal_GH_injl x Y)) (set.Range (GromovHausdorff.optimal_GH_injr x Y)) = GromovHausdorff.GH_dist x Y
{Î± : Type u} [OrderedSemiring Î±] {A B C D : Î±} [has_exists_Add_of_LE Î±] (hba : B â‰¤ A) (hdc : D â‰¤ C) : A â€¢ D + B â€¢ C â‰¤ A â€¢ C + B â€¢ D
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) : o.oangle x 0 = 0
{Î± : Type u} [PseudoEmetricSpace Î±] (Î´ : â„) (E : set Î±) : Metric.Thickening Î´ E = (Î» (x : Î±), Emetric.Inf_edist x E) â»Â¹' set.Iio (Ennreal.of_Real Î´)
{m : Type u_3} {S : Type u_4} [div_Inv_Monoid m] [set_like S m] [hSM : Subgroup_class S m] {h : S} {x y : m} (hx : x âˆˆ h) (hy : y âˆˆ h) : x / y âˆˆ h
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} (hF : strict_Convex_on ð•œ S F) {x y z : ð•œ} (hx : x âˆˆ S) (hz : z âˆˆ S) (hxy : x < y) (hyz : y < z) : (F y - F x) / (y - x) < (F z - F y) / (z - y)
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] [Nontrivial R] (x : R) : IsAlgebraic R (â‡‘(Algebra_Map R A) x)
{G : Type u} [Group G] {x : G} (hx : _of_Fin_order x) : _of_Fin_order xâ»Â¹
{Î± : Type u} [LinearOrder Î±] {x y : Î±} : x < y âˆ¨ y < x â†” x â‰  y
(n : â„•) : âˆƒ (A B C D : â„•), A ^ 2 + B ^ 2 + C ^ 2 + D ^ 2 = n
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] : reflection K * reflection K = 1
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [module.Finite K L] [_alg_IsClosed E] (pB : power_Basis K L) (e : Fin pB.dim â‰ƒ (L â†’â‚[K] E)) [_IsSeparable K L] : â‡‘(Algebra_Map K E) (Algebra.discr K â‡‘(pB.Basis)) = Finset.Univ.Prod (Î» (i : Fin pB.dim), (Finset.Filter (Î» (j : Fin pB.dim), i < j) Finset.Univ).Prod (Î» (j : Fin pB.dim), (â‡‘(â‡‘e j) pB.gen - â‡‘(â‡‘e i) pB.gen) ^ 2))
{A B : Cardinal} (ha : Cardinal.aleph0 â‰¤ A) : A + B = LinearOrder.max A B
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {B : power_Basis S A} (hB : IsIntegral R B.gen) [IsDomain S] {x y : A} (hx : âˆ€ (i : Fin B.dim), IsIntegral R (â‡‘(â‡‘(B.Basis.repr) x) i)) (hy : âˆ€ (i : Fin B.dim), IsIntegral R (â‡‘(â‡‘(B.Basis.repr) y) i)) (hmin : minpoly S B.gen = Polynomial.Map (Algebra_Map R S) (minpoly R B.gen)) (i : Fin B.dim) : IsIntegral R (â‡‘(â‡‘(B.Basis.repr) (x * y)) i)
{R : Type u} {Î¹ : Type u'} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [AddCommMonoid mâ‚‚] [module R mâ‚‚] {mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), AddCommMonoid (mâ‚' i)] [Î  (i : Î¹), module R (mâ‚' i)] (g : MultilinearMap R mâ‚' mâ‚‚) : g.Comp_Linear_Map (Î» (i : Î¹), LinearMap.Id) = g
{A : Ennreal} (h : A â‰  âŠ¤) : Add_LE_cancellable A
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] [UniformSpace Î²] [CompactSpace Î±] [SeparatedSpace Î±] {F : Î± â†’ Î²} (h : Continuous F) : uniform_Continuous F
(Î± : Type u_1) (Î² : Type u_2) [LinearOrder Î±] [LinearOrder Î²] [Encodable Î±] [DenselyOrdered Î²] [Nontrivial Î²] : Nonempty (Î± â†ªo Î²)
{Î± : Type u} [non_unital_Ring Î±] {A B C : Î±} (h : A âˆ£ C) : A âˆ£ B + C â†” A âˆ£ B
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x : C} {R : CategoryTheory.Presieve x} {xâ‚ xâ‚‚ : CategoryTheory.Presieve.FamilyOfElements P â‡‘(CategoryTheory.Sieve.generate R)} (tâ‚ : xâ‚.compatible) (tâ‚‚ : xâ‚‚.compatible) : CategoryTheory.Presieve.FamilyOfElements.Restrict _ xâ‚ = CategoryTheory.Presieve.FamilyOfElements.Restrict _ xâ‚‚ â†’ xâ‚ = xâ‚‚
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {S : set E} {F : E â†’ F} (hF : ContDiff_on ð•œ n F S) : ContDiff_on ð•œ n (Î» (x : E), -F x) S
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A B : Î±} (h : A < B) (S : set Î±) : [S âˆˆ nhds_within B (set.Iio B), S âˆˆ nhds_within B (set.Ico A B), S âˆˆ nhds_within B (set.Ioo A B), âˆƒ (l : Î±) (h : l âˆˆ set.Ico A B), set.Ioo l B âŠ† S, âˆƒ (l : Î±) (h : l âˆˆ set.Iio B), set.Ioo l B âŠ† S].tfae
{Î± : Type u_2} {Î² : Type u_3} {F : Î± â†’ Î²} (hF : Function.Injective F) : Filter.Tendsto F Filter.cofinite Filter.cofinite
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [PseudoMetricSpace Î²] {x : Î±} : Continuous (Î» (F : bounded_Continuous_Function Î± Î²), â‡‘F x)
{Î³ : Type W} [MetricSpace Î³] {x y : Î³} : HasNndist.nndist x y = 0 â†’ x = y
{R : Type u_1} {m : Type u_2} [AddCommMonoid m] [CommRing R] [Nontrivial R] [h : Algebra.Finite_Type R (AddMonoid_Algebra R m)] : AddMonoid.fg m
{Î± : Type u} [TopologicalSpace Î±] (x : Î±) [(nhds_within x {x}á¶œ).Ne_IsBot] : Interior {x} = âˆ…
{m : Type u_1} {n : Type u_2} {R : Type u_3} {S : Type u_4} [CommSemiring R] [CommSemiring S] (F : R â†’+* S) (A : Matrix m n S) : (Matrix.mv_Polynomial.x m n R).Map (mv_Polynomial.Evalâ‚‚ F (Î» (P : m Ã— n), A P.fst P.Snd)) = A
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) (x : m) (y : â†¥S) : â‡‘(F.Lift hg) (F.Mk' x y) = â‡‘g x * â†‘(â‡‘(IsUnit.Lift_Right (g.Restrict S) hg) y)â»Â¹
{Î± : Type uu} [DecidableEq Î±] {lâ‚ lâ‚‚ : List Î±} (h : âˆ€ (x : Î±), x âˆˆ lâ‚ â†’ List.count x lâ‚ â‰¤ List.count x lâ‚‚) : lâ‚ ++ lâ‚‚.Diff lâ‚ ~ lâ‚‚
{Î± : Type u} {F g : Î± â†’ Î±} (h : Function.Commute F g) : set.Inv_on F g (Function.FixedPoints (F âˆ˜ g)) (Function.FixedPoints (F âˆ˜ g))
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 : P) : EuclideanGeometry.angle P1 P2 P2 = Real.Pi / 2
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : 2 â€¢ hb.oangle x (-y) = 2 â€¢ hb.oangle x y
{Î± : Type u_1} {E : Type u_3} [semi_NormedGroup E] {l : Filter Î±} {F : Î± â†’ E} (h : Filter.Tendsto (Î» (y : Î±), âˆ¥F yâˆ¥) l Filter.at_top) (x : E) : âˆ€á¶  (y : Î±) in l, F y â‰  x
{Î± : Type u_1} [Preorder Î±] {A B : Î±} (h : A â‰¤ B) : set.Iio A âŠ† set.Iic B
{R : Type u_1} {A : R} [Monoid R] (n : â„•) (ra : IsRegular A) : IsRegular (A ^ n)
{Î± : Type u_2} {Î² : Type u_3} [Ring Î±] [IsDomain Î±] [Ring Î²] (F : Î² â†’+* Î±) (hF : Function.Injective â‡‘F) : IsDomain Î²
{Î± : Type u} {Î² : Type v} {Î³ : Type W} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [conditionally_complete_LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] [Nonempty Î³] {F : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : Continuous_at F (â¨… (i : Î³), g i)) (Mf : Monotone F) (h : BddBelow (set.Range g)) : F (â¨… (i : Î³), g i) = â¨… (i : Î³), F (g i)
{Î± : Type u_1} {Î² : Type u_2} [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) (h : Fintype.Card Î² < Fintype.Card Î±) : âˆƒ (x y : Î±), x â‰  y âˆ§ F x = F y
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {n : â„•} (hn : Finite_dimensional.finrank K v = n.Succ) : Nontrivial v
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_at F B) : deriv (Î» (u : â„), âˆ« (x : â„) in A..u, F x) B = F B
{R : Type u} [Semiring R] (P q : Polynomial R) (n : â„•) : (P * q).Coeff n = (Finset.Nat.antidiagonal n).Sum (Î» (x : â„• Ã— â„•), P.Coeff x.fst * q.Coeff x.Snd)
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : top} (F : x âŸ¶ Y) [CategoryTheory.Limits.HasProducts C] {F : top.Presheaf C x} (h : F._sheaf) : (F _* F)._sheaf
(n : â„•) : Filter.Tendsto (Î» (x : â„), x ^ n * Real.Exp (-x)) Filter.at_top (nhds 0)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P : P) (h : S.Sum (Î» (i : Î¹), W i) = 1) : â‡‘(S.affine_combination (Î» (_x : Î¹), P)) W = P
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [order_IsClosed_topology Î±] [Nonempty Î±] {S : set Î±} (hs : IsCompact S) : BddBelow S
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z â†’ B} [TopologicalSpace Z] (h : IsTopologicalFiberBundle F Proj) : Continuous Proj
{Î± : Type u_1} [TopologicalSpace Î±] [non_assoc_Ring Î±] [has_Continuous_Mul Î±] : has_Continuous_Neg Î±
{Î± : Type u} [PseudoEmetricSpace Î±] {Î´ : â„} (E : set Î±) : E âŠ† Metric.Cthickening Î´ E
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {P : P} {S : set P} (hp : P âˆˆ S) : P âˆˆ affine_Span k S
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) : S.IsAlgebraic â†” Algebra.IsAlgebraic R â†¥S
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.HasPushouts C] : CategoryTheory.Limits.HasBinaryCoproducts C
{R : Type u_1} [CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {C : tensor_Algebra R m â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(Algebra_Map R (tensor_Algebra R m)) r)) (h_grade1 : âˆ€ (x : m), C (â‡‘(tensor_Algebra.Î¹ R) x)) (h_Mul : âˆ€ (A B : tensor_Algebra R m), C A â†’ C B â†’ C (A * B)) (h_Add : âˆ€ (A B : tensor_Algebra R m), C A â†’ C B â†’ C (A + B)) (A : tensor_Algebra R m) : C A
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [Preorder Î±] [t : order_IsClosed_topology Î±] {F g : Î² â†’ Î±} {B : Filter Î²} {Aâ‚ Aâ‚‚ : Î±} [B.Ne_IsBot] (hF : Filter.Tendsto F B (nhds Aâ‚)) (hg : Filter.Tendsto g B (nhds Aâ‚‚)) (h : F â‰¤á¶ [B] g) : Aâ‚ â‰¤ Aâ‚‚
{Î± : Type u_1} [LinearOrder Î±] [DecidableEq Î±] {P : Finset Î± â†’ Prop} (S : Finset Î±) (h0 : P âˆ…) (step : âˆ€ (A : Î±) (S : Finset Î±), (âˆ€ (x : Î±), x âˆˆ S â†’ x < A) â†’ P S â†’ P (HasInsert.Insert A S)) : P S
{R : Type u_1} [CommRing R] (g : Matrix.special_Linear_Group (Fin 2) R) : _IsCoprime (â†‘g 1 0) (â†‘g 1 1)
(Î± : Type u) [Preorder Î±] [Nonempty Î±] [NoMinOrder Î±] [NoMaxOrder Î±] : âˆƒ (F : â„¤ â†’ Î±), StrictAnti F
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [UniformSpace Î±] [UniformSpace Î²] [SeparatedSpace Î±] [LocallyCompactSpace Î±] [CompactSpace Î²] [SeparatedSpace Î²] [UniformSpace Î³] (F : Î± â†’ Î² â†’ Î³) (h : Continuous â†¿F) (x : Î±) : TendstoUniformly F (F x) (nhds x)
{K : Type u_1} [Field K] [number_Field K] : number_Field.ClassNumber K = 1 â†” _principal_Ideal_Ring â†¥(number_Field.Ring_of_integers K)
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (hx : x â‰  0) (hy : y â‰  0) : âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” InnerProductGeometry.angle x y = Real.Pi
{ð•œ : Type u} [hnorm : nondiscrete_NormedField ð•œ] {E : Type v} [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul ð•œ E] [CompleteSpace ð•œ] [t2_Space E] {Î¹ : Type u_1} [Fintype Î¹] (Î¾ : Basis Î¹ ð•œ E) : Continuous â‡‘(Î¾.Equiv_fun)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {F : Type u_6} [NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} {E' : Type u_10} [semi_NormedGroup E'] [NormedSpace ð•œ E'] [Ring_hom_isometric Ïƒâ‚â‚‚] {F : â„• â†’ (E' â†’sl[Ïƒâ‚â‚‚] F)} {g : E' â†’sl[Ïƒâ‚â‚‚] F} (hg : Filter.Tendsto (Î» (n : â„•) (x : E'), â‡‘(F n) x) Filter.at_top (nhds â‡‘g)) (hF : Cauchy_Seq F) : Filter.Tendsto F Filter.at_top (nhds g)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set â„} [IntervalIntegral.FTC_Filter A (nhds_within A S) (nhds_within A t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within A t) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_within_at F t A) : HasDerivWithinAt (Î» (u : â„), âˆ« (x : â„) in u..B, F x) (-F A) S A
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) (Î¸ : Real.Angle) : â‡‘(o.rotation Î¸) x = x â†” x = 0 âˆ¨ Î¸ = 0
{R : Type u} [non_assoc_Semiring R] (S : set R) : â†‘(Subsemiring.Closure S) = â†‘(AddSubmonoid.Closure â†‘(Submonoid.Closure S))
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {S : Finset Î¹} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) {A : Î¹ â†’ Î¹ â†’ ð•œ} : S.Sum (Î» (i : Î¹), S.Sum (Î» (j : Î¹), A i j â€¢ HasInner.inner (v j) (v i))) = S.Sum (Î» (k : Î¹), A k k)
{K : Type u} {v vâ‚ : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [AddCommGroup vâ‚] [module K vâ‚] : Nonempty (v â‰ƒâ‚—[K] vâ‚) â†” module.rank K v = module.rank K vâ‚
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e e' : LocalHomeomorph Î± Î²} (h : e â‰ˆ e') : set.Eq_on â‡‘e â‡‘e' e.to_local_Equiv.Source
{Î± : Type u_1} [Linear_ordered_Field Î±] [floor_Semiring Î±] (m n : â„•) : âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n
{K L : Type} [Field K] [Field L] [_alg_IsClosed K] [_alg_IsClosed L] (P : â„•) [Char_P K P] [Char_P L P] (hK : Cardinal.aleph0 < Cardinal.Mk K) (hKL : Cardinal.Mk K = Cardinal.Mk L) : K â‰ƒ+* L
{Î± : Type u_1} [hÎ± : UniformSpace Î±] (h : Uniformity Î± = Filter.principal Id_Rel) : DiscreteTopology Î±
{B m D : â„•} (hb : 2 â‰¤ B) (hD : D âˆˆ B.digits m) : D < B
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : o.oangle x (â‡‘(o.rotation Î¸) y) = o.oangle x y + Î¸
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : Î± â‰ƒâ‚œ Î²) {B : Î²} {F : Î² â†’ E} {g : Î² â†’ F} : F =O[nhds B] g â†” (F âˆ˜ â‡‘e) =O[nhds (â‡‘(e.Symm) B)] (g âˆ˜ â‡‘e)
(G : Add_Subgroup â„) : Dense â†‘G âˆ¨ âˆƒ (A : â„), G = Add_Subgroup.Closure {A}
{n : â„•} {Î± : Type u_1} [Preorder Î±] {F : Fin (n + 1) â†’ Î±} : StrictMono F â†” âˆ€ (i : Fin n), F (â‡‘Fin.cast_Succ i) < F i.Succ
{R : Type u_1} [CommRing R] {m : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] {Râ‚˜ : Type u_4} {Sâ‚˜ : Type u_5} [CommRing Râ‚˜] [CommRing Sâ‚˜] [Algebra R Râ‚˜] [IsLocalization m Râ‚˜] [Algebra S Sâ‚˜] [IsLocalization (Algebra.Algebra_Map_Submonoid S m) Sâ‚˜] (h : Algebra.IsIntegral R S) : (IsLocalization.Map Sâ‚˜ (Algebra_Map R S) _).IsIntegral
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasWideEqualizers C] {t : C} (hT : âˆ€ (x : C), Nonempty (t âŸ¶ x)) : CategoryTheory.Limits.HasInitial C
{x y : Pgame} : x.lf y â†” (âˆƒ (i : y.Left_moves), x â‰¤ y.move_Left i) âˆ¨ âˆƒ (j : x.Right_moves), x.move_Right j â‰¤ y
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x : v} (hx : x â‰  0) (Î¸ : Real.Angle) : o.oangle x (â‡‘(o.rotation Î¸) x) = Î¸
{G : Type u_1} {h : Type u_2} [Group G] {N : Subgroup G} [Group h] {F : G â†’* h} (hN : N = F.Ker) (tH : Monoid._torsion h) (tN : Monoid._torsion â†¥N) : Monoid._torsion G
{Î± : Type u_1} {Î² : Type u_2} (e : local_Equiv Î± Î²) : e.Symm.Trans e â‰ˆ local_Equiv.of_set e.Target
{Î± : Type u_1} {Î² : Type u_2} [PartialOrder Î±] [Preorder Î²] {fa : Î± â‰ƒo Î±} {fb : Î² â†ªo Î²} {g : Î± â†’ Î²} (h : Function.Semiconj g â‡‘fa â‡‘fb) {g' : Î² â†’ Î±} (hg' : IsOrderRightAdjoint g g') : Function.Semiconj g' â‡‘fb â‡‘fa
{v : Type u_1} (Î± : Type u_2) (G : SimpleGraph v) [Decidable_Rel G.Adj] [MulZeroOneClass Î±] [Nontrivial Î±] : _.to_graph = G
{Î± : Type u_1} {Î² : Type u_2} {e e' : local_Equiv Î± Î²} (h : e â‰ˆ e') : set.Eq_on â‡‘(e.Symm) â‡‘(e'.Symm) e.Target
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Limits.HasEqualizers C
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] (S : Type u_3) [CommMonoid S] [Distrib_MulAction S m] [SmulCommClass S R m] : module._torsion' m S â†” Submodule.torsion' R m S = âŠ¤
(Î¹ : Type u_1) [Fintype Î¹] : IsClosed (StdSimplex â„ Î¹)
{Î± : Type u_1} [Preorder Î±] [SuccOrder Î±] {A B : Î±} [NoMaxOrder Î±] : A < B â†’ Order.Succ A < Order.Succ B
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (z : v) (h : InnerProductGeometry.angle x y = Real.Pi) : InnerProductGeometry.angle x z + InnerProductGeometry.angle y z = Real.Pi
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (Î¸ : Real.Angle) : o.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
{Î² : Type u} {Î± : Type v} {S : Finset Î±} {A : Î±} {F : Î± â†’ Î²} [AddCommMonoid Î²] [DecidableEq Î±] (h : A âˆ‰ S â†’ F A = 0) : (HasInsert.Insert A S).Sum (Î» (x : Î±), F x) = S.Sum (Î» (x : Î±), F x)
{Î± : Type u_1} {Î¹ : sort u_4} [CompleteLattice Î±] (F : Î¹ â†’ Î±) : (â¨… (i : {i // F i â‰  âŠ¤}), F â†‘i) = â¨… (i : Î¹), F i
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} : metric.Hausdorff_dist S (Closure S) = 0
{ð•œ : Type u_1} {_x : Ring ð•œ} {E : Type u_2} [semi_NormedGroup E] {_x_1 : module ð•œ E} {S : Submodule ð•œ E} (x : â†¥S) : âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
{n : â„•} {F : Typevec (n + 1) â†’ Type u} [Mvfunctor F] [q : Mvqpf F] {Î± : Typevec n} (r : Mvqpf.Cofix F Î± â†’ Mvqpf.Cofix F Î± â†’ Prop) (h : âˆ€ (x y : Mvqpf.Cofix F Î±), r x y â†’ Mvfunctor.Liftr' (Î±.Rel_Last' r) x.dest y.dest) (x y : Mvqpf.Cofix F Î±) : r x y â†’ x = y
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A âˆˆ t) (hb : S.Sum (Î» (x : Î±), W x) < t.Card â€¢ B) : âˆƒ (y : Î²) (h : y âˆˆ t), (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x) < B
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {F : Filter Î±} {A : Î±} [F.Ne_IsBot] : F â‰¤ nhds A â†’ F.limsup = A
{S : Type u} [has_Mul S] {A x y : S} (h : SemiconjBy A x y) : A * x = y * A
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [TopologicalSpace Î±] [UniformSpace Î²] {K : set Î±} (F : C(Î±, Î²)) (hK : IsCompact K) {U : set Î²} (hU : IsOpen U) (hF : F âˆˆ Continuous_Map.IsCompact_IsOpen.gen K U) : âˆƒ (v : set (Î² Ã— Î²)) (h : v âˆˆ Uniformity Î²), IsOpen v âˆ§ Continuous_Map.IsCompact_conv_nhd K v F âŠ† Continuous_Map.IsCompact_IsOpen.gen K U
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : â„•} {i : Fin (n + 1)} : x.Ïƒ i â‰« x.Î´ (â‡‘Fin.cast_Succ i) = ðŸ™ (x.obj (Opposite.Op (SimplexCategory.Mk n)))
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) : Fin.Cons (q 0) (Fin.tail q) = q
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (S : Submodule K v) : module.rank K â†¥S â‰¤ 1 â†” âˆƒ (vâ‚€ : v) (h : vâ‚€ âˆˆ S), S â‰¤ Submodule.Span K {vâ‚€}
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (v W : E) (h : W âˆˆ K) : HasInner.inner (v - Orthogonal_projection_fn K v) W = 0
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A B : Î±} (hab : A < B) (S : set Î±) : [S âˆˆ nhds_within A (set.ici A), S âˆˆ nhds_within A (set.icc A B), S âˆˆ nhds_within A (set.Ico A B), âˆƒ (u : Î±) (h : u âˆˆ set.ioc A B), set.Ico A u âŠ† S, âˆƒ (u : Î±) (h : u âˆˆ set.ioi A), set.Ico A u âŠ† S].tfae
{C : Type u} [CategoryTheory.Category C] {P q R : C} (F : P âŸ¶ q) (g : q âŸ¶ R) [CategoryTheory.StrongEpi F] [CategoryTheory.StrongEpi g] : CategoryTheory.StrongEpi (F â‰« g)
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {Î¹ : Type u_6} [DecidableEq Î¹] {mâ‚‚ : Type u_7} [AddCommMonoid mâ‚‚] [module R mâ‚‚] {mâ‚ƒ : Type u_8} [AddCommMonoid mâ‚ƒ] [module R mâ‚ƒ] (F : AlternatingMap R m N Î¹) (gâ‚ : mâ‚‚ â†’â‚—[R] m) (gâ‚‚ : mâ‚ƒ â†’â‚—[R] mâ‚‚) : (F.Comp_Linear_Map gâ‚).Comp_Linear_Map gâ‚‚ = F.Comp_Linear_Map (gâ‚.Comp gâ‚‚)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B : Î±} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{R : Type u_1} [CommSemiring R] (S : Subsemiring R) (m : Multiset R) : (âˆ€ (A : R), A âˆˆ m â†’ A âˆˆ S) â†’ m.Prod âˆˆ S
{n n' : â„•} (m : â„•) (i : Fin n') (h : n' = n) : â‡‘(Fin.cast_Add m) (â‡‘(Fin.cast h) i) = â‡‘(Fin.cast _) (â‡‘(Fin.cast_Add m) i)
{F : Type} [Field F] (q : â„•) [hq : Fact (Nat.Prime q)] [hF : Char_P F q] (g g' : Polynomial F) (m m' : â„•) (h_expand : â‡‘(Polynomial.expand F (q ^ m)) g = â‡‘(Polynomial.expand F (q ^ m')) g') (h : m < m') (hg : g.IsSeparable) : g.Nat_degree = g'.Nat_degree
{Î± : Type u_1} {n : Type u_4} [comm_Semigroup Î±] [AddCommMonoid Î±] [Fintype n] [AddCommGroup n] (v W : n â†’ Î±) : (Matrix.circulant v).Mul (Matrix.circulant W) = (Matrix.circulant W).Mul (Matrix.circulant v)
{Î± : Type u} [PseudoMetricSpace Î±] (x y : Î±) : HasNndist.nndist x y = (HasDist.dist x y).to_Nnreal
(Î± : Type u_1) [PartialOrder Î±] : WellFounded Gt â†” âˆ€ (A : â„• â†’o Î±), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘A n = â‡‘A m
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + 2 * HasInner.inner x y + HasInner.inner y y
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {n : â„•} [Fact (Finite_dimensional.finrank ð•œ E = n + 1)] {v : E} (hv : v â‰  0) : Finite_dimensional.finrank ð•œ â†¥(Submodule.Span ð•œ {v})á—® = n
{v : Type u_4} [InnerProductSpace â„‚ v] (t : v â†’â‚—[â„‚] v) (x y : v) : HasInner.inner (â‡‘t y) x = (HasInner.inner (â‡‘t (x + y)) (x + y) - HasInner.inner (â‡‘t (x - y)) (x - y) + Complex.i * HasInner.inner (â‡‘t (x + Complex.i â€¢ y)) (x + Complex.i â€¢ y) - Complex.i * HasInner.inner (â‡‘t (x - Complex.i â€¢ y)) (x - Complex.i â€¢ y)) / 4
{Î¹â‚ : Type u_1} {Î¹â‚‚ : Type u_2} {R : Type u_3} {Râ‚‚ : Type u_4} {S : Type u_5} {Sâ‚‚ : Type u_6} {m : Type u_7} {N : Type u_8} {P : Type u_9} [CommRing R] [CommRing S] [CommRing Râ‚‚] [CommRing Sâ‚‚] [AddCommGroup m] [AddCommGroup N] [AddCommGroup P] [module R m] [module S N] [module Râ‚‚ P] [module Sâ‚‚ P] [SmulCommClass Sâ‚‚ Râ‚‚ P] {Ïâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚â‚‚ : S â†’+* Sâ‚‚} (Bâ‚ : Basis Î¹â‚ R m) (Bâ‚‚ : Basis Î¹â‚‚ S N) {B B' : m â†’â‚›â‚—[Ïâ‚â‚‚] N â†’â‚›â‚—[Ïƒâ‚â‚‚] P} (h : âˆ€ (i : Î¹â‚) (j : Î¹â‚‚), â‡‘(â‡‘B (â‡‘Bâ‚ i)) (â‡‘Bâ‚‚ j) = â‡‘(â‡‘B' (â‡‘Bâ‚ i)) (â‡‘Bâ‚‚ j)) : B = B'
{P : â„•} : Summable (Î» (n : â„•), (â†‘n ^ P)â»Â¹) â†” 1 < P
{Î± : Type u_1} {Î² : Type u_2} [CompleteLattice Î±] {F : Filter Î²} : F.liminf (Î» (x : Î²), âŠ¤) = âŠ¤
{Î± : Type u} [MetricSpace Î±] (x : â„• â†’ Î±) (A B : Î±) : HasDist.dist (Kuratowski_Embedding.Embedding_of_Subset x A) (Kuratowski_Embedding.Embedding_of_Subset x B) â‰¤ HasDist.dist A B
{Î± : Type u_1} {Î² : Type u_2} [Fintype Î±] [CompleteLattice Î²] (F : Î± â†’ Î²) : Finset.Univ.Sup F = supr F
{Î± : Type u_1} [generalized_boolean_Algebra Î±] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] (u v : Î±) (S : Finset Î±) : (Uv.Compression u v S).Card = S.Card
{R : Type u} {Î¹ : Type W} (S : Finset Î¹) [CommSemiring R] [no_Zero_divisors R] (F : Î¹ â†’ Polynomial R) [Nontrivial R] : (S.Prod (Î» (i : Î¹), F i)).degree = S.Sum (Î» (i : Î¹), (F i).degree)
 : â‡‘LinearMap.det Complex.Conj_ae.to_Linear_Map = -1
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {vâ‚ vâ‚‚ : m} (h : SameRay R vâ‚ vâ‚‚) : âˆƒ (A B : R), 0 â‰¤ A âˆ§ 0 â‰¤ B âˆ§ A + B = 1 âˆ§ vâ‚ = A â€¢ (vâ‚ + vâ‚‚) âˆ§ vâ‚‚ = B â€¢ (vâ‚ + vâ‚‚)
{Î± : Type u} [PseudoEmetricSpace Î±] {S : set Î±} (hs : IsCompact S) : âˆƒ (t : set Î±) (h : t âŠ† S), t.countable âˆ§ S âŠ† Closure t
{S : Type v} [CommRing S] {R : Type u} (C : â„¤ â†’+* S) (F : mv_Polynomial R â„¤ â†’+* S) (x : mv_Polynomial R â„¤) : mv_Polynomial.Evalâ‚‚ C (â‡‘F âˆ˜ mv_Polynomial.x) x = â‡‘F x
{Î± : Type u_1} [Add_Semigroup Î±] (x y : Î±) : has_Add.Add x âˆ˜ has_Add.Add y = has_Add.Add (x + y)
{A : Type u} {B : Type v} {Î¹ : Type W} [CommRing A] [CommRing B] [Algebra A B] [Fintype Î¹] [DecidableEq Î¹] (B : Î¹ â†’ B) (P : Matrix Î¹ Î¹ A) : Algebra.discr A (Matrix.vec_Mul B (P.Map â‡‘(Algebra_Map A B))) = P.det ^ 2 * Algebra.discr A B
{B : â„•} {S : set â„•} (hb : B âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) {n : â„•} (hbn : B â‰¤ n) : n âˆˆ S
{G : Type u} [AddGroup G] (h : Add_Subgroup G) (h : Subsingleton (G â§¸ h)) : h = âŠ¤
{Î± : Type u_1} {m : Type u_5} [has_Zero m] {F g : Î± â†’â‚€ m} : â‡‘F = â‡‘g â†” F = g
{R : Type u} [Ring R] : CategoryTheory.Limits.HasCokernels (module R)
{Î± : Type u_1} {Î² : Type u_2} (t : Î±) (ts ys : List Î±) (F : List Î± â†’ Î²) : List.Map F (List.PermutationsAux2 t ts List.Nil ys Id).Snd = (List.PermutationsAux2 t ts List.Nil ys F).Snd
{F : â„ â†’ â„} (hF : Differentiable â„ F) (hF'_anti : StrictAnti (deriv F)) : strict_ConcaveOn â„ set.Univ F
{Î± : Type u} [PseudoMetricSpace Î±] {x : Î±} : Metric.diam {x} = 0
{n : â„•} : 0 < n â†’ 0 < SzemerediRegularity.step_bound n
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [module ð•œ E] {S : set E} (hs : Convex ð•œ S) (z : E) : Convex ð•œ ((Î» (x : E), z + x) â»Â¹' S)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e : LocalHomeomorph Î± Î²} {S : set Î±} {t : set Î²} : e._image S t â†’ e.to_local_Equiv.Target âˆ© â‡‘(e.Symm) â»Â¹' S = e.to_local_Equiv.Target âˆ© t
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [IsTrans Î± r] (F : â„• â†’ Î±) : âˆƒ (g : â„• â†ªo â„•), (âˆ€ (m n : â„•), m < n â†’ r (F (â‡‘g m)) (F (â‡‘g n))) âˆ¨ âˆ€ (m n : â„•), m < n â†’ Â¬r (F (â‡‘g m)) (F (â‡‘g n))
{m : Type u_1} [AddMonoid m] {x : m} : x âˆˆ Multiples x
 : Filter.Tendsto Complex.Exp (Filter.comap Complex.re Filter.at_top) (Filter.comap Complex.Abs Filter.at_top)
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {S : Î² â†’ Î² â†’ Prop} : Function.Injective Coe_fn
{R S : Type u} [CommRing R] [CommRing S] (m : Submonoid R) (R' : Type u) [CommRing R'] [Algebra R R'] [Algebra R' S] [Algebra R S] [IsScalarTower R R' S] [IsLocalization m R'] (S : set S) (x : S) (hx : x âˆˆ Algebra.Adjoin R' S) : âˆƒ (t : â†¥m), t â€¢ x âˆˆ Algebra.Adjoin R S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Finite_coproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.has_Finite_colimits C
{G : Type u_1} [Group G] {k : set G} {P : G â†’ Prop} {x : G} (h : x âˆˆ Subgroup.Closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ P x) (h1 : P 1) (HMul : âˆ€ (x y : G), P x â†’ P y â†’ P (x * y)) (Hinv : âˆ€ (x : G), P x â†’ P xâ»Â¹) : P x
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [SuccOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Antitone F) : Pairwise (Disjoint on Î» (n : Î±), set.ioc (F (Order.Succ n)) (F n))
{G : Type u} {x : G} [AddMonoid G] : 0 < Add_order_of x â†” _of_Fin_Add_order x
{R : Type u} [CommSemiring R] [Star_Ring R] {x : R} : â‡‘(Star_Ring_end R) x = HasStar.Star x
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (v : v) (nz : v â‰  0) : Finite_dimensional.finrank K v = 1 â†” âˆ€ (W : v), âˆƒ (C : K), C â€¢ v = W
{G : Type W} [TopologicalSpace G] [has_Inv G] [has_Mul G] [has_Continuous_Mul G] [has_Continuous_Inv G] : Continuous (Î» (g : G Ã— G), g.fst * g.Snd * (g.fst)â»Â¹)
{E : Type u_3} [semi_NormedGroup E] (u v : E) : âˆ¥vâˆ¥â‚Š â‰¤ âˆ¥uâˆ¥â‚Š + âˆ¥u - vâˆ¥â‚Š
{Î± : Type u_1} {Î² : Type u_2} [AddCommMonoid Î±] [TopologicalSpace Î±] : has_Sum (Î» (B : Î²), 0) 0
{Î± : Type u_1} {m : Type u_5} {N : Type u_6} [CommMonoid m] [CommMonoid N] {S : set Î±} {F : Î± â†’ m} (g : m â†’* N) (hâ‚€ : (S âˆ© Function.MulSupport F).Finite) : â‡‘g (finprod (Î» (j : Î±), finprod (Î» (h : j âˆˆ S), F j))) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), â‡‘g (F i)))
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] {x : B} (h : IsIntegral R x) : IsIntegral A x
{Î± : Type u_1} [TopologicalSpace Î±] [t2_Space Î±] [MeasurableSpace Î±] [BorelSpace Î±] {F g : (â„• â†’ â„•) â†’ Î±} (hF : Continuous F) (hg : Continuous g) (h : Disjoint (set.Range F) (set.Range g)) : MeasureTheory.measurably_IsSeparable (set.Range F) (set.Range g)
{n : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero â†‘â†‘n] (hn : Prime_Pow â†‘n) [IsCyclotomicExtension {n} K L] (hirr : Irreducible (Polynomial.cyclotomic â†‘n K)) (h : n â‰  2) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta n K L - 1) = â†‘(â†‘n.min_fac)
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [comm_Group Î²] {F g : Î± â†’ Î²} (hF : _Group_hom F) (hg : _Group_hom g) : _Group_hom (Î» (A : Î±), F A * g A)
{R : Type u} {n : â„•} {m : Fin n.Succ â†’ Type W} {mâ‚‚ : Type Wâ‚‚} [Semiring R] [Î  (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid mâ‚‚] [Î  (i : Fin n.Succ), module R (m i)] [module R mâ‚‚] [Î  (i : Fin n.Succ), TopologicalSpace (m i)] [TopologicalSpace mâ‚‚] (F : Continuous_MultilinearMap R m mâ‚‚) (m : Î  (i : Fin n), m i.Succ) (C : R) (x : m 0) : â‡‘F (Fin.Cons (C â€¢ x) m) = C â€¢ â‡‘F (Fin.Cons x m)
{G : Type u} {n : â„•} [Fintype G] [Left_cancel_Monoid G] (x : G) : order_of (x ^ n) = order_of x / (order_of x).Gcd n
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] [PolishSpace Î²] {F : Î± â†’ Î²} (hF : IsClosed_Embedding F) : PolishSpace Î±
{Î“ : Type u_1} [Inhabited Î“] (l : Turing.List_blank Î“) : âˆƒ (A : Î“) (l' : Turing.List_blank Î“), l = Turing.List_blank.Cons A l'
{E : Type u_2} [semi_NormedGroup E] [NormedSpace â„ E] {S : set E} (hsâ‚€ : 0 âˆˆ S) (hsâ‚ : Convex â„ S) (hsâ‚‚ : IsOpen S) {xâ‚€ : E} (hxâ‚€ : xâ‚€ âˆ‰ S) : âˆƒ (F : E â†’L[â„] â„), â‡‘F xâ‚€ = 1 âˆ§ âˆ€ (x : E), x âˆˆ S â†’ â‡‘F x < 1
{B m D : â„•} : D âˆˆ (B + 2).digits m â†’ D < B + 2
{Î± : sort u_1} {P : Î± â†’ Prop} (P : âˆƒ (A : Î±), P A) : P P.Some
{Î± : Type u} [PseudoEmetricSpace Î±] {Î´ : â„} {S : set Î±} {x : Î±} : Emetric.Inf_edist x S â‰¤ Emetric.Inf_edist x (Metric.Cthickening Î´ S) + Ennreal.of_Real Î´
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (A : Matrix m m R) (C : Matrix n m R) (D : Matrix n n R) : (Matrix.from_blocks A 0 C D).det = A.det * D.det
{Î± : Type u_1} [canonically_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B C : Î±} [ContravariantClass Î± Î± has_Add.Add has_LE.LE] (h : C â‰¤ B) : A < B - C â†” A + C < B
{R : Type u_4} [Linear_ordered_CommRing R] (A B : R) : 2 * A * B â‰¤ A ^ 2 + B ^ 2
(A : Type u_2) [CommRing A] [IsDomain A] (K : Type u_1) [Field K] [Algebra A K] [_fraction_Ring A K] : IsDedekindDomain A â†” IsNoetherian_Ring A âˆ§ Ring.dimension_LE_One A âˆ§ âˆ€ {x : K}, IsIntegral A x â†’ (âˆƒ (y : A), â‡‘(Algebra_Map A K) y = x)
{A B C m : â„•} (hmc : m.Gcd C = 1) (h : C * A â‰¡ C * B [Mod m]) : A â‰¡ B [Mod m]
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} {t : CategoryTheory.Limits.Cofork F g} {Z Z' : C} (q : Z âŸ¶ Z') (ht : CategoryTheory.Limits.IsColimit t) (k : t.x âŸ¶ Z) : â†‘(â‡‘(CategoryTheory.Limits.Cofork._Colimit.hom_is_iso ht Z') (k â‰« q)) = â†‘(â‡‘(CategoryTheory.Limits.Cofork._Colimit.hom_is_iso ht Z) k) â‰« q
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] [DenselyOrdered Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds_within A (set.Iio A) â†” âˆƒ (l : Î±) (h : l âˆˆ set.Iio A), set.Ico l A âŠ† S
{R : Type u_1} {m : Type u_2} [CommRing R] [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] {S : Finset Î¹} {q : Î¹ â†’ R} (hq : â†‘S.Pairwise (_IsCoprime on q)) (hM : module._IsTorsionBy R m (S.Prod (Î» (i : Î¹), q i))) : direct_Sum._internal (Î» (i : â†¥S), Submodule.IsTorsionBy R m (q â†‘i))
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : Vector_Span k S = Submodule.Span k (S -áµ¥ S)
(F : Type u) (K : Type v) (A : Type W) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [module K A] [module F A] [IsScalarTower F K A] : (module.rank F K).Lift * (module.rank K A).Lift = (module.rank F A).Lift
{Î± : Type u_1} [generalized_boolean_Algebra Î±] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] (u v A : Î±) : Uv.compress u v (Uv.compress u v A) = Uv.compress u v A
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : Reflexive r) {x y : Î±} : x â‰  y â†’ r x y â†” r x y
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {F : Î± â†’ â„} (K : Nnreal) (h : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ F x â‰¤ F y + â†‘K * HasDist.dist x y) : LipschitzOnWith K F S
{ð•œ : Type u_1} [_R_or_C ð•œ] {E : Type u_2} {E' : Type u_3} [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ E'] (F : E â‰ƒâ‚—áµ¢[ð•œ] E') (P : Submodule ð•œ E) [CompleteSpace â†¥P] (x : E') : â†‘(â‡‘(Orthogonal_projection (Submodule.Map â†‘(F.to_Linear_Equiv) P)) x) = â‡‘F â†‘(â‡‘(Orthogonal_projection P) (â‡‘(F.Symm) x))
{Î± : Type u} {Î² : Type v} (F : Î± â†’ Î²) (lâ‚ : Filter Î±) (lâ‚‚ : Filter Î²) : Filter.Tendsto F lâ‚ lâ‚‚ â†” âˆ€ (g : Ultrafilter Î±), â†‘g â‰¤ lâ‚ â†’ Filter.Tendsto F â†‘g lâ‚‚
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {C : â„‚} {r R : â„} (h0 : 0 < r) (hle : r â‰¤ R) {F : â„‚ â†’ E} {S : set â„‚} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C R  Metric.Ball C r)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball C R  metric.IsClosed_ball C r  S â†’ Differentiable_at â„‚ F z) : âˆ® (z : â„‚) in C(C, R), F z = âˆ® (z : â„‚) in C(C, r), F z
{A : Type u_4} [CommRing A] [IsDomain A] {K : Type u_5} [Field K] {L : Type u_7} [Field L] [Algebra A K] [_fraction_Ring A K] {g : A â†’+* L} (hg : Function.Injective â‡‘g) (x : A) (y : â†¥(non_Zero_divisors A)) : â‡‘(_fraction_Ring.Lift hg) (IsLocalization.Mk' K x y) = â‡‘g x / â‡‘g â†‘y
{v : â„• â†’ â„} {C : â„} (hâ‚€ : 0 < v 0) (hc : 1 < C) (hu : âˆ€ (n : â„•), C * v n â‰¤ v (n + 1)) : Filter.Tendsto v Filter.at_top Filter.at_top
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} {P1 P2 : P} (hp1 : P1 âˆˆ SpanPoints k S) (hp2 : P2 âˆˆ SpanPoints k S) : P1 -áµ¥ P2 âˆˆ Vector_Span k S
(G : Type u_1) [Group G] : IsAscendingCentralSeries (upper_central_series G)
{G : Type u_1} [Group G] [hH : Group.IsNilpotent G] [Nontrivial G] : Group.nilpotency_class G = Group.nilpotency_class (G â§¸ Subgroup.Center G) + 1
(A B : Nnreal) {P q : â„} (hpq : P.IsConjugateExponent q) : A * B â‰¤ A ^ P / P.to_Nnreal + B ^ q / q.to_Nnreal
{P : â„•} [Fact (Nat.Prime P)] : P % 2 = 1 â†” P â‰  2
 : â‡‘fourier_series = fourier_Lp 2
{Î± : Type u} {Î² : Type v} {Î³ : Type W} (g : Î² â†’ Î³) (F : Î± â†’ Î²) : List.Map g âˆ˜ List.Map F = List.Map (g âˆ˜ F)
{R : Type u_1} {S : Type u_2} [EuclideanDomain R] [CommRing S] [IsDomain S] [Algebra R S] (abv : AbsoluteValue R â„¤) {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] (bS : Basis Î¹ R S) (A : S) {y : â„¤} (hy : âˆ€ (k : Î¹), â‡‘abv (â‡‘(â‡‘(bS.repr) A) k) â‰¤ y) : â‡‘abv (â‡‘(Algebra.norm R) A) â‰¤ class_Group.norm_bound abv bS * y ^ Fintype.Card Î¹
{R : Type u_1} [Mul_Zero_class R] : Â¬IsRightRegular 0 â†” Nontrivial R
(x y : â„¤) : â†‘(x.Gcd y) = x * x.Gcd_A y + y * x.Gcd_B y
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [_R_or_C ð•‚] [normed_CommRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] {x : ð”¸} : HasStrictFderivAt (Exp ð•‚) (Exp ð•‚ x â€¢ 1) x
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {v : Type uâ‚ƒ} {P : Type uâ‚„} [AddCommGroup v] [AddTorsor v P] [Ring k] [module k v] (B : affine_Basis Î¹ k P) [Fintype Î¹] (Bâ‚‚ : affine_Basis Î¹ k P) (x : P) : Matrix.vec_Mul (â‡‘(Bâ‚‚.coords) x) (B.to_Matrix Bâ‚‚.points) = â‡‘(B.coords) x
{K : Type u_1} [_R_or_C K] : â‡‘_R_or_C.re _R_or_C.i = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : â„•} (S1 S2 : Affine.Simplex k P n) : S1 = S2 â†” âˆ€ (i : Fin (n + 1)), S1.points i = S2.points i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x âŸ¶ Y) [CategoryTheory.Limits.HasBinaryBiproduct Y Y] : F + g = CategoryTheory.Limits.biprod.Lift F g â‰« CategoryTheory.Limits.biprod.Desc (ðŸ™ Y) (ðŸ™ Y)
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {Râ‚ Râ‚‚ : â„} {F : â„‚ â†’ E} {C : â„‚} (hD : DifferentiableOn â„‚ F (Metric.Ball C Râ‚)) (h_maps : set.maps_to F (Metric.Ball C Râ‚) (Metric.Ball (F C) Râ‚‚)) (hâ‚€ : 0 < Râ‚) : âˆ¥deriv F Câˆ¥ â‰¤ Râ‚‚ / Râ‚
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x y : Î±} (h : y âˆˆ S) : metric.Inf_dist x S â‰¤ HasDist.dist x y
{m : Type u_1} [has_Add m] (C : Add_Con m) : Add_Con_gen â‡‘C = C
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [module ð•œ E] {x z : E} {S : set E} (hs : Star_Convex ð•œ (z + x) S) : Star_Convex ð•œ x ((Î» (x : E), z + x) â»Â¹' S)
{Î± : Type u_1} [IsEmpty Î±] (S : Finset Î±) : S = âˆ…
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [CompleteSpace E] (v : E) : â‡‘(reflection (Submodule.Span ð•œ {v})á—®) v = -v
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î²'] [DecidableEq Î³] [DecidableEq Î´] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²' â†’ Î³} {g : Î² â†’ Î²'} {F' : Î² â†’ Î± â†’ Î´} {g' : Î´ â†’ Î³} (h_Right_anticomm : âˆ€ (A : Î±) (B : Î²), F A (g B) = g' (F' B A)) : Finset.imageâ‚‚ F S (Finset.image g t) = Finset.image g' (Finset.imageâ‚‚ F' t S)
{Î¹ : Type u_1} {N : Type u_5} [ordered_CommMonoid N] {F g : Î¹ â†’ N} {S : Finset Î¹} (h : âˆ€ (i : Î¹), i âˆˆ S â†’ F i â‰¤ g i) : S.Prod (Î» (i : Î¹), F i) â‰¤ S.Prod (Î» (i : Î¹), g i)
{Î± : Type u_2} {Î² : Type u_3} [has_Zero Î±] [has_Zero Î²] [SmulWithZero Î± Î²] {S : set Î²} (h : S.Nonempty) : 0 â€¢ S = 0
{R : Type u_1} [Ring R] [TopologicalSpace R] [nonarchimedean_Ring R] (U : IsOpen_Add_Subgroup R) : âˆƒ (v : IsOpen_Add_Subgroup R), â†‘v * â†‘v âŠ† â†‘U
{Î± : Type u} {Î² : Type v} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hF : Filter.Tendsto F l Filter.at_top) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), F x * g x) l Filter.at_IsBot
{Î± : Type u_1} [has_LE Î±] {A : Î±} : _IsBot A â†’ _top (â‡‘order_dual.to_dual A)
{ð•œ : Type u_2} {E : Type u_5} {F : Type u_6} [TopologicalSpace ð•œ] [CommSemiring ð•œ] [AddCommMonoid E] [module ð•œ E] [AddCommMonoid F] [module ð•œ F] {B : E â†’â‚—[ð•œ] F â†’â‚—[ð•œ] ð•œ} (hB : Function.Injective â‡‘B) : Embedding (Î» (x : WeakBilin B) (y : F), â‡‘(â‡‘B x) y)
 : {P : â„• | Nat.Prime P}.Infinite
(Î± : Type u) (Î² : Type v) : Nonempty (Î± â†ª Î²) âˆ¨ Nonempty (Î² â†ª Î±)
{n : â„•} {i j : Fin (n + 2)} (h : i â‰¤ j) : SimplexCategoryÎ´ i â‰« SimplexCategoryÎ´ j.Succ = SimplexCategoryÎ´ j â‰« SimplexCategoryÎ´ (â‡‘Fin.cast_Succ i)
(P : â„•) [hp : Fact (Nat.Prime P)] : WittVector.IsPoly P (Î» (R : Type u_1) (_Rcr : CommRing R), witt_Vector.frobenius_fun)
{m : Type u_6} {N : Type u_7} [has_Add m] [has_Add N] (F : m â‰ƒ+ N) (x y : m) : â‡‘F (x + y) = â‡‘F x + â‡‘F y
{Î¹ : Type u} {x : Type v} [TopologicalSpace x] [ParacompactSpace x] {S : set x} (hs : IsClosed S) (u : Î¹ â†’ set x) (uo : âˆ€ (i : Î¹), IsOpen (u i)) (us : S âŠ† â‹ƒ (i : Î¹), u i) : âˆƒ (v : Î¹ â†’ set x), (âˆ€ (i : Î¹), IsOpen (v i)) âˆ§ (S âŠ† â‹ƒ (i : Î¹), v i) âˆ§ locally_Finite v âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
{Î¹ : Type u_1} {v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {C : Complex_shape Î¹} (C : homological_Complex v C) {i j j' : Î¹} (rij : C.Rel i j) (rij' : C.Rel i j') : C.D i j' â‰« CategoryTheory.Eq_to_hom _ = C.D i j
{Î± : Type u} [Preorder Î±] {S : set Î±} {A : Î±} (h : IsLub S A) : BddAbove S
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {F : Î± â†’ Î² â†’ Î³} (hF : Function.Injective2 F) [Nonempty Î²] : Function.Injective F
{R : Type u} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] {N : Type (max u v)} [AddCommGroup N] [module R N] {P : R} (hp : Irreducible P) (hN : module._torsion' N â†¥(Submonoid.Powers P)) [h' : module.Finite R N] : âˆƒ (D : â„•) (k : Fin D â†’ â„•), Nonempty (N â‰ƒâ‚—[R] direct_Sum (Fin D) (Î» (i : Fin D), R â§¸ Submodule.Span R {P ^ k i}))
(S : set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [IsDomain B] [IsNoetherian_Ring A] [Fintype â†¥S] [IsCyclotomicExtension S A B] : Algebra.IsIntegral A B
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {Î± Î² Î³ : â†¥(IsSolvableByRad F E)} (hÎ³ : Î³ âˆˆ FâŸ®Î±, Î²âŸ¯) (hÎ± : IsSolvableByRad.P Î±) (hÎ² : IsSolvableByRad.P Î²) : IsSolvableByRad.P Î³
{k k' : Turing.ToPartrec.Cont} {v : List â„•} : Turing.ToPartrec.step_ret (k.then k') v = (Turing.ToPartrec.step_ret k v).then k'
{Î± : Type u_1} [LinearOrder Î±] [TopologicalSpace Î±] [IsCompact_icc_Space Î±] {A B : Î±} : IsCompact (set.Interval A B)
(k : Type u_1) [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) [Fintype Î¹] : Finset.Univ.Sum (Î» (i : Î¹), Finset.centroid_weights_indicator k S i) = S.Sum (Î» (i : Î¹), Finset.centroid_weights k S i)
{A B : â„•} (hab : A.IsCoprime B) : (A * B).Factors ~ A.Factors ++ B.Factors
{m : Type u_1} [has_Mul m] {C D : Con m} : C â‰¤ D â†” âˆ€ {x y : m}, â‡‘C x y â†’ â‡‘D x y
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds_within A (set.Iio A) â†” âˆƒ (l : Î±) (h : l âˆˆ set.Iio A), set.Ioo l A âŠ† S
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {x : E} {n : WithTop â„•} {S : set E} {F : E â†’ ð•œ} {g : E â†’ F} (hF : ContDiff_within_at ð•œ n F S x) (hg : ContDiff_within_at ð•œ n g S x) : ContDiff_within_at ð•œ n (Î» (x : E), F x â€¢ g x) S x
{R : Type u} [ordered_Ring R] [Star_ordered_Ring R] [Algebra â„ R] [OrderedSmul â„ R] [Star_module â„ R] (Aâ‚€ Aâ‚ Bâ‚€ Bâ‚ : R) (t : _CHSH_tuple Aâ‚€ Aâ‚ Bâ‚€ Bâ‚) : Aâ‚€ * Bâ‚€ + Aâ‚€ * Bâ‚ + Aâ‚ * Bâ‚€ - Aâ‚ * Bâ‚ â‰¤ Real.sqrt 2 ^ 3 â€¢ 1
{Î± : sort u_1} {Î² : sort u_2} (F : Î± â†’ Î²) (P : Prop) [Decidable P] (x : P â†’ Î±) (y : Â¬P â†’ Î±) : F (dite P x y) = dite P (Î» (h : P), F (x h)) (Î» (h : Â¬P), F (y h))
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {x : Î±} {P : Filter Î¹} {g : Î¹ â†’ Î±} [TopologicalSpace Î±] (h : TendstoLocallyUniformly F F P) (hF : Continuous_at F x) (hg : Filter.Tendsto g P (nhds x)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) P (nhds (F x))
{Î± : Type u_1} [MetricSpace Î±] {Î² : Type u} {N : â„•} {Ï„ : â„} (hÏ„ : 1 < Ï„) (hN : IsEmpty (Besicovitch.SatelliteConfig Î± N Ï„)) (q : Besicovitch.BallPackage Î² Î±) : âˆƒ (S : Fin N â†’ set Î²), (âˆ€ (i : Fin N), (S i).Pairwise_Disjoint (Î» (j : Î²), metric.IsClosed_ball (q.C j) (q.r j))) âˆ§ set.Range q.C âŠ† â‹ƒ (i : Fin N) (j : Î²) (h : j âˆˆ S i), Metric.Ball (q.C j) (q.r j)
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {A : Î±} : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ {A}), F i)) = F A
{Î± : Type u_1} {m : Type u_4} {N : Type u_5} [CommMonoid m] [has_One N] (F : Î± â†’ N) (g : Î± â†’ N â†’ m) {S t : Finset Î±} (h : S âŠ† t) (hg : âˆ€ (A : Î±), g A 1 = 1) : S.Prod (Î» (i : Î±), g i (F i)) = t.Prod (Î» (i : Î±), g i (â†‘S.Mul_indicator F i))
{E : Type u_1} [semi_NormedGroup E] {S : Add_Subgroup E} (x : â†¥S) : âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
{Î¹ : Type u} (S : Finset Î¹) (W z : Î¹ â†’ Nnreal) (hw' : S.Sum (Î» (i : Î¹), W i) = 1) {P : â„} (hp : 1 â‰¤ P) : S.Sum (Î» (i : Î¹), W i * z i) ^ P â‰¤ S.Sum (Î» (i : Î¹), W i * z i ^ P)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e : LocalHomeomorph Î± Î²} {S : set Î±} {t : set Î²} : e.to_local_Equiv.Target âˆ© â‡‘(e.Symm) â»Â¹' (e.to_local_Equiv.Source âˆ© S) = e.to_local_Equiv.Target âˆ© t â†’ e._image S t
{o : Ordinal} : Ordinal.principal has_Add.Add o â†” o = 0 âˆ¨ âˆƒ (A : Ordinal), o = Ordinal.omega ^ A
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : GaloisConnection l u) {x y z : Î±} (hxy : x â‰¤ u (l y)) (hyz : y â‰¤ u (l z)) : x â‰¤ u (l z)
{G : Type u_1} [Group G] {h : Subgroup G} {N : Type u_3} [Group N] (F : G â†’* N) : Subgroup.Map F h.Normalizer â‰¤ (Subgroup.Map F h).Normalizer
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] {A B : Î±} : Aâ»Â¹ < B â†’ Bâ»Â¹ < A
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] {F : J â†’ C} (B : CategoryTheory.Limits.Bicone F) (Total : Finset.Univ.Sum (Î» (j : J), B.Ï€ j â‰« B.Î¹ j) = ðŸ™ B.x) : CategoryTheory.Limits.HasBiproduct F
{R : Type u_1} (Câ‚ Câ‚‚ : R) : Cardinal.Mk â†¥set.Univ = Cardinal.Mk R ^ 4
{n : â„•} (P : Fin (n + 1)) (i : Fin n) : â‡‘Fin.cast_Succ i < P âˆ¨ P < i.Succ
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {v : â„ â†’ E â†’ E} {K : Nnreal} (hv : âˆ€ (t : â„), LipschitzWith K (v t)) {F g F' g' : â„ â†’ E} {A B ÎµF Îµg Î´ : â„} (hF : Continuous_on F (set.icc A B)) (hF' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt F (F' t) (set.ici t) t) (F_bound : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDist.dist (F' t) (v t (F t)) â‰¤ ÎµF) (hg : Continuous_on g (set.icc A B)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt g (g' t) (set.ici t) t) (g_bound : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDist.dist (g' t) (v t (g t)) â‰¤ Îµg) (ha : HasDist.dist (F A) (g A) â‰¤ Î´) (t : â„) (h : t âˆˆ set.icc A B) : HasDist.dist (F t) (g t) â‰¤ gronwall_bound Î´ â†‘K (ÎµF + Îµg) (t - A)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {x : E} (hF : HasStrictFderivAt F F' x) : âˆƒ (K : Nnreal) (S : set E) (h : S âˆˆ nhds x), LipschitzOnWith K F S
{Î± : Type u_1} {Î² : Type u_2} {C : set (set Î±)} {D : set (set Î²)} (hC : IsCountablySpanning C) (hD : IsCountablySpanning D) : Prod.MeasurableSpace = MeasurableSpace.generate_from (set.image2 has_set_Prod.Prod C D)
{Î± : Type u_1} [generalized_boolean_Algebra Î±] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] (u v : Î±) (S : Finset Î±) : Uv.Compression u v (Uv.Compression u v S) = Uv.Compression u v S
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e : LocalHomeomorph Î± Î²} {S : set Î±} {t : set Î²} : e.to_local_Equiv.Target âˆ© â‡‘(e.Symm) â»Â¹' S = e.to_local_Equiv.Target âˆ© t â†’ e._image S t
{n A B : â„•} (h : A â‰¤ B) : A â‰¡ B [Mod n] â†” n âˆ£ B - A
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.Int_fract_pair K} (nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n) : ifp_n.fr < 1
(R : Type u_1) {K : Type u_2} {t : Type u_3} {U : Type u_4} [CommRing R] [Field K] [CommRing t] [Algebra R K] [Algebra K t] [Algebra R t] [IsScalarTower R K t] [CommSemiring U] [Algebra K U] [Algebra R U] [IsScalarTower R K U] (x : t) (y : U) (hy : â‡‘(Polynomial.aeval y) (minpoly K x) = 0) : â‡‘(Polynomial.aeval y) (minpoly R x) = 0
{n : â„•} (P : Mvpfunctor (n + 1)) {Î± : Typevec n} {C : P.W Î± â†’ Prop} (ih : âˆ€ (A : P.A) (F' : (P.Drop.B A).arrow Î±) (F : P.Last.B A â†’ P.W Î±), (âˆ€ (i : P.Last.B A), C (F i)) â†’ C (P.W_Mk A F' F)) (x : P.W Î±) : C x
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) (h : S.Sum (Î» (i : Î¹), W i) = 0) (B : P) : â‡‘(S.weighted_vsub P) W = â‡‘(S.weighted_vsub_of_point P B) W
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) : K â‰¤ Ká—®á—®
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {x : E} : MdifferentiableAt (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F x â†’ Differentiable_at ð•œ F x
{G : Type u_1} [AddGroup G] (N h : Add_Subgroup G) [N.Normal] : â†‘(N âŠ” h) = â†‘N + â†‘h
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {x : E} {n : WithTop â„•} {S : set E} {F g : E â†’ ð•œ} (hF : ContDiff_within_at ð•œ n F S x) (hg : ContDiff_within_at ð•œ n g S x) : ContDiff_within_at ð•œ n (Î» (x : E), F x * g x) S x
{Î± : Type u} {L L' : List Î±} (h : L = L') {i : â„•} (hi : i < L.length) : L.nth_LE i hi = L'.nth_LE i _
{Î± : Type u_1} [has_LE Î±] {S : set Î±} : _lower_set S â†’ _upper_set (â‡‘order_dual.of_dual â»Â¹' S)
{m : Type u} [Monoid m] (A : m) : A ^ 2 = A * A
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (hx : x â‰  0) (hy : y â‰  0) : hb.oangle x (-y) = hb.oangle x y + â†‘Real.Pi
{m : Type u_1} [has_Mul m] (S : Subsemigroup m) : Subsemigroup.Closure â†‘S = S
{Î± : Type u_1} [Preorder Î±] {F g : Î± â†’ Î±} (hg : Monotone g) (h : F â‰¤ g) (n : â„•) : F^[n] â‰¤ (g^[n])
{R : Type v} [CommRing R] {n : â„•} (A : Matrix (Fin n.Succ) (Fin n.Succ) R) (i : Fin n.Succ) : A.det = Finset.Univ.Sum (Î» (j : Fin n.Succ), (-1) ^ (â†‘i + â†‘j) * A i j * (A.minor â‡‘(i.Succ_above) â‡‘(j.Succ_above)).det)
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} {t : Submonoid P} {q : Type u_4} [CommMonoid q] (hg : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) (k : t.Localization_Map q) {x y : m} (h : â‡‘(F.to_Map) x = â‡‘(F.to_Map) y) : â‡‘(k.to_Map) (â‡‘g x) = â‡‘(k.to_Map) (â‡‘g y)
{Î± : Type u_1} (F : Filter Î±) [F._countably_generated] : âˆƒ (x : â„• â†’ set Î±), F.has_Antitone_Basis x
(K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [module.Finite K L] (pB : power_Basis K L) [_IsSeparable K L] : Algebra.discr K â‡‘(pB.Basis) = (-1) ^ (Finite_dimensional.finrank K L * (Finite_dimensional.finrank K L - 1) / 2) * â‡‘(Algebra.norm K) (â‡‘(Polynomial.aeval pB.gen) (â‡‘Polynomial.derivative (minpoly K pB.gen)))
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} (F g : C.Quotient â†’+ P) (h : âˆ€ (A : m), â‡‘F â†‘A = â‡‘g â†‘A) : F = g
(k : Type u_1) [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) [CharZero k] (h : S.Card â‰  0) : S.Sum (Î» (i : Î¹), Finset.centroid_weights k S i) = 1
{Î± : Type u_1} {S : Finset Î±} {F : Î± â†’ Ennreal} (h : âˆ€ (A : Î±), A âˆˆ S â†’ F A â‰  âŠ¤) : S.Sum (Î» (A : Î±), F A) < âŠ¤
{R : Type u_1} [CommRing R] [Fintype R] (P : â„•) [Fact (Nat.Prime P)] (hp : P âˆ£ Fintype.Card R) : Â¬IsUnit â†‘P
{m : Type u} {Î± : Type v} [CommRing Î±] [Fintype m] [DecidableEq m] {m : Matrix m m Î±} (h : IsUnit m) (N : Matrix m m Î±) : ((mâ»Â¹.Mul N).Mul m).det = N.det
{Î± : Type u_1} [TopologicalSpace Î±] {x : Î±} {S : set Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] [has_Continuous_Add Î³] {F g : Î± â†’ Î³} (hF : UpperSemicontinuous_within_at F S x) (hg : UpperSemicontinuous_within_at g S x) : UpperSemicontinuous_within_at (Î» (z : Î±), F z + g z) S x
{u : â„• â†’ â„} {l : â„} (h : Filter.Tendsto u Filter.at_top (nhds l)) : Filter.Tendsto (Î» (n : â„•), (â†‘n)â»Â¹ * (Finset.Range n).Sum (Î» (i : â„•), u i)) Filter.at_top (nhds l)
{k : Type u_1} {v : Type u_2} [Ring k] [AddCommGroup v] [module k v] {Î¹ : Type u_3} {P : Î¹ â†’ v} : AffineIndependent k P â†” âˆ€ (S : Finset Î¹) (W : Î¹ â†’ k), S.Sum W = 0 â†’ S.Sum (Î» (e : Î¹), W e â€¢ P e) = 0 â†’ âˆ€ (e : Î¹), e âˆˆ S â†’ W e = 0
{F : Type u_1} [Field F] {P : Polynomial F} (hp : P.IsSeparable) : Fintype.Card P.Gal = Finite_dimensional.finrank F P.splitting_Field
(S t : set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension (S âˆª t) A B] : IsCyclotomicExtension t â†¥(Algebra.Adjoin A {B : B | âˆƒ (A : â„•+), A âˆˆ S âˆ§ B ^ â†‘A = 1}) B
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A : Î±} : -A â‰¤ 0 â†” 0 â‰¤ A
{R : Type u_1} [CommRing R] (P : Ideal (Polynomial R)) : Function.Injective â‡‘((Ideal.Map (Polynomial.Map_Ring_hom (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P))) P).QuotientMap (Polynomial.Map_Ring_hom (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P))) Ideal.LE_comap_Map)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {S : set E} {C : Nnreal} : LipschitzOnWith C (F - â‡‘F') S â†’ ApproximatesLinearOn F F' S C
{n P k : â„•} (hn : n â‰  0) (h : n.factorization = Finsupp.single P k) : n = P ^ k
(P q : â„•) [hp : Fact (Nat.Prime P)] (hq0 : â†‘q â‰  0) : (Finset.Ico 1 (P / 2).Succ).Sum (Î» (A : â„•), A * q / P) + (Finset.Ico 1 (q / 2).Succ).Sum (Î» (A : â„•), A * P / q) = P / 2 * (q / 2)
{Î± : Type u} {Î² : Type v} [Semiring Î±] [Semiring Î²] {F : Î± â†’ Î²} (hF : _Semiring_hom F) : _AddMonoid_hom F
{C W : â„‚} {R : â„} (hw : W âˆˆ Metric.Ball C R) : âˆ® (z : â„‚) in C(C, R), (z - W)â»Â¹ = 2 * â†‘Real.Pi * Complex.i
{Î± : Type u_1} {Î² : Type u_2} [CompleteLattice Î±] (A : Î±) (F : Î² â†’ Î±) : (â¨† (o : Option Î²), Option.elim A F o) = A âŠ” â¨† (B : Î²), F B
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} {S t : set Î±} (h : S âŠ† t) : Emetric.Inf_edist x t â‰¤ Emetric.Inf_edist x S
{Î± : Type u_1} {Î² : Type u_2} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {K : Nnreal} {F : Î± â†’ Î²} : (âˆ€ (x y : Î±), HasDist.dist x y â‰¤ â†‘K * HasDist.dist (F x) (F y)) â†’ AntilipschitzWith K F
{R : Type u} [Semiring R] {P : Type (max u v)} [AddCommMonoid P] [module R P] (huniv : âˆ€ {m : Type (max v u)} {N : Type (max u v)} [_inst_8 : AddCommMonoid m] [_inst_9 : AddCommMonoid N] [_inst_10 : module R m] [_inst_11 : module R N] (F : m â†’â‚—[R] N) (g : P â†’â‚—[R] N), Function.Surjective â‡‘F â†’ (âˆƒ (h : P â†’â‚—[R] m), F.Comp h = g)) : module.projective R P
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (e : C â‰Œ D) : CategoryTheory.WellPowered C â†” CategoryTheory.WellPowered D
{Î± : Type u_1} [CommRing Î±] (E : LinearRecurrence Î±) (q : Î±) : E._solution (Î» (n : â„•), q ^ n) â†” E.Char_Poly._root q
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {R : â„} (h0 : 0 < R) {F : â„‚ â†’ E} {C : â„‚} {S : set â„‚} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball C R  S â†’ Differentiable_at â„‚ F z) : âˆ® (z : â„‚) in C(C, R), (z - C)â»Â¹ â€¢ F z = (2 * â†‘Real.Pi * Complex.i) â€¢ F C
{Î± : Type u_1} {m : Type u_4} [CommMonoid m] (F : Î± â†’ m) {S t : Finset Î±} (h : S âŠ† t) : S.Prod (Î» (i : Î±), F i) = t.Prod (Î» (i : Î±), â†‘S.Mul_indicator F i)
{A B : â„} (h : A < B) : Cardinal.Mk â†¥(set.ioc A B) = Cardinal.Continuum
{q : â„•+} : Fintype.Card (LucasLehmer.x q) = â†‘q ^ 2
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_at F B) : HasStrictDerivAt (Î» (u : â„), âˆ« (x : â„) in A..u, F x) (F B) B
{Î± : Type u_1} [Preorder Î±] [locally_Finite_order Î±] {A B : Î±} : Â¬A â‰¤ B â†’ Finset.icc A B = âˆ…
 : WellFounded Nat.LT
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {K : Nnreal} {F : Î± â†’ Î²} : (âˆ€ (x y : Î±), HasDist.dist (F x) (F y) â‰¤ â†‘K * HasDist.dist x y) â†’ LipschitzWith K F
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B} (hx : IsIntegral A x) : (minpoly A x).monic
{Î± : Type u_1} {Î² : Type u_2} [conditionally_CompleteLattice Î±] [SemilatticeSup Î²] {F g : Î² â†’ Î±} (hF : Monotone F) (hg : Antitone g) (h : F â‰¤ g) : (â¨† (n : Î²), F n) âˆˆ â‹‚ (n : Î²), set.icc (F n) (g n)
{m : Type u_3} [AddMonoid m] (L : List m) (h : L.Sum â‰  0) : 0 < L.length
{Î¹ : Type u_1} {m : Type u_4} [ordered_AddCommMonoid m] {S : Finset Î¹} {F : Î¹ â†’ WithTop m} : S.Sum (Î» (i : Î¹), F i) = âŠ¤ â†” âˆƒ (i : Î¹) (h : i âˆˆ S), F i = âŠ¤
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B : Î±} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{R : Type u_1} [CommRing R] {P n : â„•} (hp : Nat.Prime P) : Polynomial.cyclotomic (P ^ (n + 1)) R = (Finset.Range P).Sum (Î» (i : â„•), (Polynomial.x ^ P ^ n) ^ i)
{cb : CharBuffer} {n n' val : â„•} : Parser.Nat cb n = ParseResult.done n' val â†” âˆƒ (hn : n < n'), val = Nat.of_digits 10 (List.Map (Î» (C : Char), C.ToNat - '0'.ToNat) (List.take (n' - n) (List.Drop n (Buffer.to_List cb))).reverse) âˆ§ (âˆ€ (hn' : n' < Buffer.size cb), '0' â‰¤ Buffer.read cb âŸ¨n', hn'âŸ© â†’ '9' < Buffer.read cb âŸ¨n', hn'âŸ©) âˆ§ âˆƒ (hn'' : n' â‰¤ Buffer.size cb), âˆ€ (k : â„•) (hk : k < n'), n â‰¤ k â†’ '0' â‰¤ Buffer.read cb âŸ¨k, _âŸ© âˆ§ Buffer.read cb âŸ¨k, _âŸ© â‰¤ '9'
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] (v : v) : G.min_degree â‰¤ G.degree v
{ð•œ : Type u_1} [_R_or_C ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {r : â„} (r_nonneg : 0 â‰¤ r) {x : E} (hx : x â‰  0) : âˆ¥(â†‘r * (â†‘âˆ¥xâˆ¥)â»Â¹) â€¢ xâˆ¥ = r
{Î± : Type u_1} {Gâ‚€ : Type u_3} [Group_with_Zero Gâ‚€] [TopologicalSpace Gâ‚€] [has_Continuous_Invâ‚€ Gâ‚€] [has_Continuous_Mul Gâ‚€] {F g : Î± â†’ Gâ‚€} [TopologicalSpace Î±] {A : Î±} (hF : Continuous_at F A) (hg : Continuous_at g A) (hâ‚€ : g A â‰  0) : Continuous_at (F / g) A
{R : Type u_2} {Î“â‚€ : Type u_3} [Linear_ordered_AddCommMonoid_WithTop Î“â‚€] [CommRing R] (v : AddValuation R Î“â‚€) {J : Ideal R} (hJ : J â‰¤ v.supp) : (v.on_quot hJ).supp = Ideal.Map (Ideal.Quotient.Mk J) v.supp
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {Î¹ : Type W} [Fintype Î¹] (h : Basis Î¹ K v) : Finite_dimensional.finrank K v = Fintype.Card Î¹
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {P1 : P} (P2 : P) (hp1 : P1 âˆˆ S) : HasDist.dist P1 P2 * HasDist.dist P1 P2 = HasDist.dist P1 â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P2) * HasDist.dist P1 â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P2) + HasDist.dist P2 â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P2) * HasDist.dist P2 â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P2)
{Î± : Type u} [PseudoEmetricSpace Î±] {S : set Î±} : Emetric.Hausdorff_edist S (Closure S) = 0
{Î± : Type u_1} [PartialOrder Î±] [SuccOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ico n m â†’ r i (Order.Succ i)) (hnm : n â‰¤ m) : Relation.refl_Trans_gen r n m
{F : â„ â†’ â„} {A : â„} (h : IsLocalMax F A) : deriv F A = 0
{R : Type u} {Î¹ : Type W} (S : Finset Î¹) [CommSemiring R] (F : Î¹ â†’ Polynomial R) (h : S.Prod (Î» (i : Î¹), (F i).leading_Coeff) â‰  0) : (S.Prod (Î» (i : Î¹), F i)).Nat_degree = S.Sum (Î» (i : Î¹), (F i).Nat_degree)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (i : Fin 1) : (Affine.Simplex.Mk_of_point k P).points i = P
{k : Type u} [Linear_ordered_Field k] {A : k} (ha : 0 < A) : (set.Ioo 0 A)â»Â¹ = set.ioi Aâ»Â¹
{Î± : Type u_1} {Î² : Type u_2} (e e' : local_Equiv Î± Î²) (h : e â‰ˆ e') (S : e.Source = set.Univ) (t : e.Target = set.Univ) : e = e'
{ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedGroup G] [NormedSpace ð•œ G] {F : ð•œ â†’ G} {C : Nnreal} (hF : Differentiable ð•œ F) (bound : âˆ€ (x : ð•œ), âˆ¥deriv F xâˆ¥â‚Š â‰¤ C) : LipschitzWith C F
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [Preorder Î²] {A : Î±} {F : Î± â†’ Î²} (hâ‚ : StrictAntiOn F (set.Iic A)) (hâ‚‚ : StrictAntiOn F (set.ici A)) : StrictAnti F
{R : Type u_1} {F : Type u_3} [AddCommGroup F] [TopologicalSpace F] [topological_AddGroup F] [Ring R] [module R F] [TopologicalSpace R] [has_Continuous_Smul R F] {P v : F} : Continuous â‡‘(affine_Map.line_Map P v)
{Î± : Type u_1} {S t : set Î±} : S = t â†’ S âŠ† t
{m : Type u_3} {N : Type u_4} [has_Mul m] [has_Mul N] (F : m â†’â‚™* N) {x y : m} (h : x = y) : â‡‘F x = â‡‘F y
{m n : â„•} (cop : m.IsCoprime n) (hm : 1 < m) (hn : 1 < n) : IsFrobeniusNumber (m * n - m - n) {m, n}
{Î³ : Type W} [EmetricSpace Î³] {x y : Î³} : HasEdist.edist x y = 0 â†” x = y
{P : â„•} [hp_Prime : Fact (Nat.Prime P)] {R : Type u_1} [non_assoc_Semiring R] {F : Î  (k : â„•), R â†’+* Zmod (P ^ k)} (F_compat : âˆ€ (k1 k2 : â„•) (hk : k1 â‰¤ k2), (Zmod.cast_hom _ (Zmod (P ^ k1))).Comp (F k2) = F k1) (g : R â†’+* â„¤_[P]) (hg : âˆ€ (n : â„•), (padic_Int.to_Zmod_Pow n).Comp g = F n) : padic_Int.Lift F_compat = g
{Î± : Type u_1} [DecidableEq Î±] (S : Multiset Î±) : S - 0 = S
{P n : â„•} (hp : Nat.Prime P) (HDiv : Â¬P âˆ£ n) (R : Type u_1) [CommRing R] : â‡‘(Polynomial.expand R P) (Polynomial.cyclotomic n R) = Polynomial.cyclotomic (n * P) R * Polynomial.cyclotomic n R
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {S : set E} : Convex ð•œ S â†’ âˆ€ â¦ƒA B : ð•œâ¦„, 0 â‰¤ A â†’ 0 â‰¤ B â†’ A + B = 1 â†’ A â€¢ S + B â€¢ S âŠ† S
(R : Type u) [Field R] : _Field R
{m : Type u_1} [CommMonoid m] (F : â„• â†’ â„• â†’ m) (n : â„•) : (Finset.Nat.antidiagonal n).Prod (Î» (ij : â„• Ã— â„•), F ij.fst ij.Snd) = (Finset.Range n.Succ).Prod (Î» (k : â„•), F k (n - k))
{m : Type u_1} [has_Add m] (C : Add_Con m) {x y : m} : â‡‘C x y â†’ â‡‘C y x
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {v : Type uâ‚ƒ} [AddCommGroup v] [Ring k] [module k v] [Fintype Î¹] (B : affine_Basis Î¹ k v) (v : v) : Finset.Univ.Sum (Î» (i : Î¹), â‡‘(B.coord i) v â€¢ B.points i) = v
{Î¹ : Type u_1} {v : Type u} [CategoryTheory.Category v] [CategoryTheory.Preadditive v] {C : Complex_shape Î¹} {C D : homological_Complex v C} {F g : C âŸ¶ D} [CategoryTheory.Limits.HasEqualizers v] [CategoryTheory.Limits.HasCokernels v] [CategoryTheory.Limits.HasImages v] [CategoryTheory.Limits.HasImage_maps v] [CategoryTheory.Limits.has_Zero_object v] (h : Homotopy F g) (i : Î¹) : (homology_Functor v C i).Map F = (homology_Functor v C i).Map g
{Î¹ : Type u_1} {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [ordered_AddCommMonoid N] (F : m â†’ N) (h_One : F 0 = 0) (h_Mul : âˆ€ (x y : m), F (x + y) â‰¤ F x + F y) (S : Finset Î¹) (g : Î¹ â†’ m) : F (S.Sum (Î» (i : Î¹), g i)) â‰¤ S.Sum (Î» (i : Î¹), F (g i))
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {E' : Type u_7} [InnerProductSpace ð•œ E'] (F : E â‰ƒâ‚—áµ¢[ð•œ] E') (x y : E) : HasInner.inner (â‡‘F x) (â‡‘F y) = HasInner.inner x y
{Î± : Type u_1} {Î² : Type u_2} [Fintype Î±] (F : Î± â†’ Î²) [Fintype Î²] [Decidable_Pred (Î» (y : Î²), y âˆˆ set.Range F)] [DecidableEq Î²] : Finset.Filter (Î» (y : Î²), y âˆˆ set.Range F) Finset.Univ = Finset.image F Finset.Univ
{Î¹ : Type u} {F : Î¹ â†’ Ordinal â†’ Ordinal} (h : âˆ€ (i : Î¹), Ordinal._Normal (F i)) : set.Unbounded has_LT.LT (â‹‚ (i : Î¹), Function.FixedPoints (F i))
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) : Aâ»Â¹ = Ring.Inverse A
{K : Type u} {v vâ‚ : Type v} [Field K] [AddCommGroup v] [module K v] [AddCommGroup vâ‚] [module K vâ‚] (F : v â†’â‚—[K] vâ‚) : module.rank K â†¥(F.Range) + module.rank K â†¥(F.Ker) = module.rank K v
{x : Type u_2} [EmetricSpace x] {S : set x} (hs : S.countable) : dimH S = 0
{Î± : Type u_1} {Î² : Type u_4} [Preorder Î±] [Preorder Î²] {u : Î² â†’ Î±} (l : LowerAdjoint u) (x : Î±) : x â‰¤ u (â‡‘l x)
{mâ‚€ : Type u_1} [Monoid_with_Zero mâ‚€] (x : mâ‚€) (h : Â¬IsUnit x) : Ring.Inverse x = 0
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [CommMonoid N] (F : Î± â†’â‚€ m) (y : Î±) (g : Î± â†’ m â†’ N) (hyf : y âˆˆ F.Support) : g y (â‡‘F y) * (Finsupp.erase y F).Prod g = F.Prod g
(x y z : Pgame) : ((x + y) * z).Equiv (x * z + y * z)
{Î± : Type u} [HasSubset Î±] [HasSsubset Î±] [IsNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {A B : Î±} (h : A âŠ† B) : Â¬B âŠ‚ A
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [OrderedSemiring ð•œ] [AddCommGroup E] [module ð•œ E] [Subsingleton Î¹] (P : Î¹ â†’ E) : Convex_Independent ð•œ P
{Î± : sort u_1} (hH : Î±) {Î² : Prop} (x : Tactic.CalculatedProp Î² hH . "derive_reassoc_proof") : Î²
{F : Type u_1} [NormedGroup F] [NormedSpace â„ F] (F : â„ â†’ F) [CompleteSpace F] : Measurable_set {x : â„ | Differentiable_within_at â„ F (set.ici x) x}
(m : Type u_1) (Î± : Type u_2) [Group m] [MulAction m Î±] {P q : Subgroup m} : MulAction.FixedPoints â†¥(P âŠ” q) Î± = MulAction.FixedPoints â†¥P Î± âˆ© MulAction.FixedPoints â†¥q Î±
{m : Type u_1} [MulOneClass m] {P : m â†’ Prop} (x : m) {S : set m} (hs : Submonoid.Closure S = âŠ¤) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (h1 : P 1) (HMul : âˆ€ (x y : m), P x â†’ P y â†’ P (x * y)) : P x
{Î± : Type u_2} [Monoid Î±] (m : Î±) : (âˆƒ (C : Î±), m = C ^ 2) â†’ IsSquare m
{R : Type u_1} [CommRing R] (m : Submonoid R) (S : Type u_2) [CommRing S] [Algebra R S] {P : Type u_3} [CommRing P] [IsLocalization m S] (q : Type u_5) [CommRing q] {g : R â†’+* P} [Algebra P q] (hg : Function.Injective â‡‘g) [IsLocalization (Submonoid.Map â†‘g m) q] (hM : Submonoid.Map â†‘g m â‰¤ non_Zero_divisors P) : Function.Injective â‡‘(IsLocalization.Map q g _)
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} {N : Type u_7} [AddCommMonoid m] [AddCommMonoid N] (F : Î± â†’ Î²) (v : Î± â†’â‚€ m) (g : m â†’ N) (h0 : g 0 = 0) (HAdd : âˆ€ (x y : m), g (x + y) = g x + g y) : Finsupp.Map_IsDomain F (Finsupp.Map_Range g h0 v) = Finsupp.Map_Range g h0 (Finsupp.Map_IsDomain F v)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] (F : J â†’ C) [CategoryTheory.Limits.HasCoproduct F] : CategoryTheory.Limits.HasBiproduct F
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] [Nonempty Î²] (hb : Fintype.Card Î² â€¢ B â‰¤ Finset.Univ.Sum (Î» (x : Î±), W x)) : âˆƒ (y : Î²), B â‰¤ (Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Sum (Î» (x : Î±), W x)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (Pâ‚ Pâ‚‚ : P) : EuclideanGeometry.Cospherical {Pâ‚, Pâ‚‚}
 : golden_Conjâ»Â¹ = -GoldenRatio
{Î± : Type u} [TopologicalSpace Î±] (A : Î±) : (nhds A).has_Basis (Î» (S : set Î±), S âˆˆ nhds A âˆ§ IsOpen S) (Î» (x : set Î±), x)
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] (S : set x) : dimH S = â¨† (D : Nnreal) (hD : â‡‘(MeasureTheory.Measure.hausdorff_measure â†‘D) S = âŠ¤), â†‘D
{m : Type u_1} [AddMonoid m] {S t : set m} (ht : _Add_Submonoid t) (h : S âŠ† t) : AddMonoid.Closure S âŠ† t
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {G : C â¥¤ D} {K : CategoryTheory.GrothendieckTopology D} [CategoryTheory.Full G] [CategoryTheory.Faithful G] (Hld : CategoryTheory.locally_cover_Dense K G) : CategoryTheory.CoverLifting Hld.induced_topology K G
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Finite_dimensional R m] (xâ‚ xâ‚‚ : Orientation R m Î¹) (h : Fintype.Card Î¹ = Finite_dimensional.finrank R m) : xâ‚ = xâ‚‚ âˆ¨ xâ‚ = -xâ‚‚
{Î± : Type u_1} {Î² : Type u_2} {S : set Î±} {t : Î± â†’ set Î²} {x : Î±} (xs : x âˆˆ S) : (â‹‚ (x : Î±) (h : x âˆˆ S), t x) âŠ† t x
{Î± : Type u_1} {S t : set Î±} : (S âˆ© t).Nonempty â†’ Â¬Disjoint S t
{R : Type u_1} {S : Type u_2} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] [Semiring S] (F : R â†’+* S) (S : Submonoid S) (A : R) (ha : A â‰  0) (h : âˆ€ (B : R), B âˆˆ principal_Ideal_Ring.Factors A â†’ â‡‘F B âˆˆ S) (hF : âˆ€ (C : RË£), â‡‘F â†‘C âˆˆ S) : â‡‘F A âˆˆ S
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedSpace ð•œ E] [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {x : E} {F' : E â†’ (E â†’L[ð•œ] G)} (hs : Convex â„ S) {F : E â†’ G} (hder : âˆ€á¶  (y : E) in nhds_within x S, HasFderivWithinAt F (F' y) S y) (hcont : Continuous_within_at F' S x) (K : Nnreal) (hK : âˆ¥F' xâˆ¥â‚Š < K) : âˆƒ (t : set E) (h : t âˆˆ nhds_within x S), LipschitzOnWith K F t
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] {F : â„ â†’ E} {t : â„} (hF : Function.Periodic F t) (n : â„¤) (t : â„) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable F MeasureTheory.MeasureSpace.Volume tâ‚ tâ‚‚) : âˆ« (x : â„) in t..t + n â€¢ t, F x = n â€¢ âˆ« (x : â„) in t..t + t, F x
{Î± : Type u} [Preorder Î±] [NoMinOrder Î±] (A : Î±) : âˆƒ (F : â„• â†’ Î±), StrictAnti F âˆ§ F 0 = A
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A : Î±} : 0 < -A â†” A < 0
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {F : v â‰ƒâ‚—áµ¢[â„] v} (hD : 0 < â‡‘LinearMap.det â†‘(F.to_Linear_Equiv)) : âˆƒ (Î¸ : Real.Angle), F = hb.rotation Î¸
{C : Type uâ‚} [CategoryTheory.Category C] {A : C} (hA : CategoryTheory.IsSubterminal A) {t : C} (hT : CategoryTheory.Limits.IsTerminal t) : CategoryTheory.Mono (hT.from A)
{Î± : Type u_1} {Î¹ : Type u_2} (m : MeasureTheory.OuterMeasure Î±) {S : Î¹ â†’ set Î±} (l : Filter Î¹) [l.Ne_IsBot] (h0 : Filter.Tendsto (Î» (k : Î¹), â‡‘m ((â‹ƒ (n : Î¹), S n)  S k)) l (nhds 0)) : â‡‘m (â‹ƒ (n : Î¹), S n) = â¨† (n : Î¹), â‡‘m (S n)
{m : Type u_1} [MulOneClass m] {Î¹ : sort u_2} (S : Î¹ â†’ Submonoid m) {C : Î  (x : m), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : m) (h : x âˆˆ S i), C x _) (h1 : C 1 _) (HMul : âˆ€ (x y : m) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x * y) _) {x : m} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
{m : Type u_1} [Monoid m] (S : Submonoid m) {l : List m} (hl : âˆ€ (x : m), x âˆˆ l â†’ x âˆˆ S) : l.Prod âˆˆ S
{Î± : Type u_1} {S : Finset Î±} : S.Nonempty â†’ â†‘S.Nonempty
(x y z : Pgame) : (x * y * z).Equiv (x * (y * z))
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {Î´ : out_param (sort u_4)} [has_Coe Î± Î²] [has_Coe_t_aux Î² Î³] [has_Coe_ToFun Î³ (Î» (_x : Î³), Î´)] (x : Î±) : â‡‘x = â‡‘â†‘x
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (hn : x â‰  y) (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : hb.oangle y x = â†‘Real.Pi - 2 â€¢ hb.oangle (y - x) y
(R : Type u) (m : Type v) (N : Type W) [CommRing R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [AddCommGroup N] [module R N] [module.free R N] [module.Finite R N] : Finite_dimensional.finrank R (m â†’â‚—[R] N) = Finite_dimensional.finrank R m * Finite_dimensional.finrank R N
{h : Type u} [TopologicalSpace h] (G : StructureGroupoid h) : IsClosed_under_restriction G â†” Id_restr_groupoid â‰¤ G
{R : Type u_1} {m : Type u_2} {Râ‚‚ : Type u_3} {mâ‚‚ : Type u_4} [Ring R] [Ring Râ‚‚] [AddCommMonoid m] [AddCommGroup mâ‚‚] [module R m] [module Râ‚‚ mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [Ring_hom_surjective Ï„â‚â‚‚] {F : m â†’â‚›â‚—[Ï„â‚â‚‚] mâ‚‚} (h : âˆ€ (u v : mâ‚‚ â†’â‚—[Râ‚‚] mâ‚‚ â§¸ F.Range), u.Comp F = v.Comp F â†’ u = v) : F.Range = âŠ¤
{m : Type u_1} [AddCommGroup m] [module â„‚ m] [Finite_dimensional â„‚ m] (qâ‚ qâ‚‚ : QuadraticForm â„‚ m) (hQâ‚ : (â‡‘QuadraticForm.Associated qâ‚).nondegenerate) (hQâ‚‚ : (â‡‘QuadraticForm.Associated qâ‚‚).nondegenerate) : qâ‚.Equivalent qâ‚‚
{J : Type u} [CategoryTheory.SmallCategory J] (F : J â¥¤ top) [CategoryTheory.IsCofiltered J] [âˆ€ (j : J), Nonempty â†¥(F.obj j)] [âˆ€ (j : J), CompactSpace â†¥(F.obj j)] [âˆ€ (j : J), t2_Space â†¥(F.obj j)] : Nonempty â†¥((top.Limit_cone F).x)
{R : Type u_1} {A B : R} [Add_Semigroup R] (Ab : _Add_Right_regular (B + A)) : _Add_Right_regular B
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] {S : set Î±} {t : set Î²} (hs : Dense S) (ht : Dense t) : Dense (S Ã—Ë¢ t)
{R : Type u_1} [CommRing R] [IsDomain R] [normalized_Gcd_Monoid R] {K : Type u_2} [Field K] [Algebra R K] [_fraction_Ring R K] {P : Polynomial R} (hp : P._primitive) : Irreducible P â†” Irreducible (Polynomial.Map (Algebra_Map R K) P)
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore Î¹ B F) (B : B) : Continuous (Bundle.Total_Space_Mk B)
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (hs : IsCompact S) {e : â„} (hE : 0 < e) : âˆƒ (t : set Î±) (h : t âŠ† S), t.Finite âˆ§ S âŠ† â‹ƒ (x : Î±) (h : x âˆˆ t), Metric.Ball x e
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] (m : Submodule R A) {C : A â†’ Prop} (hr : âˆ€ (r : R), C (â‡‘(Algebra_Map R A) r)) (HAdd : âˆ€ (x y : A), C x â†’ C y â†’ C (x + y)) (HMul : âˆ€ (x : A), C x â†’ âˆ€ (m : A), m âˆˆ m â†’ C (x * m)) {x : A} {n : â„•} (hx : x âˆˆ m ^ n) : C x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] {F G : top.sheaf C x} (F : F âŸ¶ G) (U : TopologicalSpace.Opens â†¥x) (hinj : âˆ€ (x : â†¥U), Function.Injective â‡‘((top.Presheaf.stalk_Functor C x.val).Map F)) (hsurj : âˆ€ (t : â†¥(G.val.obj (Opposite.Op U))) (x : â†¥U), âˆƒ (v : TopologicalSpace.Opens â†¥x) (m : x.val âˆˆ v) (iVU : v âŸ¶ U) (S : â†¥(F.val.obj (Opposite.Op v))), â‡‘(F.App (Opposite.Op v)) S = â‡‘(G.val.Map iVU.Op) t) : Function.Surjective â‡‘(F.App (Opposite.Op U))
{R : Type u_1} [CommSemiring R] {x : Type u_2} {A : Type u_3} [Semiring A] [Algebra R A] {F g : free_Algebra R x â†’â‚[R] A} (W : â‡‘F âˆ˜ free_Algebra.Î¹ R = â‡‘g âˆ˜ free_Algebra.Î¹ R) : F = g
(Î± : Type u) [Preorder Î±] [Nonempty Î±] [NoMinOrder Î±] [NoMaxOrder Î±] : âˆƒ (F : â„¤ â†’ Î±), StrictMono F
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} : Function.Commute â‡‘clifford_Algebra.reverse â‡‘clifford_Algebra.involute
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R m) {W : Î¹ â†’ R} (hw : âˆ€ (i : Î¹), IsUnit (W i)) : â‡‘(e.det) â‡‘(e.IsUnit_Smul hw) = Finset.Univ.Prod (Î» (i : Î¹), W i)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : â†‘r < P.radius) : âˆƒ (C : â„) (h : C > 0), âˆ€ (n : â„•), âˆ¥P nâˆ¥ * â†‘r ^ n â‰¤ C
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [division_Monoid Î²] (F : Î± â†’* Î²) (g h : Î±) : â‡‘F (g / h) = â‡‘F g / â‡‘F h
{Î± : sort u_1} {Î² : sort u_2} (F : Î± â†’ Î²) : Nonempty Î± â†’ Nonempty Î²
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {J' : Type uâ‚‚} [CategoryTheory.Category J'] (e : J â‰Œ J') [CategoryTheory.Limits.HasColimits_of_shape J C] : CategoryTheory.Limits.HasColimits_of_shape J' C
{C : â„} (h1 : 0 < C) (h2 : C < 1 / 2) {n : â„•} {F g : â„• â†’ Bool} (hn : âˆ€ (k : â„•), k < n â†’ F k = g k) (fn : F n = Bool.ff) (gn : g n = Bool.tt) : Cardinal.cantor_Function C F < Cardinal.cantor_Function C g
{F : Type u_1} [NormedGroup F] [NormedSpace â„ F] {F : â„ â†’ F} {K : set F} (hK : IsComplete K) : Right_deriv_Measurable_aux.D F K âŠ† {x : â„ | Differentiable_within_at â„ F (set.ici x) x âˆ§ deriv_within F (set.ici x) x âˆˆ K}
{B : â„•} {l : List â„•} (hb : 2 â‰¤ B) (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < B) : Nat.of_digits B l < B ^ l.length
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [NormedGroup F] [NormedSpace â„ F] {x : E} {F : E â†’ F} {F' : E â†’ (E â†’L[â„] F)} {F'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€á¶  (y : E) in nhds x, HasFderivAt F (F' y) y) (hx : HasFderivAt F' F'' x) (v W : E) : â‡‘(â‡‘F'' v) W = â‡‘(â‡‘F'' W) v
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {F : Î± â†’ Î²} (hF : âˆ€ (x y : Î±), F (x * y) = F x * F y) : _Group_hom F
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : â„•} {i j : Fin (n + 2)} (h : i â‰¤ j) : x.Î´ i â‰« x.Î´ j.Succ = x.Î´ j â‰« x.Î´ (â‡‘Fin.cast_Succ i)
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (h : 0 < r * (B - A)) : F (â‡‘(affine_Map.line_Map A B) r) â‰¤ â‡‘(affine_Map.line_Map (F A) (F B)) r â†” slope F A (â‡‘(affine_Map.line_Map A B) r) â‰¤ slope F A B
{F : â„ â†’ â„} (hF' : âˆ€ (x : â„), deriv F x < 0) : StrictAnti F
{Î± : Type u_1} {E : Type u_2} {m mâ‚‚ : MeasurableSpace Î±} [TopologicalSpace E] [has_Zero E] {S : set Î±} {F : Î± â†’ E} (hs_m : Measurable_set S) (hs : âˆ€ (t : set Î±), Measurable_set (S âˆ© t) â†’ Measurable_set (S âˆ© t)) (hF : MeasureTheory.strongly_Measurable F) (hF_Zero : âˆ€ (x : Î±), x âˆ‰ S â†’ F x = 0) : MeasureTheory.strongly_Measurable F
{F : â„ â†’ â„} (hF' : âˆ€ (x : â„), 0 < deriv F x) : StrictMono F
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] (m : Submodule R A) {C : A â†’ Prop} (hr : âˆ€ (r : R), C (â‡‘(Algebra_Map R A) r)) (HAdd : âˆ€ (x y : A), C x â†’ C y â†’ C (x + y)) (HMul : âˆ€ (m : A), m âˆˆ m â†’ âˆ€ (x : A), C x â†’ C (m * x)) {x : A} {n : â„•} (hx : x âˆˆ m ^ n) : C x
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [AddCommMonoid m] {S : set Î±} {t : set Î²} {F : Î± â†’ m} {g : Î² â†’ m} (e : Î± â†’ Î²) (hEâ‚€ : set.bij_on e S t) (hEâ‚ : âˆ€ (x : Î±), x âˆˆ S â†’ F x = g (e x)) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) = finsum (Î» (j : Î²), finsum (Î» (h : j âˆˆ t), g j))
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {F F' : C â¥¤ D} (h : F â‰… F') : F.EssImage = F'.EssImage
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {S : set E} {t : set F} {g : F â†’ G} {F : E â†’ F} (x : E) (hg : ContDiff_within_at ð•œ n g t (F x)) (hF : ContDiff_within_at ð•œ n F S x) : ContDiff_within_at ð•œ n (g âˆ˜ F) (S âˆ© F â»Â¹' t) x
{Î± : Type u_1} [PseudoEmetricSpace Î±] (r C : Ennreal) {F : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (F n) (F (n + 1)) â‰¤ C * r ^ n) {A : Î±} (ha : Filter.Tendsto F Filter.at_top (nhds A)) : HasEdist.edist (F 0) A â‰¤ C / (1 - r)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [AddCommMonoid Î±] [TopologicalSpace Î±] {F : Î² â†’ Î±} [AddCommMonoid Î³] [TopologicalSpace Î³] {G : Type u_4} [Add_Equiv_class G Î± Î³] (g : G) (hg : Continuous â‡‘g) (hg' : Continuous (Add_Equiv_class.Inv g)) : Summable (â‡‘g âˆ˜ F) â†” Summable F
{G : Type u} [AddGroup G] (A x : G) : Add_SemiconjBy A x (A + x + -A)
{Î² : Type u_2} [AddCommMonoid Î²] (F : Fin 0 â†’ Î²) : Finset.Univ.Sum (Î» (i : Fin 0), F i) = 0
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] [LocallyCompactSpace Î²] (F : C(Î±, C(Î², Î³))) : Continuous (Function.uncurry (Î» (x : Î±) (y : Î²), â‡‘(â‡‘F x) y))
(C : Turing.ToPartrec.Code) (k : Turing.partrec_to_tm2.Cont') : Turing.tm2.Supports Turing.partrec_to_tm2.tr (Turing.partrec_to_tm2.code_supp C k)
{R : Type u_1} {m : Type u_2} [CommRing R] [AddCommGroup m] [module R m] (q : QuadraticForm R m) {P : Î  (x : clifford_Algebra q), x âˆˆ clifford_Algebra.Even_Odd q 0 â†’ Prop} (hr : âˆ€ (r : R), P (â‡‘(Algebra_Map R (clifford_Algebra q)) r) _) (HAdd : âˆ€ {x y : clifford_Algebra q} {hx : x âˆˆ clifford_Algebra.Even_Odd q 0} {hy : y âˆˆ clifford_Algebra.Even_Odd q 0}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_Mul : âˆ€ (mâ‚ mâ‚‚ : m) {x : clifford_Algebra q} {hx : x âˆˆ clifford_Algebra.Even_Odd q 0}, P x hx â†’ P (â‡‘(clifford_Algebra.Î¹ q) mâ‚ * â‡‘(clifford_Algebra.Î¹ q) mâ‚‚ * x) _) (x : clifford_Algebra q) (hx : x âˆˆ clifford_Algebra.Even_Odd q 0) : P x hx
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} (F : Î± â†’ Î² â†’ Î³) (P : Prop) [Decidable P] (A : P â†’ Î±) (B : Â¬P â†’ Î±) (C : P â†’ Î²) (D : Â¬P â†’ Î²) : F (dite P A B) (dite P C D) = dite P (Î» (h : P), F (A h) (C h)) (Î» (h : Â¬P), F (B h) (D h))
{Î± : Type u_1} [has_LT Î±] {A B : Î±áµ’áµˆ} : B â‹– A â†’ â‡‘order_dual.of_dual A â‹– â‡‘order_dual.of_dual B
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A : Î±} {S : set Î±} (hl : âˆƒ (l : Î±), l < A) (hu : âˆƒ (u : Î±), A < u) : S âˆˆ nhds A â†” âˆƒ (l u : Î±), A âˆˆ set.Ioo l u âˆ§ set.Ioo l u âŠ† S
{S : Type u} [Add_Semigroup S] {A x y x' y' : S} (h : Add_SemiconjBy A x y) (h' : Add_SemiconjBy A x' y') : Add_SemiconjBy A (x + x') (y + y')
{Î± : Type u} {Î² : Type v} {Î³ : Type W} [PseudoEmetricSpace Î±] [PseudoEmetricSpace Î²] [PseudoEmetricSpace Î³] {g : Î² â†’ Î³} {F : Î± â†’ Î²} (hg : Isometry g) (hF : Isometry F) : Isometry (g âˆ˜ F)
{Î± : Type u_1} [CompleteLattice Î±] [IsCompactlyGenerated Î±] {A : Î±} {S : set Î±} (h : Directed_on has_LE.LE S) : A âŠ“ HasSup.Sup S = â¨† (B : Î±) (h : B âˆˆ S), A âŠ“ B
{Î± : Type u} [TopologicalSpace Î±] {x : Î±} : ConnectedComponent x âŠ† â‹‚ (Z : {Z // IsClopen Z âˆ§ x âˆˆ Z}), â†‘Z
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {S : Î² â†’ Î² â†’ Prop} : Function.Injective Coe_fn
{h : Type u_1} [TopologicalSpace h] [LocallyCompactSpace h] [t2_Space h] : TotallyDisconnectedSpace h â†” TotallySeparatedSpace h
{G : Type u_1} {P : Type u_2} [AddGroup G] [AddTorsor G P] {x y : P} (h : Function.Injective bit0) : â‡‘(Equiv.point_reflection x) y = y â†” y = x
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {E' : Type u_7} [InnerProductSpace ð•œ E'] {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (F : E â†’â‚—áµ¢[ð•œ] E') : Orthonormal ð•œ (â‡‘F âˆ˜ v)
{C : Type u} [CategoryTheory.Category C] {Jâ‚ Jâ‚‚ : CategoryTheory.GrothendieckTopology C} (h : â‡‘Jâ‚ = â‡‘Jâ‚‚) : Jâ‚ = Jâ‚‚
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {F : Î± â†’ Î²} (hF : _Ring_hom F) : _Semiring_hom F
{Î± : Type u_1} [has_LE Î±] {A B : Î±áµ’áµˆ} : B â‰¤ A â†’ â‡‘order_dual.of_dual A â‰¤ â‡‘order_dual.of_dual B
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {F : v â‰ƒâ‚—áµ¢[â„] v} (hD : 0 < â‡‘LinearMap.det â†‘(F.to_Linear_Equiv)) : âˆƒ (Î¸ : Real.Angle), F = o.rotation Î¸
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) (h : InnerProductGeometry.angle x y = Real.Pi / 2) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
(R : Type u) [CommRing R] [IsDomain R] : discrete_Valuation_Ring R â†” _principal_Ideal_Ring R âˆ§ âˆƒ! (P : Ideal R), P â‰  âŠ¥ âˆ§ P.Prime
{Î³ : Type W} [SemilatticeInf Î³] {Aâ‚ Aâ‚‚ : Î³} {S t : set Î³} (hs : IsGlb S Aâ‚) (ht : IsGlb t Aâ‚‚) : IsGlb (S âˆª t) (Aâ‚ âŠ“ Aâ‚‚)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ F} {F' : E â†’L[ð•œ] F} (x : E) {g : F â†’ G} {g' : F â†’L[ð•œ] G} (hg : HasFderivAt g g' (F x)) (hF : HasFderivAt F F' x) : HasFderivAt (g âˆ˜ F) (g'.Comp F') x
{m : Type u_3} {N : Type u_4} {P : Type u_5} {q : Type u_1} [has_One m] [has_One N] [has_One P] [has_One q] (F : One_hom m N) (g : One_hom N P) (h : One_hom P q) : (h.Comp g).Comp F = h.Comp (g.Comp F)
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (t : CategoryTheory.Limits.IsTerminal x) (F g : Y âŸ¶ x) : F = g
{Î¹ : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : Î¹ â†’ set x} {S : set x} (hs : IsClosed S) (uo : âˆ€ (i : Î¹), IsOpen (u i)) (uf : âˆ€ (x : x), x âˆˆ S â†’ {i : Î¹ | x âˆˆ u i}.Finite) (us : S âŠ† â‹ƒ (i : Î¹), u i) : âˆƒ (v : Î¹ â†’ set x), S âŠ† set.Union v âˆ§ (âˆ€ (i : Î¹), IsClosed (v i)) âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
 : _AbsoluteValue.UniformSpace HasAbs.Abs = PseudoMetricSpace.to_UniformSpace
{Î± : Type u_1} [TopologicalSpace Î±] [PartialOrder Î±] {S : set Î±} [TopologicalSpace.IsSeparable_Space â†¥S] (hs : Dense S) : âˆƒ (t : set Î±) (h : t âŠ† S), t.countable âˆ§ Dense t âˆ§ (âˆ€ (x : Î±), _IsBot x â†’ x âˆˆ S â†’ x âˆˆ t) âˆ§ âˆ€ (x : Î±), _top x â†’ x âˆˆ S â†’ x âˆˆ t
{Î± : Type u} [HasSubset Î±] [HasSsubset Î±] [IsNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {A B : Î±} (h : A âŠ‚ B) : A âŠ† B
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {S t : CategoryTheory.Limits.Cone F} (P : CategoryTheory.Limits.IsLimit S) (q : CategoryTheory.Limits.IsLimit t) (F : S âŸ¶ t) : CategoryTheory.IsIso F
(n : â„•) : Convex_on â„ (set.ici 0) (Î» (x : â„), x ^ n)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [Ring_hom_isometric Ïƒâ‚â‚‚] (F : E â†’sl[Ïƒâ‚â‚‚] F) (x : E) : âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥â‡‘F xâˆ¥ â‰¤ âˆ¥Fâˆ¥
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace E] {F : E â†’ F} {F' : E â†’ (E â‰ƒL[ð•œ] F)} (hF : âˆ€ (x : E), HasStrictFderivAt F â†‘(F' x) x) : IsOpen_Map F
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {ps : set P} {n : â„•} [Finite_dimensional â„ v] (hD : Finite_dimensional.finrank â„ v = n) (hc : EuclideanGeometry.Cospherical ps) : âˆƒ (r : â„), âˆ€ (sx : Affine.Simplex â„ P n), set.Range sx.points âŠ† ps â†’ sx.circumradius = r
{A : Type u_1} {B : Type u_2} [CommRing A] [IsDomain A] [Ring B] [Algebra A B] {x : B} {A : Polynomial A} (hx : IsIntegral A x) (hamonic : A.monic) (hdvd : Dvd_not_Unit A (minpoly A x)) : â‡‘(Polynomial.aeval x) A â‰  0
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} {C : clifford_Algebra q â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(Algebra_Map R (clifford_Algebra q)) r)) (h_grade1 : âˆ€ (x : m), C (â‡‘(clifford_Algebra.Î¹ q) x)) (h_Mul : âˆ€ (A B : clifford_Algebra q), C A â†’ C B â†’ C (A * B)) (h_Add : âˆ€ (A B : clifford_Algebra q), C A â†’ C B â†’ C (A + B)) (A : clifford_Algebra q) : C A
{P : Nat_Ordinal â†’ Prop} (i : Nat_Ordinal) (h : âˆ€ (j : Nat_Ordinal), (âˆ€ (k : Nat_Ordinal), k < j â†’ P k) â†’ P j) : P i
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) {r : â„} (hr : r â‰  0) : 2 â€¢ o.oangle x (r â€¢ y) = 2 â€¢ o.oangle x y
{Î± : Type u} [PseudoMetricSpace Î±] {x : Î±} : Metric.Bounded {x}
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hst : Disjoint (S âˆ© Function.MulSupport F) (t âˆ© Function.MulSupport F)) (hs : (S âˆ© Function.MulSupport F).Finite) (ht : (t âˆ© Function.MulSupport F).Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S âˆª t), F i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ t), F i))
{R : Type u_1} [CommRing R] {xâ‚ xâ‚‚ yâ‚ yâ‚‚ : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2
{Î± : Type u} [PseudoMetricSpace Î±] {F : Î± â†’ â„} (K : â„) (h : âˆ€ (x y : Î±), F x â‰¤ F y + K * HasDist.dist x y) : LipschitzWith K.to_Nnreal F
(n A : â„•) (P : â„• â†’ Prop) [Decidable_Pred P] (pp : Function.Periodic P A) : â‡‘Multiset.Card (Multiset.Filter P (Multiset.Ico n (n + A))) = Nat.count P A
{Î± : Type u_1} [Semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x * x) âˆ˜ Î» (_x : Î±), _x * y) = Î» (_x : Î±), _x * (y * x)
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C â¥¤ D} (h : CategoryTheory.cover_Dense K G) [CategoryTheory.Full G] {â„± : Dáµ’áµ– â¥¤ A} {â„±' : CategoryTheory.sheaf K A} (Î± : G.Op â‹™ â„± âŸ¶ G.Op â‹™ â„±'.val) : CategoryTheory.whisker_Left G.Op (h.sheaf_hom Î±) = Î±
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] [h : Group.IsNilpotent G] (F : G â†’* G') (hF : Function.Surjective â‡‘F) : Group.IsNilpotent G'
{ð•œ : Type u_1} {v : Type u_2} {vâ‚‚ : Type u_4} {P : Type u_8} {Pâ‚‚ : Type u_9} [NormedField ð•œ] [semi_NormedGroup v] [semi_NormedGroup vâ‚‚] [NormedSpace ð•œ v] [NormedSpace ð•œ vâ‚‚] [PseudoMetricSpace P] [PseudoMetricSpace Pâ‚‚] [NormedAddTorsor v P] [NormedAddTorsor vâ‚‚ Pâ‚‚] {F : P â†’ Pâ‚‚} (hF : Isometry F) {P : P} {g : v â†’ vâ‚‚} (hg : âˆ€ (v : v), g v = F (v +áµ¥ P) -áµ¥ F P) : Isometry g
{Î¹ : Type u_1} {R : Type u_8} [ordered_CommSemiring R] {F : Î¹ â†’ R} {S : Finset Î¹} (h0 : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ F i) (h1 : âˆ€ (i : Î¹), i âˆˆ S â†’ F i â‰¤ 1) : S.Prod (Î» (i : Î¹), F i) â‰¤ 1
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {A : set E} {x : E} : x âˆˆ set.ExtremePoints ð•œ A â†” IsExtreme ð•œ A {x}
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : hb.oangle y (â‡‘(hb.rotation (hb.oangle x y)) x) = 0
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : bounded_Continuous_Function x â„) {A B : â„} {e : x â†’ Y} (hF : âˆ€ (x : x), â‡‘F x âˆˆ set.icc A B) (hle : A â‰¤ B) (hE : IsClosed_Embedding e) : âˆƒ (g : bounded_Continuous_Function Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ set.icc A B) âˆ§ â‡‘g âˆ˜ e = â‡‘F
{R S : Type u} [CommRing R] [CommRing S] (m : Submonoid R) (S' : Type u) [CommRing S'] [Algebra S S'] [Algebra R S] [Algebra R S'] [IsScalarTower R S S'] [IsLocalization (Submonoid.Map â†‘(Algebra_Map R S) m) S'] (x : S) (S : Finset S') (hx : â‡‘(Algebra_Map S S') x âˆˆ Submodule.Span R â†‘S) : âˆƒ (m : â†¥m), m â€¢ x âˆˆ Submodule.Span R â†‘(IsLocalization.Finset_integer_multiple (Submonoid.Map â†‘(Algebra_Map R S) m) S)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] (Î¹ : Type u_2) [Fintype Î¹] (E : Î¹ â†’ Type u_3) [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] (S : Î  (i : Î¹), set (E i)) (h : âˆ€ (i : Î¹), UniqueDiffOn ð•œ (S i)) : UniqueDiffOn ð•œ (set.Univ.Pi S)
(x : â„‚) : HasDerivAt Complex.Exp (Complex.Exp x) x
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : D â¥¤ C) (Y : D) : F.obj Y âˆˆ F.EssImage
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) : hb.oangle x 0 = 0
{G : Type u} [Group G] [Fintype G] {P : â„•} [hp : Fact (Nat.Prime P)] (P : Sylow P G) : (Fintype.Card â†¥P).IsCoprime â†‘P.Index
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [h : Subsingleton v] : Finite_dimensional.finrank K v = 0
(x : top) (t : â†¥x â†’ Type u) : (x.presheaf_to_Types t)._sheaf
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) (A : Î±) : â‡‘F (bit0 A) = bit0 (â‡‘F A)
{Î± : Type u} [t : TopologicalSpace Î±] {Î¹ : Type u_1} [Encodable Î¹] {U : Î¹ â†’ set Î±} [âˆ€ (i : Î¹), TopologicalSpace.SecondCountableTopology â†¥(U i)] (Uo : âˆ€ (i : Î¹), IsOpen (U i)) (hc : (â‹ƒ (i : Î¹), U i) = set.Univ) : TopologicalSpace.SecondCountableTopology Î±
(S : set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [IsDomain B] [hâ‚ : Fintype â†¥S] [hâ‚‚ : IsCyclotomicExtension S A B] : module.Finite A B
 : Primrec (Î» (A : (â„• Ã— Nat.Partrec.Code) Ã— â„•), Nat.Partrec.Code.evaln A.fst.fst A.fst.Snd A.Snd)
{Î± : Type u} [PseudoEmetricSpace Î±] (B : â„• â†’ Ennreal) (hB : âˆ€ (n : â„•), 0 < B n) (h : âˆ€ (u : â„• â†’ Î±), (âˆ€ (N n m : â„•), N â‰¤ n â†’ N â‰¤ m â†’ HasEdist.edist (u n) (u m) < B N) â†’ (âˆƒ (x : Î±), Filter.Tendsto u Filter.at_top (nhds x))) : CompleteSpace Î±
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (e : LocalHomeomorph Î± Î²) : e.Trans e.Symm â‰ˆ LocalHomeomorph.of_set e.to_local_Equiv.Source _
{n : Type u} [DecidableEq n] [Fintype n] {R : Type v} [Linear_ordered_CommRing R] (g : Matrix.special_Linear_Group n R) : â†‘â†‘â†‘g = â†‘g
{B : Type u_3} (Eâ‚ : B â†’ Type u_6) (Eâ‚‚ : B â†’ Type u_7) [TopologicalSpace (Bundle.Total_Space Eâ‚)] [TopologicalSpace (Bundle.Total_Space Eâ‚‚)] : Inducing (Î» (P : Bundle.Total_Space (Î» (x : B), Eâ‚ x Ã— Eâ‚‚ x)), (âŸ¨P.fst, P.Snd.fstâŸ©, âŸ¨P.fst, P.Snd.SndâŸ©))
(n : â„•) : n.Totient * n.Factors.to_Finset.Prod (Î» (P : â„•), P) = n * n.Factors.to_Finset.Prod (Î» (P : â„•), P - 1)
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A : Î±} {S : set Î±} (ha : IsGlb S A) (hs : S.Nonempty) (sc : IsClosed S) : A âˆˆ S
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u_3} [CategoryTheory.Category D] [CategoryTheory.Preadditive D] (G : C â¥¤ D) [G.Additive] (x : CategoryTheory.SimplicialObject C) (q n m : â„•) (hnm : AlgebraicTopology.DoldKan.C.Rel m n) : AlgebraicTopology.DoldKan.hÏƒ' q n m hnm = G.Map (AlgebraicTopology.DoldKan.hÏƒ' q n m hnm)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : â„•} {i j : Fin (n + 1)} (h : i â‰¤ j) : x.Ïƒ j â‰« x.Ïƒ (â‡‘Fin.cast_Succ i) = x.Ïƒ i â‰« x.Ïƒ j.Succ
(A : Ordinal) : âˆƒ (F : Î  (B : Ordinal), B < A.cof.Ord â†’ Ordinal), A._fundamental_sequence A.cof.Ord F
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {S : set Î±} {x : Î±} {P : Filter Î¹} {g : Î¹ â†’ Î±} [TopologicalSpace Î±] (h : TendstoLocallyUniformlyOn F F P S) (hF : Continuous_within_at F S x) (hx : x âˆˆ S) (hg : Filter.Tendsto g P (nhds_within x S)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) P (nhds (F x))
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F g : Î± â†’ m} (hF : (Function.Support F).Finite) (hg : (Function.Support g).Finite) : finsum (Î» (i : Î±), F i + g i) = finsum (Î» (i : Î±), F i) + finsum (Î» (i : Î±), g i)
(k : â„¤) {B : â„} (hb : 0 < B) : (Î» (x : â„), x ^ k) =o[Filter.at_top] Î» (x : â„), Real.Exp (B * x)
{Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [Decidable_Rel R] {l : List Î±} : List.Pairwise R l â†’ List.pw_Filter R l = l
{Î± : Type u} {Î² : Type v} {Î³ : Type W} (h : Î² â†’ Î³) (g : Î± â†’ Î²) (l : List Î±) : List.Map (h âˆ˜ g) l = List.Map h (List.Map g l)
{C : Type u} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type v} (Ps : set (Cáµ’áµ– â¥¤ Type v)) (h : P âˆˆ Ps) : CategoryTheory.Presieve._sheaf (CategoryTheory.sheaf.finest_topology Ps) P
{x : â„} (hx : x â‰¤ 0) : Exp_Neg_Inv_glue x = 0
{C : Type uâ‚} [CategoryTheory.Category C] (x : Type vâ‚) [CategoryTheory.Limits.HasCoproductsOfShape x C] : CategoryTheory.Limits.HasProducts_of_shape x Cáµ’áµ–
{Î± : Type u_1} {F g : â„• â†’ Î±} [TopologicalSpace Î±] [non_unital_non_assoc_Semiring Î±] [RegularSpace Î±] [topological_Semiring Î±] (hF : Summable F) (hg : Summable g) (hfg : Summable (Î» (x : â„• Ã— â„•), F x.fst * g x.Snd)) : (âˆ‘' (n : â„•), F n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (Finset.Range (n + 1)).Sum (Î» (k : â„•), F k * g (n - k))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {Fâ‚‚ : ð•œ â†’ F} : ContDiff ð•œ âŠ¤ Fâ‚‚ â†” Differentiable ð•œ Fâ‚‚ âˆ§ ContDiff ð•œ âŠ¤ (deriv Fâ‚‚)
{G : Type u_1} [Group G] {h : Subgroup G} [hG : Group.fg G] (hH : h.Index â‰  0) : Group.fg â†¥h
 : Filter.Tendsto (Î» (k : â„•), (Finset.Range k).Prod (Î» (i : â„•), (2 * â†‘i + 2) / (2 * â†‘i + 1) * ((2 * â†‘i + 2) / (2 * â†‘i + 3)))) Filter.at_top (nhds (Real.Pi / 2))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : E â†’ F} {g : G â†’L[ð•œ] E} (hF : ContDiff ð•œ n F) : ContDiff ð•œ n (F âˆ˜ â‡‘g)
{Î± : Type u} [PseudoEmetricSpace Î±] (E : set Î±) : Metric.Cthickening 0 E = Closure E
{S : set Ordinal} (o : Ordinal) : Ordinal.enum_Ord S o = HasInf.Inf (S âˆ© set.ici (o.blsub (Î» (A : Ordinal) (_x : A < o), Ordinal.enum_Ord S A)))
{m : Type u_1} [AddCommGroup m] [module â„ m] [Finite_dimensional â„ m] (q : QuadraticForm â„ m) : âˆƒ (W : Fin (Finite_dimensional.finrank â„ m) â†’ â„), (âˆ€ (i : Fin (Finite_dimensional.finrank â„ m)), W i = -1 âˆ¨ W i = 0 âˆ¨ W i = 1) âˆ§ q.Equivalent (QuadraticForm.weighted_Sum_squares â„ W)
{G : Add_Subgroup â„} {gâ‚€ : â„} (gâ‚€_in : gâ‚€ âˆˆ G) (gâ‚€_Ne : gâ‚€ â‰  0) (h' : Â¬âˆƒ (A : â„), IsLeast {g : â„ | g âˆˆ G âˆ§ 0 < g} A) : Dense â†‘G
{R : Type u_1} [CommRing R] [Nontrivial R] {m : Ideal R} (max : m.IsMaximal) (not_Field : Â¬_Field R) : m â‰  âŠ¥
{Î¹A : Type u_7} {Î¹B : Type u_8} [DecidableEq Î¹A] [DecidableEq Î¹B] [Fintype Î¹A] [Fintype Î¹B] {R' : Type u_9} {máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [CommSemiring R'] [AddCommGroup Nâ‚] [module R' Nâ‚] [AddCommGroup Nâ‚‚] [module R' Nâ‚‚] [AddCommMonoid máµ¢] [module R' máµ¢] (A : AlternatingMap R' máµ¢ Nâ‚ Î¹A) (B : AlternatingMap R' máµ¢ Nâ‚‚ Î¹B) : â‡‘MultilinearMap.alternatization (â†‘A.Dom_Coprod â†‘B) = ((Fintype.Card Î¹A).factorial * (Fintype.Card Î¹B).factorial) â€¢ A.Dom_Coprod B
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [DecidableEq J] (F : J â†’ C) [CategoryTheory.Limits.HasBiproduct F] (j j' : J) : CategoryTheory.Limits.biproductÎ¹ F j â‰« CategoryTheory.Limits.biproductÏ€ F j' = dite (j = j') (Î» (h : j = j'), CategoryTheory.Eq_to_hom _) (Î» (h : Â¬j = j'), 0)
(n : â„•) (Î¸ : â„‚) : Complex.cos (â†‘n * Î¸) = Polynomial.Eval (Complex.cos Î¸) (Polynomial.Chebyshev.t â„‚ n)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : o.oangle (-x) y + o.oangle (-y) x = 0
{F : â„‚ â†’ â„‚} {z : â„‚} {R : â„} (hD : DifferentiableOn â„‚ F (Metric.Ball 0 R)) (h_maps : set.maps_to F (Metric.Ball 0 R) (Metric.Ball 0 R)) (hâ‚€ : F 0 = 0) (hz : Complex.Abs z < R) : Complex.Abs (F z) â‰¤ Complex.Abs z
{m : Type u_1} [Monoid m] {F g : â„¤ â†’* m} (h_Neg_One : â‡‘F (-1) = â‡‘g (-1)) (h_Nat : F.Comp Int.of_Nat_hom.to_Monoid_hom = g.Comp Int.of_Nat_hom.to_Monoid_hom) : F = g
{Î¹ : Type v} {Î¹' : Type v'} (F : Î¹ â†’ Cardinal) (F' : Î¹' â†’ Cardinal) (g : Î¹ â†’ Î¹') (h : âˆ€ (i : Î¹), (F i).Lift â‰¤ (F' (g i)).Lift) : (Cardinal.Sup F).Lift â‰¤ (Cardinal.Sup F').Lift
{Î± : Type u_1} [Monoid Î±] {A B : Î±} {u : Î±Ë£} : A * â†‘u âˆ£ B â†” A âˆ£ B
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [CommMonoid m] {S : set Î±} {t : set Î²} (F : Î± â†’ Î² â†’ m) (hs : S.Finite) (ht : t.Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), finprod (Î» (j : Î²), finprod (Î» (h : j âˆˆ t), F i j)))) = finprod (Î» (j : Î²), finprod (Î» (h : j âˆˆ t), finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i j))))
{x y z : Pgame} (hâ‚ : x.lf y) (hâ‚‚ : y â‰¤ z) : x.lf z
{L : FirstOrder.Language} {m : Type W} [L.structure m] [h : Nonempty L.Constants] : Nonempty m
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] (F : (Fin 1 â†’ â„‚) â†’ E) (C : Fin 1 â†’ â„‚) (R : Fin 1 â†’ â„) : âˆ¯ (x : Fin 1 â†’ â„‚) in t(C, R), F x = âˆ® (z : â„‚) in C(C 0, R 0), F (Î» (_x : Fin 1), z)
{Î± : Type u_1} [MeasurableSpace Î±] {R : Type u_2} [HasScalar R Ennreal] [IsScalarTower R Ennreal Ennreal] (C : R) (m : MeasureTheory.OuterMeasure Î±) : (C â€¢ m).trim = C â€¢ m.trim
{Fq : Type u_1} [Fintype Fq] [Semiring Fq] {D m : â„•} (hm : Fintype.Card Fq ^ D â‰¤ m) (B : Polynomial Fq) (hb : B.Nat_degree â‰¤ D) (A : Fin m.Succ â†’ Polynomial Fq) (hA : âˆ€ (i : Fin m.Succ), (A i).degree < B.degree) : âˆƒ (iâ‚€ iâ‚ : Fin m.Succ), iâ‚€ â‰  iâ‚ âˆ§ A iâ‚ = A iâ‚€
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] [t2_Space Î±] {S : set Î²} (hs : Dense S) {F g : Î² â†’ Î±} (hF : Continuous F) (hg : Continuous g) (h : set.Eq_on F g S) : F = g
{C : Cardinal} (h : Cardinal.aleph0 â‰¤ C) : C + C = C
{ð’œ : Type u_1} [CategoryTheory.Category ð’œ] [CategoryTheory.Preadditive ð’œ] [CategoryTheory.Limits.HasKernels ð’œ] [CategoryTheory.Limits.HasImages ð’œ] [CategoryTheory.Limits.HasBinaryBiproducts ð’œ] (A B : ð’œ) : CategoryTheory.Exact CategoryTheory.Limits.biprod.inl_ CategoryTheory.Limits.biprod.Snd
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] : Monotone Finset.Up_shadow
{Î± : Type u} [MulOneClass Î±] [has_Distrib_Neg Î±] (A : Î±) : (-1) * A = -A
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) {vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup vâ‚‚] [module k vâ‚‚] [AddTorsor vâ‚‚ Pâ‚‚] (P : Î¹ â†’ P) (W : Î¹ â†’ k) (hw : S.Sum W = 1) (F : P â†’áµƒ[k] Pâ‚‚) : â‡‘F (â‡‘(S.affine_combination P) W) = â‡‘(S.affine_combination (â‡‘F âˆ˜ P)) W
(R : Type u) (m : Type v) (N : Type W) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [AddCommGroup N] [module R N] [module.free R N] [module.Finite R N] : Finite_dimensional.finrank R (m Ã— N) = Finite_dimensional.finrank R m + Finite_dimensional.finrank R N
(R : Type u_1) [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (K : Type u_5) [Field K] [IsDomain R] [IsDomain S] [Algebra R K] [Algebra S K] [NoZeroSmulDivisors R K] [_fraction_Ring S K] [IsScalarTower R S K] : Algebra.IsAlgebraic R S â†” Algebra.IsAlgebraic R K
{Î± : Type u_1} [Semigroup_with_Zero Î±] {A : Î±} : 0 âˆ£ A â†” A = 0
{Î± : Type u_1} [DecidableEq Î±] {S t : Finset Î±} (h : S âŠ† t) : (Finset.icc S t).Card = 2 ^ (t.Card - S.Card)
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {m : MeasurableSpace Î±} [TopologicalSpace Î²] (hF : MeasureTheory.strongly_Measurable F) : TopologicalSpace._IsSeparable (set.Range F)
(P : â„•) [Fact (Nat.Prime P)] {A : â„¤} (hp : P â‰  2) (ha0 : â†‘A â‰  0) : Zmod.legendre_Sym P A = (-1) ^ (Finset.Filter (Î» (x : â„•), P / 2 < (â†‘A * â†‘x).val) (Finset.Ico 1 (P / 2).Succ)).Card
{n P : â„•} (hp : Nat.Prime P) : multiplicity P (P * n).factorial = multiplicity P n.factorial + â†‘n
{m : Type u_2} [AddCommGroup m] {A : Type u_5} [CommRing A] [module A m] [DecidableEq m] {P : A â†’ Prop} (F : m â†’â‚—[A] m) (hb : âˆ€ (S : Finset m) (B : Basis â†¥S A m), P (â‡‘(Linear_Map.to_Matrix B B) F).det) (h1 : P 1) : P (â‡‘LinearMap.det F)
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {F C : Equiv.perm Î±} {A : Î±} (ha : A âˆˆ C.Support) (hc : C âˆˆ F.Cycle_Factors_Finset) : C = F.Cycle_of A
{Î± : Type u_1} [TopologicalSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {S : set Î±} (h : âˆ€ (x : Î±), x âˆˆ S â†’ S âˆˆ nhds_within x (set.ioi x)) : Measurable_set S
{v : Type u_1} [InnerProductSpace â„ v] {P : Type u_2} [MetricSpace P] [NormedAddTorsor v P] {A B C D P : P} (h : EuclideanGeometry.Cospherical {A, B, C, D}) (hapb : EuclideanGeometry.angle A P B = Real.Pi) (hcpd : EuclideanGeometry.angle C P D = Real.Pi) : HasDist.dist A P * HasDist.dist B P = HasDist.dist C P * HasDist.dist D P
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} : StrictMono_on F S â†’ StrictAntiOn (â‡‘order_dual.to_dual âˆ˜ F) S
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B C : Î±} : -B + A < C â†’ A < B + C
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {F : â„ â†’ E} {g : â„ â†’ F} {A B C : â„} (h_deriv : âˆ€á¶  (x : â„) in nhds_within C {C}á¶œ, Differentiable_at â„ F x) (h_infty : Filter.Tendsto (Î» (x : â„), âˆ¥F xâˆ¥) (nhds_within C {C}á¶œ) Filter.at_top) (hg : deriv F =O[nhds_within C {C}á¶œ] g) (hne : A â‰  B) (hc : C âˆˆ set.Interval A B) : Â¬IntervalIntegrable g MeasureTheory.MeasureSpace.Volume A B
{Î± : Type u} {A B : Î±} [Mul_Zero_class Î±] [PartialOrder Î±] [Zero_LT.Mul_Pos_Mono Î±] (ha : 0 â‰¤ A) (hb : 0 â‰¤ B) : 0 â‰¤ A * B
{Î± : Type u_1} {t : set Î±} (S : Finset â†¥t) : â†‘(Finset.Map (Function.Embedding.Subtype (Î» (x : Î±), x âˆˆ t)) S) âŠ† t
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} (F : C.Quotient â†’+ P) : C.Lift (F.Comp C.Mk') _ = F
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {B : m} [Linear_ordered_CommRing m] (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A âˆˆ t) (ht : t.Nonempty) (hb : t.Card â€¢ B â‰¤ â†‘(S.Card)) : âˆƒ (y : Î²) (h : y âˆˆ t), B â‰¤ â†‘((Finset.Filter (Î» (x : Î±), F x = y) S).Card)
{E : Type u_1} [InnerProductSpace â„ E] {n : â„•} (hn : 0 < n) (h : Finite_dimensional.finrank â„ E = n) (x : Orientation â„ E (Fin n)) : (Orientation.Fin_Orthonormal_Basis hn h x).Orientation = x
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] [Algebra A B] [IsScalarTower R A B] (hfpA : Algebra.Finite_presentation R A) (hfpB : Algebra.Finite_presentation A B) : Algebra.Finite_presentation R B
{m : Type u_1} {N : Type u_2} {Î± : Type u_6} {Î² : Type u_7} [HasScalar m Î±] [HasScalar Î² Î±] [SmulCommClass m Î² Î±] (g : N â†’ m) : SmulCommClass N Î² Î±
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} {F' : â„ â†’ E} (hcont : Continuous_on F (set.Interval A B)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo (LinearOrder.min A B) (LinearOrder.max A B) â†’ HasDerivWithinAt F (F' x) (set.ioi x) x) (hint : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : âˆ« (y : â„) in A..B, F' y = F B - F A
{n : â„•} (P : Mvpfunctor (n + 1)) {Î± : Typevec n} {C : Type u_1} (g : Î  (A : P.A), (P.Drop.B A).arrow Î± â†’ (P.Last.B A â†’ P.W Î±) â†’ (P.Last.B A â†’ C) â†’ C) (A : P.A) (F' : (P.Drop.B A).arrow Î±) (F : P.Last.B A â†’ P.W Î±) : P.W_rec g (P.W_Mk A F' F) = g A F' F (Î» (i : P.Last.B A), P.W_rec g (F i))
{Î± : Type u_1} [canonically_Linear_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B C : Î±} [ContravariantClass Î± Î± has_Add.Add has_LE.LE] (h : C â‰¤ A) : A - C < B - C â†” A < B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {S : set ð•œ} [CompleteSpace F] (h : AnalyticOn ð•œ F S) : AnalyticOn ð•œ (deriv F) S
{Î± : Type u_1} {ð•œ : Type u_14} [NormedField ð•œ] {l : Filter Î±} {u v : Î± â†’ ð•œ} (h : u =o[l] v) : u / v * v =á¶ [l] u
{Î± : Type u_1} [circular_Preorder Î±] {A B C : Î±} (h : HasSbtw.Sbtw A B C) : Â¬HasBtw.Btw C B A
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] {x : B} (hx : IsIntegral A x) : 0 < (minpoly A x).Nat_degree
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [hÎ¹ : Î  (n : Î²), Fintype (Î¹ n)] (D : â„) (S : set x) {l : Filter Î²} (r : Î² â†’ Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ set x) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), Emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, S âŠ† â‹ƒ (i : Î¹ n), t n i) : â‡‘(MeasureTheory.Measure.hausdorff_measure D) S â‰¤ l.liminf (Î» (n : Î²), Finset.Univ.Sum (Î» (i : Î¹ n), Emetric.diam (t n i) ^ D))
{t : â†¥Unit_Interval} : t â‰¤ 1
{Î± : Type u_1} {S : Finset Î±} {A : Î±} [DecidableEq Î±] : (S.erase A).Card = Ite (A âˆˆ S) (S.Card - 1) S.Card
{C : Type uâ‚} [CategoryTheory.Category C] (G : CategoryTheory.Comonad C) {A B : G.Coalgebra} (F : A âŸ¶ B) [CategoryTheory.IsIso F.F] : CategoryTheory.IsIso F
{l : Filter â„} {F g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in Filter.at_IsBot, Differentiable_at â„ F x) (hg' : âˆ€á¶  (x : â„) in Filter.at_IsBot, deriv g x â‰  0) (hfbot : Filter.Tendsto F Filter.at_IsBot (nhds 0)) (hgbot : Filter.Tendsto g Filter.at_IsBot (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv F x / deriv g x) Filter.at_IsBot l) : Filter.Tendsto (Î» (x : â„), F x / g x) Filter.at_IsBot l
{v : Type u_1} [InnerProductSpace â„ v] {P : Type u_2} [MetricSpace P] [NormedAddTorsor v P] {A B C D P : P} (h : EuclideanGeometry.Cospherical {A, B, C, D}) (hapb : âˆƒ (kâ‚ : â„), kâ‚ â‰  1 âˆ§ B -áµ¥ P = kâ‚ â€¢ (A -áµ¥ P)) (hcpd : âˆƒ (kâ‚‚ : â„), kâ‚‚ â‰  1 âˆ§ D -áµ¥ P = kâ‚‚ â€¢ (C -áµ¥ P)) : HasDist.dist A P * HasDist.dist B P = HasDist.dist C P * HasDist.dist D P
{F : â„ â†’ â„} {F' A : â„} (h : IsLocalExtr F A) : HasDerivAt F F' A â†’ F' = 0
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} {m' : Type u_6} {v : Î¹ â†’ m} [Semiring R] [AddCommMonoid m] [AddCommMonoid m'] [module R m] [module R m'] (F : m â†’â‚—[R] m') (hF_inj : F.Ker = âŠ¥) : LinearIndependent R (â‡‘F âˆ˜ v) â†” LinearIndependent R v
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] [CompleteSpace ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [Finite_dimensional ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {A : E} (hF : HasStrictFderivAt F F' A) (hF' : F'.Range = âŠ¤) : âˆ€á¶  (x : E) in nhds A, HasStrictFderivAt.implicit_Function F F' hF hF' (F x) (â‡‘(HasStrictFderivAt.implicit_to_LocalHomeomorph F F' hF hF') x).Snd = x
{F : Type u_3} [InnerProductSpace â„ F] (t : F â†’â‚—[â„] F) : InnerProductSpace.IsSelfAdjoint t â†” BilinForm_of_Real_inner.IsSelfAdjoint t
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m â†’+ P} (h : C â‰¤ Add_Con.Ker F) : (C.Lift F h).mrange = F.mrange
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] : Ká—®á—® = K
(B m : â„•) (hm : m â‰  0) : (B + 2) ^ ((B + 2).digits m).length â‰¤ (B + 2) * m
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y z : v} (hxyne : x â‰  y) (hxzne : x â‰  z) (hxy : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) (hxz : âˆ¥xâˆ¥ = âˆ¥zâˆ¥) : hb.oangle y z = 2 â€¢ hb.oangle (y - x) (z - x)
{Î± : Type u_1} [has_Add Î±] [has_LE Î±] [ContravariantClass Î± Î± has_Add.Add has_LE.LE] {A B C : Î±} (bc : A + B â‰¤ A + C) : B â‰¤ C
{Î± : Type u} {L : List (Î± Ã— Bool)} [DecidableEq Î±] : free_Group.Mk (free_Group.reduce L) = free_Group.Mk L
{P A B : â„•} (hab : A.IsCoprime B) : â‡‘((A * B).factorization) P = â‡‘(A.factorization) P + â‡‘(B.factorization) P
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} {S : set â„‚} {C : â„‚} (hc : S âˆˆ nhds_within C {C}á¶œ) (hD : DifferentiableOn â„‚ F S) (ho : (Î» (z : â„‚), F z - F C) =o[nhds_within C {C}á¶œ] Î» (z : â„‚), (z - C)â»Â¹) : DifferentiableOn â„‚ (Function.update F C (lim (nhds_within C {C}á¶œ) F)) (HasInsert.Insert C S)
{C : Type uâ‚} [CategoryTheory.Category C] (x : C) [h : Î  (Y : C), Unique (Y âŸ¶ x)] : CategoryTheory.Limits.HasTerminal C
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {R : â„} {C W : â„‚} {F : â„‚ â†’ E} {S : set â„‚} (hs : S.countable) (hw : W âˆˆ Metric.Ball C R  S) (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : âˆ€ (x : â„‚), x âˆˆ Metric.Ball C R  S â†’ Differentiable_at â„‚ F x) : âˆ® (z : â„‚) in C(C, R), (z - W)â»Â¹ â€¢ F z = (2 * â†‘Real.Pi * Complex.i) â€¢ F W
{Î± : Type u_1} {Î² : Type u_2} [has_Mul Î±] [Preorder Î±] [Preorder Î²] {F g : Î² â†’ Î±} [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] (hF : StrictMono F) (hg : StrictMono g) : StrictMono (Î» (x : Î²), F x * g x)
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (h : 0 < r * (B - A)) : F (â‡‘(affine_Map.line_Map A B) r) < â‡‘(affine_Map.line_Map (F A) (F B)) r â†” slope F A (â‡‘(affine_Map.line_Map A B) r) < slope F A B
{G : Type u_6} {h : Type u_7} {F : Type u_8} [Group G] [division_Monoid h] [Monoid_hom_class F G h] (F : F) (A B : G) : â‡‘F (A * Bâ»Â¹) = â‡‘F A * (â‡‘F B)â»Â¹
{Î± : Type u_1} {C : set (set Î±)} (hc : Setoid._Partition C) {S : set Î±} (hs : S âˆˆ C) : âˆƒ (y : Î±), S = {x : Î± | (Setoid.Mk_Classes C _).Rel x y}
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] : (reflection K)â»Â¹ = reflection K
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} {A : Type u_3} [Semiring A] [Algebra R A] {F g : clifford_Algebra q â†’â‚[R] A} : F.to_Linear_Map.Comp (clifford_Algebra.Î¹ q) = g.to_Linear_Map.Comp (clifford_Algebra.Î¹ q) â†’ F = g
{ð•œ : Type u_3} {E : Type u_4} [NormedField ð•œ] [semi_NormedGroup E] [NormedSpace ð•œ E] {r : â„} (hr : 0 < r) : Absorbent ð•œ (Metric.Ball 0 r)
{F : Type u_1} [Field F] (P q : Polynomial F) (hq : q.Nat_degree â‰  0) : Polynomial.Splits (Algebra_Map F (P.Comp q).splitting_Field) P
{m : Type u_3} {N : Type u_4} [MulOneClass m] [MulOneClass N] {F g : m â†’* N} : F = g â†” âˆ€ (x : m), â‡‘F x = â‡‘g x
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {x : C} (S : CategoryTheory.Sieve x) : Jâ‚.close S = âŠ¤ â†” S âˆˆ â‡‘Jâ‚ x
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle â„ P) {iâ‚ iâ‚‚ iâ‚ƒ : Fin 3} (hâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) : Affine.Simplex.altitude t iâ‚ = Affine.Simplex.monge_plane t iâ‚‚ iâ‚ƒ
{Î± : Type u_1} {Gâ‚€ : Type u_3} [has_Zero Gâ‚€] [has_Inv Gâ‚€] [TopologicalSpace Gâ‚€] [has_Continuous_Invâ‚€ Gâ‚€] {l : Filter Î±} {F : Î± â†’ Gâ‚€} {A : Gâ‚€} (hF : Filter.Tendsto F l (nhds A)) (ha : A â‰  0) : Filter.Tendsto (Î» (x : Î±), (F x)â»Â¹) l (nhds Aâ»Â¹)
{x : Type u_1} [TopologicalSpace x] {S : set x} (hs : IsClosed S) : _Seq_IsClosed S
{Î± : Type u_2} {Î¹ : Type u_5} [CommMonoid Î±] [Fintype Î¹] (F : Î¹ â†’ set Î±) (A : Î±) : A âˆˆ Finset.Univ.Prod (Î» (i : Î¹), F i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), g i âˆˆ F i), Finset.Univ.Prod (Î» (i : Î¹), g i) = A
{R : Type u_2} [cancel_CommMonoid_with_Zero R] [Unique_factorization_Monoid R] (A : R) (h : A â‰  0) (B : R) : âˆƒ (A' B' C' : R), (âˆ€ {D : R}, D âˆ£ A' â†’ D âˆ£ B' â†’ IsUnit D) âˆ§ C' * A' = A âˆ§ C' * B' = B
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {Î± Î² : â†¥(IsSolvableByRad F E)} (hÎ² : Î² âˆˆ FâŸ®Î±âŸ¯) (hÎ± : IsSolvableByRad.P Î±) : IsSolvableByRad.P Î²
{n : â„•} (C : Composition n) : C.boundaries.order_emb_of_Fin _ = C.boundary
{Î¹ : Type u_1} [Fintype Î¹] : MeasureTheory.Measure.hausdorff_measure â†‘(Fintype.Card Î¹) = MeasureTheory.MeasureSpace.Volume
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) : IsClosed â†‘Ká—®
{R : Type u} {n : â„•} {m : Fin n.Succ â†’ Type W} {mâ‚‚ : Type Wâ‚‚} [Semiring R] [Î  (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid mâ‚‚] [Î  (i : Fin n.Succ), module R (m i)] [module R mâ‚‚] [Î  (i : Fin n.Succ), TopologicalSpace (m i)] [TopologicalSpace mâ‚‚] (F : Continuous_MultilinearMap R m mâ‚‚) (m : Î  (i : Fin n), m i.Succ) (x y : m 0) : â‡‘F (Fin.Cons (x + y) m) = â‡‘F (Fin.Cons x m) + â‡‘F (Fin.Cons y m)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F : â„ â†’ E} {C : â„} (hF : DifferentiableOn â„ F (set.icc 0 1)) (bound : âˆ€ (x : â„), x âˆˆ set.Ico 0 1 â†’ âˆ¥deriv_within F (set.icc 0 1) xâˆ¥ â‰¤ C) : âˆ¥F 1 - F 0âˆ¥ â‰¤ C
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} {S : Affine.Simplex â„ P (n + 2)} {iâ‚ : Fin (n + 3)} {P : P} (h : âˆ€ (iâ‚‚ : Fin (n + 3)), iâ‚ â‰  iâ‚‚ â†’ P âˆˆ S.monge_plane iâ‚ iâ‚‚) : P = S.monge_point
{Î± : Type u_1} {A B C : Î±} [LinearOrder Î±] [Add_comm_Semigroup Î±] [HasSub Î±] [HasOrderedSub Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] (h : A - B < A - C) : C < B
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] [Finite_dimensional K L] {x : L} : â‡‘LinearMap.det (â‡‘(Algebra.lmul K L) x) = 0 â†” x = 0
{C : Type u} [CategoryTheory.Category C] {Jâ‚ Jâ‚‚ : CategoryTheory.GrothendieckTopology C} : Jâ‚ = Jâ‚‚ â†” âˆ€ (P : Cáµ’áµ– â¥¤ Type (max v u)), CategoryTheory.Presieve._sheaf Jâ‚ P â†” CategoryTheory.Presieve._sheaf Jâ‚‚ P
{P : â„•} : padic_val_Nat P 1 = 0
{Î± : Type u_1} [TopologicalSpace Î±] {S : set Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] {F g : Î± â†’ Î³} (hF : UpperSemicontinuous_on F S) (hg : UpperSemicontinuous_on g S) (hcont : âˆ€ (x : Î±), x âˆˆ S â†’ Continuous_at (Î» (P : Î³ Ã— Î³), P.fst + P.Snd) (F x, g x)) : UpperSemicontinuous_on (Î» (z : Î±), F z + g z) S
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : Real.cos (InnerProductGeometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = HasInner.inner x y
{Î± : sort u_1} {P : Î± â†’ Prop} (x : Subtype P) : P â†‘x
{Î± : Type u_3} {Î² : Type u_4} [Linear_ordered_Field Î±] {l : Filter Î²} {F : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (Î» (x : Î²), F x * r) l Filter.at_top
{E : Type u_1} [semi_NormedGroup E] {S : set E} : Metric.Bounded S â†’ (âˆƒ (R : â„), âˆ€ (x : E), x âˆˆ S â†’ âˆ¥xâˆ¥ â‰¤ R)
{x : Type u_1} [TopologicalSpace x] [NormalSpace x] {S t : set x} (hs : IsClosed S) (ht : IsClosed t) (hD : Disjoint S t) : âˆƒ (F : bounded_Continuous_Function x â„), set.Eq_on â‡‘F 0 S âˆ§ set.Eq_on â‡‘F 1 t âˆ§ âˆ€ (x : x), â‡‘F x âˆˆ set.icc 0 1
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (x : Î±) (h : âˆ€ (y : Î±), y âˆˆ S â†’ (âˆƒ (t : set Î±) (h : t âŠ† S), x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t)) : IsPreconnected S
{x : Pgame} : x â‰¤ 0 â†” âˆ€ (i : x.Left_moves), âˆƒ (j : (x.move_Left i).Right_moves), (x.move_Left i).move_Right j â‰¤ 0
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) {r : â„} (hr : 0 < r) : o.oangle x (r â€¢ y) = o.oangle x y
{Î± : Type u} [PseudoMetricSpace Î±] {F : Î± â†’ â„} (K : Nnreal) (h : âˆ€ (x y : Î±), F x â‰¤ F y + â†‘K * HasDist.dist x y) : LipschitzWith K F
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P (n + 2)) {iâ‚ iâ‚‚ : Fin (n + 3)} : S.monge_point âˆˆ S.monge_plane iâ‚ iâ‚‚
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (x : module.Ray R m) : Ray_of_Ne_Zero R x.Some_Vector _ = x
{Î± : Type u} [t : TopologicalSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_1} (S : Î¹ â†’ set Î±) (h : âˆ€ (i : Î¹), IsOpen (S i)) : âˆƒ (t : set Î¹), t.countable âˆ§ (â‹ƒ (i : Î¹) (h : i âˆˆ t), S i) = â‹ƒ (i : Î¹), S i
(P : â„•) [hp : Fact (Nat.Prime P)] (n : â„•) {m : â„•} (hm : n â‰¤ m) : (truncated_witt_Vector.truncate hm).Comp (truncated_witt_Vector.Zmod_Equiv_trunc P m).to_Ring_hom = (truncated_witt_Vector.Zmod_Equiv_trunc P n).to_Ring_hom.Comp (Zmod.cast_hom _ (Zmod (P ^ n)))
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (S : set Î±) : Continuous (Î» (F : C(Î±, Î²)), Continuous_Map.Restrict S F)
{n : Type u_1} {ð•œ : Type u_3} [Field ð•œ] [DecidableEq n] [Fintype n] (m : Matrix n n ð•œ) : âˆƒ (L L' : List (Matrix.TransvectionStruct n ð•œ)) (D : n â†’ ð•œ), ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod = Matrix.Diagonal D
{m : Type u_2} {n : Type u_3} {Î± : Type v} (m : Matrix m n Î±) (i : m) (j : n) : m.transpose j i = m i j
{G : Type W} [TopologicalSpace G] [HasNeg G] [has_Add G] [has_Continuous_Add G] (g : G) : Continuous (Î» (h : G), g + h + -g)
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [semi_NormedGroup Î²] (F : bounded_Continuous_Function Î± Î²) [h : Nonempty Î±] : âˆ¥Fâˆ¥ = HasInf.Inf {C : â„ | âˆ€ (x : Î±), âˆ¥â‡‘F xâˆ¥ â‰¤ C}
{m : Type u_1} [AddCommMonoid m] (A B : â„•) (F : â„• â†’ â„• â†’ m) : (Finset.Ico A B).Sum (Î» (i : â„•), (Finset.Ico i B).Sum (Î» (j : â„•), F i j)) = (Finset.Ico A B).Sum (Î» (j : â„•), (Finset.Ico A (j + 1)).Sum (Î» (i : â„•), F i j))
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : â‡‘(EuclideanGeometry.Orthogonal_projection S) â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P) = â‡‘(EuclideanGeometry.Orthogonal_projection S) P
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] (S : Submodule K v) : Finite_dimensional.finrank K (v â§¸ S) â‰¤ Finite_dimensional.finrank K v
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] (x : Î± Ã— Î²) : Filter.Map Prod.Snd (nhds_within x (Prod.fst â»Â¹' {x.fst})) = nhds x.Snd
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hst : Disjoint (S âˆ© Function.Support F) (t âˆ© Function.Support F)) (hs : (S âˆ© Function.Support F).Finite) (ht : (t âˆ© Function.Support F).Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S âˆª t), F i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ t), F i))
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [DivisionRing K] {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K} (Succ_nth_S_Eq : g.S.nth (n + 1) = Option.Some gp) (nth_denom_Eq : g.denominators n = ppredB) (Succ_nth_denom_Eq : g.denominators (n + 1) = predB) : g.denominators (n + 2) = gp.B * predB + gp.A * ppredB
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] (S : set Î±) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), 1)) = 1
{m : Type u_1} [AddMonoid m] {x : m} : 0 âˆˆ Multiples x
{Î± : Type u_1} [Semigroup Î±] (x y : Î±) : has_Mul.Mul x âˆ˜ has_Mul.Mul y = has_Mul.Mul (x * y)
{n : â„•} (P : Fin (n + 1)) : set.Range â‡‘(P.Succ_above) = {P}á¶œ
{Gâ‚€ : Type u_2} [Group_with_Zero Gâ‚€] (A : Gâ‚€) : A / (A / A) = A
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} (hF : IsClosed_Embedding F) : Filter.Tendsto F (Filter.cocompact Î±) (Filter.cocompact Î²)
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} : ConcaveOn ð•œ S F â†” Convex ð•œ S âˆ§ âˆ€ â¦ƒx y z : ð•œâ¦„, x âˆˆ S â†’ z âˆˆ S â†’ x < y â†’ y < z â†’ (F z - F y) / (z - y) â‰¤ (F y - F x) / (y - x)
{P : â„} : Summable (Î» (n : â„•), 1 / â†‘n ^ P) â†” 1 < P
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [AddZeroClass m] [AddCommMonoid N] {F g : Î± â†’â‚€ m} {h : Î± â†’ m â†’ N} (h_Zero : âˆ€ (A : Î±), h A 0 = 0) (h_Add : âˆ€ (A : Î±) (Bâ‚ Bâ‚‚ : m), h A (Bâ‚ + Bâ‚‚) = h A Bâ‚ + h A Bâ‚‚) : (F + g).Sum h = F.Sum h + g.Sum h
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] (x : Î± Ã— Î²) : Filter.Map Prod.fst (nhds_within x (Prod.Snd â»Â¹' {x.Snd})) = nhds x.fst
{G : Type u_1} [Group G] {h : Subgroup G} {N : Type u_3} [Group N] (F : N â†’* G) : Subgroup.comap F h.Normalizer â‰¤ (Subgroup.comap F h).Normalizer
{n : â„•} (C : Composition n) {iâ‚ iâ‚‚ : Fin C.length} (h : iâ‚ â‰  iâ‚‚) : Disjoint (set.Range â‡‘(C.Embedding iâ‚)) (set.Range â‡‘(C.Embedding iâ‚‚))
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : strict_Convex_on ð•œ S F) {x y z : E} (hx : x âˆˆ S) (hy : y âˆˆ S) (hxy : x â‰  y) (hz : z âˆˆ IsOpen_Segment ð•œ x y) : F z < LinearOrder.max (F x) (F y)
{Î± : Type u_1} {Î² : Type u_3} {C : set (set Î±)} {D : set (set Î²)} (hC : IsCountablySpanning C) (hD : IsCountablySpanning D) : IsCountablySpanning (set.image2 has_set_Prod.Prod C D)
{Î± : Type u} {F g : Filter Î±} (h : âˆ€ (S : set Î±), Sá¶œ âˆˆ F â†” Sá¶œ âˆˆ g) : F = g
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {F : m â†’+ N} (hF : âˆ€ (y : â†¥S), IsAddUnit (â‡‘F â†‘y)) {y z : â†¥S} (h : -â‡‘(IsAddUnit.Lift_Right (F.Restrict S) hF) y = -â‡‘(IsAddUnit.Lift_Right (F.Restrict S) hF) z) : â‡‘F â†‘y = â‡‘F â†‘z
(R : Type u) [Ring R] [strong_RankCondition R] {Î¹ : Type v} [Fintype Î¹] {m : Î¹ â†’ Type W} [Î  (i : Î¹), AddCommGroup (m i)] [Î  (i : Î¹), module R (m i)] [âˆ€ (i : Î¹), module.free R (m i)] : module.rank R (Î  (i : Î¹), m i) = Cardinal.Sum (Î» (i : Î¹), module.rank R (m i))
(n : â„•) : âˆ‘' (i : â„•), Ite (n â‰¤ i) (2â»Â¹ ^ i) 0 = 2 * 2â»Â¹ ^ n
{Î± : Type u_1} [PartialOrder Î±] (C : Closure_operator Î±) : C.IsClosed = set.Range â‡‘C
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S
{A B C m : â„•} (hm : 0 < m) (h : C * A â‰¡ C * B [Mod m]) : A â‰¡ B [Mod m / m.Gcd C]
{C : Type uâ‚} [CategoryTheory.Category C] {xâ‚â‚ xâ‚â‚‚ xâ‚‚â‚ xâ‚‚â‚‚ xâ‚ƒâ‚ xâ‚ƒâ‚‚ : C} {hâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚â‚‚} {hâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚‚â‚‚} {hâ‚ƒâ‚ : xâ‚ƒâ‚ âŸ¶ xâ‚ƒâ‚‚} {vâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚‚â‚} {vâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚‚â‚‚} {vâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚ƒâ‚} {vâ‚‚â‚‚ : xâ‚‚â‚‚ âŸ¶ xâ‚ƒâ‚‚} (S : CategoryTheory.IsPullback hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚) (P : hâ‚â‚ â‰« vâ‚â‚‚ = vâ‚â‚ â‰« hâ‚‚â‚) (t : CategoryTheory.IsPullback hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚) : CategoryTheory.IsPullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚
{J : Type v} {C : Type u} [CategoryTheory.Category C] {x Y : C} {F : J â†’ (x âŸ¶ Y)} [Nonempty J] {t : CategoryTheory.Limits.Cotrident F} {Z Z' : C} (q : Z âŸ¶ Z') (ht : CategoryTheory.Limits.IsColimit t) (k : t.x âŸ¶ Z) : â†‘(â‡‘(CategoryTheory.Limits.Cotrident._Colimit.hom_is_iso ht Z') (k â‰« q)) = â†‘(â‡‘(CategoryTheory.Limits.Cotrident._Colimit.hom_is_iso ht Z) k) â‰« q
{x Y : Compactum} (F : x âŸ¶ Y) : Continuous â‡‘F
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] {m N : Submodule R A} {C : Î  (r : A), r âˆˆ m * N â†’ Prop} (hm : âˆ€ (m : A) (h : m âˆˆ m) (n : A) (h_1 : n âˆˆ N), C (m * n) _) (ha : âˆ€ (x : A) (hx : x âˆˆ m * N) (y : A) (hy : y âˆˆ m * N), C x hx â†’ C y hy â†’ C (x + y) _) {r : A} (hr : r âˆˆ m * N) : C r hr
{R : Type u_1} {m : Type u_2} {mâ‚‚ : Type u_3} [TopologicalSpace m] [TopologicalSpace mâ‚‚] [Semiring R] [AddCommMonoid mâ‚‚] [module R mâ‚‚] [AddCommMonoid m] [module R m] (e : m â‰ƒL[R] mâ‚‚) : â†‘e.Inverse = â†‘(e.Symm)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) (h : 0 < P.radius) : âˆƒ (C r : â„) (hC : 0 < C) (hr : 0 < r), âˆ€ (n : â„•), âˆ¥P nâˆ¥ â‰¤ C * r ^ n
{n : â„•} (i : Fin (n + 1)) : Finset.Univ.Sum (Î» (j : Affine.Simplex.points_with_circumcenter_Index n), Affine.Simplex.point_weights_with_circumcenter i j) = 1
(k : Type uâ‚) {G : Type uâ‚‚} [Semiring k] [has_Mul G] {A : Type uâ‚ƒ} [non_unital_non_assoc_Semiring A] [Distrib_MulAction k A] {Ï†â‚ Ï†â‚‚ : Monoid_Algebra k G â†’â‚™â‚[k] A} (h : Ï†â‚.to_Mul_hom.Comp (Monoid_Algebra.of_magma k G) = Ï†â‚‚.to_Mul_hom.Comp (Monoid_Algebra.of_magma k G)) : Ï†â‚ = Ï†â‚‚
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F â‰  2) : âˆƒ (A : F), Â¬IsSquare A
{Î± : Type u_1} {o P : Part Î±} (h : âˆ€ (A : Î±), A âˆˆ o â†” A âˆˆ P) : o = P
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x : v} (hx : x â‰  0) : hb.oangle x (-x) = â†‘Real.Pi
{E : Type u_1} {F : Type u_2} [InnerProductSpace â„ E] [InnerProductSpace â„ F] {F : E â†’ F} {x : E} {F' : E â†’L[â„] F} (h : HasFderivAt F F' x) : ConformalAt F x â†” âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (u v : E), HasInner.inner (â‡‘F' u) (â‡‘F' v) = C * HasInner.inner u v
{vâ‚ : Type u_2} {vâ‚‚ : Type u_3} [semi_NormedGroup vâ‚] [semi_NormedGroup vâ‚‚] (F g : NormedGroup_hom vâ‚ vâ‚‚) : âˆ¥F + gâˆ¥ â‰¤ âˆ¥Fâˆ¥ + âˆ¥gâˆ¥
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P) -áµ¥ P âˆˆ (S.direction)á—®
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} : IsExtrOn F S A â†’ IsExtrOn (â‡‘order_dual.to_dual âˆ˜ F) S A
{Î¹ : Type u} {Î± : Type v} [Fintype Î¹] {t : Î¹ â†’ Finset Î±} [DecidableEq Î±] (ht : âˆ€ (S : Finset Î¹), S.Card â‰¤ (S.bUnion t).Card) : âˆƒ (F : Î¹ â†’ Î±), Function.Injective F âˆ§ âˆ€ (x : Î¹), F x âˆˆ t x
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {E' : Type u_6} [NormedGroup E'] [NormedSpace ð•œ E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace ð•œ F'] {F : E â†’ F} {g : E' â†’ F'} {x : E} {y : E'} (hF : ContDiff_at ð•œ n F x) (hg : ContDiff_at ð•œ n g y) : ContDiff_at ð•œ n (Prod.Map F g) (x, y)
{G : Type u_1} [div_Inv_Monoid G] [MeasurableSpace G] [has_Measurable_Mul G] (g : G) : Measurable (Î» (h : G), h / g)
{Î± : sort u_1} {k l : â„•} (h : k = l) {F : Fin k â†’ Î±} {g : Fin l â†’ Î±} : F == g â†” âˆ€ (i : Fin k), F i = g âŸ¨â†‘i, _âŸ©
{R : Type u_1} [CommSemiring R] {n : Type u_4} [Fintype n] [DecidableEq n] {mâ‚ : Type u_5} [AddCommMonoid mâ‚] [module R mâ‚] (vâ‚ : Basis n R mâ‚) : â‡‘(Linear_Map.to_Matrix vâ‚ vâ‚) LinearMap.Id = 1
{R : Type u} {m : Type v} [CommSemiring R] [AddCommMonoid m] [module R m] (m' : Submodule R m) (S : set R) (hs : Ideal.Span S = âŠ¤) (x : m) (h : âˆ€ (r : â†¥S), âˆƒ (n : â„•), â†‘r ^ n â€¢ x âˆˆ m') : x âˆˆ m'
{Î± : Type u} [PartialOrder Î±] [OrderTop Î±] {A : Î±} : _top A â†’ A = âŠ¤
{R : Type u} [Ring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {m : Type u_1} [AddCommGroup m] [module R m] (A : Î¹ â†’ Submodule R m) : direct_Sum._internal A â†” CompleteLattice.Independent A âˆ§ supr A = âŠ¤
{R : Type x} [Ring R] [no_Zero_divisors R] (u : RË£) : uâ»Â¹ = u â†” u = 1 âˆ¨ u = -1
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] (S : set A) (li : AlgebraicIndependent R Coe) (t : Finset â†¥S) : AlgebraicIndependent R Coe
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F : x âŸ¶ Y} {C : CategoryTheory.Limits.Fork F F} (h : CategoryTheory.Limits.IsLimit C) : CategoryTheory.IsIso C.Î¹
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [AddCommMonoid Î²] {S : Finset Î±} {t : Finset Î³} {F : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (A : Î±), A âˆˆ S â†’ Î³) (hi : âˆ€ (A : Î±) (ha : A âˆˆ S), i A ha âˆˆ t) (h : âˆ€ (A : Î±) (ha : A âˆˆ S), F A = g (i A ha)) (i_inj : âˆ€ (Aâ‚ Aâ‚‚ : Î±) (haâ‚ : Aâ‚ âˆˆ S) (haâ‚‚ : Aâ‚‚ âˆˆ S), i Aâ‚ haâ‚ = i Aâ‚‚ haâ‚‚ â†’ Aâ‚ = Aâ‚‚) (i_surj : âˆ€ (B : Î³), B âˆˆ t â†’ (âˆƒ (A : Î±) (ha : A âˆˆ S), B = i A ha)) : S.Sum (Î» (x : Î±), F x) = t.Sum (Î» (x : Î³), g x)
{Î± : Type u} [PseudoEmetricSpace Î±] : Emetric.diam âˆ… = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : â†‘S1 âŠ“ â†‘S2 = â†‘S1 âˆ© â†‘S2
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : Continuous_MultilinearMap ð•œ E G) (m : Î  (i : Î¹), E i) : âˆ¥â‡‘F mâˆ¥ â‰¤ âˆ¥Fâˆ¥ * Finset.Univ.Prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
 : Cardinal.Mk â†¥set.Univ = Cardinal.Continuum
{Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} {F : MeasureTheory.Filtration â„• m} {u : â„• â†’ Î± â†’ Î²} [AddCommMonoid Î²] [TopologicalSpace Î²] [has_Continuous_Add Î²] (h : MeasureTheory.Adapted F u) : MeasureTheory.prog_Measurable F u
{A : â„} {l : Filter â„} {F F' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhds_within A (set.Univ  {A}), HasDerivAt F (F' x) x) (hgg' : âˆ€á¶  (x : â„) in nhds_within A (set.Univ  {A}), HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhds_within A (set.Univ  {A}), g' x â‰  0) (hfa : Filter.Tendsto F (nhds_within A (set.Univ  {A})) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.Univ  {A})) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), F' x / g' x) (nhds_within A (set.Univ  {A})) l) : Filter.Tendsto (Î» (x : â„), F x / g x) (nhds_within A (set.Univ  {A})) l
{R : Type u} {K : Type v} {L : Type z} {P : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [_IsSeparable K L] [IsDomain R] [normalized_Gcd_Monoid R] [_fraction_Ring R K] [_integrally_IsClosed R] {B : power_Basis K L} (hp : Prime P) (hBint : IsIntegral R B.gen) {z : L} {q : Polynomial R} (hQ : â‡‘(Polynomial.aeval B.gen) q = P â€¢ z) (hzint : IsIntegral R z) (hei : (minpoly R B.gen)._eisenstein_at (Submodule.Span R {P})) : P âˆ£ q.Coeff 0
{Î± : Type u_3} {Î² : Type u_4} [Linear_ordered_Field Î±] {l : Filter Î²} {F : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (Î» (x : Î²), r * F x) l Filter.at_IsBot
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {G : Î¹ â†’ Type u_5} [Î  (i : Î¹), InnerProductSpace ð•œ (G i)] {v : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ v) {Î³ : Type u_3} {F : Î³ â†’ Î¹} (hF : Function.Injective F) : OrthogonalFamily ð•œ (Î» (g : Î³), v (F g))
{Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [Semiring Î²] [has_One Î±] [has_One Î±â‚‚] {F : Type u_4} [One_hom_class F Î± Î±â‚‚] (F : F) : Finsupp.Map_IsDomain â‡‘F 1 = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] (O : Finset C) : âˆƒ (S : C), âˆ€ {x : C}, x âˆˆ O â†’ Nonempty (x âŸ¶ S)
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {S : Î² â†’ Î² â†’ Prop} : Function.Injective Coe_fn
(P : â„•) {q : â„š} (hq : q â‰  0) : padic_norm P q = â†‘P ^ -padic_val_rat P q
{Î± : Type u_2} [DecidableEq Î±] [has_Inv Î±] {S : Finset Î±} : S.Nonempty â†’ Sâ»Â¹.Nonempty
{Î± : Type u} [has_Add Î±] : _Add_hom Id
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (S : Subalgebra R A) : S.to_Submodule * S.to_Submodule = S.to_Submodule
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {A : K} (B C : K) (fract_A_Ne_Zero : Int.fract A â‰  0) : (â†‘âŒŠAâŒ‹ * B + C) / Int.fract A + B = (B * A + C) / Int.fract A
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) {C : â„} (hF'_Ge : âˆ€ (x : â„), x âˆˆ Interior D â†’ C â‰¤ deriv F x) (x : â„) (h : x âˆˆ D) (y : â„) (h_1 : y âˆˆ D) : x â‰¤ y â†’ C * (y - x) â‰¤ F y - F x
{R : Type u_1} {L : Type u_2} [CommRing R] [lie_Ring L] [lie_Algebra R L] {h : LieSubalgebra R L} {x y : L} (hx : x âˆˆ h.Normalizer) (hy : y âˆˆ h) : â…x,yâ† âˆˆ h
{R : Type u_1} {m : Type u_2} [AddCommMonoid m] [CommSemiring R] {S : set m} (hS : AddSubmonoid.Closure S = âŠ¤) : Function.Surjective â‡‘(mv_Polynomial.aeval (Î» (S : â†¥S), AddMonoid_Algebra.of' R m â†‘S))
{n : â„•} (W : 0 < n) (h : Â¬Nat.Prime n) : n.min_fac ^ 2 â‰¤ n
{Î± : Type u_1} {F g : Î± â†’ â„} {tâ‚€ : Filter Î±} (hF : âˆ€ (t : Î±), 0 â‰¤ F t) (hft : âˆ€ (t : Î±), F t â‰¤ g t) (g0 : Filter.Tendsto g tâ‚€ (nhds 0)) : Filter.Tendsto F tâ‚€ (nhds 0)
{C : Type u} [CategoryTheory.Category C] {x Y : C} (J : CategoryTheory.GrothendieckTopology C) (F : Y âŸ¶ x) (S : CategoryTheory.Sieve x) (hF : â‡‘S F) : J.Covers S F
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} (hF : strict_ConcaveOn ð•œ S F) {x y z : ð•œ} (hx : x âˆˆ S) (hz : z âˆˆ S) (hxy : x < y) (hyz : y < z) : (F z - F y) / (z - y) < (F y - F x) / (y - x)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (R : D â¥¤ C) [CategoryTheory.Reflective R] [CategoryTheory.Limits.HasColimits_of_size C] : CategoryTheory.Limits.HasColimits_of_size D
{G : Type u_1} {h : Type u_2} [AddGroup G] {N : Add_Subgroup G} [AddGroup h] {F : G â†’+ h} (hN : N = F.Ker) (tH : AddMonoid._torsion h) (tN : AddMonoid._torsion â†¥N) : AddMonoid._torsion G
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [AddCommMonoid m] (S : Finset (Î± Ã— Î²)) (F : Î± Ã— Î² â†’ m) : finsum (Î» (Ab : Î± Ã— Î²), finsum (Î» (h : Ab âˆˆ S), F Ab)) = finsum (Î» (A : Î±), finsum (Î» (B : Î²), finsum (Î» (h : (A, B) âˆˆ S), F (A, B))))
(R : Type u) [Semiring R] [Nontrivial R] [no_Zero_divisors R] {P : â„•} [hp : Char_P R P] (P_Ne_Zero : P â‰  0) : Nat.Prime P
(n : â„•) : (Pgame.Pow_half n).Numeric
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : HasDist.dist P1 P3 * HasDist.dist P1 P3 = HasDist.dist P1 P2 * HasDist.dist P1 P2 + HasDist.dist P3 P2 * HasDist.dist P3 P2 - 2 * HasDist.dist P1 P2 * HasDist.dist P3 P2 * Real.cos (EuclideanGeometry.angle P1 P2 P3)
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Ring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] [Nonempty Î¹] (F : MultilinearMap R mâ‚ mâ‚‚) (P : Î  (i : Î¹), Submodule R (mâ‚ i)) : â†‘(F.Map P).Nonempty
{G : Type u_1} [Group G] (h : Subgroup G) {x y : G} : x âˆˆ h â†’ y âˆˆ h â†’ x * y âˆˆ h
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [TopologicalSpace Î±] [UniformSpace Î²] {F : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {P : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [LocallyCompactSpace Î±] : Filter.Tendsto F P (nhds F) â†” TendstoLocallyUniformly (Î» (i : Î¹) (A : Î±), â‡‘(F i) A) â‡‘F P
{Î± : Type u_1} {Î¹ : Type u_4} {Î¹' : Type u_5} [NormedRing Î±] [CompleteSpace Î±] {F : Î¹ â†’ Î±} {g : Î¹' â†’ Î±} (hF : Summable (Î» (x : Î¹), âˆ¥F xâˆ¥)) (hg : Summable (Î» (x : Î¹'), âˆ¥g xâˆ¥)) : (âˆ‘' (x : Î¹), F x) * âˆ‘' (y : Î¹'), g y = âˆ‘' (z : Î¹ Ã— Î¹'), F z.fst * g z.Snd
{K : Type u_1} {v : Type u_2} [Field K] [AddCommGroup v] [module K v] {P : â„™ K v â†’ Prop} (h : âˆ€ (v : v) (h : v â‰  0), P (Projectivization.Mk K v h)) (P : â„™ K v) : P P
(P : â„•) [hp : Fact (Nat.Prime P)] (n : â„•) : WittVector.IsPoly P (Î» (R : Type u_1) (_Rcr : CommRing R) (x : witt_Vector P R), x * â†‘n)
{Î¹ : Type u} {F g : Î¹ â†’ â„} {P q : â„} (hpq : P.IsConjugateExponent q) (hF : âˆ€ (i : Î¹), 0 â‰¤ F i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) (hF_Sum : Summable (Î» (i : Î¹), F i ^ P)) (hg_Sum : Summable (Î» (i : Î¹), g i ^ q)) : Summable (Î» (i : Î¹), F i * g i) âˆ§ âˆ‘' (i : Î¹), F i * g i â‰¤ (âˆ‘' (i : Î¹), F i ^ P) ^ (1 / P) * (âˆ‘' (i : Î¹), g i ^ q) ^ (1 / q)
{C : Type u} [ð’ž : CategoryTheory.Category C] {x Y Z : C} (F : x âŸ¶ Z) (g : Y âŸ¶ Z) [CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair x Y)] [CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.ParallelPair (CategoryTheory.Limits.Prod.fst â‰« F) (CategoryTheory.Limits.Prod.Snd â‰« g))] : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan F g)
{Î³ : Type W} [LinearOrder Î³] {A B : Î³} {S t : set Î³} (ha : IsGreatest S A) (hb : IsGreatest t B) : IsGreatest (S âˆª t) (LinearOrder.max A B)
(Î¸ : â„‚) (n : â„•) : Polynomial.Eval (Complex.cos Î¸) (Polynomial.Chebyshev.U â„‚ n) * Complex.sin Î¸ = Complex.sin ((â†‘n + 1) * Î¸)
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] {F : A â†’â‚[R] B} (hF : Function.Surjective â‡‘F) (hker : F.to_Ring_hom.Ker.fg) (hfp : Algebra.Finite_presentation R A) : Algebra.Finite_presentation R B
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} : strict_ConcaveOn ð•œ S F â†” Convex ð•œ S âˆ§ âˆ€ â¦ƒx y z : ð•œâ¦„, x âˆˆ S â†’ z âˆˆ S â†’ x < y â†’ y < z â†’ (F z - F y) / (z - y) < (F y - F x) / (y - x)
{Î± : Type u_1} [Semigroup Î±] {A B C : Î±} : A âˆ£ B â†’ B âˆ£ C â†’ A âˆ£ C
{C : Type uâ‚} [CategoryTheory.Category C] (x : C) [h : Î  (Y : C), Unique (x âŸ¶ Y)] : CategoryTheory.Limits.HasInitial C
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [semi_NormedGroup Î²] (F : bounded_Continuous_Function Î± Î²) (x y : Î±) : HasDist.dist (â‡‘F x) (â‡‘F y) â‰¤ 2 * âˆ¥Fâˆ¥
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ hb.oangle x y = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [CompleteSpace â†¥(S.direction)] {ps : set P} (hnps : ps.Nonempty) {P : P} (hps : ps âŠ† â†‘S) (hp : P âˆ‰ S) (hu : âˆƒ! (cccr : P Ã— â„), cccr.fst âˆˆ S âˆ§ âˆ€ (P1 : P), P1 âˆˆ ps â†’ HasDist.dist P1 cccr.fst = cccr.Snd) : âˆƒ! (cccrâ‚‚ : P Ã— â„), cccrâ‚‚.fst âˆˆ affine_Span â„ (HasInsert.Insert P â†‘S) âˆ§ âˆ€ (P1 : P), P1 âˆˆ HasInsert.Insert P ps â†’ HasDist.dist P1 cccrâ‚‚.fst = cccrâ‚‚.Snd
(z : UpperHalfPlane) : âˆƒ (g : Matrix.special_Linear_Group (Fin 2) â„¤), âˆ€ (g' : Matrix.special_Linear_Group (Fin 2) â„¤), (g' â€¢ z).im â‰¤ (g â€¢ z).im
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [CommRing ð•œ] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G] [module ð•œ E] [module ð•œ F] [module ð•œ G] [TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] [topological_AddGroup F] [has_Continuous_Const_Smul ð•œ F] [topological_AddGroup G] [has_Continuous_Const_Smul ð•œ G] (q : FormalMultilinearSeries ð•œ F G) (P : FormalMultilinearSeries ð•œ E F) (v : Fin 0 â†’ E) (v' : Fin 0 â†’ F) : â‡‘(q.Comp P 0) v = â‡‘(q 0) v'
{R : Type u} [Ring R] : Â¬_Field (Polynomial R)
{cd : Fin 2 â†’ â„¤} (hcd : _IsCoprime (cd 0) (cd 1)) : Filter.Tendsto (Î» (g : {g // â†‘g 1 = cd}), â‡‘(modular_Group.lc_row0 cd) â†‘â†‘g) Filter.cofinite (Filter.cocompact â„)
{Î± : Type u_1} [TopologicalSpace Î±] {Î¹ : Type u_2} [hÎ¹ : Nonempty Î¹] [Encodable Î¹] [t2_Space Î±] {S : Î¹ â†’ set Î±} (hs : âˆ€ (n : Î¹), MeasureTheory.analytic_set (S n)) : MeasureTheory.analytic_set (â‹‚ (n : Î¹), S n)
{Î± : Type u} (e P : Equiv.perm Î±) : â‡‘(Equiv.perm_congr e) P = e * P * eâ»Â¹
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î²] {F : Î± â†’ Î²} [TopologicalSpace Î±] (L : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (F : Î± â†’ Î²), Continuous F âˆ§ âˆ€ (y : Î±), (F y, F y) âˆˆ u)) : Continuous F
{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [Decidable_Rel r] [_Total Î± r] [IsTrans Î± r] (l : List Î±) : List.Sorted r (List.insertion_sort r l)
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (P : P) : P âˆˆ âŠ¤
(R : Type u_1) {v : Type u_2} {P : Type u_4} [Ring R] [Invertible 2] [AddCommGroup v] [module R v] [AddTorsor v P] (R' : Type u_3) [Ring R'] [Invertible 2] [module R' v] (x y : P) : midpoint R x y = midpoint R' x y
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ F} {g : F â†’ G} {n : WithTop â„•} (x : E) (hg : ContDiff_at ð•œ n g (F x)) (hF : ContDiff_at ð•œ n F x) : ContDiff_at ð•œ n (g âˆ˜ F) x
{e : â„‚ â†’ â„‚} {e' : â„‚} {z : â„} (h : HasDerivAt e e' â†‘z) : HasDerivAt (Î» (x : â„), (e â†‘x).re) e'.re z
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hs : (S âˆ© Function.MulSupport F).Finite) (ht : (t âˆ© Function.MulSupport F).Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S âˆª t), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S âˆ© t), F i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ t), F i))
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) : 0 = 1 â†” set.Range â‡‘F = {0}
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] [strict_Convex_Space â„ E] {x y : E} : Â¬SameRay â„ x y â†” âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) {r : â„} (hr : r < 0) : o.oangle x (r â€¢ y) = o.oangle x (-y)
{Î¹ : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : Î¹ â†’ E} (hF : Summable (Î» (i : Î¹), âˆ¥F iâˆ¥)) : âˆ¥âˆ‘' (i : Î¹), F iâˆ¥ â‰¤ âˆ‘' (i : Î¹), âˆ¥F iâˆ¥
{n : â„•} {i : Fin (n + 2)} : SimplexCategoryÎ´ i â‰« SimplexCategoryÎ´ (â‡‘Fin.cast_Succ i) = SimplexCategoryÎ´ i â‰« SimplexCategoryÎ´ i.Succ
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [TopologicalSpace Î²] {F g : Î² â†’ UniformSpace.completion Î±} (hF : Continuous F) (hg : Continuous g) : Continuous (Î» (x : Î²), HasDist.dist (F x) (g x))
{m : Type u_1} [AddZeroClass m] (S : set m) {P : Î  (x : m), x âˆˆ AddSubmonoid.Closure S â†’ Prop} (Hs : âˆ€ (x : m) (h : x âˆˆ S), P x _) (h1 : P 0 _) (HMul : âˆ€ (x : m) (hx : x âˆˆ AddSubmonoid.Closure S) (y : m) (hy : y âˆˆ AddSubmonoid.Closure S), P x hx â†’ P y hy â†’ P (x + y) _) {x : m} (hx : x âˆˆ AddSubmonoid.Closure S) : P x hx
{Î± : Type u} {Î² : Type v} (F : Î± â†’ Î²) (g : Î² â†’ Î±) : set.Inv_on F g (Function.FixedPoints (F âˆ˜ g)) (Function.FixedPoints (g âˆ˜ F))
{F : Type} [Field F] (q : â„•) [hq : Fact (Nat.Prime q)] [Char_P F q] (g g' : Polynomial F) (m m' : â„•) (h_expand : â‡‘(Polynomial.expand F (q ^ m)) g = â‡‘(Polynomial.expand F (q ^ m')) g') (hg : g.IsSeparable) (hg' : g'.IsSeparable) : g.Nat_degree = g'.Nat_degree
{A B C : â„¤} (h : A % B = C) : B âˆ£ A - C
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} {x : Î±} (hx : x âˆˆ S) (Fin : Emetric.Hausdorff_edist S t â‰  âŠ¤) : metric.Inf_dist x t â‰¤ metric.Hausdorff_dist S t
{R : Type u} [CommRing R] (S : Submonoid R) {L : Type u} [CommRing L] [Algebra R L] [IsLocalization S L] : Cardinal.Mk L â‰¤ Cardinal.Mk R
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {S : set Î±} {P : Filter Î¹} [TopologicalSpace Î±] (hs : IsCompact S) : TendstoLocallyUniformlyOn F F P S â†” TendstoUniformlyOn F F P S
{x : top} (F : top.Presheaf (Type v) x) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥x) (sf : top.Presheaf.sheaf_condition_Equalizer_products.Pi_Opens F U) : F._compatible U ((F.Pi_Opens_iso_sections_family U).hom sf) â†” top.Presheaf.sheaf_condition_Equalizer_products.Left_res F U sf = top.Presheaf.sheaf_condition_Equalizer_products.Right_res F U sf
(n : â„•) : Finset.Univ = Finset.Cons (Fin.Last n) (Finset.Map Fin.cast_Succ.to_Embedding Finset.Univ) _
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [module k E] [AddTorsor E PE] (F : k â†’ PE) (A B C : k) : ((B - A) / (C - A)) â€¢ slope F A B + ((C - B) / (C - A)) â€¢ slope F B C = slope F A C
(k : Type u_1) {v : Type u_2} (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] : Vector_Span k âˆ… = âŠ¥
{C C' : Î£ (n : â„•), Composition n} : C = C' â†” C.Snd.blocks = C'.Snd.blocks
{Î± : Type u_1} [Semiring Î±] {m n : â„•} (h : m âˆ£ n) : â†‘m âˆ£ â†‘n
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A B : Matrix n n Î±) : (A.Mul B).adjugate = B.adjugate.Mul A.adjugate
{m : Type u_4} [Group_with_Zero m] {F g : â„š â†’*â‚€ m} (same_on_Int : F.Comp (Int.cast_Ring_hom â„š).to_Monoid_with_ZeroHom = g.Comp (Int.cast_Ring_hom â„š).to_Monoid_with_ZeroHom) : F = g
{Î² : Type u_1} [CommRing Î²] : fib_rec.Char_Poly = Polynomial.x ^ 2 - (Polynomial.x + 1)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (q : C) (F : CategoryTheory.Over P) : F â‰ˆ â†‘0 â†” F.hom = 0
{Î± : Type u_1} {Î² : Type u_2} (P : Pmf Î±) (F : Î± â†’ Pmf Î²) : P.Bind_on_Support (Î» (A : Î±) (_x : A âˆˆ P.Support), F A) = P.Bind F
{Î± : Type u_1} [generalized_boolean_Algebra Î±] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] (u : Î±) (S : Finset Î±) : Uv.IsCompressed u u S
{Î± : Type u_3} {Î² : Type u_4} [Linear_ordered_Field Î±] {l : Filter Î²} {F : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (Î» (x : Î²), r * F x) l Filter.at_top
{m : Type u_1} [AddZeroClass m] (S : Add_Submonoid m) {x y : m} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) (h : x â‰  0) : (minpoly A x).Coeff 0 â‰  0
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [Preorder Î±] {F : Î± â†’ set Î²} {g : Î± â†’ set Î³} (hF : Monotone F) (hg : Monotone g) : Monotone (Î» (x : Î±), F x Ã—Ë¢ g x)
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} {S : set Î±} (h : IsClosed S) : x âˆˆ S â†” Emetric.Inf_edist x S = 0
{Î¹ : Type u} {Î± : Type v} [DecidableEq Î±] (t : Î¹ â†’ Finset Î±) (h : âˆ€ (S : Finset Î¹), S.Card â‰¤ (S.bUnion t).Card) (Î¹' : Finset Î¹) : Nonempty â†¥(HallMatchingsOn t Î¹')
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {t : Affine.Triangle â„ P} {iâ‚ iâ‚‚ : Fin 3} {P : P} (hâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hâ‚ : P âˆˆ Affine.Simplex.altitude t iâ‚) (hâ‚‚ : P âˆˆ Affine.Simplex.altitude t iâ‚‚) : P = t.orthocenter
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x y : E) : HasInner.inner x y = (â†‘âˆ¥x + yâˆ¥ ^ 2 - â†‘âˆ¥x - yâˆ¥ ^ 2 + (â†‘âˆ¥x - _R_or_C.i â€¢ yâˆ¥ ^ 2 - â†‘âˆ¥x + _R_or_C.i â€¢ yâˆ¥ ^ 2) * _R_or_C.i) / 4
(P : â„•) {q : â„š} (hq : q â‰  0) : âˆƒ (z : â„¤), padic_norm P q = â†‘P ^ -z
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : HasInner.inner x y = 0 â†” InnerProductGeometry.angle x y = Real.Pi / 2
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} (hs : Convex ð•œ S) (hF : âˆ€ {x y z : ð•œ}, x âˆˆ S â†’ z âˆˆ S â†’ x < y â†’ y < z â†’ (F y - F x) / (y - x) â‰¤ (F z - F y) / (z - y)) : Convex_on ð•œ S F
{k : Type u_1} {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype Î¹] {P : Î¹ â†’ P} (hi : AffineIndependent k P) {sp : AffineSubspace k P} [Finite_dimensional k â†¥(sp.direction)] (hle : affine_Span k (set.Range P) â‰¤ sp) (hc : Fintype.Card Î¹ = Finite_dimensional.finrank k â†¥(sp.direction) + 1) : affine_Span k (set.Range P) = sp
{Î± : Type u_1} [Linear_ordered_AddCommGroup Î±] [Archimedean Î±] {A : Î±} (ha : 0 < A) (g : Î±) : âˆƒ! (k : â„¤), k â€¢ A â‰¤ g âˆ§ g < (k + 1) â€¢ A
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {F : v â†’â‚—[K] v} : Function.Injective â‡‘F â†” Function.Surjective â‡‘F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q R : C} {F : P âŸ¶ q} {g : q âŸ¶ R} (h : CategoryTheory.Exact F g) : (âˆ€ (A : â†¥P), â‡‘g (â‡‘F A) = 0) âˆ§ âˆ€ (B : â†¥q), â‡‘g B = 0 â†’ (âˆƒ (A : â†¥P), â‡‘F A = B)
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} (incl : S âŠ† t) : Metric.Bounded t â†’ Metric.Bounded S
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] {S : Finset Î±} (hc : S.Card â‰¤ 1) {F : Î± â†’ Î²} {B : Î²} (h : S.Sum (Î» (x : Î±), F x) = B) (x : Î±) (h : x âˆˆ S) : F x = B
{n : â„•} (P : Fin (n + 1)) (i : Fin n) : â‡‘(P.Succ_above) i â‰  P
{Î¹ : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : Î¹ â†’ set x} {S : set x} (hs : IsClosed S) (uo : âˆ€ (i : Î¹), IsOpen (u i)) (uf : âˆ€ (x : x), x âˆˆ S â†’ {i : Î¹ | x âˆˆ u i}.Finite) (us : S âŠ† â‹ƒ (i : Î¹), u i) : âˆƒ (v : Î¹ â†’ set x), S âŠ† set.Union v âˆ§ (âˆ€ (i : Î¹), IsOpen (v i)) âˆ§ âˆ€ (i : Î¹), Closure (v i) âŠ† u i
{G : Type u} [AddGroup G] {x : G} (hx : _of_Fin_Add_order x) : _of_Fin_Add_order (-x)
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {x : C} (S : CategoryTheory.Sieve x) : Jâ‚.IsClosed (Jâ‚.close S)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [module ð•œ Î²] [LinearOrder E] {S : set E} {F : E â†’ Î²} (hs : Convex ð•œ S) (hF : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ S â†’ y âˆˆ S â†’ x < y â†’ âˆ€ â¦ƒA B : ð•œâ¦„, 0 < A â†’ 0 < B â†’ A + B = 1 â†’ A â€¢ F x + B â€¢ F y â‰¤ F (A â€¢ x + B â€¢ y)) : ConcaveOn ð•œ S F
{Î± : Type u_1} {P : set Î± â†’ Prop} {m : Î  (S : set Î±), P S â†’ Ennreal} {P0 : P âˆ…} {m0 : m âˆ… P0 = 0} {S t : set Î±} (h : âˆ€ (u : set Î±), (S âˆ© u).Nonempty â†’ (t âˆ© u).Nonempty â†’ Â¬P u) : â‡‘(MeasureTheory.induced_OuterMeasure m P0 m0) (S âˆª t) = â‡‘(MeasureTheory.induced_OuterMeasure m P0 m0) S + â‡‘(MeasureTheory.induced_OuterMeasure m P0 m0) t
{n : â„•} (A B : Finset (Fin n)) : (Finset.image (Î» (i : Fin n), â†‘i) A).to_colex < (Finset.image (Î» (i : Fin n), â†‘i) B).to_colex â†” A.to_colex < B.to_colex
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] [Fintype m] [DecidableEq m] (A : Matrix m m Î±) (B : Matrix m n Î±) (C : Matrix n m Î±) (D : Matrix n n Î±) [Invertible A] : (Matrix.from_blocks A B C D).det = A.det * (D - (C.Mul (â…Ÿ A)).Mul B).det
{m : Type u_1} [CommMonoid m] (S : Submonoid m) (m : Multiset m) (hm : âˆ€ (A : m), A âˆˆ m â†’ A âˆˆ S) : m.Prod âˆˆ S
{A B : â„•} (hab : A.IsCoprime B) : (A * B).factorization.Support = A.factorization.Support âˆª B.factorization.Support
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : HasDist.dist P3 P1 = HasDist.dist P3 P2) : EuclideanGeometry.angle P3 (midpoint â„ P1 P2) P2 = Real.Pi / 2
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] [Nontrivial k] {S : set P} {P : P} (hp : P âˆˆ S) (W : â†¥S â†’ kË£) : affine_Span k (set.Range (Î» (q : â†¥S), â‡‘(affine_Map.line_Map P â†‘q) â†‘(W q))) = affine_Span k S
{F : Type u_3} [InnerProductSpace â„ F] (x y : F) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” HasInner.inner x y = 0
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Antitone F) : Pairwise (Disjoint on Î» (n : Î±), set.Ico (F n) (F (Order.Pred n)))
(P : â„•) [hp : Fact (Nat.Prime P)] : Prime â†‘P â†” P % 4 = 3
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) {r : â„} (hr : r < 0) : InnerProductGeometry.angle x (r â€¢ y) = InnerProductGeometry.angle x (-y)
{Î± : Type u} [TopologicalSpace Î±] {A : Î±} {P : Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in nhds A, P x) â†” âˆƒ (t : set Î±), (âˆ€ (x : Î±), x âˆˆ t â†’ P x) âˆ§ IsOpen t âˆ§ A âˆˆ t
{G : Type u_1} [Group G] {hâ‚ hâ‚‚ hâ‚ƒ : Subgroup G} (h1 : â…â…hâ‚‚,hâ‚ƒâ†,hâ‚â† = âŠ¥) (h2 : â…â…hâ‚ƒ,hâ‚â†,hâ‚‚â† = âŠ¥) : â…â…hâ‚,hâ‚‚â†,hâ‚ƒâ† = âŠ¥
{Î± : Type u} [TopologicalSpace Î±] {P : Î± â†’ Prop} {A : Î±} (h : âˆ€á¶  (y : Î±) in nhds A, P y) : âˆ€á¶  (y : Î±) in nhds A, âˆ€á¶  (x : Î±) in nhds y, P x
{Î± : Type u_1} [PseudoEmetricSpace Î±] (C : Ennreal) {F : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (F n) (F (n + 1)) â‰¤ C / 2 ^ n) {A : Î±} (ha : Filter.Tendsto F Filter.at_top (nhds A)) (n : â„•) : HasEdist.edist (F n) A â‰¤ 2 * C / 2 ^ n
(A : Type u_1) (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] : minpoly A 1 = Polynomial.x - 1
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : E â†’ F Ã— G} (hF : ContDiff ð•œ n F) : ContDiff ð•œ n (Î» (x : E), (F x).fst)
(R : Type u_1) [CommRing R] [Fintype R] (P : â„•) [Fact (Nat.Prime P)] : IsUnit â†‘P â†” Â¬P âˆ£ Ring_Char R
(C : Type u_1) [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.IsIdempotentComplete C â†” âˆ€ (x : C) (P : x âŸ¶ x), P â‰« P = P â†’ CategoryTheory.Limits.HasKernel P
{Î± : Type u_3} [SemilatticeInf Î±] (A : Î±) : Filter.Map Coe Filter.at_IsBot = Filter.at_IsBot
{x : Type u} {mâ‚ mâ‚‚ : x â†’ x â†’ x} {eâ‚ eâ‚‚ : x} (hâ‚ : EckmannHilton.IsUnital mâ‚ eâ‚) (hâ‚‚ : EckmannHilton.IsUnital mâ‚‚ eâ‚‚) (Distrib : âˆ€ (A B C D : x), mâ‚ (mâ‚‚ A B) (mâ‚‚ C D) = mâ‚‚ (mâ‚ A C) (mâ‚ B D)) : IsAssociative x mâ‚‚
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : Dense (Closure S) â†’ Dense S
{R : Type u_1} [CommRing R] [IsDomain R] (K : Type u_2) [Field K] [Algebra R K] [_fraction_Ring R K] : _integrally_IsClosed R â†” âˆ€ {x : K}, IsIntegral R x â†’ (âˆƒ (y : R), â‡‘(Algebra_Map R K) y = x)
{C : Type uâ‚} [CategoryTheory.Category C] {xâ‚â‚ xâ‚â‚‚ xâ‚â‚ƒ xâ‚‚â‚ xâ‚‚â‚‚ xâ‚‚â‚ƒ : C} {hâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚â‚‚} {hâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚â‚ƒ} {hâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚‚â‚‚} {hâ‚‚â‚‚ : xâ‚‚â‚‚ âŸ¶ xâ‚‚â‚ƒ} {vâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚‚â‚} {vâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚‚â‚‚} {vâ‚â‚ƒ : xâ‚â‚ƒ âŸ¶ xâ‚‚â‚ƒ} (S : CategoryTheory.IsPullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : CategoryTheory.IsPullback hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚) : CategoryTheory.IsPullback (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : Continuous_MultilinearMap ð•œ E G) : âˆ¥Fâˆ¥ = 0 â†” F = 0
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_3} {m : Type u_5} {v : Î¹ â†’ m} [Semiring R] [AddCommMonoid m] [module R m] (h : LinearIndependent R v) (F : Î¹' â†’ Î¹) (hF : Function.Injective F) : LinearIndependent R (v âˆ˜ F)
{x : Type u_1} [TopologicalSpace x] {Î± : Type u_2} {Î² : Type u_3} (F : x â†’ Î±) (g : Î± â†’ Î²) (h : IsLocallyConstant (g âˆ˜ F)) (inj : Function.Injective g) : IsLocallyConstant F
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] (S : set m) (r : R) (hr : IsUnit r) : Submodule.Span R (r â€¢ S) = Submodule.Span R S
{Î± : Type u_1} {Î¹ : sort u_3} [conditionally_CompleteLattice Î±] [Nonempty Î¹] {F : Î¹ â†’ Î±} {C : Î±} (h : âˆ€ (x : Î¹), F x â‰¤ C) : supr F â‰¤ C
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : IsPreconnected S â†” âˆ€ (u v : set Î±), IsOpen u â†’ IsOpen v â†’ S âŠ† u âˆª v â†’ S âˆ© (u âˆ© v) = âˆ… â†’ S âŠ† u âˆ¨ S âŠ† v
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} (h : IsLocalMin F A) : fderiv â„ F A = 0
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) : âˆ¥0âˆ¥ = 0
{ð•œ : Type u_3} {E : Type u_4} [NormedField ð•œ] [AddCommGroup E] [NormedSpace â„ ð•œ] [module ð•œ E] [HasScalar â„ E] [IsScalarTower â„ ð•œ E] (P : Seminorm ð•œ E) : Convex_on â„ set.Univ â‡‘P
(Wâ‚ Wâ‚‚ Pâ‚ Pâ‚‚ : Nnreal) : Wâ‚ + Wâ‚‚ = 1 â†’ Pâ‚ ^ â†‘Wâ‚ * Pâ‚‚ ^ â†‘Wâ‚‚ â‰¤ Wâ‚ * Pâ‚ + Wâ‚‚ * Pâ‚‚
{Î± : Type u} [t : TopologicalSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] {F : Î± â†’ set Î±} (hF : âˆ€ (x : Î±), F x âˆˆ nhds x) : âˆƒ (S : set Î±), S.countable âˆ§ (â‹ƒ (x : Î±) (h : x âˆˆ S), F x) = set.Univ
{A B C : â„¤} (habc : A âˆ£ B * C) (hab : A.Gcd B = 1) : A âˆ£ C
 : Real.sin (Real.Pi / 3) ^ 2 = 3 / 4
{Î± : Type u_1} {râ‚ râ‚‚ : Setoid Î±} : râ‚ = râ‚‚ â†” râ‚.Classes = râ‚‚.Classes
 : Subgroup.Normal_Closure {âŸ¨Fin_Rotate 5, _âŸ©} = âŠ¤
{R : Type u} {m : Type v} [CommRing R] [Nontrivial R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] (F : m â†’â‚—[R] m) : â‡‘(Polynomial.aeval F) F.charpoly = 0
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {m' : Type u_3} [AddCommGroup m'] [module R m'] (F : m â‰ƒâ‚—[R] m) (e : m â‰ƒâ‚—[R] m') : â‡‘Linear_Equiv.det ((e.Symm.Trans F).Trans e) = â‡‘Linear_Equiv.det F
{Î± : Type u_1} {C : set (set Î±)} (h : âˆ€ (A : Î±), âˆƒ! (B : set Î±) (h : B âˆˆ C), A âˆˆ B) {x : Î±} {B B' : set Î±} (hc : B âˆˆ C) (hb : x âˆˆ B) (hc' : B' âˆˆ C) (hb' : x âˆˆ B') : B = B'
{x y : Pgame} (h : x.lf y) (ox : x.Numeric) (oy : y.Numeric) : x < y
{R : Type u_1} [non_assoc_Ring R] [Nontrivial R] (hR : Ring_Char R â‰  2) : set.inj_on Coe {0, 1, -1}
{Î¹ : Type u_1} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [AddCommGroup N] {P : Î¹ â†’ Add_Subgroup N} (h : CompleteLattice.Independent P) : Function.Injective â‡‘(Dfinsupp.Sum_Add_hom (Î» (i : Î¹), (P i).Subtype))
{Î± : Type u} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] : Filter.Tendsto (Î» (r : Î±), râ»Â¹) Filter.at_top (nhds_within 0 (set.ioi 0))
 : IsCyclic (Quaternion_Group 1)
{n : Type u_3} {Î± : Type v} {Î² : Type W} [has_Mul Î±] [has_Mul Î²] (F : Î± â†’ Î²) (r : Î±) (A : Matrix n n Î±) (hF : âˆ€ (Aâ‚ Aâ‚‚ : Î±), F (Aâ‚ * Aâ‚‚) = F Aâ‚ * F Aâ‚‚) : (r â€¢ A).Map F = F r â€¢ A.Map F
{Î· : Type u_2} {Gs : Î· â†’ Type u_3} [Î  (i : Î·), Group (Gs i)] [âˆ€ (i : Î·), Group.IsNilpotent (Gs i)] (n : â„•) (h : âˆ€ (i : Î·), Group.nilpotency_class (Gs i) â‰¤ n) : Group.IsNilpotent (Î  (i : Î·), Gs i)
{mâ‚€ : Type u_1} [Monoid_with_Zero mâ‚€] (u : mâ‚€Ë£) : Ring.Inverse â†‘u = â†‘uâ»Â¹
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) (C : â„) {r : Nnreal} (h : âˆ€ (n : â„•), âˆ¥P nâˆ¥ * â†‘r ^ n â‰¤ C) : â†‘r â‰¤ P.radius
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {x : E} {S t : set E} (h : nhds_within x S = nhds_within x t) : TangentConeAt ð•œ S x = TangentConeAt ð•œ t x
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} (hF : ConcaveOn ð•œ S F) {x y z : ð•œ} (hx : x âˆˆ S) (hz : z âˆˆ S) (hxy : x < y) (hyz : y < z) : (F z - F y) / (z - y) â‰¤ (F y - F x) / (y - x)
{Î± : Type u} [PseudoEmetricSpace Î±] (E : set Î±) {Î´ : â„} (Î´_Pos : 0 < Î´) : Frontier (Metric.Thickening Î´ E) âŠ† {x : Î± | Emetric.Inf_edist x E = Ennreal.of_Real Î´}
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {t : set F} (hs : UniqueDiffOn ð•œ S) (ht : UniqueDiffOn ð•œ t) : UniqueDiffOn ð•œ (S Ã—Ë¢ t)
{Î± : Type u_1} {Î² : Type u_2} [has_Mul Î±] [Preorder Î±] [Preorder Î²] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {F g : Î² â†’ Î±} (hF : Monotone F) (hg : StrictMono g) : StrictMono (Î» (x : Î²), F x * g x)
{Î± : Type u_3} [SemilatticeInf Î±] (A : Î±) : Filter.at_IsBot = Filter.comap Coe Filter.at_IsBot
(R : Type u) [Semiring R] [Nontrivial R] [no_Zero_divisors R] (q : â„•) [hq : ExpChar R q] : Nat.Prime q âˆ¨ q = 1
{S : Type u_1} [Semigroup S] {A B C : S} (hac : Commute A C) (hbc : Commute B C) : Commute (A * B) C
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} : Emetric.Hausdorff_edist S (Closure t) = Emetric.Hausdorff_edist S t
(x : â„) : LiouvilleWith 1 x
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] (F : G â†’* G') (hF : Function.Surjective â‡‘F) [h : Group.IsNilpotent G] : Group.nilpotency_class G' â‰¤ Group.nilpotency_class G
{Î± : Type u_1} {Î´ : Type u_5} [TopologicalSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±] [MeasurableSpace Î´] [complete_LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {F : â„• â†’ Î´ â†’ Î±} (hF : âˆ€ (i : â„•), Measurable (F i)) : Measurable (Î» (x : Î´), Filter.at_top.limsup (Î» (i : â„•), F i x))
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) {r : â„} : 2 â€¢ hb.oangle x (r â€¢ x) = 0
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedSpace ð•œ E] [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {x : E} {F' : E â†’ (E â†’L[ð•œ] G)} (hs : Convex â„ S) {F : E â†’ G} (hder : âˆ€á¶  (y : E) in nhds_within x S, HasFderivWithinAt F (F' y) S y) (hcont : Continuous_within_at F' S x) : âˆƒ (K : Nnreal) (t : set E) (h : t âˆˆ nhds_within x S), LipschitzOnWith K F t
{m : Type u_6} {N : Type u_7} [has_Mul m] [has_Mul N] (e : m â‰ƒ* N) (x : m) : â‡‘(e.Symm) (â‡‘e x) = x
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [semi_NormedGroup E] [NormedSpace ð•œ E] {S : set E} {x' : NormedSpace.dual ð•œ E} {C : ð•œ} (hc : âˆ€ (z : E), z âˆˆ S â†’ âˆ¥â‡‘x' zâˆ¥ â‰¤ âˆ¥Câˆ¥) : Câ»Â¹ â€¢ x' âˆˆ NormedSpace.polar ð•œ S
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : 0 < A) (hb : 0 â‰¤ B) : 0 < A + B
{Î± : Type u_1} [canonically_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B : Î±} [ContravariantClass Î± Î± has_Add.Add has_LE.LE] (h : A â‰¤ B) : B - (B - A) = A
{R : Type u} {L : Type v} [CommRing R] [lie_Ring L] [lie_Algebra R L] : lie_Algebra.IsNilpotent R â†¥((lie_Algebra.ad R L).Range) â†” lie_Algebra.IsNilpotent R L
{P : Type u_2} [MetricSpace P] {psâ‚ psâ‚‚ : set P} (hs : psâ‚ âŠ† psâ‚‚) (hc : EuclideanGeometry.Cospherical psâ‚‚) : EuclideanGeometry.Cospherical psâ‚
 : Real.cos (Real.Pi / 6) = Real.sqrt 3 / 2
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedSpace ð•œ E] [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ G} {S : set E} {F' : E â†’ (E â†’L[ð•œ] G)} {C : Nnreal} (hF : âˆ€ (x : E), x âˆˆ S â†’ HasFderivWithinAt F (F' x) S x) (bound : âˆ€ (x : E), x âˆˆ S â†’ âˆ¥F' xâˆ¥â‚Š â‰¤ C) (hs : Convex â„ S) : LipschitzOnWith C F S
{x : Pgame} : x â‰¤ 0 â†” âˆ€ (i : x.Left_moves), (x.move_Left i).lf 0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} : ContDiff ð•œ âŠ¤ F â†” Differentiable ð•œ F âˆ§ ContDiff ð•œ âŠ¤ (Î» (y : E), fderiv ð•œ F y)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] (O : Finset C) (h : Finset (Î£' (x Y : C) (mX : x âˆˆ O) (mY : Y âˆˆ O), x âŸ¶ Y)) {x Y : C} (mX : x âˆˆ O) (mY : Y âˆˆ O) {F : x âŸ¶ Y} (mf : âŸ¨x, âŸ¨Y, âŸ¨mX, âŸ¨mY, FâŸ©âŸ©âŸ©âŸ© âˆˆ h) : F â‰« CategoryTheory.IsFiltered.to_Sup O h mY = CategoryTheory.IsFiltered.to_Sup O h mX
{n : â„•} {E : Type u_1} [NormedGroup E] {F : (Fin n â†’ â„‚) â†’ E} {C : Fin n â†’ â„‚} {R : Fin n â†’ â„} (hF : TorusIntegrable F C R) : TorusIntegrable (-F) C R
{n : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero â†‘â†‘n] [IsCyclotomicExtension {n} K L] (hn : n â‰  2) (hirr : Irreducible (Polynomial.cyclotomic â†‘n K)) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta n K L) = 1
{m : Type u_1} [MulOneClass m] {C : Con m} : Function.Surjective â‡‘(C.Mk')
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x : â†¥(non_Zero_divisors R)) : v.Int_Valuation_def â†‘x â‰  0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {S : set E} {F : E â†’ F} {g : E â†’ G} (hF : ContDiff_on ð•œ n F S) (hg : ContDiff_on ð•œ n g S) : ContDiff_on ð•œ n (Î» (x : E), (F x, g x)) S
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {Î¹ : Type u_1} (B : Basis Î¹ R m) [Infinite Î¹] {Îº : Type u_1} (v : Îº â†’ m) (i : LinearIndependent R v) (m : i.Maximal) : Cardinal.Mk Îº = Cardinal.Mk Î¹
{A B : Ennreal} (h : A < B) : Add_LE_cancellable A
{Î± : sort u_1} (r : Î± â†’ Î± â†’ Prop) : Function.Surjective (Quot.Mk r)
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {B : m} [Linear_ordered_CommRing m] (ht : â†‘(S.Card) < t.Card â€¢ B) : âˆƒ (y : Î²) (h : y âˆˆ t), â†‘((Finset.Filter (Î» (x : Î±), F x = y) S).Card) < B
{x : Type u_1} [TopologicalSpace x] [CompactSpace x] (A : Subalgebra â„ C(x, â„)) (F : â†¥A) (g : Polynomial â„) : (g.to_Continuous_Map_on (set.icc (-âˆ¥Fâˆ¥) âˆ¥Fâˆ¥)).Comp â†‘F.attach_bound âˆˆ A
{E : Type u_2} [semi_NormedGroup E] [NormedSpace â„ E] (S : set E) : Metric.diam (â‡‘(Convex_hull â„) S) = Metric.diam S
{G : Type u_1} [Group G] [hH : Group.IsNilpotent G] : Group.nilpotency_class (G â§¸ Subgroup.Center G) = Group.nilpotency_class G - 1
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x y + o.oangle y z + o.oangle z x = 0
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : â‡‘(hb.rotation (hb.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
(n : â„¤) : â‡‘Zmod.Ï‡â‚„ â†‘n = Ite (n % 2 = 0) 0 (Ite (n % 4 = 1) 1 (-1))
{x : Type u_1} [TopologicalSpace x] {S t : set x} (ds : DiscreteTopology â†¥S) (ts : t âŠ† S) : DiscreteTopology â†¥t
{m : Type u_1} [Monoid m] {x : m} (m : â„•) {n : â„•} (h : x ^ n = 1) : x ^ m = x ^ (m % n)
{Î¹ : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] [ParacompactSpace x] (hs : IsClosed S) (U : Î¹ â†’ set x) (ho : âˆ€ (i : Î¹), IsOpen (U i)) (hU : S âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (F : PartitionOfUnity Î¹ x S), F._subordinate U
{Fq : Type u_1} [Fintype Fq] [Field Fq] {x y z : Polynomial Fq} {A : â„¤} (hxy : â‡‘Polynomial.Card_Pow_degree (x - y) < A) (hyz : â‡‘Polynomial.Card_Pow_degree (y - z) < A) : â‡‘Polynomial.Card_Pow_degree (x - z) < A
{R : Type u} [Semiring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {m : Type u_1} [AddCommMonoid m] [module R m] {A : Î¹ â†’ Submodule R m} (h : direct_Sum._internal A) : CompleteLattice.Independent A
{x y : Pgame} (r : x.Relabelling y) : x.Equiv y
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {vâ‚‚ : Type v'} [AddCommGroup vâ‚‚] [module K vâ‚‚] {F : v â†’â‚—[K] vâ‚‚} (hF : Function.Injective â‡‘F) : Finite_dimensional.finrank K â†¥(F.Range) = Finite_dimensional.finrank K v
{Î³ : Type u_1} [non_unital_non_assoc_Semiring Î³] (x : Î³) : _AddMonoid_hom (Î» (y : Î³), x * y)
{R : Type u_1} {E : Type u_2} {F : Type u_3} [AddCommGroup E] [TopologicalSpace E] [AddCommGroup F] [TopologicalSpace F] [topological_AddGroup F] [Ring R] [module R E] [module R F] {F : E â†’áµƒ[R] F} : Continuous â‡‘F â†” Continuous â‡‘(F.Linear)
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] (A : Î±) [NoMinOrder Î±] : Closure (set.Iio A) = set.Iic A
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : â†‘r < P.radius) : âˆƒ (C : Nnreal) (h : C > 0), âˆ€ (n : â„•), âˆ¥P nâˆ¥â‚Š * r ^ n â‰¤ C
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B : Î±} (ha : A â‰¤ 0) (hb : B < 0) : A + B < 0
(Î± : Type u) (Î² : Type u_1) [t : TopologicalSpace Î²] [TopologicalSpace.SecondCountableTopology Î²] (F : Î± â†’ Î²) : TopologicalSpace.SecondCountableTopology Î±
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : IsClopen S â†’ Frontier S = âˆ…
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S : set Î±} {B : Î±} (hs : S.Nonempty) (h__ub : âˆ€ (A : Î±), A âˆˆ S â†’ A â‰¤ B) (h_B_LE_ub : âˆ€ (ub : Î±), (âˆ€ (A : Î±), A âˆˆ S â†’ A â‰¤ ub) â†’ B â‰¤ ub) : HasSup.Sup S = B
{Î± : Type u_1} {Î² : Type u_2} [MeasurableSpace Î±] [TopologicalSpace Î²] [TopologicalSpace.pseudo_metrizable_Space Î²] [MeasurableSpace Î²] [BorelSpace Î²] {F : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hF : âˆ€ (i : â„•), Measurable (F i)) (lim : Filter.Tendsto F Filter.at_top (nhds g)) : Measurable g
{Î± : Type u} [TopologicalSpace Î±] {Î¹ : Type u_1} [CompactSpace Î±] {F : Î¹ â†’ set Î±} (hF : locally_Finite F) (hne : âˆ€ (i : Î¹), (F i).Nonempty) : set.Univ.Finite
{R : Type u_1} [CommRing R] [IsDomain R] (K : Type u_2) [Field K] [Algebra R K] [_fraction_Ring R K] : _integrally_IsClosed R â†” IsIntegral_Closure R R K
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : E â†’ F Ã— G} (hF : ContDiff ð•œ n F) : ContDiff ð•œ n (Î» (x : E), (F x).Snd)
{R : Type uâ‚} {L : Type uâ‚‚} [CommRing R] [lie_Ring L] [lie_Algebra R L] [IsNoetherian R L] : lie_Algebra._engelian R L
{R : Type v} [CommRing R] (A : Matrix (Fin 1) (Fin 1) R) : A.det = A 0 0
{Î± : Type u_1} (L : List (List Î±)) {i : â„•} (hi : i < L.length) : List.Drop (List.take i (List.Map List.length L)).Sum (List.take (List.take (i + 1) (List.Map List.length L)).Sum L.Join) = L.nth_LE i hi
{m : Type u_4} [TopologicalSpace m] [AddMonoid m] [has_Continuous_Add m] {U : set m} (hU : U âˆˆ nhds 0) : âˆƒ (v : set m), IsOpen v âˆ§ 0 âˆˆ v âˆ§ v + v âŠ† U
(n P : â„•) : (Finset.Ico 1 (n + 1)).Sum (Î» (k : â„•), â†‘k ^ P) = (Finset.Range (P + 1)).Sum (Î» (i : â„•), bernoulli' i * â†‘((P + 1).choose i) * â†‘n ^ (P + 1 - i) / (â†‘P + 1))
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] [IsNoetherian_Ring R] : Algebra.Finite_Type R A â†” Algebra.Finite_presentation R A
{Î± : Type u_1} [TopologicalSpace Î±] [PolishSpace Î±] {S : set Î±} (hs : IsClosed S) : PolishSpace._clopenable S
{Î± : Type u} [SemilatticeInf Î±] [OrderTop Î±] {Î¹ : Type u} [Fintype Î¹] (F : Î¹ â†’ Î±) : (âˆ F) = (Fintype.elems Î¹).Inf F
{Î± : Type u} {Î² : Type v} [PseudoEmetricSpace Î±] [PseudoEmetricSpace Î²] {F : Î± â†’ Î²} (hF : Isometry F) : uniform_Inducing F
{Î± : Type u_1} [Preorder Î±] [OrderBot Î±] {A : Î±} : IsAtom A â†’ IsCoatom (â‡‘order_dual.to_dual A)
{Î± : Type u} [HasSsubset Î±] [IsAsymm Î± HasSsubset.Ssubset] {A B : Î±} (h : A âŠ‚ B) : Â¬B âŠ‚ A
{P : â„•} {G : Type u_1} [Group G] {P : Subgroup G} (hP : _P_Group P â†¥P) : âˆƒ (q : Sylow P G), P â‰¤ â†‘q
{m : Type u_1} [Monoid m] : Monoid.fg m â†” âˆƒ (S : set m), Submonoid.Closure S = âŠ¤ âˆ§ S.Finite
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set â„} [IntervalIntegral.FTC_Filter B (nhds_within B S) (nhds_within B t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within B t) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_within_at F t B) : HasDerivWithinAt (Î» (u : â„), âˆ« (x : â„) in A..u, F x) (F B) S B
{C : Type u} [CategoryTheory.Category C] {x Y : C} (i : CategoryTheory.Arrow C) (P : x â‰… Y) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.Mk P.hom)
{K : Type u} {v : Type v} {v' : Type v'} [DivisionRing K] [AddCommGroup v] [module K v] [AddCommGroup v'] [module K v'] (Cond : (module.rank K v).Lift = (module.rank K v').Lift) : Nonempty (v â‰ƒâ‚—[K] v')
 : StrictMono Real.sinh
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {P : Filter Î¹} [UniformSpace Î³] {g : Î² â†’ Î³} (h : TendstoUniformly F F P) (hg : uniform_Continuous g) : TendstoUniformly (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ F) P
{A B : â„} : âˆ« (x : â„) in A..B, Real.sin x * Real.cos x = (Real.sin B ^ 2 - Real.sin A ^ 2) / 2
{Î¹ : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : Î¹ â†’ set x} {S : set x} (v : ShrinkingLemma.PartialRefinement u S) (hs : IsClosed S) (i : Î¹) (hi : i âˆ‰ v.carrier) : âˆƒ (v' : ShrinkingLemma.PartialRefinement u S), v < v'
{K : Type u_8} {Kâ‚ : Type u_9} {vâ‚ : Type u_12} {n : Type u_14} [Field K] [Field Kâ‚] [AddCommGroup vâ‚] [module Kâ‚ vâ‚] {iâ‚ iâ‚' : Kâ‚ â†’+* K} {B : vâ‚ â†’â‚›â‚—[iâ‚] vâ‚ â†’â‚›â‚—[iâ‚'] K} {v : n â†’ vâ‚} (hvâ‚ : B._Ortho v) (hvâ‚‚ : âˆ€ (i : n), Â¬B.IsOrtho (v i) (v i)) : LinearIndependent Kâ‚ v
{F : Type u_8} {G : Type u_1} {h : Type u_2} [Group G] [MulOneClass h] [Monoid_hom_class F G h] (F : F) : Function.Injective â‡‘F â†” âˆ€ (A : G), â‡‘F A = 1 â†” A = 1
{n : â„•} (C : Composition n) {j : â„•} (h : j < n) : âˆƒ (i : â„•), j < C.size_Up_to i.Succ âˆ§ i < C.length
 : True
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {Î¹ : Type W} {S : Finset Î¹} (h : Basis â†¥S K v) : Finite_dimensional K v
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} {C : â„‚} {R : â„} {W : â„‚} (hF : CircleIntegrable F C R) (hw : Complex.Abs W < R) : has_Sum (Î» (n : â„•), âˆ® (z : â„‚) in C(C, R), (W / (z - C)) ^ n â€¢ (z - C)â»Â¹ â€¢ F z) (âˆ® (z : â„‚) in C(C, R), (z - (C + W))â»Â¹ â€¢ F z)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) : hb.oangle 0 x = 0
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {G : C â¥¤ D} {K : CategoryTheory.GrothendieckTopology D} [CategoryTheory.Full G] [CategoryTheory.Faithful G] (Hld : CategoryTheory.locally_cover_Dense K G) : CategoryTheory.CoverPreserving Hld.induced_topology K G
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), has_Zero (Î² i)] {F g : Î â‚€ (i : Î¹), Î² i} : F = g â†” âˆ€ (i : Î¹), â‡‘F i = â‡‘g i
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} {C : â„‚} (hD : âˆ€á¶  (z : â„‚) in nhds_within C {C}á¶œ, Differentiable_at â„‚ F z) (hc : Continuous_at F C) : AnalyticAt â„‚ F C
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : â„•} {i : Fin (n + 1)} : x.Ïƒ i â‰« x.Î´ i.Succ = ðŸ™ (x.obj (Opposite.Op (SimplexCategory.Mk n)))
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P : P) : Function.Injective (Î» (_x : G), _x +áµ¥ P)
{Î± : Type u} [DecidableEq Î±] (i j : Î±) : Function.involutive (has_Mul.Mul (Equiv.Swap i j))
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {P : Filter Î¹} [TopologicalSpace Î±] [CompactSpace Î±] : TendstoLocallyUniformly F F P â†” TendstoUniformly F F P
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : F' =o[l] g â†’ (Î» (x : Î±), âˆ¥F' xâˆ¥) =o[l] g
{Î± : Type u} [OrderedSemiring Î±] {A B C D : Î±} [has_exists_Add_of_LE Î±] (hab : A < B) (hcd : C < D) : A * D + B * C < A * C + B * D
{Î± : Type u} {L : List (Î± Ã— Bool)} [DecidableEq Î±] : free_Group.red L (free_Group.reduce L)
{vâ‚ : Type u_2} {vâ‚‚ : Type u_3} [semi_NormedGroup vâ‚] [semi_NormedGroup vâ‚‚] (F : vâ‚ â†’+ vâ‚‚) {C : â„} (h : âˆ€ (x : vâ‚), âˆ¥â‡‘F xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥F.Mk_NormedGroup_hom C hâˆ¥ â‰¤ LinearOrder.max C 0
{l : Filter â„} {F F' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in Filter.at_top, HasDerivAt F (F' x) x) (hgg' : âˆ€á¶  (x : â„) in Filter.at_top, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in Filter.at_top, g' x â‰  0) (hftop : Filter.Tendsto F Filter.at_top (nhds 0)) (hgtop : Filter.Tendsto g Filter.at_top (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), F' x / g' x) Filter.at_top l) : Filter.Tendsto (Î» (x : â„), F x / g x) Filter.at_top l
{P : â„•} {R : Type u_1} [hp : Fact (Nat.Prime P)] [CommRing R] (x y : witt_Vector P R) : â‡‘witt_Vector.verschiebung (x * â‡‘witt_Vector.frobenius y) = â‡‘witt_Vector.verschiebung x * y
{Î± : Type u_1} {m m' : MetricSpace Î±} (h : PseudoMetricSpace.to_HasDist = PseudoMetricSpace.to_HasDist) : m = m'
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [Nonempty Î²] [SemilatticeSup Î²] {S : Î² â†’ Î±} (B : Î² â†’ â„) (h : âˆ€ (n m : Î²), n â‰¤ m â†’ HasDist.dist (S n) (S m) â‰¤ B n) (hâ‚€ : Filter.Tendsto B Filter.at_top (nhds 0)) : Cauchy_Seq S
{P : â„•} [Fact (Nat.Prime P)] {q r : â„š_[P]} : padic_norm_e q â‰  padic_norm_e r â†’ padic_norm_e (q + r) = LinearOrder.max (padic_norm_e q) (padic_norm_e r)
{A : Type u_1} {K : Type u_2} [CommRing A] [IsDomain A] [Unique_factorization_Monoid A] [Field K] [Algebra A K] [_fraction_Ring A K] {P : Polynomial A} {r : K} (hr : â‡‘(Polynomial.aeval r) P = 0) : â†‘(_fraction_Ring.denom A r) âˆ£ P.leading_Coeff
{m : Type u_3} {N : Type u_4} [MulOneClass m] [MulOneClass N] (F : m â†’* N) (A B : m) : â‡‘F (A * B) = â‡‘F A * â‡‘F B
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (hs : IsClosed S) : IsPreconnected S â†” âˆ€ (u v : set Î±), IsClosed u â†’ IsClosed v â†’ S âŠ† u âˆª v â†’ u âˆ© v = âˆ… â†’ S âŠ† u âˆ¨ S âŠ† v
{Î¹ : Type u_1} {ð•œ : Type u_2} [_R_or_C ð•œ] {E : Type u_3} [InnerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), InnerProductSpace ð•œ (G i)] {v : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ v) [âˆ€ (i : Î¹), CompleteSpace (G i)] (hV' : (â¨† (i : Î¹), (v i).to_LinearMap.Range).topological_Closure = âŠ¤) (Wâ‚€ : Î â‚€ (i : Î¹), G i) : â‡‘(â‡‘(hV.Linear_Isometry_Equiv hV') (Wâ‚€.Sum (Î» (i : Î¹), â‡‘(v i)))) = â‡‘Wâ‚€
(A B : Ennreal) {P q : â„} (hpq : P.IsConjugateExponent q) : A * B â‰¤ A ^ P / Ennreal.of_Real P + B ^ q / Ennreal.of_Real q
{n : â„•} (A : Fin (n + 1)) : â†‘â†‘A = A
{C : Type u} [CategoryTheory.Category C] {x Y : C} (F : x âŸ¶ Y) (t : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.PushoutCocone.Mk (ðŸ™ Y) (ðŸ™ Y) rfl)) : CategoryTheory.Epi F
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : Reflexive r) {x y : Î±} (hr : x â‰  y â†’ r x y) : r x y
{R : Type u} [Ring R] (S : Subring R) {x y : R} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{R : Type u_1} (m : Type u_3) [has_Zero R] [has_Zero m] [SmulWithZero R m] (r : R) : r â€¢ 0 = 0
{Î± : Type u_2} {Î² : Type u_3} [SemilatticeInf Î±] [OrderBot Î±] [SemilatticeInf Î²] [OrderBot Î²] {A B : Î±} (F : Î± â‰ƒo Î²) (ha : Disjoint A B) : Disjoint (â‡‘F A) (â‡‘F B)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [SemilatticeInf Î²] {F g : Î± â†’ Î²} (hF : Antitone F) (hg : Antitone g) : Antitone (F âŠ“ g)
(x : AlgebraicGeometry.LocallyRingedSpace) (x : â†¥x) : AlgebraicGeometry.StructureSheaf.to_stalk â†¥(Opposite.Unop (Opposite.Op (AlgebraicGeometry.LocallyRingedSpace.Î“.obj (Opposite.Op x)))) (â‡‘(x.toÎ“_spec_SheafedSpace.Base) x) â‰« AlgebraicGeometry.PresheafedSpace.stalk_Map x.toÎ“_spec_SheafedSpace x = x.Î“_to_stalk x
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {Râ‚ Râ‚‚ : â„} {F : â„‚ â†’ E} {C z : â„‚} (hD : DifferentiableOn â„‚ F (Metric.Ball C Râ‚)) (h_maps : set.maps_to F (Metric.Ball C Râ‚) (Metric.Ball (F C) Râ‚‚)) (hz : z âˆˆ Metric.Ball C Râ‚) : HasDist.dist (F z) (F C) â‰¤ Râ‚‚ / Râ‚ * HasDist.dist z C
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {x : C} (h : CategoryTheory.coyoneda.obj (Opposite.Op x) â‹™ CategoryTheory.ulift_Functor â‰… F.cocones) (S : CategoryTheory.Limits.Cocone F) : (CategoryTheory.Limits.IsColimit.of_Nat_iso.Colimit_Cocone h).extend (CategoryTheory.Limits.IsColimit.of_Nat_iso.hom_of_Cocone h S) = S
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_4} [Fintype Î¹] (B : Basis Î¹ R m) : (LinearMap.trace R m).Comp (dual_tensor_hom R m m) = contract_Left R m
{F : Type u_3} [InnerProductSpace â„ F] (x y : F) : HasInner.inner (x + y) (x - y) = 0 â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{Î± : Type u_1} [TopologicalSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] (m : MeasureTheory.OuterMeasure Î±) {S : set Î±} (hs : â‡‘m S â‰  0) : âˆƒ (x : Î±) (h : x âˆˆ S), âˆ€ (t : set Î±), t âˆˆ nhds_within x S â†’ 0 < â‡‘m t
{G : Type u_1} [Group G] (h : Subgroup G) {x y : G} (hx : x âˆˆ h) (hy : y âˆˆ h) : x / y âˆˆ h
{Î± : Type u_1} {Î² : Type u_2} [AddMonoid Î²] {S : Finset Î±} (F g : Î± â†’ Î²) (comm_ff : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ Add_Commute (F x) (F y)) (comm_gg : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ Add_Commute (g x) (g y)) (comm_gf : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ x â‰  y â†’ Add_Commute (g x) (F y)) : S.noncomm_Sum (F + g) _ = S.noncomm_Sum F comm_ff + S.noncomm_Sum g comm_gg
(k : Type u_1) (G : Type u_2) [CommSemiring k] [Group G] [Fintype G] [Invertible â†‘(Fintype.Card G)] (g : G) : Group_Algebra.average k G * Finsupp.single g 1 = Group_Algebra.average k G
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) : â‡‘LinearMap.det â†‘(hb.Conj_lie.to_Linear_Equiv) = -1
 : Irrational GoldenRatio
{n : â„¤} : Even n â†’ Even n.Nat_Abs
{m : Type u_1} [Monoid m] {x y z : m} : y âˆˆ Powers x â†’ z âˆˆ Powers x â†’ y * z âˆˆ Powers x
{m : Type u_1} [has_Mul m] {C D : Con m} (h : âˆ€ (x y : m), â‡‘C x y â†” â‡‘D x y) : C = D
{n : WithTop â„•} {ð•‚ : Type u_6} [_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [NormedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace ð•‚ F'] {F : E' â†’ F'} {F' : E' â†’L[ð•‚] F'} {x : E'} (hF : ContDiff_at ð•‚ n F x) (hF' : HasFderivAt F F' x) (hn : 1 â‰¤ n) : HasStrictFderivAt F F' x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {l : List L} : (âˆ€ (x : L), x âˆˆ l â†’ x âˆˆ S) â†’ l.Prod âˆˆ S
{R : Type u} {A : Type v} [CommSemiring R] [Ring A] [Algebra R A] {r : R} {A : A} : r âˆˆ resolvent_set R A â†” IsUnit (resolvent A r)
{Î± : Type u_1} [has_LT Î±] {A B : Î±} (h : A < B) : Â¬A â‹– B â†” âˆƒ (C : Î±), A < C âˆ§ C < B
{Î± : Type u} [Preorder Î±] {A B C : Î±} (hab : A = B) (hbc : B < C) : A < C
(A B : Nnreal) {P q : Nnreal} (hp : 1 < P) (hpq : 1 / P + 1 / q = 1) : A * B â‰¤ A ^ â†‘P / P + B ^ â†‘q / q
 : Cardinal.Mk â„ = Cardinal.Continuum
(K : Type u) {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {A : set v} (hA : A.Finite) : Finite_dimensional K â†¥(Submodule.Span K A)
{Î± : Type u_1} [PseudoMetricSpace Î±] {E' : Type u_2} [NormedGroup E'] [NormedSpace â„ E'] [Finite_dimensional â„ E'] {S : set Î±} {F : Î± â†’ E'} {K : Nnreal} (hF : LipschitzOnWith K F S) : âˆƒ (g : Î± â†’ E'), LipschitzWith (lipschitz_extension_constant E' * K) g âˆ§ set.Eq_on F g S
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {e e' : LocalHomeomorph Î± Î²} {F F' : LocalHomeomorph Î² Î³} (hE : e â‰ˆ e') (hF : F â‰ˆ F') : e.Trans F â‰ˆ e'.Trans F'
{Î± : Type u_1} {Î¹ : sort u_4} [CompleteLattice Î±] {B : Î±} {F : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), F i â‰¤ B) (hâ‚‚ : âˆ€ (W : Î±), W < B â†’ (âˆƒ (i : Î¹), W < F i)) : (â¨† (i : Î¹), F i) = B
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {P : P} (hp : P âˆˆ S) {v : v} (hv : v âˆˆ (S.direction)á—®) : â‡‘(EuclideanGeometry.Orthogonal_projection S) (v +áµ¥ P) = âŸ¨P, hpâŸ©
{ð•œ : Type u_1} {n : Type u_3} [_R_or_C ð•œ] [Fintype n] [DecidableEq n] {U : Matrix n n ð•œ} (hU : U âˆˆ Matrix.unitary_Group n ð•œ) : âˆ¥Uâˆ¥ â‰¤ 1
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} (t : CategoryTheory.Limits.Cofork F g) [CategoryTheory.Mono t.Ï€] : F = g
(ð•‚ : Type u_1) (ð•‚' : Type u_2) (ð”¸ : Type u_3) [Field ð•‚] [Field ð•‚'] [Ring ð”¸] [Algebra ð•‚ ð”¸] [Algebra ð•‚' ð”¸] [TopologicalSpace ð”¸] [topological_Ring ð”¸] : Exp ð•‚ = Exp ð•‚'
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {F' : F} [LinearOrder ð•œ] [order_IsClosed_topology ð•œ] {x y : ð•œ} (h : x < y) : HasDerivWithinAt F F' (set.Ioo x y) x â†’ HasDerivWithinAt F F' (set.ioi x) x
{Î± : Type u} {Î¹ : Type u_1} [TopologicalSpace Î±] {S : set Î±} {B : set Î¹} {C : Î¹ â†’ set Î±} (hs : IsCompact S) (hcâ‚ : âˆ€ (i : Î¹), i âˆˆ B â†’ IsOpen (C i)) (hcâ‚‚ : S âŠ† â‹ƒ (i : Î¹) (h : i âˆˆ B), C i) : âˆƒ (B' : set Î¹) (h : B' âŠ† B), B'.Finite âˆ§ S âŠ† â‹ƒ (i : Î¹) (h : i âˆˆ B'), C i
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) (z : N) (W v : P) : â‡‘(F.Lift hg) z * W = v â†” â‡‘g (F.sec z).fst * W = â‡‘g â†‘((F.sec z).Snd) * v
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x Y : C} {R : CategoryTheory.Presieve x} {x : CategoryTheory.Presieve.FamilyOfElements P R} (t : x.compatible) {F : Y âŸ¶ x} (hF : R F) : x.Sieve_extend F _ = x F hF
(L : List â„•) (h : âˆ€ (i : â„•), i âˆˆ L â†’ 1 â‰¤ i) : L.length â‰¤ L.Sum
{R : Type u} [Ring R] (S : Subring R) {l : List R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ S) â†’ l.Sum âˆˆ S
{E : Type u_1} [semi_NormedGroup E] [NormedSpace â„ E] {x y : E} (h : SameRay â„ x y) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {F g : v â†’â‚—[K] v} (hfg : F * g = 1) : g * F = 1
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} (hF : HasFpowerSeriesAt F P x) : (Î» (y : E Ã— E), F y.fst - F y.Snd - â‡‘(P 1) (Î» (_x : Fin 1), y.fst - y.Snd)) =O[nhds (x, x)] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.Sndâˆ¥
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) {u : â„• â†’ Î±} {init : Fin E.order â†’ Î±} (h : E._solution u) (HEq : âˆ€ (n : Fin E.order), u â†‘n = init n) (n : â„•) : u n = E.Mk_sol init n
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {n : â„•} : ContDiff ð•œ â†‘(n + 1) F â†” Differentiable ð•œ F âˆ§ ContDiff ð•œ â†‘n (Î» (y : E), fderiv ð•œ F y)
{R : Type u_2} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] {m : Type u_3} [AddCommGroup m] [module R m] {Î¹ : Type u_1} [Fintype Î¹] (B : Basis Î¹ R m) (N : Submodule R m) : âˆƒ (n : â„•), Nonempty (Basis (Fin n) R â†¥N)
{Î² : Type u} {Î± : Type v} {S : Finset Î±} {F : Î± â†’ Î²} [AddCommMonoid Î²] (R : Setoid Î±) [Decidable_Rel Setoid.r] (h : âˆ€ (x : Î±), x âˆˆ S â†’ (Finset.Filter (Î» (y : Î±), y â‰ˆ x) S).Sum (Î» (A : Î±), F A) = 0) : S.Sum (Î» (x : Î±), F x) = 0
{R : Type u_1} {m : Type u_2} [CommRing R] [AddCommGroup m] [module R m] (q : QuadraticForm R m) {P : Î  (x : clifford_Algebra q), x âˆˆ clifford_Algebra.Even_Odd q 1 â†’ Prop} (hÎ¹ : âˆ€ (v : m), P (â‡‘(clifford_Algebra.Î¹ q) v) _) (HAdd : âˆ€ {x y : clifford_Algebra q} {hx : x âˆˆ clifford_Algebra.Even_Odd q 1} {hy : y âˆˆ clifford_Algebra.Even_Odd q 1}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_Mul : âˆ€ (mâ‚ mâ‚‚ : m) {x : clifford_Algebra q} {hx : x âˆˆ clifford_Algebra.Even_Odd q 1}, P x hx â†’ P (â‡‘(clifford_Algebra.Î¹ q) mâ‚ * â‡‘(clifford_Algebra.Î¹ q) mâ‚‚ * x) _) (x : clifford_Algebra q) (hx : x âˆˆ clifford_Algebra.Even_Odd q 1) : P x hx
{m : Type u_1} {N : Type u_2} {Î± : Type u_6} {Î² : Type u_7} [HasScalar m Î±] [HasScalar Î² Î±] [SmulCommClass Î² m Î±] (g : N â†’ m) : SmulCommClass Î² N Î±
{m : Type u_1} {A : Type u_3} [Fintype m] [CommRing A] [IsDomain A] [DecidableEq m] {m : Matrix m m A} (hM : m.det â‰  0) : m.nondegenerate
{Î± : Type u_1} {Î² : Type u_2} {e e' : local_Equiv Î± Î²} (h : e â‰ˆ e') : e.Symm â‰ˆ e'.Symm
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} : Emetric.Hausdorff_edist (Closure S) (Closure t) = Emetric.Hausdorff_edist S t
{R : Type u} {m : Type v} [Monoid R] [MulAction R m] {P : sub_MulAction R m} (m : â†¥P) : MulAction.Stabilizer.Submonoid R m = MulAction.Stabilizer.Submonoid R â†‘m
{Î± : Type u_2} [DecidableEq Î±] {B : Finset (Finset Î±)} {n : â„•} [Fintype Î±] (h : âˆ€ (A : Î±), (Finset.Filter (HasMem.Mem A) B).Card â‰¤ n) : B.Sum (Î» (S : Finset Î±), S.Card) â‰¤ Fintype.Card Î± * n
{G : Type u_1} [Group G] {h : Type u_2} [Group h] (F : G â†’* h) (hF1 : F.Ker â‰¤ Subgroup.Center G) (hH : Group.IsNilpotent h) : Group.IsNilpotent G
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A B : Î±} : A â‰¤ Bâ»Â¹ â†’ B â‰¤ Aâ»Â¹
{Î² : Type u_2} [PseudoMetricSpace Î²] {Î± : Type u_1} [MetricSpace Î±] {K : Nnreal} {F : Î± â†’ Î²} [ProperSpace Î±] (hK : AntilipschitzWith K F) (F_Cont : Continuous F) (hF : Function.Surjective F) : ProperSpace Î²
{Î± : Type u} [EmetricSpace Î±] {S t : TopologicalSpace.Closeds Î±} : HasEdist.edist S t = Emetric.Hausdorff_edist â†‘S â†‘t
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) : 0 âˆˆ S
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [Opens_MeasurableSpace x] (m : set x â†’ Ennreal) (hcl : âˆ€ (S : set x), m (Closure S) = m S) (r : Ennreal) : (MeasureTheory.OuterMeasure.Mk_metric'.pre m r).trim = MeasureTheory.OuterMeasure.Mk_metric'.pre m r
{Î¹ : Type u_1} {R : Type u_2} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] {m : Type u_3} [AddCommGroup m] [module R m] [Fintype Î¹] (B : Basis Î¹ R m) (N O : Submodule R m) (N_LE_O : N â‰¤ O) : âˆƒ (n o : â„•) (hno : n â‰¤ o) (bO : Basis (Fin o) R â†¥O) (bN : Basis (Fin n) R â†¥N) (A : Fin n â†’ R), âˆ€ (i : Fin n), â†‘(â‡‘bN i) = A i â€¢ â†‘(â‡‘bO (â‡‘(Fin.cast_LE hno) i))
{Î± : Type u} [TopologicalSpace Î±] [t2_Space Î±] [CompactSpace Î±] [TotallyDisconnectedSpace Î±] {x : Î±} {U : set Î±} (IsOpen : _root.IsOpen U) (memU : x âˆˆ U) : âˆƒ (v : set Î±) (hV : IsClopen v), x âˆˆ v âˆ§ v âŠ† U
{Î± : Type u_1} {n : Type u_2} {m : Type u_3} [has_Mul Î±] [AddCommMonoid Î±] (A : Matrix m n Î±) [Fintype n] : A.transpose.has_Orthogonal_cols â†” A.has_Orthogonal_rows
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {E' : Type u_6} [NormedGroup E'] [NormedSpace ð•œ E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace ð•œ F'] {S : set E} {t : set E'} {F : E â†’ F} {g : E' â†’ F'} {P : E Ã— E'} (hF : ContDiff_within_at ð•œ n F S P.fst) (hg : ContDiff_within_at ð•œ n g t P.Snd) : ContDiff_within_at ð•œ n (Prod.Map F g) (S Ã—Ë¢ t) P
{ð•œ : Type u_1} [_R_or_C ð•œ] {E : Type u_2} {E' : Type u_3} [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ E'] (F : E â‰ƒâ‚—áµ¢[ð•œ] E') (K : Submodule ð•œ E) [CompleteSpace â†¥K] (x : E') : â‡‘(reflection (Submodule.Map â†‘(F.to_Linear_Equiv) K)) x = â‡‘F (â‡‘(reflection K) (â‡‘(F.Symm) x))
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x y : E} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + HasInner.inner x y + HasInner.inner y x + HasInner.inner y y
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [AddCommGroup Î²] {F : Î± â†’ Î²} (hF : _AddGroup_hom F) : _AddGroup_hom (Î» (A : Î±), -F A)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {tâ‚ tâ‚‚ : Affine.Triangle â„ P} {iâ‚ iâ‚‚ iâ‚ƒ jâ‚ jâ‚‚ jâ‚ƒ : Fin 3} (hiâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hiâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hiâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) (hjâ‚â‚‚ : jâ‚ â‰  jâ‚‚) (hjâ‚â‚ƒ : jâ‚ â‰  jâ‚ƒ) (hjâ‚‚â‚ƒ : jâ‚‚ â‰  jâ‚ƒ) (hâ‚ : tâ‚‚.points jâ‚ = tâ‚.orthocenter) (hâ‚‚ : tâ‚‚.points jâ‚‚ = tâ‚.points iâ‚‚) (hâ‚ƒ : tâ‚‚.points jâ‚ƒ = tâ‚.points iâ‚ƒ) : Affine.Simplex.altitude tâ‚‚ jâ‚‚ = affine_Span â„ {tâ‚.points iâ‚, tâ‚.points iâ‚‚}
{Î± : Type u_1} {G : Type u_4} [CompleteLattice Î±] [Group G] (Fâ‚ Fâ‚‚ : G â†’* Î± â‰ƒo Î±) (g : G) : Function.Semiconj (Î» (x : Î±), â¨† (g' : G), â‡‘(â‡‘Fâ‚ g')â»Â¹ (â‡‘(â‡‘Fâ‚‚ g') x)) â‡‘(â‡‘Fâ‚‚ g) â‡‘(â‡‘Fâ‚ g)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : 1 â‰¤ A) (hb : 1 â‰¤ B) : 1 â‰¤ A * B
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall F P x r) (h : â†‘r' < r) : âˆƒ (A : â„) (h : A âˆˆ set.Ioo 0 1) (C : â„) (h : C > 0), âˆ€ (y : E), y âˆˆ Metric.Ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥F (x + y) - P.partial_Sum n yâˆ¥ â‰¤ C * A ^ n
(P : â„•) [Fact (Nat.Prime P)] {A : â„¤} : Zmod.legendre_Sym P A = -1 â†” Â¬IsSquare â†‘A
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] {i : Î± â†’ Î²} [TopologicalSpace Î³] [t2_Space Î³] {F : Î± â†’ Î³} (di : Dense_Inducing i) (hF : âˆ€ (B : Î²), âˆƒ (C : Î³), Filter.Tendsto F (Filter.comap i (nhds B)) (nhds C)) (A : Î±) : di.extend F (i A) = F A
{R : Type u} [CommSemiring R] {Î¹ : Type u_1} (S : Finset Î¹) (P : Î¹ â†’ Polynomial R) (x : R) : Polynomial.Eval x (S.Prod (Î» (j : Î¹), P j)) = S.Prod (Î» (j : Î¹), Polynomial.Eval x (P j))
{Î± : Type u} [PartialOrder Î±] [OrderBot Î±] {A : Î±} : IsMin A â†’ A = âŠ¥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] {F G : top.sheaf C x} (F : F âŸ¶ G) : CategoryTheory.IsIso F â†” âˆ€ (x : â†¥x), CategoryTheory.IsIso ((top.Presheaf.stalk_Functor C x).Map F)
{C : Type uâ‚} [CategoryTheory.Category C] {xâ‚â‚ xâ‚â‚‚ xâ‚‚â‚ xâ‚‚â‚‚ xâ‚ƒâ‚ xâ‚ƒâ‚‚ : C} {hâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚â‚‚} {hâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚‚â‚‚} {hâ‚ƒâ‚ : xâ‚ƒâ‚ âŸ¶ xâ‚ƒâ‚‚} {vâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚‚â‚} {vâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚‚â‚‚} {vâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚ƒâ‚} {vâ‚‚â‚‚ : xâ‚‚â‚‚ âŸ¶ xâ‚ƒâ‚‚} (S : CategoryTheory.IsPushout hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚) (P : hâ‚‚â‚ â‰« vâ‚‚â‚‚ = vâ‚‚â‚ â‰« hâ‚ƒâ‚) (t : CategoryTheory.IsPushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) : CategoryTheory.IsPushout hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) (A B : Î±) : â‡‘F (A + B) = â‡‘F A + â‡‘F B
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) {Î² : Type u_1} (S : Finset Î²) (F : n â†’ Î² â†’ Î±) (i : n) : S.Sum (Î» (x : Î²), â‡‘(A.cramer) (Î» (j : n), F j x) i) = â‡‘(A.cramer) (Î» (j : n), S.Sum (Î» (x : Î²), F j x)) i
{Î± : Type u} (L : List Î±) {i j : â„•} (hi : i < (List.take j L).length) : (List.take j L).nth_LE i hi = L.nth_LE i _
{Î± : Type u_1} [circular_Preorder Î±] {A B C : Î±} (h : HasBtw.Btw A B C) : Â¬HasSbtw.Sbtw C B A
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : â‡‘(o.rotation (o.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{Î± : Type u_1} {E : Type u_2} [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] {F : Î± â†’ E} : Summable (Î» (x : Î±), âˆ¥F xâˆ¥) â†” Summable F
{m : Type u} [Monoid m] {A : m} {x y : mË£} (h : SemiconjBy A â†‘x â†‘y) : SemiconjBy A â†‘xâ»Â¹ â†‘yâ»Â¹
{m : Type u_2} [AddCommGroup m] {A : Type u_5} [CommRing A] [module A m] {N : Type u_1} [AddCommGroup N] [module A N] (F : m â†’â‚—[A] m) (e : m â‰ƒâ‚—[A] N) : â‡‘LinearMap.det (â†‘e.Comp (F.Comp â†‘(e.Symm))) = â‡‘LinearMap.det F
{E : Type u_2} [semi_NormedGroup E] [Star_AddMonoid E] [normed_Star_Group E] : Isometry HasStar.Star
{Î¹ : Type u_1} [Fintype Î¹] [DecidableEq Î¹] (t : Matrix.TransvectionStruct Î¹ â„) : MeasureTheory.MeasurePreserving â‡‘(â‡‘Matrix.to_lin' t.to_Matrix) MeasureTheory.MeasureSpace.Volume MeasureTheory.MeasureSpace.Volume
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [CompactSpace Î±] [MetricSpace Î²] : Continuous Coe_fn
{t : Type uâ‚} [CategoryTheory.Category t] {x : t} {F g : CategoryTheory.Over x} (k : F âŸ¶ g) [hk : CategoryTheory.Mono k.Left] : CategoryTheory.Mono k
{Î± : Type u} {Î² : Type v} (F : Î± â‰ƒ. Î²) (Aâ‚‚ : Î±) (h : âˆ€ (Aâ‚ : Î±), Aâ‚ â‰  Aâ‚‚ â†’ â†¥((â‡‘F Aâ‚)._Some)) : Function.Injective â‡‘F
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r r' : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) (hr : r' < r) : (Î» (y : E Ã— E), F y.fst - F y.Snd - â‡‘(P 1) (Î» (_x : Fin 1), y.fst - y.Snd)) =O[Filter.principal (Emetric.Ball (x, x) r')] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.Sndâˆ¥
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {vâ‚ vâ‚‚ : m} (h : vâ‚ âˆˆ MulAction.Orbit â†¥(units.Pos_Subgroup R) vâ‚‚) : SameRay R vâ‚ vâ‚‚
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.has_Finite_colimits C] : CategoryTheory.Limits.has_Finite_wide_pushouts C
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [CommRing ð•œ] [AddCommGroup E] [AddCommGroup F] [module ð•œ E] [module ð•œ F] [TopologicalSpace E] [TopologicalSpace F] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] [topological_AddGroup F] [has_Continuous_Const_Smul ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {n : â„•} (C : Composition n) (j : Fin n) (v : Fin n â†’ E) (z : E) : P.apply_Composition C (Function.update v j z) = Function.update (P.apply_Composition C v) (C.Index j) (â‡‘(P (C.blocks_fun (C.Index j))) (Function.update (v âˆ˜ â‡‘(C.Embedding (C.Index j))) (C.Inv_Embedding j) z))
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : (Closure S).Nonempty â†’ S.Nonempty
{x y : Pgame} (h : x.lf y) (ox : x.Numeric) (oy : y.Numeric) : x â‰¤ y
{n : â„•} (P : Fin n â†’ Prop) [Decidable_Pred P] {i : Fin n} (hi : i âˆˆ Fin.Find P) : P i
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] [t1_Space Î²] {F : Î± â†’ Î²} {A : Î±} {B : Î²} (h : Filter.Tendsto F (nhds A) (nhds B)) : F A = B
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization m S] {Î¹ : Type u_3} [Fintype Î¹] (F : Î¹ â†’ S) : âˆƒ (B : â†¥m), âˆ€ (i : Î¹), IsLocalization._integer R (â†‘B â€¢ F i)
{Î± : Type u} {l : List Î±} : l.Nodup â†’ l.sublists'.Nodup
{K : Type u_1} {S : Type u_2} [Field K] [CommRing S] [Algebra K S] {R : Type u_3} [CommRing R] [Algebra R S] [Algebra R K] [IsScalarTower R K S] {B B' : power_Basis K S} {P : Polynomial R} (h : â‡‘(Polynomial.aeval B.gen) P = B'.gen) (hB : IsIntegral R B.gen) (hmin : minpoly K B.gen = Polynomial.Map (Algebra_Map R K) (minpoly R B.gen)) (i : Fin B.dim) (j : Fin B'.dim) : IsIntegral R (B.Basis.to_Matrix â‡‘(B'.Basis) i j)
{R : Type u} {S : Type v} [Semiring R] [Semiring S] (F : R â†’+* S) {r : R} : r âˆˆ F.Ker â†” â‡‘F r = 0
{K : Type u} [Field K] (S : Subfield K) {Î¹ : Type u_1} {t : Finset Î¹} {F : Î¹ â†’ K} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Sum (Î» (i : Î¹), F i) âˆˆ S
{x : Type u} [Preorder x] {x y : x} (h : x âŸ¶ y) : x â‰¤ y
{n : WithTop â„•} {ð•‚ : Type u_6} [_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [NormedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace ð•‚ F'] {F : E' â†’ F'} {x : E'} (hF : ContDiff ð•‚ n F) (hn : 1 â‰¤ n) : HasStrictFderivAt F (fderiv ð•‚ F x) x
{R : Type u_1} {Râ‚‚ : Type u_2} {m : Type u_4} {mâ‚‚ : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [AddCommMonoid mâ‚‚] [module Râ‚‚ mâ‚‚] (F : m â†’â‚›â‚—[Ïƒâ‚â‚‚] mâ‚‚) (S : set mâ‚‚) : Submodule.Span R (â‡‘F â»Â¹' S) â‰¤ Submodule.comap F (Submodule.Span Râ‚‚ S)
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) (hF'' : DifferentiableOn â„ (deriv F) (Interior D)) (hF''_nonneg : âˆ€ (x : â„), x âˆˆ Interior D â†’ 0 â‰¤ deriv^[2] F x) : Convex_on â„ D F
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {R : â„} (h0 : 0 â‰¤ R) {F : â„‚ â†’ E} {C : â„‚} {S : set â„‚} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball C R  S â†’ Differentiable_at â„‚ F z) : âˆ® (z : â„‚) in C(C, R), F z = 0
{Î± : Type u} [Ring Î±] : _Ring_hom Id
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F g : E â†’ Î²} (hF : strict_Convex_on ð•œ S F) (hg : strict_Convex_on ð•œ S g) : strict_Convex_on ð•œ S (F âŠ” g)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) : 1 âˆˆ S
{Gâ‚€ : Type u_2} [Group_with_Zero Gâ‚€] (A : Gâ‚€) : A * A * Aâ»Â¹ = A
{Î¹ : Type W} {Î¹' : Type u_1} [Fintype Î¹'] [Fintype Î¹] (K : Type u) [Field K] [number_Field K] {B : Basis Î¹ â„š K} {B' : Basis Î¹' â„š K} (h : âˆ€ (i : Î¹) (j : Î¹'), IsIntegral â„¤ (B.to_Matrix â‡‘B' i j)) (h' : âˆ€ (i : Î¹') (j : Î¹), IsIntegral â„¤ (B'.to_Matrix â‡‘B i j)) : Algebra.discr â„š â‡‘B = Algebra.discr â„š â‡‘B'
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P q : FormalMultilinearSeries ð•œ E F) : LinearOrder.min P.radius q.radius â‰¤ (P + q).radius
{Î± : Type u_1} (r : Setoid Î±) : Setoid.Ker Quotient.Mk = r
(C : clifford_Algebra clifford_Algebra_Complex.q) : â‡‘clifford_Algebra_Complex.to_Complex (â‡‘clifford_Algebra.involute C) = â‡‘(Star_Ring_end â„‚) (â‡‘clifford_Algebra_Complex.to_Complex C)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) : P.remove_Zero.Right_Inv i = P.Right_Inv i
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : â„•} {i j : Fin (n + 1)} (h : i â‰¤ j) : x.Ïƒ (â‡‘Fin.cast_Succ i) â‰« x.Ïƒ j = x.Ïƒ j.Succ â‰« x.Ïƒ i
{Î± : Type u} [OrderedSemiring Î±] {A B C D : Î±} [has_exists_Add_of_LE Î±] (hab : A â‰¤ B) (hcd : C â‰¤ D) : A * D + B * C â‰¤ A * C + B * D
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) (h_anti : StrictAntiOn (deriv F) (Interior D)) : strict_ConcaveOn â„ D F
{n : Type u_5} {R : Type u_8} [TopologicalSpace R] [Fintype n] [DecidableEq n] [CommRing R] [topological_Ring R] (A : Matrix n n R) (h : Continuous_at Ring.Inverse A.det) : Continuous_at has_Inv.Inv A
{m : Type u_1} [has_Add m] (S : Add_Subsemigroup m) {x y : m} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
{Î± : Type u_1} {Î² : Type u_2} [has_Mul Î±] [Preorder Î±] [Preorder Î²] {F g : Î² â†’ Î±} [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] (hF : Monotone F) (hg : Monotone g) : Monotone (Î» (x : Î²), F x * g x)
{Î± : Type v} [canonically_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] [ContravariantClass Î± Î± has_Add.Add has_LE.LE] {F : â„• â†’ Î±} (h : Monotone F) (n : â„•) : (Finset.Range n).Sum (Î» (i : â„•), F (i + 1) - F i) = F n - F 0
{R : Type u_1} [CommRing R] [IsDomain R] {A B C : R} (h2 : 2 â‰  0) (ha : A â‰  0) (h : âˆ€ (S : R), discrim A B C â‰  S * S) (x : R) : A * x * x + B * x + C â‰  0
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : set P} (ho : EuclideanGeometry.OrthocentricSystem S) {P : Fin 3 â†’ P} (hps : set.Range P âŠ† S) (hpi : Function.Injective P) : AffineIndependent â„ P
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (F : Î² â†’ Î± â†’ Î²) (B : Î²) (v : Vector Î± n) : (Vector.scanl F B v).to_List = List.scanl F B v.to_List
(Î± : Type u_1) [MetricSpace Î±] [CompleteSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] [Nonempty Î±] : âˆƒ (F : (â„• â†’ â„•) â†’ Î±), Continuous F âˆ§ Function.Surjective F
{Gâ‚€ : Type u_2} [Group_with_Zero Gâ‚€] {P : Î  (g : Gâ‚€), g â‰  0 â†’ Prop} : (âˆƒ (g : Gâ‚€) (hg : g â‰  0), P g hg) â†” âˆƒ (g : Gâ‚€Ë£), P â†‘g _
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x : v} (hx : x â‰  0) (Î¸ : Real.Angle) : x = â‡‘(o.rotation Î¸) x â†” Î¸ = 0
(k : Type u_1) {Pâ‚ : Type u_2} {vâ‚ : Type u_6} [Ring k] [AddCommGroup vâ‚] [module k vâ‚] [AddTorsor vâ‚ Pâ‚] {x y : Pâ‚} (h : Function.Injective bit0) : â‡‘(affine_Equiv.point_reflection k x) y = y â†” y = x
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e e' : LocalHomeomorph Î± Î²} (hE : e â‰ˆ e') (S : set Î±) : e.restr S â‰ˆ e'.restr S
{Î± : sort u} {Î² : sort v} {Î³ : sort W} {g : Î² â†’ Î³} (hg : Function.Bijective g) : Function.Bijective (Function.Comp g)
{Î± : Type u_1} [MeasurableSpace Î±] {Î¹ : Type u_2} [Encodable Î¹] {F : Î¹ â†’ Î± â†’ Ennreal} (h : âˆ€ (i : Î¹), Measurable (F i)) : Measurable (Î» (x : Î±), âˆ‘' (i : Î¹), F i x)
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (u : RË£) (hu : â†‘u < 0) (v : module.Ray R m) : u â€¢ v = -v
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} {q : â„š} (v_Eq_q : v = â†‘q) : {h := â†‘((GeneralizedContinuedFraction.of q).h), S := Seq.Map (GeneralizedContinuedFraction.Pair.Map Coe) (GeneralizedContinuedFraction.of q).S} = GeneralizedContinuedFraction.of v
{m : Type u_1} {Î± : Type u_6} [Monoid m] [MulAction m Î±] [has_Mul Î±] (r S : m) (x y : Î±) [IsScalarTower m Î± Î±] [SmulCommClass m Î± Î±] : r â€¢ x * S â€¢ y = (r * S) â€¢ (x * y)
{R : Type u} [Semiring R] : AddSubmonoid.Closure {P : Polynomial R | âˆƒ (n : â„•) (A : R), P = â‡‘(Polynomial.monomial n) A} = âŠ¤
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (r : R) (n : â„•) : v.Int_Valuation_def r â‰¤ â†‘(â‡‘Multiplicative.of_Add (-â†‘n)) â†” v.as_Ideal ^ n âˆ£ Ideal.Span {r}
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (F : Î² â†’ Î± â†’ Î²) (B : Î²) {v : Vector Î± n} : (Vector.scanl F B v).val = List.scanl F B v.val
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {J' : Type uâ‚‚} [CategoryTheory.Category J'] (e : J â‰Œ J') [CategoryTheory.Limits.HasLimits_of_shape J C] : CategoryTheory.Limits.HasLimits_of_shape J' C
{B : Type u} [CategoryTheory.Bicategory B] {A B : B} {F g h i : A âŸ¶ B} [CategoryTheory.Bicategory.Lift_hom F] [CategoryTheory.Bicategory.Lift_hom g] [CategoryTheory.Bicategory.Lift_hom h] (Î· : F âŸ¶ g) (Î¸ : g âŸ¶ h) (Î¹ : h âŸ¶ i) [CategoryTheory.Bicategory.Lift_homâ‚‚ Î·] [CategoryTheory.Bicategory.Lift_homâ‚‚ Î¸] : Î· â‰« Î¸ â‰« Î¹ = (Î· â‰« Î¸) â‰« Î¹
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e : LocalHomeomorph Î± Î²} {S : set Î±} {t : set Î²} : e._image S t â†’ e.to_local_Equiv.Source âˆ© â‡‘e â»Â¹' t = e.to_local_Equiv.Source âˆ© S
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {x : E} {S : set E} (h : x âˆ‰ Closure S) : HasFderivWithinAt F F' S x
{m : Type u_1} [has_Mul m] {r : m â†’ m â†’ Prop} {C : Con m} (h : âˆ€ (x y : m), r x y â†’ Setoid.r x y) : Con_gen r â‰¤ C
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type W} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (hu : CategoryTheory.CoverLifting J K G) (â„± : CategoryTheory.sheaf J A) {x : A} {U : D} {S : CategoryTheory.Sieve U} (hS : S âˆˆ â‡‘K U) {x : CategoryTheory.Presieve.FamilyOfElements ((CategoryTheory.ran G.Op).obj â„±.val â‹™ CategoryTheory.coyoneda.obj (Opposite.Op x)) S.Arrows} (hx : x.compatible) (y : ((CategoryTheory.ran G.Op).obj â„±.val â‹™ CategoryTheory.coyoneda.obj (Opposite.Op x)).obj (Opposite.Op U)) (hy : x._amalgamation y) : y = CategoryTheory.ran__sheaf_of_CoverLifting.glued_section hu â„± hS hx
(B : â„¤) : B â‰¤ B ^ 2
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A : Î±} {S : set Î±} (ha : IsLub S A) (hs : S.Nonempty) (sc : IsClosed S) : A âˆˆ S
{z : UpperHalfPlane} (hz : z âˆˆ modular_Group.Fdo) (n : â„¤) : 1 < â‡‘Complex.norm_sq â†‘(modular_Group.t ^ n â€¢ z)
{Î± : Type u_1} [NormedRing Î±] [CompleteSpace Î±] {F g : â„• â†’ Î±} (hF : Summable (Î» (x : â„•), âˆ¥F xâˆ¥)) (hg : Summable (Î» (x : â„•), âˆ¥g xâˆ¥)) : (âˆ‘' (n : â„•), F n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (Finset.Nat.antidiagonal n).Sum (Î» (kl : â„• Ã— â„•), F kl.fst * g kl.Snd)
{m : Type u_1} {R : Type u_2} [Monoid m] [non_unital_non_assoc_Ring R] [Distrib_MulAction m R] (k : m) (h : âˆ€ (x : R), k â€¢ x = 0 â†’ x = 0) {A B : R} (h' : k â€¢ A = k â€¢ B) : A = B
{g : Equiv.perm (Fin 5)} (h : 3 âˆˆ g.Cycle_Type) : (g * g)._three_Cycle
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.coproducts_Disjoint C] : CategoryTheory.Limits.InitialMonoClass C
{S : Type u_2} [CommRing S] (A : Type u_6) [CommRing A] [IsDomain A] [Algebra A S] {m : Submonoid A} [IsLocalization m S] (hM : m â‰¤ non_Zero_divisors A) : IsDomain S
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {Bâ‚‚ : Basis (Fin 2) â„ v} (hbâ‚‚ : Orthonormal â„ â‡‘Bâ‚‚) (ho : B.Orientation = -Bâ‚‚.Orientation) : âˆƒ (Î¸ : Real.Angle), Bâ‚‚ = B.Map (hb.Conj_lie.Trans (hb.rotation Î¸)).to_Linear_Equiv
(n : â„•) {R : Type u_1} [Linear_ordered_CommRing R] {x : R} (hx : 1 < x) : 0 < Polynomial.Eval x (Polynomial.cyclotomic n R)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F g : â„ â†’ E} {x : â„} (F_Diff : âˆ€ (y : â„), y â‰  x â†’ HasDerivAt F (g y) y) (hF : Continuous_at F x) (hg : Continuous_at g x) (y : â„) : HasDerivAt F (g y) y
{Î± : Type u_1} [LinearOrder Î±] {A B : Finset Î±} (t : Î±) (hâ‚ : A.to_colex < B.to_colex) (hâ‚‚ : âˆ€ (x : Î±), x âˆˆ B â†’ x < t) (x : Î±) (h : x âˆˆ A) : x < t
{R : Type u} [Ring R] {S : Type v} [Ring S] (F : R â†’+* S) (P : Polynomial S) : P âˆˆ Polynomial.lifts F â†” P âˆˆ Polynomial.lifts_Ring F
{Î± : Type u_1} [canonically_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B C : Î±} [ContravariantClass Î± Î± has_Add.Add has_LE.LE] (h : A + C < B) : A < B - C
{Î² : Type u} {Î± : Type v} {Î³ : Type W} {S : Finset Î±} [CommMonoid Î²] [DecidableEq Î³] (F : Î³ â†’ Î²) (g : Î± â†’ Î³) : S.Prod (Î» (A : Î±), F (g A)) = (Finset.image g S).Prod (Î» (B : Î³), F B ^ (Finset.Filter (Î» (A : Î±), g A = B) S).Card)
{K : Type u} [Field K] {S : set K} {t : Subfield K} : Subfield.Closure S â‰¤ t â†” S âŠ† â†‘t
{Î± : Type u} {Î² : Type v} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hF : Filter.Tendsto F l Filter.at_IsBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), F x * g x) l Filter.at_IsBot
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : Affine.Simplex â„ P 1) : S.circumcenter = Finset.centroid â„ Finset.Univ S.points
{Î² : Type u_2} {F g : Î² â†’ â„} (hg : âˆ€ (B : Î²), 0 â‰¤ g B) (hgf : âˆ€ (B : Î²), g B â‰¤ F B) (hF : Summable F) : Summable g
{Î± : Type u} [MetricSpace Î±] [ProperSpace Î±] {S : set Î±} (hs : IsClosed S) {R : Î± â†’ â„} (hR : âˆ€ (x : Î±), x âˆˆ S â†’ 0 < R x) : âˆƒ (Î¹ : Type u) (C : Î¹ â†’ Î±) (r r' : Î¹ â†’ â„), (âˆ€ (i : Î¹), C i âˆˆ S âˆ§ 0 < r i âˆ§ r i < r' i âˆ§ r' i < R (C i)) âˆ§ locally_Finite (Î» (i : Î¹), Metric.Ball (C i) (r' i)) âˆ§ S âŠ† â‹ƒ (i : Î¹), Metric.Ball (C i) (r i)
{m : Type u_1} [Monoid m] {S t : set m} (h : S âŠ† t) : Monoid.Closure S âŠ† Monoid.Closure t
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (hab : A < B) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : â‡‘(affine_Map.line_Map (F A) (F B)) r < F (â‡‘(affine_Map.line_Map A B) r) â†” slope F (â‡‘(affine_Map.line_Map A B) r) B < slope F A (â‡‘(affine_Map.line_Map A B) r)
{ð•œ : Type u_1} {E : Type u_2} [NormedField ð•œ] [HasNorm E] {A : ð•œ} {F : ð•œ â†’ E} (h : Filter._bounded_under has_LE.LE (nhds_within A {A}á¶œ) (HasNorm.norm âˆ˜ F)) : F =o[nhds_within A {A}á¶œ] Î» (x : ð•œ), (x - A)â»Â¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasCokernels C] : CategoryTheory.Limits.HasCoequalizers C
{m : Type u_3} {N : Type u_4} [AddZeroClass m] [AddZeroClass N] (F : m â†’+ N) (A B : m) : â‡‘F (A + B) = â‡‘F A + â‡‘F B
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (F : J â†’ C) [CategoryTheory.Limits.HasBiproduct F] {B : CategoryTheory.Limits.Bicone F} (hb : B._bilimit) : (hb._Limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.biproduct._Limit F)).Inv = CategoryTheory.Limits.biproduct.Desc B.Î¹
{R : Type u_2} [CommRing R] [IsDomain R] [DecidableEq R] [Fintype R] {P : Polynomial R} (hp : 0 < P.degree) : Fintype.Card R â‰¤ P.Nat_degree * (Finset.image (Î» (x : R), Polynomial.Eval x P) Finset.Univ).Card
{K : Type u_1} [Linear_ordered_Field K] {A B C : K} (ha : A â‰  0) (h : âˆ€ (x : K), 0 < A * x * x + B * x + C) : discrim A B C < 0
{Î± : Type u} {Î¹ : Type u_1} {S : set Î¹} (hs : S.Finite) {t : Î  (i : Î¹), i âˆˆ S â†’ set Î±} (ht : âˆ€ (i : Î¹) (h : i âˆˆ S), (t i h).Finite) : (â‹ƒ (i : Î¹) (h : i âˆˆ S), t i h).Finite
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] {F : Type W} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace ð•œ] [Finite_dimensional ð•œ E] [Finite_dimensional ð•œ F] (Cond : Finite_dimensional.finrank ð•œ E = Finite_dimensional.finrank ð•œ F) : Nonempty (E â‰ƒL[ð•œ] F)
{Î± : Type u} {Î² : Type v} [MulOneClass Î±] [MulOneClass Î²] {F : Î± â†’ Î²} (hF : _Monoid_hom F) (x y : Î±) : F (x * y) = F x * F y
{P A B : â„•} (hpb : P âˆˆ B.Factors) (ha : A â‰  0) : P âˆˆ (A * B).Factors
{Î± : Type u_1} [has_LE Î±] {A : Î±áµ’áµˆ} : IsMax A â†’ IsMin (â‡‘order_dual.of_dual A)
{J : Type u} [CategoryTheory.Category J] [CategoryTheory.IsCofiltered J] (F : J â¥¤ Type v) [Î  (j : J), Fintype (F.obj j)] [âˆ€ (j : J), Nonempty (F.obj j)] : F.sections.Nonempty
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î²'] [DecidableEq Î³] [DecidableEq Î´] {F : Î± â†’ Î² â†’ Î³} {S : Finset Î±} {t : Finset Î²} {g : Î³ â†’ Î´} {F' : Î²' â†’ Î± â†’ Î´} {g' : Î² â†’ Î²'} (h_antidistrib : âˆ€ (A : Î±) (B : Î²), g (F A B) = F' (g' B) A) : Finset.image g (Finset.imageâ‚‚ F S t) = Finset.imageâ‚‚ F' (Finset.image g' t) S
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) [Nontrivial Î²] : â‡‘F 1 â‰  0
{R : Type u_1} {G : Type u_2} [AddCommGroup G] [CommRing R] [Nontrivial R] : Algebra.Finite_Type R (AddMonoid_Algebra R G) â†” AddGroup.fg G
{E : Type u_2} {ð•œ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] {S : set E} (hs : Convex ð•œ S) {x y : E} (hx : x âˆˆ S) (hy : x + y âˆˆ Interior S) {t : ð•œ} (ht : t âˆˆ set.ioc 0 1) : x + t â€¢ y âˆˆ Interior S
(x : â„‚) : HasDerivAt Complex.sinh (Complex.cosh x) x
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} (h : â†‘S.Nonempty) : AffineSubspace.direction_of_Nonempty h = S.direction
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [DecidableEq Î¹] [Î  (i : Î¹), has_Zero (Î± i)] {S : Finset Î¹} {F : Î â‚€ (i : Î¹), Î± i} [Î  (i : Î¹), DecidableEq (Î± i)] {t : Î â‚€ (i : Î¹), Finset (Î± i)} (ht : t.Support âŠ† S) : F âˆˆ S.Dfinsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘F i âˆˆ â‡‘t i
(P : â„•) [hp : Fact (Nat.Prime P)] (q r : â„š) : padic_norm P (q * r) = padic_norm P q * padic_norm P r
{Î± : Type u_1} [Fintype Î±] : Nonempty (Field Î±) â†” Prime_Pow (Fintype.Card Î±)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace E] {v : E} (hv : v âˆˆ K) : â‡‘(reflection Ká—®) v = -v
{Î³ : Type W} [Preorder Î³] [OrderTop Î³] (S : set Î³) : BddAbove S
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} : Emetric.Hausdorff_edist S t = Emetric.Hausdorff_edist t S
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (v W : E) (h : W âˆˆ K) : HasInner.inner (v - â†‘(â‡‘(Orthogonal_projection K) v)) W = 0
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [TopologicalSpace Î±] [TopologicalSpace Î²] {i : Î± â†’ Î²} [TopologicalSpace Î´] {F : Î³ â†’ Î±} {g : Î³ â†’ Î´} {h : Î´ â†’ Î²} {D : Î´} {A : Î±} (di : Dense_Inducing i) (h : Filter.Tendsto h (nhds D) (nhds (i A))) (comm : h âˆ˜ g = i âˆ˜ F) : Filter.Tendsto F (Filter.comap g (nhds D)) (nhds A)
{Î± : Type u} [HasSubset Î±] [HasSsubset Î±] [IsNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {A B : Î±} [IsAntisymm Î± HasSubset.Subset] (hâ‚ : A âŠ† B) (hâ‚‚ : A â‰  B) : A âŠ‚ B
{Î¹ : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : Î¹ â†’ set x} {S : set x} {C : set (ShrinkingLemma.PartialRefinement u S)} (hc : IsChain has_LE.LE C) (Ne : C.Nonempty) (hfin : âˆ€ (x : x), x âˆˆ S â†’ {i : Î¹ | x âˆˆ u i}.Finite) (hU : S âŠ† â‹ƒ (i : Î¹), u i) {v : ShrinkingLemma.PartialRefinement u S} (hv : v âˆˆ C) : v â‰¤ ShrinkingLemma.PartialRefinement.chain_Sup C hc Ne hfin hU
{n : Type u_3} [Fintype n] {A : Type u_1} [DecidableEq n] [CommRing A] [IsDomain A] {m : Matrix n n A} : m.det â‰  0 â†’ m.nondegenerate
{A : â„} {l : Filter â„} {F g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhds_within A (set.Iio A), Differentiable_at â„ F x) (hg' : âˆ€á¶  (x : â„) in nhds_within A (set.Iio A), deriv g x â‰  0) (hfa : Filter.Tendsto F (nhds_within A (set.Iio A)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.Iio A)) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv F x / deriv g x) (nhds_within A (set.Iio A)) l) : Filter.Tendsto (Î» (x : â„), F x / g x) (nhds_within A (set.Iio A)) l
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] {x y : x} {Î³ : Y â†’ Path x y} {F : Y â†’ â„} (hÎ³ : Continuous â†¿Î³) (hF : Continuous F) : Continuous (Î» (t : Y), (Î³ t).extend (F t))
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : 1 â‰¤ A) (hb : 1 â‰¤ B) : 1 â‰¤ A * B
{ð•œ : Type u_1} [_R_or_C ð•œ] [decð•œ : DecidableEq ð•œ] {E : Type u_2} [InnerProductSpace ð•œ E] {t : E â†’â‚—[ð•œ] E} (hT : InnerProductSpace.IsSelfAdjoint t) [Finite_dimensional ð•œ E] {n : â„•} (hn : Finite_dimensional.finrank ð•œ E = n) (v : E) (i : Fin n) : â‡‘(hT.diagonalization_Basis hn) (â‡‘t v) i = â†‘(hT.Eigenvalues hn i) * â‡‘(hT.diagonalization_Basis hn) v i
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {S t : set Î±} (ht : IsAntichain r t) (h : Maximals r S âŠ† t) (hs : âˆ€ â¦ƒA : Î±â¦„, A âˆˆ t â†’ (âˆƒ (B : Î±) (h : B âˆˆ Maximals r S), r B A)) : Maximals r S = t
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} (hs : IsClosed S) (ht : IsClosed t) (Fin : Emetric.Hausdorff_edist S t â‰  âŠ¤) : metric.Hausdorff_dist S t = 0 â†” S = t
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) (z : Î± (Fin.Last n)) : Fin.init (Function.update q (Fin.Last n) z) = Fin.init q
{Î± : Type u} [t : TopologicalSpace Î±] {B : set (set Î±)} (hb : TopologicalSpace._topological_Basis B) {S : set Î±} : Dense S â†” âˆ€ (o : set Î±), o âˆˆ B â†’ o.Nonempty â†’ (o âˆ© S).Nonempty
{G : Type u_1} [Group G] {h K : Subgroup G} (h : âˆ€ (x : G), x âˆˆ h â†” x âˆˆ K) : h = K
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] {E1 E2 : intermediate_Field K L} (h12 : E1 â‰¤ E2) : E2.fixing_Subgroup â‰¤ E1.fixing_Subgroup
{Î± : Type u} [Preorder Î±] {A B : Î±} (h : A < B) : A â‰  B
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A B : Î±} (ha : A â‰¤ 1) (hb : B < 1) : A * B < 1
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : P -áµ¥ â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P) âˆˆ (S.direction)á—®
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = â†‘Real.Pi
(R : Type u_1) (S : Type u_2) [Ring R] [Ring S] [IsDomain (R Ã— S)] [Nontrivial R] [Nontrivial S] : False
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} {C : CategoryTheory.Limits.Cofork F g} (i : CategoryTheory.Limits.IsColimit C) : CategoryTheory.Epi C.Ï€
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {m : Type u_6} [CommSemiring R] [AddCommMonoid m] [module R m] (B : Basis Î¹ R m) (B' : Basis Î¹' R m) [Fintype Î¹'] [Fintype Î¹] [DecidableEq Î¹] : â‡‘(Linear_Map.to_Matrix B B') LinearMap.Id = B'.to_Matrix â‡‘B
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] [DenselyOrdered Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds_within A (set.ici A) â†” âˆƒ (u : Î±) (h : u âˆˆ set.ioi A), set.icc A u âŠ† S
{G : Type u_1} {m : Type u_3} [Group G] [Monoid m] [MulAction G m] [SmulCommClass G m m] [IsScalarTower G m m] (g : G) (m : mË£) : (g â€¢ m)â»Â¹ = gâ»Â¹ â€¢ mâ»Â¹
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : intermediate_Field K L) : E.Map (AlgHom.Id K L) = E
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {F : m â†’+ P} : (Add_Con.Ker_Lift F).mrange = F.mrange
{Î¹ : Type u} (F : Î¹ â†’ Cardinal) : BddAbove (set.Range F)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : hb.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) : o.oangle x x = 0
{K : Type u} {v : Type v} {v' : Type v'} [DivisionRing K] [AddCommGroup v] [module K v] [AddCommGroup v'] [module K v'] : Nonempty (v â‰ƒâ‚—[K] v') â†” (module.rank K v).Lift = (module.rank K v').Lift
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] [NoMinOrder Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds A â†” âˆƒ (l u : Î±), A âˆˆ set.Ioo l u âˆ§ set.Ioo l u âŠ† S
{Î¹ : Type u_1} {máµ¢ : Î¹ â†’ Type u_7} [Î  (i : Î¹), AddCommGroup (máµ¢ i)] [Fintype Î¹] {R : Type u_2} [ordered_Ring R] [Î  (i : Î¹), module R (máµ¢ i)] {q : Î  (i : Î¹), QuadraticForm R (máµ¢ i)} (h : (QuadraticForm.Pi q).anisotropic) (i : Î¹) : (q i).anisotropic
{S : Type u} [has_Add S] {A x y : S} (h : Add_SemiconjBy A x y) : A + x = y + A
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasCokernel F] [CategoryTheory.Epi F] : CategoryTheory.Limits.CokernelÏ€ F = 0
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x z - hb.oangle x y = hb.oangle y z
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {G : Î¹ â†’ Type u_5} [Î  (i : Î¹), InnerProductSpace ð•œ (G i)] {v : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ v) [CompleteSpace E] (F : Î  (i : Î¹), G i) : Summable (Î» (i : Î¹), â‡‘(v i) (F i)) â†” Summable (Î» (i : Î¹), âˆ¥F iâˆ¥ ^ 2)
{A : â„•} : Real.sqrt â†‘A â‰¤ â†‘(Nat.sqrt A) + 1
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h : S1 < S2) (hn : â†‘S1.Nonempty) : S1.direction < S2.direction
{n : â„•} {E : Type u_1} [NormedGroup E] {F : (Fin n â†’ â„‚) â†’ E} {C : Fin n â†’ â„‚} {R : Fin n â†’ â„} [NormedSpace â„‚ E] (hF : TorusIntegrable F C R) : MeasureTheory.IntegrableOn (Î» (Î¸ : Fin n â†’ â„), Finset.Univ.Prod (Î» (i : Fin n), â†‘(R i) * Complex.Exp (â†‘(Î¸ i) * Complex.i) * Complex.i) â€¢ F (torus_Map C R Î¸)) (set.icc 0 (Î» (_x : Fin n), 2 * Real.Pi)) MeasureTheory.MeasureSpace.Volume
{K : Type u_4} {v : Type u} [Field K] [AddCommGroup v] [module K v] (P : Submodule K v) (hp : P < âŠ¤) : âˆƒ (F : v â†’â‚—[K] K) (h : F â‰  0), P â‰¤ F.Ker
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {n : WithTop â„•} {x : G} (g : G â†’L[ð•œ] E) (hF : ContDiff_within_at ð•œ n F S (â‡‘g x)) : ContDiff_within_at ð•œ n (F âˆ˜ â‡‘g) (â‡‘g â»Â¹' S) x
{R : Type u_1} [Semiring R] (P : Polynomial R â†’ Prop) (N : â„•) (P_0 : P 0) (P_C_Mul_Pow : âˆ€ (n : â„•) (r : R), r â‰  0 â†’ n â‰¤ N â†’ P (â‡‘Polynomial.C r * Polynomial.x ^ n)) (P_C_Add : âˆ€ (F g : Polynomial R), F.Nat_degree < g.Nat_degree â†’ g.Nat_degree â‰¤ N â†’ P F â†’ P g â†’ P (F + g)) (F : Polynomial R) : F.Nat_degree â‰¤ N â†’ P F
{Î± : Type u_1} {r S : Setoid Î±} : (r âŠ“ S).Rel = r.Rel âŠ“ S.Rel
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [LinearOrder Î²] [SuccOrder Î²] [IsSuccArchimedean Î²] [Nonempty Î²] {S : Î² â†’ set Î±} (h : âˆ€ (n : Î²), IsConnected (S n)) (K : âˆ€ (n : Î²), (S n âˆ© S (Order.Succ n)).Nonempty) : IsConnected (â‹ƒ (n : Î²), S n)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x y : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) (h : â†‘âˆ¥yâˆ¥â‚Š < r) : HasFpowerSeriesOnBall F (P.change_origin y) (x + y) (r - â†‘âˆ¥yâˆ¥â‚Š)
{Î± : Type u} {u : Ultrafilter (Ultrafilter Î±)} {x : Ultrafilter Î±} : â†‘u â‰¤ nhds x â†” x = mjoin u
{Î“ : Type u_4} [Group Î“] {t : Type u_5} [TopologicalSpace t] [MulAction Î“ t] [has_Continuous_Const_Smul Î“ t] : IsOpen_Map Quotient.Mk
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) (i : Fin n) (y : Î± (â‡‘Fin.cast_Succ i)) : Fin.init (Function.update q (â‡‘Fin.cast_Succ i) y) = Function.update (Fin.init q) i y
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} (h : SameRay R x y) (hx : x â‰  0) (hy : y â‰  0) : âˆƒ (râ‚ râ‚‚ : R), 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y
{Î± : Type u_1} [TopologicalSpace Î±] [t2_Space Î±] [MeasurableSpace Î±] [BorelSpace Î±] {S t : set Î±} (hs : MeasureTheory.analytic_set S) (ht : MeasureTheory.analytic_set t) (h : Disjoint S t) : MeasureTheory.measurably_IsSeparable S t
{P : â„•} {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime P)] [CommRing R] [CommRing S] (F : R â†’+* S) (x : witt_Vector P R) : â‡‘(witt_Vector.Map F) (â‡‘witt_Vector.verschiebung x) = â‡‘witt_Vector.verschiebung (â‡‘(witt_Vector.Map F) x)
{x y z : â„¤} (k : â„¤) (hk : k â‰  0) : PythagoreanTriple (k * x) (k * y) (k * z) â†” PythagoreanTriple x y z
{Î± : Type u_2} {Î¹ : Type u_5} [CommMonoid Î±] (t : Finset Î¹) (F : Î¹ â†’ set Î±) (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), i âˆˆ t â†’ g i âˆˆ F i) : t.Prod (Î» (i : Î¹), g i) âˆˆ t.Prod (Î» (i : Î¹), F i)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [LinearOrder Î²] {F g : Î± â†’ Î²} (hF : Monotone F) (hg : Monotone g) : Monotone (Î» (x : Î±), LinearOrder.min (F x) (g x))
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Kâ‚ Kâ‚‚ : Submodule ð•œ E} [Finite_dimensional ð•œ â†¥Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) {n : â„•} (h_dim : Finite_dimensional.finrank ð•œ â†¥Kâ‚ + n = Finite_dimensional.finrank ð•œ â†¥Kâ‚‚) : Finite_dimensional.finrank ð•œ â†¥(Kâ‚á—® âŠ“ Kâ‚‚) = n
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [module R P] (huniv : âˆ€ {m : Type (max v u)} {N : Type (max u v)} [_inst_4 : AddCommGroup m] [_inst_5 : AddCommGroup N] [_inst_6 : module R m] [_inst_7 : module R N] (F : m â†’â‚—[R] N) (g : P â†’â‚—[R] N), Function.Surjective â‡‘F â†’ (âˆƒ (h : P â†’â‚—[R] m), F.Comp h = g)) : module.projective R P
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [semi_NormedGroup Î²] (B : Î²) : âˆ¥bounded_Continuous_Function.Const Î± Bâˆ¥ â‰¤ âˆ¥Bâˆ¥
{n A : â„•} (h : A < n + 1) : â†‘A.val = A
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [Linear_ordered_Field ð•œ] [AddCommGroup E] [ordered_AddCommGroup Î²] [module ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} {t : Finset Î¹} {W : Î¹ â†’ ð•œ} {P : Î¹ â†’ E} (hF : ConcaveOn ð•œ S F) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ W i) (hâ‚ : t.Sum (Î» (i : Î¹), W i) = 1) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ P i âˆˆ S) : t.Sum (Î» (i : Î¹), W i â€¢ F (P i)) â‰¤ F (t.Sum (Î» (i : Î¹), W i â€¢ P i))
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} (hs : S.Nonempty) (ht : t.Nonempty) : Emetric.Hausdorff_edist S t â‰¤ Emetric.diam (S âˆª t)
(v : Type u_1) [semi_NormedGroup v] (h : âˆƒ (x : v), âˆ¥xâˆ¥ â‰  0) : âˆ¥NormedGroup_hom.Id vâˆ¥ = 1
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} {S t : set Î±} (h : x âˆˆ S) : Emetric.Inf_edist x t â‰¤ Emetric.Hausdorff_edist S t
{C : Type uâ‚} [CategoryTheory.Category C] {J : Type uâ‚‚} [CategoryTheory.Category J] (F : J â¥¤ Cáµ’áµ–) [CategoryTheory.Limits.HasColimit F.Left_Op] : CategoryTheory.Limits.HasLimit F
{B m : â„•} (hb : 2 â‰¤ B) : m < B ^ (B.digits m).length
 : Cardinal.Ord âˆ˜ Cardinal.aleph = Ordinal.enum_Ord {B : Ordinal | B.Card.Ord = B âˆ§ Ordinal.omega â‰¤ B}
{R : Type u} [Ring R] {P : Polynomial R} (r : R) : Polynomial.Eval r (P * (Polynomial.x - â‡‘Polynomial.C r)) = 0
{Î± : Type u} [SemilatticeSup Î±] [OrderBot Î±] {Î¹ : Type u} [Fintype Î¹] (F : Î¹ â†’ Î±) : (âˆ F) = (Fintype.elems Î¹).Sup F
{m : Type u_1} [has_Add m] (S : set m) {P : Î  (x : m), x âˆˆ Add_Subsemigroup.Closure S â†’ Prop} (Hs : âˆ€ (x : m) (h : x âˆˆ S), P x _) (HMul : âˆ€ (x : m) (hx : x âˆˆ Add_Subsemigroup.Closure S) (y : m) (hy : y âˆˆ Add_Subsemigroup.Closure S), P x hx â†’ P y hy â†’ P (x + y) _) {x : m} (hx : x âˆˆ Add_Subsemigroup.Closure S) : P x hx
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Finite_dimensional R m] [Nonempty Î¹] (x : Orientation R m Î¹) (h : Fintype.Card Î¹ = Finite_dimensional.finrank R m) : (x.Some_Basis h).Orientation = x
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [NormedSpace ð•œ E'] {n : WithTop â„•} {F : E â†’ E'} {S : set E} {x : E} : Cont_mdiff_within_at (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') n F S x â†’ ContDiff_within_at ð•œ n F S x
{Î± : Type u} {Î² : Type v} {F : Î± â‰ƒ. Î²} (h : âˆ€ (A : Î±), â†¥((â‡‘F A)._Some)) : Function.Injective â‡‘F
(x : â„) : Real.sinh x = (Real.Exp x - Real.Exp (-x)) / 2
{R : Type u_1} [CommSemiring R] (S : Subsemiring R) {Î¹ : Type u_2} {t : Finset Î¹} {F : Î¹ â†’ R} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Prod (Î» (i : Î¹), F i) âˆˆ S
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_Ring ð•œ] [AddCommGroup E] [AddCommGroup F] [module ð•œ E] [module ð•œ F] (F : E â†’áµƒ[ð•œ] F) {S : set F} (hs : Convex ð•œ S) : Convex ð•œ (â‡‘F â»Â¹' S)
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [CommMonoid N] {S : Finset Î±} {F : Î± â†’ m} {g : Î± â†’ m â†’ N} (hF : âˆ€ (A : Î±), F A â‰  0 â†’ A âˆˆ S) (hg : âˆ€ (A : Î±), g A 0 = 1) : (Finsupp.on_Finset S F hF).Prod g = S.Prod (Î» (A : Î±), g A (F A))
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.has_Finite_coproducts C] : CategoryTheory.Limits.has_Finite_biproducts C
{Î±' : sort W} [DecidableEq Î±'] {Î± : sort u_1} {Î² : sort u_2} (g : Î±' â†’ Î²) {F : Î± â†’ Î±'} {i : Î±'} (A : Î²) (h : âˆ€ (x : Î±), F x â‰  i) : Function.update g i A âˆ˜ F = g âˆ˜ F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {P : E Ã— F} : ContDiff_at ð•œ n Prod.fst P
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] (F : MultilinearMap R mâ‚ mâ‚‚) {Î± : Î¹ â†’ Type u_1} (g : Î  (i : Î¹), Î± i â†’ mâ‚ i) [Fintype Î¹] [Î  (i : Î¹), Fintype (Î± i)] : â‡‘F (Î» (i : Î¹), Finset.Univ.Sum (Î» (j : Î± i), g i j)) = Finset.Univ.Sum (Î» (r : Î  (i : Î¹), Î± i), â‡‘F (Î» (i : Î¹), g i (r i)))
{Î± : sort u_1} {Î² : sort u_2} {Sâ‚ : Setoid Î±} {Sâ‚‚ : Setoid Î²} {P : Quotient Sâ‚ â†’ Quotient Sâ‚‚ â†’ Prop} (h : âˆ€ (Aâ‚ : Î±) (Aâ‚‚ : Î²), P (Quotient.Mk' Aâ‚) (Quotient.Mk' Aâ‚‚)) (qâ‚ : Quotient Sâ‚) (qâ‚‚ : Quotient Sâ‚‚) : P qâ‚ qâ‚‚
{Î± : Type u_1} (F : Î± â†’ Nnreal) : Filter.Tendsto (Î» (S : Finset Î±), âˆ‘' (B : {x // x âˆ‰ S}), F â†‘B) Filter.at_top (nhds 0)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} {x : Î±} {S : set Î±} : Continuous_within_at F S x â†’ Continuous_within_at F (HasInsert.Insert x S) x
(A : â†¥Circle) : â‡‘Linear_Equiv.det (â‡‘rotation A).to_Linear_Equiv = 1
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommGroup E] [HasScalar ð•œ E] {S : Convex_cone ð•œ E} (hS : S.flat) : S.Pointed
(K : Type u_1) (L : Type u_2) {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [IsScalarTower K L A] (A_alg : Algebra.IsAlgebraic K A) : Algebra.IsAlgebraic L A
{Î± : Type u_1} [TopologicalSpace Î±] [PolishSpace Î±] {S : set Î±} (hs : IsClosed S) : PolishSpace â†¥S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P âŸ¶ q) : Function.Surjective â‡‘F â†’ CategoryTheory.Epi F
{n : â„•} (A : Zmod n) : â†‘â†‘A = A
{E : â„• â†’ Type u_1} {Î± : Type u_2} [PseudoMetricSpace Î±] {F : (Î  (n : â„•), E n) â†’ Î±} : (âˆ€ (x y : Î  (n : â„•), E n), HasDist.dist (F x) (F y) â‰¤ HasDist.dist x y) â†” âˆ€ (x y : Î  (n : â„•), E n) (n : â„•), y âˆˆ Pi_Nat.Cylinder x n â†’ HasDist.dist (F x) (F y) â‰¤ (1 / 2) ^ n
{Î¹ : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : Î¹ â†’ E} {g : Î¹ â†’ Nnreal} {A : Nnreal} (hg : has_Sum g A) (h : âˆ€ (i : Î¹), âˆ¥F iâˆ¥â‚Š â‰¤ g i) : âˆ¥âˆ‘' (i : Î¹), F iâˆ¥â‚Š â‰¤ A
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x y : E) (h : HasInner.inner x y = 0) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B C D : Î±} (hc : C â‰  0) (hD : D â‰  0) : A / C < B / D â†’ (A * D - B * C) / (C * D) < 0
{E : Type u_2} [AddCommGroup E] [module â„ E] (F : LinearPmap â„ E â„) (N : E â†’ â„) (N_hom : âˆ€ (C : â„), 0 < C â†’ âˆ€ (x : E), N (C â€¢ x) = C * N x) (N_Add : âˆ€ (x y : E), N (x + y) â‰¤ N x + N y) (hF : âˆ€ (x : â†¥(F.IsDomain)), â‡‘F x â‰¤ N â†‘x) : âˆƒ (g : E â†’â‚—[â„] â„), (âˆ€ (x : â†¥(F.IsDomain)), â‡‘g â†‘x = â‡‘F x) âˆ§ âˆ€ (x : E), â‡‘g x â‰¤ N x
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) : TendstoLocallyUniformlyOn (Î» (n : â„•) (y : E), P.partial_Sum n (y - x)) F Filter.at_top (Emetric.Ball x r)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} {Fâ‚— : Type u_7} [NormedGroup E] [NormedGroup F] [NormedGroup Fâ‚—] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] [NormedSpace ð•œ Fâ‚—] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (F : E â†’sl[Ïƒâ‚â‚‚] F) [CompleteSpace F] (e : E â†’L[ð•œ] Fâ‚—) (h_Dense : DenseRange â‡‘e) {N : Nnreal} (h_e : âˆ€ (x : E), âˆ¥xâˆ¥ â‰¤ â†‘N * âˆ¥â‡‘e xâˆ¥) [Ring_hom_isometric Ïƒâ‚â‚‚] : âˆ¥F.extend e h_Dense _âˆ¥ â‰¤ â†‘N * âˆ¥Fâˆ¥
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A : â„} {S : set â„} (hintg : âˆ€ (x : â„), x âˆˆ S â†’ IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A x) (hcont : Continuous F) : DifferentiableOn â„ (Î» (u : â„), âˆ« (x : â„) in A..u, F x) S
{R : Type u_1} {A : R} [Mul_Zero_class R] [Nontrivial R] (la : IsRegular A) : A â‰  0
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [_fraction_Ring R K] (v : IsDedekindDomain.height_One_Spectrum R) (r : R) : â‡‘(v.Valuation) (â‡‘(Algebra_Map R K) r) = â‡‘(v.Int_Valuation) r
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [semi_NormedGroup Î²] {F : bounded_Continuous_Function Î± Î²} {C : â„} (C0 : 0 â‰¤ C) : âˆ¥Fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘F xâˆ¥ â‰¤ C
{m : Type u_1} [CommMonoid m] {S t : set m} {x : m} : x âˆˆ Monoid.Closure (S âˆª t) â†” âˆƒ (y : m) (h : y âˆˆ Monoid.Closure S) (z : m) (h : z âˆˆ Monoid.Closure t), y * z = x
{Î± : Type u} [NormedField Î±] {u : â„• â†’ Î±} : _cau_Seq HasNorm.norm u â†” Cauchy_Seq u
{m : Type u_1} {R : Type u_3} [Fintype m] [DecidableEq m] [CommSemiring R] (A : Matrix m m R) : â‡‘((mv_Polynomial.Eval (Î» (P : m Ã— m), A P.fst P.Snd)).Map_Matrix) (Matrix.mv_Polynomial.x m m R) = A
(R : Type u) [Ring R] (hF : _Field R) (x : R) : x â‰  0 â†’ (âˆƒ! (y : R), x * y = 1)
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {t : CategoryTheory.Limits.Cone F} (h : CategoryTheory.Limits.IsLimit t) (S : CategoryTheory.Limits.Cone F) : âˆƒ! (l : S.x âŸ¶ t.x), âˆ€ (j : J), l â‰« t.Ï€.App j = S.Ï€.App j
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (S : set (Submodule ð•œ E)) : (â¨… (K : Submodule ð•œ E) (h : K âˆˆ S), Ká—®) = (HasSup.Sup S)á—®
{G : Type W} [TopologicalSpace G] [HasNeg G] [has_Add G] [has_Continuous_Add G] [has_Continuous_Neg G] (h : G) : Continuous (Î» (g : G), g + h + -g)
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] (e : Râ‚ â‰ƒ+* Râ‚‚) : RingHomInvPair â†‘e â†‘(e.Symm)
{Î± : Type u_1} {Î² : Type u_2} [MeasurableSpace Î±] [MeasurableSpace Î²] {F : Î² â†’ Î±} (hF : âˆ€ (x y : Î²), F x = F y) : Measurable F
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {Bâ‚‚ : Basis (Fin 2) â„ v} (hbâ‚‚ : Orthonormal â„ â‡‘Bâ‚‚) (ho : B.Orientation = Bâ‚‚.Orientation) : âˆƒ (Î¸ : Real.Angle), Bâ‚‚ = B.Map (hb.rotation Î¸).to_Linear_Equiv
{Gâ‚€ : Type u_2} [Group_with_Zero Gâ‚€] {P : Gâ‚€Ë£ â†’ Prop} : (âˆƒ (g : Gâ‚€Ë£), P g) â†” âˆƒ (g : Gâ‚€) (hg : g â‰  0), P (Units.Mk0 g hg)
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] : IsOpen_Map Prod.fst
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} {v : v} {x : k} {S : set Î¹} {P : Î¹ â†’ P} {B : P} : (âˆƒ (fs : Finset Î¹) (hfs : â†‘fs âŠ† S) (W : Î¹ â†’ k) (hw : fs.Sum (Î» (i : Î¹), W i) = x), v = â‡‘(fs.weighted_vsub_of_point P B) W) â†” âˆƒ (fs : Finset â†¥S) (W : â†¥S â†’ k) (hw : fs.Sum (Î» (i : â†¥S), W i) = x), v = â‡‘(fs.weighted_vsub_of_point (Î» (i : â†¥S), P â†‘i) B) W
{x : Type u_1} [TopologicalSpace x] [SequentialSpace x] {S : set x} : _Seq_IsClosed S â†’ IsClosed S
(K : Type u_1) (L : Type u_2) {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [IsScalarTower K L A] {x : A} (A_alg : IsAlgebraic K x) : IsAlgebraic L x
(k : Type u_1) [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) [CharZero k] {n : â„•} (h : S.Card = n + 1) : S.Sum (Î» (i : Î¹), Finset.centroid_weights k S i) = 1
{Î± : Type u_1} {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [has_Zero N] (F : Î± â†’ N) (g : Î± â†’ N â†’ m) {S t : Finset Î±} (h : S âŠ† t) (hg : âˆ€ (A : Î±), g A 0 = 0) : S.Sum (Î» (i : Î±), g i (F i)) = t.Sum (Î» (i : Î±), g i (â†‘S.indicator F i))
{Î± : Type u_3} [Linear_ordered_AddCommGroup Î±] : Filter.Tendsto HasAbs.Abs Filter.at_IsBot Filter.at_top
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {F : Filter Î±} {g : Filter Î²} {m : Î±' â†’ Î² â†’ Î³} {n : Î± â†’ Î±'} {m' : Î± â†’ Î² â†’ Î´} {n' : Î´ â†’ Î³} (h_Left_comm : âˆ€ (A : Î±) (B : Î²), m (n A) B = n' (m' A B)) : Filter.Mapâ‚‚ m (Filter.Map n F) g = Filter.Map n' (Filter.Mapâ‚‚ m' F g)
{R : Type u_1} [CommSemiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [Fintype n] [DecidableEq n] [Fintype m] [DecidableEq m] (m : Matrix l m R) (N : Matrix m n R) (x : n â†’ R) : â‡‘(â‡‘Matrix.to_lin' (m.Mul N)) x = â‡‘(â‡‘Matrix.to_lin' m) (â‡‘(â‡‘Matrix.to_lin' N) x)
{R : Type u_1} [CommRing R] {n : â„•} (hpos : 0 < n) : Polynomial.cyclotomic n R = (Polynomial.x ^ n - 1) /â‚˜ n.proper_divisors.Prod (Î» (i : â„•), Polynomial.cyclotomic i R)
{x : Type u_2} {Y : Type u_3} [EmetricSpace x] [EmetricSpace Y] [TopologicalSpace.SecondCountableTopology x] {r : Nnreal} {F : x â†’ Y} (hr : 0 < r) (hF : âˆ€ (x : x), âˆƒ (C : Nnreal) (S : set x) (h : S âˆˆ nhds x), HolderOnWith C r F S) : dimH (set.Range F) â‰¤ dimH set.Univ / â†‘r
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] {S : Finset Î±} {F : Î± â†’ Î²} {A : Î±} (hp : S.Prod (Î» (x : Î±), F x) = 1) (h1 : âˆ€ (x : Î±), x âˆˆ S â†’ x â‰  A â†’ F x = 1) (x : Î±) (h : x âˆˆ S) : F x = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] : CategoryTheory.Limits.HasEqualizers C
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} : Antitone_on F S â†’ Monotone_on (â‡‘order_dual.to_dual âˆ˜ F) S
{Î² : Type u} {Î± : Type v} {S : Finset Î±} [AddCommMonoid Î²] (F : Î± â†’ Î²) {P : Î± â†’ Prop} [Decidable_Pred P] (h : âˆ€ (x : Î±), x âˆˆ S â†’ P x) : (Finset.Subtype P S).Sum (Î» (x : Subtype P), F â†‘x) = S.Sum (Î» (x : Î±), F x)
{R : Type u_1} [cancel_Monoid R] (g : R) : IsRegular g
{Î± : Type u_3} {Î² : Type u_4} {F : Î± â†’ Î²} {k : Filter Î±} {l : Filter Î²} [k._countably_generated] : Filter.Tendsto F k l â†” âˆ€ (x : â„• â†’ Î±), Filter.Tendsto x Filter.at_top k â†’ Filter.Tendsto (F âˆ˜ x) Filter.at_top l
{F : Type} [CommSemiring F] {F : Polynomial F} (hF : Polynomial.has_IsSeparable_contraction 1 F) : hF.degree = F.Nat_degree
{Î± : Type u_1} {Î² : Type u_2} [AddZeroClass Î±] [AddCommGroup Î²] {F : Î± â†’ Î²} (hF : _AddMonoid_hom F) : _AddMonoid_hom (Î» (A : Î±), -F A)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {i : Î± â†’ Î²} (di : Dense_Inducing i) [TopologicalSpace.IsSeparable_Space Î±] : TopologicalSpace.IsSeparable_Space Î²
{Î± : Type u_1} (L : List Î±) {i : â„•} (hi : i < L.length) : List.Drop i (List.take (i + 1) L) = [L.nth_LE i hi]
{m : Type u_3} {N : Type u_4} [has_Zero m] [has_Zero N] {F g : ZeroHom m N} : F = g â†” âˆ€ (x : m), â‡‘F x = â‡‘g x
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : o.oangle y (â‡‘(o.rotation (o.oangle x y)) x) = 0
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [SuccOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Monotone F) : Pairwise (Disjoint on Î» (n : Î±), set.Ioo (F n) (F (Order.Succ n)))
 : Disjoint (residual â„) MeasureTheory.MeasureSpace.Volume.ae
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (Pâ‚ : Î¹ â†’ P) (Pâ‚‚ : P) (h : S.Sum (Î» (i : Î¹), W i) = 0) : S.Sum (Î» (i : Î¹), W i â€¢ (Pâ‚ i -áµ¥ Pâ‚‚)) = â‡‘(S.weighted_vsub Pâ‚) W
{A B : â„•} (ha : A â‰  0) (hb : B â‰  0) : (A * B).factorization = A.factorization + B.factorization
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : (F =o[l] Î» (x : Î±), -g' x) â†’ F =o[l] g'
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] {x Y : C} [CategoryTheory.Simple x] [CategoryTheory.Simple Y] (F : x âŸ¶ Y) : CategoryTheory.IsIso F â†” F â‰  0
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization m S] (S : Finset S) : âˆƒ (B : â†¥m), âˆ€ (A : S), A âˆˆ S â†’ IsLocalization._integer R (â†‘B â€¢ A)
{Î± : Type u_1} {Î¹ : Type u_3} [CompleteLattice Î±] {S : Finset Î¹} {F : Î¹ â†’ Î±} : CompleteLattice.Independent (F âˆ˜ Coe) â†’ S.Sup_indep F
 : Filter.Tendsto â‡‘Complex.norm_sq (Filter.cocompact â„‚) Filter.at_top
{Î± : Type u} {Î² : Type v} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {F : Filter Î²} {u : Î² â†’ Î±} {A : Î±} [F.Ne_IsBot] (h : Filter.Tendsto u F (nhds A)) : F.liminf u = A
{Î± : sort u} {Î² : Î± â†’ sort v} {Fâ‚ Fâ‚‚ : Î  (x : Î±), Î² x} (h : âˆ€ (x : Î±), Fâ‚ x = Fâ‚‚ x) : Fâ‚ = Fâ‚‚
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} (hF : HasFpowerSeriesAt F P x) (n : â„•) : (Î» (y : E), F (x + y) - P.partial_Sum n y) =O[nhds 0] Î» (y : E), âˆ¥yâˆ¥ ^ n
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R m) (F : m â‰ƒâ‚—[R] m) : (e.Map F).Orientation = -e.Orientation â†” â‡‘LinearMap.det â†‘F < 0
{Î± : Type u} [TopologicalSpace Î±] : t2_Space Î± â†” âˆ€ {x y : Î±}, (nhds x âŠ“ nhds y).Ne_IsBot â†’ x = y
{m : Type u_1} [Monoid m] (P : Submonoid m) : P.fg â†” âˆƒ (S : set m), Submonoid.Closure S = P âˆ§ S.Finite
{K : Type u_1} [Linear_ordered_Field K] {v : K} {n : â„•} [FloorRing K] (TerminatedAt_n : (GeneralizedContinuedFraction.of v).TerminatedAt n) : v = (GeneralizedContinuedFraction.of v).convergents n
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {g : Î² â†’ m} (e : Î± â†’ Î²) (hEâ‚€ : Function.Bijective e) (hEâ‚ : âˆ€ (x : Î±), F x = g (e x)) : finsum (Î» (i : Î±), F i) = finsum (Î» (j : Î²), g j)
{R : Type u} [Rack R] {A B : Rack.pre_envel_Group R} : Rack.pre_envel_Group_Rel' R A B â†’ Rack.pre_envel_Group_Rel R A B
(P : â„•) (A : â„¤) [hp : Fact (Nat.Prime P)] : â†‘(Zmod.legendre_Sym P A) = â†‘A ^ (P / 2)
{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (m : Matrix n n R) (P : Polynomial R) : â‡‘(Polynomial.aeval m) P = â‡‘(Polynomial.aeval m) (P %â‚˜ m.charpoly)
{Î± : Type u_1} [AddCommMonoid Î±] {n : â„•} (F : Affine.Simplex.points_with_circumcenter_Index n â†’ Î±) : Finset.Univ.Sum (Î» (i : Affine.Simplex.points_with_circumcenter_Index n), F i) = Finset.Univ.Sum (Î» (i : Fin (n + 1)), F (Affine.Simplex.points_with_circumcenter_Index.point_Index i)) + F Affine.Simplex.points_with_circumcenter_Index.circumcenter_Index
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] [Group Î±] [uniform_Group Î±] {hom : Type u_3} [UniformSpace Î²] [Group Î²] [uniform_Group Î²] [Monoid_hom_class hom Î± Î²] (F : hom) (hF : Continuous_at â‡‘F 1) : uniform_Continuous â‡‘F
{C : Type u} [CategoryTheory.Category C] {S : Type W} [CategoryTheory.SmallCategory S] (e : C â‰Œ S) : CategoryTheory.EssentiallySmall C
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] {A B : Î±} (ha : 1 < A) (hb : 1 â‰¤ B) : 1 < A * B
{Î± : Type u} [AddGroup Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A : Î±} (h : 0 â‰¤ A) : -A â‰¤ A
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (h : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ (âˆƒ (t : set Î±) (h : t âŠ† S), x âˆˆ t âˆ§ y âˆˆ t âˆ§ IsPreconnected t)) : IsPreconnected S
{F : â„‚ â†’ â„‚} {z : â„‚} : ConformalAt F z â†” (Differentiable_at â„‚ F z âˆ¨ Differentiable_at â„‚ (F âˆ˜ â‡‘(Star_Ring_end â„‚)) (â‡‘(Star_Ring_end â„‚) z)) âˆ§ fderiv â„ F z â‰  0
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {Î¹ : Type u_1} {S : set Î¹} [IsNoetherian K v] (B : Basis â†¥S K v) : S.Finite
{Î± : Type u_1} [PartialOrder Î±] [OrderBot Î±] {A : Î±} : âŠ¥ â‹– A â†’ IsAtom A
{P : â„•} : padic_val_Nat P 0 = 0
{R : Type u_1} [Semiring R] [Nontrivial R] (n : â„•) : (PowerSeries.x ^ n).order = â†‘n
{G : Type u_1} [Group G] {k : set G} : k âŠ† â†‘(Subgroup.Closure k)
(F : Type u_1) [Field F] (E : Type u_2) [Field E] [Algebra F E] [Fintype E] : âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
{ð’œ : Type u_1} [CategoryTheory.Category ð’œ] [CategoryTheory.Preadditive ð’œ] [CategoryTheory.Limits.HasKernels ð’œ] [CategoryTheory.Limits.HasImages ð’œ] [CategoryTheory.Limits.HasBinaryBiproducts ð’œ] (A B : ð’œ) : CategoryTheory.Exact CategoryTheory.Limits.biprod.inr_ CategoryTheory.Limits.biprod.fst
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Invertible 2] (P : Fin 2 â†’ P) : Finset.centroid k Finset.Univ P = 2â»Â¹ â€¢ (P 1 -áµ¥ P 0) +áµ¥ P 0
{Î± : Type u} [HasSubset Î±] {A B : Î±} [IsRefl Î± HasSubset.Subset] : A = B â†’ A âŠ† B
(R : Type u_1) (m : Type u_2) [Semiring R] [Subsingleton R] [AddCommMonoid m] [module R m] : Subsingleton m
{R : Type u_1} [Semiring R] (n : â„•) (A : R) (h : A â‰  0) : (â‡‘(PowerSeries.monomial R n) A).order = â†‘n
{m : Type u_2} [AddCommGroup m] {A : Type u_1} [CommRing A] [module A m] (F : m â‰ƒâ‚—[A] m) : â‡‘LinearMap.det â†‘F * â‡‘LinearMap.det â†‘(F.Symm) = 1
(n P : â„•) : (â†‘P + 1) * (Finset.Range n).Sum (Î» (k : â„•), â†‘k ^ P) = Polynomial.Eval â†‘n (Polynomial.bernoulli P.Succ) - bernoulli P.Succ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q R : C} (F : P âŸ¶ q) (g : q âŸ¶ R) : ((âˆ€ (A : â†¥P), â‡‘g (â‡‘F A) = 0) âˆ§ âˆ€ (B : â†¥q), â‡‘g B = 0 â†’ (âˆƒ (A : â†¥P), â‡‘F A = B)) â†’ CategoryTheory.Exact F g
{Î“â‚€ : Type u_1} [Linear_ordered_comm_Group_with_Zero Î“â‚€] (Î³ : Î“â‚€) (h : Î³ â‰  0) : {x : Î“â‚€ | x < Î³} âˆˆ nhds 0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] [CompleteSpace ð•œ] {n : WithTop â„•} {F : E â†’ (F â†’L[ð•œ] G)} {S : set E} [Finite_dimensional ð•œ F] : ContDiff_on ð•œ n F S â†” âˆ€ (y : F), ContDiff_on ð•œ n (Î» (x : E), â‡‘(F x) y) S
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : E â†’ F} {g : E â†’ G} (hF : ContDiff ð•œ n F) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Î» (x : E), (F x, g x))
{R : Type u} {Î¹ : Type W} (S : Finset Î¹) [CommSemiring R] [no_Zero_divisors R] (F : Î¹ â†’ Polynomial R) : (S.Prod (Î» (i : Î¹), F i)).leading_Coeff = S.Prod (Î» (i : Î¹), (F i).leading_Coeff)
{Î± : Type u_1} {Î² : Type u_2} {e e' : local_Equiv Î± Î²} (hE : e â‰ˆ e') (S : set Î²) : e.Source âˆ© â‡‘e â»Â¹' S = e'.Source âˆ© â‡‘e' â»Â¹' S
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P (n + 2)) : S.monge_point = â‡‘(Finset.Univ.affine_combination S.points_with_circumcenter) (Affine.Simplex.monge_point_weights_with_circumcenter n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {Î¹ : Type v} {B : Î¹ â†’ C} (hB : âˆ€ (A : C), âˆƒ (i : Î¹), Nonempty (B i âŸ¶ A)) : âˆƒ (t : C), âˆ€ (x : C), Nonempty (t âŸ¶ x)
{Î± : Type u_1} {Î² : Type u_2} (F : Î² â†’ Î± â†’ Î²) (B : Î²) (v : Vector Î± 1) : Vector.scanl F B v = B::áµ¥F B v.head::áµ¥Vector.Nil
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {A : Î±} {S : set Î±} (h : F A = 0) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ HasInsert.Insert A S), F i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i))
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {t : Finset v} (h : Finite_dimensional.finrank K v < t.Card) : âˆƒ (F : v â†’ K), t.Sum (Î» (e : v), F e â€¢ e) = 0 âˆ§ âˆƒ (x : v) (h : x âˆˆ t), F x â‰  0
{m : Type u_1} {R : Type u_2} [Fintype m] [CommRing R] {m : Matrix m m R} (hM : m.nondegenerate) {v : m â†’ R} (hv : âˆ€ (W : m â†’ R), Matrix.dot_Product v (m.Mul_vec W) = 0) : v = 0
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {F g : â„‚ â†’ E} (hfd : Diff_Cont_on_cl â„‚ F {z : â„‚ | 0 < z.re}) (hgd : Diff_Cont_on_cl â„‚ g {z : â„‚ | 0 < z.re}) (hfexp : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hgexp : âˆƒ (C : â„) (h : C < 2) (B : â„), g =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : Asymptotics.SuperpolynomialDecay Filter.at_top Real.Exp (Î» (x : â„), âˆ¥F â†‘x - g â†‘xâˆ¥)) (hfim : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥F (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hgim : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥g (â†‘x * Complex.i)âˆ¥ â‰¤ C) : set.Eq_on F g {z : â„‚ | 0 â‰¤ z.re}
{G : Type W} [TopologicalSpace G] [Group G] [topological_Group G] [t2_Space G] (K : TopologicalSpace.PositiveCompacts G) : LocallyCompactSpace G
{Î± : Type u} [Preorder Î±] {A B : Î±} (h : A < B) : Â¬B < A
{Î± : Type u_1} {Î² : Type u_2} (t : Î±) (ts : List Î±) (r : List Î²) (ys : List Î±) (F : List Î± â†’ Î²) : (List.PermutationsAux2 t ts r ys F).Snd = List.Map (Î» (x : List Î±), F (x ++ ts)) (List.PermutationsAux2 t List.Nil List.Nil ys Id).Snd ++ r
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {P : Filter Î¹} : TendstoUniformly F F P â†” Filter.Tendsto (Î» (q : Î¹ Ã— Î±), (F q.Snd, F q.fst q.Snd)) (P.Prod âŠ¤) (Uniformity Î²)
{m : Type u_1} {N : Type u_2} {Î± : Type u_6} {Î² : Type u_7} [HasScalar m Î±] [HasScalar m Î²] [HasScalar Î± Î²] [IsScalarTower m Î± Î²] (g : N â†’ m) : IsScalarTower N Î± Î²
 : fourier_Subalgebra.separates_points
(n : â„•) (R : Type u_1) [Ring R] [Nontrivial R] : Polynomial.cyclotomic n R â‰  0
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A : Î±} : -A < 0 â†” 0 < A
{Î± : Type u_1} {Î¹ : Type u_3} [CompleteLattice Î±] {S : Finset Î¹} {F : Î¹ â†’ Î±} : S.Sup_indep F â†’ CompleteLattice.Independent (F âˆ˜ Coe)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} {F : ð•œ â†’ F} {S : set ð•œ} {x : ð•œ} (hxs : UniqueDiffOn ð•œ S) (hx : x âˆˆ S) : iterated_deriv_within (n + 1) F S x = iterated_deriv_within n (deriv_within F S) S x
{R : Type u} [non_assoc_Semiring R] {S : set R} {P : R â†’ Prop} {x : R} (h : x âˆˆ Subsemiring.Closure S) (Hs : âˆ€ (x : R), x âˆˆ S â†’ P x) (h0 : P 0) (h1 : P 1) (HAdd : âˆ€ (x y : R), P x â†’ P y â†’ P (x + y)) (HMul : âˆ€ (x y : R), P x â†’ P y â†’ P (x * y)) : P x
{R : Type u_1} {A B : R} [Add_Semigroup R] (Ab : _Add_Left_regular (A + B)) : _Add_Left_regular B
{Î² : Type u_2} [DecidableEq Î²] (S : Finset Î²) (B : Î²) : Finset.Filter (Î» (A : Î²), A = B) S = Ite (B âˆˆ S) {B} âˆ…
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] [ContravariantClass m m has_Add.Add has_LE.LE] {A B : k} {C D : m} (hba : B â‰¤ A) (hdc : D â‰¤ C) : A â€¢ D + B â€¢ C â‰¤ A â€¢ C + B â€¢ D
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D â¥¤ C) [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.cartesian_IsClosed C] [CategoryTheory.Reflective i] (h : Î  (A : C), i â‹™ CategoryTheory.Exp A â‹™ CategoryTheory.IsLeftAdjoint i â‹™ i â‰… i â‹™ CategoryTheory.Exp A) : CategoryTheory.exponential_Ideal i
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} {t : Add_Submonoid P} {q : Type u_4} [AddCommMonoid q] (hg : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) (k : t.Localization_Map q) {x y : m} (h : â‡‘(F.to_Map) x = â‡‘(F.to_Map) y) : â‡‘(k.to_Map) (â‡‘g x) = â‡‘(k.to_Map) (â‡‘g y)
{R : Type u} [Ring R] (S : Subring R) : 1 âˆˆ S
{Î± : Type u_1} [semi_NormedRing Î±] (A : Î±) {n : â„•} (h : 0 < n) : âˆ¥A ^ nâˆ¥ â‰¤ âˆ¥Aâˆ¥ ^ n
(P : â„•) {R : Type u_1} [hp : Fact (Nat.Prime P)] [CommRing R] (r : R) (n : â„•) : â‡‘(witt_Vector.ghost_component n) (â‡‘(witt_Vector.teichmuller P) r) = r ^ P ^ n
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {C : â„} {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : Asymptotics._O_with C l F g' â†’ Asymptotics._O_with C l F (Î» (x : Î±), -g' x)
{Î± : Type u_1} {R : Type u_2} {l : Filter Î±} {F : Î± â†’ R} {r : R} [Linear_OrderedSemiring R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (Î» (x : Î±), r * F x) l Filter.at_top
{R : Type u_4} {S : Type u_5} [has_Mul R] [has_Add R] [has_Mul S] [has_Add S] {F g : R â‰ƒ+* S} (h : âˆ€ (x : R), â‡‘F x = â‡‘g x) : F = g
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (hS : IsClosed â†‘S) (m : m) (h : âˆ¥â‡‘(Quotient_AddGroup.Mk' S) mâˆ¥ = 0) : m âˆˆ S
{J : Type uâ‚} [CategoryTheory.Category J] [Nonempty J] (h : âˆ€ {Î± : Type uâ‚} (F : J â†’ Î±), (âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ F jâ‚ = F jâ‚‚) â†’ âˆ€ (j j' : J), F j = F j') : CategoryTheory.IsConnected J
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [Subsingleton Î¹] (P : Î¹ â†’ P) : AffineIndependent k P
{Râ‚‚ : Type u_5} {mâ‚‚ : Type u_6} [CommSemiring Râ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚‚ mâ‚‚] {B : BilinForm Râ‚‚ mâ‚‚} : B.nondegenerate â†” (â‡‘BilinForm.to_lin B).Ker = âŠ¥
{G : Type u_1} [AddGroup G] {k : set G} {P : G â†’ G â†’ Prop} {x y : G} (hx : x âˆˆ Add_Subgroup.Closure k) (hy : y âˆˆ Add_Subgroup.Closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ âˆ€ (y : G), y âˆˆ k â†’ P x y) (h1_Left : âˆ€ (x : G), P 0 x) (h1_Right : âˆ€ (x : G), P x 0) (HMul_Left : âˆ€ (xâ‚ xâ‚‚ y : G), P xâ‚ y â†’ P xâ‚‚ y â†’ P (xâ‚ + xâ‚‚) y) (HMul_Right : âˆ€ (x yâ‚ yâ‚‚ : G), P x yâ‚ â†’ P x yâ‚‚ â†’ P x (yâ‚ + yâ‚‚)) (Hinv_Left : âˆ€ (x y : G), P x y â†’ P (-x) y) (Hinv_Right : âˆ€ (x y : G), P x y â†’ P x (-y)) : P x y
{R : Type u_1} {S : Type u_2} [non_unital_non_assoc_Semiring R] [non_unital_non_assoc_Semiring S] (F : R â†’+ S) : (âˆ€ (x y : R), â‡‘F (x * y) = â‡‘F x * â‡‘F y) â†” AddMonoid_hom.Mul.comprâ‚‚ F = (AddMonoid_hom.Mul.Comp F).IsComplâ‚‚ F
{m : Type u_1} [has_Add m] (r : m â†’ m â†’ Prop) : Add_Con_gen r = HasInf.Inf {S : Add_Con m | âˆ€ (x y : m), r x y â†’ â‡‘S x y}
{Î± : Type u_1} {Î² : Type u_2} [Add_Semigroup Î±] [Add_comm_Semigroup Î²] {F g : Î± â†’ Î²} (hF : _Add_hom F) (hg : _Add_hom g) : _Add_hom (Î» (A : Î±), F A + g A)
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R â†’+* S} [Nontrivial S] {P : Polynomial S} (hlifts : P âˆˆ Polynomial.lifts F) (hp : P.monic) : âˆƒ (q : Polynomial R), Polynomial.Map F q = P âˆ§ q.degree = P.degree âˆ§ q.monic
{x : Type u} {Î± : Type v} [TopologicalSpace x] [LinearOrder Î±] [TopologicalSpace Î±] [order_IsClosed_topology Î±] [PreconnectedSpace x] {A B : x} {F g : x â†’ Î±} (hF : Continuous F) (hg : Continuous g) (ha : F A â‰¤ g A) (hb : g B â‰¤ F B) : âˆƒ (x : x), F x = g x
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} (hF : Monotone_on F S) (hs : S âˆˆ nhds_within A (set.Iic A)) (hfs : âˆ€ (B : Î²), B < F A â†’ (âˆƒ (C : Î±) (h : C âˆˆ S), F C âˆˆ set.Ioo B (F A))) : Continuous_within_at F (set.Iic A) A
{ð•œ : Type u_1} {E : Type u_3} {F : Type u_4} [CommRing ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] [AddCommGroup F] [module ð•œ F] [TopologicalSpace F] [topological_AddGroup F] [has_Continuous_Const_Smul ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {m n : â„•} {v : Fin m â†’ E} {W : Fin n â†’ E} (h1 : m = n) (h2 : âˆ€ (i : â„•) (him : i < m) (hin : i < n), v âŸ¨i, himâŸ© = W âŸ¨i, hinâŸ©) : â‡‘(P m) v = â‡‘(P n) W
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_at F B) : HasDerivAt (Î» (u : â„), âˆ« (x : â„) in A..u, F x) (F B) B
(m n : â„•+) : (m.Gcd n).factor_Multiset = m.factor_Multiset âŠ“ n.factor_Multiset
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [Ring ð•œ] [AddCommGroup E] [AddCommGroup F] [module ð•œ E] [module ð•œ F] [TopologicalSpace E] [TopologicalSpace F] [topological_AddGroup E] [topological_AddGroup F] [has_Continuous_Const_Smul ð•œ E] [has_Continuous_Const_Smul ð•œ F] (P : FormalMultilinearSeries ð•œ E F) (n : â„•) : Continuous (P.partial_Sum n)
(Î± : Type u) [Preorder Î±] [Nonempty Î±] [NoMinOrder Î±] : âˆƒ (F : â„• â†’ Î±), StrictAnti F
{m : Type u} [Monoid m] (u : mË£) (x : m) : SemiconjBy â†‘u x (â†‘u * x * â†‘uâ»Â¹)
{Î¹ : Type u} {F g : Î¹ â†’ Nnreal} {A B : Nnreal} {P : â„} (hp : 1 â‰¤ P) (hF : has_Sum (Î» (i : Î¹), F i ^ P) (A ^ P)) (hg : has_Sum (Î» (i : Î¹), g i ^ P) (B ^ P)) : âˆƒ (C : Nnreal), C â‰¤ A + B âˆ§ has_Sum (Î» (i : Î¹), (F i + g i) ^ P) (C ^ P)
{F : Bool â†’ Bool â†’ Bool} (hF : âˆ€ (B B' : Bool), F B B' = F B' B) (hF' : F Bool.ff Bool.ff = Bool.ff) (n m : â„•) : Nat.bitwise F n m = Nat.bitwise F m n
{S : Type v} [CommRing S] (D : â„•) (y : S) : Polynomial.Eval (1 + y) (â‡‘(Polynomial.monomial D) (â†‘D + 1)) - Polynomial.Eval y (â‡‘(Polynomial.monomial D) (â†‘D + 1)) = (Finset.Range (D + 1)).Sum (Î» (x_1 : â„•), â†‘((D + 1).choose x_1) * (â†‘x_1 * y ^ (x_1 - 1)))
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A l' : Î±} {S : set Î±} (hl' : l' < A) : S âˆˆ nhds_within A (set.Iio A) â†” âˆƒ (l : Î±) (h : l âˆˆ set.Iio A), set.Ioo l A âŠ† S
{Î± : Type u} {Lâ‚ Lâ‚‚ Lâ‚ƒ : List (Î± Ã— Bool)} : free_Group.red Lâ‚ Lâ‚‚ â†’ free_Group.red Lâ‚ Lâ‚ƒ â†’ Relation.Join free_Group.red Lâ‚‚ Lâ‚ƒ
(Î¹ : Type u_1) [Fintype Î¹] : MeasureTheory.Measure.Add_haar_measure (TopologicalSpace.PositiveCompacts.Pi_icc01 Î¹) = MeasureTheory.MeasureSpace.Volume
{R : Type u_1} {A B : R} [Semigroup R] (lra : IsLeftRegular A) (lrb : IsLeftRegular B) : IsLeftRegular (A * B)
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : â†‘âŠ¤ = set.Univ
{J : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.IsConnected J] (r : J â†’ J â†’ Prop) (hr : Equivalence r) (h : âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ r jâ‚ jâ‚‚) (jâ‚ jâ‚‚ : J) : r jâ‚ jâ‚‚
{n k : â„•} : n < k â†’ n.Desc_factorial k = 0
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Monotone F) : Pairwise (Disjoint on Î» (n : Î±), set.Ioo (F (Order.Pred n)) (F n))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {S : set E} : UniqueDiffOn ð•œ S â†’ Unique_mdiff_on (model_with_corners_self ð•œ E) S
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : â†‘S âˆ© â†‘(AffineSubspace.Mk' P (S.direction)á—®) = {EuclideanGeometry.Orthogonal_projection_fn S P}
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) (hF'_nonneg : âˆ€ (x : â„), x âˆˆ Interior D â†’ 0 â‰¤ deriv F x) : Monotone_on F D
{R : Type u_1} [comm_Group_with_Zero R] {F g : â„• â†’ R} (hF : âˆ€ (n : â„•), 0 < n â†’ F n â‰  0) (hg : âˆ€ (n : â„•), 0 < n â†’ g n â‰  0) : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.Prod (Î» (i : â„•), F i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.Prod (Î» (x : â„• Ã— â„•), g x.Snd ^ â‡‘Nat.ArithmeticFunction.moebius x.fst) = F n
{n : â„•} {iâ‚ iâ‚‚ : Fin (n + 1)} (h : iâ‚ â‰  iâ‚‚) : Finset.Univ.Sum (Î» (i : Affine.Simplex.points_with_circumcenter_Index n), Affine.Simplex.reflection_circumcenter_weights_with_circumcenter iâ‚ iâ‚‚ i) = 1
{x : Type u} [PseudoMetricSpace x] {Î´ : â„} {E : set x} : Metric.Thickening Î´ E = â‹ƒ (x : x) (h : x âˆˆ E), Metric.Ball x Î´
(R : Type u_3) (m : Type u_4) [AddCommMonoid m] [Ring R] [Fintype R] [module R m] : AddMonoid._torsion m
(ð•œ : Type u_1) {A : Type u_2} [nondiscrete_NormedField ð•œ] [NormedRing A] [normed_Algebra ð•œ A] [CompleteSpace A] (A : A) : HasFpowerSeriesOnBall (Î» (z : ð•œ), Ring.Inverse (1 - z â€¢ A)) (Î» (n : â„•), Continuous_MultilinearMap.Mk_Pi_Field ð•œ (Fin n) (A ^ n)) 0 (â†‘âˆ¥Aâˆ¥â‚Š)â»Â¹
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] [Nonempty Î²] {F : Î² â†’ Î±} (hF : Continuous F) (hlim : Filter.Tendsto F (Filter.cocompact Î²) Filter.at_IsBot) : âˆƒ (x : Î²), âˆ€ (y : Î²), F y â‰¤ F x
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : InnerProductGeometry.angle x (-y) = Real.Pi - InnerProductGeometry.angle x y
{R : Type u_1} [Left_cancel_Semigroup R] (g : R) : IsLeftRegular g
(S t : set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] (C : Type W) [CommRing C] [Algebra A C] [Algebra B C] [IsScalarTower A B C] [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension t B C] : IsCyclotomicExtension (S âˆª t) A C
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z â†’ B} [TopologicalSpace Z] (h : IsTopologicalFiberBundle F Proj) : IsOpen_Map Proj
{x y z : â„¤} : PythagoreanTriple x y z â†” âˆƒ (k m n : â„¤), (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§ (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2))
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î±] [Fintype Î±] [CommMonoid Î²] {Î´ : Î± â†’ Type u_3} {t : Î  (A : Î±), Finset (Î´ A)} (F : (Î  (A : Î±), A âˆˆ Finset.Univ â†’ Î´ A) â†’ Î²) : (Finset.Univ.Pi t).Prod (Î» (x : Î  (A : Î±), A âˆˆ Finset.Univ â†’ Î´ A), F x) = (Fintype.Pi_Finset t).Prod (Î» (x : Î  (A : Î±), Î´ A), F (Î» (A : Î±) (_x : A âˆˆ Finset.Univ), x A))
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [PartialOrder Î±] [t : OrderTopology Î±] {F g h : Î² â†’ Î±} {B : Filter Î²} {A : Î±} (hg : Filter.Tendsto g B (nhds A)) (hH : Filter.Tendsto h B (nhds A)) (hgf : g â‰¤ F) (hfh : F â‰¤ h) : Filter.Tendsto F B (nhds A)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryProducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{Î² : Type u_2} [CommMonoid Î²] (F : Fin 0 â†’ Î²) : Finset.Univ.Prod (Î» (i : Fin 0), F i) = 1
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] [Nontrivial E] {x : E} {K : set E} (hK : IsCompact K) (hx : x âˆˆ K) : âˆƒ (y : E) (h : y âˆˆ Frontier K), metric.Inf_dist x Ká¶œ = HasDist.dist x y
{C : Type uâ‚} [CategoryTheory.SmallCategory C] (P : Cáµ’áµ– â¥¤ Type uâ‚) (j : (P.Elements)áµ’áµ–) : (CategoryTheory.Cocone_of_representable P).Î¹.App j = (CategoryTheory.yoneda_sections_Small ((CategoryTheory.Category_of_Elements.Ï€ P).Left_Op.obj j) (((CategoryTheory.Functor.Const (P.Elements)áµ’áµ–).obj (CategoryTheory.Cocone_of_representable P).x).obj j)).Inv (Opposite.Unop j).Snd
(ð•œ : Type u_1) [nondiscrete_NormedField ð•œ] {E : Type u_2} [semi_NormedGroup E] [NormedSpace ð•œ E] {S : set E} (S_nhd : S âˆˆ nhds 0) : Metric.Bounded (NormedSpace.polar ð•œ S)
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {x : ð•œ} {L : Filter ð•œ} {F' : ð•œ â†’L[ð•œ] F} : HasFderivAt_Filter F F' x L â†” HasDerivAt_Filter F (â‡‘F' 1) x L
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F : x âŸ¶ Y} {C : CategoryTheory.Limits.Cofork F F} (h : CategoryTheory.Limits.IsColimit C) : CategoryTheory.IsIso C.Ï€
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : A < 0) (hb : B < 0) : A + B < 0
{Î± : Type u_1} [TopologicalSpace Î±] {x : Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] [has_Continuous_Add Î³] {F g : Î± â†’ Î³} (hF : LowerSemicontinuousAt F x) (hg : LowerSemicontinuousAt g x) : LowerSemicontinuousAt (Î» (z : Î±), F z + g z) x
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.has_Finite_products D] (F : C â¥¤ D) [CategoryTheory.cartesian_IsClosed C] [CategoryTheory.cartesian_IsClosed D] [CategoryTheory.Limits.PreservesLimits_of_shape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] {A A' : C} (F : A' âŸ¶ A) : CategoryTheory.Exp_comparison F A â‰« CategoryTheory.whisker_Left F (CategoryTheory.pre (F.Map F)) = CategoryTheory.whisker_Right (CategoryTheory.pre F) F â‰« CategoryTheory.Exp_comparison F A'
{Î± : Type u} (L : List Î±) {i j : â„•} (hi : i < L.length) (hj : i < j) : L.nth_LE i hi = (List.take j L).nth_LE i _
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] {F G : top.sheaf C x} (F : F âŸ¶ G) [âˆ€ (x : â†¥x), CategoryTheory.IsIso ((top.Presheaf.stalk_Functor C x).Map F)] : CategoryTheory.IsIso F
{Î± : Type u} [PseudoMetricSpace Î±] (x y : Î±) : HasEdist.edist x y = â†‘(HasNndist.nndist x y)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {R : Type u_6} [NormedRing R] [normed_Algebra ð•œ R] [CompleteSpace R] (x : RË£) : HasFderivAt Ring.Inverse (-â‡‘(â‡‘(Continuous_Linear_Map.lmul_Left_Right ð•œ R) â†‘xâ»Â¹) â†‘xâ»Â¹) â†‘x
{m : Type u_2} {n : Type u_3} {Î± : Type v} [HasStar Î±] (m : Matrix m n Î±) (i : m) (j : n) : m.Conj_transpose j i = HasStar.Star (m i j)
(ð•œ : Type u_1) {E : Type u_2} [normed_Linear_ordered_Field ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [strict_Convex_Space ð•œ E] (x : E) (r : â„) : strict_Convex ð•œ (metric.IsClosed_ball x r)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) (h : S.Sum (Î» (i : Î¹), W i) = 1) (Bâ‚ Bâ‚‚ : P) : â‡‘(S.weighted_vsub_of_point P Bâ‚) W +áµ¥ Bâ‚ = â‡‘(S.weighted_vsub_of_point P Bâ‚‚) W +áµ¥ Bâ‚‚
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {R : Nnreal} {C : â„‚} {F : â„‚ â†’ E} {S : set â„‚} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C â†‘R)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball C â†‘R  S â†’ Differentiable_at â„‚ F z) (hR : 0 < R) : HasFpowerSeriesOnBall F (Cauchy_PowerSeries F C â†‘R) C â†‘R
{Î± : Type u_1} {E : Î± â†’ Type u_2} {P : Ennreal} [Î  (i : Î±), NormedGroup (E i)] {Î¹ : Type u_3} {l : Filter Î¹} [l.Ne_IsBot] [Fact (1 â‰¤ P)] {F : Î¹ â†’ â†¥(Lp E P)} (hF : Metric.Bounded (set.Range F)) {F : Î  (A : Î±), E A} (hF : Filter.Tendsto (Id (Î» (i : Î¹), â‡‘(F i))) l (nhds F)) : memâ„“P F P
{C : Type u} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryProduct A B] [CategoryTheory.Limits.HasBinaryProduct A' B'] [CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')] (F : A âŸ¶ A') (g : B âŸ¶ B') : F.Map (CategoryTheory.Limits.Prod.Map F g) â‰« CategoryTheory.Limits.Prod_comparison F A' B' = CategoryTheory.Limits.Prod_comparison F A B â‰« CategoryTheory.Limits.Prod.Map (F.Map F) (F.Map g)
{ð•œ : Type u_1} {E : Type u} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] {S : set E} : â‡‘(Convex_hull ð•œ) S = â‹ƒ (t : Finset E) (hss : â†‘t âŠ† S) (hai : AffineIndependent ð•œ Coe), â‡‘(Convex_hull ð•œ) â†‘t
{G : Type u_1} [Group G] {h : Subgroup G} [DecidableEq G] {R S : Finset G} (hR : â†‘R âˆˆ Subgroup.Right_transversals â†‘h) (hR1 : 1 âˆˆ R) (hS : Subgroup.Closure â†‘S = âŠ¤) : Subgroup.Closure â†‘(Finset.image (Î» (g : G), âŸ¨g * (â†‘(Subgroup.mem_Right_transversals.ToFun hR g))â»Â¹, _âŸ©) (R * S)) = âŠ¤
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscrete_NormedField ð•‚] [normed_CommRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] [CharZero ð•‚] {x y : ð”¸} (hx : x âˆˆ Emetric.Ball 0 (Exp_series ð•‚ ð”¸).radius) (hy : y âˆˆ Emetric.Ball 0 (Exp_series ð•‚ ð”¸).radius) : Exp ð•‚ (x + y) = Exp ð•‚ x * Exp ð•‚ y
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} (hg : âˆ€ (y : â†¥S), IsAddUnit (â‡‘g â†‘y)) (z : N) : â‡‘(F.Lift hg) z + â‡‘g â†‘((F.sec z).Snd) = â‡‘g (F.sec z).fst
{v : Type u_1} [InnerProductSpace â„ v] {x : v} (hx : x â‰  0) : InnerProductGeometry.angle x (-x) = Real.Pi
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {A : Î±} {S : set Î±} (h : F A = 1) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ HasInsert.Insert A S), F i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i))
{R : Type u_1} {m : Type u_2} [TopologicalSpace R] [DivisionRing R] [has_Continuous_sub R] [AddCommGroup m] [TopologicalSpace m] [has_Continuous_Add m] [module R m] [has_Continuous_Smul R m] (F : m â†’L[R] R) (hF : F â‰  0) : IsOpen_Map â‡‘F
(n : â„•+) (K : Type W) (L : Type z) [Field K] [Field L] [Algebra K L] [Ne_Zero â†‘â†‘n] [IsCyclotomicExtension {n} K L] : Polynomial._splitting_Field K L (Polynomial.cyclotomic â†‘n K)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) {x : C} [CategoryTheory.IsIso (h.Unit.App x)] : CategoryTheory.Inv (L.Map (h.Unit.App x)) = h.counit.App (L.obj x)
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (m N : Matrix m m R) : (m.Mul N).det = (N.Mul m).det
{ð•œ : Type u_1} {E : Type u_2} [semi_NormedRing ð•œ] [HasScalar ð•œ E] {S t : set E} (hs : Balanced ð•œ S) (h : S âŠ† t) : S âŠ† Balanced_core ð•œ t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.has_Finite_Limits C
{Î± : Type u_1} [TopologicalSpace Î±] {S : set Î±} : MeasureTheory.analytic_set S â†” âˆƒ (Î² : Type) (h : TopologicalSpace Î²) (h' : PolishSpace Î²) (F : Î² â†’ Î±), Continuous F âˆ§ set.Range F = S
{m : Type u_1} [Monoid m] {S : set m} {A : m} (hs : _Submonoid S) (h : A âˆˆ S) : Powers A âŠ† S
{C : Type u} [CategoryTheory.Category C] {x Y : C} [CategoryTheory.Limits.HasEqualizers C] {x' : C} (h : x' âŸ¶ x) [CategoryTheory.IsIso h] (F : x âŸ¶ Y) [CategoryTheory.Limits.HasImage F] : CategoryTheory.Limits.image_Subobject (h â‰« F) = CategoryTheory.Limits.image_Subobject F
{Î± : Type u} [Preorder Î±] {A B C : Î±} : A < B â†’ B < C â†’ A < C
{ð•œ : Type u} [hnorm : nondiscrete_NormedField ð•œ] {E : Type v} [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul ð•œ E] {F' : Type x} [AddCommGroup F'] [module ð•œ F'] [TopologicalSpace F'] [topological_AddGroup F'] [has_Continuous_Smul ð•œ F'] [CompleteSpace ð•œ] [t2_Space E] [Finite_dimensional ð•œ E] (F : E â†’â‚—[ð•œ] F') : Continuous â‡‘F
{ð•œ : Type u_1} {E : Type u_4} [semi_NormedGroup E] [nondiscrete_NormedField ð•œ] [NormedSpace ð•œ E] {ð•œ' : Type u_10} [NormedField ð•œ'] [normed_Algebra ð•œ ð•œ'] [NormedSpace ð•œ' E] [IsScalarTower ð•œ ð•œ' E] : âˆ¥Continuous_Linear_Map.lsmul ð•œ ð•œ'âˆ¥ â‰¤ 1
{C : Type u} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryCoproduct A B] [CategoryTheory.Limits.HasBinaryCoproduct A' B'] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')] (F : A âŸ¶ A') (g : B âŸ¶ B') : CategoryTheory.Limits.Coprod_comparison F A B â‰« F.Map (CategoryTheory.Limits.Coprod.Map F g) = CategoryTheory.Limits.Coprod.Map (F.Map F) (F.Map g) â‰« CategoryTheory.Limits.Coprod_comparison F A' B'
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S : set Î±} {A : Î±} (hs : BddAbove S) (sne : S.Nonempty) : HasSup.Sup (HasInsert.Insert A S) = A âŠ” HasSup.Sup S
{Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} : lâ‚ <:+ lâ‚‚ â†’ lâ‚.reverse <+: lâ‚‚.reverse
{G : Type u_1} [AddGroup G] [Fintype G] : AddMonoid._torsion G
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (h : Metric.Bounded S) : Metric.Bounded (Closure S)
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Semiring R] [AddCommMonoid N] [module R N] (P : Î¹ â†’ Submodule R N) : CompleteLattice.Independent P â†” âˆ€ (i : Î¹) (x : â†¥(P i)) (v : Î â‚€ (i : Î¹), â†¥(P i)), â‡‘(â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (P i).Subtype)) (Dfinsupp.erase i v) = â†‘x â†’ x = 0
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] {S : set Î²} {F : Î² â†’ Î±} (hF : Continuous_on F S) (hsc : IsClosed S) {xâ‚€ : Î²} (hâ‚€ : xâ‚€ âˆˆ S) (hc : âˆ€á¶  (x : Î²) in Filter.cocompact Î² âŠ“ Filter.principal S, F x â‰¤ F xâ‚€) : âˆƒ (x : Î²) (h : x âˆˆ S), âˆ€ (y : Î²), y âˆˆ S â†’ F y â‰¤ F x
{Î± : Type u} {n : â„•} (F : Fin n â†’ Î±) : (List.of_fn F).length = n
{E : Type u} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] (F g : â„ Ã— â„ â†’ E) (F' g' : â„ Ã— â„ â†’ (â„ Ã— â„ â†’L[â„] E)) (Aâ‚ Aâ‚‚ Bâ‚ Bâ‚‚ : â„) (S : set (â„ Ã— â„)) (hs : S.countable) (Hcf : Continuous_on F (set.Interval Aâ‚ Bâ‚ Ã—Ë¢ set.Interval Aâ‚‚ Bâ‚‚)) (Hcg : Continuous_on g (set.Interval Aâ‚ Bâ‚ Ã—Ë¢ set.Interval Aâ‚‚ Bâ‚‚)) (Hdf : âˆ€ (x : â„ Ã— â„), x âˆˆ set.Ioo (LinearOrder.min Aâ‚ Bâ‚) (LinearOrder.max Aâ‚ Bâ‚) Ã—Ë¢ set.Ioo (LinearOrder.min Aâ‚‚ Bâ‚‚) (LinearOrder.max Aâ‚‚ Bâ‚‚)  S â†’ HasFderivAt F (F' x) x) (Hdg : âˆ€ (x : â„ Ã— â„), x âˆˆ set.Ioo (LinearOrder.min Aâ‚ Bâ‚) (LinearOrder.max Aâ‚ Bâ‚) Ã—Ë¢ set.Ioo (LinearOrder.min Aâ‚‚ Bâ‚‚) (LinearOrder.max Aâ‚‚ Bâ‚‚)  S â†’ HasFderivAt g (g' x) x) (Hi : MeasureTheory.IntegrableOn (Î» (x : â„ Ã— â„), â‡‘(F' x) (1, 0) + â‡‘(g' x) (0, 1)) (set.Interval Aâ‚ Bâ‚ Ã—Ë¢ set.Interval Aâ‚‚ Bâ‚‚) MeasureTheory.MeasureSpace.Volume) : âˆ« (x : â„) in Aâ‚..Bâ‚, âˆ« (y : â„) in Aâ‚‚..Bâ‚‚, â‡‘(F' (x, y)) (1, 0) + â‡‘(g' (x, y)) (0, 1) = (((âˆ« (x : â„) in Aâ‚..Bâ‚, g (x, Bâ‚‚)) - âˆ« (x : â„) in Aâ‚..Bâ‚, g (x, Aâ‚‚)) + âˆ« (y : â„) in Aâ‚‚..Bâ‚‚, F (Bâ‚, y)) - âˆ« (y : â„) in Aâ‚‚..Bâ‚‚, F (Aâ‚, y)
{Î± : Type u_1} [PartialOrder Î±] {F : Î± â†’ Î±} {P : Î± â†’ Prop} {hF : âˆ€ (x : Î±), x â‰¤ F x} {hfp : âˆ€ (x : Î±), P (F x)} {hmin : âˆ€ â¦ƒx y : Î±â¦„, x â‰¤ y â†’ P y â†’ F x â‰¤ y} {x : Î±} (hx : P x) : x âˆˆ (Closure_operator.Mkâ‚ƒ F P hF hfp hmin).IsClosed
{C : Type uâ‚} [CategoryTheory.Category C] {xâ‚â‚ xâ‚â‚‚ xâ‚â‚ƒ xâ‚‚â‚ xâ‚‚â‚‚ xâ‚‚â‚ƒ : C} {hâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚â‚‚} {hâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚â‚ƒ} {hâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚‚â‚‚} {hâ‚‚â‚‚ : xâ‚‚â‚‚ âŸ¶ xâ‚‚â‚ƒ} {vâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚‚â‚} {vâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚‚â‚‚} {vâ‚â‚ƒ : xâ‚â‚ƒ âŸ¶ xâ‚‚â‚ƒ} (S : CategoryTheory.IsPushout (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)) (P : hâ‚â‚‚ â‰« vâ‚â‚ƒ = vâ‚â‚‚ â‰« hâ‚‚â‚‚) (t : CategoryTheory.IsPushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) : CategoryTheory.IsPushout hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [InnerProductSpace ð•œ G] [CompleteSpace E] [CompleteSpace G] [CompleteSpace F] (A : F â†’L[ð•œ] G) (B : E â†’L[ð•œ] F) : â‡‘Continuous_LinearMap.Adjoint (A.Comp B) = (â‡‘Continuous_LinearMap.Adjoint B).Comp (â‡‘Continuous_LinearMap.Adjoint A)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.Fin_Category J] (F : J â¥¤ C) : Nonempty (CategoryTheory.Limits.Cone F)
{Î± : Type u_1} {P : Finset Î± â†’ Prop} [DecidableEq Î±] (S : Finset Î±) (hâ‚ : P âˆ…) (hâ‚‚ : âˆ€ â¦ƒA : Î±â¦„ {S : Finset Î±}, A âˆ‰ S â†’ P S â†’ P (HasInsert.Insert A S)) : P S
{S : â„} (h : 0 < S) : MeasureTheory.IntegrableOn (Î» (x : â„), Real.Exp (-x) * x ^ (S - 1)) (set.ioi 0) MeasureTheory.MeasureSpace.Volume
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedSpace ð•œ E] [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ G} {C : â„} {S : set E} {x y : E} (hF : DifferentiableOn ð•œ F S) (bound : âˆ€ (x : E), x âˆˆ S â†’ âˆ¥fderiv_within ð•œ F S xâˆ¥ â‰¤ C) (hs : Convex â„ S) (xs : x âˆˆ S) (ys : y âˆˆ S) : âˆ¥F y - F xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{Î± : Type u_2} [subtraction_Monoid Î±] {A : Î±} : Even A â†’ Even (-A)
{R : Type u} {A : Type W} [CommSemiring R] [Semiring A] [Algebra R A] (S : R) (x y : A) : x * S â€¢ y = S â€¢ (x * y)
{C : Type u} [CategoryTheory.Category C] {Fâ‚ Fâ‚‚ : Cáµ’áµ– â¥¤ Type v} (Î± : Fâ‚ âŸ¶ Fâ‚‚) : (CategoryTheory.Category_of_Elements.Map Î±).Op â‹™ CategoryTheory.Category_of_Elements.to_CostructuredArrow Fâ‚‚ = CategoryTheory.Category_of_Elements.to_CostructuredArrow Fâ‚ â‹™ CategoryTheory.CostructuredArrow.Map Î±
{Î± : Type u} {L : List (Î± Ã— Bool)} [DecidableEq Î±] : free_Group.reduce (free_Group.reduce L) = free_Group.reduce L
{R : Type u} {A : R} [Semiring R] {P : Polynomial R} (h : P.leading_Coeff * A â‰  0) : (P * â‡‘Polynomial.C A).Nat_degree = P.Nat_degree
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] [CategoryTheory.Limits.HasLimits_of_shape J C] (R : D â¥¤ C) [CategoryTheory.Reflective R] : CategoryTheory.Limits.HasLimits_of_shape J D
{R : Type u_1} [CommRing R] (P : Ideal (Polynomial R)) : ((Ideal.Quotient.Mk (Ideal.Map (Polynomial.Map_Ring_hom (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P))) P)).Comp Polynomial.C).Comp (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P)) = ((Ideal.Map (Polynomial.Map_Ring_hom (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P))) P).QuotientMap (Polynomial.Map_Ring_hom (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P))) Ideal.LE_comap_Map).Comp ((Ideal.Quotient.Mk P).Comp Polynomial.C)
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {F' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : F' =O[l] g' â†’ ((Î» (x : Î±), âˆ¥F' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{Î± : Type u_1} [Preorder Î±] {A B : Î±} : A â©¿ B â†’ â‡‘order_dual.to_dual B â©¿ â‡‘order_dual.to_dual A
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [UniformSpace Î±] [UniformSpace Î²] [LocallyCompactSpace Î±] [CompactSpace Î²] [SeparatedSpace Î²] [UniformSpace Î³] {F : Î± â†’ Î² â†’ Î³} {x : Î±} {U : set Î±} (hxU : U âˆˆ nhds x) (hU : IsSeparated U) (h : Continuous_on â†¿F (U Ã—Ë¢ set.Univ)) : TendstoUniformly F (F x) (nhds x)
{A : â„} {l : Filter â„} {F F' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhds A, HasDerivAt F (F' x) x) (hgg' : âˆ€á¶  (x : â„) in nhds A, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhds A, g' x â‰  0) (hfa : Filter.Tendsto F (nhds A) (nhds 0)) (hga : Filter.Tendsto g (nhds A) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), F' x / g' x) (nhds A) l) : Filter.Tendsto (Î» (x : â„), F x / g x) (nhds_within A (set.Univ  {A})) l
{P : â„} : Summable (Î» (n : â„•), (â†‘n ^ P)â»Â¹) â†” 1 < P
(x : Pgame) : (x * 1).Equiv x
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {F : Filter Î±} {g : Filter Î²} {m : Î± â†’ Î²' â†’ Î³} {n : Î² â†’ Î²'} {m' : Î± â†’ Î² â†’ Î´} {n' : Î´ â†’ Î³} (h_Right_comm : âˆ€ (A : Î±) (B : Î²), m A (n B) = n' (m' A B)) : Filter.Mapâ‚‚ m F (Filter.Map n g) = Filter.Map n' (Filter.Mapâ‚‚ m' F g)
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} : Emetric.diam {x} = 0
(R : Type u_1) {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsArtinian_Ring R] {A : set m} (hA : A.Finite) : IsArtinian R â†¥(Submodule.Span R A)
{v : Type u_1} [InnerProductSpace â„ v] {x : v} (hx : x â‰  0) : InnerProductGeometry.angle x x = 0
(P n : â„•) : WittVector.IsPoly P (Î» (R : Type u_1) (_Rcr : CommRing R), witt_Vector.init n)
{R : Type u} {L : Type v} [CommRing R] [lie_Ring L] [lie_Algebra R L] (m : Type W) [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] [lie_Algebra.IsNilpotent R L] [lie_module.IsNilpotent R L m] : lie_module.weight_Space m 0 = âŠ¤
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : bounded_Continuous_Function x â„) (e : C(x, Y)) (hE : IsClosed_Embedding â‡‘e) : âˆƒ (g : bounded_Continuous_Function Y â„), âˆ¥gâˆ¥ â‰¤ âˆ¥Fâˆ¥ / 3 âˆ§ HasDist.dist (g.Comp_Continuous e) F â‰¤ 2 / 3 * âˆ¥Fâˆ¥
{C : Type u} [CategoryTheory.Category C] (P q : C) [CategoryTheory.Limits.HasBinaryProduct P q] [CategoryTheory.Limits.HasBinaryProduct q P] : (CategoryTheory.Limits.Prod.braiding P q).hom â‰« (CategoryTheory.Limits.Prod.braiding q P).hom = ðŸ™ (P â¨¯ q)
{Î± : Type u_1} {Î² : Type u_2} (rÎ± : Î± â†’ Î± â†’ Prop) (rÎ² : Î² â†’ Î² â†’ Prop) : Prod.rprod rÎ± rÎ² â‰¤ Relation.TransGen (Relation.Game_Add rÎ± rÎ²)
{E : Type u_3} [semi_NormedGroup E] : Filter.Tendsto HasNeg.Neg (Filter.comap HasNorm.norm Filter.at_top) (Filter.comap HasNorm.norm Filter.at_top)
{Î± : Type u} : Nonempty (Field Î±) â†” Prime_Pow (Cardinal.Mk Î±)
(x : Pgame) : (x * 0).Equiv 0
{Î± : Type u_1} {m : Type u_5} {G : Type u_9} [Group G] [MulAction G Î±] [AddCommMonoid m] (g : G) (F : Î± â†’â‚€ m) (A : Î±) : â‡‘(g â€¢ F) A = â‡‘F (gâ»Â¹ â€¢ A)
 : âˆ€á¶  (x : â„) in residual â„, Liouville x
{S : Type u_1} [Add_Semigroup S] {A B C : S} (hac : Add_Commute A C) (hbc : Add_Commute B C) : Add_Commute (A + B) C
{Î¹ : Type u_1} {ð•œ : Type u_2} [_R_or_C ð•œ] {E : Type u_3} [InnerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), InnerProductSpace ð•œ (G i)] {v : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ v) [âˆ€ (i : Î¹), CompleteSpace (G i)] (hV' : (â¨† (i : Î¹), (v i).to_LinearMap.Range).topological_Closure = âŠ¤) (Wâ‚€ : Î â‚€ (i : Î¹), G i) : â‡‘((hV.Linear_Isometry_Equiv hV').Symm) (Wâ‚€.Sum (Lp.single 2)) = Wâ‚€.Sum (Î» (i : Î¹), â‡‘(v i))
{Î± : sort u_1} {Î² : sort u_2} {Sâ‚ : Setoid Î±} {Sâ‚‚ : Setoid Î²} {P : Quotient Sâ‚ â†’ Quotient Sâ‚‚ â†’ Prop} (qâ‚ : Quotient Sâ‚) (qâ‚‚ : Quotient Sâ‚‚) (h : âˆ€ (Aâ‚ : Î±) (Aâ‚‚ : Î²), P (Quotient.Mk' Aâ‚) (Quotient.Mk' Aâ‚‚)) : P qâ‚ qâ‚‚
(ð•œ : Type v) [_R_or_C ð•œ] {E : Type u} [NormedGroup E] [NormedSpace ð•œ E] {x y : E} : x = y â†” âˆ€ (g : NormedSpace.dual ð•œ E), â‡‘g x = â‡‘g y
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (u : E) {v : E} (hv : HasInner.inner v u = 0) : v âˆˆ (Submodule.Span ð•œ {u})á—®
(x : â„‚) : HasStrictDerivAt Complex.cos (-Complex.sin x) x
(u : â„• â†’ â„) (l : â„) (hmono : Monotone u) (C : â„• â†’ â„) (cone : âˆ€ (k : â„•), 1 < C k) (clim : Filter.Tendsto C Filter.at_top (nhds 1)) (hc : âˆ€ (k : â„•), Filter.Tendsto (Î» (n : â„•), u âŒŠC k ^ nâŒ‹â‚Š / â†‘âŒŠC k ^ nâŒ‹â‚Š) Filter.at_top (nhds l)) : Filter.Tendsto (Î» (n : â„•), u n / â†‘n) Filter.at_top (nhds l)
{E : Type u_1} [AddCommGroup E] [HasNorm E] (C : NormedGroup.core E) : semi_NormedGroup.core E
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {S : set Î±} {P : Filter Î¹} [TopologicalSpace Î±] (h : TendstoUniformlyOn F F P S) (hc : âˆ€á¶  (n : Î¹) in P, Continuous_on (F n) S) [P.Ne_IsBot] : Continuous_on F S
{R : Type u_4} {S : Type u_5} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R â‰ƒ+* S) : â†‘â†‘F = â†‘F
{n m : SimplexCategory {F : n âŸ¶ m} : CategoryTheory.Epi F â†” Function.Surjective â‡‘(SimplexCategory.hom.to_order_hom F)
{Î± : Type u_2} [has_Add Î±] {A : Î±} : Even A â†’ (âˆƒ (B : Î±), A = bit0 B)
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 P2 : P) (g : G) : P1 -áµ¥ (g +áµ¥ P2) = P1 -áµ¥ P2 - g
{Î± : Type u} [PseudoEmetricSpace Î±] {S t u : set Î±} : Emetric.Hausdorff_edist S u â‰¤ Emetric.Hausdorff_edist S t + Emetric.Hausdorff_edist t u
{Î± : Type u_1} [PseudoMetricSpace Î±] (r C : â„) (hr : r < 1) {F : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasDist.dist (F n) (F (n + 1)) â‰¤ C * r ^ n) : Cauchy_Seq F
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore Î¹ B F) : Continuous Z.Proj
{ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedGroup G] [NormedSpace ð•œ G] {F : ð•œ â†’ G} {S : set ð•œ} {C : Nnreal} (hF : âˆ€ (x : ð•œ), x âˆˆ S â†’ Differentiable_at ð•œ F x) (bound : âˆ€ (x : ð•œ), x âˆˆ S â†’ âˆ¥deriv F xâˆ¥â‚Š â‰¤ C) (hs : Convex â„ S) : LipschitzOnWith C F S
{G : Type u_1} [Group G] (tG : Monoid._torsion G) (h : Subgroup G) : Monoid._torsion â†¥h
{P n k : â„•} (hn : 0 < n) : P ^ â‡‘((n.choose k).factorization) P â‰¤ n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] {Y Z : C} (F : Y âŸ¶ Z) (P : CategoryTheory.ProjectiveResolution Y) (q : CategoryTheory.ProjectiveResolution Z) : CategoryTheory.ProjectiveResolution.Lift_F_One F P q â‰« q.Complex.D 1 0 = P.Complex.D 1 0 â‰« CategoryTheory.ProjectiveResolution.Lift_F_Zero F P q
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (i : Fin r âŠ• Unit) {k : â„•} (hk : k â‰¤ r) : m.Mul (List.take k (Matrix.Pivot.List_transvec_row m)).Prod i (Sum.inr_ ()) = m i (Sum.inr_ ())
{Î¹ : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {la la' : Filter â„} {LT : Filter Î¹} {A B : â„} {u v : Î¹ â†’ â„} [IntervalIntegral.FTC_Filter A la la'] (hab : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F la' MeasureTheory.MeasureSpace.Volume) (hF : Filter.Tendsto F (la' âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) (hu : Filter.Tendsto u LT la) (hv : Filter.Tendsto v LT la) : (Î» (t : Î¹), ((âˆ« (x : â„) in v t..B, F x) - âˆ« (x : â„) in u t..B, F x) + (v t - u t) â€¢ C) =o[LT] (v - u)
{A : Nnreal} : Add_LE_cancellable â†‘A
{Î± : Type u} [HasSsubset Î±] [IsIrrefl Î± HasSsubset.Ssubset] {A B : Î±} : A âŠ‚ B â†’ B â‰  A
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [CompleteSpace E] (v : E) : â‡‘(Orthogonal_projection (Submodule.Span ð•œ {v})á—®) v = 0
{Î± : Type} {F g : (Î± â†’ â„•) â†’ â„•} (df : Dioph.DiophFn F) (dg : Dioph.DiophFn g) : Dioph.DiophFn (Î» (v : Î± â†’ â„•), F v ^ g v)
(R : Type u) (L : Type v) [CommRing R] [lie_Ring L] [lie_Algebra R L] [lie_Algebra._semisimple R L] [h : IsLieAbelian L] : Subsingleton L
{G : Type u_3} [AddGroup G] (P : Add_Subgroup G) : P.fg â†” P.to_Add_Submonoid.fg
{R : Type u_1} [CommRing R] (u v W : Fin 3 â†’ R) : Matrix.dot_Product u (â‡‘(â‡‘CrossProduct v) W) = Matrix.dot_Product v (â‡‘(â‡‘CrossProduct W) u)
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (G : D â¥¤ C) [CategoryTheory.IsRightAdjoint G] : CategoryTheory.solution_set_condition G
{R : Type u_1} [CommSemiring R] (x y : R) (n : â„•) : (x + y) ^ n = (Finset.Range (n + 1)).Sum (Î» (m : â„•), x ^ m * y ^ (n - m) * â†‘(n.choose m))
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {v : E} (hv : v âˆˆ Ká—®) : â‡‘(reflection K) v = -v
{B m : â„•} : m < (B + 2) ^ ((B + 2).digits m).length
{Î± : Type u_1} {r : Setoid Î±} : âˆ… âˆ‰ r.Classes
{G : Type u_1} {h : Type u_2} [Group G] {N : Subgroup G} [Group h] {F : G â†’* h} (hF : Function.Surjective â‡‘F) (hN : N = F.Ker) (tN : Monoid._torsion â†¥N) : Monoid._torsion h â†” Monoid._torsion G
{P : â„•} (hp : 1 < P) : padic_val_Nat P P = 1
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : F =O[l] g â†” âˆƒ (C : â„), âˆ€á¶  (x : Î±) in l, âˆ¥F xâˆ¥ â‰¤ C * âˆ¥g xâˆ¥
{P n k : â„•} : â‡‘((n.choose k).factorization) P â‰¤ Nat.log P n
{R : Type u_1} [Mul_Zero_class R] (h : IsRightRegular 0) : Subsingleton R
{Î± : Type u_1} {S : Multiset Î±} : S.Nodup â†’ S.powerset.Nodup
{Î± : Type u_1} {m : Type u_5} {R : Type u_11} {S : Type u_12} [has_Zero m] [CommSemiring R] [CommSemiring S] (h : R â†’+* S) (F : Î± â†’â‚€ m) (g : Î± â†’ m â†’ R) : â‡‘h (F.Prod g) = F.Prod (Î» (A : Î±) (B : m), â‡‘h (g A B))
{G : Type u_6} {h : Type u_7} {F : Type u_8} [Group G] [division_Monoid h] [Monoid_hom_class F G h] (F : F) (A : G) : â‡‘F Aâ»Â¹ = (â‡‘F A)â»Â¹
{Î± : Type u} {Î² : Type v} [CommSemiring Î²] {Î´ : Î± â†’ Type u_1} [DecidableEq Î±] [Î  (A : Î±), DecidableEq (Î´ A)] {S : Finset Î±} {t : Î  (A : Î±), Finset (Î´ A)} {F : Î  (A : Î±), Î´ A â†’ Î²} : S.Prod (Î» (A : Î±), (t A).Sum (Î» (B : Î´ A), F A B)) = (S.Pi t).Sum (Î» (P : Î  (A : Î±), A âˆˆ S â†’ Î´ A), S.attach.Prod (Î» (x : {x // x âˆˆ S}), F x.val (P x.val _)))
(R : Type u) [CommSemiring R] {m : Type v} [AddCommMonoid m] [module R m] (g : m â†’â‚—[R] m) (F : (m â†’â‚—[R] m)Ë£) : â‡‘(LinearMap.trace R m) (â†‘F * g * â†‘Fâ»Â¹) = â‡‘(LinearMap.trace R m) g
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G h : C â¥¤ D} (e : F â‰… G) (e' : G â‰… h) (hF : CategoryTheory.IsEquivalence F) : CategoryTheory.IsEquivalence.of_iso e' (CategoryTheory.IsEquivalence.of_iso e hF) = CategoryTheory.IsEquivalence.of_iso (e â‰ªâ‰« e') hF
{J : Type v} [CategoryTheory.SmallCategory J] {F : J â¥¤ Type (max v u)} (x : CategoryTheory.Limits.Colimit F) : âˆƒ (j : J) (y : F.obj j), CategoryTheory.Limits.ColimitÎ¹ F j y = x
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ Mon_) [CategoryTheory.IsFiltered J] {x x' y : Î£ (j : J), â†¥(F.obj j)} (hxx' : CategoryTheory.Limits.types.filtered_Colimit.Rel (F â‹™ CategoryTheory.Forget Mon_) x x') : Mon_.FilteredColimits.Colimit_Mul_aux F x y = Mon_.FilteredColimits.Colimit_Mul_aux F x' y
{Î± : Type u} [AddGroup Î±] [LinearOrder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] (A : Î±) : LinearOrder.max A 0 - LinearOrder.max (-A) 0 = A
{A B : â„•} (hab : A.IsCoprime B) : (A * B).factorization = A.factorization + B.factorization
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (P : Î¹ â†’ P) : Finset.centroid k S P = â‡‘(S.affine_combination P) (Finset.centroid_weights k S)
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_4} [Fintype Î¹] [DecidableEq Î¹] [Nontrivial R] (e : Basis Î¹ R m) (W : Î¹ â†’ RË£) : (e.units_Smul W).Orientation = (Finset.Univ.Prod (Î» (i : Î¹), W i))â»Â¹ â€¢ e.Orientation
(n : â„•) (R : Type u_1) [CommRing R] [IsDomain R] : (Polynomial.cyclotomic' n R).roots = (primitive_roots n R).val
{m : Type u_1} {Î¹ : Type u_2} {R : Type u_3} [DecidableEq m] [AddMonoid m] [DecidableEq Î¹] [AddMonoid Î¹] [CommSemiring R] (F : m â†’+ Î¹) : direct_Sum._internal (AddMonoid_Algebra.grade_by R â‡‘F)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} : Antitone F â†’ Monotone (â‡‘order_dual.to_dual âˆ˜ F)
{Î± : Type u_1} [TopologicalSpace Î±] [non_unital_non_assoc_Ring Î±] [topological_Ring Î±] (x : Î±) : Continuous â‡‘(AddMonoid_hom.Mul_Right x)
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {F : â„‚ â†’ E} (hD : Diff_Cont_on_cl â„‚ F (set.ioi 0 Ã—â„‚ set.ioi 0)) (hB : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.ioi 0 Ã—â„‚ set.ioi 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ F â†‘x = 0) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ F (â†‘x * Complex.i) = 0) : set.Eq_on F 0 {z : â„‚ | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] (x : C) : CategoryTheory.IsPushout 0 (ðŸ™ x) 0 0
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [NormedGroup F] [NormedSpace â„ F] {S : set E} (S_conv : Convex â„ S) {F : E â†’ F} {F' : E â†’ (E â†’L[â„] F)} {F'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€ (x : E), x âˆˆ Interior S â†’ HasFderivAt F (F' x) x) {x : E} (xs : x âˆˆ S) (hx : HasFderivWithinAt F' F'' (Interior S) x) {v W : E} (hv : x + v âˆˆ Interior S) (hw : x + v + W âˆˆ Interior S) : (Î» (h : â„), F (x + h â€¢ v + h â€¢ W) - F (x + h â€¢ v) - h â€¢ â‡‘(F' x) W - h ^ 2 â€¢ â‡‘(â‡‘F'' v) W - (h ^ 2 / 2) â€¢ â‡‘(â‡‘F'' W) W) =o[nhds_within 0 (set.ioi 0)] Î» (h : â„), h ^ 2
{h : Type u_1} [TopologicalSpace h] {e : LocalHomeomorph h h} : e âˆˆ ChartedSpace.Atlas h h â†” e = LocalHomeomorph.refl h
{R : Type u_1} {E : Type u_2} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (S : set E) : â‡‘(Convex_hull R) S = â‹ƒ (t : Finset E) (W : â†‘t âŠ† S), â‡‘(Convex_hull R) â†‘t
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.has_Finite_Limits C] : CategoryTheory.Limits.has_Finite_wide_pullbacks C
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ Finset.Nat.antidiagonal n â†” x.fst + x.Snd = n
{P : â„•} [hp : Fact (Nat.Prime P)] {R : Type u_1} [CommRing R] {S : Type u_2} [Semiring S] {F : Î  (k : â„•), S â†’+* truncated_witt_Vector P k R} (F_compat : âˆ€ (kâ‚ kâ‚‚ : â„•) (hk : kâ‚ â‰¤ kâ‚‚), (truncated_witt_Vector.truncate hk).Comp (F kâ‚‚) = F kâ‚) (g : S â†’+* witt_Vector P R) (g_compat : âˆ€ (k : â„•), (witt_Vector.truncate k).Comp g = F k) : witt_Vector.Lift (Î» (kâ‚‚ : â„•), F kâ‚‚) F_compat = g
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {A B : â„} {F F' : â„ â†’ â„} {g : â„ â†’ E} (h : âˆ€ (x : â„), x âˆˆ set.Interval A B â†’ HasDerivAt F (F' x) x) (h' : Continuous_on F' (set.Interval A B)) (hg : Continuous g) : âˆ« (x : â„) in A..B, F' x â€¢ (g âˆ˜ F) x = âˆ« (x : â„) in F A..F B, g x
{k : Type u_1} {m : Type u_2} [Linear_ordered_Field k] [ordered_AddCommMonoid m] [MulAction_with_Zero k m] (hlt : âˆ€ â¦ƒA B : mâ¦„ â¦ƒC : kâ¦„, A < B â†’ 0 < C â†’ C â€¢ A â‰¤ C â€¢ B) : OrderedSmul k m
{Î³ : Type u_3} [tÎ³ : TopologicalSpace Î³] [PolishSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³] {Î² : Type u_4} [tÎ² : TopologicalSpace Î²] [t2_Space Î²] [MeasurableSpace Î²] [BorelSpace Î²] {S : set Î³} {F : Î³ â†’ Î²} (hs : Measurable_set S) (F_Cont : Continuous_on F S) (F_inj : set.inj_on F S) : Measurable_Embedding (S.Restrict F)
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) (h : (Multiset.Map (Î» (F : Polynomial R), F.leading_Coeff) t).Prod â‰  0) : t.Prod.Nat_degree = (Multiset.Map (Î» (F : Polynomial R), F.Nat_degree) t).Sum
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {v : Type uâ‚ƒ} {P : Type uâ‚„} [AddCommGroup v] [AddTorsor v P] [Ring k] [module k v] (B : affine_Basis Î¹ k P) {Î¹' : Type u_1} [Fintype Î¹'] [Fintype Î¹] [DecidableEq Î¹] [Nontrivial k] (P : Î¹' â†’ P) {A : Matrix Î¹ Î¹' k} (hA : A.Mul (B.to_Matrix P) = 1) : affine_Span k (set.Range P) = âŠ¤
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {Î¹ : Type W} {S : set Î¹} (h : Basis â†¥S K v) (hs : S.Finite) : Finite_dimensional K v
{Î± : Type u_1} [conditionally_CompleteLattice Î±] (A : Î±) : HasInf.Inf {A} = A
(P : â„•) [hp : Fact (Nat.Prime P)] {k : Type u_1} [CommRing k] [Char_P k P] (n : â„•) (x y : witt_Vector P k) : witt_Vector.peval (witt_Vector.Poly_of_interest P n) ![Î» (i : â„•), x.Coeff i, Î» (i : â„•), y.Coeff i] = (x * y).Coeff (n + 1) - y.Coeff (n + 1) * x.Coeff 0 ^ P ^ (n + 1) - x.Coeff (n + 1) * y.Coeff 0 ^ P ^ (n + 1)
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {S : set â„‚} {F : â„‚ â†’ E} {z : â„‚} (hD : DifferentiableOn â„‚ F S) (hz : S âˆˆ nhds z) : AnalyticAt â„‚ F z
{Î± : Type u} [TopologicalSpace Î±] [t2_Space Î±] {S : set Î±} (hs : IsCompact S) {Î¹ : Type u_1} (t : Finset Î¹) (U : Î¹ â†’ set Î±) (hU : âˆ€ (i : Î¹), i âˆˆ t â†’ IsOpen (U i)) (hsC : S âŠ† â‹ƒ (i : Î¹) (h : i âˆˆ t), U i) : âˆƒ (K : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), IsCompact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ S = â‹ƒ (i : Î¹) (h : i âˆˆ t), K i
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : Convex_on ð•œ S F) {x y z : E} (hx : x âˆˆ S) (hy : y âˆˆ S) (hz : z âˆˆ Segment ð•œ x y) : F z â‰¤ LinearOrder.max (F x) (F y)
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {R : â„} {C W : â„‚} {F : â„‚ â†’ E} (h : Diff_Cont_on_cl â„‚ F (Metric.Ball C R)) (hw : W âˆˆ Metric.Ball C R) : âˆ® (z : â„‚) in C(C, R), (z - W)â»Â¹ â€¢ F z = (2 * â†‘Real.Pi * Complex.i) â€¢ F W
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P âŸ¶ q) : Function.Injective â‡‘F â†’ âˆ€ (A : â†¥P), â‡‘F A = 0 â†’ A = 0
{ð•œ : Type u} {A : Type v} [Field ð•œ] [Ring A] [Algebra ð•œ A] [Nontrivial A] : Spectrum ð•œ 0 = {0}
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommGroup Î²] [HasScalar ð•œ E] [module ð•œ Î²] {S : set E} {F : E â†’ Î²} : strict_Convex_on ð•œ S (-F) â†” strict_ConcaveOn ð•œ S F
{E : Type u_2} {ð•œ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] {S : set E} (hs : Convex ð•œ S) {A B : ð•œ} (ha : 0 â‰¤ A) (hb : 0 < B) (hab : A + B = 1) : A â€¢ Closure S + B â€¢ Interior S âŠ† Interior S
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] : (EuclideanGeometry.reflection S).Symm = EuclideanGeometry.reflection S
{ð•œ : Type u_1} {E : Type u_2} [semi_NormedRing ð•œ] [HasScalar ð•œ E] [has_Zero E] [TopologicalSpace E] {Sâ‚ Sâ‚‚ : set E} (h : Sâ‚ âŠ† Sâ‚‚) (hsâ‚‚ : Bornology._vonN_bounded ð•œ Sâ‚‚) : Bornology._vonN_bounded ð•œ Sâ‚
{R : Type u_1} [Mul_Zero_class R] : IsRegular 0 â†” Subsingleton R
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : F =o[l] g â†” âˆ€ â¦ƒC : â„â¦„, 0 < C â†’ Asymptotics._O_with C l F g
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} (h_Mono : StrictMono_on F S) (hs : S âˆˆ nhds_within A (set.Iic A)) (hfs : set.surj_on F S (set.Iio (F A))) : Continuous_within_at F (set.Iic A) A
{x Y : top} {F g : C(â†¥x, â†¥Y)} (h : F.Homotopy g) {xâ‚€ xâ‚ : â†¥x} (P : FundamentalGroupoid.from_top xâ‚€ âŸ¶ FundamentalGroupoid.from_top xâ‚) : (FundamentalGroupoid.FundamentalGroupoid_Functor.Map g).Map P = Continuous_Map.Homotopy.hcast _ â‰« (FundamentalGroupoid.FundamentalGroupoid_Functor.Map h.ulift_Map).Map (Continuous_Map.Homotopy.Prod_to_Prod_top_i (ðŸ™ {down := 1}) P) â‰« Continuous_Map.Homotopy.hcast _
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (Î¸ : Real.Angle) : hb.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
{R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [Semiring R] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [semi_NormedGroup E] [semi_NormedGroup Eâ‚‚] [module R E] [module Râ‚‚ Eâ‚‚] {Î¹ : Type u_3} (B : Basis Î¹ R E) {Fâ‚ Fâ‚‚ : E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚} (h : âˆ€ (i : Î¹), â‡‘Fâ‚ (â‡‘B i) = â‡‘Fâ‚‚ (â‡‘B i)) : Fâ‚ = Fâ‚‚
{G : Type u_4} [NormedGroup G] [NormedSpace â„ G] {S : set G} {x y : G} (h : IsOpen_Segment â„ x y âŠ† S) : y - x âˆˆ TangentConeAt â„ S x
{Î± : Type u} [SemilatticeSup Î±] [OrderBot Î±] (x y z : Î±) (F : z âŸ¶ x) (g : z âŸ¶ y) : CategoryTheory.Limits.pushout F g = x âŠ” y
{m : Type u_1} [has_Mul m] (C : Con m) : Con_gen â‡‘C = C
{K : Type u_4} {v : Type u} [DivisionRing K] [AddCommGroup v] [module K v] {x : v} {n : â„•} {v : Fin n â†’ v} (hv : LinearIndependent K v) (hx : x âˆ‰ Submodule.Span K (set.Range v)) : LinearIndependent K (Fin.Cons x v)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (lâ‚ lâ‚‚ : Î¹ â†’â‚€ ð•œ) : HasInner.inner (â‡‘(Finsupp.Total Î¹ E ð•œ v) lâ‚) (â‡‘(Finsupp.Total Î¹ E ð•œ v) lâ‚‚) = lâ‚.Sum (Î» (i : Î¹) (y : ð•œ), â‡‘(Star_Ring_end ð•œ) y * â‡‘lâ‚‚ i)
{Î± : Type u_1} [has_Add Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B C D : Î±} (hâ‚ : A < B) (hâ‚‚ : C < D) : A + C < B + D
(n : â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] : IsCyclotomicExtension {n} A B â†” (âˆƒ (r : B), â‡‘(Polynomial.aeval r) (Polynomial.cyclotomic â†‘n A) = 0) âˆ§ âˆ€ (x : B), x âˆˆ Algebra.Adjoin A {B : B | B ^ â†‘n = 1}
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} {A : Î±} : (âˆƒá¶  (x : Î±) in nhds A, x âˆˆ S) â†’ A âˆˆ Closure S
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] : CategoryTheory.Limits.has_Finite_products C
{Î± : Type} {D : â„•} {ds : List â„•} (x y : Holor Î± (D :: ds)) (h : x.Slice = y.Slice) : x = y
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] [Finite_dimensional â„ v] (hD : Finite_dimensional.finrank â„ v = 2) {Câ‚ Câ‚‚ Pâ‚ Pâ‚‚ P : P} {râ‚ râ‚‚ : â„} (hc : Câ‚ â‰  Câ‚‚) (hp : Pâ‚ â‰  Pâ‚‚) (hpâ‚Câ‚ : HasDist.dist Pâ‚ Câ‚ = râ‚) (hpâ‚‚Câ‚ : HasDist.dist Pâ‚‚ Câ‚ = râ‚) (hpcâ‚ : HasDist.dist P Câ‚ = râ‚) (hpâ‚Câ‚‚ : HasDist.dist Pâ‚ Câ‚‚ = râ‚‚) (hpâ‚‚Câ‚‚ : HasDist.dist Pâ‚‚ Câ‚‚ = râ‚‚) (hpcâ‚‚ : HasDist.dist P Câ‚‚ = râ‚‚) : P = Pâ‚ âˆ¨ P = Pâ‚‚
{ð•œ : Type u_1} [NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Subspace ð•œ E} (hFc : IsClosed â†‘F) (hF : âˆƒ (x : E), x âˆ‰ F) {r : â„} (hr : r < 1) : âˆƒ (xâ‚€ : E), xâ‚€ âˆ‰ F âˆ§ âˆ€ (y : E), y âˆˆ F â†’ r * âˆ¥xâ‚€âˆ¥ â‰¤ âˆ¥xâ‚€ - yâˆ¥
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} {ps : set P} (h : ps âŠ† â†‘S) [Nonempty â†¥S] {n : â„•} [Finite_dimensional â„ â†¥(S.direction)] (hD : Finite_dimensional.finrank â„ â†¥(S.direction) = n) (hc : EuclideanGeometry.Cospherical ps) : âˆƒ (r : â„), âˆ€ (sx : Affine.Simplex â„ P n), set.Range sx.points âŠ† ps â†’ sx.circumradius = r
{Î± : Type u_1} [has_Mul Î±] [has_LE Î±] [ContravariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B C : Î±} (bc : A * B â‰¤ A * C) : B â‰¤ C
{C : Type u} [CategoryTheory.Category C] {x Y : C} (J : CategoryTheory.GrothendieckTopology C) (F : Y âŸ¶ x) (S : CategoryTheory.Sieve x) (h : J.Covers S F) {Z : C} (g : Z âŸ¶ Y) : J.Covers S (g â‰« F)
{Î± : Type u_1} [AddCommMonoid Î±] {Î² : Type u_2} [Fintype Î²] (S : set Î²) [Decidable_Pred (Î» (_x : Î²), _x âˆˆ S)] (F : Î² â†’ Î±) (g : â†¥S â†’ Î±) (W : âˆ€ (x : Î²) (h : x âˆˆ S), F x = g âŸ¨x, hâŸ©) (W' : âˆ€ (x : Î²), x âˆ‰ S â†’ F x = 0) : Finset.Univ.Sum F = Finset.Univ.Sum g
{K : Type u_1} {S : Type u_2} [Field K] [CommRing S] [Algebra K S] (h : power_Basis K S) : (â‡‘(Algebra.Left_Mul_Matrix h.Basis) h.gen).charpoly = minpoly K h.gen
(n : â„•) : n.Factors.to_Finset = Finset.Filter Nat.Prime n.divisors
(R : Type u_1) [CommSemiring R] (m : Type u_4) (N : Type u_5) [AddCommMonoid m] [AddCommMonoid N] [module R m] [module R N] : Submodule.Span R {t : TensorProduct R m N | âˆƒ (m : m) (n : N), m âŠ—â‚œ[R] n = t} = âŠ¤
{Î± : Type u} [PseudoMetricSpace Î±] : Metric.diam âˆ… = 0
{R : Type u} {S : Type v} [non_assoc_Semiring R] [non_assoc_Semiring S] {F g : R â†’+* S} {S : set R} (h : set.Eq_on â‡‘F â‡‘g S) : set.Eq_on â‡‘F â‡‘g â†‘(Subsemiring.Closure S)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace.IsSeparable_Space Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} (h : DenseRange F) (h' : Continuous F) : TopologicalSpace.IsSeparable_Space Î²
{P : â„•} [Fact (Nat.Prime P)] {A : Zmod P} (ha : A â‰  0) : A ^ (P - 1) = 1
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚} [CategoryTheory.Category K] [CategoryTheory.IsPreconnected J] (e : J â‰Œ K) : CategoryTheory.IsPreconnected K
{G : Type W} [TopologicalSpace G] [HasNeg G] [has_Add G] [has_Continuous_Add G] [has_Continuous_Neg G] : Continuous (Î» (g : G Ã— G), g.fst + g.Snd + -g.fst)
{Î± : Type u_1} [Preorder Î±] {S : set Î±} : S.Ord_connected â†” âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ x â‰¤ y â†’ set.icc x y âŠ† S
{G : Type u_1} [Group G] {k : set G} {P : Î  (x : G), x âˆˆ Subgroup.Closure k â†’ Prop} (Hs : âˆ€ (x : G) (h : x âˆˆ k), P x _) (h1 : P 1 _) (HMul : âˆ€ (x : G) (hx : x âˆˆ Subgroup.Closure k) (y : G) (hy : y âˆˆ Subgroup.Closure k), P x hx â†’ P y hy â†’ P (x * y) _) (Hinv : âˆ€ (x : G) (hx : x âˆˆ Subgroup.Closure k), P x hx â†’ P xâ»Â¹ _) {x : G} (hx : x âˆˆ Subgroup.Closure k) : P x hx
{K : Type u_4} [NormedField K] {Î¾ : K} : Summable (Î» (n : â„•), Î¾ ^ n) â†” âˆ¥Î¾âˆ¥ < 1
{R : Type u_1} {m : Type u_2} [CommRing R] [AddCommGroup m] [module R m] : Submodule.torsion R (m â§¸ Submodule.torsion R m) = âŠ¥
{K : Type u} [Field K] (S : Subfield K) {x y : K} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
{R : Type u} [Semiring R] {P : Type (max u v)} [AddCommMonoid P] [module R P] {m : Type (max u v)} [AddCommGroup m] [module R m] {N : Type u_1} [AddCommGroup N] [module R N] [h : module.projective R P] (F : m â†’â‚—[R] N) (g : P â†’â‚—[R] N) (hF : Function.Surjective â‡‘F) : âˆƒ (h : P â†’â‚—[R] m), F.Comp h = g
{Î± : Type u_1} [Linear_ordered_comm_Group Î±] {n : â„¤} {A B : Î±} (hn : n â‰  0) : A ^ n = B ^ n â†” A = B
{Î± : Type u_1} {m : Type u_3} {n : Type u_4} [NonUnitalSemiring Î±] [Star_Ring Î±] {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} : (Matrix.from_blocks A B C D)._hermitian â†” A._hermitian âˆ§ B.Conj_transpose = C âˆ§ C.Conj_transpose = B âˆ§ D._hermitian
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [AddZeroClass m] {F : Î± â†’ Î²} (hF : Function.Injective F) (vâ‚ vâ‚‚ : Î² â†’â‚€ m) : Finsupp.comap_IsDomain F (vâ‚ + vâ‚‚) _ = Finsupp.comap_IsDomain F vâ‚ _ + Finsupp.comap_IsDomain F vâ‚‚ _
{m : Type u_1} [has_Mul m] {C D : Con m} : C âŠ” D = Con_gen (Setoid.r âŠ” Setoid.r)
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {F' : F} {x : ð•œ} [PartialOrder ð•œ] : HasDerivWithinAt F F' (set.Iic x) x â†’ HasDerivWithinAt F F' (set.Iio x) x
(n : â„•) : â‡‘Multiset.Card (Multiset.Nat.antidiagonal n) = n + 1
{Î± : Type u_1} {Î² : Type u_2} {mÎ² : MeasurableSpace Î²} {m : MeasurableSpace Î±} (t : â„• â†’ set Î²) (t_Meas : âˆ€ (n : â„•), Measurable_set (t n)) (t_disj : Pairwise (Disjoint on t)) (g : â„• â†’ Î² â†’ Î±) (hg : âˆ€ (n : â„•), Measurable (g n)) : âˆƒ (F : Î² â†’ Î±), Measurable F âˆ§ âˆ€ (n : â„•) (x : Î²), x âˆˆ t n â†’ F x = g n x
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall F P x r) (h : â†‘r' < r) : TendstoUniformlyOn (Î» (n : â„•) (y : E), P.partial_Sum n y) (Î» (y : E), F (x + y)) Filter.at_top (Metric.Ball 0 â†‘r')
{Î± : sort u} {Î² : sort v} (e : Î± â‰ƒ Î²) : IsEmpty Î± â†” IsEmpty Î²
{m : Type u_1} [has_Add m] {C D : Add_Con m} : C âŠ” D = Add_Con_gen (Setoid.r âŠ” Setoid.r)
{R : Type u} [non_assoc_Semiring R] (m : Submonoid R) : m.Subsemiring_Closure = Subsemiring.Closure â†‘m
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] : _IsCompl K Ká—®
{Î± : sort u_1} {Î² : sort u_2} (F : Î± â†’ Î²) (P : Prop) [Decidable P] (A B : Î±) : F (Ite P A B) = Ite P (F A) (F B)
{A B : â„} {g' g : â„ â†’ â„} (hab : A â‰¤ B) (hcont : Continuous_on g (set.icc A B)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivWithinAt g (g' x) (set.ioi x) x) (g'Int : MeasureTheory.IntegrableOn g' (set.icc A B) MeasureTheory.MeasureSpace.Volume) : âˆ« (y : â„) in A..B, g' y = g B - g A
{P : â„•} (hp : 1 < P) : padic_norm P â†‘P = 1 / â†‘P
{R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [Semiring R] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} [RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] [RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] [semi_NormedGroup E] [semi_NormedGroup Eâ‚‚] [module R E] [module Râ‚‚ Eâ‚‚] {Î¹ : Type u_3} (B : Basis Î¹ R E) {Fâ‚ Fâ‚‚ : E â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚} (h : âˆ€ (i : Î¹), â‡‘Fâ‚ (â‡‘B i) = â‡‘Fâ‚‚ (â‡‘B i)) : Fâ‚ = Fâ‚‚
{n : â„•} (R : Type u_1) [Ring R] [Fact (0 < n)] : Coe âˆ˜ Zmod.val = Coe
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F Fâ‚ : E â†’ F} {n : WithTop â„•} {P : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n F P S) (hâ‚ : âˆ€ (x : E), x âˆˆ S â†’ Fâ‚ x = F x) : HasFtaylorSeriesUpToOn n Fâ‚ P S
{E : Type u_3} {F : Type u_4} [semi_NormedGroup E] [semi_NormedGroup F] (F : E â†’+ F) (C : â„) (h : âˆ€ (x : E), âˆ¥â‡‘F xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : LipschitzWith C.to_Nnreal â‡‘F
{C : Type uâ‚} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : CategoryTheory.Presieve.IsSheafFor P â‡‘S) {F : S.Functor âŸ¶ P} (t : CategoryTheory.yoneda.obj x âŸ¶ P) (ht : S.Functor_inclusion â‰« t = F) : t = h.extend F
{E : Type u_2} [semi_NormedGroup E] [NormedSpace â„ E] (S : set E) : Emetric.diam (â‡‘(Convex_hull â„) S) = Emetric.diam S
(P : set â†’ Prop) : Class.Iota P âˆˆ Class.Univ
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (m : m) : âˆ¥â‡‘(Quotient_AddGroup.Mk' S) mâˆ¥ = 0 â†” m âˆˆ Closure â†‘S
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {F F' : C â¥¤ D} (h : F â‰… F') {Y : D} (hY : Y âˆˆ F.EssImage) : Y âˆˆ F'.EssImage
{K : Type u_1} {L : Type u_2} {m : Type u_3} [Field K] [Field L] [Field m] [Algebra K L] [Algebra K m] {E1 E2 : intermediate_Field K L} (e : L â‰ƒâ‚[K] m) (h12 : E1 â‰¤ E2) : E1.Map e.to_AlgHom â‰¤ E2.Map e.to_AlgHom
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : F =O[l] g' â†’ (F =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} [Fintype Î¹] {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’ ð•œ) (i : Î¹) : HasInner.inner (Finset.Univ.Sum (Î» (i : Î¹), l i â€¢ v i)) (v i) = â‡‘(Star_Ring_end ð•œ) (l i)
{n : â„•} (hn : 2 â‰¤ n) : strict_Convex_on â„ (set.ici 0) (Î» (x : â„), x ^ n)
{R : Type u_1} {m : Type u_2} {P : Type u_3} [Ring R] [AddCommGroup m] [module R m] [AddCommGroup P] [module R P] (F : m â†’â‚—[R] P) {S : Submodule R m} (hs1 : (Submodule.Map F S).fg) (hs2 : (S âŠ“ F.Ker).fg) : S.fg
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {Î¹ : Type W} {P : Î¹ â†’ Submodule K v} (hp : CompleteLattice.Independent P) [Fintype {i // P i â‰  âŠ¥}] : Fintype.Card {i // P i â‰  âŠ¥} â‰¤ Finite_dimensional.finrank K v
{Î± : Type u_1} {Î² : Type u_2} [HasMem Î± Î²] {S t : Î²} {A : Î±} : A âˆˆ S â†’ A âˆ‰ t â†’ S â‰  t
{S : Type u_1} [has_Add S] {A B : S} (h : Add_Commute A B) : Add_Commute B A
{K : Type u_1} {L : Type u_2} {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [IsScalarTower K L A] (L_alg : Algebra.IsAlgebraic K L) (A_alg : Algebra.IsAlgebraic L A) : Algebra.IsAlgebraic K A
{Î± : Type u} : DenseRange has_pure.pure
{Î± : Type u} [Semiring Î±] {x y : Î±} (h : Commute x y) (n : â„•) : (Finset.Range n).Sum (Î» (i : â„•), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {E' : Type u_7} [InnerProductSpace ð•œ E'] (F : E â†’â‚—áµ¢[ð•œ] E') (x y : E) : HasInner.inner (â‡‘F x) (â‡‘F y) = HasInner.inner x y
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {S : set Y} (F : bounded_Continuous_Function â†¥S â„) (hs : IsClosed S) : âˆƒ (g : bounded_Continuous_Function Y â„), âˆ¥gâˆ¥ = âˆ¥Fâˆ¥ âˆ§ g.Restrict S = F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {x Y : C} [CategoryTheory.Simple x] {F : x âŸ¶ Y} [CategoryTheory.Epi F] (W : F â‰  0) : CategoryTheory.IsIso F
{m : Type u_3} [AddMonoid m] (l : List m) : (l.nth 0).get_or_else 0 + l.tail.Sum = l.Sum
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] : Continuous_Map.IsCompact_IsOpen = â¨… (S : set Î±) (hs : IsCompact S), TopologicalSpace.induced (Continuous_Map.Restrict S) Continuous_Map.IsCompact_IsOpen
{A : Type u_1} [NormedRing A] [normed_Algebra â„‚ A] [CompleteSpace A] [Star_Ring A] [cstar_Ring A] [Star_module â„‚ A] [Nontrivial A] (A : â†¥(self_Adjoint A)) {z : â„‚} (hz : z âˆˆ Spectrum â„‚ â†‘A) : z = â†‘(z.re)
{R : Type u} [Ring R] [RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {Î¹ : Type u_1} (B : Basis Î¹ R m) {W : set m} [Fintype â†¥W] (S : Submodule.Span R W = âŠ¤) : Cardinal.Mk Î¹ â‰¤ â†‘(Fintype.Card â†¥W)
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [_fraction_Ring R K] (v : IsDedekindDomain.height_One_Spectrum R) (r : R) : â‡‘(v.Valuation) (â‡‘(Algebra_Map R K) r) < 1 â†” v.as_Ideal âˆ£ Ideal.Span {r}
{Î± : Type u} [SemilatticeInf Î±] [OrderBot Î±] {A : Î±} : Disjoint A A â†’ A = âŠ¥
{R : Type u_1} [CommRing R] {xâ‚ xâ‚‚ yâ‚ yâ‚‚ n : R} : (xâ‚ ^ 2 + n * xâ‚‚ ^ 2) * (yâ‚ ^ 2 + n * yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - n * xâ‚‚ * yâ‚‚) ^ 2 + n * (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2
{K : Type u_3} {L : Type u_4} [Field K] [Field L] [Algebra K L] (A : Subalgebra K L) (hKL : Algebra.IsAlgebraic K L) : _Field â†¥A
{Î¹ : Type u} (S : Finset Î¹) (F g : Î¹ â†’ Nnreal) {P : â„} (hp : 1 â‰¤ P) : S.Sum (Î» (i : Î¹), (F i + g i) ^ P) ^ (1 / P) â‰¤ S.Sum (Î» (i : Î¹), F i ^ P) ^ (1 / P) + S.Sum (Î» (i : Î¹), g i ^ P) ^ (1 / P)
{m : Type u_1} {A : Type u_2} [AddCommMonoid m] {S : set m} (hs : _Add_Submonoid S) (F : A â†’ m) (t : Finset A) : (âˆ€ (B : A), B âˆˆ t â†’ F B âˆˆ S) â†’ t.Sum (Î» (B : A), F B) âˆˆ S
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {P : P} : â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P) = P â†” P âˆˆ S
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {F : Î³ â†’ Î±} {S : set Î³} (h : S âŠ† F â»Â¹' e.to_local_Equiv.Source) : Continuous_on F S â†” Continuous_on (â‡‘e âˆ˜ F) S
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h1 : â†‘S1.Nonempty) (h2 : â†‘S2.Nonempty) (hD : S1.direction âŠ” S2.direction = âŠ¤) : (â†‘S1 âˆ© â†‘S2).Nonempty
{Î± : Type u} [HasSubset Î±] [HasSsubset Î±] [IsNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {A B C : Î±} [IsTrans Î± HasSubset.Subset] (hâ‚ : A âŠ† B) (hâ‚‚ : B âŠ‚ C) : A âŠ‚ C
{m : Type u_1} {N : Type u_2} [AddZeroClass m] [AddZeroClass N] (h : m â‰ƒ+ N) : _AddMonoid_hom â‡‘h
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {E : Type W} [NormedGroup E] [NormedSpace ð•œ E] {F : ð•œ â†’ F} {F' : F} (x : ð•œ) {l : F â†’ E} {l' : F â†’L[ð•œ] E} (hl : HasFderivAt l l' (F x)) (hF : HasDerivAt F F' x) : HasDerivAt (l âˆ˜ F) (â‡‘l' F') x
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (e : m â‰ƒ n) (A : Matrix m m R) : (â‡‘(Matrix.reindex e e) A).det = A.det
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [CompleteSpace E] [CompleteSpace F] (A : E â†’L[ð•œ] F) : â‡‘Continuous_LinearMap.Adjoint (â‡‘Continuous_LinearMap.Adjoint A) = A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {S : set E} {x : E} : UniqueMdiffWithinAt (model_with_corners_self ð•œ E) S x â†’ UniqueDiffWithinAt ð•œ S x
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {F : Filter Î±} [IsTrans Î± r] (A : Î±) (h : âˆ€ (S : set Î±), S âˆˆ F â†’ (âˆƒ (x : Î±) (h : x âˆˆ S), r A x)) : Filter._cobounded r F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : E â†’ G} {x : E Ã— F} (hF : ContDiff_at ð•œ n F x.fst) : ContDiff_at ð•œ n (Î» (x : E Ã— F), F x.fst) x
{Î± : Type v} {S : Finset Î±} {m : Type u_1} [AddCommMonoid m] (F : Î± â†’ m) (P : m â†’ Prop) (P_Mul : âˆ€ (A B : m), P A â†’ P B â†’ P (A + B)) (hs_Nonempty : S.Nonempty) (P_S : âˆ€ (x : Î±), x âˆˆ S â†’ P (F x)) : P (S.Sum (Î» (x : Î±), F x))
{Î± : Type u_1} [PartialOrder Î±] [OrderTop Î±] {A : Î±} : A â‹– âŠ¤ â†’ IsCoatom A
(ð•œ : Type u_1) [nondiscrete_NormedField ð•œ] (E : Type u_2) [NormedGroup E] [NormedSpace ð•œ E] : (model_with_corners_self ð•œ E).to_local_Equiv = local_Equiv.refl E
{Î± : Type v} {S : Finset Î±} {m : Type u_1} [CommMonoid m] (F : Î± â†’ m) (P : m â†’ Prop) (P_Mul : âˆ€ (A B : m), P A â†’ P B â†’ P (A * B)) (hs_Nonempty : S.Nonempty) (P_S : âˆ€ (x : Î±), x âˆˆ S â†’ P (F x)) : P (S.Prod (Î» (x : Î±), F x))
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] (x : C) : CategoryTheory.IsPushout (ðŸ™ x) 0 0 0
{A B : â„} (h : A < B) : Cardinal.Mk â†¥(set.Ico A B) = Cardinal.Continuum
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {F : Î± â†’ Î²} (hF : Isometry F) (x y : Î±) : HasNndist.nndist (F x) (F y) = HasNndist.nndist x y
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [CompactSpace Î±] [MetricSpace Î²] {F g : C(Î±, Î²)} (x : Î±) : HasDist.dist (â‡‘F x) (â‡‘g x) â‰¤ HasDist.dist F g
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [NormedGroup G] [NormedSpace ð•œ G] {g : F â†’ G} {F : E â†’ F} {x : E} (hg : AnalyticAt ð•œ g (F x)) (hF : AnalyticAt ð•œ F x) : AnalyticAt ð•œ (g âˆ˜ F) x
{m : Type u_1} {N : Type u_2} [has_Add m] [has_Add N] {F g : Add_hom m N} {S : set m} (h : set.Eq_on â‡‘F â‡‘g S) : set.Eq_on â‡‘F â‡‘g â†‘(Add_Subsemigroup.Closure S)
{Î± : Type u} [PseudoMetricSpace Î±] (S : set Î±) : Continuous (Î» (x : Î±), metric.Inf_nndist x S)
(A : Type u_4) (K : Type u_5) [CommRing A] [IsDomain A] (L : Type u_6) [Field K] [Field L] [Algebra A K] [Algebra A L] [_fraction_Ring A K] (C : Type u_7) [CommRing C] [IsDomain C] [Algebra C L] [IsIntegral_Closure C A L] [Algebra A C] [IsScalarTower A C L] [Algebra K L] [IsScalarTower A K L] [Finite_dimensional K L] : _fraction_Ring C L
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {ca cb : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds A âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb : Filter.Tendsto F (nhds B âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) : HasStrictFderivAt (Î» (P : â„ Ã— â„), âˆ« (x : â„) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd â„ â„ â„).Smul_Right cb - (Continuous_Linear_Map.fst â„ â„ â„).Smul_Right ca) (A, B)
{ð•œ : Type u_1} {E : Type u_2} [Linear_ordered_Ring ð•œ] [AddCommGroup E] [module ð•œ E] [DenselyOrdered ð•œ] [NoZeroSmulDivisors ð•œ E] {A : set E} {x : E} : x âˆˆ set.ExtremePoints ð•œ A â†” x âˆˆ A âˆ§ âˆ€ (xâ‚ : E), xâ‚ âˆˆ A â†’ âˆ€ (xâ‚‚ : E), xâ‚‚ âˆˆ A â†’ x âˆˆ Segment ð•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ¨ xâ‚‚ = x
{k : â„•} {A : Finset â„•} (hâ‚ : âˆ€ {x : â„•}, x âˆˆ A â†’ x < k) : A.Sum (has_Pow.Pow 2) < 2 ^ k
{Î± : Type u_1} [circular_Preorder Î±] {A B C : Î±} (h : HasSbtw.Sbtw A B C) : Â¬HasSbtw.Sbtw C B A
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {B : m} [Linear_ordered_CommRing m] [Nonempty Î²] (hb : Fintype.Card Î² â€¢ B â‰¤ â†‘(Fintype.Card Î±)) : âˆƒ (y : Î²), B â‰¤ â†‘((Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Card)
{n : â„•} (i : Fin (n + 2)) : â‡‘(i.Succ.Succ_above) 1 = (â‡‘(i.Succ_above) 0).Succ
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e : LocalHomeomorph Î± Î²} {S : set Î±} {t : set Î²} : e.to_local_Equiv.Source âˆ© â‡‘e â»Â¹' t = e.to_local_Equiv.Source âˆ© S â†’ e._image S t
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {v : â„ â†’ E â†’ E} {S : â„ â†’ set E} {K : â„} (hv : âˆ€ (t : â„) (x : E), x âˆˆ S t â†’ âˆ€ (y : E), y âˆˆ S t â†’ HasDist.dist (v t x) (v t y) â‰¤ K * HasDist.dist x y) {F g : â„ â†’ E} {A B Î´ : â„} (hF : Continuous_on F (set.icc A B)) (hF' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt F (v t (F t)) (set.ici t) t) (hfs : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ F t âˆˆ S t) (hg : Continuous_on g (set.icc A B)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt g (v t (g t)) (set.ici t) t) (hgs : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ g t âˆˆ S t) (ha : HasDist.dist (F A) (g A) â‰¤ Î´) (t : â„) (h : t âˆˆ set.icc A B) : HasDist.dist (F t) (g t) â‰¤ Î´ * Real.Exp (K * (t - A))
(n : â„•) : Filter.Tendsto (Î» (x : â„), Polynomial.Eval x (Exp_Neg_Inv_glue.P_aux n) * Real.Exp (-xâ»Â¹) / x ^ (2 * n)) (nhds_within 0 (set.ioi 0)) (nhds 0)
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [LinearOrder Î²] [DenselyOrdered Î²] [NoMinOrder Î²] [NoMaxOrder Î²] [Nonempty Î²] (F : Order.PartialIso Î± Î²) (A : Î±) : âˆƒ (B : Î²), âˆ€ (P : Î± Ã— Î²), P âˆˆ F.val â†’ cmp P.fst A = cmp P.Snd B
(P : â„•) [P_Prime : Fact (Nat.Prime P)] {n : â„•} {F : â„• â†’ â„š} (hF : âˆ€ (i : â„•), i < n â†’ 0 < padic_val_rat P (F i)) (hn0 : (Finset.Range n).Sum (Î» (i : â„•), F i) â‰  0) : 0 < padic_val_rat P ((Finset.Range n).Sum (Î» (i : â„•), F i))
{m : Type u_1} [Monoid m] {x : m} : Monoid.Closure {x} = Powers x
{Î± : Type u} {Î² : Type v} {Î³ : Type W} [Preorder Î±] [Preorder Î²] [Preorder Î³] {F : Î± â†’ Î² â†’ Î³} {S : set Î±} {t : set Î²} (hâ‚€ : âˆ€ (B : Î²), Monotone (Function.Swap F B)) (hâ‚ : âˆ€ (A : Î±), Monotone (F A)) : BddAbove S â†’ BddAbove t â†’ BddAbove (set.image2 F S t)
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] : Fintype.Card (Sym2 Î±) = Fintype.Card Î± * (Fintype.Card Î± + 1) / 2
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedSpace ð•œ E] [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ G} {C : â„} {S : set E} {x y : E} {F' : E â†’ (E â†’L[ð•œ] G)} (hF : âˆ€ (x : E), x âˆˆ S â†’ HasFderivWithinAt F (F' x) S x) (bound : âˆ€ (x : E), x âˆˆ S â†’ âˆ¥F' xâˆ¥ â‰¤ C) (hs : Convex â„ S) (xs : x âˆˆ S) (ys : y âˆˆ S) : âˆ¥F y - F xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {x Y : C} (P : x = Y) : F.Map_iso (CategoryTheory.Eq_to_iso P) = CategoryTheory.Eq_to_iso _
{Î± : Type u} [TopologicalSpace Î±] {Î¹ : Type u_1} [CompactSpace Î±] {F : Î¹ â†’ set Î±} (hF : locally_Finite F) : {i : Î¹ | (F i).Nonempty}.Finite
(n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1
(P' : â„•) (h : LucasLehmer.LucasLehmer_residue (P' + 2) = 0) : order_of (LucasLehmer.Ï‰_Unit (P' + 2)) = 2 ^ (P' + 2)
{R : Type u_1} {m : Type u_2} {mâ‚‚ : Type u_3} [Ring R] [AddCommGroup m] [AddCommGroup mâ‚‚] [module R m] [module R mâ‚‚] (F : m â‰ƒâ‚—[R] mâ‚‚) (P : Submodule R m) : Finite_dimensional.finrank R â†¥(Submodule.Map â†‘F P) = Finite_dimensional.finrank R â†¥P
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i j : D.to_GlueData.J) (U : TopologicalSpace.Opens â†¥((D.to_GlueData.U i).carrier)) : D.Diagram_over_IsOpen_Ï€ U i â‰« D.Î¹_Inv_App_Ï€_Eq_Map U â‰« D.Î¹_Inv_App U â‰« D.Diagram_over_IsOpen_Ï€ U j = D.Diagram_over_IsOpen_Ï€ U j
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {S : Finset Î±} : S âˆˆ ð’œ.Up_shadow â†” âˆƒ (t : Finset Î±) (h : t âˆˆ ð’œ), t âŠ† S âˆ§ t.Card + 1 = S.Card
{A : Type u_2} [NormedRing A] [normed_Algebra â„‚ A] [CompleteSpace A] [NormOneClass A] (A : A) : Filter.Tendsto (Î» (n : â„•), â†‘âˆ¥A ^ nâˆ¥â‚Š ^ (1 / â†‘n)) Filter.at_top (nhds (spectral_radius â„‚ A))
{Î± : Type u_1} [PartialOrder Î±] [SuccOrder Î±] {A B : Î±} [NoMaxOrder Î±] : A â‰  B â†’ Order.Succ A â‰  Order.Succ B
{K : Type u_1} {n : â„•} {S : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] : GeneralizedContinuedFraction.convergents'_aux S (n + 2) = GeneralizedContinuedFraction.convergents'_aux (GeneralizedContinuedFraction.squash_Seq S n) (n + 1)
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] (F : J Ã— K â¥¤ Type v) [CategoryTheory.IsFiltered K] [Fintype J] : Function.Injective (CategoryTheory.Limits.Colimit_Limit_to_Limit_Colimit F)
{R : Type v} [CommRing R] {n : â„•} (A : Matrix (Fin n.Succ) (Fin n.Succ) R) : A.det = Finset.Univ.Sum (Î» (j : Fin n.Succ), (-1) ^ â†‘j * A 0 j * (A.minor Fin.Succ â‡‘(j.Succ_above)).det)
{Î± : Type u_1} [Preorder Î±] [Add_comm_Semigroup Î±] [HasSub Î±] [HasOrderedSub Î±] {A B : Î±} : B - (B - A) â‰¤ A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {A : E} (hF : HasStrictFderivAt F F' A) {C : Nnreal} (hc : Subsingleton E âˆ¨ 0 < C) : âˆƒ (S : set E) (h : S âˆˆ nhds A), ApproximatesLinearOn F F' S C
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} {m' : Type u_6} {v : Î¹ â†’ m} [Semiring R] [AddCommMonoid m] [AddCommMonoid m'] [module R m] [module R m'] (hv : LinearIndependent R v) {F : m â†’â‚—[R] m'} (hF_inj : Disjoint (Submodule.Span R (set.Range v)) F.Ker) : LinearIndependent R (â‡‘F âˆ˜ v)
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [CommMonoid Î²] {S : Finset Î³} {t : Finset Î±} {F : Î³ â†’ Î± â†’ Î²} : (S.Product t).Prod (Î» (x : Î³ Ã— Î±), F x.fst x.Snd) = t.Prod (Î» (y : Î±), S.Prod (Î» (x : Î³), F x y))
{x : Type u} {Î± : Type v} [TopologicalSpace x] [LinearOrder Î±] [TopologicalSpace Î±] [order_IsClosed_topology Î±] [PreconnectedSpace x] (A B : x) {F : x â†’ Î±} (hF : Continuous F) : set.icc (F A) (F B) âŠ† set.Range F
{K : Type u_1} [Field K] [Invertible 2] {A B C : K} (ha : A â‰  0) {S : K} (h : discrim A B C = S * S) (x : K) : A * x * x + B * x + C = 0 â†” x = (-B + S) / (2 * A) âˆ¨ x = (-B - S) / (2 * A)
{Î± : Type u_1} {Î² : Type u_2} {P : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£ (A : Î±), Subtype (P A)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.Snd) = â†‘(xâ‚.Snd) â†’ xâ‚€ = xâ‚
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix m n Î±) (B : Matrix n n Î±) [Invertible B] : (A.Mul (â…Ÿ B)).Mul B = A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] : IsBoundedLinearMap ð•œ (Î» (P : Continuous_MultilinearMap ð•œ E F Ã— Continuous_MultilinearMap ð•œ E G), P.fst.Prod P.Snd)
{Î± : Type uâ‚} {x Y : CategoryTheory.Discrete Î±} (i : x âŸ¶ Y) : x.as = Y.as
{R : Type u} {S : Type v} [Ring R] [Ring S] [IsDomain S] (F : R â†’+* S) : F.Ker.Prime
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x : C} {R : CategoryTheory.Presieve x} {x : CategoryTheory.Presieve.FamilyOfElements P R} (t : x.compatible) : CategoryTheory.Presieve.FamilyOfElements.Restrict _ x.Sieve_extend = x
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] {F : Î² â†’ Î±} [TopologicalSpace Î²] (hF : Inducing F) {S : set Î±} (hs : TopologicalSpace._IsSeparable S) : TopologicalSpace._IsSeparable (F â»Â¹' S)
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {m : Type u_6} [CommSemiring R] [AddCommMonoid m] [module R m] (B : Basis Î¹ R m) (B' : Basis Î¹' R m) [DecidableEq Î¹] [Fintype Î¹'] : (B.to_Matrix â‡‘B').Mul (B'.to_Matrix â‡‘B) = 1
{m : Type u_3} {N : Type u_4} {F : Type u_8} {mM : MulOneClass m} {mN : MulOneClass N} [Monoid_hom_class F m N] (F : F) {x : m} (hx : âˆƒ (y : m), x * y = 1) : âˆƒ (y : N), â‡‘F x * y = 1
{Î± : Type u_3} [SemilatticeSup Î±] (A : Î±) : Filter.Map Coe Filter.at_top = Filter.at_top
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {x : C} {S t : CategoryTheory.Sieve x} (h : S â‰¤ t) (hT : Jâ‚.IsClosed t) : Jâ‚.close S â‰¤ t
{Î± : Type u_1} {Î¹ : Type u_2} {Î¹' : Type u_3} [CompleteLattice Î±] {S : set Î¹'} {g : Î¹' â†’ set Î¹} {F : Î¹ â†’ Î±} (hs : S.Pairwise_Disjoint (Î» (i' : Î¹'), â¨† (i : Î¹) (h : i âˆˆ g i'), F i)) (hg : âˆ€ (i : Î¹'), i âˆˆ S â†’ (g i).Pairwise_Disjoint F) : (â‹ƒ (i : Î¹') (h : i âˆˆ S), g i).Pairwise_Disjoint F
{x y z : Pgame} (hâ‚ : x < y) (hâ‚‚ : y.lf z) : x.lf z
{R : Type u} {K : Type v} {L : Type z} {P : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [_IsSeparable K L] [IsDomain R] [normalized_Gcd_Monoid R] [_fraction_Ring R K] [_integrally_IsClosed R] {B : power_Basis K L} (hp : Prime P) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z) (hz : P â€¢ z âˆˆ Algebra.Adjoin R {B.gen}) (hei : (minpoly R B.gen)._eisenstein_at (Submodule.Span R {P})) : z âˆˆ Algebra.Adjoin R {B.gen}
{Î± : Type u_1} [Bornology Î±] {P : Î± â†’ Prop} : Bornology._bounded {x : Î± | P x} â†’ BoundedSpace (Subtype P)
{mâ‚€ : Type u_1} [MulZeroOneClass mâ‚€] : 0 â‰  1 âˆ¨ âˆ€ (A : mâ‚€), A = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) : S.monge_point âˆˆ affine_Span â„ (set.Range S.points)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e : Î± â†’ Î²} (de : Dense_Embedding e) [TopologicalSpace.IsSeparable_Space Î±] : TopologicalSpace.IsSeparable_Space Î²
{R : Type u_1} {E : Type u_2} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (t : Finset E) {W : E â†’ R} (hwâ‚€ : âˆ€ (i : E), i âˆˆ t â†’ 0 â‰¤ W i) (hws : 0 < t.Sum (Î» (i : E), W i)) : t.Center_mass W Id âˆˆ â‡‘(Convex_hull R) â†‘t
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [BaireSpace Î±] {S : set Î²} {F : Î² â†’ set Î±} (ho : âˆ€ (S : Î²), S âˆˆ S â†’ IsOpen (F S)) (hS : S.countable) (hD : âˆ€ (S : Î²), S âˆˆ S â†’ Dense (F S)) : Dense (â‹‚ (S : Î²) (h : S âˆˆ S), F S)
{Î± : Type u} [TopologicalSpace Î±] [t2_Space Î±] {S : set Î±} (hs : IsCompact S) : IsClosed S
(S : Type u_1) [Ring S] (A : â„•) : â†‘(A.Desc_factorial 2) = â†‘A * (â†‘A - 1)
{R : Type u_1} [CommRing R] : Ideal._jacobson R â†” âˆ€ (P : Ideal R), P.Prime â†’ P.jacobson = P
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {A B C : Matrix n n Î±} (h : A.Mul B = 1) (g : C.Mul A = 1) : B = C
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} : HasInner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆ¥yâˆ¥ â€¢ x = âˆ¥xâˆ¥ â€¢ y
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (F : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {C : â„} (h : âˆ€ (x : E), âˆ¥â‡‘F xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥F.Mk_Continuous C hâˆ¥ â‰¤ LinearOrder.max C 0
(A B : â„) (h : A < B) : (Polynomial_Functions Unit_Interval).comap' (Continuous_Map.Comp_Right_AlgHom â„ (icc_homeo_i A B h).Symm.to_Continuous_Map) = Polynomial_Functions (set.icc A B)
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {F : Î± â†’ Î²} (hF : _AddGroup_hom F) {Î³ : Type u_1} [AddGroup Î³] {g : Î² â†’ Î³} (hg : _AddGroup_hom g) : _AddGroup_hom (g âˆ˜ F)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : â‡‘(Orthogonal_projection S.direction) (P -áµ¥ â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P)) = 0
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {S : set Î±} {P : Filter Î¹} (hF : TendstoUniformlyOn F F P S) : uniform_Cauchy_Seq_on F P S
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [DivisionRing K] {gp ppred Pred : GeneralizedContinuedFraction.Pair K} (Succ_nth_S_Eq : g.S.nth (n + 1) = Option.Some gp) (nth_conts_Eq : g.continuants n = ppred) (Succ_nth_conts_Eq : g.continuants (n + 1) = Pred) : g.continuants (n + 2) = {A := gp.B * Pred.A + gp.A * ppred.A, B := gp.B * Pred.B + gp.A * ppred.B}
{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [Decidable_Rel r] (A : Î±) (l : List Î±) : List.ordered_Insert r A l = List.take_while (Î» (B : Î±), Â¬r A B) l ++ A :: List.Drop_while (Î» (B : Î±), Â¬r A B) l
{Î± : Type u_1} [circular_Preorder Î±] {A B C D : Î±} (hbc : HasSbtw.Sbtw A B C) (hcd : HasSbtw.Sbtw A C D) : HasSbtw.Sbtw A B D
{C : Type u} [CategoryTheory.Category C] {x : top} (F : top.Presheaf C x) : CategoryTheory.Presheaf.IsSheaf (Opens.GrothendieckTopology â†¥x) F â†” F._sheaf_Opens_LE_cover
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : F =O[l] g' â†’ (F =O[l] Î» (x : Î±), -g' x)
{m : Type u_3} {N : Type u_4} [has_One m] [has_One N] (F : One_hom m N) {x y : m} (h : x = y) : â‡‘F x = â‡‘F y
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F â‰  2) (A : F) : â†‘({x : F | x ^ 2 = A}.to_Finset.Card) = Char.quadratic_Char F A + 1
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [_R_or_C ð•‚] [NormedRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] : HasFderivAt (Exp ð•‚) 1 0
(A : Type u) {B : Type v} {Î¹ : Type W} [CommRing A] [CommRing B] [Algebra A B] [Fintype Î¹] [IsDomain A] {B : Î¹ â†’ B} (hli : Â¬LinearIndependent A B) : Algebra.discr A B = 0
{Î± : sort u} {Î² : sort v} [DecidableEq Î±] {v : Î± â†’ Î²} {i j : Î±} (hv : v i = v j) (k : Î±) : v (â‡‘(Equiv.Swap i j) k) = v k
{Î± : Type u_1} [EmetricSpace Î±] {K : Nnreal} {F : Î± â†’ Î±} (hF : ContractingWith K F) {S : set Î±} (hsc : IsComplete S) (hsf : set.maps_to F S S) (hfs : ContractingWith K (set.maps_to.Restrict F S S hsf)) {x : Î±} (hxs : x âˆˆ S) (hx : HasEdist.edist x (F x) â‰  âŠ¤) {t : set Î±} (htc : IsComplete t) (htf : set.maps_to F t t) (hft : ContractingWith K (set.maps_to.Restrict F t t htf)) {y : Î±} (hyt : y âˆˆ t) (hy : HasEdist.edist y (F y) â‰  âŠ¤) (hxy : HasEdist.edist x y â‰  âŠ¤) : ContractingWith.efixed_point' F hsc hsf hfs x hxs hx = ContractingWith.efixed_point' F htc htf hft y hyt hy
(ð•œ : Type u_1) (E : Type u_2) [OrderedSemiring ð•œ] [ordered_AddCommGroup E] [module ð•œ E] [OrderedSmul ð•œ E] : (Convex_cone.PositiveCone ð•œ E).Pointed
(N i : â„•) : Polynomial.rev_at_fun N i = â‡‘(Polynomial.rev_at N) i
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î²] {F : Î± â†’. Î²} [Î  (x : Î±), Decidable (F x).Dom] {S : Finset Î±} : Finset.pimage F S = Finset.image (Î» (x : {x // x âˆˆ Finset.Filter (Î» (x : Î±), (F x).Dom) S}), (F â†‘x).get _) (Finset.Filter (Î» (x : Î±), (F x).Dom) S).attach
{n : â„•} {Î± : Type u_1} (l : List Î±) (C : Composition n) : (l.split_wrt_Composition C).length = C.length
{Î± : Type u_1} {Î¹ : Type u_4} [CompleteLattice Î±] (S : Î¹ â†’ Î±) : (â¨† (i : Î¹), S i) = â¨† (t : Finset Î¹) (i : Î¹) (h : i âˆˆ t), S i
{Î² : Type u} {Î³ : Type W} [non_assoc_Semiring Î²] [non_assoc_Semiring Î³] (F : Î² â†’+* Î³) (l : List Î²) : â‡‘F l.Sum = (List.Map â‡‘F l).Sum
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [Fintype Î¹] (P : Î¹ â†’ P) : AffineIndependent k P â†” âˆ€ (W : Î¹ â†’ k), Finset.Univ.Sum (Î» (i : Î¹), W i) = 0 â†’ â‡‘(Finset.Univ.weighted_vsub P) W = 0 â†’ âˆ€ (i : Î¹), W i = 0
{L : FirstOrder.Language} {m : Type W} {N : Type W'} [L.structure m] [L.structure N] {P : Type u_1} [L.structure P] {q : Type u_2} [L.structure q] (F : L.Embedding m N) (g : L.Embedding N P) (h : L.Embedding P q) : (h.Comp g).Comp F = h.Comp (g.Comp F)
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} {R : Type u_11} [AddMonoid m] [Monoid R] [Distrib_MulAction R m] {F : Î± â†’ Î²} (hF : Function.Injective F) (r : R) (v : Î² â†’â‚€ m) : Finsupp.comap_IsDomain F (r â€¢ v) _ = r â€¢ Finsupp.comap_IsDomain F v _
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B C : Î±} : A * B < C â†’ B < Aâ»Â¹ * C
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {x : E} {n : WithTop â„•} {P : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n F P S) (hn : 1 â‰¤ n) (hx : S âˆˆ nhds x) : HasFderivAt F (â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (P x 1)) x
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x : C} {R : CategoryTheory.Presieve x} (t : CategoryTheory.Presieve.IsSeparated_for P R) : (âˆ€ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.compatible â†’ (âˆƒ (t : P.obj (Opposite.Op x)), x._amalgamation t)) â†’ CategoryTheory.Presieve.IsSheafFor P R
{L : FirstOrder.Language} (K : set (CategoryTheory.Bundled L.structure)) {m : Type W} [L.structure m] [L.countable_Functions] (h : FirstOrder.Language._fraisse_Limit K m) : FirstOrder.Language._fraisse K
{Î± : Type u_1} (n : â„•) (x : Î±) : Function.IsPeriodicPt Id n x
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} (ha : A < 0) (hb : B < 0) : A + B < 0
{ð•œ : Type u_1} {E : Type u_2} [semi_NormedRing ð•œ] [HasScalar ð•œ E] {S t : set E} (ht : Balanced ð•œ t) (h : S âŠ† t) : Balanced_hull ð•œ S âŠ† t
{R : Type u} [Ring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {m : Type u_1} [AddCommGroup m] [module R m] {A : Î¹ â†’ Submodule R m} (hi : CompleteLattice.Independent A) (hs : supr A = âŠ¤) : direct_Sum._internal A
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {S : set Î±} {P : Filter Î¹} [TopologicalSpace Î±] (h : TendstoLocallyUniformlyOn F F P S) (hc : âˆ€á¶  (n : Î¹) in P, Continuous_on (F n) S) [P.Ne_IsBot] : Continuous_on F S
(F : â†¥(MeasureTheory.Lp â„‚ 2 haar_Circle)) (i : â„¤) : â‡‘(â‡‘(fourier_series.repr) F) i = âˆ« (t : â†¥Circle), â†‘t ^ -i * â‡‘F t âˆ‚haar_Circle
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R m) (x : Orientation R m Î¹) : x = e.Orientation âˆ¨ x = -e.Orientation
{Î± : Type u} [PseudoMetricSpace Î±] : uniform_Continuous (Î» (P : UniformSpace.completion Î± Ã— UniformSpace.completion Î±), HasDist.dist P.fst P.Snd)
{x Y : top} {F g : C(â†¥x, â†¥Y)} (h : F.Homotopy g) {xâ‚€ xâ‚ : â†¥x} (P : FundamentalGroupoid.from_top xâ‚€ âŸ¶ FundamentalGroupoid.from_top xâ‚) : (FundamentalGroupoid.FundamentalGroupoid_Functor.Map F).Map P = Continuous_Map.Homotopy.hcast _ â‰« (FundamentalGroupoid.FundamentalGroupoid_Functor.Map h.ulift_Map).Map (Continuous_Map.Homotopy.Prod_to_Prod_top_i (ðŸ™ {down := 0}) P) â‰« Continuous_Map.Homotopy.hcast _
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (m N P : Matrix m m R) : (m.Mul (N.Mul P)).det = (N.Mul (m.Mul P)).det
{m : Type u_1} [AddCommMonoid m] (S : Add_Submonoid m) (m : Multiset m) (hm : âˆ€ (A : m), A âˆˆ m â†’ A âˆˆ S) : m.Sum âˆˆ S
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (v : E) : Orthogonal_projection_fn K v âˆˆ K
 : Irrational golden_Conj
{R : Type u1} [CommSemiring R] {m : Type u2} [AddCommMonoid m] [module R m] {C : exterior_Algebra R m â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(Algebra_Map R (exterior_Algebra R m)) r)) (h_grade1 : âˆ€ (x : m), C (â‡‘(exterior_Algebra.Î¹ R) x)) (h_Mul : âˆ€ (A B : exterior_Algebra R m), C A â†’ C B â†’ C (A * B)) (h_Add : âˆ€ (A B : exterior_Algebra R m), C A â†’ C B â†’ C (A + B)) (A : exterior_Algebra R m) : C A
{Î¹ : Type u_1} {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [ordered_AddCommMonoid N] (F : m â†’ N) (P : m â†’ Prop) (h_Mul : âˆ€ (x y : m), P x â†’ P y â†’ F (x + y) â‰¤ F x + F y) (hp_Mul : âˆ€ (x y : m), P x â†’ P y â†’ P (x + y)) (g : Î¹ â†’ m) (S : Finset Î¹) (hs_Nonempty : S.Nonempty) (hs : âˆ€ (i : Î¹), i âˆˆ S â†’ P (g i)) : F (S.Sum (Î» (i : Î¹), g i)) â‰¤ S.Sum (Î» (i : Î¹), F (g i))
{A B : â„•} (hab : A.IsCoprime B) : A.Factors.Disjoint B.Factors
(G : Type u_1) [AddCommGroup G] : AddMonoid._torsion_free (G â§¸ Add_torsion G)
(Î¹ : Type u_3) : WellFounded has_LT.LT
{K : Type u} {v vâ‚ vâ‚‚ vâ‚ƒ : Type v} [Field K] [AddCommGroup v] [module K v] [AddCommGroup vâ‚] [module K vâ‚] [AddCommGroup vâ‚‚] [module K vâ‚‚] [AddCommGroup vâ‚ƒ] [module K vâ‚ƒ] (db : vâ‚‚ â†’â‚—[K] v) (eb : vâ‚ƒ â†’â‚—[K] v) (cd : vâ‚ â†’â‚—[K] vâ‚‚) (ce : vâ‚ â†’â‚—[K] vâ‚ƒ) (hde : âŠ¤ â‰¤ db.Range âŠ” eb.Range) (hgd : cd.Ker = âŠ¥) (Eq : db.Comp cd = eb.Comp ce) (Eqâ‚‚ : âˆ€ (D : vâ‚‚) (e : vâ‚ƒ), â‡‘db D = â‡‘eb e â†’ (âˆƒ (C : vâ‚), â‡‘cd C = D âˆ§ â‡‘ce C = e)) : module.rank K v + module.rank K vâ‚ = module.rank K vâ‚‚ + module.rank K vâ‚ƒ
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {S : set E} (h : IsLocalMinOn F S A) {y : E} (hy : y âˆˆ Pos_TangentConeAt S A) : 0 â‰¤ â‡‘(fderiv_within â„ F S A) y
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {x Y : C} {F g : x âŸ¶ Y} (h : F = g) (x : â†¥x) : â‡‘F x = â‡‘g x
{Î¹ : Type u} (S : Finset Î¹) (W z : Î¹ â†’ Ennreal) (hw' : S.Sum (Î» (i : Î¹), W i) = 1) {P : â„} (hp : 1 â‰¤ P) : S.Sum (Î» (i : Î¹), W i * z i) ^ P â‰¤ S.Sum (Î» (i : Î¹), W i * z i ^ P)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {vâ‚‚ : Type v'} [AddCommGroup vâ‚‚] [module K vâ‚‚] [Finite_dimensional K v] [Finite_dimensional K vâ‚‚] : Nonempty (v â‰ƒâ‚—[K] vâ‚‚) â†” Finite_dimensional.finrank K v = Finite_dimensional.finrank K vâ‚‚
{A B : â„¤} (ha : A â‰  0) : IsLeast {n : â„• | 0 < n âˆ§ âˆƒ (x y : â„¤), â†‘n = A * x + B * y} (A.Gcd B)
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Mul_Pos_StrictMono Î±] (ha : 1 < A) (hb : 1 â‰¤ B) (B0 : 0 < B) : 1 < A * B
(x : Type u) (Y : Type v) [MetricSpace x] [CompactSpace x] [Nonempty x] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] {F : Cb x Y} (h : F âˆˆ candidates_B x Y) : metric.Hausdorff_dist (set.Range (GromovHausdorff.optimal_GH_injl x Y)) (set.Range (GromovHausdorff.optimal_GH_injr x Y)) â‰¤ GromovHausdorff.hD F
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [IsRefl Î± r] [IsAntisymm Î± r] {A B : Î±} : antisymm_Rel r A B â†’ A = B
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [CompleteSpace E] [CompleteSpace F] (A : E â†’L[ð•œ] F) (B : F â†’L[ð•œ] E) : A = â‡‘Continuous_LinearMap.Adjoint B â†” âˆ€ (x : E) (y : F), HasInner.inner (â‡‘A x) y = HasInner.inner x (â‡‘B y)
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {C : â„} {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : Asymptotics._O_with C l F (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ Asymptotics._O_with C l F g'
{m : Type u_3} {N : Type u_4} [Monoid m] [Monoid N] (F : m â†’* N) (l : List m) : â‡‘F l.Prod = (List.Map â‡‘F l).Prod
{n : â„•} {A B : Fin n} : â†‘A â‰¤ â†‘B â†” A â‰¤ B
{Î± : Type u_1} [PartialOrder Î±] [OrderBot Î±] {A : Î±} : IsAtom A â†’ âŠ¥ â‹– A
{Î± : Type u_1} [Preorder Î±] [PredOrder Î±] {A B : Î±} [NoMinOrder Î±] : A < B â†’ Order.Pred A < Order.Pred B
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} : (GeneralizedContinuedFraction.of v).h = â†‘âŒŠvâŒ‹
{P : â„•} [Fact (Nat.Prime P)] {F : cau_Seq â„š (padic_norm P)} (hF : Â¬F â‰ˆ 0) : âˆƒ (N : â„•), âˆ€ (m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ padic_norm P (â‡‘F n) = padic_norm P (â‡‘F m)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (h_Int : Algebra.IsIntegral K L) : IsTotallyDisconnected set.Univ
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {K : J â¥¤ C} {C D : CategoryTheory.Limits.Cocone K} (F : C âŸ¶ D) [i : CategoryTheory.IsIso F.hom] : CategoryTheory.IsIso F
{G : Type u} [AddMonoid G] : _of_Fin_Add_order 0
{R : Type u_1} {A B : R} [Add_Semigroup R] (lra : _Add_Left_regular A) (lrb : _Add_Left_regular B) : _Add_Left_regular (A + B)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) {r : â„} (hr : r â‰  0) : 2 â€¢ hb.oangle (r â€¢ x) y = 2 â€¢ hb.oangle x y
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : set P} (ho : EuclideanGeometry.OrthocentricSystem S) {t : Affine.Triangle â„ P} (ht : set.Range t.points âŠ† S) : S = HasInsert.Insert t.orthocenter (set.Range t.points)
{G : Type u_10} {h : Type u_11} [AddGroup G] [subtraction_Monoid h] (h : G â‰ƒ+ h) (x y : G) : â‡‘h (x - y) = â‡‘h x - â‡‘h y
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) [Nontrivial n] : A.adjugate.adjugate = A.det ^ (Fintype.Card n - 2) â€¢ A
{Î± : Type u_1} [has_Mul Î±] [has_LT Î±] [ContravariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B C : Î±} (bc : A * B < A * C) : B < C
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {n : WithTop â„•} : ContDiff ð•œ n F â†” (âˆ€ (m : â„•), â†‘m â‰¤ n â†’ Continuous (iterated_deriv m F)) âˆ§ âˆ€ (m : â„•), â†‘m < n â†’ Differentiable ð•œ (iterated_deriv m F)
{R : Type u} [Semiring R] (r : R) : Polynomial.x * â‡‘Polynomial.C r = â‡‘Polynomial.C r * Polynomial.x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] {Y Z : C} (F : Y âŸ¶ Z) (P : CategoryTheory.ProjectiveResolution Y) (q : CategoryTheory.ProjectiveResolution Z) : CategoryTheory.ProjectiveResolution.Lift F P q â‰« q.Ï€ = P.Ï€ â‰« (chain_Complex.singleâ‚€ C).Map F
{Î± : Type u_1} {r S : Setoid Î±} : r âŠ” S = EqvGen.Setoid (r.Rel âŠ” S.Rel)
{E : Type u_3} {F : Type u_4} [semi_NormedGroup E] [semi_NormedGroup F] {F : E â†’ F} {C : Nnreal} : LipschitzWith C F â†’ âˆ€ (x y : E), âˆ¥F x - F yâˆ¥ â‰¤ â†‘C * âˆ¥x - yâˆ¥
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {v : Type u_14} [NormedGroup v] [NormedSpace ð•œ v] : Smooth ((model_with_corners_self ð•œ ð•œ).Prod (model_with_corners_self ð•œ v)) (model_with_corners_self ð•œ v) (Î» (P : ð•œ Ã— v), P.fst â€¢ P.Snd)
{P : Ordinal â†’ Prop} (i : Ordinal) (h : âˆ€ (j : Ordinal), (âˆ€ (k : Ordinal), k < j â†’ P k) â†’ P j) : P i
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * HasInner.inner x y + âˆ¥yâˆ¥ ^ 2
 : Function.Injective Real.sinh
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {A : Type uâ‚ƒ} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (K : CategoryTheory.GrothendieckTopology D) {L : CategoryTheory.GrothendieckTopology A} {F : C â¥¤ D} (hF : CategoryTheory.CoverPreserving J K F) {G : D â¥¤ A} (hG : CategoryTheory.CoverPreserving K L G) : CategoryTheory.CoverPreserving J L (F â‹™ G)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [Add_cancel_CommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [HasScalar ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : strict_Convex_on ð•œ S F) (C : E) : strict_Convex_on ð•œ ((Î» (z : E), C + z) â»Â¹' S) (F âˆ˜ Î» (z : E), C + z)
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A : Î±} : 0 < -A â†” A < 0
{m : Type u_1} [Group m] (C : Con m) {W x : m} : â‡‘C W x â†’ â‡‘C Wâ»Â¹ xâ»Â¹
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} (l : List m) : â‡‘clifford_Algebra.involute (List.Map â‡‘(clifford_Algebra.Î¹ q) l).Prod = (-1) ^ l.length â€¢ (List.Map â‡‘(clifford_Algebra.Î¹ q) l).Prod
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : IsPreirreducible S â†” âˆ€ (zâ‚ zâ‚‚ : set Î±), IsClosed zâ‚ â†’ IsClosed zâ‚‚ â†’ S âŠ† zâ‚ âˆª zâ‚‚ â†’ S âŠ† zâ‚ âˆ¨ S âŠ† zâ‚‚
{R : Type u_1} {m : Type u_9} [Semiring R] [AddCommMonoid m] [module R m] (P : Submodule R m) : Submodule.Map P.Subtype âŠ¤ = P
(Î± : sort u_1) [S : Setoid Î±] : Function.Surjective Quotient.Mk
{m : Type u_1} [AddZeroClass m] {N : Type u_2} [AddZeroClass N] (F : m â†’+ N) (hF : Function.Surjective â‡‘F) : F.mrange = âŠ¤
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} {S : set â„‚} {C : â„‚} (hc : S âˆˆ nhds C) (hD : DifferentiableOn â„‚ F (S  {C})) (ho : (Î» (z : â„‚), F z - F C) =o[nhds_within C {C}á¶œ] Î» (z : â„‚), (z - C)â»Â¹) : DifferentiableOn â„‚ (Function.update F C (lim (nhds_within C {C}á¶œ) F)) S
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) (h : Fintype.Card n â‰  1) : A.adjugate.adjugate = A.det ^ (Fintype.Card n - 2) â€¢ A
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Ring R] [AddCommGroup N] [module R N] (P : Î¹ â†’ Submodule R N) : CompleteLattice.Independent P â†” Function.Injective â‡‘(â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (P i).Subtype))
{P : Type u_1} [Preorder P] [OrderTop P] {F : Order.Pfilter P} : âŠ¤ âˆˆ F
{G : Type u_1} [Group G] {S t : set G} (ht : _Normal_Subgroup t) (h : S âŠ† t) : Group.Normal_Closure S âŠ† t
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : E â†’ FormalMultilinearSeries ð•œ E F} {n : â„•} : HasFtaylorSeriesUpTo â†‘(n + 1) F P â†” (âˆ€ (x : E), (P x 0).uncurry0 = F x) âˆ§ (âˆ€ (x : E), HasFderivAt (Î» (y : E), P y 0) (P x 1).Curry_Left x) âˆ§ HasFtaylorSeriesUpTo â†‘n (Î» (x : E), â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (P x 1)) (Î» (x : E), (P x).shift)
{Î± : Type u_1} [Linear_OrderedSemiring Î±] : Subsingleton (floor_Semiring Î±)
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m â†’+ P} (h : C â‰¤ Add_Con.Ker F) (g : C.Quotient â†’+ P) (Hg : g.Comp C.Mk' = F) : g = C.Lift F h
{r : Nnreal} (hr : r < 1) : has_Sum (Î» (n : â„•), r ^ n) (1 - r)â»Â¹
{Î¹ : Type u_1} {R : Type u_2} [CommSemiring R] [LinearOrder Î¹] (S : Finset Î¹) (F g : Î¹ â†’ R) : S.Prod (Î» (i : Î¹), F i + g i) = S.Prod (Î» (i : Î¹), F i) + S.Sum (Î» (i : Î¹), g i * (Finset.Filter (Î» (_x : Î¹), _x < i) S).Prod (Î» (j : Î¹), F j + g j) * (Finset.Filter (Î» (j : Î¹), i < j) S).Prod (Î» (j : Î¹), F j))
{Î± : Type u} [PseudoEmetricSpace Î±] : (âˆ€ (u : â„• â†’ Î±), Cauchy_Seq u â†’ (âˆƒ (A : Î±), Filter.Tendsto u Filter.at_top (nhds A))) â†’ CompleteSpace Î±
{Î± : Type u} [PseudoEmetricSpace Î±] {Î´â‚ Î´â‚‚ : â„} (hle : Î´â‚ â‰¤ Î´â‚‚) (E : set Î±) : Metric.Thickening Î´â‚ E âŠ† Metric.Thickening Î´â‚‚ E
{n : â„•} (hpos : 0 < n) {P : â„•} [hprime : Fact (Nat.Prime P)] {A : â„•} (hroot : (Polynomial.cyclotomic n (Zmod P))._root (â‡‘(Nat.cast_Ring_hom (Zmod P)) A)) : A.IsCoprime P
{Î± : Type u_1} {n : Type u_3} {A : Matrix n n Î±} : (âˆ€ (i j : n), A j i = A i j) â†’ A.IsSymm
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {v : â„ â†’ E â†’ E} {S : â„ â†’ set E} {K : â„} (hv : âˆ€ (t : â„) (x : E), x âˆˆ S t â†’ âˆ€ (y : E), y âˆˆ S t â†’ HasDist.dist (v t x) (v t y) â‰¤ K * HasDist.dist x y) {F g : â„ â†’ E} {A B : â„} (hF : Continuous_on F (set.icc A B)) (hF' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt F (v t (F t)) (set.ici t) t) (hfs : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ F t âˆˆ S t) (hg : Continuous_on g (set.icc A B)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt g (v t (g t)) (set.ici t) t) (hgs : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ g t âˆˆ S t) (ha : F A = g A) (t : â„) (h : t âˆˆ set.icc A B) : F t = g t
{C : Type u} [CategoryTheory.Category C] {Î¹ : Type u_1} {S : Î¹ â†’ C} [CategoryTheory.Preadditive C] [CategoryTheory.Limits.has_Finite_biproducts C] [âˆ€ (i : Î¹), invariant_Basis_number (CategoryTheory.End (S i))] (o : CategoryTheory.HomOrthogonal S) {Î± Î² : Type v} [Fintype Î±] [Fintype Î²] {F : Î± â†’ Î¹} {g : Î² â†’ Î¹} (i : (â¨ Î» (A : Î±), S (F A)) â‰… â¨ Î» (B : Î²), S (g B)) : âˆƒ (e : Î± â‰ƒ Î²), âˆ€ (A : Î±), g (â‡‘e A) = F A
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x : C} {Râ‚ Râ‚‚ : CategoryTheory.Presieve x} (h : Râ‚ â‰¤ Râ‚‚) {x : CategoryTheory.Presieve.FamilyOfElements P Râ‚‚} : x.compatible â†’ (CategoryTheory.Presieve.FamilyOfElements.Restrict h x).compatible
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {F : Filter Î±} {g : Filter Î²} {n : Î³ â†’ Î´} {m' : Î±' â†’ Î² â†’ Î´} {n' : Î± â†’ Î±'} (h_Distrib : âˆ€ (A : Î±) (B : Î²), n (m A B) = m' (n' A) B) : Filter.Map n (Filter.Mapâ‚‚ m F g) = Filter.Mapâ‚‚ m' (Filter.Map n' F) g
(n : â„•) : (Finset.Range n).Sum (Î» (i : â„•), i) * 2 = n * (n - 1)
{Î¹ : Type u_1} {m : Type u_4} {N : Type u_5} [CommMonoid m] [ordered_CommMonoid N] (F : m â†’ N) (h_Mul : âˆ€ (x y : m), F (x * y) â‰¤ F x * F y) {S : Finset Î¹} (hs : S.Nonempty) (g : Î¹ â†’ m) : F (S.Prod (Î» (i : Î¹), g i)) â‰¤ S.Prod (Î» (i : Î¹), F (g i))
{Î± : Type u} [HasSsubset Î±] [IsTrans Î± HasSsubset.Ssubset] {A B C : Î±} : A âŠ‚ B â†’ B âŠ‚ C â†’ A âŠ‚ C
(P : â„ Ã— â„) (hp : P.fst < 0) : HasStrictFderivAt (Î» (x : â„ Ã— â„), x.fst ^ x.Snd) ((P.Snd * P.fst ^ (P.Snd - 1)) â€¢ Continuous_Linear_Map.fst â„ â„ â„ + (P.fst ^ P.Snd * Real.log P.fst - Real.Exp (Real.log P.fst * P.Snd) * Real.sin (P.Snd * Real.Pi) * Real.Pi) â€¢ Continuous_Linear_Map.Snd â„ â„ â„) P
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] : (âˆ€ (F : â„• â†’o Submodule R m), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘F n = â‡‘F m) â†” IsNoetherian R m
{S : Type u_1} [has_Mul S] (A : S) : Commute A A
{C : Type uâ‚} [CategoryTheory.Category C] {x Y Z : C} (P : x = Y) (q : Y âŸ¶ Z) : _.mpr q = CategoryTheory.Eq_to_hom P â‰« q
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A : Î±} : -A < 0 â†” 0 < A
{x : Type u_1} [TopologicalSpace x] [NoncompactSpace x] : DenseRange Coe
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [Linear_ordered_Field ð•œ] [AddCommGroup E] [ordered_AddCommGroup Î²] [module ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} {t : Finset Î¹} {W : Î¹ â†’ ð•œ} {P : Î¹ â†’ E} (hF : Convex_on ð•œ S F) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ W i) (hâ‚ : 0 < t.Sum (Î» (i : Î¹), W i)) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ P i âˆˆ S) : F (t.Center_mass W P) â‰¤ t.Center_mass W (F âˆ˜ P)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : hb.oangle (â‡‘(hb.Conj_lie) x) (â‡‘(hb.Conj_lie) y) = -hb.oangle x y
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} {n : â„•} {ifp_n : GeneralizedContinuedFraction.Int_fract_pair K} (Stream_nth_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n) (nth_fr_Ne_Zero : ifp_n.fr â‰  0) : (GeneralizedContinuedFraction.of v).S.nth n = Option.Some {A := 1, B := â†‘((GeneralizedContinuedFraction.Int_fract_pair.of (ifp_n.fr)â»Â¹).B)}
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle â„ P) {iâ‚ : Fin 3} : t.orthocenter âˆˆ Affine.Simplex.altitude t iâ‚
{Î± : Type u} [Semigroup Î±] [has_Distrib_Neg Î±] (A B : Î±) : A âˆ£ -B â†” A âˆ£ B
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = Real.Pi) : EuclideanGeometry.angle P2 P1 P3 = 0
{E : Type u_2} [AddCommGroup E] [module â„ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul â„ E] : Path_connected_Space E
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : A < 0) (hb : B â‰¤ 0) : A + B < 0
{F : Type u_2} [NormedGroup F] [NormedSpace â„ F] {x y : F} (hx : x â‰  0) (hy : y â‰  0) : SameRay â„ x y â†” âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y z : m} (hxy : SameRay R x y) (hyz : SameRay R y z) (hy : y = 0 â†’ x = 0 âˆ¨ z = 0) : SameRay R x z
{ð•œ : Type u} [hnorm : nondiscrete_NormedField ð•œ] {t : TopologicalSpace ð•œ} (hâ‚ : topological_AddGroup ð•œ) (hâ‚‚ : has_Continuous_Smul ð•œ ð•œ) (hâ‚ƒ : t2_Space ð•œ) : t = UniformSpace.to_TopologicalSpace
{Î± : Type u_1} [CompleteLattice Î±] {P q : Prop} {S : P â†’ q â†’ Î±} : (â¨… (hâ‚ : P) (hâ‚‚ : q), S hâ‚ hâ‚‚) = â¨… (h : P âˆ§ q), S _ _
{Î² : Type u} {Î³ : Type W} [Semiring Î²] [Semiring Î³] (F : Î² â†’+* Î³) (l : List Î²) : â‡‘F l.Prod = (List.Map â‡‘F l).Prod
{m : Type u_1} [AddGroup m] (C : Add_Con m) {W x y z : m} : â‡‘C W x â†’ â‡‘C y z â†’ â‡‘C (W - y) (x - z)
{R : Type u} [Semiring R] {P : Polynomial R â†’ Prop} (P : Polynomial R) (h0 : 0 < P.degree) (hC : âˆ€ {A : R}, A â‰  0 â†’ P (â‡‘Polynomial.C A * Polynomial.x)) (hX : âˆ€ {P : Polynomial R}, 0 < P.degree â†’ P P â†’ P (P * Polynomial.x)) (HAdd : âˆ€ {P : Polynomial R} {A : R}, 0 < P.degree â†’ P P â†’ P (P + â‡‘Polynomial.C A)) : P P
{Î± : Type u} (S : Seq Î±) {m n : â„•} (m_LE_n : m â‰¤ n) (TerminatedAt_m : S.TerminatedAt m) : S.TerminatedAt n
{k n : â„•} (S : Finset â„•) (hs : Add_salem_spencer â†‘S) (hsn : âˆ€ (x : â„•), x âˆˆ S â†’ x < n) (hsk : S.Card = k) : k â‰¤ â‡‘roth_number_Nat n
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} : StrictAntiOn F S â†’ StrictMono_on (F âˆ˜ â‡‘order_dual.of_dual) S
{Î± : Type u_1} {Î² : Type u_2} [Infinite Î±] [Fintype Î²] (F : Î± â†’ Î²) : âˆƒ (y : Î²), Infinite â†¥(F â»Â¹' {y})
{Î± : Type u_3} (F : Filter Î±) [F._countably_generated] [F.Ne_IsBot] : âˆƒ (x : â„• â†’ Î±), Filter.Tendsto x Filter.at_top F
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] [t2_Space Î±] {S t : set Î²} {F g : Î² â†’ Î±} (h : set.Eq_on F g S) (hF : Continuous_on F t) (hg : Continuous_on g t) (hst : S âŠ† t) (hts : t âŠ† Closure S) : set.Eq_on F g t
{Î± : Type u_1} [has_LE Î±] {A : Î±áµ’áµˆ} : IsMin A â†’ IsMax (â‡‘order_dual.of_dual A)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : LocalHomeomorph Î± Î²) {B : Î²} (hb : B âˆˆ e.to_local_Equiv.Target) {F : Î² â†’ E} {g : Î² â†’ F} : F =o[nhds B] g â†” (F âˆ˜ â‡‘e) =o[nhds (â‡‘(e.Symm) B)] (g âˆ˜ â‡‘e)
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {C : â„} {F' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : Asymptotics._O_with C l F' g' â†’ Asymptotics._O_with C l (Î» (x : Î±), âˆ¥F' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥)
{Î± : Type v} {S : Type W} (e : Î± â‰ƒ S) : Small Î±
{G : Type W} [TopologicalSpace G] [has_Inv G] [has_Mul G] [has_Continuous_Mul G] [has_Continuous_Inv G] (h : G) : Continuous (Î» (g : G), g * h * gâ»Â¹)
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] {A B : Î±} : Aâ»Â¹ < Bâ»Â¹ â†’ B < A
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [AddCommMonoid Î²] {S : Finset Î³} {t : Finset Î±} {F : Î³ â†’ Î± â†’ Î²} : (S.Product t).Sum (Î» (x : Î³ Ã— Î±), F x.fst x.Snd) = S.Sum (Î» (x : Î³), t.Sum (Î» (y : Î±), F x y))
{n : â„•} {E : Type u_1} [NormedGroup E] {F g : (Fin n â†’ â„‚) â†’ E} {C : Fin n â†’ â„‚} {R : Fin n â†’ â„} (hF : TorusIntegrable F C R) (hg : TorusIntegrable g C R) : TorusIntegrable (F + g) C R
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] {F : Type v} [NormedGroup F] [NormedSpace â„‚ F] {F : E â†’ F} (hF : Differentiable â„‚ F) (hb : Metric.Bounded (set.Range F)) : âˆƒ (C : F), F = Function.Const E C
{F : Type} [CommSemiring F] {q : â„•} {F : Polynomial F} (hF : Polynomial.has_IsSeparable_contraction q F) : hF.degree âˆ£ F.Nat_degree
(Î± : Type u) (Î² : Type v) [Group Î±] [MulAction Î± Î²] [Fintype Î±] [Î  (A : Î±), Fintype â†¥(MulAction.FixedBy Î± Î² A)] [Fintype (Quotient (MulAction.Orbit_Rel Î± Î²))] : Finset.Univ.Sum (Î» (A : Î±), Fintype.Card â†¥(MulAction.FixedBy Î± Î² A)) = Fintype.Card (Quotient (MulAction.Orbit_Rel Î± Î²)) * Fintype.Card Î±
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] [Fintype m] [DecidableEq m] (A : Matrix m n Î±) (B : Matrix n m Î±) : (1 + A.Mul B).det = (1 + B.Mul A).det
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D â¥¤ C} [CategoryTheory.Reflective i] {A : C} {B : D} (F : i.obj ((CategoryTheory.IsLeftAdjoint i).obj A) âŸ¶ i.obj B) : â‡‘((CategoryTheory.Unit_Comp_partial_Bijective_aux A B).Symm) F = (CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App A â‰« F
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [PseudoMetricSpace Î²] {F g : bounded_Continuous_Function Î± Î²} [IsEmpty Î±] : HasDist.dist F g = 0
(x : AlgebraicGeometry.LocallyRingedSpace) (r : â†¥(AlgebraicGeometry.LocallyRingedSpace.Î“.obj (Opposite.Op x))) (F : (AlgebraicGeometry.spec.StructureSheaf â†¥(AlgebraicGeometry.LocallyRingedSpace.Î“.obj (Opposite.Op x))).val.obj (Opposite.Op (Prime_Spectrum.basic_IsOpen r)) âŸ¶ x.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (Opposite.Op (x.toÎ“_spec_Map_basic_IsOpen r))) : AlgebraicGeometry.StructureSheaf.to_IsOpen â†¥(AlgebraicGeometry.LocallyRingedSpace.Î“.obj (Opposite.Op x)) (Prime_Spectrum.basic_IsOpen r) â‰« F = x.to_toÎ“_spec_Map_basic_IsOpen r â†” F = x.toÎ“_spec_C_App r
{Î± : Type u} [UniformSpace Î±] {F : Filter Î±} {x : Î±} (adhs : âˆ€ (S : set (Î± Ã— Î±)), S âˆˆ Uniformity Î± â†’ (âˆƒ (t : set Î±) (h : t âˆˆ F), t Ã—Ë¢ t âŠ† S âˆ§ âˆƒ (y : Î±), (x, y) âˆˆ S âˆ§ y âˆˆ t)) : F â‰¤ nhds x
{Î± : Type u} {Î² : Type v} [PseudoEmetricSpace Î±] [PseudoEmetricSpace Î²] {F : Î± â†’ Î²} {g : Î² â†’ Î±} (h : Isometry F) (hg : Function.RightInverse g F) : Isometry g
(P : â„•) [Fact (Nat.Prime P)] (k : Type u_1) [Field k] [_alg_IsClosed k] [Char_P k P] (v : Type u_2) [AddCommGroup v] [witt_Vector.isocrystal P k v] (h_dim : Finite_dimensional.finrank (fraction_Ring (witt_Vector P k)) v = 1) : âˆƒ (m : â„¤), Nonempty (witt_Vector.isocrystal_Equiv P k (witt_Vector.standard_One_dim_isocrystal P k m) v)
{Î± : Type u} [AddCommGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B C : Î±} : B â‰¤ C - A â†’ A + B â‰¤ C
(n : â„•) : Finset.Univ.Sum (Î» (i : Affine.Simplex.points_with_circumcenter_Index (n + 2)), Affine.Simplex.monge_point_weights_with_circumcenter n i) = 1
{Î± : Type u_1} {Î² : Type u_2} [Monoid Î²] {S : Finset Î±} (F g : Î± â†’ Î²) (comm_ff : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ Commute (F x) (F y)) (comm_gg : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ Commute (g x) (g y)) (comm_gf : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ x â‰  y â†’ Commute (g x) (F y)) : S.noncomm_Prod (F * g) _ = S.noncomm_Prod F comm_ff * S.noncomm_Prod g comm_gg
{R : Type u_1} {m : Type u_2} [CommMonoid m] [CommRing R] [Nontrivial R] : Algebra.Finite_Type R (Monoid_Algebra R m) â†” Monoid.fg m
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {ca cb : E} {la lb : Filter â„} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F la MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F lb MeasureTheory.MeasureSpace.Volume) {S t : set â„} [IntervalIntegral.FTC_Filter A (nhds_within A S) la] [IntervalIntegral.FTC_Filter B (nhds_within B t) lb] (ha : Filter.Tendsto F (la âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb : Filter.Tendsto F (lb âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) (hs : UniqueDiffWithinAt â„ S A . "UniqueDiffWithinAt_ici_Iic_Univ") (ht : UniqueDiffWithinAt â„ t B . "UniqueDiffWithinAt_ici_Iic_Univ") : fderiv_within â„ (Î» (P : â„ Ã— â„), âˆ« (x : â„) in P.fst..P.Snd, F x) (S Ã—Ë¢ t) (A, B) = (Continuous_Linear_Map.Snd â„ â„ â„).Smul_Right cb - (Continuous_Linear_Map.fst â„ â„ â„).Smul_Right ca
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (h : 0 < r * (B - A)) : â‡‘(affine_Map.line_Map (F A) (F B)) r < F (â‡‘(affine_Map.line_Map A B) r) â†” slope F A B < slope F A (â‡‘(affine_Map.line_Map A B) r)
{Î± : Type u_1} [DecidableEq Î±] {S : Finset Î±} {A B : Î±} (hs : B âˆˆ S) (hsa : B âˆ‰ S.erase A) : B = A
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_4} [Fintype Î¹] [DecidableEq Î¹] (B : Basis Î¹ R m) : LinearMap.trace R m = (contract_Left R m).Comp (dual_tensor_hom_Equiv_of_Basis B).Symm.to_Linear_Map
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {S : set E} {x : E} : mfderiv_within (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F S x = fderiv_within ð•œ F S x
{Î± : Type u_1} {S : Finset Î±} : S.Nonempty â†’ 0 < S.Card
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {F : Filter Î±} {g : Filter Î²} {n : Î³ â†’ Î´} {m' : Î²' â†’ Î± â†’ Î´} {n' : Î² â†’ Î²'} (h_antidistrib : âˆ€ (A : Î±) (B : Î²), n (m A B) = m' (n' B) A) : Filter.Map n (Filter.Mapâ‚‚ m F g) = Filter.Mapâ‚‚ m' (Filter.Map n' g) F
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : â„ â†’ E} {F' : E} {x r : â„} (hF : HasDerivWithinAt F F' (set.ici x) x) (hr : âˆ¥F'âˆ¥ < r) : âˆƒá¶  (z : â„) in nhds_within x (set.ioi x), âˆ¥z - xâˆ¥â»Â¹ * âˆ¥F z - F xâˆ¥ < r
(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A] [Nontrivial R] {x : A} : IsIntegral R x â†’ IsAlgebraic R x
{x Y : Profinite} (F : x âŸ¶ Y) (bij : Function.Bijective â‡‘F) : CategoryTheory.IsIso F
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x : E) (S : Submodule ð•œ E) [CompleteSpace E] [CompleteSpace â†¥S] : âˆ¥xâˆ¥ ^ 2 = âˆ¥â‡‘(Orthogonal_projection S) xâˆ¥ ^ 2 + âˆ¥â‡‘(Orthogonal_projection Sá—®) xâˆ¥ ^ 2
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B C : Î±} : A â‰¤ C - B â†’ A + B â‰¤ C
{P : â„•} (hp : 1 < P) : padic_val_Int P â†‘P = 1
(n : â„¤) : â‡‘Zmod.Ï‡â‚ˆ' â†‘n = Ite (n % 2 = 0) 0 (Ite (n % 8 = 1 âˆ¨ n % 8 = 3) 1 (-1))
{x : Type u_1} [TopologicalSpace x] [NormalSpace x] {S t : set x} (hs : IsClosed S) (ht : IsClosed t) (hD : Disjoint S t) {A B : â„} (hle : A â‰¤ B) : âˆƒ (F : bounded_Continuous_Function x â„), set.Eq_on â‡‘F (Function.Const x A) S âˆ§ set.Eq_on â‡‘F (Function.Const x B) t âˆ§ âˆ€ (x : x), â‡‘F x âˆˆ set.icc A B
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {A B : Î±} (h : A â‰  B) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ {A, B}), F i)) = F A + F B
{Î± : Type u_1} {Î¹ : Type u_2} {Î² : Type u_3} {S : Î¹ â†’ set Î±} {F : Î  (i : Î¹), â†¥(S i) â†’ Î²} {hF : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), F i âŸ¨x, hxiâŸ© = F j âŸ¨x, hxjâŸ©} {t : set Î±} (hT' : t = set.Union S) (Dir : Directed has_LE.LE S) (Op : â†¥t â†’ â†¥t â†’ â†¥t) (opi : Î  (i : Î¹), â†¥(S i) â†’ â†¥(S i) â†’ â†¥(S i)) (hopi : âˆ€ (i : Î¹) (x y : â†¥(S i)), set.inclusion _ (opi i x y) = Op (set.inclusion _ x) (set.inclusion _ y)) (OpÎ² : Î² â†’ Î² â†’ Î²) (h : âˆ€ (i : Î¹) (x y : â†¥(S i)), F i (opi i x y) = OpÎ² (F i x) (F i y)) (x y : â†¥t) : set.Union_Lift S F hF t _ (Op x y) = OpÎ² (set.Union_Lift S F hF t _ x) (set.Union_Lift S F hF t _ y)
(G : Type u_1) [Monoid G] : Â¬Monoid._torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ _of_Fin_order g
{Î± : Type u} [TopologicalSpace Î±] (S : set Î±) : Frontier Sá¶œ = Frontier S
(n : â„•) (n_big : 4 â‰¤ n) : 4 ^ n < n * n.central_binom
{Î± : Type u_1} {Î² : Type u_2} {F g : Î± â†’. Î²} (h1 : âˆ€ (A : Î±), A âˆˆ F.Dom â†” A âˆˆ g.Dom) (h2 : âˆ€ (A : Î±) (P : F.Dom A) (q : g.Dom A), F.fn A P = g.fn A q) : F = g
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_3} (S : Finset Î¹) (F : Î¹ â†’ E) (x : E) : HasInner.inner x (S.Sum (Î» (i : Î¹), F i)) = S.Sum (Î» (i : Î¹), HasInner.inner x (F i))
{P : Type u â†’ Prop} (of_Equiv : âˆ€ {Î± Î² : Type u}, Î± â‰ƒ Î² â†’ P Î± â†’ P Î²) (h_Empty : P PEmpty) (h_Option : âˆ€ {Î± : Type u} [_inst_1 : Fintype Î±], P Î± â†’ P (Option Î±)) (Î± : Type u) [Fintype Î±] : P Î±
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace F] (P : FormalMultilinearSeries ð•œ E F) (h : 0 < P.radius) : HasFpowerSeriesOnBall P.Sum P 0 P.radius
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_coproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.Normal_Epi_Category C] [CategoryTheory.Limits.has_Zero_object C] {x Y : C} (F : x âŸ¶ Y) (hF : âˆ€ (Z : C) (g : Z âŸ¶ x), g â‰« F = 0 â†’ g = 0) : CategoryTheory.Mono F
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) (init : Fin E.order â†’ Î±) : E._solution (E.Mk_sol init)
{Î¹ : Type u} {Î± : Type v} [Fintype Î¹] {t : Î¹ â†’ Finset Î±} [DecidableEq Î±] {n : â„•} (hn : Fintype.Card Î¹ = n + 1) (ht : âˆ€ (S : Finset Î¹), S.Card â‰¤ (S.bUnion t).Card) (ih : âˆ€ {Î¹' : Type u} [_inst_3 : Fintype Î¹'] (t' : Î¹' â†’ Finset Î±), Fintype.Card Î¹' â‰¤ n â†’ (âˆ€ (S' : Finset Î¹'), S'.Card â‰¤ (S'.bUnion t').Card) â†’ (âˆƒ (F : Î¹' â†’ Î±), Function.Injective F âˆ§ âˆ€ (x : Î¹'), F x âˆˆ t' x)) (ha : âˆ€ (S : Finset Î¹), S.Nonempty â†’ S â‰  Finset.Univ â†’ S.Card < (S.bUnion t).Card) : âˆƒ (F : Î¹ â†’ Î±), Function.Injective F âˆ§ âˆ€ (x : Î¹), F x âˆˆ t x
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {x : E} {n : â„•} : ContDiff_within_at ð•œ â†‘(n + 1) F S x â†” âˆƒ (u : set E) (h : u âˆˆ nhds_within x (HasInsert.Insert x S)) (F' : E â†’ (E â†’L[ð•œ] F)), (âˆ€ (x : E), x âˆˆ u â†’ HasFderivWithinAt F (F' x) u x) âˆ§ ContDiff_within_at ð•œ â†‘n F' u x
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (t : CategoryTheory.Limits.IsInitial x) (F : Y âŸ¶ x) : CategoryTheory.Epi F
{Î¹ : Type W} {R : Type u} [Ring R] [Nontrivial R] {m : Type v} [AddCommGroup m] [module R m] {v : Î¹ â†’ m} (i : LinearIndependent R v) : i.Maximal â†” âˆ€ (Îº : Type v) (W : Îº â†’ m), LinearIndependent R W â†’ âˆ€ (j : Î¹ â†’ Îº), W âˆ˜ j = v â†’ Function.Surjective j
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : (F =O[l] Î» (x : Î±), -g' x) â†’ F =O[l] g'
{Î± : Type u_1} [Preorder Î±] [Nonempty Î±] [NoMaxOrder Î±] : Infinite Î±
{Î± : Type u_2} {m : Type u_4} {n : Type u_5} {R : Type u_8} [TopologicalSpace R] [TopologicalSpace Î±] {F : Î± â†’ Matrix m n R} (h : âˆ€ (i : m) (j : n), Continuous (Î» (A : Î±), F A i j)) : Continuous F
{Î± : Type u} [non_unital_non_assoc_Ring Î±] (A B C : Î±) : A * (B - C) = A * B - A * C
{Î± : Type u_1} [Preorder Î±] [locally_Finite_order Î±] {A B : Î±} : Â¬A < B â†’ Multiset.ioc A B = 0
{Î¹ : Type u} (S : Finset Î¹) (F : Î¹ â†’ Nnreal) {P : â„} (hp : 1 â‰¤ P) : S.Sum (Î» (i : Î¹), F i) ^ P â‰¤ â†‘(S.Card) ^ (P - 1) * S.Sum (Î» (i : Î¹), F i ^ P)
{Î± : Type u_1} [PseudoMetricSpace Î±] (C : â„) {F : â„• â†’ Î±} (huâ‚‚ : âˆ€ (n : â„•), HasDist.dist (F n) (F (n + 1)) â‰¤ C / 2 / 2 ^ n) {A : Î±} (ha : Filter.Tendsto F Filter.at_top (nhds A)) (n : â„•) : HasDist.dist (F n) A â‰¤ C / 2 ^ n
{Î² : Type u_1} [conditionally_CompleteLattice Î²] {S : set (WithTop Î²)} (hs : S.Nonempty) : IsLub S (HasSup.Sup S)
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {g : Î² â†’ Î±} (hg : Function.Injective g) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ set.Range g), F i)) = finsum (Î» (j : Î²), F (g j))
{m : Type u_1} [Monoid m] : _Submonoid set.Univ
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {x : E} {S : set E} (h : HasFderivWithinAt F F' S x) {Î± : Type u_4} (l : Filter Î±) {C : Î± â†’ ð•œ} {D : Î± â†’ E} {v : E} (dtop : âˆ€á¶  (n : Î±) in l, x + D n âˆˆ S) (clim : Filter.Tendsto (Î» (n : Î±), âˆ¥C nâˆ¥) l Filter.at_top) (cdlim : Filter.Tendsto (Î» (n : Î±), C n â€¢ D n) l (nhds v)) : Filter.Tendsto (Î» (n : Î±), C n â€¢ (F (x + D n) - F x)) l (nhds (â‡‘F' v))
{P : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero â†‘â†‘P] {k : â„•} [hpri : Fact (Nat.Prime â†‘P)] [IsCyclotomicExtension {P ^ (k + 1)} K L] (hirr : Irreducible (Polynomial.cyclotomic â†‘(P ^ (k + 1)) K)) {S : â„•} (hs : S â‰¤ k) (htwo : P ^ (k - S + 1) â‰  2) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta (P ^ (k + 1)) K L ^ â†‘P ^ S - 1) = â†‘P ^ â†‘P ^ S
{q : â„š} {n : â„•} {ifp_n ifp_Succ_n : GeneralizedContinuedFraction.Int_fract_pair â„š} (Stream_nth_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream q n = Option.Some ifp_n) (Stream_Succ_nth_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream q (n + 1) = Option.Some ifp_Succ_n) : ifp_Succ_n.fr.Num < ifp_n.fr.Num
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (h : Add_Subgroup G) {F : N â†’+ G} (hF : Function.Surjective â‡‘F) : Add_Subgroup.comap F h.Normalizer = (Add_Subgroup.comap F h).Normalizer
{Î± : Type u_1} {A B C : Î±} [LinearOrder Î±] [Add_comm_Semigroup Î±] [HasSub Î±] [HasOrderedSub Î±] : A < B - C â†” C + A < B
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {S : set E} (h : IsLocalMaxOn F S A) {y : E} (hy : y âˆˆ Pos_TangentConeAt S A) : â‡‘(fderiv_within â„ F S A) y â‰¤ 0
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S t : set E) : â†‘(intermediate_Field.Adjoin â†¥(intermediate_Field.Adjoin F S) t) = â†‘(intermediate_Field.Adjoin â†¥(intermediate_Field.Adjoin F t) S)
{Î± : Type u_1} {Î¹ : sort u_4} [CompleteLattice Î±] (F : Î¹ â†’ Î±) : (â¨† (i : {i // F i â‰  âŠ¥}), F â†‘i) = â¨† (i : Î¹), F i
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] {F : â„ â†’ E} {t : â„} (hF : Function.Periodic F t) (t S : â„) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable F MeasureTheory.MeasureSpace.Volume tâ‚ tâ‚‚) : âˆ« (x : â„) in t..S + t, F x = (âˆ« (x : â„) in t..S, F x) + âˆ« (x : â„) in t..t + t, F x
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R â†’+* S} {P : Polynomial S} (r : R) (hp : P âˆˆ Polynomial.lifts F) : â‡‘Polynomial.C (â‡‘F r) * P âˆˆ Polynomial.lifts F
{Î± : Type u_1} {S : set Î±} : set.Range Subtype.val = S
{A : Type u_1} [NormedRing A] [normed_Algebra â„‚ A] [CompleteSpace A] [Nontrivial A] (A : A) : (Spectrum â„‚ A).Nonempty
{Î± : Type u_1} {Î² : Type u_2} {e : local_Equiv Î± Î²} {S : set Î±} {t : set Î²} : e._image S t â†’ e.Target âˆ© â‡‘(e.Symm) â»Â¹' S = e.Target âˆ© t
{R : Type u_1} [Semiring R] (n : â„•) (A : R) [Decidable (A = 0)] : (â‡‘(PowerSeries.monomial R n) A).order = Ite (A = 0) âŠ¤ â†‘n
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {n : â„•} (ht : t.Nonempty) (hn : S.Card â‰¤ t.Card * n) : âˆƒ (y : Î²) (h : y âˆˆ t), (Finset.Filter (Î» (x : Î±), F x = y) S).Card â‰¤ n
{Î± : Type u} [Preorder Î±] {A B C : Î±} : A < B â†’ B â‰¤ C â†’ A < C
{t : set GromovHausdorff.GH_Space} {C : â„} {u : â„• â†’ â„} {K : â„• â†’ â„•} (ulim : Filter.Tendsto u Filter.at_top (nhds 0)) (hdiam : âˆ€ (P : GromovHausdorff.GH_Space), P âˆˆ t â†’ Metric.diam set.Univ â‰¤ C) (hcov : âˆ€ (P : GromovHausdorff.GH_Space), P âˆˆ t â†’ âˆ€ (n : â„•), âˆƒ (S : set P.Rep), Cardinal.Mk â†¥S â‰¤ â†‘(K n) âˆ§ set.Univ âŠ† â‹ƒ (x : P.Rep) (h : x âˆˆ S), Metric.Ball x (u n)) : TotallyBounded t
{Î± : Type u_1} {m : MeasurableSpace Î±} (Î½ : MeasureTheory.Measure Î±) [MeasureTheory.sigma_Finite Î½] {S : set Î±} (hs : Measurable_set S) : (Î½.Restrict S).rn_deriv Î½ =áµ[Î½] S.indicator 1
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.Limits.HasColimits_of_size D] [CategoryTheory.CreatesColimitsOfSize F] : CategoryTheory.Limits.HasColimits_of_size C
{E : Type u_2} [semi_NormedGroup E] [NormedSpace â„ E] {S t : set E} {x y : E} (hx : x âˆˆ â‡‘(Convex_hull â„) S) (hy : y âˆˆ â‡‘(Convex_hull â„) t) : âˆƒ (x' : E) (h : x' âˆˆ S) (y' : E) (h : y' âˆˆ t), HasDist.dist x y â‰¤ HasDist.dist x' y'
{Î± : Type u_1} [Linear_ordered_Field Î±] [Archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : y < 1) : âˆƒ (n : â„•), y ^ n < x
{Î± : Type u} [Preorder Î±] {S t : set Î±} (h : BddBelow S) : BddBelow (S âˆ© t)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} {u v : E} (hu : u âˆˆ K) (hv : v âˆˆ Ká—®) : HasInner.inner u v = 0
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) {r : â„} : 2 â€¢ o.oangle x (r â€¢ x) = 0
(P' : â„•) : 2 < LucasLehmer.q (P' + 2)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type uâ‚} [CategoryTheory.Category D] {L : D â¥¤ C} {R : C â¥¤ D} (h : L âŠ£ R) : CategoryTheory.IsFiltered D
{Î± : Type u} {Î² : Type v} [PseudoEmetricSpace Î±] [PseudoEmetricSpace Î²] {F : Î± â†’ Î²} [Subsingleton Î±] : Isometry F
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] (A : Î±) [NoMaxOrder Î±] : Closure (set.ioi A) = set.ici A
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (P : Cáµ’áµ– â¥¤ A) {x : C} (R : CategoryTheory.Presieve x) : Nonempty (CategoryTheory.Limits.IsLimit (P.Map_cone (CategoryTheory.Sieve.generate R).Arrows.Cocone.Op)) â†” âˆ€ (E : Aáµ’áµ–), CategoryTheory.Presieve.IsSheafFor (P â‹™ CategoryTheory.coyoneda.obj E) R
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : Real.sin (InnerProductGeometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = Real.sqrt (HasInner.inner x x * HasInner.inner y y - HasInner.inner x y * HasInner.inner x y)
{n : â„•} (hpos : 0 < n) : Irreducible (Polynomial.cyclotomic n â„¤)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [NormedGroup E] [NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (F : E â†’sl[Ïƒâ‚â‚‚] F) [Ring_hom_isometric Ïƒâ‚â‚‚] : âˆ¥Fâˆ¥ = 0 â†” F = 0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} : Mdifferentiable (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F â†” Differentiable ð•œ F
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [NormedGroup G] [NormedSpace ð•œ G] (q : FormalMultilinearSeries ð•œ F G) (P : FormalMultilinearSeries ð•œ E F) (r : Nnreal) (hr : Summable (Î» (i : Î£ (n : â„•), Composition n), âˆ¥q.Comp_along_Composition P i.Sndâˆ¥â‚Š * r ^ i.fst)) : â†‘r â‰¤ (q.Comp P).radius
{Î± : Type u_1} {Î¹ : Type u_4} [LinearOrder Î±] [DecidableEq Î¹] (F : Î¹ â†’ Î±) {P : Finset Î¹ â†’ Prop} (S : Finset Î¹) (h0 : P âˆ…) (step : âˆ€ (A : Î¹) (S : Finset Î¹), A âˆ‰ S â†’ (âˆ€ (x : Î¹), x âˆˆ S â†’ F x â‰¤ F A) â†’ P S â†’ P (HasInsert.Insert A S)) : P S
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hst : Disjoint S t) (hs : (S âˆ© Function.MulSupport F).Finite) (ht : (t âˆ© Function.MulSupport F).Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S âˆª t), F i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ t), F i))
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {C : Î±} [Linear_ordered_AddCommGroup Î±] [Archimedean Î±] (h : Function.Periodic F C) (hc : 0 < C) (x : Î±) : âˆƒ (y : Î±) (h : y âˆˆ set.Ico 0 C), F x = F y
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [OrderedSemiring ð•œ] [AddCommGroup E] [module ð•œ E] {P : Î¹ â†’ E} (hc : Convex_Independent ð•œ P) (S : set Î¹) : Convex_Independent ð•œ (Î» (i : â†¥S), P â†‘i)
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (h : InnerProductGeometry.angle x y = 0) : HasInner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] [TopologicalSpace ð•œ] [OrderTopology ð•œ] [Archimedean ð•œ] : DenseRange Coe
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {x y : m} (h : SameRay R x y) (hy : y â‰  0) : âˆƒ (r : R), 0 â‰¤ r âˆ§ x = r â€¢ y
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} : metric.Hausdorff_dist (Closure S) t = metric.Hausdorff_dist S t
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 : P) : HasDist.dist P1 (midpoint â„ P1 P2) = HasDist.dist P2 (midpoint â„ P1 P2)
{Î“â‚€ : Type u_3} [Linear_ordered_CommMonoid_with_Zero Î“â‚€] [Nontrivial Î“â‚€] {K : Type u_1} [DivisionRing K] (v : Valuation K Î“â‚€) {x : K} : â‡‘v x = 0 â†” x = 0
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] [NoZeroSmulDivisors R m] (x : module.Ray R m) : x â‰  -x
(A : Zmod 8) : â‡‘Zmod.Ï‡â‚ˆ' A = 0 âˆ¨ â‡‘Zmod.Ï‡â‚ˆ' A = 1 âˆ¨ â‡‘Zmod.Ï‡â‚ˆ' A = -1
{Î± : Type u_2} {Î² : Type u_3} [Linear_ordered_Field Î±] [Linear_ordered_Field Î²] [Archimedean Î²] : Subsingleton (Î± â‰ƒ+*o Î²)
{Î± : Type u} (L : List Î±) {i j : â„•} (h : j < (List.Drop i L).length) : (List.Drop i L).nth_LE j h = L.nth_LE (i + j) _
{Î± : Type u_1} [LinearOrder Î±] (A : Î±) : {A}.min' _ = A
{x : â„} (n : â„•) (m : â„¤) (hxr : x ^ n = â†‘m) (hv : Â¬âˆƒ (y : â„¤), x = â†‘y) (hnpos : 0 < n) : Irrational x
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} (P : Î¹ â†’ P) (i0 : Î¹) : Vector_Span k (set.Range P) = Submodule.Span k (set.Range (Î» (i : Î¹), P i0 -áµ¥ P i))
{x Y : Type u} (F : x âŸ¶ Y) : CategoryTheory.IsIso F â†” Function.Bijective F
{x : Type u_1} {Y : Type u_2} [NormedGroup x] [NormedGroup Y] [NormedSpace â„ x] [NormedSpace â„ Y] {F : x â†’ Y} {x : x} : ConformalAt F x â†” IsConformalMap (fderiv â„ F x)
(F : â„ â†’ â„) {A B : â„} (hab : A < B) (g : â„ â†’ â„) {lfa lga lfb lgb : â„} (hdf : DifferentiableOn â„ F (set.Ioo A B)) (hdg : DifferentiableOn â„ g (set.Ioo A B)) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds lfa)) (hga : Filter.Tendsto g (nhds_within A (set.ioi A)) (nhds lga)) (hfb : Filter.Tendsto F (nhds_within B (set.Iio B)) (nhds lfb)) (hgb : Filter.Tendsto g (nhds_within B (set.Iio B)) (nhds lgb)) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), (lgb - lga) * deriv F C = (lfb - lfa) * deriv g C
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] {P : Î¹ â†’ E} : Convex_Independent ð•œ P â†” âˆ€ (S : Finset Î¹) (x : Î¹), P x âˆˆ â‡‘(Convex_hull ð•œ) â†‘(Finset.image P S) â†’ x âˆˆ S
 : Filter.Tendsto Coe Filter.cofinite (Filter.cocompact â„)
{Î· : Type u_5} {F : Î· â†’ Type u_6} [Î  (i : Î·), AddGroup (F i)] [DecidableEq Î·] [Fintype Î·] {h : Î  (i : Î·), Add_Subgroup (F i)} {J : Add_Subgroup (Î  (i : Î·), F i)} : Add_Subgroup.Pi set.Univ h â‰¤ J â†” âˆ€ (i : Î·), Add_Subgroup.Map (AddMonoid_hom.single F i) (h i) â‰¤ J
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [NormedSpace ð•œ E'] {n : WithTop â„•} {F : E â†’ E'} : ContDiff ð•œ n F â†’ Cont_mdiff (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') n F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {S : set ð•œ} {n : WithTop â„•} {m : â„•} (h : ContDiff_on ð•œ n F S) (hmn : â†‘m â‰¤ n) (hs : UniqueDiffOn ð•œ S) : Continuous_on (iterated_deriv_within m F S) S
{Î³ : Type W} [EmetricSpace Î³] {S : set Î³} (hs : IsCompact S) : âˆƒ (t : set Î³) (h : t âŠ† S), t.countable âˆ§ S = Closure t
{m : Type u_1} [MulOneClass m] {S t : Submonoid m} (h : âˆ€ (x : m), x âˆˆ S â†” x âˆˆ t) : S = t
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Nontrivial R] [Nonempty Î¹] (e : Basis Î¹ R m) (x : Orientation R m Î¹) (i : Î¹) : â‡‘(e.adjust_to_Orientation x) i = â‡‘e i âˆ¨ â‡‘(e.adjust_to_Orientation x) i = -â‡‘e i
{m : Type u_3} [AddMonoid m] [Preorder m] (L : List m) (h : L.Sum < 0) : 0 < L.length
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (h : â†‘(S.topological_Closure) = set.Univ) : âˆ¥S.normed_Mkâˆ¥ = 0
{C : Type u} [CategoryTheory.Category C] {x Y : C} (F : x âŸ¶ Y) (t : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.PullbackCone.Mk (ðŸ™ x) (ðŸ™ x) rfl)) : CategoryTheory.Mono F
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [Nonempty Î²] [SemilatticeSup Î²] {S : Î² â†’ Î±} (B : Î² â†’ â„) (h : âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ HasDist.dist (S n) (S m) â‰¤ B N) (hâ‚€ : Filter.Tendsto B Filter.at_top (nhds 0)) : Cauchy_Seq S
{x : â„} (hx : 0 â‰¤ x) (y z : â„) : x ^ y * x ^ z â‰¤ x ^ (y + z)
{Î¹ : Type u_1} {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [ordered_AddCommMonoid N] (F : m â†’ N) (h_Mul : âˆ€ (x y : m), F (x + y) â‰¤ F x + F y) {S : Finset Î¹} (hs : S.Nonempty) (g : Î¹ â†’ m) : F (S.Sum (Î» (i : Î¹), g i)) â‰¤ S.Sum (Î» (i : Î¹), F (g i))
(n : â„•) : (n + 2).Factors = (n + 2).min_fac :: ((n + 2) / (n + 2).min_fac).Factors
{Î± : Type u} [Preorder Î±] {S : set Î±} {A : Î±} (h : IsGreatest S A) : BddAbove S
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {n : â„•} (hn : Fintype.Card Î² * n < Fintype.Card Î±) : âˆƒ (y : Î²), n < (Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Card
{n m : â„•} (e : Fin n â‰ƒo Fin m) (i : Fin n) : â†‘(â‡‘e i) = â†‘i
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{Î± : Type u_1} {Î¹ : sort u_2} (m : Î¹ â†’ MeasureTheory.OuterMeasure Î±) {S : set Î±} (hs : S.Nonempty) : (â‡‘â¨… (i : Î¹), m i) S = â¨… (t : â„• â†’ set Î±) (h2 : S âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹), â‡‘(m i) (t n)
{m : Type u_1} [AddMonoid m] : _Add_Submonoid set.Univ
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} (h : S.Finite) : Finite_dimensional k â†¥((affine_Span k S).direction)
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} (hF : Function.Injective F) : Function.Injective (Option.Map F)
(S : â„) : Filter.Tendsto (Î» (x : â„), Real.Exp x / x ^ S) Filter.at_top Filter.at_top
{G : Type u_2} [Group G] : MulAction.FixedPoints (ConjAct G) G = â†‘(Subgroup.Center G)
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S t : set Î±} (hs : BddAbove S) (sne : S.Nonempty) (ht : BddAbove t) (tne : t.Nonempty) : HasSup.Sup (S âˆª t) = HasSup.Sup S âŠ” HasSup.Sup t
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : EuclideanGeometry.Orthogonal_projection_fn S P -áµ¥ P âˆˆ (S.direction)á—®
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] {S : Finset Î±} (F : Î± â†’ Î²) : Mul_Opposite.Op (S.Sum (Î» (x : Î±), F x)) = S.Sum (Î» (x : Î±), Mul_Opposite.Op (F x))
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} {S : set Î±} {x : Î±} (h : Continuous_within_at F S x) : Filter.Tendsto F (nhds_within x S) (nhds (F x))
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [DecidableEq Î³] (S : Finset Î±) (t : Finset Î²) (F : Î± Ã— Î² â†’ Finset Î³) : (S.Product t).bUnion F = S.bUnion (Î» (A : Î±), t.bUnion (Î» (B : Î²), F (A, B)))
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} : StrictMono F â†’ StrictAnti (â‡‘order_dual.to_dual âˆ˜ F)
{Î± : Type u} [Preorder Î±] {A B C : Î±} : B â‰¤ C â†’ A = B â†’ A â‰¤ C
{Î± : Type u} {Î² : Type v} [AddCommMonoid Î²] (S : Finset Î±) (F : Finset Î± â†’ Î²) : S.powerset.Sum (Î» (t : Finset Î±), F t) = (Finset.Range (S.Card + 1)).Sum (Î» (j : â„•), (Finset.powerset_len j S).Sum (Î» (t : Finset Î±), F t))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] [CompleteSpace ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [Finite_dimensional ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {A : E} (hF : HasStrictFderivAt F F' A) (hF' : F'.Range = âŠ¤) {Î± : Type u_4} {l : Filter Î±} {gâ‚ : Î± â†’ F} {gâ‚‚ : Î± â†’ â†¥(F'.Ker)} (hâ‚ : Filter.Tendsto gâ‚ l (nhds (F A))) (hâ‚‚ : Filter.Tendsto gâ‚‚ l (nhds 0)) : Filter.Tendsto (Î» (t : Î±), HasStrictFderivAt.implicit_Function F F' hF hF' (gâ‚ t) (gâ‚‚ t)) l (nhds A)
{Î± : Type u_3} {Î² : Type u_4} [Nonempty Î±] [SemilatticeSup Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Monotone F) : Filter.Tendsto F Filter.at_top Filter.at_top â†” âˆ€ (B : Î²), âˆƒ (A : Î±), B â‰¤ F A
{R : Type uâ‚} [Linear_ordered_Ring R] {A : R} (h : -2 â‰¤ A) (n : â„•) : 1 + â†‘n * A â‰¤ (1 + A) ^ n
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A : Î±} : 1 â‰¤ Aâ»Â¹ â†’ A â‰¤ 1
{Î± : Type u_1} {m : Type u_4} [has_Zero m] {S : set Î±} {F : Î± â†’ m} {A : Î±} (h : S.indicator F A â‰  0) : A âˆˆ S
{R : Type u_1} [CommMonoid_with_Zero R] (F : Nat.ArithmeticFunction R) (hF : F.Multiplicative) (g : Nat.ArithmeticFunction R) (hg : g.Multiplicative) : F = g â†” âˆ€ (P i : â„•), Nat.Prime P â†’ â‡‘F (P ^ i) = â‡‘g (P ^ i)
{Î¹ : Type u} {Î³ : Type W} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [Î  (i : Î¹), AddZeroClass (Î² i)] [AddCommMonoid Î³] (F : Î  (i : Î¹), Î² i â†’+ Î³) (i : Î¹) : (â‡‘Dfinsupp.Lift_Add_hom F).Comp (Dfinsupp.single_Add_hom Î² i) = F i
{Î± : Type u_1} {R : Type u_2} {l : Filter Î±} {F : Î± â†’ R} {r : R} [Linear_ordered_Ring R] [Archimedean R] (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (Î» (x : Î±), F x * r) l Filter.at_top
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [Field K] (nth_Part_denom_Ne_Zero : âˆ€ {B : K}, g.partial_denominators.nth n = Option.Some B â†’ B â‰  0) : g.convergents (n + 1) = (g.squash_gcf n).convergents n
{R : Type u_1} [CommRing R] [IsDomain R] {A B C : R} (h2 : 2 â‰  0) (ha : A â‰  0) (x : R) : A * x * x + B * x + C = 0 â†” discrim A B C = (2 * A * x + B) ^ 2
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} {n : â„•} : GeneralizedContinuedFraction.Int_fract_pair.Stream v (n + 1) = Option.None â†” GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.None âˆ¨ âˆƒ (ifp : GeneralizedContinuedFraction.Int_fract_pair K), GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp âˆ§ ifp.fr = 0
{Î± : Type u_1} (F : Î± â†’ Î± â†’ Î±) [IsAssociative Î± F] (x y : Î±) : F x âˆ˜ F y = F (F x y)
{mâ‚€ : Type u_1} [Mul_Zero_class mâ‚€] : (Î» (_x : mâ‚€), _x * 0) = Function.Const mâ‚€ 0
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {F : â„‚ â†’ E} (hD : Diff_Cont_on_cl â„‚ F {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : Asymptotics.SuperpolynomialDecay Filter.at_top Real.Exp (Î» (x : â„), âˆ¥F â†‘xâˆ¥)) (him : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥F (â†‘x * Complex.i)âˆ¥ â‰¤ C) : set.Eq_on F 0 {z : â„‚ | 0 â‰¤ z.re}
{E : Type u_1} [AddCommGroup E] [module â„ E] [TopologicalSpace E] [has_Continuous_Smul â„ E] {F : Type u_2} [AddCommGroup F] [module â„ F] [TopologicalSpace F] [has_Continuous_Smul â„ F] [t2_Space F] (F : E â†’+ F) (hF : Continuous â‡‘F) (C : â„) (x : E) : â‡‘F (C â€¢ x) = C â€¢ â‡‘F x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type W} [CategoryTheory.Category J] (K : J â¥¤ C) (F : C â¥¤ D) [CategoryTheory.Limits.HasLimit (K â‹™ F)] [CategoryTheory.CreatesLimit K F] : CategoryTheory.Limits.HasLimit K
(n : â„•) (R : Type u_1) [Ring R] : (Polynomial.cyclotomic n R).monic
{A B : Prop} : Â¬(A âˆ§ B) â†” Â¬A âˆ¨ Â¬B
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {A : Î±} {S : set Î±} (h : A âˆ‰ S â†’ F A = 0) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ HasInsert.Insert A S), F i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i))
{Î± : Type u_1} {Î² : Type u_2} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {K : Nnreal} {F : Î± â†’ Î²} : AntilipschitzWith K F â†’ âˆ€ (x y : Î±), HasNndist.nndist x y â‰¤ K * HasNndist.nndist (F x) (F y)
(x : â„‚) : HasStrictDerivAt Complex.cosh (Complex.sinh x) x
{m : Type u_1} [Monoid m] (u : mË£) (A : m) : IsUnit (â†‘u * A) â†” IsUnit A
{R : Type u_1} [CommRing R] : set.surj_on (Î» (g : Matrix.special_Linear_Group (Fin 2) R), â†‘g 1) set.Univ {cd : Fin 2 â†’ R | _IsCoprime (cd 0) (cd 1)}
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{Î± : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} [LinearOrder Î¹] {F : MeasureTheory.Filtration Î¹ m} {Ï„ : Î± â†’ Î¹} [TopologicalSpace Î¹] [OrderTopology Î¹] [TopologicalSpace.first_countable_topology Î¹] (hÏ„ : MeasureTheory.IsStoppingTime F Ï„) (i : Î¹) (h_IsLub : IsLub (set.Iio i) i) : Measurable_set {x : Î± | Ï„ x < i}
{Î± : Type u} {Î² : Type v} [Semiring Î±] [Semiring Î²] {F : Î± â†’ Î²} (hF : _Semiring_hom F) {Î³ : Type u_1} [Semiring Î³] {g : Î² â†’ Î³} (hg : _Semiring_hom g) : _Semiring_hom (g âˆ˜ F)
{Î± : Type u_1} {Î¹ : Type u_3} [CompleteLattice Î±] [Fintype Î¹] {F : Î¹ â†’ Î±} : CompleteLattice.Independent F â†’ Finset.Univ.Sup_indep F
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_at F A) (hb : Continuous_at F B) : HasFderivAt (Î» (P : â„ Ã— â„), âˆ« (x : â„) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd â„ â„ â„).Smul_Right (F B) - (Continuous_Linear_Map.fst â„ â„ â„).Smul_Right (F A)) (A, B)
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 2)} : x.Î´ i â‰« x.Î´ (â‡‘Fin.cast_Succ i) = x.Î´ i â‰« x.Î´ i.Succ
{m : Type u_1} [has_Add m] {r S : m â†’ m â†’ Prop} (h : âˆ€ (x y : m), r x y â†’ S x y) : Add_Con_gen r â‰¤ Add_Con_gen S
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (ð•œ : Type u_3) [DivisionRing ð•œ] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Linear ð•œ C] {x Y : C} [CategoryTheory.Simple x] [CategoryTheory.Simple Y] (h : (x â‰… Y) â†’ False) : Finite_dimensional.finrank ð•œ (x âŸ¶ Y) = 0
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (B : n â†’ Î±) (h : IsUnit A.det) : A.det â€¢ Matrix.vec_Mul B Aâ»Â¹ = â‡‘(A.transpose.cramer) B
{Î± : Type u_1} [LinearOrder Î±] {S : set Î±} : Â¬BddBelow S â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (h : y âˆˆ S), y < x
{k : â„•} : Fact (Even (Fintype.Card (Fin (bit0 k))))
{n : â„•} (hn : n % 2 = 1) : â‡‘Zmod.Ï‡â‚„ â†‘n = (-1) ^ (n / 2)
{Î¹ : Type u_1} {Râ‚‚ : Type u_7} {mâ‚‚ : Type u_8} [CommRing Râ‚‚] [AddCommGroup mâ‚‚] [module Râ‚‚ mâ‚‚] [DecidableEq Î¹] (e : Basis Î¹ Râ‚‚ mâ‚‚) (W : Î¹ â†’ Râ‚‚Ë£) : e.to_Matrix â‡‘(e.units_Smul W) = Matrix.Diagonal (Coe âˆ˜ W)
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} {Î¹ : Type v} (hs : IsCompact S) (Z : Î¹ â†’ set Î±) (hZc : âˆ€ (i : Î¹), IsClosed (Z i)) (hsZ : (S âˆ© â‹‚ (i : Î¹), Z i) = âˆ…) : âˆƒ (t : Finset Î¹), (S âˆ© â‹‚ (i : Î¹) (h : i âˆˆ t), Z i) = âˆ…
(l : List â„•) (n : â„•) : List.Sorted has_LE.LE (Denumerable.raise l n)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ Mon_) [CategoryTheory.IsFiltered J] (j : J) : 1 = Mon_.FilteredColimits.m.Mk F âŸ¨j, 1âŸ©
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} {n : â„•} {ifp_Succ_n : GeneralizedContinuedFraction.Int_fract_pair K} (Stream_Succ_nth_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v (n + 1) = Option.Some ifp_Succ_n) : (GeneralizedContinuedFraction.of v).S.nth n = Option.Some {A := 1, B := â†‘(ifp_Succ_n.B)}
(ð•œ : Type u_1) {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_3} [LinearOrder Î¹] [OrderBot Î¹] [locally_Finite_order Î¹] [IsWellOrder Î¹ has_LT.LT] [SuccOrder Î¹] [IsSuccArchimedean Î¹] (F : Î¹ â†’ E) (hâ‚€ : LinearIndependent ð•œ F) : Orthonormal ð•œ (gram_schmidt_normed ð•œ F)
{G : Type u_1} [Group G] {N : Type u_2} [Group N] (F : G â†’* N) (hF : Function.Surjective â‡‘F) : F.Range = âŠ¤
{R : Type u_1} {A : R} [Mul_Zero_class R] [Nontrivial R] (ra : IsRightRegular A) : A â‰  0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {x : E} {n : WithTop â„•} {F : E â†’ F} (hF : ContDiff_at ð•œ n F x) : ContDiff_at ð•œ n (Î» (x : E), -F x) x
{Î± : Type u_1} {Î² : sort u_2} {Î³ : sort u_3} {S : set Î±} (e : Î² â‰ƒ â†¥S) (v : Î² â†’ Î³) (W : Î± â†’ Î³) (j : Î²) (x : Î³) [DecidableEq Î²] [DecidableEq Î±] [Î  (j : Î±), Decidable (j âˆˆ S)] : (Î» (i : Î±), dite (i âˆˆ S) (Î» (h : i âˆˆ S), Function.update v j x (â‡‘(e.Symm) âŸ¨i, hâŸ©)) (Î» (h : i âˆ‰ S), W i)) = Function.update (Î» (i : Î±), dite (i âˆˆ S) (Î» (h : i âˆˆ S), v (â‡‘(e.Symm) âŸ¨i, hâŸ©)) (Î» (h : i âˆ‰ S), W i)) â†‘(â‡‘e j) x
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m â†’* P} (h : C â‰¤ Con.Ker F) (x : m) : â‡‘(C.Lift F h) â†‘x = â‡‘F x
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) {r : â„} : 2 â€¢ o.oangle (r â€¢ x) x = 0
{G : Type u_6} {h : Type u_7} {F : Type u_8} [AddGroup G] [subtraction_Monoid h] [AddMonoid_hom_class F G h] (F : F) (A B : G) : â‡‘F (A + -B) = â‡‘F A + -â‡‘F B
{Î± : Type u} [TopologicalSpace Î±] [t2_Space Î±] (h : TopologicalSpace._topological_Basis {S : set Î± | IsClopen S}) : TotallySeparatedSpace Î±
{Î± : Type uu} (A : Î±) {lâ‚ lâ‚‚ : List Î±} : A :: lâ‚ <+~ A :: lâ‚‚ â†’ lâ‚ <+~ lâ‚‚
{m : Type u_3} {F : Type u_8} {G : Type u_1} [Group G] [Monoid m] [Monoid_hom_class F G m] {F g : F} {x : G} (h : â‡‘F x = â‡‘g x) : â‡‘F xâ»Â¹ = â‡‘g xâ»Â¹
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} [CompactSpace Î±] : Metric.Bounded S
{x : Type u_2} [EmetricSpace x] {mâ‚ mâ‚‚ : Ennreal â†’ Ennreal} (hle : mâ‚ â‰¤á¶ [nhds_within 0 (set.ici 0)] mâ‚‚) : MeasureTheory.OuterMeasure.Mk_metric mâ‚ â‰¤ MeasureTheory.OuterMeasure.Mk_metric mâ‚‚
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {A B C : v} {F : A âŸ¶ B} [CategoryTheory.Limits.HasImage F] {g : B âŸ¶ C} [CategoryTheory.Limits.HasKernel g] (W : F â‰« g = 0) {A' B' C' : v} {F' : A' âŸ¶ B'} [CategoryTheory.Limits.HasImage F'] {g' : B' âŸ¶ C'} [CategoryTheory.Limits.HasKernel g'] (W' : F' â‰« g' = 0) (Î± : CategoryTheory.Arrow.Mk F âŸ¶ CategoryTheory.Arrow.Mk F') [CategoryTheory.Limits.HasImage_Map Î±] (Î² : CategoryTheory.Arrow.Mk g âŸ¶ CategoryTheory.Arrow.Mk g') (P : Î±.Right = Î².Left) : image_to_Kernel F g W â‰« CategoryTheory.Limits.Kernel_Subobject_Map Î² = CategoryTheory.Limits.image_Subobject_Map Î± â‰« image_to_Kernel F' g' W'
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] {F g : P1 â†’áµƒ[k] P2} (h : âˆ€ (P : P1), â‡‘F P = â‡‘g P) : F = g
{Î± : Type u_1} [Preorder Î±] [locally_Finite_order Î±] {A B : Î±} : Â¬A < B â†’ Finset.ioc A B = âˆ…
{E : Type u_1} [NormedGroup E] {F : â„‚ â†’ E} {C : â„‚} {R : â„} [NormedSpace â„‚ E] (hF : CircleIntegrable F C R) : IntervalIntegrable (Î» (Î¸ : â„), deriv (Circle_Map C R) Î¸ â€¢ F (Circle_Map C R Î¸)) MeasureTheory.MeasureSpace.Volume 0 (2 * Real.Pi)
{Î± : Type u_1} (C : set (set Î±)) (hc : Setoid._Partition C) : (Setoid.Mk_Classes C _).Classes = C
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B C : Î±} : B < Aâ»Â¹ * C â†’ A * B < C
{Î± : Type u_1} {S t : set Î±} : Disjoint S t â†’ Disjoint (Filter.principal S) (Filter.principal t)
{Î± : Type u_1} {l : List Î±} : l <+: List.Nil â†’ l = List.Nil
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [AddZeroClass m] [AddCommMonoid N] {F g : Î± â†’â‚€ m} {h : Î± â†’ m â†’ N} (h_Zero : âˆ€ (A : Î±), A âˆˆ F.Support âˆª g.Support â†’ h A 0 = 0) (h_Add : âˆ€ (A : Î±), A âˆˆ F.Support âˆª g.Support â†’ âˆ€ (Bâ‚ Bâ‚‚ : m), h A (Bâ‚ + Bâ‚‚) = h A Bâ‚ + h A Bâ‚‚) : (F + g).Sum h = F.Sum h + g.Sum h
(Î± : Type u) [Semiring Î±] [Nontrivial Î±] : âˆƒ (m : Ideal Î±), m.IsMaximal
{Î± : Type u_1} {Î¹ : sort u_4} [CompleteLattice Î±] {B : Î±} {F : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), B â‰¤ F i) (hâ‚‚ : âˆ€ (W : Î±), B < W â†’ (âˆƒ (i : Î¹), F i < W)) : (â¨… (i : Î¹), F i) = B
(x : â„) : 0 < Real.cosh x
{n P : â„•} (hp : Nat.Prime P) : multiplicity P (P * (n + 1)).factorial = multiplicity P (P * n).factorial + multiplicity P (n + 1) + 1
{ð•‚ : Type u_1} [nondiscrete_NormedField ð•‚] [CompleteSpace ð•‚] [CharZero ð•‚] {x : ð•‚} (hx : x âˆˆ Emetric.Ball 0 (Exp_series ð•‚ ð•‚).radius) : HasDerivAt (Exp ð•‚) (Exp ð•‚ x) x
{R : Type u_1} [MulOneClass R] : IsRegular 1
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [Nontrivial k] {P : Î¹ â†’ P} (ha : AffineIndependent k P) : Function.Injective P
{A B C : â„¤} (h : fermat_42 A B C) : âˆƒ (A0 B0 C0 : â„¤), fermat_42.Minimal A0 B0 C0 âˆ§ A0 % 2 = 1 âˆ§ 0 < C0
{Î± : Type u_1} {Î² : Type u_2} [has_Add Î±] [Preorder Î±] [Preorder Î²] [CovariantClass Î± Î± has_Add.Add has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {F g : Î² â†’ Î±} (hF : Monotone F) (hg : StrictMono g) : StrictMono (Î» (x : Î²), F x + g x)
(P : â„•) [hp : Fact (Nat.Prime P)] {n i j : â„•} (hi : i < n) (hj : j < P ^ (n - i)) : j - pnat_multiplicity P âŸ¨j + 1, _âŸ© + n = i + j + (n - i - pnat_multiplicity P âŸ¨j + 1, _âŸ©)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : â„•} (S : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : â„•} (h : fs.Card = m + 1) (i : Fin (m + 1)) : (S.face h).points i = S.points (â‡‘(fs.order_emb_of_Fin h) i)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (P : Î¹ â†’ P) : (S.affine_combination P).Linear = S.weighted_vsub P
{Î± : Type u} (ls : List (List Î±)) [DecidableEq Î±] (x : Î±) (hx : âˆ€ (l : List Î±), l âˆˆ ls â†’ x âˆ‰ l) (hls : ls â‰  List.Nil) : List.split_on x ([x].intercalate ls) = ls
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [AddCommMonoid Î²] [AddCommMonoid Î³] (g : Î² â†’+ Î³) (F : Î± â†’ Î²) (S : Finset Î±) : â‡‘g (S.Sum (Î» (x : Î±), F x)) = S.Sum (Î» (x : Î±), â‡‘g (F x))
{C : Type uâ‚} [CategoryTheory.Category C] {xâ‚â‚ xâ‚â‚‚ xâ‚‚â‚ xâ‚‚â‚‚ xâ‚ƒâ‚ xâ‚ƒâ‚‚ : C} {hâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚â‚‚} {hâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚‚â‚‚} {hâ‚ƒâ‚ : xâ‚ƒâ‚ âŸ¶ xâ‚ƒâ‚‚} {vâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚‚â‚} {vâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚‚â‚‚} {vâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚ƒâ‚} {vâ‚‚â‚‚ : xâ‚‚â‚‚ âŸ¶ xâ‚ƒâ‚‚} (S : CategoryTheory.IsPullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : CategoryTheory.IsPullback hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚) : CategoryTheory.IsPullback hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚
{mâ‚€ : Type u_1} [Monoid_with_Zero mâ‚€] [Nontrivial mâ‚€] (u : mâ‚€Ë£) : â†‘u â‰  0
{C : Type u} [CategoryTheory.Category C] (P q : C) [CategoryTheory.Limits.HasBinaryProduct P q] : CategoryTheory.Limits.HasBinaryProduct q P
 : (Polynomial_Functions Unit_Interval).topological_Closure = âŠ¤
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C â¥¤ D) {x Y Z : C} {F : x âŸ¶ Y} {g : Y âŸ¶ Z} [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.Additive] [CategoryTheory.Limits.preserves_Finite_colimits F] [CategoryTheory.Epi g] (ex : CategoryTheory.Exact F g) : CategoryTheory.Exact (F.Map F) (F.Map g)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) {P : P} (hr : âˆƒ (r : â„), âˆ€ (i : Fin (n + 1)), HasDist.dist (S.points i) P = r) : â†‘(â‡‘(S.Orthogonal_projection_Span) P) = S.circumcenter
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (h : 0 < (1 - r) * (B - A)) : F (â‡‘(affine_Map.line_Map A B) r) < â‡‘(affine_Map.line_Map (F A) (F B)) r â†” slope F A B < slope F (â‡‘(affine_Map.line_Map A B) r) B
{Î± : Type u} {Î² : Type v} : (Î± â†ª Î²) â†’ (Î² â†ª Î±) â†’ Nonempty (Î± â‰ƒ Î²)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h2 : P2 â‰  P1) (h3 : P3 â‰  P1) : EuclideanGeometry.angle P1 P2 P3 + EuclideanGeometry.angle P2 P3 P1 + EuclideanGeometry.angle P3 P1 P2 = Real.Pi
{G : Type u_6} {h : Type u_7} {F : Type u_8} [Group G] [division_Monoid h] [Monoid_hom_class F G h] (F : F) (g : G) (n : â„¤) : â‡‘F (g ^ n) = â‡‘F g ^ n
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] {n : Type W} [Nontrivial R] [no_Zero_divisors R] (B : BilinForm R m) (v : Basis n R m) (hO : B._Ortho â‡‘v) : B.nondegenerate â†” âˆ€ (i : n), Â¬B.IsOrtho (â‡‘v i) (â‡‘v i)
{x : Type u_1} [TopologicalSpace x] [CompactSpace x] {Y : Type u_2} [TopologicalSpace Y] : IsClosed_Map Prod.Snd
{n : â„•} : Prime_Pow n â†” âˆƒ! (P : â„•), Nat.Prime P âˆ§ P âˆ£ n
{Î± : Type u} (x : Î±) : Function.IsFixedPt Id x
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {n : WithTop â„•} : ContDiff ð•œ n F â†” HasFtaylorSeriesUpTo n F (ftaylor_series ð•œ F)
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (q : QuadraticForm R m) (m : m) : â‡‘(clifford_Algebra.Î¹ q) m * â‡‘(clifford_Algebra.Î¹ q) m = â‡‘(Algebra_Map R (clifford_Algebra q)) (â‡‘q m)
(ð•œ : Type u_5) (E : Type u_6) [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [Nontrivial E] : NoncompactSpace E
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] : Continuous (Î» (P : Continuous_MultilinearMap ð•œ E G Ã— Î  (i : Î¹), E i), â‡‘(P.fst) P.Snd)
{G : Type u_1} [AddCommMonoid G] (tG : AddMonoid._torsion G) : AddCommMonoid.Add_torsion G = âŠ¤
{m : Type u_1} [has_Add m] {C D : Add_Con m} (h : âˆ€ (x y : m), â‡‘C x y â†” â‡‘D x y) : C = D
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] [Finite_dimensional K L] {x : L} : â‡‘(Algebra.norm K) x = 0 â†” x = 0
{x : â„} (h : 0 < x) (h' : x â‰¤ 1) : x - x ^ 3 / 4 < Real.sin x
{Î³ : Type W} [MetricSpace Î³] {x y : Î³} : HasNndist.nndist x y = 0 â†” x = y
{K : Type u} [Field K] (S : Subfield K) (m : Multiset K) : (âˆ€ (A : K), A âˆˆ m â†’ A âˆˆ S) â†’ m.Prod âˆˆ S
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (G : C â¥¤ D) [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.Empty C) G] : CategoryTheory.Limits.HasTerminal D
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} : 0 < A - B â†’ B < A
(P : â„•) [Fact (Nat.Prime P)] (A : â„¤) (ha : â†‘A â‰  0) : Zmod.legendre_Sym P (A ^ 2) = 1
{Î± : Type u} (S t : set Î±) : Cardinal.Mk â†¥(S âˆª t) â‰¤ Cardinal.Mk â†¥S + Cardinal.Mk â†¥t
{Î¹ : Type u} (S : Finset Î¹) (F g : Î¹ â†’ Nnreal) {P q : â„} (hpq : P.IsConjugateExponent q) : S.Sum (Î» (i : Î¹), F i * g i) â‰¤ S.Sum (Î» (i : Î¹), F i ^ P) ^ (1 / P) * S.Sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
{R : Type u} [CommRing R] {P : Ideal R} (h : P.Prime) : IsDomain (Polynomial R â§¸ Ideal.Map Polynomial.C P)
(G : Type u_1) [Monoid G] (L : Type u_2) [CommRing L] [no_Zero_divisors L] : LinearIndependent L (Î» (F : G â†’* L), â‡‘F)
{Î± : Type u} {S : set Î±} : S.countable â†’ {t : set Î± | t.Finite âˆ§ t âŠ† S}.countable
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {Î¹ : Type u_1} (B : Basis Î¹ R m) {Îº : Type u_1} (v : Îº â†’ m) (i : LinearIndependent R v) : Cardinal.Mk Îº â‰¤ Cardinal.Mk Î¹
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) [Invertible A] : â…Ÿ A = Aâ»Â¹
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type W} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (hu : CategoryTheory.CoverLifting J K G) (â„± : CategoryTheory.sheaf J A) {x : A} {U : D} {S : CategoryTheory.Sieve U} (hS : S âˆˆ â‡‘K U) {x : CategoryTheory.Presieve.FamilyOfElements ((CategoryTheory.ran G.Op).obj â„±.val â‹™ CategoryTheory.coyoneda.obj (Opposite.Op x)) S.Arrows} (hx : x.compatible) : x._amalgamation (CategoryTheory.ran__sheaf_of_CoverLifting.glued_section hu â„± hS hx)
(R : Type u_1) [CommRing R] (m : Type u_2) [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [Nontrivial R] : LinearMap.trace R m = (contract_Left R m).Comp (dual_tensor_hom_Equiv R m m).Symm.to_Linear_Map
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h0 : 0 < r) (h : â†‘r < P.radius) : âˆƒ (C : â„) (h : C > 0), âˆ€ (n : â„•), âˆ¥P nâˆ¥ â‰¤ C / â†‘r ^ n
{ð’ª : Type u} {K : Type v} {Î“ : Type W} [CommRing ð’ª] [IsDomain ð’ª] [Field K] [Algebra ð’ª K] [Linear_ordered_comm_Group_with_Zero Î“] (v : Valuation K Î“) (hH : v.integers ð’ª) : Valuation_Ring ð’ª
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] [DecidableEq Î±] (S : Finset Î±) (F : Î± â†’ Î²) {A : Î±} (h : A âˆˆ S) : (S.erase A).Sum (Î» (x : Î±), F x) + F A = S.Sum (Î» (x : Î±), F x)
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ âˆ…), F i)) = 1
{Î± : Type u_1} {n : Type u_3} [DecidableEq n] [has_Zero Î±] (v : n â†’ Î±) : (Matrix.Diagonal v).IsSymm
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {n : WithTop â„•} (e : G â‰ƒL[ð•œ] E) : ContDiff_on ð•œ n (F âˆ˜ â‡‘e) (â‡‘e â»Â¹' S) â†” ContDiff_on ð•œ n F S
{Î± : Type u_1} {Î¹ : sort u_4} {l : Filter Î±} {P : Î¹ â†’ Prop} {S : Î¹ â†’ set Î±} (h : l.has_Basis P S) {v : set Î±} (hV : v âˆˆ l) : l.has_Basis (Î» (i : Î¹), P i âˆ§ S i âŠ† v) S
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : IsCompact S â†” âˆ€ {Î¹ : Type u} (Z : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ (S âˆ© â‹‚ (i : Î¹), Z i) = âˆ… â†’ (âˆƒ (t : Finset Î¹), (S âˆ© â‹‚ (i : Î¹) (h : i âˆˆ t), Z i) = âˆ…)
{Î± : Type u} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] : Filter.Tendsto (Î» (x : Î±), xâ»Â¹) (nhds_within 0 (set.ioi 0)) Filter.at_top
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle â„ P) : t.orthocenter = Affine.Simplex.monge_point t
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {g : Î² â†’ Î³} (hg : Function.Injective g) : Function.Injective (Function.Comp g)
(o : Ordinal) : o.to_Pgame.Numeric
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {S : set Î±} {x : Î±} {P : Filter Î¹} {g : Î¹ â†’ Î±} [TopologicalSpace Î±] (h : TendstoUniformlyOn F F P S) (hF : Continuous_within_at F S x) (hg : Filter.Tendsto g P (nhds_within x S)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) P (nhds (F x))
{A B : â„} {g' g : â„ â†’ â„} (hab : A â‰¤ B) (hcont : Continuous_on g (set.icc A B)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivAt g (g' x) x) (g'Pos : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ 0 â‰¤ g' x) : MeasureTheory.IntegrableOn g' (set.ioc A B) MeasureTheory.MeasureSpace.Volume
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) : (S.circumcenter_circumradius.fst âˆˆ affine_Span â„ (set.Range S.points) âˆ§ âˆ€ (i : Fin (n + 1)), HasDist.dist (S.points i) S.circumcenter_circumradius.fst = S.circumcenter_circumradius.Snd) âˆ§ âˆ€ (cccr : P Ã— â„), (cccr.fst âˆˆ affine_Span â„ (set.Range S.points) âˆ§ âˆ€ (i : Fin (n + 1)), HasDist.dist (S.points i) cccr.fst = cccr.Snd) â†’ cccr = S.circumcenter_circumradius
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} (h_Mono : StrictMono_on F S) (hs : S âˆˆ nhds_within A (set.Iic A)) (hfs : âˆ€ (B : Î²), B < F A â†’ (âˆƒ (C : Î±) (h : C âˆˆ S), F C âˆˆ set.Ico B (F A))) : Continuous_within_at F (set.Iic A) A
(A : Type u_1) (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] : minpoly A 0 = Polynomial.x
{G : Type u_1} [Group G] {Î¹ : sort u_2} (S : Î¹ â†’ Subgroup G) {C : Î  (x : G), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : G) (h : x âˆˆ S i), C x _) (h1 : C 1 _) (HMul : âˆ€ (x y : G) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x * y) _) {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
(x : â„) : Real.arsinh (Real.sinh x) = x
(n : â„•) {A : â„} (h : 2 - ((A - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ Real.sqrt_two_Add_series (â†‘0 / â†‘1) n) (hâ‚‚ : 1 / 4 ^ n â‰¤ A) : Real.Pi < A
{Î± : sort u} {Î² : sort v} {F : Î± â†’ Î²} (hF : Function.Injective F) [Subsingleton Î²] : Subsingleton Î±
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {P : P} (hp : P âˆ‰ S) : HasDist.dist P â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P) â‰  0
(P : â„• â†’ â„• â†’ Prop) (ha : âˆ€ (A : â„•), P (A + 1) (A + 1)) (hb : âˆ€ (B : â„•), P 0 (B + 1)) (hD : âˆ€ (A B : â„•), A < B â†’ P (A + 1) B â†’ P A (B + 1) â†’ P (A + 1) (B + 1)) (A B : â„•) : A < B â†’ P A B
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P : P) : Function.Injective (Î» (_x : P), _x -áµ¥ P)
{G : Type u_1} [Group G] [hG : Group.IsNilpotent G] : Nat.Find _ = Group.nilpotency_class G
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {P : Î¹ â†’ P} (ha : AffineIndependent k P) : AffineIndependent k (Î» (x : â†¥(set.Range P)), â†‘x)
{Î± : Type u_1} [Preorder Î±] {A B : Î±} (h : A < B) : Â¬IsMax A
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} {g : â„ â†’ E} (fdiff : DifferentiableOn â„ F (set.icc A B)) (gdiff : DifferentiableOn â„ g (set.icc A B)) (hderiv : set.Eq_on (deriv_within F (set.icc A B)) (deriv_within g (set.icc A B)) (set.Ico A B)) (hi : F A = g A) (y : â„) (h : y âˆˆ set.icc A B) : F y = g y
{G : Type u_7} [Group G] (L : List G) : (L.Prod)â»Â¹ = (List.Map (Î» (x : G), xâ»Â¹) L).reverse.Prod
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {m : MeasurableSpace Î±} [TopologicalSpace Î²] [TopologicalSpace.pseudo_metrizable_Space Î²] [MeasurableSpace Î²] [BorelSpace Î²] : MeasureTheory.strongly_Measurable F â†” Measurable F âˆ§ TopologicalSpace._IsSeparable (set.Range F)
{n : â„•} : order_of (Quaternion_Group.A 1) = 2 * n
{Î± : Type u_1} [TopologicalSpace Î±] {x : Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] {F g : Î± â†’ Î³} (hF : UpperSemicontinuous_at F x) (hg : UpperSemicontinuous_at g x) (hcont : Continuous_at (Î» (P : Î³ Ã— Î³), P.fst + P.Snd) (F x, g x)) : UpperSemicontinuous_at (Î» (z : Î±), F z + g z) x
{R : Type u_1} [CommSemiring R] {m : Submonoid R} {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization m S] {g : R â†’+* P} (hg : âˆ€ (y : â†¥m), IsUnit (â‡‘g â†‘y)) (x : R) (y : â†¥m) : â‡‘(IsLocalization.Lift hg) (IsLocalization.Mk' S x y) = â‡‘g x * â†‘(â‡‘(IsUnit.Lift_Right (g.to_Monoid_hom.Restrict m) hg) y)â»Â¹
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {F : â„‚ â†’ E} (hD : Diff_Cont_on_cl â„‚ F (set.Iio 0 Ã—â„‚ set.Iio 0)) (hB : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.Iio 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ F â†‘x = 0) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ F (â†‘x * Complex.i) = 0) : set.Eq_on F 0 {z : â„‚ | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}
{Î± : Type u_1} {G : Type u_4} [conditionally_CompleteLattice Î±] [Group G] (Fâ‚ Fâ‚‚ : G â†’* Î± â‰ƒo Î±) (hbdd : âˆ€ (x : Î±), BddAbove (set.Range (Î» (g : G), â‡‘(â‡‘Fâ‚ g)â»Â¹ (â‡‘(â‡‘Fâ‚‚ g) x)))) (g : G) : Function.Semiconj (Î» (x : Î±), â¨† (g' : G), â‡‘(â‡‘Fâ‚ g')â»Â¹ (â‡‘(â‡‘Fâ‚‚ g') x)) â‡‘(â‡‘Fâ‚‚ g) â‡‘(â‡‘Fâ‚ g)
{R : Type u_1} {A : Type u_2} {m : Type u_3} {N : Type u_4} {P : Type u_5} [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid m] [module R m] [module A m] [IsScalarTower R A m] [AddCommMonoid N] [module R N] [AddCommMonoid P] [module R P] [module A P] [IsScalarTower R A P] : Function.Injective TensorProduct.Algebra_tensor_module.Curry
{C : Type u} [CategoryTheory.Category C] {x : C} (i : CategoryTheory.Arrow C) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.Mk (ðŸ™ x))
{Î± : Type u} [SemilatticeSup Î±] [Nonempty Î±] (S : Finset Î±) : BddAbove â†‘S
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : (Matrix n n Î±)Ë£) : â†‘Aâ»Â¹ = (â†‘A)â»Â¹
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommGroup Î²] [HasScalar ð•œ E] [module ð•œ Î²] {S : set E} {F : E â†’ Î²} : Convex_on ð•œ S (-F) â†” ConcaveOn ð•œ S F
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {mâ‚ mâ‚‚ : Ennreal â†’ Ennreal} (hle : mâ‚ â‰¤á¶ [nhds_within 0 (set.ici 0)] mâ‚‚) : MeasureTheory.Measure.Mk_metric mâ‚ â‰¤ MeasureTheory.Measure.Mk_metric mâ‚‚
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S : AffineSubspace k P} (h : â†‘S.Nonempty) : S.direction = âŠ¤ â†” S = âŠ¤
{G : Type u_1} [AddGroup G] {k : set G} : k âŠ† â†‘(Add_Subgroup.Closure k)
{C : Type u} [CategoryTheory.Category C] {A B : C} {F g : A âŸ¶ B} [CategoryTheory.IsReflexivePair F g] : CategoryTheory.IsReflexivePair g F
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m â†’* P} (h : C â‰¤ Con.Ker F) : (C.Lift F h).Comp C.Mk' = F
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) : S.normed_Mk.Ker = S
{Î± : Type u_1} [non_unital_semi_NormedRing Î±] (x y : Î±) : âˆ¥â‡‘(AddMonoid_hom.Mul_Right x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{R : Type u} [CommRing R] {n : â„•} (u : RË£) (hn : IsUnit â†‘n) : (Polynomial.x ^ n - â‡‘Polynomial.C â†‘u).IsSeparable
{Î± : sort u_1} (x : Î±) (h : âˆ€ (y : Î±), y = x) : Subsingleton Î±
{Î± : Type u_1} (L : List (List Î±)) (i : â„•) : List.take (List.take i (List.Map List.length L)).Sum L.Join = (List.take i L).Join
{K : Type u_1} {Kâ‚˜ : Type u_2} [Field K] [CommRing Kâ‚˜] {m : Submonoid K} (hM : 0 âˆ‰ m) [Algebra K Kâ‚˜] [IsLocalization m Kâ‚˜] : Function.Bijective â‡‘(Algebra_Map K Kâ‚˜)
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {mâ‚ : Type u_4} [TopologicalSpace mâ‚] [AddCommMonoid mâ‚] {mâ‚‚ : Type u_6} [TopologicalSpace mâ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚ mâ‚] [module Râ‚‚ mâ‚‚] [t2_Space mâ‚‚] {S : set mâ‚} (hs : Dense â†‘(Submodule.Span Râ‚ S)) {F g : mâ‚ â†’sl[Ïƒâ‚â‚‚] mâ‚‚} (h : set.Eq_on â‡‘F â‡‘g S) : F = g
{m : Type u_1} [AddMonoid m] {S : set m} {A : m} (hs : _Add_Submonoid S) (h : A âˆˆ S) {n : â„•} : n â€¢ A âˆˆ S
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x : L} : x âˆˆ S â†’ xâ»Â¹ âˆˆ S
{x : Type u_1} [UniformSpace x] {S : set x} [(Uniformity x)._countably_generated] : IsCompact S â†” _Seq_IsCompact S
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (x : module.Ray R m) : âŸ¦x.Some_Ray_VectorâŸ§ = x
{Î± : Type u_1} [TopologicalSpace Î±] {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] [has_Continuous_Add Î³] {F g : Î± â†’ Î³} (hF : LowerSemicontinuous F) (hg : LowerSemicontinuous g) : LowerSemicontinuous (Î» (z : Î±), F z + g z)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : 1 < A) (hb : 1 â‰¤ B) : 1 < A * B
{Î± : Type u_1} {Î² : Type u_2} {F g : Î± â†’ Î²} {m : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} {P : Î± â†’ Prop} {_x : Decidable_Pred P} (hp : Measurable_set {A : Î± | P A}) (hF : Measurable F) (hg : Measurable g) : Measurable (Î» (x : Î±), Ite (P x) (F x) (g x))
{Î± : Type u} [TopologicalSpace Î±] (A : Î±) : (nhds A).has_Basis (Î» (S : set Î±), A âˆˆ S âˆ§ IsOpen S) (Î» (S : set Î±), S)
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {C : Î±} [Linear_ordered_AddCommGroup Î±] [Archimedean Î±] (h : Function.Periodic F C) (hc : 0 < C) (x A : Î±) : âˆƒ (y : Î±) (h : y âˆˆ set.Ico A (A + C)), F x = F y
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup vâ‚‚] [module k vâ‚‚] [AddTorsor vâ‚‚ Pâ‚‚] {S : set P} (e : P â‰ƒáµƒ[k] Pâ‚‚) : AffineIndependent k Coe â†” AffineIndependent k Coe
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (x : CategoryTheory.SimplicialObject C) (n : â„•) : AlgebraicTopology.alternating_face_Map_Complex.obj_D x (n + 1) â‰« AlgebraicTopology.alternating_face_Map_Complex.obj_D x n = 0
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {v : E} : â†‘(â‡‘(Orthogonal_projection K) v) = v â†” v âˆˆ K
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : (F =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ F =O[l] g'
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] (x : C) (h : âˆ€ {Z : C} (F : x âŸ¶ Z) [_inst_3 : CategoryTheory.Epi F], CategoryTheory.IsIso F â†” F â‰  0) : CategoryTheory.Simple x
{R : Type u_1} {S : Type u_2} [EuclideanDomain R] [CommRing S] [IsDomain S] [Algebra R S] (abv : AbsoluteValue R â„¤) {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] (bS : Basis Î¹ R S) {t : Type u_3} [Linear_ordered_Ring t] (A : S) {y : t} (hy : âˆ€ (k : Î¹), â†‘(â‡‘abv (â‡‘(â‡‘(bS.repr) A) k)) < y) : â†‘(â‡‘abv (â‡‘(Algebra.norm R) A)) < â†‘(class_Group.norm_bound abv bS) * y ^ Fintype.Card Î¹
(k : Type u_1) [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) [CharZero k] [Fintype Î¹] {n : â„•} (h : S.Card = n + 1) : Finset.Univ.Sum (Î» (i : Î¹), Finset.centroid_weights_indicator k S i) = 1
{m : Type u_1} [AddMonoid m] {Sâ‚ Sâ‚‚ : set m} (â‚ : _Add_Submonoid Sâ‚) (â‚‚ : _Add_Submonoid Sâ‚‚) : _Add_Submonoid (Sâ‚ âˆ© Sâ‚‚)
{m : Type u_1} [has_Mul m] {C D : Con m} : Setoid.r = Setoid.r â†” C = D
{Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [Semiring Î²] [has_Mul Î±] [has_Mul Î±â‚‚] {F : Type u_4} [Mul_hom_class F Î± Î±â‚‚] (F : F) (x y : Monoid_Algebra Î² Î±) : Finsupp.Map_IsDomain â‡‘F (x * y) = Finsupp.Map_IsDomain â‡‘F x * Finsupp.Map_IsDomain â‡‘F y
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {x y : m} : SameRay R (-x) (-y) â†” SameRay R x y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type uâ‚} [CategoryTheory.Category D] (h : C â‰Œ D) : CategoryTheory.IsFiltered D
{P : Polynomial â„š} (P_irr : Irreducible P) (P_deg : Nat.Prime P.Nat_degree) (P_roots1 : Fintype.Card â†¥(P.root_set â„) + 1 â‰¤ Fintype.Card â†¥(P.root_set â„‚)) (P_roots2 : Fintype.Card â†¥(P.root_set â„‚) â‰¤ Fintype.Card â†¥(P.root_set â„) + 3) : Function.Bijective â‡‘(Polynomial.Gal.Gal_action_hom P â„‚)
{G : Type u_1} [Linear_ordered_AddCommGroup G] [Archimedean G] {h : Add_Subgroup G} {A : G} (ha : IsLeast {g : G | g âˆˆ h âˆ§ 0 < g} A) : h = Add_Subgroup.Closure {A}
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B : Î±} (ha : A < 0) (hb : B < 0) : A + B < 0
{m : â„•} (hm : 0 < m) (k : â„•) : âˆƒ (P : â„•), Liouville.Liouville_number_initial_terms â†‘m k = â†‘P / â†‘m ^ k.factorial
{Î± : Type u_1} [has_LE Î±] {A : Î±áµ’áµˆ} : _IsBot A â†’ _top (â‡‘order_dual.of_dual A)
{J : Type v} {C : Type u} [CategoryTheory.Category C] {x Y : C} {F : J â†’ (x âŸ¶ Y)} [Nonempty J] {t : CategoryTheory.Limits.Trident F} (ht : CategoryTheory.Limits.IsLimit t) {Z Z' : C} (q : Z' âŸ¶ Z) (k : Z âŸ¶ t.x) : â†‘(â‡‘(CategoryTheory.Limits.Trident._Limit.hom_is_iso ht Z') (q â‰« k)) = q â‰« â†‘(â‡‘(CategoryTheory.Limits.Trident._Limit.hom_is_iso ht Z) k)
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Monotone F) : Pairwise (Disjoint on Î» (n : Î±), set.Ico (F (Order.Pred n)) (F n))
{Î² : Type u} {Î³ : Type W} [CommSemiring Î²] [CommSemiring Î³] (F : Î² â†’+* Î³) (S : Multiset Î²) : â‡‘F S.Prod = (Multiset.Map â‡‘F S).Prod
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), Monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : _of_Fin_order x) (i : Î·) : _of_Fin_order (x i)
{Î± : Type u_3} {Î² : Type u_4} [Linear_ordered_Field Î±] {l : Filter Î²} {F : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (Î» (x : Î²), F x / r) l Filter.at_IsBot
{Î± : Type u} {Î² : Type v} [AddZeroClass Î±] [AddZeroClass Î²] {F : Î± â†’ Î²} (hF : _AddMonoid_hom F) (x y : Î±) : F (x + y) = F x + F y
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * HasInner.inner x y + âˆ¥yâˆ¥ ^ 2
{E : Type u_2} {ð•œ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] {S : set E} (hs : Convex ð•œ S) {x y : E} (hx : x âˆˆ S) (hy : y âˆˆ Interior S) {t : ð•œ} (ht : t âˆˆ set.ioc 0 1) : x + t â€¢ (y - x) âˆˆ Interior S
(ð•œ : Type u_1) [nondiscrete_NormedField ð•œ] {n : WithTop â„•} {R : Type u_6} [NormedRing R] [normed_Algebra ð•œ R] [CompleteSpace R] (x : RË£) : ContDiff_at ð•œ n Ring.Inverse â†‘x
{K : Type u} [Field K] (S : Subfield K) {x : K} : x âˆˆ S â†’ xâ»Â¹ âˆˆ S
{K : Type u_1} [Field K] (F : Polynomial K) (A : K) (hF' : Polynomial.Eval A (â‡‘Polynomial.derivative F) â‰  0) : _IsCoprime (Polynomial.x - â‡‘Polynomial.C A) (F /â‚˜ (Polynomial.x - â‡‘Polynomial.C A))
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] {x : top} (F : top.Presheaf C x) : F._sheaf â†” F._sheaf_Unique_gluing
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R x (r â€¢ y)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {t : E â†’â‚—[ð•œ] E} (hT : InnerProductSpace.IsSelfAdjoint t) {v : Submodule ð•œ E} (hV : âˆ€ (v : E), v âˆˆ v â†’ â‡‘t v âˆˆ v) : InnerProductSpace.IsSelfAdjoint (t.Restrict hV)
{Î± : Type u} [t : TopologicalSpace Î±] {A : Î±} {S : set Î±} {B : set (set Î±)} (hb : TopologicalSpace._topological_Basis B) : S âˆˆ nhds A â†” âˆƒ (t : set Î±) (h : t âˆˆ B), A âˆˆ t âˆ§ t âŠ† S
{n : â„•} {i : Fin (n + 1)} : SimplexCategoryÎ´ i.Succ â‰« SimplexCategoryÏƒ i = ðŸ™ (SimplexCategory.Mk n)
{G : Type u_1} [Group G] (h : Subgroup G) [h.Normal] : upper_central_series_step h = Subgroup.comap (Quotient_Group.Mk' h) (Subgroup.Center (G â§¸ h))
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) [Finite_dimensional k â†¥(Vector_Span k S)] : Collinear k S â†” Finite_dimensional.finrank k â†¥(Vector_Span k S) â‰¤ 1
{R : Type u_4} [Linear_ordered_Ring R] (A : R) (h : A â‰  0) : 0 < A ^ 2
{n : â„•} {Î± : Type u_1} {v : Vector Î± n} : v.reverse.to_List = v.to_List.reverse
{R : Type u_1} [Ring R] {m : Type u_2} [AddCommGroup m] [module R m] {N : Type u_3} [AddCommGroup N] [module R N] [_simple_module R m] [_simple_module R N] (F : m â†’â‚—[R] N) : Function.Bijective â‡‘F âˆ¨ F = 0
{r : â„} (hr : 0 â‰¤ r) (h'r : r < 1) : Filter.Tendsto (Î» (n : â„•), â†‘n * r ^ n) Filter.at_top (nhds 0)
(K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [module.Finite K L] {R : Type z} [CommRing R] [Algebra R K] [Algebra R L] [IsScalarTower R K L] [IsDomain R] [_IsSeparable K L] [_integrally_IsClosed R] [_fraction_Ring R K] {B : power_Basis K L} (hint : IsIntegral R B.gen) {z : L} (hz : IsIntegral R z) : Algebra.discr K â‡‘(B.Basis) â€¢ z âˆˆ Algebra.Adjoin R {B.gen}
{Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), MetricSpace (E i)] [âˆ€ (i : Î¹), CompleteSpace (E i)] : CompleteSpace (Î£ (i : Î¹), E i)
{F : Type u_8} {G : Type u_1} {h : Type u_2} [Group G] [MulOneClass h] [Monoid_hom_class F G h] (F : F) : Function.Injective â‡‘F â†” âˆ€ (A : G), â‡‘F A = 1 â†’ A = 1
{Î± : Type u_1} {ð•œ : Type u_14} [NormedField ð•œ] {l : Filter Î±} {F g : Î± â†’ ð•œ} (hgf : âˆ€ (x : Î±), g x = 0 â†’ F x = 0) : Filter.Tendsto (Î» (x : Î±), F x / g x) l (nhds 0) â†’ F =o[l] g
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {F : â„‚ â†’ E} (hD : Diff_Cont_on_cl â„‚ F (set.ioi 0 Ã—â„‚ set.Iio 0)) (hB : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.ioi 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ F â†‘x = 0) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ F (â†‘x * Complex.i) = 0) : set.Eq_on F 0 {z : â„‚ | 0 â‰¤ z.re âˆ§ z.im â‰¤ 0}
{x : Type u_1} [TopologicalSpace x] {x y : x} {F : set x} (h : JoinedIn F x y) : Joined âŸ¨x, _âŸ© âŸ¨y, _âŸ©
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : MeasurableSpace Î±} {mâ‚‚ : MeasurableSpace Î²} {F : Î± â†’ Î²} : Measurable F â†’ MeasurableSpace.comap F mâ‚‚ â‰¤ mâ‚
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {S : set E} [CompleteSpace F] (h : AnalyticOn ð•œ F S) : AnalyticOn ð•œ (fderiv ð•œ F) S
(k : Type u_1) {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype Î¹] (P : Î¹ â†’ P) {n : â„•} (hc : Fintype.Card Î¹ = n + 1) : AffineIndependent k P â†” Finite_dimensional.finrank k â†¥(Vector_Span k (set.Range P)) = n
{Î± : Type u} [AddCommGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B C : Î±} : A + B â‰¤ C â†’ B â‰¤ C - A
{R : Type u} [Ring R] {S : set R} : S âŠ† â†‘(Subring.Closure S)
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {F g : â„‚ â†’ E} (hdf : Diff_Cont_on_cl â„‚ F (set.ioi 0 Ã—â„‚ set.ioi 0)) (hBf : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.ioi 0 Ã—â„‚ set.ioi 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hdg : Diff_Cont_on_cl â„‚ g (set.ioi 0 Ã—â„‚ set.ioi 0)) (hBg : âˆƒ (C : â„) (h : C < 2) (B : â„), g =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.ioi 0 Ã—â„‚ set.ioi 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ F â†‘x = g â†‘x) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ F (â†‘x * Complex.i) = g (â†‘x * Complex.i)) : set.Eq_on F g {z : â„‚ | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] {B : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.Some B) : âˆƒ (z : â„¤), B = â†‘z
(R : Type u_1) [CommRing R] (m k : â„•) : 2 * Polynomial.Chebyshev.t R m * Polynomial.Chebyshev.t R (m + k) = Polynomial.Chebyshev.t R (2 * m + k) + Polynomial.Chebyshev.t R k
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u_3} [CategoryTheory.Category D] [CategoryTheory.Preadditive D] (G : C â¥¤ D) [G.Additive] (x : CategoryTheory.SimplicialObject C) (q n : â„•) : (AlgebraicTopology.DoldKan.hÏƒ q).F n = G.Map ((AlgebraicTopology.DoldKan.hÏƒ q).F n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type uâ‚} [CategoryTheory.Category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) : CategoryTheory.IsCofiltered D
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m â†’* P} (h : C â‰¤ Con.Ker F) (g : C.Quotient â†’* P) (Hg : g.Comp C.Mk' = F) : g = C.Lift F h
(G : Type u_1) [Group G] (n : â„•) (x : G) : x âˆˆ upper_central_series G (n + 1) â†” âˆ€ (y : G), x * y * xâ»Â¹ * yâ»Â¹ âˆˆ upper_central_series G n
(P : â„•) [Fact (Nat.Prime P)] (A B : â„¤) : Zmod.legendre_Sym P (A * B) = Zmod.legendre_Sym P A * Zmod.legendre_Sym P B
{v : Type u_9} {K : Type u_10} [Field K] [AddCommGroup v] [module K v] {B : BilinForm K v} {x : v} (hx : Â¬B.IsOrtho x x) : _IsCompl (Submodule.Span K {x}) (B.Orthogonal (Submodule.Span K {x}))
{R : Type u_1} {A B : R} [Semigroup R] (rra : IsRightRegular A) (rrb : IsRightRegular B) : IsRightRegular (A * B)
(Î± : Type u) [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] [TopologicalSpace.IsSeparable_Space Î±] [Nontrivial Î±] : âˆƒ (S : set Î±), S.countable âˆ§ Dense S âˆ§ (âˆ€ (x : Î±), _IsBot x â†’ x âˆ‰ S) âˆ§ âˆ€ (x : Î±), _top x â†’ x âˆ‰ S
{C : Type uâ‚} [CategoryTheory.Category C] {B A : C} {x : CategoryTheory.Subobject B} (F : A âŸ¶ B) [CategoryTheory.Mono F] (i : â†‘x â‰… A) (W : i.hom â‰« F = x.arrow) : x = CategoryTheory.Subobject.Mk F
{C : Type uâ‚} [CategoryTheory.Category C] {J : Type uâ‚‚} [CategoryTheory.Category J] (F : J â¥¤ Cáµ’áµ–) [CategoryTheory.Limits.HasLimit F.Left_Op] : CategoryTheory.Limits.HasColimit F
(E : Type u_1) [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] : âˆƒ (Î´ : â„), 0 < Î´ âˆ§ Î´ < 1 âˆ§ âˆ€ (S : Finset E), (âˆ€ (C : E), C âˆˆ S â†’ âˆ¥Câˆ¥ â‰¤ 2) â†’ (âˆ€ (C : E), C âˆˆ S â†’ âˆ€ (D : E), D âˆˆ S â†’ C â‰  D â†’ 1 - Î´ â‰¤ âˆ¥C - Dâˆ¥) â†’ S.Card â‰¤ Besicovitch.multiplicity E
{P k : â„•} (hk : k â‰  0) (hp : Nat.Prime P) : (P ^ k).Factors.to_Finset = {P}
{Î± : Type u} [PseudoEmetricSpace Î±] {x y : Î±} {S : set Î±} (hx : x âˆˆ S) (hy : y âˆˆ S) : HasEdist.edist x y â‰¤ Emetric.diam S
{C : Type uâ‚} [CategoryTheory.Category C] {xâ‚â‚ xâ‚â‚‚ xâ‚â‚ƒ xâ‚‚â‚ xâ‚‚â‚‚ xâ‚‚â‚ƒ : C} {hâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚â‚‚} {hâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚â‚ƒ} {hâ‚‚â‚ : xâ‚‚â‚ âŸ¶ xâ‚‚â‚‚} {hâ‚‚â‚‚ : xâ‚‚â‚‚ âŸ¶ xâ‚‚â‚ƒ} {vâ‚â‚ : xâ‚â‚ âŸ¶ xâ‚‚â‚} {vâ‚â‚‚ : xâ‚â‚‚ âŸ¶ xâ‚‚â‚‚} {vâ‚â‚ƒ : xâ‚â‚ƒ âŸ¶ xâ‚‚â‚ƒ} (S : CategoryTheory.IsPullback (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)) (P : hâ‚â‚ â‰« vâ‚â‚‚ = vâ‚â‚ â‰« hâ‚‚â‚) (t : CategoryTheory.IsPullback hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚) : CategoryTheory.IsPullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚
{Î± : Type u_1} {C : set (set Î±)} (h : âˆ€ (A : Î±), âˆƒ! (B : set Î±) (h : B âˆˆ C), A âˆˆ B) : C.Pairwise_Disjoint Id
{x : â„} (hx : 0 < x) : 0 < Exp_Neg_Inv_glue x
{P : â„•} [hp : Fact (Nat.Prime P)] {k : Type u_1} [Field k] [Char_P k P] [perfect_Ring k P] : discrete_Valuation_Ring (witt_Vector P k)
(k : Type uâ‚) {G : Type uâ‚‚} [Semiring k] [has_Add G] {A : Type uâ‚ƒ} [non_unital_non_assoc_Semiring A] [Distrib_MulAction k A] {Ï†â‚ Ï†â‚‚ : AddMonoid_Algebra k G â†’â‚™â‚[k] A} (h : Ï†â‚.to_Mul_hom.Comp (AddMonoid_Algebra.of_magma k G) = Ï†â‚‚.to_Mul_hom.Comp (AddMonoid_Algebra.of_magma k G)) : Ï†â‚ = Ï†â‚‚
{Î± : Type u_1} {P : Î± â†’ Prop} [Decidable_Pred P] {S : Finset Î±} (h : âˆ€ (x : Î±), x âˆˆ S â†’ P x) : Finset.Filter P S = S
{A B : Cardinal} : Cardinal.aleph0 â‰¤ A * B â†” A â‰  0 âˆ§ B â‰  0 âˆ§ (Cardinal.aleph0 â‰¤ A âˆ¨ Cardinal.aleph0 â‰¤ B)
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {x x' Y Y' Z Z' : C} [CategoryTheory.ExactPairing Y Y'] (F : x âŸ¶ Z âŠ— Y') (g : x' âŸ¶ Z') : â‡‘((CategoryTheory.tensor_Right_hom_Equiv (x' âŠ— x) Y Y' (Z' âŠ— Z)).Symm) ((g âŠ— F) â‰« (Î±_ Z' Z Y').Inv) = (Î±_ x' x Y).hom â‰« (g âŠ— â‡‘((CategoryTheory.tensor_Right_hom_Equiv x Y Y' Z).Symm) F)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [BaireSpace Î±] [Encodable Î²] {F : Î² â†’ set Î±} (hc : âˆ€ (S : Î²), IsClosed (F S)) (hU : (â‹ƒ (S : Î²), F S) = set.Univ) : Dense (â‹ƒ (S : Î²), Interior (F S))
{Î± : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : Î± â†’ E} {g : Î± â†’ â„} {tâ‚€ : Filter Î±} (h : âˆ€ (n : Î±), âˆ¥F nâˆ¥ â‰¤ g n) (h' : Filter.Tendsto g tâ‚€ (nhds 0)) : Filter.Tendsto F tâ‚€ (nhds 0)
(F : â„• â†’ Nnreal) : Filter.Tendsto (Î» (i : â„•), âˆ‘' (k : â„•), F (k + i)) Filter.at_top (nhds 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (B : CategoryTheory.Limits.BinaryBicone x Y) (Total : B.fst â‰« B.inl_ + B.Snd â‰« B.inr_ = ðŸ™ B.x) : CategoryTheory.Limits.HasBinaryBiproduct x Y
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} [DiscreteTopology â†¥S] {x : Î±} (hx : x âˆˆ S) : âˆƒ (U : set Î±) (h : U âˆˆ nhds x), U âˆ© S = {x}
{Î± : Type u} {Î² : Type v} [complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [complete_LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {Î¹ : sort u_1} {F : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : Continuous_at F (infi g)) (Mf : Monotone F) (ftop : F âŠ¤ = âŠ¤) : F (infi g) = infi (F âˆ˜ g)
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] [AddGroup Î±] [uniform_AddGroup Î±] {hom : Type u_3} [UniformSpace Î²] [DiscreteTopology Î²] [AddGroup Î²] [uniform_AddGroup Î²] [AddMonoid_hom_class hom Î± Î²] {F : hom} : uniform_Continuous â‡‘F â†” IsOpen â†‘(â†‘F.Ker)
{Î± : Type u} [TopologicalSpace Î±] {Z A B : set Î±} (h : IsClopen Z) (cover : Z âŠ† A âˆª B) (ha : IsOpen A) (hb : IsOpen B) (hab : A âˆ© B = âˆ…) : IsClopen (Z âˆ© A)
{Î¹ : Type u_1} {Î± : Type u_2} [has_Zero Î±] {S : Finset Î¹} {F : Î¹ â†’â‚€ Î±} {t : Î¹ â†’â‚€ Finset Î±} (ht : t.Support âŠ† S) : F âˆˆ S.Finsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘F i âˆˆ â‡‘t i
(x : Type u) (Y : Type v) [MetricSpace x] [CompactSpace x] [Nonempty x] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : Isometry (GromovHausdorff.optimal_GH_injr x Y)
{Î± : Type u_1} {E : Î± â†’ Type u_2} [Î  (i : Î±), NormedGroup (E i)] {P q : Ennreal} (hpq : P.to_Real.IsConjugateExponent q.to_Real) (F : â†¥(Lp E P)) (g : â†¥(Lp E q)) : Summable (Î» (i : Î±), âˆ¥â‡‘F iâˆ¥ * âˆ¥â‡‘g iâˆ¥) âˆ§ âˆ‘' (i : Î±), âˆ¥â‡‘F iâˆ¥ * âˆ¥â‡‘g iâˆ¥ â‰¤ âˆ¥Fâˆ¥ * âˆ¥gâˆ¥
{R : Type u_1} [Add_Left_cancel_Semigroup R] (g : R) : _Add_Left_regular g
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] (h : âˆ€ (x y : E), âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†’ SameRay â„ x y) : strict_Convex_Space â„ E
{S : â„‚} (hs : 0 < S.re) {x : â„} (hX : 0 â‰¤ x) : (S + 1).partial_gamma x = S * S.partial_gamma x - â†‘(Real.Exp (-x)) * â†‘x ^ S
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) (y : E) : HasFpowerSeriesOnBall (Î» (z : E), F (z - y)) P (x + y) r
{Î± : Type u_1} [canonically_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {B C : Î±} [ContravariantClass Î± Î± has_Add.Add has_LE.LE] (h : C â‰¤ B) (A : Î±) : A + B - C = A + (B - C)
(n : â„•) (x : â„) (hx : 0 < x) : HasDerivAt (Exp_Neg_Inv_glue.F_aux n) (Polynomial.Eval x (Exp_Neg_Inv_glue.P_aux (n + 1)) * Real.Exp (-xâ»Â¹) / x ^ (2 * (n + 1))) x
{C : Type u} [CategoryTheory.Category C] (F G : CategoryTheory.Discrete PEmpty â¥¤ C) : F = G
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (q : QuadraticForm R m) (P q : Submodule R (clifford_Algebra q)) : Submodule.Map clifford_Algebra.reverse (P * q) = Submodule.Map clifford_Algebra.reverse q * Submodule.Map clifford_Algebra.reverse P
{Î¹ : Type u_1} [Fintype Î¹] : StdSimplex â„ Î¹ âŠ† metric.IsClosed_ball 0 1
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] : reflection âŠ¥ = Linear_Isometry_Equiv.Neg ð•œ
{E : Type u_1} [AddCommGroup E] [module â„ E] {S : set E} {x : E} : gauge S x = HasInf.Inf {r âˆˆ set.ioi 0 | râ»Â¹ â€¢ x âˆˆ S}
{R : Type u_1} [CommSemiring R] {A : Type u_2} [CommSemiring A] [Algebra R A] {m : Type u_3} [AddCommMonoid m] [module A m] [module R m] {D1 D2 : Derivation R A m} (S : set A) (hs : Algebra.Adjoin R S = âŠ¤) (h : set.Eq_on â‡‘D1 â‡‘D2 S) : D1 = D2
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] (D : â„) (S : set x) : â‡‘(MeasureTheory.Measure.hausdorff_measure D) S = â¨† (r : Ennreal) (hr : 0 < r), â¨… (t : â„• â†’ set x) (hts : S âŠ† â‹ƒ (n : â„•), t n) (ht : âˆ€ (n : â„•), Emetric.diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (h : (t n).Nonempty), Emetric.diam (t n) ^ D
{x y z : Pgame} (hâ‚ : x â‰¤ y) (hâ‚‚ : y.lf z) : x.lf z
{Î± : Type u} [LinearOrder Î±] {A B C : Î±} : set.Interval A C âŠ† set.Interval A B âˆª set.Interval B C
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Finite_dimensional R m] (x : Orientation R m Î¹) (F : m â‰ƒâ‚—[R] m) (h : Fintype.Card Î¹ = Finite_dimensional.finrank R m) : â‡‘(Orientation.Map Î¹ F) x = (â‡‘Linear_Equiv.det F)â»Â¹ â€¢ x
{h : Type u_1} [TopologicalSpace h] (G : StructureGroupoid h) {m : Type u_2} [TopologicalSpace m] [ChartedSpace h m] [HasGroupoid m G] {e e' : LocalHomeomorph m h} (hE : e âˆˆ ChartedSpace.Atlas h m) (hE' : e' âˆˆ ChartedSpace.Atlas h m) : e.Symm.Trans e' âˆˆ G
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B : Î±} (ha : A < 0) (hb : B < 0) : A + B < 0
{Î± : Type u_1} [Fintype Î±] [Field Î±] : Prime_Pow (Fintype.Card Î±)
{ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedGroup G] [NormedSpace ð•œ G] {F F' : ð•œ â†’ G} {S : set ð•œ} {C : Nnreal} (hs : Convex â„ S) (hF : âˆ€ (x : ð•œ), x âˆˆ S â†’ HasDerivWithinAt F (F' x) S x) (bound : âˆ€ (x : ð•œ), x âˆˆ S â†’ âˆ¥F' xâˆ¥â‚Š â‰¤ C) : LipschitzOnWith C F S
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : (-o).oangle x y = -o.oangle x y
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [AddCommMonoid Î±] {F : Î² â†’ Î±} {g : Î³ â†’ Î±} (h_Eq : âˆ€ (u : Finset Î³), âˆƒ (v : Finset Î²), âˆ€ (v' : Finset Î²), v âŠ† v' â†’ (âˆƒ (u' : Finset Î³), u âŠ† u' âˆ§ u'.Sum (Î» (x : Î³), g x) = v'.Sum (Î» (B : Î²), F B))) : Filter.Map (Î» (S : Finset Î²), S.Sum (Î» (B : Î²), F B)) Filter.at_top â‰¤ Filter.Map (Î» (S : Finset Î³), S.Sum (Î» (x : Î³), g x)) Filter.at_top
{G : Type u_3} [Group G] : Group.fg G â†” Monoid.fg G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P âŸ¶ q) (x y : â†¥P) : â‡‘F x = â‡‘F y â†’ (âˆƒ (z : â†¥P), â‡‘F z = 0 âˆ§ âˆ€ (R : C) (g : P âŸ¶ R), â‡‘g y = 0 â†’ â‡‘g z = â‡‘g x)
(P : â„•) [P_Prime : Fact (Nat.Prime P)] {q : â„š} (hq : q â‰  0) {k : â„•} : padic_val_rat P (q ^ k) = â†‘k * padic_val_rat P q
 : fourier_Subalgebra.topological_Closure = âŠ¤
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] (x : ð•œ) {ð•œ' : Type u_1} [nondiscrete_NormedField ð•œ'] [normed_Algebra ð•œ ð•œ'] [NormedSpace ð•œ' F] [IsScalarTower ð•œ ð•œ' F] {h : ð•œ â†’ ð•œ'} {h' : ð•œ'} {gâ‚ : ð•œ' â†’ F} {gâ‚' : F} (hg : HasDerivAt gâ‚ gâ‚' (h x)) (hH : HasDerivAt h h' x) : HasDerivAt (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x
{F : â„ â†’ â„} (hF : Differentiable â„ F) (hF'_Mono : StrictMono (deriv F)) : strict_Convex_on â„ set.Univ F
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} {C : â„‚} (hD : âˆ€á¶  (z : â„‚) in nhds_within C {C}á¶œ, Differentiable_at â„‚ F z) (ho : (Î» (z : â„‚), F z - F C) =o[nhds_within C {C}á¶œ] Î» (z : â„‚), (z - C)â»Â¹) : Filter.Tendsto F (nhds_within C {C}á¶œ) (nhds (lim (nhds_within C {C}á¶œ) F))
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A : Î±} : 0 < -A â†’ A < 0
{E : â„• â†’ Type u_1} [Î  (n : â„•), TopologicalSpace (E n)] [âˆ€ (n : â„•), DiscreteTopology (E n)] {S : set (Î  (n : â„•), E n)} (hs : IsClosed S) (hne : S.Nonempty) : âˆƒ (F : (Î  (n : â„•), E n) â†’ Î  (n : â„•), E n), (âˆ€ (x : Î  (n : â„•), E n), x âˆˆ S â†’ F x = x) âˆ§ set.Range F = S âˆ§ Continuous F
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] [Algebra K S] (pB : power_Basis K S) : â‡‘(Algebra.norm K) pB.gen = (-1) ^ pB.dim * (minpoly K pB.gen).Coeff 0
{m : Type u_2} {Î± : sort u_4} [CommMonoid m] {F : Î± â†’ m} (P : m â†’ Prop) (hpâ‚€ : P 1) (hpâ‚ : âˆ€ (x y : m), P x â†’ P y â†’ P (x * y)) (hpâ‚‚ : âˆ€ (i : Î±), P (F i)) : P (finprod (Î» (i : Î±), F i))
{F : Type u_3} [InnerProductSpace â„ F] {K : set F} (Ne : K.Nonempty) (hâ‚ : IsComplete K) (hâ‚‚ : Convex â„ K) (u : F) : âˆƒ (v : F) (h : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (W : â†¥K), âˆ¥u - â†‘Wâˆ¥
{F : Type u_3} [InnerProductSpace â„ F] (x y : F) : HasInner.inner x y = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] [NormedGroup F] [NormedSpace â„ F] [MeasurableSpace E] [BorelSpace E] [TopologicalSpace.SecondCountableTopology F] (F : E â†’ F) (S : set E) (F' : E â†’ (E â†’L[â„] F)) (hF' : âˆ€ (x : E), x âˆˆ S â†’ HasFderivWithinAt F (F' x) S x) (r : (E â†’L[â„] F) â†’ Nnreal) (rpos : âˆ€ (A : E â†’L[â„] F), r A â‰  0) : âˆƒ (t : â„• â†’ set E) (A : â„• â†’ (E â†’L[â„] F)), Pairwise (Disjoint on t) âˆ§ (âˆ€ (n : â„•), Measurable_set (t n)) âˆ§ (S âŠ† â‹ƒ (n : â„•), t n) âˆ§ (âˆ€ (n : â„•), ApproximatesLinearOn F (A n) (S âˆ© t n) (r (A n))) âˆ§ (S.Nonempty â†’ âˆ€ (n : â„•), âˆƒ (y : E) (h : y âˆˆ S), A n = F' y)
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTopologicalFiberBundle F Prod.Snd
{P : â„•} (hp : Nat.Prime P) {n : â„•} (hn : 0 < n) : (P ^ n).Totient = P ^ (n - 1) * (P - 1)
(x : top) (t : Type u) : (x.presheaf_to_Type t)._sheaf
 : Filter.Tendsto (Î» (x : â„), x ^ (1 / x)) Filter.at_top (nhds 1)
(K : Type u) [Field K] (v : Type v) [AddCommGroup v] [module K v] [Finite_dimensional K v] : (LinearMap.rtensor (module.dual K v) (contract_Left K v)).Comp ((TensorProduct.assoc K (module.dual K v) v (module.dual K v)).Symm.to_Linear_Map.Comp (LinearMap.ltensor (module.dual K v) (coevaluation K v))) = (TensorProduct.lid K (module.dual K v)).Symm.to_Linear_Map.Comp (TensorProduct.rid K (module.dual K v)).to_Linear_Map
{Î± : Type u} {Î² : Type v} (F : Î± â†’ Finset Î²) (h : (set.Range F).Finite) : (â‹ƒ (A : Î±), â†‘(F A)).Finite
{Î± : Type u_1} {Î² : Type u_3} [MeasurableSpace Î±] [MeasurableSpace Î²] {Î½ : MeasureTheory.Measure Î²} [MeasureTheory.sigma_Finite Î½] {F : Î± Ã— Î² â†’ Ennreal} (hF : Measurable F) : Measurable (Î» (x : Î±), âˆ«â» (y : Î²), F (x, y) âˆ‚Î½)
{Î± : Type u_1} [DecidableEq Î±] {S t : Finset Î±} (h : S âŠ† t) : (Finset.Ico S t).Card = 2 ^ (t.Card - S.Card) - 1
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) : (minpoly A x).Coeff 0 = 0 â†” x = 0
{Î¹ : Type u} {F g : Î¹ â†’ â„} {P : â„} (hp : 1 â‰¤ P) (hF : âˆ€ (i : Î¹), 0 â‰¤ F i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) {A B : â„} (hA : 0 â‰¤ A) (hB : 0 â‰¤ B) (hfA : has_Sum (Î» (i : Î¹), F i ^ P) (A ^ P)) (hgB : has_Sum (Î» (i : Î¹), g i ^ P) (B ^ P)) : âˆƒ (C : â„), 0 â‰¤ C âˆ§ C â‰¤ A + B âˆ§ has_Sum (Î» (i : Î¹), (F i + g i) ^ P) (C ^ P)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedSpace ð•œ E] [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ G} {S : set E} {x y : E} (hs : Convex â„ S) (hF : DifferentiableOn ð•œ F S) (hF' : âˆ€ (x : E), x âˆˆ S â†’ fderiv_within ð•œ F S x = 0) (hx : x âˆˆ S) (hy : y âˆˆ S) : F x = F y
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} (P : Î¹ â†’ P) (iâ‚€ : Î¹) : Vector_Span k (set.Range P) = Submodule.Span k (set.Range (Î» (i : {x // x â‰  iâ‚€}), P â†‘i -áµ¥ P iâ‚€))
{C : Type uâ‚} [CategoryTheory.Category C] {Z x Y : C} {C : CategoryTheory.Limits.BinaryCofan x Y} (h : CategoryTheory.Limits.IsColimit C) (t : CategoryTheory.Limits.IsInitial Z) : CategoryTheory.IsPushout (t.to ((CategoryTheory.Limits.pair x Y).obj {as := CategoryTheory.Limits.WalkingPair.Left})) (t.to ((CategoryTheory.Limits.pair x Y).obj {as := CategoryTheory.Limits.WalkingPair.Right})) C.inl_ C.inr_
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] [Nontrivial R] {Î¹ : Type W} (B : Basis Î¹ R m) {Îº : Type W'} (v : Îº â†’ m) (i : LinearIndependent R v) (m : i.Maximal) : (â‹ƒ (k : Îº), â†‘((â‡‘(B.repr) (v k)).Support)) = set.Univ
(C : Type (u+1)) [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] (D : Type (u+1)) [CategoryTheory.Category D] [CategoryTheory.ConcreteCategory D] [CategoryTheory.has_Forgetâ‚‚ C D] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] : CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forgetâ‚‚ C D)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ F} {S : set E} (g : F â†’L[ð•œ] G) (h : AnalyticOn ð•œ F S) : AnalyticOn ð•œ (â‡‘g âˆ˜ F) S
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] [TopologicalSpace ð•œ] [OrderTopology ð•œ] {S : set ð•œ} : strict_Convex ð•œ S â†” Convex ð•œ S
{m : Type u_1} [Monoid_with_Zero m] {Ï†â‚ Ï†â‚‚ : â„¤ â†’*â‚€ m} (h_Neg_One : â‡‘Ï†â‚ (-1) = â‡‘Ï†â‚‚ (-1)) (h_Pos : âˆ€ (n : â„•), 0 < n â†’ â‡‘Ï†â‚ â†‘n = â‡‘Ï†â‚‚ â†‘n) : Ï†â‚ = Ï†â‚‚
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasTerminal C] : CategoryTheory.Limits.has_Finite_products C
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Pretopology.to_grothendieck C âŠ¥ = âŠ¥
{Î¹ : Type u} (S : Finset Î¹) {F g : Î¹ â†’ â„} {P : â„} (hp : 1 â‰¤ P) (hF : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ F i) (hg : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ g i) : S.Sum (Î» (i : Î¹), (F i + g i) ^ P) ^ (1 / P) â‰¤ S.Sum (Î» (i : Î¹), F i ^ P) ^ (1 / P) + S.Sum (Î» (i : Î¹), g i ^ P) ^ (1 / P)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : S1 < S2 â†” S1 â‰¤ S2 âˆ§ âˆƒ (P : P) (h : P âˆˆ S2), P âˆ‰ S1
{Î± : Type u_1} {Î² : Type u_2} {F g : Î± â†’ Î²} {m : MeasurableSpace Î±} [TopologicalSpace Î²] {P : Î± â†’ Prop} {_x : Decidable_Pred P} (hp : Measurable_set {A : Î± | P A}) (hF : MeasureTheory.strongly_Measurable F) (hg : MeasureTheory.strongly_Measurable g) : MeasureTheory.strongly_Measurable (Î» (x : Î±), Ite (P x) (F x) (g x))
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S : AffineSubspace k P) : affine_Span k â†‘S = S
{Î± : Type u_1} {n : Type u_4} {m : Type u_5} [has_Zero Î±] {A : Matrix m m Î±} {D : Matrix n n Î±} (ha : A.IsDiag) (hD : D.IsDiag) : (Matrix.from_blocks A 0 0 D).IsDiag
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {B : m} [Linear_ordered_CommRing m] (hb : Fintype.Card Î² â€¢ B < â†‘(Fintype.Card Î±)) : âˆƒ (y : Î²), B < â†‘((Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Card)
{G : Type u_10} [AddGroup G] (A : G) : â‡‘(Equiv.Symm (Equiv.Add_Right A)) = Î» (x : G), x + -A
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (Sâ‚‚ : Finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) : â‡‘((Finset.Map e Sâ‚‚).affine_combination P) W = â‡‘(Sâ‚‚.affine_combination (P âˆ˜ â‡‘e)) (W âˆ˜ â‡‘e)
{Î± : Type u} {Î² : Type v} [complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [complete_LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {Î¹ : sort u_1} [Nonempty Î¹] {F : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : Continuous_at F (infi g)) (Mf : Monotone F) : F (â¨… (i : Î¹), g i) = â¨… (i : Î¹), F (g i)
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î± â†’ Î² Ã— Î³} (hF : Continuous F) : Continuous (Î» (A : Î±), (F A).fst)
{Î± : Type u} [Preorder Î±] {A B : Î±} : A â‰¤ B â†’ Â¬B â‰¤ A â†’ A < B
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Abelian v] {A B C D A' B' C' D' : v} {F : A âŸ¶ B} {g : B âŸ¶ C} {h : C âŸ¶ D} {F' : A' âŸ¶ B'} {g' : B' âŸ¶ C'} {h' : C' âŸ¶ D'} {Î± : A âŸ¶ A'} {Î² : B âŸ¶ B'} {Î³ : C âŸ¶ C'} {Î´ : D âŸ¶ D'} (commâ‚ : Î± â‰« F' = F â‰« Î²) (commâ‚‚ : Î² â‰« g' = g â‰« Î³) (commâ‚ƒ : Î³ â‰« h' = h â‰« Î´) (hfg : CategoryTheory.Exact F g) (hgh : CategoryTheory.Exact g h) (hF'g' : CategoryTheory.Exact F' g') (hÎ± : CategoryTheory.Epi Î±) (hÎ² : CategoryTheory.Mono Î²) (hÎ´ : CategoryTheory.Mono Î´) : CategoryTheory.Mono Î³
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Finite_dimensional R m] (x : Orientation R m Î¹) (F : m â‰ƒâ‚—[R] m) (h : Fintype.Card Î¹ = Finite_dimensional.finrank R m) : â‡‘(Orientation.Map Î¹ F) x = x â†” 0 < â‡‘LinearMap.det â†‘F
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Î¹ â†’ set P) : affine_Span k (â‹ƒ (i : Î¹), S i) = â¨† (i : Î¹), affine_Span k (S i)
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (u : RË£) (hu : 0 < â†‘u) (v : module.Ray R m) : u â€¢ v = v
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} {x : Î±} (Fin : Emetric.Hausdorff_edist S t â‰  âŠ¤) : metric.Inf_dist x t â‰¤ metric.Inf_dist x S + metric.Hausdorff_dist S t
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : â„•} (S : Affine.Simplex k P n) (i : Fin (n + 1)) : S.face _ = Affine.Simplex.Mk_of_point k (S.points i)
{Î± : Type u} {Î² : Type v} {Î³ : Type W} [PseudoEmetricSpace Î±] [TopologicalSpace Î²] [PseudoEmetricSpace Î³] (F : Î± Ã— Î² â†’ Î³) {S : set Î±} {t : set Î²} (K : Nnreal) (ha : âˆ€ (A : Î±), A âˆˆ S â†’ Continuous_on (Î» (y : Î²), F (A, y)) t) (hb : âˆ€ (B : Î²), B âˆˆ t â†’ LipschitzOnWith K (Î» (x : Î±), F (x, B)) S) : Continuous_on F (S Ã—Ë¢ t)
{Î± : Type u} [DecidableEq Î±] (i j : Î±) : Function.involutive (Î» (_x : Equiv.perm Î±), _x * Equiv.Swap i j)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (F : C(Î±, Î²)) (x : Î±) : Continuous_at â‡‘F x
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S : set Î±} (h : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) â‰  0) : S.Nonempty
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x y : E) : â‡‘_R_or_C.re (HasInner.inner x y) = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
{Î¹ : Type u_1} {Î± : Type u_3} [Preorder Î¹] [LinearOrder Î±] {u : Î¹ â†’ Î±} (h : Monotone u) (h : Â¬BddBelow (set.Range u)) : Filter.Tendsto u Filter.at_IsBot Filter.at_IsBot
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : Cáµ’áµ–} (F : x âŸ¶ Y) [CategoryTheory.IsIso (CategoryTheory.coyoneda.Map F)] : CategoryTheory.IsIso F
{m : Type u_3} [AddMonoid m] [Preorder m] [CovariantClass m m (Function.Swap has_Add.Add) has_LE.LE] [CovariantClass m m has_Add.Add has_LE.LE] {lâ‚ lâ‚‚ : List m} (h : lâ‚ <+ lâ‚‚) (hâ‚ : âˆ€ (A : m), A âˆˆ lâ‚‚ â†’ 0 â‰¤ A) : lâ‚.Sum â‰¤ lâ‚‚.Sum
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} {t : Add_Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) {q : Type u_4} [AddCommMonoid q] {k : t.Localization_Map q} (z : N) (u : q) : â‡‘(F.Map hy k) z = u â†” â‡‘(k.to_Map) (â‡‘g (F.sec z).fst) = â‡‘(k.to_Map) (â‡‘g â†‘((F.sec z).Snd)) + u
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {n : WithTop â„•} (h : ContDiff_on ð•œ n F S) (hs : UniqueDiffOn ð•œ S) (hn : 1 â‰¤ n) : Continuous_on (Î» (P : E Ã— E), â‡‘(fderiv_within ð•œ F S P.fst) P.Snd) (S Ã—Ë¢ set.Univ)
{Î± : Type u_1} {Î¹ : Type u_4} [TopologicalSpace Î±] {S : set Î¹} (hs : S.Finite) {F : Î¹ â†’ set Î±} (h : âˆ€ (i : Î¹), i âˆˆ S â†’ _GÎ´ (F i)) : _GÎ´ (â‹ƒ (i : Î¹) (h : i âˆˆ S), F i)
{Î± : Type u} [non_unital_non_assoc_Ring Î±] (k : Î±) (h : âˆ€ (x : Î±), x * k = 0 â†’ x = 0) : IsRightRegular k
{C : Type uâ‚} [CategoryTheory.Category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {x : C} (R : CategoryTheory.Presieve x) [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Presieve.IsSheafFor P R â†” Nonempty (CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofÎ¹ (CategoryTheory.Equalizer.fork_Map P R) _))
{Î± : Type u_1} [circular_Preorder Î±] {A B C : Î±} (h : HasBtw.Btw A B C) : HasBtw.Btw C A B
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) {râ‚ râ‚‚ : â„} : 2 â€¢ o.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
{Î± : Type u_1} {A B C : Î±} [LinearOrder Î±] [Add_comm_Semigroup Î±] [HasSub Î±] [HasOrderedSub Î±] (h : A - C < B - C) : A < B
{Î± : Type u} [LinearOrder Î±] (A B : Î±) : LinearOrder.min A B = A âˆ§ A â‰¤ B âˆ¨ LinearOrder.min A B = B âˆ§ B < A
{x y : Pgame} : x â‰¤ y â†” (âˆ€ (i : x.Left_moves), (âˆƒ (i' : y.Left_moves), x.move_Left i â‰¤ y.move_Left i') âˆ¨ âˆƒ (j : (x.move_Left i).Right_moves), (x.move_Left i).move_Right j â‰¤ y) âˆ§ âˆ€ (j : y.Right_moves), (âˆƒ (i : (y.move_Right j).Left_moves), x â‰¤ (y.move_Right j).move_Left i) âˆ¨ âˆƒ (j' : x.Right_moves), x.move_Right j' â‰¤ y.move_Right j
{R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (S : Finset Î¹) (Wâ‚ Wâ‚‚ : Î¹ â†’ R) (z : Î¹ â†’ E) (hwâ‚ : S.Sum (Î» (i : Î¹), Wâ‚ i) = 1) (hwâ‚‚ : S.Sum (Î» (i : Î¹), Wâ‚‚ i) = 1) (A B : R) (hab : A + B = 1) : A â€¢ S.Center_mass Wâ‚ z + B â€¢ S.Center_mass Wâ‚‚ z = S.Center_mass (Î» (i : Î¹), A * Wâ‚ i + B * Wâ‚‚ i) z
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} : strict_Convex_on ð•œ S F â†” Convex ð•œ S âˆ§ âˆ€ â¦ƒx y z : ð•œâ¦„, x âˆˆ S â†’ z âˆˆ S â†’ x < y â†’ y < z â†’ (F y - F x) / (y - x) < (F z - F y) / (z - y)
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} : Emetric.Hausdorff_edist S t = 0 â†” Closure S = Closure t
{Î± : Type u} [TopologicalSpace Î±] [LocallyCompactSpace Î±] [t2_Space Î±] (x : Î±) : âˆƒ (U : set Î±), IsOpen U âˆ§ x âˆˆ U âˆ§ IsCompact (Closure U)
{Î± : Type u_1} [PartialOrder Î±] {F : Î± â†’ Î±} {P : Î± â†’ Prop} {hF : âˆ€ (x : Î±), x â‰¤ F x} {hfp : âˆ€ (x : Î±), P (F x)} {hmin : âˆ€ â¦ƒx y : Î±â¦„, x â‰¤ y â†’ P y â†’ F x â‰¤ y} {x y : Î±} (hxy : x â‰¤ y) (hy : P y) : â‡‘(Closure_operator.Mkâ‚ƒ F P hF hfp hmin) x â‰¤ y
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {F : m â†’* N} (hF : âˆ€ (y : â†¥S), IsUnit (â‡‘F â†‘y)) {y z : â†¥S} (h : (â‡‘(IsUnit.Lift_Right (F.Restrict S) hF) y)â»Â¹ = (â‡‘(IsUnit.Lift_Right (F.Restrict S) hF) z)â»Â¹) : â‡‘F â†‘y = â‡‘F â†‘z
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [division_Monoid Î²] (F : Î± â†’* Î²) (g : Î±) (n : â„¤) : â‡‘F (g ^ n) = â‡‘F g ^ n
{Î± : Type u} [TopologicalSpace Î±] {F : Filter Î±} (h : âˆƒ (A : Î±), F â‰¤ nhds A) : F â‰¤ nhds (lim F)
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [module ð•œ E] {S : set E} (hs : Convex ð•œ S) (z : E) : Convex ð•œ ((Î» (x : E), x + z) â»Â¹' S)
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [LinearOrder Î²] [SuccOrder Î²] [IsSuccArchimedean Î²] {S : Î² â†’ set Î±} {t : set Î²} (ht : t.Ord_connected) (h : âˆ€ (n : Î²), n âˆˆ t â†’ IsPreconnected (S n)) (K : âˆ€ (n : Î²), n âˆˆ t â†’ Order.Succ n âˆˆ t â†’ (S n âˆ© S (Order.Succ n)).Nonempty) : IsPreconnected (â‹ƒ (n : Î²) (h : n âˆˆ t), S n)
(R : Type u) (L : Type v) [CommRing R] [lie_Ring L] [lie_Algebra R L] [lie_Algebra.IsNilpotent R L] : (â¨… (x : L), (â‡‘(lie_Algebra.ad R L) x).Maximal_generalized_eigenspace 0) = âŠ¤
{Î± : Type u} {n : â„•} (A : Array n Î±) : A.to_List = List.of_fn A.read
 : Filter.Tendsto Real.log Filter.at_top Filter.at_top
{Î± : Type u} [PseudoMetricSpace Î±] {u : â„• â†’ Î±} (hu : Cauchy_Seq u) : âˆƒ (R : â„) (h : R > 0), âˆ€ (m n : â„•), HasDist.dist (u m) (u n) < R
{R : Type u_1} [CommRing R] (hR : discrete_Valuation_Ring.has_Unit_Mul_Pow_Irreducible_factorization R) [IsDomain R] : Unique_factorization_Monoid R
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] (r : Î± â†’ Î² â†’ Prop) [Î  (A : Î±), Fintype â†¥(Rel.image r {A})] : (âˆ€ (A : Finset Î±), A.Card â‰¤ Fintype.Card â†¥(Rel.image r â†‘A)) â†” âˆƒ (F : Î± â†’ Î²), Function.Injective F âˆ§ âˆ€ (x : Î±), r x (F x)
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] (v : K) : (GeneralizedContinuedFraction.Int_fract_pair.Stream v)._Seq
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {F : â„ â†’ E} {g : â„ â†’ F} {A B C : â„} (hne : A â‰  B) (hc : C âˆˆ set.Interval A B) (h_deriv : âˆ€á¶  (x : â„) in nhds_within C (set.Interval A B  {C}), Differentiable_at â„ F x) (h_infty : Filter.Tendsto (Î» (x : â„), âˆ¥F xâˆ¥) (nhds_within C (set.Interval A B  {C})) Filter.at_top) (hg : deriv F =O[nhds_within C (set.Interval A B  {C})] g) : Â¬IntervalIntegrable g MeasureTheory.MeasureSpace.Volume A B
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [module ð•œ Î²] (F : E â†’â‚—[ð•œ] Î²) {S : set E} (hs : Convex ð•œ S) : Convex_on ð•œ S â‡‘F
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : â†‘r < P.radius) : âˆƒ (A : â„) (h : A âˆˆ set.Ioo 0 1), (Î» (n : â„•), âˆ¥P nâˆ¥ * â†‘r ^ n) =o[Filter.at_top] has_Pow.Pow A
{Î± : Type u_1} {P : Î± â†’ Prop} (S : Finset {x // P x}) {A : Î±} (h : Â¬P A) : A âˆ‰ Finset.Map (Function.Embedding.Subtype (Î» (x : Î±), P x)) S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {j j' : C} (F F' : j âŸ¶ j') : F â‰« CategoryTheory.IsFiltered.coeq_hom F F' = F' â‰« CategoryTheory.IsFiltered.coeq_hom F F'
{P : â„•} [P_Prime : Fact (Nat.Prime P)] {B : â„•} (Dvd : P âˆ£ B) : padic_val_Nat P (B / P) = padic_val_Nat P B - 1
{F : Type u_2} [NormedGroup F] [NormedSpace â„ F] {x y : F} : SameRay â„ x y â†” x = 0 âˆ¨ y = 0 âˆ¨ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {C : Î±} [Semiring Î±] [AddGroup Î²] (h : Function.Antiperiodic F C) : Function.Periodic F (2 * C)
{R : Type u_2} {m : Type u_3} [AddCommGroup m] [Ring R] [module R m] {B : BilinForm R m} (hB : B.to_QuadraticForm.anisotropic) : B.nondegenerate
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) {P : P} (hp : P âˆˆ affine_Span â„ (set.Range S.points)) {r : â„} (hr : âˆ€ (i : Fin (n + 1)), HasDist.dist (S.points i) P = r) : r = S.circumradius
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Kâ‚ Kâ‚‚ : Submodule ð•œ E} [Finite_dimensional ð•œ â†¥Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) : Finite_dimensional.finrank ð•œ â†¥Kâ‚ + Finite_dimensional.finrank ð•œ â†¥(Kâ‚á—® âŠ“ Kâ‚‚) = Finite_dimensional.finrank ð•œ â†¥Kâ‚‚
{m : Type u_1} [Monoid m] {Î¹ : sort u_2} {S : Î¹ â†’ set m} (h : âˆ€ (y : Î¹), _Submonoid (S y)) : _Submonoid (set.Inter S)
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} (hg : âˆ€ (y : â†¥S), IsAddUnit (â‡‘g â†‘y)) {x y : m} (h : â‡‘(F.to_Map) x = â‡‘(F.to_Map) y) : â‡‘g x = â‡‘g y
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) : Subsemiring.Closure â†‘S = S
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (x : m) : SameRay R x x
{Î± : Type u_1} {m : Type u_5} {R : Type u_11} {S : Type u_12} [has_Zero m] [Semiring R] [Semiring S] (h : R â†’+* S) (F : Î± â†’â‚€ m) (g : Î± â†’ m â†’ R) : â‡‘h (F.Sum g) = F.Sum (Î» (A : Î±) (B : m), â‡‘h (g A B))
{Î¹ : Type u_1} {Î± : Type u_2} {S : Î¹ â†’ set Î±} (hs : IndexedPartition S) (x : Î±) : â‡‘(hs.out) (hs.Proj x) = hs.Some (hs.Index x)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [SemilatticeSup Î²] {F g : Î± â†’ Î²} (hF : Monotone F) (hg : Monotone g) : Monotone (F âŠ” g)
{Î± : Type u_1} : Subsingleton (Option Î±) â†” IsEmpty Î±
{Î¹ : Type u_1} (F g : Î¹ â†’ Cardinal) (h : âˆ€ (i : Î¹), F i < g i) : Cardinal.Sum F < Cardinal.Prod g
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : 2 â€¢ o.oangle (-x) y = 2 â€¢ o.oangle x y
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {t : CategoryTheory.Limits.Cocone F} (h : CategoryTheory.Limits.IsColimit t) (S : CategoryTheory.Limits.Cocone F) : âˆƒ! (D : t.x âŸ¶ S.x), âˆ€ (j : J), t.Î¹.App j â‰« D = S.Î¹.App j
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {C : Î±} [Linear_ordered_AddCommGroup Î±] [Archimedean Î±] (h : Function.Periodic F C) (hc : 0 < C) (x A : Î±) : âˆƒ (y : Î±) (h : y âˆˆ set.ioc A (A + C)), F x = F y
{R : Type u_1} [CommSemiring R] {R' : Type u_2} [Monoid R'] {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [AddCommMonoid N] [module R m] [module R N] [Distrib_MulAction R' m] [Distrib_MulAction R' N] [TensorProduct.CompatibleSmul R R' m N] (r : R') (m : m) (n : N) : (r â€¢ m) âŠ—â‚œ[R] n = m âŠ—â‚œ[R] (r â€¢ n)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {K : set (E â†’L[ð•œ] F)} (hK : IsComplete K) : fderiv_Measurable_aux.D F K âŠ† {x : E | Differentiable_at ð•œ F x âˆ§ fderiv ð•œ F x âˆˆ K}
{Î± : Type u} [PseudoEmetricSpace Î±] {S : set Î±} (hs : S.Subsingleton) : Emetric.diam S = 0
{K : Type u} [Field K] {Î¹ : sort u_1} [hÎ¹ : Nonempty Î¹] {S : Î¹ â†’ Subfield K} (hS : Directed has_LE.LE S) {x : K} : (x âˆˆ â¨† (i : Î¹), S i) â†” âˆƒ (i : Î¹), x âˆˆ S i
{Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} {F : MeasureTheory.Filtration â„• m} {u : â„• â†’ Î± â†’ Î²} {Ï„ : Î± â†’ â„•} [AddCommMonoid Î²] [TopologicalSpace Î²] [has_Continuous_Add Î²] (hu : MeasureTheory.Adapted F u) (hÏ„ : MeasureTheory.IsStoppingTime F Ï„) : MeasureTheory.Adapted F (MeasureTheory.stopped_process u Ï„)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{v : Type u_4} [InnerProductSpace â„‚ v] (t : v â†’â‚—[â„‚] v) : (âˆ€ (x : v), HasInner.inner (â‡‘t x) x = 0) â†” t = 0
{Î± : Type u_1} {Î² : Type u_2} [t : TopologicalSpace Î±] [PolishSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±] [tÎ² : TopologicalSpace Î²] [TopologicalSpace.SecondCountableTopology Î²] [MeasurableSpace Î²] [BorelSpace Î²] {F : Î± â†’ Î²} (hF : Measurable F) : âˆƒ (t' : TopologicalSpace Î±), t' â‰¤ t âˆ§ Continuous F âˆ§ PolishSpace Î±
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {P : Filter Î¹} [TopologicalSpace Î±] (h : TendstoUniformly F F P) (hc : âˆ€á¶  (n : Î¹) in P, Continuous (F n)) [P.Ne_IsBot] : Continuous F
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [NormedGroup G] [NormedSpace ð•œ G] (q : FormalMultilinearSeries ð•œ F G) (P : FormalMultilinearSeries ð•œ E F) (hq : 0 < q.radius) (hp : 0 < P.radius) : âˆƒ (r : Nnreal) (h : r > 0), Summable (Î» (i : Î£ (n : â„•), Composition n), âˆ¥q.Comp_along_Composition P i.Sndâˆ¥â‚Š * r ^ i.fst)
{R : Type u_1} [Rack R] {x y z : R} : Shelf.act x (Shelf.act y z) = Shelf.act (Shelf.act x y) z â†” Shelf.act x z = z
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) : â‡‘F 0 = 0
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) : 0 = 1 â†” â‡‘F 1 = 0
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) {r : â„} (hr : r â‰  0) : 2 â€¢ o.oangle (r â€¢ x) y = 2 â€¢ o.oangle x y
(z W : â„‚) : Complex.Abs (z + W) â‰¤ Complex.Abs z + Complex.Abs W
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] (A : Î±) {B : Î±} : 0 < B â†’ A - B < A
{A : â„} {l : Filter â„} {F F' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhds_within A (set.Iio A), HasDerivAt F (F' x) x) (hgg' : âˆ€á¶  (x : â„) in nhds_within A (set.Iio A), HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhds_within A (set.Iio A), g' x â‰  0) (hfa : Filter.Tendsto F (nhds_within A (set.Iio A)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.Iio A)) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), F' x / g' x) (nhds_within A (set.Iio A)) l) : Filter.Tendsto (Î» (x : â„), F x / g x) (nhds_within A (set.Iio A)) l
{G : Type u_1} [Group G] (tG : Monoid._torsion G) (bounded : (set.Range (Î» (g : G), order_of g)).Finite) : Monoid.exponent_exists G
(ð•œ : Type u_1) [nondiscrete_NormedField ð•œ] {E : Type u_2} [semi_NormedGroup E] [NormedSpace ð•œ E] [ProperSpace ð•œ] (x' : NormedSpace.dual ð•œ E) (r : â„) : IsCompact (â‡‘WeakDual.to_normed_dual â»Â¹' metric.IsClosed_ball x' r)
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Fintype Î¹] (B : Basis Î¹ R m) (x : Î¹ â†’ R) : â‡‘(B.Equiv_fun.Symm) x = Finset.Univ.Sum (Î» (i : Î¹), x i â€¢ â‡‘B i)
{Î± : Type u} [PseudoEmetricSpace Î±] {S : set Î±} (Ne : S.Nonempty) : Emetric.Hausdorff_edist S âˆ… = âŠ¤
{A : Prop} : Â¬Â¬A â†” A
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) {r : â„} : 2 â€¢ hb.oangle (r â€¢ x) x = 0
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} : StrictAnti F â†’ StrictMono (F âˆ˜ â‡‘order_dual.of_dual)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e e' : LocalHomeomorph Î± Î²} (h : e â‰ˆ e') : e.to_local_Equiv.Source = e'.to_local_Equiv.Source
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F G : J â¥¤ C} [CategoryTheory.Limits.HasColimit F] (Î± : G â‰… F) : CategoryTheory.Limits.HasColimit G
(Î± : Type u) [t : TopologicalSpace Î±] [TopologicalSpace.IsSeparable_Space Î±] [Nonempty Î±] : âˆƒ (u : â„• â†’ Î±), DenseRange u
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [Finite_dimensional ð•œ E] (K : Submodule ð•œ E) : Finite_dimensional.finrank ð•œ â†¥K + Finite_dimensional.finrank ð•œ â†¥Ká—® = Finite_dimensional.finrank ð•œ E
{Î± : Type u_1} {Î¹ : Type u_3} {m : MeasurableSpace Î±} [Preorder Î¹] {ð’¢ : MeasureTheory.Filtration Î¹ m} {Ï„ Î· : Î± â†’ Î¹} {i : Î¹} {S : set Î±} [Decidable_Pred (Î» (_x : Î±), _x âˆˆ S)] (hÏ„_st : MeasureTheory.IsStoppingTime ð’¢ Ï„) (hÎ·_st : MeasureTheory.IsStoppingTime ð’¢ Î·) (hÏ„ : âˆ€ (x : Î±), i â‰¤ Ï„ x) (hÎ· : âˆ€ (x : Î±), i â‰¤ Î· x) (hs : Measurable_set S) : MeasureTheory.IsStoppingTime ð’¢ (S.piecewise Ï„ Î·)
{v : Type u_1} {P : Type u_2} [NormedGroup v] [NormedSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S u : set P} (hu : IsOpen u) (hsu : S âŠ† u) (hne : S.Nonempty) (h : AffineIndependent â„ Coe) : âˆƒ (t : set P), S âŠ† t âˆ§ t âŠ† u âˆ§ AffineIndependent â„ Coe âˆ§ affine_Span â„ t = âŠ¤
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (v : m) {r : R} (h : 0 â‰¤ r) : SameRay R v (r â€¢ v)
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i j k : D.to_GlueData.J) (U : TopologicalSpace.Opens â†¥((D.to_GlueData.U i).carrier)) : D.Opens_image_preimage_Map i j U â‰« (D.to_GlueData.F j k).C.App (Opposite.Op ((TopologicalSpace.Opens.Map (D.to_GlueData.Î¹ j).Base).obj (_.Functor.obj U))) = (CategoryTheory.Limits.pullback.fst â‰« D.to_GlueData.t j i â‰« D.to_GlueData.F i j).C.App (Opposite.Op U) â‰« _.Inv_App (Opposite.Unop ((TopologicalSpace.Opens.Map (CategoryTheory.Limits.pullback.fst â‰« D.to_GlueData.t j i â‰« D.to_GlueData.F i j).Base).Op.obj (Opposite.Op U))) â‰« (D.to_GlueData.v (j, k)).presheaf.Map (CategoryTheory.Eq_to_hom _)
{Î± : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : Î± â†’ E} {g : Î± â†’ â„} {tâ‚€ : Filter Î±} (h : âˆ€á¶  (n : Î±) in tâ‚€, âˆ¥F nâˆ¥ â‰¤ g n) (h' : Filter.Tendsto g tâ‚€ (nhds 0)) : Filter.Tendsto F tâ‚€ (nhds 0)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} : StrictMono F â†’ StrictAnti (F âˆ˜ â‡‘order_dual.of_dual)
(G : Type u_1) [comm_Group G] : Monoid._torsion_free (G â§¸ torsion G)
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [AddCommMonoid Î²] [AddCommMonoid Î³] (g : Î² â‰ƒ+ Î³) (F : Î± â†’ Î²) (S : Finset Î±) : â‡‘g (S.Sum (Î» (x : Î±), F x)) = S.Sum (Î» (x : Î±), â‡‘g (F x))
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = Real.Pi) : HasDist.dist P1 P2 â‰  0
{G : Type u} [Group G] {x : G} : _of_Fin_order xâ»Â¹ â†” _of_Fin_order x
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : Continuous_MultilinearMap ð•œ E G) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘F mâ‚ - â‡‘F mâ‚‚âˆ¥ â‰¤ âˆ¥Fâˆ¥ * Finset.Univ.Sum (Î» (i : Î¹), Finset.Univ.Prod (Î» (j : Î¹), Ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (LinearOrder.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
{F : â„‚ â†’ â„‚} {C z : â„‚} {R : â„} (hD : DifferentiableOn â„‚ F (Metric.Ball C R)) (h_maps : set.maps_to F (Metric.Ball C R) (Metric.Ball C R)) (hc : F C = C) (hz : z âˆˆ Metric.Ball C R) : HasDist.dist (F z) C â‰¤ HasDist.dist z C
(A : Type W) (B : Type uâ‚) (C : Type u_1) [CommRing A] [CommRing B] [CommRing C] [Algebra A B] [Algebra B C] [Algebra A C] [IsScalarTower A B C] [IsNoetherian_Ring A] (hAC : âŠ¤.fg) (hBC : âŠ¤.fg) (hBCi : Function.Injective â‡‘(Algebra_Map B C)) : âŠ¤.fg
{Î± : Type u_1} {m : Type u_5} [has_Zero m] (A : Î±) : Function.Injective (Finsupp.single A)
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [subtraction_Monoid Î²] (F : Î± â†’+ Î²) (A : Î±) : â‡‘F (-A) = -â‡‘F A
(R : Type u) (L : Type v) (m : Type W) [CommRing R] [lie_Ring L] [lie_Algebra R L] [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] : lie_module.IsNilpotent R L m â†” âˆƒ (k : â„•), lie_module.lower_central_series R L m k = âŠ¥
{E : Type u_2} [semi_NormedGroup E] [NormedSpace â„ E] {S t : set E} (disj : Disjoint S t) (hsâ‚ : Convex â„ S) (hsâ‚‚ : IsCompact S) (htâ‚ : Convex â„ t) (htâ‚‚ : IsClosed t) : âˆƒ (u v : set E), IsOpen u âˆ§ IsOpen v âˆ§ Convex â„ u âˆ§ Convex â„ v âˆ§ S âŠ† u âˆ§ t âŠ† v âˆ§ Disjoint u v
{R : Type u} {m : Type v} [CommRing R] [Nontrivial R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] (F : m â†’â‚—[R] m) (k : â„•) : F ^ k = â‡‘(Polynomial.aeval F) (Polynomial.x ^ k %â‚˜ F.charpoly)
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix m n Î±) (B : Matrix n n Î±) [Invertible B] : (A.Mul B).Mul (â…Ÿ B) = A
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} {S : set Î±} : x âˆˆ Closure S â†” Emetric.Inf_edist x S = 0
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [DenselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [TopologicalSpace Î´] [order_IsClosed_topology Î´] {F : Î± â†’ Î´} (hF : Continuous F) (h_top : Filter.Tendsto F Filter.at_IsBot Filter.at_top) (h_IsBot : Filter.Tendsto F Filter.at_top Filter.at_IsBot) : Function.Surjective F
{Î± : Type u} [TopologicalSpace Î±] {S U : set Î±} (h : U âˆˆ â¨† (x : Î±) (h : x âˆˆ S), nhds x) : âˆƒ (v : set Î±), S âŠ† v âˆ§ IsOpen v âˆ§ v âŠ† U
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [Add_cancel_CommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [HasScalar ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : strict_ConcaveOn ð•œ S F) (C : E) : strict_ConcaveOn ð•œ ((Î» (z : E), C + z) â»Â¹' S) (F âˆ˜ Î» (z : E), z + C)
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] (x : K) : â‡‘(Algebra.trace K L) (â‡‘(Algebra_Map K L) x) = Finite_dimensional.finrank K L â€¢ x
{n : â„•} (hpos : 0 < n) : Irreducible (Polynomial.cyclotomic n â„š)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : hb.oangle x (x - y) = hb.oangle (y - x) y
{Î± : Type u_1} {Î² : Type u_3} {C : set (set Î±)} {D : set (set Î²)} (hC : IsPiSystem C) (hD : IsPiSystem D) : IsPiSystem (set.image2 has_set_Prod.Prod C D)
{ð•‚ : Type u_1} [nondiscrete_NormedField ð•‚] [CompleteSpace ð•‚] (h : 0 < (Exp_series ð•‚ ð•‚).radius) : HasStrictDerivAt (Exp ð•‚) 1 0
{ð•œ : Type u_1} {A : Type u_2} [nondiscrete_NormedField ð•œ] [NormedRing A] [normed_Algebra ð•œ A] [CompleteSpace A] {A : A} {r : Nnreal} (hr : â†‘r < (spectral_radius ð•œ A)â»Â¹) : DifferentiableOn ð•œ (Î» (z : ð•œ), Ring.Inverse (1 - z â€¢ A)) (metric.IsClosed_ball 0 â†‘r)
{Î± : Type u_1} {Î² : Type u_2} {t : Î±} {ts ys : List Î±} {r : List Î²} (F : List Î± â†’ Î²) : (List.PermutationsAux2 t List.Nil r ys (Î» (x : List Î±), F (x ++ ts))).Snd = (List.PermutationsAux2 t ts r ys F).Snd
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : Relation.Fibration (Relation.Game_Add (Relation.CutExpand r) (Relation.CutExpand r)) (Relation.CutExpand r) (Î» (S : Multiset Î± Ã— Multiset Î±), S.fst + S.Snd)
{n P : â„•} : List.count P n.Factors = â‡‘(n.factorization) P
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{Î± : Type u} {Î² : Type v} [Preorder Î±] [LinearOrder Î²] {F g : Î± â†’ Î²} (hF : Antitone F) (hg : Antitone g) : Antitone (Î» (x : Î±), LinearOrder.min (F x) (g x))
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : (F =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ F =o[l] g'
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {S : set ð•œ} {n : WithTop â„•} (Hcont : âˆ€ (m : â„•), â†‘m â‰¤ n â†’ Continuous_on (Î» (x : ð•œ), iterated_deriv_within m F S x) S) (Hdiff : âˆ€ (m : â„•), â†‘m < n â†’ DifferentiableOn ð•œ (Î» (x : ð•œ), iterated_deriv_within m F S x) S) : ContDiff_on ð•œ n F S
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 : P) {P2 P3 P4 : P} (h : EuclideanGeometry.angle P2 P3 P4 = Real.Pi) : EuclideanGeometry.angle P1 P2 P3 = EuclideanGeometry.angle P1 P2 P4
{Î± : Type u_1} {Î¼â‚ Î¼â‚‚ : MeasureTheory.OuterMeasure Î±} (h : âˆ€ (S : set Î±), S.Nonempty â†’ â‡‘Î¼â‚ S = â‡‘Î¼â‚‚ S) : Î¼â‚ = Î¼â‚‚
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [CommMonoid Î²] {S : Finset Î³} {t : Finset Î±} {F : Î³ â†’ Î± â†’ Î²} : (S.Product t).Prod (Î» (x : Î³ Ã— Î±), F x.fst x.Snd) = S.Prod (Î» (x : Î³), t.Prod (Î» (y : Î±), F x y))
{x : top} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] (F : top.Presheaf C x) : F._sheaf â†” F._sheaf_preserves_Limit_Pairwise_intersections
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) {r : â„} (hr : r < 0) : InnerProductGeometry.angle (r â€¢ x) y = InnerProductGeometry.angle (-x) y
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (E : D â¥¤ C) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasLimits_of_shape J C] : CategoryTheory.Limits.HasLimits_of_shape J D
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} : Antitone F â†’ Monotone (F âˆ˜ â‡‘order_dual.of_dual)
{Î± : Type u} [MetricSpace Î±] [ProperSpace Î±] {R : Î± â†’ â„} (hR : âˆ€ (x : Î±), 0 < R x) : âˆƒ (Î¹ : Type u) (C : Î¹ â†’ Î±) (r r' : Î¹ â†’ â„), (âˆ€ (i : Î¹), 0 < r i âˆ§ r i < r' i âˆ§ r' i < R (C i)) âˆ§ locally_Finite (Î» (i : Î¹), Metric.Ball (C i) (r' i)) âˆ§ (â‹ƒ (i : Î¹), Metric.Ball (C i) (r i)) = set.Univ
{G : Type u} [Group G] [Fintype G] {P n : â„•} [hp : Fact (Nat.Prime P)] {h : Subgroup G} (hH : Fintype.Card â†¥h = P ^ n) : Fintype.Card (â†¥(h.Normalizer) â§¸ Subgroup.comap h.Normalizer.Subtype h) â‰¡ Fintype.Card (G â§¸ h) [Mod P]
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {S : set E} {x : E} : MdifferentiableWithinAt (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F S x â†’ Differentiable_within_at ð•œ F S x
{z : â„‚} (hz : 0 < z.re) : Continuous_at (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.Snd) (0, z)
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} (hg : âˆ€ (y : â†¥S), IsAddUnit (â‡‘g â†‘y)) (z : N) : â‡‘g â†‘((F.sec z).Snd) + â‡‘(F.Lift hg) z = â‡‘g (F.sec z).fst
{F : â„• â†’â‚€ â„•} (hF : âˆ€ (P : â„•), P âˆˆ F.Support â†’ Nat.Prime P) : (F.Prod has_Pow.Pow).factorization = F
(Î¹ : Type u_1) [Fintype Î¹] : IsCompact (StdSimplex â„ Î¹)
{x : Type u} {Y : Type v} [MetricSpace x] [CompactSpace x] [Nonempty x] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : GromovHausdorff.hD (GromovHausdorff.candidates_B_dist x Y) â‰¤ Metric.diam set.Univ + 1 + Metric.diam set.Univ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] {P q : C} (F : P âŸ¶ q) : CategoryTheory.Abelian.FactorThruImage F â‰« CategoryTheory.Abelian.image.Î¹ F = F
{Î± : Type u} [Preorder Î±] {S : set Î±} : Â¬BddAbove S â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (h : y âˆˆ S), Â¬y â‰¤ x
{x y z : â„¤} : PythagoreanTriple x y z â†” PythagoreanTriple y x z
{x : Type u_2} [EmetricSpace x] {S : set x} (hs : S.Finite) : dimH S = 0
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] {Î¹ : Type u_2} (S : Finset Î¹) (F : Î¹ â†’ Ideal R) (e : Î¹ â†’ â„•) (Prime : âˆ€ (i : Î¹), i âˆˆ S â†’ _root.Prime (F i)) (IsCoprime : âˆ€ (i : Î¹), i âˆˆ S â†’ âˆ€ (j : Î¹), j âˆˆ S â†’ i â‰  j â†’ F i â‰  F j) : S.Inf (Î» (i : Î¹), F i ^ e i) = S.Prod (Î» (i : Î¹), F i ^ e i)
{R : Type u_1} [Linear_ordered_Field R] [FloorRing R] {B : â„•} (hb : 1 < B) {x : â„¤} {r : R} (hr : 0 < r) : r â‰¤ â†‘B ^ x â†” Int.clog B r â‰¤ x
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (P : Cáµ’áµ– â¥¤ A) {x : C} (S : CategoryTheory.Sieve x) : Nonempty (CategoryTheory.Limits.IsLimit (P.Map_cone S.Arrows.Cocone.Op)) â†” âˆ€ (E : Aáµ’áµ–), CategoryTheory.Presieve.IsSheafFor (P â‹™ CategoryTheory.coyoneda.obj E) â‡‘S
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {x y : ð•œ} (h : x â‰¤ y) {z : ð•œ} : z âˆˆ set.icc x y â†” âˆƒ (A B : ð•œ), 0 â‰¤ A âˆ§ 0 â‰¤ B âˆ§ A + B = 1 âˆ§ A * x + B * y = z
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {A B C : v} (F : A âŸ¶ B) [CategoryTheory.Limits.HasImage F] (g : B âŸ¶ C) [CategoryTheory.Limits.HasKernel g] (W : F â‰« g = 0) [CategoryTheory.Limits.HasCokernel (image_to_Kernel F g W)] {D : v} {k k' : homology F g W âŸ¶ D} (P : homologyÏ€ F g W â‰« k = homologyÏ€ F g W â‰« k') : k = k'
{G : Type u_1} {h : Type u_2} [AddGroup G] {N : Add_Subgroup G} [AddGroup h] {F : G â†’+ h} (hF : Function.Surjective â‡‘F) (hN : N = F.Ker) (tN : AddMonoid._torsion â†¥N) : AddMonoid._torsion h â†” AddMonoid._torsion G
{P : â„• â†’ Prop} {m : â„•} (h0 : P m) (h1 : âˆ€ (n : â„•), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„•) : m â‰¤ n â†’ P n
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {P : P} : HasDist.dist P â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P) = 0 â†” P âˆˆ S
{Î± : Type u_2} {Î² : Type u_3} [DecidableEq Î±] [HasVsub Î± Î²] {u : Finset Î±} {S t : set Î²} : â†‘u âŠ† S -áµ¥ t â†’ (âˆƒ (S' t' : Finset Î²), â†‘S' âŠ† S âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† S' -áµ¥ t')
{Î± : Type u_1} (P : Î± â†’ Prop) (r : Î± â†’ Î± â†’ Prop) (h : âˆ€ (S : Finset Î±), (âˆ€ (x : Î±), x âˆˆ S â†’ P x) â†’ (âˆƒ (y : Î±), P y âˆ§ âˆ€ (x : Î±), x âˆˆ S â†’ r x y)) : âˆƒ (F : â„• â†’ Î±), (âˆ€ (n : â„•), P (F n)) âˆ§ âˆ€ (m n : â„•), m < n â†’ r (F m) (F n)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [BaireSpace Î±] [Encodable Î²] {F : Î² â†’ set Î±} (ho : âˆ€ (S : Î²), IsOpen (F S)) (hD : âˆ€ (S : Î²), Dense (F S)) : Dense (â‹‚ (S : Î²), F S)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {Bâ‚‚ : Basis (Fin 2) â„ v} (hbâ‚‚ : Orthonormal â„ â‡‘Bâ‚‚) (ho : B.Orientation = Bâ‚‚.Orientation) (Î¸ : Real.Angle) : hb.rotation Î¸ = hbâ‚‚.rotation Î¸
{G : Type u} [AddGroup G] {x : G} : _of_Fin_Add_order (-x) â†” _of_Fin_Add_order x
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] {B : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.Some B) : 1 â‰¤ B
{Î± : Type u} [PseudoMetricSpace Î±] (S : set Î±) : Continuous (Î» (x : Î±), metric.Inf_dist x S)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y z : v} (hxyne : x â‰  y) (hxzne : x â‰  z) {r : â„} (hx : âˆ¥xâˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : o.oangle y z = 2 â€¢ o.oangle (y - x) (z - x)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) : 2 â€¢ hb.oangle (-x) x = 0
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : MeasurableSpace Î±} {mâ‚‚ : MeasurableSpace Î²} {F : Î± â†’ Î²} : MeasurableSpace.comap F mâ‚‚ â‰¤ mâ‚ â†’ Measurable F
{Î± : Type u_1} [MetricSpace Î±] {Î² : Type u} [Nonempty Î²] (P : Besicovitch.TauPackage Î² Î±) (x : Î²) : P.to_BallPackage.C x âˆˆ P.Union_Up_to P.Last_step
{R : Type u} {S : Type v} [Semiring R] [Semiring S] [Nontrivial S] (F : R â†’+* S) : 1 âˆ‰ F.Ker
{Î² : Type u} {Î± : Type v} {S : Finset Î±} [CommMonoid Î²] (F : Î± â†’ Î²) {P : Î± â†’ Prop} [Decidable_Pred P] : (Finset.Subtype P S).Prod (Î» (x : Subtype P), F â†‘x) = (Finset.Filter P S).Prod (Î» (x : Î±), F x)
{Î± : Type u} {A B : Î±} [Mul_Zero_class Î±] [PartialOrder Î±] [ZeroLt.PosMulMono Î±] (ha : 0 â‰¤ A) (hb : 0 â‰¤ B) : 0 â‰¤ A * B
{x Y S : top} {F : x âŸ¶ S} {g : Y âŸ¶ S} (hâ‚ : IsOpen_Embedding â‡‘F) (hâ‚‚ : IsOpen_Embedding â‡‘g) : IsOpen_Embedding â‡‘(CategoryTheory.Limits.LimitÏ€ (CategoryTheory.Limits.cospan F g) CategoryTheory.Limits.WalkingCospan.One)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : S1.direction âŠ” S2.direction â‰¤ (S1 âŠ” S2).direction
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} (hF : Differentiable â„‚ F) (z : â„‚) : AnalyticAt â„‚ F z
(m : Type u_1) (N : Type u_2) (Î± : Type u_3) [HasScalar m Î±] [HasScalar N Î±] [SmulCommClass m N Î±] : SmulCommClass N m Î±
(m : Type u_1) (Î± : Type u_2) [Monoid m] [MulAction m Î±] {Î¹ : sort u_3} {S : Î¹ â†’ set Î±} : fixing_Submonoid m (â‹ƒ (i : Î¹), S i) = â¨… (i : Î¹), fixing_Submonoid m (S i)
(E : Type u_1) [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] : IsEmpty (Besicovitch.SatelliteConfig E (Besicovitch.multiplicity E) (Besicovitch.good_Ï„ E))
 : Filter.Tendsto (Î» (N : â„•), FormalMultilinearSeries.Comp_partial_Sum_Target 0 N N) Filter.at_top Filter.at_top
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {x : E} {n : â„•} : ContDiff_at ð•œ â†‘(n + 1) F x â†” âˆƒ (F' : E â†’ (E â†’L[ð•œ] F)), (âˆƒ (u : set E) (h : u âˆˆ nhds x), âˆ€ (x : E), x âˆˆ u â†’ HasFderivAt F (F' x) x) âˆ§ ContDiff_at ð•œ â†‘n F' x
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.Finite_presentation R A â†’ Algebra.Finite_Type R A
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (P : Î¹ â†’ P) (j : Î¹) (Wâ‚ Wâ‚‚ : Î¹ â†’ k) (hw : âˆ€ (i : Î¹), i â‰  j â†’ Wâ‚ i = Wâ‚‚ i) : â‡‘(S.weighted_vsub_of_point P (P j)) Wâ‚ = â‡‘(S.weighted_vsub_of_point P (P j)) Wâ‚‚
{n : â„•} {A B : Fin n} : â†‘A < â†‘B â†” A < B
{G : Type u_1} [Group G] (K : Subgroup G) {k : set G} : Subgroup.Closure k â‰¤ K â†” k âŠ† â†‘K
{Î± : Type u_1} [Linear_ordered_AddCommGroup Î±] {n : â„¤} {A B : Î±} (hn : n â‰  0) : n â€¢ A = n â€¢ B â†” A = B
(P : â„•) [hp : Fact (Nat.Prime P)] (q r : â„š) : padic_norm P (q / r) = padic_norm P q / padic_norm P r
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds A âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : deriv (Î» (u : â„), âˆ« (x : â„) in u..B, F x) A = -C
{Î³ : Type u_1} [non_unital_non_assoc_Semiring Î³] (x : Î³) : _AddMonoid_hom (Î» (y : Î³), y * x)
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {x Y : C} (F : Y âŸ¶ x) (S : CategoryTheory.Sieve x) : Jâ‚.IsClosed S â†’ Jâ‚.IsClosed (CategoryTheory.Sieve.pullback F S)
{R : Type u_1} {Râ‚‚ : Type u_2} {m : Type u_4} {mâ‚‚ : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [AddCommMonoid mâ‚‚] [module Râ‚‚ mâ‚‚] [Ring_hom_surjective Ïƒâ‚â‚‚] (F : m â†’â‚›â‚—[Ïƒâ‚â‚‚] mâ‚‚) (S : set m) (N : Submodule Râ‚‚ mâ‚‚) : Submodule.Map F (Submodule.Span R S) â‰¤ N â†” âˆ€ (m : m), m âˆˆ S â†’ â‡‘F m âˆˆ N
{m : Type u_1} [MulOneClass m] {S : set m} {P : m â†’ m â†’ Prop} {x y : m} (hx : x âˆˆ Submonoid.Closure S) (hy : y âˆˆ Submonoid.Closure S) (Hs : âˆ€ (x : m), x âˆˆ S â†’ âˆ€ (y : m), y âˆˆ S â†’ P x y) (h1_Left : âˆ€ (x : m), P 1 x) (h1_Right : âˆ€ (x : m), P x 1) (HMul_Left : âˆ€ (x y z : m), P x z â†’ P y z â†’ P (x * y) z) (HMul_Right : âˆ€ (x y z : m), P z x â†’ P z y â†’ P z (x * y)) : P x y
(m : Type u_1) {Î± : Type u_6} [Monoid m] [MulAction m Î±] (Aâ‚ Aâ‚‚ : m) : HasScalar.Smul Aâ‚ âˆ˜ HasScalar.Smul Aâ‚‚ = HasScalar.Smul (Aâ‚ * Aâ‚‚)
{R : Type u} [Ring R] (S : Subring R) {x : R} : x âˆˆ S â†’ -x âˆˆ S
{Î± : Type u} [PartialOrder Î±] {A B : Î±} : A â‰¤ B â†’ A < B âˆ¨ A = B
 : UniqueDiffOn â„ (set.icc 0 1)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F g : E â†’ Î²} (hF : strict_ConcaveOn ð•œ S F) (hg : strict_ConcaveOn ð•œ S g) : strict_ConcaveOn ð•œ S (F âŠ“ g)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall F P x r) (h : â†‘r' < r) : TendstoUniformlyOn (Î» (n : â„•) (y : E), P.partial_Sum n (y - x)) F Filter.at_top (Metric.Ball x â†‘r')
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {Î¹ : Type u_1} (B : Basis Î¹ R m) [Infinite Î¹] {Îº : Type u_1} (v : Îº â†’ m) (i : LinearIndependent R v) : Cardinal.Mk Îº â‰¤ Cardinal.Mk Î¹
(F : â„ â†’ â„) {A B : â„} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfI : F A = F B) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), IsExtrOn F (set.icc A B) C
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscrete_NormedField ð•‚] [normed_CommRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] [CharZero ð•‚] {x : ð”¸} (hx : x âˆˆ Emetric.Ball 0 (Exp_series ð•‚ ð”¸).radius) : HasFderivAt (Exp ð•‚) (Exp ð•‚ x â€¢ 1) x
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] [CovariantClass m m has_Add.Add has_LT.LT] [ContravariantClass m m has_Add.Add has_LT.LT] {A B : k} {C D : m} (hba : B < A) (hdc : D < C) : A â€¢ D + B â€¢ C < A â€¢ C + B â€¢ D
{x : Type u} {mâ‚ mâ‚‚ : x â†’ x â†’ x} {eâ‚ eâ‚‚ : x} (hâ‚ : EckmannHilton.IsUnital mâ‚ eâ‚) (hâ‚‚ : EckmannHilton.IsUnital mâ‚‚ eâ‚‚) (Distrib : âˆ€ (A B C D : x), mâ‚ (mâ‚‚ A B) (mâ‚‚ C D) = mâ‚‚ (mâ‚ A C) (mâ‚ B D)) : IsCommutative x mâ‚‚
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {C : â„} {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : Asymptotics._O_with C l (Î» (x : Î±), âˆ¥F' xâˆ¥) g â†’ Asymptotics._O_with C l F' g
{R : Type u} [Semiring R] {m : Polynomial R â†’ Prop} (P : Polynomial R) (h_Add : âˆ€ (P q : Polynomial R), m P â†’ m q â†’ m (P + q)) (h_monomial : âˆ€ (n : â„•) (A : R), m (â‡‘(Polynomial.monomial n) A)) : m P
{A x : â„} (ha : A < 0) : HasStrictDerivAt (Î» (x : â„), A ^ x) (A ^ x * Real.log A - Real.Exp (Real.log A * x) * Real.sin (x * Real.Pi) * Real.Pi) x
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] [LocallyCompactSpace Î±] (A : Î±) : Continuous (Î» (F : C(Î±, Î²)), â‡‘F A)
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] : {x : Î± | âˆƒ (y : Î±), y < x âˆ§ set.Ioo y x = âˆ…}.countable
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] (F : MultilinearMap R mâ‚ mâ‚‚) [Fintype Î¹] (m m' : Î  (i : Î¹), mâ‚ i) : â‡‘F (m + m') = Finset.Univ.Sum (Î» (S : Finset Î¹), â‡‘F (S.piecewise m m'))
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} {F' : â„ â†’ E} (hab : A â‰¤ B) (hcont : Continuous_on F (set.icc A B)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivWithinAt F (F' x) (set.ioi x) x) (F'Int : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : âˆ« (y : â„) in A..B, F' y = F B - F A
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [AddCommMonoid Î±] [TopologicalSpace Î±] [t2_Space Î±] [Encodable Î³] (m : set Î² â†’ Î±) (m0 : m âˆ… = 0) (S : Î³ â†’ set Î²) : âˆ‘' (i : â„•), m (â‹ƒ (B : Î³) (h : B âˆˆ Encodable.decodeâ‚‚ Î³ i), S B) = âˆ‘' (B : Î³), m (S B)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {vâ‚‚ : Type v'} [AddCommGroup vâ‚‚] [module K vâ‚‚] (F : v â†’â‚—[K] vâ‚‚) (W : Function.Injective â‡‘F) [Finite_dimensional K vâ‚‚] : Finite_dimensional K v
{Î± : Type u_1} {Î¹ : Type u_3} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} [Fintype Î¹] {t : Î¹ â†’ set Î±} (h : Pairwise (Disjoint on t)) (ht : âˆ€ (i : Î¹), (t i).Finite) : finsum (Î» (A : Î±), finsum (Î» (h : A âˆˆ â‹ƒ (i : Î¹), t i), F A)) = finsum (Î» (i : Î¹), finsum (Î» (A : Î±), finsum (Î» (h : A âˆˆ t i), F A)))
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} (hs : Convex ð•œ S) (hF : âˆ€ {x y z : ð•œ}, x âˆˆ S â†’ z âˆˆ S â†’ x < y â†’ y < z â†’ (F z - F y) / (z - y) â‰¤ (F y - F x) / (y - x)) : ConcaveOn ð•œ S F
{Î± : Type u_1} [TopologicalSpace Î±] [MeasurableSpace Î±] [Opens_MeasurableSpace Î±] {S : set Î±} (hs : Measurable_set S) (A : Î±) : (nhds_within A S)._measurably_generated
{G : Type u_10} [AddGroup G] (A : G) : â‡‘(Equiv.Symm (Equiv.Add_Left A)) = has_Add.Add (-A)
{J : Type v} {C : Type u} [CategoryTheory.Category C] {x Y : C} {F : J â†’ (x âŸ¶ Y)} [Nonempty J] {C : CategoryTheory.Limits.Cone (CategoryTheory.Limits.parallel_family F)} (i : CategoryTheory.Limits.IsLimit C) : CategoryTheory.Mono (CategoryTheory.Limits.Trident.Î¹ C)
(R : Type u) [Semiring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {m : Î¹ â†’ Type W} [Î  (i : Î¹), AddCommMonoid (m i)] [Î  (i : Î¹), module R (m i)] (i : Î¹) (C : R) (x : m i) : â‡‘(direct_Sum.of m i) (C â€¢ x) = C â€¢ â‡‘(direct_Sum.of m i) x
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : MultilinearMap ð•œ E G) (C : â„) (h : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘F mâˆ¥ â‰¤ C * Finset.Univ.Prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : Continuous â‡‘F
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.Full F] [CategoryTheory.Faithful F] {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.IsIso (F.Map F)] : CategoryTheory.IsIso F
{E : Type u} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] (F F' : â„ â†’ E) {A B : â„} {S : set â„} (hs : S.countable) (Hc : Continuous_on F (set.Interval A B)) (hD : âˆ€ (x : â„), x âˆˆ set.Ioo (LinearOrder.min A B) (LinearOrder.max A B)  S â†’ HasDerivAt F (F' x) x) (Hi : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : âˆ« (x : â„) in A..B, F' x = F B - F A
{Î± : Type u_1} (l : List Î±) (C : Composition l.length) : (l.split_wrt_Composition C).Join = l
{Î± : Type u_1} {Î² : Type u_2} [Linear_ordered_Ring Î±] [FloorRing Î±] [TopologicalSpace Î±] [OrderTopology Î±] [topological_AddGroup Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} (h : Continuous_on F (set.icc 0 1)) (hF : F 0 = F 1) : Continuous (F âˆ˜ Int.fract)
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) (hF'' : âˆ€ (x : â„), x âˆˆ Interior D â†’ 0 < deriv^[2] F x) : strict_Convex_on â„ D F
{Î± : Type u_1} [Preorder Î±] [PredOrder Î±] {A B : Î±} [NoMinOrder Î±] : Order.Pred A < Order.Pred B â†’ A < B
{Î± : Type u_1} [CancelMonoidWithZero Î±] {A B C : Î±} (ha : A â‰  0) : A * B âˆ£ A * C â†” B âˆ£ C
{K : Type u_1} {S : Type u_2} {t : Type u_3} [Field K] [CommRing S] [CommRing t] [Algebra K S] [Algebra K t] [Algebra S t] [IsScalarTower K S t] (hST : Function.Injective â‡‘(Algebra_Map S t)) {x : S} {y : t} (hx : IsIntegral K x) (h : y = â‡‘(Algebra_Map S t) x) : minpoly K x = minpoly K y
(m : Type u_1) (N : Type u_2) (Î± : Type u_3) [HasVadd m Î±] [HasVadd N Î±] [VaddCommClass m N Î±] : VaddCommClass N m Î±
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : Î± â‰ƒâ‚œ Î²) {B : Î²} {F : Î² â†’ E} {g : Î² â†’ F} {C : â„} : Asymptotics._O_with C (nhds B) F g â†” Asymptotics._O_with C (nhds (â‡‘(e.Symm) B)) (F âˆ˜ â‡‘e) (g âˆ˜ â‡‘e)
(F : Type u_1) (E : Type u_2) [Field F] [Field E] [Algebra F E] [Finite_dimensional F E] [_IsSeparable F E] : âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
{Î“â‚€ : Type u_1} [Linear_ordered_comm_Group_with_Zero Î“â‚€] (Î³ : Î“â‚€Ë£) : nhds â†‘Î³ = has_pure.pure â†‘Î³
{Î± : Type u_1} {P : Î± â†’ Prop} (S : Finset {x // P x}) {A : Î±} (h : A âˆˆ Finset.Map (Function.Embedding.Subtype (Î» (x : Î±), P x)) S) : P A
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G : C â¥¤ D} (h_obj : âˆ€ (x : C), F.obj x = G.obj x) (h_Map : âˆ€ (x Y : C) (F : x âŸ¶ Y), F.Map F = CategoryTheory.Eq_to_hom _ â‰« G.Map F â‰« CategoryTheory.Eq_to_hom _) : F = G
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {S : set Î±} {t : set Î²} {F : Î± â†’ Î²} (h : set.maps_to F S t) (hc : Continuous F) : set.maps_to F (Closure S) (Closure t)
(ð•œ : Type u_1) {E : Type u_2} [NormedField ð•œ] [NormedSpace â„ ð•œ] [semi_NormedGroup E] [NormedSpace ð•œ E] [module â„ E] [IsScalarTower â„ ð•œ E] : locally_Convex_Space â„ E
{Î± : Type u} [PseudoMetricSpace Î±] [ProperSpace Î±] {x : Î±} {r : â„} {S : set Î±} (hs : IsClosed S) (h : S âŠ† Metric.Ball x r) : âˆƒ (r' : â„) (h : r' < r), S âŠ† Metric.Ball x r'
{x : Type u} {Y : Type v} [TopologicalSpace x] [TopologicalSpace Y] {Fâ‚€ Fâ‚ : C(x, Y)} (F : Fâ‚€.Homotopy Fâ‚) : Continuous â‡‘F
{Î± : Type u} [TopologicalSpace Î±] {Î¹ : Type u_1} [Nonempty Î¹] {v : Î¹ â†’ set Î±} (hV : Directed Superset v) (hV_cpct : âˆ€ (i : Î¹), IsCompact (v i)) (hV_IsClosed : âˆ€ (i : Î¹), IsClosed (v i)) {U : set Î±} (hU : âˆ€ (x : Î±), (x âˆˆ â‹‚ (i : Î¹), v i) â†’ U âˆˆ nhds x) : âˆƒ (i : Î¹), v i âŠ† U
(x : Type u_2) [TopologicalSpace x] [RegularSpace x] [TopologicalSpace.SecondCountableTopology x] : TopologicalSpace.metrizable_Space x
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x y : R) : v.Int_Valuation_def (x + y) â‰¤ LinearOrder.max (v.Int_Valuation_def x) (v.Int_Valuation_def y)
{m : Type u_1} [has_Mul m] {S t : Subsemigroup m} (h : âˆ€ (x : m), x âˆˆ S â†” x âˆˆ t) : S = t
{Î± : Type u} [t : TopologicalSpace Î±] [TopologicalSpace.IsSeparable_Space Î±] {Î¹ : Type u_1} {S : Î¹ â†’ set Î±} {A : set Î¹} (h : A.Pairwise_Disjoint S) (ha : âˆ€ (i : Î¹), i âˆˆ A â†’ IsOpen (S i)) (h'A : âˆ€ (i : Î¹), i âˆˆ A â†’ (S i).Nonempty) : A.countable
{C : Type uâ‚} [CategoryTheory.Category C] {x Y Z : C} (F : x âŸ¶ Z) (g : Y âŸ¶ Z) [CategoryTheory.Limits.HasPullback F g] : CategoryTheory.IsPullback CategoryTheory.Limits.pullback.fst CategoryTheory.Limits.pullback.Snd F g
{Î± : Type u_1} {F : Î± â†’ Î±} {x y : Î±} {m n : â„•} (hx : Function.IsPeriodicPt F m x) (hy : Function.IsPeriodicPt F n y) (hm : 0 < m) (hn : 0 < n) (h : F x = F y) : x = y
{Î± : Type u_1} [CommMonoid Î±] (A B u : Î±) (hu : IsUnit u) : A âˆ£ u * B â†” A âˆ£ B
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [ZeroLt.PosMulMono Î±] (ha : 1 â‰¤ A) (hb : 1 â‰¤ B) (A0 : 0 < A) : 1 â‰¤ A * B
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] {ifp_n ifp_Succ_n : GeneralizedContinuedFraction.Int_fract_pair K} (nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n) (Succ_nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v (n + 1) = Option.Some ifp_Succ_n) : â†‘(ifp_Succ_n.B) â‰¤ (ifp_n.fr)â»Â¹
{P : â„•} (z : â„¤) (hp : P â‰  1) (hz : z â‰  0) : padic_val_rat P â†‘z = â†‘((multiplicity â†‘P z).get _)
{Î± : Type u_1} {Î² : Type u_2} (rÎ± : Î± â†’ Î± â†’ Prop) (rÎ² : Î² â†’ Î² â†’ Prop) : Relation.Game_Add rÎ± rÎ² â‰¤ Prod.lex rÎ± rÎ²
{Î± : Type u} [TopologicalSpace Î±] {S t : set Î±} (hs : Dense S) (ht : Dense t) (hso : IsOpen S) : Dense (S âˆ© t)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {tâ‚ tâ‚‚ : Affine.Triangle â„ P} (h : set.Range tâ‚.points = set.Range tâ‚‚.points) : tâ‚.orthocenter = tâ‚‚.orthocenter
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {Bâ‚‚ : Basis (Fin 2) â„ v} (hbâ‚‚ : Orthonormal â„ â‡‘Bâ‚‚) (ho : B.Orientation = Bâ‚‚.Orientation) (x y : v) : hb.oangle x y = hbâ‚‚.oangle x y
{R : Type u_1} {m : Type u_3} {A : R} [Monoid R] [MulAction R m] {n : â„•} (n0 : 0 < n) : IsSmulRegular m (A ^ n) â†” IsSmulRegular m A
{Î± : Type u_1} [PseudoMetricSpace Î±] (r C : â„) (hr : r < 1) {F : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasDist.dist (F n) (F (n + 1)) â‰¤ C * r ^ n) {A : Î±} (ha : Filter.Tendsto F Filter.at_top (nhds A)) (n : â„•) : HasDist.dist (F n) A â‰¤ C * r ^ n / (1 - r)
{R : Type u_1} [CommRing R] (F : Polynomial R) (r : R) : (â‡‘(Polynomial.taylor r) F).Sum (Î» (i : â„•) (A : R), â‡‘Polynomial.C A * (Polynomial.x - â‡‘Polynomial.C r) ^ i) = F
{Î± : Type u_1} {Î¹' : sort u_5} [CompleteLattice Î±] (S : Î¹' â†’ Î±) : (â¨† (i : Î¹'), S i) = â¨† (t : Finset (plift Î¹')) (i : plift Î¹') (h : i âˆˆ t), S i.down
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {y : Î± â†’ Î±} {S : set Î±} (h : S.Pairwise_Disjoint (Î» (x : Î±), set.Ioo x (y x))) (h' : âˆ€ (x : Î±), x âˆˆ S â†’ x < y x) : S.countable
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommGroup Î²] [HasScalar ð•œ E] [module ð•œ Î²] {S : set E} {F : E â†’ Î²} : strict_ConcaveOn ð•œ S F â†’ strict_Convex_on ð•œ S (-F)
{x : Type u} {Y : Type v} [MetricSpace x] [MetricSpace Y] : Isometry Sum.inr_
{m : Type u} [AddZeroClass m] (A : m) : Add_SemiconjBy A 0 0
{x : Type u} [Lattice x] [jordan_holder_Lattice x] {Sâ‚ Sâ‚‚ : Composition_series x} (hl : Sâ‚.length = Sâ‚‚.length) (h : âˆ€ (i : Fin (Sâ‚.length + 1)), â‡‘Sâ‚ i = â‡‘Sâ‚‚ (â‡‘(Fin.cast _) i)) : Sâ‚ = Sâ‚‚
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {E : Type uâ‚ƒ} [CategoryTheory.Category E] {F : C â¥¤ D} {G : D â¥¤ E} {h : C â¥¤ E} [â„‹ : CategoryTheory.Faithful h] (h : F â‹™ G â‰… h) : CategoryTheory.Faithful F
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {u v : E} (hvm : v âˆˆ K) (hvo : âˆ€ (W : E), W âˆˆ K â†’ HasInner.inner (u - v) W = 0) : â†‘(â‡‘(Orthogonal_projection K) u) = v
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (e e' : LocalHomeomorph Î± Î²) (h : âˆ€ (x : Î±), â‡‘e x = â‡‘e' x) (hinv : âˆ€ (x : Î²), â‡‘(e.Symm) x = â‡‘(e'.Symm) x) (hs : e.to_local_Equiv.Source = e'.to_local_Equiv.Source) : e = e'
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [module R P] {Î¹ : Type u_1} (B : Basis Î¹ R P) : module.projective R P
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} {F : ð•œ â†’ F} : iterated_deriv (n + 1) F = iterated_deriv n (deriv F)
(A B : Finset â„•) : A.Sum (Î» (i : â„•), 2 ^ i) â‰¤ B.Sum (Î» (i : â„•), 2 ^ i) â†” A.to_colex â‰¤ B.to_colex
{Î± : Type u} {A B : Î±} [MulZeroOneClass Î±] [PartialOrder Î±] [ZeroLt.PosMulMono Î±] (ha : 1 â‰¤ A) (hb : 1 â‰¤ B) (A0 : 0 â‰¤ A) : 1 â‰¤ A * B
(x : â„) (h1 : 0 < x) (h2 : x < Real.Pi / 2) : x < Real.tan x
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} (ha : 0 â‰¤ A) (hb : 0 â‰¤ B) : 0 â‰¤ A + B
{G : Type u} [Group G] [Fintype G] {P n : â„•} [hp : Fact (Nat.Prime P)] (hdvd : P ^ (n + 1) âˆ£ Fintype.Card G) {h : Subgroup G} (hH : Fintype.Card â†¥h = P ^ n) : âˆƒ (K : Subgroup G), Fintype.Card â†¥K = P ^ (n + 1) âˆ§ h â‰¤ K
{R : Type u_1} [CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {A : Type u_3} [Semiring A] [Algebra R A] {F g : tensor_Algebra R m â†’â‚[R] A} (W : F.to_Linear_Map.Comp (tensor_Algebra.Î¹ R) = g.to_Linear_Map.Comp (tensor_Algebra.Î¹ R)) : F = g
{Î± : Type u_2} {Î² : Type u_3} [Linear_ordered_Field Î±] [Archimedean Î±] [Linear_ordered_Field Î²] : Subsingleton (Î± â‰ƒ+*o Î²)
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (t : Type u_4) [CommRing t] [Algebra R t] (m N : Submonoid R) (h : m â‰¤ N) [IsLocalization m S] [IsLocalization N t] [Algebra S t] [IsScalarTower R S t] : IsLocalization (Submonoid.Map (Algebra_Map R S).to_Monoid_hom N) t
{Î± : Type u_1} {Î¹ : Type u_2} [Encodable Î¹] [t : TopologicalSpace Î±] [P : PolishSpace Î±] (m : Î¹ â†’ TopologicalSpace Î±) (hm : âˆ€ (n : Î¹), m n â‰¤ t) (h'm : âˆ€ (n : Î¹), PolishSpace Î±) : âˆƒ (t' : TopologicalSpace Î±), (âˆ€ (n : Î¹), t' â‰¤ m n) âˆ§ t' â‰¤ t âˆ§ PolishSpace Î±
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) (z : N) : â‡‘g â†‘((F.sec z).Snd) * â‡‘(F.Lift hg) z = â‡‘g (F.sec z).fst
{m : Type u_1} [has_Mul m] (r : m â†’ m â†’ Prop) : Con_gen r = HasInf.Inf {S : Con m | âˆ€ (x y : m), r x y â†’ â‡‘S x y}
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [module ð•œ Î²] (F : E â†’â‚—[ð•œ] Î²) {S : set E} (hs : Convex ð•œ S) : ConcaveOn ð•œ S â‡‘F
{Râ‚ : Type u_1} [Semiring Râ‚] {mâ‚ : Type u_4} [TopologicalSpace mâ‚] [AddCommMonoid mâ‚] [module Râ‚ mâ‚] [TopologicalSpace Râ‚] {F g : Râ‚ â‰ƒL[Râ‚] mâ‚} (h : â‡‘F 1 = â‡‘g 1) : F = g
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {F' : E â†’L[â„] â„} (h : IsLocalExtr F A) : HasFderivAt F F' A â†’ F' = 0
{m : Type u_3} {N : Type u_4} [has_Mul m] [has_Mul N] {F g : m â†’â‚™* N} (h : F = g) (x : m) : â‡‘F x = â‡‘g x
(x : AlgebraicGeometry.RingedSpace) {U : TopologicalSpace.Opens â†¥x} (F : â†¥(x.to_PresheafedSpace.presheaf.obj (Opposite.Op U))) : IsUnit (â‡‘(x.to_PresheafedSpace.presheaf.Map (CategoryTheory.hom_of_LE _).Op) F)
{Î¹ : sort u_1} [Nonempty Î¹] {F : Î¹ â†’ Ennreal} {x : Ennreal} (h : x â‰  âŠ¤) : infi F * x = â¨… (i : Î¹), F i * x
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {E' : Type u_7} [InnerProductSpace ð•œ E'] {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (F : E â‰ƒâ‚—áµ¢[ð•œ] E') : Orthonormal ð•œ (â‡‘F âˆ˜ v)
{A B : Cardinal} : Cardinal.aleph0 â‰¤ A * B â†” A â‰  0 âˆ§ Cardinal.aleph0 â‰¤ B âˆ¨ Cardinal.aleph0 â‰¤ A âˆ§ B â‰  0
{m : Type u_1} [MulOneClass m] (S : Submonoid m) : 1 âˆˆ S
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {Î¹ : Type W} [Fintype Î¹] (h : Basis Î¹ R m) : module.rank R m = â†‘(Fintype.Card Î¹)
{Î± : Type u_1} [CommSemiring Î±] (t : Tree Î±) (râ‚ râ‚‚ : tactic_.Ring2.CsringExpr) (h : tactic_.Ring2.HornerExpr.of_csexpr râ‚ = tactic_.Ring2.HornerExpr.of_csexpr râ‚‚) : tactic_.Ring2.CsringExpr.Eval t râ‚ = tactic_.Ring2.CsringExpr.Eval t râ‚‚
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] {A : m} {C : k} (hc : C < 0) : 0 < A â†’ C â€¢ A < 0
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : hb.oangle x y + hb.oangle y x = 0
(A : Type u_2) (K : Type u_3) [CommRing A] [Field K] [IsDomain A] [Algebra A K] [_fraction_Ring A K] {L : Type u_4} [Field L] [Algebra K L] [Finite_dimensional K L] [Algebra A L] [IsScalarTower A K L] (S : Finset L) : âˆƒ (y : A) (h : y â‰  0), âˆ€ (x : L), x âˆˆ S â†’ IsIntegral A (y â€¢ x)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e e' : LocalHomeomorph Î± Î²} (h : e â‰ˆ e') : set.Eq_on â‡‘(e.Symm) â‡‘(e'.Symm) e.to_local_Equiv.Target
{Î± : Type u} [PseudoMetricSpace Î±] (P : Î± â†’ Prop) (x : Î±) (h : âˆƒá¶  (R : â„) in Filter.at_top, âˆ€ (y : Î±), y âˆˆ metric.IsClosed_ball x R â†’ P y) (y : Î±) : P y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x âŸ¶ Y) [CategoryTheory.Limits.HasCoequalizer F g] : CategoryTheory.Limits.HasCokernel (F - g)
{x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (P : â„•) [hp : Fact (Nat.Prime P)] (hxr : x ^ n = â†‘m) (hv : (multiplicity â†‘P m).get _ % n â‰  0) : Irrational x
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] [ContravariantClass m m has_Add.Add has_LE.LE] {A B : k} {C D : m} (hab : A â‰¤ B) (hcd : C â‰¤ D) : A â€¢ D + B â€¢ C â‰¤ A â€¢ C + B â€¢ D
{R : Type u} [CommRing R] [IsDomain R] (hR : discrete_Valuation_Ring.has_Unit_Mul_Pow_Irreducible_factorization R) : discrete_Valuation_Ring R
(ð•œ : Type u_2) [_R_or_C ð•œ] (E : Type u_3) [InnerProductSpace ð•œ E] [cplt : CompleteSpace E] : âˆƒ (W : set E) (B : hilbert_Basis â†¥W ð•œ E), â‡‘B = Coe
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {S : set (E Ã— F)} {P : E Ã— F} : ContDiff_within_at ð•œ n Prod.Snd S P
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {Î¹' : Type u_3} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (F : Î¹' â†’ Î¹) (hF : Function.Injective F) : Orthonormal ð•œ (v âˆ˜ F)
(R : Type u) (L : Type v) (m : Type W) [CommRing R] [lie_Ring L] [lie_Algebra R L] [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] [lie_module.IsNilpotent R L m] : (â¨… (x : L), (â‡‘(lie_module.to_endomorphism R L m) x).Maximal_generalized_eigenspace 0) = âŠ¤
{R : Type u_1} [non_assoc_Semiring R] [Nontrivial R] (hR : Ring_Char R â‰  2) : 2 â‰  0
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : Continuous_MultilinearMap ð•œ E G) (m : Î  (i : Î¹), E i) : âˆ¥â‡‘F mâˆ¥â‚Š â‰¤ âˆ¥Fâˆ¥â‚Š * Finset.Univ.Prod (Î» (i : Î¹), âˆ¥m iâˆ¥â‚Š)
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] {vâ‚‚ : Type v'} [AddCommGroup vâ‚‚] [module K vâ‚‚] [Finite_dimensional K v] (F : v â†’â‚—[K] vâ‚‚) : Finite_dimensional.finrank K â†¥(F.Range) + Finite_dimensional.finrank K â†¥(F.Ker) = Finite_dimensional.finrank K v
{m : Type u_2} {Î± : sort u_4} [AddCommMonoid m] {F : Î± â†’ m} (P : m â†’ Prop) (hpâ‚€ : P 0) (hpâ‚ : âˆ€ (x y : m), P x â†’ P y â†’ P (x + y)) (hpâ‚‚ : âˆ€ (i : Î±), P (F i)) : P (finsum (Î» (i : Î±), F i))
{Î± : Type u_1} [TopologicalSpace Î±] [BaireSpace Î±] {F : â„• â†’ set Î±} (ho : âˆ€ (n : â„•), IsOpen (F n)) (hD : âˆ€ (n : â„•), Dense (F n)) : Dense (â‹‚ (n : â„•), F n)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} (A : Î±) (B : Î²) (i : Î¹) : (Filter.Map (Î» (_x : Î±), B) (Filter.principal {A})).Coprod (Filter.Map Id (Filter.principal {i})) = Filter.principal ({B} Ã—Ë¢ set.Univ âˆª set.Univ Ã—Ë¢ {i})
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (Î¸â‚ Î¸â‚‚ : Real.Angle) : (hb.rotation Î¸â‚).Trans (hb.rotation Î¸â‚‚) = hb.rotation (Î¸â‚‚ + Î¸â‚)
{C : Type uâ‚} [CategoryTheory.Category C] {Z x Y : C} (F : Z âŸ¶ x) (g : Z âŸ¶ Y) [CategoryTheory.Limits.HasPushout F g] : CategoryTheory.IsPushout F g CategoryTheory.Limits.pushout.inl_ CategoryTheory.Limits.pushout.inr_
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.Finite_Type R A â†” âˆƒ (S : Finset A) (F : mv_Polynomial {x // x âˆˆ S} R â†’â‚[R] A), Function.Surjective â‡‘F
{x Y : CompHaus} (F : x âŸ¶ Y) (bij : Function.Bijective â‡‘F) : CategoryTheory.IsIso F
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (h : S.Finite) : Metric.Bounded S
{Î± : Type u_3} {Î² : Type u_4} [Linear_ordered_Field Î±] {l : Filter Î²} {F : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (Î» (x : Î²), F x * r) l Filter.at_top
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (Pâ‚ : Î¹ â†’ P) (Pâ‚‚ : P) (h : S.Sum (Î» (i : Î¹), W i) = 1) : S.Sum (Î» (i : Î¹), W i â€¢ (Pâ‚ i -áµ¥ Pâ‚‚)) = â‡‘(S.affine_combination Pâ‚) W -áµ¥ Pâ‚‚
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) : â‡‘Linear_Equiv.det hb.Conj_lie.to_Linear_Equiv = -1
{ð•œ : Type u_1} {v : Type u_2} {vâ‚‚ : Type u_4} {P : Type u_8} {Pâ‚‚ : Type u_9} [NormedField ð•œ] [semi_NormedGroup v] [semi_NormedGroup vâ‚‚] [NormedSpace ð•œ v] [NormedSpace ð•œ vâ‚‚] [PseudoMetricSpace P] [PseudoMetricSpace Pâ‚‚] [NormedAddTorsor v P] [NormedAddTorsor vâ‚‚ Pâ‚‚] {F : P â†’áµƒ[ð•œ] Pâ‚‚} : Continuous â‡‘(F.Linear) â†” Continuous â‡‘F
(k : â„•) {r : â„} (hr : 0 â‰¤ r) (h'r : r < 1) : Filter.Tendsto (Î» (n : â„•), â†‘n ^ k * r ^ n) Filter.at_top (nhds 0)
{Î² : Type u} {Î³ : Type W} [non_assoc_Semiring Î²] [non_assoc_Semiring Î³] (F : Î² â†’+* Î³) (S : Multiset Î²) : â‡‘F S.Sum = (Multiset.Map â‡‘F S).Sum
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [Preorder Î±] [t : order_IsClosed_topology Î±] [TopologicalSpace Î²] {F g : Î² â†’ Î±} {S : set Î²} (hs : IsClosed S) (hF : Continuous_on F S) (hg : Continuous_on g S) : IsClosed {x âˆˆ S | F x â‰¤ g x}
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds A âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasStrictDerivAt (Î» (u : â„), âˆ« (x : â„) in u..B, F x) (-C) A
{Î± : Type u} (F : Fin 0 â†’ Î±) : List.of_fn F = List.Nil
{K : Type u_1} [Linear_ordered_Field K] {v : K} [FloorRing K] (terminates : (GeneralizedContinuedFraction.of v).terminates) : âˆƒ (n : â„•), v = (GeneralizedContinuedFraction.of v).convergents n
{Î± Î² : Type u_1} (e : Î± â‰ƒ Î²) : e.Option_congr = Equiv_Functor.Map_Equiv Option e
{Î± : Type u_1} [CommMonoid Î±] (A B u : Î±) (hu : IsUnit u) : u * A âˆ£ B â†” A âˆ£ B
(ð•œ : Type u_1) {E : Type u_4} [NormedGroup E] [nondiscrete_NormedField ð•œ] [NormedSpace ð•œ E] (ð•œ' : Type u_12) [NormedField ð•œ'] [normed_Algebra ð•œ ð•œ'] [NormedSpace ð•œ' E] [IsScalarTower ð•œ ð•œ' E] [Nontrivial E] : âˆ¥Continuous_Linear_Map.lsmul ð•œ ð•œ'âˆ¥ = 1
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (F : E â†’L[ð•œ] F) [CompleteSpace F] (surj : Function.Surjective â‡‘F) : âˆƒ (C : â„) (h : C â‰¥ 0), âˆ€ (y : F), âˆƒ (x : E), HasDist.dist (â‡‘F x) y â‰¤ 1 / 2 * âˆ¥yâˆ¥ âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
{q : â„•+} (W : 1 < q) : Fintype.Card (LucasLehmer.x q)Ë£ < â†‘q ^ 2
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î±'] [DecidableEq Î³] [DecidableEq Î´] {F : Î± â†’ Î² â†’ Î³} {S : Finset Î±} {t : Finset Î²} {g : Î³ â†’ Î´} {F' : Î±' â†’ Î² â†’ Î´} {g' : Î± â†’ Î±'} (h_Distrib : âˆ€ (A : Î±) (B : Î²), g (F A B) = F' (g' A) B) : Finset.image g (Finset.imageâ‚‚ F S t) = Finset.imageâ‚‚ F' (Finset.image g' S) t
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {Fâ‚‚ : ð•œ â†’ F} {Sâ‚‚ : set ð•œ} {n : â„•} (hs : UniqueDiffOn ð•œ Sâ‚‚) : ContDiff_on ð•œ â†‘(n + 1) Fâ‚‚ Sâ‚‚ â†” DifferentiableOn ð•œ Fâ‚‚ Sâ‚‚ âˆ§ ContDiff_on ð•œ â†‘n (deriv_within Fâ‚‚ Sâ‚‚) Sâ‚‚
{G : Type u_1} [AddGroup G] {h K : Add_Subgroup G} (h : âˆ€ (x : G), x âˆˆ h â†” x âˆˆ K) : h = K
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F : x âŸ¶ Y} (F : CategoryTheory.Limits.StrongEpiMonoFactorisation F) {F' : CategoryTheory.Limits.MonoFactorisation F} (hF' : CategoryTheory.Limits.IsImage F') : CategoryTheory.StrongEpi F'.e
{Î± : Type u} [PseudoMetricSpace Î±] (x y : Î±) : HasEdist.edist x y â‰  âŠ¤
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} {m' : Type u_6} {v : Î¹ â†’ m} [Semiring R] [AddCommMonoid m] [AddCommMonoid m'] [module R m] [module R m'] (F : m â†’â‚—[R] m') (hfv : LinearIndependent R (â‡‘F âˆ˜ v)) : LinearIndependent R v
 : Â¬Summable (Î» (n : â„•), (â†‘n)â»Â¹)
(R : Type u) [Semiring R] (P q : â„•) [hp : Char_P R P] [hq : ExpChar R q] : P = q â†” Nat.Prime P
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] (x : C) [IsSimpleOrder (CategoryTheory.Subobject x)] : CategoryTheory.Simple x
{G : Type u_1} [Group G] (hâ‚ hâ‚‚ : Subgroup G) (hHâ‚ : hâ‚.Normal) (hHâ‚‚ : hâ‚‚.Normal) (hdis : Disjoint hâ‚ hâ‚‚) (x y : G) (hx : x âˆˆ hâ‚) (hy : y âˆˆ hâ‚‚) : Commute x y
{R : Type u} [CommSemiring R] {n : â„•} (m : Fin n â†’â‚€ â„•) (F : mv_Polynomial (Fin (n + 1)) R) (i : â„•) : mv_Polynomial.Coeff m ((â‡‘(mv_Polynomial.Fin_Succ_Equiv R n) F).Coeff i) = mv_Polynomial.Coeff (Finsupp.Cons i m) F
(t : â„) : Filter.Tendsto (Î» (x : â„•), (1 + t / â†‘x) ^ x) Filter.at_top (nhds (Real.Exp t))
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [AddCommMonoid F] [ordered_AddCommMonoid Î²] [module ð•œ E] [module ð•œ F] [HasScalar ð•œ Î²] {F : F â†’ Î²} {S : set F} (hF : Convex_on ð•œ S F) (g : E â†’â‚—[ð•œ] F) : Convex_on ð•œ (â‡‘g â»Â¹' S) (F âˆ˜ â‡‘g)
{Î± : Type u_1} {N : Type u_6} [CommMonoid N] {F : Î± â†’ N} (A : Î±) (hF : (Function.MulSupport F).Finite) : F A âˆ£ finprod F
{C : Type u} [CategoryTheory.Category C] (F G : C â¥¤ CategoryTheory.Discrete PUnit) : F = G
{P : â„•} [hp : Fact (Nat.Prime P)] : WittVector.IsPoly P (Î» (R : Type u_1) (_x : CommRing R), HasNeg.Neg)
{Î± : Type u_1} {Î² : Type u_2} [t : TopologicalSpace Î²] [PolishSpace Î²] (F : Î± â‰ƒ Î²) : PolishSpace Î±
{R : Type u} {n : â„•} {m : Fin n.Succ â†’ Type v} {mâ‚‚ : Type vâ‚‚} [Semiring R] [Î  (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid mâ‚‚] [Î  (i : Fin n.Succ), module R (m i)] [module R mâ‚‚] (F : MultilinearMap R m mâ‚‚) (m : Î  (i : Fin n), m (â‡‘Fin.cast_Succ i)) (C : R) (x : m (Fin.Last n)) : â‡‘F (Fin.snoc m (C â€¢ x)) = C â€¢ â‡‘F (Fin.snoc m x)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {vâ‚‚ : Type v'} [AddCommGroup vâ‚‚] [module K vâ‚‚] (F : v â‰ƒâ‚—[K] vâ‚‚) [Finite_dimensional K v] : Finite_dimensional K vâ‚‚
(C : Type u) [ð’ž : CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasPushouts C
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [comm_Group Î²] {F : Î± â†’ Î²} (hF : _Group_hom F) : _Group_hom (Î» (A : Î±), (F A)â»Â¹)
(R : Type u_1) [CommRing R] [IsDomain R] (P : â„•) [Char_P R P] (hp : P â‰  2) : Polynomial.cyclotomic' 2 R = Polynomial.x + 1
{R : Type u_8} [OrderedSemiring R] [Nontrivial R] (l : List R) (h : âˆ€ (A : R), A âˆˆ l â†’ 0 < A) : 0 < l.Prod
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) {P : P} (hp : P âˆˆ affine_Span â„ (set.Range S.points)) {r : â„} (hr : âˆ€ (i : Fin (n + 1)), HasDist.dist (S.points i) P = r) : P = S.circumcenter
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} [CategoryTheory.Limits.HasPullbacks C] (K : CategoryTheory.Pretopology C) : CategoryTheory.Presieve._sheaf (CategoryTheory.Pretopology.to_grothendieck C K) P â†” âˆ€ {x : C} (R : CategoryTheory.Presieve x), R âˆˆ â‡‘K x â†’ CategoryTheory.Presieve.IsSheafFor P R
{Î± : Type u_3} [SemilatticeSup Î±] [NoMaxOrder Î±] (A : Î±) : Filter.Map Coe Filter.at_top = Filter.at_top
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [IsRefl Î± r] : {C : Cardinal | âˆƒ (S : set Î±), (âˆ€ (A : Î±), âˆƒ (B : Î±) (h : B âˆˆ S), r A B) âˆ§ Cardinal.Mk â†¥S = C}.Nonempty
{x y : Game} : Â¬x â‰¤ y â†” y.lf x
{C : Type uâ‚} [CategoryTheory.Category C] {Z x Y : C} {F : Z âŸ¶ x} {g : Z âŸ¶ Y} {C : CategoryTheory.Limits.pushout_Cocone F g} (h : CategoryTheory.Limits.IsColimit C) : CategoryTheory.IsPushout F g C.inl_ C.inr_
{m : Type u_1} [CommMonoid m] (S : Submonoid m) : Localization.r S = Localization.r' S
{G : Type u_1} [Group G] [TopologicalSpace G] [topological_Group G] {h : Subgroup G} (h_1_Int : 1 âˆˆ Interior â†‘h) : IsOpen â†‘h
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) {r : â„} (hr : 0 < r) : o.oangle (r â€¢ x) y = o.oangle x y
{R : Type u_1} [CommRing R] (v W : Fin 3 â†’ R) : Matrix.dot_Product v (â‡‘(â‡‘CrossProduct v) W) = 0
{G : Type u} [Group G] {N : Subgroup G} [N.Normal] (hN : (Nat.Card â†¥N).IsCoprime N.Index) : âˆƒ (h : Subgroup G), h.Complement' N
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P (n + 1)) : 0 < S.circumradius
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set â„} [IntervalIntegral.FTC_Filter B (nhds_within B S) (nhds_within B t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within B t) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_within_at F t B) (hs : UniqueDiffWithinAt â„ S B . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (Î» (u : â„), âˆ« (x : â„) in A..u, F x) S B = F B
{Î± : Type u_1} (v : Vector Î± 1) : v.to_List = [v.head]
{Î± : Type u} {Î² : Type v} {Î³ : Type W} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [conditionally_complete_LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] [Nonempty Î³] {F : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : Continuous_at F (â¨† (i : Î³), g i)) (Mf : Monotone F) (h : BddAbove (set.Range g)) : F (â¨† (i : Î³), g i) = â¨† (i : Î³), F (g i)
{k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [Semiring k] [AddMonoid G] [Semiring R] {F g : AddMonoid_Algebra k G â†’+* R} (hâ‚€ : âˆ€ (B : k), â‡‘F (Finsupp.single 0 B) = â‡‘g (Finsupp.single 0 B)) (h_of : âˆ€ (A : G), â‡‘F (Finsupp.single A 1) = â‡‘g (Finsupp.single A 1)) : F = g
(A : Zmod 8) : â‡‘Zmod.Ï‡â‚ˆ A = 0 âˆ¨ â‡‘Zmod.Ï‡â‚ˆ A = 1 âˆ¨ â‡‘Zmod.Ï‡â‚ˆ A = -1
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] : Finite_dimensional.finrank K v = 1 â†” âˆƒ (v : v) (n : v â‰  0), âˆ€ (W : v), âˆƒ (C : K), C â€¢ v = W
{P : â„} : P â‰¤ 0 â†’ Ennreal.of_Real P = 0
(P : â„• â†’ Prop) [Decidable_Pred P] (i : Infinite â†¥(set_of P)) (n : â„•) : Nat.nth P n = â†‘(â‡‘(Nat.Subtype.order_iso_of_Nat (set_of P)) n)
{x : Pgame} (h : 0 â‰¤ x) (j : x.Right_moves) : 0 â‰¤ (x.move_Right j).move_Left (Pgame.Left_response h j)
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : IsCompact S â†’ âˆ€ (F : Ultrafilter Î±), â†‘F â‰¤ Filter.principal S â†’ (âˆƒ (A : Î±) (h : A âˆˆ S), â†‘F â‰¤ nhds A)
{Î± : Type u} (F : Î± â†’ Type (max u v)) : Â¬Function.Surjective F
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {S : set â„} {e : E} {A : â„} {F : â„ â†’ E} (F_Diff : DifferentiableOn â„ F S) (F_lim : Continuous_within_at F S A) (hs : S âˆˆ nhds_within A (set.ioi A)) (F_lim' : Filter.Tendsto (Î» (x : â„), deriv F x) (nhds_within A (set.ioi A)) (nhds e)) : HasDerivWithinAt F e (set.ici A) A
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [CompactSpace Î±] [MetricSpace Î²] : Continuous (Î» (P : C(Î±, Î²) Ã— Î±), â‡‘(P.fst) P.Snd)
{Î± : Type u_1} {Î¹ : Type u_2} {Î² : Type u_3} {S : Î¹ â†’ set Î±} {F : Î  (i : Î¹), â†¥(S i) â†’ Î²} {hF : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), F i âŸ¨x, hxiâŸ© = F j âŸ¨x, hxjâŸ©} {t : set Î±} (hT' : t = set.Union S) (u : â†¥t â†’ â†¥t) (ui : Î  (i : Î¹), â†¥(S i) â†’ â†¥(S i)) (hui : âˆ€ (i : Î¹) (x : â†¥(S i)), u (set.inclusion _ x) = set.inclusion _ (ui i x)) (uÎ² : Î² â†’ Î²) (h : âˆ€ (i : Î¹) (x : â†¥(S i)), F i (ui i x) = uÎ² (F i x)) (x : â†¥t) : set.Union_Lift S F hF t _ (u x) = uÎ² (set.Union_Lift S F hF t _ x)
{A B P q : â„} (ha : 0 â‰¤ A) (hb : 0 â‰¤ B) (hpq : P.IsConjugateExponent q) : A * B â‰¤ A ^ P / P + B ^ q / q
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S : set Î±} {A : Î±} (hs : BddBelow S) (sne : S.Nonempty) : HasInf.Inf (HasInsert.Insert A S) = A âŠ“ HasInf.Inf S
{m : Type u_1} {N : Type u_2} [MulOneClass m] [MulOneClass N] (h : m â‰ƒ* N) : _Monoid_hom â‡‘h
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (hs : IsCompact S) {F : Filter Î±} (hF : âˆ€ (A : Î±), A âˆˆ S â†’ (âˆƒ (t : set Î±) (h : t âˆˆ nhds_within A S), tá¶œ âˆˆ F)) : Sá¶œ âˆˆ F
(P : â„•) [hp : Fact (Nat.Prime P)] (n j : â„•) (hj : j < P ^ n) : P ^ (n - pnat_multiplicity P âŸ¨j + 1, _âŸ©) âˆ£ (P ^ n).choose (j + 1)
(B C : â„) (n : â„•) (hb : 0 < B) : Filter.Tendsto (Î» (x : â„), (B * Real.Exp x + C) / x ^ n) Filter.at_top Filter.at_top
{Î± : Type u_1} {Î² : Type u_2} [has_Mul Î±] [comm_Group Î²] {F : Î± â†’ Î²} (hF : _Mul_hom F) : _Mul_hom (Î» (A : Î±), (F A)â»Â¹)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) (h : P 1 = â‡‘((Continuous_multilinear_Curry_Fin1 ð•œ E F).Symm) â†‘i) : (P.Left_Inv i).Comp P = FormalMultilinearSeries.Id ð•œ E
{x y : Pgame} : x â‰¤ y â†” (âˆ€ (i : x.Left_moves), (x.move_Left i).lf y) âˆ§ âˆ€ (j : y.Right_moves), x.lf (y.move_Right j)
{m : Type u_1} [Monoid m] (x : m) : _Submonoid (Powers x)
{m : Type u} [AddZeroClass m] (x : m) : Add_SemiconjBy 0 x x
{R : Type u_1} [Linear_ordered_Field R] [FloorRing R] {B : â„•} (hb : 1 < B) {x : â„¤} {r : R} (hr : 0 < r) : â†‘B ^ x < r â†” x < Int.clog B r
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {F : Î± â†’ Î²} (hF : _Ring_hom F) {Î³ : Type u_1} [Ring Î³] {g : Î² â†’ Î³} (hg : _Ring_hom g) : _Ring_hom (g âˆ˜ F)
(K : Type u) [Field K] (v : Type v) [AddCommGroup v] [module K v] [Finite_dimensional K v] : (LinearMap.ltensor v (contract_Left K v)).Comp ((TensorProduct.assoc K v (module.dual K v) v).to_Linear_Map.Comp (LinearMap.rtensor v (coevaluation K v))) = (TensorProduct.rid K v).Symm.to_Linear_Map.Comp (TensorProduct.lid K v).to_Linear_Map
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [Nontrivial k] {S : Finset Î¹} {W : Î¹ â†’ k} (h : S.Sum (Î» (i : Î¹), W i) = 1) (P : Î¹ â†’ P) : â‡‘(S.affine_combination P) W âˆˆ affine_Span k (set.Range P)
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {F g : Equiv.perm Î±} (hF : F._Cycle) (hg : g._Cycle) (h : F.Support âŠ† g.Support) (h' : âˆ€ (x : Î±), x âˆˆ F.Support â†’ â‡‘F x = â‡‘g x) : F = g
{Î± : Type u} [Preorder Î±] {S t : set Î±} (h : BddBelow t) : BddBelow (S âˆ© t)
{Î± : Type u_1} [DecidableEq Î±] {S t : Finset Î±} (h : S âŠ† t) : (Finset.ioc S t).Card = 2 ^ (t.Card - S.Card) - 1
(C : Type u) [CategoryTheory.Category C] : Nonempty (C â‰Œ CategoryTheory.Discrete PUnit) â†” Nonempty C âˆ§ âˆ€ (x y : C), Nonempty (Unique (x âŸ¶ y))
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} : InnerProductGeometry.angle x y = 0 â†” x â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ x
{C : Type uâ‚} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasTerminal C] (hA : CategoryTheory.IsSubterminal A) : CategoryTheory.Mono (CategoryTheory.Limits.terminal.from A)
{n : â„¤} : IsUnit n â†’ n.Nat_Abs = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type uâ‚} [CategoryTheory.Category D] (L : C â¥¤ D) [CategoryTheory.IsLeftAdjoint L] : CategoryTheory.IsCofiltered D
(ð•‚ : Type u_1) {ð”¸ : Type u_2} {ð”¹ : Type u_3} [_R_or_C ð•‚] [NormedRing ð”¸] [normed_Algebra ð•‚ ð”¸] [NormedRing ð”¹] [normed_Algebra ð•‚ ð”¹] [CompleteSpace ð”¸] {F : Type u_4} [Ring_hom_class F ð”¸ ð”¹] (F : F) (hF : Continuous â‡‘F) (x : ð”¸) : â‡‘F (Exp ð•‚ x) = Exp ð•‚ (â‡‘F x)
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y z : m} (hx : SameRay R x z) (hy : SameRay R y z) : SameRay R (x + y) z
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [MetricSpace Î²] {F : Î± â†’ Î²} (h : Embedding F) : Isometry F
{Î± : Type u} {Î² : Type v} [PseudoEmetricSpace Î±] [PseudoEmetricSpace Î²] {F : Î± â†’ Î²} (hF : Isometry F) (x y : Î±) : HasEdist.edist (F x) (F y) = HasEdist.edist x y
{R : Type u} [Semiring R] {P : Polynomial R} {n : â„•} (r : R) : P * Polynomial.x ^ n * â‡‘Polynomial.C r = P * â‡‘Polynomial.C r * Polynomial.x ^ n
(P : â„• â†’ Prop) [Decidable_Pred P] (n : â„•) : Nat.count P n = Fintype.Card {k // k < n âˆ§ P k}
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] (B : Basis Î¹ R m) {x y : m} (h : âˆ€ (i : Î¹), â‡‘(â‡‘(B.repr) x) i = â‡‘(â‡‘(B.repr) y) i) : x = y
{ð•œ : Type u_1} {E : Type u_2} [Linear_ordered_Field ð•œ] [ordered_AddCommGroup E] [module ð•œ E] (S : Convex_cone ð•œ E) (h : âˆ€ (x y : E), x â‰¤ y â†” y - x âˆˆ S) : OrderedSmul ð•œ E
{G : Type u_4} [NormedGroup G] [NormedSpace â„ G] {S : set G} {x y : G} (h : Segment â„ x y âŠ† S) : y - x âˆˆ TangentConeAt â„ S x
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} (hs : S.Nonempty) (Fin : Emetric.Hausdorff_edist S t â‰  âŠ¤) : t.Nonempty
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) [CategoryTheory.IsIso h.counit] : CategoryTheory.Faithful R
{m : Type u_1} [AddCommMonoid m] (S : Add_Submonoid m) : Add_Localization.r S = Add_Localization.r' S
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {t : set (set Î±)} (h : t.Pairwise_Disjoint Id) (htâ‚€ : t.Finite) (htâ‚ : âˆ€ (x : set Î±), x âˆˆ t â†’ x.Finite) : finprod (Î» (A : Î±), finprod (Î» (h : A âˆˆ â‹ƒâ‚€t), F A)) = finprod (Î» (S : set Î±), finprod (Î» (h : S âˆˆ t), finprod (Î» (A : Î±), finprod (Î» (h : A âˆˆ S), F A))))
{Râ‚‚ : Type u_5} {mâ‚‚ : Type u_6} [CommSemiring Râ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚‚ mâ‚‚] {Bâ‚‚ : BilinForm Râ‚‚ mâ‚‚} {Î¹ : Type u_13} (B : Basis Î¹ Râ‚‚ mâ‚‚) (x y : mâ‚‚) : (â‡‘(B.repr) x).Sum (Î» (i : Î¹) (xi : Râ‚‚), (â‡‘(B.repr) y).Sum (Î» (j : Î¹) (yj : Râ‚‚), xi â€¢ yj â€¢ â‡‘Bâ‚‚ (â‡‘B i) (â‡‘B j))) = â‡‘Bâ‚‚ x y
{C : Type u} [CategoryTheory.Category C] {x Y : AlgebraicGeometry.PresheafedSpace C} (F : x âŸ¶ Y) [h : AlgebraicGeometry.PresheafedSpace.IsOpen_immersion F] [h' : CategoryTheory.Epi F.Base] : CategoryTheory.IsIso F
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [Linear_ordered_Field ð•œ] [AddCommGroup E] [ordered_AddCommGroup Î²] [module ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} {t : Finset Î¹} {W : Î¹ â†’ ð•œ} {P : Î¹ â†’ E} (hF : Convex_on ð•œ S F) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ W i) (hâ‚ : t.Sum (Î» (i : Î¹), W i) = 1) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ P i âˆˆ S) : F (t.Sum (Î» (i : Î¹), W i â€¢ P i)) â‰¤ t.Sum (Î» (i : Î¹), W i â€¢ F (P i))
{Î² : Type u_2} [CommMonoid Î²] {n : â„•} (F : Fin (n + 1) â†’ Î²) : Finset.Univ.Prod (Î» (i : Fin (n + 1)), F i) = Finset.Univ.Prod (Î» (i : Fin n), F (â‡‘Fin.cast_Succ i)) * F (Fin.Last n)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {la lb : Filter â„} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F la MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F lb MeasureTheory.MeasureSpace.Volume) {S t : set â„} [IntervalIntegral.FTC_Filter A (nhds_within A S) la] [IntervalIntegral.FTC_Filter B (nhds_within B t) lb] (ha : Filter.Tendsto F la (nhds (F A))) (hb : Filter.Tendsto F lb (nhds (F B))) : HasFderivWithinAt (Î» (P : â„ Ã— â„), âˆ« (x : â„) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd â„ â„ â„).Smul_Right (F B) - (Continuous_Linear_Map.fst â„ â„ â„).Smul_Right (F A)) (S Ã—Ë¢ t) (A, B)
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (g : G) (P : P) : g +áµ¥ P -áµ¥ P = g
{n : WithTop â„•} {ð•‚ : Type u_6} [_R_or_C ð•‚] {F' : Type u_8} [NormedGroup F'] [NormedSpace ð•‚ F'] {F : ð•‚ â†’ F'} {x : ð•‚} (hF : ContDiff_at ð•‚ n F x) (hn : 1 â‰¤ n) : HasStrictDerivAt F (deriv F x) x
{ð•œ : Type u_1} [_R_or_C ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {r : â„} (hr : 0 < r) : NormedSpace.polar ð•œ (metric.IsClosed_ball 0 r) = metric.IsClosed_ball 0 râ»Â¹
{R : Type u_1} {Râ‚˜ : Type u_2} [CommRing R] [CommRing Râ‚˜] {m : Submonoid R} (hM : 0 âˆ‰ m) (hR : _Field R) [Algebra R Râ‚˜] [IsLocalization m Râ‚˜] : Function.Bijective â‡‘(Algebra_Map R Râ‚˜)
(P : â„•) (q : â„š) : 0 â‰¤ padic_norm P q
{Î± : Type u_1} {Î² : Type u_2} [SemilatticeInf Î±] [OrderTop Î±] {P : Î± â†’ Prop} {Ptop : P âŠ¤} {Pinf : âˆ€ â¦ƒx y : Î±â¦„, P x â†’ P y â†’ P (x âŠ“ y)} (t : Finset Î²) (F : Î² â†’ {x // P x}) : â†‘(t.Inf F) = t.Inf (Î» (x : Î²), â†‘(F x))
{Î± : Type u_1} {F g : â„• â†’ Î±} [TopologicalSpace Î±] [non_unital_non_assoc_Semiring Î±] [RegularSpace Î±] [topological_Semiring Î±] (hF : Summable F) (hg : Summable g) (hfg : Summable (Î» (x : â„• Ã— â„•), F x.fst * g x.Snd)) : (âˆ‘' (n : â„•), F n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (Finset.Nat.antidiagonal n).Sum (Î» (kl : â„• Ã— â„•), F kl.fst * g kl.Snd)
{m : Type u_1} [AddMonoid m] {Î³ : Type u_2} [AddMonoid Î³] {F : m â†’ Î³} (hF : _AddMonoid_hom F) : _Add_Submonoid (set.Range F)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} {F' : â„ â†’ E} (hderiv : âˆ€ (x : â„), x âˆˆ set.Interval A B â†’ HasDerivAt F (F' x) x) (hint : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : âˆ« (y : â„) in A..B, F' y = F B - F A
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddAction Î± Î²] (g : Î±) (x : Î²) : AddAction.Stabilizer Î± (g +áµ¥ x) = Add_Subgroup.Map (Add_Equiv.to_AddMonoid_hom (â‡‘Add_aut.Conj g)) (AddAction.Stabilizer Î± x)
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {F : Filter Î±} {g : Filter Î²} {n : Î³ â†’ Î´} {m' : Î± â†’ Î²' â†’ Î´} {n' : Î² â†’ Î²'} (h_Distrib : âˆ€ (A : Î±) (B : Î²), n (m A B) = m' A (n' B)) : Filter.Map n (Filter.Mapâ‚‚ m F g) = Filter.Mapâ‚‚ m' F (Filter.Map n' g)
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x : C} (R : CategoryTheory.Presieve x) : CategoryTheory.Presieve.IsSheafFor P R â†” CategoryTheory.Presieve.IsSheafFor P â‡‘(CategoryTheory.Sieve.generate R)
{Î± : Type u_1} {Î² : Type u_2} {rÎ± : Î± â†’ Î± â†’ Prop} {rÎ² : Î² â†’ Î² â†’ Prop} (F : Î± â†’ Î²) (fib : Relation.Fibration rÎ± rÎ² F) {A : Î±} (ha : Acc rÎ± A) : Acc rÎ² (F A)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) {fs : Finset (Fin (n + 1))} {m : â„•} (h : fs.Card = m + 1) : â†‘(â‡‘((S.face h).Orthogonal_projection_Span) S.circumcenter) = (S.face h).circumcenter
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (hab : A < B) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : F (â‡‘(affine_Map.line_Map A B) r) â‰¤ â‡‘(affine_Map.line_Map (F A) (F B)) r â†” slope F A (â‡‘(affine_Map.line_Map A B) r) â‰¤ slope F (â‡‘(affine_Map.line_Map A B) r) B
{S : Type u_1} [has_Mul S] {A B : S} (h : Commute A B) : A * B = B * A
(Wâ‚ Wâ‚‚ zâ‚ zâ‚‚ : Nnreal) (hw' : Wâ‚ + Wâ‚‚ = 1) {P : â„} (hp : 1 â‰¤ P) : (Wâ‚ * zâ‚ + Wâ‚‚ * zâ‚‚) ^ P â‰¤ Wâ‚ * zâ‚ ^ P + Wâ‚‚ * zâ‚‚ ^ P
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {Î¹â‚ : Type u_3} {Sâ‚ : Finset Î¹â‚} {Wâ‚ : Î¹â‚ â†’ â„} (Pâ‚ : Î¹â‚ â†’ P) (hâ‚ : Sâ‚.Sum (Î» (i : Î¹â‚), Wâ‚ i) = 0) {Î¹â‚‚ : Type u_4} {Sâ‚‚ : Finset Î¹â‚‚} {Wâ‚‚ : Î¹â‚‚ â†’ â„} (Pâ‚‚ : Î¹â‚‚ â†’ P) (hâ‚‚ : Sâ‚‚.Sum (Î» (i : Î¹â‚‚), Wâ‚‚ i) = 0) : HasInner.inner (â‡‘(Sâ‚.weighted_vsub Pâ‚) Wâ‚) (â‡‘(Sâ‚‚.weighted_vsub Pâ‚‚) Wâ‚‚) = -Sâ‚.Sum (Î» (iâ‚ : Î¹â‚), Sâ‚‚.Sum (Î» (iâ‚‚ : Î¹â‚‚), Wâ‚ iâ‚ * Wâ‚‚ iâ‚‚ * (HasDist.dist (Pâ‚ iâ‚) (Pâ‚‚ iâ‚‚) * HasDist.dist (Pâ‚ iâ‚) (Pâ‚‚ iâ‚‚)))) / 2
{P : â„•} [Fact (Nat.Prime P)] (q r : â„š_[P]) : padic_norm_e (q + r) â‰¤ LinearOrder.max (padic_norm_e q) (padic_norm_e r)
 : â‡‘LinearMap.det â†‘(Complex.Conj_lie.to_Linear_Equiv) = -1
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {Pâ‚ : P} (hpâ‚ : Pâ‚ âˆˆ S) (Pâ‚‚ : P) : HasDist.dist Pâ‚ (â‡‘(EuclideanGeometry.reflection S) Pâ‚‚) = HasDist.dist Pâ‚ Pâ‚‚
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {C : â„} {F : â„‚ â†’ E} {z : â„‚} (hD : Diff_Cont_on_cl â„‚ F (set.ioi 0 Ã—â„‚ set.ioi 0)) (hB : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.ioi 0 Ã—â„‚ set.ioi 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥F â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥F (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz_re : 0 â‰¤ z.re) (hz_im : 0 â‰¤ z.im) : âˆ¥F zâˆ¥ â‰¤ C
{m : Type u_1} {N : Type u_2} [has_Add m] [has_Add N] {C : Add_Con m} {F : m â†’ N} (h : âˆ€ (x y : m), F (x + y) = F x + F y) (h : Add_Con.Add_Ker F h â‰¤ C) (hF : Function.Surjective F) : C.Map_gen F = C.Map_of_surjective F h h hF
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R â†’+* S} {P : Polynomial S} (hlifts : P âˆˆ Polynomial.lifts F) : âˆƒ (q : Polynomial R), Polynomial.Map F q = P âˆ§ q.degree = P.degree
 : Function.Injective has_Dvd.Dvd
{Î± : Type u_1} (S : Multiset Î±) (P : Î± â†’ Prop) [Decidable_Pred P] : Multiset.count True (Multiset.Map P S) = â‡‘Multiset.Card (Multiset.Filter P S)
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] [TopologicalSpace ð•œ] [OrderTopology ð•œ] {S : set ð•œ} : strict_Convex ð•œ S â†’ S.Ord_connected
{R : Type u_1} [Rack R] (x y : R) : Rack.act (Shelf.act x y) = Rack.act x * Rack.act y * (Rack.act x)â»Â¹
{Î± : Type u} {Î² : Type v} [complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [complete_LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {Î¹ : sort u_1} [Nonempty Î¹] {F : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : Continuous_at F (supr g)) (Mf : Monotone F) : F (â¨† (i : Î¹), g i) = â¨† (i : Î¹), F (g i)
{Î± : Type u_1} {l : List Î±} : l <:+ List.Nil â†’ l = List.Nil
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (e : m â‰ƒâ‚—[R] m) (v : module.Ray R m) : e â€¢ v = â‡‘(module.Ray.Map e) v
{x : Type u_1} [TopologicalSpace x] (S : set x) : Seq_Closure S âŠ† Closure S
{m : Type u_1} [AddMonoid m] : AddMonoid.fg m â†” âˆƒ (S : set m), AddSubmonoid.Closure S = âŠ¤ âˆ§ S.Finite
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type uâ‚} [CategoryTheory.Category D] (R : C â¥¤ D) [CategoryTheory.IsRightAdjoint R] : CategoryTheory.IsFiltered D
{Î± : Type u} {Î² : Type v} [Setoid Î±] [TopologicalSpace Î±] {F : Î² â†’ Î±} (hF : DenseRange F) : DenseRange (Quotient.Mk âˆ˜ F)
{Î± : Type u} [MetricSpace Î±] (x : â„• â†’ Î±) (h : DenseRange x) : Isometry (Kuratowski_Embedding.Embedding_of_Subset x)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B : Î±} (ha : 0 â‰¤ A) (hb : 0 < B) : 0 < A + B
{Î± : Type u} [OrderedSemiring Î±] {A B C D : Î±} [has_exists_Add_of_LE Î±] (hba : B < A) (hdc : D < C) : A â€¢ D + B â€¢ C < A â€¢ C + B â€¢ D
{Î± : Type u} [SemilatticeInf Î±] [Nonempty Î±] {S : set Î±} (hs : S.Finite) : BddBelow S
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} : IsMax_chain r (MaxChain r)
{P : Polynomial â„¤} (hp : P._primitive) : Irreducible P â†” Irreducible (Polynomial.Map (Int.cast_Ring_hom â„š) P)
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {A B : Î±} (P : Î± â†’ Prop) (l : List Î±) (h : List.chain r A l) (hb : (A :: l).Last _ = B) (carries : âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ P y â†’ P x) (final : P B) : P A
{D : set â„} (hD : Convex â„ D) (hDâ‚‚ : IsOpen D) {F : â„ â†’ â„} (hF' : DifferentiableOn â„ F D) (hF'' : âˆ€ (x : â„), x âˆˆ D â†’ deriv^[2] F x < 0) : strict_ConcaveOn â„ D F
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} {Î¹ : Type v} (hs : IsCompact S) (U : Î¹ â†’ set Î±) (hUo : âˆ€ (i : Î¹), IsOpen (U i)) (hsU : S âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (t : Finset Î¹), S âŠ† â‹ƒ (i : Î¹) (h : i âˆˆ t), U i
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {A B C : Î±} (h : âˆ€ (A B C : Î±), r A B â†’ r A C â†’ (âˆƒ (D : Î±), Relation.ReflGen r B D âˆ§ Relation.refl_Trans_gen r C D)) (hab : Relation.refl_Trans_gen r A B) (hac : Relation.refl_Trans_gen r A C) : Relation.Join (Relation.refl_Trans_gen r) B C
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x y : Î±} (h : Metric.Bounded S) (hx : x âˆˆ S) (hy : y âˆˆ S) : HasDist.dist x y â‰¤ Metric.diam S
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] {mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), AddCommMonoid (mâ‚' i)] [Î  (i : Î¹), module R (mâ‚' i)] (g : MultilinearMap R mâ‚' mâ‚‚) (F : Î  (i : Î¹), mâ‚ i â‰ƒâ‚—[R] mâ‚' i) : g.Comp_Linear_Map (Î» (i : Î¹), â†‘(F i)) = 0 â†” g = 0
{C : Type u} [CategoryTheory.Category C] {x : top} (F : top.Presheaf C x) : F._sheaf_Opens_LE_cover â†” F._sheaf_Pairwise_intersections
{Î¹ : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] (P : (x â†’ â„) â†’ Prop) (h01 : âˆ€ (S t : set x), IsClosed S â†’ IsClosed t â†’ Disjoint S t â†’ (âˆƒ (F : C(x, â„)), P â‡‘F âˆ§ set.Eq_on â‡‘F 0 S âˆ§ set.Eq_on â‡‘F 1 t âˆ§ âˆ€ (x : x), â‡‘F x âˆˆ set.icc 0 1)) (hs : IsClosed S) (U : Î¹ â†’ set x) (ho : âˆ€ (i : Î¹), IsOpen (U i)) (hF : locally_Finite U) (hU : S âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (F : BumpCovering Î¹ x S), (âˆ€ (i : Î¹), P â‡‘(â‡‘F i)) âˆ§ F._subordinate U
{Î± : Type u} [PseudoMetricSpace Î±] [CompleteSpace Î±] {S : â„• â†’ set Î±} (hs : âˆ€ (n : â„•), IsClosed (S n)) (h'S : âˆ€ (n : â„•), Metric.Bounded (S n)) (h : âˆ€ (N : â„•), (â‹‚ (n : â„•) (h : n â‰¤ N), S n).Nonempty) (h' : Filter.Tendsto (Î» (n : â„•), Metric.diam (S n)) Filter.at_top (nhds 0)) : (â‹‚ (n : â„•), S n).Nonempty
{R : Type x} [has_Mul R] [has_Add R] [Right_Distrib_class R] (A B C : R) : (A + B) * C = A * C + B * C
{F : Type u_3} [InnerProductSpace â„ F] (x y : F) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” HasInner.inner x y = 0
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [ZeroLt.PosMulMono Î±] (ha : A < 1) (hb : B â‰¤ 1) (A0 : 0 < A) : A * B < 1
{Î± : Type u} [HasSubset Î±] [HasSsubset Î±] [IsNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {A B : Î±} (hâ‚ : A âŠ† B) (hâ‚‚ : Â¬B âŠ† A) : A âŠ‚ B
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [CommMonoid m] {S : set Î±} {t : set Î²} {F : Î± â†’ m} {g : Î² â†’ m} (e : Î± â†’ Î²) (hEâ‚€ : set.bij_on e S t) (hEâ‚ : âˆ€ (x : Î±), x âˆˆ S â†’ F x = g (e x)) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) = finprod (Î» (j : Î²), finprod (Î» (h : j âˆˆ t), g j))
(P : â„•) [hp : Fact (Nat.Prime P)] : WittVector.IsPoly P (Î» (R : Type u_1) (_Rcr : CommRing R), â‡‘witt_Vector.frobenius)
(P : â„•) [P_Prime : Fact (Nat.Prime P)] {q r : â„š} (hqr : q + r â‰  0) (h : padic_val_rat P q â‰¤ padic_val_rat P r) : padic_val_rat P q â‰¤ padic_val_rat P (q + r)
{Î± : Type u_1} [has_LE Î±] {A : Î±áµ’áµˆ} : _top A â†’ _IsBot (â‡‘order_dual.of_dual A)
{m : Type u_4} [CommMonoid m] {Î¹ : Type u_1} [Subsingleton Î¹] {S : Finset Î¹} {F : Î¹ â†’ m} {B : m} (h : S.Prod (Î» (i : Î¹), F i) = B) (i : Î¹) (h : i âˆˆ S) : F i = B
{x : â„} (hx : 0 â‰¤ x) (hx' : x â‰¤ Real.Pi / 2) : 2 / Real.Pi * x â‰¤ Real.sin x
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (v : â†¥K) : â‡‘(Orthogonal_projection K) â†‘v = v
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {P : Î¹ â†’ P} (ha : AffineIndependent k P) (S : set Î¹) : AffineIndependent k (Î» (i : â†¥S), P â†‘i)
{Î´ : â„} {x : Type u} [PseudoMetricSpace x] {E : set x} {x : x} : x âˆˆ Metric.Thickening Î´ E â†” âˆƒ (z : x) (h : z âˆˆ E), HasDist.dist x z < Î´
{R : Type v} [Ring R] {L m N K : module R} {F : L âŸ¶ m} {g : m âŸ¶ N} (W : F â‰« g = 0) {h k : homology F g W âŸ¶ K} (W_1 : âˆ€ (x : â†¥(LinearMap.Ker g)), â‡‘h (â‡‘(CategoryTheory.Limits.CokernelÏ€ (image_to_Kernel F g W)) (â‡‘module.to_Kernel_Subobject x)) = â‡‘k (â‡‘(CategoryTheory.Limits.CokernelÏ€ (image_to_Kernel F g W)) (â‡‘module.to_Kernel_Subobject x))) : h = k
{P n : â„•} : padic_val_rat P â†‘n = â†‘(padic_val_Nat P n)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) : hb.rotation â†‘Real.Pi = Linear_Isometry_Equiv.Neg â„
{C : Type uâ‚} [CategoryTheory.Category C] {J : Type uâ‚‚} [CategoryTheory.Category J] [CategoryTheory.Limits.HasColimits_of_shape Jáµ’áµ– C] : CategoryTheory.Limits.HasLimits_of_shape J Cáµ’áµ–
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) {y : A} (h : (minpoly A x)._root y) : â‡‘(Algebra_Map A B) y = x
{h : Type u} {m : Type u_2} [TopologicalSpace h] [TopologicalSpace m] [ChartedSpace h m] {G : StructureGroupoid h} {e e' : LocalHomeomorph m h} (hE : e âˆˆ StructureGroupoid.MaximalAtlas m G) (hE' : e' âˆˆ StructureGroupoid.MaximalAtlas m G) : e.Symm.Trans e' âˆˆ G
{Î± : Type u_1} [has_LE Î±] {A : Î±} : IsMax A â†’ IsMin (â‡‘order_dual.to_dual A)
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] (F : C â¥¤ D) [F.initial] {E : Type u} [CategoryTheory.Category E] {G : D â¥¤ E} [CategoryTheory.Limits.HasLimit (F â‹™ G)] : CategoryTheory.Limits.HasLimit G
{Î± : Type u_1} [TopologicalSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] (m : MeasureTheory.OuterMeasure Î±) (S : set Î±) (hs : âˆ€ (x : Î±), x âˆˆ S â†’ (âˆƒ (u : set Î±) (h : u âˆˆ nhds_within x S), â‡‘m u = 0)) : â‡‘m S = 0
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : (âˆ€ â¦ƒC : â„â¦„, 0 < C â†’ Asymptotics._O_with C l F g) â†’ F =o[l] g
{Î± : Type u_1} {Î¹ : sort u_3} [conditionally_complete_LinearOrder Î±] {B : Î±} [Nonempty Î¹] {F : Î¹ â†’ Î±} (h : B < supr F) : âˆƒ (i : Î¹), B < F i
(ð•œ : Type u_1) {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace F] (F : E â†’ F) : IsOpen {x : E | AnalyticAt ð•œ F x}
{Î± : Type u} [DecidableEq Î±] [Fintype Î±] {P : Equiv.perm Î± â†’ Prop} (F : Equiv.perm Î±) : P 1 â†’ (âˆ€ (F : Equiv.perm Î±) (x y : Î±), x â‰  y â†’ P F â†’ P (Equiv.Swap x y * F)) â†’ P F
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [DenselyOrdered Î±] {A B : Î±} : IsPreconnected (set.icc A B)
(F : â„ â†’ â„) {A B : â„} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfI : F A = F B) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), IsLocalExtr F C
{G : Type u_1} [Group G] (h : Subgroup G) (hnc : NormalizerCondition G) (hmax : IsCoatom h) : h.Normal
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} {t : Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) {q : Type u_4} [CommMonoid q] {k : t.Localization_Map q} {A : Type u_5} [CommMonoid A] {U : Submonoid A} {R : Type u_6} [CommMonoid R] (j : U.Localization_Map R) {l : P â†’* A} (hl : âˆ€ (W : â†¥t), â‡‘l â†‘W âˆˆ U) (x : N) : â‡‘(k.Map hl j) (â‡‘(F.Map hy k) x) = â‡‘(F.Map _ j) x
{P : Type u_1} [Preorder P] (S t : Order.Pfilter P) (h : â†‘S = â†‘t) : S = t
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : Aâ»Â¹ â‰¤ B â†” Bâ»Â¹ â‰¤ A
{R : Type u} {m : Type v} {Î¹ : Type W} [Semiring R] [AddCommMonoid m] {module_m : module R m} (P : Submodule R m) (x : Î¹ â†’ â†¥P) (S : Finset Î¹) : â†‘(S.Sum (Î» (i : Î¹), x i)) = S.Sum (Î» (i : Î¹), â†‘(x i))
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] : (reflection K).Symm = reflection K
{m : Type u_1} {R : Type u_4} [non_unital_non_assoc_Semiring R] [set_like m R] [MulMemClass m R] {S : m} {A B : R} (ha : A âˆˆ S) (hb : B âˆˆ AddSubmonoid.Closure â†‘S) : A * B âˆˆ AddSubmonoid.Closure â†‘S
{Î± : Type u} {Î² : Type v} [PartialOrder Î±] [Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : GaloisConnection l u) (A : Î±) : (âˆƒ (B : Î²), A = u B) â†” A = u (l A)
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] {Î¹ : sort u_2} (P : Î¹ â†’ Submodule R m) {C : Î  (x : m), (x âˆˆ â¨† (i : Î¹), P i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : m) (h : x âˆˆ P i), C x _) (h0 : C 0 _) (HAdd : âˆ€ (x y : m) (hx : x âˆˆ â¨† (i : Î¹), P i) (hy : y âˆˆ â¨† (i : Î¹), P i), C x hx â†’ C y hy â†’ C (x + y) _) {x : m} (hx : x âˆˆ â¨† (i : Î¹), P i) : C x hx
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} (F : Î± â†’ Î² â†’ Î³) (P : Prop) [Decidable P] (A B : Î±) (C D : Î²) : F (Ite P A B) (Ite P C D) = Ite P (F A C) (F B D)
{x : Type u_1} [TopologicalSpace x] {x y : x} (Î³ : Path x y) : Continuous Î³.extend
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : strict_ConcaveOn ð•œ S F) {x y z : E} (hx : x âˆˆ S) (hy : y âˆˆ S) (hxy : x â‰  y) (hz : z âˆˆ IsOpen_Segment ð•œ x y) : LinearOrder.min (F x) (F y) < F z
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D â¥¤ C) [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.cartesian_IsClosed C] (h : âˆ€ (B : D) (A : C), (CategoryTheory.Exp A).obj (i.obj B) âˆˆ i.EssImage) : CategoryTheory.exponential_Ideal i
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : 0 â‰¤ A) (hb : 0 â‰¤ B) : 0 â‰¤ A + B
{Î± : Type u} {Î¹ : sort x} {F : Î¹ â†’ Î±} [h : Unique Î¹] : set.Range F = {F Inhabited.Default}
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] : 0 < Finite_dimensional.finrank K v â†” Nontrivial v
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ Multiset.Nat.antidiagonal n â†” x.fst + x.Snd = n
{Î± : Type u_1} {m : Type u_5} {N : Type u_6} [CommMonoid m] [CommMonoid N] {S : set Î±} (F : Î± â†’ m) (g : m â†’* N) (hs : S.Finite) : â‡‘g (finprod (Î» (j : Î±), finprod (Î» (h : j âˆˆ S), F j))) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), â‡‘g (F i)))
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : x = y â†” hb.oangle x y = 0
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (Î¸ : Real.Angle) : â‡‘Linear_Equiv.det (hb.rotation Î¸).to_Linear_Equiv = 1
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 P2 P3 : P) : P1 -áµ¥ P2 + (P2 -áµ¥ P3) = P1 -áµ¥ P3
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [AddZeroClass m] [CommMonoid N] {F g : Î± â†’â‚€ m} {h : Î± â†’ m â†’ N} (h_Zero : âˆ€ (A : Î±), A âˆˆ F.Support âˆª g.Support â†’ h A 0 = 1) (h_Add : âˆ€ (A : Î±), A âˆˆ F.Support âˆª g.Support â†’ âˆ€ (Bâ‚ Bâ‚‚ : m), h A (Bâ‚ + Bâ‚‚) = h A Bâ‚ * h A Bâ‚‚) : (F + g).Prod h = F.Prod h * g.Prod h
{Î¹ : Type u} (F : Î¹ â†’ Ordinal) : BddAbove (set.Range F)
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 P2 : P) : -(P1 -áµ¥ P2) = P2 -áµ¥ P1
{Î± : Type u_1} {m : Type u_4} [has_One m] {S : set Î±} {F : Î± â†’ m} {A : Î±} (h : S.Mul_indicator F A â‰  1) : A âˆˆ S
 : Cardinal.Ord âˆ˜ Cardinal.aleph' = Ordinal.enum_Ord {B : Ordinal | B.Card.Ord = B}
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {l : Filter Î±} {A : Î±} : _extr_Filter (â‡‘order_dual.to_dual âˆ˜ F) l A â†’ _extr_Filter F l A
{n D : â„•} (hnd : D âˆ£ n) : (n / D).Totient = (Finset.Filter (Î» (k : â„•), n.Gcd k = D) (Finset.Range n)).Card
{Î± : Type u_1} [cancel_CommMonoid_with_Zero Î±] {A B C : Î±} (hc : C â‰  0) : A * C âˆ£ B * C â†” A âˆ£ B
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î²'] [DecidableEq Î³] [DecidableEq Î´] {F : Î± â†’ Î² â†’ Î³} {S : Finset Î±} {t : Finset Î²} {g : Î³ â†’ Î´} {F' : Î± â†’ Î²' â†’ Î´} {g' : Î² â†’ Î²'} (h_Distrib : âˆ€ (A : Î±) (B : Î²), g (F A B) = F' A (g' B)) : Finset.image g (Finset.imageâ‚‚ F S t) = Finset.imageâ‚‚ F' S (Finset.image g' t)
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [_PartialOrder Î± r] : âˆƒ (S : Î± â†’ Î± â†’ Prop) (_x : _LinearOrder Î± S), r â‰¤ S
{S : Type u_1} [Semigroup S] {A B C : S} (hab : Commute A B) (hac : Commute A C) : Commute A (B * C)
(F : Circle_deg1_Lift) (hF : Continuous â‡‘F) : âˆƒ (x : â„), â‡‘F x = x + F.TranslationNumber
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S : set Î±} {A : Î±} (h : IsGreatest S A) : HasSup.Sup S = A
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) : Collinear k {P}
 : Cardinal.Mk â„‚ = Cardinal.Continuum
{K : Type u} [Field K] {S : set K} {P : K â†’ Prop} {x : K} (h : x âˆˆ Subfield.Closure S) (Hs : âˆ€ (x : K), x âˆˆ S â†’ P x) (h1 : P 1) (HAdd : âˆ€ (x y : K), P x â†’ P y â†’ P (x + y)) (Hneg : âˆ€ (x : K), P x â†’ P (-x)) (Hinv : âˆ€ (x : K), P x â†’ P xâ»Â¹) (HMul : âˆ€ (x y : K), P x â†’ P y â†’ P (x * y)) : P x
{Î± : Type u_1} [LinearOrder Î±] {S : Finset Î±} {k : â„•} (h : S.Card = k) {F : Fin k â†’ Î±} (hfs : âˆ€ (x : Fin k), F x âˆˆ S) (hmono : StrictMono F) : F = â‡‘(S.order_emb_of_Fin h)
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ âˆ…), F i)) = 0
{v : Type u_1} {Î± : Type u_2} [MulZeroOneClass Î±] [Nontrivial Î±] {A : Matrix v v Î±} (h : A._Adj_Matrix) [DecidableEq Î±] : SimpleGraph.Adj_Matrix Î± h.to_graph = A
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [Finite_dimensional ð•œ E] {K : Submodule ð•œ E} {n : â„•} (h_dim : Finite_dimensional.finrank ð•œ â†¥K + n = Finite_dimensional.finrank ð•œ E) : Finite_dimensional.finrank ð•œ â†¥Ká—® = n
 : PythagoreanTriple 0 0 0
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) (hF'_Mono : StrictMono_on (deriv F) (Interior D)) : strict_Convex_on â„ D F
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : i â‰¤ â‡‘Fin.cast_Succ j) : x.Ïƒ j.Succ â‰« x.Î´ (â‡‘Fin.cast_Succ i) = x.Î´ i â‰« x.Ïƒ j
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] (A B : Î±) : Filter.comap Coe (nhds_within B (set.Iio B)) = Filter.at_top
{R : Type u} [CommSemiring R] [Nontrivial R] {P : Fin 2 â†’ R} (h : _IsCoprime (P 0) (P 1)) : P â‰  0
{A B : â„} (m n : â„•) : âˆ« (x : â„) in A..B, Real.sin x ^ m * Real.cos x ^ (2 * n + 1) = âˆ« (u : â„) in Real.sin A..Real.sin B, u ^ m * (1 - u ^ 2) ^ n
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) (B : n â†’ Î±) : â‡‘(A.cramer) B = A.adjugate.Mul_vec B
(n : â„•) : (n + 1) * (n + 1).central_binom = 2 * (2 * n + 1) * n.central_binom
{Î¹ : Type u_1} {R : Type u_2} {Î± : Type u_3} {S : Type u_4} [set_like S R] [Monoid R] [AddMonoid Î¹] (A : Î¹ â†’ S) [set_like.graded_Monoid A] (FÎ¹ : Î± â†’ Î¹) (fA : Î  (A : Î±), â†¥(A (FÎ¹ A))) (l : List Î±) : â†‘(l.dprod FÎ¹ fA) = (List.Map (Î» (A : Î±), â†‘(fA A)) l).Prod
{C : Type u} [ð’ž : CategoryTheory.Category C] {x Y Z : C} (F : x âŸ¶ Y) (g : x âŸ¶ Z) [CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair Y Z)] [CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.ParallelPair (F â‰« CategoryTheory.Limits.Coprod.inl_) (g â‰« CategoryTheory.Limits.Coprod.inr_))] : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.Span F g)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x : v} (hx : x â‰  0) (Î¸ : Real.Angle) : hb.oangle (â‡‘(hb.rotation Î¸) x) x = -Î¸
{Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î²] [TopologicalSpace Î³] {Î¹ : Type u_2} {Îº : Type u_3} {F : Î¹ â†’ Î²} {g : Îº â†’ Î³} (hF : DenseRange F) (hg : DenseRange g) : DenseRange (Prod.Map F g)
{Î³ : Type W} [SemilatticeInf Î³] (A : Î³) {S : set Î³} : BddBelow (HasInsert.Insert A S) â†” BddBelow S
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” InnerProductGeometry.angle x y = Real.Pi / 2
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {Î¹ : Type u_1} (v : Î¹ â†’ m) (i : LinearIndependent R v) (W : set m) [Fintype â†¥W] (S : set.Range v â‰¤ â†‘(Submodule.Span R W)) : Cardinal.Mk Î¹ â‰¤ â†‘(Fintype.Card â†¥W)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.Preadditive_yoneda â‹™ (CategoryTheory.whiskering_Right Cáµ’áµ– AddCommGroup (Type v)).obj (CategoryTheory.Forget AddCommGroup) = CategoryTheory.yoneda
{Î± : Type u} [PseudoEmetricSpace Î±] {Î´ : â„} {S : set Î±} {x : Î±} : Emetric.Inf_edist x S â‰¤ Emetric.Inf_edist x (Metric.Thickening Î´ S) + Ennreal.of_Real Î´
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {Î¹ : Type u_3} {t : Finset Î¹} {F : Î¹ â†’ L} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Sum (Î» (i : Î¹), F i) âˆˆ S
{Î¹ : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : Î¹ â†’ E} (hF : Summable (Î» (i : Î¹), âˆ¥F iâˆ¥â‚Š)) : âˆ¥âˆ‘' (i : Î¹), F iâˆ¥â‚Š â‰¤ âˆ‘' (i : Î¹), âˆ¥F iâˆ¥â‚Š
{A B : Ordinal} (h : B â‰  0) : {o : Ordinal | A < B * Order.Succ o}.Nonempty
{Î± : Type u_1} [DecidableEq Î±] (P : Finset Î± â†’ Finset Î± â†’ Prop) (Symm : âˆ€ {A B : Finset Î±}, P A B â†’ P B A) (Empty_Right : âˆ€ {A : Finset Î±}, P A âˆ…) (singletons : âˆ€ {A B : Î±}, P {A} {B}) (union_of : âˆ€ {A B C : Finset Î±}, P A C â†’ P B C â†’ P (A âˆª B) C) (A B : Finset Î±) : P A B
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†ª Î²} {S : Finset Î±} : S.Nonempty â†’ (Finset.Map F S).Nonempty
{C : Type u} [CategoryTheory.Category C] (Ps : set (Cáµ’áµ– â¥¤ Type v)) (J : CategoryTheory.GrothendieckTopology C) (hJ : âˆ€ (P : Cáµ’áµ– â¥¤ Type v), P âˆˆ Ps â†’ CategoryTheory.Presieve._sheaf J P) : J â‰¤ CategoryTheory.sheaf.finest_topology Ps
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] {Î¹ : Type u_1} {F : Î¹ â†’ A} (hF : Function.Injective F) : AlgebraicIndependent R Coe â†’ AlgebraicIndependent R F
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (u : E) {v : E} (hv : HasInner.inner u v = 0) : v âˆˆ (Submodule.Span ð•œ {u})á—®
(n : â„•) : (Nat.fib n).IsCoprime (Nat.fib (n + 1))
(k : Type u_1) [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) [CharZero k] (h : S.Nonempty) : S.Sum (Î» (i : Î¹), Finset.centroid_weights k S i) = 1
{m : Type u_3} [Monoid m] [Preorder m] [CovariantClass m m (Function.Swap has_Mul.Mul) has_LE.LE] [CovariantClass m m has_Mul.Mul has_LE.LE] {lâ‚ lâ‚‚ : List m} (h : lâ‚ <+ lâ‚‚) (hâ‚ : âˆ€ (A : m), A âˆˆ lâ‚‚ â†’ 1 â‰¤ A) : lâ‚.Prod â‰¤ lâ‚‚.Prod
{Î± : Type u} [Group Î±] [Fintype Î±] {P : â„•} [hp : Fact (Nat.Prime P)] (h : Fintype.Card Î± = P) : _simple_Group Î±
(F : Bool â†’ Bool) (x : Bool) : F (F (F x)) = F x
{Î± : Type u} [PartialOrder Î±] {A B : Î±} : A â‰¤ B â†’ B â‰¤ A â†’ B = A
{G : Type u_1} [Group G] : NormalizerCondition G â†” âˆ€ (h : Subgroup G), h.Normalizer = h â†’ h = âŠ¤
{C : Type u} [CategoryTheory.Category C] (F : Cáµ’áµ– â¥¤ Type v) : (CategoryTheory.Category_of_Elements.to_CostructuredArrow F).Right_Op â‹™ CategoryTheory.Category_of_Elements.from_CostructuredArrow F = ðŸ­ F.Elements
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (C : Î±) : Metric.Bounded S â†” âˆƒ (r : â„), S âŠ† metric.IsClosed_ball C r
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [normed_CommRing ð•œ] [AddCommMonoid E] [AddCommMonoid F] [module ð•œ E] [module ð•œ F] (B : E â†’â‚—[ð•œ] F â†’â‚—[ð•œ] ð•œ) (S : set E) : IsClosed (B.polar S)
{Î± : Type u} [PseudoEmetricSpace Î±] {Î´ : â„} (Î´_Pos : 0 < Î´) (E : set Î±) : E âŠ† Metric.Thickening Î´ E
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) {r : â„} (hr : 0 < r) : InnerProductGeometry.angle (r â€¢ x) y = InnerProductGeometry.angle x y
{x Y : Type u} (F : x âŸ¶ Y) : CategoryTheory.Mono F â†” Function.Injective F
{Î± : Type u_1} {Î² : Type u_2} [has_Add Î±] [Preorder Î±] [Preorder Î²] {F g : Î² â†’ Î±} [CovariantClass Î± Î± has_Add.Add has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] (hF : StrictMono F) (hg : StrictMono g) : StrictMono (Î» (x : Î²), F x + g x)
{G : Type u} {x : G} {n : â„•} [Fintype G] [Group G] : x ^ n = 1 â†” x ^ n.Gcd (Fintype.Card G) = 1
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cáµ’áµ– â¥¤ A) : (âˆ€ (E : A), CategoryTheory.Presieve.IsSeparated J (P â‹™ CategoryTheory.coyoneda.obj (Opposite.Op E))) â†” âˆ€ â¦ƒx : Câ¦„ (S : CategoryTheory.Sieve x), S âˆˆ â‡‘J x â†’ âˆ€ (C : CategoryTheory.Limits.Cone (S.Arrows.Diagram.Op â‹™ P)), Subsingleton (C âŸ¶ P.Map_cone S.Arrows.Cocone.Op)
{R : Type u_1} [CommSemiring R] {x : R} : HasStar.Star x = x
{Î± : Type u_1} [PseudoEmetricSpace Î±] (C : Ennreal) (hC : C â‰  âŠ¤) {F : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (F n) (F (n + 1)) â‰¤ C / 2 ^ n) : Cauchy_Seq F
{R : Type u_1} [Ring R] [TopologicalSpace R] [nonarchimedean_Ring R] (U : IsOpen_Add_Subgroup R) (r : R) : âˆƒ (v : IsOpen_Add_Subgroup R), r â€¢ â†‘v âŠ† â†‘U
{F : â„ â†’ â„} (hF : Differentiable â„ F) (hF' : âˆ€ (x : â„), deriv F x â‰¤ 0) : Antitone F
{G : Type u_1} {h : Type u_2} [AddGroup G] [AddGroup h] [_Add_cyclic h] (F : G â†’+ h) (hF : F.Ker â‰¤ Add_Subgroup.Center G) (A B : G) : A + B = B + A
{m : Type u_1} [has_Add m] {r : m â†’ m â†’ Prop} {C : Add_Con m} (h : âˆ€ (x y : m), r x y â†’ Setoid.r x y) : Add_Con_gen r â‰¤ C
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (W : Î¹ â†’ k) (P : Î¹ â†’ P) {Sâ‚ Sâ‚‚ : Finset Î¹} (h : Sâ‚ âŠ† Sâ‚‚) : â‡‘(Sâ‚.weighted_vsub P) W = â‡‘(Sâ‚‚.weighted_vsub P) (â†‘Sâ‚.indicator W)
{Î± : Type u} [PseudoMetricSpace Î±] {F : Î± â†’ â„} {S : set Î±} {K : Nnreal} (hF : LipschitzOnWith K F S) : âˆƒ (g : Î± â†’ â„), LipschitzWith K g âˆ§ set.Eq_on F g S
{ð•œ : Type u_1} [NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {C : ð•œ} (hc : 1 < âˆ¥Câˆ¥) {R : â„} (hR : âˆ¥Câˆ¥ < R) {F : Subspace ð•œ E} (hFc : IsClosed â†‘F) (hF : âˆƒ (x : E), x âˆ‰ F) : âˆƒ (xâ‚€ : E), âˆ¥xâ‚€âˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ F â†’ 1 â‰¤ âˆ¥xâ‚€ - yâˆ¥
{P n : â„•} (hp : Nat.Prime P) (HDiv : P âˆ£ n) (R : Type u_1) [CommRing R] : â‡‘(Polynomial.expand R P) (Polynomial.cyclotomic n R) = Polynomial.cyclotomic (n * P) R
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y z : m} (hy : SameRay R x y) (hz : SameRay R x z) : SameRay R x (y + z)
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [DivisionRing K] {m : â„•} (m_LT_n : m < n) : (g.squash_gcf (n + 1)).S.nth m = g.S.nth m
{P : â„•} [hp : Fact (Nat.Prime P)] {n : â„•} (hn : 0 < n) : padic_val_Nat P n = (multiplicity P n).get _
{Î± : sort u_1} {Sâ‚ : Setoid Î±} : Function.Surjective Quotient.Mk'
{R : Type u_1} {m : Type u_3} [Monoid_with_Zero R] [has_Zero m] [MulAction_with_Zero R m] (h : IsSmulRegular m 0) : Subsingleton m
{m : Type u_1} [Semigroup m] (A : Stream m) (S : set (set m)) (sfin : S.Finite) (scov : Hindman.FP A âŠ† â‹ƒâ‚€S) : âˆƒ (C : set m) (h : C âˆˆ S) (B : Stream m), Hindman.FP B âŠ† C
(Î± : Type u_1) [CompleteLattice Î±] (k : Î±) : CompleteLattice.IsCompact_element k â†” âˆ€ (S : set Î±), S.Nonempty â†’ Directed_on has_LE.LE S â†’ k â‰¤ HasSup.Sup S â†’ (âˆƒ (x : Î±), x âˆˆ S âˆ§ k â‰¤ x)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_coproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.Normal_Epi_Category C] {x Y : C} (F : x âŸ¶ Y) (Z : C) (l : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofÎ¹ 0 _)) : CategoryTheory.Mono F
{Î± : Type u_1} [LinearOrder Î±] [PredOrder Î±] [_Pred_Archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ set.ioc m n â†’ r i (Order.Pred i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.ioc n m â†’ r (Order.Pred i) i) (hnm : n â‰  m) : Relation.TransGen r n m
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [NormedGroup G] [NormedSpace ð•œ G] {g : F â†’ G} {F : E â†’ F} {q : FormalMultilinearSeries ð•œ F G} {P : FormalMultilinearSeries ð•œ E F} {x : E} (hg : HasFpowerSeriesAt g q (F x)) (hF : HasFpowerSeriesAt F P x) : HasFpowerSeriesAt (g âˆ˜ F) (q.Comp P) x
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = EuclideanGeometry.angle P1 P3 P2) (hpi : EuclideanGeometry.angle P2 P1 P3 â‰  Real.Pi) : HasDist.dist P1 P2 = HasDist.dist P1 P3
{P : â„•} [Fact (Nat.Prime P)] {R : Type uâ‚} [CommSemiring R] [Char_P R P] {P : Type uâ‚ƒ} [CommSemiring P] [Char_P P P] [perfect_Ring P P] {F : P â†’+* R} (g : P â‰ƒ+* Ring.perfection R P) (hfg : â‡‘(Perfection.Lift P P R) F = â†‘g) : PerfectionMap P F
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î²] {F : Î± â†’ Î²} [TopologicalSpace Î±] (L : âˆ€ (x : Î±) (u : set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : set Î±) (h : t âˆˆ nhds x) (F : Î± â†’ Î²), Continuous_at F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (F y, F y) âˆˆ u)) : Continuous F
{q : â„•+} (i : â„•) : â†‘(LucasLehmer.S i) = LucasLehmer.x.Ï‰ ^ 2 ^ i + LucasLehmer.x.Ï‰B ^ 2 ^ i
{Î± : Type u} [PseudoMetricSpace Î±] (F : â„• â†’ Î±) {m n : â„•} (h : m â‰¤ n) : HasDist.dist (F m) (F n) â‰¤ (Finset.Ico m n).Sum (Î» (i : â„•), HasDist.dist (F i) (F (i + 1)))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {x : E} {n : WithTop â„•} {S : set E} {F g : E â†’ F} (hF : ContDiff_within_at ð•œ n F S x) (hg : ContDiff_within_at ð•œ n g S x) : ContDiff_within_at ð•œ n (Î» (x : E), F x + g x) S x
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î±'] [DecidableEq Î³] [DecidableEq Î´] {S : Finset Î±} {t : Finset Î²} {F : Î±' â†’ Î² â†’ Î³} {g : Î± â†’ Î±'} {F' : Î± â†’ Î² â†’ Î´} {g' : Î´ â†’ Î³} (h_Left_comm : âˆ€ (A : Î±) (B : Î²), F (g A) B = g' (F' A B)) : Finset.imageâ‚‚ F (Finset.image g S) t = Finset.image g' (Finset.imageâ‚‚ F' S t)
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] {F : Type W} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace ð•œ] [Finite_dimensional ð•œ E] [Finite_dimensional ð•œ F] : Nonempty (E â‰ƒL[ð•œ] F) â†” Finite_dimensional.finrank ð•œ E = Finite_dimensional.finrank ð•œ F
{ð•œ : Type u_1} {E : Type u} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] {S : set E} {x : E} (hx : x âˆˆ â‡‘(Convex_hull ð•œ) S) : âˆƒ (Î¹ : Type u) (_x : Fintype Î¹) (z : Î¹ â†’ E) (W : Î¹ â†’ ð•œ) (hss : set.Range z âŠ† S) (hai : AffineIndependent ð•œ z) (hw : âˆ€ (i : Î¹), 0 < W i), Finset.Univ.Sum (Î» (i : Î¹), W i) = 1 âˆ§ Finset.Univ.Sum (Î» (i : Î¹), W i â€¢ z i) = x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {x Y : C} [CategoryTheory.Simple Y] {F : x âŸ¶ Y} [CategoryTheory.Mono F] (W : F â‰  0) : CategoryTheory.IsIso F
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (Î¹ : Type u_1) [Unique Î¹] : Finite_dimensional.finrank K v = 1 â†” Nonempty (Basis Î¹ K v)
(x : Pgame) : (0 + x).Equiv x
{Î± : Type u} [PseudoEmetricSpace Î±] (Î´ : â„) {Eâ‚ Eâ‚‚ : set Î±} (h : Eâ‚ âŠ† Eâ‚‚) : Metric.Cthickening Î´ Eâ‚ âŠ† Metric.Cthickening Î´ Eâ‚‚
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Fintype Î¹] [DecidableEq Î¹] [Î  (i : Î¹), DecidableEq (Î± i)] [Î  (i : Î¹), LinearOrder (Î± i)] {P : (Î  (i : Î¹), Finset (Î± i)) â†’ Prop} (F : Î  (i : Î¹), Finset (Î± i)) (h0 : P (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), Finset (Î± i)) (i : Î¹) (x : Î± i), (âˆ€ (y : Î± i), y âˆˆ g i â†’ y < x) â†’ P g â†’ P (Function.update g i (HasInsert.Insert x (g i)))) : P F
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : MultilinearMap ð•œ E G) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘F mâˆ¥ â‰¤ C * Finset.Univ.Prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘F mâ‚ - â‡‘F mâ‚‚âˆ¥ â‰¤ C * â†‘(Fintype.Card Î¹) * LinearOrder.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (Fintype.Card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
{G : Type u} {x y : G} [CommMonoid G] (hx : _of_Fin_order x) (hy : _of_Fin_order y) : _of_Fin_order (x * y)
{Î± : Type u_1} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {S : Finset Î±} (hs : S âˆˆ ð’œ.shadow) : âˆƒ (t : Finset Î±) (h : t âˆˆ ð’œ), S âŠ† t
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (F : Î² â†’ Î± â†’ Î²) (B : Î²) (v : Vector Î± n) (x : Î±) : Vector.scanl F B (x::áµ¥v) = B::áµ¥Vector.scanl F (F B x) v
{ð•œ : Type u_1} [Field ð•œ] {m : Type u_2} [AddCommGroup m] [module ð•œ m] (C : ð•œ) (F : m â†’â‚—[ð•œ] m) : â‡‘LinearMap.det (C â€¢ F) = C ^ Finite_dimensional.finrank ð•œ m * â‡‘LinearMap.det F
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} (hx : âˆ¥xâˆ¥ = 1) (hy : âˆ¥yâˆ¥ = 1) : HasInner.inner x y < 1 â†” x â‰  y
(P : â„•) [hp : Fact (Nat.Prime P)] (z : â„¤) : padic_norm P â†‘z â‰¤ 1
{A : Type u_6} [CommRing A] [IsDomain A] {m : Submonoid A} (hM : m â‰¤ non_Zero_divisors A) : IsDomain (Localization m)
{Î± : Type u} [non_unital_non_assoc_Ring Î±] (A B C : Î±) : (A - B) * C = A * C - B * C
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {F : Filter Î±} {g : Filter Î²} {m : Î± â†’ Î²' â†’ Î³} {n : Î² â†’ Î²'} {m' : Î² â†’ Î± â†’ Î´} {n' : Î´ â†’ Î³} (h_Right_anticomm : âˆ€ (A : Î±) (B : Î²), m A (n B) = n' (m' B A)) : Filter.Mapâ‚‚ m F (Filter.Map n g) = Filter.Map n' (Filter.Mapâ‚‚ m' g F)
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {F : Î± â†’ Î²} (h : _Semiring_hom F) : _Ring_hom F
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R m) [Nontrivial R] : e.det â‰  0
{Î± : Type u_1} [Preorder Î±] [AddCommMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B : Î±} : A â‰¤ B â†’ A - B â‰¤ 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (x Y : C) [CategoryTheory.Limits.HasBinaryProduct x Y] : CategoryTheory.Limits.HasBinaryBiproduct x Y
{Î¹ : Type u_1} {Î± : Type u_3} [Preorder Î¹] [Preorder Î±] {l : Filter Î¹} {u : Î¹ â†’ Î±} (h : Monotone u) [l.Ne_IsBot] (hu : Filter.Tendsto u l Filter.at_top) : Filter.Tendsto u Filter.at_top Filter.at_top
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x : R) (hx : x â‰  0) : v.Int_Valuation_def x â‰  0
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] [h : Nontrivial v] : 0 < Finite_dimensional.finrank K v
{ð•œ : Type u_3} [_R_or_C ð•œ] {n m : â„•} (A B : Matrix (Fin n) (Fin m) ð•œ) (i j : Fin m) : HasInner.inner (A.transpose i) (B.transpose j) = A.Conj_transpose.Mul B i j
{F : Type u_8} {G : Type u_1} {h : Type u_2} [AddGroup G] [AddZeroClass h] [AddMonoid_hom_class F G h] (F : F) : Function.Injective â‡‘F â†” âˆ€ (A : G), â‡‘F A = 0 â†’ A = 0
{G : Type u_6} {h : Type u_7} {F : Type u_8} [Group G] [division_Monoid h] [Monoid_hom_class F G h] (F : F) (A B : G) : â‡‘F (A / B) = â‡‘F A / â‡‘F B
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} {t : Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) {q : Type u_4} [CommMonoid q] {k : t.Localization_Map q} {A : Type u_5} [CommMonoid A] {U : Submonoid A} {R : Type u_6} [CommMonoid R] (j : U.Localization_Map R) {l : P â†’* A} (hl : âˆ€ (W : â†¥t), â‡‘l â†‘W âˆˆ U) : (k.Map hl j).Comp (F.Map hy k) = F.Map _ j
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] {r : â„} (hr : 0 < r) (x : E) : x +áµ¥ r â€¢ Metric.Ball 0 1 = Metric.Ball x r
{Î± : Type u_1} {G : Type u_4} {S : set Î±} [subtraction_CommMonoid G] (F g : Î± â†’ G) (hs : S.Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i - g i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) - finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), g i))
{Î´ : Type u_1} {Îº : Î´ â†’ Type u_2} [Î  (D : Î´), TopologicalSpace (Îº D)] : Filter.Coprod (Î» (D : Î´), Filter.cocompact (Îº D)) = Filter.cocompact (Î  (D : Î´), Îº D)
{R : Type u_1} [NormedRing R] [CompleteSpace R] : IsOpen_Embedding Coe
(v : Prime_Multiset) : v.Prod.factor_Multiset = v
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] : IsOpen_Map Prod.Snd
{Î± : Type u_1} {Î³ : Type u_3} {Î¹ : Type u_2} {P : Î¹ â†’ Prop} {S : Î¹ â†’ set Î±} {F : Filter Î±} (hF : F.has_Basis P S) {Î² : Î¹ â†’ Type u_4} {pg : Î  (i : Î¹), Î² i â†’ Prop} {sg : Î  (i : Î¹), Î² i â†’ set Î³} {g : set Î± â†’ Filter Î³} (hg : âˆ€ (i : Î¹), (g (S i)).has_Basis (pg i) (sg i)) (gm : Monotone g) : (F.Lift g).has_Basis (Î» (i : Î£ (i : Î¹), Î² i), P i.fst âˆ§ pg i.fst i.Snd) (Î» (i : Î£ (i : Î¹), Î² i), sg i.fst i.Snd)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) {r : â„} (hr : 0 â‰¤ r) : hb.oangle (r â€¢ x) x = 0
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : Collinear k S â†” âˆƒ (Pâ‚€ : P) (v : v), âˆ€ (P : P), P âˆˆ S â†’ (âˆƒ (r : k), P = r â€¢ v +áµ¥ Pâ‚€)
{Î± : Type u_1} {S : Finset Î±} {g : Î± â†’ â„•} (hS : âˆ€ (x : Î±), x âˆˆ S â†’ g x â‰  0) : (S.Prod g).factorization = S.Sum (Î» (x : Î±), (g x).factorization)
{m : Type u_1} [has_Add m] (r : m â†’ m â†’ Prop) : Add_Con_gen â‡‘(Add_Con_gen r) = Add_Con_gen r
{E : Type u_3} [semi_NormedGroup E] (g h : E) : âˆ¥g + hâˆ¥ â‰¤ âˆ¥gâˆ¥ + âˆ¥hâˆ¥
{R : Type u1} [CommSemiring R] {m : Type u2} [AddCommMonoid m] [module R m] (m : m) : â‡‘(exterior_Algebra.Î¹ R) m * â‡‘(exterior_Algebra.Î¹ R) m = 0
{F : Type u_1} [NormedGroup F] [NormedSpace â„ F] {F : â„ â†’ F} (K : set F) : {x : â„ | Differentiable_within_at â„ F (set.ici x) x âˆ§ deriv_within F (set.ici x) x âˆˆ K} âŠ† Right_deriv_Measurable_aux.D F K
(m n k : â„•) : (m + n).choose k = (Finset.Nat.antidiagonal k).Sum (Î» (ij : â„• Ã— â„•), m.choose ij.fst * n.choose ij.Snd)
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), Group (Gs i)] (tfGs : âˆ€ (i : Î·), Monoid._torsion_free (Gs i)) : Monoid._torsion_free (Î  (i : Î·), Gs i)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] : (reflection K).Trans (reflection K) = Linear_Isometry_Equiv.refl ð•œ E
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [NormedGroup G] [NormedSpace ð•œ G] {n : â„•} (q : FormalMultilinearSeries ð•œ F G) (P : FormalMultilinearSeries ð•œ E F) (C : Composition n) : âˆ¥q.Comp_along_Composition P Câˆ¥ â‰¤ âˆ¥q C.lengthâˆ¥ * Finset.Univ.Prod (Î» (i : Fin C.length), âˆ¥P (C.blocks_fun i)âˆ¥)
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] (B : Basis Î¹ R m) (F : m â†’ Î¹ â†’ R) (HAdd : âˆ€ (x y : m), F (x + y) = F x + F y) (hsmul : âˆ€ (C : R) (x : m), F (C â€¢ x) = C â€¢ F x) (F_Eq : âˆ€ (i : Î¹), F (â‡‘B i) = â‡‘(Finsupp.single i 1)) (x : m) (i : Î¹) : â‡‘(â‡‘(B.repr) x) i = F x i
{K : Type u_1} [Linear_ordered_Field K] {C : ContinuedFraction K} : â†‘C.convergents = â†‘C.convergents'
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {Î¹ : Type u_6} [DecidableEq Î¹] {mâ‚‚ : Type u_7} [AddCommMonoid mâ‚‚] [module R mâ‚‚] (F : AlternatingMap R m N Î¹) (g : mâ‚‚ â‰ƒâ‚—[R] m) : F.Comp_Linear_Map â†‘g = 0 â†” F = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {v : v} (Pâ‚ Pâ‚‚ : P) (hv : v â‰  0) (r : â„) : HasDist.dist (r â€¢ v +áµ¥ Pâ‚) Pâ‚‚ = HasDist.dist Pâ‚ Pâ‚‚ â†” r = 0 âˆ¨ r = (-2) * HasInner.inner v (Pâ‚ -áµ¥ Pâ‚‚) / HasInner.inner v v
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A : Î±} : A < 1 â†’ 1 < Aâ»Â¹
(R : Type u_1) [CommRing R] {n : â„•} (hn : 2 â‰¤ n) : (Polynomial.cyclotomic n R).Coeff 0 = 1
{Î± : Type u} [EmetricSpace Î±] : uniform_Embedding TopologicalSpace.Nonempty_Compacts.to_Closeds
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [_fraction_Ring R K] (v : IsDedekindDomain.height_One_Spectrum R) (r : R) : â‡‘(v.Valuation) (â‡‘(Algebra_Map R K) r) â‰¤ 1
{x : top} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] (F : top.Presheaf C x) : F._sheaf â†” F._sheaf_Pairwise_intersections
{Î± : Type u_1} (m : MeasureTheory.OuterMeasure Î±) {S : â„• â†’ set Î±} (h_Mono : âˆ€ (n : â„•), S n âŠ† S (n + 1)) (h0 : âˆ‘' (k : â„•), â‡‘m (S (k + 1)  S k) â‰  âŠ¤) : â‡‘m (â‹ƒ (n : â„•), S n) = â¨† (n : â„•), â‡‘m (S n)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {v W : E} (h : HasInner.inner v W = 0) : âˆ¥W - vâˆ¥ = âˆ¥W + vâˆ¥
{Î± : Type u_1} [CompleteLattice Î±] {P q : Prop} {S : P â†’ q â†’ Î±} : (â¨† (hâ‚ : P) (hâ‚‚ : q), S hâ‚ hâ‚‚) = â¨† (h : P âˆ§ q), S _ _
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle y z + hb.oangle x y = hb.oangle x z
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [subtraction_Monoid Î²] (F : Î± â†’+ Î²) (g h : Î±) : â‡‘F (g - h) = â‡‘F g - â‡‘F h
{R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} {Î¹' : Type u_5} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (S : Finset Î¹) (t : Finset Î¹') (ws : Î¹ â†’ R) (zs : Î¹ â†’ E) (wt : Î¹' â†’ R) (zt : Î¹' â†’ E) (hws : S.Sum (Î» (i : Î¹), ws i) = 1) (hwt : t.Sum (Î» (i : Î¹'), wt i) = 1) (A B : R) (hab : A + B = 1) : A â€¢ S.Center_mass ws zs + B â€¢ t.Center_mass wt zt = (Finset.Map Function.Embedding.inl_ S âˆª Finset.Map Function.Embedding.inr_ t).Center_mass (Sum.elim (Î» (i : Î¹), A * ws i) (Î» (j : Î¹'), B * wt j)) (Sum.elim zs zt)
{R : Type u_1} [non_assoc_Semiring R] (F : â„• â†’+* R) : F = Nat.cast_Ring_hom R
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) {r : â„} (hr : r < 0) : hb.oangle (r â€¢ x) y = hb.oangle (-x) y
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hderiv : âˆ€ (x : â„), x âˆˆ set.Interval A B â†’ Differentiable_at â„ F x) (hint : IntervalIntegrable (deriv F) MeasureTheory.MeasureSpace.Volume A B) : âˆ« (y : â„) in A..B, deriv F y = F B - F A
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [Nonempty Î±] (h : âˆ€ (C : set Î±), IsChain r C â†’ C.Nonempty â†’ (âˆƒ (ub : Î±), âˆ€ (A : Î±), A âˆˆ C â†’ r A ub)) (Trans : âˆ€ {A B C : Î±}, r A B â†’ r B C â†’ r A C) : âˆƒ (m : Î±), âˆ€ (A : Î±), r m A â†’ r A m
{Î± : Type u_1} (A : Î±) (S : set Î±) [MeasurableSpace Î±] (hs : Measurable_set S) : â‡‘((Pmf.pure A).to_measure) S = Ite (A âˆˆ S) 1 0
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {Sâ‚ Sâ‚‚ : Submodule K v} [Finite_dimensional K â†¥Sâ‚‚] (hle : Sâ‚ â‰¤ Sâ‚‚) (hD : Finite_dimensional.finrank K â†¥Sâ‚ = Finite_dimensional.finrank K â†¥Sâ‚‚) : Sâ‚ = Sâ‚‚
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : ConcaveOn ð•œ S F) {x y z : E} (hx : x âˆˆ S) (hy : y âˆˆ S) (hz : z âˆˆ Segment ð•œ x y) : LinearOrder.min (F x) (F y) â‰¤ F z
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} (hs : Metric.Bounded S) (ht : Metric.Bounded t) : Metric.Bounded (S âˆª t)
{Î± : Type u} {Î² : Type v} {F : Type u_1} [non_assoc_Semiring Î±] [non_assoc_Semiring Î²] [Add_hom_class F Î± Î²] (F : F) (A : Î±) : â‡‘F (bit0 A) = bit0 (â‡‘F A)
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {F' : F} {x : ð•œ} {S t u : set ð•œ} (hu : u âˆˆ nhds x) (h : S âˆ© u = t âˆ© u) : HasDerivWithinAt F F' S x â†’ HasDerivWithinAt F F' t x
{Î± : Type u_1} [PseudoMetricSpace Î±] {F : â„• â†’ Î±} (D : â„• â†’ â„) (hF : âˆ€ (n : â„•), HasDist.dist (F n) (F n.Succ) â‰¤ D n) (hD : Summable D) : Cauchy_Seq F
 : Â¬BddAbove {P : â„• | Nat.Prime P}
{C : Type (max v u)} [CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {D : Type W} [CategoryTheory.Category D] {K : Type (max v u)} [CategoryTheory.SmallCategory K] [CategoryTheory.Limits.HasLimits_of_shape K D] (F : K â¥¤ CategoryTheory.sheaf J D) (E : CategoryTheory.Limits.Cone (F â‹™ CategoryTheory.sheaf_to_presheaf J D)) (hE : CategoryTheory.Limits.IsLimit E) : CategoryTheory.Presheaf.IsSheaf J E.x
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] (F : â„• â†’ R) (g : â„• â†’ m) (n : â„•) : (Finset.Range n).Sum (Î» (i : â„•), F i â€¢ g i) = F (n - 1) â€¢ (Finset.Range n).Sum (Î» (i : â„•), g i) - (Finset.Range (n - 1)).Sum (Î» (i : â„•), (F (i + 1) - F i) â€¢ (Finset.Range (i + 1)).Sum (Î» (i : â„•), g i))
{B : Type u_3} {S : B} {m : Type u_1} [AddCommMonoid m] [set_like B m] [Add_Submonoid_class B m] (m : Multiset m) (hm : âˆ€ (A : m), A âˆˆ m â†’ A âˆˆ S) : m.Sum âˆˆ S
{ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedGroup G] [NormedSpace ð•œ G] {F : ð•œ â†’ G} {S : set ð•œ} {x y : ð•œ} {C : â„} (hF : DifferentiableOn ð•œ F S) (bound : âˆ€ (x : ð•œ), x âˆˆ S â†’ âˆ¥deriv_within F S xâˆ¥ â‰¤ C) (hs : Convex â„ S) (xs : x âˆˆ S) (ys : y âˆˆ S) : âˆ¥F y - F xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{Î¹ : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {ca cb : E} {la la' lb lb' : Filter â„} {LT : Filter Î¹} {A B : â„} {ua ub va vb : Î¹ â†’ â„} [IntervalIntegral.FTC_Filter A la la'] [IntervalIntegral.FTC_Filter B lb lb'] (hab : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F la' MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F lb' MeasureTheory.MeasureSpace.Volume) (ha_lim : Filter.Tendsto F (la' âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb_lim : Filter.Tendsto F (lb' âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) (hua : Filter.Tendsto ua LT la) (hva : Filter.Tendsto va LT la) (hub : Filter.Tendsto ub LT lb) (hvb : Filter.Tendsto vb LT lb) : (Î» (t : Î¹), ((âˆ« (x : â„) in va t..vb t, F x) - âˆ« (x : â„) in ua t..ub t, F x) - ((vb t - ub t) â€¢ cb - (va t - ua t) â€¢ ca)) =o[LT] Î» (t : Î¹), âˆ¥va t - ua tâˆ¥ + âˆ¥vb t - ub tâˆ¥
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [TopologicalSpace Î±] [UniformSpace Î²] (F : C(Î±, Î²)) {Î¹ : Type uâ‚ƒ} {P : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} : Filter.Tendsto F P (nhds F) â†” âˆ€ (K : set Î±), IsCompact K â†’ TendstoUniformlyOn (Î» (i : Î¹) (A : Î±), â‡‘(F i) A) â‡‘F P K
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (Fâ‚ Fâ‚‚ : CategoryTheory.Mono_over x â¥¤ CategoryTheory.Mono_over Y) (h : Fâ‚ â‰… Fâ‚‚) : CategoryTheory.Subobject.lower Fâ‚ = CategoryTheory.Subobject.lower Fâ‚‚
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [_R_or_C ð•‚] [NormedRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] : HasStrictFderivAt (Exp ð•‚) 1 0
{Î± : Type u_1} [TopologicalSpace Î±] [t1_Space Î±] (x : Î±) [hx : (nhds_within x {x}á¶œ).Ne_IsBot] {S : set Î±} (hs : S âˆˆ nhds x) : S.Infinite
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] {Bâ‚ Bâ‚‚ : Basis Î¹ R m} (h : âˆ€ (i : Î¹), â‡‘Bâ‚ i = â‡‘Bâ‚‚ i) : Bâ‚ = Bâ‚‚
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚} [CategoryTheory.Category K] (e : J â‰Œ K) [CategoryTheory.IsConnected J] : CategoryTheory.IsConnected K
{E : Type u_2} {ð•œ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] {S : set E} (hs : Convex ð•œ S) {A B : ð•œ} (ha : 0 â‰¤ A) (hb : 0 < B) (hab : A + B = 1) : A â€¢ S + B â€¢ Interior S âŠ† Interior S
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A : Î±} : Aâ»Â¹ < 1 â†’ 1 < A
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] (F : â„‚ â†’ E) (z W : â„‚) (S : set â„‚) (hs : S.countable) (Hc : Continuous_on F (set.Interval z.re W.re Ã—â„‚ set.Interval z.im W.im)) (hD : âˆ€ (x : â„‚), x âˆˆ set.Ioo (LinearOrder.min z.re W.re) (LinearOrder.max z.re W.re) Ã—â„‚ set.Ioo (LinearOrder.min z.im W.im) (LinearOrder.max z.im W.im)  S â†’ Differentiable_at â„‚ F x) : (((âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(W.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(W.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(z.re) + â†‘y * Complex.i) = 0
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} : CategoryTheory.Presieve._sheaf âŠ¥ P
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {Fâ‚ Fâ‚‚ : D â¥¤ C} [âˆ€ (x Y : C), Subsingleton (x âŸ¶ Y)] (hC : CategoryTheory.Skeletal C) (hF : Fâ‚ â‰… Fâ‚‚) : Fâ‚ = Fâ‚‚
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} : IsExtrOn (â‡‘order_dual.to_dual âˆ˜ F) S A â†’ IsExtrOn F S A
{P : â„•} [Fact (Nat.Prime P)] : padic_norm_e 1 = 1
{Î¹ : Type u} (S : Finset Î¹) (W z : Î¹ â†’ Nnreal) (hw' : S.Sum (Î» (i : Î¹), W i) = 1) {P : â„} (hp : 1 â‰¤ P) : S.Sum (Î» (i : Î¹), W i * z i) â‰¤ S.Sum (Î» (i : Î¹), W i * z i ^ P) ^ (1 / P)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} : StrictMono_on F S â†’ StrictAntiOn (F âˆ˜ â‡‘order_dual.of_dual) S
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [TopologicalSpace Î²] (F : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (S : set Î±) {C : set Î²} (hcâ‚ : IsCompact C) (hcâ‚‚ : âˆƒ (v : set Ï„) (h : v âˆˆ F), Closure (set.image2 Ï• v S) âŠ† C) {n : set Î²} (hnâ‚ : IsOpen n) (hnâ‚‚ : OmegaLimit F Ï• S âŠ† n) : âˆƒ (u : set Ï„) (h : u âˆˆ F), Closure (set.image2 Ï• u S) âŠ† n
{G : Type u_1} [Group G] [hG : Group.IsNilpotent G] : Nat.Find _ = Group.nilpotency_class G
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} {S t : set Î±} {r : Ennreal} (h : x âˆˆ S) (h : Emetric.Hausdorff_edist S t < r) : âˆƒ (y : Î±) (h : y âˆˆ t), HasEdist.edist x y < r
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [IsSymm Î± r] {A B : Î±} : r A B â†” r B A
{Î± : Type u} [TopologicalSpace Î±] [t2_Space Î±] {Î¹ : Type u_1} [Nonempty Î¹] {v : Î¹ â†’ set Î±} (hV : Directed Superset v) (hV_cpct : âˆ€ (i : Î¹), IsCompact (v i)) {U : set Î±} (hU : âˆ€ (x : Î±), (x âˆˆ â‹‚ (i : Î¹), v i) â†’ U âˆˆ nhds x) : âˆƒ (i : Î¹), v i âŠ† U
{Î± : Type u} [Infinite Î±] {S : set Î±} (hF : S.Finite) : Sá¶œ âˆˆ Filter.hyperfilter Î±
{R : Type u_1} {Râ‚‚ : Type u_3} {m : Type u_9} {mâ‚‚ : Type u_12} [Semiring R] [Semiring Râ‚‚] [AddCommMonoid m] [AddCommMonoid mâ‚‚] [module R m] [module Râ‚‚ mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {F : m â†’â‚›â‚—[Ï„â‚â‚‚] mâ‚‚} (h : âˆ€ (u v : â†¥(F.Ker) â†’â‚—[R] m), F.Comp u = F.Comp v â†’ u = v) : F.Ker = âŠ¥
{R : Type u_1} {S : Type u_2} {m : Type u_3} {A : R} {S : S} [Monoid S] [HasScalar R m] [HasScalar R S] [MulAction S m] [IsScalarTower R S m] (h : A â€¢ S = 1) : IsSmulRegular m S
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A âˆˆ t) (ht : t.Nonempty) (hb : t.Card â€¢ B â‰¤ S.Sum (Î» (x : Î±), W x)) : âˆƒ (y : Î²) (h : y âˆˆ t), B â‰¤ (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x)
{Î± : Type u} [PartialOrder Î±] [OrderBot Î±] {A : Î±} : _IsBot A â†’ A = âŠ¥
 : Filter.cofinite = Filter.at_top
{Î± : Type u_1} [Linear_ordered_AddCommGroup Î±] {x dx y dy : Î±} (h : dy < dx) (hx : 0 < dx) : Nonempty â†¥(set.Ico x (x + dx)  set.Ico y (y + dy))
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} (ha : A â‰  0) : Char.quadratic_Char F A = -1 â†” Â¬Char.quadratic_Char F A = 1
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î±] [Fintype Î±] [AddCommMonoid Î²] {Î´ : Î± â†’ Type u_3} {t : Î  (A : Î±), Finset (Î´ A)} (F : (Î  (A : Î±), A âˆˆ Finset.Univ â†’ Î´ A) â†’ Î²) : (Finset.Univ.Pi t).Sum (Î» (x : Î  (A : Î±), A âˆˆ Finset.Univ â†’ Î´ A), F x) = (Fintype.Pi_Finset t).Sum (Î» (x : Î  (A : Î±), Î´ A), F (Î» (A : Î±) (_x : A âˆˆ Finset.Univ), x A))
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} (A : Î±) (B : Î²) (i : Î¹) : Filter.Map (Prod.Map (Î» (_x : Î±), B) Id) ((Filter.principal {A}).Coprod (Filter.principal {i})) = Filter.principal ({B} Ã—Ë¢ set.Univ)
{m : â„} (hm : 1 < m) (k : â„•) : Liouville.Liouville_number m = Liouville.Liouville_number_initial_terms m k + Liouville.Liouville_number_tail m k
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) : âˆ¥S.normed_Mkâˆ¥ â‰¤ 1
{k : Type u_1} {m : Type u_2} [OrderedSemiring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] {A : m} {C : k} (hc : 0 < C) : A < 0 â†’ C â€¢ A < 0
{Î± : Type u_2} [Monoid Î±] (m : Î±) : IsSquare m â†’ (âˆƒ (C : Î±), m = C ^ 2)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B : Î±} (ha : 1 â‰¤ A) (hb : 1 < B) : 1 < A * B
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x : R) : v.Int_Valuation_def x â‰¤ 1
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] : CategoryTheory.Limits.HasLimits Cáµ’áµ–
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (Sâ‚‚ : Finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) (B : P) : â‡‘((Finset.Map e Sâ‚‚).weighted_vsub_of_point P B) W = â‡‘(Sâ‚‚.weighted_vsub_of_point (P âˆ˜ â‡‘e) B) (W âˆ˜ â‡‘e)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Fintype Î¹] [DecidableEq Î¹] [Î  (i : Î¹), DecidableEq (Î± i)] [Î  (i : Î¹), LinearOrder (Î± i)] {P : (Î  (i : Î¹), Finset (Î± i)) â†’ Prop} (F : Î  (i : Î¹), Finset (Î± i)) (h0 : P (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), Finset (Î± i)) (i : Î¹) (x : Î± i), (âˆ€ (y : Î± i), y âˆˆ g i â†’ x < y) â†’ P g â†’ P (Function.update g i (HasInsert.Insert x (g i)))) : P F
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} {Î³ : Type u_3} [Î  (A : Î±), CommMonoid (Î² A)] (S : Finset Î³) (g : Î³ â†’ Î  (A : Î±), Î² A) : S.Prod (Î» (C : Î³), g C) = Î» (A : Î±), S.Prod (Î» (C : Î³), g C A)
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {vâ‚ vâ‚‚ : m} (hvâ‚ : vâ‚ â‰  0) (hvâ‚‚ : vâ‚‚ â‰  0) : Ray_of_Ne_Zero R vâ‚ hvâ‚ = Ray_of_Ne_Zero R vâ‚‚ hvâ‚‚ â†” SameRay R vâ‚ vâ‚‚
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] [DecidableEq Î±] (S : Finset Î±) (A : Î±) (B : Î± â†’ Î²) : S.Sum (Î» (x : Î±), Ite (x = A) (B x) 0) = Ite (A âˆˆ S) (B A) 0
{R : Type u_1} {m : Type u_2} {Î¹ : Type u_5} [CommRing R] [AddCommGroup m] [module R m] [Fintype Î¹] (B : Basis Î¹ R m) (F : Î¹ â†’â‚€ R) (i : Î¹) : â‡‘(â‡‘(Finsupp.Total Î¹ (module.dual R m) R B.coord) F) (â‡‘B i) = â‡‘F i
{R : Type u_1} (Câ‚ Câ‚‚ : R) : Cardinal.Mk (Quaternion_Algebra R Câ‚ Câ‚‚) = Cardinal.Mk R ^ 4
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {S : set E} {F g : E â†’ F} (hF : ContDiff_on ð•œ n F S) (hg : ContDiff_on ð•œ n g S) : ContDiff_on ð•œ n (Î» (x : E), F x - g x) S
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} (h_Mono : Monotone_on F S) (hs : S âˆˆ nhds A) (hfs_l : âˆ€ (B : Î²), B < F A â†’ (âˆƒ (C : Î±) (h : C âˆˆ S), F C âˆˆ set.Ioo B (F A))) (hfs_r : âˆ€ (B : Î²), B > F A â†’ (âˆƒ (C : Î±) (h : C âˆˆ S), F C âˆˆ set.Ioo (F A) B)) : Continuous_at F A
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R m) {v : Î¹ â†’ m} (hli : LinearIndependent R v) (hsp : Submodule.Span R (set.Range v) = âŠ¤) (i : Î¹) : â‡‘(e.det) v â€¢ (Basis.Mk hli hsp).coord i = e.det.to_MultilinearMap.to_Linear_Map v i
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {S : Finset Î±} (hs : S âˆˆ ð’œ.Up_shadow) : âˆƒ (t : Finset Î±) (h : t âˆˆ ð’œ), t âŠ† S
{Î² : Type u} {F g : Î² â†’ Type u} (Î± : Î  (j : Î²), F j âŸ¶ g j) (B : Î²) (x : âˆ Î» (j : Î²), F j) : CategoryTheory.Limits.Pi.Ï€ g B (CategoryTheory.Limits.Pi.Map Î± x) = Î± B (CategoryTheory.Limits.Pi.Ï€ F B x)
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {m : MeasurableSpace Î±} [TopologicalSpace Î²] [TopologicalSpace.pseudo_metrizable_Space Î²] [MeasurableSpace Î²] [BorelSpace Î²] (hF : MeasureTheory.strongly_Measurable F) : Measurable F
{Î± : Type u_1} {S : Multiset Î±} {x : Multiset Î± Ã— Multiset Î±} : x âˆˆ S.antidiagonal â†” x.fst + x.Snd = S
{R : Type u} [Semiring R] {m : Polynomial R â†’ Prop} {F : Polynomial R} (F0 : F.Nat_degree â‰  0) (h_C_Add : âˆ€ {A : R} {P : Polynomial R}, m P â†’ m (â‡‘Polynomial.C A + P)) (h_Add : âˆ€ {P q : Polynomial R}, m P â†’ m q â†’ m (P + q)) (h_monomial : âˆ€ {n : â„•} {A : R}, A â‰  0 â†’ n â‰  0 â†’ m (â‡‘(Polynomial.monomial n) A)) : m F
{R : Type u_1} {m : Type u_2} [AddCommMonoid m] [CommRing R] [Nontrivial R] : Algebra.Finite_Type R (AddMonoid_Algebra R m) â†” AddMonoid.fg m
{Î± : Type u_1} {Î² : Type u_2} [SemilatticeSup Î±] [OrderBot Î±] {P : Î± â†’ Prop} {Pbot : P âŠ¥} {Psup : âˆ€ â¦ƒx y : Î±â¦„, P x â†’ P y â†’ P (x âŠ” y)} (t : Finset Î²) (F : Î² â†’ {x // P x}) : â†‘(t.Sup F) = t.Sup (Î» (x : Î²), â†‘(F x))
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {vâ‚‚ : Type v'} [AddCommGroup vâ‚‚] [module K vâ‚‚] [Finite_dimensional K v] [Finite_dimensional K vâ‚‚] (Cond : Finite_dimensional.finrank K v = Finite_dimensional.finrank K vâ‚‚) : Nonempty (v â‰ƒâ‚—[K] vâ‚‚)
{F : â„• â†’ Nnreal} (hF : âˆ€ â¦ƒm n : â„•â¦„, 0 < m â†’ m â‰¤ n â†’ F n â‰¤ F m) : Summable (Î» (k : â„•), 2 ^ k * F (2 ^ k)) â†” Summable F
{F : Type u} [Field F] {n : â„•} (A : F) (hn : â†‘n â‰  0) (ha : A â‰  0) : (Polynomial.x ^ n - â‡‘Polynomial.C A).IsSeparable
{Î± : Type u_1} [Preorder Î±] {A B : Î±} (h : A â‰¤ B) : set.Iio A âŠ† set.Iio B
{P : â„•} (hp : Nat.Prime P) (n k : â„•) : multiplicity P n â‰¤ multiplicity P (n.choose k) + multiplicity P k
{m : Type u_1} [has_Add m] {C : Add_Con m} {C : C.Quotient â†’ Prop} (q : C.Quotient) (h : âˆ€ (x : m), C â†‘x) : C q
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [semi_NormedGroup Î²] (F : bounded_Continuous_Function Î± Î²) (C : Nnreal) : âˆ¥Fâˆ¥â‚Š â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘F xâˆ¥â‚Š â‰¤ C
{Î± : Type u} [AddGroup Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A : Î±} (h : 0 < A) : -A < A
{m : Type u_1} [MulOneClass m] (S : Submonoid m) {x y : m} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{m : Type u_3} [AddCommGroup m] {Râ‚ : Type u_4} [CommRing Râ‚] [module Râ‚ m] {Î¹ : Type u_6} [Fintype Î¹] [Invertible 2] (q : QuadraticForm Râ‚ m) (v : Basis Î¹ Râ‚ m) (hvâ‚‚ : (â‡‘QuadraticForm.Associated q)._Ortho â‡‘v) : q.Basis_repr v = QuadraticForm.weighted_Sum_squares Râ‚ (Î» (i : Î¹), â‡‘q (â‡‘v i))
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : F =o[l] g â†’ âˆ€ â¦ƒC : â„â¦„, 0 < C â†’ Asymptotics._O_with C l F g
{m : Type u_1} [has_Add m] {S : set m} {P : m â†’ m â†’ Prop} {x y : m} (hx : x âˆˆ Add_Subsemigroup.Closure S) (hy : y âˆˆ Add_Subsemigroup.Closure S) (Hs : âˆ€ (x : m), x âˆˆ S â†’ âˆ€ (y : m), y âˆˆ S â†’ P x y) (HMul_Left : âˆ€ (x y z : m), P x z â†’ P y z â†’ P (x + y) z) (HMul_Right : âˆ€ (x y z : m), P z x â†’ P z y â†’ P z (x + y)) : P x y
{x y : Pgame} (ox : x.Numeric) (oy : y.Numeric) : x â‰¤ y â†” (âˆ€ (i : x.Left_moves), x.move_Left i < y) âˆ§ âˆ€ (j : y.Right_moves), x < y.move_Right j
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P : P) : Function.Injective (HasVsub.vsub P)
{R : Type u_1} {m : Type u_2} {N : Type u_3} [has_Zero R] [has_Zero m] [has_Zero N] [HasScalar R m] [HasScalar R N] [NoZeroSmulDivisors R N] (F : m â†’ N) (hF : Function.Injective F) (h0 : F 0 = 0) (hs : âˆ€ (C : R) (x : m), F (C â€¢ x) = C â€¢ F x) : NoZeroSmulDivisors R m
(F F' : â„ â†’ â„) {A B : â„} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivAt F (F' x) x) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), F' C = (F B - F A) / (B - A)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (direction : Submodule k v) : â†‘(AffineSubspace.Mk' P direction).Nonempty
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] [_Pred_Archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.ioc n m â†’ r (Order.Pred i) i) (hmn : n < m) : Relation.TransGen r n m
(P : â„•) [hp : Fact (Nat.Prime P)] (n : â„•) {m : â„•} (hm : n â‰¤ m) : (truncated_witt_Vector.Zmod_Equiv_trunc P n).Symm.to_Ring_hom.Comp (truncated_witt_Vector.truncate hm) = (Zmod.cast_hom _ (Zmod (P ^ n))).Comp (truncated_witt_Vector.Zmod_Equiv_trunc P m).Symm.to_Ring_hom
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {F : Î³ â†’ Î±} (h : F â»Â¹' e.to_local_Equiv.Source = set.Univ) : Continuous F â†” Continuous (â‡‘e âˆ˜ F)
{n : â„•} : Nat.fib (n + 2) = Nat.fib n + Nat.fib (n + 1)
{Î± : Type u_1} {E : Type u_3} [TopologicalSpace Î±] [CompactSpace Î±] [NormedGroup E] (F : C(Î±, E)) (x y : Î±) : HasDist.dist (â‡‘F x) (â‡‘F y) â‰¤ 2 * âˆ¥Fâˆ¥
{Î± : Type u} {Î² : Type v} [Semiring Î±] [Semiring Î²] {F : Î± â†’ Î²} (hF : _Semiring_hom F) : _Monoid_hom F
{v : Type u_4} [InnerProductSpace â„‚ v] (t : v â†’â‚—[â„‚] v) : InnerProductSpace.IsSelfAdjoint t â†” âˆ€ (v : v), â‡‘(Star_Ring_end â„‚) (HasInner.inner (â‡‘t v) v) = HasInner.inner (â‡‘t v) v
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Sâ‚ Sâ‚‚ : AffineSubspace k P} {P : P} (h : P âˆˆ Sâ‚ âŠ“ Sâ‚‚) : (Sâ‚ âŠ“ Sâ‚‚).direction = Sâ‚.direction âŠ“ Sâ‚‚.direction
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} (h : â†‘S.Nonempty) : â†‘(S.direction) = â†‘S -áµ¥ â†‘S
{Î± : sort u_1} {P : Î± â†’ Prop} (hp : âˆ€ (A : Î±), Â¬P A) : IsEmpty (Subtype P)
{F : Type} [Field F] (q : â„•) [hF : ExpChar F q] (F : Polynomial F) [irred : Irreducible F] : Polynomial.has_IsSeparable_contraction q F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {S : set E} {t : set F} {g : F â†’ G} {F : E â†’ F} (x : E) (hg : ContDiff_within_at ð•œ n g t (F x)) (hF : ContDiff_within_at ð•œ n F S x) (st : S âŠ† F â»Â¹' t) : ContDiff_within_at ð•œ n (g âˆ˜ F) S x
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} : Convex ð•œ S â†’ S.Ord_connected
(R : Type u) (m : Type v) (N : Type W) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [AddCommGroup N] [module R N] [module.free R N] : module.rank R (m Ã— N) = (module.rank R m).Lift + (module.rank R N).Lift
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) (Î¸ : Real.Angle) : â‡‘(hb.rotation Î¸) x = x â†” x = 0 âˆ¨ Î¸ = 0
{A : Type u_2} [NormedRing A] [normed_Algebra â„‚ A] [CompleteSpace A] (A : A) : Filter.at_top.limsup (Î» (n : â„•), â†‘âˆ¥A ^ nâˆ¥â‚Š ^ (1 / â†‘n)) â‰¤ spectral_radius â„‚ A
{R : Type u_1} [CommSemiring R] {A : Type u_2} [Semiring A] (P q : Algebra R A) (W : âˆ€ (r : R), â‡‘(Algebra_Map R A) r = â‡‘(Algebra_Map R A) r) : P = q
{G : Type u_1} [Group G] (h : Monoid.exponent_exists G) : Monoid._torsion G
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {C : â„} {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : Asymptotics._O_with C l F' g â†’ Asymptotics._O_with C l (Î» (x : Î±), -F' x) g
{m : Type u_1} [AddZeroClass m] (S : Add_Submonoid m) : 0 âˆˆ S
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [LinearOrder Î±] [order_IsClosed_topology Î±] [Nonempty Î±] [TopologicalSpace Î²] [has_Zero Î±] {F : Î² â†’ Î±} (hF : Continuous F) (h : has_IsCompact_Support F) : BddAbove (set.Range F)
{Î± : Type u_1} {S : set Î±} : âŠ¥._clique S â†’ S.Subsingleton
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {x : E} (hF : HasFderivAt F F' x) (v : E) {Î± : Type u_4} {C : Î± â†’ ð•œ} {l : Filter Î±} (hc : Filter.Tendsto (Î» (n : Î±), âˆ¥C nâˆ¥) l Filter.at_top) : Filter.Tendsto (Î» (n : Î±), C n â€¢ (F (x + (C n)â»Â¹ â€¢ v) - F x)) l (nhds (â‡‘F' v))
{Î± : Type u_1} [MeasurableSpace Î±] {mâ‚ mâ‚‚ : MeasureTheory.OuterMeasure Î±} {Op : Ennreal â†’ Ennreal} (h : âˆ€ (S : set Î±), â‡‘mâ‚ S = Op (â‡‘mâ‚‚ S)) (S : set Î±) : â‡‘(mâ‚.trim) S = Op (â‡‘(mâ‚‚.trim) S)
{R : Type u_2} {m : Type u_3} [AddCommGroup m] [Ring R] [module R m] [Invertible 2] (q : QuadraticForm R m) (hB : q.anisotropic) : (â‡‘QuadraticForm.Associated' q).nondegenerate
{m : Type u_2} [AddCommGroup m] {ð•œ : Type u_1} [Field ð•œ] [module ð•œ m] (F : m â‰ƒâ‚—[ð•œ] m) : â‡‘LinearMap.det â†‘(F.Symm) = (â‡‘LinearMap.det â†‘F)â»Â¹
{Î± : Type u_1} [PseudoEmetricSpace Î±] {Î´Seq : â„• â†’ â„} (Î´Seq_lim : Filter.Tendsto Î´Seq Filter.at_top (nhds 0)) (E : set Î±) : Filter.Tendsto (Î» (n : â„•), thickened_indicator_aux (Î´Seq n) E) Filter.at_top (nhds ((Closure E).indicator (Î» (x : Î±), 1)))
{Î± : Type u} [TopologicalSpace Î±] [t2_Space Î±] {x y : Î±} (h : x â‰  y) : âˆƒ (u v : set Î±), IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ u âˆ© v = âˆ…
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.Finite_Type R A â†” âˆƒ (n : â„•) (F : mv_Polynomial (Fin n) R â†’â‚[R] A), Function.Surjective â‡‘F
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 P : P} (h : P -áµ¥ P1 = P -áµ¥ P2) : P1 = P2
{Î± : Type u} [CommSemiring Î±] {P P' ps ps' : Î±} : P = P' â†’ ps = ps' â†’ P + ps = P' + ps'
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} {N : Type u_7} [AddCommMonoid m] [AddCommMonoid N] {F : Î± â†’ Î²} {S : Î± â†’â‚€ m} (h : Î² â†’ m â†’+ N) : (Finsupp.Map_IsDomain F S).Sum (Î» (B : Î²) (m : m), â‡‘(h B) m) = S.Sum (Î» (A : Î±) (m : m), â‡‘(h (F A)) m)
{A B k : â„•} (h_Ab_IsCoprime : A.IsCoprime B) (hka : k âˆ£ A) (hkb : k âˆ£ B) : k = 1
{Î± : Type u_1} [PseudoMetricSpace Î±] {Î´ : â„} {E : set Î±} (hE : IsCompact E) (hÎ´ : 0 â‰¤ Î´) : Metric.Cthickening Î´ E = â‹ƒ (x : Î±) (h : x âˆˆ E), metric.IsClosed_ball x Î´
{Î± : Type u_1} {ð’œ : Finset (Finset Î±)} {A : Finset Î±} {r : â„•} : A âˆˆ ð’œ.Slice r â†” A âˆˆ ð’œ âˆ§ A.Card = r
{k : Type u_1} {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype Î¹] {P : Î¹ â†’ P} (hi : AffineIndependent k P) {sm : Submodule k v} [Finite_dimensional k â†¥sm] (hle : Vector_Span k (set.Range P) â‰¤ sm) (hc : Fintype.Card Î¹ = Finite_dimensional.finrank k â†¥sm + 1) : Vector_Span k (set.Range P) = sm
{K : Type u_1} [Linear_ordered_Field K] {v : K} {n : â„•} [FloorRing K] {ifp_n : GeneralizedContinuedFraction.Int_fract_pair K} : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n â†’ v = GeneralizedContinuedFraction.Comp_exact_value ((GeneralizedContinuedFraction.of v).continuants_aux n) ((GeneralizedContinuedFraction.of v).continuants_aux (n + 1)) ifp_n.fr
{C : Type u} [CategoryTheory.Category C] {x Y : C} [CategoryTheory.Limits.HasZeroMorphisms C] (F : x âŸ¶ Y) [CategoryTheory.Limits.HasKernel F] {Z : C} (h : Y âŸ¶ Z) [CategoryTheory.Mono h] : CategoryTheory.Limits.Kernel_Subobject (F â‰« h) = CategoryTheory.Limits.Kernel_Subobject F
{m : Type u_1} [AddZeroClass m] {C D : Add_Con m} (h : C â‰¤ D) (x : C.Quotient) : â‡‘(C.Map D h) x = â‡‘(C.Lift D.Mk' _) x
{G : Type u_3} [Group G] (P : Subgroup G) : P.fg â†” âˆƒ (S : set G), Subgroup.Closure S = P âˆ§ S.Finite
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} [DecidableEq Î³] {F F' : Î± â†’ Î² â†’ Î³} {S : Finset Î±} {t : Finset Î²} (h : âˆ€ (A : Î±) (B : Î²), F A B = F' A B) : Finset.imageâ‚‚ F S t = Finset.imageâ‚‚ F' S t
{Î± : Type u_1} {Î² : Type u_2} {e : local_Equiv Î± Î²} {S : set Î±} {t : set Î²} : e._image S t â†’ e.Source âˆ© â‡‘e â»Â¹' t = e.Source âˆ© S
{ð•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [NormedGroup E] [NormedGroup Fâ‚—] [nondiscrete_NormedField ð•œ] [NormedSpace ð•œ E] [NormedSpace ð•œ Fâ‚—] {r : â„} (r_Pos : 0 < r) (C : â„) (F : E â†’â‚—[ð•œ] Fâ‚—) (h : âˆ€ (z : E), z âˆˆ Metric.Ball 0 r â†’ âˆ¥â‡‘F zâˆ¥ â‰¤ C) : âˆƒ (C : â„), âˆ€ (z : E), âˆ¥â‡‘F zâˆ¥ â‰¤ C * âˆ¥zâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [LinearOrder Î±] [TopologicalSpace Î³] {A B : Î±} {h : A â‰¤ B} [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] {F : Î³ â†’ â†¥(set.icc A B) â†’ Î²} {g : Î³ â†’ Î±} (hF : Continuous â†¿F) (hg : Continuous g) : Continuous (Î» (A_1 : Î³), set.icc_extend h (F A_1) (g A_1))
{G : Type u_1} [Group G] (h : Subgroup G) : h = âŠ¥ âˆ¨ Nontrivial â†¥h
{R : Type u_1} {G : Type u_4} [Group G] [MulAction G R] (g : G) : IsSmulRegular R g
{Î± : Type u} {Î² : Type v} [has_Add Î±] [has_Add Î²] {Î³ : Type u_1} [has_Add Î³] {F : Î± â†’ Î²} {g : Î² â†’ Î³} (hF : _Add_hom F) (hg : _Add_hom g) : _Add_hom (g âˆ˜ F)
{x : Type u_1} {Y : Type u_2} [PseudoEmetricSpace x] [PseudoEmetricSpace Y] {C : Nnreal} {F : x â†’ Y} : LipschitzWith C F â†’ HolderWith C 1 F
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) â‰  0) (i : Fin r) : ((Matrix.Pivot.List_transvec_col m).Prod.Mul m).Mul (Matrix.Pivot.List_transvec_row m).Prod (Sum.inl_ i) (Sum.inr_ ()) = 0
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] [_Pred_Archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.ioc n m â†’ r (Order.Pred i) i) (hmn : n â‰¤ m) : Relation.refl_Trans_gen r n m
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [AddCommMonoid Î²] {S : Finset Î³} {t : Î³ â†’ Finset Î±} {t' : Finset Î±} {S' : Î± â†’ Finset Î³} (h : âˆ€ (x : Î³) (y : Î±), x âˆˆ S âˆ§ y âˆˆ t x â†” x âˆˆ S' y âˆ§ y âˆˆ t') {F : Î³ â†’ Î± â†’ Î²} : S.Sum (Î» (x : Î³), (t x).Sum (Î» (y : Î±), F x y)) = t'.Sum (Î» (y : Î±), (S' y).Sum (Î» (x : Î³), F x y))
(C : Type u) [CategoryTheory.Category C] [âˆ€ {J : Type v} {x Y : C} {F : J â†’ (x âŸ¶ Y)}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallel_family F)] : CategoryTheory.Limits.HasWideCoequalizers C
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {F : Filter Î²} {u : Î² â†’ Î±} : (âˆƒ (B : Î±), âˆ€ (x : Î²), r (u x) B) â†’ Filter._bounded_under r F u
{Î± : Type u_1} [Field Î±] (E : LinearRecurrence Î±) : module.rank Î± â†¥(E.sol_Space) = â†‘(E.order)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : A â‰¤ 1) (hb : B â‰¤ 1) : A * B â‰¤ 1
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] {mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), AddCommMonoid (mâ‚' i)] [Î  (i : Î¹), module R (mâ‚' i)] {mâ‚'' : Î¹ â†’ Type u_2} [Î  (i : Î¹), AddCommMonoid (mâ‚'' i)] [Î  (i : Î¹), module R (mâ‚'' i)] (g : MultilinearMap R mâ‚'' mâ‚‚) (Fâ‚ : Î  (i : Î¹), mâ‚' i â†’â‚—[R] mâ‚'' i) (Fâ‚‚ : Î  (i : Î¹), mâ‚ i â†’â‚—[R] mâ‚' i) : (g.Comp_Linear_Map Fâ‚).Comp_Linear_Map Fâ‚‚ = g.Comp_Linear_Map (Î» (i : Î¹), (Fâ‚ i).Comp (Fâ‚‚ i))
(R : Type u_1) {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [_fraction_Ring R K] (P : â„•) [Char_P R P] : Char_P K P
(n : â„•) : iterated_deriv n (Exp_Neg_Inv_glue.F_aux 0) = Exp_Neg_Inv_glue.F_aux n
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_at F A) : HasStrictDerivAt (Î» (u : â„), âˆ« (x : â„) in u..B, F x) (-F A) A
{Î± : Type u} (P : Î± â†’ Prop) [Decidable_Pred P] (xs : List Î±) (h : âˆ€ (x : Î±), x âˆˆ xs â†’ Â¬P x) : List.split_on_P P xs = [xs]
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace E] [CompleteSpace â†¥K] (u v : E) : HasInner.inner â†‘(â‡‘(Orthogonal_projection K) u) v = HasInner.inner u â†‘(â‡‘(Orthogonal_projection K) v)
{x : Type v} [TopologicalSpace x] [LocallyCompactSpace x] [SigmaCompactSpace x] [t2_Space x] {Î¹ : x â†’ Type u} {P : Î  (x : x), Î¹ x â†’ Prop} {B : Î  (x : x), Î¹ x â†’ set x} (hB : âˆ€ (x : x), (nhds x).has_Basis (P x) (B x)) : âˆƒ (Î± : Type v) (C : Î± â†’ x) (r : Î  (A : Î±), Î¹ (C A)), (âˆ€ (A : Î±), P (C A) (r A)) âˆ§ (â‹ƒ (A : Î±), B (C A) (r A)) = set.Univ âˆ§ locally_Finite (Î» (A : Î±), B (C A) (r A))
{G : Type u_1} [Group G] {Î¹ : sort u_2} (S : Î¹ â†’ Subgroup G) {C : G â†’ Prop} {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : G), x âˆˆ S i â†’ C x) (h1 : C 1) (HMul : âˆ€ (x y : G), C x â†’ C y â†’ C (x * y)) : C x
{F : Type u_3} [InnerProductSpace â„ F] (x y : F) : HasInner.inner x y * HasInner.inner x y â‰¤ HasInner.inner x x * HasInner.inner y y
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hs : (S âˆ© Function.Support F).Finite) (ht : (t âˆ© Function.Support F).Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S âˆª t), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S âˆ© t), F i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ t), F i))
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] (F : â„‚ â†’ E) (F' : â„‚ â†’ (â„‚ â†’L[â„] E)) (z W : â„‚) (S : set â„‚) (hs : S.countable) (Hc : Continuous_on F (set.Interval z.re W.re Ã—â„‚ set.Interval z.im W.im)) (hD : âˆ€ (x : â„‚), x âˆˆ set.Ioo (LinearOrder.min z.re W.re) (LinearOrder.max z.re W.re) Ã—â„‚ set.Ioo (LinearOrder.min z.im W.im) (LinearOrder.max z.im W.im)  S â†’ HasFderivAt F (F' x) x) (Hi : MeasureTheory.IntegrableOn (Î» (z : â„‚), Complex.i â€¢ â‡‘(F' z) 1 - â‡‘(F' z) Complex.i) (set.Interval z.re W.re Ã—â„‚ set.Interval z.im W.im) MeasureTheory.MeasureSpace.Volume) : (((âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(W.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(W.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(z.re) + â†‘y * Complex.i) = âˆ« (x : â„) in z.re..W.re, âˆ« (y : â„) in z.im..W.im, Complex.i â€¢ â‡‘(F' (â†‘x + â†‘y * Complex.i)) 1 - â‡‘(F' (â†‘x + â†‘y * Complex.i)) Complex.i
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A : Î±} : Aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ A
{R : Type u_2} {m : Type u_3} [AddCommGroup m] [Ring R] [module R m] [Invertible 2] {q : QuadraticForm R m} (hBâ‚ : â‡‘QuadraticForm.Associated' q â‰  0) : âˆƒ (x : m), â‡‘q x â‰  0
{Î± : Type u} [PseudoEmetricSpace Î±] {x y : Î±} {S t : set Î±} (xs : x âˆˆ S) (yt : y âˆˆ t) : Emetric.diam (S âˆª t) â‰¤ Emetric.diam S + HasEdist.edist x y + Emetric.diam t
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [Ring_hom_isometric Ïƒâ‚â‚‚] (F : E â†’sl[Ïƒâ‚â‚‚] F) (m : Nnreal) (hM : âˆ€ (x : E), âˆ¥â‡‘F xâˆ¥â‚Š â‰¤ m * âˆ¥xâˆ¥â‚Š) : âˆ¥Fâˆ¥â‚Š â‰¤ m
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {F g : â„‚ â†’ E} (hdf : Diff_Cont_on_cl â„‚ F (set.ioi 0 Ã—â„‚ set.Iio 0)) (hBf : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.ioi 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hdg : Diff_Cont_on_cl â„‚ g (set.ioi 0 Ã—â„‚ set.Iio 0)) (hBg : âˆƒ (C : â„) (h : C < 2) (B : â„), g =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.ioi 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ F â†‘x = g â†‘x) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ F (â†‘x * Complex.i) = g (â†‘x * Complex.i)) : set.Eq_on F g {z : â„‚ | 0 â‰¤ z.re âˆ§ z.im â‰¤ 0}
{m : Type u_4} [Group_with_Zero m] {F g : â„š â†’*â‚€ m} (same_on_Neg_One : â‡‘F (-1) = â‡‘g (-1)) (same_on_pnat : âˆ€ (n : â„•), 0 < n â†’ â‡‘F â†‘n = â‡‘g â†‘n) : F = g
{Î± : Type u_1} {Î² : Type u_2} (e : local_Equiv Î± Î²) : e.Trans e.Symm â‰ˆ local_Equiv.of_set e.Source
(A : Type u_4) [CommRing A] [IsDomain A] {K : Type u_5} [CommRing K] [Algebra A K] [_fraction_Ring A K] : IsDomain K
{R : Type u_1} [CommRing R] (u v W x : Fin 3 â†’ R) : Matrix.dot_Product (â‡‘(â‡‘CrossProduct u) v) (â‡‘(â‡‘CrossProduct W) x) = Matrix.dot_Product u W * Matrix.dot_Product v x - Matrix.dot_Product u x * Matrix.dot_Product v W
{Î¹ : Type u} (S : Finset Î¹) (F : Î¹ â†’ Ennreal) {P : â„} (hp : 1 â‰¤ P) : S.Sum (Î» (i : Î¹), F i) ^ P â‰¤ â†‘(S.Card) ^ (P - 1) * S.Sum (Î» (i : Î¹), F i ^ P)
{R : Type u} {m : Type v} [Group R] [MulAction R m] {P : sub_MulAction R m} (m : â†¥P) : MulAction.Stabilizer R m = MulAction.Stabilizer R â†‘m
{R : Type u_1} {m : Type u_2} {Î¹ : Type u_3} [CommRing R] [AddCommGroup m] [module R m] [Fintype Î¹] (B : Basis Î¹ R m) : module.Finite R m
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P âŸ¶ q) : (âˆ€ (A : â†¥P), â‡‘F A = 0) â†’ F = 0
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Abelian v] {A B C D A' B' C' D' : v} {F : A âŸ¶ B} {g : B âŸ¶ C} {h : C âŸ¶ D} {F' : A' âŸ¶ B'} {g' : B' âŸ¶ C'} {h' : C' âŸ¶ D'} {Î± : A âŸ¶ A'} {Î² : B âŸ¶ B'} {Î³ : C âŸ¶ C'} {Î´ : D âŸ¶ D'} (commâ‚ : Î± â‰« F' = F â‰« Î²) (commâ‚‚ : Î² â‰« g' = g â‰« Î³) (commâ‚ƒ : Î³ â‰« h' = h â‰« Î´) (hgh : CategoryTheory.Exact g h) (hF'g' : CategoryTheory.Exact F' g') (hg'h' : CategoryTheory.Exact g' h') (hÎ± : CategoryTheory.Epi Î±) (hÎ³ : CategoryTheory.Epi Î³) (hÎ´ : CategoryTheory.Mono Î´) : CategoryTheory.Epi Î²
{R : Type u_1} {A B : R} [Semigroup R] (Ab : IsRightRegular (B * A)) : IsRightRegular B
{m : Type u_6} {N : Type u_7} [has_Add m] [has_Add N] {F g : m â‰ƒ+ N} (h : âˆ€ (x : m), â‡‘F x = â‡‘g x) : F = g
{B : â„•} (hb : 1 < B) {x y : â„•} (hy : 0 < y) : B ^ x â‰¤ y â†” x â‰¤ Nat.log B y
{Î± : Type u_1} [UniformSpace Î±] [CompactSpace Î±] [SeparatedSpace Î±] : Uniformity Î± = â¨† (x : Î±), nhds (x, x)
{G : Type u_1} [Group G] (Pâ‚ Pâ‚‚ : â„•) [hpâ‚ : Fact (Nat.Prime Pâ‚)] [hpâ‚‚ : Fact (Nat.Prime Pâ‚‚)] (hne : Pâ‚ â‰  Pâ‚‚) (hâ‚ hâ‚‚ : Subgroup G) (hHâ‚ : _P_Group Pâ‚ â†¥hâ‚) (hHâ‚‚ : _P_Group Pâ‚‚ â†¥hâ‚‚) : Disjoint hâ‚ hâ‚‚
{Î± : Type u_2} [DecidableEq Î±] [HasSub Î±] {u : Finset Î±} {S t : set Î±} : â†‘u âŠ† S - t â†’ (âˆƒ (S' t' : Finset Î±), â†‘S' âŠ† S âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† S' - t')
{R : Type u_1} {K : Type u_2} [Semiring R] [CommSemiring K] {B : R} {bi : K} (i : R â†’+* K) (F : Polynomial R) (A : R) (bu : bi * â‡‘i B = 1) : DenomsClearable A B F.Nat_degree F i
(h : Add_Subgroup â„¤) : âˆƒ (A : â„¤), h = Add_Subgroup.Closure {A}
{R : Type u} [Semiring R] {P : Polynomial R} : Polynomial.x * P = P * Polynomial.x
{Î± : Type u_1} {n : Type u_4} {m : Type u_5} [has_Zero Î±] {A : Matrix m m Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} (h : (Matrix.from_blocks A 0 C D).IsSymm) (ha : A.IsDiag) (hD : D.IsDiag) : (Matrix.from_blocks A 0 C D).IsDiag
{R : Type u_1} [CommRing R] (u v W : Fin 3 â†’ R) : â‡‘(â‡‘CrossProduct u) (â‡‘(â‡‘CrossProduct v) W) + â‡‘(â‡‘CrossProduct v) (â‡‘(â‡‘CrossProduct W) u) + â‡‘(â‡‘CrossProduct W) (â‡‘(â‡‘CrossProduct u) v) = 0
{Î¹ : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : Î¹ â†’ set x} {S : set x} {C : set (ShrinkingLemma.PartialRefinement u S)} (hc : IsChain has_LE.LE C) {vâ‚ vâ‚‚ : ShrinkingLemma.PartialRefinement u S} (hâ‚ : vâ‚ âˆˆ C) (hâ‚‚ : vâ‚‚ âˆˆ C) {i : Î¹} (hiâ‚ : i âˆˆ vâ‚.carrier) (hiâ‚‚ : i âˆˆ vâ‚‚.carrier) : â‡‘vâ‚ i = â‡‘vâ‚‚ i
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} {ps : set P} (h : ps âŠ† â†‘S) [Nonempty â†¥S] {n : â„•} [Finite_dimensional â„ â†¥(S.direction)] (hD : Finite_dimensional.finrank â„ â†¥(S.direction) = n) (hc : EuclideanGeometry.Cospherical ps) : âˆƒ (C : P), âˆ€ (sx : Affine.Simplex â„ P n), set.Range sx.points âŠ† ps â†’ sx.circumcenter = C
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} {F : ð•œ â†’ F} : iterated_fderiv ð•œ n F = â‡‘(Continuous_MultilinearMap.Pi_Field_Equiv ð•œ (Fin n) F) âˆ˜ iterated_deriv n F
{ð•‚ : Type u_6} [_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [NormedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace ð•‚ F'] {F : E' â†’ F'} {x : E'} (hF : ContDiff_at ð•‚ 1 F x) (K : Nnreal) (hK : âˆ¥fderiv ð•‚ F xâˆ¥â‚Š < K) : âˆƒ (t : set E') (h : t âˆˆ nhds x), LipschitzOnWith K F t
{Î± : Type u} {A B C D : Î±} [Preorder Î±] (hca : C â‰¤ A) (hbd : B â‰¤ D) : A â‰¤ B â†’ C â‰¤ D
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} [DecidableEq Î¹] {v : Î¹ â†’ Submodule ð•œ E} (hV : OrthogonalFamily ð•œ (Î» (i : Î¹), (v i).Subtypeâ‚—áµ¢)) (hc : IsComplete â†‘(supr v)) : direct_Sum._internal v â†” (supr v)á—® = âŠ¥
{Î± : Type u_1} {l : List Î±} {x : Î±} : List.Duplicate x l â†” [x, x] <+ l
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] {S : Finset Î±} (hc : S.Card â‰¤ 1) {F : Î± â†’ Î²} {B : Î²} (h : S.Prod (Î» (x : Î±), F x) = B) (x : Î±) (h : x âˆˆ S) : F x = B
{Î± : Type u_1} {m : MeasurableSpace Î±} (Î½ : MeasureTheory.Measure Î±) [MeasureTheory.sigma_Finite Î½] {F : Î± â†’ Ennreal} (hF : Measurable F) : (Î½.with_density F).rn_deriv Î½ =áµ[Î½] F
{t : â†¥Unit_Interval} : 0 â‰¤ t
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {v : v} (hv : v âˆˆ S.direction) {P : P} (hp : P âˆˆ S) : v +áµ¥ P âˆˆ S
(A : â†¥Circle) : â‡‘LinearMap.det â†‘((â‡‘rotation A).to_Linear_Equiv) = 1
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} (hF : Continuous F) : Filter.comap F (Filter.cocompact Î²) â‰¤ Filter.cocompact Î±
(Fq F : Type) [Field Fq] [Field F] (Fqt : Type u_1) [Field Fqt] [Algebra (Polynomial Fq) Fqt] [_fraction_Ring (Polynomial Fq) Fqt] [Algebra (Ratfunc Fq) F] [Algebra Fqt F] [Algebra (Polynomial Fq) F] [IsScalarTower (Polynomial Fq) Fqt F] [IsScalarTower (Polynomial Fq) (Ratfunc Fq) F] : Function_Field Fq F â†” Finite_dimensional Fqt F
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} : IsMaxOn (â‡‘order_dual.to_dual âˆ˜ F) S A â†’ IsMinOn F S A
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {A B : Î±} (l : List Î±) (hlâ‚ : List.chain r A l) (hlâ‚‚ : (A :: l).Last _ = B) : Relation.refl_Trans_gen r A B
{Î± : Type u_1} [circular_Preorder Î±] {A B C : Î±} (habc : HasBtw.Btw A B C) (hcba : Â¬HasBtw.Btw C B A) : HasSbtw.Sbtw A B C
{n : WithTop â„•} {ð•‚ : Type u_6} [_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [NormedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace ð•‚ F'] {S : set E'} {F : E' â†’ F'} {x : E'} {P : E' â†’ FormalMultilinearSeries ð•‚ E' F'} (hF : HasFtaylorSeriesUpToOn n F P S) (hn : 1 â‰¤ n) (hs : S âˆˆ nhds x) : HasStrictFderivAt F (â‡‘(Continuous_multilinear_Curry_Fin1 ð•‚ E' F') (P x 1)) x
{Î± : Type u_1} [DecidableEq Î±] (S : set Î±) [Fintype â†¥S] {A : Î±} (h : A âˆˆ S) : A âˆˆ tactic_.Interval_cases.set_elems S
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î±] [Fintype Î±] [CommSemiring Î²] {Î´ : Î± â†’ Type u_1} [Î  (A : Î±), DecidableEq (Î´ A)] {t : Î  (A : Î±), Finset (Î´ A)} {F : Î  (A : Î±), Î´ A â†’ Î²} : Finset.Univ.Prod (Î» (A : Î±), (t A).Sum (Î» (B : Î´ A), F A B)) = (Fintype.Pi_Finset t).Sum (Î» (P : Î  (A : Î±), Î´ A), Finset.Univ.Prod (Î» (x : Î±), F x (P x)))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} : ContDiff ð•œ n Prod.fst
(R : Type u_1) {P m : â„•} [Fact (Nat.Prime P)] [Ring R] [Char_P R P] (hm : Â¬P âˆ£ m) {k : â„•} : 0 < k â†’ Polynomial.cyclotomic (P ^ k * m) R = Polynomial.cyclotomic m R ^ (P ^ k - P ^ (k - 1))
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G : C â¥¤ D} (Î± : F âŸ¶ G) [âˆ€ (x : C), CategoryTheory.Epi (Î±.App x)] : CategoryTheory.Epi Î±
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {F : v â†’â‚—[K] v} (hinj : Function.Injective â‡‘F) : Function.Surjective â‡‘F
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Mul_Pos_Mono Î±] (ha : 1 â‰¤ A) (hb : 1 â‰¤ B) (B0 : 0 < B) : 1 â‰¤ A * B
{Î± : Type v} [LinearOrder Î±] [TopologicalSpace Î±] [order_IsClosed_topology Î±] {S : set Î±} (hs : IsPreconnected S) {A B : Î±} (ha : A âˆˆ S) (hb : B âˆˆ S) : set.icc A B âŠ† S
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (t : Type u_4) [CommRing t] [Algebra R t] (m N : Submonoid R) (h : m â‰¤ N) [IsLocalization m S] [IsLocalization N t] : IsScalarTower R S t
{Î± : Type u_1} {S : Finset Î±} {P : Î± â†’ Prop} [Decidable_Pred P] (h : âˆ€ (x : Î±), x âˆˆ S â†’ P x) : Finset.Map (Function.Embedding.Subtype P) (Finset.Subtype P S) = S
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : hb.oangle (-x) (-y) = hb.oangle x y
{Î¹ : Type u_1} {R : Type u_2} {Î± : Type u_3} {S : Type u_4} [set_like S R] [Monoid R] [AddMonoid Î¹] (A : Î¹ â†’ S) [set_like.graded_Monoid A] (FÎ¹ : Î± â†’ Î¹) (fA : Î  (A : Î±), â†¥(A (FÎ¹ A))) (l : List Î±) : l.dprod FÎ¹ fA = âŸ¨(List.Map (Î» (A : Î±), â†‘(fA A)) l).Prod, _âŸ©
{Î± : Type u_1} [AddCommMonoid Î±] [TopologicalSpace Î±] {A : Î±} {F : â„• â†’ Î±} (h : has_Sum F A) : Filter.Tendsto (Î» (n : â„•), (Finset.Range n).Sum (Î» (i : â„•), F i)) Filter.at_top (nhds A)
{Î± : Type u_1} [MeasurableSpace Î±] {S : set Î±} : Measurable_set S â†’ (Filter.principal S)._measurably_generated
(P : â„•) [Fact (Nat.Prime P)] (A : â„¤) (ha : â†‘A â‰  0) : Zmod.legendre_Sym P A = 1 âˆ¨ Zmod.legendre_Sym P A = -1
{Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î²] [TopologicalSpace Î³] {Îº : Type u_5} {g : Î² â†’ Î³} {F : Îº â†’ Î²} (hg : DenseRange g) (hF : DenseRange F) (cg : Continuous g) : DenseRange (g âˆ˜ F)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x âŸ¶ Y) [CategoryTheory.Limits.HasEqualizer F g] : CategoryTheory.Limits.HasKernel (F - g)
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {x y : ð•œ} (h : x < y) {z : ð•œ} : z âˆˆ set.ioc x y â†” âˆƒ (A B : ð•œ), 0 â‰¤ A âˆ§ 0 < B âˆ§ A + B = 1 âˆ§ A * x + B * y = z
{m : Type u_3} {N : Type u_4} {F : Type u_8} {mM : AddZeroClass m} {mN : AddZeroClass N} [AddMonoid_hom_class F m N] (F : F) {x : m} (hx : âˆƒ (y : m), x + y = 0) : âˆƒ (y : N), â‡‘F x + y = 0
{R : Type u1} [CommSemiring R] {m : Type u2} [AddCommMonoid m] [module R m] : Disjoint (exterior_Algebra.Î¹ R).Range 1
{F : Type u_3} [InnerProductSpace â„ F] {K : set F} (h : Convex â„ K) {u v : F} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (W : â†¥K), âˆ¥u - â†‘Wâˆ¥) â†” âˆ€ (W : F), W âˆˆ K â†’ HasInner.inner (u - v) (W - v) â‰¤ 0
{R : Type u_1} [cancel_CommMonoid_with_Zero R] {x y A P : R} {n : â„•} (hp : Prime P) (hx : x * y = A * P ^ n) : âˆƒ (i j : â„•) (B C : R), i + j = n âˆ§ A = B * C âˆ§ x = B * P ^ i âˆ§ y = C * P ^ j
(A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension âˆ… A B] : âŠ¥ = âŠ¤
{Î± : Type u_1} [has_LE Î±] {A : Î±} : _top A â†’ _IsBot (â‡‘order_dual.to_dual A)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] {x : E} {S : set E} (hx : x âˆˆ S) (hs : S â‰  set.Univ) : âˆƒ (y : E) (h : y âˆˆ Frontier S), metric.Inf_dist x Sá¶œ = HasDist.dist x y
{Î± : Type u_1} [PseudoEmetricSpace Î±] (C : Ennreal) {F : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (F n) (F (n + 1)) â‰¤ C / 2 ^ n) {A : Î±} (ha : Filter.Tendsto F Filter.at_top (nhds A)) : HasEdist.edist (F 0) A â‰¤ 2 * C
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} (F : top.Presheaf C x) (U : TopologicalSpace.Opens â†¥x) (R : CategoryTheory.Presieve U) (hR : CategoryTheory.Sieve.generate R âˆˆ â‡‘(Opens.GrothendieckTopology â†¥x) U) : CategoryTheory.presheaf.fork_Map R F â‰« (top.Presheaf.covering_of_Presieve.FirstObj_iso_Pi_Opens F U R).hom = F.Map (CategoryTheory.Eq_to_hom _).Op â‰« top.Presheaf.sheaf_condition_Equalizer_products.res F (top.Presheaf.covering_of_Presieve U R)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : EuclideanGeometry.Orthogonal_projection_fn S P âˆˆ AffineSubspace.Mk' P (S.direction)á—®
{Î± : Type u_1} {G : Type u_4} [subtraction_CommMonoid G] {F g : Î± â†’ G} (hF : (Function.Support F).Finite) (hg : (Function.Support g).Finite) : finsum (Î» (i : Î±), F i - g i) = finsum (Î» (i : Î±), F i) - finsum (Î» (i : Î±), g i)
{Î± : Type u_2} [Semiring Î±] {A : Î±} : Odd A â†’ (âˆƒ (B : Î±), A = bit1 B)
(P : â„•) [P_Prime : Fact (Nat.Prime P)] {q r : â„•} (hq : q â‰  0) (hr : r â‰  0) : padic_val_Nat P (q * r) = padic_val_Nat P q + padic_val_Nat P r
(F : Circle_deg1_Lift) {x : â„} {n : â„•} {m : â„¤} (h : â‡‘(F ^ n) x = x + â†‘m) (hn : 0 < n) : F.TranslationNumber = â†‘m / â†‘n
{G : Type u_1} [AddGroup G] {Î¹ : Type u_2} (S : Finset Î¹) (F : Î¹ â†’ G) (comm : âˆ€ (x : Î¹), x âˆˆ S â†’ âˆ€ (y : Î¹), y âˆˆ S â†’ Add_Commute (F x) (F y)) (K : Î¹ â†’ Add_Subgroup G) (hind : CompleteLattice.Independent K) (hmem : âˆ€ (x : Î¹), x âˆˆ S â†’ F x âˆˆ K x) (HEq1 : S.noncomm_Sum F comm = 0) (i : Î¹) (h : i âˆˆ S) : F i = 0
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {A : Î±} {S : set Î±} (F : Î± â†’ m) (h : A âˆ‰ S) (hs : S.Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ HasInsert.Insert A S), F i)) = F A * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i))
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - 2 * âˆ¥xâˆ¥ * âˆ¥yâˆ¥ * Real.cos (InnerProductGeometry.angle x y)
{Gâ‚€ : Type u_2} [Group_with_Zero Gâ‚€] (A : Gâ‚€) : A / A * A = A
{m : Type u_3} {N : Type u_4} [has_Add m] [has_Add N] {F g : Add_hom m N} (h : F = g) (x : m) : â‡‘F x = â‡‘g x
{Î± : Type u_1} {Î² : Type u_2} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²} (hâ‚ : tâ‚‚ â‰¤ tâ‚ƒ) {S : set Î±} {F : Î± â†’ Î²} (hâ‚‚ : Continuous_on F S) : Continuous_on F S
(A : â„) : Cardinal.Mk â†¥(set.ioi A) = Cardinal.Continuum
{G : Type u_1} [AddGroup G] (h : Add_Subgroup G) {x : G} : x âˆˆ h â†’ -x âˆˆ h
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] (h : âˆ€ (x : C), CategoryTheory.Mono (CategoryTheory.Limits.initial.to x)) : CategoryTheory.Limits.InitialMonoClass C
{Î± : Type u_2} {Î¹ : Type u_5} [CommMonoid Î±] (t : Finset Î¹) (Fâ‚ Fâ‚‚ : Î¹ â†’ set Î±) (hF : âˆ€ {i : Î¹}, i âˆˆ t â†’ Fâ‚ i âŠ† Fâ‚‚ i) : t.Prod (Î» (i : Î¹), Fâ‚ i) âŠ† t.Prod (Î» (i : Î¹), Fâ‚‚ i)
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (K : Type u_2) [Field K] [Algebra R K] [_fraction_Ring R K] (v : IsDedekindDomain.height_One_Spectrum R) : Classical.Some _ â‰  0
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {mâ‚ mâ‚‚ : Ennreal â†’ Ennreal} {C : Ennreal} (hc : C â‰  âŠ¤) (h0 : C â‰  0) (hle : mâ‚ â‰¤á¶ [nhds_within 0 (set.ici 0)] C â€¢ mâ‚‚) : MeasureTheory.Measure.Mk_metric mâ‚ â‰¤ C â€¢ MeasureTheory.Measure.Mk_metric mâ‚‚
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace E] {v : E} (hv : v âˆˆ K) : â‡‘(Orthogonal_projection Ká—®) v = 0
{h : Type u} [TopologicalSpace h] (G : StructureGroupoid h) : LocalHomeomorph.refl h âˆˆ StructureGroupoid.MaximalAtlas h G
{m : Type u_1} {N : Type u_2} [MulOneClass m] [MulOneClass N] (h : m â‰ƒ* N) : _Mul_hom â‡‘h
(Wâ‚ Wâ‚‚ zâ‚ zâ‚‚ : Ennreal) (hw' : Wâ‚ + Wâ‚‚ = 1) {P : â„} (hp : 1 â‰¤ P) : (Wâ‚ * zâ‚ + Wâ‚‚ * zâ‚‚) ^ P â‰¤ Wâ‚ * zâ‚ ^ P + Wâ‚‚ * zâ‚‚ ^ P
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {F : m â†’* P} : (Con.Ker_Lift F).mrange = F.mrange
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D â¥¤ C) [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Reflective i] [CategoryTheory.cartesian_IsClosed C] [CategoryTheory.exponential_Ideal i] (A B : C) : CategoryTheory.IsIso (CategoryTheory.Limits.Prod_comparison (CategoryTheory.IsLeftAdjoint i) A B)
{C : Type uâ‚} [CategoryTheory.Category C] {x : C} (P : Cáµ’áµ– â¥¤ Type W) {S : CategoryTheory.Sieve x} {R : CategoryTheory.Presieve x} (h : â‡‘S â‰¤ R) (Trans : âˆ€ â¦ƒY : Câ¦„ (F : Y âŸ¶ x), CategoryTheory.Presieve.IsSheafFor P â‡‘(CategoryTheory.Sieve.pullback F S)) : CategoryTheory.Presieve.IsSheafFor P R
{m : Type u_1} [has_Mul m] (C : Con m) {A B : m} : â†‘A = â†‘B â†” â‡‘C A B
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) {l : List R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ S) â†’ l.Sum âˆˆ S
(C : Type u) [CategoryTheory.Category C] [âˆ€ {x Y Z : C} {F : x âŸ¶ Y} {g : x âŸ¶ Z}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.Span F g)] : CategoryTheory.Limits.HasPushouts C
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [BaireSpace Î±] [Nonempty Î±] [Encodable Î²] {F : Î² â†’ set Î±} (hc : âˆ€ (S : Î²), IsClosed (F S)) (hU : (â‹ƒ (S : Î²), F S) = set.Univ) : âˆƒ (S : Î²), (Interior (F S)).Nonempty
{Î¹ : Type u_1} {ð•œ : Type u_2} [_R_or_C ð•œ] {E : Type u_3} [InnerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), InnerProductSpace ð•œ (G i)] {v : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ v) [âˆ€ (i : Î¹), CompleteSpace (G i)] (hV' : (â¨† (i : Î¹), (v i).to_LinearMap.Range).topological_Closure = âŠ¤) (W : â†¥(Lp G 2)) : â‡‘((hV.Linear_Isometry_Equiv hV').Symm) W = âˆ‘' (i : Î¹), â‡‘(v i) (â‡‘W i)
{Î± : Type u_1} {F : Î± â†’ Î±} {x : Î±} (hF : Function.IsFixedPt F x) (n : â„•) : Function.IsPeriodicPt F n x
(n : â„•) : (Finset.Range (n + 1)).Sum (Î» (m : â„•), n.choose m) = 2 ^ n
{Î± : Type u_1} {Î² : Type u_3} [MeasurableSpace Î±] [MeasurableSpace Î²] {Î½ : MeasureTheory.Measure Î²} [MeasureTheory._Finite_measure Î½] {S : set (Î± Ã— Î²)} (hs : Measurable_set S) : Measurable (Î» (x : Î±), â‡‘Î½ (Prod.Mk x â»Â¹' S))
{G : Type u} [Group G] [Fintype G] {P n : â„•} [hp : Fact (Nat.Prime P)] {h : Subgroup G} (hH : Fintype.Card â†¥h = P ^ n) : Fintype.Card â†¥(h.Normalizer) â‰¡ Fintype.Card G [Mod P ^ (n + 1)]
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {A B : Î±} {S : set Î±} (hs : IsClosed (S âˆ© set.icc A B)) (ha : A âˆˆ S) (hgt : âˆ€ (x : Î±), x âˆˆ S âˆ© set.Ico A B â†’ âˆ€ (y : Î±), y âˆˆ set.ioi x â†’ (S âˆ© set.ioc x y).Nonempty) : set.icc A B âŠ† S
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace ð•œ] {C : ð•œ} (hc : 1 < âˆ¥Câˆ¥) {R : â„} (hR : âˆ¥Câˆ¥ < R) (h : Â¬Finite_dimensional ð•œ E) : âˆƒ (F : â„• â†’ E), (âˆ€ (n : â„•), âˆ¥F nâˆ¥ â‰¤ R) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ 1 â‰¤ âˆ¥F m - F nâˆ¥
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S t : set Î±} : BddBelow S â†’ BddBelow t â†’ (S âˆ© t).Nonempty â†’ HasInf.Inf S âŠ” HasInf.Inf t â‰¤ HasInf.Inf (S âˆ© t)
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A : Î±} : Aâ»Â¹ < 1 â†” 1 < A
{n : â„•} (R : Type u_1) [Ring R] : Coe âˆ˜ Coe = Coe
(r n : â„•) : (2 * n).choose r â‰¤ n.central_binom
{Î± : Type u_1} {Î² : Type u_2} {P : Pmf Î±} (F : Î  (A : Î±), A âˆˆ P.Support â†’ Pmf Î²) (S : set Î²) [MeasurableSpace Î²] (hs : Measurable_set S) : â‡‘((P.Bind_on_Support F).to_measure) S = âˆ‘' (A : Î±), â†‘(â‡‘P A) * dite (â‡‘P A = 0) (Î» (h : â‡‘P A = 0), 0) (Î» (h : Â¬â‡‘P A = 0), â‡‘((F A h).to_measure) S)
{Î± : Type u_1} [TopologicalSpace Î±] [BaireSpace Î±] {S : set (set Î±)} (ho : âˆ€ (S : set Î±), S âˆˆ S â†’ IsOpen S) (hS : S.countable) (hD : âˆ€ (S : set Î±), S âˆˆ S â†’ Dense S) : Dense (â‹‚â‚€ S)
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] {F : Type v} [NormedGroup F] [NormedSpace â„‚ F] {F : E â†’ F} {z : E} {r : â„} (hD : Diff_Cont_on_cl â„‚ F (Metric.Ball z r)) (hz : IsMaxOn (HasNorm.norm âˆ˜ F) (Metric.Ball z r) z) : set.Eq_on (HasNorm.norm âˆ˜ F) (Function.Const E âˆ¥F zâˆ¥) (metric.IsClosed_ball z r)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' Fâ‚' : E â†’L[ð•œ] F} {x : E} {S : set E} (hF : HasFderivWithinAt F F' S x) (hg : HasFderivWithinAt F Fâ‚' S x) : set.Eq_on â‡‘F' â‡‘Fâ‚' (TangentConeAt ð•œ S x)
{Î± : Type u_1} {P : Î± â†’ Prop} : set.Range Coe = {x : Î± | P x}
{R : Type u_1} {A B : R} [Add_Semigroup R] : IsAddRegular (A + B) âˆ§ IsAddRegular (B + A) â†” IsAddRegular A âˆ§ IsAddRegular B
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B C : Î±} : -B + A < C â†’ A < B + C
{R : Type uâ‚} [CommRing R] (A B : R) : A ^ 2 - B ^ 2 = (A + B) * (A - B)
{Î± : Type u_1} [DecidableEq Î±] (S : Finset Î±) : S.Sym2.Card = S.Card * (S.Card + 1) / 2
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [CommMonoid Î±] {g : Î³ â†’ Î²} (hg : Function.Injective g) {F : Î² â†’ Î±} (hF : âˆ€ (x : Î²), x âˆ‰ set.Range g â†’ F x = 1) : Filter.Map (Î» (S : Finset Î³), S.Prod (Î» (i : Î³), F (g i))) Filter.at_top = Filter.Map (Î» (S : Finset Î²), S.Prod (Î» (i : Î²), F i)) Filter.at_top
{Î± : Type u} [t : TopologicalSpace Î±] {B : set (set Î±)} (hb : TopologicalSpace._topological_Basis B) {S : set Î±} {A : Î±} : A âˆˆ Closure S â†” âˆ€ (o : set Î±), o âˆˆ B â†’ A âˆˆ o â†’ (o âˆ© S).Nonempty
(n : â„•) : (Multiset.Nat.antidiagonal n).Nodup
(Î± : Type u) {Î² : Type v} [AddGroup Î±] [AddAction Î± Î²] (B : Î²) [Fintype Î±] [Fintype â†¥(AddAction.Orbit Î± B)] [Fintype â†¥(AddAction.Stabilizer Î± B)] : Fintype.Card â†¥(AddAction.Orbit Î± B) * Fintype.Card â†¥(AddAction.Stabilizer Î± B) = Fintype.Card Î±
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {vâ‚ vâ‚‚ : Ray_Vector R m} : -vâ‚ â‰ˆ -vâ‚‚ â†” vâ‚ â‰ˆ vâ‚‚
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [order_IsClosed_topology Î±] [Nonempty Î±] {S : set Î±} (hs : IsCompact S) : BddAbove S
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : F =O[l] g â†” âˆƒ (C : â„), Asymptotics._O_with C l F g
{F : Type u â†’ Type u} [Functor F] [q : Qpf F] {Î± : Type u} (u : F Î± â†’ Î±) (x y : (Qpf.P F).W) : Qpf.Wequiv x y â†’ Qpf.recF u x = Qpf.recF u y
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) (i : Fin (n + 1)) : HasDist.dist (S.points i) S.circumcenter = S.circumradius
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) : S.circumcenter âˆˆ affine_Span â„ (set.Range S.points)
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] [Nonempty Î²] {F : Î² â†’ Î±} (hF : Continuous F) (hlim : Filter.Tendsto F (Filter.cocompact Î²) Filter.at_top) : âˆƒ (x : Î²), âˆ€ (y : Î²), F x â‰¤ F y
{S : Type u_2} [CommRing S] {K : Type u_6} [Field K] [Algebra K S] {x : S} (hx : IsIntegral K x) : LinearIndependent K (Î» (i : Fin (minpoly K x).Nat_degree), x ^ â†‘i)
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hst : Disjoint S t) (hs : S.Finite) (ht : t.Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S âˆª t), F i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ t), F i))
{A B : â„•} (hab : A.IsCoprime B) : Disjoint A.factorization.Support B.factorization.Support
{K : Type u} [Field K] (S : Subfield K) : Subfield.Closure â†‘S = S
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {l : Filter Î±} {A : Î±} : IsMin_Filter (â‡‘order_dual.to_dual âˆ˜ F) l A â†’ IsMax_Filter F l A
{R : Type u} [CommRing R] [IsDomain R] [discrete_Valuation_Ring R] (Ï– : R) : Irreducible Ï– â†” local_Ring.Maximal_Ideal R = Ideal.Span {Ï–}
{Î± : Type u} [PartialOrder Î±] {A B : Î±} (hab : A â‰¤ B) (hba : Â¬A < B) : B = A
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : bounded_Continuous_Function x â„) {e : x â†’ Y} (hE : IsClosed_Embedding e) : âˆƒ (g : bounded_Continuous_Function Y â„), âˆ¥gâˆ¥ = âˆ¥Fâˆ¥ âˆ§ â‡‘g âˆ˜ e = â‡‘F
{G : Type u_1} [AddCommGroup G] (K : Add_Subgroup G) (g : Multiset G) : (âˆ€ (A : G), A âˆˆ g â†’ A âˆˆ K) â†’ g.Sum âˆˆ K
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) [Fintype Î¹] (P : Î¹ â†’ P) : Finset.centroid k S P = â‡‘(Finset.Univ.affine_combination P) (Finset.centroid_weights_indicator k S)
(n : â„•) : Filter.Tendsto (Î» (x : â„), Real.Exp x / x ^ n) Filter.at_top Filter.at_top
(m n : â„•) : Nat.fib (m + n + 1) = Nat.fib m * Nat.fib n + Nat.fib (m + 1) * Nat.fib (n + 1)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P1 : P} (hp1 : P1 âˆˆ S) (P2 P : P) : P âˆˆ affine_Span k (HasInsert.Insert P2 â†‘S) â†” âˆƒ (r : k) (P0 : P) (hp0 : P0 âˆˆ S), P = r â€¢ (P2 -áµ¥ P1) +áµ¥ P0
{Î± : Type u_1} {P : Î  (S : Finset Î±), S.Nonempty â†’ Prop} (hâ‚€ : âˆ€ (A : Î±), P {A} _) (hâ‚ : âˆ€ â¦ƒA : Î±â¦„ (S : Finset Î±) (h : A âˆ‰ S) (hs : S.Nonempty), P S hs â†’ P (Finset.Cons A S h) _) {S : Finset Î±} (hs : S.Nonempty) : P S hs
{G : Type u_1} [sub_Neg_Monoid G] [MeasurableSpace G] [has_Measurable_Add G] (g : G) : Measurable (Î» (h : G), h - g)
{m : Type u_1} [has_Mul m] {C D : Con m} (h : Setoid.r = Setoid.r) : C = D
{R : Type u_1} {A : Type u_2} [CommSemiring R] [CommRing A] [Algebra R A] (ð’œ : â„• â†’ Submodule R A) [graded_Algebra ð’œ] : GaloisConnection (Î» (S : set A), projective_Spectrum.Zero_locus ð’œ S) (Î» (t : (set (projective_Spectrum ð’œ))áµ’áµˆ), â†‘(projective_Spectrum.vanishing_Ideal t))
{Î± : Type u_3} {Î² : Type u_4} [Nonempty Î±] [SemilatticeInf Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Monotone F) : Filter.Tendsto F Filter.at_IsBot Filter.at_IsBot â†” âˆ€ (B : Î²), âˆƒ (A : Î±), F A â‰¤ B
{R : Type v} [CommRing R] {n : â„•} (A : Matrix (Fin n.Succ) (Fin n.Succ) R) : A.det = Finset.Univ.Sum (Î» (i : Fin n.Succ), (-1) ^ â†‘i * A i 0 * (A.minor â‡‘(i.Succ_above) Fin.Succ).det)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type W} [CategoryTheory.Category J] (F : C â¥¤ D) [CategoryTheory.Limits.HasColimits_of_shape J D] [CategoryTheory.CreatesColimitsOfShape J F] : CategoryTheory.Limits.HasColimits_of_shape J C
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {R : â„} {C W : â„‚} {F : â„‚ â†’ E} {S : set â„‚} (hs : S.countable) (hw : W âˆˆ Metric.Ball C R) (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : âˆ€ (x : â„‚), x âˆˆ Metric.Ball C R  S â†’ Differentiable_at â„‚ F x) : âˆ® (z : â„‚) in C(C, R), (z - W)â»Â¹ â€¢ F z = (2 * â†‘Real.Pi * Complex.i) â€¢ F W
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {A B : Î±} {S : set Î±} (hs : IsClosed (S âˆ© set.icc A B)) (ha : A âˆˆ S) (hab : A â‰¤ B) (hgt : âˆ€ (x : Î±), x âˆˆ S âˆ© set.Ico A B â†’ (S âˆ© set.ioc x B).Nonempty) : B âˆˆ S
{R : Type u_4} [Linear_ordered_Ring R] (A : R) : 0 â‰¤ A ^ 2
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] {ifp_Succ_n : GeneralizedContinuedFraction.Int_fract_pair K} (Succ_nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v (n + 1) = Option.Some ifp_Succ_n) : 1 â‰¤ ifp_Succ_n.B
(R : Type u) [CommSemiring R] {m : Type v} [AddCommMonoid m] [module R m] {S : Finset m} (B : Basis â†¥S R m) (F : m â†’â‚—[R] m) : â‡‘(LinearMap.trace R m) F = (â‡‘(Linear_Map.to_Matrix B B) F).trace
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] [Algebra R S] [IsDomain S] (h : Algebra.IsIntegral R S) (P : Ideal R) [P_max : P.IsMaximal] (hP : (Algebra_Map R S).Ker â‰¤ P) : âˆƒ (q : Ideal S), q.IsMaximal âˆ§ Ideal.comap (Algebra_Map R S) q = P
(m : Type u_1) (Î± : Type u_2) [Monoid m] [MulAction m Î±] : GaloisConnection (â‡‘order_dual.to_dual âˆ˜ fixing_Submonoid m) ((Î» (P : Submonoid m), MulAction.FixedPoints â†¥P Î±) âˆ˜ â‡‘order_dual.of_dual)
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} [MeasurableSpace Î±] [MeasurableSpace Î²] [MeasurableSpace Î³] {Î´ : Type u_7} [MeasurableSpace Î´] {Î¼A : MeasureTheory.Measure Î±} {Î¼B : MeasureTheory.Measure Î²} {Î¼C : MeasureTheory.Measure Î³} {Î¼D : MeasureTheory.Measure Î´} [MeasureTheory.sigma_Finite Î¼B] [MeasureTheory.sigma_Finite Î¼D] {F : Î± â†’ Î²} {g : Î³ â†’ Î´} (hF : MeasureTheory.MeasurePreserving F Î¼A Î¼B) (hg : MeasureTheory.MeasurePreserving g Î¼C Î¼D) : MeasureTheory.MeasurePreserving (Prod.Map F g) (Î¼A.Prod Î¼C) (Î¼B.Prod Î¼D)
 : Filter.Tendsto Complex.Abs (Filter.cocompact â„‚) Filter.at_top
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m â†’+ P} (h : C â‰¤ Add_Con.Ker F) (x : m) : â‡‘(C.Lift F h) â†‘x = â‡‘F x
{n : â„•} (i j : Î£ (A : Composition n), Composition A.length) : i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.Snd.blocks = j.Snd.blocks
{K : Type u_1} [Linear_ordered_Field K] {A B C : K} (h : âˆ€ (x : K), 0 â‰¤ A * x * x + B * x + C) : discrim A B C â‰¤ 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (direction : Submodule k v) : P âˆˆ AffineSubspace.Mk' P direction
{m : Type u_1} [has_Mul m] {C : Con m} {C : C.Quotient â†’ Prop} (q : C.Quotient) (h : âˆ€ (x : m), C â†‘x) : C q
{Î¹ : Type u} {Î³ : Type W} [dec : DecidableEq Î¹] [AddCommMonoid Î³] (S : Î¹ â†’ Add_Submonoid Î³) : supr S = (Dfinsupp.Sum_Add_hom (Î» (i : Î¹), (S i).Subtype)).mrange
(P : â„•) [hp : Fact (Nat.Prime P)] {q : â„š} (hq : q â‰  0) : padic_norm P q â‰  0
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [module R P] : module.projective R P â†” CategoryTheory.Projective (module.of R P)
{R : Type u} [Ring R] : CategoryTheory.Limits.HasKernels (module R)
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : RË£) : Continuous_at Ring.Inverse â†‘x
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) {x y : R} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
{x : Type u_2} {Y : Type u_3} [EmetricSpace x] [EmetricSpace Y] {C r : Nnreal} {F : x â†’ Y} (h : HolderWith C r F) (hr : 0 < r) : dimH (set.Range F) â‰¤ dimH set.Univ / â†‘r
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S t : set Î±} (hs : BddAbove S) (ht : BddAbove t) (hst : (S âˆ© t).Nonempty) : HasSup.Sup (S âˆ© t) â‰¤ HasSup.Sup S âŠ“ HasSup.Sup t
{P L : Type u} [HasMem P L] [Configuration.Nondegenerate P L] [Fintype P] [Fintype L] (h : Fintype.Card L â‰¤ Fintype.Card P) : âˆƒ (F : L â†’ P), Function.Injective F âˆ§ âˆ€ (l : L), F l âˆ‰ l
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {m : Matrix n n R} {i j : n} (i_Ne_j : i â‰  j) (hij : âˆ€ (k : n), m k i = m k j) : m.det = 0
{G : Type u} {x : G} {n : â„•} [Monoid G] (hn : 0 < n) (hx : x ^ n = 1) (hD : âˆ€ (P : â„•), Nat.Prime P â†’ P âˆ£ n â†’ x ^ (n / P) â‰  1) : order_of x = n
{m : Type u_1} [AddMonoid m] {x : m} : AddMonoid.Closure {x} = Multiples x
{Î± : Type u} [PseudoMetricSpace Î±] {x : Î±} {r : â„} : Metric.Bounded (Metric.Sphere x r)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : 2 â€¢ hb.oangle (-x) y = 2 â€¢ hb.oangle x y
{Î± : Type u_1} [UniformSpace Î±] {S : set (Î± Ã— Î±)} (hs : S âˆˆ Uniformity Î±) : âˆ€á¶  (t : set (Î± Ã— Î±)) in (Uniformity Î±).Small_sets, Comp_Rel t t âŠ† S
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) : hb.rotation 0 = Linear_Isometry_Equiv.refl â„ v
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasStrictTerminalObjects C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ C) [CategoryTheory.Limits.HasLimit F] (i : J) (h : Î  (j : J), j â‰  i â†’ CategoryTheory.Limits.IsTerminal (F.obj j)) [Subsingleton (i âŸ¶ i)] : CategoryTheory.IsIso (CategoryTheory.Limits.LimitÏ€ F i)
{G : Type u_1} [Group G] : IsDescendingCentralSeries (lower_central_series G)
{x : Pgame} (h : x â‰¤ 0) (i : x.Left_moves) : (x.move_Left i).move_Right (Pgame.Right_response h i) â‰¤ 0
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.Normal] (h1 : (Fintype.Card â†¥N).IsCoprime N.Index) (h2 : âˆ€ (G' : Type u) [_inst_4 : Group G'] [_inst_5 : Fintype G'], Fintype.Card G' < Fintype.Card G â†’ âˆ€ {N' : Subgroup G'} [_inst_6 : N'.Normal], (Fintype.Card â†¥N').IsCoprime N'.Index â†’ (âˆƒ (h' : Subgroup G'), N'.Complement' h')) (h3 : âˆ€ (h : Subgroup G), Â¬N.Complement' h) : N.IsCommutative
(ð•œ : Type u_1) [nondiscrete_NormedField ð•œ] {E : Type u_2} [semi_NormedGroup E] [NormedSpace ð•œ E] (S : set E) : IsClosed (WeakDual.Polar ð•œ S)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {v : â„ â†’ E â†’ E} {K : Nnreal} (hv : âˆ€ (t : â„), LipschitzWith K (v t)) {F g : â„ â†’ E} {A B : â„} (hF : Continuous_on F (set.icc A B)) (hF' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt F (v t (F t)) (set.ici t) t) (hg : Continuous_on g (set.icc A B)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt g (v t (g t)) (set.ici t) t) (ha : F A = g A) (t : â„) (h : t âˆˆ set.icc A B) : F t = g t
(R : Type u) [Ring R] [strong_RankCondition R] {Î¹ : Type v} : module.rank R (Î¹ â†’â‚€ R) = (Cardinal.Mk Î¹).Lift
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {Fâ‚‚ : ð•œ â†’ F} {n : â„•} : ContDiff ð•œ â†‘(n + 1) Fâ‚‚ â†” Differentiable ð•œ Fâ‚‚ âˆ§ ContDiff ð•œ â†‘n (deriv Fâ‚‚)
(n : â„•) (R : Type u_1) [CommRing R] : (Polynomial.cyclotomic n R)._primitive
{Î± : Type u} [TopologicalSpace Î±] {S t : set Î±} (hs : IsCompact S) (ht : IsOpen t) : IsCompact (S  t)
(n : â„¤) : â‡‘Zmod.Ï‡â‚ˆ â†‘n = Ite (n % 2 = 0) 0 (Ite (n % 8 = 1 âˆ¨ n % 8 = 7) 1 (-1))
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} {C : â„‚} {R : Nnreal} (hF : CircleIntegrable F C â†‘R) (hR : 0 < R) : HasFpowerSeriesOnBall (Î» (W : â„‚), (2 * â†‘Real.Pi * Complex.i)â»Â¹ â€¢ âˆ® (z : â„‚) in C(C, â†‘R), (z - W)â»Â¹ â€¢ F z) (Cauchy_PowerSeries F C â†‘R) C â†‘R
{Î± : Type u_1} {S : set Î±} (P : â†¥S) : â†‘P âˆˆ S
{L : FirstOrder.Language} {m : Type W} [L.structure m] {S t : L.Substructure m} (h : âˆ€ (x : m), x âˆˆ S â†” x âˆˆ t) : S = t
{Î± : Type u_1} [circular_Preorder Î±] {A B C : Î±} : HasSbtw.Sbtw A B C â†” HasSbtw.Sbtw C A B
{n : â„•} {iâ‚ iâ‚‚ : Fin (n + 3)} (h : iâ‚ â‰  iâ‚‚) : Finset.Univ.Sum (Î» (i : Affine.Simplex.points_with_circumcenter_Index (n + 2)), Affine.Simplex.monge_point_vsub_face_centroid_weights_with_circumcenter iâ‚ iâ‚‚ i) = 0
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) : CategoryTheory.topology_of_Closure_operator Jâ‚.Closure_operator _ = Jâ‚
(R : Type u_1) [CommRing R] [IsDomain R] : Polynomial.cyclotomic' 1 R = Polynomial.x - 1
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F : J â¥¤ C} [CategoryTheory.Limits.HasColimit F] (C : CategoryTheory.Limits.Cocone F) (j : J) : CategoryTheory.Limits.ColimitÎ¹ F j â‰« CategoryTheory.Limits.Colimit.Desc F C = C.Î¹.App j
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) : P.radius = Filter.at_top.liminf (Î» (n : â„•), 1 / â†‘(âˆ¥P nâˆ¥â‚Š ^ (1 / â†‘n)))
{R : Type u_1} [CommRing R] (S : Subring R) {Î¹ : Type u_2} {t : Finset Î¹} {F : Î¹ â†’ R} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Prod (Î» (i : Î¹), F i) âˆˆ S
{n : Type u_3} [Fintype n] {K : Type u_1} [DecidableEq n] [Field K] {m : Matrix n n K} : (âˆƒ (v : n â†’ K) (h : v â‰  0), m.Mul_vec v = 0) â†” m.det = 0
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hs : S.Finite) (ht : t.Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S âˆª t), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S âˆ© t), F i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ t), F i))
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x y : Î±} (h : Emetric.diam S â‰  âŠ¤) (hx : x âˆˆ S) (hy : y âˆˆ S) : HasDist.dist x y â‰¤ Metric.diam S
{R : Type u_1} [CommRing R] [CharZero R] : Function.Injective (Î» (n : â„•), Polynomial.cyclotomic n R)
{R : Type u} [Semiring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {m : Type u_1} [AddCommMonoid m] [module R m] {A : Î¹ â†’ Submodule R m} (h : direct_Sum._internal A) : supr A = âŠ¤
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [CommMonoid N] [DecidableEq Î±] (F : Î± â†’â‚€ m) (A : Î±) (B : Î± â†’ m â†’ N) : F.Prod (Î» (x : Î±) (v : m), Ite (x = A) (B x v) 1) = Ite (A âˆˆ F.Support) (B A (â‡‘F A)) 1
 : Subgroup.Normal_Closure {âŸ¨Equiv.Swap 0 4 * Equiv.Swap 1 3, _âŸ©} = âŠ¤
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S : set Î±} {B : Î±} : S.Nonempty â†’ (âˆ€ (A : Î±), A âˆˆ S â†’ B â‰¤ A) â†’ (âˆ€ (W : Î±), B < W â†’ (âˆƒ (A : Î±) (h : A âˆˆ S), A < W)) â†’ HasInf.Inf S = B
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] : âˆ….Up_shadow = âˆ…
{Î± : Type u} [TopologicalSpace Î±] {S t : set Î±} (hs : IsCompact S) (ht : IsClosed t) : IsCompact (S âˆ© t)
{E : Type u} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] {n : â„•} {F : Type u_1} [NormedGroup F] [NormedSpace â„ F] [PartialOrder F] [MeasureTheory.Measure_Space F] [BorelSpace F] (eL : F â‰ƒL[â„] Fin (n + 1) â†’ â„) (hE_Ord : âˆ€ (x y : F), â‡‘eL x â‰¤ â‡‘eL y â†” x â‰¤ y) (hE_vol : MeasureTheory.MeasurePreserving â‡‘eL MeasureTheory.MeasureSpace.Volume MeasureTheory.MeasureSpace.Volume) (F : Fin (n + 1) â†’ F â†’ E) (F' : Fin (n + 1) â†’ F â†’ (F â†’L[â„] E)) (S : set F) (hs : S.countable) (A B : F) (hle : A â‰¤ B) (Hc : âˆ€ (i : Fin (n + 1)), Continuous_on (F i) (set.icc A B)) (hD : âˆ€ (x : F), x âˆˆ Interior (set.icc A B)  S â†’ âˆ€ (i : Fin (n + 1)), HasFderivAt (F i) (F' i x) x) (DF : F â†’ E) (hDF : âˆ€ (x : F), DF x = Finset.Univ.Sum (Î» (i : Fin (n + 1)), â‡‘(F' i x) (â‡‘(eL.Symm) (Pi.single i 1)))) (Hi : MeasureTheory.IntegrableOn DF (set.icc A B) MeasureTheory.MeasureSpace.Volume) : âˆ« (x : F) in set.icc A B, DF x = Finset.Univ.Sum (Î» (i : Fin (n + 1)), (âˆ« (x : Fin n â†’ â„) in set.icc (â‡‘eL A âˆ˜ â‡‘(i.Succ_above)) (â‡‘eL B âˆ˜ â‡‘(i.Succ_above)), F i (â‡‘(eL.Symm) (i.Insert_nth (â‡‘eL B i) x))) - âˆ« (x : Fin n â†’ â„) in set.icc (â‡‘eL A âˆ˜ â‡‘(i.Succ_above)) (â‡‘eL B âˆ˜ â‡‘(i.Succ_above)), F i (â‡‘(eL.Symm) (i.Insert_nth (â‡‘eL A i) x)))
{Î± : Type u_1} [TopologicalSpace Î±] [BaireSpace Î±] {S t : set Î±} (hs : _GÎ´ S) (ht : _GÎ´ t) (hsc : Dense S) (htc : Dense t) : Dense (S âˆ© t)
{A B : â„} (m n : â„•) : âˆ« (x : â„) in A..B, Real.sin x ^ (2 * m) * Real.cos x ^ (2 * n) = âˆ« (x : â„) in A..B, ((1 - Real.cos (2 * x)) / 2) ^ m * ((1 + Real.cos (2 * x)) / 2) ^ n
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N' : Type u_5} [AddCommGroup N'] [module R N'] {Î¹ : Type u_6} [DecidableEq Î¹] [Fintype Î¹] (A : AlternatingMap R m N' Î¹) : â‡‘MultilinearMap.alternatization â†‘A = (Fintype.Card Î¹).factorial â€¢ A
{P : â„•} : padic_val_Int P 0 = 0
{m : Type u_1} [AddZeroClass m] {C : Add_Con m} : â†‘0 = 0
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x y : Î±} {t : set Î±} (xs : x âˆˆ S) (yt : y âˆˆ t) : Metric.diam (S âˆª t) â‰¤ Metric.diam S + HasDist.dist x y + Metric.diam t
{Î± : Type u} {Î² : Type v} [SemilatticeSup Î±] {F : Î± â†’ Î²} {r : Î² â†’ Î² â†’ Prop} (h : âˆ€ â¦ƒi j : Î±â¦„, i â‰¤ j â†’ r (F i) (F j)) : Directed r F
{R : Type u} {Î¹ : Type v} {mâ‚ : Î¹ â†’ Type Wâ‚} {mâ‚‚ : Type Wâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] [Î  (i : Î¹), TopologicalSpace (mâ‚ i)] [TopologicalSpace mâ‚‚] (F : Continuous_MultilinearMap R mâ‚ mâ‚‚) {Î± : Î¹ â†’ Type u_1} [Fintype Î¹] (g : Î  (i : Î¹), Î± i â†’ mâ‚ i) [Î  (i : Î¹), Fintype (Î± i)] : â‡‘F (Î» (i : Î¹), Finset.Univ.Sum (Î» (j : Î± i), g i j)) = Finset.Univ.Sum (Î» (r : Î  (i : Î¹), Î± i), â‡‘F (Î» (i : Î¹), g i (r i)))
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] [Nonempty Î²] [has_One Î±] {F : Î² â†’ Î±} (hF : Continuous F) (h : HasCompactMulSupport F) : âˆƒ (x : Î²), âˆ€ (y : Î²), F x â‰¤ F y
{A B C : â„¤} (habc : A âˆ£ B * C) (hab : A.Gcd C = 1) : A âˆ£ B
{Î± : Type u} [PseudoMetricSpace Î±] (A : Î±) : HasNndist.nndist A A = 0
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {F : Î± â†’ Î² â†’ Î³} {S S' : set Î±} {t t' : set Î²} (hs : S âŠ† S') (ht : t âŠ† t') : set.image2 F S t âŠ† set.image2 F S' t'
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] [DecidableEq Î±] (S : Finset Î±) (F : Î± â†’ Î²) {A : Î±} (h : A âˆˆ S) : (S.erase A).Prod (Î» (x : Î±), F x) * F A = S.Prod (Î» (x : Î±), F x)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) : âˆ‘' (i : Î¹), âˆ¥HasInner.inner (v i) xâˆ¥ ^ 2 â‰¤ âˆ¥xâˆ¥ ^ 2
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] {S : set E} (hsâ‚ : Convex â„ S) (hsâ‚‚ : IsClosed S) : (â‹‚ (l : E â†’L[â„] â„), {x : E | âˆƒ (y : E) (h : y âˆˆ S), â‡‘l x â‰¤ â‡‘l y}) = S
{m : Type u_3} {N : Type u_4} [AddZeroClass m] [AddZeroClass N] (F : m â†’+ N) {x y : m} (h : x = y) : â‡‘F x = â‡‘F y
{D : set â„} (hD : Convex â„ D) (hDâ‚‚ : IsOpen D) {F : â„ â†’ â„} (hF' : DifferentiableOn â„ F D) (hF'' : DifferentiableOn â„ (deriv F) D) (hF''_nonneg : âˆ€ (x : â„), x âˆˆ D â†’ 0 â‰¤ deriv^[2] F x) : Convex_on â„ D F
(Î± : Type u_1) [TopologicalSpace Î±] [TopologicalSpace.IsSeparable_Space Î±] [PartialOrder Î±] : âˆƒ (S : set Î±), S.countable âˆ§ Dense S âˆ§ (âˆ€ (x : Î±), _IsBot x â†’ x âˆˆ S) âˆ§ âˆ€ (x : Î±), _top x â†’ x âˆˆ S
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [Add_cancel_CommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [HasScalar ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : strict_Convex_on ð•œ S F) (C : E) : strict_Convex_on ð•œ ((Î» (z : E), C + z) â»Â¹' S) (F âˆ˜ Î» (z : E), z + C)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) (F : v â‰ƒâ‚—áµ¢[â„] v) : _.oangle x y = hb.oangle (â‡‘(F.Symm) x) (â‡‘(F.Symm) y)
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] {F : J â¥¤ Profinite} (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) {Î± : Type u_1} (F : LocallyConstant â†¥(C.x) Î±) : âˆƒ (j : J) (g : LocallyConstant â†¥(F.obj j) Î±), F = LocallyConstant.comap â‡‘(C.Ï€.App j) g
{R : Type u_1} [CommRing R] (u v W : Fin 3 â†’ R) : Matrix.dot_Product u (â‡‘(â‡‘CrossProduct v) W) = Matrix.det ![u, v, W]
{t : â„} {g : â„ â†’ â„} (hg : Function.Periodic g t) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.MeasureSpace.Volume tâ‚ tâ‚‚) (hâ‚€ : 0 < âˆ« (x : â„) in 0..t, g x) (hT : 0 < t) : Filter.Tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) Filter.at_IsBot Filter.at_IsBot
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) (h : InnerProductGeometry.angle x y = Real.Pi / 2) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [Ring_hom_isometric Ïƒâ‚â‚‚] (x : E) : LipschitzWith âˆ¥xâˆ¥â‚Š (Î» (F : E â†’sl[Ïƒâ‚â‚‚] F), â‡‘F x)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (S : Submodule K v) : module.rank K â†¥S â‰¤ 1 â†” âˆƒ (vâ‚€ : v), S â‰¤ Submodule.Span K {vâ‚€}
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} (l : List m) : â‡‘clifford_Algebra.reverse (List.Map â‡‘(clifford_Algebra.Î¹ q) l).Prod = (List.Map â‡‘(clifford_Algebra.Î¹ q) l).reverse.Prod
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {P1 : P} (P2 : P) (hp1 : P1 âˆˆ S) : â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P2 -áµ¥ âŸ¨P1, hp1âŸ©) âˆˆ S.direction
{mâ‚€ : Type u_1} [MulZeroOneClass mâ‚€] (h : 0 = 1) (A : mâ‚€) : A = 0
{ð•‚ : Type u_6} [_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [NormedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace ð•‚ F'] {F : E' â†’ F'} {x : E'} (hF : ContDiff_at ð•‚ 1 F x) : âˆƒ (K : Nnreal) (t : set E') (h : t âˆˆ nhds x), LipschitzOnWith K F t
{h : Type u} [TopologicalSpace h] {Î± : Type u_5} [TopologicalSpace Î±] (e : LocalHomeomorph Î± h) (h : e.to_local_Equiv.Source = set.Univ) (G : StructureGroupoid h) [IsClosed_under_restriction G] : HasGroupoid Î± G
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A l' : Î±} {S : set Î±} (hl' : l' < A) : S âˆˆ nhds_within A (set.Iic A) â†” âˆƒ (l : Î±) (h : l âˆˆ set.Iio A), set.ioc l A âŠ† S
 : Filter.Tendsto Complex.Exp (Filter.comap Complex.re Filter.at_IsBot) (nhds 0)
(n : â„•) (x : â„) (hx : x â‰  0) : HasDerivAt (Î» (x : â„), Polynomial.Eval x (Exp_Neg_Inv_glue.P_aux n) * Real.Exp (-xâ»Â¹) / x ^ (2 * n)) (Polynomial.Eval x (Exp_Neg_Inv_glue.P_aux (n + 1)) * Real.Exp (-xâ»Â¹) / x ^ (2 * (n + 1))) x
{Î± : Type u} [PseudoEmetricSpace Î±] {Î´ : â„} (Î´_Pos : 0 < Î´) (E : set Î±) : Closure E âŠ† Metric.Thickening Î´ E
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} (h : HasInner.inner x y = 0) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
(L : List â„•) : L.tail.Sum = L.Sum - L.head
{Î± : Type u_1} {Î³ : Type u_2} [MeasurableSpace Î±] [AddMonoid Î³] {P : MeasureTheory.SimpleFunc Î± Î³ â†’ Prop} (h_ind : âˆ€ (C : Î³) {S : set Î±} (hs : Measurable_set S), P (MeasureTheory.SimpleFunc.piecewise S hs (MeasureTheory.SimpleFunc.Const Î± C) (MeasureTheory.SimpleFunc.Const Î± 0))) (h_Add : âˆ€ â¦ƒF g : MeasureTheory.SimpleFunc Î± Î³â¦„, Disjoint (Function.Support â‡‘F) (Function.Support â‡‘g) â†’ P F â†’ P g â†’ P (F + g)) (F : MeasureTheory.SimpleFunc Î± Î³) : P F
{Î± : Type u_1} [CommMonoid Î±] {Î² : Type u_2} [Fintype Î²] (S : set Î²) [Decidable_Pred (Î» (_x : Î²), _x âˆˆ S)] (F : Î² â†’ Î±) (g : â†¥S â†’ Î±) (W : âˆ€ (x : Î²) (h : x âˆˆ S), F x = g âŸ¨x, hâŸ©) (W' : âˆ€ (x : Î²), x âˆ‰ S â†’ F x = 1) : Finset.Univ.Prod F = Finset.Univ.Prod g
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {S : set Î±} {t : set Î²} {u : set Î³} (h : âˆ€ (A : Î±) (B : Î²) (C : Î³), g A B C = g' A B C) : set.image3 g S t u = set.image3 g' S t u
{Î± : Type u} {L : List (Î± Ã— Bool)} {x : Î±} {B : Bool} : free_Group.red ((x, B) :: L) List.Nil â†” free_Group.red L [(x, !B)]
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (e : LocalHomeomorph Î± Î²) {x : Î²} (h : x âˆˆ e.to_local_Equiv.Target) : Continuous_at â‡‘(e.Symm) x
{Î± : Type u_1} {Î² : Type u_2} [has_Add Î±] [Preorder Î±] [Preorder Î²] {F g : Î² â†’ Î±} [CovariantClass Î± Î± has_Add.Add has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] (hF : Monotone F) (hg : Monotone g) : Monotone (Î» (x : Î²), F x + g x)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) {r : â„} (hr : r â‰  0) : 2 â€¢ hb.oangle x (r â€¢ y) = 2 â€¢ hb.oangle x y
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î² â†’ Î³} (hF : Continuous F) : Continuous (Î» (x : Î± Ã— Î²), F x.Snd)
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] [UniformSpace Î²] {S : set Î±} {F : Î± â†’ Î²} (hs : IsCompact S) (hs' : IsSeparated S) (hF : Continuous_on F S) : uniform_Continuous_on F S
 : CategoryTheory.Faithful Compactum_to_CompHaus
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] [strict_Convex_Space â„ E] {x y z : E} {r : â„} (hx : x âˆˆ metric.IsClosed_ball z r) (hy : y âˆˆ metric.IsClosed_ball z r) (hne : x â‰  y) : IsOpen_Segment â„ x y âŠ† Metric.Ball z r
{n m : SimplexCategory {F : n âŸ¶ m} : CategoryTheory.Mono F â†” Function.Injective â‡‘(SimplexCategory.hom.to_order_hom F)
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R â†’+* S} {P : Polynomial S} (n : â„•) (h : P âˆˆ Polynomial.lifts F) : Polynomial.erase n P âˆˆ Polynomial.lifts F
{A B C : Prop} : A âˆ§ B âˆ¨ C â†” (A âˆ¨ C) âˆ§ (B âˆ¨ C)
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) : 0 = 1 â†” âˆ€ (x : Î±), â‡‘F x = 0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {Fâ‚‚ : ð•œ â†’ F} {Sâ‚‚ : set ð•œ} (hs : UniqueDiffOn ð•œ Sâ‚‚) : ContDiff_on ð•œ âŠ¤ Fâ‚‚ Sâ‚‚ â†” DifferentiableOn ð•œ Fâ‚‚ Sâ‚‚ âˆ§ ContDiff_on ð•œ âŠ¤ (deriv_within Fâ‚‚ Sâ‚‚) Sâ‚‚
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] [DecidableEq Î±] (S : Finset Î±) {F : Î± â†’ Î²} {A : Î±} (h : F A = 0) : (S.erase A).Sum (Î» (x : Î±), F x) = S.Sum (Î» (x : Î±), F x)
{n : â„•} {E : Type u_1} [NormedGroup E] {F g : (Fin n â†’ â„‚) â†’ E} {C : Fin n â†’ â„‚} {R : Fin n â†’ â„} (hF : TorusIntegrable F C R) (hg : TorusIntegrable g C R) : TorusIntegrable (F - g) C R
{R : Type u_1} {A : Type u_2} [AddZeroClass R] [AddZeroClass A] {P : Unitization R A â†’ Prop} (h : âˆ€ (r : R) (A : A), P (Unitization.inl_ r + â†‘A)) (x : Unitization R A) : P x
{R : Type u_3} {S : Type u_4} {A : Type u_5} [CommRing R] [CommRing S] [CommRing A] [Algebra R S] [Algebra S A] [Algebra R A] [IsScalarTower R S A] (hinj : Function.Injective â‡‘(Algebra_Map R S)) (A_alg : Algebra.IsAlgebraic R A) : Algebra.IsAlgebraic S A
{R : Type u} [CommRing R] (S : Submonoid R) (L : Type u) [CommRing L] [Algebra R L] [IsLocalization S L] (hS : S â‰¤ non_Zero_divisors R) : Cardinal.Mk R = Cardinal.Mk L
{Î± : Type u} [UniformSpace Î±] {S : set Î±} {C : set (set Î±)} (hs : IsCompact S) (hcâ‚ : âˆ€ (t : set Î±), t âˆˆ C â†’ IsOpen t) (hcâ‚‚ : S âŠ† â‹ƒâ‚€C) : âˆƒ (n : set (Î± Ã— Î±)) (h : n âˆˆ Uniformity Î±), âˆ€ (x : Î±), x âˆˆ S â†’ (âˆƒ (t : set Î±) (h : t âˆˆ C), âˆ€ (y : Î±), (x, y) âˆˆ n â†’ y âˆˆ t)
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B C : Î±} : B â‰¤ Aâ»Â¹ * C â†’ A * B â‰¤ C
{R : Type u_1} [CommRing R] {P : Ideal (Polynomial R)} (pB : P â‰  âŠ¥) (hP : âˆ€ (x : R), â‡‘Polynomial.C x âˆˆ P â†’ x = 0) : âˆƒ (P : Polynomial R), P âˆˆ P âˆ§ Polynomial.Map (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P)) P â‰  0
{m : Type u_1} [Monoid m] {x : m} : x âˆˆ Powers x
{m : Type u_1} [AddCommGroup m] [module â„ m] [Finite_dimensional â„ m] (q : QuadraticForm â„ m) (hQ : (â‡‘QuadraticForm.Associated q).nondegenerate) : âˆƒ (W : Fin (Finite_dimensional.finrank â„ m) â†’ â„), (âˆ€ (i : Fin (Finite_dimensional.finrank â„ m)), W i = -1 âˆ¨ W i = 1) âˆ§ q.Equivalent (QuadraticForm.weighted_Sum_squares â„ W)
{R : Type v} [CommRing R] {A : Matrix (Fin 0) (Fin 0) R} : A.det = 1
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type W} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (hG : CategoryTheory.CoverLifting J K G) (â„± : CategoryTheory.sheaf J A) : CategoryTheory.Presheaf.IsSheaf K ((CategoryTheory.ran G.Op).obj â„±.val)
 : (Î» (N : â„•), â†‘(â‡‘roth_number_Nat N)) =O[Filter.at_top] Î» (N : â„•), â†‘N
(z : UpperHalfPlane) : âˆƒ (g : Matrix.special_Linear_Group (Fin 2) â„¤), g â€¢ z âˆˆ modular_Group.Fd
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set â„} [IntervalIntegral.FTC_Filter B (nhds_within B S) (nhds_within B t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within B t) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds_within B t âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasDerivWithinAt (Î» (u : â„), âˆ« (x : â„) in A..u, F x) C S B
{R : Type u_1} {G : Type u_2} [CommRing R] [IsDomain R] [Group G] [Fintype G] (F : G â†’* R) (hF : F â‰  1) : Finset.Univ.Sum (Î» (g : G), â‡‘F g) = 0
{Î± : Type u_1} [MeasurableSpace Î±] [TopologicalSpace Î±] [Opens_MeasurableSpace Î±] {Î² : Type u_2} [TopologicalSpace Î²] [TopologicalSpace.pseudo_metrizable_Space Î²] [h : SecondCountableTopologyEither Î± Î²] {F : Î± â†’ Î²} (hF : Continuous F) : MeasureTheory.strongly_Measurable F
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B : Î±} (ha : A â‰¤ 1) (hb : B < 1) : A * B < 1
{Î± : Type u_1} [cancel_CommMonoid_with_Zero Î±] [Unique_factorization_Monoid Î±] [normalization_Monoid Î±] [DecidableEq Î±] {x : Î±} {n : â„•} : factorization (x ^ n) = n â€¢ factorization x
{A B : Ereal} : -A â‰¤ B â†” -B â‰¤ A
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] {mâ‚ : Type v} [AddCommGroup mâ‚] [module R mâ‚] (F : m â‰ƒâ‚—[R] mâ‚) (P : Submodule R m) : module.rank R â†¥(Submodule.Map â†‘F P) = module.rank R â†¥P
{K : Type u} [hring : CommRing K] [hdomain : IsDomain K] {P : Ratfunc K â†’ Prop} (x : Ratfunc K) (F : âˆ€ (P q : Polynomial K), q â‰  0 â†’ P (â‡‘(Algebra_Map (Polynomial K) (Ratfunc K)) P / â‡‘(Algebra_Map (Polynomial K) (Ratfunc K)) q)) : P x
{G : Type W} [TopologicalSpace G] [Group G] [topological_Group G] {K v : set G} (hK : IsCompact K) (hV : (Interior v).Nonempty) : âˆƒ (t : Finset G), K âŠ† â‹ƒ (g : G) (h : g âˆˆ t), (Î» (h : G), g * h) â»Â¹' v
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [TopologicalSpace Î²] (F : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (S : set Î±) [F.Ne_IsBot] {C : set Î²} (hcâ‚ : IsCompact C) (hcâ‚‚ : âˆƒ (v : set Ï„) (h : v âˆˆ F), Closure (set.image2 Ï• v S) âŠ† C) (hs : S.Nonempty) : (OmegaLimit F Ï• S).Nonempty
{Î± : Type u} {Î¹ : Type x} [PseudoEmetricSpace Î±] (F : Î¹ â†’ Function.End Î±) (K : Î¹ â†’ Nnreal) (h : âˆ€ (i : Î¹), LipschitzWith (K i) (F i)) (l : List Î¹) : LipschitzWith (List.Map K l).Prod (List.Map F l).Prod
{m : Type u_1} [AddMonoid m] (A : m) (u : AddUnits m) : IsAddUnit (A + â†‘u) â†” IsAddUnit A
{Î± : Type u_1} [CompleteLattice Î±] {k : Î±} (hk : CompleteLattice.IsCompact_element k) {S : set Î±} (hemp : S.Nonempty) (hdir : Directed_on has_LE.LE S) (hbelow : âˆ€ (x : Î±), x âˆˆ S â†’ x < k) : HasSup.Sup S < k
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {x Y : C} (F g : x âŸ¶ Y) (W : âˆ€ (x : â†¥x), â‡‘F x = â‡‘g x) : F = g
{Î± : Type u_1} {m : Type u_4} [AddCommMonoid m] (F : Î± â†’ m) {S t : Finset Î±} (h : S âŠ† t) : S.Sum (Î» (i : Î±), F i) = t.Sum (Î» (i : Î±), â†‘S.indicator F i)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) (i : Î¹) : â‡‘((S.erase i).weighted_vsub_of_point P (P i)) W = â‡‘(S.weighted_vsub_of_point P (P i)) W
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : InnerProductGeometry.angle x y = InnerProductGeometry.angle y x
{Î± : Type u_1} {Î² : Type u_2} {r : Setoid Î±} {F : Î± â†’ Î²} (h : Setoid.Ker F â‰¤ r) (hF : Function.Surjective F) : r.Map F = r.Map_of_surjective F h hF
(A : Cardinal) : A < 2 ^ A
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [Î  (n : Î²), Encodable (Î¹ n)] (S : set x) {l : Filter Î²} (r : Î² â†’ Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ set x) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), Emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, S âŠ† â‹ƒ (i : Î¹ n), t n i) (m : Ennreal â†’ Ennreal) : â‡‘(MeasureTheory.Measure.Mk_metric m) S â‰¤ l.liminf (Î» (n : Î²), âˆ‘' (i : Î¹ n), m (Emetric.diam (t n i)))
{g : Matrix.special_Linear_Group (Fin 2) â„¤} {z : UpperHalfPlane} (hz : z âˆˆ modular_Group.Fdo) (hg : g â€¢ z âˆˆ modular_Group.Fdo) : â†‘g 1 0 = 0
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), AddMonoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : _of_Fin_Add_order x) (i : Î·) : _of_Fin_Add_order (x i)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup vâ‚‚] [module k vâ‚‚] [AddTorsor vâ‚‚ Pâ‚‚] {P : Î¹ â†’ P} (hai : AffineIndependent k P) (F : P â†’áµƒ[k] Pâ‚‚) (hF : Function.Injective â‡‘F) : AffineIndependent k (â‡‘F âˆ˜ P)
{R : Type u_1} [CommRing R] (v W : Fin 3 â†’ R) : Matrix.dot_Product W (â‡‘(â‡‘CrossProduct v) W) = 0
{m : Type u_1} [has_Add m] {Î² : sort u_2} (C : Add_Con m) (F : m â†’ Î²) (h : âˆ€ (A B : m), â‡‘C A B â†’ F A = F B) (x : m) : Add_Con.Lift_on â†‘x F h = F x
 : strict_Convex_on â„ set.Univ Real.Exp
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [TopologicalSpace Î±] [UniformSpace Î²] (x : set (C(Î±, Î²) Ã— C(Î±, Î²))) : x âˆˆ Continuous_Map.IsCompact_convergence_Uniformity â†” âˆƒ (K : set Î±) (v : set (Î² Ã— Î²)) (hK : IsCompact K) (hV : v âˆˆ Uniformity Î²), {fg : C(Î±, Î²) Ã— C(Î±, Î²) | âˆ€ (x : Î±), x âˆˆ K â†’ (â‡‘(fg.fst) x, â‡‘(fg.Snd) x) âˆˆ v} âŠ† x
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Kâ‚ Kâ‚‚ : Submodule ð•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) : Kâ‚á—®á—® â‰¤ Kâ‚‚á—®á—®
{Î¹ : Type u_1} {Î± : Type u_3} [Preorder Î¹] [LinearOrder Î±] {u : Î¹ â†’ Î±} (h : Monotone u) (h : Â¬BddAbove (set.Range u)) : Filter.Tendsto u Filter.at_top Filter.at_top
(P : â„•) (G : Type u_1) [Group G] [Fact (Nat.Prime P)] [Fintype (Sylow P G)] : Fintype.Card (Sylow P G) â‰¡ 1 [Mod P]
{m : Type u_1} [has_Mul m] (C : Con m) {W x y z : m} : â‡‘C W x â†’ â‡‘C y z â†’ â‡‘C (W * y) (x * z)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Sâ‚ Sâ‚‚ : AffineSubspace k P} {P : P} (hâ‚ : P âˆˆ Sâ‚) (hâ‚‚ : P âˆˆ Sâ‚‚) : (Sâ‚ âŠ“ Sâ‚‚).direction = Sâ‚.direction âŠ“ Sâ‚‚.direction
{Î± : Type u} [AddCommGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B C : Î±} : A < B + C â†’ A - B < C
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î±] [DecidableEq Î²] (F : Î± â†’ Î²) (S : Multiset Î±) (hF : set.inj_on F {x : Î± | x âˆˆ S}) (x : Î±) (h : x âˆˆ S) : Multiset.count (F x) (Multiset.Map F S) = Multiset.count x S
 : â‡‘Linear_Equiv.det Complex.Conj_lie.to_Linear_Equiv = -1
{C : Type u} [CategoryTheory.Category C] {x Y Z : C} (F : x âŸ¶ Z) (g : Y âŸ¶ Z) [CategoryTheory.Limits.HasPullback F g] : CategoryTheory.Limits.HasPullback g F
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x : v} (hx : x â‰  0) (Î¸ : Real.Angle) : â‡‘(o.rotation Î¸) x = x â†” Î¸ = 0
{P n : â„•} : padic_val_Int P â†‘n = padic_val_Nat P n
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] {m' : Type v'} [AddCommGroup m'] [module R m'] (F : m â‰ƒâ‚—[R] m') : (module.rank R m).Lift = (module.rank R m').Lift
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {jâ‚ jâ‚‚ kâ‚ kâ‚‚ : C} (Fâ‚ : jâ‚ âŸ¶ kâ‚) (gâ‚ : jâ‚ âŸ¶ kâ‚‚) (Fâ‚‚ : jâ‚‚ âŸ¶ kâ‚) (gâ‚‚ : jâ‚‚ âŸ¶ kâ‚‚) : âˆƒ (S : C) (Î± : kâ‚ âŸ¶ S) (Î² : kâ‚‚ âŸ¶ S), Fâ‚ â‰« Î± = gâ‚ â‰« Î² âˆ§ Fâ‚‚ â‰« Î± = gâ‚‚ â‰« Î²
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : Aâ»Â¹ â‰¤ Bâ»Â¹ â†” B â‰¤ A
{C : CategoryTheory.groupoid} : ðŸ­ â†¥C = ðŸ™ C
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x : â†¥(non_Zero_divisors R)) : 0 < v.Int_Valuation_def â†‘x
{m : Type u_1} [MulOneClass m] (S : Submonoid m) : S = âŠ¥ âˆ¨ âˆƒ (x : m) (h : x âˆˆ S), x â‰  1
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S : set Î±} (h : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) â‰  1) : âˆƒ (x : Î±) (h : x âˆˆ S), F x â‰  1
{Î¹ : Type u_1} {Î± : Type u_2} {S : Î¹ â†’ set Î±} (hs : IndexedPartition S) (x : hs.Quotient) : hs.Proj (â‡‘(hs.out) x) = x
{Î± : Type u} [comm_Group Î±] : _Group_hom has_Inv.Inv
{Î± : Type u} [UniformSpace Î±] {S : set Î±} (h : TotallyBounded S) : TotallyBounded (Closure S)
 : Filter.Tendsto (Î» (x : â„), x ^ ((-1) / x)) Filter.at_top (nhds 1)
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] [Nonempty x] (F : bounded_Continuous_Function x â„) {e : x â†’ Y} (hE : IsClosed_Embedding e) : âˆƒ (g : bounded_Continuous_Function Y â„), (âˆ€ (y : Y), âˆƒ (xâ‚ xâ‚‚ : x), â‡‘g y âˆˆ set.icc (â‡‘F xâ‚) (â‡‘F xâ‚‚)) âˆ§ â‡‘g âˆ˜ e = â‡‘F
(S : â„) : (Î» (x : â„), Real.Exp (-x) * x ^ S) =o[Filter.at_top] Î» (x : â„), Real.Exp (-(1 / 2) * x)
{Î± : Type u} [TopologicalSpace Î±] {F : Filter Î±} : IsClosed {x : Î± | ClusterPt x F}
{Î± : Type u} [Preorder Î±] {A B : Î±} (h : A â‰¤ B) : Â¬B < A
{F : â„• â†’ â„} (hfa : Monotone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) : âˆƒ (l : â„), Filter.Tendsto (Î» (n : â„•), (Finset.Range (n + 1)).Sum (Î» (i : â„•), (-1) ^ i * F i)) Filter.at_top (nhds l)
{Î² : Type u} {Î± : Type v} {S : Finset Î±} {A : Î±} {F : Î± â†’ Î²} [AddCommMonoid Î²] [DecidableEq Î±] (h : F A = 0) : (HasInsert.Insert A S).Sum (Î» (x : Î±), F x) = S.Sum (Î» (x : Î±), F x)
{Î± : Type u} [Preorder Î±] {A : Î±} {S t P : set Î±} (hs : IsGlb S A) (hp : IsGlb P A) (hst : S âŠ† t) (htp : t âŠ† P) : IsGlb t A
{Î± : Type u_1} {Î´ : Type u_5} [TopologicalSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±] [MeasurableSpace Î´] [complete_LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {F : â„• â†’ Î´ â†’ Î±} (hF : âˆ€ (i : â„•), Measurable (F i)) : Measurable (Î» (x : Î´), Filter.at_top.liminf (Î» (i : â„•), F i x))
{Î± : Type u} {F g : Î± â†’ Î±} {x : Î±} (hF : Function.IsFixedPt F x) (hg : Function.IsFixedPt g x) : Function.IsFixedPt (F âˆ˜ g) x
(B m : â„•) (hb : 2 â‰¤ B) : m â‰  0 â†’ B ^ (B.digits m).length â‰¤ B * m
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedSpace ð•œ E] [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ G} {C : â„} {S : set E} {x y : E} (hF : âˆ€ (x : E), x âˆˆ S â†’ Differentiable_at ð•œ F x) (bound : âˆ€ (x : E), x âˆˆ S â†’ âˆ¥fderiv ð•œ F xâˆ¥ â‰¤ C) (hs : Convex â„ S) (xs : x âˆˆ S) (ys : y âˆˆ S) : âˆ¥F y - F xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{F : â„ â†’ â„} {A : â„} (h : IsLocalExtr F A) : deriv F A = 0
{G : Type u_1} {h : Type u_2} [Group G] [Group h] [IsCyclic h] (F : G â†’* h) (hF : F.Ker â‰¤ Subgroup.Center G) (A B : G) : A * B = B * A
{Î± : Type u} [PseudoEmetricSpace Î±] (Î´ : â„) {Eâ‚ Eâ‚‚ : set Î±} (h : Eâ‚ âŠ† Eâ‚‚) : Metric.Thickening Î´ Eâ‚ âŠ† Metric.Thickening Î´ Eâ‚‚
{R : Type uâ‚} {L : Type uâ‚‚} {m : Type uâ‚„} [CommRing R] [lie_Ring L] [lie_Algebra R L] [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] [IsNoetherian R L] : lie_module.IsNilpotent R L m â†” âˆ€ (x : L), IsNilpotent (â‡‘(lie_module.to_endomorphism R L m) x)
{Î¹ : Type u} {x : Type v} [TopologicalSpace x] [ParacompactSpace x] (u : Î¹ â†’ set x) (uo : âˆ€ (A : Î¹), IsOpen (u A)) (uc : (â‹ƒ (i : Î¹), u i) = set.Univ) : âˆƒ (v : Î¹ â†’ set x), (âˆ€ (A : Î¹), IsOpen (v A)) âˆ§ (â‹ƒ (i : Î¹), v i) = set.Univ âˆ§ locally_Finite v âˆ§ âˆ€ (A : Î¹), v A âŠ† u A
(n : â„•) : LinearIndependent â„š (Î» (Î½ : Fin (n + 1)), bernstein_Polynomial â„š n â†‘Î½)
{m : Type u_1} [AddMonoid m] {Î¹ : sort u_2} {S : Î¹ â†’ set m} (h : âˆ€ (y : Î¹), _Add_Submonoid (S y)) : _Add_Submonoid (set.Inter S)
{Î± : Type u_1} [CompleteLattice Î±] {A : Î±} {S : set Î±} : HasInf.Inf S âŠ” A â‰¤ â¨… (B : Î±) (h : B âˆˆ S), B âŠ” A
{m : Type u_3} {N : Type u_4} [has_One m] [has_One N] {F g : One_hom m N} : F = g â†” âˆ€ (x : m), â‡‘F x = â‡‘g x
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (Pâ‚ Pâ‚‚ : P) : HasDist.dist Pâ‚ (â‡‘(EuclideanGeometry.reflection S) Pâ‚‚) = HasDist.dist (â‡‘(EuclideanGeometry.reflection S) Pâ‚) Pâ‚‚
{Î¹ : sort u_1} {Î¹' : sort u_2} {Î± : Type u_3} [CompleteLattice Î±] {S : Î¹ â†’ Î±} (hs : CompleteLattice.Independent S) (F : Î¹' â†’ Î¹) (hF : Function.Injective F) : CompleteLattice.Independent (S âˆ˜ F)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [Linear_ordered_Field ð•œ] [AddCommGroup E] [Linear_ordered_AddCommGroup Î²] [module ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : ConcaveOn ð•œ (â‡‘(Convex_hull ð•œ) S) F) {x : E} (hx : x âˆˆ â‡‘(Convex_hull ð•œ) S) : âˆƒ (y : E) (h : y âˆˆ S), F y â‰¤ F x
 : set.Unbounded has_LT.LT {B : Ordinal | B.Card.Ord = B}
{Î± : Type u_1} {R : Type u_2} {l : Filter Î±} {F : Î± â†’ R} {r : R} [Linear_ordered_Ring R] [Archimedean R] (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (Î» (x : Î±), F x * r) l Filter.at_IsBot
{z : UpperHalfPlane} (h : â‡‘Complex.norm_sq â†‘z < 1) : z.im < (modular_Group.S â€¢ z).im
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [OrderedSemiring ð•œ] [AddCommGroup E] [module ð•œ E] {Î¹' : Type u_4} (F : Î¹' â†ª Î¹) {P : Î¹ â†’ E} (hc : Convex_Independent ð•œ P) : Convex_Independent ð•œ (P âˆ˜ â‡‘F)
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] (F : â„• â†’ R) (g : â„• â†’ m) {m n : â„•} (hmn : m < n) : (Finset.Ico m n).Sum (Î» (i : â„•), F i â€¢ g i) = F (n - 1) â€¢ (Finset.Range n).Sum (Î» (i : â„•), g i) - F m â€¢ (Finset.Range m).Sum (Î» (i : â„•), g i) - (Finset.Ico m (n - 1)).Sum (Î» (i : â„•), (F (i + 1) - F i) â€¢ (Finset.Range (i + 1)).Sum (Î» (i : â„•), g i))
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] {S t : set E} (hsâ‚ : Convex â„ S) (hsâ‚‚ : IsCompact S) (htâ‚ : Convex â„ t) (htâ‚‚ : IsClosed t) (disj : Disjoint S t) : âˆƒ (F : E â†’L[â„] â„) (u v : â„), (âˆ€ (A : E), A âˆˆ S â†’ â‡‘F A < u) âˆ§ u < v âˆ§ âˆ€ (B : E), B âˆˆ t â†’ v < â‡‘F B
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] {A : Î±} : Aâ»Â¹ < 1 â†” 1 < A
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : Dense (Closure S) â†” Dense S
{m : Type u_1} {F : Type u_2} [Monoid F] (C : F â†’ m â†’ m) (h1 : C 1 = Id) (HMul : âˆ€ (F g : F), C (F * g) = C F âˆ˜ C g) (F : F) (n : â„•) : C (F ^ n) = (C F^[n])
{Î± : Type u_1} {Î² : Type u_2} {e e' : local_Equiv Î± Î²} (h : âˆ€ (x : Î±), â‡‘e x = â‡‘e' x) (hsymm : âˆ€ (x : Î²), â‡‘(e.Symm) x = â‡‘(e'.Symm) x) (hs : e.Source = e'.Source) : e = e'
{ð•œ : Type u_1} {E : Type u_4} [NormedGroup E] [nondiscrete_NormedField ð•œ] [NormedSpace ð•œ E] [Nontrivial E] : âˆ¥Continuous_LinearMap.Id ð•œ Eâˆ¥ = 1
{F : â„ â†’ â„} (hF : Differentiable â„ F) (hF'_Mono : Monotone (deriv F)) : Convex_on â„ set.Univ F
{Î± : Type u_1} {Î² : Type u_2} {Gâ‚€ : Type u_3} [Group_with_Zero Gâ‚€] [TopologicalSpace Gâ‚€] [has_Continuous_Invâ‚€ Gâ‚€] [has_Continuous_Mul Gâ‚€] [TopologicalSpace Î±] [TopologicalSpace Î²] {F g : Î± â†’ Gâ‚€} (h : Î± â†’ Gâ‚€ â†’ Î²) (hF : Continuous F) (hg : Continuous g) (hH : âˆ€ (A : Î±), g A â‰  0 â†’ Continuous_at â†¿h (A, F A / g A)) (h2h : âˆ€ (A : Î±), g A = 0 â†’ Filter.Tendsto â†¿h ((nhds A).Prod âŠ¤) (nhds (h A 0))) : Continuous (Î» (x : Î±), h x (F x / g x))
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A : Î±} : A < 0 â†’ 0 < -A
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {C : â„} {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : (âˆ€á¶  (x : Î±) in l, âˆ¥F xâˆ¥ â‰¤ C * âˆ¥g xâˆ¥) â†’ Asymptotics._O_with C l F g
(P : â„•) [Fact (Nat.Prime P)] {A : â„¤} (ha0 : â†‘A â‰  0) : Zmod.legendre_Sym P A = 1 â†” IsSquare â†‘A
(ð•œ : Type u_1) [nondiscrete_NormedField ð•œ] {E : Type u_2} [semi_NormedGroup E] [NormedSpace ð•œ E] [ProperSpace ð•œ] {S : set E} (S_nhd : S âˆˆ nhds 0) : IsCompact (WeakDual.Polar ð•œ S)
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] {F : x â†’ Y} [SequentialSpace x] : Continuous F â†” Seq_Continuous F
{Î± : Type u} [Preorder Î±] {A B C : Î±} (hab : A = B) (hbc : B â‰¤ C) : A â‰¤ C
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {C : â„} {F : â„‚ â†’ E} {z : â„‚} (hD : Diff_Cont_on_cl â„‚ F (set.ioi 0 Ã—â„‚ set.Iio 0)) (hB : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.ioi 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥F â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥F (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz_re : 0 â‰¤ z.re) (hz_im : z.im â‰¤ 0) : âˆ¥F zâˆ¥ â‰¤ C
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (Î¸ : Real.Angle) : (-o).rotation Î¸ = o.rotation (-Î¸)
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] : omega_complete_PartialOrder.Continuous' Coe
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {P : Filter Î¹} {C : Î²} : Filter.Tendsto â†¿F (P.Prod âŠ¤) (nhds C) â†” TendstoUniformly F (Î» (_x : Î±), C) P
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hi : Irreflexive r) {S : Multiset Î±} : (âˆ€ (A : Î±), A âˆˆ S â†’ Acc (Relation.CutExpand r) {A}) â†’ Acc (Relation.CutExpand r) S
{S : set Ordinal} (o : Ordinal) : Ordinal.enum_Ord S o = HasInf.Inf (S âˆ© {B : Ordinal | âˆ€ (C : Ordinal), C < o â†’ Ordinal.enum_Ord S C < B})
(n : â„•) : Finset.Univ.Sum (Î» (i : Affine.Simplex.points_with_circumcenter_Index n), Affine.Simplex.circumcenter_weights_with_circumcenter n i) = 1
{Î± : Type u} [PseudoEmetricSpace Î±] (E : set Î±) {Î´ : â„} : Frontier (Metric.Cthickening Î´ E) âŠ† {x : Î± | Emetric.Inf_edist x E = Ennreal.of_Real Î´}
(F F' : â„ â†’ â„) {A B : â„} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfI : F A = F B) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivAt F (F' x) x) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), F' C = 0
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {F' : E â†’L[â„] â„} (h : IsLocalMax F A) (hF : HasFderivAt F F' A) : F' = 0
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [TopologicalSpace Î±] [UniformSpace Î²] {K : set Î±} {v : set (Î² Ã— Î²)} (F : C(Î±, Î²)) (hV : v âˆˆ Uniformity Î²) : âˆƒ (v' : set (Î² Ã— Î²)) (h : v' âˆˆ Uniformity Î²), v' âŠ† v âˆ§ âˆ€ (g : C(Î±, Î²)), g âˆˆ Continuous_Map.IsCompact_conv_nhd K v' F â†’ Continuous_Map.IsCompact_conv_nhd K v' g âŠ† Continuous_Map.IsCompact_conv_nhd K v F
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {x : C} {S : CategoryTheory.Sieve x} (h : Jâ‚.IsClosed S) {Y : C} (F : Y âŸ¶ x) : Jâ‚.Covers S F â†” â‡‘S F
 : Real.sin (Real.Pi / 3) = Real.sqrt 3 / 2
{x : Compactum} (F : Ultrafilter â†¥x) : F.lim = x.str F
(P : â„•) (q : â„š) : padic_norm P (-q) = padic_norm P q
{ð•œ : Type u_1} {E : Type u_3} [OrderedSemiring ð•œ] [TopologicalSpace E] [Add_cancel_CommMonoid E] [has_Continuous_Add E] [module ð•œ E] {S : set E} (hs : strict_Convex ð•œ S) (z : E) : strict_Convex ð•œ ((Î» (x : E), z + x) â»Â¹' S)
{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„¤) : m â‰¤ n â†’ P n
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.Finite_presentation R A â†” âˆƒ (Î¹ : Type u_2) (_x : Fintype Î¹) (F : mv_Polynomial Î¹ R â†’â‚[R] A), Function.Surjective â‡‘F âˆ§ F.to_Ring_hom.Ker.fg
{n : â„•} [Fact (0 < n)] (x : (Zmod n)Ë£) : x ^ n.Totient = 1
{Î³ : Type W} [LinearOrder Î³] {A B : Î³} {S t : set Î³} (ha : IsLeast S A) (hb : IsLeast t B) : IsLeast (S âˆª t) (LinearOrder.min A B)
{R : Type u_1} {m : Type u_3} [Monoid_with_Zero R] [has_Zero m] [MulAction_with_Zero R m] : Â¬IsSmulRegular m 0 â†” Nontrivial m
{R : Type u_4} [Linear_ordered_CommRing R] (A B : R) : 2 * A * B â‰¤ A ^ 2 + B ^ 2
{Î± : Type u} [TopologicalSpace Î±] : TotallyDisconnectedSpace Î± â†” âˆ€ (x : Î±), ConnectedComponent x = {x}
{E : Type u_4} {F : Type u_5} [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] [NormedGroup F] [NormedSpace â„ F] [Finite_dimensional â„ F] {F : E â†’ F} (h : ContDiff â„ 1 F) (hEF : Finite_dimensional.finrank â„ E < Finite_dimensional.finrank â„ F) : Dense (set.Range F)á¶œ
{F : Type u_2} [NormedGroup F] [NormedSpace â„ F] {x y : F} (hx : x â‰  0) (hy : y â‰  0) : SameRay â„ x y â†’ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (P : P) : P âˆ‰ âŠ¥
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] [Fintype m] [DecidableEq m] (A : Matrix m n Î±) (B : Matrix n m Î±) : (A.Mul B + 1).det = (B.Mul A + 1).det
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) : K âŠ“ Ká—® = âŠ¥
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {F : Î± â†’ Î²} (hF : _AddGroup_hom F) : F 0 = 0
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} (hF' : DenseRange F) (hF : Continuous F) {S : set Î±} (hs : Dense S) {t : set Î²} (ht : set.maps_to F S t) : Dense t
(m N : â„•) : â‡‘roth_number_Nat (m + N) â‰¤ â‡‘roth_number_Nat m + â‡‘roth_number_Nat N
{E : Type u_4} [NormedGroup E] [NormedSpace â„ E] {B : â„} {F : â„• â†’ â„} {z : â„• â†’ E} (hfa : Antitone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) (hzb : âˆ€ (n : â„•), âˆ¥(Finset.Range n).Sum (Î» (i : â„•), z i)âˆ¥ â‰¤ B) : Cauchy_Seq (Î» (n : â„•), (Finset.Range (n + 1)).Sum (Î» (i : â„•), F i â€¢ z i))
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} (h : S âŠ† t) : Emetric.diam S â‰¤ Emetric.diam t
(m : â„¤) : Convex_on â„ (set.ioi 0) (Î» (x : â„), x ^ m)
{Î± : Type u_1} [Add_Semigroup Î±] [PartialOrder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] [ContravariantClass Î± Î± has_Add.Add has_LE.LE] [ContravariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B C D : Î±} (hac : A â‰¤ C) (hbd : B â‰¤ D) : A + B = C + D â†” A = C âˆ§ B = D
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} (h : (S âˆ© t).Nonempty) : Metric.diam (S âˆª t) â‰¤ Metric.diam S + Metric.diam t
{Î± : Type u_1} [CommMonoid Î±] (F : â„• â†’ Î±) (n : â„•) : Finset.Univ.Prod (Î» (i : Fin n), F â†‘i) = (Finset.Range n).Prod (Î» (i : â„•), F i)
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] [Finite : Finite_dimensional K L] : Algebra.IsAlgebraic K L
(Î± : Type u_1) [Fintype Î±] {R : Type u_2} [CommSemiring R] (A B : R) : Finset.Univ.Sum (Î» (S : Finset Î±), A ^ S.Card * B ^ (Fintype.Card Î± - S.Card)) = (A + B) ^ Fintype.Card Î±
(n k : â„•) : (n ^ k).factorization = k â€¢ n.factorization
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [DecidableEq Î±] (h : free_Group.reduce Lâ‚ = free_Group.reduce Lâ‚‚) : free_Group.Mk Lâ‚ = free_Group.Mk Lâ‚‚
{m : Type u_3} [Monoid m] [Inhabited m] (l : List m) (h : l â‰  List.Nil) : l.head * l.tail.Prod = l.Prod
{Î± : Type u} [Preorder Î±] {F : â„• â†’ Î±} (hF : Monotone F) (n : â„•) {x : Î±} (h1 : F n < x) (h2 : x < F (n + 1)) (A : â„•) : F A â‰  x
{m : Type u_1} {N : Type u_2} [MulOneClass m] [MulOneClass N] (h : m â‰ƒ* N) : â‡‘h 1 = 1
(R : Type u_1) [CommRing R] [IsDomain R] : Polynomial.cyclotomic' 0 R = 1
{Î± : Type u} {l : List Î±} (hn : l.Nodup) : l.cyclic_permutations.Nodup
{ð•‚ : Type u_1} [_R_or_C ð•‚] : HasStrictDerivAt (Exp ð•‚) 1 0
{Î± : Type u_1} {S : Finset Î±} {F : Î± â†’ Ennreal} : S.Sum (Î» (A : Î±), F A) < âŠ¤ â†” âˆ€ (A : Î±), A âˆˆ S â†’ F A < âŠ¤
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup vâ‚‚] [module k vâ‚‚] [AddTorsor vâ‚‚ Pâ‚‚] {P : Î¹ â†’ P} (F : P â†’áµƒ[k] Pâ‚‚) (hF : Function.Injective â‡‘F) : AffineIndependent k (â‡‘F âˆ˜ P) â†” AffineIndependent k P
{x : â„} (hx : Liouville x) (P : â„) : LiouvilleWith P x
{n : Type u_1} {ð•œ : Type u_3} [Field ð•œ] [DecidableEq n] [Fintype n] (m : Matrix n n ð•œ) : âˆƒ (L L' : List (Matrix.TransvectionStruct n ð•œ)) (D : n â†’ ð•œ), m = ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul (Matrix.Diagonal D)).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod
(K : Type u) (v : Type v) [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] : â†‘(Finite_dimensional.finrank K v) = module.rank K v
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {r : Setoid Î²} : Setoid.comap F r = Setoid.Ker (Quotient.Mk âˆ˜ F)
(x : â„) : Summable (Î» (n : â„•), x ^ n / â†‘(n.factorial))
{Î± : Type u} [PseudoMetricSpace Î±] (S : set Î±) : uniform_Continuous (Î» (x : Î±), metric.Inf_nndist x S)
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] : Submodule.torsion R â†¥(Submodule.torsion R m) = âŠ¤
{Î¹ : Type u} {Î± : Type v} [DecidableEq Î±] (t : Î¹ â†’ Finset Î±) : (âˆ€ (S : Finset Î¹), S.Card â‰¤ (S.bUnion t).Card) â†” âˆƒ (F : Î¹ â†’ Î±), Function.Injective F âˆ§ âˆ€ (x : Î¹), F x âˆˆ t x
{n : â„•} (A B : Finset (Fin n)) : (Finset.image (Î» (i : Fin n), â†‘i) A).to_colex â‰¤ (Finset.image (Î» (i : Fin n), â†‘i) B).to_colex â†” A.to_colex â‰¤ B.to_colex
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F â‰  2) (A : FË£) : IsSquare A â†” A ^ (Fintype.Card F / 2) = 1
{G : Type u} {y : G} [Monoid G] {x : G} (h : Commute x y) (hx : _of_Fin_order x) (hy : _of_Fin_order y) : _of_Fin_order (x * y)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds B âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasDerivAt (Î» (u : â„), âˆ« (x : â„) in A..u, F x) C B
{m : Type u} [div_Inv_Monoid m] (x : m) (z : â„¤) : Mul_Opposite.Op (x ^ z) = Mul_Opposite.Op x ^ z
{x Y : Type u} (F : x âŸ¶ Y) : CategoryTheory.Epi F â†” Function.Surjective F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} (n : â„•) (hs : IsOpen S) : set.Eq_on (iterated_fderiv_within ð•œ n F S) (iterated_fderiv ð•œ n F) S
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] {i : D.to_GlueData.J} (U : TopologicalSpace.Opens â†¥((D.to_GlueData.U i).carrier)) : âˆƒ (Eq_1 : Opposite.Op U = Opposite.Op ((TopologicalSpace.Opens.Map (CategoryTheory.Limits.ColimitÎ¹ D.to_GlueData.Diagram.multispan (Opposite.Unop (Opposite.Op (CategoryTheory.Limits.WalkingMultispan.Right i)))).Base).obj (_.Functor.obj U))), D.Î¹_Inv_App U â‰« D.Diagram_over_IsOpen_Ï€ U i = (D.to_GlueData.U i).presheaf.Map (CategoryTheory.Eq_to_hom Eq_1)
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} : IsMinOn F S A â†’ IsMaxOn (â‡‘order_dual.to_dual âˆ˜ F) S A
{L : FirstOrder.Language} {m : Type W} {N : Type W'} [L.structure m] [L.structure N] {P : Type u_1} [L.structure P] {q : Type u_2} [L.structure q] (F : L.Equiv m N) (g : L.Equiv N P) (h : L.Equiv P q) : (h.Comp g).Comp F = h.Comp (g.Comp F)
{F : â„‚ â†’ â„‚} {C : â„‚} {Râ‚ Râ‚‚ : â„} (hD : DifferentiableOn â„‚ F (Metric.Ball C Râ‚)) (h_maps : set.maps_to F (Metric.Ball C Râ‚) (Metric.Ball (F C) Râ‚‚)) (hâ‚€ : 0 < Râ‚) : Complex.Abs (deriv F C) â‰¤ Râ‚‚ / Râ‚
(n : â„•+) (K : Type W) (L : Type z) [Field K] [Field L] [Algebra K L] [Ne_Zero â†‘â†‘n] [IsCyclotomicExtension {n} K L] : Polynomial._splitting_Field K L (Polynomial.x ^ â†‘n - 1)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {n : WithTop â„•} {P : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpTo n F P) (hn : 1 â‰¤ n) (x : E) : HasFderivAt F (â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (P x 1)) x
{n : â„•} : n.factorization.Support = n.Factors.to_Finset
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (ð•œ : Type u_3) [Field ð•œ] [_alg_IsClosed ð•œ] [CategoryTheory.Linear ð•œ C] [CategoryTheory.Limits.HasKernels C] (x Y : C) [Finite_dimensional ð•œ (x âŸ¶ x)] [CategoryTheory.Simple x] [CategoryTheory.Simple Y] : Finite_dimensional.finrank ð•œ (x âŸ¶ Y) â‰¤ 1
(A : Zmod 4) : â‡‘Zmod.Ï‡â‚„ A = 0 âˆ¨ â‡‘Zmod.Ï‡â‚„ A = 1 âˆ¨ â‡‘Zmod.Ï‡â‚„ A = -1
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [IsAntisymm Î± r] {A B : Î±} : r A B â†’ r B A â†’ A = B
{R : Type uâ‚} [CommSemiring R] (A B : R) : (A + B) ^ 2 = A ^ 2 + 2 * A * B + B ^ 2
(n : â„•) (R : Type u_1) [CommRing R] [IsDomain R] : (Polynomial.cyclotomic' n R).monic
(R : Type u_1) {m : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid m] [module R m] (S : set m) [Semiring S] [HasScalar R S] [module S m] [IsScalarTower R S m] : Submodule.Span S â†‘(Submodule.Span R S) = Submodule.Span S S
{K : Type u_8} {v : Type u_11} [Field K] [AddCommGroup v] [module K v] {B : v â†’â‚—[K] v â†’â‚—[K] K} {x : v} (hx : Â¬B.IsOrtho x x) : _IsCompl (Submodule.Span K {x}) ((Submodule.Span K {x}).Orthogonal_bilin B)
{R : Type u_1} {m : Type u_2} {mâ‚‚ : Type u_3} [TopologicalSpace m] [TopologicalSpace mâ‚‚] [Semiring R] [AddCommMonoid mâ‚‚] [module R mâ‚‚] [AddCommMonoid m] [module R m] (F : m â†’L[R] mâ‚‚) (h : Â¬âˆƒ (e' : m â‰ƒL[R] mâ‚‚), â†‘e' = F) : F.Inverse = 0
(P : â„•) [Fact (Nat.Prime P)] (A : â„¤) : Zmod.legendre_Sym P A = Zmod.legendre_Sym P (A % â†‘P)
(R : Type uâ‚) {L : Type uâ‚‚} [CommRing R] [lie_Ring L] [lie_Algebra R L] {A : Type uâ‚ƒ} [Ring A] [Algebra R A] {gâ‚ gâ‚‚ : universal_enveloping_Algebra R L â†’â‚[R] A} (h : â†‘gâ‚.Comp (universal_enveloping_Algebra.Î¹ R) = â†‘gâ‚‚.Comp (universal_enveloping_Algebra.Î¹ R)) : gâ‚ = gâ‚‚
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F g : ð•œ â†’ ð•œ} {F' A : ð•œ} (hg : Continuous_at g A) (hF : HasStrictDerivAt F F' (g A)) (hF' : F' â‰  0) (hfg : âˆ€á¶  (y : ð•œ) in nhds A, F (g y) = y) : HasStrictDerivAt g F'â»Â¹ A
(K : Type u) [DivisionRing K] : Finite_dimensional.finrank K K = 1
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {Dâ‚ Dâ‚‚ : â„} (h : Dâ‚ < Dâ‚‚) (S : set x) : â‡‘(MeasureTheory.Measure.hausdorff_measure Dâ‚‚) S = 0 âˆ¨ â‡‘(MeasureTheory.Measure.hausdorff_measure Dâ‚) S = âŠ¤
{F : Type u_3} [InnerProductSpace â„ F] {x : F} {r : â„} (hx : x â‰  0) (hr : 0 < r) : HasInner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
{R : Type uâ‚} [Linear_ordered_Ring R] {A : R} (h : -1 â‰¤ A) (n : â„•) : 1 + â†‘n * (A - 1) â‰¤ A ^ n
{Î± : Type u} {Î² : Type v} [AddZeroClass Î±] [AddGroup Î²] {F : Î± â†’ Î²} (hF : _Add_hom F) : _AddMonoid_hom F
{Î± : Type u_1} {Î² : Type u_2} [HasMem Î± Î²] {S : Î²} {A B : Î±} : A âˆˆ S â†’ B âˆ‰ S â†’ A â‰  B
{Î± : Type u} [Preorder Î±] {F : â„• â†’ Î±} (hF : Antitone F) (n : â„•) {x : Î±} (h1 : F (n + 1) < x) (h2 : x < F n) (A : â„•) : F A â‰  x
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) : CategoryTheory.Presieve._sheaf Jâ‚ (CategoryTheory.Functor.IsClosed_sieves Jâ‚)
(P : â„•) {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime P)] [CommRing R] [CommRing S] (F : R â†’+* S) (r : R) : â‡‘(witt_Vector.Map F) (â‡‘(witt_Vector.teichmuller P) r) = â‡‘(witt_Vector.teichmuller P) (â‡‘F r)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (Pâ‚‚ : Î¹ â†’ P) (Pâ‚ : P) (h : S.Sum (Î» (i : Î¹), W i) = 1) : S.Sum (Î» (i : Î¹), W i â€¢ (Pâ‚ -áµ¥ Pâ‚‚ i)) = Pâ‚ -áµ¥ â‡‘(S.affine_combination Pâ‚‚) W
{r n : â„•} (h : r < n / 2) : n.choose r â‰¤ n.choose (r + 1)
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [Nontrivial k] {P1 : P} {P : Î¹ â†’ P} : P1 âˆˆ affine_Span k (set.Range P) â†” âˆƒ (S : Finset Î¹) (W : Î¹ â†’ k) (hw : S.Sum (Î» (i : Î¹), W i) = 1), P1 = â‡‘(S.affine_combination P) W
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ F} {x : E} {n : WithTop â„•} (g : F â†’L[ð•œ] G) (hF : ContDiff_at ð•œ n F x) : ContDiff_at ð•œ n (â‡‘g âˆ˜ F) x
{Î± : Type u_1} [DecidableEq Î±] {S t : Finset Î±} (h : S âŠ† t) : (Finset.Ioo S t).Card = 2 ^ (t.Card - S.Card) - 2
{R : Type u} [Ring R] [RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {Î¹ : Type u_1} [Fintype Î¹] (B : Basis Î¹ R m) {W : set m} [Fintype â†¥W] (S : Submodule.Span R W = âŠ¤) : Fintype.Card Î¹ â‰¤ Fintype.Card â†¥W
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : E â†’ G} (hF : ContDiff ð•œ n F) : ContDiff ð•œ n (Î» (x : E Ã— F), F x.fst)
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} : (GeneralizedContinuedFraction.Int_fract_pair.Seq1 v).fst = GeneralizedContinuedFraction.Int_fract_pair.of v
{Î± : Type u_1} [DecidableEq Î±] (S : Finset Î±) : (Finset.image Quotient.Mk S.diag).Card = S.Card
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {n : â„•} : iterated_fderiv_within ð•œ (n + 1) F S = â‡‘(Continuous_multilinear_Curry_Left_Equiv ð•œ (Î» (i : Fin (n + 1)), E) F) âˆ˜ fderiv_within ð•œ (iterated_fderiv_within ð•œ n F S) S
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B C : Î±} : A < C - B â†’ A + B < C
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {S : Submodule K v} (h : Finite_dimensional.finrank K â†¥S = Finite_dimensional.finrank K v) : S = âŠ¤
{C : Type uâ‚} [CategoryTheory.Category C] {x : C} (P : Cáµ’áµ– â¥¤ Type W) : CategoryTheory.Presieve.IsSheafFor P â‡‘âŠ¤
{Î± : Type uu} (A : Î±) {lâ‚ lâ‚‚ : List Î±} : lâ‚ <+~ lâ‚‚ â†’ A :: lâ‚ <+~ A :: lâ‚‚
{Î± : Type u_1} {Î¹ : sort u_3} [conditionally_CompleteLattice Î±] [Nonempty Î¹] {F : Î¹ â†’ Î±} {C : Î±} (h : âˆ€ (x : Î¹), C â‰¤ F x) : C â‰¤ infi F
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) (hF : CategoryTheory.IsEquivalence F) : CategoryTheory.IsEquivalence.of_iso (CategoryTheory.Iso.refl F) hF = hF
{Î± : Type u_1} : HasStar.Star 1 = 1
(ð•œ : Type v) [_R_or_C ð•œ] {E : Type u} [NormedGroup E] [NormedSpace ð•œ E] (x : E) (h : x â‰  0) : âˆƒ (g : E â†’L[ð•œ] ð•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {j j' : C} (F F' : j âŸ¶ j') : CategoryTheory.IsCofiltered.Eq_hom F F' â‰« F = CategoryTheory.IsCofiltered.Eq_hom F F' â‰« F'
{P x : â„} {r : â„š} (hr : r â‰  0) : LiouvilleWith P (x * â†‘r) â†” LiouvilleWith P x
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (W : Î¹ â†’ k) (P : Î¹ â†’ P) {Sâ‚ Sâ‚‚ : Finset Î¹} (h : Sâ‚ âŠ† Sâ‚‚) : â‡‘(Sâ‚.affine_combination P) W = â‡‘(Sâ‚‚.affine_combination P) (â†‘Sâ‚.indicator W)
{Râ‚ : Type u_3} {A : Type u_5} {B : Type u_6} [CommSemiring Râ‚] [CommRing A] [CommRing B] [Algebra Râ‚ A] [Algebra Râ‚ B] (F : A â†’â‚[Râ‚] B) : Function.Injective â‡‘(Ideal.Ker_Lift_alg F)
{L : FirstOrder.Language} {m : Type u_3} [L.structure m] : FirstOrder.Language.structure.fg L m â†” âˆƒ (S : set m), S.Finite âˆ§ â‡‘(FirstOrder.Language.Substructure.Closure L) S = âŠ¤
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) (u v : â„• â†’ Î±) (hu : E._solution u) (hv : E._solution v) : u = v â†” set.Eq_on u v â†‘(Finset.Range E.order)
 : Filter.Tendsto Real.Exp Filter.at_top Filter.at_top
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F Fâ‚ : E â†’ F} {x : E} {n : â„•} (hs : UniqueDiffOn ð•œ S) (hL : âˆ€ (y : E), y âˆˆ S â†’ Fâ‚ y = F y) (hx : x âˆˆ S) : iterated_fderiv_within ð•œ n Fâ‚ S x = iterated_fderiv_within ð•œ n F S x
{Î± : Type u_1} [TopologicalSpace Î±] {S : set Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] [has_Continuous_Add Î³] {F g : Î± â†’ Î³} (hF : UpperSemicontinuous_on F S) (hg : UpperSemicontinuous_on g S) : UpperSemicontinuous_on (Î» (z : Î±), F z + g z) S
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hi : Irreflexive r) {A : Î±} (hacc : Acc r A) : Acc (Relation.CutExpand r) {A}
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P : P} (hp : P âˆˆ S) : AffineSubspace.Mk' P S.direction = S
{Î¹ : Type u_1} {v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {C : Complex_shape Î¹} [CategoryTheory.Limits.has_Zero_object v] [CategoryTheory.Limits.HasKernels v] [CategoryTheory.Limits.HasImages v] (C : homological_Complex v C) (i : Î¹) (h : C.boundaries i â‰¤ C.cycles i) : (C.boundaries i).of_LE (C.cycles i) h = C.boundaries_to_cycles i
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x y : E} : HasInner.inner x y = â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥ â†” â†‘âˆ¥yâˆ¥ â€¢ x = â†‘âˆ¥xâˆ¥ â€¢ y
{Î± : Type u} {R : Î± â†’ Î± â†’ Prop} {lâ‚ lâ‚‚ lâ‚ƒ : List Î±} (hâ‚ : List.chain' R (lâ‚ ++ lâ‚‚)) (hâ‚‚ : List.chain' R (lâ‚‚ ++ lâ‚ƒ)) (hn : lâ‚‚ â‰  List.Nil) : List.chain' R (lâ‚ ++ lâ‚‚ ++ lâ‚ƒ)
{m : Type u_1} [AddCommGroup m] [module â„‚ m] [Finite_dimensional â„‚ m] (q : QuadraticForm â„‚ m) (hQ : (â‡‘QuadraticForm.Associated q).nondegenerate) : q.Equivalent (QuadraticForm.weighted_Sum_squares â„‚ 1)
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] (F : S.Localization_Map N) (x : m) (y : â†¥S) : âˆƒ (C : â†¥S), x + â†‘((F.sec (F.Mk' x y)).Snd) + â†‘C = (F.sec (F.Mk' x y)).fst + â†‘y + â†‘C
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) (i : Fin (n + 1)) : S.points i = â‡‘(Finset.Univ.affine_combination S.points_with_circumcenter) (Affine.Simplex.point_weights_with_circumcenter i)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (v : v) (h : âˆ€ (W : v), âˆƒ (C : K), C â€¢ v = W) : Finite_dimensional.finrank K v â‰¤ 1
{Î² : Type u} {Î± : Type v} {S : Finset Î±} {A : Î±} {F : Î± â†’ Î²} [CommMonoid Î²] [DecidableEq Î±] (h : A âˆ‰ S â†’ F A = 1) : (HasInsert.Insert A S).Prod (Î» (x : Î±), F x) = S.Prod (Î» (x : Î±), F x)
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (F : E â†’sl[Ïƒâ‚â‚‚] F) : Isometry â‡‘F â†” âˆ€ (x : E), âˆ¥â‡‘F xâˆ¥ = âˆ¥xâˆ¥
(Î¹ : Type u_1) {R : Type u_2} {Î± : Type u_3} [AddMonoid Î¹] [Monoid R] (l : List Î±) (FÎ¹ : Î± â†’ Î¹) (fA : Î± â†’ R) : l.dprod FÎ¹ fA = (List.Map fA l).Prod
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.Finite_Type R A â†” âˆƒ (Î¹ : Type u_2) (_x : Fintype Î¹) (F : mv_Polynomial Î¹ R â†’â‚[R] A), Function.Surjective â‡‘F
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} (hF : IsClosed_Embedding F) {K : set Î²} (hK : IsCompact K) : IsCompact (F â»Â¹' K)
{mâ‚€ : Type u_1} {mâ‚€' : Type u_3} [MulZeroOneClass mâ‚€] [Nontrivial mâ‚€] [has_Zero mâ‚€'] [has_One mâ‚€'] (F : mâ‚€' â†’ mâ‚€) (Zero : F 0 = 0) (One : F 1 = 1) : Nontrivial mâ‚€'
{Î± : Type u_2} {Gâ‚€ : Type u_4} [TopologicalSpace Î±] [Group_with_Zero Gâ‚€] [MulAction Gâ‚€ Î±] [has_Continuous_Const_Smul Gâ‚€ Î±] {C : Gâ‚€} (hc : C â‰  0) : IsClosed_Map (Î» (x : Î±), C â€¢ x)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} {S : Affine.Simplex â„ P n} {P Pâ‚ Pâ‚‚ : P} {r : â„} (hpâ‚ : Pâ‚ âˆˆ affine_Span â„ (HasInsert.Insert P (set.Range S.points))) (hpâ‚‚ : Pâ‚‚ âˆˆ affine_Span â„ (HasInsert.Insert P (set.Range S.points))) (hâ‚ : âˆ€ (i : Fin (n + 1)), HasDist.dist (S.points i) Pâ‚ = r) (hâ‚‚ : âˆ€ (i : Fin (n + 1)), HasDist.dist (S.points i) Pâ‚‚ = r) : Pâ‚ = Pâ‚‚ âˆ¨ Pâ‚ = â‡‘(EuclideanGeometry.reflection (affine_Span â„ (set.Range S.points))) Pâ‚‚
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {Î¹ : Type u_2} {E : Î¹ â†’ Type u_5} [DecidableEq Î¹] [Fintype Î¹] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] : IsBoundedBilinearMap ð•œ (Î» (P : (F â†’L[ð•œ] G) Ã— Continuous_MultilinearMap ð•œ E F), P.fst.Comp_Continuous_MultilinearMap P.Snd)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} {ps : set P} (h : ps âŠ† â†‘S) [Nonempty â†¥S] [Finite_dimensional â„ â†¥(S.direction)] : EuclideanGeometry.Cospherical ps â†” âˆƒ (Center : P) (h : Center âˆˆ S) (radius : â„), âˆ€ (P : P), P âˆˆ ps â†’ HasDist.dist P Center = radius
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [_R_or_C ð•‚] [normed_CommRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] {x : ð”¸} : HasFderivAt (Exp ð•‚) (Exp ð•‚ x â€¢ 1) x
{Î² : Type u_4} [LinearOrder Î²] [NoMinOrder Î²] {u : â„• â†’ Î²} (hu : Filter.Tendsto u Filter.at_top Filter.at_IsBot) : âˆƒá¶  (n : â„•) in Filter.at_top, âˆ€ (k : â„•), k < n â†’ u n < u k
{m : Type u} {Î± : Type v} [CommRing Î±] [Fintype m] [DecidableEq m] {m : Matrix m m Î±} (h : IsUnit m) (N : Matrix m m Î±) : ((m.Mul N).Mul mâ»Â¹).det = N.det
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : bounded_Continuous_Function x â„) (e : C(x, Y)) (hE : IsClosed_Embedding â‡‘e) : âˆƒ (g : bounded_Continuous_Function Y â„), âˆ¥gâˆ¥ = âˆ¥Fâˆ¥ âˆ§ g.Comp_Continuous e = F
{Î± : Type u_1} [Semigroup Î±] [PartialOrder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] [ContravariantClass Î± Î± has_Mul.Mul has_LE.LE] [ContravariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A B C D : Î±} (hac : A â‰¤ C) (hbd : B â‰¤ D) : A * B = C * D â†” A = C âˆ§ B = D
{m : Type u_1} [has_Mul m] {C D : Con m} : Setoid.r = Setoid.r âŠ“ Setoid.r
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {n : â„•} : ContDiff_on ð•œ â†‘(n + 1) F S â†” âˆ€ (x : E), x âˆˆ S â†’ (âˆƒ (u : set E) (h : u âˆˆ nhds_within x (HasInsert.Insert x S)) (F' : E â†’ (E â†’L[ð•œ] F)), (âˆ€ (x : E), x âˆˆ u â†’ HasFderivWithinAt F (F' x) u x) âˆ§ ContDiff_on ð•œ â†‘n F' u)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {S : set E} : Mdifferentiable_on (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F S â†’ DifferentiableOn ð•œ F S
{Î± : Type u} (P : Î± â†’ Prop) [Decidable_Pred P] (xs : List Î±) (h : âˆ€ (x : Î±), x âˆˆ xs â†’ Â¬P x) (Sep : Î±) (hsep : P Sep) (as : List Î±) : List.split_on_P P (xs ++ Sep :: as) = xs :: List.split_on_P P as
{Î± : Type u_1} [CommMonoid Î±] {A B : Î±} {u : Î±Ë£} : A âˆ£ â†‘u * B â†” A âˆ£ B
{Î± : Type u_1} [circular_Preorder Î±] {A B C : Î±} (h : HasSbtw.Sbtw A B C) : HasBtw.Btw A B C
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) : S.circumcenter = â‡‘(Finset.Univ.affine_combination S.points_with_circumcenter) (Affine.Simplex.circumcenter_weights_with_circumcenter n)
(R : Type u_1) {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsNoetherian_Ring R] {A : set m} (hA : A.Finite) : IsNoetherian R â†¥(Submodule.Span R A)
{Î± : Type u_1} [Preorder Î±] {A B : Î±} (h : A â‰¤ B) : set.ioi B âŠ† set.ici A
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] (S : set Î±) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), 0)) = 0
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscrete_NormedField ð•‚] [NormedRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] (h : 0 < (Exp_series ð•‚ ð”¸).radius) : HasStrictFderivAt (Exp ð•‚) 1 0
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [CommMonoid Î²] {S : Finset Î±} {t : Finset Î³} {F : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (A : Î±), A âˆˆ S â†’ Î³) (hi : âˆ€ (A : Î±) (ha : A âˆˆ S), i A ha âˆˆ t) (h : âˆ€ (A : Î±) (ha : A âˆˆ S), F A = g (i A ha)) (i_inj : âˆ€ (Aâ‚ Aâ‚‚ : Î±) (haâ‚ : Aâ‚ âˆˆ S) (haâ‚‚ : Aâ‚‚ âˆˆ S), i Aâ‚ haâ‚ = i Aâ‚‚ haâ‚‚ â†’ Aâ‚ = Aâ‚‚) (i_surj : âˆ€ (B : Î³), B âˆˆ t â†’ (âˆƒ (A : Î±) (ha : A âˆˆ S), B = i A ha)) : S.Prod (Î» (x : Î±), F x) = t.Prod (Î» (x : Î³), g x)
(x : AlgebraicGeometry.LocallyRingedSpace) (r : â†¥(AlgebraicGeometry.LocallyRingedSpace.Î“.obj (Opposite.Op x))) : IsUnit (â‡‘(x.to_toÎ“_spec_Map_basic_IsOpen r) r)
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {F : m â†’+ P} (x : m) : â‡‘(Add_Con.Ker_Lift F) â†‘x = â‡‘F x
{n : Type u_1} {P : Type u_2} {ð•œ : Type u_3} [Field ð•œ] [DecidableEq n] [DecidableEq P] [Fintype n] [Fintype P] (m : Matrix P P ð•œ) (e : P â‰ƒ n) (h : âˆƒ (L L' : List (Matrix.TransvectionStruct n ð•œ)) (D : n â†’ ð•œ), ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul (â‡‘(Matrix.reindex_alg_Equiv ð•œ e) m)).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod = Matrix.Diagonal D) : âˆƒ (L L' : List (Matrix.TransvectionStruct P ð•œ)) (D : P â†’ ð•œ), ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod = Matrix.Diagonal D
{C : Type u} [CategoryTheory.Category C] {x Y : AlgebraicGeometry.PresheafedSpace C} (F : x âŸ¶ Y) [CategoryTheory.IsIso F.Base] [CategoryTheory.IsIso F.C] : CategoryTheory.IsIso F
(F : StieltjesFunction) {A B : â„} {C D : â„• â†’ â„} (ss : set.icc A B âŠ† â‹ƒ (i : â„•), set.Ioo (C i) (D i)) : Ennreal.of_Real (â‡‘F B - â‡‘F A) â‰¤ âˆ‘' (i : â„•), Ennreal.of_Real (â‡‘F (D i) - â‡‘F (C i))
(F : Type u_1) [Field F] [Fintype F] {A : F} (ha : A â‰  0) : âˆƒ (B : F), â‡‘(Algebra.trace (Zmod (Ring_Char F)) F) (A * B) â‰  0
{R : Type u} [ordered_CommRing R] [Star_ordered_Ring R] [Algebra â„ R] [OrderedSmul â„ R] (Aâ‚€ Aâ‚ Bâ‚€ Bâ‚ : R) (t : _CHSH_tuple Aâ‚€ Aâ‚ Bâ‚€ Bâ‚) : Aâ‚€ * Bâ‚€ + Aâ‚€ * Bâ‚ + Aâ‚ * Bâ‚€ - Aâ‚ * Bâ‚ â‰¤ 2
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : _Irreducible S â†” âˆ€ (U : Finset (set Î±)), (âˆ€ (u : set Î±), u âˆˆ U â†’ IsOpen u) â†’ (âˆ€ (u : set Î±), u âˆˆ U â†’ (S âˆ© u).Nonempty) â†’ (S âˆ© â‹‚â‚€ â†‘U).Nonempty
{G : Type u} {x : G} [Fintype G] [Group G] [DecidableEq G] : Finset.image (Î» (i : â„•), x ^ i) (Finset.Range (order_of x)) = â†‘(Subgroup.zpowers x).to_Finset
{m : Type u_1} [AddZeroClass m] {S : set m} {P : m â†’ Prop} {x : m} (h : x âˆˆ AddSubmonoid.Closure S) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (h1 : P 0) (HMul : âˆ€ (x y : m), P x â†’ P y â†’ P (x + y)) : P x
{Î± : Type u_1} {F : Î± â†’ Î±} {x y : Î±} {n : â„•} (hx : Function.IsPeriodicPt F n x) (hy : Function.IsPeriodicPt F n y) (hn : 0 < n) (h : F x = F y) : x = y
(G : Type u_1) [comm_Group G] : CommMonoid.torsion G = (torsion G).to_Submonoid
(Î± : Type u_1) [CompleteLattice Î±] : CompleteLattice._Sup_IsClosed_IsCompact Î± â†’ CompleteLattice._Sup_Finite_IsCompact Î±
{Î± : Type u} {Î² : Type v} [CommMonoid Î²] (S : Finset Î±) (F : Finset Î± â†’ Î²) : S.powerset.Prod (Î» (t : Finset Î±), F t) = (Finset.Range (S.Card + 1)).Prod (Î» (j : â„•), (Finset.powerset_len j S).Prod (Î» (t : Finset Î±), F t))
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [DecidableEq Î±] (h : free_Group.red (free_Group.reduce Lâ‚) Lâ‚‚) : free_Group.reduce Lâ‚ = Lâ‚‚
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {S : set Y} (F : C(â†¥S, â„)) (hs : IsClosed S) : âˆƒ (g : C(Y, â„)), Continuous_Map.Restrict S g = F
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [AddCommMonoid N] (F : Î± â†’â‚€ m) (y : Î±) (g : Î± â†’ m â†’ N) (hyf : y âˆˆ F.Support) : g y (â‡‘F y) + (Finsupp.erase y F).Sum g = F.Sum g
(cf cg : Nat.Partrec.Code) (A : â„•) : (cf.prec cg).Eval (Nat.mkpair A 0) = cf.Eval A
{Î± : Type u_2} {Î² : Type u_3} [non_assoc_Ring Î±] [non_assoc_Ring Î²] (F : Î± â†’+* Î²) (x : Î±) : â‡‘F (-x) = -â‡‘F x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type W} [CategoryTheory.Category J] (K : J â¥¤ C) (F : C â¥¤ D) [CategoryTheory.Limits.HasColimit (K â‹™ F)] [CategoryTheory.CreatesColimit K F] : CategoryTheory.Limits.HasColimit K
{A B : â„} : âˆ« (x : â„) in A..B, Real.sin x * Real.cos x = (Real.cos A ^ 2 - Real.cos B ^ 2) / 2
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] (F : LocalHomeomorph ð•œ ð•œ) {A F' : ð•œ} (ha : A âˆˆ F.to_local_Equiv.Target) (hF' : F' â‰  0) (htff' : HasStrictDerivAt â‡‘F F' (â‡‘(F.Symm) A)) : HasStrictDerivAt â‡‘(F.Symm) F'â»Â¹ A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace F] [CompleteSpace E] (e : E â‰ƒâ‚—[ð•œ] F) (h : Continuous â‡‘e) : Continuous â‡‘(e.Symm)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F F' : â„ â†’ E} {C : â„} (hF : âˆ€ (x : â„), x âˆˆ set.icc 0 1 â†’ HasDerivWithinAt F (F' x) (set.icc 0 1) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico 0 1 â†’ âˆ¥F' xâˆ¥ â‰¤ C) : âˆ¥F 1 - F 0âˆ¥ â‰¤ C
{n : â„•} [Fact (0 < n)] : Fintype.Card (Quaternion_Group n) = 4 * n
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : S âŠ† â†‘(affine_Span k S)
{n : WithTop â„•} {ð•‚ : Type u_6} [_R_or_C ð•‚] {F' : Type u_8} [NormedGroup F'] [NormedSpace ð•‚ F'] {F : ð•‚ â†’ F'} {F' : F'} {x : ð•‚} (hF : ContDiff_at ð•‚ n F x) (hF' : HasDerivAt F F' x) (hn : 1 â‰¤ n) : HasStrictDerivAt F F' x
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x y + o.oangle y z = o.oangle x z
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] (F : P1 â†’ P2) (Linear : v1 â†’â‚—[k] v2) (Add : âˆ€ (P : P1) (v : v1), F (v +áµ¥ P) = â‡‘Linear v +áµ¥ F P) : â‡‘{ToFun := F, Linear := Linear, Map_vadd' := Add} = F
{Î± : Type u} [PseudoEmetricSpace Î±] {x y : Î±} {S : set Î±} (h : y âˆˆ S) : Emetric.Inf_edist x S â‰¤ HasEdist.edist x y
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {ð•œâ‚ƒ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [NormedGroup E] [NormedGroup F] [NormedGroup G] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [nondiscrete_NormedField ð•œâ‚ƒ] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] [NormedSpace ð•œâ‚ƒ G] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} {Ïƒâ‚‚â‚ƒ : ð•œâ‚‚ â†’+* ð•œâ‚ƒ} {Ïƒâ‚â‚ƒ : ð•œ â†’+* ð•œâ‚ƒ} [Ring_hom_Comp_triple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [Ring_hom_isometric Ïƒâ‚â‚‚] (F : F â†’â‚›â‚—áµ¢[Ïƒâ‚‚â‚ƒ] G) {g : E â†’sl[Ïƒâ‚â‚‚] F} : âˆ¥F.to_Continuous_Linear_Map.Comp gâˆ¥ = âˆ¥gâˆ¥
{P : â„•} [hp_Prime : Fact (Nat.Prime P)] (z : â„¤_[P]) : z - â†‘(â‡‘padic_Int.to_Zmod z) âˆˆ local_Ring.Maximal_Ideal â„¤_[P]
{R : Type u_2} {m : Type u_3} [AddCommGroup m] [Ring R] [module R m] [htwo : Invertible 2] {B : BilinForm R m} (hBâ‚ : B â‰  0) (hBâ‚‚ : B.IsSymm) : âˆƒ (x : m), Â¬B.IsOrtho x x
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [Finite_dimensional ð•œ E] {n : â„•} (hn : Finite_dimensional.finrank ð•œ E = n) {Î¹ : Type u_4} [Fintype Î¹] [DecidableEq Î¹] {v : Î¹ â†’ Submodule ð•œ E} (hV : direct_Sum._internal v) (A : Fin n) : â‡‘(direct_Sum._internal.subordinate_Orthonormal_Basis hn hV) A âˆˆ v (direct_Sum._internal.subordinate_Orthonormal_Basis_Index hn hV A)
{Î± : Type u_1} [CompleteLattice Î±] [_modular_Lattice Î±] [IsCompactlyGenerated Î±] [IsAtomistic Î±] : IsComplemented Î±
{Î± : Type u} {Î² : Type v} [EmetricSpace Î±] [CompleteSpace Î±] [EmetricSpace Î²] {F : Î± â†’ Î²} (hF : Isometry F) : IsClosed_Embedding F
{C : Type u} [CategoryTheory.Category C] (B : C) : CategoryTheory.Limits.HasTerminal (CategoryTheory.Over B)
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’. Î² âŠ• Î±} (A : Î±) {B : Î²} (hb : Sum.inl_ B âˆˆ F A) : B âˆˆ F.fix A
(m : Type u_1) {Î± : Type u_6} [Monoid m] [MulAction m Î±] : HasScalar.Smul 1 = Id
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] {x : C} (h : Â¬CategoryTheory.Limits._Zero x) : Nontrivial (CategoryTheory.Subobject x)
{Î± : Type u} {Î² : Type v} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_top) : Filter.Tendsto (Î» (x : Î²), F x * g x) l Filter.at_top
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] (F : x â†’ Y) (h : âˆ€ (x : x), âˆƒ (e : LocalHomeomorph x Y), x âˆˆ e.to_local_Equiv.Source âˆ§ âˆ€ (x : x), x âˆˆ e.to_local_Equiv.Source â†’ F x = â‡‘e x) : IsLocallyHomeomorph F
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] (m : Ennreal â†’ Ennreal) (S : set x) : â‡‘(MeasureTheory.Measure.Mk_metric m) S = â¨† (r : Ennreal) (hr : 0 < r), â¨… (t : â„• â†’ set x) (h : S âŠ† set.Union t) (h' : âˆ€ (n : â„•), Emetric.diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (h : (t n).Nonempty), m (Emetric.diam (t n))
{G : Type u_1} [CommMonoid G] (tG : Monoid._torsion G) : CommMonoid.torsion G = âŠ¤
(x : Type u_2) [TopologicalSpace x] [RegularSpace x] [TopologicalSpace.SecondCountableTopology x] : âˆƒ (F : x â†’ bounded_Continuous_Function â„• â„), Embedding F
{t : Type uâ‚} [CategoryTheory.Category t] {x : t} {F g : CategoryTheory.Over x} (k : F âŸ¶ g) [hk : CategoryTheory.Epi k.Left] : CategoryTheory.Epi k
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) {r : â„} (hr : 0 < r) : hb.oangle (r â€¢ x) y = hb.oangle x y
{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (B : â„¤), âˆ€ (z : â„¤), P z â†’ z â‰¤ B) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (ub : â„¤), P ub âˆ§ âˆ€ (z : â„¤), P z â†’ z â‰¤ ub
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 0 R = 1
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : EqvGen.Setoid (EqvGen.Setoid r).Rel = EqvGen.Setoid r
{K : Type u} [Field K] (S : Subfield K) {x y : K} : x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : HasDist.dist P1 P3 * HasDist.dist P1 P3 = HasDist.dist P1 P2 * HasDist.dist P1 P2 + HasDist.dist P3 P2 * HasDist.dist P3 P2 - 2 * HasDist.dist P1 P2 * HasDist.dist P3 P2 * Real.cos (EuclideanGeometry.angle P1 P2 P3)
{Î± : Type u_2} {Î² : Type u_3} [DecidableEq Î²] [HasScalar Î± Î²] {u : Finset Î²} {S : set Î±} {t : set Î²} : â†‘u âŠ† S â€¢ t â†’ (âˆƒ (S' : Finset Î±) (t' : Finset Î²), â†‘S' âŠ† S âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† S' â€¢ t')
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : _Irreducible S â†” âˆ€ (Z : Finset (set Î±)), (âˆ€ (z : set Î±), z âˆˆ Z â†’ IsClosed z) â†’ S âŠ† â‹ƒâ‚€â†‘Z â†’ (âˆƒ (z : set Î±) (h : z âˆˆ Z), S âŠ† z)
{G : Type u_1} [div_Inv_Monoid G] (A B : G) : A / B = A * Bâ»Â¹
{Î± : Type u_1} {S t : Multiset Î±} : S â‰¤ t â†’ S âŠ† t
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {F : Filter Î±} {A : Î±} [F.Ne_IsBot] (h : F â‰¤ nhds A) : F.liminf = A
{Î± : Type u} [TopologicalSpace Î±] {F : â„ â†’ Î±} {C : â„} (hp : Function.Periodic F C) (hc : C â‰  0) (hF : Continuous F) : IsCompact (set.Range F)
(R : Type u_1) [CommRing R] (m n : â„•) : Polynomial.Chebyshev.t R (m * n) = (Polynomial.Chebyshev.t R m).Comp (Polynomial.Chebyshev.t R n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasTerminal C] : CategoryTheory.Limits.has_Zero_object C
{Î± : Type u} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] {n : â„•} (hn : 1 â‰¤ n) : Filter.Tendsto (Î» (x : Î±), x ^ -â†‘n) Filter.at_top (nhds 0)
{Î± : Type u_1} {n : Type u_3} {m : Type u_4} {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} : (Matrix.from_blocks A B C D).IsSymm â†” A.IsSymm âˆ§ B.transpose = C âˆ§ C.transpose = B âˆ§ D.IsSymm
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F â‰  2) {A : F} (ha : A â‰  0) : A ^ (Fintype.Card F / 2) = 1 âˆ¨ A ^ (Fintype.Card F / 2) = -1
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_3} {v : Î¹ â†’ E} (hz : âˆ€ (i : Î¹), v i â‰  0) (ho : âˆ€ (i j : Î¹), i â‰  j â†’ HasInner.inner (v i) (v j) = 0) : LinearIndependent ð•œ v
{R : Type u_1} [Mul_Zero_class R] [nR : Nontrivial R] : Â¬IsLeftRegular 0
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (G : C â¥¤ D) [CategoryTheory.ReflectsIsomorphisms G] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.HasLimits D] [CategoryTheory.Limits.PreservesLimits G] {x : top} (F : top.Presheaf C x) : F._sheaf â†” top.Presheaf._sheaf (F â‹™ G)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : F =o[l] g â†’ âˆ€ â¦ƒC : â„â¦„, 0 < C â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥F xâˆ¥ â‰¤ C * âˆ¥g xâˆ¥)
{R : Type u} {S : Type u_1} [Ring R] [Ring S] [_principal_Ideal_Ring R] (F : R â†’+* S) (hF : Function.Surjective â‡‘F) : _principal_Ideal_Ring S
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.SplitMono F] [CategoryTheory.Epi F] : CategoryTheory.IsIso F
{G : Type u_10} [Group G] (A : G) : â‡‘(Equiv.Symm (Equiv.Mul_Right A)) = Î» (x : G), x * Aâ»Â¹
(Î± : Type u) [TopologicalSpace Î±] [TopologicalSpace.SecondCountableTopology Î±] [RegularSpace Î±] : NormalSpace Î±
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} {r : â„} (hr : 0 â‰¤ r) (h1 : âˆ€ (x : Î±), x âˆˆ S â†’ (âˆƒ (y : Î±) (h : y âˆˆ t), HasDist.dist x y â‰¤ r)) (h2 : âˆ€ (x : Î±), x âˆˆ t â†’ (âˆƒ (y : Î±) (h : y âˆˆ S), HasDist.dist x y â‰¤ r)) : metric.Hausdorff_dist S t â‰¤ r
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : set P} (ho : EuclideanGeometry.OrthocentricSystem S) : âˆƒ (r : â„), âˆ€ (t : Affine.Triangle â„ P), set.Range t.points âŠ† S â†’ Affine.Simplex.circumradius t = r
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds_within A (set.Iic A) â†” âˆƒ (l : Î±) (h : l âˆˆ set.Iio A), set.ioc l A âŠ† S
{R : Type u} {L : Type v} [CommRing R] [lie_Ring L] [lie_Algebra R L] : Subsingleton (lie_Ideal R â†¥âŠ¥)
{L : FirstOrder.Language} {m : Type W} [L.structure m] {S : L.Substructure m} {S : set m} : â‡‘(FirstOrder.Language.Substructure.Closure L) S â‰¤ S â†” S âŠ† â†‘S
{G : Type u_1} [comm_Group G] (K : Subgroup G) (g : Multiset G) : (âˆ€ (A : G), A âˆˆ g â†’ A âˆˆ K) â†’ g.Prod âˆˆ K
(G : Type u_1) [AddMonoid G] : Â¬AddMonoid._torsion G â†” âˆƒ (g : G), Â¬_of_Fin_Add_order g
{n : â„•} {Î± : Type u_1} [Preorder Î±] {F : Fin (n + 1) â†’ Î±} : Monotone F â†” âˆ€ (i : Fin n), F (â‡‘Fin.cast_Succ i) â‰¤ F i.Succ
{k : Type u_1} {v : Type u_2} [Ring k] [AddCommGroup v] [module k v] {Î¹ : Type u_3} (S : Finset Î¹) {W : Î¹ â†’ k} {P : Î¹ â†’ v} (hw : S.Sum W = 0) : â‡‘(S.weighted_vsub P) W = S.Sum (Î» (i : Î¹), W i â€¢ P i)
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [Nontrivial k] (P : Î¹ â†’ P) (j : Î¹) (q : P) : q âˆˆ affine_Span k (set.Range P) â†” âˆƒ (S : Finset Î¹) (W : Î¹ â†’ k), q = â‡‘(S.weighted_vsub_of_point P (P j)) W +áµ¥ P j
{Î± : Type u} [TopologicalSpace Î±] {Z : set Î±} (h : IsClopen Z) : (â‹ƒ (x : Î±) (h : x âˆˆ Z), ConnectedComponent x) = Z
{K : Type u_1} [Field K] [Invertible 2] {A B C : K} (ha : A â‰  0) (h : discrim A B C = 0) (x : K) : A * x * x + B * x + C = 0 â†” x = -B / (2 * A)
{F : Type v} [NormedGroup F] [NormedSpace â„‚ F] {C : â„‚} {R C : â„} {F : â„‚ â†’ F} (hR : 0 < R) (hD : Diff_Cont_on_cl â„‚ F (Metric.Ball C R)) (hC : âˆ€ (z : â„‚), z âˆˆ Metric.Sphere C R â†’ âˆ¥F zâˆ¥ â‰¤ C) : âˆ¥deriv F Câˆ¥ â‰¤ C / R
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) (i : Fin (n + 1)) : HasDist.dist S.circumcenter (S.points i) = S.circumradius
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (g : G) (P1 P2 : P) : g +áµ¥ P1 -áµ¥ P2 = g + (P1 -áµ¥ P2)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) (h : P 1 = â‡‘((Continuous_multilinear_Curry_Fin1 ð•œ E F).Symm) â†‘i) (h0 : P 0 = 0) : P.Comp (P.Right_Inv i) = FormalMultilinearSeries.Id ð•œ F
 : â‡‘Linear_Equiv.det Complex.Conj_ae.to_Linear_Equiv = -1
(P q n : â„•) [Fact (Nat.Prime P)] (hq : q â‰  0) : padic_val_Nat P (q ^ n) = n * padic_val_Nat P q
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (B : Matrix n m Î±) [Invertible A] : A.Mul ((â…Ÿ A).Mul B) = B
{Î± : Type u} [Lattice Î±] [comm_Group Î±] (A : Î±) (h : 1 â‰¤ A) : Aâº = A
{K : Type u_1} [Linear_ordered_Field K] {v : K} [FloorRing K] (terminates : (GeneralizedContinuedFraction.of v).terminates) : âˆ€á¶  (n : â„•) in Filter.at_top, v = (GeneralizedContinuedFraction.of v).convergents n
{G : Type u_10} [Group G] (A : G) : â‡‘(Equiv.Symm (Equiv.Mul_Left A)) = has_Mul.Mul Aâ»Â¹
{B : Type u_3} {S : B} {m : Type u_1} [CommMonoid m] [set_like B m] [Submonoid_class B m] (m : Multiset m) (hm : âˆ€ (A : m), A âˆˆ m â†’ A âˆˆ S) : m.Prod âˆˆ S
{Î“â‚€ : Type u_1} [Linear_ordered_comm_Group_with_Zero Î“â‚€] : (nhds 0).has_Basis (Î» (_x : Î“â‚€Ë£), True) (Î» (Î³â‚€ : Î“â‚€Ë£), {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
(x : â„‚) : HasStrictDerivAt Complex.sinh (Complex.cosh x) x
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {F g : v â†’â‚—[K] v} : F.Comp g = LinearMap.Id â†” g.Comp F = LinearMap.Id
{n : â„•} (R : Type u_1) [CommRing R] [IsDomain R] : â‡‘(Algebra_Map (Polynomial R) (Ratfunc R)) (Polynomial.cyclotomic n R) = n.divisors_antidiagonal.Prod (Î» (i : â„• Ã— â„•), â‡‘(Algebra_Map (Polynomial R) (Ratfunc R)) (Polynomial.x ^ i.Snd - 1) ^ â‡‘Nat.ArithmeticFunction.moebius i.fst)
{C : Type u} [CategoryTheory.Category C] {P q : C} (F : P âŸ¶ q) [CategoryTheory.Epi F] [CategoryTheory.StrongMono F] : CategoryTheory.IsIso F
{P : Type u_1} [SemilatticeSup P] {x y : P} {S : order.Ideal P} (hx : x âˆˆ S) (hy : y âˆˆ S) : x âŠ” y âˆˆ S
{Î± : Type u_1} [LinearOrder Î±] {r : Î±} {S : Finset Î±} : S.to_colex < {r}.to_colex â†” âˆ€ (x : Î±), x âˆˆ S â†’ x < r
{Î± : Type u_1} {Î² : Type u_2} {e : local_Equiv Î± Î²} {S : set Î±} {t : set Î²} : e.Source âˆ© â‡‘e â»Â¹' t = e.Source âˆ© S â†’ e._image S t
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} : metric.Hausdorff_dist S t = metric.Hausdorff_dist t S
{C : Type u} [CategoryTheory.Category C] (x : C) : CategoryTheory.Presieve._sheaf (CategoryTheory.sheaf.canonical_topology C) (CategoryTheory.yoneda.obj x)
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [subtraction_Monoid Î²] (F : Î± â†’+ Î²) (g h : Î±) : â‡‘F (g + -h) = â‡‘F g + -â‡‘F h
{G : Type u} [CategoryTheory.groupoid G] [IsFreeGroupoid G] (t : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) [Quiver.Arborescence â†¥t] {A B : IsFreeGroupoid.Generators G} (e : A âŸ¶ B) (h : e âˆˆ Quiver.WideSubquiver_Symmetrify t A B) : IsFreeGroupoid.spanning_Tree.loop_of_hom t (IsFreeGroupoid.of e) = ðŸ™ (root' t)
{Î± : Type u} {Î¹ : Type x} [PseudoMetricSpace Î±] [Fintype Î¹] {F : Î± â†’ Î¹ â†’ â„} {S : set Î±} {K : Nnreal} (hF : LipschitzOnWith K F S) : âˆƒ (g : Î± â†’ Î¹ â†’ â„), LipschitzWith K g âˆ§ set.Eq_on F g S
(F : â†¥(MeasureTheory.Lp â„‚ 2 haar_Circle)) : âˆ‘' (i : â„¤), âˆ¥â‡‘(â‡‘(fourier_series.repr) F) iâˆ¥ ^ 2 = âˆ« (t : â†¥Circle), âˆ¥â‡‘F tâˆ¥ ^ 2 âˆ‚haar_Circle
{m : Type u_1} [has_Mul m] (C : Con m) : Con.Mul_Ker Coe _ = C
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [TopologicalSpace Î±] [UniformSpace Î²] {F : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {P : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} (h : TendstoLocallyUniformly (Î» (i : Î¹) (A : Î±), â‡‘(F i) A) â‡‘F P) : Filter.Tendsto F P (nhds F)
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : RË£) : (Î» (t : R), Ring.Inverse (â†‘x + t)) =O[nhds 0] Î» (t : R), 1
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (v : m) {r : R} (h : 0 < r) : SameRay R (r â€¢ v) v
(C : Type uâ‚) [CategoryTheory.Category C] (D : Type uâ‚‚) [CategoryTheory.Category D] (x : C) (Y : D) : ðŸ™ (x, Y) = (ðŸ™ x, ðŸ™ Y)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_3} (l : Î¹ â†’â‚€ ð•œ) (v : Î¹ â†’ E) (x : E) : HasInner.inner (l.Sum (Î» (i : Î¹) (A : ð•œ), A â€¢ v i)) x = l.Sum (Î» (i : Î¹) (A : ð•œ), â‡‘(Star_Ring_end ð•œ) A â€¢ HasInner.inner (v i) x)
(n : â„•) : Ring_Char (Zmod n) = n
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {S : set Î±} (hs : IsPreconnected S) : S âˆˆ {set.icc (HasInf.Inf S) (HasSup.Sup S), set.Ico (HasInf.Inf S) (HasSup.Sup S), set.ioc (HasInf.Inf S) (HasSup.Sup S), set.Ioo (HasInf.Inf S) (HasSup.Sup S), set.ici (HasInf.Inf S), set.ioi (HasInf.Inf S), set.Iic (HasSup.Sup S), set.Iio (HasSup.Sup S), set.Univ, âˆ…}
{Î± : Type u_1} {S : Finset Î±} {F : Î± â†’ Ennreal} (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A â‰  âŠ¤) : (S.Sum (Î» (A : Î±), F A)).to_Nnreal = S.Sum (Î» (A : Î±), (F A).to_Nnreal)
{Î± : Type u_1} [TopologicalSpace Î±] [BaireSpace Î±] {P : Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in residual Î±, P x) â†” âˆƒ (t : set Î±), _GÎ´ t âˆ§ Dense t âˆ§ âˆ€ (x : Î±), x âˆˆ t â†’ P x
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : â„•} {i j : Fin (n + 2)} (h : i â‰¤ j) : x.Î´ j.Succ â‰« x.Î´ i = x.Î´ (â‡‘Fin.cast_Succ i) â‰« x.Î´ j
{G : Type u_1} [Group G] (N h : Subgroup G) [N.Normal] : â†‘(N âŠ” h) = â†‘N * â†‘h
{Î± : Type u} {Î² : Type v} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [DenselyOrdered Î±] {F : Filter Î²} {u : Î² â†’ Î±} {S : set Î±} (hs : Dense S) (h : âˆ€ (A : Î±), A âˆˆ S â†’ âˆ€ (B : Î±), B âˆˆ S â†’ A < B â†’ Â¬((âˆƒá¶  (n : Î²) in F, u n < A) âˆ§ âˆƒá¶  (n : Î²) in F, B < u n)) (h : Filter._bounded_under has_LE.LE F u . "_bounded_Default") (h' : Filter._bounded_under Ge F u . "_bounded_Default") : âˆƒ (C : Î±), Filter.Tendsto u F (nhds C)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} : StrictAntiOn F S â†’ StrictMono_on (â‡‘order_dual.to_dual âˆ˜ F) S
{R : Type u_1} [Ring R] (S : Subring R) {Î¹ : Type u_2} {t : Finset Î¹} {F : Î¹ â†’ R} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Sum (Î» (i : Î¹), F i) âˆˆ S
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {m : MeasurableSpace Î±} [TopologicalSpace Î²] [TopologicalSpace.pseudo_metrizable_Space Î²] [TopologicalSpace Î³] [TopologicalSpace.pseudo_metrizable_Space Î³] {g : Î² â†’ Î³} {F : Î± â†’ Î²} (hg : Embedding g) : MeasureTheory.strongly_Measurable (Î» (x : Î±), g (F x)) â†” MeasureTheory.strongly_Measurable F
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] (x : K) : â‡‘(Algebra.norm K) (â‡‘(Algebra_Map K L) x) = x ^ Finite_dimensional.finrank K L
{n m : â„•} (h : Fin n = Fin m) : cast h = â‡‘(Fin.cast _)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x y : E) : â‡‘_R_or_C.im (HasInner.inner x y) = (âˆ¥x - _R_or_C.i â€¢ yâˆ¥ * âˆ¥x - _R_or_C.i â€¢ yâˆ¥ - âˆ¥x + _R_or_C.i â€¢ yâˆ¥ * âˆ¥x + _R_or_C.i â€¢ yâˆ¥) / 4
(n B : â„•) : (n + 1) / (B + 2) < n + 1
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} (connected_fibers : âˆ€ (t : Î²), IsConnected (F â»Â¹' {t})) (hcl : âˆ€ (t : set Î²), IsClosed t â†” IsClosed (F â»Â¹' t)) (t : Î²) : IsConnected (F â»Â¹' ConnectedComponent t)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [CharZero k] {S : Finset Î¹} (P : Î¹ â†’ P) (h : S.Card â‰  0) : Finset.centroid k S P âˆˆ affine_Span k (set.Range P)
{R : Type u_1} {m : Type u_4} {S : Type u_7} [Semiring R] [AddCommMonoid m] [module R m] (P : Submodule R m) [Semiring S] [HasScalar S R] [module S m] [IsScalarTower S R m] : Submodule.Span S â†‘P = Submodule.Restrict_scalars S P
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {l : List L} : (âˆ€ (x : L), x âˆˆ l â†’ x âˆˆ S) â†’ l.Sum âˆˆ S
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : InnerProductGeometry.angle (-x) (-y) = InnerProductGeometry.angle x y
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x : C} {R : CategoryTheory.Presieve x} : (CategoryTheory.Presieve.IsSeparated_for P R âˆ§ âˆ€ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.compatible â†’ (âˆƒ (t : P.obj (Opposite.Op x)), x._amalgamation t)) â†” CategoryTheory.Presieve.IsSheafFor P R
{Î² : Type u_2} [DecidableEq Î²] (S : Finset Î²) (B : Î²) : Finset.Filter (Eq B) S = Ite (B âˆˆ S) {B} âˆ…
{G : Type u_1} [AddCommGroup G] (B : AddGroup_Filter_Basis G) : uniform_AddGroup G
{F g : â„ â†’ â„} {A B : â„} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hgc : Continuous_on g (set.icc A B)) (hle : âˆ€ (x : â„), x âˆˆ set.ioc A B â†’ F x â‰¤ g x) (hlt : âˆƒ (C : â„) (h : C âˆˆ set.icc A B), F C < g C) : âˆ« (x : â„) in A..B, F x < âˆ« (x : â„) in A..B, g x
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} (F g : C.Quotient â†’* P) (h : âˆ€ (A : m), â‡‘F â†‘A = â‡‘g â†‘A) : F = g
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : â†‘S âˆ© â†‘(AffineSubspace.Mk' P (S.direction)á—®) = {â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P)}
{Î± : Type u_1} {Î² : Type u_2} [EmetricSpace Î±] [PseudoEmetricSpace Î²] {F : Î± â†’ Î²} (h : AntilipschitzWith 0 F) : Subsingleton Î±
{R : Type u_1} {A : R} [Semigroup R] (B : R) (ha : IsRightRegular A) : IsRightRegular (B * A) â†” IsRightRegular B
{Î± : Type u} [UniformSpace Î±] {S : set Î±} {Î¹ : sort u_1} {C : Î¹ â†’ set Î±} (hs : IsCompact S) (hcâ‚ : âˆ€ (i : Î¹), IsOpen (C i)) (hcâ‚‚ : S âŠ† â‹ƒ (i : Î¹), C i) : âˆƒ (n : set (Î± Ã— Î±)) (h : n âˆˆ Uniformity Î±), âˆ€ (x : Î±), x âˆˆ S â†’ (âˆƒ (i : Î¹), {y : Î± | (x, y) âˆˆ n} âŠ† C i)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (Î¸ : Real.Angle) : hb.oangle x y = Î¸ â†” (x â‰  0 âˆ§ y â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(hb.rotation Î¸) x) âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
(n : â„•) [Fact (0 < n)] [Fintype (Zmod n)Ë£] : Fintype.Card (Zmod n)Ë£ = n.Totient
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] : Finite_dimensional K â†¥âŠ¥
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x y : E} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ ^ 2
{Î± : Type u_1} [generalized_boolean_Algebra Î±] (u v : Î±) : set.inj_on (Î» (x : Î±), (x âŠ” u)  v) {x : Î± | Disjoint u x âˆ§ v â‰¤ x}
{Î² : Type u_4} [LinearOrder Î²] [NoMaxOrder Î²] {u : â„• â†’ Î²} (hu : Filter.Tendsto u Filter.at_top Filter.at_top) (N : â„•) : âˆƒ (n : â„•) (h : n â‰¥ N), âˆ€ (k : â„•), k < n â†’ u k < u n
{R : Type u_1} [CommRing R] [top : TopologicalSpace R] [topological_Ring R] {J : Ideal R} : IsAdic J â†” (âˆ€ (n : â„•), IsOpen â†‘(J ^ n)) âˆ§ âˆ€ (S : set R), S âˆˆ nhds 0 â†’ (âˆƒ (n : â„•), â†‘(J ^ n) âŠ† S)
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {Dâ‚ Dâ‚‚ : â„} (h : Dâ‚ â‰¤ Dâ‚‚) (S : set x) : â‡‘(MeasureTheory.Measure.hausdorff_measure Dâ‚‚) S â‰¤ â‡‘(MeasureTheory.Measure.hausdorff_measure Dâ‚) S
{R : Type x} [non_unital_non_assoc_Ring R] {A B : R} (h : Commute A B) : A * A - B * B = (A + B) * (A - B)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {xâ‚€ : E} (hF : HasFderivAt F F' xâ‚€) {C : â„} (hCâ‚€ : 0 â‰¤ C) (hlip : âˆ€á¶  (x : E) in nhds xâ‚€, âˆ¥F x - F xâ‚€âˆ¥ â‰¤ C * âˆ¥x - xâ‚€âˆ¥) : âˆ¥F'âˆ¥ â‰¤ C
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} (P : Î¹ â†’ P) (iâ‚€ : Î¹) : Vector_Span k (set.Range P) = Submodule.Span k (set.Range (Î» (i : {x // x â‰  iâ‚€}), P iâ‚€ -áµ¥ P â†‘i))
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x : v} (hx : x â‰  0) : o.oangle (-x) x = â†‘Real.Pi
{G : Type u} [Group G] {N : Subgroup G} [N.Normal] (hN : (Nat.Card â†¥N).IsCoprime N.Index) : âˆƒ (h : Subgroup G), N.Complement' h
 : fourier_Subalgebra.to_Submodule = Submodule.Span â„‚ (set.Range fourier)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P (n + 2)) (iâ‚ iâ‚‚ : Fin (n + 3)) : S.monge_plane iâ‚ iâ‚‚ = S.monge_plane iâ‚‚ iâ‚
{Î± : Type u_1} [Preorder Î±] [PredOrder Î±] {A : Î±} : Â¬IsMin A â†’ Order.Pred A < A
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (h : Subgroup G) (F : G â‰ƒ* N) : Subgroup.Map F.to_Monoid_hom h.Normalizer = (Subgroup.Map F.to_Monoid_hom h).Normalizer
{R : Type u_1} [CommRing R] {A B : R} : A ^ 4 + 4 * B ^ 4 = (A ^ 2 - 2 * A * B + 2 * B ^ 2) * (A ^ 2 + 2 * A * B + 2 * B ^ 2)
{Î± : Type u_1} [Preorder Î±] {A B : Î±} (h1 : A â‰¤ B) (h2 : B â‰¤ A) : A â©¿ B
{n : Type u_1} {ð•œ : Type u_3} [Field ð•œ] [DecidableEq n] [Fintype n] (P : Matrix n n ð•œ â†’ Prop) (m : Matrix n n ð•œ) (hdiag : âˆ€ (D : n â†’ ð•œ), (Matrix.Diagonal D).det = m.det â†’ P (Matrix.Diagonal D)) (htransvec : âˆ€ (t : Matrix.TransvectionStruct n ð•œ), P t.to_Matrix) (HMul : âˆ€ (A B : Matrix n n ð•œ), P A â†’ P B â†’ P (A.Mul B)) : P m
{Î± : Type u_1} {Î² : Type u_2} [MeasurableSpace Î±] [TopologicalSpace Î²] [TopologicalSpace.pseudo_metrizable_Space Î²] [MeasurableSpace Î²] [BorelSpace Î²] {Î¹ : Type u_3} {F : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [u.Ne_IsBot] [u._countably_generated] (hF : âˆ€ (i : Î¹), Measurable (F i)) (lim : Filter.Tendsto F u (nhds g)) : Measurable g
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} {S : set Î±} (h : x âˆˆ S) : Emetric.Inf_edist x S = 0
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] : Finite_dimensional.finrank K v â‰¤ 1 â†” âˆƒ (v : v), âˆ€ (W : v), âˆƒ (C : K), C â€¢ v = W
{A : â„} {l : Filter â„} {F g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhds A, Differentiable_at â„ F x) (hg' : âˆ€á¶  (x : â„) in nhds A, deriv g x â‰  0) (hfa : Filter.Tendsto F (nhds A) (nhds 0)) (hga : Filter.Tendsto g (nhds A) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv F x / deriv g x) (nhds A) l) : Filter.Tendsto (Î» (x : â„), F x / g x) (nhds_within A (set.Univ  {A})) l
{R : Type u_1} {m : Type u_3} [Monoid_with_Zero R] [has_Zero m] [MulAction_with_Zero R m] : IsSmulRegular m 0 â†” Subsingleton m
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {v : Type uâ‚ƒ} {P : Type uâ‚„} [AddCommGroup v] [AddTorsor v P] [Ring k] [module k v] (B : affine_Basis Î¹ k P) {Î¹' : Type u_1} [Fintype Î¹'] [Fintype Î¹] [DecidableEq Î¹'] (P : Î¹' â†’ P) {A : Matrix Î¹ Î¹' k} (hA : (B.to_Matrix P).Mul A = 1) : AffineIndependent k P
{x : Type u} {Î± : Type v} [TopologicalSpace x] [LinearOrder Î±] [TopologicalSpace Î±] [order_IsClosed_topology Î±] [PreconnectedSpace x] {C : Î±} {F : x â†’ Î±} (hF : Continuous F) (hâ‚ : âˆƒ (A : x), F A â‰¤ C) (hâ‚‚ : âˆƒ (B : x), C â‰¤ F B) : C âˆˆ set.Range F
{Î± : Type u_1} [PseudoMetricSpace Î±] (C : â„) {F : â„• â†’ Î±} (huâ‚‚ : âˆ€ (n : â„•), HasDist.dist (F n) (F (n + 1)) â‰¤ C / 2 / 2 ^ n) : Cauchy_Seq F
{xl xr : Type u_1} {xL : xl â†’ Pgame} {xR : xr â†’ Pgame} {yl yr : Type u_1} {yL : yl â†’ Pgame} {yR : yr â†’ Pgame} : (Pgame.Mk xl xr xL xR).lf (Pgame.Mk yl yr yL yR) â†” (âˆƒ (i : yl), Pgame.Mk xl xr xL xR â‰¤ yL i) âˆ¨ âˆƒ (j : xr), xR j â‰¤ Pgame.Mk yl yr yL yR
{G : Type u} {x : G} [Monoid G] : 0 < order_of x â†” _of_Fin_order x
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {S t : Convex_cone ð•œ E} (h : â†‘S = â†‘t) : S = t
{Î± : Type u} (S : set (set Î±)) : Cardinal.Mk â†¥{t : set Î± | MeasurableSpace.generate_Measurable S t} â‰¤ LinearOrder.max (Cardinal.Mk â†¥S) 2 ^ Cardinal.aleph0
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 P2 P3 : P) : P1 -áµ¥ P3 - (P2 -áµ¥ P3) = P1 -áµ¥ P2
(P : â„•) [Fact (Nat.Prime P)] (A : â„¤) (ha : â†‘A â‰  0) : Zmod.legendre_Sym P A ^ 2 = 1
{R : Type u_4} {S : Type u_5} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R â‰ƒ+* S) : â†‘F.to_Equiv = â†‘F.to_Equiv
(S : set â„•+) (K : Type W) [Field K] (C : Type z) [Fintype â†¥S] [CommRing C] [Algebra K C] [IsDomain C] [IsCyclotomicExtension S K C] : Finite_dimensional K C
{v : Type u_9} {K : Type u_10} [Field K] [AddCommGroup v] [module K v] {n : Type W} {B : BilinForm K v} {v : n â†’ v} (hvâ‚ : B._Ortho v) (hvâ‚‚ : âˆ€ (i : n), Â¬B.IsOrtho (v i) (v i)) : LinearIndependent K v
{Î± : Type u} [Preorder Î±] {A B C : Î±} : B < C â†’ A â‰¤ B â†’ A < C
{R : Type u_1} [Mul_Zero_class R] (h : IsLeftRegular 0) : Subsingleton R
{R : Type u_1} {G : Type u_2} [comm_Group G] [CommRing R] [Nontrivial R] : Algebra.Finite_Type R (Monoid_Algebra R G) â†” Group.fg G
{Î± : Type u} [TopologicalSpace Î±] [SigmaCompactSpace Î±] {F : Î± â†’ set Î±} (hF : âˆ€ (x : Î±), F x âˆˆ nhds x) : âˆƒ (S : set Î±), S.countable âˆ§ (â‹ƒ (x : Î±) (h : x âˆˆ S), F x) = set.Univ
{A : Type u_1} [AddCommMonoid A] (A B C : A) : C âˆˆ AddSubmonoid.Closure {A, B} â†” âˆƒ (m n : â„•), m â€¢ A + n â€¢ B = C
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] [Nontrivial R] {Î¹ : Type W} (B : Basis Î¹ R m) [Infinite Î¹] {Îº : Type W} (v : Îº â†’ m) (i : LinearIndependent R v) (m : i.Maximal) : Cardinal.Mk Î¹ â‰¤ Cardinal.Mk Îº
{Î± : Type u_1} [canonically_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B : Î±} (h : A â‰¤ B) : A - B = 0
(P : â„•) [Fact (Nat.Prime P)] : padic_norm P â†‘P < 1
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {Sâ‚ Sâ‚‚ : Submodule K v} [Finite_dimensional K â†¥Sâ‚‚] (h : Sâ‚ â‰¤ Sâ‚‚) : Finite_dimensional K â†¥Sâ‚
{Î“â‚€ : Type u_3} [Linear_ordered_AddCommMonoid_WithTop Î“â‚€] [Nontrivial Î“â‚€] {K : Type u_1} [DivisionRing K] (v : AddValuation K Î“â‚€) {x : K} : â‡‘v x = âŠ¤ â†” x = 0
{Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [Preorder Î²] [Preorder Î³] {F : Î± â†’ Î²} {e : Î² â†’ Î³} {l : Filter Î±} (hm : âˆ€ (Bâ‚ Bâ‚‚ : Î²), e Bâ‚ â‰¤ e Bâ‚‚ â†” Bâ‚ â‰¤ Bâ‚‚) (hu : âˆ€ (C : Î³), âˆƒ (B : Î²), e B â‰¤ C) : Filter.Tendsto (e âˆ˜ F) l Filter.at_IsBot â†” Filter.Tendsto F l Filter.at_IsBot
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {S : Finset Î±} : S âˆˆ ð’œ.Up_shadow â†” âˆƒ (A : Î±) (h : A âˆˆ S), S.erase A âˆˆ ð’œ
{Î± : Type u_1} [cancel_CommMonoid_with_Zero Î±] {A : Î±} {F : Multiset Î±} (ha : Irreducible A) (pfa : (âˆ€ (B : Î±), B âˆˆ F â†’ Prime B) âˆ§ Associated F.Prod A) : âˆƒ (P : Î±), Associated A P âˆ§ F = {P}
{Î± : Type u} [PseudoEmetricSpace Î±] {Î´â‚ Î´â‚‚ : â„} (hle : Î´â‚ â‰¤ Î´â‚‚) (E : set Î±) : Metric.Cthickening Î´â‚ E âŠ† Metric.Cthickening Î´â‚‚ E
{K : Type v} [Field K] {P : Polynomial K} : Polynomial.Splits (Ring_hom.Id K) P â†” â‡‘Multiset.Card P.roots = P.Nat_degree
{R : Type u_1} [CommSemiring R] {n : Type u_4} [Fintype n] [DecidableEq n] : Linear_Map.to_Matrix (Pi.Basis_fun R n) (Pi.Basis_fun R n) = Linear_Map.to_Matrix'
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} : Mdifferentiable (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F â†’ Differentiable ð•œ F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {x : E} {S : set E} {t : set F} {y : F} (hs : UniqueDiffWithinAt ð•œ S x) (ht : UniqueDiffWithinAt ð•œ t y) : UniqueDiffWithinAt ð•œ (S Ã—Ë¢ t) (x, y)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (R : D â¥¤ C) [CategoryTheory.Reflective R] [CategoryTheory.Limits.HasColimits_of_shape J C] : CategoryTheory.Limits.HasColimits_of_shape J D
{m : Type u_1} [AddMonoid m] {N : Type u_2} [AddMonoid N] {F : m â†’ N} (hF : _AddMonoid_hom F) {S : set N} (hs : _Add_Submonoid S) : _Add_Submonoid (F â»Â¹' S)
{Î± : Type u_1} [canonically_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B C : Î±} [ContravariantClass Î± Î± has_Add.Add has_LE.LE] [ContravariantClass Î± Î± has_Add.Add has_LT.LT] (hca : C â‰¤ A) (h : A - B < A - C) : C < B
{G : Type u_7} [AddGroup G] (L : List G) : -L.Sum = (List.Map (Î» (x : G), -x) L).reverse.Sum
{Î± : Type u_1} [CompleteLattice Î±] {S : set Î±} (hs : CompleteLattice.set_Independent S) : S.Pairwise_Disjoint Id
{R : Type u} [Ring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {m : Type u_1} [AddCommGroup m] [module R m] (A : Î¹ â†’ Submodule R m) {i j : Î¹} (hij : i â‰  j) (h : set.Univ = {i, j}) : direct_Sum._internal A â†” _IsCompl (A i) (A j)
{Î± : Type u_1} [MetricSpace Î±] {K : Nnreal} {F : Î± â†’ Î±} (hF : ContractingWith K F) (g : Î± â†’ Î±) {x y : Î±} (hx : Function.IsFixedPt F x) (hy : Function.IsFixedPt g y) {C : â„} (hfg : âˆ€ (z : Î±), HasDist.dist (F z) (g z) â‰¤ C) : HasDist.dist x y â‰¤ C / (1 - â†‘K)
(x : AlgebraicGeometry.LocallyRingedSpace) : Continuous x.toÎ“_spec_fun
{G : Type u_10} {h : Type u_11} [AddGroup G] [subtraction_Monoid h] (h : G â‰ƒ+ h) (x : G) : â‡‘h (-x) = -â‡‘h x
{m : Type u_1} {B : Type u_3} [Monoid m] [set_like B m] [Submonoid_class B m] {S : B} {l : List m} (hl : âˆ€ (x : m), x âˆˆ l â†’ x âˆˆ S) : l.Prod âˆˆ S
(G : Type u_1) [Monoid G] : Â¬Monoid._torsion G â†” âˆƒ (g : G), Â¬_of_Fin_order g
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (h : 0 < (1 - r) * (B - A)) : â‡‘(affine_Map.line_Map (F A) (F B)) r â‰¤ F (â‡‘(affine_Map.line_Map A B) r) â†” slope F (â‡‘(affine_Map.line_Map A B) r) B â‰¤ slope F A B
{m : Type u_1} [MulOneClass m] {C D : Con m} (h : C â‰¤ D) (x : C.Quotient) : â‡‘(C.Map D h) x = â‡‘(C.Lift D.Mk' _) x
{Î± : Type u} [UniformSpace Î±] [(Uniformity Î±)._countably_generated] (U : â„• â†’ set (Î± Ã— Î±)) (U_mem : âˆ€ (n : â„•), U n âˆˆ Uniformity Î±) (HU : âˆ€ (u : â„• â†’ Î±), (âˆ€ (N m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ (u m, u n) âˆˆ U N) â†’ (âˆƒ (A : Î±), Filter.Tendsto u Filter.at_top (nhds A))) : CompleteSpace Î±
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] [CategoryTheory.Limits.HasInitial C] : CategoryTheory.Limits.has_Finite_coproducts C
{Î± : Type u} [PartialOrder Î±] {A B : Î±} : A â‰¤ B â†’ B â‰  A â†’ A < B
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommGroup Î²] [HasScalar ð•œ E] [module ð•œ Î²] {S : set E} {F : E â†’ Î²} : ConcaveOn ð•œ S F â†’ Convex_on ð•œ S (-F)
(R : Type u) (m : Type v) (N : Type W) [CommRing R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [AddCommGroup N] [module R N] [module.free R N] : module.rank R (TensorProduct R m N) = (module.rank R m).Lift * (module.rank R N).Lift
{Î± : Type v} [LinearOrder Î±] [TopologicalSpace Î±] [order_IsClosed_topology Î±] {S : set Î±} (hs : IsConnected S) {A B : Î±} (ha : A âˆˆ S) (hb : B âˆˆ S) : set.icc A B âŠ† S
{ð•œ : Type u_1} {E : Type u_4} [semi_NormedGroup E] [nondiscrete_NormedField ð•œ] [NormedSpace ð•œ E] : âˆ¥Continuous_LinearMap.Id ð•œ Eâˆ¥ â‰¤ 1
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (h : 0 < (1 - r) * (B - A)) : F (â‡‘(affine_Map.line_Map A B) r) â‰¤ â‡‘(affine_Map.line_Map (F A) (F B)) r â†” slope F A B â‰¤ slope F (â‡‘(affine_Map.line_Map A B) r) B
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] {A : m} {C : k} (hc : C < 0) : A < 0 â†’ 0 < C â€¢ A
{n A : â„•} (h : A < n + 1) : â†‘â†‘A = A
{R : Type u} {A : Type W} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) (r : R) (y : A) : x * â‡‘(Algebra_Map R A) r * y = x * y * â‡‘(Algebra_Map R A) r
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} [CategoryTheory.Limits.HasImages C] (F : x âŸ¶ Y) [CategoryTheory.Mono F] : CategoryTheory.Subobject.exists F = CategoryTheory.Subobject.Map F
{A B : Ereal} (h : A â‰¤ -B) : B â‰¤ -A
{G : Type u_3} [AddGroup G] (P : Add_Subgroup G) : P.fg â†” âˆƒ (S : set G), Add_Subgroup.Closure S = P âˆ§ S.Finite
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] : Algebra.IsAlgebraic R A â†” âŠ¤.IsAlgebraic
{Î± : Type u_1} [DecidableEq Î±] {S : Multiset Î±} : S.Nodup â†’ S.dedup = S
{h : Type u_1} [TopologicalSpace h] (G : StructureGroupoid h) [IsClosed_under_restriction G] : G.LocalInvariantProp G G._local_structomorph_within_at
{x : Type u} {mâ‚ mâ‚‚ : x â†’ x â†’ x} {eâ‚ eâ‚‚ : x} (hâ‚ : EckmannHilton.IsUnital mâ‚ eâ‚) (hâ‚‚ : EckmannHilton.IsUnital mâ‚‚ eâ‚‚) (Distrib : âˆ€ (A B C D : x), mâ‚ (mâ‚‚ A B) (mâ‚‚ C D) = mâ‚‚ (mâ‚ A C) (mâ‚ B D)) : eâ‚ = eâ‚‚
(S : set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ 0 â‰¤ x) : 0 â‰¤ HasSup.Sup S
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {n : WithTop â„•} {P : E â†’ FormalMultilinearSeries ð•œ E F} (g : F â†’L[ð•œ] G) (hF : HasFtaylorSeriesUpToOn n F P S) : HasFtaylorSeriesUpToOn n (â‡‘g âˆ˜ F) (Î» (x : E) (k : â„•), g.Comp_Continuous_MultilinearMap (P x k)) S
{Î± : Type u_1} [Linear_ordered_Field Î±] [Archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : 1 < y) : âˆƒ (n : â„¤), x âˆˆ set.Ico (y ^ n) (y ^ (n + 1))
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {Î± : E} {q : Polynomial F} (q_irred : Irreducible q) (q_aeval : â‡‘(Polynomial.aeval Î±) q = 0) (hÎ± : _IsSolvableByRad F Î±) : IsSolvable q.Gal
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {F : Î² â†’ Î³} {S : set Î²} (h : S âŠ† e.to_local_Equiv.Target) : Continuous_on F S â†” Continuous_on (F âˆ˜ â‡‘e) (e.to_local_Equiv.Source âˆ© â‡‘e â»Â¹' S)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) : Disjoint K Ká—®
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {x : ð•œ} {F' : ð•œ â†’L[ð•œ] F} : HasFderivAt F F' x â†” HasDerivAt F (â‡‘F' 1) x
{L : FirstOrder.Language} {m : Type W} [L.structure m] {S : set m} {P : m â†’ Prop} {x : m} (h : x âˆˆ â‡‘(FirstOrder.Language.Substructure.Closure L) S) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (Hfun : âˆ€ {n : â„•} (F : L.Functions n), FirstOrder.Language.IsClosed_under F (set_of P)) : P x
{B : Type u} [CategoryTheory.Bicategory B] {A B C : B} (F : A âŸ¶ B) (g : B âŸ¶ C) : CategoryTheory.Bicategory.whisker_Right (CategoryTheory.Bicategory.Left_unitor F).hom g = (CategoryTheory.Bicategory.associator (ðŸ™ A) F g).hom â‰« (CategoryTheory.Bicategory.Left_unitor (F â‰« g)).hom
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (Pâ‚ Pâ‚‚ : Î¹ â†’ P) : S.Sum (Î» (i : Î¹), W i â€¢ (Pâ‚ i -áµ¥ Pâ‚‚ i)) = â‡‘(S.affine_combination Pâ‚) W -áµ¥ â‡‘(S.affine_combination Pâ‚‚) W
{Î± : Type u_1} [Preorder Î±] [PredOrder Î±] {A B : Î±} [NoMinOrder Î±] : Order.Pred A â‰¤ Order.Pred B â†’ A â‰¤ B
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : IsPreconnected S â†” âˆ€ (u v : set Î±), IsClosed u â†’ IsClosed v â†’ S âŠ† u âˆª v â†’ S âˆ© (u âˆ© v) = âˆ… â†’ S âŠ† u âˆ¨ S âŠ† v
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) (i : Fin n) (y : Î± i.Succ) : Fin.tail (Function.update q i.Succ y) = Function.update (Fin.tail q) i y
{C : Type u} [CategoryTheory.Category C] {x Y : AlgebraicGeometry.PresheafedSpace C} {F : x âŸ¶ Y} (h : AlgebraicGeometry.PresheafedSpace.IsOpen_immersion F) (U : TopologicalSpace.Opens â†¥Y) (hU : â†‘U âŠ† set.Range â‡‘(F.Base)) : F.C.App (Opposite.Op U) â‰« h.Inv_App ((TopologicalSpace.Opens.Map F.Base).obj U) = Y.presheaf.Map (CategoryTheory.Eq_to_hom _).Op
{n : â„•} (P : Fin (n + 1)) (i : Fin n) : â‡‘(P.Succ_above) i < P â†” â‡‘Fin.cast_Succ i < P
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : hb.oangle x (-y) + hb.oangle y (-x) = 0
{Î± : Type u_3} [SemilatticeSup Î±] (A : Î±) : Filter.at_top = Filter.comap Coe Filter.at_top
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {C : â„} {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : Asymptotics._O_with C l F (Î» (x : Î±), -g' x) â†’ Asymptotics._O_with C l F g'
(k : Type u_1) {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype Î¹] (P : Î¹ â†’ P) {n : â„•} (hc : Fintype.Card Î¹ = n + 1) : Finite_dimensional.finrank k â†¥(Vector_Span k (set.Range P)) â‰¤ n
{n : â„•} {P : Fin n â†’ Prop} [Decidable_Pred P] : â†¥((Fin.Find P)._Some) â†” âˆƒ (i : Fin n), P i
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : â†‘(affine_Span k S) = SpanPoints k S
{k : Type uâ‚} {G : Type uâ‚‚} [CommSemiring k] [AddMonoid G] {A : Type uâ‚ƒ} [Semiring A] [Algebra k A] (F : AddMonoid_Algebra k G â†’â‚[k] A) (F : Monoid_Algebra k G) : â‡‘F F = Finsupp.Sum F (Î» (A : G) (B : k), B â€¢ â‡‘F (Finsupp.single A 1))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {n : WithTop â„•} {F g : E â†’ ð•œ} (hF : ContDiff ð•œ n F) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Î» (x : E), F x * g x)
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {x : C} (S : CategoryTheory.Sieve x) : S â‰¤ Jâ‚.close S
(n : â„•) : (Finset.Range n).Sum (Î» (i : â„•), i) = n * (n - 1) / 2
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} (F : E â†’sl[Ïƒâ‚â‚‚] F) {m : â„} (hMp : 0 â‰¤ m) (hM : âˆ€ (x : E), âˆ¥â‡‘F xâˆ¥ â‰¤ m * âˆ¥xâˆ¥) : âˆ¥Fâˆ¥ â‰¤ m
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {x : E} {n : WithTop â„•} {P : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n F P S) (hn : 1 â‰¤ n) (hx : S âˆˆ nhds x) : âˆ€á¶  (y : E) in nhds x, HasFderivAt F (â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (P y 1)) y
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} : A < -B â†’ B < -A
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [CommRing ð•œ] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G] [module ð•œ E] [module ð•œ F] [module ð•œ G] [TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] [topological_AddGroup F] [has_Continuous_Const_Smul ð•œ F] [topological_AddGroup G] [has_Continuous_Const_Smul ð•œ G] (q : FormalMultilinearSeries ð•œ F G) (P : FormalMultilinearSeries ð•œ E F) (v : Fin 1 â†’ E) : â‡‘(q.Comp P 1) v = â‡‘(q 1) (Î» (i : Fin 1), â‡‘(P 1) v)
{Î± : Type u_1} [TopologicalSpace Î±] [non_assoc_Ring Î±] (h : topological_Semiring Î±) : topological_Ring Î±
{Î± : Type u} [PartialOrder Î±] {A B : Î±} (h : A â‰¤ B) : A = B âˆ¨ A < B
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [Semiring Râ‚] [Semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {mâ‚ : Type u_4} [TopologicalSpace mâ‚] [AddCommMonoid mâ‚] {mâ‚‚ : Type u_6} [TopologicalSpace mâ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚ mâ‚] [module Râ‚‚ mâ‚‚] [t2_Space mâ‚‚] {S : set mâ‚} {F g : mâ‚ â†’sl[Ïƒâ‚â‚‚] mâ‚‚} (h : set.Eq_on â‡‘F â‡‘g S) : set.Eq_on â‡‘F â‡‘g (Closure â†‘(Submodule.Span Râ‚ S))
{Fâ‚ Fâ‚‚ : Circle_deg1_Lift} (hâ‚ : IsUnit Fâ‚) (hâ‚‚ : IsUnit Fâ‚‚) (h : Fâ‚.TranslationNumber = Fâ‚‚.TranslationNumber) : âˆƒ (F : Circle_deg1_Lift), Function.Semiconj â‡‘F â‡‘Fâ‚ â‡‘Fâ‚‚
(Î± : Type u) [MetricSpace Î±] [TopologicalSpace.IsSeparable_Space Î±] : Isometry (Kuratowski_Embedding Î±)
{ð•œ : Type u_1} {F : Type u_3} [_R_or_C ð•œ] [AddCommGroup F] [module ð•œ F] [C : InnerProductSpace.core ð•œ F] {x y : F} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + HasInner.inner x y + HasInner.inner y x + HasInner.inner y y
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [MetricSpace Î²] [has_Zero Î²] {Î¹ : Type u_1} {F : Î¹ â†’ Zero_at_infty_Continuous_Map Î± Î²} {F : Zero_at_infty_Continuous_Map Î± Î²} {l : Filter Î¹} : Filter.Tendsto F l (nhds F) â†” TendstoUniformly (Î» (i : Î¹), â‡‘(F i)) â‡‘F l
{Î± : Type u_1} [MeasurableSpace Î±] : Function.Injective MeasureTheory.JordanDecomposition.to_SignedMeasure
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {n : WithTop â„•} (e : F â‰ƒL[ð•œ] G) : ContDiff_on ð•œ n (â‡‘e âˆ˜ F) S â†” ContDiff_on ð•œ n F S
{m : Type u_1} [AddMonoid m] {S : set m} {A : m} (hs : _Add_Submonoid S) (h : A âˆˆ S) : Multiples A âŠ† S
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} [ProperSpace Î±] (hc : IsClosed S) (hb : Metric.Bounded S) : IsCompact S
{n : â„•} {Î± : Type u_1} (l : List Î±) (C : Composition n) {i : â„•} (hi : i < (l.split_wrt_Composition C).length) : (l.split_wrt_Composition C).nth_LE i hi = List.Drop (C.size_Up_to i) (List.take (C.size_Up_to (i + 1)) l)
{S : â„‚} (hs : 0 < S.re) : MeasureTheory.IntegrableOn (Î» (x : â„), â†‘(Real.Exp (-x)) * â†‘x ^ (S - 1)) (set.ioi 0) MeasureTheory.MeasureSpace.Volume
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_Ring ð•œ] [AddCommGroup E] [AddCommGroup F] [module ð•œ E] [module ð•œ F] {A B : ð•œ} {x y : E} {F : E â†’áµƒ[ð•œ] F} (h : A + B = 1) : â‡‘F (A â€¢ x + B â€¢ y) = A â€¢ â‡‘F x + B â€¢ â‡‘F y
{m : Type u_1} [Monoid m] {S : set m} {A : m} (h : A âˆˆ Monoid.Closure S) : âˆƒ (l : List m), (âˆ€ (x : m), x âˆˆ l â†’ x âˆˆ S) âˆ§ l.Prod = A
{Î± : Type u} [Preorder Î±] {A B C : Î±} (hab : A < B) (hbc : B = C) : A < C
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} [Fintype Î¹] {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’ ð•œ) (i : Î¹) : HasInner.inner (v i) (Finset.Univ.Sum (Î» (i : Î¹), l i â€¢ v i)) = l i
{Î± : Type u_1} [CommMonoid Î±] [Decidable_Rel has_Dvd.Dvd] {A B : Î±} : A âˆ£ B â†’ 0 < multiplicity A B
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r r' : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) (hr : r' < r) : âˆƒ (C : â„), âˆ€ (y : E), y âˆˆ Emetric.Ball x r' â†’ âˆ€ (z : E), z âˆˆ Emetric.Ball x r' â†’ âˆ¥F y - F z - â‡‘(P 1) (Î» (_x : Fin 1), y - z)âˆ¥ â‰¤ C * LinearOrder.max âˆ¥y - xâˆ¥ âˆ¥z - xâˆ¥ * âˆ¥y - zâˆ¥
{Î± : Type u_1} [TopologicalSpace Î±] {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] [has_Continuous_Add Î³] {F g : Î± â†’ Î³} (hF : UpperSemicontinuous F) (hg : UpperSemicontinuous g) : UpperSemicontinuous (Î» (z : Î±), F z + g z)
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {g : Î² â†’ Î±} (hg : Function.Injective g) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ set.Range g), F i)) = finprod (Î» (j : Î²), F (g j))
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {Î¹ : Type u_1} {S : set Î¹} (B : Basis â†¥S R m) (h : module.rank R m < Cardinal.aleph0) : S.Finite
{P : Real.Angle â†’ Prop} (Î¸ : Real.Angle) (h : âˆ€ (x : â„), P â†‘x) : P Î¸
{Î± : Type u_1} {Î¹ : sort u_3} [conditionally_CompleteLattice Î±] {F : Î¹ â†’ Î±} (h : BddBelow (set.Range F)) (C : Î¹) : infi F â‰¤ F C
{A : Type u_1} [CommRing A] [Algebra â„š A] : PowerSeries.Exp A * â‡‘PowerSeries.Eval_Neg_hom (PowerSeries.Exp A) = 1
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [DivisionRing K] {m : â„•} : m â‰¤ n â†’ g.continuants_aux m = (g.squash_gcf n).continuants_aux m
{n : â„•} {P : Fin n â†’ Prop} [Decidable_Pred P] {i : Fin n} (hi : i âˆˆ Fin.Find P) {j : Fin n} (hj : j < i) : Â¬P j
{Î¹A : Type u_7} {Î¹B : Type u_8} [DecidableEq Î¹A] [DecidableEq Î¹B] [Fintype Î¹A] [Fintype Î¹B] {R' : Type u_9} {máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [CommSemiring R'] [AddCommGroup Nâ‚] [module R' Nâ‚] [AddCommGroup Nâ‚‚] [module R' Nâ‚‚] [AddCommMonoid máµ¢] [module R' máµ¢] (A : MultilinearMap R' (Î» (_x : Î¹A), máµ¢) Nâ‚) (B : MultilinearMap R' (Î» (_x : Î¹B), máµ¢) Nâ‚‚) : â†‘(â‡‘MultilinearMap.alternatization A).Dom_Coprod â†‘(â‡‘MultilinearMap.alternatization B) = Finset.Univ.Sum (Î» (ÏƒA : Equiv.perm Î¹A), Finset.Univ.Sum (Î» (ÏƒB : Equiv.perm Î¹B), â‡‘Equiv.perm.sign ÏƒA â€¢ â‡‘Equiv.perm.sign ÏƒB â€¢ (MultilinearMap.Dom_Dom_congr ÏƒA A).Dom_Coprod (MultilinearMap.Dom_Dom_congr ÏƒB B)))
{Î± : Type u} {lâ‚ lâ‚‚ : List Î±} (i : â„•) : List.take (lâ‚.length + i) (lâ‚ ++ lâ‚‚) = lâ‚ ++ List.take i lâ‚‚
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} [CategoryTheory.Limits.HasCoequalizer F g] [CategoryTheory.Mono (CategoryTheory.Limits.coequalizerÏ€ F g)] : F = g
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.EnoughProjectives C] [CategoryTheory.Abelian C] {x Y : C} (F : x âŸ¶ Y) : CategoryTheory.Exact (CategoryTheory.Projective.D F) F
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B C : Î±} : A + B â‰¤ C â†’ A â‰¤ C - B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {P : E Ã— F} : ContDiff_at ð•œ n Prod.Snd P
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] {A B : Î±} (ha : A < 1) (hb : B < 1) : A * B < 1
{Î± : Type u} [CommSemiring Î±] (x y : Î±) (n : â„•) : (Finset.Range n).Sum (Î» (i : â„•), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
{Î± : Type u_2} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {m n : â„•} (hð’œ : IsAntichain HasSubset.Subset â†‘ð’œ) : Disjoint (ð’œ.Slice m) (Finset.falling n ð’œ).shadow
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {t : Affine.Triangle â„ P} (ho : t.orthocenter âˆ‰ set.Range t.points) {P : Fin 3 â†’ P} (hps : set.Range P âŠ† HasInsert.Insert t.orthocenter (set.Range t.points)) (hpi : Function.Injective P) : âˆƒ (C : P) (h : C âˆˆ affine_Span â„ (set.Range t.points)), âˆ€ (Pâ‚ : P), Pâ‚ âˆˆ set.Range P â†’ HasDist.dist Pâ‚ C = Affine.Simplex.circumradius t
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) : 1 âˆˆ S
(n P : â„•) : Polynomial.Eval â†‘n (Polynomial.bernoulli P.Succ) = bernoulli P.Succ + (â†‘P + 1) * (Finset.Range n).Sum (Î» (k : â„•), â†‘k ^ P)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {v : E} (hv : v âˆˆ Ká—®) : â‡‘(Orthogonal_projection K) v = 0
(R : Type u_1) [CommRing R] (n : â„•) : (Finset.Range (n + 1)).Sum (Î» (Î½ : â„•), (n â€¢ Polynomial.x - â†‘Î½) ^ 2 * bernstein_Polynomial R n Î½) = n â€¢ Polynomial.x * (1 - Polynomial.x)
{R : Type u} [EuclideanDomain R] [DecidableEq R] (A B : R) : EuclideanDomain.Gcd A B = A * EuclideanDomain.Gcd_A A B + B * EuclideanDomain.Gcd_B A B
{Î± : Type u} [has_Mul Î±] : _Mul_hom Id
{P x : â„} {r : â„š} (h : LiouvilleWith P x) (hr : r â‰  0) : LiouvilleWith P (x * â†‘r)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (E : D â¥¤ C) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasLimits_of_size C] : CategoryTheory.Limits.HasLimits_of_size D
(k : Type u_1) {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype Î¹] (P : Î¹ â†’ P) {n : â„•} (hc : Fintype.Card Î¹ = n + 2) : Finite_dimensional.finrank k â†¥(Vector_Span k (set.Range P)) â‰¤ n â†” Â¬AffineIndependent k P
{Î± : Type u_1} [PseudoEmetricSpace Î±] {F : â„• â†’ Î±} (D : â„• â†’ Nnreal) (hF : âˆ€ (n : â„•), HasEdist.edist (F n) (F n.Succ) â‰¤ â†‘(D n)) (hD : Summable D) : Cauchy_Seq F
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : â„•} {i : Fin (n + 2)} : x.Î´ (â‡‘Fin.cast_Succ i) â‰« x.Î´ i = x.Î´ i.Succ â‰« x.Î´ i
{Î± : Type u} [Semiring Î±] : _Semiring_hom Id
{Î¹ : sort u_1} {F : Î¹ â†’ Ennreal} {x : Ennreal} (h0 : x â‰  0) (h : x â‰  âŠ¤) : infi F * x = â¨… (i : Î¹), F i * x
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set â„} [IntervalIntegral.FTC_Filter A (nhds_within A S) (nhds_within A t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within A t) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds_within A t âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) (hs : UniqueDiffWithinAt â„ S A . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (Î» (u : â„), âˆ« (x : â„) in u..B, F x) S A = -C
{k : Type uâ‚} {G : Type uâ‚‚} [CommSemiring k] [Monoid G] {A : Type uâ‚ƒ} [Semiring A] [Algebra k A] (F : Monoid_Algebra k G â†’â‚[k] A) (F : Monoid_Algebra k G) : â‡‘F F = Finsupp.Sum F (Î» (A : G) (B : k), B â€¢ â‡‘F (Finsupp.single A 1))
{Î± : Type u_1} [CommSemiring Î±] : fib_rec._solution (Î» (x : â„•), â†‘(Nat.fib x))
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasImages v] [CategoryTheory.Limits.has_Zero_object v] [CategoryTheory.Preadditive v] [CategoryTheory.Limits.HasKernels v] [CategoryTheory.Limits.HasCokernels v] {Aâ‚ Bâ‚ Câ‚ Aâ‚‚ Bâ‚‚ Câ‚‚ : v} (Fâ‚ : Aâ‚ âŸ¶ Bâ‚) (gâ‚ : Bâ‚ âŸ¶ Câ‚) (Fâ‚‚ : Aâ‚‚ âŸ¶ Bâ‚‚) (gâ‚‚ : Bâ‚‚ âŸ¶ Câ‚‚) (Î± : Aâ‚ â‰… Aâ‚‚) (Î² : Bâ‚ â‰… Bâ‚‚) (Î³ : Câ‚ â‰… Câ‚‚) (hsqâ‚ : Î±.hom â‰« Fâ‚‚ = Fâ‚ â‰« Î².hom) (hsqâ‚‚ : Î².hom â‰« gâ‚‚ = gâ‚ â‰« Î³.hom) (h : CategoryTheory.Exact Fâ‚ gâ‚) : CategoryTheory.Exact Fâ‚‚ gâ‚‚
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] : module._torsion R â†¥(Submodule.torsion R m)
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] {S : set Î±} (hs : IsCompact S) {t : set Î²} (ht : IsCompact t) {n : set (Î± Ã— Î²)} (hn : IsOpen n) (hp : S Ã—Ë¢ t âŠ† n) : âˆƒ (u : set Î±) (v : set Î²), IsOpen u âˆ§ IsOpen v âˆ§ S âŠ† u âˆ§ t âŠ† v âˆ§ u Ã—Ë¢ v âŠ† n
{Î± : Type u_1} [LinearOrder Î±] [SuccOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ set.Ico n m â†’ r i (Order.Succ i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.Ico m n â†’ r (Order.Succ i) i) (hnm : n â‰  m) : Relation.TransGen r n m
(B C : â„) (n : â„•) (hb : 0 â‰  B) : Filter.Tendsto (Î» (x : â„), x ^ n / (B * Real.Exp x + C)) Filter.at_top (nhds 0)
{Î± : Type u_1} {Î² : Type u_2} [Fintype Î±] [Fintype Î²] (h : Fintype.Card Î² < Fintype.Card Î±) : IsEmpty (Î± â†ª Î²)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) [Nontrivial B] : minpoly A x â‰  1
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {F' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : ((Î» (x : Î±), âˆ¥F' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ F' =o[l] g'
{R : Type u} {m : Type v} {mâ‚‚ : Type W} {mâ‚ƒ : Type y} [Ring R] [AddCommGroup m] [AddCommGroup mâ‚‚] [AddCommGroup mâ‚ƒ] [module R m] [module R mâ‚‚] [module R mâ‚ƒ] {F : m â†’â‚—[R] mâ‚‚} {g : m â†’â‚—[R] mâ‚ƒ} (h : F.Ker âŠ” g.Ker = âŠ¤) : (F.Prod g).Range = F.Range.Prod g.Range
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set â„} [IntervalIntegral.FTC_Filter A (nhds_within A S) (nhds_within A t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within A t) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds_within A t âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasDerivWithinAt (Î» (u : â„), âˆ« (x : â„) in u..B, F x) (-C) S A
{ð•‚ : Type u_6} [_R_or_C ð•‚] {E' : Type u_7} [NormedGroup E'] [NormedSpace ð•‚ E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace ð•‚ F'] [CompleteSpace E'] {F : E' â†’ F'} {F' : E' â‰ƒL[ð•‚] F'} {A : E'} {n : WithTop â„•} (hF : ContDiff_at ð•‚ n F A) (hF' : HasFderivAt F â†‘F' A) (hn : 1 â‰¤ n) : ContDiff_at ð•‚ n (hF.local_Inverse hF' hn) (F A)
{Î² : Type u_2} [TopologicalSpace Î²] {Îº : Type u_5} {F : Îº â†’ Î²} (hF : Function.Surjective F) : DenseRange F
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Abelian C] [CategoryTheory.HasInjectiveResolutions C] [CategoryTheory.Abelian D] (F : C â¥¤ D) [F.Additive] (n : â„•) {x Y : C} (F : Y âŸ¶ x) {P : CategoryTheory.InjectiveResolution x} {q : CategoryTheory.InjectiveResolution Y} (g : q.cocomplex âŸ¶ P.cocomplex) (W : q.Î¹ â‰« g = (cochain_Complex.singleâ‚€ C).Map F â‰« P.Î¹) : (F.Right_derived n).Map F = (F.Right_derived_obj_iso n q).hom â‰« (homology_Functor D (ComplexShape.Up â„•) n).Map ((F.Map_homological_Complex (ComplexShape.Up â„•)).Map g) â‰« (F.Right_derived_obj_iso n P).Inv
{R : Type u_1} [Ring R] [strong_RankCondition R] (n : â„•) {m : â„•} (v : Fin m â†’ Fin n â†’ R) : LinearIndependent R v â†’ m â‰¤ n
{Î± : Type u_1} [AddCommGroup Î±] [TopologicalSpace Î±] [topological_AddGroup Î±] [t2_Space Î±] (F : â„• â†’ Î±) : Filter.Tendsto (Î» (i : â„•), âˆ‘' (k : â„•), F (k + i)) Filter.at_top (nhds 0)
{Î± : Type u_1} [TopologicalSpace Î±] {x : Î±} {S : set Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] {F g : Î± â†’ Î³} (hF : UpperSemicontinuous_within_at F S x) (hg : UpperSemicontinuous_within_at g S x) (hcont : Continuous_at (Î» (P : Î³ Ã— Î³), P.fst + P.Snd) (F x, g x)) : UpperSemicontinuous_within_at (Î» (z : Î±), F z + g z) S x
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] {n : â„•} (h : âˆ€ (S : Finset A), AlgebraicIndependent R (Î» (i : â†¥S), â†‘i) â†’ S.Card â‰¤ n) (S : set A) : AlgebraicIndependent R Coe â†’ Cardinal.Mk â†¥S â‰¤ â†‘n
{Î± : Type u} [UniformSpace Î±] [(Uniformity Î±)._countably_generated] (h' : âˆ€ (u : â„• â†’ Î±), Cauchy_Seq u â†’ (âˆƒ (A : Î±), Filter.Tendsto u Filter.at_top (nhds A))) : CompleteSpace Î±
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : â‡‘(EuclideanGeometry.reflection S) (â‡‘(EuclideanGeometry.reflection S) P) = P
(n : â„•) : â†‘(n.Succ) â€¢ Polynomial.bernoulli n = â‡‘(Polynomial.monomial n) â†‘(n.Succ) - (Finset.Range n).Sum (Î» (k : â„•), â†‘((n + 1).choose k) â€¢ Polynomial.bernoulli k)
{R : Type u_1} {m : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup m] [module R m] [no_Zero_divisors R] {B : m â†’â‚—[R] m â†’â‚—[R] R} (v : Basis n R m) (hO : B._Ortho â‡‘v) (h : âˆ€ (i : n), Â¬B.IsOrtho (â‡‘v i) (â‡‘v i)) : B.separating_Left
(R : Type u) [Ring R] [strong_RankCondition R] (m n : Type v) [Fintype m] [Fintype n] : module.rank R (Matrix m n R) = (Cardinal.Mk m * Cardinal.Mk n).Lift
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : 0 â‰¤ A) (hb : 0 â‰¤ B) : 0 â‰¤ A + B
{m : Type u_1} [Semigroup m] [TopologicalSpace m] [t2_Space m] (Continuous_Mul_Left : âˆ€ (r : m), Continuous (Î» (_x : m), _x * r)) (S : set m) (snemp : S.Nonempty) (S_IsCompact : IsCompact S) (S_Add : âˆ€ (x : m), x âˆˆ S â†’ âˆ€ (y : m), y âˆˆ S â†’ x * y âˆˆ S) : âˆƒ (m : m) (h : m âˆˆ S), m * m = m
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Finite_dimensional R m] (x : Orientation R m Î¹) (F : m â‰ƒâ‚—[R] m) (h : Fintype.Card Î¹ = Finite_dimensional.finrank R m) : â‡‘(Orientation.Map Î¹ F) x = -x â†” â‡‘LinearMap.det â†‘F < 0
{Î± : Type u_1} [non_unital_semi_NormedRing Î±] (x y : Î±) : âˆ¥â‡‘(AddMonoid_hom.Mul_Left x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{Î± : Type u_1} [LinearOrder Î±] {r S : Î±} : {r}.to_colex < {S}.to_colex â†” r < S
{x : top} (F : top.Presheaf (CategoryTheory.Discrete PUnit) x) : F._sheaf
{Î± : Type u} [TopologicalSpace Î±] {S t : set Î±} (ht : IsCompact t) (hs : IsClosed S) : IsCompact (S âˆ© t)
{n : â„•} [Fact (0 < n)] : Fintype.Card (dihedral_Group n) = 2 * n
{Î± : Type u} [TopologicalSpace Î±] [LocallyCompactSpace Î±] {K : set Î±} (hK : IsCompact K) : âˆƒ (K' : set Î±), IsCompact K' âˆ§ K âŠ† Interior K'
{Î± : Type u_1} {G : Type u_4} [division_CommMonoid G] {F g : Î± â†’ G} (hF : (Function.MulSupport F).Finite) (hg : (Function.MulSupport g).Finite) : finprod (Î» (i : Î±), F i / g i) = finprod (Î» (i : Î±), F i) / finprod (Î» (i : Î±), g i)
{Î² : Type u} {Î± : Type v} {S : Finset Î±} [AddCommMonoid Î²] (F : Î± â†’ Î²) {P : Î± â†’ Prop} [Decidable_Pred P] : (Finset.Subtype P S).Sum (Î» (x : Subtype P), F â†‘x) = (Finset.Filter P S).Sum (Î» (x : Î±), F x)
{Î± : Type u_3} {Î² : Type u_4} [SemilatticeSup Î±] [SemilatticeSup Î²] {F : Î± â†’ Î²} (g : Î² â†’ Î±) (B' : Î²) (hF : Monotone F) (gc : âˆ€ (A : Î±) (B : Î²), B â‰¥ B' â†’ (F A â‰¤ B â†” A â‰¤ g B)) (hgi : âˆ€ (B : Î²), B â‰¥ B' â†’ B â‰¤ F (g B)) : Filter.Map F Filter.at_top = Filter.at_top
{Î± : Type u} [Linear_ordered_Ring Î±] (A B C : Î±) : 0 â‰¤ A * B âˆ¨ 0 â‰¤ B * C âˆ¨ 0 â‰¤ C * A
{R : Type u_1} {S : Type u_2} (L : Type u_4) [EuclideanDomain R] [CommRing S] [IsDomain S] [Field L] [algRL : Algebra R L] [Algebra R S] [Algebra S L] [ist : IsScalarTower R S L] [Iic : IsIntegral_Closure S R L] {abv : AbsoluteValue R â„¤} {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] (bS : Basis Î¹ R S) (adm : abv._Admissible) [Infinite R] [DecidableEq R] (h : Algebra.IsAlgebraic R L) (A : S) {B : S} (hb : B â‰  0) : âˆƒ (q : S) (r : R) (h : r âˆˆ class_Group.Finset_approx bS adm), â‡‘abv (â‡‘(Algebra.norm R) (r â€¢ A - q * B)) < â‡‘abv (â‡‘(Algebra.norm R) B)
{Î³ : Type W} [SemilatticeSup Î³] {S t : set Î³} : BddAbove S â†’ BddAbove t â†’ BddAbove (S âˆª t)
{Î³ : Type W} [SemilatticeInf Î³] {S t : set Î³} : BddBelow (S âˆª t) â†” BddBelow S âˆ§ BddBelow t
{t : Type u} [CategoryTheory.Category t] {x Y : t} (i : x â‰… Y) (P : CategoryTheory.Arrow t) (sq : CategoryTheory.Arrow.Mk i.hom âŸ¶ P) : i.Inv â‰« sq.Left â‰« P.hom = sq.Right
{Î± : Type u} [Monoid_with_Zero Î±] (x : Î±) [Invertible x] : Ring.Inverse x = â…Ÿ x
(n : â„•+) (A : Type W) (B : Type z) [CommRing A] [CommRing B] [Algebra A B] [IsCyclotomicExtension {n} A B] [IsDomain B] [Ne_Zero â†‘â†‘n] : IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) â†‘n
{Î± : Type u_1} [TopologicalSpace Î±] {x : Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] {F g : Î± â†’ Î³} (hF : LowerSemicontinuousAt F x) (hg : LowerSemicontinuousAt g x) (hcont : Continuous_at (Î» (P : Î³ Ã— Î³), P.fst + P.Snd) (F x, g x)) : LowerSemicontinuousAt (Î» (z : Î±), F z + g z) x
(R : Type u) [Ring R] [strong_RankCondition R] {Î¹ : Type v} [Fintype Î¹] : Finite_dimensional.finrank R (Î¹ â†’ R) = Fintype.Card Î¹
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {n : â„•} (hn : S.Card < t.Card * n) : âˆƒ (y : Î²) (h : y âˆˆ t), (Finset.Filter (Î» (x : Î±), F x = y) S).Card < n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasLimits C
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (Pâ‚‚ : Î¹ â†’ P) (Pâ‚ : P) (h : S.Sum (Î» (i : Î¹), W i) = 0) : S.Sum (Î» (i : Î¹), W i â€¢ (Pâ‚ -áµ¥ Pâ‚‚ i)) = -â‡‘(S.weighted_vsub Pâ‚‚) W
(m : Type u_1) (Î± : Type u_2) [Group m] [MulAction m Î±] {S t : set Î±} : fixing_Subgroup m (S âˆª t) = fixing_Subgroup m S âŠ“ fixing_Subgroup m t
(C : Type u) [CategoryTheory.Category C] [âˆ€ {x Y : C}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair x Y)] : CategoryTheory.Limits.HasBinaryProducts C
{x : Type u_1} [tX : TopologicalSpace x] {S t : set x} (ts : t âŠ† S) : Subtype.TopologicalSpace = TopologicalSpace.induced (set.inclusion ts) Subtype.TopologicalSpace
{P : â„•} (q : â„š) : padic_val_rat P (-q) = padic_val_rat P q
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h1 : â†‘S1.Nonempty) (h2 : â†‘S2.Nonempty) (hD : _IsCompl S1.direction S2.direction) : âˆƒ (P : P), â†‘S1 âˆ© â†‘S2 = {P}
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_Ring ð•œ] [AddCommGroup E] [AddCommGroup F] [module ð•œ E] [module ð•œ F] {x : E} (F : E â†’áµƒ[ð•œ] F) {S : set F} (hs : Star_Convex ð•œ (â‡‘F x) S) : Star_Convex ð•œ x (â‡‘F â»Â¹' S)
{F : â„• â†’ â„} (hfa : Antitone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) : âˆƒ (l : â„), Filter.Tendsto (Î» (n : â„•), (Finset.Range (n + 1)).Sum (Î» (i : â„•), (-1) ^ i * F i)) Filter.at_top (nhds l)
{Î¹ : Type u} {Î³ : Type W} [dec : DecidableEq Î¹] (P : Î¹ â†’ Prop) [Decidable_Pred P] [AddCommMonoid Î³] (S : Î¹ â†’ Add_Submonoid Î³) : (â¨† (i : Î¹) (h : P i), S i) = ((Dfinsupp.Sum_Add_hom (Î» (i : Î¹), (S i).Subtype)).Comp (Dfinsupp.Filter_AddMonoid_hom (Î» (i : Î¹), â†¥(S i)) P)).mrange
{Î± : Type u_1} {P : Î± â†’ Prop} [Decidable_Pred P] {S : Finset Î±} (h : âˆ€ (x : Î±), x âˆˆ S â†’ Â¬P x) : Finset.Filter P S = âˆ…
{A B : â„•} (W : A âˆ£ B) (h : B < A) : B = 0
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] : (GeneralizedContinuedFraction.of v).denominators n â‰¤ (GeneralizedContinuedFraction.of v).denominators (n + 1)
{S : Type u_1} [has_Add S] {A B : S} (h : Add_Commute A B) : A + B = B + A
{P : Ennreal} [Fact (1 â‰¤ P)] (hp : P â‰  âŠ¤) : (Submodule.Span â„‚ (set.Range (fourier_Lp P))).topological_Closure = âŠ¤
{Î± : Type u_1} [has_LE Î±] {S : set Î±áµ’áµˆ} : _lower_set S â†’ _upper_set (â‡‘order_dual.to_dual â»Â¹' S)
{Î± : Type u} {Î³ : Type u_1} [TopologicalSpace Î³] [t2_Space Î³] [CompactSpace Î³] {F : Î± â†’ Î³} {B : Ultrafilter Î±} {C : Î³} : Ultrafilter.extend F B = C â†” â†‘(Ultrafilter.Map F B) â‰¤ nhds C
{n : â„•} (hpos : 0 < n) {P : â„•} [Fact (Nat.Prime P)] {A : â„•} (hroot : (Polynomial.cyclotomic n (Zmod P))._root (â‡‘(Nat.cast_Ring_hom (Zmod P)) A)) : order_of (Zmod.Unit_of_IsCoprime A _) âˆ£ n
 : fib_rec._solution (has_Pow.Pow GoldenRatio)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {y : E} {Î± : Type u_3} (l : Filter Î±) {C : Î± â†’ ð•œ} {D : Î± â†’ E} (hc : Filter.Tendsto (Î» (n : Î±), âˆ¥C nâˆ¥) l Filter.at_top) (hD : Filter.Tendsto (Î» (n : Î±), C n â€¢ D n) l (nhds y)) : Filter.Tendsto D l (nhds 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} (F : top.Presheaf C x) (U : TopologicalSpace.Opens â†¥x) (R : CategoryTheory.Presieve U) : CategoryTheory.presheaf.second_Map R F â‰« (top.Presheaf.covering_of_Presieve.second_obj_iso_Pi_inters F U R).hom = (top.Presheaf.covering_of_Presieve.FirstObj_iso_Pi_Opens F U R).hom â‰« top.Presheaf.sheaf_condition_Equalizer_products.Right_res F (top.Presheaf.covering_of_Presieve U R)
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (hs : S.Nonempty) {C : â„} (h : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ HasDist.dist x y â‰¤ C) : Metric.diam S â‰¤ C
{m : â„} {F : â„• â†’ â„•} (hm : 1 < m) (fi : âˆ€ (i : â„•), i â‰¤ F i) : Summable (Î» (i : â„•), 1 / m ^ F i)
{Î± : Type u} {Î² : Type v} {S : set Î±} {t : set Î²} {F : Î± â†’ Î²} {F' : Î² â†’ Î±} (h : set.Inv_on F' F S t) (hF : set.maps_to F S t) (hF' : set.maps_to F' t S) : set.bij_on F S t
{Î± : Type u_1} {Î¹ : Type u_3} {Î¹' : Type u_4} [Distrib_Lattice Î±] [OrderBot Î±] [DecidableEq Î¹] {S : Finset Î¹'} {g : Î¹' â†’ Finset Î¹} {F : Î¹ â†’ Î±} (hs : S.Sup_indep (Î» (i : Î¹'), (g i).Sup F)) (hg : âˆ€ (i' : Î¹'), i' âˆˆ S â†’ (g i').Sup_indep F) : (S.Sup g).Sup_indep F
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscrete_NormedField ð•‚] [NormedRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] [CharZero ð•‚] {x y : ð”¸} (hxy : Commute x y) (hx : x âˆˆ Emetric.Ball 0 (Exp_series ð•‚ ð”¸).radius) (hy : y âˆˆ Emetric.Ball 0 (Exp_series ð•‚ ð”¸).radius) : Exp ð•‚ (x + y) = Exp ð•‚ x * Exp ð•‚ y
(n A : â„•) (P : â„• â†’ Prop) [Decidable_Pred P] (pp : Function.Periodic P A) : (Finset.Filter P (Finset.Ico n (n + A))).Card = Nat.count P A
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e : LocalHomeomorph Î± Î²} {S : set Î±} {t : set Î²} : e._image S t â†’ e.to_local_Equiv.Target âˆ© â‡‘(e.Symm) â»Â¹' (e.to_local_Equiv.Source âˆ© S) = e.to_local_Equiv.Target âˆ© t
{K : Type v} [Field K] {P : Polynomial K} (hmo : P.monic) (hP : Polynomial.Splits (Ring_hom.Id K) P) : P.next_Coeff = -P.roots.Sum
{Î± : Type u} [PseudoMetricSpace Î±] {x : Î±} {r : â„} : Metric.Bounded (Metric.Ball x r)
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : MultilinearMap ð•œ E G) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘F mâˆ¥ â‰¤ C * Finset.Univ.Prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘F mâ‚ - â‡‘F mâ‚‚âˆ¥ â‰¤ C * Finset.Univ.Sum (Î» (i : Î¹), Finset.Univ.Prod (Î» (j : Î¹), Ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (LinearOrder.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
{Î± : Type u_1} {Î² : Type u_2} {e : local_Equiv Î± Î²} {S : set Î±} {t : set Î²} : e.Target âˆ© â‡‘(e.Symm) â»Â¹' S = e.Target âˆ© t â†’ e._image S t
(R : Type u_1) [CommRing R] (m : Type u_2) [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [Nontrivial R] : (LinearMap.trace R m).Comp (dual_tensor_hom R m m) = contract_Left R m
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {S : Finset Î±} : S âˆˆ ð’œ.Up_shadow â†” âˆƒ (t : Finset Î±) (h : t âˆˆ ð’œ) (A : Î±) (h : A âˆ‰ t), HasInsert.Insert A t = S
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (F : Î± â‰ƒâ‚œ Î²) (K : TopologicalSpace.Compacts Î±) : (â‡‘(TopologicalSpace.Compacts.Equiv F) K).carrier = â‡‘(F.Symm) â»Â¹' K.carrier
{Î± : sort u_1} {Î² : sort u_2} {Î³ : out_param (sort u_3)} [has_Coe Î± Î²] [has_Coe_ToFun Î² (Î» (_x : Î²), Î³)] (x : Î±) : â‡‘x = â‡‘â†‘x
{A B : â„•} (ha : A â‰  0) (hb : B â‰  0) : (A * B).Factors.to_Finset = A.Factors.to_Finset âˆª B.Factors.to_Finset
{Î± : Type u_1} [Preorder Î±] {A B : Î±} (h : A â‰¤ B) : set.ioi B âŠ† set.ioi A
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [module ð•œ Î²] [LinearOrder E] {S : set E} {F : E â†’ Î²} (hs : Convex ð•œ S) (hF : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ S â†’ y âˆˆ S â†’ x < y â†’ âˆ€ â¦ƒA B : ð•œâ¦„, 0 < A â†’ 0 < B â†’ A + B = 1 â†’ F (A â€¢ x + B â€¢ y) < A â€¢ F x + B â€¢ F y) : strict_Convex_on ð•œ S F
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} : Antitone_on F S â†’ Monotone_on (F âˆ˜ â‡‘order_dual.of_dual) S
{Î± : Type u_1} [circular_Preorder Î±] {A B C : Î±} (h : HasSbtw.Sbtw A B C) : HasSbtw.Sbtw B C A
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds A âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasDerivAt (Î» (u : â„), âˆ« (x : â„) in u..B, F x) (-C) A
{Î± : Type u_1} {R : Type u_2} {l : Filter Î±} {F : Î± â†’ R} {r : R} [Linear_ordered_Ring R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (Î» (x : Î±), F x * r) l Filter.at_IsBot
{n : â„•+} (h1 : n â‰  1) : âˆƒ (k : â„•+), n = k + 1
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {S : set E} : DifferentiableOn ð•œ F S â†’ Mdifferentiable_on (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F S
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] (S : Submodule K v) : Finite_dimensional.finrank K (v â§¸ S) + Finite_dimensional.finrank K â†¥S = Finite_dimensional.finrank K v
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {F : Î² â†’ Î³} {S : set Î²} {x : Î²} (h : x âˆˆ e.to_local_Equiv.Target) : Continuous_within_at F S x â†” Continuous_within_at (F âˆ˜ â‡‘e) (â‡‘e â»Â¹' S) (â‡‘(e.Symm) x)
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B} [Nontrivial A] (hx : IsIntegral A x) : minpoly A x â‰  0
{Î± : Type u_1} {Î² : Type u_2} {S : set Î±} {t : Î± â†’ set Î²} {x : Î±} {y : Î²} (xs : x âˆˆ S) (ytx : y âˆˆ t x) : y âˆˆ â‹ƒ (x : Î±) (h : x âˆˆ S), t x
(P : â„•) {Idx : Type u_2} [hp : Fact (Nat.Prime P)] (Î¦ : mv_Polynomial Idx â„š) (n : â„•) : witt_structure_rat P Î¦ n = â‡‘mv_Polynomial.C (1 / â†‘P ^ n) * (â‡‘(mv_Polynomial.Bindâ‚ (Î» (B : Idx), â‡‘(mv_Polynomial.Rename (Î» (i : â„•), (B, i))) (witt_Polynomial P â„š n))) Î¦ - (Finset.Range n).Sum (Î» (i : â„•), â‡‘mv_Polynomial.C (â†‘P ^ i) * witt_structure_rat P Î¦ i ^ P ^ (n - i)))
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] [strict_Convex_Space â„ E] {x y z : E} {A B r : â„} (hx : x âˆˆ metric.IsClosed_ball z r) (hy : y âˆˆ metric.IsClosed_ball z r) (hne : x â‰  y) (ha : 0 < A) (hb : 0 < B) (hab : A + B = 1) : A â€¢ x + B â€¢ y âˆˆ Metric.Ball z r
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î± â†’ Î² Ã— Î³} {x : Î±} (hF : Continuous_at F x) : Continuous_at (Î» (A : Î±), (F A).Snd) x
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] (F : P1 â†’áµƒ[k] P2) (P : P1) (v : v1) : â‡‘F (v +áµ¥ P) = â‡‘(F.Linear) v +áµ¥ â‡‘F P
{R : Type u_1} {Râ‚ : Type u_2} {Râ‚‚ : Type u_3} {mâ‚ : Type u_6} {mâ‚‚ : Type u_7} [CommSemiring R] [CommSemiring Râ‚] [AddCommMonoid mâ‚] [module Râ‚ mâ‚] [CommSemiring Râ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚‚ mâ‚‚] {iâ‚ : Râ‚ â†’+* R} {iâ‚‚ : Râ‚‚ â†’+* R} {B : mâ‚ â†’â‚›â‚—[iâ‚] mâ‚‚ â†’â‚›â‚—[iâ‚‚] R} : B.separating_Right â†” B.Flip.Ker = âŠ¥
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.RegularMono F] [e : CategoryTheory.Epi F] : CategoryTheory.IsIso F
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [InnerProductSpace ð•œ G] [Finite_dimensional ð•œ E] [Finite_dimensional ð•œ F] [Finite_dimensional ð•œ G] (A : F â†’â‚—[ð•œ] G) (B : E â†’â‚—[ð•œ] F) : â‡‘LinearMap.Adjoint (A.Comp B) = (â‡‘LinearMap.Adjoint B).Comp (â‡‘LinearMap.Adjoint A)
{G : Type u_1} [comm_Group G] : Group.nilpotency_class G â‰¤ 1
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} : -A < B â†’ -B < A
{F : Type u_3} [InnerProductSpace â„ F] {Î¹â‚ : Type u_1} {Sâ‚ : Finset Î¹â‚} {Wâ‚ : Î¹â‚ â†’ â„} (vâ‚ : Î¹â‚ â†’ F) (hâ‚ : Sâ‚.Sum (Î» (i : Î¹â‚), Wâ‚ i) = 0) {Î¹â‚‚ : Type u_2} {Sâ‚‚ : Finset Î¹â‚‚} {Wâ‚‚ : Î¹â‚‚ â†’ â„} (vâ‚‚ : Î¹â‚‚ â†’ F) (hâ‚‚ : Sâ‚‚.Sum (Î» (i : Î¹â‚‚), Wâ‚‚ i) = 0) : HasInner.inner (Sâ‚.Sum (Î» (iâ‚ : Î¹â‚), Wâ‚ iâ‚ â€¢ vâ‚ iâ‚)) (Sâ‚‚.Sum (Î» (iâ‚‚ : Î¹â‚‚), Wâ‚‚ iâ‚‚ â€¢ vâ‚‚ iâ‚‚)) = -Sâ‚.Sum (Î» (iâ‚ : Î¹â‚), Sâ‚‚.Sum (Î» (iâ‚‚ : Î¹â‚‚), Wâ‚ iâ‚ * Wâ‚‚ iâ‚‚ * (âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥ * âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥))) / 2
{E : Type u_2} [semi_NormedGroup E] [NormedSpace â„ E] {S : set E} (hs : Convex â„ S) : Convex_on â„ S HasNorm.norm
{Î± : Type u_1} [has_LT Î±] {A B : Î±} : A â‹– B â†’ â‡‘order_dual.to_dual B â‹– â‡‘order_dual.to_dual A
{R S : Type u} [CommRing R] [CommRing S] (m : Submonoid R) (S' : Type u) [CommRing S'] [Algebra S S'] [Algebra R S] [Algebra R S'] [IsScalarTower R S S'] [IsLocalization (Submonoid.Map â†‘(Algebra_Map R S) m) S'] (x : S) (S : Finset S') (hx : â‡‘(Algebra_Map S S') x âˆˆ Algebra.Adjoin R â†‘S) : âˆƒ (m : â†¥m), m â€¢ x âˆˆ Algebra.Adjoin R â†‘(IsLocalization.Finset_integer_multiple (Submonoid.Map â†‘(Algebra_Map R S) m) S)
{Î¹ : Type u_1} {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [ordered_AddCommMonoid N] (F : m â†’ N) (P : m â†’ Prop) (h_One : F 0 = 0) (h_Mul : âˆ€ (x y : m), P x â†’ P y â†’ F (x + y) â‰¤ F x + F y) (hp_Mul : âˆ€ (x y : m), P x â†’ P y â†’ P (x + y)) (g : Î¹ â†’ m) {S : Finset Î¹} (hs : âˆ€ (i : Î¹), i âˆˆ S â†’ P (g i)) : F (S.Sum (Î» (i : Î¹), g i)) â‰¤ S.Sum (Î» (i : Î¹), F (g i))
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] (F : S.Localization_Map N) : F.of_Add_Equiv_of_Dom _ = F
(n : â„•) (R : Type u_1) (hpos : 0 < n) [Ring R] [Nontrivial R] : 0 < (Polynomial.cyclotomic n R).degree
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hst : Disjoint S t) (hs : (S âˆ© Function.Support F).Finite) (ht : (t âˆ© Function.Support F).Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S âˆª t), F i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ t), F i))
{ð•œ : Type u_3} {E : Type u_4} [NormedField ð•œ] [AddCommGroup E] [NormedSpace â„ ð•œ] [module ð•œ E] [module â„ E] [IsScalarTower â„ ð•œ E] (P : Seminorm ð•œ E) (x : E) (r : â„) : Convex â„ (P.ball x r)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x y : E} : HasInner.inner (x + y) (x + y) + HasInner.inner (x - y) (x - y) = 2 * (HasInner.inner x x + HasInner.inner y y)
{C : Type u} [CategoryTheory.Category C] (Jâ‚ : CategoryTheory.GrothendieckTopology C) {x Y : C} (F : Y âŸ¶ x) (S : CategoryTheory.Sieve x) : Jâ‚.close (CategoryTheory.Sieve.pullback F S) = CategoryTheory.Sieve.pullback F (Jâ‚.close S)
{Î± : Type u_2} [Bornology Î±] {S : set Î±} : Bornology._cobounded Sá¶œ â†’ Bornology._bounded S
{P : â„•} [hp : Fact (Nat.Prime P)] (x : witt_Vector P (Zmod P)) : â‡‘witt_Vector.verschiebung x = x * â†‘P
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} {Sâ‚ Sâ‚‚ : Affine.Simplex â„ P n} (h : set.Range Sâ‚.points = set.Range Sâ‚‚.points) : Sâ‚.circumcenter = Sâ‚‚.circumcenter
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [_R_or_C ð•‚] [normed_CommRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] {x y : ð”¸} : Exp ð•‚ (x + y) = Exp ð•‚ x * Exp ð•‚ y
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (x : Î± 0) (P : Î  (i : Fin n), Î± i.Succ) (z : Î± 0) : Function.update (Fin.Cons x P) 0 z = Fin.Cons z P
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Fintype Î¹] [DecidableEq Î¹] [Î  (i : Î¹), DecidableEq (Î± i)] {P : (Î  (i : Î¹), Finset (Î± i)) â†’ Prop} (F : Î  (i : Î¹), Finset (Î± i)) (h0 : P (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), Finset (Î± i)) (i : Î¹) (x : Î± i), x âˆ‰ g i â†’ P g â†’ P (Function.update g i (HasInsert.Insert x (g i)))) : P F
{Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î±] [DecidableEq Î²] (F : Î± â†’ Î²) (S : Multiset Î±) (hF : Function.Injective F) (x : Î±) : Multiset.count (F x) (Multiset.Map F S) = Multiset.count x S
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Kâ‚ Kâ‚‚ : Submodule ð•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) : Kâ‚‚á—® â‰¤ Kâ‚á—®
{G : Type u_7} [comm_Group G] (L : List G) (n : â„•) (A : G) : (L.update_nth n A).Prod = L.Prod * dite (n < L.length) (Î» (hn : n < L.length), (L.nth_LE n hn)â»Â¹ * A) (Î» (hn : Â¬n < L.length), 1)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {P : Î¹ â†’ P} (hp : AffineIndependent k P) (j : Î¹) (W : Î¹ â†’ kË£) : AffineIndependent k (Î» (i : Î¹), â‡‘(affine_Map.line_Map (P j) (P i)) â†‘(W i))
{Î± : Type u_2} [DecidableEq Î±] [has_Inv Î±] {S : Finset Î±} : Sâ»Â¹.Nonempty â†’ S.Nonempty
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {E : Type W} [NormedGroup E] [NormedSpace ð•œ E] {F : ð•œ â†’ F} {F' : F} (x : ð•œ) {S : set ð•œ} {l : F â†’ E} {l' : F â†’L[ð•œ] E} {t : set F} (hl : HasFderivWithinAt l l' t (F x)) (hF : HasDerivWithinAt F F' S x) (hst : set.maps_to F S t) : HasDerivWithinAt (l âˆ˜ F) (â‡‘l' F') S x
{Î± : Type u} [PseudoMetricSpace Î±] (x y : Î±) : HasNndist.nndist x y = (HasEdist.edist x y).to_Nnreal
{m : Type u_1} (R : Type u_3) {S : Type u_4} [Fintype m] [DecidableEq m] [CommSemiring R] [CommSemiring S] [Algebra R S] (A : Matrix m m S) : â‡‘((mv_Polynomial.aeval (Î» (P : m Ã— m), A P.fst P.Snd)).Map_Matrix) (Matrix.mv_Polynomial.x m m R) = A
{mâ‚€ : Type u_1} [MulZeroOneClass mâ‚€] : 0 = 1 â†” Subsingleton mâ‚€
{C : Cardinal} (h : Cardinal.aleph0 â‰¤ C) : C * C = C
{E : Type u_1} [NormedGroup E] {A : â„} {F g : â„‚ â†’ E} {l : Filter â„‚} (hBf : âˆƒ (C : â„) (h : C < A) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ l] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hBg : âˆƒ (C : â„) (h : C < A) (B : â„), g =O[Filter.comap Complex.Abs Filter.at_top âŠ“ l] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) : âˆƒ (C : â„) (h : C < A) (B : â„), (F - g) =O[Filter.comap Complex.Abs Filter.at_top âŠ“ l] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)
{Î± : Type u} {S t : set Î±} {l : Filter Î±} : (âˆ€á¶  (x : Î±) in l, x âˆˆ S â†” x âˆˆ t) â†’ S =á¶ [l] t
{x Y : CompHaus} (F : x âŸ¶ Y) : IsClosed_Map â‡‘F
{G : Type u_10} {h : Type u_11} [Group G] [division_Monoid h] (h : G â‰ƒ* h) (x y : G) : â‡‘h (x / y) = â‡‘h x / â‡‘h y
{Î± : Type u_1} {Î² : Type u_2} {e e' : local_Equiv Î± Î²} (h : e â‰ˆ e') : e.Source = e'.Source
{x : Type u} {Î± : Type v} [TopologicalSpace x] [LinearOrder Î±] [TopologicalSpace Î±] [order_IsClosed_topology Î±] {S : set x} (hs : IsPreconnected S) {A B : x} (ha : A âˆˆ S) (hb : B âˆˆ S) {F g : x â†’ Î±} (hF : Continuous_on F S) (hg : Continuous_on g S) (ha' : F A â‰¤ g A) (hb' : g B â‰¤ F B) : âˆƒ (x : x) (h : x âˆˆ S), F x = g x
{z W : â„‚} (hz : 0 â‰¤ z.re âˆ¨ z.im â‰  0) (hw : 0 < W.re) : Continuous_at (Î» (x : â„‚), x ^ W) z
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} {F' : â„ â†’ E} (hab : A â‰¤ B) (hcont : Continuous_on F (set.icc A B)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivAt F (F' x) x) (hint : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : âˆ« (y : â„) in A..B, F' y = F B - F A
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {F : Î± â†’ Î² â†’ Î³} {ta1 ta2 : TopologicalSpace Î±} {tb1 tb2 : TopologicalSpace Î²} {Tc1 : TopologicalSpace Î³} (h : Continuous (Î» (P : Î± Ã— Î²), F P.fst P.Snd)) : Continuous (Î» (P : Î± Ã— Î²), F P.fst P.Snd)
{C : Type uâ‚} [CategoryTheory.SmallCategory C] {Pâ‚ Pâ‚‚ : Cáµ’áµ– â¥¤ Type uâ‚} (Î± : Pâ‚ âŸ¶ Pâ‚‚) (j : (Pâ‚.Elements)áµ’áµ–) : (CategoryTheory.Cocone_of_representable Pâ‚).Î¹.App j â‰« Î± = (CategoryTheory.Cocone_of_representable Pâ‚‚).Î¹.App ((CategoryTheory.Category_of_Elements.Map Î±).Op.obj j)
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : C(x, â„)) (e : x â†’ Y) (hE : IsClosed_Embedding e) : âˆƒ (g : C(Y, â„)), â‡‘g âˆ˜ e = â‡‘F
{P : â„•} (hp : Nat.Prime P) {n B : â„•} : Nat.log P n < B â†’ multiplicity P n.factorial = â†‘((Finset.Ico 1 B).Sum (Î» (i : â„•), n / P ^ i))
(G : Type u_1) [Group G] : Group.IsNilpotent G â†” âˆƒ (n : â„•) (h : â„• â†’ Subgroup G), IsAscendingCentralSeries h âˆ§ h n = âŠ¤
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F g : Î± â†’ m} {S : set Î±} (hs : S.Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i * g i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), g i))
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [Finite_dimensional ð•œ E] (t : E â†’â‚—[ð•œ] E) (x : E) : 0 â‰¤ â‡‘_R_or_C.re (HasInner.inner x (â‡‘(â‡‘LinearMap.Adjoint t * t) x))
(ð•œ : Type u_5) (E : Type u_6) [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [Nontrivial E] (C : â„) : âˆƒ (x : E), C < âˆ¥xâˆ¥
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {S : set ð•œ} {n : WithTop â„•} (hs : UniqueDiffOn ð•œ S) : ContDiff_on ð•œ n F S â†” (âˆ€ (m : â„•), â†‘m â‰¤ n â†’ Continuous_on (iterated_deriv_within m F S) S) âˆ§ âˆ€ (m : â„•), â†‘m < n â†’ DifferentiableOn ð•œ (iterated_deriv_within m F S) S
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {l : Filter Î±} {A : Î±} : IsMin_Filter F l A â†’ IsMax_Filter (â‡‘order_dual.to_dual âˆ˜ F) l A
{B : Type u_3} {S : B} {m : Type u_1} [AddCommMonoid m] [set_like B m] [Add_Submonoid_class B m] {Î¹ : Type u_2} {t : Finset Î¹} {F : Î¹ â†’ m} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Sum (Î» (C : Î¹), F C) âˆˆ S
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] {F : Type v} [NormedGroup F] [NormedSpace â„‚ F] [Nontrivial E] [Finite_dimensional â„‚ E] {F : E â†’ F} {U : set E} (hb : Metric.Bounded U) (hne : U.Nonempty) (hD : Diff_Cont_on_cl â„‚ F U) : âˆƒ (z : E) (h : z âˆˆ Frontier U), IsMaxOn (HasNorm.norm âˆ˜ F) (Closure U) z
{Î± : Type u_1} [CompleteLattice Î±] {A : Î±} {S : set Î±} : (â¨† (B : Î±) (h : B âˆˆ S), B âŠ“ A) â‰¤ HasSup.Sup S âŠ“ A
{Î± : Type u_3} [Linear_ordered_AddCommGroup Î±] : Filter.Tendsto HasAbs.Abs Filter.at_top Filter.at_top
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] [AddGroup Î±] [uniform_AddGroup Î±] {hom : Type u_3} [UniformSpace Î²] [AddGroup Î²] [uniform_AddGroup Î²] [AddMonoid_hom_class hom Î± Î²] (F : hom) (hF : Continuous_at â‡‘F 0) : uniform_Continuous â‡‘F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (P : P) (S1 S2 : AffineSubspace k P) : P âˆˆ S1 âŠ“ S2 â†” P âˆˆ S1 âˆ§ P âˆˆ S2
(n : â„•) {m : â„} (m1 : 1 < m) : âˆ‘' (i : â„•), 1 / m ^ (i + (n + 1)).factorial < (1 - 1 / m)â»Â¹ * (1 / m ^ (n + 1).factorial)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {v : â„ â†’ E â†’ E} {K : Nnreal} (hv : âˆ€ (t : â„), LipschitzWith K (v t)) {F g : â„ â†’ E} {A B Î´ : â„} (hF : Continuous_on F (set.icc A B)) (hF' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt F (v t (F t)) (set.ici t) t) (hg : Continuous_on g (set.icc A B)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt g (v t (g t)) (set.ici t) t) (ha : HasDist.dist (F A) (g A) â‰¤ Î´) (t : â„) (h : t âˆˆ set.icc A B) : HasDist.dist (F t) (g t) â‰¤ Î´ * Real.Exp (â†‘K * (t - A))
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (W : Î¹ â†’ k) (P : Î¹ â†’ P) (B : P) {Sâ‚ Sâ‚‚ : Finset Î¹} (h : Sâ‚ âŠ† Sâ‚‚) : â‡‘(Sâ‚.weighted_vsub_of_point P B) W = â‡‘(Sâ‚‚.weighted_vsub_of_point P B) (â†‘Sâ‚.indicator W)
{ð•œ : Type u_1} [_R_or_C ð•œ] {E : Type u_2} {E' : Type u_3} [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ E'] (F : E â‰ƒâ‚—áµ¢[ð•œ] E') (K : Submodule ð•œ E) [CompleteSpace â†¥K] : reflection (Submodule.Map â†‘(F.to_Linear_Equiv) K) = F.Symm.Trans ((reflection K).Trans F)
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [hÎ¹ : Î  (n : Î²), Encodable (Î¹ n)] (D : â„) (S : set x) {l : Filter Î²} (r : Î² â†’ Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ set x) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), Emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, S âŠ† â‹ƒ (i : Î¹ n), t n i) : â‡‘(MeasureTheory.Measure.hausdorff_measure D) S â‰¤ l.liminf (Î» (n : Î²), âˆ‘' (i : Î¹ n), Emetric.diam (t n i) ^ D)
(R : Type u) [CommRing R] [IsDomain R] [discrete_Valuation_Ring R] : âˆƒ (Ï– : R), Prime Ï–
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (m : m) : âˆ¥â‡‘(Quotient_AddGroup.Mk' S) mâˆ¥ â‰¤ âˆ¥mâˆ¥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P âŸ¶ q) [CategoryTheory.Mono F] : Function.Injective â‡‘F
{L : FirstOrder.Language} {m : Type W} [L.structure m] (S : L.Substructure m) : â‡‘(FirstOrder.Language.Substructure.Closure L) â†‘S = S
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] {F : J â¥¤ Profinite} (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) {U : set â†¥(C.x)} (hU : IsClopen U) : âˆƒ (j : J) (v : set â†¥(F.obj j)) (hV : IsClopen v), U = â‡‘(C.Ï€.App j) â»Â¹' v
{m : Type u_2} [AddCommGroup m] {A : Type u_1} [CommRing A] [module A m] (F : m â‰ƒâ‚—[A] m) : IsUnit (â‡‘LinearMap.det â†‘F)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : S -áµ¥ S âŠ† â†‘(Vector_Span k S)
{m : Type u_1} {R : Type u_4} [non_unital_non_assoc_Semiring R] [set_like m R] [MulMemClass m R] {S : m} {A B : R} (ha : A âˆˆ AddSubmonoid.Closure â†‘S) (hb : B âˆˆ AddSubmonoid.Closure â†‘S) : A * B âˆˆ AddSubmonoid.Closure â†‘S
{Î± : Type u_1} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {S : Finset Î±} : S âˆˆ ð’œ.shadow â†” âˆƒ (t : Finset Î±) (h : t âˆˆ ð’œ), S âŠ† t âˆ§ t.Card = S.Card + 1
{R : Type u_2} [cancel_CommMonoid_with_Zero R] [Unique_factorization_Monoid R] [Nontrivial R] [normalization_Monoid R] [DecidableEq R] [dec_Dvd : Decidable_Rel has_Dvd.Dvd] {A B : R} (ha : Irreducible A) (hb : B â‰  0) : multiplicity A B = â†‘(Multiset.count (â‡‘normalize A) (Unique_factorization_Monoid.normalized_Factors B))
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {ps : set P} (hps : ps âŠ† â†‘S) (P : P) : (âˆƒ (r : â„), âˆ€ (P1 : P), P1 âˆˆ ps â†’ HasDist.dist P1 P = r) â†” âˆƒ (r : â„), âˆ€ (P1 : P), P1 âˆˆ ps â†’ HasDist.dist P1 â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P) = r
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [_R_or_C ð•‚] [normed_CommRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] {Î¹ : Type u_3} (S : Finset Î¹) (F : Î¹ â†’ ð”¸) : Exp ð•‚ (S.Sum (Î» (i : Î¹), F i)) = S.Prod (Î» (i : Î¹), Exp ð•‚ (F i))
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} {S t : set Î±} : Emetric.Inf_edist x (S âˆª t) = Emetric.Inf_edist x S âŠ“ Emetric.Inf_edist x t
(x : â„) (h : Real.cos x â‰  0) : deriv (Î» (y : â„), Real.tan y - y) x = 1 / Real.cos x ^ 2 - 1
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {S : set E} {t : set F} {g : F â†’ G} {F : E â†’ F} (hg : ContDiff_on ð•œ n g t) (hF : ContDiff_on ð•œ n F S) (st : S âŠ† F â»Â¹' t) : ContDiff_on ð•œ n (g âˆ˜ F) S
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {m : Type u_6} [CommSemiring R] [AddCommMonoid m] [module R m] [Fintype Î¹'] [Fintype Î¹] [DecidableEq Î¹] [DecidableEq Î¹'] (B : Basis Î¹ R m) (v : Î¹' â†’ m) (e : Î¹ â‰ƒ Î¹') : (B.reindex e).to_Matrix v = â‡‘(Matrix.reindex_alg_Equiv R e) (B.to_Matrix (v âˆ˜ â‡‘e))
{x : Type u_2} [EmetricSpace x] (S : Finset x) : dimH â†‘S = 0
{Î± : Type u} {F g : Î± â†’ Î±} {x : Î±} (hF : Function.IsFixedPt F x) (h : Function.LeftInverse g F) : Function.IsFixedPt g x
{R : Type u} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] [Gcd_Monoid R] (A B : R) : âˆƒ (x y : R), Gcd_Monoid.Gcd A B = A * x + B * y
(R : Type u_1) [CommRing R] (Î¹ : Type u_2) [Fintype Î¹] : Algebra.Finite_presentation R (mv_Polynomial Î¹ R)
{n : â„•} {Î± : Type u_1} [Preorder Î±] {F : Fin (n + 1) â†’ Î±} : StrictAnti F â†” âˆ€ (i : Fin n), F i.Succ < F (â‡‘Fin.cast_Succ i)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {Bâ‚‚ : Basis (Fin 2) â„ v} (hbâ‚‚ : Orthonormal â„ â‡‘Bâ‚‚) (ho : B.Orientation = -Bâ‚‚.Orientation) (x y : v) : hb.oangle x y = -hbâ‚‚.oangle x y
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : â„ â†’ E} {F' : E} {S : set â„} {x r : â„} (hF : HasDerivWithinAt F F' S x) (hr : âˆ¥F'âˆ¥ < r) : âˆ€á¶  (z : â„) in nhds_within x S, âˆ¥z - xâˆ¥â»Â¹ * âˆ¥F z - F xâˆ¥ < r
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {S : Setoid Î±} (h : âˆ€ (x y : Î±), r x y â†’ S.Rel x y) : EqvGen.Setoid r â‰¤ S
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x y : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) (h : y âˆˆ Emetric.Ball x r) : AnalyticAt ð•œ F y
{x : Pgame} : x.lf 0 â†” âˆƒ (j : x.Right_moves), âˆ€ (i : (x.move_Right j).Left_moves), ((x.move_Right j).move_Left i).lf 0
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) {r : â„} (hr : r < 0) : o.oangle (r â€¢ x) y = o.oangle (-x) y
{Î¹ : Type u_1} {ð•œ : Type u_2} [_R_or_C ð•œ] {E : Type u_3} [InnerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), InnerProductSpace ð•œ (G i)] {v : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ v) [âˆ€ (i : Î¹), CompleteSpace (G i)] : hV.Linear_Isometry.to_LinearMap.Range = (â¨† (i : Î¹), (v i).to_LinearMap.Range).topological_Closure
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (Î¸ : Real.Angle) : â‡‘Linear_Equiv.det (o.rotation Î¸).to_Linear_Equiv = 1
{Î± : sort u_1} {P : Î± â†’ Prop} {q : Î  (x : Î±), P x â†’ Prop} : (âˆ€ (x : Î±) (h : P x), q x h) â†” âˆ€ (x : {A // P A}), q â†‘x _
{G : Type u} [Monoid G] : _of_Fin_order 1
{n : â„¤} (hn : n â‰  -1) (C W : â„‚) (R : â„) : âˆ® (z : â„‚) in C(C, R), (z - W) ^ n = 0
{m : Type u_3} {N : Type u_4} [has_Mul m] [has_Mul N] {F g : m â†’â‚™* N} : F = g â†” âˆ€ (x : m), â‡‘F x = â‡‘g x
{Î± : Type u} (S : set (set Î±)) : Cardinal.Mk â†¥{t : set Î± | Measurable_set t} â‰¤ LinearOrder.max (Cardinal.Mk â†¥S) 2 ^ Cardinal.aleph0
{vâ‚ : Type u_2} {vâ‚‚ : Type u_3} [semi_NormedGroup vâ‚] [semi_NormedGroup vâ‚‚] (F : NormedGroup_hom vâ‚ vâ‚‚) (x : vâ‚) : âˆ¥â‡‘F xâˆ¥ â‰¤ âˆ¥Fâˆ¥ * âˆ¥xâˆ¥
{Î± : Type u_1} [Monoid Î±] {A B : Î±} {u : Î±Ë£} : A âˆ£ B * â†‘u â†” A âˆ£ B
 : Orthonormal â„‚ (fourier_Lp 2)
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {A B : Matrix n n Î±} (h : B.Mul A = 1) : Aâ»Â¹ = B
{mâ‚€ : Type u_1} [Mul_Zero_class mâ‚€] : has_Mul.Mul 0 = Function.Const mâ‚€ 0
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] [NoZeroSmulDivisors R m] {v : m} (hv : v â‰  0) {r : R} (hr : r â‰  0) : SameRay R v (r â€¢ v) â†” 0 < r
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {F : E Ã— F â†’ G} (h : IsBoundedBilinearMap ð•œ F) : IsBoundedLinearMap ð•œ (Î» (P : E Ã— F), h.deriv P)
{R : Type u_1} {m : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup m] [module R m] [no_Zero_divisors R] {B : m â†’â‚—[R] m â†’â‚—[R] R} (v : Basis n R m) (hO : B._Ortho â‡‘v) (h : âˆ€ (i : n), Â¬B.IsOrtho (â‡‘v i) (â‡‘v i)) : B.separating_Right
{P x : â„} {r : â„š} (hr : r â‰  0) : LiouvilleWith P (â†‘r * x) â†” LiouvilleWith P x
{Î± : Type u_1} [HasSup Î±] [HasInf Î±] (Sup_comm : âˆ€ (A B : Î±), A âŠ” B = B âŠ” A) (Sup_assoc : âˆ€ (A B C : Î±), A âŠ” B âŠ” C = A âŠ” (B âŠ” C)) (Sup_idem : âˆ€ (A : Î±), A âŠ” A = A) (Inf_comm : âˆ€ (A B : Î±), A âŠ“ B = B âŠ“ A) (Inf_assoc : âˆ€ (A B C : Î±), A âŠ“ B âŠ“ C = A âŠ“ (B âŠ“ C)) (Inf_idem : âˆ€ (A : Î±), A âŠ“ A = A) (Sup_Inf_self : âˆ€ (A B : Î±), A âŠ” A âŠ“ B = A) (Inf_Sup_self : âˆ€ (A B : Î±), A âŠ“ (A âŠ” B) = A) : SemilatticeSup.to_PartialOrder Î± = SemilatticeInf.to_PartialOrder Î±
{Î± : Type u} (S : set Î±) : IsOpen {u : Ultrafilter Î± | S âˆˆ u}
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {v : v} (P : P) {direction : Submodule k v} (hv : v âˆˆ direction) : v +áµ¥ P âˆˆ AffineSubspace.Mk' P direction
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : F' =o[l] g â†’ (Î» (x : Î±), -F' x) =o[l] g
{Î± : Type u} [OrderedSemiring Î±] [Nontrivial Î±] : 0 < 1
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [division_Monoid Î²] (F : Î± â†’* Î²) (g h : Î±) : â‡‘F (g * hâ»Â¹) = â‡‘F g * (â‡‘F h)â»Â¹
{m : Type u_1} [MulOneClass m] {S : set m} : S âŠ† â†‘(Submonoid.Closure S)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {S : set ð•œ} {n : WithTop â„•} (h : âˆ€ (m : â„•), â†‘m â‰¤ n â†’ DifferentiableOn ð•œ (iterated_deriv_within m F S) S) : ContDiff_on ð•œ n F S
{Î± : Type u_1} {Î² : Type u_2} {F g : Î± â†’ Î²} {m : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} [Measurable_Singleton_class Î±] (hF : Measurable F) (h : {x : Î± | F x â‰  g x}.countable) : Measurable g
{Î± : Type u} {Î² : Type v} [has_Mul Î±] [has_Mul Î²] {Î³ : Type u_1} [has_Mul Î³] {F : Î± â†’ Î²} {g : Î² â†’ Î³} (hF : _Mul_hom F) (hg : _Mul_hom g) : _Mul_hom (g âˆ˜ F)
{Î± : Type u} {Î² : Type v} [MulOneClass Î±] [MulOneClass Î²] {F : Î± â†’ Î²} (hF : _Monoid_hom F) {Î³ : Type u_1} [MulOneClass Î³] {g : Î² â†’ Î³} (hg : _Monoid_hom g) : _Monoid_hom (g âˆ˜ F)
{m : Type u_1} [has_Add m] {S : set m} {S : Add_Subsemigroup m} : Add_Subsemigroup.Closure S â‰¤ S â†” S âŠ† â†‘S
{m : Type u_1} [MulOneClass m] {N : Type u_2} [MulOneClass N] (F : m â†’* N) (hF : Function.Surjective â‡‘F) : F.mrange = âŠ¤
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {Î± : â†¥(IsSolvableByRad F E)} {n : â„•} (hn : n â‰  0) (hÎ± : IsSolvableByRad.P (Î± ^ n)) : IsSolvableByRad.P Î±
{Î± : Type u_1} [generalized_boolean_Algebra Î±] {F D : â„• â†’ Î±} (hdisj : Pairwise (Disjoint on D)) (hsups : partial_sups D = partial_sups F) : D = disjointed F
{x : Type u_1} {m : Type u_4} {n : Type u_5} {P : Type u_6} {R : Type u_8} [TopologicalSpace x] [TopologicalSpace R] [Fintype n] [has_Mul R] [AddCommMonoid R] [has_Continuous_Add R] [has_Continuous_Mul R] {A : x â†’ Matrix m n R} {B : x â†’ Matrix n P R} (hA : Continuous A) (hB : Continuous B) : Continuous (Î» (x : x), (A x).Mul (B x))
 : Finset.Nat.antidiagonal 0 = {(0, 0)}
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [non_assoc_Semiring Î²] [non_assoc_Semiring Î³] (g : Î² â†’+* Î³) (F : Î± â†’ Î²) (S : Finset Î±) : â‡‘g (S.Sum (Î» (x : Î±), F x)) = S.Sum (Î» (x : Î±), â‡‘g (F x))
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) : o.rotation 0 = Linear_Isometry_Equiv.refl â„ v
{Î± : Type u_3} [SemilatticeInf Î±] (A : Î±) : Filter.at_IsBot = Filter.comap Coe Filter.at_IsBot
{Î± : Type u} {L : List (Î± Ã— Bool)} : free_Group.red List.Nil L â†” L = List.Nil
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) : 0 âˆˆ S
{Î± : Type u} [CompleteLattice Î±] {J : Type u} [CategoryTheory.SmallCategory J] (F : J â¥¤ Î±) : CategoryTheory.Limits.Limit F = infi F.obj
{m : Type u_3} {N : Type u_4} [has_Zero m] [has_Zero N] (F : ZeroHom m N) {x y : m} (h : x = y) : â‡‘F x = â‡‘F y
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A : Î±} : 1 â‰¤ Aâ»Â¹ â†” A â‰¤ 1
{m : Type u_3} {S : Type u_4} [sub_Neg_Monoid m] [set_like S m] [hSM : Add_Subgroup_class S m] {h : S} {x y : m} (hx : x âˆˆ h) (hy : y âˆˆ h) : x - y âˆˆ h
{Î± : Type u_1} [MeasurableSpace Î±] {F g : Î± â†’ â„} {S : set Î±} (hF : Measurable F) (hg : Measurable g) (hs : Measurable_set S) : Measurable_set (RegionBetween F g S)
{ð•œ : Type u_1} [_R_or_C ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {x : E} (hx : x â‰  0) : âˆ¥(â†‘âˆ¥xâˆ¥)â»Â¹ â€¢ xâˆ¥ = 1
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A : Î±} : -A < 0 â†” 0 < A
{n m : â„•} (h : n = m) : â‡‘(Fin.cast h) = cast _
{m : Type u_2} {n : Type u_3} (R : Type u_11) [CommRing R] [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (e : m â‰ƒ n) (A : Matrix m m R) : (â‡‘(Matrix.reindex_alg_Equiv R e) A).det = A.det
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [CompactSpace Î±] [MetricSpace Î²] (x : Î±) : Continuous (Î» (F : C(Î±, Î²)), â‡‘F x)
{Î± : sort u_1} {Î³ : sort u_4} {r : Î± â†’ Î± â†’ Prop} (F : Î± â†’ Î³) (h : âˆ€ (Aâ‚ Aâ‚‚ : Î±), r Aâ‚ Aâ‚‚ â†’ F Aâ‚ = F Aâ‚‚) (A : Î±) : Quot.Lift F h (Quot.Mk r A) = F A
{Î± : Type u} [non_unital_non_assoc_Ring Î±] (k : Î±) (h : âˆ€ (x : Î±), k * x = 0 â†’ x = 0) : IsLeftRegular k
{Î± : Type u} {Î² : Type v} [Group Î±] [MulAction Î± Î²] [HasFaithfulSmul Î± Î²] : Function.Injective MulAction.to_perm
(R : Type u_1) {m : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid m] [module R m] (S : set m) [Semiring S] [HasScalar R S] [module S m] [IsScalarTower R S m] : â†‘(Submodule.Span R S) âŠ† â†‘(Submodule.Span S S)
{F : Type u_3} [InnerProductSpace â„ F] (x : F) (r : â„) : HasInner.inner (r â€¢ x) x = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
{Î± : Type u} {Î² : Type v} {F : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} : Filter.Tendsto F lâ‚ lâ‚‚ â†’ lâ‚ â‰¤ Filter.comap F lâ‚‚
{A B : â„} {F F' g : â„ â†’ â„} (h : âˆ€ (x : â„), x âˆˆ set.Interval A B â†’ HasDerivAt F (F' x) x) (h' : Continuous_on F' (set.Interval A B)) (hg : Continuous g) : âˆ« (x : â„) in A..B, (g âˆ˜ F) x * F' x = âˆ« (x : â„) in F A..F B, g x
(k : Type u_1) [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) [CharZero k] [Fintype Î¹] (h : S.Nonempty) : Finset.Univ.Sum (Î» (i : Î¹), Finset.centroid_weights_indicator k S i) = 1
{m : Type u_3} {N : Type u_4} {F : Type u_8} {mM : AddZeroClass m} {mN : AddZeroClass N} [AddMonoid_hom_class F m N] (F : F) {x : m} (hx : âˆƒ (y : m), y + x = 0) : âˆƒ (y : N), y + â‡‘F x = 0
{E : Type u_2} {ð•œ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] {S : set E} (hs : Convex ð•œ S) {A B : ð•œ} (ha : 0 < A) (hb : 0 â‰¤ B) (hab : A + B = 1) : A â€¢ Interior S + B â€¢ S âŠ† Interior S
{Î± : Type u_1} [Preorder Î±] {A B : Î±} (h : A â‰¤ B) : Â¬A â©¿ B â†” âˆƒ (C : Î±), A < C âˆ§ C < B
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (F : G â†’* N) {h K : Subgroup G} (hH : F.Ker â‰¤ h) (hK : F.Ker â‰¤ K) (hF : Subgroup.Map F h = Subgroup.Map F K) : h = K
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B C : Î±} : A < B * C â†’ Bâ»Â¹ * A < C
(K : Type u) [DivisionRing K] {Î¹ : Type v} [Fintype Î¹] : Finite_dimensional.finrank K (Î¹ â†’ K) = Fintype.Card Î¹
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] (S : Submodule K v) : Finite_dimensional.finrank K â†¥S â‰¤ Finite_dimensional.finrank K v
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} {S t : set Î±} : Emetric.Inf_edist x t â‰¤ Emetric.Inf_edist x S + Emetric.Hausdorff_edist S t
{P : â„•} {R : Type u_1} [hp : Fact (Nat.Prime P)] [CommRing R] (x : witt_Vector P R) : â‡‘witt_Vector.frobenius (â‡‘witt_Vector.verschiebung x) = x * â†‘P
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [NormedSpace ð•œ E'] {n : WithTop â„•} {F : E â†’ E'} {S : set E} {x : E} : ContDiff_within_at ð•œ n F S x â†’ Cont_mdiff_within_at (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') n F S x
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.Int_fract_pair K} (nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n) : 0 â‰¤ ifp_n.fr
{G : Type u_1} [Group G] (K : Subgroup G) {l : List G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.Prod âˆˆ K
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [DenselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [TopologicalSpace Î´] [order_IsClosed_topology Î´] {F : Î± â†’ Î´} {S : set Î±} [S.Ord_connected] (hs : S.Nonempty) (hF : Continuous_on F S) (hbot : Filter.Tendsto (Î» (x : â†¥S), F â†‘x) Filter.at_IsBot Filter.at_top) (htop : Filter.Tendsto (Î» (x : â†¥S), F â†‘x) Filter.at_top Filter.at_IsBot) : set.surj_on F S set.Univ
{A : â„•} : â†‘(Nat.sqrt A) â‰¤ Real.sqrt â†‘A
{C : Type uâ‚} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : CategoryTheory.Presieve.IsSheafFor P â‡‘S) (tâ‚ tâ‚‚ : CategoryTheory.yoneda.obj x âŸ¶ P) (ht : S.Functor_inclusion â‰« tâ‚ = S.Functor_inclusion â‰« tâ‚‚) : tâ‚ = tâ‚‚
{Î± : Type u} [TopologicalSpace Î±] {x : Î±} : Dense {x}á¶œ â†” Â¬IsOpen {x}
{G : Type u_7} [Group G] (L : List G) : L.reverse.Prod = ((List.Map (Î» (x : G), xâ»Â¹) L).Prod)â»Â¹
{m : Type u_1} [has_Mul m] {C D : Con m} {x y : m} : â‡‘(C âŠ“ D) x y â†” â‡‘C x y âˆ§ â‡‘D x y
{ð•œ : Type u} {A : Type v} [Field ð•œ] [Ring A] [Algebra ð•œ A] [Nontrivial A] (k : ð•œ) (A : A) (ha : (Spectrum ð•œ A).Nonempty) : Spectrum ð•œ (k â€¢ A) = k â€¢ Spectrum ð•œ A
{F : â„• â†’ â„} (hfa : Monotone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) : Cauchy_Seq (Î» (n : â„•), (Finset.Range (n + 1)).Sum (Î» (i : â„•), (-1) ^ i * F i))
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommGroup E] [HasScalar ð•œ E] {S : Convex_cone ð•œ E} : S.Blunt â†’ S.salient
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {g : Î² â†’ Î±} (hg : set.inj_on g (Function.Support (F âˆ˜ g))) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ set.Range g), F i)) = finsum (Î» (j : Î²), F (g j))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {n : WithTop â„•} (h : âˆ€ (m : â„•), â†‘m â‰¤ n â†’ Differentiable ð•œ (iterated_deriv m F)) : ContDiff ð•œ n F
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) : S.monge_point = (â†‘(n + 1) / â†‘(n - 1)) â€¢ (Finset.centroid â„ Finset.Univ S.points -áµ¥ S.circumcenter) +áµ¥ S.circumcenter
(R : Type u) [CommRing R] [strong_RankCondition R] (m : Type v) (N : Type W) [AddCommGroup m] [module R m] [module.free R m] [AddCommGroup N] [module R N] [module.free R N] : Finite_dimensional.finrank R (TensorProduct R m N) = Finite_dimensional.finrank R m * Finite_dimensional.finrank R N
{R : Type u} [CommRing R] [IsDomain R] {P : Polynomial R} {A : R} {n : â„•} (hzero : P â‰  0) (h : (Polynomial.x - â‡‘Polynomial.C A) ^ n âˆ£ P) : n â‰¤ Polynomial.root_multiplicity A P
{Î¹ : Type u_1} {Î± : Type u_2} [Fintype Î¹] [DecidableEq Î±] (t : Î¹ â†’ Finset Î±) : (âˆ€ (S : Finset Î¹), S.Card â‰¤ (S.bUnion t).Card) â†” âˆƒ (F : Î¹ â†’ Î±), Function.Injective F âˆ§ âˆ€ (x : Î¹), F x âˆˆ t x
{Î± : Type u_1} {Î² : Type u_2} {e e' : local_Equiv Î± Î²} (h : e â‰ˆ e') : set.Eq_on â‡‘e â‡‘e' e.Source
{ð•œ : Type u_1} [_R_or_C ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {r : â„} (r_Pos : 0 < r) (C : â„) (F : E â†’â‚—[ð•œ] ð•œ) (h : âˆ€ (z : E), z âˆˆ metric.IsClosed_ball 0 r â†’ âˆ¥â‡‘F zâˆ¥ â‰¤ C) (z : E) : âˆ¥â‡‘F zâˆ¥ â‰¤ C / r * âˆ¥zâˆ¥
{Î± : Type u} [EmetricSpace Î±] {S : set Î±} (hs : IsClosed S) : IsClosed {t : TopologicalSpace.Closeds Î± | â†‘t âŠ† S}
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} (hF : Continuous F) (x : Î±) (y : Î²) (h : F x = y) : Filter.Tendsto F (nhds x) (nhds y)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {n : WithTop â„•} (h : âˆ€ (x : E), x âˆˆ S â†’ (âˆƒ (u : set E), IsOpen u âˆ§ x âˆˆ u âˆ§ ContDiff_on ð•œ n F (S âˆ© u))) : ContDiff_on ð•œ n F S
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} {t : CategoryTheory.Limits.Fork F g} (ht : CategoryTheory.Limits.IsLimit t) {Z Z' : C} (q : Z' âŸ¶ Z) (k : Z âŸ¶ t.x) : â†‘(â‡‘(CategoryTheory.Limits.Fork._Limit.hom_is_iso ht Z') (q â‰« k)) = q â‰« â†‘(â‡‘(CategoryTheory.Limits.Fork._Limit.hom_is_iso ht Z) k)
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] (F : LocalHomeomorph ð•œ ð•œ) {A F' : ð•œ} (ha : A âˆˆ F.to_local_Equiv.Target) (hF' : F' â‰  0) (htff' : HasDerivAt â‡‘F F' (â‡‘(F.Symm) A)) : HasDerivAt â‡‘(F.Symm) F'â»Â¹ A
{Î± : Type u} [TopologicalSpace Î±] [t1_Space Î±] {S : set Î±} (hs : Dense S) (x : Î±) [(nhds_within x {x}á¶œ).Ne_IsBot] : Dense (S  {x})
{Î± : Type u_1} [PartialOrder Î±] [OrderTop Î±] {A : Î±} : IsCoatom A â†’ A â‹– âŠ¤
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [PartialOrder Î±] [t : OrderTopology Î±] {F g h : Î² â†’ Î±} {B : Filter Î²} {A : Î±} (hg : Filter.Tendsto g B (nhds A)) (hH : Filter.Tendsto h B (nhds A)) (hgf : âˆ€á¶  (B : Î²) in B, g B â‰¤ F B) (hfh : âˆ€á¶  (B : Î²) in B, F B â‰¤ h B) : Filter.Tendsto F B (nhds A)
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] : (âˆ€ (F : â„• â†’o (Submodule R m)áµ’áµˆ), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘F n = â‡‘F m) â†” IsArtinian R m
{R : Type u_1} [CommSemiring R] {m : Submonoid R} {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization m S] {g : R â†’+* P} (hg : âˆ€ (y : â†¥m), IsUnit (â‡‘g â†‘y)) {x y : R} (h : â‡‘(Algebra_Map R S) x = â‡‘(Algebra_Map R S) y) : â‡‘g x = â‡‘g y
{R : Type u_1} {A : R} [CancelMonoidWithZero R] (A0 : A â‰  0) : IsRegular A
{m n : â„•} : (âˆ€ (A : â„•), m âˆ£ A â†” n âˆ£ A) â†” m = n
{A : Type u_1} {B : Type u_2} [CommRing A] [IsDomain A] [Ring B] [Algebra A B] {x : B} [IsDomain B] (hx : IsIntegral A x) : Irreducible (minpoly A x)
{vâ‚ : Type u_2} {vâ‚‚ : Type u_3} [semi_NormedGroup vâ‚] [semi_NormedGroup vâ‚‚] (F : vâ‚ â†’+ vâ‚‚) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : vâ‚), âˆ¥â‡‘F xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥F.Mk_NormedGroup_hom C hâˆ¥ â‰¤ C
{Î¹ : Type u_1} {Î± : Type u_2} {A : Î¹ â†’ Type u_3} [AddMonoid Î¹] [graded_Monoid.Gmonoid A] (l : List Î±) (F : Î± â†’ graded_Monoid A) : (List.Map F l).Prod = graded_Monoid.Mk (l.dprod_Index (Î» (i : Î±), (F i).fst)) (l.dprod (Î» (i : Î±), (F i).fst) (Î» (i : Î±), (F i).Snd))
{Î± : Type u_1} {R : Type u_2} {l : Filter Î±} {F : Î± â†’ R} {r : R} [Linear_OrderedSemiring R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (Î» (x : Î±), F x * r) l Filter.at_top
{Î± : Type u} [HasSubset Î±] {A B : Î±} [IsRefl Î± HasSubset.Subset] : A = B â†’ B âŠ† A
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] [DenselyOrdered Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds_within A (set.Iic A) â†” âˆƒ (l : Î±) (h : l âˆˆ set.Iio A), set.icc l A âŠ† S
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {P : Polynomial A} (hp : â‡‘(Polynomial.aeval x) P = 0) : minpoly A x âˆ£ P
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î±'] [DecidableEq Î³] [DecidableEq Î´] {F : Î± â†’ Î² â†’ Î³} {S : Finset Î±} {t : Finset Î²} {g : Î³ â†’ Î´} {F' : Î² â†’ Î±' â†’ Î´} {g' : Î± â†’ Î±'} (h_antidistrib : âˆ€ (A : Î±) (B : Î²), g (F A B) = F' B (g' A)) : Finset.image g (Finset.imageâ‚‚ F S t) = Finset.imageâ‚‚ F' t (Finset.image g' S)
{Î± : Type u} [Group Î±] : _Group_hom Id
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] {F : Î² â†’ Î±} (hF : Continuous F) (xâ‚€ : Î²) (h : âˆ€á¶  (x : Î²) in Filter.cocompact Î², F x â‰¤ F xâ‚€) : âˆƒ (x : Î²), âˆ€ (y : Î²), F y â‰¤ F x
{Î± : Type u_1} {Î² : Type u_2} {S : set Î±} {t : Î± â†’ set Î²} {y : Î²} (h : âˆ€ (x : Î±), x âˆˆ S â†’ y âˆˆ t x) : y âˆˆ â‹‚ (x : Î±) (h : x âˆˆ S), t x
(F : Circle_deg1_Lift) (P : â„ â†’ Prop) (h : âˆ€ (x : â„), x âˆˆ set.icc 0 1 â†’ P (â‡‘F x - x)) (x : â„) : P (â‡‘F x - x)
(k : Type u_1) {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : Î¹ â†’ P) (S : Finset Î¹) {n : â„•} (hc : S.Card = n + 1) : Finite_dimensional.finrank k â†¥(Vector_Span k â†‘(Finset.image P S)) â‰¤ n
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {F : Î³ â†’ Î±} {S : set Î³} {x : Î³} (hx : F x âˆˆ e.to_local_Equiv.Source) (h : F â»Â¹' e.to_local_Equiv.Source âˆˆ nhds_within x S) : Continuous_within_at F S x â†” Continuous_within_at (â‡‘e âˆ˜ F) S x
{Î± : Type u_1} {Î¹ : Type u_2} {F : Î¹ â†’ Î±} : Function.Injective F â†’ Pairwise (Ne on F)
{Î± : Type u_1} {n : â„•} (S : Sym Î± n) : Sym.Map (Î» (x : Î±), x) S = S
{k : Type u_1} {G : Type u_2} {v : Type u_3} [CommRing k] [Group G] [AddCommGroup v] [module k v] (Ï : Representation k G v) [Nontrivial k] [module.free k v] [module.Finite k v] : Ï.character 1 = â†‘(Finite_dimensional.finrank k v)
{k : Type u_1} {v1 : Type u_2} {v2 : Type u_4} [Ring k] [AddCommGroup v1] [module k v1] [AddCommGroup v2] [module k v2] (F : v1 â†’áµƒ[k] v2) : â‡‘F = â‡‘(F.Linear) + Î» (z : v1), â‡‘F 0
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {C : â„} {F : â„‚ â†’ E} {z : â„‚} (hD : Diff_Cont_on_cl â„‚ F (set.Iio 0 Ã—â„‚ set.ioi 0)) (hB : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.Iio 0 Ã—â„‚ set.ioi 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥F â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥F (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz_re : z.re â‰¤ 0) (hz_im : 0 â‰¤ z.im) : âˆ¥F zâˆ¥ â‰¤ C
{L : FirstOrder.Language} {m : Type W} [L.structure m] {P : m â†’ Prop} (x : m) {S : set m} (hs : â‡‘(FirstOrder.Language.Substructure.Closure L) S = âŠ¤) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (Hfun : âˆ€ {n : â„•} (F : L.Functions n), FirstOrder.Language.IsClosed_under F (set_of P)) : P x
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {S : set E} [CompleteSpace F] (h : AnalyticOn ð•œ F S) (n : â„•) : AnalyticOn ð•œ (iterated_fderiv ð•œ n F) S
{Î± : Type u_1} [Fintype Î±] (P q : Î± â†’ Prop) [Fintype {x // P x}] [Fintype {x // Â¬P x}] [Fintype {x // q x}] [Fintype {x // Â¬q x}] (h : Fintype.Card {x // P x} = Fintype.Card {x // q x}) : Fintype.Card {x // Â¬P x} = Fintype.Card {x // Â¬q x}
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x : C} {R : CategoryTheory.Presieve x} {P' : Cáµ’áµ– â¥¤ Type W} (i : P â‰… P') : CategoryTheory.Presieve.IsSheafFor P R â†’ CategoryTheory.Presieve.IsSheafFor P' R
{ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedGroup G] [NormedSpace ð•œ G] {F F' : ð•œ â†’ G} {S : set ð•œ} {x y : ð•œ} {C : â„} (hF : âˆ€ (x : ð•œ), x âˆˆ S â†’ HasDerivWithinAt F (F' x) S x) (bound : âˆ€ (x : ð•œ), x âˆˆ S â†’ âˆ¥F' xâˆ¥ â‰¤ C) (hs : Convex â„ S) (xs : x âˆˆ S) (ys : y âˆˆ S) : âˆ¥F y - F xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {A : Î±} {S : set Î±} (F : Î± â†’ m) (h : A âˆ‰ S) (hs : (S âˆ© Function.MulSupport F).Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ HasInsert.Insert A S), F i)) = F A * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i))
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {F' : E â†’L[â„] â„} {S : set E} (h : IsLocalMinOn F S A) (hF : HasFderivWithinAt F F' S A) {y : E} (hy : y âˆˆ Pos_TangentConeAt S A) : 0 â‰¤ â‡‘F' y
{J : Type u} [Preorder J] [_Directed J has_LE.LE] (F : Jáµ’áµ– â¥¤ Type v) [Î  (j : Jáµ’áµ–), Fintype (F.obj j)] [âˆ€ (j : Jáµ’áµ–), Nonempty (F.obj j)] : F.sections.Nonempty
{m : Type u_1} [Semigroup m] [Nonempty m] (S : set (set m)) (sfin : S.Finite) (scov : âŠ¤ âŠ† â‹ƒâ‚€S) : âˆƒ (C : set m) (h : C âˆˆ S) (A : Stream m), Hindman.FP A âŠ† C
{E : Type u_4} [NormedGroup E] [NormedSpace â„ E] {B : â„} {F : â„• â†’ â„} {z : â„• â†’ E} (hfa : Monotone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) (hgb : âˆ€ (n : â„•), âˆ¥(Finset.Range n).Sum (Î» (i : â„•), z i)âˆ¥ â‰¤ B) : Cauchy_Seq (Î» (n : â„•), (Finset.Range (n + 1)).Sum (Î» (i : â„•), F i â€¢ z i))
{Î± : Type u} [Semigroup Î±] [has_Distrib_Neg Î±] (A B : Î±) : -A âˆ£ B â†” A âˆ£ B
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_4} [Fintype Î¹] [DecidableEq Î¹] (e : Basis Î¹ R m) (x : Orientation R m Î¹) (F : m â‰ƒâ‚—[R] m) : â‡‘(Orientation.Map Î¹ F) x = (â‡‘Linear_Equiv.det F)â»Â¹ â€¢ x
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] : Finset.Univ = Finset.Map Equiv.perm.decompose_Option.Symm.to_Embedding Finset.Univ
{E : Type u_3} [semi_NormedGroup E] {F : â„• â†’ E} (g : â„• â†’ â„) (hg : Cauchy_Seq (Î» (n : â„•), (Finset.Range n).Sum (Î» (i : â„•), g i))) (hF : âˆ€ (i : â„•), âˆ¥F iâˆ¥ â‰¤ g i) : Cauchy_Seq (Î» (n : â„•), (Finset.Range n).Sum (Î» (i : â„•), F i))
{E : Type u_2} [AddCommGroup E] [module â„ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul â„ E] [t2_Space E] {S : set E} (hs : S.Finite) : IsClosed (â‡‘(Convex_hull â„) S)
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) â‰  0) : (((Matrix.Pivot.List_transvec_col m).Prod.Mul m).Mul (Matrix.Pivot.List_transvec_row m).Prod)._two_block_Diagonal
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (direction : Submodule k v) : (AffineSubspace.Mk' P direction).direction = direction
{Î± : Type u} [Preorder Î±] {A B C : Î±} : B = C â†’ A â‰¤ B â†’ A â‰¤ C
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (h : o.oangle x y = 0) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{Î± : Type u} (xs : List Î±) (x : Î±) [DecidableEq Î±] : [x].intercalate (List.split_on x xs) = xs
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} {F : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F} (hF : Continuous â‡‘F) {x : E} (hx : âˆ¥xâˆ¥ = 0) : âˆ¥â‡‘F xâˆ¥ = 0
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {A B : Î±} (h : Relation.refl_Trans_gen r A B) : âˆƒ (l : List Î±), List.chain r A l âˆ§ (A :: l).Last _ = B
{K : Type u} [Field K] (S : Subfield K) : 0 âˆˆ S
{A : Type u_1} [CommMonoid A] (A B C : A) : C âˆˆ Submonoid.Closure {A, B} â†” âˆƒ (m n : â„•), A ^ m * B ^ n = C
{Î± : Type u_2} {Î¹ : Type u_5} [AddCommMonoid Î±] (t : Finset Î¹) (Fâ‚ Fâ‚‚ : Î¹ â†’ set Î±) (hF : âˆ€ {i : Î¹}, i âˆˆ t â†’ Fâ‚ i âŠ† Fâ‚‚ i) : t.Sum (Î» (i : Î¹), Fâ‚ i) âŠ† t.Sum (Î» (i : Î¹), Fâ‚‚ i)
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z â†’ B} [TopologicalSpace Z] (e : TopologicalFiberBundle.Trivialization F Proj) {x : Z} (ex : x âˆˆ e.to_LocalHomeomorph.to_local_Equiv.Source) : Continuous_at Proj x
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {v : n â†’ Î±} : IsUnit (Matrix.Diagonal v) â†” IsUnit v
(r : â„) (h : r â‰  0) : r.sign = -1 âˆ¨ r.sign = 1
{A B C : â„¤} (h : fermat_42.Minimal A B C) : _IsCoprime A B
{Î± : Type u_1} [has_Add Î±] [has_LT Î±] [ContravariantClass Î± Î± has_Add.Add has_LT.LT] {A B C : Î±} (bc : A + B < A + C) : B < C
{Î± : Type u} [HasSubset Î±] [HasSsubset Î±] [IsNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {A B : Î±} [IsAntisymm Î± HasSubset.Subset] (h : A âŠ† B) : A = B âˆ¨ A âŠ‚ B
{x y : Pgame} : x.lf y â†” (âˆƒ (i : y.Left_moves), (âˆ€ (i' : x.Left_moves), (x.move_Left i').lf (y.move_Left i)) âˆ§ âˆ€ (j : (y.move_Left i).Right_moves), x.lf ((y.move_Left i).move_Right j)) âˆ¨ âˆƒ (j : x.Right_moves), (âˆ€ (i : (x.move_Right j).Left_moves), ((x.move_Right j).move_Left i).lf y) âˆ§ âˆ€ (j' : y.Right_moves), (x.move_Right j).lf (y.move_Right j')
(R : Type u_1) {m : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid m] [module R m] (S : set m) [Semiring S] [HasScalar R S] [module S m] [IsScalarTower R S m] : Submodule.Span R S â‰¤ Submodule.Restrict_scalars R (Submodule.Span S S)
{Î± : Type u} {Lâ‚ : List (Î± Ã— Bool)} {x : Î± Ã— Bool} : free_Group.red [x] Lâ‚ â†” Lâ‚ = [x]
{Î± : Type u_1} [Lattice Î±] [_modular_Lattice Î±] {Î² : Type u_2} {Î³ : Type u_3} [Preorder Î²] [PartialOrder Î³] (hâ‚ : WellFounded Gt) (hâ‚‚ : WellFounded Gt) (K : Î±) (Fâ‚ : Î² â†’ Î±) (Fâ‚‚ : Î± â†’ Î²) (gâ‚ : Î³ â†’ Î±) (gâ‚‚ : Î± â†’ Î³) (gci : GaloisCoinsertion Fâ‚ Fâ‚‚) (gi : GaloisInsertion gâ‚‚ gâ‚) (hF : âˆ€ (A : Î±), Fâ‚ (Fâ‚‚ A) = A âŠ“ K) (hg : âˆ€ (A : Î±), gâ‚ (gâ‚‚ A) = A âŠ” K) : WellFounded Gt
(x : â„‚) : HasStrictDerivAt Complex.sin (Complex.cos x) x
{Î± : Type u_1} {Î¹ : Type u_3} [CompleteLattice Î±] {t : Î¹ â†’ Î±} (ht : CompleteLattice.Independent t) : Pairwise (Disjoint on t)
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [CommSemiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] (F : MultilinearMap R mâ‚ mâ‚‚) [Fintype Î¹] (C : Î¹ â†’ R) (m : Î  (i : Î¹), mâ‚ i) : â‡‘F (Î» (i : Î¹), C i â€¢ m i) = Finset.Univ.Prod (Î» (i : Î¹), C i) â€¢ â‡‘F m
{m n B : â„•} (hm : m â‰  1) (hn : 0 < n) (hb : Nat.log m n < B) : multiplicity m n = â†‘((Finset.Filter (Î» (i : â„•), m ^ i âˆ£ n) (Finset.Ico 1 B)).Card)
{Î² Î± : Type u_1} (F : Î² â†’ Î±) (W : Cardinal.Mk Î± < Cardinal.Mk Î²) (W' : Infinite Î±) : âˆƒ (A : Î±), Infinite â†¥(F â»Â¹' {A})
{Î± : Type u} {Î² : Type v} [AddCommGroup Î²] (g h : free_abelian_Group Î± â†’+ Î²) (h : âˆ€ (x : Î±), â‡‘g (free_abelian_Group.of x) = â‡‘h (free_abelian_Group.of x)) : g = h
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] (B : Basis Î¹ R m) (e : Î¹ â‰ƒ Î¹') : set.Range (â‡‘B âˆ˜ â‡‘(e.Symm)) = set.Range â‡‘B
{K : Type u_1} [Linear_ordered_Field K] {v : K} {n : â„•} [FloorRing K] (nth_Stream_Eq_None : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.None) : v = (GeneralizedContinuedFraction.of v).convergents (n - 1)
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : Continuous_MultilinearMap ð•œ E G) (m : Î  (i : Î¹), E i) (h : âˆ¥mâˆ¥ â‰¤ 1) : âˆ¥â‡‘F mâˆ¥ â‰¤ âˆ¥Fâˆ¥
{Î± : Type u_1} {m : MeasurableSpace Î±} (S : set Î±) : Nonempty {t // S âŠ† t âˆ§ Measurable_set t}
{Î± : Type u_2} {Î² : Type u_3} : Filter.cofinite.Coprod Filter.cofinite = Filter.cofinite
{Î± : Type u_1} [UniformSpace Î±] : (Uniformity Î±).has_Basis (Î» (v : set (Î± Ã— Î±)), v âˆˆ Uniformity Î± âˆ§ IsOpen v âˆ§ symmetric_Rel v) Id
{Î± : Type u} [Ring Î±] {A B : Î±} : A âˆ£ B + A â†” A âˆ£ B
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [Preorder Î²] {A : Î±} {F : Î± â†’ Î²} (hâ‚ : StrictMono_on F (set.Iic A)) (hâ‚‚ : StrictMono_on F (set.ici A)) : StrictMono F
{Î± : Type u_1} [Fintype Î±] [DecidableEq Î±] (h5 : 5 â‰¤ Fintype.Card Î±) {F : Equiv.perm Î±} (hF : F._three_Cycle) : Subgroup.Normal_Closure {âŸ¨F, _âŸ©} = âŠ¤
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [Linear_ordered_AddCommGroup Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_top) : Filter.Tendsto (Î» (x : Î²), F x + g x) l Filter.at_top
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F â‰  2) : Finset.Univ.Sum (Î» (A : F), Char.quadratic_Char F A) = 0
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) : â‡‘F 1 = 1
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : Collinear k S â†” module.rank k â†¥(Vector_Span k S) â‰¤ 1
{Î± : Type u} [TopologicalSpace Î±] {S t : set Î±} (hs : Dense S) (ht : Dense t) (hto : IsOpen t) : Dense (S âˆ© t)
{R : Type u_1} {Î¹â‚ : Type u_2} {Î¹â‚‚ : Type u_3} {Î¹â‚ƒ : Type u_4} {Î¹â‚„ : Type u_5} [CommSemiring R] [DecidableEq Î¹â‚] [DecidableEq Î¹â‚‚] [DecidableEq Î¹â‚ƒ] [DecidableEq Î¹â‚„] {Nâ‚ : Type u_6} [AddCommMonoid Nâ‚] [module R Nâ‚] {Nâ‚‚ : Type u_7} [AddCommMonoid Nâ‚‚] [module R Nâ‚‚] {N : Type u_8} [AddCommMonoid N] [module R N] (A : MultilinearMap R (Î» (_x : Î¹â‚), N) Nâ‚) (B : MultilinearMap R (Î» (_x : Î¹â‚‚), N) Nâ‚‚) (ÏƒA : Î¹â‚ â‰ƒ Î¹â‚ƒ) (ÏƒB : Î¹â‚‚ â‰ƒ Î¹â‚„) : MultilinearMap.Dom_Dom_congr (ÏƒA.Sum_congr ÏƒB) (A.Dom_Coprod B) = (MultilinearMap.Dom_Dom_congr ÏƒA A).Dom_Coprod (MultilinearMap.Dom_Dom_congr ÏƒB B)
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x : Î±} (h : S.Nonempty) : x âˆˆ Closure S â†” metric.Inf_dist x S = 0
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : A â‰¤ 0) (hb : B â‰¤ 0) : A + B â‰¤ 0
{Ï„ : Type u_1} {Î± : Type u_2} [canonically_ordered_AddMonoid Ï„] {Ï• : Ï„ â†’ Î± â†’ Î±} {S : set Î±} (h : IsFwInvariant Ï• S) : IsInvariant Ï• S
{m : Type u_1} [MulOneClass m] {S : set m} {S : Submonoid m} : Submonoid.Closure S â‰¤ S â†” S âŠ† â†‘S
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {F : m â†’* N} (h : âˆ€ (y : â†¥S), IsUnit (â‡‘F â†‘y)) {y : â†¥S} {z : N} (h : â‡‘F â†‘y * z = 1) : â†‘(â‡‘(IsUnit.Lift_Right (F.Restrict S) h) y)â»Â¹ = z
{Î± : Type u_1} [LinearOrder Î±] {S : Finset Î±} {k : â„•} (h : S.Card = k) (hz : 0 < k) : â‡‘(S.order_emb_of_Fin h) âŸ¨k - 1, _âŸ© = S.max' _
{m : Type u} [Monoid m] {A : mË£} {x y : m} (h : SemiconjBy â†‘A x y) : SemiconjBy â†‘Aâ»Â¹ y x
(x : AlgebraicGeometry.LocallyRingedSpace) : AlgebraicGeometry.to_spec_Î“ (AlgebraicGeometry.LocallyRingedSpace.Î“.obj (Opposite.Op x)) â‰« x.toÎ“_spec.val.C.App (Opposite.Op âŠ¤) = ðŸ™ (AlgebraicGeometry.LocallyRingedSpace.Î“.obj (Opposite.Op x))
{R : Type u_1} [NormedRing R] {r : â„} (hr : 1 < r) : Coe =o[Filter.at_top] Î» (n : â„•), r ^ n
{Î± : Type u_1} {Î² : Type u_3} [MeasurableSpace Î±] [MeasurableSpace Î²] {Î½ : MeasureTheory.Measure Î²} [MeasureTheory.sigma_Finite Î½] {S : set (Î± Ã— Î²)} (hs : Measurable_set S) : Measurable (Î» (x : Î±), â‡‘Î½ (Prod.Mk x â»Â¹' S))
{Î± : Type u} [PseudoMetricSpace Î±] {Î¹ : Type u_1} {Fâ‚ Fâ‚‚ : Î¹ â†’ Î±} {P : Filter Î¹} {A : Î±} (hâ‚ : Filter.Tendsto Fâ‚ P (nhds A)) (h : Filter.Tendsto (Î» (x : Î¹), HasDist.dist (Fâ‚ x) (Fâ‚‚ x)) P (nhds 0)) : Filter.Tendsto Fâ‚‚ P (nhds A)
{Î± : Type u_1} (F : Î± â†’ set Î±) : Â¬Function.Surjective F
{E : Type u_1} {x : Type u_2} [InnerProductSpace â„ E] [NormedGroup x] [NormedSpace â„ x] {n : WithTop â„•} {C g : x â†’ E} {F : Î  (x : x), ContDiff_bump_of_inner (C x)} {x : x} (hc : ContDiff_at â„ n C x) (hr : ContDiff_at â„ n (Î» (x : x), (F x).r) x) (hR : ContDiff_at â„ n (Î» (x : x), (F x).R) x) (hg : ContDiff_at â„ n g x) : ContDiff_at â„ n (Î» (x : x), â‡‘(F x) (g x)) x
{Î± : Type u_1} [Linear_ordered_Field Î±] [Archimedean Î±] {x y : Î±} (xpos : 0 < x) (hx : x â‰¤ 1) (ypos : 0 < y) (hy : y < 1) : âˆƒ (n : â„•), y ^ (n + 1) < x âˆ§ x â‰¤ y ^ n
{R : Type u} [Ring R] (S : Subring R) {l : List R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ S) â†’ l.Prod âˆˆ S
(K : Type u_1) [_R_or_C K] (E : Type u_2) [NormedGroup E] [NormedSpace K E] [Finite_dimensional K E] : ProperSpace E
{Î¹ : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : Î¹ â†’ set x} (uo : âˆ€ (i : Î¹), IsOpen (u i)) (uf : âˆ€ (x : x), {i : Î¹ | x âˆˆ u i}.Finite) (uU : (â‹ƒ (i : Î¹), u i) = set.Univ) : âˆƒ (v : Î¹ â†’ set x), set.Union v = set.Univ âˆ§ (âˆ€ (i : Î¹), IsOpen (v i)) âˆ§ âˆ€ (i : Î¹), Closure (v i) âŠ† u i
{Î± : Type u} [PseudoEmetricSpace Î±] {S : set Î±} {D : Ennreal} (h : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ HasEdist.edist x y â‰¤ D) : Emetric.diam S â‰¤ D
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) (F : v â‰ƒâ‚—áµ¢[â„] v) : (â‡‘(Orientation.Map (Fin 2) F.to_Linear_Equiv) o).oangle x y = o.oangle (â‡‘(F.Symm) x) (â‡‘(F.Symm) y)
{Î± : Type u} {S : set (set Î±)} : Cardinal.Mk â†¥S â‰¤ Cardinal.Continuum â†’ Cardinal.Mk â†¥{t : set Î± | Measurable_set t} â‰¤ Cardinal.Continuum
{Î± : Type u_1} [TopologicalSpace Î±] {S : set Î±} (h : IsOpen S) : _GÎ´ S
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {ð•œâ‚ƒ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semi_NormedGroup E] [semi_NormedGroup F] [semi_NormedGroup G] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [nondiscrete_NormedField ð•œâ‚ƒ] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] [NormedSpace ð•œâ‚ƒ G] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} {Ïƒâ‚‚â‚ƒ : ð•œâ‚‚ â†’+* ð•œâ‚ƒ} {Ïƒâ‚â‚ƒ : ð•œ â†’+* ð•œâ‚ƒ} [Ring_hom_Comp_triple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [Ring_hom_isometric Ïƒâ‚â‚‚] [Ring_hom_isometric Ïƒâ‚‚â‚ƒ] (h : F â†’sl[Ïƒâ‚‚â‚ƒ] G) (F : E â†’sl[Ïƒâ‚â‚‚] F) : âˆ¥h.Comp Fâˆ¥ â‰¤ âˆ¥hâˆ¥ * âˆ¥Fâˆ¥
{Î¹ : Type u_1} {E : Type u_3} [semi_NormedGroup E] [CompleteSpace E] {F : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : Summable g) (h : âˆ€ (i : Î¹), âˆ¥F iâˆ¥ â‰¤ g i) : Summable F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S t : set P} (ha : AffineIndependent k (Î» (x : â†¥t), â†‘x)) (hs : S âŠ† t) : AffineIndependent k (Î» (x : â†¥S), â†‘x)
{x : top} {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥x) : CategoryTheory.Sieve.generate (top.Presheaf.Presieve_of_covering U) âˆˆ â‡‘(Opens.GrothendieckTopology â†¥x) (supr U)
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : MultilinearMap ð•œ E G) {C : â„} (h : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘F mâˆ¥ â‰¤ C * Finset.Univ.Prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥F.Mk_Continuous C hâˆ¥ â‰¤ LinearOrder.max C 0
{Î± : Type u} {Î² : Type v} {F : Î± â†’ Î²} {B : Î²} {l : List Î±} : B âˆˆ List.Map F l â†’ (âˆƒ (A : Î±), A âˆˆ l âˆ§ F A = B)
{Î± : Type u_1} {Î¹ : Type u_3} [CompleteLattice Î±] [Fintype Î¹] {F : Î¹ â†’ Î±} : CompleteLattice.Independent F â†” Finset.Univ.Sup_indep F
{R : Type u_1} {A B : R} [Add_Semigroup R] (rra : _Add_Right_regular A) (rrb : _Add_Right_regular B) : _Add_Right_regular (A + B)
{Î± : Type u_1} [UniformSpace Î±] {K U : set Î±} (hK : IsCompact K) (hU : IsOpen U) (hKU : K âŠ† U) : âˆƒ (v : set (Î± Ã— Î±)) (h : v âˆˆ Uniformity Î±), IsOpen v âˆ§ âˆ€ (x : Î±), x âˆˆ K â†’ UniformSpace.ball x v âŠ† U
{Î± : Type u_2} [Group Î±] {S t : set Î±} : Disjoint S t â†’ 1 âˆ‰ S / t
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {P : FormalMultilinearSeries ð•œ E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) : Continuous_on F (Emetric.Ball x r)
{n : â„•} (P : Fin (n + 1)) (i : Fin n) (h : P â‰¤ â‡‘Fin.cast_Succ i) : â‡‘(P.Succ_above) i = i.Succ
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [UniformSpace Î²] [(Uniformity Î²)._countably_generated] (F : Î± â†’ Î²) : _GÎ´ {x : Î± | Continuous_at F x}
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {v : v} {P : Î¹ â†’ P} : v âˆˆ Vector_Span k (set.Range P) â†” âˆƒ (S : Finset Î¹) (W : Î¹ â†’ k) (h : S.Sum (Î» (i : Î¹), W i) = 0), v = â‡‘(S.weighted_vsub P) W
{Î± : Type u_1} {Î² : Type u_2} {l : Filter Î±} {F : Î± â†’ Î²} {lb : Filter Î²} : Filter.Tendsto F l lb â†’ â†‘F.tendsto lb
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} {P0 : P} {S : set Î¹} {P : Î¹ â†’ P} : (âˆƒ (fs : Finset Î¹) (hfs : â†‘fs âŠ† S) (W : Î¹ â†’ k) (hw : fs.Sum (Î» (i : Î¹), W i) = 1), P0 = â‡‘(fs.affine_combination P) W) â†” âˆƒ (fs : Finset â†¥S) (W : â†¥S â†’ k) (hw : fs.Sum (Î» (i : â†¥S), W i) = 1), P0 = â‡‘(fs.affine_combination (Î» (i : â†¥S), P â†‘i)) W
{A : Ennreal} : Add_LE_cancellable A â†” A â‰  âŠ¤
{R : Type u} [CommRing R] [IsDomain R] {P q : Polynomial R} (A : R) (hzero : P + q â‰  0) : LinearOrder.min (Polynomial.root_multiplicity A P) (Polynomial.root_multiplicity A q) â‰¤ Polynomial.root_multiplicity A (P + q)
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] [strict_Convex_Space â„ E] {x y z : E} : HasDist.dist x y + HasDist.dist y z = HasDist.dist x z â†” y âˆˆ Segment â„ x z
{ð•œ : Type u_1} {E : Type u_2} [normed_Linear_ordered_Field ð•œ] [NormedGroup E] [NormedSpace ð•œ E] {A : set E} {x : E} : x âˆˆ set.ExposedPoints ð•œ A â†” IsExposed ð•œ A {x}
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (IH : âˆ€ (m : Matrix (Fin r) (Fin r) ð•œ), âˆƒ (Lâ‚€ Lâ‚€' : List (Matrix.TransvectionStruct (Fin r) ð•œ)) (Dâ‚€ : Fin r â†’ ð•œ), ((List.Map Matrix.TransvectionStruct.to_Matrix Lâ‚€).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix Lâ‚€').Prod = Matrix.Diagonal Dâ‚€) (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) : âˆƒ (L L' : List (Matrix.TransvectionStruct (Fin r âŠ• Unit) ð•œ)) (D : Fin r âŠ• Unit â†’ ð•œ), ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod = Matrix.Diagonal D
{Î± : Type u_1} [Preorder Î±] [has_Add Î±] [HasSub Î±] [HasOrderedSub Î±] {A B : Î±} : A + B - B â‰¤ A
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} (h : Differentiable â„‚ F) (z : â„‚) {R : Nnreal} (hR : 0 < R) : HasFpowerSeriesOnBall F (Cauchy_PowerSeries F z â†‘R) z âŠ¤
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [has_LE Î²] {F g : Î± â†’ Î²} {A : Î±} (h : F â‰¤á¶ [nhds A] g) : âˆ€á¶  (y : Î±) in nhds A, F â‰¤á¶ [nhds y] g
{Î± : Type u} [MetricSpace Î±] {x y : TopologicalSpace.Nonempty_Compacts Î±} : HasDist.dist x y = metric.Hausdorff_dist â†‘x â†‘y
{Î± : sort u} {F : Î± â†’ Î±} (h : Function.involutive F) (P : Prop) [Decidable P] (x : Î±) : F (Ite P x (F x)) = Ite (Â¬P) x (F x)
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’ Î²} {mÎ± : MeasurableSpace Î±} [MeasurableSpace Î²] [TopologicalSpace Î²] [TopologicalSpace.pseudo_metrizable_Space Î²] [TopologicalSpace.SecondCountableTopology Î²] [Opens_MeasurableSpace Î²] (hF : Measurable F) : MeasureTheory.strongly_Measurable F
{R : Type u_1} [CommRing R] [IsDomain R] : Prime PowerSeries.x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type W} [CategoryTheory.Category J] (F : C â¥¤ D) [CategoryTheory.Limits.HasLimits_of_shape J D] [CategoryTheory.CreatesLimitsOfShape J F] : CategoryTheory.Limits.HasLimits_of_shape J C
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} : ContDiff ð•œ n Prod.Snd
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (x : E) : â‡‘(reflection K) x = x â†” x âˆˆ K
{n n' m : â„•} (i : Fin n') (h : n' = n) : â‡‘(Fin.Add_Nat m) (â‡‘(Fin.cast h) i) = â‡‘(Fin.cast _) (â‡‘(Fin.Add_Nat m) i)
(x : â„) : 0 â‰¤ Exp_Neg_Inv_glue x
{Î± : Type u_1} [canonically_Linear_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B C : Î±} [ContravariantClass Î± Î± has_Add.Add has_LE.LE] (h : B â‰¤ A) : A - B < A - C â†” C < B
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimits C] : CategoryTheory.Limits.HasColimits Cáµ’áµ–
{m : Type u_1} [has_Mul m] {P : m â†’ Prop} (x : m) {S : set m} (hs : Subsemigroup.Closure S = âŠ¤) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (HMul : âˆ€ (x y : m), P x â†’ P y â†’ P (x * y)) : P x
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F1 F2 : Î± â†’â‚€ m} (hD : Disjoint F1.Support F2.Support) {Î² : Type u_2} [CommMonoid Î²] (g : Î± â†’ m â†’ Î²) : (F1 + F2).Prod g = F1.Prod g * F2.Prod g
{n : â„•} {F : Typevec (n + 1) â†’ Type u} [Mvfunctor F] [q : Mvqpf F] {Î± : Typevec n} (r : Mvqpf.Cofix F Î± â†’ Mvqpf.Cofix F Î± â†’ Prop) (h : âˆ€ (x y : Mvqpf.Cofix F Î±), r x y â†’ Mvfunctor.Map (Typevec.Id ::: Quot.Mk r) x.dest = Mvfunctor.Map (Typevec.Id ::: Quot.Mk r) y.dest) (x y : Mvqpf.Cofix F Î±) : r x y â†’ x = y
(x : Prime_Spectrum PUnit) : False
{G : Type u_1} [Group G] [Fintype G] (P : â„•) [hp : Fact (Nat.Prime P)] (hdvd : P âˆ£ Fintype.Card G) : âˆƒ (x : G), order_of x = P
{ð•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [NormedGroup E] [NormedGroup Fâ‚—] [nondiscrete_NormedField ð•œ] [NormedSpace ð•œ E] [NormedSpace ð•œ Fâ‚—] (F : E â†’L[ð•œ] Fâ‚—) (hF : uniform_Embedding â‡‘F) : âˆƒ (K : Nnreal), AntilipschitzWith K â‡‘F
{Î± : Type u} (S : set Î±) : Cardinal.Mk (â†¥ð’«S) = 2 ^ Cardinal.Mk â†¥S
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [module ð•œ Î²] [LinearOrder E] {S : set E} {F : E â†’ Î²} (hs : Convex ð•œ S) (hF : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ S â†’ y âˆˆ S â†’ x < y â†’ âˆ€ â¦ƒA B : ð•œâ¦„, 0 < A â†’ 0 < B â†’ A + B = 1 â†’ F (A â€¢ x + B â€¢ y) â‰¤ A â€¢ F x + B â€¢ F y) : Convex_on ð•œ S F
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] : Even (Finset.Filter (Î» (v : v), Odd (G.degree v)) Finset.Univ).Card
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {F : Î² â†’ Î³} {x : Î²} (h : x âˆˆ e.to_local_Equiv.Target) : Continuous_at F x â†” Continuous_at (F âˆ˜ â‡‘e) (â‡‘(e.Symm) x)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace E] [CompleteSpace â†¥K] : Continuous_LinearMap.Id ð•œ E = K.subtypeL.Comp (Orthogonal_projection K) + Ká—®.subtypeL.Comp (Orthogonal_projection Ká—®)
{m : Type u_1} [AddCommMonoid m] (F S : â„• â†’ m) (h0 : S 0 = 0) (h : âˆ€ (n : â„•), S (n + 1) = S n + F n) (n : â„•) : (Finset.Range n).Sum (Î» (k : â„•), F k) = S n
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (Sâ‚‚ : Finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) : â‡‘((Finset.Map e Sâ‚‚).weighted_vsub P) W = â‡‘(Sâ‚‚.weighted_vsub (P âˆ˜ â‡‘e)) (W âˆ˜ â‡‘e)
{A B : â„•} : A â‹– B â†’ â†‘A â‹– â†‘B
{R : Type u} [Ring R] {m : module R} {Î¹ : Type u_1} (B : Basis Î¹ R â†¥m) : CategoryTheory.Projective m
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B C : Î±} : A + B < C â†’ A < C - B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {Fâ‚‚ : ð•œ â†’ F} {Sâ‚‚ : set ð•œ} {n : â„•} (hs : IsOpen Sâ‚‚) : ContDiff_on ð•œ â†‘(n + 1) Fâ‚‚ Sâ‚‚ â†” DifferentiableOn ð•œ Fâ‚‚ Sâ‚‚ âˆ§ ContDiff_on ð•œ â†‘n (deriv Fâ‚‚) Sâ‚‚
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : C â¥¤ D) {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.Span F F) F] [CategoryTheory.Epi (F.Map F)] : CategoryTheory.Epi F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} (hs : IsOpen S) : ContDiff_on ð•œ âŠ¤ F S â†” DifferentiableOn ð•œ F S âˆ§ ContDiff_on ð•œ âŠ¤ (Î» (y : E), fderiv ð•œ F y) S
(v W : â„• â†’ â„•) (t : omega.Nat.Preterm) : (âˆ€ (x : â„•), x < t.fresh_Index â†’ v x = W x) â†’ omega.Nat.Preterm.val v t = omega.Nat.Preterm.val W t
{Î± : Type u} [PseudoMetricSpace Î±] (x y : Î±) : HasDist.dist x y = (HasEdist.edist x y).to_Real
(L : FirstOrder.Language) {m : Type W} [Nonempty m] [L.structure m] (S : set m) (Îº : Cardinal) (h1 : Cardinal.aleph0 â‰¤ Îº) (h2 : (Cardinal.Mk â†¥S).Lift â‰¤ Îº.Lift) (h3 : L.Card.Lift â‰¤ Îº.Lift) (h4 : Îº.Lift â‰¤ (Cardinal.Mk m).Lift) : âˆƒ (S : L.elementary_Substructure m), S âŠ† â†‘S âˆ§ (Cardinal.Mk â†¥S).Lift = Îº.Lift
{S : set Ordinal} (F : Ordinal â†’ Ordinal) (hS : set.Unbounded has_LT.LT S) : StrictMono F âˆ§ set.Range F = S â†” F = Ordinal.enum_Ord S
(Ee : List Omega.Ee) (C : Omega.Clause) : (omega.Eq_elim Ee C).Unsat â†’ C.Unsat
{G : Type u_1} [AddGroup G] {N : Type u_2} [AddGroup N] (F : G â†’+ N) (hF : Function.Surjective â‡‘F) : F.Range = âŠ¤
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (P : P) : â†‘(affine_Span k {P}) = {P}
{n : â„•} (A : Composition n) (B : Composition A.length) {i j : â„•} (hi : i < B.length) (hj : j < B.blocks_fun âŸ¨i, hiâŸ©) : A.size_Up_to (B.size_Up_to i + j) = (A.gather B).size_Up_to i + (A.sigma_Composition_aux B âŸ¨i, _âŸ©).size_Up_to j
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] {Aâ‚ Aâ‚‚ Aâ‚ƒ : x} {Bâ‚ Bâ‚‚ Bâ‚ƒ : Y} (Î³â‚ : Path Aâ‚ Aâ‚‚) (Î´â‚ : Path Aâ‚‚ Aâ‚ƒ) (Î³â‚‚ : Path Bâ‚ Bâ‚‚) (Î´â‚‚ : Path Bâ‚‚ Bâ‚ƒ) : (Î³â‚.Prod Î³â‚‚).Trans (Î´â‚.Prod Î´â‚‚) = (Î³â‚.Trans Î´â‚).Prod (Î³â‚‚.Trans Î´â‚‚)
(x : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens â†¥x) (F : â†¥(x.to_PresheafedSpace.presheaf.obj (Opposite.Op U))) (h : âˆ€ (x : â†¥U), IsUnit (â‡‘(x.to_PresheafedSpace.presheaf.germ x) F)) : IsUnit F
{R : Type u_1} {A B : R} [Semigroup R] : IsRegular (A * B) âˆ§ IsRegular (B * A) â†” IsRegular A âˆ§ IsRegular B
{Î± : Type u} {Î² : Type v} [UniformSpace Î±] [SemilatticeSup Î²] {K : set Î±} (hâ‚ : IsComplete K) {u : Î² â†’ Î±} (hâ‚‚ : âˆ€ (n : Î²), u n âˆˆ K) (hâ‚ƒ : Cauchy_Seq u) : âˆƒ (v : Î±) (h : v âˆˆ K), Filter.Tendsto u Filter.at_top (nhds v)
{Î± : Type u} [t : TopologicalSpace Î±] {S : set (set Î±)} (h_IsOpen : âˆ€ (u : set Î±), u âˆˆ S â†’ IsOpen u) (h_nhds : âˆ€ (A : Î±) (u : set Î±), A âˆˆ u â†’ IsOpen u â†’ (âˆƒ (v : set Î±) (h : v âˆˆ S), A âˆˆ v âˆ§ v âŠ† u)) : TopologicalSpace._topological_Basis S
{P q : â„•} [P_Prime : Fact (Nat.Prime P)] [q_Prime : Fact (Nat.Prime q)] (neq : P â‰  q) : padic_norm P â†‘q = 1
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B C : Î±} : Bâ»Â¹ * A < C â†’ A < B * C
{m : Type u_1} [has_Add m] (C : Add_Con m) : Add_Con.Add_Ker Coe _ = C
{Î± : Type u_1} {Î¹ : Type u_3} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} [Fintype Î¹] {t : Î¹ â†’ set Î±} (h : Pairwise (Disjoint on t)) (ht : âˆ€ (i : Î¹), (t i).Finite) : finprod (Î» (A : Î±), finprod (Î» (h : A âˆˆ â‹ƒ (i : Î¹), t i), F A)) = finprod (Î» (i : Î¹), finprod (Î» (A : Î±), finprod (Î» (h : A âˆˆ t i), F A)))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {E' : Type u_6} [NormedGroup E'] [NormedSpace ð•œ E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace ð•œ F'] {F : E â†’ F} {g : E' â†’ F'} (hF : ContDiff ð•œ n F) (hg : ContDiff ð•œ n g) : ContDiff ð•œ n (Prod.Map F g)
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D â¥¤ C} [CategoryTheory.Reflective i] {A : C} [CategoryTheory.SplitMono ((CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App A)] : A âˆˆ i.EssImage
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {S : set Î±} {x : Î±} {P : Filter Î¹} {g : Î¹ â†’ Î±} [TopologicalSpace Î±] (h : Continuous_within_at F S x) (hg : Filter.Tendsto g P (nhds_within x S)) (hunif : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : set Î±) (h : t âˆˆ nhds_within x S), âˆ€á¶  (n : Î¹) in P, âˆ€ (y : Î±), y âˆˆ t â†’ (F y, F n y) âˆˆ u)) : Filter.Tendsto (Î» (n : Î¹), F n (g n)) P (nhds (F x))
{Î± : Type u_1} {S : set Î±} [MeasurableSpace Î±] (hs : S.Infinite) : â‡‘MeasureTheory.Measure.count S = âŠ¤
{C : Type uâ‚} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} {P : Cáµ’áµ– â¥¤ Type vâ‚} (x : S.Functor âŸ¶ P) (g : CategoryTheory.yoneda.obj x âŸ¶ P) : S.Functor_inclusion â‰« g = x â†” (â‡‘CategoryTheory.Presieve.Nat_Trans_Equiv_compatible_family x).val._amalgamation (â‡‘CategoryTheory.yoneda_Equiv g)
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F g : Î± â†’ m} {S : set Î±} (hF : (S âˆ© Function.MulSupport F).Finite) (hg : (S âˆ© Function.MulSupport g).Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i * g i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), g i))
{Î± : Type u_1} {E : Type u_2} (R : Type u_3) [AddCommGroup E] [DivisionRing R] [Monoid Î±] [module R E] [Distrib_MulAction Î± E] (n : â„¤) (S : Î±) (x : E) : (â†‘n)â»Â¹ â€¢ S â€¢ x = S â€¢ (â†‘n)â»Â¹ â€¢ x
(R : Type u_1) [has_One R] [HasNeg R] : Cardinal.Mk â†¥set.Univ = Cardinal.Mk R ^ 4
{Î± : Type u_1} [LinearOrder Î±] (S : Finset Î±) (hâ‚‚ : 1 < S.Card) : S.min' _ < S.max' _
{x : Type u_1} [TopologicalSpace x] (hX : âˆ€ {x y : x}, x â‰  y â†’ (âˆƒ (U : set x) (h_IsClopen : IsClopen U), x âˆˆ U âˆ§ y âˆ‰ U)) : IsTotallyDisconnected set.Univ
{A : Type u_1} {F : Type u_2} [MulZeroOneClass A] [Monoid_with_ZeroHom_class F â„• A] (F g : F) (h_Pos : âˆ€ {n : â„•}, 0 < n â†’ â‡‘F n = â‡‘g n) : F = g
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ o.oangle x y = 0
{n : â„•} (P : Fin (n + 1)) (i : Fin n) : â‡‘Fin.cast_Succ i < P âˆ¨ P â‰¤ â‡‘Fin.cast_Succ i
{n : â„•} {i : Fin (n + 1)} (h : 0 < i) : 0 < â‡‘Fin.cast_Succ i
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (hx : x â‰  0) (hy : y â‰  0) : HasInner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” InnerProductGeometry.angle x y = 0
{m : Type u_1} [CommMonoid_with_Zero m] {P : m} {L : List m} (pp : Prime P) : P âˆ£ L.Prod â†” âˆƒ (A : m) (h : A âˆˆ L), P âˆ£ A
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [Ring_hom_isometric Ïƒâ‚â‚‚] : âˆ¥0âˆ¥ = 0
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A B : Î±} (ha : 1 â‰¤ A) (hb : 1 < B) : 1 < A * B
(x : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens â†¥x) (F : â†¥(x.to_PresheafedSpace.presheaf.obj (Opposite.Op U))) (x : â†¥U) (h : IsUnit (â‡‘(x.to_PresheafedSpace.presheaf.germ x) F)) : âˆƒ (v : TopologicalSpace.Opens â†¥x) (i : v âŸ¶ U) (hxV : x.val âˆˆ v), IsUnit (â‡‘(x.to_PresheafedSpace.presheaf.Map i.Op) F)
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚‚} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J â¥¤ C} (e : K â‰Œ J) [CategoryTheory.Limits.HasColimit (e.Functor â‹™ F)] : CategoryTheory.Limits.HasColimit F
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} (hs : S.Nonempty) (ht : t.Nonempty) (bs : Metric.Bounded S) (bt : Metric.Bounded t) : Emetric.Hausdorff_edist S t â‰  âŠ¤
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) {C : â„} (LT_hF' : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv F x < C) (x : â„) (h : x âˆˆ D) (y : â„) (h_1 : y âˆˆ D) : x < y â†’ F y - F x < C * (y - x)
{x : Type u_1} [TopologicalSpace x] {S : set x} (hs : _Seq_IsClosed S) {x : â„• â†’ x} (hmem : âˆ€ (n : â„•), x n âˆˆ S) {A : x} (ha : Filter.Tendsto x Filter.at_top (nhds A)) : A âˆˆ S
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {F : C â¥¤ D} {Y Y' : D} (h : Y â‰… Y') (hY : Y âˆˆ F.EssImage) : Y' âˆˆ F.EssImage
{m : Type u_1} [has_Add m] {P : m â†’ Prop} (x : m) {S : set m} (hs : Add_Subsemigroup.Closure S = âŠ¤) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (HMul : âˆ€ (x y : m), P x â†’ P y â†’ P (x + y)) : P x
{m : Type u_3} {N : Type u_4} [MulOneClass m] [MulOneClass N] {F g : m â†’* N} (h : F = g) (x : m) : â‡‘F x = â‡‘g x
{A : Type u} {B : Type v} {Î¹ : Type W} [CommRing A] [CommRing B] [Algebra A B] [Fintype Î¹] [DecidableEq Î¹] (B : Î¹ â†’ B) (P : Matrix Î¹ Î¹ A) : Algebra.discr A ((P.Map â‡‘(Algebra_Map A B)).Mul_vec B) = P.det ^ 2 * Algebra.discr A B
{Î± : sort u} [DecidableEq Î±] {Î² : sort u_1} (F : Î± â†’ Î²) (A' : Î±) (B : Î²) (A : Î±) : Function.update F A' B A = Ite (A = A') B (F A)
{Î± : Type u_1} {l : Filter Î±} {P : Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in l, P x) â†’ (âˆ€á¶  (S : set Î±) in l.Small_sets, âˆ€ (x : Î±), x âˆˆ S â†’ P x)
{n n' : â„•} (i : Fin n) (h : n.Succ = n'.Succ) : â‡‘(Fin.cast h) i.Succ = (â‡‘(Fin.cast _) i).Succ
{Î¹ : Type v} {Î¹' : Type v'} (F : Î¹ â†’ Cardinal) (F' : Î¹' â†’ Cardinal) (g : Î¹ â†’ Î¹') (h : âˆ€ (i : Î¹), (F i).Lift â‰¤ (F' (g i)).Lift) : (Cardinal.Sup F).Lift â‰¤ (Cardinal.Sup F').Lift
(R : Type u_5) [Semiring R] (m : Type u_1) [AddCommMonoid m] [module R m] : Function.Surjective â‡‘(Finsupp.Total m m R Id)
{x : Type u_1} [TopologicalSpace x] [CompactSpace x] (A : Subalgebra â„ C(x, â„)) (W : A.separates_points) (F : C(x, â„)) : F âˆˆ A.topological_Closure
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] [DecidableEq v] : Finset.Univ.Sum (Î» (v : v), G.degree v) = 2 * G.edge_Finset.Card
{C : Type uâ‚} [CategoryTheory.Category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {x : C} (S : CategoryTheory.Sieve x) (x : CategoryTheory.Equalizer.FirstObj P â‡‘S) : ((CategoryTheory.Equalizer.FirstObj_Eq_family P â‡‘S).hom x).compatible â†” CategoryTheory.Equalizer.Sieve.first_Map P S x = CategoryTheory.Equalizer.Sieve.second_Map P S x
(Fq F : Type) [Field Fq] [Fintype Fq] [Field F] [Algebra (Polynomial Fq) F] [Algebra (Ratfunc Fq) F] [IsScalarTower (Polynomial Fq) (Ratfunc Fq) F] [Function_Field Fq F] [_IsSeparable (Ratfunc Fq) F] : Function_Field.ClassNumber Fq F = 1 â†” _principal_Ideal_Ring â†¥(Function_Field.Ring_of_integers Fq F)
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] {A : Î±} (h : (set.Iio A).Nonempty) : Closure (set.Iio A) = set.Iic A
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : Fin 3 â†’ P) : AffineIndependent k P â†” Â¬Collinear k (set.Range P)
{F : Type u_3} [Field F] [Fintype F] : Ring_Char F = 2 â†” Fintype.Card F % 2 = 0
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] {F : Type v} [NormedGroup F] [NormedSpace â„‚ F] {F : E â†’ F} (hF : Differentiable â„‚ F) (hb : Metric.Bounded (set.Range F)) (z W : E) : F z = F W
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} [CategoryTheory.Limits.HasEqualizer F g] (h : F = g) : CategoryTheory.IsIso (CategoryTheory.Limits.EqualizerÎ¹ F g)
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [DenselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [TopologicalSpace Î´] [order_IsClosed_topology Î´] {S : set Î±} [hs : S.Ord_connected] {F : Î± â†’ Î´} (hF : Continuous_on F S) {A B : Î±} (ha : A âˆˆ S) (hb : B âˆˆ S) : set.surj_on F S (set.Interval (F A) (F B))
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} : Char.quadratic_Char F A = -1 â†” Â¬IsSquare A
{Î± : Type u_1} [TopologicalSpace Î±] [non_unital_non_assoc_Ring Î±] [topological_Ring Î±] (x : Î±) : Continuous â‡‘(AddMonoid_hom.Mul_Left x)
(P : Prop) [Decidable P] : P âˆ¨ Â¬P
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : â†‘r < P.radius) : âˆƒ (A : â„) (h : A âˆˆ set.Ioo 0 1) (C : â„) (h : C > 0), âˆ€ (n : â„•), âˆ¥P nâˆ¥ * â†‘r ^ n â‰¤ C * A ^ n
{J : Type uâ‚} [CategoryTheory.Category J] [Nonempty J] {jâ‚€ : J} (h : âˆ€ (P : set J), jâ‚€ âˆˆ P â†’ (âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ (jâ‚ âˆˆ P â†” jâ‚‚ âˆˆ P)) â†’ âˆ€ (j : J), j âˆˆ P) : CategoryTheory.IsConnected J
{m : Type u_1} [AddMonoid m] (S : Add_Submonoid m) {l : List m} (hl : âˆ€ (x : m), x âˆˆ l â†’ x âˆˆ S) : l.Sum âˆˆ S
{Î± : Type u_1} {Î² : Type u_2} (P : Pmf Î±) (F : Î± â†’ Pmf Î²) (S : set Î²) [MeasurableSpace Î²] (hs : Measurable_set S) : â‡‘((P.Bind F).to_measure) S = âˆ‘' (A : Î±), â†‘(â‡‘P A) * â‡‘((F A).to_measure) S
{G : Type u_1} [Group G] (h : Subgroup G) : 1 âˆˆ h
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type uâ‚} [CategoryTheory.Category D] (h : C â‰Œ D) : CategoryTheory.IsCofiltered D
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x y : E) : _R_or_C.Abs (HasInner.inner x y) * _R_or_C.Abs (HasInner.inner y x) â‰¤ â‡‘_R_or_C.re (HasInner.inner x x) * â‡‘_R_or_C.re (HasInner.inner y y)
{A B C m : â„•} (hmc : m.Gcd C = 1) (h : A * C â‰¡ B * C [Mod m]) : A â‰¡ B [Mod m]
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] {x : m} {S : set m} {P : m â†’ Prop} (h : x âˆˆ Submodule.Span R S) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (h0 : P 0) (h1 : âˆ€ (x y : m), P x â†’ P y â†’ P (x + y)) (h2 : âˆ€ (A : R) (x : m), P x â†’ P (A â€¢ x)) : P x
{Î± : Type u_1} {Î¹ : sort u_3} [conditionally_complete_LinearOrder Î±] {A : Î±} [Nonempty Î¹] {F : Î¹ â†’ Î±} (h : infi F < A) : âˆƒ (i : Î¹), F i < A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {x : E} {n : WithTop â„•} (e : G â‰ƒL[ð•œ] E) : ContDiff_within_at ð•œ n (F âˆ˜ â‡‘e) (â‡‘e â»Â¹' S) (â‡‘(e.Symm) x) â†” ContDiff_within_at ð•œ n F S x
{m : Type u_6} {N : Type u_7} [has_Mul m] [has_Mul N] {F g : m â‰ƒ* N} (h : âˆ€ (x : m), â‡‘F x = â‡‘g x) : F = g
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] {L : C â¥¤ D} {R : D â¥¤ C} (Adj : L âŠ£ R) : R.final
(S B : â„) (hb : 0 < B) : Filter.Tendsto (Î» (x : â„), Real.Exp (B * x) / x ^ S) Filter.at_top Filter.at_top
{R : Type u} {Î¹ : Type W} (S : Finset Î¹) [CommSemiring R] (F : Î¹ â†’ Polynomial R) (h : S.Prod (Î» (i : Î¹), (F i).leading_Coeff) â‰  0) : (S.Prod (Î» (i : Î¹), F i)).leading_Coeff = S.Prod (Î» (i : Î¹), (F i).leading_Coeff)
{x : top} {Y : TopologicalSpace.Opens â†¥x} (R : CategoryTheory.Presieve Y) : top.Presheaf.Presieve_of_covering_aux (top.Presheaf.covering_of_Presieve Y R) Y = R
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_3} [Fintype Î±] [Fintype Î²] [AddCommMonoid m] (e : Î± â†’ Î²) (hE : Function.Bijective e) (F : Î± â†’ m) (g : Î² â†’ m) (h : âˆ€ (x : Î±), F x = g (e x)) : Finset.Univ.Sum (Î» (x : Î±), F x) = Finset.Univ.Sum (Î» (x : Î²), g x)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {x : E} {n : WithTop â„•} (g : F â†’L[ð•œ] G) (hF : ContDiff_within_at ð•œ n F S x) : ContDiff_within_at ð•œ n (â‡‘g âˆ˜ F) S x
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {g1 g2 : G} (P : P) (h : g1 +áµ¥ P = g2 +áµ¥ P) : g1 = g2
{Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î± â†’ Prop) (S : Î² â†’ Î² â†’ Prop) [IsTrichotomous Î± r] [IsIrrefl Î² S] (F : Î± â†’ Î²) (hF : âˆ€ {x y : Î±}, r x y â†’ S (F x) (F y)) : Function.Injective F
{Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {F F' : Î± â†’ Î² â†’ Î³} {S : set Î±} {t : set Î²} (h : âˆ€ (A : Î±) (B : Î²), F A B = F' A B) : set.image2 F S t = set.image2 F' S t
{m : Type u_1} [has_Add m] {C D : Add_Con m} (h : C.to_Setoid = D.to_Setoid) : C = D
{C : Type u} [CategoryTheory.Category C] {x Y : C} [CategoryTheory.Limits.HasZeroMorphisms C] (F : x âŸ¶ Y) [CategoryTheory.Limits.HasKernel F] {Z : C} (h : Y âŸ¶ Z) [CategoryTheory.Limits.HasKernel (F â‰« h)] : CategoryTheory.Limits.Kernel_Subobject F â‰¤ CategoryTheory.Limits.Kernel_Subobject (F â‰« h)
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {F g : v â†’â‚—[K] v} : F * g = 1 â†” g * F = 1
{v : Type u_1} [InnerProductSpace â„ v] {x : v} (hx : x â‰  0) : InnerProductGeometry.angle (-x) x = Real.Pi
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {P1 P2 : P} (P3 : P) (hp1 : P1 âˆˆ S) (hp2 : P2 âˆˆ S) : HasDist.dist P1 P3 = HasDist.dist P2 P3 â†” HasDist.dist P1 â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P3) = HasDist.dist P2 â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P3)
{m : Type u_1} [AddCommMonoid m] (S : Add_Submonoid m) {Î¹ : Type u_2} {t : Finset Î¹} {F : Î¹ â†’ m} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Sum (Î» (C : Î¹), F C) âˆˆ S
{J : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] {Î± : Type uâ‚} (F : J â†’ Î±) (h : âˆ€ (jâ‚ jâ‚‚ : J), (jâ‚ âŸ¶ jâ‚‚) â†’ F jâ‚ = F jâ‚‚) (j j' : J) : F j = F j'
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {x : E} : P.radius - â†‘âˆ¥xâˆ¥â‚Š â‰¤ (P.change_origin x).radius
{R : Type u_1} [CommMonoid_with_Zero R] (n : R) : Prime_Pow n â†” âˆƒ (P : R) (k : â„•), Prime P âˆ§ P ^ (k + 1) = n
(C : â„‚) (R : â„) : Function.Periodic (Circle_Map C R) (2 * Real.Pi)
{Î± : Type u} [PseudoEmetricSpace Î±] (x y z : Î±) : HasEdist.edist x y â‰¤ HasEdist.edist z x + HasEdist.edist z y
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (Sâ‚ Sâ‚‚ : AffineSubspace â„ P) [Nonempty â†¥Sâ‚] [Nonempty â†¥Sâ‚‚] [CompleteSpace â†¥(Sâ‚.direction)] [CompleteSpace â†¥(Sâ‚‚.direction)] (P : P) : â‡‘(EuclideanGeometry.reflection Sâ‚) P = â‡‘(EuclideanGeometry.reflection Sâ‚‚) P â†” â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection Sâ‚) P) = â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection Sâ‚‚) P)
{E : Type u} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] {n : â„•} (A B : Fin (n + 1) â†’ â„) (hle : A â‰¤ B) (F : (Fin (n + 1) â†’ â„) â†’ Fin (n + 1) â†’ E) (F' : (Fin (n + 1) â†’ â„) â†’ ((Fin (n + 1) â†’ â„) â†’L[â„] Fin (n + 1) â†’ E)) (S : set (Fin (n + 1) â†’ â„)) (hs : S.countable) (Hc : Continuous_on F (set.icc A B)) (hD : âˆ€ (x : Fin (n + 1) â†’ â„), x âˆˆ set.Univ.Pi (Î» (i : Fin (n + 1)), set.Ioo (A i) (B i))  S â†’ HasFderivAt F (F' x) x) (Hi : MeasureTheory.IntegrableOn (Î» (x : Fin (n + 1) â†’ â„), Finset.Univ.Sum (Î» (i : Fin (n + 1)), â‡‘(F' x) (Pi.single i 1) i)) (set.icc A B) MeasureTheory.MeasureSpace.Volume) : âˆ« (x : Fin (n + 1) â†’ â„) in set.icc A B, Finset.Univ.Sum (Î» (i : Fin (n + 1)), â‡‘(F' x) (Pi.single i 1) i) = Finset.Univ.Sum (Î» (i : Fin (n + 1)), (âˆ« (x : Fin n â†’ â„) in set.icc (A âˆ˜ â‡‘(i.Succ_above)) (B âˆ˜ â‡‘(i.Succ_above)), F (i.Insert_nth (B i) x) i) - âˆ« (x : Fin n â†’ â„) in set.icc (A âˆ˜ â‡‘(i.Succ_above)) (B âˆ˜ â‡‘(i.Succ_above)), F (i.Insert_nth (A i) x) i)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : F =o[l] g â†” âˆ€ â¦ƒC : â„â¦„, 0 < C â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥F xâˆ¥ â‰¤ C * âˆ¥g xâˆ¥)
{Î± : Type u_1} [has_Add Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B C D : Î±} (hâ‚ : A < B) (hâ‚‚ : C < D) : A + C < B + D
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) (init : Fin E.order â†’ Î±) (n : Fin E.order) : E.Mk_sol init â†‘n = init n
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cáµ’áµ– â¥¤ A) [CategoryTheory.Limits.HasProducts A] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Presheaf.IsSheaf J P â†” CategoryTheory.Presheaf.IsSheaf' J P
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} {ps : set P} (h : ps âŠ† â†‘S) [Nonempty â†¥S] {n : â„•} [Finite_dimensional â„ â†¥(S.direction)] (hD : Finite_dimensional.finrank â„ â†¥(S.direction) = n) (hc : EuclideanGeometry.Cospherical ps) {sxâ‚ sxâ‚‚ : Affine.Simplex â„ P n} (hsxâ‚ : set.Range sxâ‚.points âŠ† ps) (hsxâ‚‚ : set.Range sxâ‚‚.points âŠ† ps) : sxâ‚.circumcenter = sxâ‚‚.circumcenter
{Î± : Type u_1} {Î² : Type u_2} [CompleteLattice Î±] (A : Î±) (F : Î² â†’ Î±) : (â¨… (o : Option Î²), Option.elim A F o) = A âŠ“ â¨… (B : Î²), F B
{m : Type u_6} {N : Type u_7} [has_Add m] [has_Add N] (e : m â‰ƒ+ N) (y : N) : â‡‘e (â‡‘(e.Symm) y) = y
{Î² : Type u_4} [LinearOrder Î²] [NoMinOrder Î²] {u : â„• â†’ Î²} (hu : Filter.Tendsto u Filter.at_top Filter.at_IsBot) (N : â„•) : âˆƒ (n : â„•) (h : n â‰¥ N), âˆ€ (k : â„•), k < n â†’ u n < u k
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [CommMonoid N] (F : Î± â†’â‚€ m) (y : Î±) (g : Î± â†’ m â†’ N) (hg : âˆ€ (i : Î±), g i 0 = 1) : g y (â‡‘F y) * (Finsupp.erase y F).Prod g = F.Prod g
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 P : P} : P1 -áµ¥ P = P2 -áµ¥ P â†” P1 = P2
{Î± : Type u} [Linear_ordered_Ring Î±] {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} (ha : A < 0) (hb : B < 0) : A + B < 0
{Î± : Type u_1} [Subsingleton Î±] (S : Finset Î±) : S.Card â‰¤ 1
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] {x Y : C} [CategoryTheory.Simple x] [CategoryTheory.Simple Y] {F : x âŸ¶ Y} (W : F â‰  0) : CategoryTheory.IsIso F
{P : â„•} {G : Type u_1} [Group G] (hG : _P_Group P G) [hp : Fact (Nat.Prime P)] (Î± : Type u_2) [MulAction G Î±] [Fintype Î±] [Fintype â†¥(MulAction.FixedPoints G Î±)] : Fintype.Card Î± â‰¡ Fintype.Card â†¥(MulAction.FixedPoints G Î±) [Mod P]
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Simple 0] : False
{R : Type u_1} {A B : R} [AddMonoid R] (h : A + B = 0) : _Add_Right_regular A
{Î± : Type u_1} {Î² : Type u_2} [AddGroup Î±] [AddCommGroup Î²] {F g : Î± â†’ Î²} (hF : _AddGroup_hom F) (hg : _AddGroup_hom g) : _AddGroup_hom (Î» (A : Î±), F A + g A)
{G : Type u_1} [Group G] [hN : Nontrivial G] : Monoid._torsion_free G â†’ Â¬Monoid._torsion G
{Î¹ : Type u_1} {R : Type u_2} (S : Type u_3) {m : Î¹ â†’ Type u_4} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (m i)] [Î  (i : Î¹), module R (m i)] [AddCommMonoid N] [module R N] [Semiring S] [module S N] [SmulCommClass R S N] (F : Î  (i : Î¹), m i â†’â‚—[R] N) (i : Î¹) (x : m i) : â‡‘(â‡‘(Dfinsupp.lsum S) F) (Dfinsupp.single i x) = â‡‘(F i) x
{Î± : Type u_1} {g g' : GeneralizedContinuedFraction Î±} : g = g' â†” g.h = g'.h âˆ§ g.S = g'.S
{A : â„} {l : Filter â„} {F F' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhds_within A (set.ioi A), HasDerivAt F (F' x) x) (hgg' : âˆ€á¶  (x : â„) in nhds_within A (set.ioi A), HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhds_within A (set.ioi A), g' x â‰  0) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.ioi A)) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), F' x / g' x) (nhds_within A (set.ioi A)) l) : Filter.Tendsto (Î» (x : â„), F x / g x) (nhds_within A (set.ioi A)) l
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {P : Filter Î¹} [TopologicalSpace Î±] (h : TendstoLocallyUniformly F F P) (hc : âˆ€á¶  (n : Î¹) in P, Continuous (F n)) [P.Ne_IsBot] : Continuous F
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization m S] {Î¹ : Type u_3} (S : Finset Î¹) (F : Î¹ â†’ S) : âˆƒ (B : â†¥m), âˆ€ (i : Î¹), i âˆˆ S â†’ IsLocalization._integer R (â†‘B â€¢ F i)
(ð•œ : Type u_1) (E : Type u_2) [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] (v : Fin 1 â†’ E) : â‡‘(FormalMultilinearSeries.Id ð•œ E 1) v = v 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x Y : AlgebraicGeometry.PresheafedSpace C} (Î± Î² : x âŸ¶ Y) (hâ‚ : Î± = Î²) (x x' : â†¥x) (hâ‚‚ : x = x') : AlgebraicGeometry.PresheafedSpace.stalk_Map Î± x â‰« CategoryTheory.Eq_to_hom _ = CategoryTheory.Eq_to_hom _ â‰« AlgebraicGeometry.PresheafedSpace.stalk_Map Î² x'
{Î± : Type u_1} {Î² : Type u_2} [has_Add Î±] [Preorder Î±] [Preorder Î²] {F g : Î² â†’ Î±} [CovariantClass Î± Î± has_Add.Add has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] (hF : StrictMono F) (hg : Monotone g) : StrictMono (Î» (x : Î²), F x + g x)
{Î± : Type u_1} [CompleteLattice Î±] {S : set Î±} {B : Î±} : (âˆ€ (A : Î±), A âˆˆ S â†’ B â‰¤ A) â†’ (âˆ€ (W : Î±), B < W â†’ (âˆƒ (A : Î±) (h : A âˆˆ S), A < W)) â†’ HasInf.Inf S = B
{Î± : Type u_1} {E : Type u_3} [TopologicalSpace Î±] [CompactSpace Î±] [NormedGroup E] (F : C(Î±, E)) {C : â„} (C0 : 0 â‰¤ C) : âˆ¥Fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘F xâˆ¥ â‰¤ C
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] [DenselyOrdered Î²] {F : Î± â†’ Î²} (h_Mono : Monotone F) (h_Dense : DenseRange F) : Continuous F
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} (h : S âŠ† t) (ht : Metric.Bounded t) : Metric.diam S â‰¤ Metric.diam t
{Î¹ : sort u_1} {F : Î¹ â†’ Ennreal} {x : Ennreal} (h0 : x â‰  0) (h : x â‰  âŠ¤) : x * infi F = â¨… (i : Î¹), x * F i
{m : Type u_1} {N : Type u_2} [AddZeroClass m] [AddZeroClass N] (h : m â‰ƒ+ N) : _Add_hom â‡‘h
{m : Type u_1} [has_Add m] (C : Add_Con m) {W x y z : m} : â‡‘C W x â†’ â‡‘C y z â†’ â‡‘C (W + y) (x + z)
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (hs : TopologicalSpace._IsSeparable S) : TopologicalSpace.IsSeparable_Space â†¥S
{R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] {n : â„•} (h : âˆ€ (S : Finset m), LinearIndependent R (Î» (i : â†¥S), â†‘i) â†’ S.Card â‰¤ n) (S : set m) : LinearIndependent R Coe â†’ Cardinal.Mk â†¥S â‰¤ â†‘n
{R : Type u} [Ring R] {S t : Subring R} (h : âˆ€ (x : R), x âˆˆ S â†” x âˆˆ t) : S = t
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
{Î± : sort u} : WellFounded Empty_Relation
{Î± : Type u} {G : Type W} [TopologicalSpace G] [has_Inv G] [has_Continuous_Inv G] {F : Î± â†’ G} {l : Filter Î±} {y : G} (h : Filter.Tendsto F l (nhds y)) : Filter.Tendsto (Î» (x : Î±), (F x)â»Â¹) l (nhds yâ»Â¹)
{Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {F : Filter Î±} {l : Filter Î¹} [l._countably_generated] (hxy : âˆ€ (ns : â„• â†’ Î¹), Filter.Tendsto ns Filter.at_top l â†’ (âˆƒ (ms : â„• â†’ â„•), Filter.Tendsto (Î» (n : â„•), x (ns (ms n))) Filter.at_top F)) : Filter.Tendsto x l F
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F g : Î± â†’ m} {S : set Î±} (hF : (S âˆ© Function.Support F).Finite) (hg : (S âˆ© Function.Support g).Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i + g i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), g i))
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (i : Fin r âŠ• Unit) : m.Mul (Matrix.Pivot.List_transvec_row m).Prod i (Sum.inr_ ()) = m i (Sum.inr_ ())
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {z : â„‚} {F : â„‚ â†’ E} (h : Differentiable_at â„‚ F z) (hF' : deriv F z â‰  0) : ConformalAt F z
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] (A : R) : module._IsTorsionBy R m A â†” Submodule.IsTorsionBy R m A = âŠ¤
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] (eâ‚ eâ‚‚ : Basis Î¹ R m) : eâ‚.Orientation = eâ‚‚.Orientation â†” 0 < â‡‘(eâ‚.det) â‡‘eâ‚‚
{Î± : Type u} {l : List Î±} : l.attach.Nodup â†’ l.Nodup
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {S : set E} (h : IsLocalMaxOn F S A) {y : E} (hy : y âˆˆ Pos_TangentConeAt S A) (hy' : -y âˆˆ Pos_TangentConeAt S A) : â‡‘(fderiv_within â„ F S A) y = 0
{A : Type u_1} {K : Type u_2} [CommRing A] [IsDomain A] [Unique_factorization_Monoid A] [Field K] [Algebra A K] [_fraction_Ring A K] {P : Polynomial A} {r : K} (hr : â‡‘(Polynomial.aeval r) P = 0) : _fraction_Ring.Num A r âˆ£ P.Coeff 0
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (S : Subalgebra R A) (HS : S.to_Submodule.fg) (x : A) (hx : x âˆˆ S) : IsIntegral R x
{R : Type u} [CommRing R] (U v : TopologicalSpace.Opens â†¥(AlgebraicGeometry.Prime_Spectrum.top R)) (iVU : v âŸ¶ U) : AlgebraicGeometry.StructureSheaf.comap (Ring_hom.Id R) U v _ = (AlgebraicGeometry.spec.StructureSheaf R).val.Map iVU.Op
{m : Type u_1} [AddCommMonoid m] {S t : set m} {x : m} : x âˆˆ AddMonoid.Closure (S âˆª t) â†” âˆƒ (y : m) (h : y âˆˆ AddMonoid.Closure S) (z : m) (h : z âˆˆ AddMonoid.Closure t), y + z = x
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : âˆ¥x + yâˆ¥ = âˆ¥x - yâˆ¥ â†” InnerProductGeometry.angle x y = Real.Pi / 2
{Î± : Type u} [PseudoEmetricSpace Î±] {Î´ : â„} {E : set Î±} : IsOpen (Metric.Thickening Î´ E)
(u : pnat.xgcd_Type) (hr : u.r â‰  0) : u.step.v = u.v.Swap
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : S âŠ† SpanPoints k S
{Î± : Type u_1} [Preorder Î±] [SuccOrder Î±] {A B : Î±} [NoMaxOrder Î±] : Order.Succ A < Order.Succ B â†’ A < B
{Î± : Type u_1} [generalized_boolean_Algebra Î±] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] {S : Finset Î±} {u v A : Î±} (ha : A âˆˆ Uv.Compression u v S) (hva : v â‰¤ A) (hvu : v = âŠ¥ â†’ u = âŠ¥) : A âˆˆ S
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {F : â„‚ â†’ E} (hD : Diff_Cont_on_cl â„‚ F (set.Iio 0 Ã—â„‚ set.ioi 0)) (hB : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.Iio 0 Ã—â„‚ set.ioi 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ F â†‘x = 0) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ F (â†‘x * Complex.i) = 0) : set.Eq_on F 0 {z : â„‚ | z.re â‰¤ 0 âˆ§ 0 â‰¤ z.im}
{Î± : Type u_3} {Î² : Type u_4} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Monotone F) (h : âˆ€ (B : Î²), âˆƒ (A : Î±), B â‰¤ F A) : Filter.Tendsto F Filter.at_top Filter.at_top
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} : Differentiable ð•œ F â†’ Mdifferentiable (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F
{Î± : Type u_1} [Linear_ordered_Field Î±] {A : Î±} (A2 : 2 â‰¤ A) : (1 - 1 / A)â»Â¹ â‰¤ 2
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (R : D â¥¤ C) [CategoryTheory.Limits.HasLimits_of_size C] [CategoryTheory.Reflective R] : CategoryTheory.Limits.HasLimits_of_size D
(ð•œ : Type v) [_R_or_C ð•œ] {E : Type u} [NormedGroup E] [NormedSpace ð•œ E] [Nontrivial E] (x : E) : âˆƒ (g : E â†’L[ð•œ] ð•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
{R : Type u_1} {S : Type u_2} {m : Type u_3} {A : R} {S : S} [HasScalar R m] [HasScalar R S] [HasScalar S m] [IsScalarTower R S m] (ra : IsSmulRegular m A) (rs : IsSmulRegular m S) : IsSmulRegular m (A â€¢ S)
{G : Type u} [Group G] (h : Subgroup G) (h : Subsingleton (G â§¸ h)) : h = âŠ¤
{Î± : Type u_1} {n : Type u_3} {m : Type u_4} {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} (hA : A.IsSymm) (hBC : B.transpose = C) (hD : D.IsSymm) : (Matrix.from_blocks A B C D).IsSymm
{m : Type u_1} [Semigroup m] {A : Stream m} {m : m} (hm : m âˆˆ Hindman.FP A) : âˆƒ (n : â„•), âˆ€ (m' : m), m' âˆˆ Hindman.FP (Stream.Drop n A) â†’ m * m' âˆˆ Hindman.FP A
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : hb.oangle x y = Î¸ â†” âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(hb.rotation Î¸) x
{ð•œ : Type u_1} {E : Type u_2} [Linear_ordered_Field ð•œ] [ordered_AddCommGroup E] [module ð•œ E] {S : set E} (hs : Convex ð•œ S) : IsLeast {t : Convex_cone ð•œ E | S âŠ† â†‘t} (Convex.to_cone S hs)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} {F : ð•œ â†’ F} {S : set ð•œ} {x : ð•œ} {m : Fin n â†’ ð•œ} : â‡‘(iterated_fderiv_within ð•œ n F S x) m = Finset.Univ.Prod (Î» (i : Fin n), m i) â€¢ iterated_deriv_within n F S x
(C : â„‚) : â‡‘clifford_Algebra_Complex.of_Complex (â‡‘(Star_Ring_end â„‚) C) = â‡‘clifford_Algebra.involute (â‡‘clifford_Algebra_Complex.of_Complex C)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (F : v â‰ƒâ‚—áµ¢[â„] v) : âˆƒ (Î¸ : Real.Angle), F = hb.rotation Î¸ âˆ¨ F = hb.Conj_lie.Trans (hb.rotation Î¸)
{Î¹ : Type u} (S : Finset Î¹) (W z : Î¹ â†’ Nnreal) (hw' : S.Sum (Î» (i : Î¹), W i) = 1) : S.Prod (Î» (i : Î¹), z i ^ â†‘(W i)) â‰¤ S.Sum (Î» (i : Î¹), W i * z i)
{x : â„} (lx : Liouville x) : Transcendental â„¤ x
{F : â„ â†’ â„} {A B : â„} (hfi : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (h : âˆ€ (x : â„), 0 < F x) (hab : A < B) : 0 < âˆ« (x : â„) in A..B, F x
{A B C D B' D' : SemiNormedGroup} {fab : A âŸ¶ B} {fbd : B âŸ¶ D} {fac : A âŸ¶ C} {fcd : C âŸ¶ D} {h : fab â‰« fbd = fac â‰« fcd} {fbb' : B âŸ¶ B'} {fdd' : D âŸ¶ D'} {condb : fab â‰« fbb' = 0} {condd : fcd â‰« fdd' = 0} {g : B' âŸ¶ D'} (h' : fbb' â‰« g = fbd â‰« fdd') : SemiNormedGroup.explicit_Cokernel_Desc condb â‰« g = SemiNormedGroup.explicit_Cokernel.Map h â‰« SemiNormedGroup.explicit_Cokernel_Desc condd
{R : Type u_1} [Semiring R] (P : Polynomial R) : â‡‘Polynomial.to_laurent P = Finsupp.Map_IsDomain Coe P.to_Finsupp
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [NormedGroup F] [NormedSpace â„ F] {F : E â†’ F} {P : E â†’ FormalMultilinearSeries â„ E F} {S : set E} {x : E} (hF : HasFtaylorSeriesUpToOn 1 F P (HasInsert.Insert x S)) (hs : Convex â„ S) : âˆƒ (K : Nnreal) (t : set E) (h : t âˆˆ nhds_within x S), LipschitzOnWith K F t
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] {m : m} {S : set m} : m âˆˆ Submodule.Span R S â†” âˆƒ (C : m â†’â‚€ R), â†‘(C.Support) âŠ† S âˆ§ C.Sum (Î» (mi : m) (r : R), r â€¢ mi) = m
{x : Type u_1} {Y : Type u_2} {F : x â†’ Y} (hF : Function.Injective F) : TopologicalSpace.induced F âŠ¥ = âŠ¥
{Î± : Type u_1} {F : Î± â†’ Ennreal} (hF : âˆ‘' (x : Î±), F x â‰  âŠ¤) : Filter.Tendsto (Î» (S : Finset Î±), âˆ‘' (B : {x // x âˆ‰ S}), F â†‘B) Filter.at_top (nhds 0)
(ð•œ : Type u_1) (E : Type u_2) [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] {n : â„•} (h : n â‰  1) : FormalMultilinearSeries.Id ð•œ E n = 0
{Î± : Type u} {Î² : Type v} {Î³ : Type W} [TopologicalSpace Î±] [PseudoMetricSpace Î²] [PseudoMetricSpace Î³] {G : Î² â†’ Î³} {C : Nnreal} (h : LipschitzWith C G) : LipschitzWith C (bounded_Continuous_Function.Comp G h)
{Î“ : Type u_1} [Inhabited Î“] (l : Turing.List_blank Î“) : Turing.List_blank.Cons l.head l.tail = l
{G : Type u_1} [AddGroup G] {h : Add_Subgroup G} {N : Type u_3} [AddGroup N] (F : N â†’+ G) : Add_Subgroup.comap F h.Normalizer â‰¤ (Add_Subgroup.comap F h).Normalizer
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {v : â„ â†’ E â†’ E} {S : â„ â†’ set E} {K : â„} (hv : âˆ€ (t : â„) (x : E), x âˆˆ S t â†’ âˆ€ (y : E), y âˆˆ S t â†’ HasDist.dist (v t x) (v t y) â‰¤ K * HasDist.dist x y) {F g F' g' : â„ â†’ E} {A B ÎµF Îµg Î´ : â„} (hF : Continuous_on F (set.icc A B)) (hF' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt F (F' t) (set.ici t) t) (F_bound : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDist.dist (F' t) (v t (F t)) â‰¤ ÎµF) (hfs : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ F t âˆˆ S t) (hg : Continuous_on g (set.icc A B)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDerivWithinAt g (g' t) (set.ici t) t) (g_bound : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ HasDist.dist (g' t) (v t (g t)) â‰¤ Îµg) (hgs : âˆ€ (t : â„), t âˆˆ set.Ico A B â†’ g t âˆˆ S t) (ha : HasDist.dist (F A) (g A) â‰¤ Î´) (t : â„) (h : t âˆˆ set.icc A B) : HasDist.dist (F t) (g t) â‰¤ gronwall_bound Î´ K (ÎµF + Îµg) (t - A)
{m : Type u_1} [has_Add m] {C D : Add_Con m} {x y : m} : â‡‘(C âŠ“ D) x y â†” â‡‘C x y âˆ§ â‡‘D x y
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] (hfp : Algebra.Finite_presentation R A) (e : A â‰ƒâ‚[R] B) : Algebra.Finite_presentation R B
{Î¹ : Type u_1} {m : Î¹ â†’ Type u_2} [Î  (i : Î¹), Monoid (m i)] (W : FreeProduct.Word m) (h : W â‰  FreeProduct.Word.Empty) : âˆƒ (i j : Î¹) (W' : FreeProduct.Neword m i j), W'.to_Word = W
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : i â‰¤ â‡‘Fin.cast_Succ j) : x.Î´ (â‡‘Fin.cast_Succ i) â‰« x.Ïƒ j.Succ = x.Ïƒ j â‰« x.Î´ i
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {n : WithTop â„•} (hF : IsBoundedLinearMap ð•œ F) : ContDiff ð•œ n F
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (ht : âˆ€ (y : Î²), y âˆ‰ t â†’ 0 â‰¤ (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x)) (hb : S.Sum (Î» (x : Î±), W x) < t.Card â€¢ B) : âˆƒ (y : Î²) (h : y âˆˆ t), (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x) < B
{A : Type u_1} [CommRing A] [Algebra â„š A] (k : â„•) : PowerSeries.Exp A ^ k = â‡‘(PowerSeries.rescale â†‘k) (PowerSeries.Exp A)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â‰ƒL[ð•œ] F} {g : F â†’ E} {A : F} (hg : Continuous_at g A) (hF : HasStrictFderivAt F â†‘F' (g A)) (hfg : âˆ€á¶  (y : F) in nhds A, F (g y) = y) : HasStrictFderivAt g â†‘(F'.Symm) A
(x : Type u) [MetricSpace x] [CompactSpace x] [Nonempty x] (Y : Type v) [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : âˆƒ (Î¦ : x â†’ â†¥(Lp (Î» (n : â„•), â„) âŠ¤)) (Î¨ : Y â†’ â†¥(Lp (Î» (n : â„•), â„) âŠ¤)), Isometry Î¦ âˆ§ Isometry Î¨ âˆ§ GromovHausdorff.GH_dist x Y = metric.Hausdorff_dist (set.Range Î¦) (set.Range Î¨)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {vâ‚‚ : Type v'} [AddCommGroup vâ‚‚] [module K vâ‚‚] (F : v â†’â‚—[K] vâ‚‚) (W : Function.Surjective â‡‘F) [Finite_dimensional K v] : Finite_dimensional K vâ‚‚
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [NormedGroup F] [NormedSpace â„ F] {x : E} {F : E â†’ F} {F' : E â†’ (E â†’L[â„] F)} {F'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€ (y : E), HasFderivAt F (F' y) y) (hx : HasFderivAt F' F'' x) (v W : E) : â‡‘(â‡‘F'' v) W = â‡‘(â‡‘F'' W) v
{Î± : Type u_1} {Î¹' : sort u_5} [CompleteLattice Î±] (S : Î¹' â†’ Î±) : (â¨… (i : Î¹'), S i) = â¨… (t : Finset (plift Î¹')) (i : plift Î¹') (h : i âˆˆ t), S i.down
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {F : v â‰ƒâ‚—áµ¢[â„] v} (hD : â‡‘LinearMap.det â†‘(F.to_Linear_Equiv) < 0) : âˆƒ (Î¸ : Real.Angle), F = hb.Conj_lie.Trans (hb.rotation Î¸)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {x Y : C} (F g : x âŸ¶ Y) : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.ParallelPair F g)
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [AddZeroClass m] [CommMonoid N] {F g : Î± â†’â‚€ m} {h : Î± â†’ m â†’ N} (h_Zero : âˆ€ (A : Î±), h A 0 = 1) (h_Add : âˆ€ (A : Î±) (Bâ‚ Bâ‚‚ : m), h A (Bâ‚ + Bâ‚‚) = h A Bâ‚ * h A Bâ‚‚) : (F + g).Prod h = F.Prod h * g.Prod h
{R : Type u_1} {Râ‚‚ : Type u_2} {m : Type u_4} {mâ‚‚ : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Semiring Râ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚‚ mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {S : set m} {F g : m â†’â‚›â‚—[Ïƒâ‚â‚‚] mâ‚‚} (h : set.Eq_on â‡‘F â‡‘g S) : set.Eq_on â‡‘F â‡‘g â†‘(Submodule.Span R S)
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 P : P} (h : P1 -áµ¥ P = P2 -áµ¥ P) : P1 = P2
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) {u : â„• â†’ Î±} {init : Fin E.order â†’ Î±} (h : E._solution u) (HEq : âˆ€ (n : Fin E.order), u â†‘n = init n) : u = E.Mk_sol init
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = Real.Pi) : HasDist.dist P1 P3 = HasDist.dist P1 P2 + HasDist.dist P3 P2
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {S : set E} {x : E} : MdifferentiableWithinAt (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F S x â†” Differentiable_within_at ð•œ F S x
{m : Type u} [Monoid m] (x : m) (n : â„•) : Mul_Opposite.Op (x ^ n) = Mul_Opposite.Op x ^ n
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S : set Î±} (h : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) â‰  0) : âˆƒ (x : Î±) (h : x âˆˆ S), F x â‰  0
{B x C : Ordinal} (B1 : 1 < B) (x0 : 0 < x) : B ^ C â‰¤ x â†” C â‰¤ Ordinal.log B x
(G : Type u_1) [Group G] : Group.IsNilpotent G â†” âˆƒ (n : â„•) (h : â„• â†’ Subgroup G), IsDescendingCentralSeries h âˆ§ h n = âŠ¥
{Î² : Type u} {Î± : Type v} {S : Finset Î±} {A : Î±} {F : Î± â†’ Î²} [CommMonoid Î²] [DecidableEq Î±] (h : F A = 1) : (HasInsert.Insert A S).Prod (Î» (x : Î±), F x) = S.Prod (Î» (x : Î±), F x)
 : Function.Injective Fin
{R : Type u} [comm_Semigroup R] [Star_Semigroup R] (x y : R) : HasStar.Star (x * y) = HasStar.Star x * HasStar.Star y
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] {F : Î² â†’ Î±} {l : Filter Î²} {S : set Î²} {A : Î±} (h : âˆ€ (x : Î²), x âˆ‰ S â†’ F x = A) : Filter.Tendsto F (l âŠ“ Filter.principal S) (nhds A) â†” Filter.Tendsto F l (nhds A)
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] (S : set R) : Submodule.IsTorsionBy_set R m S = Submodule.IsTorsionBy_set R m â†‘(Ideal.Span S)
{v : Type u_1} [NormedGroup v] [Nontrivial v] : âˆ¥NormedGroup_hom.Id vâˆ¥ = 1
{R K : Type u} [CommRing R] [Field K] [Algebra R K] [_alg_IsClosed K] {Î¹ : Type u} (v : Î¹ â†’ K) [Nontrivial R] (hv : _transcendence_Basis R v) (hR : Cardinal.Mk R â‰¤ Cardinal.aleph0) (hK : Cardinal.aleph0 < Cardinal.Mk K) : Cardinal.Mk K = Cardinal.Mk Î¹
{m : Type u_1} [MulOneClass m] (C : Con m) : Con.Ker C.Mk' = C
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] [CovariantClass m m has_Add.Add has_LT.LT] [ContravariantClass m m has_Add.Add has_LT.LT] {A B : k} {C D : m} (hab : A < B) (hcd : C < D) : A â€¢ D + B â€¢ C < A â€¢ C + B â€¢ D
{Î± : Type u_1} [UniformSpace Î±] : (â¨† (x : Î±), nhds (x, x)) â‰¤ Uniformity Î±
{x : Type u_2} [EmetricSpace x] (m : set x â†’ Ennreal) : (MeasureTheory.OuterMeasure.Mk_metric' m)._metric
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {F : m â†’* N} (h : âˆ€ (y : â†¥S), IsUnit (â‡‘F â†‘y)) {xâ‚ xâ‚‚ : m} {yâ‚ yâ‚‚ : â†¥S} : â‡‘F xâ‚ * â†‘(â‡‘(IsUnit.Lift_Right (F.Restrict S) h) yâ‚)â»Â¹ = â‡‘F xâ‚‚ * â†‘(â‡‘(IsUnit.Lift_Right (F.Restrict S) h) yâ‚‚)â»Â¹ â†” â‡‘F (xâ‚ * â†‘yâ‚‚) = â‡‘F (xâ‚‚ * â†‘yâ‚)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {F : E â†’ F} (hF : ContDiff ð•œ n F) : ContDiff ð•œ n (Î» (x : E), -F x)
{A : Type u_1} {R : Type u_2} (K : Type u_3) [CommRing A] [IsDomain A] [normalized_Gcd_Monoid A] [Field K] [CommRing R] [IsDomain R] [Algebra A K] [_fraction_Ring A K] [Algebra K R] [Algebra A R] [IsScalarTower A K R] {x : R} (hx : IsIntegral A x) {P : Polynomial A} (hprim : P._primitive) (hroot : â‡‘(Polynomial.aeval x) P = 0) : minpoly A x âˆ£ P
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Finite_dimensional â„ â†¥(S.direction)] (hD : Finite_dimensional.finrank â„ â†¥(S.direction) = 2) {Câ‚ Câ‚‚ Pâ‚ Pâ‚‚ P : P} (hcâ‚S : Câ‚ âˆˆ S) (hcâ‚‚S : Câ‚‚ âˆˆ S) (hpâ‚S : Pâ‚ âˆˆ S) (hpâ‚‚S : Pâ‚‚ âˆˆ S) (hps : P âˆˆ S) {râ‚ râ‚‚ : â„} (hc : Câ‚ â‰  Câ‚‚) (hp : Pâ‚ â‰  Pâ‚‚) (hpâ‚Câ‚ : HasDist.dist Pâ‚ Câ‚ = râ‚) (hpâ‚‚Câ‚ : HasDist.dist Pâ‚‚ Câ‚ = râ‚) (hpcâ‚ : HasDist.dist P Câ‚ = râ‚) (hpâ‚Câ‚‚ : HasDist.dist Pâ‚ Câ‚‚ = râ‚‚) (hpâ‚‚Câ‚‚ : HasDist.dist Pâ‚‚ Câ‚‚ = râ‚‚) (hpcâ‚‚ : HasDist.dist P Câ‚‚ = râ‚‚) : P = Pâ‚ âˆ¨ P = Pâ‚‚
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {Î¹ : Type u_6} [DecidableEq Î¹] (F : AlternatingMap R m N Î¹) : F.Comp_Linear_Map LinearMap.Id = F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {S : set E} {g : F â†’ G} {F : E â†’ F} (hg : ContDiff ð•œ n g) (hF : ContDiff_on ð•œ n F S) : ContDiff_on ð•œ n (g âˆ˜ F) S
{n : â„•} (u v : Î£ (C : Composition n), Î  (i : Fin C.length), Composition (C.blocks_fun i)) : u = v â†” List.of_fn (Î» (i : Fin u.fst.length), (u.Snd i).blocks) = List.of_fn (Î» (i : Fin v.fst.length), (v.Snd i).blocks)
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ List.Nat.antidiagonal n â†” x.fst + x.Snd = n
{A B : â„} : IntervalIntegrable (Î» (x : â„), xâ»Â¹) MeasureTheory.MeasureSpace.Volume A B â†” A = B âˆ¨ 0 âˆ‰ set.Interval A B
(ð•œ : Type u_1) [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] (x : E) : ext_chart_at (model_with_corners_self ð•œ E) x = local_Equiv.refl E
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {F : â„ â†’ E} {g : â„ â†’ F} {A B : â„} (l : Filter â„) [l.Ne_IsBot] [Filter.Tendsto_Ixx_class set.icc l l] (hl : set.Interval A B âˆˆ l) (hD : âˆ€á¶  (x : â„) in l, Differentiable_at â„ F x) (hF : Filter.Tendsto (Î» (x : â„), âˆ¥F xâˆ¥) l Filter.at_top) (hfg : deriv F =O[l] g) : Â¬IntervalIntegrable g MeasureTheory.MeasureSpace.Volume A B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} [CompleteSpace E] (F : LocalHomeomorph E F) {Fâ‚€' : E â‰ƒL[ð•œ] F} {A : F} (ha : A âˆˆ F.to_local_Equiv.Target) (hFâ‚€' : HasFderivAt â‡‘F â†‘Fâ‚€' (â‡‘(F.Symm) A)) (hF : ContDiff_at ð•œ n â‡‘F (â‡‘(F.Symm) A)) : ContDiff_at ð•œ n â‡‘(F.Symm) A
(Î± : Type u_1) [has_Zero Î±] [has_One Î±] (n : â„•) : Matrix.circulant (Î» (i : Fin n), Ite (â†‘i = 0) 1 0) = 1
{m : Type u_1} {R : Type u_2} [Fintype m] [CommRing R] {m : Matrix m m R} (hM : m.nondegenerate) {v : m â†’ R} (hv : v â‰  0) : âˆƒ (W : m â†’ R), Matrix.dot_Product v (m.Mul_vec W) â‰  0
{R : Type u_4} [NormedRing R] [CompleteSpace R] (x : R) (h : âˆ¥xâˆ¥ < 1) : âˆ¥âˆ‘' (n : â„•), x ^ nâˆ¥ â‰¤ âˆ¥1âˆ¥ - 1 + (1 - âˆ¥xâˆ¥)â»Â¹
{Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [rÎ± : non_assoc_Semiring Î±] [rÎ² : non_assoc_Semiring Î²] {rÎ³ : non_assoc_Semiring Î³} {Î´ : Type u_1} {rÎ´ : non_assoc_Semiring Î´} (F : Î± â†’+* Î²) (g : Î² â†’+* Î³) (h : Î³ â†’+* Î´) : (h.Comp g).Comp F = h.Comp (g.Comp F)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Sâ‚ Sâ‚‚ : set P} (h : Sâ‚ âŠ† Sâ‚‚) : affine_Span k Sâ‚ â‰¤ affine_Span k Sâ‚‚
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsArtinian R m] (F : m â†’â‚—[R] m) (S : Function.Injective â‡‘F) : Function.Bijective â‡‘F
{m : Type u} [Monoid m] (A : m) : A ^ 2 = A * A
{Î± : Type u_1} {E : Type u_2} (R : Type u_3) [AddCommGroup E] [DivisionRing R] [Monoid Î±] [module R E] [Distrib_MulAction Î± E] (n : â„•) (S : Î±) (x : E) : (â†‘n)â»Â¹ â€¢ S â€¢ x = S â€¢ (â†‘n)â»Â¹ â€¢ x
{R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] {Î¹ : Type u_1} {F : Î¹ â†’ m} (hF : Function.Injective F) : LinearIndependent R Coe â†’ LinearIndependent R F
(k : Type u_1) {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype Î¹] (P : Î¹ â†’ P) {n : â„•} (hc : Fintype.Card Î¹ = n + 2) : AffineIndependent k P â†” Â¬Finite_dimensional.finrank k â†¥(Vector_Span k (set.Range P)) â‰¤ n
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [RegularSpace Y] {F : x â†’ Y} {A B : set x} (hB : B âŠ† Closure A) (hF : âˆ€ (x : x), x âˆˆ B â†’ (âˆƒ (y : Y), Filter.Tendsto F (nhds_within x A) (nhds y))) : Continuous_on (extend_from A F) B
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] {S : set m} {P : Î  (x : m), x âˆˆ Submodule.Span R S â†’ Prop} (Hs : âˆ€ (x : m) (h : x âˆˆ S), P x _) (h0 : P 0 _) (h1 : âˆ€ (x : m) (hx : x âˆˆ Submodule.Span R S) (y : m) (hy : y âˆˆ Submodule.Span R S), P x hx â†’ P y hy â†’ P (x + y) _) (h2 : âˆ€ (A : R) (x : m) (hx : x âˆˆ Submodule.Span R S), P x hx â†’ P (A â€¢ x) _) {x : m} (hx : x âˆˆ Submodule.Span R S) : P x hx
{ð•œ : Type u_1} {E : Type u_3} [NormedField ð•œ] [AddCommGroup E] [module ð•œ E] {A : set E} [TopologicalSpace E] [has_Continuous_Smul ð•œ E] (hA : A âˆˆ nhds 0) : Absorbent ð•œ A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {B : E Ã— F â†’ G} {n : WithTop â„•} (hb : IsBoundedBilinearMap ð•œ B) : ContDiff ð•œ n B
{m : Type u_1} [has_Add m] {C D : Add_Con m} (h : Setoid.r = Setoid.r) : C = D
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits_of_size C] : CategoryTheory.Limits.HasColimits_of_size C
(n : â„•) (x : â„) : HasDerivAt (Exp_Neg_Inv_glue.F_aux n) (Exp_Neg_Inv_glue.F_aux (n + 1) x) x
(R : Type u_1) {P n : â„•} [hp : Fact (Nat.Prime P)] [Ring R] [Char_P R P] (hn : Â¬P âˆ£ n) : Polynomial.cyclotomic (n * P) R = Polynomial.cyclotomic n R ^ (P - 1)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_at F A) : deriv (Î» (u : â„), âˆ« (x : â„) in u..B, F x) A = -F A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {x : E} {n : WithTop â„•} {F g : E â†’ F} (hF : ContDiff_at ð•œ n F x) (hg : ContDiff_at ð•œ n g x) : ContDiff_at ð•œ n (Î» (x : E), F x - g x) x
{A B : â„} (m n : â„•) : âˆ« (x : â„) in A..B, Real.sin x ^ (2 * m + 1) * Real.cos x ^ n = âˆ« (u : â„) in Real.cos B..Real.cos A, u ^ n * (1 - u ^ 2) ^ m
{Î¹ : Type u} {Î± : Type v} [Fintype Î¹] {t : Î¹ â†’ Finset Î±} [DecidableEq Î±] {n : â„•} (hn : Fintype.Card Î¹ = n + 1) (ht : âˆ€ (S : Finset Î¹), S.Card â‰¤ (S.bUnion t).Card) (ih : âˆ€ {Î¹' : Type u} [_inst_3 : Fintype Î¹'] (t' : Î¹' â†’ Finset Î±), Fintype.Card Î¹' â‰¤ n â†’ (âˆ€ (S' : Finset Î¹'), S'.Card â‰¤ (S'.bUnion t').Card) â†’ (âˆƒ (F : Î¹' â†’ Î±), Function.Injective F âˆ§ âˆ€ (x : Î¹'), F x âˆˆ t' x)) (S : Finset Î¹) (hs : S.Nonempty) (hns : S â‰  Finset.Univ) (hus : S.Card = (S.bUnion t).Card) : âˆƒ (F : Î¹ â†’ Î±), Function.Injective F âˆ§ âˆ€ (x : Î¹), F x âˆˆ t x
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A : Î±} : 0 â‰¤ -A â†’ A â‰¤ 0
{ð•œâ‚‚ : Type u_2} {ð•œâ‚ƒ : Type u_3} {F : Type u_6} {G : Type u_8} [NormedGroup F] [NormedGroup G] [nondiscrete_NormedField ð•œâ‚‚] [nondiscrete_NormedField ð•œâ‚ƒ] [NormedSpace ð•œâ‚‚ F] [NormedSpace ð•œâ‚ƒ G] {Ïƒâ‚‚â‚ƒ : ð•œâ‚‚ â†’+* ð•œâ‚ƒ} {ð•œâ‚‚' : Type u_10} [nondiscrete_NormedField ð•œâ‚‚'] {F' : Type u_11} [NormedGroup F'] [NormedSpace ð•œâ‚‚' F'] {Ïƒâ‚‚' : ð•œâ‚‚' â†’+* ð•œâ‚‚} {Ïƒâ‚‚'' : ð•œâ‚‚ â†’+* ð•œâ‚‚'} {Ïƒâ‚‚â‚ƒ' : ð•œâ‚‚' â†’+* ð•œâ‚ƒ} [RingHomInvPair Ïƒâ‚‚' Ïƒâ‚‚''] [RingHomInvPair Ïƒâ‚‚'' Ïƒâ‚‚'] [Ring_hom_Comp_triple Ïƒâ‚‚' Ïƒâ‚‚â‚ƒ Ïƒâ‚‚â‚ƒ'] [Ring_hom_Comp_triple Ïƒâ‚‚'' Ïƒâ‚‚â‚ƒ' Ïƒâ‚‚â‚ƒ] [Ring_hom_isometric Ïƒâ‚‚â‚ƒ] [Ring_hom_isometric Ïƒâ‚‚'] [Ring_hom_isometric Ïƒâ‚‚''] [Ring_hom_isometric Ïƒâ‚‚â‚ƒ'] (F : F â†’sl[Ïƒâ‚‚â‚ƒ] G) (g : F' â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚‚'] F) : âˆ¥F.Comp g.to_Linear_Isometry.to_Continuous_Linear_Mapâˆ¥ = âˆ¥Fâˆ¥
{n m : â„•} (h : n = m) (i : Fin n) : â†‘(â‡‘(Fin.cast h) i) = â†‘i
{Î¹ : Type u} {Î³ : Type W} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [Î  (i : Î¹), AddZeroClass (Î² i)] [AddCommMonoid Î³] (F : Î  (i : Î¹), Î² i â†’+ Î³) (i : Î¹) (x : Î² i) : â‡‘(â‡‘Dfinsupp.Lift_Add_hom F) (Dfinsupp.single i x) = â‡‘(F i) x
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} (h_Mono : StrictMono_on F S) (hs : S âˆˆ nhds_within A (set.ici A)) (hfs : set.surj_on F S (set.ioi (F A))) : Continuous_within_at F (set.ici A) A
{R : Type u} [Ring R] (S : Subring R) : 0 âˆˆ S
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y z : v} (hxyne : x â‰  y) (hxzne : x â‰  z) {r : â„} (hx : âˆ¥xâˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : hb.oangle y z = 2 â€¢ hb.oangle (y - x) (z - x)
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : â†‘âŠ¥ = âˆ…
{Î± : Type u_1} [comm_Semigroup Î±] {A B : Î±} (C : Î±) (h : C * A = B) : A âˆ£ B
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] (h : Function.Injective â‡‘(Algebra_Map A B)) {x : A} (h : IsIntegral R (â‡‘(Algebra_Map A B) x)) : IsIntegral R x
{m : Type u} [MulOneClass m] (x : m) : SemiconjBy 1 x x
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (h : Function.Injective â‡‘(Algebra_Map R A)) [CharZero R] : CharZero A
{Î± : Type u_1} {Î² : Type u_2} [AddCommMonoid Î±] [TopologicalSpace Î±] [t2_Space Î±] [CompleteLattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (R : Î± â†’ Î± â†’ Prop) (m_supr : âˆ€ (S : â„• â†’ Î²), R (m (â¨† (i : â„•), S i)) (âˆ‘' (i : â„•), m (S i))) (Sâ‚ Sâ‚‚ : Î²) : R (m (Sâ‚ âŠ” Sâ‚‚)) (m Sâ‚ + m Sâ‚‚)
{C : Type u} [CategoryTheory.Category C] {x Y x' : C} (h : x' âŸ¶ x) (F : x âŸ¶ Y) [CategoryTheory.Limits.HasImage F] [CategoryTheory.Limits.HasImage (h â‰« F)] : CategoryTheory.Limits.image_Subobject (h â‰« F) â‰¤ CategoryTheory.Limits.image_Subobject F
{Râ‚ Râ‚‚ : â„} {C z : â„‚} {F : â„‚ â†’ â„‚} (hD : DifferentiableOn â„‚ F (Metric.Ball C Râ‚)) (h_maps : set.maps_to F (Metric.Ball C Râ‚) (Metric.Ball (F C) Râ‚‚)) (hz : z âˆˆ Metric.Ball C Râ‚) : âˆ¥dslope F C zâˆ¥ â‰¤ Râ‚‚ / Râ‚
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Mul_Pos_Mono Î±] (ha : A â‰¤ 1) (hb : B < 1) (B0 : 0 < B) : A * B < 1
{R : Type u} [CommSemiring R] (P q : Polynomial R) : â‡‘Polynomial.derivative (Polynomial.Evalâ‚‚ Polynomial.C q P) = Polynomial.Evalâ‚‚ Polynomial.C q (â‡‘Polynomial.derivative P) * â‡‘Polynomial.derivative q
{R : Type u} [Ring R] {Î“â‚€ : Type v} [Linear_ordered_comm_Group_with_Zero Î“â‚€] (v : Valuation R Î“â‚€) : Ring_subgroups_Basis (Î» (Î³ : Î“â‚€Ë£), v.LT_Add_Subgroup Î³)
{x : Type u_1} [TopologicalSpace x] {x y : x} : Inseparable x y â†’ nhds x = nhds y
{R : Type u_1} [CommSemiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [Fintype n] [Fintype m] [DecidableEq n] {mâ‚ : Type u_5} {mâ‚‚ : Type u_6} [AddCommMonoid mâ‚] [AddCommMonoid mâ‚‚] [module R mâ‚] [module R mâ‚‚] (vâ‚ : Basis n R mâ‚) (vâ‚‚ : Basis m R mâ‚‚) {mâ‚ƒ : Type u_7} [AddCommMonoid mâ‚ƒ] [module R mâ‚ƒ] (vâ‚ƒ : Basis l R mâ‚ƒ) [Fintype l] [DecidableEq m] (A : Matrix l m R) (B : Matrix m n R) (x : mâ‚) : â‡‘(â‡‘(Matrix.to_lin vâ‚ vâ‚ƒ) (A.Mul B)) x = â‡‘(â‡‘(Matrix.to_lin vâ‚‚ vâ‚ƒ) A) (â‡‘(â‡‘(Matrix.to_lin vâ‚ vâ‚‚) B) x)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (Pâ‚ Pâ‚‚ : Î¹ â†’ P) : S.Sum (Î» (i : Î¹), W i â€¢ (Pâ‚ i -áµ¥ Pâ‚‚ i)) = â‡‘(S.weighted_vsub Pâ‚) W - â‡‘(S.weighted_vsub Pâ‚‚) W
(A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension {1} A B] : âŠ¥ = âŠ¤
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S : set Î±} (P : m â†’ Prop) (hpâ‚€ : P 1) (hpâ‚ : âˆ€ (x y : m), P x â†’ P y â†’ P (x * y)) (hpâ‚‚ : âˆ€ (x : Î±), x âˆˆ S â†’ P (F x)) : P (finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)))
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set â„} [IntervalIntegral.FTC_Filter A (nhds_within A S) (nhds_within A t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within A t) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_within_at F t A) (hs : UniqueDiffWithinAt â„ S A . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (Î» (u : â„), âˆ« (x : â„) in u..B, F x) S A = -F A
{Î± : Type u_1} [TopologicalSpace Î±] {x : Î±} {S : set Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] {F g : Î± â†’ Î³} (hF : LowerSemicontinuous_within_at F S x) (hg : LowerSemicontinuous_within_at g S x) (hcont : Continuous_at (Î» (P : Î³ Ã— Î³), P.fst + P.Snd) (F x, g x)) : LowerSemicontinuous_within_at (Î» (z : Î±), F z + g z) S x
(S : set Cardinal) : BddAbove S â†” Small â†¥S
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] (P q : module R m) (W : âˆ€ (r : R) (m : m), r â€¢ m = r â€¢ m) : P = q
{Î± : Type u} [PartialOrder Î±] [Decidable_Rel has_LE.LE] {A B : Î±} (hab : A â‰¤ B) : A = B âˆ¨ A < B
{A : Type u_2} [AddMonoid A] {x y : A} : y âˆˆ AddSubmonoid.Closure {x} â†” âˆƒ (n : â„•), n â€¢ x = y
{Î± : Type u} {A B : Î±} [Mul_Zero_class Î±] [Preorder Î±] [Zero_LT.Pos_Mul_StrictMono Î±] (ha : 0 < A) (hb : 0 < B) : 0 < A * B
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) : LinearIndependent ð•œ v
{Î± : Type u_1} {Î² : Type u_2} {Gâ‚€ : Type u_3} [Group_with_Zero Gâ‚€] [TopologicalSpace Gâ‚€] [has_Continuous_Invâ‚€ Gâ‚€] [has_Continuous_Mul Gâ‚€] [TopologicalSpace Î±] [TopologicalSpace Î²] {A : Î±} {F g : Î± â†’ Gâ‚€} (h : Î± â†’ Gâ‚€ â†’ Î²) (hF : Continuous_at F A) (hg : Continuous_at g A) (hH : g A â‰  0 â†’ Continuous_at â†¿h (A, F A / g A)) (h2h : g A = 0 â†’ Filter.Tendsto â†¿h ((nhds A).Prod âŠ¤) (nhds (h A 0))) : Continuous_at (Î» (x : Î±), h x (F x / g x)) A
{Î¹ : sort u_1} {Î± : Type u_2} {Î² : Type u_3} [CompleteLattice Î±] [CompleteLattice Î²] (F : Î± â‰ƒo Î²) {A : Î¹ â†’ Î±} (ha : CompleteLattice.Independent A) : CompleteLattice.Independent (â‡‘F âˆ˜ A)
{C : Type u} [CategoryTheory.Category C] {F : C â¥¤ C} {A : CategoryTheory.Endofunctor.Algebra F} (h : CategoryTheory.Limits.IsInitial A) : CategoryTheory.IsIso A.str
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] [Algebra R S] {Î¹ : Type W} [Fintype Î¹] (B : Basis Î¹ R S) (x : R) : â‡‘(Algebra.trace R S) (â‡‘(Algebra_Map R S) x) = Fintype.Card Î¹ â€¢ x
{R : Type u_1} {m : Type u_2} [CommMonoid m] [CommSemiring R] {S : set m} (hS : Submonoid.Closure S = âŠ¤) : Function.Surjective â‡‘(mv_Polynomial.aeval (Î» (S : â†¥S), â‡‘(Monoid_Algebra.of R m) â†‘S))
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [Finite_dimensional ð•œ E] [Finite_dimensional ð•œ F] (A : E â†’â‚—[ð•œ] F) (x : E) (y : F) : HasInner.inner (â‡‘(â‡‘LinearMap.Adjoint A) y) x = HasInner.inner y (â‡‘A x)
{Gâ‚ : Type u_2} {Gâ‚‚ : Type u_3} [Group Gâ‚] [Group Gâ‚‚] [Group.IsNilpotent Gâ‚] [Group.IsNilpotent Gâ‚‚] : Group.nilpotency_class (Gâ‚ Ã— Gâ‚‚) = LinearOrder.max (Group.nilpotency_class Gâ‚) (Group.nilpotency_class Gâ‚‚)
{Î¹ : Type u} (S : Finset Î¹) (F g : Î¹ â†’ Ennreal) {P : â„} (hp : 1 â‰¤ P) : S.Sum (Î» (i : Î¹), (F i + g i) ^ P) ^ (1 / P) â‰¤ S.Sum (Î» (i : Î¹), F i ^ P) ^ (1 / P) + S.Sum (Î» (i : Î¹), g i ^ P) ^ (1 / P)
{Î± : Type u} [PseudoMetricSpace Î±] (x y : Î±) : HasDist.dist x y = â†‘(HasNndist.nndist x y)
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] : {x : Î± | âˆƒ (y : Î±), x < y âˆ§ set.Ioo x y = âˆ…}.countable
{R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] {m : â„•} (x : m) (v : Fin m â†’ m) (hli : LinearIndependent R v) (x_IsOrtho : âˆ€ (C : R) (y : â†¥(Submodule.Span R (set.Range v))), C â€¢ x + â†‘y = 0 â†’ C = 0) : LinearIndependent R (Fin.Cons x v)
{m : Type u_1} [AddZeroClass m] {S : set m} : S âŠ† â†‘(AddSubmonoid.Closure S)
{Î± : Type u} [Monoid Î±] (F : â„• â†’ Î±) (n : â„•) : (List.Map F (List.Range n.Succ)).Prod = F 0 * (List.Map (Î» (i : â„•), F i.Succ) (List.Range n)).Prod
(ð•œ : Type u_1) [nondiscrete_NormedField ð•œ] (ð•œ' : Type u_2) [NormedRing ð•œ'] [normed_Algebra ð•œ ð•œ'] : IsBoundedBilinearMap ð•œ (Î» (P : ð•œ' Ã— ð•œ'), â‡‘(â‡‘(Continuous_Linear_Map.lmul_Left_Right ð•œ ð•œ') P.fst) P.Snd)
{E : Type u_2} {ð•œ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] {S : set E} (hs : Convex ð•œ S) {A B : ð•œ} (ha : 0 < A) (hb : 0 â‰¤ B) (hab : A + B = 1) : A â€¢ Interior S + B â€¢ Closure S âŠ† Interior S
{S : â„‚} (hs : 0 < S.re) : (S + 1).gamma_integral = S * S.gamma_integral
{Î± : Type u} [OrderedSemiring Î±] [Nontrivial Î±] : 0 < 2
{Î± : Type u} {l : List Î±} : l.Nodup â†’ l.attach.Nodup
{x Y Z : Type u} (F : x âŸ¶ Y) {g h : Y âŸ¶ Z} (W : F â‰« g = F â‰« h) (t : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofÎ¹ F W)) (y : Y) (hy : g y = h y) : âˆƒ! (x : x), F x = y
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {n : â„•} : iterated_fderiv ð•œ (n + 1) F = â‡‘(Continuous_multilinear_Curry_Left_Equiv ð•œ (Î» (i : Fin (n + 1)), E) F) âˆ˜ fderiv ð•œ (iterated_fderiv ð•œ n F)
{Î± : Type u_1} {Î¹ : Type u_4} [TopologicalSpace Î±] [Encodable Î¹] {S : Î¹ â†’ set Î±} (hs : âˆ€ (i : Î¹), _GÎ´ (S i)) : _GÎ´ (â‹‚ (i : Î¹), S i)
(m : Type u_1) (R : Type u_3) [DecidableEq m] [Fintype m] [CommRing R] [Nontrivial R] : (Matrix.mv_Polynomial.x m m R).det â‰  0
{Î± : Type u_1} [DecidableEq Î±] (S : Finset Î±) : (Finset.image Quotient.Mk S.off_diag).Card = S.Card.choose 2
{C : Type u} [CategoryTheory.Category C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ C) [CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.Functor F.obj)] [CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.Functor (Î» (F : Î£ (P : J Ã— J), P.fst âŸ¶ P.Snd), F.obj F.fst.fst))] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasColimit F
{ð•œ : Type u_1} {E : Type u_2} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] {P : FormalMultilinearSeries ð•œ ð•œ E} {x : ð•œ} (h : HasFpowerSeriesAt 0 P x) : P = 0
{m : Type u_1} [Monoid m] {Sâ‚ Sâ‚‚ : set m} (â‚ : _Submonoid Sâ‚) (â‚‚ : _Submonoid Sâ‚‚) : _Submonoid (Sâ‚ âˆ© Sâ‚‚)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : â‡‘(Polynomial.aeval x) (minpoly A x) = 0
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hst : S âŠ† t) (ht : t.Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ t  S), F i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ t), F i))
{mâ‚€ : Type u_1} [CancelMonoidWithZero mâ‚€] {A B : mâ‚€} (hâ‚ : B â‰  1) (hâ‚‚ : B * A = A) : A = 0
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A : Î±} : Aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ A
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] : Finite_dimensional.finrank K v = 0 â†” Subsingleton v
{R : Type u_1} {m : Type u_2} [CommMonoid m] [CommRing R] [Nontrivial R] [h : Algebra.Finite_Type R (Monoid_Algebra R m)] : Monoid.fg m
{m : Type u_1} {N : Type u_2} [has_Mul m] [has_Mul N] {C : Con m} {D : Con N} {C : C.Quotient â†’ D.Quotient â†’ Prop} (P : C.Quotient) (q : D.Quotient) (h : âˆ€ (x : m) (y : N), C â†‘x â†‘y) : C P q
{Î± : Type u_1} [PseudoMetricSpace Î±] {x : Î±} {E : set Î±} (hx : x âˆˆ E) (Î´ : â„) : metric.IsClosed_ball x Î´ âŠ† Metric.Cthickening Î´ E
{v : Type uâ‚} [Quiver v] {C : Type u_1} [CategoryTheory.Category C] {F G : CategoryTheory.Paths v â¥¤ C} (h_obj : F.obj = G.obj) (h : âˆ€ (A B : v) (e : A âŸ¶ B), F.Map e.to_Path = CategoryTheory.Eq_to_hom _ â‰« G.Map e.to_Path â‰« CategoryTheory.Eq_to_hom _) : F = G
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [NormedGroup F] [NormedSpace â„ F] {S : set E} (S_conv : Convex â„ S) {F : E â†’ F} {F' : E â†’ (E â†’L[â„] F)} {F'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€ (x : E), x âˆˆ Interior S â†’ HasFderivAt F (F' x) x) {x : E} (xs : x âˆˆ S) (hx : HasFderivWithinAt F' F'' (Interior S) x) {v W : E} (h4v : x + 4 â€¢ v âˆˆ Interior S) (h4W : x + 4 â€¢ W âˆˆ Interior S) : (Î» (h : â„), F (x + h â€¢ (2 â€¢ v + 2 â€¢ W)) + F (x + h â€¢ (v + W)) - F (x + h â€¢ (2 â€¢ v + W)) - F (x + h â€¢ (v + 2 â€¢ W)) - h ^ 2 â€¢ â‡‘(â‡‘F'' v) W) =o[nhds_within 0 (set.ioi 0)] Î» (h : â„), h ^ 2
{ð•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [NormedGroup E] [NormedGroup Fâ‚—] [nondiscrete_NormedField ð•œ] [NormedSpace ð•œ E] [NormedSpace ð•œ Fâ‚—] (C : E â†’L[ð•œ] ð•œ) (F : Fâ‚—) : âˆ¥C.Smul_Right Fâˆ¥â‚Š = âˆ¥Câˆ¥â‚Š * âˆ¥Fâˆ¥â‚Š
{Î± : Type u_6} {Î² : Type u_7} [has_Mul Î²] [HasScalar Î± Î²] [IsScalarTower Î± Î² Î²] (r : Î±) (x y : Î²) : r â€¢ x * y = r â€¢ (x * y)
{C : Type uâ‚} [CategoryTheory.Category C] {x Y Z : C} {F : x âŸ¶ Z} {g : Y âŸ¶ Z} {C : CategoryTheory.Limits.PullbackCone F g} (h : CategoryTheory.Limits.IsLimit C) : CategoryTheory.IsPullback C.fst C.Snd F g
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [AddCommMonoid m] {S : set Î±} {t : set Î²} (F : Î± â†’ Î² â†’ m) (hs : S.Finite) (ht : t.Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), finsum (Î» (j : Î²), finsum (Î» (h : j âˆˆ t), F i j)))) = finsum (Î» (j : Î²), finsum (Î» (h : j âˆˆ t), finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i j))))
{E : Type u_1} {F : Type u_2} {ð•œ : Type u_3} {ð•œâ‚‚ : Type u_4} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [Ring_hom_isometric Ïƒâ‚â‚‚] {Î¹ : Type u_5} [CompleteSpace E] {g : Î¹ â†’ (E â†’sl[Ïƒâ‚â‚‚] F)} (h : âˆ€ (x : E), âˆƒ (C : â„), âˆ€ (i : Î¹), âˆ¥â‡‘(g i) xâˆ¥ â‰¤ C) : âˆƒ (C' : â„), âˆ€ (i : Î¹), âˆ¥g iâˆ¥ â‰¤ C'
{B : Type u} [Quiver B] {A B C : B} (P : Quiver.Path A B) {F g : CategoryTheory.FreeBicategory.Hom B C} (Î· : F âŸ¶ g) : CategoryTheory.Bicategory.whisker_Left ((CategoryTheory.FreeBicategory.preinclusion B).Map {as := P}) Î· â‰« (CategoryTheory.FreeBicategory.normalize_iso P g).hom = (CategoryTheory.FreeBicategory.normalize_iso P F).hom â‰« (CategoryTheory.FreeBicategory.preinclusion B).Mapâ‚‚ (CategoryTheory.Eq_to_hom _)
{R : Type u} [CommRing R] (U v : TopologicalSpace.Opens â†¥(AlgebraicGeometry.Prime_Spectrum.top R)) (hUV : U = v) : AlgebraicGeometry.StructureSheaf.comap (Ring_hom.Id R) U v _ = CategoryTheory.Eq_to_hom _
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (S : Submodule K v) : S.fg â†” Finite_dimensional K â†¥S
{Î± : Type u_1} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {S : Finset Î±} : S âˆˆ ð’œ.shadow â†” âˆƒ (t : Finset Î±) (h : t âˆˆ ð’œ) (A : Î±) (h : A âˆˆ t), t.erase A = S
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x : Î±} (h : x âˆˆ S) : metric.Inf_dist x S = 0
{C : Type u} [CategoryTheory.Category C] {F : C â¥¤ C} {Aâ‚€ Aâ‚ : CategoryTheory.Endofunctor.Algebra F} (F : Aâ‚€ âŸ¶ Aâ‚) [CategoryTheory.IsIso F.F] : CategoryTheory.IsIso F
{G : Type u_1} [Group G] {k : set G} {P : G â†’ G â†’ Prop} {x y : G} (hx : x âˆˆ Subgroup.Closure k) (hy : y âˆˆ Subgroup.Closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ âˆ€ (y : G), y âˆˆ k â†’ P x y) (h1_Left : âˆ€ (x : G), P 1 x) (h1_Right : âˆ€ (x : G), P x 1) (HMul_Left : âˆ€ (xâ‚ xâ‚‚ y : G), P xâ‚ y â†’ P xâ‚‚ y â†’ P (xâ‚ * xâ‚‚) y) (HMul_Right : âˆ€ (x yâ‚ yâ‚‚ : G), P x yâ‚ â†’ P x yâ‚‚ â†’ P x (yâ‚ * yâ‚‚)) (Hinv_Left : âˆ€ (x y : G), P x y â†’ P xâ»Â¹ y) (Hinv_Right : âˆ€ (x y : G), P x y â†’ P x yâ»Â¹) : P x y
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_GlueData.J) (U : TopologicalSpace.Opens â†¥((CategoryTheory.Limits.pullback (D.to_GlueData.F i j) (D.to_GlueData.F i k)).carrier)) : âˆƒ (Eq_1 : (TopologicalSpace.Opens.Map (D.to_GlueData.t k i).Base).Op.obj (Opposite.Op (_.IsOpen_Functor.obj U)) = Opposite.Op (_.IsOpen_Functor.obj (Opposite.Unop ((TopologicalSpace.Opens.Map (D.to_GlueData.t' k i j).Base).Op.obj (Opposite.Op U))))), _.Inv_App U â‰« (D.to_GlueData.t k i).C.App (Opposite.Op (_.IsOpen_Functor.obj U)) â‰« (D.to_GlueData.v (k, i)).presheaf.Map (CategoryTheory.Eq_to_hom Eq_1) = (D.to_GlueData.t' k i j).C.App (Opposite.Op U) â‰« _.Inv_App (Opposite.Unop ((TopologicalSpace.Opens.Map (D.to_GlueData.t' k i j).Base).Op.obj (Opposite.Op U)))
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [RegularSpace Y] {F : x â†’ Y} {A : set x} (hA : Dense A) (hF : âˆ€ (x : x), âˆƒ (y : Y), Filter.Tendsto F (nhds_within x A) (nhds y)) : Continuous (extend_from A F)
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_GlueData.J) (U : TopologicalSpace.Opens â†¥((CategoryTheory.Limits.pullback (D.to_GlueData.F i j) (D.to_GlueData.F i k)).carrier)) : _.Inv_App U â‰« (D.to_GlueData.t k i).C.App (Opposite.Op (_.IsOpen_Functor.obj U)) = (D.to_GlueData.t' k i j).C.App (Opposite.Op U) â‰« _.Inv_App (Opposite.Unop ((TopologicalSpace.Opens.Map (D.to_GlueData.t' k i j).Base).Op.obj (Opposite.Op U))) â‰« (D.to_GlueData.v (k, i)).presheaf.Map (CategoryTheory.Eq_to_hom _)
{C : Type uâ‚} [CategoryTheory.Category C] {x : C} (P : Cáµ’áµ– â¥¤ Type W) {S : CategoryTheory.Sieve x} {R : CategoryTheory.Presieve x} (h : â‡‘S â‰¤ R) (hS : CategoryTheory.Presieve.IsSheafFor P â‡‘S) (Trans : âˆ€ â¦ƒY : Câ¦„ â¦ƒF : Y âŸ¶ xâ¦„, R F â†’ CategoryTheory.Presieve.IsSeparated_for P â‡‘(CategoryTheory.Sieve.pullback F S)) : CategoryTheory.Presieve.IsSheafFor P R
{R : Type u_1} {A B : R} [Add_Semigroup R] (Ab : IsAddRegular (A + B)) (ba : IsAddRegular (B + A)) : IsAddRegular A âˆ§ IsAddRegular B
(S : set â„•+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] : IsCyclotomicExtension S A B â†” (âˆ€ (A : â„•+), A âˆˆ S â†’ (âˆƒ (r : B), â‡‘(Polynomial.aeval r) (Polynomial.cyclotomic â†‘A A) = 0)) âˆ§ Algebra.Adjoin A {B : B | âˆƒ (A : â„•+), A âˆˆ S âˆ§ B ^ â†‘A = 1} = âŠ¤
{x : Type u_1} {Y : Type u_2} [PseudoEmetricSpace x] [PseudoEmetricSpace Y] {C r : Nnreal} {F : x â†’ Y} {S : set x} (hF : HolderOnWith C r F S) (h0 : 0 < r) : uniform_Continuous_on F S
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} : -A < -B â†’ B < A
{Î± : Type u_1} : WellFounded has_LT.LT
{m : Type u_1} [has_Add m] (C : Add_Con m) {x y z : m} : â‡‘C x y â†’ â‡‘C y z â†’ â‡‘C x z
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} {S : Finset Î¹} (hv : Orthonormal ð•œ v) : S.Sum (Î» (i : Î¹), âˆ¥HasInner.inner (v i) xâˆ¥ ^ 2) â‰¤ âˆ¥xâˆ¥ ^ 2
{R : Type u} [CommSemiring R] (r : R) : â‡‘Polynomial.C r = â‡‘(Algebra_Map R (Polynomial R)) r
{Î± : Type u_2} {Î² : Type u_3} [Linear_ordered_Field Î±] [Linear_ordered_Field Î²] [Archimedean Î²] : Subsingleton (Î± â†’+*o Î²)
{x n : â„•} (h : x.IsCoprime n) : x ^ n.Totient â‰¡ 1 [Mod n]
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] {F : â„ â†’ E} {t : â„} (hF : Function.Periodic F t) (t S : â„) : âˆ« (x : â„) in t..t + t, F x = âˆ« (x : â„) in S..S + t, F x
{Î± : Type u} [Preorder Î±] {S : set Î±} : Â¬BddBelow S â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (h : y âˆˆ S), Â¬x â‰¤ y
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (A B C P : P) (h : EuclideanGeometry.angle B P C = Real.Pi) : HasDist.dist A B ^ 2 * HasDist.dist C P + HasDist.dist A C ^ 2 * HasDist.dist B P = HasDist.dist B C * (HasDist.dist A P ^ 2 + HasDist.dist B P * HasDist.dist C P)
{Î± : Type u_1} {Î² : Type u_2} [CompleteLattice Î±] {F : Filter Î²} : F.limsup (Î» (x : Î²), âŠ¥) = âŠ¥
{m : Type u_1} [has_Mul m] {C : Con m} (x y : m) : â†‘(x * y) = â†‘x * â†‘y
{Î± : Type u} {Î² : Type v} [CommSemiring Î²] (F g : Î± â†’ Î²) (S : Finset Î±) : S.Prod (Î» (A : Î±), F A + g A) = S.powerset.Sum (Î» (t : Finset Î±), t.Prod (Î» (A : Î±), F A) * (S  t).Prod (Î» (A : Î±), g A))
{n : â„•} (h_Odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0
{n : â„•} {x : Fin (n + 1)} : Function.Injective â‡‘(x.Succ_above)
{L : FirstOrder.Language} {t : L.Theory} : t._satisfiable â†” t._finitely_satisfiable
{E : Type u} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] {n : â„•} (A B : Fin (n + 1) â†’ â„) (hle : A â‰¤ B) (F : Fin (n + 1) â†’ (Fin (n + 1) â†’ â„) â†’ E) (F' : Fin (n + 1) â†’ (Fin (n + 1) â†’ â„) â†’ ((Fin (n + 1) â†’ â„) â†’L[â„] E)) (S : set (Fin (n + 1) â†’ â„)) (hs : S.countable) (Hc : âˆ€ (i : Fin (n + 1)), Continuous_on (F i) (set.icc A B)) (hD : âˆ€ (x : Fin (n + 1) â†’ â„), x âˆˆ set.Univ.Pi (Î» (i : Fin (n + 1)), set.Ioo (A i) (B i))  S â†’ âˆ€ (i : Fin (n + 1)), HasFderivAt (F i) (F' i x) x) (Hi : MeasureTheory.IntegrableOn (Î» (x : Fin (n + 1) â†’ â„), Finset.Univ.Sum (Î» (i : Fin (n + 1)), â‡‘(F' i x) (Pi.single i 1))) (set.icc A B) MeasureTheory.MeasureSpace.Volume) : âˆ« (x : Fin (n + 1) â†’ â„) in set.icc A B, Finset.Univ.Sum (Î» (i : Fin (n + 1)), â‡‘(F' i x) (Pi.single i 1)) = Finset.Univ.Sum (Î» (i : Fin (n + 1)), (âˆ« (x : Fin n â†’ â„) in set.icc (A âˆ˜ â‡‘(i.Succ_above)) (B âˆ˜ â‡‘(i.Succ_above)), F i (i.Insert_nth (B i) x)) - âˆ« (x : Fin n â†’ â„) in set.icc (A âˆ˜ â‡‘(i.Succ_above)) (B âˆ˜ â‡‘(i.Succ_above)), F i (i.Insert_nth (A i) x))
{v : Type u} {K : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] [hK : Invertible 2] {B : BilinForm K v} (hBâ‚‚ : B.IsSymm) : âˆƒ (v : Basis (Fin (Finite_dimensional.finrank K v)) K v), B._Ortho â‡‘v
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : EuclideanGeometry.angle P1 P2 P3 â‰¤ Real.Pi
{Î± : Type u_1} [Preorder Î±] [Add_comm_Semigroup Î±] [HasSub Î±] [HasOrderedSub Î±] {A B C : Î±} [CovariantClass Î± Î± has_Add.Add has_LE.LE] : A + B - C â‰¤ A + (B - C)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (hx : x â‰  0) (hy : y â‰  0) : hb.oangle (-x) y = hb.oangle x y + â†‘Real.Pi
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} : B < A â†’ 0 < A - B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {S : set E} {t : set F} {g : F â†’ G} {F : E â†’ F} (hg : ContDiff_on ð•œ n g t) (hF : ContDiff_on ð•œ n F S) : ContDiff_on ð•œ n (g âˆ˜ F) (S âˆ© F â»Â¹' t)
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x : Î±} : 0 â‰¤ metric.Inf_dist x S
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z â†’ B} [TopologicalSpace Z] [conditionally_complete_LinearOrder B] [OrderTopology B] (h : IsTopologicalFiberBundle F Proj) (A B : B) : âˆƒ (e : TopologicalFiberBundle.Trivialization F Proj), set.icc A B âŠ† e.Base_set
{m : Type u_1} [cancel_CommMonoid_with_Zero m] {q : Associates m} {n : â„•} (hn : n â‰  0) {C : Fin (n + 1) â†’ Associates m} (hâ‚ : StrictMono C) (hâ‚‚ : âˆ€ {r : Associates m}, r â‰¤ q â†” âˆƒ (i : Fin (n + 1)), r = C i) (hq : q â‰  0) : Irreducible (C 1)
{Î± : Type u_1} {Î² : Type u_2} [has_Mul Î±] [Preorder Î±] [Preorder Î²] {F g : Î² â†’ Î±} [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] (hF : StrictMono F) (hg : Monotone g) : StrictMono (Î» (x : Î²), F x * g x)
(Î± : Type u_1) [TopologicalSpace Î±] [PolishSpace Î±] [Nonempty Î±] : âˆƒ (F : (â„• â†’ â„•) â†’ Î±), Continuous F âˆ§ Function.Surjective F
{R : Type u} [Semiring R] {P q : Polynomial R} : P * q = P.Support.Sum (Î» (i : â„•), q.Sum (Î» (j : â„•) (A : R), â‡‘(Polynomial.monomial (i + j)) (P.Coeff i * A)))
{R : Type u_1} [CommSemiring R] {m : Type u_4} {N : Type u_5} {P : Type u_6} [AddCommMonoid m] [AddCommMonoid N] [AddCommMonoid P] [module R m] [module R N] [module R P] {g h : TensorProduct R m N â†’â‚—[R] P} (h : (TensorProduct.Mk R m N).comprâ‚‚ g = (TensorProduct.Mk R m N).comprâ‚‚ h) : g = h
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S u : set E} {F : E â†’ F} {x : E} {n : â„•} (hu : IsOpen u) (hs : UniqueDiffOn ð•œ (S âˆ© u)) (hx : x âˆˆ S âˆ© u) : iterated_fderiv_within ð•œ n F (S âˆ© u) x = iterated_fderiv_within ð•œ n F S x
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {K : Nnreal} {S : set Î±} {F : Î± â†’ Î²} : (âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ HasDist.dist (F x) (F y) â‰¤ â†‘K * HasDist.dist x y) â†’ LipschitzOnWith K F S
 : Â¬_Field â„¤
{Î¹ : Type u_1} {m : Type u_4} {N : Type u_5} [CommMonoid m] [ordered_CommMonoid N] (F : m â†’ N) (P : m â†’ Prop) (h_One : F 1 = 1) (h_Mul : âˆ€ (x y : m), P x â†’ P y â†’ F (x * y) â‰¤ F x * F y) (hp_Mul : âˆ€ (x y : m), P x â†’ P y â†’ P (x * y)) (g : Î¹ â†’ m) {S : Finset Î¹} (hs : âˆ€ (i : Î¹), i âˆˆ S â†’ P (g i)) : F (S.Prod (Î» (i : Î¹), g i)) â‰¤ S.Prod (Î» (i : Î¹), F (g i))
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} (h : IsLocalMax F A) : fderiv â„ F A = 0
{Î± : Type u_1} [Preorder Î±] [BoundedOrder Î±] [IsSimpleOrder Î±] {A B : Î±} (h : A < B) : A = âŠ¥
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} {x1 : Î±} {B1 : Bool} {x2 : Î±} {B2 : Bool} (h1 : (x1, B1) â‰  (x2, B2)) (h2 : free_Group.red ((x1, B1) :: Lâ‚) ((x2, B2) :: Lâ‚‚)) : free_Group.red Lâ‚ ((x1, !B1) :: (x2, B2) :: Lâ‚‚)
{Î± : Type u_1} {Î¹ : sort u_4} {l : Filter Î±} {P : Î¹ â†’ Prop} {S : Î¹ â†’ set Î±} (h : l.has_Basis P S) {q : Î¹ â†’ Prop} (hq : âˆ€ (i : Î¹), P i â†’ (âˆƒ (j : Î¹), P j âˆ§ q j âˆ§ S j âŠ† S i)) : l.has_Basis (Î» (i : Î¹), P i âˆ§ q i) S
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cáµ’áµ– â¥¤ A) [CategoryTheory.Limits.HasPullbacks C] (S : A â¥¤ Type (max vâ‚ uâ‚)) [CategoryTheory.Limits.HasLimits A] [CategoryTheory.Limits.PreservesLimits S] [CategoryTheory.ReflectsIsomorphisms S] : CategoryTheory.Presheaf.IsSheaf J P â†” CategoryTheory.Presheaf.IsSheaf J (P â‹™ S)
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [SuccOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Antitone F) : Pairwise (Disjoint on Î» (n : Î±), set.Ico (F (Order.Succ n)) (F n))
{C : Type uâ‚} [CategoryTheory.Category C] {A t : C} (hT : CategoryTheory.Limits.IsTerminal t) [CategoryTheory.Mono (hT.from A)] : CategoryTheory.IsSubterminal A
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] : module.rank K v â‰¤ 1 â†” âˆƒ (vâ‚€ : v), âˆ€ (v : v), âˆƒ (r : K), r â€¢ vâ‚€ = v
{Î¹ : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : Î¹ â†’ E} {g : Î¹ â†’ â„} {A : â„} (hg : has_Sum g A) (h : âˆ€ (i : Î¹), âˆ¥F iâˆ¥ â‰¤ g i) : âˆ¥âˆ‘' (i : Î¹), F iâˆ¥ â‰¤ A
{Î± : Type u} [TopologicalSpace Î±] [LocallyCompactSpace Î±] (x : Î±) : âˆƒ (K : set Î±), IsCompact K âˆ§ K âˆˆ nhds x
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedSpace ð•œ E] [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ G} {S : set E} {C : Nnreal} (hF : âˆ€ (x : E), x âˆˆ S â†’ Differentiable_at ð•œ F x) (bound : âˆ€ (x : E), x âˆˆ S â†’ âˆ¥fderiv ð•œ F xâˆ¥â‚Š â‰¤ C) (hs : Convex â„ S) : LipschitzOnWith C F S
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {x : E} {n : WithTop â„•} {F g : E â†’ F} (hF : ContDiff_at ð•œ n F x) (hg : ContDiff_at ð•œ n g x) : ContDiff_at ð•œ n (Î» (x : E), F x + g x) x
{F : â„ â†’ â„} {A B l : â„} (hab : A < B) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds l)) (hfb : Filter.Tendsto F (nhds_within B (set.Iio B)) (nhds l)) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), deriv F C = 0
(k : Type u_1) [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) [CharZero k] [Fintype Î¹] (h : S.Card â‰  0) : Finset.Univ.Sum (Î» (i : Î¹), Finset.centroid_weights_indicator k S i) = 1
{x : Type u} [Lattice x] [jordan_holder_Lattice x] {Sâ‚ Sâ‚‚ : Composition_series x} (h : âˆ€ (x : x), x âˆˆ Sâ‚ â†” x âˆˆ Sâ‚‚) : Sâ‚ = Sâ‚‚
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) {S : set Î¹} {i : Î¹} (hi : i âˆ‰ S) {l : Î¹ â†’â‚€ ð•œ} (hl : l âˆˆ Finsupp.supported ð•œ ð•œ S) : HasInner.inner (â‡‘(Finsupp.Total Î¹ E ð•œ v) l) (v i) = 0
{m : Type u_3} [Monoid m] (l : List m) : (l.nth 0).get_or_else 1 * l.tail.Prod = l.Prod
{Î± : Type u} {Î² : Type v} [EmetricSpace Î±] [PseudoEmetricSpace Î²] {F : Î± â†’ Î²} (hF : Isometry F) : uniform_Embedding F
{K : Type u} [hfield : Field K] {L : Type u_1} [Field L] (F : K â†’+* L) (A : L) {x y : Ratfunc K} (hx : Polynomial.Evalâ‚‚ F A x.denom â‰  0) (hy : Polynomial.Evalâ‚‚ F A y.denom â‰  0) : Ratfunc.Eval F A (x * y) = Ratfunc.Eval F A x * Ratfunc.Eval F A y
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : 1 < A) (hb : 1 â‰¤ B) : 1 < A * B
{C : Type u_1} [CategoryTheory.Category C] (P : CategoryTheory.Idempotents.Karoubi C) : ðŸ™ P = P.decomp_Id_i â‰« P.decomp_Id_P
{n : â„•} {Î± : Type u_1} {v : Vector Î± (n + 1)} : v.Last = v.nth (Fin.Last n)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] [TopologicalSpace Î´] {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î³ â†’ Î´} (deâ‚ : Dense_Inducing eâ‚) (deâ‚‚ : Dense_Inducing eâ‚‚) : Dense_Inducing (Î» (P : Î± Ã— Î³), (eâ‚ P.fst, eâ‚‚ P.Snd))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] : IsBoundedBilinearMap ð•œ (Î» (P : (E â†’L[ð•œ] ð•œ) Ã— F), P.fst.Smul_Right P.Snd)
{x : Type v} [TopologicalSpace x] [LocallyCompactSpace x] [SigmaCompactSpace x] [t2_Space x] {Î¹ : x â†’ Type u} {P : Î  (x : x), Î¹ x â†’ Prop} {B : Î  (x : x), Î¹ x â†’ set x} {S : set x} (hs : IsClosed S) (hB : âˆ€ (x : x), x âˆˆ S â†’ (nhds x).has_Basis (P x) (B x)) : âˆƒ (Î± : Type v) (C : Î± â†’ x) (r : Î  (A : Î±), Î¹ (C A)), (âˆ€ (A : Î±), C A âˆˆ S âˆ§ P (C A) (r A)) âˆ§ (S âŠ† â‹ƒ (A : Î±), B (C A) (r A)) âˆ§ locally_Finite (Î» (A : Î±), B (C A) (r A))
{Î± : Type u_1} {Î² : Type u_2} [Infinite Î²] (F : Î± â†’ Finset Î²) (W : (â‹ƒ (A : Î±), â†‘(F A)) = âŠ¤) : Cardinal.Mk Î² â‰¤ Cardinal.Mk â†¥(set.Range F)
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [Finite_dimensional ð•œ E] [Finite_dimensional ð•œ F] (A : E â†’â‚—[ð•œ] F) : â‡‘LinearMap.Adjoint (â‡‘LinearMap.Adjoint A) = A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {S : set E} : Mdifferentiable_on (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F S â†” DifferentiableOn ð•œ F S
(n A B : â„•) : n < A âˆ¨ B â‰¤ n âˆ¨ n âˆˆ List.Ico A B
{Î± : Type u_1} {m m' : PseudoMetricSpace Î±} (h : PseudoMetricSpace.to_HasDist = PseudoMetricSpace.to_HasDist) : m = m'
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : E â†’ F Ã— G} {x : E} (hF : ContDiff_at ð•œ n F x) : ContDiff_at ð•œ n (Î» (x : E), (F x).Snd) x
{F : â„• â†’ â„} (h_nonneg : âˆ€ (n : â„•), 0 â‰¤ F n) (h_Mono : âˆ€ â¦ƒm n : â„•â¦„, 0 < m â†’ m â‰¤ n â†’ F n â‰¤ F m) : Summable (Î» (k : â„•), 2 ^ k * F (2 ^ k)) â†” Summable F
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 P4 P5 : P} (hapc : EuclideanGeometry.angle P1 P5 P3 = Real.Pi) (hbpd : EuclideanGeometry.angle P2 P5 P4 = Real.Pi) : EuclideanGeometry.angle P1 P5 P2 = EuclideanGeometry.angle P3 P5 P4
{E : Type u_2} [AddCommGroup E] [module â„ E] (S : Convex_cone â„ E) (F : LinearPmap â„ E â„) (nonneg : âˆ€ (x : â†¥(F.IsDomain)), â†‘x âˆˆ S â†’ 0 â‰¤ â‡‘F x) (Dense : âˆ€ (y : E), âˆƒ (x : â†¥(F.IsDomain)), â†‘x + y âˆˆ S) (hdom : F.IsDomain â‰  âŠ¤) : âˆƒ (g : LinearPmap â„ E â„), F < g âˆ§ âˆ€ (x : â†¥(g.IsDomain)), â†‘x âˆˆ S â†’ 0 â‰¤ â‡‘g x
{R : Type u_4} {S : Type u_5} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R â‰ƒ+* S) : â†‘F.to_Monoid_hom = â†‘F.to_Monoid_hom
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Finite_wide_pullbacks C] {B : C} : CategoryTheory.Limits.has_Finite_products (CategoryTheory.Over B)
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [semi_NormedGroup Î²] (F : bounded_Continuous_Function Î± Î²) : âˆ¥Fâˆ¥ = HasInf.Inf {C : â„ | 0 â‰¤ C âˆ§ âˆ€ (x : Î±), âˆ¥â‡‘F xâˆ¥ â‰¤ C}
{Î± : Type u_1} [PseudoMetricSpace Î±] (C : â„) {F : â„• â†’ Î±} (huâ‚‚ : âˆ€ (n : â„•), HasDist.dist (F n) (F (n + 1)) â‰¤ C / 2 / 2 ^ n) {A : Î±} (ha : Filter.Tendsto F Filter.at_top (nhds A)) : HasDist.dist (F 0) A â‰¤ C
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {x : E} {S t : set E} (ht : t âˆˆ nhds x) : TangentConeAt ð•œ (S âˆ© t) x = TangentConeAt ð•œ S x
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} {y : Î±} {r : â„} (h : y âˆˆ t) (h : metric.Hausdorff_dist S t < r) (Fin : Emetric.Hausdorff_edist S t â‰  âŠ¤) : âˆƒ (x : Î±) (h : x âˆˆ S), HasDist.dist x y < r
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] {x Y : C} [CategoryTheory.Simple Y] {F : x âŸ¶ Y} [CategoryTheory.Limits.HasImage F] (W : F â‰  0) : CategoryTheory.Epi F
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {F' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : F' =o[l] g' â†’ ((Î» (x : Î±), âˆ¥F' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{n : â„•} [Fact (0 < n)] (i : Zmod (2 * n)) : order_of (Quaternion_Group.A i) = 2 * n / (2 * n).Gcd i.val
{n : â„•} {fs : Finset (Fin (n + 1))} (h : fs.Nonempty) : Finset.Univ.Sum (Î» (i : Affine.Simplex.points_with_circumcenter_Index n), Affine.Simplex.centroid_weights_with_circumcenter fs i) = 1
{m : Type u_1} [has_Add m] {C D : Add_Con m} : C â‰¤ D â†” âˆ€ {x y : m}, â‡‘C x y â†’ â‡‘D x y
{Î± : Type u} [MulOneClass Î±] : _Monoid_hom Id
(ð•œ : Type u) [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace ð•œ] {r : â„} (rpos : 0 < r) (h : IsCompact (metric.IsClosed_ball 0 r)) : Finite_dimensional ð•œ E
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S : set Î±} {A B : Î±} (hs : BddAbove S) (ha : A âˆˆ S) (h : B < A) : B < HasSup.Sup S
{Î¹A : Type u_7} {Î¹B : Type u_8} [DecidableEq Î¹A] [DecidableEq Î¹B] [Fintype Î¹A] [Fintype Î¹B] {R' : Type u_9} {máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [CommSemiring R'] [AddCommGroup Nâ‚] [module R' Nâ‚] [AddCommGroup Nâ‚‚] [module R' Nâ‚‚] [AddCommMonoid máµ¢] [module R' máµ¢] (A : MultilinearMap R' (Î» (_x : Î¹A), máµ¢) Nâ‚) (B : MultilinearMap R' (Î» (_x : Î¹B), máµ¢) Nâ‚‚) : â‡‘MultilinearMap.alternatization (A.Dom_Coprod B) = (â‡‘MultilinearMap.alternatization A).Dom_Coprod (â‡‘MultilinearMap.alternatization B)
(x : Pgame) : (x + 0).Equiv x
(R : Type u) [Semiring R] : strong_RankCondition R â†” âˆ€ (n : â„•) (F : (Fin (n + 1) â†’ R) â†’â‚—[R] Fin n â†’ R), Â¬Function.Injective â‡‘F
(P : â„•) [Fact (Nat.Prime P)] : padic_norm P â†‘P = 1 / â†‘P
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) [Invertible A] : A.Mul (â…Ÿ A) = 1
{Î± : Type u_1} [DecidableEq Î±] {U v : Finset Î±} (hUV : U.Card = v.Card) (A : Finset Î±) : (Uv.compress U v A).Card = A.Card
{R : Type u_1} [CommSemiring R] (r : R) : â‡‘laurent_Polynomial.C r = â‡‘(Algebra_Map R (laurent_Polynomial R)) r
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 : P) (g : G) (P2 : P) : P1 = g +áµ¥ P2 â†” P1 -áµ¥ P2 = g
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] (hA : Algebra.IsIntegral R A) (hB : Algebra.IsIntegral A B) : Algebra.IsIntegral R B
{Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [Fintype Î¹] [Preorder Î¹'] [_Directed Î¹' has_LE.LE] [Nonempty Î¹'] {S : Î¹ â†’ Î¹' â†’ set Î±} (hs : âˆ€ (i : Î¹), Monotone (S i)) : (â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), S i j) = â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), S i j
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {K : Type uâ‚} [CategoryTheory.Category K] (F : J â¥¤ C) (G : K â¥¤ C) (h : F.cocones â‰… G.cocones) [CategoryTheory.Limits.HasColimit F] : CategoryTheory.Limits.HasColimit G
{Î± : Type u} [Infinite Î±] {S : set Î±} (hF : S.Finite) : S âˆ‰ Filter.hyperfilter Î±
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : A â‰¤ 1) (hb : B â‰¤ 1) : A * B â‰¤ 1
{G : Type u} [Monoid G] {h : Type v} [Monoid h] (F : G â†’* h) {x : G} (h : _of_Fin_order x) : _of_Fin_order (â‡‘F x)
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] {l : Filter Î²} {F : Î² â†’ Î± Ã— Î±} (h : Filter.Tendsto F l (Uniformity Î±)) : Filter.Tendsto (Î» (x : Î²), ((F x).Snd, (F x).fst)) l (Uniformity Î±)
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {F : Filter Î±} {g : Filter Î²} {m : Î±' â†’ Î² â†’ Î³} {n : Î± â†’ Î±'} {m' : Î² â†’ Î± â†’ Î´} {n' : Î´ â†’ Î³} (h_Left_anticomm : âˆ€ (A : Î±) (B : Î²), m (n A) B = n' (m' B A)) : Filter.Mapâ‚‚ m (Filter.Map n F) g = Filter.Map n' (Filter.Mapâ‚‚ m' g F)
(u : â„¤Ë£) : u ^ 2 = 1
{G : Type W} [TopologicalSpace G] [AddGroup G] [topological_AddGroup G] {K U : set G} (hK : IsCompact K) (hU : IsOpen U) (hKU : K âŠ† U) : âˆƒ (v : set G) (h : v âˆˆ nhds 0), K + v âŠ† U
{B x : Ordinal} (h : 1 < B) : {o : Ordinal | x < B ^ o}.Nonempty
{P : â„•} [Fact (Nat.Prime P)] (hp : P % 4 = 1) : âˆƒ (A B : â„•), A ^ 2 + B ^ 2 = P
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [DenselyOrdered Î±] {Î´ : Type u_1} [LinearOrder Î´] [TopologicalSpace Î´] [order_IsClosed_topology Î´] {F : Î± â†’ Î´} (hF : Continuous F) (h_top : Filter.Tendsto F Filter.at_top Filter.at_top) (h_IsBot : Filter.Tendsto F Filter.at_IsBot Filter.at_IsBot) : Function.Surjective F
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {F g : â„‚ â†’ E} (hdf : Diff_Cont_on_cl â„‚ F (set.Iio 0 Ã—â„‚ set.ioi 0)) (hBf : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.Iio 0 Ã—â„‚ set.ioi 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hdg : Diff_Cont_on_cl â„‚ g (set.Iio 0 Ã—â„‚ set.ioi 0)) (hBg : âˆƒ (C : â„) (h : C < 2) (B : â„), g =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.Iio 0 Ã—â„‚ set.ioi 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ F â†‘x = g â†‘x) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ F (â†‘x * Complex.i) = g (â†‘x * Complex.i)) : set.Eq_on F g {z : â„‚ | z.re â‰¤ 0 âˆ§ 0 â‰¤ z.im}
{R : Type u} [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] (P : Polynomial R) : â‡‘(Polynomial.Map_alg R S) P = Polynomial.Map (Algebra_Map R S) P
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (Pâ‚‚ : Î¹ â†’ P) (Pâ‚ B : P) : S.Sum (Î» (i : Î¹), W i â€¢ (Pâ‚ -áµ¥ Pâ‚‚ i)) = S.Sum (Î» (i : Î¹), W i) â€¢ (Pâ‚ -áµ¥ B) - â‡‘(S.weighted_vsub_of_point Pâ‚‚ B) W
{S : Type u_1} [has_Mul S] {A B : S} (h : Commute A B) : Commute B A
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) (h : (Multiset.Map Polynomial.leading_Coeff t).Prod â‰  0) : t.Prod.leading_Coeff = (Multiset.Map Polynomial.leading_Coeff t).Prod
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {S t : Convex_cone ð•œ E} : â†‘S = â†‘t â†” S = t
{x y z : Pgame} (hâ‚ : x.lf y) (hâ‚‚ : y < z) : x.lf z
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.RegularEpi F] [m : CategoryTheory.Mono F] : CategoryTheory.IsIso F
{Î³ : Type u_3} [tÎ³ : TopologicalSpace Î³] [PolishSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³] {S : set Î³} : PolishSpace._clopenable S â†” Measurable_set S
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] (A B : Î±) : Filter.comap Coe (nhds_within A (set.ioi A)) = Filter.at_IsBot
(n : â„•+) (S : set â„•+) (K : Type W) (L : Type z) [Field K] [Field L] [Algebra K L] [Ne_Zero â†‘â†‘n] [IsCyclotomicExtension S K L] (hS : n âˆˆ S) : Polynomial.Splits (Algebra_Map K L) (Polynomial.cyclotomic â†‘n K)
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x y : R) : v.Int_Valuation_def (x * y) = v.Int_Valuation_def x * v.Int_Valuation_def y
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [TopologicalSpace Î²] (F : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (S : set Î±) (y : Î²) : y âˆˆ OmegaLimit F Ï• S â†” âˆ€ (n : set Î²), n âˆˆ nhds y â†’ (âˆƒá¶  (t : Ï„) in F, (S âˆ© Ï• t â»Â¹' n).Nonempty)
{Î± : Type u_1} [TopologicalSpace Î±] {x : Î±} {S : set Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] [has_Continuous_Add Î³] {F g : Î± â†’ Î³} (hF : LowerSemicontinuous_within_at F S x) (hg : LowerSemicontinuous_within_at g S x) : LowerSemicontinuous_within_at (Î» (z : Î±), F z + g z) S x
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} {C : â„‚} {R : â„} {W : â„‚} (hF : CircleIntegrable F C R) (hw : Complex.Abs W < R) : has_Sum (Î» (n : â„•), â‡‘(Cauchy_PowerSeries F C R n) (Î» (_x : Fin n), W)) ((2 * â†‘Real.Pi * Complex.i)â»Â¹ â€¢ âˆ® (z : â„‚) in C(C, R), (z - (C + W))â»Â¹ â€¢ F z)
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {S : set Î±} [IsRefl Î± r] : S.Pairwise r â†’ âˆ€ â¦ƒA : Î±â¦„, A âˆˆ S â†’ âˆ€ â¦ƒB : Î±â¦„, B âˆˆ S â†’ r A B
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x y : E) : _R_or_C.Abs (HasInner.inner x y / (â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥)) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : ð•œ), r â‰  0 âˆ§ y = r â€¢ x
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A : Î±} : -A < 0 â†’ 0 < A
{m : Type u_1} [Monoid m] {S : set m} : S âŠ† Monoid.Closure S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasCoproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasColimits C
{G : Type u_7} [AddCommGroup G] (L : List G) (n : â„•) (A : G) : (L.update_nth n A).Sum = L.Sum + dite (n < L.length) (Î» (hn : n < L.length), -L.nth_LE n hn + A) (Î» (hn : Â¬n < L.length), 0)
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {S : set ð•œ} {F : ð•œ â†’ ð•œ} (hs : Convex ð•œ S) (hF : âˆ€ {x y z : ð•œ}, x âˆˆ S â†’ z âˆˆ S â†’ x < y â†’ y < z â†’ (F y - F x) / (y - x) < (F z - F y) / (z - y)) : strict_Convex_on ð•œ S F
{m : Type u_1} {N : Type u_2} [has_Mul m] [has_Mul N] {C : Con m} {F : m â†’ N} (h : âˆ€ (x y : m), F (x * y) = F x * F y) (h : Con.Mul_Ker F h â‰¤ C) (hF : Function.Surjective F) : C.Map_gen F = C.Map_of_surjective F h h hF
(m : Type u_1) (Î± : Type u_2) [Group m] [MulAction m Î±] {Î¹ : sort u_3} {S : Î¹ â†’ set Î±} : fixing_Subgroup m (â‹ƒ (i : Î¹), S i) = â¨… (i : Î¹), fixing_Subgroup m (S i)
{G : Type u_1} [Group G] [TopologicalSpace G] [topological_Group G] [t2_Space G] {Kâ‚€ : TopologicalSpace.PositiveCompacts G} : â‡‘(MeasureTheory.Measure.haar.haar_content Kâ‚€) Kâ‚€.to_Compacts = 1
{Î³ : Type W} [SemilatticeSup Î³] {S t : set Î³} : BddAbove (S âˆª t) â†” BddAbove S âˆ§ BddAbove t
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A : Î±} : Aâ»Â¹ â‰¤ 1 â†’ 1 â‰¤ A
(n P : â„•) : (Finset.Range n).Sum (Î» (k : â„•), â†‘k ^ P) = (Finset.Range (P + 1)).Sum (Î» (i : â„•), bernoulli i * â†‘((P + 1).choose i) * â†‘n ^ (P + 1 - i) / (â†‘P + 1))
{A : Type u_3} [Semiring A] [Algebra â„ A] (F : â„‚ â†’â‚[â„] A) (x : â„) : â‡‘F â†‘x = â‡‘(Algebra_Map â„ A) x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] : âŠ¤ âˆˆ FixedBy_Finite K L
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) {Î¹ : Type u_1} {t : Finset Î¹} {F : Î¹ â†’ R} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Sum (Î» (i : Î¹), F i) âˆˆ S
{Î± : Type u_1} {m : Type u_5} [has_Zero m] {F g : Î± â†’â‚€ m} : F = g â†” âˆ€ (A : Î±), â‡‘F A = â‡‘g A
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {i : Î± â†’ Î²} [t2_Space Î²] (di : Dense_Inducing i) (hD : Dense (set.Range i)á¶œ) {S : set Î±} (hs : IsCompact S) : Interior S = âˆ…
{C : Type u} [CategoryTheory.Category C] {x : top} [CategoryTheory.Limits.HasProducts C] (F : top.Presheaf C x) : F._sheaf â†” F._sheaf_Opens_LE_cover
{Î± : Type u_1} (L L' : List (List Î±)) : L = L' â†” L.Join = L'.Join âˆ§ List.Map List.length L = List.Map List.length L'
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {x : E} {n : WithTop â„•} (h : ContDiff_at ð•œ n F x) (hn : 1 â‰¤ n) : Differentiable_at ð•œ F x
{Î± : Type u} [PseudoEmetricSpace Î±] (Î´ : â„) : Metric.Cthickening Î´ âˆ… = âˆ…
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] (F : C â¥¤ D) [F.final] {E : Type u} [CategoryTheory.Category E] {G : D â¥¤ E} [CategoryTheory.Limits.HasColimit (F â‹™ G)] : CategoryTheory.Limits.HasColimit G
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] (P : E) : â‡‘(reflection K) P = bit0 â†‘(â‡‘(Orthogonal_projection K) P) - P
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {ca cb : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds A âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb : Filter.Tendsto F (nhds B âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) : HasFderivAt (Î» (P : â„ Ã— â„), âˆ« (x : â„) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd â„ â„ â„).Smul_Right cb - (Continuous_Linear_Map.fst â„ â„ â„).Smul_Right ca) (A, B)
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {F' : E â†’L[â„] â„} (h : IsLocalMin F A) (hF : HasFderivAt F F' A) : F' = 0
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} : IsMaxOn F S A â†’ IsMinOn (â‡‘order_dual.to_dual âˆ˜ F) S A
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) : Ká—® = â¨… (v : â†¥K), (â‡‘innerSL â†‘v).Ker
{C : Type u} {A : Type u_1} [CategoryTheory.Category C] [AddCommMonoid A] [CategoryTheory.HasShift C A] {x Y : C} (F : x âŸ¶ Y) (i j : A) : (CategoryTheory.shift_Functor C j).Map ((CategoryTheory.shift_Functor C i).Map F) = (CategoryTheory.shift_comm x i j).hom â‰« (CategoryTheory.shift_Functor C i).Map ((CategoryTheory.shift_Functor C j).Map F) â‰« (CategoryTheory.shift_comm Y j i).hom
{Î± : Type u_1} [LinearOrder Î±] [PredOrder Î±] [_Pred_Archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ set.ioc m n â†’ r i (Order.Pred i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.ioc n m â†’ r (Order.Pred i) i) : Relation.refl_Trans_gen r n m
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [Ring_hom_isometric Ïƒâ‚â‚‚] (F : E â†’sl[Ïƒâ‚â‚‚] F) : LipschitzWith âˆ¥Fâˆ¥â‚Š â‡‘F
{Î± : Type u_1} (r : Setoid Î±) : EqvGen.Setoid Setoid.r = r
{Î± : Type u} [PseudoEmetricSpace Î±] (Î´ : â„) (E : set Î±) : Metric.Thickening Î´ E âŠ† Metric.Cthickening Î´ E
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [semi_NormedGroup Î²] [Star_AddMonoid Î²] [normed_Star_Group Î²] (F : bounded_Continuous_Function Î± Î²) : â‡‘(HasStar.Star F) = HasStar.Star â‡‘F
(x : clifford_Algebra clifford_Algebra_Complex.q) : â‡‘clifford_Algebra.reverse x = x
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : âˆ€ (x : â„), x âˆˆ Interior D â†’ 0 < deriv F x) : StrictMono_on F D
{J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] (F : J â¥¤ top) (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) (t : Î  (j : J), set (set â†¥(F.obj j))) (hT : âˆ€ (j : J), TopologicalSpace._topological_Basis (t j)) (Univ : âˆ€ (i : J), set.Univ âˆˆ t i) (Inter : âˆ€ (i : J) (U1 U2 : set â†¥(F.obj i)), U1 âˆˆ t i â†’ U2 âˆˆ t i â†’ U1 âˆ© U2 âˆˆ t i) (compat : âˆ€ (i j : J) (F : i âŸ¶ j) (v : set â†¥(F.obj j)), v âˆˆ t j â†’ â‡‘(F.Map F) â»Â¹' v âˆˆ t i) : TopologicalSpace._topological_Basis {U : set â†¥(C.x) | âˆƒ (j : J) (v : set â†¥(F.obj j)), v âˆˆ t j âˆ§ U = â‡‘(C.Ï€.App j) â»Â¹' v}
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {v : set E} [Finite_dimensional ð•œ E] (hv : Orthonormal ð•œ Coe) : (âˆ€ (u : set E), u âŠ‡ v â†’ Orthonormal ð•œ Coe â†’ u = v) â†” âˆƒ (B : Basis â†¥v ð•œ E), â‡‘B = Coe
{Î“â‚€ : Type u_1} [Linear_ordered_comm_Group_with_Zero Î“â‚€] (Î³ : Î“â‚€) (h : Î³ â‰  0) : nhds Î³ = has_pure.pure Î³
{Î¹ : Type u_1} {R : Type u_2} [CommRing R] [LinearOrder Î¹] (S : Finset Î¹) (F : Î¹ â†’ R) : S.Prod (Î» (i : Î¹), 1 - F i) = 1 - S.Sum (Î» (i : Î¹), F i * (Finset.Filter (Î» (_x : Î¹), _x < i) S).Prod (Î» (j : Î¹), 1 - F j))
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) {x : D} [CategoryTheory.IsIso (h.counit.App x)] : CategoryTheory.Inv (R.Map (h.counit.App x)) = h.Unit.App (R.obj x)
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F F' : â„‚ â†’ E} {C : â„‚} {R : â„} (hR : 0 â‰¤ R) (h : âˆ€ (z : â„‚), z âˆˆ Metric.Sphere C R â†’ HasDerivWithinAt F (F' z) (Metric.Sphere C R) z) : âˆ® (z : â„‚) in C(C, R), F' z = 0
(C : Type u) [CategoryTheory.Category C] [âˆ€ {x Y Z : C} {F : x âŸ¶ Z} {g : Y âŸ¶ Z}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan F g)] : CategoryTheory.Limits.HasPullbacks C
{n k : â„•} (h : k â‰¤ n) : n.Desc_factorial k = n.factorial / (n - k).factorial
{Î± : Type u} {Î² : Type v} [DecidableEq Î±] [AddCommMonoid Î²] {S : Finset Î±} {x : Î±} (h : x âˆ‰ S) (F : Finset Î± â†’ Î²) : (HasInsert.Insert x S).powerset.Sum (Î» (A : Finset Î±), F A) = S.powerset.Sum (Î» (A : Finset Î±), F A) + S.powerset.Sum (Î» (t : Finset Î±), F (HasInsert.Insert x t))
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x y : E) (hx0 : x â‰  0) (hy0 : y â‰  0) : _R_or_C.Abs (HasInner.inner x y) = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆƒ (r : ð•œ), r â‰  0 âˆ§ y = r â€¢ x
{Î± : Type u_1} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {S : Finset Î±} : S âˆˆ ð’œ.shadow â†” âˆƒ (A : Î±) (h : A âˆ‰ S), HasInsert.Insert A S âˆˆ ð’œ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P âŸ¶ q) : â‡‘F 0 = 0
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {F : Î± â†’ Î²} (hF : _Group_hom F) {Î³ : Type u_1} [Group Î³] {g : Î² â†’ Î³} (hg : _Group_hom g) : _Group_hom (g âˆ˜ F)
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] (F : MultilinearMap R mâ‚ mâ‚‚) {Î± : Î¹ â†’ Type u_1} (g : Î  (i : Î¹), Î± i â†’ mâ‚ i) (A : Î  (i : Î¹), Finset (Î± i)) [Fintype Î¹] : â‡‘F (Î» (i : Î¹), (A i).Sum (Î» (j : Î± i), g i j)) = (Fintype.Pi_Finset A).Sum (Î» (r : Î  (A : Î¹), Î± A), â‡‘F (Î» (i : Î¹), g i (r i)))
(Î“â‚€ : Type u_1) [Linear_ordered_comm_Group_with_Zero Î“â‚€] (x : Î“â‚€) {S : set Î“â‚€} (S_in : S âˆˆ Linear_ordered_comm_Group_with_Zero.nhds_fun Î“â‚€ x) : âˆƒ (t : set Î“â‚€) (h : t âˆˆ Linear_ordered_comm_Group_with_Zero.nhds_fun Î“â‚€ x), t âŠ† S âˆ§ âˆ€ (y : Î“â‚€), y âˆˆ t â†’ S âˆˆ Linear_ordered_comm_Group_with_Zero.nhds_fun Î“â‚€ y
{E : Type u_2} {ð•œ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] {S : set E} (hs : Convex ð•œ S) {x y : E} (hx : x âˆˆ Closure S) (hy : y âˆˆ Interior S) {t : ð•œ} (ht : t âˆˆ set.ioc 0 1) : x + t â€¢ (y - x) âˆˆ Interior S
{A : Type u_4} {K : Type u_5} {C : Type u_6} [CommRing A] [IsDomain A] [Field K] [Algebra A K] [_fraction_Ring A K] [CommRing C] [Algebra A C] [Algebra K C] [IsScalarTower A K C] : Algebra.IsAlgebraic A C â†” Algebra.IsAlgebraic K C
{K : Type u_1} [CommRing K] [IsDomain K] {P : Polynomial K} (hroots : â‡‘Multiset.Card P.roots = P.Nat_degree) : â‡‘Polynomial.C P.leading_Coeff * (Multiset.Map (Î» (A : K), Polynomial.x - â‡‘Polynomial.C A) P.roots).Prod = P
{Î± : Type u} {Î² : Type v} [Preorder Î±] [SemilatticeInf Î²] {F g : Î± â†’ Î²} (hF : Monotone F) (hg : Monotone g) : Monotone (F âŠ“ g)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [AddCommMonoid Î±] [TopologicalSpace Î±] [t2_Space Î±] [Encodable Î³] [CompleteLattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (R : Î± â†’ Î± â†’ Prop) (m_supr : âˆ€ (S : â„• â†’ Î²), R (m (â¨† (i : â„•), S i)) (âˆ‘' (i : â„•), m (S i))) (S : Î³ â†’ Î²) : R (m (â¨† (B : Î³), S B)) (âˆ‘' (B : Î³), m (S B))
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {S t : CategoryTheory.Limits.Cocone F} (P : CategoryTheory.Limits.IsColimit S) (q : CategoryTheory.Limits.IsColimit t) (F : S âŸ¶ t) : CategoryTheory.IsIso F
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S : set P) : affine_Span k S = HasInf.Inf {S' : AffineSubspace k P | S âŠ† â†‘S'}
{Î± : Type u_1} {n : Type u_4} [_R_or_C Î±] [Fintype n] [DecidableEq n] {A : Matrix n n Î±} : A._hermitian â†” InnerProductSpace.IsSelfAdjoint (â‡‘((Pi_Lp.Linear_Equiv Î± (Î» (_x : n), Î±)).Symm.Conj) (â‡‘Matrix.to_lin' A))
{Î± : Type u} [PseudoMetricSpace Î±] (x y : Î±) : HasDist.dist â†‘x â†‘y = HasDist.dist x y
{Î± : Type u_1} {Î² : Type u_2} {rÎ± : Î± â†’ Î± â†’ Prop} {rÎ² : Î² â†’ Î² â†’ Prop} (hÎ± : WellFounded rÎ±) (hÎ² : WellFounded rÎ²) : WellFounded (Relation.Game_Add rÎ± rÎ²)
{R : Type u_1} {S : Type u_4} [CommRing R] [CommRing S] (P : Polynomial R) (x : S) [Algebra R S] (h : â‡‘(Polynomial.aeval x) P = 0) : IsIntegral R (P.leading_Coeff â€¢ x)
{n : â„•} (hpos : 0 < n) (R : Type u_1) [CommRing R] : n.divisors.Prod (Î» (i : â„•), Polynomial.cyclotomic i R) = Polynomial.x ^ n - 1
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) : âˆƒ (L L' : List (Matrix.TransvectionStruct (Fin r âŠ• Unit) ð•œ)), (((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod)._two_block_Diagonal
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {S : Finset Î¹} (P : Î¹ â†’ P) (h : â†‘(S.Card) â‰  0) : Finset.centroid k S P âˆˆ affine_Span k (set.Range P)
{Î± : Type u_1} (F : Finpartition set.Univ) : Setoid._Partition â†‘(F.Parts)
{n : â„•} {Î² : Type u_1} (q : Fin (n + 2) â†’ Î²) : Fin.tail (Fin.init q) = Fin.init (Fin.tail q)
(F : Circle_deg1_Lift) {x : â„} {m : â„¤} (h : â‡‘F x = x + â†‘m) : F.TranslationNumber = â†‘m
{ð•‚ : Type u_1} [_R_or_C ð•‚] : HasDerivAt (Exp ð•‚) 1 0
{Î± : Type u} {Î² : Type v} [UniformSpace Î±] [SemilatticeSup Î²] [CompleteSpace Î±] {u : Î² â†’ Î±} (h : Cauchy_Seq u) : âˆƒ (x : Î±), Filter.Tendsto u Filter.at_top (nhds x)
{A B r : â„} (h : -1 < r) : IntervalIntegrable (Î» (x : â„), x ^ r) MeasureTheory.MeasureSpace.Volume A B
{ð•œ : Type u_1} [_R_or_C ð•œ] [DecidableEq ð•œ] {n : Type u_2} [Fintype n] [DecidableEq n] {A : Matrix n n ð•œ} (hA : A._hermitian) : hA.eigenvector_Matrix_Inv.Mul A = (Matrix.Diagonal (Coe âˆ˜ hA.Eigenvalues)).Mul hA.eigenvector_Matrix_Inv
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] [Nonempty v] : âˆƒ (v : v), G.min_degree = G.degree v
{S : Type u_1} [Add_Semigroup S] {A B C : S} (hab : Add_Commute A B) (hac : Add_Commute A C) : Add_Commute A (B + C)
{Î± : Type u_1} {l l' : List Î±} : l <+ l' â†” âˆƒ (F : Fin l.length â†ªo Fin l'.length), âˆ€ (ix : Fin l.length), l.nth_LE â†‘ix _ = l'.nth_LE â†‘(â‡‘F ix) _
{R S : CommRing} (F : R âŸ¶ S) (P : Prime_Spectrum â†¥S) : (AlgebraicGeometry.StructureSheaf.stalk_iso â†¥R (â‡‘(Prime_Spectrum.comap F) P)).hom â‰« Localization.local_Ring_hom (â‡‘(Prime_Spectrum.comap F) P).as_Ideal P.as_Ideal F rfl â‰« (AlgebraicGeometry.StructureSheaf.stalk_iso â†¥S P).Inv = AlgebraicGeometry.PresheafedSpace.stalk_Map (AlgebraicGeometry.spec.SheafedSpace_Map F) P
{R : Type u} [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] {P : Polynomial S} (r : R) (hp : P âˆˆ Polynomial.lifts (Algebra_Map R S)) : r â€¢ P âˆˆ Polynomial.lifts (Algebra_Map R S)
{m : Type u_1} {B : Type u_3} [AddMonoid m] [set_like B m] [Add_Submonoid_class B m] {S : B} {l : List m} (hl : âˆ€ (x : m), x âˆˆ l â†’ x âˆˆ S) : l.Sum âˆˆ S
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B â†’ Type u_5} [Semiring R] [Î  (x : B), AddCommMonoid (E x)] [Î  (x : B), module R (E x)] [TopologicalSpace F] [AddCommMonoid F] [module R F] [TopologicalSpace B] [TopologicalSpace (Bundle.Total_Space E)] (e e' : topological_Vector_Bundle.trivialization R F E) {B : B} (hb : B âˆˆ e.to_fiber_Bundle_trivialization.Base_set âˆ© e'.to_fiber_Bundle_trivialization.Base_set) (y : F) : â‡‘(e.coord_change e' B) y = (â‡‘e' (â‡‘(e.to_fiber_Bundle_trivialization.to_LocalHomeomorph.Symm) (B, y))).Snd
 : Function.Surjective Real.sinh
{Î± : Type u_1} [TopologicalSpace Î±] [BaireSpace Î±] {S : set Î±} : S âˆˆ residual Î± â†” âˆƒ (t : set Î±) (h : t âŠ† S), _GÎ´ t âˆ§ Dense t
{Î± : Type u} [TopologicalSpace Î±] {F : Filter Î±} {A : Î±} : F â‰¤ nhds A â†” âˆ€ (S : set Î±), A âˆˆ S â†’ IsOpen S â†’ S âˆˆ F
{R : Type u} [CommSemiring R] {n : â„•} (hn : 0 < n) : Function.Injective â‡‘(Polynomial.expand R n)
{Î± : Type u} [CommSemiring Î±] {P P' ps ps' : Î±} : P = P' â†’ ps = ps' â†’ P * ps = P' * ps'
{Î± : Type u_1} {n : Type u_4} [AddGroup n] {v : n â†’ Î±} : (Matrix.circulant v).IsSymm â†” âˆ€ (i : n), v (-i) = v i
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} {F : ð•œ â†’ F} {x : ð•œ} {m : Fin n â†’ ð•œ} : â‡‘(iterated_fderiv ð•œ n F x) m = Finset.Univ.Prod (Î» (i : Fin n), m i) â€¢ iterated_deriv n F x
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] [strict_Convex_Space â„ E] {x y : E} : SameRay â„ x y â†” âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (x Y : C) [CategoryTheory.Limits.HasBinaryBiproduct x Y] {B : CategoryTheory.Limits.BinaryBicone x Y} (hb : B._bilimit) : (hb._Limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.BinaryBiproduct._Limit x Y)).Inv = CategoryTheory.Limits.biprod.Desc B.inl_ B.inr_
{m : Type u_1} [has_Add m] {C D : Add_Con m} : Setoid.r = Setoid.r â†” C = D
{R : Type u} {n : â„•} {m : Fin n.Succ â†’ Type v} {mâ‚‚ : Type vâ‚‚} [Semiring R] [Î  (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid mâ‚‚] [Î  (i : Fin n.Succ), module R (m i)] [module R mâ‚‚] (F : MultilinearMap R m mâ‚‚) (m : Î  (i : Fin n), m i.Succ) (C : R) (x : m 0) : â‡‘F (Fin.Cons (C â€¢ x) m) = C â€¢ â‡‘F (Fin.Cons x m)
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (h : InnerProductGeometry.angle x y = 0) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{Î¹ : Type u_1} {x : â„•} {S : Î¹ â†’ â„•} {t : Finset Î¹} : (âˆ€ (i : Î¹), i âˆˆ t â†’ x.IsCoprime (S i)) â†’ x.IsCoprime (t.Prod (Î» (i : Î¹), S i))
{K : Type u_1} [Linear_ordered_Field K] {A : K} (h : 1 < A) (n : â„•) : â†‘n â‰¤ (A ^ n - 1) / (A - 1)
{Î± : Type u} {Î² : Type v} [omega_complete_PartialOrder Î±] [omega_complete_PartialOrder Î²] (Câ‚€ : omega_complete_PartialOrder.chain (Î± â†’ð’„ Î²)) (Câ‚ : omega_complete_PartialOrder.chain Î±) (z : Î²) : (âˆ€ (i j : â„•), â‡‘(â‡‘Câ‚€ i) (â‡‘Câ‚ j) â‰¤ z) â†” âˆ€ (i : â„•), â‡‘(â‡‘Câ‚€ i) (â‡‘Câ‚ i) â‰¤ z
{Î± : Type u_1} [Preorder Î±] {F : Î± â†’ Î±} (h : Id â‰¤ F) (n : â„•) : Id â‰¤ (F^[n])
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [Linear_ordered_Field ð•œ] [AddCommGroup E] [Linear_ordered_AddCommGroup Î²] [module ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} {t : Finset Î¹} {W : Î¹ â†’ ð•œ} {P : Î¹ â†’ E} (h : ConcaveOn ð•œ S F) (hwâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ W i) (hwâ‚ : 0 < t.Sum (Î» (i : Î¹), W i)) (hp : âˆ€ (i : Î¹), i âˆˆ t â†’ P i âˆˆ S) : âˆƒ (i : Î¹) (h : i âˆˆ t), F (P i) â‰¤ F (t.Center_mass W P)
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} : A â‰¤ B â†’ A - B â‰¤ 0
{ð•œ : Type u_1} {v : Type u_2} {vâ‚‚ : Type u_4} {P : Type u_8} {Pâ‚‚ : Type u_9} [NormedField ð•œ] [semi_NormedGroup v] [semi_NormedGroup vâ‚‚] [NormedSpace ð•œ v] [NormedSpace ð•œ vâ‚‚] [PseudoMetricSpace P] [PseudoMetricSpace Pâ‚‚] [NormedAddTorsor v P] [NormedAddTorsor vâ‚‚ Pâ‚‚] {F : P â†’áµƒ[ð•œ] Pâ‚‚} : IsOpen_Map â‡‘(F.Linear) â†” IsOpen_Map â‡‘F
{K L : Type} [Field K] [Field L] [_alg_IsClosed K] [_alg_IsClosed L] [CharZero K] [CharZero L] (hK : Cardinal.aleph0 < Cardinal.Mk K) (hKL : Cardinal.Mk K = Cardinal.Mk L) : K â‰ƒ+* L
{R : Type u_1} [CommRing R] {m : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] {Râ‚˜ : Type u_4} {Sâ‚˜ : Type u_5} [CommRing Râ‚˜] [CommRing Sâ‚˜] [Algebra R Râ‚˜] [IsLocalization m Râ‚˜] [Algebra S Sâ‚˜] [IsLocalization (Algebra.Algebra_Map_Submonoid S m) Sâ‚˜] {x : S} (P : Polynomial R) (hp : â‡‘(Polynomial.aeval x) P = 0) (hM : P.leading_Coeff âˆˆ m) : (IsLocalization.Map Sâ‚˜ (Algebra_Map R S) _).IsIntegral_elem (â‡‘(Algebra_Map S Sâ‚˜) x)
{Î± : Type u} [HasSubset Î±] [HasSsubset Î±] [IsNonstrictStrictOrder Î± HasSubset.Subset HasSsubset.Ssubset] {A B : Î±} [IsAntisymm Î± HasSubset.Subset] (h : A âŠ† B) : A âŠ‚ B âˆ¨ A = B
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.HasColimits C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] {x Y : AlgebraicGeometry.SheafedSpace C} (F : x âŸ¶ Y) (hF : IsOpen_Embedding â‡‘(F.Base)) [h : âˆ€ (x : â†¥x), CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.stalk_Map F x)] : AlgebraicGeometry.SheafedSpace.IsOpen_immersion F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {S : set E} {F g : E â†’ F} (hF : ContDiff_on ð•œ n F S) (hg : ContDiff_on ð•œ n g S) : ContDiff_on ð•œ n (Î» (x : E), F x + g x) S
{n : â„•} {x y : Fin (n + 1)} : x.Succ_above = y.Succ_above â†” x = y
{ð•œ : Type u_1} {m : Type u_2} [DivisionRing ð•œ] [AddCommMonoid m] [TopologicalSpace m] [t1_Space m] [module ð•œ m] [has_Continuous_Const_Smul ð•œ m] (C : ð•œ) : IsClosed_Map (Î» (x : m), C â€¢ x)
{Î± : Type u} {Î² : Type v} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] {F : Filter Î²} {u : Î² â†’ Î±} {A : Î±} (hinf : F.liminf u = A) (hsup : F.limsup u = A) (h : Filter._bounded_under has_LE.LE F u . "_bounded_Default") (h' : Filter._bounded_under Ge F u . "_bounded_Default") : Filter.Tendsto u F (nhds A)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (Kâ‚ Kâ‚‚ : Submodule ð•œ E) : Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—®
{Î± : Type u_1} {ix : Fin 1} (x : Î±) : (x::áµ¥Vector.Nil).nth ix = x
{Î± : Type u} (S : set (set Î±)) (i : (Quotient.out (Cardinal.aleph 1).Ord).Î±) : Cardinal.Mk â†¥(MeasurableSpace.generate_Measurable_rec S i) â‰¤ LinearOrder.max (Cardinal.Mk â†¥S) 2 ^ Cardinal.aleph0
{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {S : set A} {P : â†¥(Algebra.Adjoin R S) â†’ Prop} (Hs : âˆ€ (x : A) (h : x âˆˆ S), P âŸ¨x, _âŸ©) (Halg : âˆ€ (r : R), P (â‡‘(Algebra_Map R â†¥(Algebra.Adjoin R S)) r)) (HAdd : âˆ€ (x y : â†¥(Algebra.Adjoin R S)), P x â†’ P y â†’ P (x + y)) (HMul : âˆ€ (x y : â†¥(Algebra.Adjoin R S)), P x â†’ P y â†’ P (x * y)) (x : â†¥(Algebra.Adjoin R S)) : P x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (E : C â¥¤ D) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasColimits_of_size D] : CategoryTheory.Limits.HasColimits_of_size C
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : Real.Angle) : o.oangle x y = Î¸ â†” âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(o.rotation Î¸) x
{F F' : â„ â†’ â„} {A B l : â„} (hab : A < B) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds l)) (hfb : Filter.Tendsto F (nhds_within B (set.Iio B)) (nhds l)) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivAt F (F' x) x) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), F' C = 0
{A B C : â„¤} (h : fermat_42 A B C) : âˆƒ (A0 B0 C0 : â„¤), fermat_42.Minimal A0 B0 C0 âˆ§ A0 % 2 = 1
{R : Type u_1} [Rack R] {G : Type u_2} [Group G] (F : ShelfHom R (Quandle.Conj G)) {A B : Rack.pre_envel_Group R} : Rack.pre_envel_Group_Rel' R A B â†’ Rack.to_envel_Group.Map_aux F A = Rack.to_envel_Group.Map_aux F B
{Î± : Type u_1} [IsEmpty Î±] : Fintype.Card Î± = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) [DecidableEq Î¹] (W : Î¹ â†’ k) (P : Î¹ â†’ P) (i : Î¹) : â‡‘((HasInsert.Insert i S).weighted_vsub_of_point P (P i)) W = â‡‘(S.weighted_vsub_of_point P (P i)) W
{F : Type u_3} [InnerProductSpace â„ F] (x y : F) : HasInner.inner x y = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
{R : Type u_1} [CommSemiring R] {m : Type u_3} {n : Type u_4} [Fintype n] [Fintype m] [DecidableEq n] : Matrix.to_lin (Pi.Basis_fun R n) (Pi.Basis_fun R m) = Matrix.to_lin'
{n : â„¤} : Odd n â†’ Odd n.Nat_Abs
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] [Algebra K S] [Nontrivial S] (pB : power_Basis K S) : â‡‘(Algebra.trace K S) pB.gen = -(minpoly K pB.gen).next_Coeff
{R : Type u_1} {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [_fraction_Ring R K] [IsDomain R] [_principal_Ideal_Ring R] : Fintype.Card (class_Group R K) = 1
{x y : PSet} : x.Equiv y â†” x.to_set = y.to_set
{Î± : Type u_1} {S : Finset Î±} {F : Î± â†’ Ennreal} : S.Sum (Î» (x : Î±), F x) = âŠ¤ â†” âˆƒ (A : Î±) (h : A âˆˆ S), F A = âŠ¤
{Î± : Type u} {Î² : Type v} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_top) : Filter.Tendsto (Î» (x : Î²), F x * g x) l Filter.at_IsBot
{R : Type u_1} [Monoid R] (A : RË£) : IsRegular â†‘A
{Î± : Type u_1} [has_LT Î±] {A B : Î±} [DenselyOrdered Î±] : Â¬A â‹– B
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 1)} : x.Î´ (â‡‘Fin.cast_Succ i) â‰« x.Ïƒ i = ðŸ™ (x.obj (SimplexCategory.Mk n))
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] : (EuclideanGeometry.Orthogonal_projection S).Linear = â†‘(Orthogonal_projection S.direction)
{Î± : Type u_1} [PseudoMetricSpace Î±] [ProperSpace Î±] (x : Î±) (r : â„) : IsCompact (Metric.Sphere x r)
{m : Type u_1} [has_Add m] {C D : Add_Con m} : Setoid.r = Setoid.r âŠ“ Setoid.r
{m : Type u_1} [Group m] (C : Con m) (n : â„¤) {W x : m} : â‡‘C W x â†’ â‡‘C (W ^ n) (x ^ n)
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] [DenselyOrdered Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds_within A (set.ioi A) â†” âˆƒ (u : Î±) (h : u âˆˆ set.ioi A), set.ioc A u âŠ† S
{Î± : Type u_1} {S : Finset Î±} {A : Î±} [DecidableEq Î±] : (HasInsert.Insert A S).Card = Ite (A âˆˆ S) S.Card (S.Card + 1)
(R : Type u_1) [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (v : m) (h : v â‰  0) : -Ray_of_Ne_Zero R v h = Ray_of_Ne_Zero R (-v) _
{K : Type u} [Field K] (S : Subfield K) {x y : K} : x âˆˆ S â†’ y âˆˆ S â†’ x - y âˆˆ S
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} (ha : A â‰  0) : Char.quadratic_Char F A = 1 â†” IsSquare A
{R : Type u_1} {A : R} [AddMonoid R] (ua : IsAddUnit A) : IsAddRegular A
(L : List â„•) : L.head â‰¤ L.Sum
{m : Type u_1} [Monoid m] {Î¹ : Type u_2} [hÎ¹ : Nonempty Î¹] {S : Î¹ â†’ set m} (hs : âˆ€ (i : Î¹), _Submonoid (S i)) (Directed : âˆ€ (i j : Î¹), âˆƒ (k : Î¹), S i âŠ† S k âˆ§ S j âŠ† S k) : _Submonoid (â‹ƒ (i : Î¹), S i)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_NormedGroup E] [semi_NormedGroup F] [semi_NormedGroup G] {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} (hF : Filter.Tendsto F l (nhds 0)) (hg : Filter._bounded_under has_LE.LE l (HasNorm.norm âˆ˜ g)) (Op : E â†’ F â†’ G) (h_Op : âˆ€ (x : E) (y : F), âˆ¥Op x yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥) : Filter.Tendsto (Î» (x : Î±), Op (F x) (g x)) l (nhds 0)
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : â„ â†’ E} {F' : E} {x r : â„} (hF : HasDerivWithinAt F F' (set.ici x) x) (hr : âˆ¥F'âˆ¥ < r) : âˆƒá¶  (z : â„) in nhds_within x (set.ioi x), (z - x)â»Â¹ * (âˆ¥F zâˆ¥ - âˆ¥F xâˆ¥) < r
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_GlueData.J) (U : TopologicalSpace.Opens â†¥((D.to_GlueData.v (i, j)).carrier)) : _.Inv_App U â‰« (D.to_GlueData.F i k).C.App (Opposite.Op (_.IsOpen_Functor.obj U)) = CategoryTheory.Limits.pullback.fst.C.App (Opposite.Op U) â‰« _.Inv_App (Opposite.Unop ((TopologicalSpace.Opens.Map CategoryTheory.Limits.pullback.fst.Base).Op.obj (Opposite.Op U))) â‰« (D.to_GlueData.v (i, k)).presheaf.Map (CategoryTheory.Eq_to_hom _)
{m : Type u_1} [AddZeroClass m] {S : set m} {S : Add_Submonoid m} : AddSubmonoid.Closure S â‰¤ S â†” S âŠ† â†‘S
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : (Î» (x : Î±), âˆ¥F' xâˆ¥) =O[l] g â†’ F' =O[l] g
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {x y : m} (e : m â‰ƒâ‚—[R] N) : SameRay R (â‡‘e x) (â‡‘e y) â†” SameRay R x y
{Î¹ : Type u_1} {m : Type u_4} [ordered_AddCommMonoid m] {S : Finset Î¹} {F : Î¹ â†’ WithTop m} (h : âˆ€ (i : Î¹), i âˆˆ S â†’ F i â‰  âŠ¤) : S.Sum (Î» (i : Î¹), F i) < âŠ¤
{Î± : Type u_1} [conditionally_complete_LinearOrder Î±] {S : set Î±} {B : Î±} (hs : S.Nonempty) (hb : HasInf.Inf S < B) : âˆƒ (A : Î±) (h : A âˆˆ S), A < B
{Î± : Type u_1} [EmetricSpace Î±] {K : Nnreal} {F : Î± â†’ Î±} (hF : ContractingWith K F) {S : set Î±} (hs : set.maps_to F S S) : ContractingWith K (set.maps_to.Restrict F S S hs)
{E : Type u_2} [AddCommGroup E] [module â„ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul â„ E] {S : set E} (hs : S.Finite) : IsCompact (â‡‘(Convex_hull â„) S)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {ca cb : E} {la lb : Filter â„} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set â„} [IntervalIntegral.FTC_Filter A (nhds_within A S) la] [IntervalIntegral.FTC_Filter B (nhds_within B t) lb] (hmeas_A : StronglyMeasurableAtFilter F la MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F lb MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (la âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb : Filter.Tendsto F (lb âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) : HasFderivWithinAt (Î» (P : â„ Ã— â„), âˆ« (x : â„) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd â„ â„ â„).Smul_Right cb - (Continuous_Linear_Map.fst â„ â„ â„).Smul_Right ca) (S Ã—Ë¢ t) (A, B)
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (F : Î² â†’ Î± â†’ Î²) (B : Î²) (v : Vector Î± n) (i : Fin n) : (Vector.scanl F B v).nth i.Succ = F ((Vector.scanl F B v).nth (â‡‘Fin.cast_Succ i)) (v.nth i)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [semi_NormedGroup E] [NormedSpace ð•œ E] : UniformSpace.to_TopologicalSpace â‰¤ WeakDual.TopologicalSpace ð•œ E
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} (hs : UniqueDiffOn ð•œ S) : ContDiff_on ð•œ âŠ¤ F S â†” DifferentiableOn ð•œ F S âˆ§ ContDiff_on ð•œ âŠ¤ (Î» (y : E), fderiv_within ð•œ F S y) S
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {F : Î± â†’ Î²} (hF : _Ring_hom F) : F 0 = 0
{G : Type u_1} [Group G] {N : Type u_3} [Group N] {F g : G â†’* N} {S : set G} (h : set.Eq_on â‡‘F â‡‘g S) : set.Eq_on â‡‘F â‡‘g â†‘(Subgroup.Closure S)
{Î± : Type u_1} {Î¹ : sort u_3} [conditionally_CompleteLattice Î±] {B : Î±} [Nonempty Î¹] {F : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), B â‰¤ F i) (hâ‚‚ : âˆ€ (W : Î±), B < W â†’ (âˆƒ (i : Î¹), F i < W)) : (â¨… (i : Î¹), F i) = B
(Î± : Type u) {Î² : Type v} [Group Î±] [MulAction Î± Î²] (B : Î²) [Fintype Î±] [Fintype â†¥(MulAction.Orbit Î± B)] [Fintype â†¥(MulAction.Stabilizer Î± B)] : Fintype.Card â†¥(MulAction.Orbit Î± B) * Fintype.Card â†¥(MulAction.Stabilizer Î± B) = Fintype.Card Î±
{Î¹ : sort u_1} [Nonempty Î¹] {F : Î¹ â†’ Ennreal} {x : Ennreal} (h : x â‰  âŠ¤) : x * infi F = â¨… (i : Î¹), x * F i
{Î± : Type u} {m : â„•} (x : Î±) (u : Fin m.Succ â†’ Î±) : Matrix.vec_Cons x u 1 = Matrix.vec_head u
{Î± : Type u_1} {Î¹ : Type u_3} [Distrib_Lattice Î±] [OrderBot Î±] {S : Finset Î¹} {F : Î¹ â†’ Î±} : â†‘S.Pairwise_Disjoint F â†’ S.Sup_indep F
{Î± : Type u_1} {Î² : Type u_2} [Nontrivial Î±] {F : Î± â†’ Î²} (hF : Function.Injective F) : Nontrivial Î²
{y : â„} (hy : 0 < y) : Filter.Tendsto (Î» (x : â„), x ^ -y) Filter.at_top (nhds 0)
{G : Type u_1} {P : Type u_2} [AddCommGroup G] [AddTorsor G P] (P1 P2 P3 : P) : P3 -áµ¥ P2 - (P3 -áµ¥ P1) = P1 -áµ¥ P2
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.Normal] (hN : (Fintype.Card â†¥N).IsCoprime N.Index) : âˆƒ (h : Subgroup G), h.Complement' N
{F : â„ â†’ â„} (hF : Differentiable â„ F) (hF' : âˆ€ (x : â„), 0 â‰¤ deriv F x) : Monotone F
{Î± : Type u_1} [has_LT Î±] [DecidableEq Î±] (A B : Finset Î±) : (A  B).to_colex < (B  A).to_colex â†” A.to_colex < B.to_colex
(r n : â„•) : n.choose r â‰¤ n.choose (n / 2)
{R : Type u} [CommSemiring R] [Nontrivial R] (h : âˆ€ (A B : R), A âˆˆ Nonunits R â†’ B âˆˆ Nonunits R â†’ A + B âˆˆ Nonunits R) : local_Ring R
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) {P : P} {r : â„} (hr : âˆ€ (i : Fin (n + 1)), HasDist.dist (S.points i) P = r) : â†‘(â‡‘(S.Orthogonal_projection_Span) P) = S.circumcenter
{Î± : Type u} [AddZeroClass Î±] : _AddMonoid_hom Id
{m : Type u_1} [comm_Group m] (F : â„• â†’ m) (n : â„•) : (Finset.Range n).Prod (Î» (i : â„•), F (i + 1) * (F i)â»Â¹) = F n * (F 0)â»Â¹
{F : â„• â†’ â„•} (hF : Function.Injective F) : Filter.Tendsto F Filter.at_top Filter.at_top
{C : Type u} [CategoryTheory.Category C] (P : Cáµ’áµ– â¥¤ Type v) [P.representable] : CategoryTheory.Presieve._sheaf (CategoryTheory.sheaf.canonical_topology C) P
{Î± : Type u_1} (n : â„•) (S : Finset Î±) : (Finset.powerset_len n S).Card = S.Card.choose n
(R : Type u) (m : Type v) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] : module.rank R m = Cardinal.Mk (module.free.choose_Basis_Index R m)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {S : set ð•œ} {n : WithTop â„•} {m : â„•} (h : ContDiff_on ð•œ n F S) (hmn : â†‘m < n) (hs : UniqueDiffOn ð•œ S) : DifferentiableOn ð•œ (iterated_deriv_within m F S) S
{k : Type u_1} {v1 : Type u_2} {v2 : Type u_4} [Ring k] [AddCommGroup v1] [module k v1] [AddCommGroup v2] [module k v2] (F : v1 â†’áµƒ[k] v2) : â‡‘(F.Linear) = â‡‘F - Î» (z : v1), â‡‘F 0
{Î± : Type u_1} (v : Vector Î± 1) : v.tail = Vector.Nil
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] {F : Type v} [NormedGroup F] [NormedSpace â„‚ F] {F : E â†’ F} (hF : Differentiable â„‚ F) (hb : Metric.Bounded (set.Range F)) : âˆƒ (C : F), âˆ€ (z : E), F z = C
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’ ð•œ) {S : Finset Î¹} {i : Î¹} (hi : i âˆˆ S) : HasInner.inner (v i) (S.Sum (Î» (i : Î¹), l i â€¢ v i)) = l i
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} : metric.Hausdorff_dist S (Closure t) = metric.Hausdorff_dist S t
{R : Type u_1} [CommSemiring R] (m : Submonoid R) (S : Type u_2) [CommSemiring S] [Algebra R S] [IsLocalization m S] (J : Ideal S) : J.Prime â†” (Ideal.comap (Algebra_Map R S) J).Prime âˆ§ Disjoint â†‘m â†‘(Ideal.comap (Algebra_Map R S) J)
{x : top} (F : top.Presheaf (Type v) x) (Fsh : F._sheaf) : F._sheaf_Unique_gluing
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (ht : âˆ€ (y : Î²), y âˆ‰ t â†’ (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x) â‰¤ 0) (hb : t.Card â€¢ B < S.Sum (Î» (x : Î±), W x)) : âˆƒ (y : Î²) (h : y âˆˆ t), B < (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x)
{E : Type u_2} {ð•œ : Type u_3} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul ð•œ E] {S : set E} (hs : Convex ð•œ S) : Convex ð•œ (Closure S)
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] {Î¹ : sort u_2} (P : Î¹ â†’ Submodule R m) {C : m â†’ Prop} {x : m} (hx : x âˆˆ â¨† (i : Î¹), P i) (hp : âˆ€ (i : Î¹) (x : m), x âˆˆ P i â†’ C x) (h0 : C 0) (HAdd : âˆ€ (x y : m), C x â†’ C y â†’ C (x + y)) : C x
{Î± : Type u_1} [LinearOrder Î±] (A B : Finset Î±) : (A  B).to_colex â‰¤ (B  A).to_colex â†” A.to_colex â‰¤ B.to_colex
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e : LocalHomeomorph Î± Î²} {S : set Î±} {t : set Î²} : e._image S t â†’ e.to_local_Equiv.Source âˆ© â‡‘e â»Â¹' (e.to_local_Equiv.Target âˆ© t) = e.to_local_Equiv.Source âˆ© S
{R : Type u_1} {Î¹ : Type u_2} {mâ‚‚ : Type u_4} {mâ‚ƒ : Type u_5} [CommSemiring R] [AddCommMonoid mâ‚‚] [AddCommMonoid mâ‚ƒ] [module R mâ‚‚] [module R mâ‚ƒ] [DecidableEq Î¹] [Fintype Î¹] {F g : MultilinearMap R (Î» (i : Î¹), mâ‚‚) mâ‚ƒ} {Î¹â‚ : Type u_3} (e : Basis Î¹â‚ R mâ‚‚) (h : âˆ€ (v : Î¹ â†’ Î¹â‚), â‡‘F (Î» (i : Î¹), â‡‘e (v i)) = â‡‘g (Î» (i : Î¹), â‡‘e (v i))) : F = g
{K : Type u} [hfield : Field K] {L : Type u_1} [Field L] (F : K â†’+* L) (A : L) {x y : Ratfunc K} (hx : Polynomial.Evalâ‚‚ F A x.denom â‰  0) (hy : Polynomial.Evalâ‚‚ F A y.denom â‰  0) : Ratfunc.Eval F A (x + y) = Ratfunc.Eval F A x + Ratfunc.Eval F A y
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (hs : IsCompact S) {F : Filter Î±} (hF : âˆ€ (A : Î±), A âˆˆ S â†’ Sá¶œ âˆˆ nhds A âŠ“ F) : Sá¶œ âˆˆ F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] (F : top.Presheaf C x) (x : â†¥x) (t : â†¥(F.stalk x)) : âˆƒ (U : TopologicalSpace.Opens â†¥x) (m : x âˆˆ U) (S : â†¥(F.obj (Opposite.Op U))), â‡‘(F.germ âŸ¨x, mâŸ©) S = t
{Î± : Type u_1} {A B : Finset Î±} (i : â„•) (hâ‚ : i + B.Card â‰¤ A.Card) (hâ‚‚ : B âŠ† A) : âˆƒ (C : Finset Î±), B âŠ† C âˆ§ C âŠ† A âˆ§ C.Card = i + B.Card
(ð•œ : Type u) [nondiscrete_NormedField ð•œ] (E : Type v) [NormedGroup E] [NormedSpace ð•œ E] [ProperSpace ð•œ] [Finite_dimensional ð•œ E] : ProperSpace E
{Î± : Type u_2} [AddMonoid Î±] (m : Î±) : (âˆƒ (C : Î±), m = 2 â€¢ C) â†’ Even m
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : Convex_on ð•œ S F) {x y : E} (hx : x âˆˆ S) (hy : y âˆˆ S) {A B : ð•œ} (ha : 0 â‰¤ A) (hb : 0 â‰¤ B) (hab : A + B = 1) : F (A â€¢ x + B â€¢ y) â‰¤ LinearOrder.max (F x) (F y)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} {u v : E} (hu : u âˆˆ K) (hv : v âˆˆ Ká—®) : HasInner.inner v u = 0
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S : set Î±} (hb : BddBelow S) (ha : BddAbove S) (Ne : S.Nonempty) : HasInf.Inf S â‰¤ HasSup.Sup S
{C : Type uâ‚} [CategoryTheory.Category C] {P x Y Z : C} {fst : P âŸ¶ x} {Snd : P âŸ¶ Y} {F : x âŸ¶ Z} {g : Y âŸ¶ Z} (W : CategoryTheory.CommSq fst Snd F g) (h : CategoryTheory.Limits.IsLimit W.cone) : CategoryTheory.IsPullback fst Snd F g
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] (A : Î±) {B : Î±} : 0 â‰¤ B â†’ A - B â‰¤ A
{n : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [IsCyclotomicExtension {n} K L] (hirr : Irreducible (Polynomial.cyclotomic â†‘n K)) [Ne_Zero â†‘â†‘n] : Finite_dimensional.finrank K L = â†‘n.Totient
{R : Type u} {L : Type v} {m : Type W} [CommRing R] [lie_Ring L] [lie_Algebra R L] [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] {Nâ‚ : lie_Submodule R L m} (h : Nâ‚.centralizer = Nâ‚) (k : â„•) : lie_Submodule.ucs k âŠ¥ â‰¤ Nâ‚
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (h : Subgroup G) {F : N â†’* G} (hF : Function.Surjective â‡‘F) : Subgroup.comap F h.Normalizer = (Subgroup.comap F h).Normalizer
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m â†’+ P} (h : C â‰¤ Add_Con.Ker F) (x : m) : â‡‘(C.Lift F h) (â‡‘(C.Mk') x) = â‡‘F x
{v : Type u_1} [InnerProductSpace â„ v] (x : v) : InnerProductGeometry.angle x 0 = Real.Pi / 2
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚‚} [CategoryTheory.Category K] (F : J â¥¤ K) {jâ‚ jâ‚‚ : J} (h : CategoryTheory.Zigzag jâ‚ jâ‚‚) : CategoryTheory.Zigzag (F.obj jâ‚) (F.obj jâ‚‚)
(R : Type u_1) [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {C : module.Ray R m â†’ Prop} (h : âˆ€ (v : m) (hv : v â‰  0), C (Ray_of_Ne_Zero R v hv)) (x : module.Ray R m) : C x
{P x : â„} (h : LiouvilleWith P x) (hp : 1 < P) : Irrational x
{R : Type u_1} [AddZeroClass R] : IsAddRegular 0
(m : Type u_1) (Î± : Type u_2) [Group m] [MulAction m Î±] : GaloisConnection (â‡‘order_dual.to_dual âˆ˜ fixing_Subgroup m) ((Î» (P : Subgroup m), MulAction.FixedPoints â†¥P Î±) âˆ˜ â‡‘order_dual.of_dual)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} (P : Î¹ â†’ P) : AffineIndependent k P â†” âˆ€ (S : Finset Î¹) (W : Î¹ â†’ k), S.Sum (Î» (i : Î¹), W i) = 0 â†’ â‡‘(S.weighted_vsub P) W = 0 â†’ âˆ€ (i : Î¹), i âˆˆ S â†’ W i = 0
{R : Type u_1} [Mul_Zero_class R] [Nontrivial R] : Â¬IsRegular 0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {x : E} {n : WithTop â„•} (h : ContDiff_within_at ð•œ n F S x) (hn : 1 â‰¤ n) : Differentiable_within_at ð•œ F (HasInsert.Insert x S) x
{Î± : Type u} [TopologicalSpace Î±] [LocallyCompactSpace Î±] [t2_Space Î±] {K : set Î±} (hK : IsCompact K) : âˆƒ (v : set Î±), IsOpen v âˆ§ K âŠ† v âˆ§ IsCompact (Closure v)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {S : set Î±} {P : Filter Î¹} [P.Ne_IsBot] (hF : uniform_Cauchy_Seq_on F P S) (hF' : âˆ€ (x : Î±), x âˆˆ S â†’ Filter.Tendsto (Î» (n : Î¹), F n x) P (nhds (F x))) : TendstoUniformlyOn F F P S
{Î± : Type u} [PseudoEmetricSpace Î±] {x : Î±} {S : set Î±} : Emetric.Inf_edist x (Closure S) = Emetric.Inf_edist x S
{Î± : Type u_1} {Î¹ : Type u_2} (S : Î¹ â†’ set Î±) : (â¨… (i : Î¹), Filter.principal (S i)).has_Basis (Î» (t : set Î¹), t.Finite) (Î» (t : set Î¹), â‹‚ (i : Î¹) (h : i âˆˆ t), S i)
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {C : â„‚} {R : â„} (h0 : 0 < R) {F : â„‚ â†’ E} {y : E} {S : set â„‚} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C R  {C})) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball C R  {C}  S â†’ Differentiable_at â„‚ F z) (hy : Filter.Tendsto F (nhds_within C {C}á¶œ) (nhds y)) : âˆ® (z : â„‚) in C(C, R), (z - C)â»Â¹ â€¢ F z = (2 * â†‘Real.Pi * Complex.i) â€¢ y
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B : Î±} (ha : 0 â‰¤ A) (hb : 0 < B) : 0 < A + B
{P q r : Prop} (hâ‚ : Implies P q) (hâ‚‚ : Implies q r) : Implies P r
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra R A] [Algebra R B] (F : A â‰ƒâ‚[R] B) : (integral_Closure R A).Map â†‘F = integral_Closure R B
{Î± : Type u} [PartialOrder Î±] [Decidable_Rel has_LE.LE] {A B : Î±} (hab : A â‰¤ B) : A < B âˆ¨ A = B
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [TopologicalSpace Î±] [UniformSpace Î²] {F : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {P : Filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} (hÎ± : âˆ€ (x : Î±), âˆƒ (n : set Î±), IsCompact n âˆ§ n âˆˆ nhds x) (h : Filter.Tendsto F P (nhds F)) : TendstoLocallyUniformly (Î» (i : Î¹) (A : Î±), â‡‘(F i) A) â‡‘F P
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} : A - B < 0 â†’ A < B
(k : Type u_1) [DivisionRing k] {Î¹ : Type u_4} (S : Finset Î¹) (i : Î¹) : Finset.centroid_weights k S i = (â†‘(S.Card))â»Â¹
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [NormedSpace ð•œ E'] {n : WithTop â„•} {F : E â†’ E'} {x : E} : Cont_mdiff_at (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') n F x â†’ ContDiff_at ð•œ n F x
{Î± : Type u} [Preorder Î±] {A B C : Î±} (hab : A â‰¤ B) (hbc : B = C) : A â‰¤ C
(m : â„¤) {n : â„¤} (hn : 0 < n) : (âˆƒ (k : â„¤), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m
{F : Type v} [NormedGroup F] [NormedSpace â„‚ F] [CompleteSpace F] {R : â„} {C : â„‚} {F : â„‚ â†’ F} (hR : 0 < R) (hF : Diff_Cont_on_cl â„‚ F (Metric.Ball C R)) : deriv F C = (2 * â†‘Real.Pi * Complex.i)â»Â¹ â€¢ âˆ® (z : â„‚) in C(C, R), (z - C) ^ -2 â€¢ F z
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {Î¹ : Type u_6} [DecidableEq Î¹] {mâ‚‚ : Type u_7} [AddCommMonoid mâ‚‚] [module R mâ‚‚] (F : mâ‚‚ â†’â‚—[R] m) (hF : Function.Surjective â‡‘F) : Function.Injective (Î» (g : AlternatingMap R m N Î¹), g.Comp_Linear_Map F)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) [CategoryTheory.IsIso h.Unit] : CategoryTheory.Faithful L
{mâ‚ : Type u_3} {mâ‚‚ : Type u_4} [AddCommGroup mâ‚] [AddCommGroup mâ‚‚] {R : Type u_1} [ordered_Ring R] [module R mâ‚] [module R mâ‚‚] {qâ‚ : QuadraticForm R mâ‚} {qâ‚‚ : QuadraticForm R mâ‚‚} (h : (qâ‚.Prod qâ‚‚).anisotropic) : qâ‚.anisotropic âˆ§ qâ‚‚.anisotropic
(m : â„•+) (P : Nat.Primes) (k : â„•) : â†‘P ^ k âˆ£ m â†” k â‰¤ Multiset.count P m.factor_Multiset
{R : Type} [CommRing R] [CharZero R] {D : â„¤} (r : {r // r * r = â†‘D}) (hD : âˆ€ (n : â„¤), D â‰  n * n) : Function.Injective â‡‘(â‡‘Zsqrtd.Lift r)
(v : Type u_2) {P : Type u_3} [semi_NormedGroup v] [PseudoMetricSpace P] [NormedAddTorsor v P] (x y : P) : HasDist.dist x y = âˆ¥x -áµ¥ yâˆ¥
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] (P : Polynomial ð•œ) (x : ð•œ) : HasStrictDerivAt (Î» (x : ð•œ), Polynomial.Eval x P) (Polynomial.Eval x (â‡‘Polynomial.derivative P)) x
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] (v : PicardLindelof E) [CompleteSpace E] : âˆƒ (F : â„ â†’ E), F â†‘(v.tâ‚€) = v.xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ set.icc v.t_min v.t_max â†’ HasDerivWithinAt F (â‡‘v t (F t)) (set.icc v.t_min v.t_max) t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (x Y : C) [CategoryTheory.Limits.HasBinaryCoproduct x Y] : CategoryTheory.Limits.HasBinaryBiproduct x Y
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (e : LocalHomeomorph Î± Î²) {x : Î±} (h : x âˆˆ e.to_local_Equiv.Source) : Continuous_at â‡‘e x
{Î± : Type u} (F : Filter Î±) [h : F.Ne_IsBot] : âˆƒ (u : Ultrafilter Î±), â†‘u â‰¤ F
{R : Type u} {m : Type v} {mâ‚‚ : Type W} {mâ‚ƒ : Type y} [Semiring R] [AddCommMonoid m] [AddCommMonoid mâ‚‚] [AddCommMonoid mâ‚ƒ] [module R m] [module R mâ‚‚] [module R mâ‚ƒ] {F g : m Ã— mâ‚‚ â†’â‚—[R] mâ‚ƒ} (hl : F.Comp (LinearMap.inl_ R m mâ‚‚) = g.Comp (LinearMap.inl_ R m mâ‚‚)) (hr : F.Comp (LinearMap.inr_ R m mâ‚‚) = g.Comp (LinearMap.inr_ R m mâ‚‚)) : F = g
(C : Type u) [CategoryTheory.Category C] [âˆ€ {x Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair x Y)] : CategoryTheory.Limits.HasBinaryCoproducts C
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {A B : Matrix n n R} (C : n â†’ R) (k : n) (hk : C k = 0) (A_Eq : âˆ€ (i j : n), A i j = B i j + C i * B k j) : A.det = B.det
{n : â„•} {P q : â„• Ã— â„•} (hp : P âˆˆ Finset.Nat.antidiagonal n) (hq : q âˆˆ Finset.Nat.antidiagonal n) : P = q â†” P.fst = q.fst
{n : â„•} [hpos : Fact (0 < n)] (i : Zmod (2 * n)) : order_of (Quaternion_Group.xa i) = 4
{Î² : Type u} {Î± : Type v} [AddCommMonoid Î²] [Fintype Î±] [DecidableEq Î±] (S : Finset Î±) (F : Î± â†’ Î²) : S.Sum (Î» (i : Î±), F i) + Sá¶œ.Sum (Î» (i : Î±), F i) = Finset.Univ.Sum (Î» (i : Î±), F i)
{R : Type u_1} {A B : R} [Add_comm_Semigroup R] : IsAddRegular (A + B) â†” IsAddRegular A âˆ§ IsAddRegular B
{Î± : Type u} [TopologicalSpace Î±] {S U : set Î±} (h : âˆ€ (x : Î±), x âˆˆ S â†’ U âˆˆ nhds x) : âˆƒ (v : set Î±), S âŠ† v âˆ§ IsOpen v âˆ§ v âŠ† U
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : IsCompact S â†” âˆ€ {Î¹ : Type u} (U : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ (S âŠ† â‹ƒ (i : Î¹), U i) â†’ (âˆƒ (t : Finset Î¹), S âŠ† â‹ƒ (i : Î¹) (h : i âˆˆ t), U i)
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B : Î±} (ha : 1 â‰¤ A) (hb : 1 < B) : 1 < A * B
{Î± : Type u} {S t : set Î±} {l : Filter Î±} : S =á¶ [l] t â†’ (âˆ€á¶  (x : Î±) in l, x âˆˆ S â†” x âˆˆ t)
{Î± : Type u} {F g : Î± â†’ Î±} {x : Î±} (hfg : Function.IsFixedPt (F âˆ˜ g) x) (hg : Function.IsFixedPt g x) : Function.IsFixedPt F x
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) (Î¸ : Real.Angle) : o.oangle (â‡‘(o.rotation Î¸) x) (â‡‘(o.rotation Î¸) y) = o.oangle x y
{S : set Ordinal} (hS : set.Unbounded has_LT.LT S) {o : Ordinal} : {x : Ordinal | x âˆˆ S âˆ§ âˆ€ (C : Ordinal), C < o â†’ Ordinal.enum_Ord S C < x}.Nonempty
{R : Type u_1} {m : Type u_2} {P : Type u_3} {N : Type W} [Ring R] [AddCommGroup m] [module R m] [AddCommGroup N] [module R N] [AddCommGroup P] [module R P] [IsNoetherian R m] [IsNoetherian R P] (F : m â†’â‚—[R] N) (g : N â†’â‚—[R] P) (hF : Function.Injective â‡‘F) (hg : Function.Surjective â‡‘g) (h : F.Range = g.Ker) : IsNoetherian R N
{R : Type u_1} [CommRing R] {G : module R} {x y : CategoryTheory.Over G} (h : CategoryTheory.Abelian.PseudoEqual G x y) : LinearMap.Range x.hom = LinearMap.Range y.hom
{m : Type u_2} [AddCommGroup m] {ð•œ : Type u_1} [Field ð•œ] [module ð•œ m] (F : m â†’â‚—[ð•œ] m) (hF : â‡‘LinearMap.det F â‰  1) : Finite_dimensional ð•œ m
{Î± : Type u} {Î² : Type v} (F : Î± â†’ Î²) {l : List Î±} {n : â„•} (h : n < l.length) : F (l.nth_LE n h) = (List.Map F l).nth_LE n _
(ð•œ : Type u_5) (ð•œ' : Type u_6) [NormedField ð•œ] [semi_NormedRing ð•œ'] [normed_Algebra ð•œ ð•œ'] [NormOneClass ð•œ'] : Isometry â‡‘(Algebra_Map ð•œ ??')
(x y z : Pgame) : (x * (y + z)).Equiv (x * y + x * z)
{Î± : Type u_1} {Î¹ : sort u_4} {S : set Î±} {t : Î¹ â†’ set Î±} (i : Î¹) (h : S âŠ† t i) : S âŠ† â‹ƒ (i : Î¹), t i
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {E : Type uâ‚ƒ} [CategoryTheory.Category E] {F : C â¥¤ D} {G : D â¥¤ E} {h : C â¥¤ E} [â„‹ : CategoryTheory.Faithful h] (h : F â‹™ G = h) : CategoryTheory.Faithful F
{y : â„} (hy : 0 < y) : Filter.Tendsto (Î» (x : â„), x ^ y) Filter.at_top Filter.at_top
{A B : â„¤} (W : A âˆ£ B) (h : B.Nat_Abs < A.Nat_Abs) : B = 0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} (hn : 2 â‰¤ n + 1) (P : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) {r A C : â„} (hr : 0 â‰¤ r) (ha : 0 â‰¤ A) (hC : 0 â‰¤ C) (hp : âˆ€ (n : â„•), âˆ¥P nâˆ¥ â‰¤ C * r ^ n) : (Finset.Ico 1 (n + 1)).Sum (Î» (k : â„•), A ^ k * âˆ¥P.Right_Inv i kâˆ¥) â‰¤ âˆ¥â†‘(i.Symm)âˆ¥ * A + âˆ¥â†‘(i.Symm)âˆ¥ * C * (Finset.Ico 2 (n + 1)).Sum (Î» (k : â„•), (r * (Finset.Ico 1 n).Sum (Î» (j : â„•), A ^ j * âˆ¥P.Right_Inv i jâˆ¥)) ^ k)
(F : C(â†¥Unit_Interval, â„)) : Filter.Tendsto (Î» (n : â„•), bernstein_approximation n F) Filter.at_top (nhds F)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {n : WithTop â„•} {P : E â†’ FormalMultilinearSeries ð•œ E F} (hF : HasFtaylorSeriesUpToOn n F P S) {g : E â†’ G} {q : E â†’ FormalMultilinearSeries ð•œ E G} (hg : HasFtaylorSeriesUpToOn n g q S) : HasFtaylorSeriesUpToOn n (Î» (y : E), (F y, g y)) (Î» (y : E) (k : â„•), (P y k).Prod (q y k)) S
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x : Î±} : metric.Inf_dist x (Closure S) = metric.Inf_dist x S
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} [DecidableEq Î±] (h : free_Group.red Lâ‚ Lâ‚‚) : free_Group.reduce Lâ‚ = free_Group.reduce Lâ‚‚
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] {A B : Î±} : A < Bâ»Â¹ â†’ B < Aâ»Â¹
{m n : â„•} : (âˆ€ (A : â„•), A âˆ£ m â†” A âˆ£ n) â†” m = n
{n : â„•} : (Fin.Last n).Succ_above = Fin.cast_Succ
 : Convex_on â„ set.Univ Real.Exp
{x : Type u_2} {Y : Type u_3} [TopologicalSpace x] [TopologicalSpace Y] [TopologicalSpace.metrizable_Space Y] {F : x â†’ Y} (hF : Embedding F) : TopologicalSpace.metrizable_Space x
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} {n : â„•} {ifp_Succ_n : GeneralizedContinuedFraction.Int_fract_pair K} : GeneralizedContinuedFraction.Int_fract_pair.Stream v (n + 1) = Option.Some ifp_Succ_n â†” âˆƒ (ifp_n : GeneralizedContinuedFraction.Int_fract_pair K), GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n âˆ§ ifp_n.fr â‰  0 âˆ§ GeneralizedContinuedFraction.Int_fract_pair.of (ifp_n.fr)â»Â¹ = ifp_Succ_n
{F : Type} [Field F] (q : â„•) {F : Polynomial F} (hF : Polynomial.has_IsSeparable_contraction q F) [hF : ExpChar F q] (g : Polynomial F) (hg : Polynomial._IsSeparable_contraction q F g) : g.Nat_degree = hF.degree
{n : â„•} {Î± : Type u_1} {v : Vector Î± (n + 1)} : v.reverse.head = v.Last
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) {râ‚ râ‚‚ : â„} (hrâ‚ : 0 â‰¤ râ‚) (hrâ‚‚ : 0 â‰¤ râ‚‚) : o.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
(G : Pgame) [G.Impartial] : G.Equiv (nim G.grundy_value)
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (h : Add_Subgroup G) (F : G â‰ƒ+ N) : Add_Subgroup.Map F.to_AddMonoid_hom h.Normalizer = (Add_Subgroup.Map F.to_AddMonoid_hom h).Normalizer
{C : Type uâ‚} [CategoryTheory.Category C] {Z x Y P : C} {F : Z âŸ¶ x} {g : Z âŸ¶ Y} {inl_ : x âŸ¶ P} {inr_ : Y âŸ¶ P} (W : CategoryTheory.CommSq F g inl_ inr_) (h : CategoryTheory.Limits.IsColimit W.Cocone) : CategoryTheory.IsPushout F g inl_ inr_
{Î± : Type u} [Preorder Î±] {A B C : Î±} : A â‰¤ B â†’ B â‰¤ C â†’ A â‰¤ C
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] (not_TerminatedAt_n : Â¬(GeneralizedContinuedFraction.of v).TerminatedAt n) : (GeneralizedContinuedFraction.of v).numerators n * (GeneralizedContinuedFraction.of v).denominators (n + 1) - (GeneralizedContinuedFraction.of v).denominators n * (GeneralizedContinuedFraction.of v).numerators (n + 1) = (-1) ^ (n + 1)
{Î± : Type u} [AddGroup Î±] : _AddGroup_hom Id
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] (F : P1 â†’áµƒ[k] P2) (P1 P2 : P1) : â‡‘(F.Linear) (P1 -áµ¥ P2) = â‡‘F P1 -áµ¥ â‡‘F P2
{m : Type u_1} [CommMonoid m] {S : set m} (hs : _Submonoid S) (m : Multiset m) : (âˆ€ (A : m), A âˆˆ m â†’ A âˆˆ S) â†’ m.Prod âˆˆ S
{ð•œ : Type u} [hnorm : nondiscrete_NormedField ð•œ] {E : Type v} [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul ð•œ E] (l : E â†’â‚—[ð•œ] ð•œ) (hl : IsClosed â†‘(l.Ker)) : Continuous â‡‘l
{A : â„} {l : Filter â„} {F g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhds_within A (set.ioi A), Differentiable_at â„ F x) (hg' : âˆ€á¶  (x : â„) in nhds_within A (set.ioi A), deriv g x â‰  0) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.ioi A)) (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), deriv F x / deriv g x) (nhds_within A (set.ioi A)) l) : Filter.Tendsto (Î» (x : â„), F x / g x) (nhds_within A (set.ioi A)) l
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type uâ‚‚} [CategoryTheory.Category D] [CategoryTheory.Abelian D] (F : C â¥¤ D) (G : D â¥¤ C) [G.preserves_Zero_morphisms] (i : F â‹™ G â‰… ðŸ­ C) (Adj : G âŠ£ F) : CategoryTheory.Limits.HasCokernels C
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x y : E} : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * â‡‘_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] (F : J â¥¤ Type u) [hF : Î  (j : J), Fintype (F.obj j)] [hne : âˆ€ (j : J), Nonempty (F.obj j)] : F.sections.Nonempty
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : EuclideanGeometry.Orthogonal_projection_fn S P âˆˆ S
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [Linear_ordered_AddCommGroup Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_IsBot) : Filter.Tendsto (Î» (x : Î²), F x + g x) l Filter.at_IsBot
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = Real.Pi) : EuclideanGeometry.angle P2 P3 P1 = 0
{R : Type u_1} [OrderedSemiring R] [Nontrivial R] : CharZero R
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_at F A) (hb : Continuous_at F B) : HasStrictFderivAt (Î» (P : â„ Ã— â„), âˆ« (x : â„) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd â„ â„ â„).Smul_Right (F B) - (Continuous_Linear_Map.fst â„ â„ â„).Smul_Right (F A)) (A, B)
{R : Type u_3} {S : Type u_4} {A : Type u_5} [CommRing R] [CommRing S] [CommRing A] [Algebra R S] [Algebra S A] [Algebra R A] [IsScalarTower R S A] (hinj : Function.Injective â‡‘(Algebra_Map R S)) {x : A} (A_alg : IsAlgebraic R x) : IsAlgebraic S x
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] {gp : GeneralizedContinuedFraction.Pair K} (nth_S_Eq : (GeneralizedContinuedFraction.of v).S.nth n = Option.Some gp) : gp.A = 1 âˆ§ âˆƒ (z : â„¤), gp.B = â†‘z
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (W : Î¹ â†’ k) (P : Î¹ â†’ P) : â‡‘(âˆ….weighted_vsub P) W = 0
{A : Type u_5} [CommRing A] {m : Type u_6} {n : Type u_7} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] {m : Matrix n m A} {N m' : Matrix m n A} (hMM' : m.Mul m' = 1) (hM'm : m'.Mul m = 1) : (m.Mul N).det = (N.Mul m).det
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Nontrivial R] (e : Basis Î¹ R m) (i : Î¹) : (e.units_Smul (Function.update 1 i (-1))).Orientation = -e.Orientation
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D â¥¤ C} [CategoryTheory.Reflective i] {A : C} (h : A âˆˆ i.EssImage) : CategoryTheory.IsIso ((CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App A)
{mâ‚€ : Type u_1} [Mul_Zero_class mâ‚€] [no_Zero_divisors mâ‚€] {A B : mâ‚€} : 0 = A * B â†” A = 0 âˆ¨ B = 0
{Î± : Type u_1} : Vector.Nil.tail = Vector.Nil
{ð•œ : Type u_1} {Î± : Type u_2} [Linear_ordered_Field ð•œ] [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {r : â„•} (hr : r â‰  0) (hð’œ : set.sized r â†‘ð’œ) : â†‘(ð’œ.Card) / â†‘((Fintype.Card Î±).choose r) â‰¤ â†‘(ð’œ.shadow.Card) / â†‘((Fintype.Card Î±).choose (r - 1))
{Î± : Type u} : Dense_Inducing has_pure.pure
{Î± : Type u_1} {Î² : Type u_2} [Group Î±] [division_Monoid Î²] (F : Î± â†’* Î²) (A : Î±) : â‡‘F Aâ»Â¹ = (â‡‘F A)â»Â¹
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] [_Pred_Archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.ioc m n â†’ r i (Order.Pred i)) (hnm : m â‰¤ n) : Relation.refl_Trans_gen r n m
 : Exp_Neg_Inv_glue.F_aux 0 = Exp_Neg_Inv_glue
(k : â„•) {B : â„} (hb : 0 < B) : (Î» (x : â„), x ^ k) =o[Filter.at_top] Î» (x : â„), Real.Exp (B * x)
{R : Type u_1} [comm_Group R] {F g : â„• â†’ R} : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.Prod (Î» (i : â„•), F i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.Prod (Î» (x : â„• Ã— â„•), g x.Snd ^ â‡‘Nat.ArithmeticFunction.moebius x.fst) = F n
{Râ‚‚ : Type u_5} {mâ‚‚ : Type u_6} [CommSemiring Râ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚‚ mâ‚‚] {Bâ‚‚ Fâ‚‚ : BilinForm Râ‚‚ mâ‚‚} {Î¹ : Type u_13} (B : Basis Î¹ Râ‚‚ mâ‚‚) (h : âˆ€ (i j : Î¹), â‡‘Bâ‚‚ (â‡‘B i) (â‡‘B j) = â‡‘Fâ‚‚ (â‡‘B i) (â‡‘B j)) : Bâ‚‚ = Fâ‚‚
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : InnerProductGeometry.angle (-x) y = Real.Pi - InnerProductGeometry.angle x y
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (v : v) (n : v â‰  0) (h : âˆ€ (W : v), âˆƒ (C : K), C â€¢ v = W) : Finite_dimensional.finrank K v = 1
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] {F g : Equiv.perm Î±} (hF : F._Cycle) (hg : g._Cycle) (h : âˆ€ (x : Î±), x âˆˆ F.Support âˆ© g.Support â†’ â‡‘F x = â‡‘g x) {x : Î±} (hx : â‡‘F x = â‡‘g x) (hx' : x âˆˆ F.Support) : F = g
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {F : Î± â†’ Î²} {x : Î±} (hF : _Ring_hom F) : F (-x) = -F x
(F : Type u_1) [Field F] (E : Type u_2) [Field E] [Algebra F E] [Fintype F] [Finite_dimensional F E] : âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 : P) : EuclideanGeometry.angle P1 P1 P2 = Real.Pi / 2
{Î± : Type u_1} {A B : set (Finset Î±)} {r : â„•} : set.sized r A âˆ§ set.sized r B â†’ set.sized r (A âˆª B)
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {F : m â†’+ P} (x : m) : â‡‘(Add_Con.Ker F) x = â‡‘F â»Â¹' {â‡‘F x}
{n : â„•} (i : Zmod n) : order_of (dihedral_Group.sr i) = 2
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [HasScalar ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : Convex_on ð•œ S F) (C : E) : Convex_on ð•œ ((Î» (z : E), C + z) â»Â¹' S) (F âˆ˜ Î» (z : E), C + z)
{Î± : Type u} (S : set (set Î±)) : {t : set Î± | MeasurableSpace.generate_Measurable S t} = â‹ƒ (i : (Quotient.out (Cardinal.aleph 1).Ord).Î±), MeasurableSpace.generate_Measurable_rec S i
{x : â„} : (âˆ€ (P : â„), LiouvilleWith P x) â†” Liouville x
{m : Type u_1} {A : Type u_2} [CommMonoid m] {S : set m} (hs : _Submonoid S) (F : A â†’ m) (t : Finset A) : (âˆ€ (B : A), B âˆˆ t â†’ F B âˆˆ S) â†’ t.Prod (Î» (B : A), F B) âˆˆ S
{Î± : sort u} {Î² : sort v} : Function.Injective Coe_fn
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x z - o.oangle y z = o.oangle x y
{Î± : Type u} [t : TopologicalSpace Î±] {B : set (set Î±)} (hB : TopologicalSpace._topological_Basis B) {u : set Î±} (ou : IsOpen u) : u = â‹ƒâ‚€{S âˆˆ B | S âŠ† u}
{Î± : Type u_1} [Preorder Î±] [SuccOrder Î±] {A B : Î±} [NoMaxOrder Î±] : Order.Succ A â‰¤ Order.Succ B â†’ A â‰¤ B
{R : Type u} {A : Type v} {B : Type W} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B] [Subsingleton (Subalgebra R A)] : Subsingleton (A â†’â‚[R] B)
{m n : â„•} : m âˆ£ n + m â†” m âˆ£ n
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {t : Finset v} (h : Finite_dimensional.finrank K v + 1 < t.Card) : âˆƒ (F : v â†’ K), t.Sum (Î» (e : v), F e â€¢ e) = 0 âˆ§ t.Sum (Î» (e : v), F e) = 0 âˆ§ âˆƒ (x : v) (h : x âˆˆ t), F x â‰  0
{Î¹ : Type W} {Î¹' : Type W'} {R : Type u} [Ring R] [invariant_Basis_number R] {m : Type v} [AddCommGroup m] [module R m] (v : Basis Î¹ R m) (v' : Basis Î¹' R m) : (Cardinal.Mk Î¹).Lift = (Cardinal.Mk Î¹').Lift
{R : Type u_1} [NormedRing R] {x : R} (h : âˆ¥xâˆ¥ < 1) : Filter.Tendsto (Î» (n : â„•), x ^ n) Filter.at_top (nhds 0)
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) : Prime (minpoly A x)
{L : FirstOrder.Language} {m : Type W} {N : Type u_1} [L.structure m] [L.structure N] {F g : L.hom m N} {S : set m} (h : set.Eq_on â‡‘F â‡‘g S) : set.Eq_on â‡‘F â‡‘g â†‘(â‡‘(FirstOrder.Language.Substructure.Closure L) S)
{Î± : Type u_1} [UniformSpace Î±] : (Uniformity Î±).has_Basis (Î» (v : set (Î± Ã— Î±)), v âˆˆ Uniformity Î± âˆ§ IsOpen v) Id
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} : 0 â‰¤ A - B â†’ B â‰¤ A
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} {t : Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) {q : Type u_4} [CommMonoid q] {k : t.Localization_Map q} (z : N) (u : q) : â‡‘(F.Map hy k) z = u â†” â‡‘(k.to_Map) (â‡‘g (F.sec z).fst) = â‡‘(k.to_Map) (â‡‘g â†‘((F.sec z).Snd)) * u
{P : â„• â†’ Prop} [Decidable_Pred P] {n : â„•} : P n â†’ Nat.count P (n + 1) = Nat.count P n + 1
{Î± : Type u_1} [Preorder Î±] {A B : Î±áµ’áµˆ} : B â©¿ A â†’ â‡‘order_dual.of_dual A â©¿ â‡‘order_dual.of_dual B
{m : Type u_1} [AddMonoid m] {S t : set m} (h : S âŠ† t) : AddMonoid.Closure S âŠ† AddMonoid.Closure t
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î²] [TopologicalSpace Î³] [t2_Space Î³] {F : Î± â†’ Î²} (hfd : DenseRange F) {g h : Î² â†’ Î³} (hg : Continuous g) (hH : Continuous h) (h : g âˆ˜ F = h âˆ˜ F) : g = h
(K : Type u_1) [Field K] [number_Field K] : Â¬_Field â†¥(number_Field.Ring_of_integers K)
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {R : Nnreal} {C : â„‚} {F : â„‚ â†’ E} (hF : Diff_Cont_on_cl â„‚ F (Metric.Ball C â†‘R)) (hR : 0 < R) : HasFpowerSeriesOnBall F (Cauchy_PowerSeries F C â†‘R) C â†‘R
(A B : â„•) : A - B.Succ = A - B - 1
{x : Type u_1} {Y : Type u_2} [tY : TopologicalSpace Y] [DiscreteTopology Y] {F : x â†’ Y} (hF : Function.Injective F) : DiscreteTopology x
{ð•œ : Type u_3} [Field ð•œ] {r : â„•} (m : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ð•œ) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) â‰  0) (i : Fin r) : m.Mul (Matrix.Pivot.List_transvec_row m).Prod (Sum.inr_ ()) (Sum.inl_ i) = 0
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {F : Filter Î±} [IsTrans Î± r] [F.Ne_IsBot] : Filter._bounded r F â†’ Filter._cobounded (Flip r) F
{C : â„} (h1 : 0 < C) (h2 : C < 1 / 2) : Function.Injective (Cardinal.cantor_Function C)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) : o.rotation â†‘Real.Pi = Linear_Isometry_Equiv.Neg â„
(R : Type u_1) [CommRing R] (m n : â„•) : Polynomial.dickson 1 1 (m * n) = (Polynomial.dickson 1 1 m).Comp (Polynomial.dickson 1 1 n)
{Î± : Type u} [LinearOrder Î±] (A B : Î±) : LinearOrder.max A B = A âˆ§ B â‰¤ A âˆ¨ LinearOrder.max A B = B âˆ§ A < B
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [CommMonoid Î²] {S : Finset Î³} {t : Î³ â†’ Finset Î±} {t' : Finset Î±} {S' : Î± â†’ Finset Î³} (h : âˆ€ (x : Î³) (y : Î±), x âˆˆ S âˆ§ y âˆˆ t x â†” x âˆˆ S' y âˆ§ y âˆˆ t') {F : Î³ â†’ Î± â†’ Î²} : S.Prod (Î» (x : Î³), (t x).Prod (Î» (y : Î±), F x y)) = t'.Prod (Î» (y : Î±), (S' y).Prod (Î» (x : Î³), F x y))
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : S1 â‰¤ S2 â†” âˆ€ (P : P), P âˆˆ S1 â†’ P âˆˆ S2
{G : Type u_1} [Group G] {P : â„•} [Fact (Nat.Prime P)] {N : Subgroup G} [N.Normal] [Fintype (Sylow P â†¥N)] (P : Sylow P â†¥N) : (Subgroup.Map N.Subtype â†‘P).Normalizer âŠ” N = âŠ¤
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Semiring R] [AddCommMonoid N] [module R N] [Î  (m : R), Decidable (m â‰  0)] (P : Î¹ â†’ Submodule R N) {v : Î¹ â†’ N} (hv : âˆ€ (i : Î¹), v i âˆˆ P i) : (â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (P i).Subtype)).Comp ((Dfinsupp.Map_Range.Linear_Map (Î» (i : Î¹), Linear_Map.to_Span_Singleton R â†¥(P i) âŸ¨v i, _âŸ©)).Comp (Finsupp_lequiv_Dfinsupp R).to_Linear_Map) = Finsupp.Total Î¹ N R v
{Î± : Type u_1} [PseudoEmetricSpace Î±] (r C : Ennreal) (hr : r < 1) (hC : C â‰  âŠ¤) {F : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasEdist.edist (F n) (F (n + 1)) â‰¤ C * r ^ n) : Cauchy_Seq F
{R : Type u} [Ring R] {S : set R} {t : Subring R} : Subring.Closure S â‰¤ t â†” S âŠ† â†‘t
{Î± : Type u} [PseudoMetricSpace Î±] [ProperSpace Î±] {x : Î±} {r : â„} {S : set Î±} (hr : 0 < r) (hs : IsClosed S) (h : S âŠ† Metric.Ball x r) : âˆƒ (r' : â„) (h : r' âˆˆ set.Ioo 0 r), S âŠ† Metric.Ball x r'
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [Finite_dimensional ð•œ E] [Finite_dimensional ð•œ F] (A : E â†’â‚—[ð•œ] F) (x : E) (y : F) : HasInner.inner x (â‡‘(â‡‘LinearMap.Adjoint A) y) = HasInner.inner (â‡‘A x) y
(ð•œ : Type u_1) {E : Type u_2} [normed_Linear_ordered_Field ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedSpace â„ E] [LinearMap.CompatibleSmul E E ð•œ â„] (h : strict_Convex ð•œ (metric.IsClosed_ball 0 1)) : strict_Convex_Space ð•œ E
{R : Type u_2} {m : Type u_3} [AddCommGroup m] [Ring R] [module R m] {q : QuadraticForm R m} : q.ToFun = â‡‘q
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasEqualizers C] {x Y : C} {F : x âŸ¶ Y} (h : F = 0) [CategoryTheory.Limits.HasImage F] : CategoryTheory.Limits.imageÎ¹ F = 0
{G : Type u_1} [Group G] (h N : Subgroup G) [N.Normal] : â†‘(h âŠ” N) = â†‘h * â†‘N
{K : Type u_1} {n : â„•} {S : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] (TerminatedAt_Succ_n : S.TerminatedAt (n + 1)) : GeneralizedContinuedFraction.squash_Seq S n = S
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) (h : S.Sum (Î» (i : Î¹), W i) = 1) (B : P) : â‡‘(S.affine_combination P) W = â‡‘(S.weighted_vsub_of_point P B) W +áµ¥ B
{Î± : Type u_1} {Î² : Type u_2} {rÎ± : Î± â†’ Î± â†’ Prop} {rÎ² : Î² â†’ Î² â†’ Prop} {A : Î±} {B : Î²} (ha : Acc rÎ± A) (hb : Acc rÎ² B) : Acc (Relation.Game_Add rÎ± rÎ²) (A, B)
{Î¹ : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : Î¹ â†’ set x} (uo : âˆ€ (i : Î¹), IsOpen (u i)) (uf : âˆ€ (x : x), {i : Î¹ | x âˆˆ u i}.Finite) (uU : (â‹ƒ (i : Î¹), u i) = set.Univ) : âˆƒ (v : Î¹ â†’ set x), set.Union v = set.Univ âˆ§ (âˆ€ (i : Î¹), IsClosed (v i)) âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
{C : Type uâ‚} [CategoryTheory.Category C] {t : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] (D : J â¥¤ t.Algebra) [CategoryTheory.Limits.HasLimit (D â‹™ t.Forget)] : CategoryTheory.Limits.HasLimit D
(t : â„) : Filter.Tendsto (Î» (x : â„), (1 + t / x) ^ x) Filter.at_top (nhds (Real.Exp t))
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) (hF'_nonpos : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv F x â‰¤ 0) : Antitone_on F D
{Î± : sort u} {F : Î± â†’ Î±} (h : Function.involutive F) {x y : Î±} : F x = y â†” x = F y
{n : â„•} [Fact (0 < n)] (A : Zmod n) : â†‘(A.val) = A
{n : â„•} (h : n â‰  0) (D : â„•) : âˆƒá¶  (m : â„•) in Filter.at_top, m â‰¡ D [Mod n]
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] {Bâ‚ Bâ‚‚ : Basis Î¹ R m} (h : âˆ€ (x : m) (i : Î¹), â‡‘(â‡‘(Bâ‚.repr) x) i = â‡‘(â‡‘(Bâ‚‚.repr) x) i) : Bâ‚ = Bâ‚‚
{F : â„ â†’ â„} {F' A : â„} (h : IsLocalMin F A) (hF : HasDerivAt F F' A) : F' = 0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {S : set E} [CompleteSpace F] (h : AnalyticOn ð•œ F S) {n : WithTop â„•} : ContDiff_on ð•œ n F S
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] {L : C â¥¤ D} {R : D â¥¤ C} (Adj : L âŠ£ R) : L.initial
{mâ‚€ : Type u_6} [Monoid_with_Zero mâ‚€] [Nontrivial mâ‚€] [no_Zero_divisors mâ‚€] {L : List mâ‚€} : L.Prod = 0 â†” 0 âˆˆ L
{G : Type u_1} [AddGroup G] (tG : AddMonoid._torsion G) (h : Add_Subgroup G) : AddMonoid._torsion â†¥h
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A B : Î±} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {x y : ð•œ} (h : x < y) {z : ð•œ} : z âˆˆ set.Ioo x y â†” âˆƒ (A B : ð•œ), 0 < A âˆ§ 0 < B âˆ§ A + B = 1 âˆ§ A * x + B * y = z
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n m : â„•} (n_LE_m : n â‰¤ m) (TerminatedAt_n : g.TerminatedAt n) : g.TerminatedAt m
{m : Type u_1} [Monoid m] {S : set m} {A : m} (hs : _Submonoid S) (h : A âˆˆ S) {n : â„•} : A ^ n âˆˆ S
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {S : set E} {x : E} {F' : TangentSpace (model_with_corners_self ð•œ E) x â†’L[ð•œ] TangentSpace (model_with_corners_self ð•œ E') (F x)} : HasFderivWithinAt F F' S x â†’ HasMfderivWithinAt (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F S x F'
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} {S1 : AffineSubspace k P} (h : S âŠ† â†‘S1) : SpanPoints k S âŠ† â†‘S1
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hb : Fintype.Card Î² â€¢ B < Finset.Univ.Sum (Î» (x : Î±), W x)) : âˆƒ (y : Î²), B < (Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Sum (Î» (x : Î±), W x)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [CompactSpace Î±] [MetricSpace Î²] {F g : C(Î±, Î²)} {C : â„} (C0 : 0 â‰¤ C) : HasDist.dist F g â‰¤ C â†” âˆ€ (x : Î±), HasDist.dist (â‡‘F x) (â‡‘g x) â‰¤ C
{R : Type u_1} [CommRing R] (u v W : Fin 3 â†’ R) : â‡‘(â‡‘CrossProduct u) (â‡‘(â‡‘CrossProduct v) W) = â‡‘(â‡‘CrossProduct (â‡‘(â‡‘CrossProduct u) v)) W + â‡‘(â‡‘CrossProduct v) (â‡‘(â‡‘CrossProduct u) W)
{Î± : Type u} [PseudoMetricSpace Î±] (P : Î± â†’ Prop) (x : Î±) (h : âˆƒá¶  (R : â„) in Filter.at_top, âˆ€ (y : Î±), y âˆˆ Metric.Ball x R â†’ P y) (y : Î±) : P y
{Î± : Type u_1} [has_LE Î±] {S : set Î±áµ’áµˆ} : _upper_set S â†’ _lower_set (â‡‘order_dual.to_dual â»Â¹' S)
{R : Type u} {A : Type W} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) (r : R) (y : A) : x * (â‡‘(Algebra_Map R A) r * y) = â‡‘(Algebra_Map R A) r * (x * y)
{R : Type u_5} [CommRing R] [IsDomain R] {k l : â„•} (h : k â‰  l) : Disjoint (primitive_roots k R) (primitive_roots l R)
{R : Type u_1} [Right_cancel_Semigroup R] (g : R) : IsRightRegular g
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (hs : IsCompact S) {e : â„} (hE : 0 < e) : âˆƒ (t : set Î±) (h : t âŠ† S), t.Finite âˆ§ S âŠ† â‹ƒ (x : Î±) (h : x âˆˆ t), Metric.Ball x e
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [DecidableEq Î¹] [Î  (i : Î¹), LinearOrder (Î± i)] (x y x' y' : Î  (i : Î¹), Î± i) : set.icc x y  set.Univ.Pi (Î» (i : Î¹), set.Ioo (x' i) (y' i)) âŠ† (â‹ƒ (i : Î¹), set.icc x (Function.update y i (x' i))) âˆª â‹ƒ (i : Î¹), set.icc (Function.update x i (y' i)) y
{Î± : Type u} [UniformSpace Î±] {F : Filter Î±} {x : Î±} (hF : Cauchy F) (adhs : ClusterPt x F) : F â‰¤ nhds x
{Î± : Type u_1} [DecidableEq Î±] [Fintype Î±] : Function.Injective Equiv.perm.Cycle_Factors_Finset
{Î± : Type u_1} [Monoid Î±] {A : Î±} {u : Î±Ë£} : â†‘u âˆ£ A
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {B : m} [Linear_ordered_CommRing m] [Nonempty Î²] (hb : â†‘(Fintype.Card Î±) â‰¤ Fintype.Card Î² â€¢ B) : âˆƒ (y : Î²), â†‘((Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Card) â‰¤ B
{Î± : Type u_2} [DecidableEq Î±] {S : Finset Î±} {B : Finset (Finset Î±)} {n : â„•} (h : âˆ€ (A : Î±), A âˆˆ S â†’ (Finset.Filter (HasMem.Mem A) B).Card = n) : B.Sum (Î» (t : Finset Î±), (S âˆ© t).Card) = S.Card * n
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : âˆ€ (y : Î²), y âˆ‰ t â†’ (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x) â‰¤ 0) (ht : t.Nonempty) (hb : t.Card â€¢ B â‰¤ S.Sum (Î» (x : Î±), W x)) : âˆƒ (y : Î²) (h : y âˆˆ t), B â‰¤ (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] (P : E) : â‡‘(reflection K) (â‡‘(reflection K) P) = P
{P : â„•} : Summable (Î» (n : â„•), 1 / â†‘n ^ P) â†” 1 < P
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (h : âˆ€ {Î¹ : Type u} (Z : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), IsClosed (Z i)) â†’ (S âˆ© â‹‚ (i : Î¹), Z i) = âˆ… â†’ (âˆƒ (t : Finset Î¹), (S âˆ© â‹‚ (i : Î¹) (h : i âˆˆ t), Z i) = âˆ…)) : IsCompact S
{G : Type W} [TopologicalSpace G] [Group G] [topological_Group G] {K U : set G} (hK : IsCompact K) (hU : IsOpen U) (hKU : K âŠ† U) : âˆƒ (v : set G) (h : v âˆˆ nhds 1), v * K âŠ† U
{Î± : Type u_1} [Preorder Î±] [Nonempty Î±] [NoMinOrder Î±] : Infinite Î±
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace ð•œ] [Finite_dimensional ð•œ E] {n : â„•} {F : E â†’ F} : ContDiff ð•œ â†‘(n + 1) F â†” Differentiable ð•œ F âˆ§ âˆ€ (y : E), ContDiff ð•œ â†‘n (Î» (x : E), â‡‘(fderiv ð•œ F x) y)
{m : Type u} {n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] [Fintype m] [DecidableEq m] (A : Matrix m m Î±) (B : Matrix m n Î±) (C : Matrix n m Î±) (D : Matrix n n Î±) [Invertible D] : (Matrix.from_blocks A B C D).det = D.det * (A - (B.Mul (â…Ÿ D)).Mul C).det
{R : Type u} {m : Type v} [CommRing R] [Nontrivial R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] (F : m â†’â‚—[R] m) (P : Polynomial R) : â‡‘(Polynomial.aeval F) P = â‡‘(Polynomial.aeval F) (P %â‚˜ F.charpoly)
{x : top} (F : top.Presheaf (Type v) x) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥x) (sf : top.Presheaf.sheaf_condition_Equalizer_products.Pi_Opens F U) (S : F.obj (Opposite.Op (supr U))) : F._gluing U ((F.Pi_Opens_iso_sections_family U).hom sf) S â†” top.Presheaf.sheaf_condition_Equalizer_products.res F U S = sf
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) (hF'_Mono : Monotone_on (deriv F) (Interior D)) : Convex_on â„ D F
{F : â„• â†’ â„} (hfa : Antitone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) : Cauchy_Seq (Î» (n : â„•), (Finset.Range (n + 1)).Sum (Î» (i : â„•), (-1) ^ i * F i))
{Î± : Type u} [non_unital_CommRing Î±] {B C x : Î±} (h : x * x - B * x + C = 0) : âˆƒ (y : Î±), y * y - B * y + C = 0 âˆ§ x + y = B âˆ§ x * y = C
{Î² : Type u_2} [ordered_AddCommGroup Î²] [module â„ Î²] [OrderedSmul â„ Î²] {F : â„ â†’ Î²} {A B : â„} (A_LT_B : A < B) (h_IsLocalMin : IsLocalMinOn F (set.icc A B) A) (h_conv : Convex_on â„ (set.icc A B) F) : IsMinOn F (set.icc A B) A
{Î¹ : Type u_1} {m : Î¹ â†’ Type u_2} [Î  (i : Î¹), Monoid (m i)] {N : Type u_3} [Monoid N] (F g : FreeProduct m â†’* N) (h : âˆ€ (i : Î¹), F.Comp FreeProduct.of = g.Comp FreeProduct.of) : F = g
{m : Type u_1} [has_Mul m] {C D : Con m} : (âˆ€ (x y : m), â‡‘C x y â†” â‡‘D x y) â†” C = D
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_3} (l : Î¹ â†’â‚€ ð•œ) (v : Î¹ â†’ E) (x : E) : HasInner.inner x (l.Sum (Î» (i : Î¹) (A : ð•œ), A â€¢ v i)) = l.Sum (Î» (i : Î¹) (A : ð•œ), A â€¢ HasInner.inner x (v i))
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (m : m) : 0 â‰¤ âˆ¥â‡‘(Quotient_AddGroup.Mk' S) mâˆ¥
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x y : E} : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * â‡‘_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (F : LocalHomeomorph E F) {F' : E â‰ƒL[ð•œ] F} {A : F} (ha : A âˆˆ F.to_local_Equiv.Target) (htff' : HasFderivAt â‡‘F â†‘F' (â‡‘(F.Symm) A)) : HasFderivAt â‡‘(F.Symm) â†‘(F'.Symm) A
{Î± : Type u_1} (r : Setoid Î±) : Setoid.Mk_Classes r.Classes Setoid.Classes_eqv_Classes = r
{Î± : Type u_1} {Î² : Type u_3} [MeasurableSpace Î±] [MeasurableSpace Î²] {C : set (set Î±)} {D : set (set Î²)} (hC : MeasurableSpace.generate_from C = _inst_1) (hD : MeasurableSpace.generate_from D = _inst_3) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) : MeasurableSpace.generate_from (set.image2 has_set_Prod.Prod C D) = Prod.MeasurableSpace
(A : â„) : Cardinal.Mk â†¥(set.ici A) = Cardinal.Continuum
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} (h : SameRay R x y) : SameRay R y x
{P : Polynomial â„š} (P_irr : Irreducible P) (P_deg : Nat.Prime P.Nat_degree) (P_roots : Fintype.Card â†¥(P.root_set â„‚) = Fintype.Card â†¥(P.root_set â„) + 2) : Function.Bijective â‡‘(Polynomial.Gal.Gal_action_hom P â„‚)
{m : Type u_6} {N : Type u_7} [has_Add m] [has_Add N] (e : m â‰ƒ+ N) (x : m) : â‡‘(e.Symm) (â‡‘e x) = x
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] [NormedGroup G] [NormedSpace ð•œ G] {n : â„•} (P : FormalMultilinearSeries ð•œ E F) (C : Composition n) (F : Continuous_MultilinearMap ð•œ (Î» (i : Fin C.length), F) G) (v : Fin n â†’ E) : âˆ¥â‡‘(Continuous_MultilinearMap.Comp_along_Composition P C F) vâˆ¥ â‰¤ âˆ¥Fâˆ¥ * Finset.Univ.Prod (Î» (i : Fin C.length), âˆ¥P (C.blocks_fun i)âˆ¥) * Finset.Univ.Prod (Î» (i : Fin n), âˆ¥v iâˆ¥)
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : 1 / A < 1 / B â†” B < A
{ð•œ : Type u_1} {E : Type u_2} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] {S : set E} : Convex ð•œ S â†” âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ S â†’ y âˆˆ S â†’ âˆ€ â¦ƒA B : ð•œâ¦„, 0 â‰¤ A â†’ 0 â‰¤ B â†’ 0 < A + B â†’ (A / (A + B)) â€¢ x + (B / (A + B)) â€¢ y âˆˆ S
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x : E} : âˆ¥â‡‘innerSL xâˆ¥ = âˆ¥xâˆ¥
{Î± : Type u_2} [Preorder Î±] [NoMaxOrder Î±] : Filter.at_top â‰¤ Filter.cofinite
{P : â„•} [hp_Prime : Fact (Nat.Prime P)] {R : Type u_1} [non_assoc_Semiring R] {F : Î  (k : â„•), R â†’+* Zmod (P ^ k)} (F_compat : âˆ€ (k1 k2 : â„•) (hk : k1 â‰¤ k2), (Zmod.cast_hom _ (Zmod (P ^ k1))).Comp (F k2) = F k1) (n : â„•) : (padic_Int.to_Zmod_Pow n).Comp (padic_Int.Lift F_compat) = F n
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] {P : Î± â†’ Prop} {S : Finset {x // P x}} {F : {x // P x} â†’ Î²} {g : Î± â†’ Î²} (h : âˆ€ (x : {x // P x}), x âˆˆ S â†’ g â†‘x = F x) : (Finset.Map (Function.Embedding.Subtype (Î» (x : Î±), P x)) S).Prod (Î» (x : Î±), g x) = S.Prod (Î» (x : {x // P x}), F x)
{Î± : Type u_2} {Î¹ : Type u_5} [AddCommMonoid Î±] [Fintype Î¹] (F : Î¹ â†’ set Î±) (A : Î±) : A âˆˆ Finset.Univ.Sum (Î» (i : Î¹), F i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), g i âˆˆ F i), Finset.Univ.Sum (Î» (i : Î¹), g i) = A
{R : Type u_1} [Semiring R] (r : R) (F : Polynomial R) (n : â„•) : (â‡‘(Polynomial.taylor r) F).Coeff n = Polynomial.Eval r (â‡‘(Polynomial.hasse_deriv n) F)
{P : â„• â†’ Prop} : (âˆƒ (x : â„•), P x) â†’ WellFounded (Nat.Upto.Gt P)
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] [NormedGroup F] [NormedSpace â„ F] [TopologicalSpace.SecondCountableTopology F] (F : E â†’ F) (S : set E) (F' : E â†’ (E â†’L[â„] F)) (hF' : âˆ€ (x : E), x âˆˆ S â†’ HasFderivWithinAt F (F' x) S x) (r : (E â†’L[â„] F) â†’ Nnreal) (rpos : âˆ€ (A : E â†’L[â„] F), r A â‰  0) : âˆƒ (t : â„• â†’ set E) (A : â„• â†’ (E â†’L[â„] F)), (âˆ€ (n : â„•), IsClosed (t n)) âˆ§ (S âŠ† â‹ƒ (n : â„•), t n) âˆ§ (âˆ€ (n : â„•), ApproximatesLinearOn F (A n) (S âˆ© t n) (r (A n))) âˆ§ (S.Nonempty â†’ âˆ€ (n : â„•), âˆƒ (y : E) (h : y âˆˆ S), A n = F' y)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (hG : CategoryTheory.CompatiblePreserving K G) (â„± : CategoryTheory.SheafOfTypes K) {Z : C} {t : CategoryTheory.Presieve Z} {x : CategoryTheory.Presieve.FamilyOfElements (G.Op â‹™ â„±.val) t} (h : x.compatible) : (CategoryTheory.Presieve.FamilyOfElements.Functor_pushforward G x).compatible
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} {F' : â„ â†’ E} {C : â„} (hF : Continuous_on F (set.icc A B)) (hF' : âˆ€ (x : â„), x âˆˆ set.Ico A B â†’ HasDerivWithinAt F (F' x) (set.ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico A B â†’ âˆ¥F' xâˆ¥ â‰¤ C) (x : â„) (h : x âˆˆ set.icc A B) : âˆ¥F x - F Aâˆ¥ â‰¤ C * (x - A)
{Î± : Type u} [Preorder Î±] [OrderTop Î±] {A B : Î±} (h : A < B) : A â‰  âŠ¤
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m â†’* P} (h : C â‰¤ Con.Ker F) (hF : Function.Surjective â‡‘F) : Function.Surjective â‡‘(C.Lift F h)
{Î± : Type u_1} {F g : Î± â†’ â„} {tâ‚€ : Filter Î±} (hF : âˆ€á¶  (t : Î±) in tâ‚€, 0 â‰¤ F t) (hft : âˆ€á¶  (t : Î±) in tâ‚€, F t â‰¤ g t) (g0 : Filter.Tendsto g tâ‚€ (nhds 0)) : Filter.Tendsto F tâ‚€ (nhds 0)
{Î¹ : Type u} {F g : Î¹ â†’ Nnreal} {P q : â„} (hpq : P.IsConjugateExponent q) (hF : Summable (Î» (i : Î¹), F i ^ P)) (hg : Summable (Î» (i : Î¹), g i ^ q)) : Summable (Î» (i : Î¹), F i * g i) âˆ§ âˆ‘' (i : Î¹), F i * g i â‰¤ (âˆ‘' (i : Î¹), F i ^ P) ^ (1 / P) * (âˆ‘' (i : Î¹), g i ^ q) ^ (1 / q)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {Î¹ : Type W} [Fintype Î¹] (h : Basis Î¹ K v) : Finite_dimensional K v
{Î± : Type u_1} {S : set Î±} : S.Pairwise âŠ¥ â†’ S.Subsingleton
{R : Type u_1} [NormedRing R] (k : â„•) {râ‚ : R} {râ‚‚ : â„} (h : âˆ¥râ‚âˆ¥ < râ‚‚) : (Î» (n : â„•), â†‘n ^ k * râ‚ ^ n) =o[Filter.at_top] Î» (n : â„•), râ‚‚ ^ n
{Î± : Type u} {lâ‚ lâ‚‚ : List Î±} {n : â„•} : List.Drop n (lâ‚ ++ lâ‚‚) = List.Drop n lâ‚ ++ List.Drop (n - lâ‚.length) lâ‚‚
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} {v : Î¹ â†’ m} [Semiring R] [AddCommMonoid m] [module R m] [Fintype Î¹] : LinearIndependent R v â†” (â‡‘(LinearMap.lsum R (Î» (i : Î¹), R) â„•) (Î» (i : Î¹), LinearMap.Id.Smul_Right (v i))).Ker = âŠ¥
{C : Type u} [CategoryTheory.Category C] {x : C} {S R : CategoryTheory.Sieve x} (J : CategoryTheory.GrothendieckTopology C) (rj : R âˆˆ â‡‘J x) (sj : S âˆˆ â‡‘J x) : R âŠ“ S âˆˆ â‡‘J x
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.HasTerminal C] (h : CategoryTheory.Mono (CategoryTheory.Limits.initial.to (âŠ¤_ C))) : CategoryTheory.Limits.InitialMonoClass C
{P : â„•} [Fact (Nat.Prime P)] : WittVector.IsPolyâ‚‚ P (Î» (_x : Type u_1) (_x_1 : CommRing _x), has_Add.Add)
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {A : Î±} {S : set Î±} (h : A âˆ‰ S â†’ F A = 1) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ HasInsert.Insert A S), F i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i))
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {l : Filter Î±} {A : Î±} : _extr_Filter F l A â†’ _extr_Filter (â‡‘order_dual.to_dual âˆ˜ F) l A
{R : Type u_1} [Semiring R] {x y : R} (h : Commute x y) (n : â„•) : (x + y) ^ n = (Finset.Range (n + 1)).Sum (Î» (m : â„•), x ^ m * y ^ (n - m) * â†‘(n.choose m))
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] [_Pred_Archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.ioc m n â†’ r i (Order.Pred i)) (hnm : m < n) : Relation.TransGen r n m
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] (F : S.Localization_Map N) (x : m) (y : â†¥S) : âˆƒ (C : â†¥S), x * â†‘((F.sec (F.Mk' x y)).Snd) * â†‘C = (F.sec (F.Mk' x y)).fst * â†‘y * â†‘C
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {v : set E} (hv : Orthonormal ð•œ Coe) : (âˆ€ (u : set E), u âŠ‡ v â†’ Orthonormal ð•œ Coe â†’ u = v) â†” (Submodule.Span ð•œ v)á—® = âŠ¥
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : MultilinearMap ð•œ E G) (hF : Continuous â‡‘F) : âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘F mâˆ¥ â‰¤ C * Finset.Univ.Prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F â‰  2) : âˆƒ (A : F), Char.quadratic_Char F A = -1
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x y : E) : â‡‘_R_or_C.re (HasInner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
{G : Type u_1} [AddGroup G] (h : Add_Subgroup G) : 0 âˆˆ h
{Î± : Type u_1} (A : Finset Î±) (i : â„•) (hâ‚ : i â‰¤ A.Card) : âˆƒ (B : Finset Î±), B âŠ† A âˆ§ B.Card = i
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.Additive] [CategoryTheory.EnoughProjectives C] {x Y : C} (F : x âŸ¶ Y) (P : CategoryTheory.ProjectiveResolution x) (q : CategoryTheory.ProjectiveResolution Y) : (F.Left_derived 0).Map F â‰« CategoryTheory.Abelian.Functor.Left_derived_Zero_to_self_App F q = CategoryTheory.Abelian.Functor.Left_derived_Zero_to_self_App F P â‰« F.Map F
{Î± : Type u} {Î² : Type v} {Î³ : Type W} [TopologicalSpace Î±] [PseudoMetricSpace Î²] [PseudoMetricSpace Î³] {G : Î² â†’ Î³} {C : Nnreal} (h : LipschitzWith C G) : Continuous (bounded_Continuous_Function.Comp G h)
{m : Type u_1} {N : Type u_2} [Preorder m] [has_Add m] [HasSub m] [HasOrderedSub m] [PartialOrder N] [has_Add N] [HasSub N] [HasOrderedSub N] (e : m â‰ƒo N) (h_Add : âˆ€ (A B : m), â‡‘e (A + B) = â‡‘e A + â‡‘e B) (A B : m) : â‡‘e (A - B) = â‡‘e A - â‡‘e B
{x : top} (U : TopologicalSpace.Opens â†¥x) (R : CategoryTheory.Presieve U) (hR : CategoryTheory.Sieve.generate R âˆˆ â‡‘(Opens.GrothendieckTopology â†¥x) U) : supr (top.Presheaf.covering_of_Presieve U R) = U
{Î± Î² : Type u} (e : Î± â‰ƒ Î²) : Cardinal.Mk Î± = Cardinal.Mk Î²
(u : â„• â†’ â„) (l : â„) (hmono : Monotone u) (hlim : âˆ€ (A : â„), 1 < A â†’ (âˆƒ (C : â„• â†’ â„•), (âˆ€á¶  (n : â„•) in Filter.at_top, â†‘(C (n + 1)) â‰¤ A * â†‘(C n)) âˆ§ Filter.Tendsto C Filter.at_top Filter.at_top âˆ§ Filter.Tendsto (Î» (n : â„•), u (C n) / â†‘(C n)) Filter.at_top (nhds l))) : Filter.Tendsto (Î» (n : â„•), u n / â†‘n) Filter.at_top (nhds l)
{ð•œ : Type u_1} {E : Type u_3} [OrderedSemiring ð•œ] [TopologicalSpace E] [Add_cancel_CommMonoid E] [has_Continuous_Add E] [module ð•œ E] {S : set E} (hs : strict_Convex ð•œ S) (z : E) : strict_Convex ð•œ ((Î» (x : E), x + z) â»Â¹' S)
{Î± : Type u} [TopologicalSpace Î±] : DenseRange stone_cech_Unit
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} {P1 P2 : P} (hp1 : P1 âˆˆ S) (hp2 : P2 âˆˆ S) : P1 -áµ¥ P2 âˆˆ Vector_Span k S
{x y : Pgame} (h : x.Fuzzy y) : x.lf y
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) P) âˆˆ S
{G : Type u_1} [Group G] [_free_Group G] {h : Type u_2} [Group h] (F : _free_Group.Generators G â†’ h) : âˆƒ! (F : G â†’* h), âˆ€ (A : _free_Group.Generators G), â‡‘F (_free_Group.of A) = F A
{Î± : Type u_1} {Î¹ : Type u_3} {Î¹' : Type u_4} [Distrib_Lattice Î±] [OrderBot Î±] [DecidableEq Î¹] {S : Finset Î¹'} {g : Î¹' â†’ Finset Î¹} {F : Î¹ â†’ Î±} (hs : S.Sup_indep (Î» (i : Î¹'), (g i).Sup F)) (hg : âˆ€ (i' : Î¹'), i' âˆˆ S â†’ (g i').Sup_indep F) : (S.bUnion g).Sup_indep F
{Î± : Type u_1} [canonically_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B C : Î±} [ContravariantClass Î± Î± has_Add.Add has_LE.LE] [ContravariantClass Î± Î± has_Add.Add has_LT.LT] (hâ‚ : B â‰¤ A) (hâ‚‚ : C â‰¤ A) : A - B < A - C â†” C < B
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {t : E â†’L[ð•œ] E} (hT : InnerProductSpace.IsSelfAdjoint â†‘t) (x : E) : â†‘(t.re_apply_inner_self x) = HasInner.inner (â‡‘t x) x
{Î± : Type u_1} {Î² : Type u_2} {e e' : local_Equiv Î± Î²} (h : e â‰ˆ e') : e.Target = e'.Target
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} (hg : âˆ€ (y : â†¥S), IsUnit (â‡‘g â†‘y)) (z : N) (v : P) : â‡‘(F.Lift hg) z = v â†” â‡‘g (F.sec z).fst = â‡‘g â†‘((F.sec z).Snd) * v
(Î¹ : Type u_1) [Fintype Î¹] : Metric.Bounded (StdSimplex â„ Î¹)
{Î± : Type u_1} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hs : S.Finite) (ht : t.Finite) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S âˆª t), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S âˆ© t), F i)) = finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ S), F i)) * finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ t), F i))
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S : set E) {K : Subfield E} (hF : set.Range â‡‘(Algebra_Map F E) âŠ† â†‘K) (HS : S âŠ† â†‘K) : (intermediate_Field.Adjoin F S).to_Subfield â‰¤ K
{Î± : Type u_1} [CommSemiring Î±] (E : LinearRecurrence Î±) (u : â„• â†’ Î±) : E._solution u â†” u âˆˆ E.sol_Space
(R : Type u) [CommRing R] [IsDomain R] (n : â„•) : IsDomain (mv_Polynomial (Fin n) R)
{Î± : Type u_1} [UniformSpace Î±] {S : set (Î± Ã— Î±)} (hs : S âˆˆ Uniformity Î±) : âˆƒ (t : set (Î± Ã— Î±)) (h : t âˆˆ Uniformity Î±), symmetric_Rel t âˆ§ Comp_Rel t t âŠ† S
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) : â‡‘(S.affine_combination P) W = â‡‘(S.weighted_vsub_of_point P (Classical.choice AddTorsor.Nonempty)) W +áµ¥ Classical.choice AddTorsor.Nonempty
{n m : â„•} (h : n = m) : (Fin.cast h).to_Equiv = Equiv.cast _
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {C : â„} (h : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ HasDist.dist x y â‰¤ C) : Emetric.diam S â‰¤ Ennreal.of_Real C
{J : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.IsConnected J] (jâ‚ jâ‚‚ : J) : CategoryTheory.Zigzag jâ‚ jâ‚‚
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : Real.cos (InnerProductGeometry.angle x y) = HasInner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : Î± â‰ƒâ‚œ Î²) {B : Î²} {F : Î² â†’ E} {g : Î² â†’ F} : F =o[nhds B] g â†” (F âˆ˜ â‡‘e) =o[nhds (â‡‘(e.Symm) B)] (g âˆ˜ â‡‘e)
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (h : TotallyBounded S) : Metric.Bounded S
{Î± : Type u_1} {Î² : Type u_2} {mÎ² : MeasurableSpace Î²} {m : MeasurableSpace Î±} {F : â„• â†’ Î± â†’ Î²} {P : â„• â†’ Î± â†’ Prop} [Î  (n : â„•), Decidable_Pred (P n)] (hF : âˆ€ (n : â„•), Measurable (F n)) (hp : âˆ€ (n : â„•), Measurable_set {x : Î± | P n x}) (h : âˆ€ (x : Î±), âˆƒ (n : â„•), P n x) : Measurable (Î» (x : Î±), F (Nat.Find _) x)
{E : Type u_1} {Î² : Type u_2} [AddCommGroup E] [TopologicalSpace E] [module â„ E] [topological_AddGroup E] [has_Continuous_Smul â„ E] [ordered_AddCommGroup Î²] [module â„ Î²] [OrderedSmul â„ Î²] {F : E â†’ Î²} {A : E} (h_IsLocalMin : IsLocalMin F A) (h_conv : Convex_on â„ set.Univ F) (x : E) : F A â‰¤ F x
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G : C â¥¤ D} (Î± : F âŸ¶ G) [âˆ€ (x : C), CategoryTheory.IsIso (Î±.App x)] : CategoryTheory.IsIso Î±
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A : Î±} : 1 â‰¤ Aâ»Â¹ â†” A â‰¤ 1
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) : 2 â€¢ hb.oangle x (-x) = 0
{Î± : Type u_1} [Linear_ordered_Ring Î±] : Subsingleton (FloorRing Î±)
(N : â„•) {j : â„} (hj : 0 < j) {C : â„} (hc : 1 < C) : (Finset.Filter (Î» (i : â„•), j < C ^ i) (Finset.Range N)).Sum (Î» (i : â„•), 1 / (C ^ i) ^ 2) â‰¤ C ^ 3 * (C - 1)â»Â¹ / j ^ 2
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (lâ‚ lâ‚‚ : Î¹ â†’â‚€ ð•œ) : HasInner.inner (â‡‘(Finsupp.Total Î¹ E ð•œ v) lâ‚) (â‡‘(Finsupp.Total Î¹ E ð•œ v) lâ‚‚) = lâ‚‚.Sum (Î» (i : Î¹) (y : ð•œ), â‡‘(Star_Ring_end ð•œ) (â‡‘lâ‚ i) * y)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_coproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.Normal_Epi_Category C] {x Y Z : C} (A : x âŸ¶ Y) (B : x âŸ¶ Z) [CategoryTheory.Epi A] [CategoryTheory.Epi B] : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.Span A B)
{n m : â„•} (h : âˆ€ (i : â„•), n.test_bit i = m.test_bit i) : n = m
{Î± : Type u} {Î² : Type v} [UniformSpace Î±] [SemilatticeSup Î²] {u : Î² â†’ Î±} (hu : Cauchy_Seq u) {Î¹ : Type u_1} {F : Î¹ â†’ Î²} {P : Filter Î¹} [P.Ne_IsBot] (hF : Filter.Tendsto F P Filter.at_top) {A : Î±} (ha : Filter.Tendsto (u âˆ˜ F) P (nhds A)) : Filter.Tendsto u Filter.at_top (nhds A)
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (h : IsUnit A.det) : A.Mul Aâ»Â¹ = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] (h : âˆ€ (A : C) (F : A âŸ¶ âŠ¥_ C), CategoryTheory.IsIso F) : CategoryTheory.Limits.HasStrictInitialObjects C
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P : P} (hp : P âˆˆ S) (v : v) : v âˆˆ S.direction â†” âˆƒ (P2 : P) (h : P2 âˆˆ S), v = P2 -áµ¥ P
{F : â„• â†’ â„} (hF : âˆ€ (i : â„•), 0 â‰¤ F i) (r : â„) : has_Sum F r â†” Filter.Tendsto (Î» (n : â„•), (Finset.Range n).Sum (Î» (i : â„•), F i)) Filter.at_top (nhds r)
{Î± : Type u} {Î² : Type v} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hF : Filter.Tendsto F l Filter.at_IsBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), F x * g x) l Filter.at_top
{Î¹ : Type u_1} {Î± : Type u_2} [CompleteLattice Î±] {t : Î¹ â†’ Î±} (ht : CompleteLattice.Independent t) {x : Î¹} {y : set Î¹} (hx : x âˆ‰ y) : Disjoint (t x) (â¨† (i : Î¹) (h : i âˆˆ y), t i)
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] (S : Finset m) : CompleteLattice.IsCompact_element (Submodule.Span R â†‘S)
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Pos_Mul_StrictMono Î±] (ha : A < 1) (hb : B < 1) (A0 : 0 < A) : A * B < 1
{Î± : Type u_1} [LinearOrder Î±] (A : Î±) (i : Fin 1) : â‡‘({A}.order_emb_of_Fin _) i = A
{Î± : Type u} [Preorder Î±] {S : set Î±} {A : Î±} (h : IsGlb S A) : BddBelow S
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {F : Filter Î±} : Filter._bounded r F â†” âˆƒ (S : set Î±) (h : S âˆˆ F.sets) (B : Î±), S âŠ† {x : Î± | r x B}
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] {F : Type v} [NormedGroup F] [NormedSpace â„‚ F] [Nontrivial E] {F g : E â†’ F} {U : set E} (hU : Metric.Bounded U) (hF : Diff_Cont_on_cl â„‚ F U) (hg : Diff_Cont_on_cl â„‚ g U) (hfg : set.Eq_on F g (Frontier U)) : set.Eq_on F g U
{Î± : Type u_1} {E : Type u_3} [NormedGroup E] [TopologicalSpace Î±] {F : Î± â†’ E} : has_IsCompact_Support F â†’ has_IsCompact_Support (Î» (x : Î±), âˆ¥F xâˆ¥)
(P : â„•) : padic_norm P 1 = 1
{G : Type u_1} [sub_Neg_Monoid G] (A B : G) : A - B = A + -B
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (q : QuadraticForm R m) (P : Submodule R (clifford_Algebra q)) (n : â„•) : Submodule.Map clifford_Algebra.reverse (P ^ n) = Submodule.Map clifford_Algebra.reverse P ^ n
{Î± : sort u_1} {Î² : sort u_2} {P : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£' (A : Î±), Subtype (P A)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.Snd) = â†‘(xâ‚.Snd) â†’ xâ‚€ = xâ‚
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {B : C} : CategoryTheory.Limits.HasBinaryProducts (CategoryTheory.Over B)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] (S : Finset E) (hs : âˆ€ (C : E), C âˆˆ S â†’ âˆ¥Câˆ¥ â‰¤ 2) (h : âˆ€ (C : E), C âˆˆ S â†’ âˆ€ (D : E), D âˆˆ S â†’ C â‰  D â†’ 1 â‰¤ âˆ¥C - Dâˆ¥) : S.Card â‰¤ 5 ^ Finite_dimensional.finrank â„ E
{A B C : â„¤} : fermat_42.Minimal A B C â†’ fermat_42.Minimal A B (-C)
{R : Type u_1} [CommRing R] (S : Submonoid R) {P : Type u_2} [CommRing P] [Algebra R P] [loc : IsLocalization S P] (x : P) (hx : IsIntegral R x) : IsFractional S (Algebra.Adjoin R {x}).to_Submodule
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} {v3 : Type u_6} {P3 : Type u_7} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] [AddCommGroup v3] [module k v3] [AddTorsor v3 P3] (F : P2 â†’áµƒ[k] P3) (g : P1 â†’áµƒ[k] P2) (P : P1) : â‡‘(F.Comp g) P = â‡‘F (â‡‘g P)
{Î± : Type u_1} [LinearOrder Î±] {r : Î±} {S : Finset Î±} : {r}.to_colex â‰¤ S.to_colex â†” âˆƒ (x : Î±) (h : x âˆˆ S), r â‰¤ x
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (h : â†‘r < P.radius) : (Î» (n : â„•), âˆ¥P nâˆ¥ * â†‘r ^ n) =o[Filter.at_top] Î» (_x : â„•), 1
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} (h : AffineIndependent k (Î» (P : â†¥S), â†‘P)) : âˆƒ (t : set P), S âŠ† t âˆ§ AffineIndependent k (Î» (P : â†¥t), â†‘P) âˆ§ affine_Span k t = âŠ¤
{Î± : Type u_1} [CompleteLattice Î±] {S : set Î±} (hs : CompleteLattice.set_Independent S) {x : Î±} {y : set Î±} (hx : x âˆˆ S) (hy : y âŠ† S) (hxy : x âˆ‰ y) : Disjoint x (HasSup.Sup y)
{Î± : Type u} [Group Î±] (g : Group_topology Î±) : Continuous has_Inv.Inv
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [AddCommMonoid F] [ordered_AddCommMonoid Î²] [module ð•œ E] [module ð•œ F] [HasScalar ð•œ Î²] {F : F â†’ Î²} {S : set F} (hF : ConcaveOn ð•œ S F) (g : E â†’â‚—[ð•œ] F) : ConcaveOn ð•œ (â‡‘g â»Â¹' S) (F âˆ˜ â‡‘g)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : 0 < A) (hb : 0 â‰¤ B) : 0 < A + B
(R : Type u_1) {P n : â„•} [hp : Fact (Nat.Prime P)] [Ring R] [Char_P R P] (hn : P âˆ£ n) : Polynomial.cyclotomic (n * P) R = Polynomial.cyclotomic n R ^ P
{R : Type u_1} [CommRing R] {Râ‚˜ : Type u_3} {Sâ‚˜ : Type u_4} [CommRing Râ‚˜] [CommRing Sâ‚˜] (P : Ideal (Polynomial R)) (pX : Polynomial R) (hpX : pX âˆˆ P) [Algebra (R â§¸ Ideal.comap Polynomial.C P) Râ‚˜] [IsLocalization.Away (Polynomial.Map (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P)) pX).leading_Coeff Râ‚˜] [Algebra (Polynomial R â§¸ P) Sâ‚˜] [IsLocalization (Submonoid.Map â†‘(P.QuotientMap Polynomial.C LE_rfl) (Submonoid.Powers (Polynomial.Map (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P)) pX).leading_Coeff)) Sâ‚˜] : (IsLocalization.Map Sâ‚˜ (P.QuotientMap Polynomial.C LE_rfl) _).IsIntegral
{C : Type u} [CategoryTheory.Category C] {x Y Z : C} {F g : x âŸ¶ Y} (W : F = g) (h : Y âŸ¶ Z) : F â‰« h = g â‰« h
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F : Type v} [NormedGroup F] [NormedSpace ð•œ F] {F : ð•œ â†’ F} {F' : F} {x : ð•œ} [PartialOrder ð•œ] : HasDerivWithinAt F F' (set.ioi x) x â†’ HasDerivWithinAt F F' (set.ici x) x
{Î± : Type u_1} {E : Î± â†’ Type u_2} {P : Ennreal} [Î  (i : Î±), NormedGroup (E i)] [Fact (1 â‰¤ P)] {F : â„• â†’ â†¥(Lp E P)} (hF : Cauchy_Seq F) {F : â†¥(Lp E P)} (hF : Filter.Tendsto (Id (Î» (i : â„•), â‡‘(F i))) Filter.at_top (nhds â‡‘F)) : Filter.Tendsto F Filter.at_top (nhds F)
{E : Type u_3} [semi_NormedGroup E] (u v : E) : âˆ¥vâˆ¥ â‰¤ âˆ¥uâˆ¥ + âˆ¥u - vâˆ¥
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) (hF'' : DifferentiableOn â„ (deriv F) (Interior D)) (hF''_nonpos : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv^[2] F x â‰¤ 0) : ConcaveOn â„ D F
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m â†’* P} (h : C â‰¤ Con.Ker F) (x : m) : â‡‘(C.Lift F h) (â‡‘(C.Mk') x) = â‡‘F x
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (F : Î± â†’ Î² â†’ Î³) (S : set Î±) (t : set Î²) : set.image2 F S t = â‹ƒ (i : Î±) (h : i âˆˆ S) (j : Î²) (h : j âˆˆ t), {F i j}
{Î± : Type u_1} [LinearOrder Î±] (S : set Î±) (h : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ âˆ€ (z : Î±), z âˆˆ S â†’ x â‰¤ y â†’ y â‰¤ z â†’ x = y âˆ¨ y = z) : S.Finite
{P : â„•} [Fact (Nat.Prime P)] {F : padic_Seq P} (hF : Â¬F â‰ˆ 0) (v1 v3 : â„•) : padic_norm P (â‡‘F (padic_Seq.stationary_point hF)) = padic_norm P (â‡‘F (LinearOrder.max v1 (LinearOrder.max (padic_Seq.stationary_point hF) v3)))
{F F' : â„ â†’ â„} {S : set â„} (hs : Convex â„ S) (hF : âˆ€ (x : â„), x âˆˆ S â†’ HasDerivAt F (F' x) x) {m : â„} (hF' : âˆ€ (x : â„), x âˆˆ S â†’ F' x â‰  m) : (âˆ€ (x : â„), x âˆˆ S â†’ F' x < m) âˆ¨ âˆ€ (x : â„), x âˆˆ S â†’ m < F' x
{G : Type u_1} [Group G] (tG : Monoid._torsion_free G) (h : Subgroup G) : Monoid._torsion_free â†¥h
{n : â„•} : Finset.Univ = Finset.Map Equiv.perm.decompose_Fin.Symm.to_Embedding Finset.Univ
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [Linear_ordered_Field ð•œ] [AddCommGroup E] [Linear_ordered_AddCommGroup Î²] [module ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} {t : Finset Î¹} {W : Î¹ â†’ ð•œ} {P : Î¹ â†’ E} (h : Convex_on ð•œ S F) (hwâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ W i) (hwâ‚ : 0 < t.Sum (Î» (i : Î¹), W i)) (hp : âˆ€ (i : Î¹), i âˆˆ t â†’ P i âˆˆ S) : âˆƒ (i : Î¹) (h : i âˆˆ t), F (t.Center_mass W P) â‰¤ F (P i)
{A P k : â„•} (pp : Nat.Prime P) (hâ‚ : Â¬A âˆ£ P ^ k) (hâ‚‚ : A âˆ£ P ^ (k + 1)) : A = P ^ (k + 1)
{G : Type u_1} [Group G] (h : Subgroup G) [hG : Group.IsNilpotent G] : Group.nilpotency_class â†¥h â‰¤ Group.nilpotency_class G
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {Lâ‚ Lâ‚‚ : C â¥¤ D} {Râ‚ Râ‚‚ : D â¥¤ C} (Adjâ‚ : Lâ‚ âŠ£ Râ‚) (Adjâ‚‚ : Lâ‚‚ âŠ£ Râ‚‚) (F : Lâ‚‚ âŸ¶ Lâ‚) [CategoryTheory.IsIso (â‡‘(CategoryTheory.transfer_Nat_Trans_self Adjâ‚ Adjâ‚‚) F)] : CategoryTheory.IsIso F
{C : Type uâ‚} [CategoryTheory.Category C] {B A : C} {x : CategoryTheory.Subobject B} (F : A âŸ¶ B) [CategoryTheory.Mono F] (i : A â‰… â†‘x) (W : i.hom â‰« x.arrow = F) : CategoryTheory.Subobject.Mk F = x
(R : CommRing) : AlgebraicGeometry.identity_toÎ“_spec.App (AlgebraicGeometry.spec.to_LocallyRingedSpace.obj (Opposite.Op R)) â‰« AlgebraicGeometry.spec.to_LocallyRingedSpace.Map (AlgebraicGeometry.spec_Î“_identity.Inv.App R).Op = ðŸ™ ((ðŸ­ AlgebraicGeometry.LocallyRingedSpace).obj (AlgebraicGeometry.spec.to_LocallyRingedSpace.obj (Opposite.Op R)))
{C : Type uâ‚} [CategoryTheory.Category C] {x : C} (P : Cáµ’áµ– â¥¤ Type W) : CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.Singleton (ðŸ™ x))
(x : â„‚) : HasDerivAt Complex.cosh (Complex.sinh x) x
{m : Type u_3} {N : Type u_4} [has_One m] [has_One N] {F g : One_hom m N} (h : F = g) (x : m) : â‡‘F x = â‡‘g x
{Î± : Type u} [TopologicalSpace Î±] {x : Î±} : Coe â»Â¹' {â†‘x} = ConnectedComponent x
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [wo : IsWellOrder Î± r] {S : set (set Î±)} (hâ‚ : set.Unbounded r (â‹ƒâ‚€S)) (hâ‚‚ : Cardinal.Mk â†¥S < StrictOrder.cof r) : âˆƒ (x : set Î±) (h : x âˆˆ S), set.Unbounded r x
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} {C : CategoryTheory.Limits.Fork F g} (h : CategoryTheory.Limits.IsLimit C) [CategoryTheory.Epi C.Î¹] : CategoryTheory.IsIso C.Î¹
(P : â„•) [P_Prime : Fact (Nat.Prime P)] {q r : â„š} (hq : q â‰  0) (hr : r â‰  0) : padic_val_rat P (q / r) = padic_val_rat P q - padic_val_rat P r
{ð•œ : Type u} [hnorm : nondiscrete_NormedField ð•œ] {E : Type v} [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul ð•œ E] (l : E â†’â‚—[ð•œ] ð•œ) : Continuous â‡‘l â†” IsClosed â†‘(l.Ker)
{R : Type v} [CommRing R] (A : Matrix (Fin 3) (Fin 3) R) : A.det = A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 + A 0 2 * A 1 0 * A 2 1 - A 0 2 * A 1 1 * A 2 0
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : C â¥¤ D) {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan F F) F] [CategoryTheory.Mono (F.Map F)] : CategoryTheory.Mono F
{mâ‚€ : Type u_1} [MulZeroOneClass mâ‚€] [Nontrivial mâ‚€] : 0 â‰  1
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x : C} {R : CategoryTheory.Presieve x} {x : CategoryTheory.Presieve.FamilyOfElements P â‡‘(CategoryTheory.Sieve.generate R)} (t : x.compatible) : (CategoryTheory.Presieve.FamilyOfElements.Restrict _ x).Sieve_extend = x
{C : Type u} [CategoryTheory.Category C] {P q R : C} (F : P âŸ¶ q) (g : q âŸ¶ R) [CategoryTheory.StrongMono (F â‰« g)] : CategoryTheory.StrongMono F
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [DivisionRing R] [DivisionRing S] [module R E] [module S E] (r : â„š) (x : E) : â†‘r â€¢ x = â†‘r â€¢ x
(n : â„•) (R : Type u_1) [Ring R] [Nontrivial R] : (Polynomial.cyclotomic n R).degree = â†‘(n.Totient)
{A B : â„} {g' g : â„ â†’ â„} (hcont : Continuous_on g (set.Interval A B)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo (LinearOrder.min A B) (LinearOrder.max A B) â†’ HasDerivAt g (g' x) x) (hpos : âˆ€ (x : â„), x âˆˆ set.Ioo (LinearOrder.min A B) (LinearOrder.max A B) â†’ 0 â‰¤ g' x) : IntervalIntegrable g' MeasureTheory.MeasureSpace.Volume A B
(ð•œ : Type u_1) [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (F : E â†’ F) [MeasurableSpace E] [Opens_MeasurableSpace E] {K : set (E â†’L[ð•œ] F)} (hK : IsComplete K) : Measurable_set {x : E | Differentiable_at ð•œ F x âˆ§ fderiv ð•œ F x âˆˆ K}
{R : Type u} [CommSemiring R] [no_Zero_divisors R] (t : Multiset (Polynomial R)) : t.Prod.leading_Coeff = (Multiset.Map (Î» (F : Polynomial R), F.leading_Coeff) t).Prod
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] (x : C) : CategoryTheory.IsPullback 0 0 (ðŸ™ x) 0
{P n r B : â„•} (hp : Nat.Prime P) (hbn : Nat.log P n < B) : P ^ r âˆ£ n.factorial â†” r â‰¤ (Finset.Ico 1 B).Sum (Î» (i : â„•), n / P ^ i)
(n : â„•) : (List.Nat.antidiagonal n).length = n + 1
{Î± : Type u_1} [Preorder Î±] {F g : Î± â†’ Î±} (hF : Monotone F) (h : F â‰¤ g) (n : â„•) : F^[n] â‰¤ (g^[n])
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [Linear_ordered_AddCommGroup Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hF : Filter.Tendsto F l Filter.at_top) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), F x + g x) l Filter.at_top
{Î± : Type u_1} {S : Finset Î±} (P : Î± â†’ Prop) [Decidable_Pred P] : Finset.Map (Function.Embedding.Subtype P) (Finset.Subtype P S) = Finset.Filter P S
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m â†’+ P} (h : C â‰¤ Add_Con.Ker F) (hF : Function.Surjective â‡‘F) : Function.Surjective â‡‘(C.Lift F h)
{Î± : Type u_1} {Î² : Type u_3} [MeasurableSpace Î±] [MeasurableSpace Î²] : IsPiSystem (set.image2 has_set_Prod.Prod {S : set Î± | Measurable_set S} {t : set Î² | Measurable_set t})
{E : Type u_1} [InnerProductSpace â„ E] {n : â„•} (hn : 0 < n) (h : Finite_dimensional.finrank â„ E = n) (x : Orientation â„ E (Fin n)) : Orthonormal â„ â‡‘(Orientation.Fin_Orthonormal_Basis hn h x)
(C : Type u) [CategoryTheory.Category C] [âˆ€ {x Y : C} {F g : x âŸ¶ Y}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.ParallelPair F g)] : CategoryTheory.Limits.HasEqualizers C
{m : Type u_1} [AddZeroClass m] {Î¹ : sort u_2} (S : Î¹ â†’ Add_Submonoid m) {C : m â†’ Prop} {x : m} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : m), x âˆˆ S i â†’ C x) (h1 : C 0) (HMul : âˆ€ (x y : m), C x â†’ C y â†’ C (x + y)) : C x
{n : â„¤} (hn : n â‰  0) (z : â†¥Circle) : â‡‘(fourier n) (â‡‘Exp_Map_Circle ((â†‘n)â»Â¹ * Real.Pi) * z) = -â‡‘(fourier n) z
{Î² : Type u_1} [conditionally_CompleteLattice Î²] {S : set (WithTop Î²)} (hs : BddBelow S) : IsGlb S (HasInf.Inf S)
{n : â„•} (P : Fin (n + 2)) (i : Fin (n + 1)) (h : 0 < i) : 0 < â‡‘(P.Succ_above) i
{C : Type u} [CategoryTheory.Category C] {x Y Z : C} (F : x âŸ¶ Y) {g h : Y âŸ¶ Z} (W : g = h) : F â‰« g = F â‰« h
{Î± : Type u} {Î² : Type v} [SemilatticeInf Î±] {r : Î² â†’ Î² â†’ Prop} {F : Î± â†’ Î²} (hF : âˆ€ (Aâ‚ Aâ‚‚ : Î±), Aâ‚ â‰¤ Aâ‚‚ â†’ r (F Aâ‚‚) (F Aâ‚)) : Directed r F
(R : Type u) [Ring R] [strong_RankCondition R] (m : Type v) (n : Type W) [Fintype m] [Fintype n] : module.rank R (Matrix m n R) = (Cardinal.Mk m).Lift * (Cardinal.Mk n).Lift
{n : Type u_3} {Î± : Type v} {Î² : Type W} [has_Mul Î±] [has_Mul Î²] (F : Î± â†’ Î²) (r : Î±) (A : Matrix n n Î±) (hF : âˆ€ (Aâ‚ Aâ‚‚ : Î±), F (Aâ‚ * Aâ‚‚) = F Aâ‚ * F Aâ‚‚) : (Mul_Opposite.Op r â€¢ A).Map F = Mul_Opposite.Op (F r) â€¢ A.Map F
{B : â„•} (hb : 1 < B) {x y : â„•} : x â‰¤ B ^ y â†” Nat.clog B x â‰¤ y
{m : Type u_3} {N : Type u_4} {F : Type u_8} {mM : MulOneClass m} {mN : MulOneClass N} [Monoid_hom_class F m N] (F : F) {x : m} (hx : âˆƒ (y : m), y * x = 1) : âˆƒ (y : N), y * â‡‘F x = 1
{Î± : Type u} [PseudoEmetricSpace Î±] {Î´ : â„} {E : set Î±} : IsClosed (Metric.Cthickening Î´ E)
{x : Type u_1} [TopologicalSpace x] : DiscreteTopology x â†” nhds = has_pure.pure
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} (terminates : (GeneralizedContinuedFraction.of v).terminates) : âˆƒ (q : â„š), v = â†‘q
(x : AlgebraicGeometry.LocallyRingedSpace) (r : â†¥(AlgebraicGeometry.LocallyRingedSpace.Î“.obj (Opposite.Op x))) : x.toÎ“_spec_fun â»Â¹' (Prime_Spectrum.basic_IsOpen r).val = (x.to_RingedSpace.basic_IsOpen r).val
{Î¹ : Type W} [Fintype Î¹] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [module.Finite K L] [_IsSeparable K L] (B : Basis Î¹ K L) : Algebra.discr K â‡‘B â‰  0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (Pâ‚ Pâ‚‚ : Î¹ â†’ P) (B : P) : S.Sum (Î» (i : Î¹), W i â€¢ (Pâ‚ i -áµ¥ Pâ‚‚ i)) = â‡‘(S.weighted_vsub_of_point Pâ‚ B) W - â‡‘(S.weighted_vsub_of_point Pâ‚‚ B) W
{G : Type u_6} {h : Type u_7} {F : Type u_8} [AddGroup G] [subtraction_Monoid h] [AddMonoid_hom_class F G h] (F : F) (A : G) : â‡‘F (-A) = -â‡‘F A
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] (x : ð•œ) {ð•œ' : Type u_1} [nondiscrete_NormedField ð•œ'] [normed_Algebra ð•œ ð•œ'] {h : ð•œ â†’ ð•œ'} {hâ‚‚ : ð•œ' â†’ ð•œ'} {h' hâ‚‚' : ð•œ'} (hHâ‚‚ : HasDerivAt hâ‚‚ hâ‚‚' (h x)) (hH : HasDerivAt h h' x) : HasDerivAt (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x
{m : Type u_1} [CommMonoid m] (S : Submonoid m) {Î¹ : Type u_2} {t : Finset Î¹} {F : Î¹ â†’ m} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Prod (Î» (C : Î¹), F C) âˆˆ S
{J : Type v} {C : Type u} [CategoryTheory.Category C] {B : C} (F : CategoryTheory.Discrete J â¥¤ CategoryTheory.Over B) [CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.wide_pullback_Diagram_of_Diagram_over B F)] : CategoryTheory.Limits.HasLimit F
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] [UniformSpace Î²] [SeparatedSpace Î±] {F : Î± â†’ Î²} (hF : uniform_Inducing F) : uniform_Embedding F
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [RegularSpace Î±] [non_unital_non_assoc_Semiring Î±] [topological_Semiring Î±] {F : Î² â†’ Î±} {g : Î³ â†’ Î±} (hF : Summable F) (hg : Summable g) (hfg : Summable (Î» (x : Î² Ã— Î³), F x.fst * g x.Snd)) : (âˆ‘' (x : Î²), F x) * âˆ‘' (y : Î³), g y = âˆ‘' (z : Î² Ã— Î³), F z.fst * g z.Snd
{Î³ : Type u_3} [tÎ³ : TopologicalSpace Î³] [PolishSpace Î³] {Î² : Type u_1} [TopologicalSpace Î²] [t2_Space Î²] [MeasurableSpace Î²] [BorelSpace Î²] {F : Î³ â†’ Î²} (F_Cont : Continuous F) (F_inj : Function.Injective F) : Measurable_set (set.Range F)
{ð•œ : Type u_1} [_R_or_C ð•œ] {E : Type u_2} [InnerProductSpace ð•œ E] [CompleteSpace E] {t : E â†’L[ð•œ] E} (hT : InnerProductSpace.IsSelfAdjoint â†‘t) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0) (hextr : IsLocalExtr_on t.re_apply_inner_self (Metric.Sphere 0 âˆ¥xâ‚€âˆ¥) xâ‚€) : module.End.HasEigenvector â†‘t â†‘((Î» (x : E), t.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) xâ‚€) xâ‚€
(P : â„•) [hp : Fact (Nat.Prime P)] (q r : â„š) : padic_norm P (q + r) â‰¤ padic_norm P q + padic_norm P r
{Î± : Type u} {Î² : Type v} [Preorder Î²] {F : Î± â†’ Î²} {l : Filter Î±} {A : Î±} : IsMax_Filter F l A â†’ IsMin_Filter (â‡‘order_dual.to_dual âˆ˜ F) l A
{F : â„ â†’ â„} {A B : â„} (h0 : 0 < B) (h1 : Continuous_on F (set.ici A)) (h2 : F =O[Filter.at_top] Î» (x : â„), Real.Exp (-B * x)) : MeasureTheory.IntegrableOn F (set.ioi A) MeasureTheory.MeasureSpace.Volume
 : MeasureTheory.Measure.Add_haar_measure TopologicalSpace.PositiveCompacts.icc01 = MeasureTheory.MeasureSpace.Volume
(R : Type u_1) [CommRing R] : Algebra.Finite_presentation R R
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Antitone F) : Pairwise (Disjoint on Î» (n : Î±), set.Ioo (F n) (F (Order.Pred n)))
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S : set Î±} (hF : set.Eq_on F 0 S) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) = 0
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] (F : S.Localization_Map N) (z : N) : F.Mk' (F.sec z).fst (F.sec z).Snd = z
(Î± : Type u) [Preorder Î±] [Nonempty Î±] [NoMaxOrder Î±] : âˆƒ (F : â„• â†’ Î±), StrictMono F
{Î± : Type u} [Preorder Î±] [OrderBot Î±] {A B : Î±} (h : A < B) : B â‰  âŠ¥
{Î± : Type u_1} {Î² : Type u_2} {l : Filter Î±} {F g : Î± â†’ Î²} : F =á¶ [l] g â†’ â†‘F = â†‘g
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (hx : x â‰  0) (hy : y â‰  0) : o.oangle x (-y) = o.oangle x y + â†‘Real.Pi
{R : Type u} [CommRing R] (S : Submonoid R) {L : Type u} [CommRing L] [Algebra R L] [IsLocalization S L] [Fintype R] : Function.Surjective â‡‘(Algebra_Map R L)
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [AddCommMonoid Î²] {S : Finset Î±} {t : Finset Î³} {F : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (A : Î±), A âˆˆ S â†’ Î³) (hi : âˆ€ (A : Î±) (ha : A âˆˆ S), i A ha âˆˆ t) (h : âˆ€ (A : Î±) (ha : A âˆˆ S), F A = g (i A ha)) (j : Î  (A : Î³), A âˆˆ t â†’ Î±) (hj : âˆ€ (A : Î³) (ha : A âˆˆ t), j A ha âˆˆ S) (Left_Inv : âˆ€ (A : Î±) (ha : A âˆˆ S), j (i A ha) _ = A) (Right_Inv : âˆ€ (A : Î³) (ha : A âˆˆ t), i (j A ha) _ = A) : S.Sum (Î» (x : Î±), F x) = t.Sum (Î» (x : Î³), g x)
{Î± : sort u} {C : Î± â†’ sort v} {r : Î± â†’ Î± â†’ Prop} (hwf : WellFounded r) (F : Î  (x : Î±), (Î  (y : Î±), r y x â†’ C y) â†’ C x) (x : Î±) : hwf.fix F x = F x (Î» (y : Î±) (h : r y x), hwf.fix F y)
(A : â†¥Circle) : â‡‘(Linear_Map.to_Matrix Complex.Basis_One_i Complex.Basis_One_i) â†‘((â‡‘rotation A).to_Linear_Equiv) = â‡‘(Matrix.plane_conformal_Matrix â†‘A.re â†‘A.im _)
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (r : R) : v.Int_Valuation_def r < 1 â†” v.as_Ideal âˆ£ Ideal.Span {r}
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.Normal] (hN : (Fintype.Card â†¥N).IsCoprime N.Index) : âˆƒ (h : Subgroup G), N.Complement' h
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] (A : A) (hF : Function.Injective â‡‘(Algebra_Map A B)) : minpoly A (â‡‘(Algebra_Map A B) A) = Polynomial.x - â‡‘Polynomial.C A
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : â„•} (S : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : â„•} (h : fs.Card = m + 1) : (S.face h).points = S.points âˆ˜ â‡‘(fs.order_emb_of_Fin h)
{Î± : Type u_2} [division_Monoid Î±] {A : Î±} : IsSquare A â†’ IsSquare Aâ»Â¹
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [_R_or_C ð•‚] [NormedRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] {Î¹ : Type u_3} (S : Finset Î¹) (F : Î¹ â†’ ð”¸) (h : âˆ€ (i : Î¹), i âˆˆ S â†’ âˆ€ (j : Î¹), j âˆˆ S â†’ Commute (F i) (F j)) : Exp ð•‚ (S.Sum (Î» (i : Î¹), F i)) = S.noncomm_Prod (Î» (i : Î¹), Exp ð•‚ (F i)) _
{Î± : Type u_1} {ð’œ : Finset (Finset Î±)} {r : â„•} : set.sized r â†‘(ð’œ.Slice r)
{Î± : Type u_1} {S : Finset Î±} {F : Î± â†’ Ennreal} (h : âˆ€ (A : Î±), A âˆˆ S â†’ F A â‰  âŠ¤) : S.Prod (Î» (A : Î±), F A) < âŠ¤
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [module k E] [AddTorsor E PE] (F : k â†’ PE) (A B C : k) (h : A â‰  C) : â‡‘(affine_Map.line_Map (slope F A B) (slope F B C)) ((C - B) / (C - A)) = slope F A C
{R : Type u_1} [Ring R] {E : Type u_2} [AddCommGroup E] [module R E] {F : Type u_3} [AddCommGroup F] [module R F] (F g : LinearPmap R E F) (h : Disjoint F.IsDomain g.IsDomain) (x : â†¥(F.IsDomain)) (y : â†¥(g.IsDomain)) (hxy : â†‘x = â†‘y) : â‡‘F x = â‡‘g y
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [CharZero k] {S : Finset Î¹} (P : Î¹ â†’ P) {n : â„•} (h : S.Card = n + 1) : Finset.centroid k S P âˆˆ affine_Span k (set.Range P)
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (P1 P2 : P) : P1 âˆˆ affine_Span k {P2} â†” P1 = P2
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 1 R = Polynomial.x - 1
{Î± : Type u_1} {Î³ : Type u_3} [TopologicalSpace Î±] [MeasurableSpace Î±] [Opens_MeasurableSpace Î±] [TopologicalSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³] {F g : Î± â†’ Î³} {S : set Î±} [Î  (j : Î±), Decidable (j âˆˆ S)] (hF : Continuous_on F S) (hg : Continuous_on g Sá¶œ) (hs : Measurable_set S) : Measurable (S.piecewise F g)
(P : â„•) : padic_norm P 0 = 0
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} {R : Type u_11} [Semiring R] [AddCommMonoid m] [AddCommMonoid N] [Distrib_MulAction R m] [Distrib_MulAction R N] {F g : (Î± â†’â‚€ m) â†’+[R] N} (h : âˆ€ (A : Î±), F.Comp (Finsupp.Distrib_MulAction_hom.single A) = g.Comp (Finsupp.Distrib_MulAction_hom.single A)) : F = g
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (F : m â†’â‚—[R] m) [hfg : module.Finite R m] (F_surj : Function.Surjective â‡‘F) : Function.Injective â‡‘F
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x : Î±} (hx : x âˆˆ Closure S) : metric.Inf_dist x S = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 : P} (h : P1 â‰  P2) : EuclideanGeometry.angle P1 P2 P1 = 0
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] {mâ‚ : Type v} [AddCommGroup mâ‚] [module R mâ‚] (F : m â‰ƒâ‚—[R] mâ‚) : module.rank R m = module.rank R mâ‚
{Î± : Type u_1} [LinearOrder Î±] {A B C D : Î±} (hâ‚ : LinearOrder.min A B < LinearOrder.max C D) (hâ‚‚ : LinearOrder.min C D < LinearOrder.max A B) : set.icc A B âˆª set.icc C D = set.icc (LinearOrder.min A C) (LinearOrder.max B D)
{Î± : Type u} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] : {S : set Î± | IsPreconnected S} âŠ† set.Range (Function.uncurry set.icc) âˆª set.Range (Function.uncurry set.Ico) âˆª set.Range (Function.uncurry set.ioc) âˆª set.Range (Function.uncurry set.Ioo) âˆª (set.Range set.ici âˆª set.Range set.ioi âˆª set.Range set.Iic âˆª set.Range set.Iio âˆª {set.Univ, âˆ…})
{R : Type v} [CommRing R] {n : â„•} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R} (C : Fin n â†’ R) (A_Zero : âˆ€ (i : Fin (n + 1)), A i 0 = B i 0) (A_Succ : âˆ€ (i : Fin (n + 1)) (j : Fin n), A i j.Succ = B i j.Succ + C j * A i (â‡‘Fin.cast_Succ j)) : A.det = B.det
{Î¹ : Type u} {F g : Î¹ â†’ â„} {P : â„} (hp : 1 â‰¤ P) (hF : âˆ€ (i : Î¹), 0 â‰¤ F i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) (hF_Sum : Summable (Î» (i : Î¹), F i ^ P)) (hg_Sum : Summable (Î» (i : Î¹), g i ^ P)) : Summable (Î» (i : Î¹), (F i + g i) ^ P) âˆ§ (âˆ‘' (i : Î¹), (F i + g i) ^ P) ^ (1 / P) â‰¤ (âˆ‘' (i : Î¹), F i ^ P) ^ (1 / P) + (âˆ‘' (i : Î¹), g i ^ P) ^ (1 / P)
{Î± : Type u} [PseudoMetricSpace Î±] {x : Î±} {r : â„} (h : 0 â‰¤ r) : Metric.diam (Metric.Ball x r) â‰¤ 2 * r
{n : â„•} : Function.Injective Fin.Succ_above
{R : Type u_1} [Semiring R] (F : laurent_Polynomial R) (m n : â„¤) : F * laurent_Polynomial.t m * laurent_Polynomial.t n = F * laurent_Polynomial.t (m + n)
{Î± : Type u_1} [LinearOrder Î±] {S : Finset Î±} {k : â„•} (h : S.Card = k) {F : Fin k â†ªo Î±} (hfs : âˆ€ (x : Fin k), â‡‘F x âˆˆ S) : F = S.order_emb_of_Fin h
{Î± : Type u_1} [circular_Preorder Î±] {A B C : Î±} (h : HasSbtw.Sbtw A B C) : HasSbtw.Sbtw C A B
{G : Type u_1} [Group G] (h : Subgroup G) [h.Normal] [h : Group.IsNilpotent G] : Group.nilpotency_class (G â§¸ h) â‰¤ Group.nilpotency_class G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} (F : top.Presheaf C x) {x : â†¥x} {Y : C} {Fâ‚ Fâ‚‚ : F.stalk x âŸ¶ Y} (ih : âˆ€ (U : TopologicalSpace.Opens â†¥x) (hxU : x âˆˆ U), F.germ âŸ¨x, hxUâŸ© â‰« Fâ‚ = F.germ âŸ¨x, hxUâŸ© â‰« Fâ‚‚) : Fâ‚ = Fâ‚‚
{ð•œ : Type u_1} {_x : Ring ð•œ} {E : Type u_2} [semi_NormedGroup E] {_x_1 : module ð•œ E} {S : Submodule ð•œ E} (x : â†¥S) : âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
{ð•œ : Type u_1} {E : Type u_2} [ordered_Ring ð•œ] [AddCommGroup E] [module ð•œ E] {K : Geometry.SimplicialComplex ð•œ E} {S t : Finset E} (hs : S âˆˆ K.Faces) (ht : t âˆˆ K.Faces) : Disjoint (â‡‘(Convex_hull ð•œ) â†‘S) (â‡‘(Convex_hull ð•œ) â†‘t) âˆ¨ âˆƒ (u : Finset E) (h : u âˆˆ K.Faces), â‡‘(Convex_hull ð•œ) â†‘S âˆ© â‡‘(Convex_hull ð•œ) â†‘t = â‡‘(Convex_hull ð•œ) â†‘u
{G : Type u} [Group G] [Fintype G] (P : â„•) {n m : â„•} [hp : Fact (Nat.Prime P)] (hdvd : P ^ m âˆ£ Fintype.Card G) (h : Subgroup G) (hH : Fintype.Card â†¥h = P ^ n) (hnm : n â‰¤ m) : âˆƒ (K : Subgroup G), Fintype.Card â†¥K = P ^ m âˆ§ h â‰¤ K
{A : Type u_4} (K : Type u_5) [CommRing A] [IsDomain A] (L : Type u_6) [Field K] [Field L] [Algebra A K] [_fraction_Ring A K] [Algebra A L] [Algebra K L] [IsScalarTower A K L] [Finite_dimensional K L] : _fraction_Ring â†¥(integral_Closure A L) L
{Î± : Type u_1} {Î² : Type u_2} {m : MeasurableSpace Î±} [TopologicalSpace Î²] {F : Î± â†’ Î²} (hF : âˆ€ (x y : Î±), F x = F y) : MeasureTheory.strongly_Measurable F
{F : â„ â†’ â„} (hF : Differentiable â„ F) (hF'_anti : Antitone (deriv F)) : ConcaveOn â„ set.Univ F
(j : â„•) : Â¬AlgebraicTopology.DoldKan.C.Rel 0 j
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [CharZero k] {n : â„•} (S : Affine.Simplex k P n) {fsâ‚ fsâ‚‚ : Finset (Fin (n + 1))} {mâ‚ mâ‚‚ : â„•} (hâ‚ : fsâ‚.Card = mâ‚ + 1) (hâ‚‚ : fsâ‚‚.Card = mâ‚‚ + 1) : Finset.centroid k fsâ‚ S.points = Finset.centroid k fsâ‚‚ S.points â†” fsâ‚ = fsâ‚‚
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (A B : F) : Char.quadratic_Char F (A * B) = Char.quadratic_Char F A * Char.quadratic_Char F B
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} {t : Add_Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) {q : Type u_4} [AddCommMonoid q] {k : t.Localization_Map q} (z : N) : â‡‘(F.Map hy k) z + â‡‘(k.to_Map) (â‡‘g â†‘((F.sec z).Snd)) = â‡‘(k.to_Map) (â‡‘g (F.sec z).fst)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} (P : Î¹ â†’ P) (i0 : Î¹) : Vector_Span k (set.Range P) = Submodule.Span k (set.Range (Î» (i : Î¹), P i -áµ¥ P i0))
{Î± : Type u} [PseudoEmetricSpace Î±] {S : set Î±} : Isometry Coe
{Î± : Type u_1} {R : Type u_2} [CommSemiring R] (A B : R) (S : Finset Î±) : S.powerset.Sum (Î» (t : Finset Î±), A ^ t.Card * B ^ (S.Card - t.Card)) = (A + B) ^ S.Card
{K : Type u} [Field K] (S : Subfield K) {x y : K} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{Î± : Type u_1} [has_Add Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B C D : Î±} (hâ‚ : A < B) (hâ‚‚ : C < D) : A + C < B + D
{Î± : Type u} [HasSsubset Î±] [IsIrrefl Î± HasSsubset.Ssubset] {A B : Î±} : A âŠ‚ B â†’ A â‰  B
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : âŠ¤.direction = âŠ¤
{R : Type u_1} {A B : R} [Monoid R] (h : A * B = 1) : IsRightRegular A
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : MeasurableSpace Î±} {mâ‚‚ : MeasurableSpace Î²} {F : Î± â†’ Î²} : Measurable F â†’ mâ‚‚ â‰¤ MeasurableSpace.Map F mâ‚
{Î± : Type u_1} {E : Type u_3} {F'' : Type u_10} [HasNorm E] [NormedGroup F''] {F : Î± â†’ E} {g'' : Î± â†’ F''} (h : F =O[Filter.cofinite] g'') : âˆƒ (C : â„) (h : C > 0), âˆ€ â¦ƒx : Î±â¦„, g'' x â‰  0 â†’ âˆ¥F xâˆ¥ â‰¤ C * âˆ¥g'' xâˆ¥
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : RË£) : (Î» (t : R), Ring.Inverse (â†‘x + t) - â†‘xâ»Â¹ + â†‘xâ»Â¹ * t * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ 2
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [module ð•œ E] {x z : E} {S : set E} (hs : Star_Convex ð•œ (x + z) S) : Star_Convex ð•œ x ((Î» (x : E), x + z) â»Â¹' S)
{F : Type u_1} [Field F] {P : Polynomial F} {E : Type u_2} [Field E] [Algebra F E] [Fact (Polynomial.Splits (Algebra_Map F E) P)] (Ï• : E â‰ƒâ‚[F] E) (x : â†¥(P.root_set E)) : â†‘(â‡‘(Polynomial.Gal.Restrict P E) Ï• â€¢ x) = â‡‘Ï• â†‘x
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {Î¹ : Type u_1} [Fintype Î¹] {B : Î¹ â†’ v} : LinearIndependent K B â†” Fintype.Card Î¹ = set.finrank K (set.Range B)
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (hx : x â‰  0) (hy : y â‰  0) : Real.sin (InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = Real.sin (InnerProductGeometry.angle x y)
{R : Type u_1} [has_Mul R] {A : R} : IsRightRegular A â†” IsSmulRegular R (Mul_Opposite.Op A)
{Î¹ : Type u_1} {E : Type u_2} [Fintype Î¹] [NormedGroup E] [NormedSpace â„ E] (B : affine_Basis Î¹ â„ E) : Interior (â‡‘(Convex_hull â„) (set.Range B.points)) = {x : E | âˆ€ (i : Î¹), 0 < â‡‘(B.coord i) x}
{Î± : Type u_1} {Î² : Type u_2} {S : set Î±} {u : Î± â†’ set Î²} {x : Î±} (xs : x âˆˆ S) : u x âŠ† â‹ƒ (x : Î±) (h : x âˆˆ S), u x
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) (v : E) : v âˆˆ Ká—® â†” âˆ€ (u : E), u âˆˆ K â†’ HasInner.inner u v = 0
{m : Type u_1} [has_Add m] (C : Add_Con m) {A B : m} : â†‘A = â†‘B â†” â‡‘C A B
{G : Type u} [Fintype G] [Left_cancel_Monoid G] (x : G) : 0 < order_of x
{Î± : Type u_1} {Î¹ : sort u_4} {S : Î¹ â†’ set Î±} {t : set Î±} (i : Î¹) (h : S i âŠ† t) : (â‹‚ (i : Î¹), S i) âŠ† t
{Î± : Type u} (S : set Î±) : Subsingleton â†¥S â†” S.Subsingleton
(R : Type u_2) {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] (n : â„•) (B : m) : n â€¢ B = â†‘n â€¢ B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : E â†’ F Ã— G} {x : E} (hF : ContDiff_at ð•œ n F x) : ContDiff_at ð•œ n (Î» (x : E), (F x).fst) x
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {Râ‚ Râ‚‚ : â„} {F : â„‚ â†’ E} {C z : â„‚} (hD : DifferentiableOn â„‚ F (Metric.Ball C Râ‚)) (h_maps : set.maps_to F (Metric.Ball C Râ‚) (Metric.Ball (F C) Râ‚‚)) (hz : z âˆˆ Metric.Ball C Râ‚) : âˆ¥dslope F C zâˆ¥ â‰¤ Râ‚‚ / Râ‚
{Î± : Type u_1} [MeasurableSpace Î±] (mâ‚ mâ‚‚ : MeasureTheory.OuterMeasure Î±) : (mâ‚ âŠ” mâ‚‚).trim = mâ‚.trim âŠ” mâ‚‚.trim
{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (B : â„¤), âˆ€ (z : â„¤), P z â†’ B â‰¤ z) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (lb : â„¤), P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z
{F : Polynomial â„‚} (hF : 0 < F.degree) : âˆƒ (z : â„‚), F._root z
{k : Type u_1} {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {P : Î¹ â†’ P} (hi : AffineIndependent k P) {S : Finset Î¹} {n : â„•} (hc : S.Card = n + 1) : Finite_dimensional.finrank k â†¥(Vector_Span k â†‘(Finset.image P S)) = n
{Î± : Type u_1} {ð•œ : Type u_14} [NormedField ð•œ] {l : Filter Î±} {u v : Î± â†’ ð•œ} (h : u =O[l] v) : u / v * v =á¶ [l] u
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} [DiscreteTopology â†¥S] {x : Î±} (hx : x âˆˆ S) : âˆƒ (U : set Î±) (h : U âˆˆ nhds_within x {x}á¶œ), Disjoint U S
{Î± : Type u} [SemilatticeInf Î±] [Nonempty Î±] (S : Finset Î±) : BddBelow â†‘S
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 : P} : P1 -áµ¥ P2 = 0 â†” P1 = P2
{Î± : Type u} {Î² : Type v} [Ring Î±] [Ring Î²] {F : Î± â†’ Î²} {x y : Î±} (hF : _Ring_hom F) : F (x - y) = F x - F y
{Î± : sort u} {Î±' : sort W} [DecidableEq Î±] [DecidableEq Î±'] {Î² : sort u_1} (g : Î±' â†’ Î²) {F : Î± â†’ Î±'} (hF : Function.Injective F) (i : Î±) (A : Î²) : Function.update g (F i) A âˆ˜ F = Function.update (g âˆ˜ F) i A
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {F : Î± â†’ Î²} {S : set Î±} {A : Î±} (h_Mono : Monotone_on F S) (hs : S âˆˆ nhds_within A (set.ici A)) (hfs : âˆ€ (B : Î²), B > F A â†’ (âˆƒ (C : Î±) (h : C âˆˆ S), F C âˆˆ set.Ioo (F A) B)) : Continuous_within_at F (set.ici A) A
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (F : J â†’ C) [CategoryTheory.Limits.HasBiproduct F] {B : CategoryTheory.Limits.Bicone F} (hb : B._bilimit) : (hb._Limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.biproduct._Limit F)).hom = CategoryTheory.Limits.biproduct.Lift B.Ï€
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {F g : â„‚ â†’ E} (hdf : Diff_Cont_on_cl â„‚ F (set.Iio 0 Ã—â„‚ set.Iio 0)) (hBf : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.Iio 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hdg : Diff_Cont_on_cl â„‚ g (set.Iio 0 Ã—â„‚ set.Iio 0)) (hBg : âˆƒ (C : â„) (h : C < 2) (B : â„), g =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal (set.Iio 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ F â†‘x = g â†‘x) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ F (â†‘x * Complex.i) = g (â†‘x * Complex.i)) : set.Eq_on F g {z : â„‚ | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}
{F : Type u_2} [NormedGroup F] {F : â„ â†’ F} {A B C : â„} (hF : (Î» (x : â„), (x - C)â»Â¹) =O[nhds_within C {C}á¶œ] F) (hne : A â‰  B) (hc : C âˆˆ set.Interval A B) : Â¬IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} {C : CategoryTheory.Limits.Fork F g} (i : CategoryTheory.Limits.IsLimit C) : CategoryTheory.Mono C.Î¹
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m â†’+ P} (h : C â‰¤ Add_Con.Ker F) : (C.Lift F h).Comp C.Mk' = F
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} {P : Type u_8} [has_Zero m] [AddCommMonoid N] [AddCommMonoid P] (h : N â†’+ P) (F : Î± â†’â‚€ m) (g : Î± â†’ m â†’ N) : â‡‘h (F.Sum g) = F.Sum (Î» (A : Î±) (B : m), â‡‘h (g A B))
(A : Zmod 8) : â‡‘Zmod.Ï‡â‚ˆ' A = â‡‘Zmod.Ï‡â‚„ â†‘A * â‡‘Zmod.Ï‡â‚ˆ A
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A B : Î±} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_NormedField R] [NormedGroup F] [NormedSpace R F] [TopologicalSpace B] {Î¹ : Type u_6} (Z : TopologicalVectorBundleCore R B F Î¹) : Continuous Z.Proj
{Î± : Type u_1} {Î² : Type u_2} [Infinite Î±] [Fintype Î²] (F : Î± â†’ Î²) : âˆƒ (x y : Î±), x â‰  y âˆ§ F x = F y
{F : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [non_assoc_Semiring Î±] [non_assoc_Semiring Î²] [Ring_hom_class F Î± Î²] (F : F) (A : Î±) : â‡‘F (bit1 A) = bit1 (â‡‘F A)
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} {x : Î±} {r : â„} (h : x âˆˆ S) (h : metric.Hausdorff_dist S t < r) (Fin : Emetric.Hausdorff_edist S t â‰  âŠ¤) : âˆƒ (y : Î±) (h : y âˆˆ t), HasDist.dist x y < r
{Î± : Type u_1} [cancel_CommMonoid_with_Zero Î±] [Unique_factorization_Monoid Î±] {A P : Associates Î±} (hp : Irreducible P) [Î  (n : â„•), Decidable (A âˆ£ P ^ n)] {n : â„•} (h : A âˆ£ P ^ n) : A = P ^ Nat.Find _
{R : Type u_1} [Semiring R] (S : Subsemiring R) {l : List R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ S) â†’ l.Prod âˆˆ S
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [Ring_hom_isometric Ïƒâ‚â‚‚] (F g : E â†’sl[Ïƒâ‚â‚‚] F) : âˆ¥F + gâˆ¥ â‰¤ âˆ¥Fâˆ¥ + âˆ¥gâˆ¥
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ AddMon) [CategoryTheory.IsFiltered J] (x y : Î£ (j : J), â†¥(F.obj j)) (k : J) (F : x.fst âŸ¶ k) (g : y.fst âŸ¶ k) : AddMon.FilteredColimits.m.Mk F x + AddMon.FilteredColimits.m.Mk F y = AddMon.FilteredColimits.m.Mk F âŸ¨k, â‡‘(F.Map F) x.Snd + â‡‘(F.Map g) y.SndâŸ©
{G : Type u_1} [AddGroup G] [hN : Nontrivial G] : AddMonoid._torsion_free G â†’ Â¬AddMonoid._torsion G
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] (e : LocalHomeomorph Î± Î²) (S : set Î²) : e.to_local_Equiv.Source âˆ© â‡‘e â»Â¹' Interior S = e.to_local_Equiv.Source âˆ© Interior (â‡‘e â»Â¹' S)
{G : Type u_10} {h : Type u_11} [Group G] [division_Monoid h] (h : G â‰ƒ* h) (x : G) : â‡‘h xâ»Â¹ = (â‡‘h x)â»Â¹
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} {r : R} (h : SameRay R x y) (hr : 0 â‰¤ r) : SameRay R (r â€¢ x) y
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : o.oangle (â‡‘(o.rotation (o.oangle x y)) x) y = 0
{Î± : Type u_1} [UniformSpace Î±] : (Uniformity Î±).has_Basis (Î» (v : set (Î± Ã— Î±)), v âˆˆ Uniformity Î±) Closure
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {Î¹ : Type W} (h : Basis Î¹ K v) : â†‘(Finite_dimensional.finrank K v) = Cardinal.Mk Î¹
{Î± : Type u_1} {m : Type u_5} [has_Zero m] : Function.Injective Coe_fn
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) {r : Nnreal} (hâ‚€ : r â‰  0) {A : â„} (ha : A âˆˆ set.Ioo (-1) 1) (hp : (Î» (n : â„•), âˆ¥P nâˆ¥ * â†‘r ^ n) =O[Filter.at_top] has_Pow.Pow A) : â†‘r < P.radius
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (x : Î± (Fin.Last n)) (P : Î  (i : Fin n), Î± (â‡‘Fin.cast_Succ i)) (z : Î± (Fin.Last n)) : Function.update (Fin.snoc P x) (Fin.Last n) z = Fin.snoc P z
{Î± : Type u} [TopologicalSpace Î±] [LocallyCompactSpace Î±] [RegularSpace Î±] {K U : set Î±} (hK : IsCompact K) (hU : IsOpen U) (hKU : K âŠ† U) : âˆƒ (v : set Î±), IsOpen v âˆ§ K âŠ† v âˆ§ Closure v âŠ† U âˆ§ IsCompact (Closure v)
(K : Type u_1) [Field K] [_alg_IsClosed K] (S : set â„•+) : IsCyclotomicExtension S K K
{Î± : Type u} [HasSubset Î±] [IsTrans Î± HasSubset.Subset] {A B C : Î±} : A âŠ† B â†’ B âŠ† C â†’ A âŠ† C
(F : Circle_deg1_Lift) (x : â„) : Filter.Tendsto (Î» (n : â„•), (â‡‘(F ^ n) x - x) / â†‘n) Filter.at_top (nhds F.TranslationNumber)
{Î± : Type u_1} {Î¹ : sort u_3} [conditionally_CompleteLattice Î±] {B : Î±} [Nonempty Î¹] {F : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), F i â‰¤ B) (hâ‚‚ : âˆ€ (W : Î±), W < B â†’ (âˆƒ (i : Î¹), W < F i)) : (â¨† (i : Î¹), F i) = B
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F g : E â†’ Î²} (hF : ConcaveOn ð•œ S F) (hg : ConcaveOn ð•œ S g) : ConcaveOn ð•œ S (F âŠ“ g)
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [AddCommMonoid N] (F : Î± â†’â‚€ m) (y : Î±) (g : Î± â†’ m â†’ N) (hg : âˆ€ (i : Î±), g i 0 = 0) : g y (â‡‘F y) + (Finsupp.erase y F).Sum g = F.Sum g
{C : Type u} [CategoryTheory.Category C] {P q R : C} (F : P âŸ¶ q) (g : q âŸ¶ R) [CategoryTheory.StrongMono F] [CategoryTheory.StrongMono g] : CategoryTheory.StrongMono (F â‰« g)
{x : Type u_2} [EmetricSpace x] {mâ‚ mâ‚‚ : Ennreal â†’ Ennreal} {C : Ennreal} (hc : C â‰  âŠ¤) (h0 : C â‰  0) (hle : mâ‚ â‰¤á¶ [nhds_within 0 (set.ici 0)] C â€¢ mâ‚‚) : MeasureTheory.OuterMeasure.Mk_metric mâ‚ â‰¤ C â€¢ MeasureTheory.OuterMeasure.Mk_metric mâ‚‚
{Î± : Type u_1} [MeasurableSpace Î±] {Î¹ : Type u_2} {F : Î¹ â†’ Î± â†’ Ennreal} {g : Î± â†’ Ennreal} (u : Filter Î¹) [u.Ne_IsBot] [u._countably_generated] (hF : âˆ€ (i : Î¹), Measurable (F i)) (lim : Filter.Tendsto F u (nhds g)) : Measurable g
{m : Type u} [Monoid m] {F : Type v} [DivisionRing F] [Mul_Semiring_action m F] (x : m) (m : F) : x â€¢ mâ»Â¹ = (x â€¢ m)â»Â¹
{Î± : Type u_1} [PseudoEmetricSpace Î±] {F : â„• â†’ Î±} (D : â„• â†’ Ennreal) (hF : âˆ€ (n : â„•), HasEdist.edist (F n) (F n.Succ) â‰¤ D n) {A : Î±} (ha : Filter.Tendsto F Filter.at_top (nhds A)) (n : â„•) : HasEdist.edist (F n) A â‰¤ âˆ‘' (m : â„•), D (n + m)
{C : Type u} [CategoryTheory.Category C] (F : Cáµ’áµ– â¥¤ Type v) : (CategoryTheory.Category_of_Elements.from_CostructuredArrow F).Right_Op â‹™ CategoryTheory.Category_of_Elements.to_CostructuredArrow F = ðŸ­ (CategoryTheory.CostructuredArrow CategoryTheory.yoneda F)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) : 2 â€¢ o.oangle x (-x) = 0
{m : Type u_1} [Monoid_with_Zero m] {F g : â„¤ â†’*â‚€ m} (h_Neg_One : â‡‘F (-1) = â‡‘g (-1)) (h_Nat : F.Comp Int.of_Nat_hom.to_Monoid_with_ZeroHom = g.Comp Int.of_Nat_hom.to_Monoid_with_ZeroHom) : F = g
{vâ‚ : Type u_2} {vâ‚‚ : Type u_3} [semi_NormedGroup vâ‚] [semi_NormedGroup vâ‚‚] (F : NormedGroup_hom vâ‚ vâ‚‚) {m : â„} (hMp : 0 â‰¤ m) (hM : âˆ€ (x : vâ‚), âˆ¥â‡‘F xâˆ¥ â‰¤ m * âˆ¥xâˆ¥) : âˆ¥Fâˆ¥ â‰¤ m
{v : Type u_1} [InnerProductSpace â„ v] (x : v) : InnerProductGeometry.angle 0 x = Real.Pi / 2
{n : â„•} {Î± : Type u_1} [Preorder Î±] {F g : Fin n â†’ Î±} (hF : StrictMono F) (hg : StrictMono g) (h : set.Range F = set.Range g) : F = g
{R : Type u_1} [Fintype R] [CommRing R] [IsReduced R] [Char_P R 2] (A : R) : IsSquare A
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : F =O[l] g' â†” âˆ€á¶  (C : â„) in Filter.at_top, âˆ€á¶  (x : Î±) in l, âˆ¥F xâˆ¥ â‰¤ C * âˆ¥g' xâˆ¥
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_3} (K : Î¹ â†’ Submodule ð•œ E) : (â¨… (i : Î¹), (K i)á—®) = (supr K)á—®
{R : Type u} {K : Type v} {L : Type z} {P : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [_IsSeparable K L] [IsDomain R] [normalized_Gcd_Monoid R] [_fraction_Ring R K] [_integrally_IsClosed R] {B : power_Basis K L} (hp : Prime P) (hBint : IsIntegral R B.gen) {n : â„•} {z : L} (hzint : IsIntegral R z) (hz : P ^ n â€¢ z âˆˆ Algebra.Adjoin R {B.gen}) (hei : (minpoly R B.gen)._eisenstein_at (Submodule.Span R {P})) : z âˆˆ Algebra.Adjoin R {B.gen}
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] {F : Î² â†’ Î±} : Metric.Bounded (set.Range F) â†” âˆƒ (C : â„), âˆ€ (x y : Î²), HasDist.dist (F x) (F y) â‰¤ C
{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (m : Matrix n n R) (k : â„•) : m ^ k = â‡‘(Polynomial.aeval m) (Polynomial.x ^ k %â‚˜ m.charpoly)
{Î± : Type u_1} [LinearOrder Î±] [DecidableEq Î±] {P : Finset Î± â†’ Prop} (S : Finset Î±) (h0 : P âˆ…) (step : âˆ€ (A : Î±) (S : Finset Î±), (âˆ€ (x : Î±), x âˆˆ S â†’ A < x) â†’ P S â†’ P (HasInsert.Insert A S)) : P S
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_coproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.Normal_Epi_Category C] {x Y : C} (F g : x âŸ¶ Y) : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.ParallelPair F g)
{k : Type u_1} {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Finite_dimensional k v] [Fintype Î¹] {P : Î¹ â†’ P} (hi : AffineIndependent k P) : affine_Span k (set.Range P) = âŠ¤ â†” Fintype.Card Î¹ = Finite_dimensional.finrank k v + 1
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 : P) (hp1P2 : P1 â‰  P2) : EuclideanGeometry.angle P1 (midpoint â„ P1 P2) P2 = Real.Pi
(m : Type u_1) (Î± : Type u_2) [Monoid m] [MulAction m Î±] {P q : Submonoid m} : MulAction.FixedPoints â†¥(P âŠ” q) Î± = MulAction.FixedPoints â†¥P Î± âˆ© MulAction.FixedPoints â†¥q Î±
{m : Type u_1} [Group_with_Zero m] : set.Center mË£ = Coe â»Â¹' set.Center m
{Î± : Type u} {n : â„•} (F : Fin n â†’ Î±) (i : â„•) : (List.of_fn F).nth i = List.of_fn_nth_val F i
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x y : E} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ ^ 2
{F : Type u_3} [InnerProductSpace â„ F] (x y : F) : HasInner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ x
{Î¹ : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] [ParacompactSpace x] (P : (x â†’ â„) â†’ Prop) (h01 : âˆ€ (S t : set x), IsClosed S â†’ IsClosed t â†’ Disjoint S t â†’ (âˆƒ (F : C(x, â„)), P â‡‘F âˆ§ set.Eq_on â‡‘F 0 S âˆ§ set.Eq_on â‡‘F 1 t âˆ§ âˆ€ (x : x), â‡‘F x âˆˆ set.icc 0 1)) (hs : IsClosed S) (U : Î¹ â†’ set x) (ho : âˆ€ (i : Î¹), IsOpen (U i)) (hU : S âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (F : BumpCovering Î¹ x S), (âˆ€ (i : Î¹), P â‡‘(â‡‘F i)) âˆ§ F._subordinate U
{Î± : Type u_1} {Î² : Type u_2} {F : Î± â†’. Î² âŠ• Î±} (A A' : Î±) (ha' : Sum.inr_ A' âˆˆ F A) : F.fix A = F.fix A'
{Î± : Type u_1} [TopologicalSpace Î±] [t2_Space Î±] {F : Î± â†’ Î±} (hF : Continuous F) : IsClosed (Function.FixedPoints F)
{S : set â„} : IsPreconnected S â†’ Convex â„ S
{Fâ‚ Fâ‚‚ : Circle_deg1_LiftË£} (h : â†‘Fâ‚.TranslationNumber = â†‘Fâ‚‚.TranslationNumber) : âˆƒ (F : Circle_deg1_Lift), Function.Semiconj â‡‘F â‡‘Fâ‚ â‡‘Fâ‚‚
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] (F : m â†’+ P) {x y : m} : â‡‘(Add_Con.Ker F) x y â†” â‡‘F x = â‡‘F y
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {x Y : C} (P : x = Y) : F.Map (CategoryTheory.Eq_to_hom P) = CategoryTheory.Eq_to_hom _
{Î± : Type u_3} [SemilatticeSup Î±] (A : Î±) : Filter.at_top = Filter.comap Coe Filter.at_top
{Î± : Type u_1} [NormedRing Î±] [CompleteSpace Î±] {F g : â„• â†’ Î±} (hF : Summable (Î» (x : â„•), âˆ¥F xâˆ¥)) (hg : Summable (Î» (x : â„•), âˆ¥g xâˆ¥)) : (âˆ‘' (n : â„•), F n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (Finset.Range (n + 1)).Sum (Î» (k : â„•), F k * g (n - k))
 : Filter.Tendsto (Î» (n : â„•), (Finset.Range n).Sum (Î» (i : â„•), 1 / (â†‘i + 1))) Filter.at_top Filter.at_top
{m : Type u_1} [cancel_CommMonoid_with_Zero m] [DecidableEq m] [Unique_factorization_Monoid m] [Unique mË£] (x : m) : Unique_factorization_Monoid.Factors x = Unique_factorization_Monoid.normalized_Factors x
{Î± : sort u_1} {Î² : Type u_2} {Î³ : sort u_3} [DecidableEq Î²] (g : Î² â†’ Î³) {F : Î± â†’ Î²} {i : Î²} (A : Î³) (h : i âˆ‰ set.Range F) : Function.update g i A âˆ˜ F = g âˆ˜ F
{ð•‚ : Type u_1} {ð”¸ : Type u_2} {ð”¹ : Type u_3} [nondiscrete_NormedField ð•‚] [NormedRing ð”¸] [NormedRing ð”¹] [normed_Algebra ð•‚ ð”¸] [normed_Algebra ð•‚ ð”¹] [CompleteSpace ð”¸] {F : Type u_4} [Ring_hom_class F ð”¸ ð”¹] (F : F) (hF : Continuous â‡‘F) (x : ð”¸) (hx : x âˆˆ Emetric.Ball 0 (Exp_series ð•‚ ð”¸).radius) : â‡‘F (Exp ð•‚ x) = Exp ð•‚ (â‡‘F x)
{S : set â„} : Convex â„ S â†’ IsPreconnected S
{Î± : Type u_3} {Î² : Type u_4} [Nonempty Î±] [SemilatticeSup Î±] [Preorder Î²] {F : Î± â†’ Î²} : Filter.Tendsto F Filter.at_top Filter.at_top â†” âˆ€ (B : Î²), âˆƒ (i : Î±), âˆ€ (A : Î±), i â‰¤ A â†’ B â‰¤ F A
{R : Type u} [non_assoc_Semiring R] {S t : Subsemiring R} (h : âˆ€ (x : R), x âˆˆ S â†” x âˆˆ t) : S = t
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] {v : â„ â†’ E â†’ E} {t_min tâ‚€ t_max : â„} (htâ‚€ : tâ‚€ âˆˆ set.icc t_min t_max) (xâ‚€ : E) {C R : â„} (hR : 0 â‰¤ R) {L : Nnreal} (Hlip : âˆ€ (t : â„), t âˆˆ set.icc t_min t_max â†’ LipschitzOnWith L (v t) (metric.IsClosed_ball xâ‚€ R)) (Hcont : âˆ€ (x : E), x âˆˆ metric.IsClosed_ball xâ‚€ R â†’ Continuous_on (Î» (t : â„), v t x) (set.icc t_min t_max)) (Hnorm : âˆ€ (t : â„), t âˆˆ set.icc t_min t_max â†’ âˆ€ (x : E), x âˆˆ metric.IsClosed_ball xâ‚€ R â†’ âˆ¥v t xâˆ¥ â‰¤ C) (HMul_LE : C * LinearOrder.max (t_max - tâ‚€) (tâ‚€ - t_min) â‰¤ R) : âˆƒ (F : â„ â†’ E), F tâ‚€ = xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ set.icc t_min t_max â†’ HasDerivWithinAt F (v t (F t)) (set.icc t_min t_max) t
{S : set â„} (h : Metric.Bounded S) : Metric.diam S = HasSup.Sup S - HasInf.Inf S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {jâ‚ jâ‚‚ jâ‚ƒ kâ‚ kâ‚‚ l : C} (Fâ‚ : jâ‚ âŸ¶ kâ‚) (Fâ‚‚ : jâ‚‚ âŸ¶ kâ‚) (Fâ‚ƒ : jâ‚‚ âŸ¶ kâ‚‚) (Fâ‚„ : jâ‚ƒ âŸ¶ kâ‚‚) (gâ‚ : jâ‚ âŸ¶ l) (gâ‚‚ : jâ‚ƒ âŸ¶ l) : âˆƒ (S : C) (Î± : kâ‚ âŸ¶ S) (Î² : l âŸ¶ S) (Î³ : kâ‚‚ âŸ¶ S), Fâ‚ â‰« Î± = gâ‚ â‰« Î² âˆ§ Fâ‚‚ â‰« Î± = Fâ‚ƒ â‰« Î³ âˆ§ Fâ‚„ â‰« Î³ = gâ‚‚ â‰« Î²
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] [DecidableEq Î±] (S : Finset Î±) (F : Î± â†’ Î²) {A : Î±} (h : A âˆˆ S) : F A * (S.erase A).Prod (Î» (x : Î±), F x) = S.Prod (Î» (x : Î±), F x)
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore Î¹ B F) : IsTopologicalFiberBundle F Z.Proj
{Î± : Type u_1} [has_LE Î±] {A B : Î±} : B â‰¤ A â†’ â‡‘order_dual.to_dual A â‰¤ â‡‘order_dual.to_dual B
{Î± : Type u} [PseudoMetricSpace Î±] (x y : UniformSpace.completion Î±) (h : HasDist.dist x y = 0) : x = y
{Î² : Type v} {Î´ : Type u_2} [TopologicalSpace Î²] [TopologicalSpace Î´] {Î± : Type u_1} {Î³ : Type u_3} (F : Î± â†’ Î²) (g : Î³ â†’ Î´) : Prod.TopologicalSpace = TopologicalSpace.induced (Î» (P : Î± Ã— Î³), (F P.fst, g P.Snd)) Prod.TopologicalSpace
(x : Pgame) : (0 * x).Equiv 0
{Î± : Type u} {Î² : Î± â†’ Type u} [Î  (A : Î±), Fintype (Î² A)] : Cardinal.Mk (W_Type Î²) â‰¤ LinearOrder.max (Cardinal.Mk Î±) Cardinal.aleph0
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] {x : E} {S : set E} (hs : S âˆˆ nhds x) : âˆƒ (F : E â†’ â„), F =á¶ [nhds x] 1 âˆ§ (âˆ€ (y : E), F y âˆˆ set.icc 0 1) âˆ§ ContDiff â„ âŠ¤ F âˆ§ has_IsCompact_Support F âˆ§ Tsupport F âŠ† S
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {v : m} (h : v â‰  0) {r : R} (hr : 0 < r) (hrv : r â€¢ v â‰  0) : Ray_of_Ne_Zero R (r â€¢ v) hrv = Ray_of_Ne_Zero R v h
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (h : CategoryTheory.cover_Dense K G) [CategoryTheory.Full G] {â„± : Dáµ’áµ– â¥¤ Type v} {â„±' : CategoryTheory.SheafOfTypes K} (Î± : G.Op â‹™ â„± âŸ¶ G.Op â‹™ â„±'.val) {x : D} (x : â„±.obj (Opposite.Op x)) : (CategoryTheory.cover_Dense.types.pushforward_family h Î± x).compatible
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds_within A (set.ioi A) â†” âˆƒ (u : Î±) (h : u âˆˆ set.ioi A), set.Ioo A u âŠ† S
{Î¹ : Type u_1} {R : Type u_8} [canonically_ordered_CommSemiring R] [Nontrivial R] [DecidableEq R] {S : Finset Î¹} {F : Î¹ â†’ WithTop R} (h : âˆ€ (i : Î¹), i âˆˆ S â†’ F i â‰  âŠ¤) : S.Prod (Î» (i : Î¹), F i) < âŠ¤
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R m) (W : Î¹ â†’ RË£) : â‡‘(e.det) â‡‘(e.units_Smul W) = Finset.Univ.Prod (Î» (i : Î¹), â†‘(W i))
(h : Type u) (m : Type u_2) [TopologicalSpace h] [TopologicalSpace m] [ChartedSpace h m] [LocallyCompactSpace h] : LocallyCompactSpace m
{A B : Prop} : Â¬(A âˆ¨ B) â†” Â¬A âˆ§ Â¬B
{g : Matrix.special_Linear_Group (Fin 2) â„¤} {z : UpperHalfPlane} (hz : z âˆˆ modular_Group.Fdo) (hg : g â€¢ z âˆˆ modular_Group.Fdo) : z = g â€¢ z
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] [DecidableEq Î±] (S : Finset Î±) (A : Î±) (B : Î± â†’ Î²) : S.Prod (Î» (x : Î±), Ite (x = A) (B x) 1) = Ite (A âˆˆ S) (B A) 1
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] [no_Zero_divisors A] (h : Function.Injective â‡‘(Algebra_Map R A)) : NoZeroSmulDivisors R A
{Î¹ : Type v} (F : Î¹ â†’ Cardinal) : (Cardinal.Sup F).Lift = Cardinal.Sup (Î» (i : Î¹), (F i).Lift)
{x Y Z : AlgebraicGeometry.scheme} (ð’° : x.IsOpen_cover) (F : x âŸ¶ Z) (g : Y âŸ¶ Z) [âˆ€ (i : ð’°.J), CategoryTheory.Limits.HasPullback (ð’°.Map i â‰« F) g] (i : ð’°.J) : CategoryTheory.Limits.pullback.Lift CategoryTheory.Limits.pullback.Snd (CategoryTheory.Limits.pullback.fst â‰« AlgebraicGeometry.scheme.pullback.P2 ð’° F g) _ â‰« (AlgebraicGeometry.scheme.pullback.gluing ð’° F g).Î¹ i = CategoryTheory.Limits.pullback.fst
{Î± : Type u_1} (L : List (List Î±)) {i j : â„•} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : L.Join.nth_LE ((List.take i (List.Map List.length L)).Sum + j) _ = (L.nth_LE i hi).nth_LE j hj
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : (Î» (x : Î±), -F' x) =O[l] g â†’ F' =O[l] g
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {Lâ‚ Lâ‚‚ : C â¥¤ D} {Râ‚ Râ‚‚ : D â¥¤ C} (Adjâ‚ : Lâ‚ âŠ£ Râ‚) (Adjâ‚‚ : Lâ‚‚ âŠ£ Râ‚‚) (F : Râ‚ âŸ¶ Râ‚‚) [CategoryTheory.IsIso (â‡‘((CategoryTheory.transfer_Nat_Trans_self Adjâ‚ Adjâ‚‚).Symm) F)] : CategoryTheory.IsIso F
{x y : Game} : Â¬x.lf y â†” y â‰¤ x
{Î± : Type u_1} [DecidableEq Î±] {ð’œ : Finset (Finset Î±)} {r : â„•} (hð’œ : set.sized r â†‘ð’œ) : set.sized (r - 1) â†‘(ð’œ.shadow)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {K' : Submodule ð•œ E} [CompleteSpace â†¥K'] (h : K = K') (u : E) : â†‘(â‡‘(Orthogonal_projection K) u) = â†‘(â‡‘(Orthogonal_projection K') u)
{m : Type u_1} [AddMonoid m] {S : set m} (hs : _Add_Submonoid S) {l : List m} : (âˆ€ (x : m), x âˆˆ l â†’ x âˆˆ S) â†’ l.Sum âˆˆ S
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (ps : set P) : affine_Span k (HasInsert.Insert P â†‘(affine_Span k ps)) = affine_Span k (HasInsert.Insert P ps)
{k : Type u_1} {G : Type u_2} {v : Type u_3} [CommRing k] [Group G] [AddCommGroup v] [module k v] (Ï : Representation k G v) (g h : G) : Ï.character (h * g * hâ»Â¹) = Ï.character g
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} (h : S.Finite) : Finite_dimensional k â†¥(Vector_Span k S)
{Î± : Type u_1} [MeasurableSpace Î±] (mâ‚ mâ‚‚ : MeasureTheory.OuterMeasure Î±) : (mâ‚ + mâ‚‚).trim = mâ‚.trim + mâ‚‚.trim
{Î± : Type u_1} {Î² : Type u_2} {S : Finset Î±} {t : Finset Î²} (hc : t.Card < S.Card) {F : Î± â†’ Î²} (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A âˆˆ t) : âˆƒ (x : Î±) (h : x âˆˆ S) (y : Î±) (h : y âˆˆ S), x â‰  y âˆ§ F x = F y
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsArtinian R m] (F : m â†’â‚—[R] m) (S : Function.Injective â‡‘F) : Function.Surjective â‡‘F
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x : CategoryTheory.SimplicialObject C} (q : â„•) : (AlgebraicTopology.DoldKan.hÏƒ q).F 0 = 0
{Î± : Type u_1} {Î² : Type u_2} {S Sâ‚ : set Î±} {t tâ‚ : set Î²} : S Ã—Ë¢ t âŠ† Sâ‚ Ã—Ë¢ tâ‚ â†” S âŠ† Sâ‚ âˆ§ t âŠ† tâ‚ âˆ¨ S = âˆ… âˆ¨ t = âˆ…
{R : Type u_1} {S : Type u_2} [CommSemiring R] [CommSemiring S] [h : local_Ring S] (F : R â†’+* S) [_local_Ring_hom F] : local_Ring R
{F : â„• â†’â‚€ â„•} (hF : 0 âˆ‰ F.Support) : 0 < F.Prod has_Pow.Pow
(S : â„) (hs : 1 < S) : MeasureTheory.IntegrableOn (Î» (x : â„), âˆ¥Real.Exp (-x) * Real.log x * x ^ (S - 1)âˆ¥) (set.ioi 0) MeasureTheory.MeasureSpace.Volume
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [AddCommMonoid Î²] {S : Finset Î³} {t : Finset Î±} {F : Î³ â†’ Î± â†’ Î²} : (S.Product t).Sum (Î» (x : Î³ Ã— Î±), F x.fst x.Snd) = t.Sum (Î» (y : Î±), S.Sum (Î» (x : Î³), F x y))
{z : UpperHalfPlane} (h : 1 < â‡‘Complex.norm_sq â†‘z) : â‡‘Complex.norm_sq â†‘(modular_Group.S â€¢ z) < 1
{A : Type u_1} [NormedRing A] [normed_Algebra â„‚ A] [CompleteSpace A] [Star_Ring A] [cstar_Ring A] [Star_module â„‚ A] [Nontrivial A] {A : A} (ha : A âˆˆ self_Adjoint A) {z : â„‚} (hz : z âˆˆ Spectrum â„‚ A) : z = â†‘(z.re)
{R : Type u_1} {m : Type u_9} {Î¹ : Type u_17} [Semiring R] [AddCommMonoid m] [module R m] [Fintype Î¹] [DecidableEq Î¹] (F : (Î¹ â†’ R) â†’â‚—[R] m) (x : Î¹ â†’ R) : â‡‘F x = Finset.Univ.Sum (Î» (i : Î¹), x i â€¢ â‡‘F (Î» (j : Î¹), Ite (i = j) 1 0))
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î²] {F : Î± â†’ Î²} {S : set Î±} [TopologicalSpace Î±] (L : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : set Î±) (h : t âˆˆ nhds_within x S) (F : Î± â†’ Î²), Continuous_within_at F S x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (F y, F y) âˆˆ u)) : Continuous_on F S
{Î± : Type u_1} [TopologicalSpace Î±] [BaireSpace Î±] {S : set (set Î±)} (ho : âˆ€ (S : set Î±), S âˆˆ S â†’ _GÎ´ S) (hS : S.countable) (hD : âˆ€ (S : set Î±), S âˆˆ S â†’ Dense S) : Dense (â‹‚â‚€ S)
{R : Type u_2} [cancel_CommMonoid_with_Zero R] [Unique_factorization_Monoid R] [Nontrivial R] [normalization_Monoid R] [DecidableEq R] {P x : R} (hp : Irreducible P) (hnorm : â‡‘normalize P = P) {n : â„•} (hle : P ^ n âˆ£ x) (hlt : Â¬P ^ (n + 1) âˆ£ x) : Multiset.count P (Unique_factorization_Monoid.normalized_Factors x) = n
{Î± : Type u_1} [PartialOrder Î±] {F : Î± â†’ Î±} {P : Î± â†’ Prop} {hF : âˆ€ (x : Î±), x â‰¤ F x} {hfp : âˆ€ (x : Î±), P (F x)} {hmin : âˆ€ â¦ƒx y : Î±â¦„, x â‰¤ y â†’ P y â†’ F x â‰¤ y} (x : Î±) : P (â‡‘(Closure_operator.Mkâ‚ƒ F P hF hfp hmin) x)
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (e : n â‰ƒ m) (A : Matrix m m R) : (A.minor â‡‘e â‡‘e).det = A.det
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [hÎ¹ : Î  (n : Î²), Fintype (Î¹ n)] (S : set x) {l : Filter Î²} (r : Î² â†’ Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ set x) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), Emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, S âŠ† â‹ƒ (i : Î¹ n), t n i) (m : Ennreal â†’ Ennreal) : â‡‘(MeasureTheory.Measure.Mk_metric m) S â‰¤ l.liminf (Î» (n : Î²), Finset.Univ.Sum (Î» (i : Î¹ n), m (Emetric.diam (t n i))))
{ð•œ : Type u_1} [NormedField ð•œ] [CompleteSpace ð•œ] {r : ð•œ} (hr : âˆ¥râˆ¥ < 1) : âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : â‡‘Fin.cast_Succ j < i) : x.Ïƒ (â‡‘Fin.cast_Succ j) â‰« x.Î´ i.Succ = x.Î´ i â‰« x.Ïƒ j
{k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [Semiring k] [AddMonoid G] [Semiring R] {F g : AddMonoid_Algebra k G â†’+* R} (hâ‚ : F.Comp AddMonoid_Algebra.single_Zero_Ring_hom = g.Comp AddMonoid_Algebra.single_Zero_Ring_hom) (h_of : â†‘F.Comp (AddMonoid_Algebra.of k G) = â†‘g.Comp (AddMonoid_Algebra.of k G)) : F = g
{R : Type u_1} {A : R} [Mul_Zero_class R] [Nontrivial R] (la : IsLeftRegular A) : A â‰  0
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S t : set Î±} (hs : BddBelow S) (sne : S.Nonempty) (ht : BddBelow t) (tne : t.Nonempty) : HasInf.Inf (S âˆª t) = HasInf.Inf S âŠ“ HasInf.Inf t
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {C : â„} {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : Asymptotics._O_with C l F' g â†’ Asymptotics._O_with C l (Î» (x : Î±), âˆ¥F' xâˆ¥) g
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Semiring R] [AddCommMonoid N] [module R N] (P : Î¹ â†’ Prop) [Decidable_Pred P] (S : Î¹ â†’ Submodule R N) : (â¨† (i : Î¹) (h : P i), S i) = ((â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (S i).Subtype)).Comp (Dfinsupp.Filter_Linear_Map R (Î» (i : Î¹), â†¥(S i)) P)).Range
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {Aâ‚ Aâ‚‚ : Î±} {Bâ‚ Bâ‚‚ : Î²} (qâ‚ : Path.Homotopic.Quotient Aâ‚ Aâ‚‚) (qâ‚‚ : Path.Homotopic.Quotient Bâ‚ Bâ‚‚) : Path.Homotopic.Proj_Left (Path.Homotopic.Prod qâ‚ qâ‚‚) = qâ‚
{Î¹ : Type u_1} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [AddCommGroup N] (P : Î¹ â†’ Add_Subgroup N) : CompleteLattice.Independent P â†” Function.Injective â‡‘(Dfinsupp.Sum_Add_hom (Î» (i : Î¹), (P i).Subtype))
{G : Type u_7} [comm_Group G] (L : List G) : (L.Prod)â»Â¹ = (List.Map (Î» (x : G), xâ»Â¹) L).Prod
(Î± : Type u_1) : Subsingleton Î± âˆ¨ Nontrivial Î±
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S1 S2 : AffineSubspace k P} {P1 P2 : P} (hp1 : P1 âˆˆ S1) (hp2 : P2 âˆˆ S2) : (S1 âŠ” S2).direction = S1.direction âŠ” S2.direction âŠ” Submodule.Span k {P2 -áµ¥ P1}
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {x : C} (h : CategoryTheory.yoneda.obj x â‹™ CategoryTheory.ulift_Functor â‰… F.cones) (S : CategoryTheory.Limits.Cone F) : (CategoryTheory.Limits.IsLimit.of_Nat_iso.Limit_cone h).extend (CategoryTheory.Limits.IsLimit.of_Nat_iso.hom_of_cone h S) = S
{Fq : Type u_1} [Fintype Fq] [Ring Fq] {D m : â„•} (hm : Fintype.Card Fq ^ D â‰¤ m) (B : Polynomial Fq) (A : Fin m.Succ â†’ Polynomial Fq) (hA : âˆ€ (i : Fin m.Succ), (A i).degree < B.degree) : âˆƒ (iâ‚€ iâ‚ : Fin m.Succ), iâ‚€ â‰  iâ‚ âˆ§ (A iâ‚ - A iâ‚€).degree < â†‘(B.Nat_degree - D)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S u : set E} {F : E â†’ F} {x : E} {n : â„•} (hu : u âˆˆ nhds x) (hs : UniqueDiffOn ð•œ S) (xs : x âˆˆ S) : iterated_fderiv_within ð•œ n F (S âˆ© u) x = iterated_fderiv_within ð•œ n F S x
 : Cont_mdiff (model_with_corners_self â„ â„) (model_with_corners_self â„ (EuclideanSpace â„ (Fin 1))) âŠ¤ â‡‘Exp_Map_Circle
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F â‰  2) {A : F} (ha : A â‰  0) : Char.quadratic_Char F A = Ite (A ^ (Fintype.Card F / 2) = 1) 1 (-1)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {x : E} {n : WithTop â„•} {F : E â†’ ð•œ} {g : E â†’ F} (hF : ContDiff_at ð•œ n F x) (hg : ContDiff_at ð•œ n g x) : ContDiff_at ð•œ n (Î» (x : E), F x â€¢ g x) x
{R : Type u} {S : Type v} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R â†’+* S) (hF : Function.Surjective â‡‘F) : F.srange = âŠ¤
(ð•‚ : Type u_1) (ð•‚' : Type u_2) (ð”¸ : Type u_3) [Field ð•‚] [Field ð•‚'] [Ring ð”¸] [Algebra ð•‚ ð”¸] [Algebra ð•‚' ð”¸] [TopologicalSpace ð”¸] [topological_Ring ð”¸] (n : â„•) (x : ð”¸) : â‡‘(Exp_series ð•‚ ð”¸ n) (Î» (_x : Fin n), x) = â‡‘(Exp_series ð•‚' ð”¸ n) (Î» (_x : Fin n), x)
{E : Type u_1} {F : Type u_2} [InnerProductSpace â„ E] [InnerProductSpace â„ F] (F : E â†’L[â„] F) : IsConformalMap F â†” âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (u v : E), HasInner.inner (â‡‘F u) (â‡‘F v) = C * HasInner.inner u v
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {F : Filter Î±} {g : Filter Î²} {n : Î³ â†’ Î´} {m' : Î² â†’ Î±' â†’ Î´} {n' : Î± â†’ Î±'} (h_antidistrib : âˆ€ (A : Î±) (B : Î²), n (m A B) = m' B (n' A)) : Filter.Map n (Filter.Mapâ‚‚ m F g) = Filter.Mapâ‚‚ m' g (Filter.Map n' F)
{P n : â„•} (n_big : 2 < n) (P_LE_n : P â‰¤ n) (big : 2 * n < 3 * P) : â‡‘(n.central_binom.factorization) P = 0
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [DecidableEq Î¹] [Î  (i : Î¹), LinearOrder (Î± i)] (x y z : Î  (i : Î¹), Î± i) : set.icc x z  set.Univ.Pi (Î» (i : Î¹), set.ioc (y i) (z i)) âŠ† â‹ƒ (i : Î¹), set.icc x (Function.update z i (y i))
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (h : InnerProductGeometry.angle x y = Real.Pi) : âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} : Monotone F â†’ Antitone (â‡‘order_dual.to_dual âˆ˜ F)
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (u : RË£) (v : module.Ray R m) : uâ»Â¹ â€¢ v = u â€¢ v
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] {S : set Î²} : IsCompact S â†’ S.Nonempty â†’ âˆ€ {F : Î² â†’ Î±}, Continuous_on F S â†’ (âˆƒ (x : Î²) (h : x âˆˆ S), âˆ€ (y : Î²), y âˆˆ S â†’ F y â‰¤ F x)
{Î± : Type u_1} [TopologicalSpace Î±] [PolishSpace Î±] {S : set Î±} (hs : IsOpen S) : PolishSpace â†¥S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] {x : C} (F : 0 âŸ¶ x) : F = 0
{R : Type u_1} [CommRing R] {Câ‚ Câ‚‚ : R} (C : clifford_Algebra (clifford_Algebra_Quaternion.q Câ‚ Câ‚‚)) : â‡‘clifford_Algebra_Quaternion.to_Quaternion (â‡‘clifford_Algebra.involute (â‡‘clifford_Algebra.reverse C)) = â‡‘Quaternion_Algebra.Conj (â‡‘clifford_Algebra_Quaternion.to_Quaternion C)
(P : â„•) (A : Zmod P) (ha : A ^ (P - 1) = 1) (hD : âˆ€ (q : â„•), Nat.Prime q â†’ q âˆ£ P - 1 â†’ A ^ ((P - 1) / q) â‰  1) : Nat.Prime P
{x Y : Profinite} (F : x âŸ¶ Y) : IsClosed_Map â‡‘F
{vâ‚ : Type u_2} {vâ‚‚ : Type u_3} [semi_NormedGroup vâ‚] [semi_NormedGroup vâ‚‚] (F : NormedGroup_hom vâ‚ vâ‚‚) : LipschitzWith âŸ¨âˆ¥Fâˆ¥, _âŸ© â‡‘F
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (h : Â¬Metric.Bounded S) : Metric.diam S = 0
{R : Type u_1} {S : Type u_2} [CommRing R] [IsDomain R] [CommRing S] {L : Type u_3} [Field L] [Algebra R S] [Algebra S L] [Algebra R L] [IsScalarTower R S L] [IsIntegral_Closure S R L] (h : Algebra.IsAlgebraic R L) (inj : Function.Injective â‡‘(Algebra_Map R L)) (A : S) {B : S} (hb : B â‰  0) : âˆƒ (C : S) (D : R) (h : D â‰  0), D â€¢ A = B * C
{Î± : Type u_2} [Bornology Î±] {S : set Î±} : Bornology._bounded S â†’ Bornology._cobounded Sá¶œ
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] {A : Î±} (h : (set.ioi A).Nonempty) : Closure (set.ioi A) = set.ici A
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : strict_Convex_on ð•œ S F) {x y : E} (hx : x âˆˆ S) (hy : y âˆˆ S) (hxy : x â‰  y) {A B : ð•œ} (ha : 0 < A) (hb : 0 < B) (hab : A + B = 1) : F (A â€¢ x + B â€¢ y) < LinearOrder.max (F x) (F y)
{Î± : Type v} {S : Finset Î±} {m : Type u_1} [CommMonoid m] (F : Î± â†’ m) (P : m â†’ Prop) (P_Mul : âˆ€ (A B : m), P A â†’ P B â†’ P (A * B)) (P_One : P 1) (P_S : âˆ€ (x : Î±), x âˆˆ S â†’ P (F x)) : P (S.Prod (Î» (x : Î±), F x))
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [Linear_ordered_Field ð•œ] [AddCommGroup E] [ordered_AddCommGroup Î²] [module ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F : E â†’ Î²} {t : Finset Î¹} {W : Î¹ â†’ ð•œ} {P : Î¹ â†’ E} (hF : ConcaveOn ð•œ S F) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ W i) (hâ‚ : 0 < t.Sum (Î» (i : Î¹), W i)) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ P i âˆˆ S) : t.Center_mass W (F âˆ˜ P) â‰¤ F (t.Center_mass W P)
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} : StrictAnti F â†’ StrictMono (â‡‘order_dual.to_dual âˆ˜ F)
{G : Type u_3} [AddGroup G] : AddGroup.fg G â†” AddMonoid.fg G
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚‚} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J â¥¤ C} [CategoryTheory.Limits.HasLimit F] {E : K â¥¤ J} [CategoryTheory.Limits.HasLimit (E â‹™ F)] (S : CategoryTheory.Limits.Limit_cone (E â‹™ F)) (t : CategoryTheory.Limits.Limit_cone F) : CategoryTheory.Limits.Limit.pre F E = (CategoryTheory.Limits.Limit.iso_Limit_cone t).hom â‰« S._Limit.Lift (CategoryTheory.Limits.Cone.whisker E t.cone) â‰« (CategoryTheory.Limits.Limit.iso_Limit_cone S).Inv
{G : Type W} [TopologicalSpace G] [Group G] [topological_Group G] {m : Type u_1} {hom : Type u_2} [MulOneClass m] [TopologicalSpace m] [has_Continuous_Mul m] [Monoid_hom_class hom G m] (F : hom) (hF : Continuous_at â‡‘F 1) : Continuous â‡‘F
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (m : m) : â‡‘(S.normed_Mk) m = â‡‘(Quotient_AddGroup.Mk' S) m
{Î± : Type u_1} {n : Type u_4} {m : Type u_5} [Mul_Zero_class Î±] {A : Matrix m m Î±} {B : Matrix n n Î±} (hA : A.IsDiag) (hB : B.IsDiag) : (Matrix.kronecker_Map has_Mul.Mul A B).IsDiag
{ð•‚ : Type u_1} [nondiscrete_NormedField ð•‚] [CompleteSpace ð•‚] (h : 0 < (Exp_series ð•‚ ð•‚).radius) : HasDerivAt (Exp ð•‚) 1 0
{Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [Fintype Î¹] [Preorder Î¹'] [_Directed Î¹' (Function.Swap has_LE.LE)] [Nonempty Î¹'] {S : Î¹ â†’ Î¹' â†’ set Î±} (hs : âˆ€ (i : Î¹), Antitone (S i)) : (â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), S i j) = â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), S i j
{G : Type u_1} [AddGroup G] {Î¹ : sort u_2} (S : Î¹ â†’ Add_Subgroup G) {C : Î  (x : G), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : G) (h : x âˆˆ S i), C x _) (h1 : C 0 _) (HMul : âˆ€ (x y : G) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x + y) _) {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
{Î± : Type u} {Î² : Type v} {t : set Î²} {F : Î± â†’ Î²} (h : âˆ€ (x : Î±), F x âˆˆ t) : Function.Injective F â†’ Function.Injective (set.cod_Restrict F t h)
{v : Type u} {G : SimpleGraph v} [DecidableEq v] {u v W : v} (P : G.Walk v W) (h : u âˆˆ P.Support) : (P.take_until u h).Append (P.Drop_until u h) = P
{G : Type u_1} [Group G] {Î¹ : Type u_2} (S : Finset Î¹) (F : Î¹ â†’ G) (comm : âˆ€ (x : Î¹), x âˆˆ S â†’ âˆ€ (y : Î¹), y âˆˆ S â†’ Commute (F x) (F y)) (K : Î¹ â†’ Subgroup G) (hind : CompleteLattice.Independent K) (hmem : âˆ€ (x : Î¹), x âˆˆ S â†’ F x âˆˆ K x) (HEq1 : S.noncomm_Prod F comm = 1) (i : Î¹) (h : i âˆˆ S) : F i = 1
(u : pnat.xgcd_Type) : u.r + (u.bp + 1) * u.q = u.ap + 1
{Î² Î± : Type u} (F : Î² â†’ Î±) (hâ‚ : Cardinal.aleph0 â‰¤ Cardinal.Mk Î²) (hâ‚‚ : Cardinal.Mk Î± < (Cardinal.Mk Î²).Ord.cof) : âˆƒ (A : Î±), Cardinal.Mk â†¥(F â»Â¹' {A}) = Cardinal.Mk Î²
{Î¹ : Type u_1} {m : Type u_4} {N : Type u_5} [CommMonoid m] [ordered_CommMonoid N] (F : m â†’ N) (P : m â†’ Prop) (h_Mul : âˆ€ (x y : m), P x â†’ P y â†’ F (x * y) â‰¤ F x * F y) (hp_Mul : âˆ€ (x y : m), P x â†’ P y â†’ P (x * y)) (g : Î¹ â†’ m) (S : Finset Î¹) (hs_Nonempty : S.Nonempty) (hs : âˆ€ (i : Î¹), i âˆˆ S â†’ P (g i)) : F (S.Prod (Î» (i : Î¹), g i)) â‰¤ S.Prod (Î» (i : Î¹), F (g i))
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (h : S.Finite) : Metric.Bounded S
{R : Type u} [Semiring R] [no_Zero_divisors R] [Nontrivial R] (l : List (Polynomial R)) : l.Prod.degree = (List.Map Polynomial.degree l).Sum
(F : Type uâ‚€ â†’ Type uâ‚) [Equiv_Functor F] {Î± Î² Î³ : Type uâ‚€} (Ab : Î± â‰ƒ Î²) (bc : Î² â‰ƒ Î³) : (Equiv_Functor.Map_Equiv F Ab).Trans (Equiv_Functor.Map_Equiv F bc) = Equiv_Functor.Map_Equiv F (Ab.Trans bc)
{R : Type u_1} (m : Type u_3) [Monoid R] [MulAction R m] : IsSmulRegular m 1
{C : Type u} [CategoryTheory.Category C] (S : set (CategoryTheory.GrothendieckTopology C)) : IsGlb S (HasInf.Inf S)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {m n : WithTop â„•} {F : E â†’ F} (hF : ContDiff ð•œ n F) (hmn : m + 1 â‰¤ n) : ContDiff ð•œ m (Î» (P : E Ã— E), â‡‘(fderiv ð•œ F P.fst) P.Snd)
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} {P : Type u_8} [has_Zero m] [CommMonoid N] [CommMonoid P] (h : N â†’* P) (F : Î± â†’â‚€ m) (g : Î± â†’ m â†’ N) : â‡‘h (F.Prod g) = F.Prod (Î» (A : Î±) (B : m), â‡‘h (g A B))
{Î± : Type u_1} {l : Filter Î±} {F : Î± â†’ â„} : ((Î» (x : Î±), 1) =O[l] Î» (x : Î±), Real.Exp (F x)) â†” Filter._bounded_under Ge l F
{L : FirstOrder.Language} (t : L.Theory) (Îº : Cardinal) (m : Type W') [L.structure m] [m âŠ¨ t] [Infinite m] : âˆƒ (N : t.model), Îº.Lift â‰¤ Cardinal.Mk â†¥N
{E : Type u_1} [semi_NormedGroup E] {S : Add_Subgroup E} (x : â†¥S) : âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
{E : Type u_1} [semi_NormedGroup E] [NormedSpace â„ E] (P : Subspace â„ E) (F : â†¥P â†’L[â„] â„) : âˆƒ (g : E â†’L[â„] â„), (âˆ€ (x : â†¥P), â‡‘g â†‘x = â‡‘F x) âˆ§ âˆ¥gâˆ¥ = âˆ¥Fâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {r : Setoid Î±} (F : Î± â†’ Î²) (h : âˆ€ (x y : Î±), r.Rel x y â†’ F x = F y) (h : Function.Injective (Quotient.Lift F h)) : Setoid.Ker F = r
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} (hs : IsClosed S) (ht : IsClosed t) : Emetric.Hausdorff_edist S t = 0 â†” S = t
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [IsRefl Î± r] {x y : Î±} : x â‰  y â†’ r x y â†” r x y
(Î“â‚€ : Type u_1) [Linear_ordered_comm_Group_with_Zero Î“â‚€] : has_pure.pure â‰¤ Linear_ordered_comm_Group_with_Zero.nhds_fun Î“â‚€
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} : Function.Injective2 Fin.Cons
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle (-x) y + o.oangle (-y) z + o.oangle (-z) x = â†‘Real.Pi
{G : Type u_2} [Group G] {A B : G} : A = B â†’ A / B = 1
{Î± : Type u} [Preorder Î±] {A B C : Î±} : A â‰¤ B â†’ B < C â†’ A < C
{vâ‚ : Type u_1} {vâ‚‚ : Type u_2} [NormedGroup vâ‚] [NormedGroup vâ‚‚] {F : NormedGroup_hom vâ‚ vâ‚‚} : âˆ¥Fâˆ¥ = 0 â†” F = 0
{Î± : Type u} [AddCommGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B C : Î±} : A - B < C â†’ A < B + C
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] {F : Type u_6} [Field F] [Algebra K S] [Algebra K F] [Nontrivial S] (pB : power_Basis K S) (hF : Polynomial.Splits (Algebra_Map K F) (minpoly K pB.gen)) : â‡‘(Algebra_Map K F) (â‡‘(Algebra.trace K S) pB.gen) = (Polynomial.Map (Algebra_Map K F) (minpoly K pB.gen)).roots.Sum
{m : Type u_1} [AddZeroClass m] (S : Add_Submonoid m) : S = âŠ¥ âˆ¨ âˆƒ (x : m) (h : x âˆˆ S), x â‰  0
{t : â„‚} {S1 S2 x : â„} (ht1 : S1 â‰¤ t.re) (ht2 : t.re â‰¤ S2) (hx : 0 < x) : âˆ¥dGamma_integrand t xâˆ¥ â‰¤ dGamma_integrand_Real S1 x + dGamma_integrand_Real S2 x
{m : Type u_1} [MulOneClass m] (S : set m) {P : Î  (x : m), x âˆˆ Submonoid.Closure S â†’ Prop} (Hs : âˆ€ (x : m) (h : x âˆˆ S), P x _) (h1 : P 1 _) (HMul : âˆ€ (x : m) (hx : x âˆˆ Submonoid.Closure S) (y : m) (hy : y âˆˆ Submonoid.Closure S), P x hx â†’ P y hy â†’ P (x * y) _) {x : m} (hx : x âˆˆ Submonoid.Closure S) : P x hx
(R : Type u) [Ring R] [strong_RankCondition R] {Î¹ : Type v} [Fintype Î¹] : Finite_dimensional.finrank R (Î¹ â†’â‚€ R) = Fintype.Card Î¹
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} (hâ‚€ : F = g) {C : CategoryTheory.Limits.Fork F g} (h : CategoryTheory.Limits.IsLimit C) : CategoryTheory.IsIso C.Î¹
{R : Type u} [Semiring R] [no_Zero_divisors R] {Pâ‚ Pâ‚‚ qâ‚ qâ‚‚ : Polynomial R} (hpâ‚ : Pâ‚ â‰  0) (hqâ‚ : qâ‚ â‰  0) (hpâ‚‚ : Pâ‚‚ â‰  0) (hqâ‚‚ : qâ‚‚ â‰  0) (h_Eq : Pâ‚ * qâ‚‚ = Pâ‚‚ * qâ‚) : â†‘(Pâ‚.Nat_degree) - â†‘(qâ‚.Nat_degree) = â†‘(Pâ‚‚.Nat_degree) - â†‘(qâ‚‚.Nat_degree)
{Î¹ : Type v} (F : Î¹ â†’ Cardinal) (t : Cardinal) (W : âˆ€ (i : Î¹), (F i).Lift â‰¤ t) : (Cardinal.Sup F).Lift â‰¤ t
{Î± : Type u} [TopologicalSpace Î±] {x : Î±} {S : set Î±} : ClusterPt x (Filter.principal S) â†” âˆ€ (U : set Î±), U âˆˆ nhds x â†’ (U âˆ© S).Nonempty
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {n : â„•} (hn : Fintype.Card Î± < Fintype.Card Î² * n) : âˆƒ (y : Î²), (Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Card < n
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), has_Zero (Î² i)] : Function.Injective Coe_fn
{G : Type u_1} [Group G] [TopologicalSpace G] [nonarchimedean_Group G] {U : set (G Ã— G)} (hU : U âˆˆ nhds 1) : âˆƒ (v : IsOpen_Subgroup G), â†‘v Ã—Ë¢ â†‘v âŠ† U
{m : Type u_1} [AddZeroClass m] {Î¹ : sort u_2} (S : Î¹ â†’ Add_Submonoid m) {C : Î  (x : m), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : m) (h : x âˆˆ S i), C x _) (h1 : C 0 _) (HMul : âˆ€ (x y : m) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x + y) _) {x : m} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] {Î¹ : Type u_3} {P : Î¹ â†’ Submodule R m} {m : m} : (m âˆˆ â¨† (i : Î¹), P i) â†” âˆƒ (S : Finset Î¹), m âˆˆ â¨† (i : Î¹) (h : i âˆˆ S), P i
{mâ‚€ : Type u_6} [Monoid_with_Zero mâ‚€] {L : List mâ‚€} (h : 0 âˆˆ L) : L.Prod = 0
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] (e : Basis Î¹ R m) (F : AlternatingMap R m R Î¹) : F = â‡‘F â‡‘e â€¢ e.det
{P : Type u_1} [SemilatticeInf P] {x y : P} {F : Order.Pfilter P} (hx : x âˆˆ F) (hy : y âˆˆ F) : x âŠ“ y âˆˆ F
{m : Type u_1} [has_Mul m] (C : Con m) {x y : m} : â‡‘C x y â†’ â‡‘C y x
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace â„ E] [NormedGroup F] [NormedSpace â„ F] {S : set E} (S_conv : Convex â„ S) (hne : (Interior S).Nonempty) {F : E â†’ F} {F' : E â†’ (E â†’L[â„] F)} {F'' : E â†’L[â„] E â†’L[â„] F} (hF : âˆ€ (x : E), x âˆˆ Interior S â†’ HasFderivAt F (F' x) x) {x : E} (xs : x âˆˆ S) (hx : HasFderivWithinAt F' F'' (Interior S) x) (v W : E) : â‡‘(â‡‘F'' v) W = â‡‘(â‡‘F'' W) v
{Î± : Type u} {Î² : Type v} (F : Î± â†’ Î²) (g : Î² â†’ Î±) : set.bij_on g (Function.FixedPoints (F âˆ˜ g)) (Function.FixedPoints (g âˆ˜ F))
{R : Type u_1} {m : Type u_2} {mâ‚‚ : Type u_3} [TopologicalSpace m] [TopologicalSpace mâ‚‚] [Ring R] [AddCommGroup m] [topological_AddGroup m] [module R m] [AddCommGroup mâ‚‚] [module R mâ‚‚] (e : m â‰ƒL[R] mâ‚‚) (F : m â†’L[R] mâ‚‚) : F.Inverse = (Ring.Inverse (â†‘(e.Symm).Comp F)).Comp â†‘(e.Symm)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (Î¸ : Real.Angle) : (o.rotation Î¸).Symm = o.rotation (-Î¸)
{e : â„‚ â†’ â„‚} {e' : â„‚} {z : â„} (h : HasStrictDerivAt e e' â†‘z) : HasStrictDerivAt (Î» (x : â„), (e â†‘x).re) e'.re z
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] : ContDiff ð•œ âŠ¤ â‡‘(Equiv.Prod_assoc E F G)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (F : E â†’L[ð•œ] F) [CompleteSpace F] [CompleteSpace E] (surj : Function.Surjective â‡‘F) : âˆƒ (C : â„) (h : C > 0), âˆ€ (y : F), âˆƒ (x : E), â‡‘F x = y âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
{R : Type u_4} {S : Type u_5} [non_unital_non_assoc_Semiring R] [non_unital_non_assoc_Semiring S] (F : R â‰ƒ+* S) : â‡‘F 0 = 0
{n : â„•} : Fin_Succ_Equiv' 0 = Fin_Succ_Equiv n
{R : Type u} [CommSemiring R] [Star_Ring R] (x : R) : â‡‘(Star_Ring_end R) (â‡‘(Star_Ring_end R) x) = x
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m â†’* P} {t : Submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ t) {q : Type u_4} [CommMonoid q] {k : t.Localization_Map q} (z : N) : â‡‘(k.to_Map) (â‡‘g â†‘((F.sec z).Snd)) * â‡‘(F.Map hy k) z = â‡‘(k.to_Map) (â‡‘g (F.sec z).fst)
{C : Type u} [CategoryTheory.Category C] {x : C} {S R : CategoryTheory.Sieve x} (J : CategoryTheory.GrothendieckTopology C) (Hss : S â‰¤ R) (sjx : S âˆˆ â‡‘J x) : R âˆˆ â‡‘J x
{K : Type u} [Field K] (S : Subfield K) {l : List K} : (âˆ€ (x : K), x âˆˆ l â†’ x âˆˆ S) â†’ l.Prod âˆˆ S
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : â„•} {S1 S2 : Affine.Simplex k P n} (h : âˆ€ (i : Fin (n + 1)), S1.points i = S2.points i) : S1 = S2
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : intermediate_Field K L) [Finite_dimensional K â†¥E] : IsClosed â†‘(E.fixing_Subgroup)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P B : P) : â‡‘(S.weighted_vsub_of_point (Î» (_x : Î¹), P) B) W = S.Sum (Î» (i : Î¹), W i) â€¢ (P -áµ¥ B)
(k n : â„•) : (List.Nat.antidiagonal_tuple k n).Nodup
{Î± : Type u_1} [LinearOrder Î±] {S : Finset Î±} {k : â„•} (h : S.Card = k) (hz : 0 < k) : â‡‘(S.order_emb_of_Fin h) âŸ¨0, hzâŸ© = S.min' _
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} (Fin : Emetric.Hausdorff_edist S t â‰  âŠ¤) : metric.Hausdorff_dist S t = 0 â†” Closure S = Closure t
{Î± : Type u} : Function.Injective free_Group.of
{mâ‚€ : Type u_1} [Mul_Zero_class mâ‚€] [no_Zero_divisors mâ‚€] {A B : mâ‚€} : A * B = 0 â†” B * A = 0
{Î± : Type u_1} [LinearOrder Î±] {A B : Finset Î±} (h : A âŠ† B) : A.to_colex â‰¤ B.to_colex
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [Linear_ordered_Ring Î±] [FloorRing Î±] [TopologicalSpace Î±] [OrderTopology Î±] [topological_AddGroup Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î² â†’ Î± â†’ Î³} (h : Continuous_on (Function.uncurry F) (set.Univ Ã—Ë¢ set.icc 0 1)) (hF : âˆ€ (S : Î²), F S 0 = F S 1) : Continuous (Î» (st : Î² Ã— Î±), F st.fst (Int.fract st.Snd))
{R : Type u_1} {S : Type u_2} [EuclideanDomain R] [CommRing S] [IsDomain S] [Algebra R S] {abv : AbsoluteValue R â„¤} {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] (bS : Basis Î¹ R S) (adm : abv._Admissible) [Infinite R] [DecidableEq R] (A : S) {B : R} (hb : B â‰  0) : âˆƒ (q : S) (r : R) (h : r âˆˆ class_Group.Finset_approx bS adm), â‡‘abv (â‡‘(Algebra.norm R) (r â€¢ A - B â€¢ q)) < â‡‘abv (â‡‘(Algebra.norm R) (â‡‘(Algebra_Map R S) B))
{Î± : Type u_1} [Monoid Î±] {A B u : Î±} (hu : IsUnit u) : A * u âˆ£ B â†” A âˆ£ B
{P : â„•} (hp : 1 < P) : padic_norm P â†‘P < 1
{R : Type u} {A' : Type u_1} {B' : Type u_2} [CommSemiring A'] [Semiring B'] [CommSemiring R] [Algebra R A'] [Algebra R B'] {F g : Polynomial A' â†’â‚[R] B'} (hâ‚ : F.Comp (IsScalarTower.to_AlgHom R A' (Polynomial A')) = g.Comp (IsScalarTower.to_AlgHom R A' (Polynomial A'))) (hâ‚‚ : â‡‘F Polynomial.x = â‡‘g Polynomial.x) : F = g
{Î± : Type u} [SemilatticeSup Î±] {Î² : Type u_1} [Preorder Î²] {F g : Î± â†’ Î²} (hF : Monotone F) (hg : Antitone g) (h : F â‰¤ g) (m n : Î±) : F m â‰¤ g n
{R : Type u_1} [CommRing R] {P : â„•} (hp : Nat.Prime P) : Polynomial.cyclotomic P R = (Finset.Range P).Sum (Î» (i : â„•), Polynomial.x ^ i)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [cs : CompleteSpace E] {F : E â†’ F} {F' : E â‰ƒL[ð•œ] F} {A : E} (hF : HasStrictFderivAt F â†‘F' A) {g : F â†’ E} (hg : âˆ€á¶  (x : E) in nhds A, g (F x) = x) : HasStrictFderivAt g â†‘(F'.Symm) (F A)
{C : Type u} [CategoryTheory.Category C] {P q : C} (F : P âŸ¶ q) [CategoryTheory.Mono F] [CategoryTheory.StrongEpi F] : CategoryTheory.IsIso F
{Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {m : Type u_6} [CommSemiring R] [AddCommMonoid m] [module R m] (B : Basis Î¹ R m) (B' : Basis Î¹' R m) {Î¹'' : Type u_3} [Fintype Î¹'] (B'' : Î¹'' â†’ m) : (B.to_Matrix â‡‘B').Mul (B'.to_Matrix B'') = B.to_Matrix B''
{G : Type u_1} [AddGroup G] {k : set G} {P : Î  (x : G), x âˆˆ Add_Subgroup.Closure k â†’ Prop} (Hs : âˆ€ (x : G) (h : x âˆˆ k), P x _) (h1 : P 0 _) (HMul : âˆ€ (x : G) (hx : x âˆˆ Add_Subgroup.Closure k) (y : G) (hy : y âˆˆ Add_Subgroup.Closure k), P x hx â†’ P y hy â†’ P (x + y) _) (Hinv : âˆ€ (x : G) (hx : x âˆˆ Add_Subgroup.Closure k), P x hx â†’ P (-x) _) {x : G} (hx : x âˆˆ Add_Subgroup.Closure k) : P x hx
{Î¹ : Type u_1} {v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {C : Complex_shape Î¹} (C : homological_Complex v C) {i i' j : Î¹} (rij : C.Rel i j) (rij' : C.Rel i' j) : CategoryTheory.Eq_to_hom _ â‰« C.D i' j = C.D i j
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] (v : K) (n : â„•) : âˆƒ (q : â„š), (GeneralizedContinuedFraction.of v).convergents n = â†‘q
{Î¹ : Type u} (S : Finset Î¹) (F g : Î¹ â†’ Ennreal) {P q : â„} (hpq : P.IsConjugateExponent q) : S.Sum (Î» (i : Î¹), F i * g i) â‰¤ S.Sum (Î» (i : Î¹), F i ^ P) ^ (1 / P) * S.Sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] {C : â„} {F : â„‚ â†’ E} {z : â„‚} (hD : Diff_Cont_on_cl â„‚ F {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (C : â„) (h : C < 2) (B : â„), F =O[Filter.comap Complex.Abs Filter.at_top âŠ“ Filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), Real.Exp (B * Complex.Abs z ^ C)) (hre : Filter.Tendsto (Î» (x : â„), F â†‘x) Filter.at_top (nhds 0)) (him : âˆ€ (x : â„), âˆ¥F (â†‘x * Complex.i)âˆ¥ â‰¤ C) (hz : 0 â‰¤ z.re) : âˆ¥F zâˆ¥ â‰¤ C
{R : Type u_1} {m : Type u_3} {A : R} [Monoid R] [MulAction R m] (n : â„•) (ra : IsSmulRegular m A) : IsSmulRegular m (A ^ n)
{R : Type uâ‚} {L : Type uâ‚‚} [CommRing R] [lie_Ring L] [lie_Algebra R L] [IsNoetherian R L] : lie_Algebra.IsNilpotent R L â†” âˆ€ (x : L), IsNilpotent (â‡‘(lie_Algebra.ad R L) x)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x : v} (hx : x â‰  0) : hb.oangle (-x) x = â†‘Real.Pi
(ð•œ : Type u_1) (E : Type u_2) [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] {n : â„•} (h : n = 1) (v : Fin n â†’ E) : â‡‘(FormalMultilinearSeries.Id ð•œ E n) v = v âŸ¨0, _âŸ©
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} (h : â†‘S.Nonempty) (v : v) : v âˆˆ S.direction â†” âˆƒ (P1 : P) (h : P1 âˆˆ S) (P2 : P) (h : P2 âˆˆ S), v = P1 -áµ¥ P2
{R : Type u_4} [NormedRing R] [CompleteSpace R] (x : R) (h : âˆ¥xâˆ¥ < 1) : Summable (Î» (n : â„•), x ^ n)
{Î± : Type u_1} {Î² : Type u_2} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {K : Nnreal} {F : Î± â†’ Î²} : (âˆ€ (x y : Î±), HasNndist.nndist x y â‰¤ K * HasNndist.nndist (F x) (F y)) â†’ AntilipschitzWith K F
(R : Type u) [Semiring R] [Nontrivial R] (P q : â„•) [Char_P R P] [ExpChar R q] : q = 1 â†” P = 0
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S : set P} (hs : S.Nonempty) : affine_Span k S = âŠ¤ â†” Vector_Span k S = âŠ¤
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {C : set Î±} (hc : IsChain r C) : âˆƒ (m : set Î±), IsMax_chain r m âˆ§ C âŠ† m
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [CommSemiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] (F : MultilinearMap R mâ‚ mâ‚‚) (C : Î¹ â†’ R) (m : Î  (i : Î¹), mâ‚ i) (S : Finset Î¹) : â‡‘F (S.piecewise (Î» (i : Î¹), C i â€¢ m i) m) = S.Prod (Î» (i : Î¹), C i) â€¢ â‡‘F m
{E : Type u_1} [AddCommGroup E] [module â„ E] {S : set E} (x : E) : 0 â‰¤ gauge S x
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} {x : C} {R : CategoryTheory.Presieve x} {x : CategoryTheory.Presieve.FamilyOfElements P R} (hx : x.compatible) : x.Sieve_extend.compatible
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (h : IsClosed S) : Interior (Frontier S) = âˆ…
{R : Type u_1} [CommRing R] (S : Subring R) (m : Multiset R) : (âˆ€ (A : R), A âˆˆ m â†’ A âˆˆ S) â†’ m.Prod âˆˆ S
{L : FirstOrder.Language} {m : Type u_3} [L.structure m] : FirstOrder.Language.structure.cg L m â†” âˆƒ (S : set m), S.countable âˆ§ â‡‘(FirstOrder.Language.Substructure.Closure L) S = âŠ¤
{S : â„‚} (hs : 1 < S.re) : MeasureTheory.IntegrableOn (Î» (x : â„), â†‘(Real.Exp (-x)) * â†‘(Real.log x) * â†‘x ^ (S - 1)) (set.ioi 0) MeasureTheory.MeasureSpace.Volume âˆ§ HasDerivAt Complex.gamma_integral (âˆ« (x : â„) in set.ioi 0, â†‘(Real.Exp (-x)) * â†‘(Real.log x) * â†‘x ^ (S - 1)) S
{C : Type u} [CategoryTheory.Category C] {x Y Z : C} (F : x âŸ¶ Y) (g : x âŸ¶ Z) [CategoryTheory.Limits.HasPushout F g] : CategoryTheory.Limits.HasPushout g F
{Î± : Type u} {Î² : Type v} [EmetricSpace Î±] [PseudoEmetricSpace Î²] {F : Î± â†’ Î²} (hF : Isometry F) : Embedding F
{m : Type u_3} {N : Type u_4} [Monoid m] [Monoid N] (F : m â†’* Náµáµ’áµ–) (l : List m) : Mul_Opposite.Unop (â‡‘F l.Prod) = (List.Map (Mul_Opposite.Unop âˆ˜ â‡‘F) l).reverse.Prod
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] [InnerProductSpace ð•œ F] [CompleteSpace E] [CompleteSpace F] (A : E â†’L[ð•œ] F) (x : E) (y : F) : HasInner.inner x (â‡‘(â‡‘Continuous_LinearMap.Adjoint A) y) = HasInner.inner (â‡‘A x) y
{R : Type u_2} {Î“â‚€ : Type u_3} [CommRing R] [Linear_ordered_CommMonoid_with_Zero Î“â‚€] (v : Valuation R Î“â‚€) {J : Ideal R} (hJ : J â‰¤ v.supp) : (v.on_quot hJ).supp = Ideal.Map (Ideal.Quotient.Mk J) v.supp
{Î± : Type u_1} [LinearOrder Î±] {k l : â„•} {S : Finset Î±} {i : Fin k} {j : Fin l} {h : S.Card = k} {h' : S.Card = l} : â‡‘(S.order_emb_of_Fin h) i = â‡‘(S.order_emb_of_Fin h') j â†” â†‘i = â†‘j
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {x : E} {n : WithTop â„•} {S : set E} {F : E â†’ F} {g : E â†’ G} (hF : ContDiff_within_at ð•œ n F S x) (hg : ContDiff_within_at ð•œ n g S x) : ContDiff_within_at ð•œ n (Î» (x : E), (F x, g x)) S x
 : (Submodule.Span â„‚ (set.Range fourier)).topological_Closure = âŠ¤
{Î± : Type u} {Î² : Type v} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_IsBot) : Filter.Tendsto (Î» (x : Î²), F x * g x) l Filter.at_IsBot
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.has_Finite_products C] : CategoryTheory.Limits.has_Finite_biproducts C
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} (hg : âˆ€ (y : â†¥S), IsAddUnit (â‡‘g â†‘y)) (z : N) (W v : P) : â‡‘(F.Lift hg) z + W = v â†” â‡‘g (F.sec z).fst + W = â‡‘g â†‘((F.sec z).Snd) + v
{R : Type u_1} {m : Type u_3} {A B : R} [HasScalar R m] [has_Mul R] [IsScalarTower R R m] : IsSmulRegular m (A * B) âˆ§ IsSmulRegular m (B * A) â†” IsSmulRegular m A âˆ§ IsSmulRegular m B
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) (hF'' : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv^[2] F x < 0) : strict_ConcaveOn â„ D F
{Î± : Type u_1} {m : Type u_3} {n : Type u_4} [NonUnitalSemiring Î±] [Star_Ring Î±] {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} (hA : A._hermitian) (hBC : B.Conj_transpose = C) (hD : D._hermitian) : (Matrix.from_blocks A B C D)._hermitian
(K : Type u) {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {vâ‚‚ : Type v'} [AddCommGroup vâ‚‚] [module K vâ‚‚] (F : v â†’â‚—[K] vâ‚‚) (P : Submodule K v) [Finite_dimensional K â†¥P] : Finite_dimensional.finrank K â†¥(Submodule.Map F P) â‰¤ Finite_dimensional.finrank K â†¥P
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 P : P} : P -áµ¥ P1 = P -áµ¥ P2 â†” P1 = P2
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (x y : m â§¸ S) : âˆ¥x + yâˆ¥ â‰¤ âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{C : Type uâ‚} {D : Type uâ‚‚} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D â¥¤ C} [CategoryTheory.IsRightAdjoint i] (A : C) [CategoryTheory.IsIso ((CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App A)] : A âˆˆ i.EssImage
{Î± : Type u} [SemilatticeInf Î±] [OrderTop Î±] (x y : Î±) : (x â¨¯ y) = x âŠ“ y
{Î± : Type u_1} (L : List (List Î±)) (C : Composition L.Join.length) (h : List.Map List.length L = C.blocks) : L.Join.split_wrt_Composition C = L
{Î± : Type u_1} {n : Type u_4} {R : Type u_5} [HasSub n] [HasScalar R Î±] (k : R) (v : n â†’ Î±) : Matrix.circulant (k â€¢ v) = k â€¢ Matrix.circulant v
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} (v : v) {P : P} (hp : P âˆˆ S) : v +áµ¥ P âˆˆ S â†” v âˆˆ S.direction
(R : Type u_1) {S : Type u_2} {m : Type u_3} [Semiring R] [Semiring S] [AddCommMonoid m] [HasScalar R S] [module S m] [module R m] [IsScalarTower R S m] (h : IsNoetherian R m) : IsNoetherian S m
{J : Type uâ‚} [CategoryTheory.Category J] [Nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), âˆƒ (l : List J), List.chain CategoryTheory.Zag jâ‚ l âˆ§ (jâ‚ :: l).Last _ = jâ‚‚) : CategoryTheory.IsConnected J
{ð•œ : Type u_1} {x : Type u_2} [_R_or_C ð•œ] [TopologicalSpace x] [CompactSpace x] (A : Subalgebra ð•œ C(x, ð•œ)) (hA : A.separates_points) (hA' : Continuous_Map.Conj_invariant_Subalgebra (Subalgebra.Restrict_scalars â„ A)) : A.topological_Closure = âŠ¤
{Î± : Type u_1} [UniformSpace Î±] {S : set Î±} : IsOpen S â†” âˆ€ (x : Î±), x âˆˆ S â†’ (âˆƒ (v : set (Î± Ã— Î±)) (h : v âˆˆ Uniformity Î±), UniformSpace.ball x v âŠ† S)
{ð•œ : Type u_3} [Field ð•œ] (n : Type) [Fintype n] [DecidableEq n] (m : Matrix n n ð•œ) : âˆƒ (L L' : List (Matrix.TransvectionStruct n ð•œ)) (D : n â†’ ð•œ), ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod = Matrix.Diagonal D
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [CharZero k] {n : â„•} (S : Affine.Simplex k P n) {fsâ‚ fsâ‚‚ : Finset (Fin (n + 1))} {mâ‚ mâ‚‚ : â„•} (hâ‚ : fsâ‚.Card = mâ‚ + 1) (hâ‚‚ : fsâ‚‚.Card = mâ‚‚ + 1) : Finset.centroid k Finset.Univ (S.face hâ‚).points = Finset.centroid k Finset.Univ (S.face hâ‚‚).points â†” fsâ‚ = fsâ‚‚
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m â†’* P} (h : C â‰¤ Con.Ker F) : (C.Lift F h).mrange = F.mrange
{Î± : Type u} [PseudoMetricSpace Î±] (S : set Î±) : uniform_Continuous (Î» (x : Î±), metric.Inf_dist x S)
{R : Type u_1} (S : Type u_2) [CommRing R] [CommRing S] (y : R) [Algebra R S] [IsLocalization.Away y S] [h : Ideal._jacobson R] (J : Ideal S) : J.IsMaximal â†” (Ideal.comap (Algebra_Map R S) J).IsMaximal âˆ§ y âˆ‰ Ideal.comap (Algebra_Map R S) J
{xâ‚ xâ‚‚ Y : top} {F : C(â†¥xâ‚, â†¥Y)} {g : C(â†¥xâ‚‚, â†¥Y)} {xâ‚€ xâ‚ : â†¥xâ‚} {xâ‚‚ xâ‚ƒ : â†¥xâ‚‚} {P : Path xâ‚€ xâ‚} {q : Path xâ‚‚ xâ‚ƒ} (hfg : âˆ€ (t : â†¥Unit_Interval), â‡‘F (â‡‘P t) = â‡‘g (â‡‘q t)) : (FundamentalGroupoid.FundamentalGroupoid_Functor.Map F).Map âŸ¦PâŸ§ == (FundamentalGroupoid.FundamentalGroupoid_Functor.Map g).Map âŸ¦qâŸ§
{Î± : Type u_1} {C : set (set Î±)} (h : âˆ€ (A : Î±), âˆƒ! (B : set Î±) (h : B âˆˆ C), A âˆˆ B) {S : set Î±} {y : Î±} (hs : S âˆˆ C) (hy : y âˆˆ S) : S = {x : Î± | (Setoid.Mk_Classes C h).Rel x y}
{F : Type u_1} [NormedGroup F] [NormedSpace â„ F] (F : â„ â†’ F) {K : set F} (hK : IsComplete K) : Measurable_set {x : â„ | Differentiable_within_at â„ F (set.ici x) x âˆ§ deriv_within F (set.ici x) x âˆˆ K}
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {x Y : C} (g : x âŸ¶ Y) (Fâ‚ Fâ‚‚ : CategoryTheory.Subobject Y) : (CategoryTheory.Subobject.pullback g).obj (Fâ‚ âŠ“ Fâ‚‚) = (CategoryTheory.Subobject.pullback g).obj Fâ‚ âŠ“ (CategoryTheory.Subobject.pullback g).obj Fâ‚‚
{Î² : Type u} {Î³ : Type W} [Semiring Î²] [Semiring Î³] (F : Î² â†’+* Î³áµáµ’áµ–) (l : List Î²) : Mul_Opposite.Unop (â‡‘F l.Prod) = (List.Map (Mul_Opposite.Unop âˆ˜ â‡‘F) l).reverse.Prod
{o : Ordinal} : Ordinal.principal has_Mul.Mul o â†” o â‰¤ 2 âˆ¨ âˆƒ (A : Ordinal), o = Ordinal.omega ^ Ordinal.omega ^ A
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] (v : v) : G.degree v â‰¤ G.max_degree
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (h : B.Orientation = o) (Î¸ : â„) : o.rotation â†‘Î¸ = hb.rotation â†‘Î¸
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) (m : Multiset L) : (âˆ€ (A : L), A âˆˆ m â†’ A âˆˆ S) â†’ m.Prod âˆˆ S
{R : Type u} [CommRing R] [IsDomain R] [Unique_factorization_Monoid R] (hâ‚ : âˆƒ (P : R), Irreducible P) (hâ‚‚ : âˆ€ â¦ƒP q : Râ¦„, Irreducible P â†’ Irreducible q â†’ Associated P q) : discrete_Valuation_Ring R
{Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {g : Î± â†’ Î²} (h : Function.Semiconj g fa fb) : set.maps_to g (Function.FixedPoints fa) (Function.FixedPoints fb)
(R : Type u) [CommRing R] [IsDomain R] [discrete_Valuation_Ring R] : âˆƒ (Ï– : R), Irreducible Ï–
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A B : Î±} (ha : 1 â‰¤ A) (hb : 1 â‰¤ B) : 1 â‰¤ A * B
{Î± : Type u_1} [TopologicalSpace Î±] [t0_Space Î±] [CompactSpace Î±] {S : set Î±} (hS : IsClosed S) (hne : S.Nonempty) : âˆƒ (x : Î±), x âˆˆ S âˆ§ IsClosed {x}
(N : â„•) {j : â„} (hj : 0 < j) {C : â„} (hc : 1 < C) : (Finset.Filter (Î» (i : â„•), j < â†‘âŒŠC ^ iâŒ‹â‚Š) (Finset.Range N)).Sum (Î» (i : â„•), 1 / â†‘âŒŠC ^ iâŒ‹â‚Š ^ 2) â‰¤ C ^ 5 * (C - 1)â»Â¹ ^ 3 / j ^ 2
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {Î¹ : Type u_1} (v : Î¹ â†’ m) (i : LinearIndependent R v) (W : set m) [Fintype â†¥W] (S : Submodule.Span R W = âŠ¤) : Cardinal.Mk Î¹ â‰¤ â†‘(Fintype.Card â†¥W)
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A B : Î±} : Aâ»Â¹ â‰¤ B â†’ Bâ»Â¹ â‰¤ A
{Î¹ : Type u} (S : Finset Î¹) {F g : Î¹ â†’ â„} {P q : â„} (hpq : P.IsConjugateExponent q) (hF : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ F i) (hg : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ g i) : S.Sum (Î» (i : Î¹), F i * g i) â‰¤ S.Sum (Î» (i : Î¹), F i ^ P) ^ (1 / P) * S.Sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) : Vector_Span k {P} = âŠ¥
{Î± : Type u} {A B : Î±} [MulZeroOneClass Î±] [PartialOrder Î±] [ZeroLt.PosMulMono Î±] (ha : A â‰¤ 1) (hb : B â‰¤ 1) (A0 : 0 â‰¤ A) : A * B â‰¤ 1
{Î± : Type u_1} {Î² : Type u_2} [AddCommMonoid Î±] [TopologicalSpace Î±] {F : Î² â†’ Î±} {S : Finset Î²} (hF : âˆ€ (B : Î²), B âˆ‰ S â†’ F B = 0) : has_Sum F (S.Sum (Î» (B : Î²), F B))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {x : E} {n : WithTop â„•} {P : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n F P S) (hn : 1 â‰¤ n) (hx : S âˆˆ nhds x) : Differentiable_at ð•œ F x
{Î± : Type u_1} {n : Type u_4} [Semiring Î±] [Fintype n] [AddGroup n] (v W : n â†’ Î±) : (Matrix.circulant v).Mul (Matrix.circulant W) = Matrix.circulant ((Matrix.circulant v).Mul_vec W)
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m â†’+ P} (hg : âˆ€ (y : â†¥S), IsAddUnit (â‡‘g â†‘y)) (z : N) (v : P) : â‡‘(F.Lift hg) z = v â†” â‡‘g (F.sec z).fst = â‡‘g â†‘((F.sec z).Snd) + v
{m : Type u_1} [semi_NormedGroup m] {S : Add_Subgroup m} (x : m â§¸ S) : âˆ¥-xâˆ¥ = âˆ¥xâˆ¥
{Î± : Type u_1} {Î² : Type u_2} [AddZeroClass Î±] [AddZeroClass Î²] (F g : Î±áµáµ’áµ– â†’+ Î²) (h : F.Comp Mul_Opposite.Op_Add_Equiv.to_AddMonoid_hom = g.Comp Mul_Opposite.Op_Add_Equiv.to_AddMonoid_hom) : F = g
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [PseudoMetricSpace Î²] : Continuous (Î» (P : bounded_Continuous_Function Î± Î² Ã— Î±), â‡‘(P.fst) P.Snd)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {u v : E} (hv : v âˆˆ K) (hvo : u - v âˆˆ Ká—®) : â†‘(â‡‘(Orthogonal_projection K) u) = v
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} {m' : Type u_6} {v : Î¹ â†’ m} [Semiring R] [AddCommMonoid m] [AddCommMonoid m'] [module R m] [module R m'] (hv : LinearIndependent R v) (F : m â†’â‚—[R] m') (hF_inj : F.Ker = âŠ¥) : LinearIndependent R (â‡‘F âˆ˜ v)
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (x y : E) : _R_or_C.Abs (HasInner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{Î¹ : Type u_1} {S : Type u_3} {R : Type u_4} [DecidableEq Î¹] [AddMonoid Î¹] [CommSemiring S] [Semiring R] [Algebra S R] (A : Î¹ â†’ Submodule S R) [set_like.graded_Monoid A] : (â¨† (i : Î¹), A i) = (direct_Sum.Coe_AlgHom A).Range.to_Submodule
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x y : E} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘_R_or_C.re (HasInner.inner x y) + âˆ¥yâˆ¥ ^ 2
{R : Type u} [Semiring R] {Î¹ : Type v} [decÎ¹ : DecidableEq Î¹] {m : Type u_1} [AddCommMonoid m] [module R m] {A : Î¹ â†’ Submodule R m} {i j : Î¹} (hij : i â‰  j) (h : set.Univ = {i, j}) (hi : direct_Sum._internal A) : _IsCompl (A i) (A j)
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} [CategoryTheory.Limits.HasCoequalizer F g] (h : F = g) : CategoryTheory.IsIso (CategoryTheory.Limits.coequalizerÏ€ F g)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_at F A) (hb : Continuous_at F B) : fderiv â„ (Î» (P : â„ Ã— â„), âˆ« (x : â„) in P.fst..P.Snd, F x) (A, B) = (Continuous_Linear_Map.Snd â„ â„ â„).Smul_Right (F B) - (Continuous_Linear_Map.fst â„ â„ â„).Smul_Right (F A)
(A : â„) {B : â„} (h : 0 < B) : MeasureTheory.IntegrableOn (Î» (x : â„), Real.Exp (-B * x)) (set.ioi A) MeasureTheory.MeasureSpace.Volume
{K : Type u_1} [Field K] (n : â„•) : Polynomial.Splits (Ring_hom.Id K) (Polynomial.cyclotomic' n K)
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} {R : CategoryTheory.Presieve x} (F : Y âŸ¶ x) [CategoryTheory.SplitEpi F] (hF : R F) : CategoryTheory.Sieve.generate R = âŠ¤
{Î± : Type u_1} {Î¹' : sort u_5} (S : Î¹' â†’ set Î±) : (â‹‚ (i : Î¹'), S i) = â‹‚ (t : Finset (plift Î¹')) (i : plift Î¹') (h : i âˆˆ t), S i.down
{Î± : Type u_1} {n : â„•} (v : Vector Î± n) : Vector.Map Id v = v
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (hfp : Algebra.Finite_presentation R A) (Î¹ : Type u_3) [Fintype Î¹] : Algebra.Finite_presentation R (mv_Polynomial Î¹ A)
{Î± : Type u} (S : set Î±) [h : Fintype â†¥S] : S.Finite
(P : â„•) [P_Prime : Fact (Nat.Prime P)] {q : â„š} {n D : â„¤} (hqz : q â‰  0) (qdf : q = Rat.Mk n D) : padic_val_rat P q = â†‘((multiplicity â†‘P n).get _) - â†‘((multiplicity â†‘P D).get _)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} (F : top.Presheaf C x) (U : TopologicalSpace.Opens â†¥x) (R : CategoryTheory.Presieve U) (F : Î£ (v : TopologicalSpace.Opens â†¥x), {F // R F}) : (top.Presheaf.covering_of_Presieve.FirstObj_iso_Pi_Opens F U R).hom â‰« CategoryTheory.Limits.Pi.Ï€ (Î» (i : Î£ (v : TopologicalSpace.Opens â†¥x), {F // R F}), F.obj (Opposite.Op (top.Presheaf.covering_of_Presieve U R i))) F = CategoryTheory.Limits.Pi.Ï€ (Î» (F : Î£ (v : TopologicalSpace.Opens â†¥x), {F // R F}), F.obj (Opposite.Op F.fst)) F
{G : Type u_1} [Group G] [hG : Group.IsNilpotent G] : Nat.Find _ = Group.nilpotency_class G
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {F' : E â†’L[â„] â„} {S : set E} (h : IsLocalMinOn F S A) (hF : HasFderivWithinAt F F' S A) {y : E} (hy : y âˆˆ Pos_TangentConeAt S A) (hy' : -y âˆˆ Pos_TangentConeAt S A) : â‡‘F' y = 0
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * HasInner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {y : L} : y âˆˆ S â†’ âˆ€ {x : K}, x â€¢ y âˆˆ S
(J : Type u_1) (C : Type u_2) [CategoryTheory.Category J] [CategoryTheory.Category C] : CategoryTheory.Idempotents.to_Karoubi (J â¥¤ C) â‹™ CategoryTheory.Idempotents.Karoubi_Functor_Category_Embedding J C = (CategoryTheory.whiskering_Right J C (CategoryTheory.Idempotents.Karoubi C)).obj (CategoryTheory.Idempotents.to_Karoubi C)
{Î± : Type u_1} [CommSemiring Î±] (t : Tree Î±) (r : tactic_.Ring2.CsringExpr) : (tactic_.Ring2.HornerExpr.of_csexpr r)._cs âˆ§ tactic_.Ring2.HornerExpr.cseval t (tactic_.Ring2.HornerExpr.of_csexpr r) = tactic_.Ring2.CsringExpr.Eval t r
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (Wâ‚ Wâ‚‚ : Î¹ â†’ k) (P : Î¹ â†’ P) : â‡‘(S.weighted_vsub P) Wâ‚ +áµ¥ â‡‘(S.affine_combination P) Wâ‚‚ = â‡‘(S.affine_combination P) (Wâ‚ + Wâ‚‚)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P1 P2 : P} (hp1 : P1 âˆˆ S) : (affine_Span k (HasInsert.Insert P2 â†‘S)).direction = Submodule.Span k {P2 -áµ¥ P1} âŠ” S.direction
{Î± : Type u} {Î² : Type v} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_IsBot) : Filter.Tendsto (Î» (x : Î²), F x * g x) l Filter.at_top
{S : set â„‚} : S.countable â†’ (Complex.Exp â»Â¹' S).countable
{Î± : Type u_1} {n : Type u_4} [has_Zero Î±] [DecidableEq n] (A : Matrix n n Î±) : A.IsDiag â†” Matrix.Diagonal A.diag = A
{Î± : Type u_1} {E : Î± â†’ Type u_2} {P : Ennreal} [Î  (i : Î±), NormedGroup (E i)] {Î¹ : Type u_3} {l : Filter Î¹} [l.Ne_IsBot] [Fact (1 â‰¤ P)] {C : â„} {F : Î¹ â†’ â†¥(Lp E P)} (hCF : âˆ€á¶  (k : Î¹) in l, âˆ¥F kâˆ¥ â‰¤ C) {F : â†¥(Lp E P)} (hF : Filter.Tendsto (Id (Î» (i : Î¹), â‡‘(F i))) l (nhds â‡‘F)) : âˆ¥Fâˆ¥ â‰¤ C
{m : Type u_3} {N : Type u_4} [AddZeroClass m] [AddZeroClass N] (F : m â†’+ N) : â‡‘F 0 = 0
{E : Type u_1} [InnerProductSpace â„ E] {n : â„•} [Fact (Finite_dimensional.finrank â„ E = n + 1)] : Cont_mdiff (model_with_corners_self â„ (EuclideanSpace â„ (Fin n))) (model_with_corners_self â„ (EuclideanSpace â„ (Fin n))) âŠ¤ (Î» (x : â†¥(Metric.Sphere 0 1)), -x)
{m : Type u_1} [Monoid m] {S : set m} (hs : _Submonoid S) {l : List m} : (âˆ€ (x : m), x âˆˆ l â†’ x âˆˆ S) â†’ l.Prod âˆˆ S
{G : Type u_7} [AddGroup G] (L : List G) : L.reverse.Sum = -(List.Map (Î» (x : G), -x) L).Sum
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} {F : ð•œ â†’ F} : iterated_deriv (n + 1) F = deriv (iterated_deriv n F)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [AddCommMonoid Î±] [TopologicalSpace Î±] [t2_Space Î±] [Encodable Î³] [CompleteLattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (S : Î³ â†’ Î²) : âˆ‘' (i : â„•), m (â¨† (B : Î³) (h : B âˆˆ Encodable.decodeâ‚‚ Î³ i), S B) = âˆ‘' (B : Î³), m (S B)
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {F : Î± â†’ Î²} (hF : _Group_hom F) : F 1 = 1
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {P : E â†’ FormalMultilinearSeries ð•œ E F} {n : â„•} : HasFtaylorSeriesUpToOn â†‘(n + 1) F P S â†” (âˆ€ (x : E), x âˆˆ S â†’ (P x 0).uncurry0 = F x) âˆ§ (âˆ€ (x : E), x âˆˆ S â†’ HasFderivWithinAt (Î» (y : E), P y 0) (P x 1).Curry_Left S x) âˆ§ HasFtaylorSeriesUpToOn â†‘n (Î» (x : E), â‡‘(Continuous_multilinear_Curry_Fin1 ð•œ E F) (P x 1)) (Î» (x : E), (P x).shift) S
{Î± : Type u} [Subsingleton Î±] (l : Filter Î±) [l.Ne_IsBot] : l = âŠ¤
(t : â„) : Filter.Tendsto (Î» (x : â„), x * Real.log (1 + t / x)) Filter.at_top (nhds t)
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î± â†’ Î² Ã— Î³} (hF : Continuous F) : Continuous (Î» (A : Î±), (F A).Snd)
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A : Î±} : -A â‰¤ 0 â†’ 0 â‰¤ A
{G : Type u_1} [Group G] {x y : G} : y âˆˆ Subgroup.Closure {x} â†” âˆƒ (n : â„¤), x ^ n = y
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : EqvGen.Setoid r = HasInf.Inf {S : Setoid Î± | âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ S.Rel x y}
{G : Type u_1} [AddGroup G] (K : Add_Subgroup G) {l : List G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.Sum âˆˆ K
{Î± : Type u_1} [cancel_CommMonoid_with_Zero Î±] [wf_Dvd_Monoid Î±] [Gcd_Monoid Î±] : Unique_factorization_Monoid Î±
(C : Type u) [CategoryTheory.Category C] : CategoryTheory.EssentiallySmall C â†” Small (CategoryTheory.Skeleton C) âˆ§ CategoryTheory.locally_Small C
{A B C : â„¤} (h1 : A % B = C) (h2 : (A - C).Nat_Abs < B.Nat_Abs) : A = C
{R : Type u_1} [Semiring R] [Nontrivial R] : PowerSeries.x.order = 1
{m : Type u_2} [AddCommGroup m] {A : Type u_1} [CommRing A] [module A m] (F : m â‰ƒâ‚—[A] m) : â‡‘LinearMap.det â†‘(F.Symm) * â‡‘LinearMap.det â†‘F = 1
{n : â„•} {i : Fin (n + 1)} : SimplexCategoryÎ´ (â‡‘Fin.cast_Succ i) â‰« SimplexCategoryÏƒ i = ðŸ™ (SimplexCategory.Mk n)
{C : Type uâ‚} [CategoryTheory.Category C] {P : Cáµ’áµ– â¥¤ Type W} (J : CategoryTheory.GrothendieckTopology C) {P' : Cáµ’áµ– â¥¤ Type W} (i : P â‰… P') (h : CategoryTheory.Presieve._sheaf J P) : CategoryTheory.Presieve._sheaf J P'
{t : Type u} [CategoryTheory.Category t] (i : CategoryTheory.Arrow t) {x Y : t} (P : x â‰… Y) (sq : i âŸ¶ CategoryTheory.Arrow.Mk P.hom) : i.hom â‰« sq.Right â‰« P.Inv = sq.Left
{n : â„•} {A : Cardinal} (h : n â‰  0) : n â€¢ A < Cardinal.aleph0 â†” A < Cardinal.aleph0
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] {F g : Î± â†’ Î²} {A : Î±} (h : F =á¶ [nhds A] g) : âˆ€á¶  (y : Î±) in nhds A, F =á¶ [nhds y] g
(x : Type u) (Y : Type v) [MetricSpace x] [CompactSpace x] [Nonempty x] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : Isometry (GromovHausdorff.optimal_GH_injl x Y)
{Î± : Type u_2} {Î¹ : Type u_5} [AddCommMonoid Î±] (t : Finset Î¹) (F : Î¹ â†’ set Î±) (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), i âˆˆ t â†’ g i âˆˆ F i) : t.Sum (Î» (i : Î¹), g i) âˆˆ t.Sum (Î» (i : Î¹), F i)
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B C : Î±} : A + B < C â†’ B < -A + C
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] {F : Type v} [NormedGroup F] [NormedSpace â„‚ F] {F : E â†’ F} {S : set E} {z W : E} (hD : Diff_Cont_on_cl â„‚ F S) (hz : IsMaxOn (HasNorm.norm âˆ˜ F) S z) (HSub : Metric.Ball z (HasDist.dist W z) âŠ† S) : âˆ¥F Wâˆ¥ = âˆ¥F zâˆ¥
{Î¹ : Type u_1} {R : Type u_3} {K : Type u_4} {m : Type u_5} {v : Î¹ â†’ m} [Semiring R] [AddCommMonoid m] [module R m] [Semiring K] [SmulWithZero R K] [module K m] [IsScalarTower R K m] (hinj : Function.Injective (Î» (r : R), r â€¢ 1)) (li : LinearIndependent K v) : LinearIndependent R v
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommMonoid E] [HasScalar ð•œ E] {x : E} {S : set E} : Star_Convex ð•œ x S â†” âˆ€ â¦ƒA B : ð•œâ¦„, 0 â‰¤ A â†’ 0 â‰¤ B â†’ A + B = 1 â†’ A â€¢ {x} + B â€¢ S âŠ† S
{E : Type u_1} {F : Type u_2} [InnerProductSpace â„ E] [InnerProductSpace â„ F] {F : E â†’ F} {x : E} : ConformalAt F x â†” âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (u v : E), HasInner.inner (â‡‘(fderiv â„ F x) u) (â‡‘(fderiv â„ F x) v) = C * HasInner.inner u v
{E : Type u} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] (F F' : â„ â†’ E) {A B : â„} (hle : A â‰¤ B) {S : set â„} (hs : S.countable) (Hc : Continuous_on F (set.icc A B)) (hD : âˆ€ (x : â„), x âˆˆ set.Ioo A B  S â†’ HasDerivAt F (F' x) x) (Hi : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : âˆ« (x : â„) in A..B, F' x = F B - F A
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} : InnerProductGeometry.angle x y = Real.Pi â†” x â‰  0 âˆ§ âˆƒ (r : â„), r < 0 âˆ§ y = r â€¢ x
{C : Type uâ‚} [CategoryTheory.Category C] {t : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] {D : J â¥¤ t.Algebra} (C : CategoryTheory.Limits.Cocone (D â‹™ t.Forget)) (t : CategoryTheory.Limits.IsColimit C) [CategoryTheory.Limits.PreservesColimit (D â‹™ t.Forget) â†‘t] (j : J) : â†‘t.Map (C.Î¹.App j) â‰« CategoryTheory.Monad.Forget_creates_colimits.lambda C t = (D.obj j).A â‰« C.Î¹.App j
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization m S] (A : S) : âˆƒ (B : â†¥m), IsLocalization._integer R (A * â‡‘(Algebra_Map R S) â†‘B)
{Î± : Type u_1} [circular_Preorder Î±] {A B C : Î±} : HasBtw.Btw A B C â†” HasBtw.Btw C A B
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) : Function.Surjective â‡‘(S.normed_Mk)
{n : â„•} : order_of (dihedral_Group.r 1) = n
{Î± : Type u_1} {Î² : Type u_2} [Nontrivial Î²] {F : Î± â†’ Î²} (hF : Function.Surjective F) : Nontrivial Î±
{Î± : Type u_1} [cancel_CommMonoid_with_Zero Î±] [Gcd_Monoid Î±] {m n k : Î±} (h : k âˆ£ m * n) : âˆƒ (Dâ‚ : Î±) (hDâ‚ : Dâ‚ âˆ£ m) (Dâ‚‚ : Î±) (hDâ‚‚ : Dâ‚‚ âˆ£ n), k = Dâ‚ * Dâ‚‚
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : Dense S â†’ Dense (Closure S)
{Î± : Type u_1} (S : Finset Î±) : S.powerset.Card = 2 ^ S.Card
{ð•‚ : Type u_1} {ð”¸ : Type u_2} [nondiscrete_NormedField ð•‚] [normed_CommRing ð”¸] [normed_Algebra ð•‚ ð”¸] [CompleteSpace ð”¸] [CharZero ð•‚] {x : ð”¸} (hx : x âˆˆ Emetric.Ball 0 (Exp_series ð•‚ ð”¸).radius) : HasStrictFderivAt (Exp ð•‚) (Exp ð•‚ x â€¢ 1) x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasKernel F] [CategoryTheory.Mono F] : CategoryTheory.Limits.KernelÎ¹ F = 0
{Î± : Type u_1} [Monoid Î±] {A u : Î±} (hu : IsUnit u) : u âˆ£ A
{Î± : Type u_1} {Î´ : Type u_5} [TopologicalSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±] [MeasurableSpace Î´] [complete_LinearOrder Î±] [OrderTopology Î±] [TopologicalSpace.SecondCountableTopology Î±] {Î¹ : Type u_2} {Î¹' : Type u_3} {F : Î¹ â†’ Î´ â†’ Î±} {u : Filter Î¹} (hF : âˆ€ (i : Î¹), Measurable (F i)) {P : Î¹' â†’ Prop} {S : Î¹' â†’ set Î¹} (hu : u.has_countable_Basis P S) (hs : âˆ€ (i : Î¹'), (S i).countable) : Measurable (Î» (x : Î´), u.limsup (Î» (i : Î¹), F i x))
(S : set â„•+) (K : Type W) (L : Type z) [Field K] [Field L] [Algebra K L] [h : number_Field K] [Fintype â†¥S] [IsCyclotomicExtension S K L] : number_Field L
{R : Type u_1} {A : Type u_2} [CommSemiring R] [CommSemiring A] [Algebra R A] (S t : Subalgebra R A) : S.to_Submodule * t.to_Submodule = (S âŠ” t).to_Submodule
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {x : m} [NoZeroSmulDivisors R m] (h : SameRay R x (-x)) : x = 0
{n : â„•} {Î± : Type u_1} [Preorder Î±] {F : Fin (n + 1) â†’ Î±} : Antitone F â†” âˆ€ (i : Fin n), F i.Succ â‰¤ F (â‡‘Fin.cast_Succ i)
(m : Type u_1) [Monoid_with_Zero m] : IsSquare 0
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (h : module.rank K v < Cardinal.aleph0) : (Basis.of_Vector_Space_Index K v).Finite
{R : Type u_1} {A : R} [Monoid R] {n : â„•} (n0 : 0 < n) : IsRegular (A ^ n) â†” IsRegular A
{C : Type uâ‚} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Mono (CategoryTheory.Limits.terminal.from A)] : CategoryTheory.IsSubterminal A
{x : top} {t : â†¥x â†’ Type v} (P : top.LocalPredicate t) (x : â†¥x) (W : âˆ€ (t : t x), âˆƒ (U : TopologicalSpace.IsOpen_nhds x) (F : Î  (y : â†¥(U.val)), t â†‘y) (h : P.to_prelocal_predicate.Pred F), F âŸ¨x, _âŸ© = t) : Function.Surjective (top.stalk_to_fiber P x)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Fintype Î¹] [DecidableEq Î¹] [Î  (i : Î¹), DecidableEq (Î± i)] (r : Î  (i : Î¹), Î± i â†’ Finset (Î± i) â†’ Prop) (h_ex : âˆ€ (i : Î¹) (S : Finset (Î± i)), S.Nonempty â†’ (âˆƒ (x : Î± i) (h : x âˆˆ S), r i x (S.erase x))) {P : (Î  (i : Î¹), Finset (Î± i)) â†’ Prop} (F : Î  (i : Î¹), Finset (Î± i)) (h0 : P (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), Finset (Î± i)) (i : Î¹) (x : Î± i), r i x (g i) â†’ P g â†’ P (Function.update g i (HasInsert.Insert x (g i)))) : P F
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {F' : E â†’L[â„] â„} {S : set E} (h : IsLocalMaxOn F S A) (hF : HasFderivWithinAt F F' S A) {y : E} (hy : y âˆˆ Pos_TangentConeAt S A) : â‡‘F' y â‰¤ 0
{J : Type uâ‚} [CategoryTheory.Category J] [Nonempty J] (h : âˆ€ {Î± : Type uâ‚} (F : J â¥¤ CategoryTheory.Discrete Î±) (j j' : J), F.obj j = F.obj j') : CategoryTheory.IsConnected J
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {A B : C} (F : A âŸ¶ B) (F : C â¥¤ D) [CategoryTheory.IsIso (F.Map F)] [CategoryTheory.ReflectsIsomorphisms F] : CategoryTheory.IsIso F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [AddCommGroup vâ‚‚] [module k vâ‚‚] [AddTorsor vâ‚‚ Pâ‚‚] {P : Î¹ â†’ P} (F : P â†’áµƒ[k] Pâ‚‚) (hai : AffineIndependent k (â‡‘F âˆ˜ P)) : AffineIndependent k P
{R : Type u} [non_assoc_Semiring R] {S : set R} {t : Subsemiring R} : Subsemiring.Closure S â‰¤ t â†” S âŠ† â†‘t
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] {S t : set E} (hsâ‚ : Convex â„ S) (hsâ‚‚ : IsOpen S) (ht : Convex â„ t) (disj : Disjoint S t) : âˆƒ (F : E â†’L[â„] â„) (u : â„), (âˆ€ (A : E), A âˆˆ S â†’ â‡‘F A < u) âˆ§ âˆ€ (B : E), B âˆˆ t â†’ u â‰¤ â‡‘F B
{ð•œ : Type u_1} {E : Type u_2} [NormedField ð•œ] [semi_NormedGroup E] [NormedSpace ð•œ E] {x : E} {S : set E} (hs : Metric.Bounded S) {u : set E} (hu : u âˆˆ nhds x) : âˆ€á¶  (r : ð•œ) in nhds 0, {x} + r â€¢ S âŠ† u
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : RË£) (n : â„•) : âˆ€á¶  (t : R) in nhds 0, Ring.Inverse (â†‘x + t) = (Finset.Range n).Sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹ + (-â†‘xâ»Â¹ * t) ^ n * Ring.Inverse (â†‘x + t)
{Î± : Type u} [TopologicalSpace Î±] [t1_Space Î±] [âˆ€ (x : Î±), (nhds_within x {x}á¶œ).Ne_IsBot] {S : set Î±} (hs : Dense S) (t : Finset Î±) : Dense (S  â†‘t)
{ð•œ : Type u_1} [Field ð•œ] {m : Type u_2} [AddCommGroup m] [module ð•œ m] : â‡‘LinearMap.det 0 = 0 ^ Finite_dimensional.finrank ð•œ m
{Î± : Type u_1} {m : set Î± â†’ Ennreal} {m_Empty : m âˆ… = 0} {S t : set Î±} (h : âˆ€ (u : set Î±), (S âˆ© u).Nonempty â†’ (t âˆ© u).Nonempty â†’ m u = âŠ¤) : â‡‘(MeasureTheory.OuterMeasure.of_Function m m_Empty) (S âˆª t) = â‡‘(MeasureTheory.OuterMeasure.of_Function m m_Empty) S + â‡‘(MeasureTheory.OuterMeasure.of_Function m m_Empty) t
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (G : C â¥¤ D) [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.Empty C) G] : CategoryTheory.Limits.HasInitial D
{m : Type u_1} [AddZeroClass m] {C : Add_Con m} : Function.Surjective â‡‘(C.Mk')
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C â¥¤ D) [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.Additive] [CategoryTheory.EnoughInjectives C] {x Y : C} (F : x âŸ¶ Y) (P : CategoryTheory.InjectiveResolution x) (q : CategoryTheory.InjectiveResolution Y) : F.Map F â‰« CategoryTheory.Abelian.Functor.Right_derived_Zero_to_self_App_Inv F q = CategoryTheory.Abelian.Functor.Right_derived_Zero_to_self_App_Inv F P â‰« (F.Right_derived 0).Map F
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {S t : set Î±} (ht : IsAntichain r t) (h : Minimals r S âŠ† t) (hs : âˆ€ â¦ƒA : Î±â¦„, A âˆˆ t â†’ (âˆƒ (B : Î±) (h : B âˆˆ Minimals r S), r A B)) : Minimals r S = t
{G : Type u_1} [Group G] (S : set G) : _Subgroup (Group.Normal_Closure S)
{Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {x : Î±} (hx : Function.IsFixedPt fa x) {g : Î± â†’ Î²} (h : Function.Semiconj g fa fb) : Function.IsFixedPt fb (g x)
{K : Type u_1} [Linear_ordered_Field K] {A : K} (h : 1 < A) (n : â„•) : â†‘n â‰¤ A ^ n / (A - 1)
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î±'] [DecidableEq Î³] [DecidableEq Î´] {S : Finset Î±} {t : Finset Î²} {F : Î±' â†’ Î² â†’ Î³} {g : Î± â†’ Î±'} {F' : Î² â†’ Î± â†’ Î´} {g' : Î´ â†’ Î³} (h_Left_anticomm : âˆ€ (A : Î±) (B : Î²), F (g A) B = g' (F' B A)) : Finset.imageâ‚‚ F (Finset.image g S) t = Finset.image g' (Finset.imageâ‚‚ F' t S)
{C : Type uâ‚} [CategoryTheory.Category C] {B Aâ‚ Aâ‚‚ : C} (F : Aâ‚ âŸ¶ B) (g : Aâ‚‚ âŸ¶ B) [CategoryTheory.Mono F] [CategoryTheory.Mono g] (i : Aâ‚ â‰… Aâ‚‚) (W : i.hom â‰« g = F) : CategoryTheory.Subobject.Mk F = CategoryTheory.Subobject.Mk g
{Î± : Type u_1} [Order.Frame Î±] {S : set Î±} : S.Pairwise_Disjoint Id â†’ CompleteLattice.set_Independent S
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {ps : set P} {n : â„•} [Finite_dimensional â„ v] (hD : Finite_dimensional.finrank â„ v = n) (hc : EuclideanGeometry.Cospherical ps) : âˆƒ (C : P), âˆ€ (sx : Affine.Simplex â„ P n), set.Range sx.points âŠ† ps â†’ sx.circumcenter = C
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [TopologicalSpace Î²] (F : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (S : set Î±) [t2_Space Î²] {C : set Î²} (hcâ‚ : IsCompact C) (hcâ‚‚ : âˆ€á¶  (t : Ï„) in F, set.maps_to (Ï• t) S C) {n : set Î²} (hnâ‚ : IsOpen n) (hnâ‚‚ : OmegaLimit F Ï• S âŠ† n) : âˆƒ (u : set Ï„) (h : u âˆˆ F), Closure (set.image2 Ï• u S) âŠ† n
{Î± : Type u_1} [generalized_boolean_Algebra Î±] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] {S : Finset Î±} {u v A : Î±} : A âˆˆ Uv.Compression u v S â†” A âˆˆ S âˆ§ Uv.compress u v A âˆˆ S âˆ¨ A âˆ‰ S âˆ§ âˆƒ (B : Î±) (h : B âˆˆ S), Uv.compress u v B = A
{ð•œ : Type u_1} {E : Type u_4} [semi_NormedGroup E] [nondiscrete_NormedField ð•œ] [NormedSpace ð•œ E] (h : âˆƒ (x : E), âˆ¥xâˆ¥ â‰  0) : âˆ¥Continuous_LinearMap.Id ð•œ Eâˆ¥ = 1
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : E â†’ â„} {A : E} {S : set E} (h : IsLocalMinOn F S A) {y : E} (hy : y âˆˆ Pos_TangentConeAt S A) (hy' : -y âˆˆ Pos_TangentConeAt S A) : â‡‘(fderiv_within â„ F S A) y = 0
{n : â„•} {F : Typevec (n + 1) â†’ Type u} [Mvfunctor F] [q : Mvqpf F] {Î± : Typevec n} {Î² : Type u_1} (q : Î² â†’ Prop) (u v : Î² â†’ Mvqpf.Cofix F Î±) (h : âˆ€ (x : Î²), q x â†’ (âˆƒ (A : (Mvqpf.P F).A) (F' : ((Mvqpf.P F).Drop.B A).arrow Î±) (Fâ‚€ Fâ‚ : (Mvqpf.P F).Last.B A â†’ Mvqpf.Cofix F Î±), (u x).dest = Mvqpf.Abs âŸ¨A, (Mvqpf.P F).Append_contents F' Fâ‚€âŸ© âˆ§ (v x).dest = Mvqpf.Abs âŸ¨A, (Mvqpf.P F).Append_contents F' Fâ‚âŸ© âˆ§ âˆ€ (i : (Mvqpf.P F).Last.B A), âˆƒ (x' : Î²), q x' âˆ§ Fâ‚€ i = u x' âˆ§ Fâ‚ i = v x')) (x : Î²) : q x â†’ u x = v x
{R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] (S : set m) (li : LinearIndependent R Coe) (t : Finset â†¥S) : LinearIndependent R Coe
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (Wâ‚ Wâ‚‚ : Î¹ â†’ k) (P : Î¹ â†’ P) : â‡‘(S.affine_combination P) Wâ‚ -áµ¥ â‡‘(S.affine_combination P) Wâ‚‚ = â‡‘(S.weighted_vsub P) (Wâ‚ - Wâ‚‚)
{C : Type u} [CategoryTheory.Category C] {P q R : C} (F : P âŸ¶ q) (g : q âŸ¶ R) [CategoryTheory.StrongEpi (F â‰« g)] : CategoryTheory.StrongEpi g
{P : â„‚ Ã— â„‚} (hp_fst : 0 < P.fst.re âˆ¨ P.fst.im â‰  0) : Continuous_at (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.Snd) P
 : Real.cos (Real.Pi / 3) = 1 / 2
(n : â„•) (P : Fin (n + 1)) : Finset.Univ = Finset.Cons P (Finset.Map P.Succ_above.to_Embedding Finset.Univ) _
{E : Type u_1} {F : Type u_2} [InnerProductSpace â„ E] [InnerProductSpace â„ F] {F : E â†’ F} {x : E} {F' : E â†’L[â„] F} (h : HasFderivAt F F' x) (h : ConformalAt F x) (u v : E) : InnerProductGeometry.angle (â‡‘F' u) (â‡‘F' v) = InnerProductGeometry.angle u v
{A : Type u_1} [CommRing A] [Algebra â„š A] (A B : A) : â‡‘(PowerSeries.rescale A) (PowerSeries.Exp A) * â‡‘(PowerSeries.rescale B) (PowerSeries.Exp A) = â‡‘(PowerSeries.rescale (A + B)) (PowerSeries.Exp A)
(A B : â„•) : A ^ 2 - B ^ 2 = (A + B) * (A - B)
{k : Type u_1} {l : Type u_2} {m : Type u_3} {n : Type u_4} {Î± : Type v} [Fintype n] [Fintype k] [DecidableEq n] [DecidableEq k] [DecidableEq m] [Semiring Î±] (A : m) (B : n) (C : k) (m : Matrix k l Î±) : (Pequiv.single A B).to_Matrix.Mul ((Pequiv.single B C).to_Matrix.Mul m) = (Pequiv.single A C).to_Matrix.Mul m
{Î± : Type u} {Î¹ : Type v} [MetricSpace Î±] [ProperSpace Î±] {C : Î¹ â†’ Î±} {S : set Î±} {r : Î¹ â†’ â„} (hr : âˆ€ (i : Î¹), 0 < r i) (hs : IsClosed S) (uf : âˆ€ (x : Î±), x âˆˆ S â†’ {i : Î¹ | x âˆˆ Metric.Ball (C i) (r i)}.Finite) (us : S âŠ† â‹ƒ (i : Î¹), Metric.Ball (C i) (r i)) : âˆƒ (r' : Î¹ â†’ â„), (S âŠ† â‹ƒ (i : Î¹), Metric.Ball (C i) (r' i)) âˆ§ âˆ€ (i : Î¹), r' i âˆˆ set.Ioo 0 (r i)
{G : Type u_1} [Group G] (Fâ‚ Fâ‚‚ : G â†’* Circle_deg1_Lift) (h : âˆ€ (g : G), (â‡‘Fâ‚ g).TranslationNumber = (â‡‘Fâ‚‚ g).TranslationNumber) : âˆƒ (F : Circle_deg1_Lift), âˆ€ (g : G), Function.Semiconj â‡‘F â‡‘(â‡‘Fâ‚ g) â‡‘(â‡‘Fâ‚‚ g)
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [AddCommMonoid m] [DecidableEq Î±] [DecidableEq Î²] (S : Finset (Î± Ã— Î²)) (F : Î± Ã— Î² â†’ m) : finsum (Î» (Ab : Î± Ã— Î²), finsum (Î» (h : Ab âˆˆ S), F Ab)) = finsum (Î» (A : Î±), finsum (Î» (B : Î²), finsum (Î» (h : B âˆˆ Finset.image Prod.Snd (Finset.Filter (Î» (Ab : Î± Ã— Î²), Ab.fst = A) S)), F (A, B))))
{G : Type u_1} [AddGroup G] {h : Add_Subgroup G} {N : Type u_3} [AddGroup N] (F : G â†’+ N) : Add_Subgroup.Map F h.Normalizer â‰¤ (Add_Subgroup.Map F h).Normalizer
{Î± : Type u_2} {Î² : Type u_3} {F : Î± â†’ Î²} (hF : Function.Injective F) : Filter.comap F Filter.cofinite = Filter.cofinite
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_3} [Fintype Î±] [Fintype Î²] [CommMonoid m] (e : Î± â†’ Î²) (hE : Function.Bijective e) (F : Î± â†’ m) (g : Î² â†’ m) (h : âˆ€ (x : Î±), F x = g (e x)) : Finset.Univ.Prod (Î» (x : Î±), F x) = Finset.Univ.Prod (Î» (x : Î²), g x)
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] (F : P1 â†’áµƒ[k] P2) : F.ToFun = â‡‘F
{Î± : Type u_1} [PseudoMetricSpace Î±] (r C : â„) (hr : r < 1) {F : â„• â†’ Î±} (hu : âˆ€ (n : â„•), HasDist.dist (F n) (F (n + 1)) â‰¤ C * r ^ n) {A : Î±} (ha : Filter.Tendsto F Filter.at_top (nhds A)) : HasDist.dist (F 0) A â‰¤ C / (1 - r)
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C â¥¤ D} (h : CategoryTheory.cover_Dense K G) [CategoryTheory.Full G] [CategoryTheory.Faithful G] : CategoryTheory.CompatiblePreserving K G
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {A B C : Matrix n n Î±} (h : B.Mul A = 1) (g : C.Mul A = 1) : B = C
{ð•œ : Type u} {G : Type wG} {G' : Type wG'} [nondiscrete_NormedField ð•œ] [NormedGroup G] [NormedSpace ð•œ G] [NormedGroup G'] [NormedSpace ð•œ G'] {k n : â„•} (F : MultilinearMap ð•œ (Î» (i : Fin n), G) G') (S : Finset (Fin n)) (hk : S.Card = k) (z : G) {C : â„} (h : âˆ€ (m : Fin n â†’ G), âˆ¥â‡‘F mâˆ¥ â‰¤ C * Finset.Univ.Prod (Î» (i : Fin n), âˆ¥m iâˆ¥)) (v : Fin k â†’ G) : âˆ¥â‡‘(F.restr S hk z) vâˆ¥ â‰¤ C * âˆ¥zâˆ¥ ^ (n - k) * Finset.Univ.Prod (Î» (i : Fin k), âˆ¥v iâˆ¥)
(k : Type uâ‚) {G : Type uâ‚‚} [Semiring k] [has_Add G] {A : Type uâ‚ƒ} [non_unital_non_assoc_Semiring A] [Distrib_MulAction k A] {Ï†â‚ Ï†â‚‚ : AddMonoid_Algebra k G â†’â‚™â‚[k] A} (h : âˆ€ (x : G), â‡‘Ï†â‚ (Finsupp.single x 1) = â‡‘Ï†â‚‚ (Finsupp.single x 1)) : Ï†â‚ = Ï†â‚‚
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {Î¹ : Type u_2} [DecidableEq Î¹] {E : Î¹ â†’ Type u_3} [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] {S : Î  (i : Î¹), set (E i)} {x : Î  (i : Î¹), E i} {i : Î¹} (hi : âˆ€ (j : Î¹), j â‰  i â†’ x j âˆˆ Closure (S j)) : set.maps_to â‡‘(LinearMap.single i) (TangentConeAt ð•œ (S i) (x i)) (TangentConeAt ð•œ (set.Univ.Pi S) x)
(R : Type u_1) (m : Type u_2) [Ring R] [TopologicalSpace R] [TopologicalSpace m] [AddCommGroup m] [has_Continuous_Add m] [module R m] [has_Continuous_Smul R m] [Nontrivial m] [(nhds_within 0 {0}á¶œ).Ne_IsBot] [NoZeroSmulDivisors R m] (x : m) : (nhds_within x {x}á¶œ).Ne_IsBot
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : (Î» (x : Î±), âˆ¥F' xâˆ¥) =o[l] g â†’ F' =o[l] g
{Î¹ : Type u_1} {ð•œ : Type u_2} [_R_or_C ð•œ] {E : Type u_3} [InnerProductSpace ð•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), InnerProductSpace ð•œ (G i)] {v : Î  (i : Î¹), G i â†’â‚—áµ¢[ð•œ] E} (hV : OrthogonalFamily ð•œ v) [âˆ€ (i : Î¹), CompleteSpace (G i)] (hV' : (â¨† (i : Î¹), (v i).to_LinearMap.Range).topological_Closure = âŠ¤) {i : Î¹} (x : G i) : â‡‘((hV.Linear_Isometry_Equiv hV').Symm) (Lp.single 2 i x) = â‡‘(v i) x
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} {v : Î¹ â†’ m} [Ring R] [AddCommGroup m] [module R m] {hli : LinearIndependent R v} {hsp : Submodule.Span R (set.Range v) = âŠ¤} {i j : Î¹} (h : j â‰  i) : â‡‘((Basis.Mk hli hsp).coord i) (v j) = 0
{x Y : top} {F g : C(â†¥x, â†¥Y)} (h : F.Homotopy g) (x : â†¥x) : âŸ¦h.Eval_at xâŸ§ = Continuous_Map.Homotopy.hcast _ â‰« (FundamentalGroupoid.FundamentalGroupoid_Functor.Map h.ulift_Map).Map (Continuous_Map.Homotopy.Prod_to_Prod_top_i Unit_Interval.uhpath01 (ðŸ™ x)) â‰« Continuous_Map.Homotopy.hcast _
{m : Type u_1} [AddZeroClass m] (S : Add_Submonoid m) : AddSubmonoid.Closure â†‘S = S
{Î¹ : Type W} [Fintype Î¹] (K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [module.Finite K L] [_alg_IsClosed E] (B : Î¹ â†’ L) [DecidableEq Î¹] [_IsSeparable K L] (e : Î¹ â‰ƒ (L â†’â‚[K] E)) : â‡‘(Algebra_Map K E) (Algebra.discr K B) = (Algebra.embeddings_Matrix_reindex K E B e).det ^ 2
(C : Type u) [ð’ž : CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasPullbacks C
{h : Type u_1} [TopologicalSpace h] [LocallyCompactSpace h] [t2_Space h] [TotallyDisconnectedSpace h] : TopologicalSpace._topological_Basis {S : set h | IsClopen S}
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [PseudoMetricSpace Î²] {F g : bounded_Continuous_Function Î± Î²} (x : Î±) : HasDist.dist (â‡‘F x) (â‡‘g x) â‰¤ HasDist.dist F g
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimits_of_size C] : CategoryTheory.Limits.HasLimits_of_size C
{m : Type u_1} {N : Type u_2} [AddZeroClass m] [AddZeroClass N] {C : Add_Con m} {F : N â†’+ m} : Add_Con.comap â‡‘F _ C = Add_Con.Ker (C.Mk'.Comp F)
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) : v.Int_Valuation_def 0 = 0
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S t : set Î±} (hst : Disjoint S t) (hs : S.Finite) (ht : t.Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S âˆª t), F i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ t), F i))
{Î± : Type u_1} {A B C : Î±} [LinearOrder Î±] [Add_comm_Semigroup Î±] [HasSub Î±] [HasOrderedSub Î±] : A < B - C â†” A + C < B
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle â„ P) : t.orthocenter âˆˆ affine_Span â„ (set.Range t.points)
(A : â„) : Cardinal.Mk â†¥(set.Iic A) = Cardinal.Continuum
{K : Type u_1} {n : â„•} {S : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] {gp_n gp_Succ_n : GeneralizedContinuedFraction.Pair K} (S_nth_Eq : S.nth n = Option.Some gp_n) (S_Succ_nth_Eq : S.nth (n + 1) = Option.Some gp_Succ_n) : (GeneralizedContinuedFraction.squash_Seq S n).nth n = Option.Some {A := gp_n.A, B := gp_n.B + gp_Succ_n.A / gp_Succ_n.B}
(t : Type u) [TopologicalSpace t] : CategoryTheory.Pretopology.to_grothendieck (TopologicalSpace.Opens t) (Opens.pretopology t) = Opens.GrothendieckTopology t
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] {S : set Î²} (hs : IsCompact S) (Ne_S : S.Nonempty) {F : Î² â†’ Î±} (hF : Continuous_on F S) : âˆƒ (x : Î²) (h : x âˆˆ S), âˆ€ (y : Î²), y âˆˆ S â†’ F x â‰¤ F y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] {x : C} (F : x âŸ¶ 0) : F = 0
{n : â„•} {l : Multiset â„•} (hl : l.Sum = n) {i : â„•} (hi : i â‰  0) : Multiset.count i (Nat.Partition.of_sums n l hl).Parts = Multiset.count i l
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) (h : âˆ€ (x : C), CategoryTheory.Presieve._sheaf J (CategoryTheory.yoneda.obj x)) : CategoryTheory.sheaf.Subcanonical J
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {Î¹2 : Type u_5} (F : Î¹2 â†ª Î¹) {P : Î¹ â†’ P} (ha : AffineIndependent k P) : AffineIndependent k (P âˆ˜ â‡‘F)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds B âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : deriv (Î» (u : â„), âˆ« (x : â„) in A..u, F x) B = C
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} {P : Type u_8} [has_Zero m] [AddCommMonoid N] [AddCommMonoid P] (h : N â‰ƒ+ P) (F : Î± â†’â‚€ m) (g : Î± â†’ m â†’ N) : â‡‘h (F.Sum g) = F.Sum (Î» (A : Î±) (B : m), â‡‘h (g A B))
{m : Type u_1} [has_Mul m] (C : Con m) (x : m) : â‡‘C x x
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [DecidableEq Î²] [Preorder Î²] {F : Î± â†’ Î²} (hâ‚ : StrictMono F) (A B : Finset Î±) : (Finset.image F A).to_colex < (Finset.image F B).to_colex â†” A.to_colex < B.to_colex
{ð•œ : Type u_3} {E : Type u_4} [NormedField ð•œ] [AddCommGroup E] [module ð•œ E] (P : Seminorm ð•œ E) {r : â„} {x : E} (hpr : â‡‘P x < r) : Absorbent ð•œ (P.ball x r)
{K : Type u_1} {v : Type u_2} [Field K] [AddCommGroup v] [module K v] (n : â„•) [Fact (Finite_dimensional.finrank K v = n + 1)] : Finite_dimensional K v
{Î± : Type u} [Preorder Î±] {A B : Î±} : A < B â†’ A â‰¤ B
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [CommMonoid Î²] [CommMonoid Î³] (g : Î² â‰ƒ* Î³) (F : Î± â†’ Î²) (S : Finset Î±) : â‡‘g (S.Prod (Î» (x : Î±), F x)) = S.Prod (Î» (x : Î±), â‡‘g (F x))
{l : Filter â„} {F F' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in Filter.at_IsBot, HasDerivAt F (F' x) x) (hgg' : âˆ€á¶  (x : â„) in Filter.at_IsBot, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  (x : â„) in Filter.at_IsBot, g' x â‰  0) (hfbot : Filter.Tendsto F Filter.at_IsBot (nhds 0)) (hgbot : Filter.Tendsto g Filter.at_IsBot (nhds 0)) (HDiv : Filter.Tendsto (Î» (x : â„), F' x / g' x) Filter.at_IsBot l) : Filter.Tendsto (Î» (x : â„), F x / g x) Filter.at_IsBot l
{m : Type u_4} [AddCommMonoid m] {Î¹ : Type u_1} [Subsingleton Î¹] {S : Finset Î¹} {F : Î¹ â†’ m} {B : m} (h : S.Sum (Î» (i : Î¹), F i) = B) (i : Î¹) (h : i âˆˆ S) : F i = B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] [CompleteSpace ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [Finite_dimensional ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {A : E} (hF : HasStrictFderivAt F F' A) (hF' : F'.Range = âŠ¤) : âˆ€á¶  (P : F Ã— â†¥(F'.Ker)) in nhds (F A, 0), F (HasStrictFderivAt.implicit_Function F F' hF hF' P.fst P.Snd) = P.fst
{x : â„} (h : 0 < x) : Real.sin x < x
{R : Type u_1} [Add_cancel_Monoid R] (g : R) : IsAddRegular g
{ð•œ : Type u_4} {E : Type u_5} [Linear_ordered_Field ð•œ] [TopologicalSpace E] [AddCommMonoid E] [module ð•œ E] {S : set E} (hsâ‚€ : IsClosed S) (hsâ‚ : strict_Convex ð•œ S) : Add_salem_spencer (Frontier S)
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) {x y : R} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] {S : set m} {x : m} (hx : x âˆˆ Submodule.Span R S) : âˆƒ (t : Finset m), â†‘t âŠ† S âˆ§ x âˆˆ Submodule.Span R â†‘t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P âŸ¶ q) [CategoryTheory.Epi F] : Function.Surjective â‡‘F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : S1 â‰¤ S2 â†” â†‘S1 âŠ† â†‘S2
{A : Type u_1} [AddMonoid A] {F g : â„¤ â†’+ A} (h1 : â‡‘F 1 = â‡‘g 1) : F = g
{Î± : Type u_1} [Linear_ordered_AddCommGroup Î±] {n : â„¤} (hn : n â‰  0) : Function.Injective (Î» (_x : Î±), n â€¢ _x)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} (ha : A â‰¤ 0) (hb : B < 0) : A + B < 0
{Î± : Type u} [PseudoMetricSpace Î±] {F : â„ â†’ Î±} {C : â„} (hp : Function.Periodic F C) (hc : C â‰  0) (hF : Continuous F) : Metric.Bounded (set.Range F)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x y + hb.oangle y z = hb.oangle x z
{R : Type u_1} {E : Type u_2} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (S : set E) : â‡‘(Convex_hull R) S = {x : E | âˆƒ (Î¹ : Type u') (t : Finset Î¹) (W : Î¹ â†’ R) (z : Î¹ â†’ E) (hwâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ W i) (hwâ‚ : t.Sum (Î» (i : Î¹), W i) = 1) (hz : âˆ€ (i : Î¹), i âˆˆ t â†’ z i âˆˆ S), t.Center_mass W z = x}
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A : Î±} : 1 < Aâ»Â¹ â†’ A < 1
{G : Type u_1} [Group G] {S : set G} {N : Subgroup G} [N.Normal] (h : S âŠ† â†‘N) : Subgroup.Normal_Closure S â‰¤ N
(n : â„•) (R : Type u_1) [Ring R] [Nontrivial R] : (Polynomial.cyclotomic n R).Nat_degree = n.Totient
(A : â„) : Cardinal.Mk â†¥(set.Iio A) = Cardinal.Continuum
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {S : set Î±} : Directed_on r S â†’ Directed r Coe
(R : Type u) [Ring R] [strong_RankCondition R] (m n : Type v) [Fintype m] [Fintype n] : Finite_dimensional.finrank R (Matrix m n R) = Fintype.Card m * Fintype.Card n
{Î± : Type u_1} (t : set (set Î±)) (Î´ : set Î± â†’ â„) (Ï„ : â„) (hÏ„ : 1 < Ï„) (Î´nonneg : âˆ€ (A : set Î±), A âˆˆ t â†’ 0 â‰¤ Î´ A) (R : â„) (Î´LE : âˆ€ (A : set Î±), A âˆˆ t â†’ Î´ A â‰¤ R) (hne : âˆ€ (A : set Î±), A âˆˆ t â†’ A.Nonempty) : âˆƒ (u : set (set Î±)) (h : u âŠ† t), u.Pairwise_Disjoint Id âˆ§ âˆ€ (A : set Î±), A âˆˆ t â†’ (âˆƒ (B : set Î±) (h : B âˆˆ u), (A âˆ© B).Nonempty âˆ§ Î´ A â‰¤ Ï„ * Î´ B)
{R : Type u} [CommSemiring R] (S : Multiset (Polynomial R)) (x : R) : Polynomial.Eval x S.Prod = (Multiset.Map (Polynomial.Eval x) S).Prod
{Î± : Type u_1} {Î² : Type u_2} {r : Setoid Î±} {F : Î± â†’ Î²} (h : r â‰¤ Setoid.Ker F) (g : Quotient r â†’ Î²) (Hg : F = g âˆ˜ Quotient.Mk) : Quotient.Lift F h = g
{m : Type u_2} {n : Type u_3} (R : Type u_11) [CommRing R] [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (e : m â‰ƒ n) (m : Matrix m m R) : (â‡‘(Matrix.reindex_Linear_Equiv R R e e) m).det = m.det
{ð•œ : Type u_1} {E : Type u_3} [OrderedSemiring ð•œ] [TopologicalSpace E] [AddCommMonoid E] [module ð•œ E] {S : set E} (h : IsOpen S) (hs : Convex ð•œ S) : strict_Convex ð•œ S
{R : Type u_1} [Mul_Zero_class R] : IsRightRegular 0 â†” Subsingleton R
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [NormedSpace ð•œ E'] {n : WithTop â„•} {F : E â†’ E'} : Cont_mdiff (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') n F â†’ ContDiff ð•œ n F
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] {F : Î² â†’ Î±} (hF : Continuous F) (xâ‚€ : Î²) (h : âˆ€á¶  (x : Î²) in Filter.cocompact Î², F xâ‚€ â‰¤ F x) : âˆƒ (x : Î²), âˆ€ (y : Î²), F x â‰¤ F y
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C â¥¤ D} (h : CategoryTheory.cover_Dense K G) [CategoryTheory.Full G] {â„± : Dáµ’áµ– â¥¤ A} {â„±' : CategoryTheory.sheaf K A} (Î± : â„± âŸ¶ â„±'.val) : h.sheaf_hom (CategoryTheory.whisker_Left G.Op Î±) = Î±
{xl xr : Type u_1} {xL : xl â†’ Pgame} {xR : xr â†’ Pgame} {yl yr : Type u_1} {yL : yl â†’ Pgame} {yR : yr â†’ Pgame} : Pgame.Mk xl xr xL xR â‰¤ Pgame.Mk yl yr yL yR â†” (âˆ€ (i : xl), (xL i).lf (Pgame.Mk yl yr yL yR)) âˆ§ âˆ€ (j : yr), (Pgame.Mk xl xr xL xR).lf (yR j)
{Î± : Type u_1} [CompleteLattice Î±] [_modular_Lattice Î±] [IsCompactlyGenerated Î±] (h : HasSup.Sup {A : Î± | IsAtom A} = âŠ¤) : IsComplemented Î±
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) : S.points_with_circumcenter Affine.Simplex.points_with_circumcenter_Index.circumcenter_Index = S.circumcenter
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) (m : Multiset R) : (âˆ€ (A : R), A âˆˆ m â†’ A âˆˆ S) â†’ m.Sum âˆˆ S
{P : â„•} (hp : Nat.Prime P) {n : â„¤} (hpn : _IsCoprime n â†‘P) : n ^ (P - 1) â‰¡ 1 [Zmod â†‘P]
{Î± : Type v} {S : Finset Î±} {m : Type u_1} [AddCommMonoid m] (F : Î± â†’ m) (P : m â†’ Prop) (P_Mul : âˆ€ (A B : m), P A â†’ P B â†’ P (A + B)) (P_One : P 0) (P_S : âˆ€ (x : Î±), x âˆˆ S â†’ P (F x)) : P (S.Sum (Î» (x : Î±), F x))
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : A < 0) (hb : B < 0) : A + B < 0
(k : Type u_1) {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype Î¹] (P : Î¹ â†’ P) {n : â„•} (hc : Fintype.Card Î¹ = n + 1) : AffineIndependent k P â†” n â‰¤ Finite_dimensional.finrank k â†¥(Vector_Span k (set.Range P))
(R : Type u_1) (A : Type u_2) (m : Type u_3) [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid m] [module R m] [module A m] [IsScalarTower R A m] (x : set m) (hsur : Function.Surjective â‡‘(Algebra_Map R A)) : Submodule.Span R x = Submodule.Restrict_scalars R (Submodule.Span A x)
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (A : Matrix n n R) : (-A).det = (-1) ^ Fintype.Card n â€¢ A.det
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : 0 â‰¤ InnerProductGeometry.angle x y
{Î± : Type u} [non_unital_non_assoc_Ring Î±] {A B C D e : Î±} : A * e + C = B * e + D â†’ (A - B) * e + C = D
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {n : â„•} (hs : UniqueDiffOn ð•œ S) : ContDiff_on ð•œ â†‘(n + 1) F S â†” DifferentiableOn ð•œ F S âˆ§ ContDiff_on ð•œ â†‘n (Î» (y : E), fderiv_within ð•œ F S y) S
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (t : Type u_4) [CommRing t] [Algebra R t] [Algebra S t] [IsScalarTower R S t] [IsLocalization m S] (P : Ideal S) [Hp : P.Prime] [IsLocalization.at_Prime t P] : IsLocalization.at_Prime t (Ideal.comap (Algebra_Map R S) P)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y z : v} (hxyne : x â‰  y) (hxzne : x â‰  z) (hxy : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) (hxz : âˆ¥xâˆ¥ = âˆ¥zâˆ¥) : o.oangle y z = 2 â€¢ o.oangle (y - x) (z - x)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {P : FormalMultilinearSeries ð•œ E F} {r : Ennreal} {F : E â†’ F} {x : E} [CompleteSpace F] (h : HasFpowerSeriesOnBall F P x r) : HasFpowerSeriesOnBall (fderiv ð•œ F) (â†‘(Continuous_multilinear_Curry_Fin1 ð•œ E F).Comp_FormalMultilinearSeries (P.change_origin_series 1)) x r
{Î± : Type u_1} [conditionally_complete_LinearOrder Î±] {S : set Î±} {B : Î±} (hs : S.Nonempty) (hb : B < HasSup.Sup S) : âˆƒ (A : Î±) (h : A âˆˆ S), B < A
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {C : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds B âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasStrictDerivAt (Î» (u : â„), âˆ« (x : â„) in A..u, F x) C B
(k : Type u_1) {v : Type u_2} (P : Type u_3) [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] : Collinear k âˆ…
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {x : E} {n : â„•} (hs : UniqueDiffOn ð•œ S) (hx : x âˆˆ S) : iterated_fderiv_within ð•œ (n + 1) F S x = (â‡‘(Continuous_multilinear_Curry_Right_Equiv' ð•œ n E F) âˆ˜ iterated_fderiv_within ð•œ n (Î» (y : E), fderiv_within ð•œ F S y) S) x
{x : Type u_2} {Y : Type u_3} [EmetricSpace x] [EmetricSpace Y] [TopologicalSpace.SecondCountableTopology x] {F : x â†’ Y} (hF : âˆ€ (x : x), âˆƒ (C : Nnreal) (S : set x) (h : S âˆˆ nhds x), LipschitzOnWith C F S) : dimH (set.Range F) â‰¤ dimH set.Univ
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {S : set E} : Unique_mdiff_on (model_with_corners_self ð•œ E) S â†’ UniqueDiffOn ð•œ S
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] {A B : Î±} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{R : Type u_1} [CommRing R] {xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2 + xâ‚… ^ 2 + xâ‚† ^ 2 + xâ‚‡ ^ 2 + xâ‚ˆ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2 + yâ‚… ^ 2 + yâ‚† ^ 2 + yâ‚‡ ^ 2 + yâ‚ˆ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„ - xâ‚… * yâ‚… - xâ‚† * yâ‚† - xâ‚‡ * yâ‚‡ - xâ‚ˆ * yâ‚ˆ) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ + xâ‚… * yâ‚† - xâ‚† * yâ‚… - xâ‚‡ * yâ‚ˆ + xâ‚ˆ * yâ‚‡) ^ 2 + (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚ + xâ‚… * yâ‚‡ + xâ‚† * yâ‚ˆ - xâ‚‡ * yâ‚… - xâ‚ˆ * yâ‚†) ^ 2 + (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚ + xâ‚… * yâ‚ˆ - xâ‚† * yâ‚‡ + xâ‚‡ * yâ‚† - xâ‚ˆ * yâ‚…) ^ 2 + (xâ‚ * yâ‚… - xâ‚‚ * yâ‚† - xâ‚ƒ * yâ‚‡ - xâ‚„ * yâ‚ˆ + xâ‚… * yâ‚ + xâ‚† * yâ‚‚ + xâ‚‡ * yâ‚ƒ + xâ‚ˆ * yâ‚„) ^ 2 + (xâ‚ * yâ‚† + xâ‚‚ * yâ‚… - xâ‚ƒ * yâ‚ˆ + xâ‚„ * yâ‚‡ - xâ‚… * yâ‚‚ + xâ‚† * yâ‚ - xâ‚‡ * yâ‚„ + xâ‚ˆ * yâ‚ƒ) ^ 2 + (xâ‚ * yâ‚‡ + xâ‚‚ * yâ‚ˆ + xâ‚ƒ * yâ‚… - xâ‚„ * yâ‚† - xâ‚… * yâ‚ƒ + xâ‚† * yâ‚„ + xâ‚‡ * yâ‚ - xâ‚ˆ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚ˆ - xâ‚‚ * yâ‚‡ + xâ‚ƒ * yâ‚† + xâ‚„ * yâ‚… - xâ‚… * yâ‚„ - xâ‚† * yâ‚ƒ + xâ‚‡ * yâ‚‚ + xâ‚ˆ * yâ‚) ^ 2
(R : Type u_2) (m : Type u_5) [Semiring R] [AddCommMonoid m] [module R m] [has_One m] [CharZero m] : CharZero R
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B : Î±} (ha : A < 0) (hb : B â‰¤ 0) : A + B < 0
{m : Type u_1} [AddMonoid m] (P : Add_Submonoid m) : P.fg â†” âˆƒ (S : set m), AddSubmonoid.Closure S = P âˆ§ S.Finite
{Î¹ : Type u_6} [DecidableEq Î¹] {Î¹â‚ : Type u_7} [Fintype Î¹] {R' : Type u_8} {Nâ‚ : Type u_9} {Nâ‚‚ : Type u_10} [CommSemiring R'] [AddCommMonoid Nâ‚] [AddCommMonoid Nâ‚‚] [module R' Nâ‚] [module R' Nâ‚‚] {F g : AlternatingMap R' Nâ‚ Nâ‚‚ Î¹} (e : Basis Î¹â‚ R' Nâ‚) (h : âˆ€ (v : Î¹ â†’ Î¹â‚), Function.Injective v â†’ â‡‘F (Î» (i : Î¹), â‡‘e (v i)) = â‡‘g (Î» (i : Î¹), â‡‘e (v i))) : F = g
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {A B : Î±} (P : Î± â†’ Prop) (l : List Î±) (h : List.chain r A l) (hb : (A :: l).Last _ = B) (carries : âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ P y â†’ P x) (final : P B) (i : Î±) (h : i âˆˆ A :: l) : P i
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : Continuous_MultilinearMap ð•œ E G) {m : â„} (hMp : 0 â‰¤ m) (hM : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘F mâˆ¥ â‰¤ m * Finset.Univ.Prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥Fâˆ¥ â‰¤ m
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasImages v] [CategoryTheory.Limits.has_Zero_object v] [CategoryTheory.Preadditive v] [CategoryTheory.Limits.HasKernels v] [CategoryTheory.Limits.HasCokernels v] {A B C : v} (F : A âŸ¶ B) (g : B âŸ¶ C) : CategoryTheory.Exact F g â†” âˆƒ (W : F â‰« g = 0), Nonempty (homology F g W â‰… 0)
{C : Type uâ‚} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasBinaryProduct A A] [CategoryTheory.IsIso (CategoryTheory.Limits.diag A)] : CategoryTheory.IsSubterminal A
{C : Type uâ‚} [CategoryTheory.Category C] {A : C} (hA : CategoryTheory.IsSubterminal A) [CategoryTheory.Limits.HasBinaryProduct A A] : CategoryTheory.IsIso (CategoryTheory.Limits.diag A)
(G : Type u) (F : Type v) [Group G] [Field F] [Fintype G] [Mul_Semiring_action G F] [HasFaithfulSmul G F] : Function.Bijective (Mul_Semiring_action.to_AlgHom â†¥(FixedPoints.Subfield G F) F)
(P : â„•) [Fact (Nat.Prime P)] (R : Type uâ‚) [CommSemiring R] [Char_P R P] [perfect_Ring R P] : PerfectionMap P (Ring_hom.Id R)
(R : Type u_1) {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [_fraction_Ring R K] [CharZero R] : CharZero K
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {K : Submodule ð•œ E} [CompleteSpace â†¥K] {u v z : E} (hv : v âˆˆ K) (hz : z âˆˆ Ká—®) (hu : u = v + z) : â†‘(â‡‘(Orthogonal_projection K) u) = v
{Î± : Type u} [PseudoMetricSpace Î±] {S t u : set Î±} (Fin : Emetric.Hausdorff_edist t u â‰  âŠ¤) : metric.Hausdorff_dist S u â‰¤ metric.Hausdorff_dist S t + metric.Hausdorff_dist t u
{Î± : Type u_1} [TopologicalSpace Î±] {S : set Î±} {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] {F g : Î± â†’ Î³} (hF : LowerSemicontinuousOn F S) (hg : LowerSemicontinuousOn g S) (hcont : âˆ€ (x : Î±), x âˆˆ S â†’ Continuous_at (Î» (P : Î³ Ã— Î³), P.fst + P.Snd) (F x, g x)) : LowerSemicontinuousOn (Î» (z : Î±), F z + g z) S
(S : â„‚) (h2 : S â‰  0) : (S + 1).gamma = S * S.gamma
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {F : m â†’* P} (x : m) : â‡‘(Con.Ker F) x = â‡‘F â»Â¹' {â‡‘F x}
(R : Type u) [Ring R] [strong_RankCondition R] {Î¹ : Type v} [Fintype Î¹] {m : Î¹ â†’ Type W} [Î  (i : Î¹), AddCommGroup (m i)] [Î  (i : Î¹), module R (m i)] [âˆ€ (i : Î¹), module.free R (m i)] [âˆ€ (i : Î¹), module.Finite R (m i)] : Finite_dimensional.finrank R (Î  (i : Î¹), m i) = Finset.Univ.Sum (Î» (i : Î¹), Finite_dimensional.finrank R (m i))
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommGroup E] [module ð•œ E] {S : set E} : Convex_Independent ð•œ (Î» (x : â†¥S), â†‘x) â†” âˆ€ (x : E), x âˆˆ S â†’ x âˆ‰ â‡‘(Convex_hull ð•œ) (S  {x})
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A : Î±} : 1 < Aâ»Â¹ â†” A < 1
{Î± : Type u} {Î² : Type v} [Preorder Î±] [SemilatticeSup Î²] {F g : Î± â†’ Î²} (hF : Antitone F) (hg : Antitone g) : Antitone (F âŠ” g)
{Î± : Type u_1} [UniformSpace Î±] {S : set Î±} {U : set (Î± Ã— Î±)} (hs : Dense S) (hU : U âˆˆ Uniformity Î±) : (â‹ƒ (x : Î±) (h : x âˆˆ S), UniformSpace.ball x U) = set.Univ
{R : Type u_1} {Râ‚‚ : Type u_2} {m : Type u_4} {mâ‚‚ : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Semiring Râ‚‚] [AddCommMonoid mâ‚‚] [module Râ‚‚ mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {S : set m} {F g : m â†’â‚›â‚—[Ïƒâ‚â‚‚] mâ‚‚} (hv : Submodule.Span R S = âŠ¤) (h : set.Eq_on â‡‘F â‡‘g S) : F = g
 : Irrational (Real.sqrt 2)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [Fintype Î¹] : Filter.Coprod (Î» (i : Î¹), Filter.cofinite) = Filter.cofinite
{R : Type u} {S : Type v} [Ring R] [Ring S] (F : R â†’+* S) (hF : Function.Surjective â‡‘F) : F.Range = âŠ¤
{Î± : Type u_1} {Î² : Type u_2} [Fintype Î±] [CompleteLattice Î²] (F : Î± â†’ Î²) : Finset.Univ.Inf F = infi F
{C : Type uâ‚} [CategoryTheory.Category C] {J : Type uâ‚‚} [CategoryTheory.Category J] [CategoryTheory.Limits.HasLimits_of_shape Jáµ’áµ– C] : CategoryTheory.Limits.HasColimits_of_shape J Cáµ’áµ–
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [TopologicalSpace Î±] [UniformSpace Î²] : Continuous_Map.IsCompact_IsOpen = Continuous_Map.IsCompact_convergence_topology
{Î± : Type u} [Preorder Î±] {F : â„¤ â†’ Î±} (hF : Monotone F) (n : â„¤) {x : Î±} (h1 : F n < x) (h2 : x < F (n + 1)) (A : â„¤) : F A â‰  x
{Î± : Type u_1} [TopologicalSpace Î±] {Î¹ : Type u_2} [Encodable Î¹] {S : Î¹ â†’ set Î±} (hs : âˆ€ (n : Î¹), MeasureTheory.analytic_set (S n)) : MeasureTheory.analytic_set (â‹ƒ (n : Î¹), S n)
{A : Type u_5} [CommRing A] {m : Type u_6} {n : Type u_7} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] {m : Matrix m n A} {m' : Matrix n m A} {N : Matrix n n A} (hMM' : m.Mul m' = 1) (hM'm : m'.Mul m = 1) : ((m.Mul N).Mul m').det = N.det
{o : Ordinal} {F : Î  (B : Ordinal), B < o â†’ Ordinal â†’ Ordinal} (h : âˆ€ (i : Ordinal) (hi : i < o), Ordinal._Normal (F i hi)) : set.Unbounded has_LT.LT (â‹‚ (i : Ordinal) (hi : i < o), Function.FixedPoints (F i hi))
{R : Type u_1} {m : Type u_2} [CommRing R] [AddCommGroup m] [module R m] (q : QuadraticForm R m) (n : Zmod 2) {P : Î  (x : clifford_Algebra q), x âˆˆ clifford_Algebra.Even_Odd q n â†’ Prop} (hr : âˆ€ (v : clifford_Algebra q) (h : v âˆˆ (clifford_Algebra.Î¹ q).Range ^ n.val), P v _) (HAdd : âˆ€ {x y : clifford_Algebra q} {hx : x âˆˆ clifford_Algebra.Even_Odd q n} {hy : y âˆˆ clifford_Algebra.Even_Odd q n}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_Mul : âˆ€ (mâ‚ mâ‚‚ : m) {x : clifford_Algebra q} {hx : x âˆˆ clifford_Algebra.Even_Odd q n}, P x hx â†’ P (â‡‘(clifford_Algebra.Î¹ q) mâ‚ * â‡‘(clifford_Algebra.Î¹ q) mâ‚‚ * x) _) (x : clifford_Algebra q) (hx : x âˆˆ clifford_Algebra.Even_Odd q n) : P x hx
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C â¥¤ D} (h : CategoryTheory.cover_Dense K G) [CategoryTheory.Full G] {â„± â„±' : CategoryTheory.sheaf K A} (Î± : â„± âŸ¶ â„±') (i : CategoryTheory.IsIso (CategoryTheory.whisker_Left G.Op Î±.val)) : CategoryTheory.IsIso Î±
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] [IsNoetherian R m] {S : set m} (hi : LinearIndependent R Coe) : S.Finite
{Î± : Type u} {F : Ultrafilter Î±} {P : Î± â†’ Prop} : (âˆƒá¶  (x : Î±) in â†‘F, P x) â†’ (âˆ€á¶  (x : Î±) in â†‘F, P x)
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {v : Type uâ‚ƒ} {P : Type uâ‚„} [AddCommGroup v] [AddTorsor v P] [CommRing k] [module k v] [DecidableEq Î¹] [Fintype Î¹] (B Bâ‚‚ : affine_Basis Î¹ k P) (x : P) : Matrix.vec_Mul (â‡‘(B.coords) x) (B.to_Matrix Bâ‚‚.points)â»Â¹ = â‡‘(Bâ‚‚.coords) x
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} [decÎ¹ : DecidableEq Î¹] {v : Î¹ â†’ E} : Orthonormal ð•œ v â†” âˆ€ (i j : Î¹), HasInner.inner (v i) (v j) = Ite (i = j) 1 0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] (F : E â†’L[ð•œ] F â†’L[ð•œ] G) : Continuous (Function.uncurry (Î» (x : E) (y : F), â‡‘(â‡‘F x) y))
{q : â„š} (q_Pos : 0 < q) : (GeneralizedContinuedFraction.Int_fract_pair.of qâ»Â¹).fr.Num < q.Num
{Î± : Type u_1} [has_LT Î±] {A B : Î±} (h : A < B) : Â¬A â‹– B â†’ (âˆƒ (C : Î±), A < C âˆ§ C < B)
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B : Î±} (ha : A < 0) (hb : B < 0) : 1 / A < 1 / B â†” B < A
{R : Type u_1} [NormedRing R] (k : â„•) {r : â„} (hr : 1 < r) : (Î» (n : â„•), â†‘n ^ k) =o[Filter.at_top] Î» (n : â„•), r ^ n
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S t : set P) : affine_Span k (S âˆª t) = affine_Span k S âŠ” affine_Span k t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] {P q : C} (F : P âŸ¶ q) : CategoryTheory.Abelian.coimage.Ï€ F â‰« CategoryTheory.Abelian.FactorThruCoimage F = F
{Î± : Type u} [EmetricSpace Î±] [CompleteSpace Î±] : IsClosed (set.Range TopologicalSpace.Nonempty_Compacts.to_Closeds)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) (Î¸ : Real.Angle) : x = â‡‘(o.rotation Î¸) x â†” x = 0 âˆ¨ Î¸ = 0
{Î¹ : Type W} [Fintype Î¹] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [module.Finite K L] {R : Type z} [CommRing R] [Algebra R K] [Algebra R L] [IsScalarTower R K L] {B : Î¹ â†’ L} (h : âˆ€ (i : Î¹), IsIntegral R (B i)) : IsIntegral R (Algebra.discr K B)
{ð•œ : Type u_3} [_R_or_C ð•œ] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {h : Type u_5} [NormedGroup h] [NormedSpace ð•œ h] {F : G â†’ h} {F' : G â†’ (G â†’L[ð•œ] h)} {x : G} (hder : âˆ€á¶  (y : G) in nhds x, HasFderivAt F (F' y) y) (hcont : Continuous_at F' x) : HasStrictFderivAt F (F' x) x
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) [Nontrivial Î²] : Nontrivial Î±
{ð•œ : Type u_3} {E : Type u_4} [semi_NormedRing ð•œ] [AddCommGroup E] [module ð•œ E] (P : Seminorm ð•œ E) (x y : E) : â‡‘P x â‰¤ â‡‘P y + â‡‘P (x - y)
{Î² Î± : Type u} (F : Î² â†’ Î±) (W : Cardinal.Mk Î± < Cardinal.Mk Î²) (W' : Cardinal.aleph0 â‰¤ Cardinal.Mk Î±) : âˆƒ (A : Î±), Cardinal.Mk Î± < Cardinal.Mk â†¥(F â»Â¹' {A})
{Î± : sort u_1} (hH : Î±) {Î² : Prop} (x : Tactic.CalculatedProp Î² hH . "derive_elementwise_proof") : Î²
{R : Type u} [Semiring R] {P : Polynomial R} {n : â„•} : P.degree â‰¤ â†‘n â†’ P.Nat_degree â‰¤ n
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [OrderedSemiring ð•œ] [AddCommGroup E] [module ð•œ E] {P : Î¹ â†’ E} (hc : Convex_Independent ð•œ P) : Function.Injective P
{Î± : Type u} [CompleteLattice Î±] {J : Type u} [CategoryTheory.SmallCategory J] (F : J â¥¤ Î±) : CategoryTheory.Limits.Colimit F = supr F.obj
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F g : Î± â†’ m} {S : set Î±} (hs : S.Finite) : finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i + g i)) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)) + finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), g i))
{E : Type u} [NormedGroup E] [NormedSpace â„ E] {F : â„ â†’ E} {F' : E} {S : set â„} {x r : â„} (hF : HasDerivWithinAt F F' S x) (hr : âˆ¥F'âˆ¥ < r) : âˆ€á¶  (z : â„) in nhds_within x S, âˆ¥z - xâˆ¥â»Â¹ * (âˆ¥F zâˆ¥ - âˆ¥F xâˆ¥) < r
{m : Type u} {Î± : Type v} [CommRing Î±] [Fintype m] [DecidableEq m] (u v : m â†’ Î±) : (1 + (Matrix.col u).Mul (Matrix.row v)).det = 1 + Matrix.dot_Product v u
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Pos_Mul_StrictMono Î±] (ha : A â‰¤ 1) (hb : B < 1) (A0 : 0 < A) : A * B < 1
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) : 0 â‰¤ S.circumradius
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [CommMonoid Î²] [CommMonoid Î³] (g : Î² â†’* Î³) (F : Î± â†’ Î²) (S : Finset Î±) : â‡‘g (S.Prod (Î» (x : Î±), F x)) = S.Prod (Î» (x : Î±), â‡‘g (F x))
{C : Type u} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (F : C â¥¤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryProduct A B] [CategoryTheory.Limits.HasBinaryProduct A' B'] [CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')] (F : A âŸ¶ A') (g : B âŸ¶ B') [CategoryTheory.IsIso (CategoryTheory.Limits.Prod_comparison F A B)] [CategoryTheory.IsIso (CategoryTheory.Limits.Prod_comparison F A' B')] : CategoryTheory.Inv (CategoryTheory.Limits.Prod_comparison F A B) â‰« F.Map (CategoryTheory.Limits.Prod.Map F g) = CategoryTheory.Limits.Prod.Map (F.Map F) (F.Map g) â‰« CategoryTheory.Inv (CategoryTheory.Limits.Prod_comparison F A' B')
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S : set P} (h : affine_Span k S = âŠ¤) : Vector_Span k S = âŠ¤
{Î± : Type u_1} [PseudoEmetricSpace Î±] {Î´Seq : â„• â†’ â„} (Î´Seq_Pos : âˆ€ (n : â„•), 0 < Î´Seq n) (Î´Seq_lim : Filter.Tendsto Î´Seq Filter.at_top (nhds 0)) (E : set Î±) : Filter.Tendsto (Î» (n : â„•), â‡‘(thickened_indicator _ E)) Filter.at_top (nhds ((Closure E).indicator (Î» (x : Î±), 1)))
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle â„ P) (i : Fin 3) : affine_Span â„ {t.orthocenter, t.points i} â‰¤ Affine.Simplex.altitude t i
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {E' : Type u_4} [NormedGroup E'] [NormedSpace ð•œ E'] {F' : Type u_5} [NormedGroup F'] [NormedSpace ð•œ F'] {S : set E} {t : set E'} {F : E â†’ F} {g : E' â†’ F'} (hF : ContDiff_on ð•œ n F S) (hg : ContDiff_on ð•œ n g t) : ContDiff_on ð•œ n (Prod.Map F g) (S Ã—Ë¢ t)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : F â†’ G} (hF : ContDiff ð•œ n F) : ContDiff ð•œ n (Î» (x : E Ã— F), F x.Snd)
{Î± : Type u_1} [DecidableEq Î±] {S : Finset Î±} : S.Nonempty â†’ S.Sym2.Nonempty
{m : Type u_4} [TopologicalSpace m] [Monoid m] [has_Continuous_Mul m] {U : set m} (hU : U âˆˆ nhds 1) : âˆƒ (v : set m), IsOpen v âˆ§ 1 âˆˆ v âˆ§ v * v âŠ† U
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField ð•œ] [NormedGroup E] [NormedSpace ð•œ E] [NormedGroup F] [NormedSpace ð•œ F] {P : FormalMultilinearSeries ð•œ E F} {x : E} (h : HasFpowerSeriesAt 0 P x) (n : â„•) (y : E) : â‡‘(P n) (Î» (i : Fin n), y) = 0
{Î± : Type u} {Î² : Type v} [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {K : Nnreal} {F : Î± â†’ Î²} : LipschitzWith K F â†’ âˆ€ (x y : Î±), HasDist.dist (F x) (F y) â‰¤ â†‘K * HasDist.dist x y
(R : Type u) [Ring R] [strong_RankCondition R] {Î¹ : Type v} [Fintype Î¹] (m : Î¹ â†’ Type W) [Î  (i : Î¹), AddCommGroup (m i)] [Î  (i : Î¹), module R (m i)] [âˆ€ (i : Î¹), module.free R (m i)] [âˆ€ (i : Î¹), module.Finite R (m i)] : Finite_dimensional.finrank R (direct_Sum Î¹ (Î» (i : Î¹), m i)) = Finset.Univ.Sum (Î» (i : Î¹), Finite_dimensional.finrank R (m i))
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommMonoid Î²] [module ð•œ E] [HasScalar ð•œ Î²] {S : set E} {F : E â†’ Î²} (hF : ConcaveOn ð•œ S F) (C : E) : ConcaveOn ð•œ ((Î» (z : E), C + z) â»Â¹' S) (F âˆ˜ Î» (z : E), z + C)
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMinOrder Î±] [DenselyOrdered Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds_within A (set.Iic A) â†” âˆƒ (l : Î±), l < A âˆ§ set.icc l A âŠ† S
{P A B : â„•} (hab : A.IsCoprime B) (hpb : P âˆˆ B.Factors) : â‡‘((A * B).factorization) P = â‡‘(B.factorization) P
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] {x : B} (hx : IsIntegral A x) : 0 < (minpoly A x).degree
{g : â„‚ â†’L[â„] â„‚} : IsConformalMap g â†” ((âˆƒ (Map : â„‚ â†’L[â„‚] â„‚), Continuous_Linear_Map.Restrict_scalars â„ Map = g) âˆ¨ âˆƒ (Map : â„‚ â†’L[â„‚] â„‚), Continuous_Linear_Map.Restrict_scalars â„ Map = g.Comp â†‘Complex.Conj_cle) âˆ§ g â‰  0
{Î± : Type u_1} [has_LE Î±] {A : Î±} : IsMin A â†’ IsMax (â‡‘order_dual.to_dual A)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle (-x) y + hb.oangle (-y) z + hb.oangle (-z) x = â†‘Real.Pi
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (hx : x â‰  0) (hy : y â‰  0) : Real.sin (InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = 0
(m n : â„•) : Nat.fib (m.Gcd n) = (Nat.fib m).Gcd (Nat.fib n)
{P : â„•+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero â†‘â†‘P] [hpri : Fact (Nat.Prime â†‘P)] [hcyc : IsCyclotomicExtension {P} K L] (hirr : Irreducible (Polynomial.cyclotomic â†‘P K)) (h : P â‰  2) : â‡‘(Algebra.norm K) (IsCyclotomicExtension.zeta P K L - 1) = â†‘P
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : Î± â†’ E} {g' : Î± â†’ F'} {l : Filter Î±} : F =o[l] g' â†’ (F =o[l] Î» (x : Î±), -g' x)
(x : â„) : Real.sqrt (1 + Real.sinh x ^ 2) = Real.cosh x
{Î± : Type u_1} [CompleteLattice Î±] {A : Î±} {S : set Î±} : (â¨† (B : Î±) (h : B âˆˆ S), A âŠ“ B) â‰¤ A âŠ“ HasSup.Sup S
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (x : m â§¸ S) : 0 â‰¤ âˆ¥xâˆ¥
{Î± : Type u} {F g : Î± â†’ Î±} (h : Function.Commute F g) : set.bij_on g (Function.FixedPoints (F âˆ˜ g)) (Function.FixedPoints (F âˆ˜ g))
{i : â„•} {F g : â„• â†’ â„} (h0 : âˆ€ (B : â„•), 0 â‰¤ F B) (h : âˆ€ (B : â„•), F B â‰¤ g B) (hi : F i < g i) (hg : Summable g) : âˆ‘' (n : â„•), F n < âˆ‘' (n : â„•), g n
{Î± : Type u} [TopologicalSpace Î±] {S U Z : set Î±} (hZ : IsPreirreducible Z) (hU : U.Nonempty) (hU' : IsOpen U) (hâ‚ : U âŠ† S) (hâ‚‚ : S âŠ† Z) : _Irreducible S
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] [t1_Space Î²] {F : Î± â†’ Î²} {A : Î±} {B : Î²} (h : Filter.Tendsto F (nhds A) (nhds B)) : Continuous_at F A
{n : Type u} [DecidableEq n] [Fintype n] {Î± : Type v} [CommRing Î±] (A : Matrix n n Î±) {Î² : Type u_1} (S : Finset Î²) (F : Î² â†’ n â†’ Î±) : S.Sum (Î» (x : Î²), â‡‘(A.cramer) (F x)) = â‡‘(A.cramer) (S.Sum (Î» (x : Î²), F x))
{m : Type u_3} {N : Type u_4} [has_Add m] [has_Add N] (F : Add_hom m N) {x y : m} (h : x = y) : â‡‘F x = â‡‘F y
(P : â„•) [Fact (Nat.Prime P)] (hp : P â‰  2) : Zmod.legendre_Sym P (-1) = â‡‘Zmod.Ï‡â‚„ â†‘P
{J : Type uâ‚} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] (P : set J) {jâ‚€ : J} (h0 : jâ‚€ âˆˆ P) (h1 : âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ (jâ‚ âˆˆ P â†” jâ‚‚ âˆˆ P)) (j : J) : j âˆˆ P
{Î± : Type u} [MulOneClass Î±] [has_Distrib_Neg Î±] (A : Î±) : A * -1 = -A
{G : Type u_1} [Group G] [TopologicalSpace G] [topological_Group G] [t2_Space G] {Kâ‚€ : TopologicalSpace.PositiveCompacts G} (g : G) (K : TopologicalSpace.Compacts G) : â‡‘(MeasureTheory.Measure.haar.haar_content Kâ‚€) (TopologicalSpace.Compacts.Map (Î» (B : G), g * B) _ K) = â‡‘(MeasureTheory.Measure.haar.haar_content Kâ‚€) K
{Î± : Type u} [OrderedSemiring Î±] [Nontrivial Î±] : 0 < 3
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} {F' : â„ â†’ E} {C : â„} (hF : âˆ€ (x : â„), x âˆˆ set.icc A B â†’ HasDerivWithinAt F (F' x) (set.icc A B) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico A B â†’ âˆ¥F' xâˆ¥ â‰¤ C) (x : â„) (h : x âˆˆ set.icc A B) : âˆ¥F x - F Aâˆ¥ â‰¤ C * (x - A)
{Î¹ : Type u_1} {Î± : Type u_2} {S : Î¹ â†’ set Î±} (hs : IndexedPartition S) (x : hs.Quotient) : hs.Index (Quotient.out' x) = hs.Index (â‡‘(hs.out) x)
{n : â„•} {iâ‚ iâ‚‚ : Fin (n + 3)} (h : iâ‚ â‰  iâ‚‚) : Affine.Simplex.monge_point_vsub_face_centroid_weights_with_circumcenter iâ‚ iâ‚‚ = Affine.Simplex.monge_point_weights_with_circumcenter n - Affine.Simplex.centroid_weights_with_circumcenter {iâ‚, iâ‚‚}á¶œ
{Î± : Type u_1} [LinearOrder Î±] (A : Î±) : {A}.max' _ = A
{F : â„• â†’. â„•} : Nat.partrec F â†” âˆƒ (C : Nat.Partrec.Code), C.Eval = F
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {Aâ‚ Aâ‚‚ Aâ‚ƒ : Î±} {Bâ‚ Bâ‚‚ Bâ‚ƒ : Î²} (qâ‚ : Path.Homotopic.Quotient Aâ‚ Aâ‚‚) (qâ‚‚ : Path.Homotopic.Quotient Bâ‚ Bâ‚‚) (râ‚ : Path.Homotopic.Quotient Aâ‚‚ Aâ‚ƒ) (râ‚‚ : Path.Homotopic.Quotient Bâ‚‚ Bâ‚ƒ) : (Path.Homotopic.Prod qâ‚ qâ‚‚).Comp (Path.Homotopic.Prod râ‚ râ‚‚) = Path.Homotopic.Prod (qâ‚.Comp râ‚) (qâ‚‚.Comp râ‚‚)
{C : Type uâ‚} [CategoryTheory.Category C] {x Y Z : C} {C : CategoryTheory.Limits.BinaryFan x Y} (h : CategoryTheory.Limits.IsLimit C) (t : CategoryTheory.Limits.IsTerminal Z) : CategoryTheory.IsPullback C.fst C.Snd (t.from ((CategoryTheory.Limits.pair x Y).obj {as := CategoryTheory.Limits.WalkingPair.Left})) (t.from ((CategoryTheory.Limits.pair x Y).obj {as := CategoryTheory.Limits.WalkingPair.Right}))
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] [LocallyCompactSpace Î±] : Continuous (Î» (P : C(Î±, Î²) Ã— Î±), â‡‘(P.fst) P.Snd)
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (hx : x â‰  0) (hy : y â‰  0) : Real.cos (InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = -Real.cos (InnerProductGeometry.angle x y)
{R : Type u_1} {A : R} [Add_Semigroup R] (B : R) (ha : _Add_Left_regular A) : _Add_Left_regular (A + B) â†” _Add_Left_regular B
{Î± : Type u} [PseudoMetricSpace Î±] (B : â„• â†’ â„) (hB : âˆ€ (n : â„•), 0 < B n) (h : âˆ€ (u : â„• â†’ Î±), (âˆ€ (N n m : â„•), N â‰¤ n â†’ N â‰¤ m â†’ HasDist.dist (u n) (u m) < B N) â†’ (âˆƒ (x : Î±), Filter.Tendsto u Filter.at_top (nhds x))) : CompleteSpace Î±
{E : Type u_2} [semi_NormedGroup E] [NormedSpace â„ E] {S : set E} {x : E} (hx : x âˆˆ â‡‘(Convex_hull â„) S) (y : E) : âˆƒ (x' : E) (h : x' âˆˆ S), HasDist.dist x y â‰¤ HasDist.dist x' y
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F g : Continuous_MultilinearMap ð•œ E G) : âˆ¥F + gâˆ¥ â‰¤ âˆ¥Fâˆ¥ + âˆ¥gâˆ¥
{G : Type W} [TopologicalSpace G] [has_Inv G] [has_Mul G] [has_Continuous_Mul G] (g : G) : Continuous (Î» (h : G), g * h * gâ»Â¹)
{Î± : Type u_1} [MetricSpace Î±] (t : set (set Î±)) (R : â„) (ht : âˆ€ (S : set Î±), S âˆˆ t â†’ (âˆƒ (x : Î±) (r : â„), S = metric.IsClosed_ball x r âˆ§ r â‰¤ R)) : âˆƒ (u : set (set Î±)) (h : u âŠ† t), u.Pairwise_Disjoint Id âˆ§ âˆ€ (A : set Î±), A âˆˆ t â†’ (âˆƒ (x : Î±) (r : â„), metric.IsClosed_ball x r âˆˆ u âˆ§ A âŠ† metric.IsClosed_ball x (5 * r))
{ð•œ : Type u_1} [Linear_ordered_Field ð•œ] {x y : ð•œ} (h : x < y) {z : ð•œ} : z âˆˆ set.Ico x y â†” âˆƒ (A B : ð•œ), 0 < A âˆ§ 0 â‰¤ B âˆ§ A + B = 1 âˆ§ A * x + B * y = z
{R : Type uâ‚} [Monoid R] [has_Distrib_Neg R] (A : R) : (-A) ^ 2 = A ^ 2
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] [no_Zero_divisors R] [Nontrivial R] : NoZeroSmulDivisors R m â†” Submodule.torsion R m = âŠ¥
{E : â„• â†’ Type u_1} [Î  (n : â„•), TopologicalSpace (E n)] [âˆ€ (n : â„•), DiscreteTopology (E n)] {x y : Î  (n : â„•), E n} {S : set (Î  (n : â„•), E n)} (hs : IsClosed S) (hne : S.Nonempty) (h : Pi_Nat.longest_prefix x S < Pi_Nat.first_Diff x y) (xs : x âˆ‰ S) (ys : y âˆ‰ S) : Pi_Nat.Cylinder x (Pi_Nat.longest_prefix x S) = Pi_Nat.Cylinder y (Pi_Nat.longest_prefix y S)
{Î± : Type u_1} {Î² : Type u_2} {e e' : local_Equiv Î± Î²} (hE : e â‰ˆ e') (S : set Î±) : e.restr S â‰ˆ e'.restr S
{R : Type x} [CommRing R] (A B : R) : A * A - B * B = (A + B) * (A - B)
{mâ‚€ : Type u_1} {mâ‚€' : Type u_3} [has_Mul mâ‚€] [has_Zero mâ‚€] [has_Mul mâ‚€'] [has_Zero mâ‚€'] [no_Zero_divisors mâ‚€'] (F : mâ‚€ â†’ mâ‚€') (hF : Function.Injective F) (Zero : F 0 = 0) (Mul : âˆ€ (x y : mâ‚€), F (x * y) = F x * F y) : no_Zero_divisors mâ‚€
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] [LocallyCompactSpace Î±] [LocallyCompactSpace Î²] : Continuous Continuous_Map.uncurry
{Î± : Type u_1} {n : Type u_4} [AddGroup n] {v : n â†’ Î±} (h : (Matrix.circulant v).IsSymm) (i : n) : v (-i) = v i
{Î± : Type u} {A : set Î±} (h : A.Finite) : {B : set Î± | B âŠ† A}.Finite
{Î± : Type u_1} {Î¹ : sort u_2} [Nonempty Î¹] (m : Î¹ â†’ MeasureTheory.OuterMeasure Î±) (S : set Î±) : (â‡‘â¨… (i : Î¹), m i) S = â¨… (t : â„• â†’ set Î±) (h2 : S âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹), â‡‘(m i) (t n)
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] (C : Add_Con m) (F : m â†’+ P) (h : C â‰¤ Add_Con.Ker F) (h : Function.Injective â‡‘(C.Lift F h)) : Add_Con.Ker F = C
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] {A B C : Matrix n n Î±} (h : A.Mul B = 1) (g : A.Mul C = 1) : B = C
{Î± : Type u} (F : Filter Î±) [h : F.Ne_IsBot] : âˆƒ (u : Ultrafilter Î±), â†‘u â‰¤ F
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {x y : v} (h : hb.oangle x y = 0) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{G : Type u_1} [TopologicalSpace G] [Group G] [topological_Group G] (N : Subgroup G) [N.Normal] : N.topological_Closure.Normal
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} {v : Î¹ â†’ m} [Ring R] [AddCommGroup m] [module R m] : LinearIndependent R v â†’ Function.Injective â‡‘(Finsupp.Total Î¹ m R v)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h : S1 < S2) : âˆƒ (P : P) (h : P âˆˆ S2), P âˆ‰ S1
{Î± : Type u} {Î² : Type v} [Preorder Î±] [Preorder Î²] {F : Î± â†’ Î²} {S : set Î±} : Monotone_on F S â†’ Antitone_on (â‡‘order_dual.to_dual âˆ˜ F) S
(K : Type u) [DivisionRing K] {n : â„•} : Finite_dimensional.finrank K (Fin n â†’ K) = n
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P : P) : P -áµ¥ P = 0
{Î± : Type u_1} [has_Mul Î±] [Preorder Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LT.LT] {A B C D : Î±} (hâ‚ : A < B) (hâ‚‚ : C < D) : A * C < B * D
{Î± : Type u} [PseudoMetricSpace Î±] [Preorder Î±] [IsCompact_icc_Space Î±] {S : set Î±} (hâ‚ : BddAbove S) (hâ‚‚ : BddBelow S) : Metric.Bounded S
{m : Type u_1} [AddMonoid m] {x : m} (m : â„•) {n : â„•} (h : n â€¢ x = 0) : m â€¢ x = (m % n) â€¢ x
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} : HasInner.inner (x - y) (x - y) = HasInner.inner x x - 2 * HasInner.inner x y + HasInner.inner y y
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] [CompleteSpace F] [CompleteSpace E] (g : E â†’â‚—[ð•œ] F) (hg : âˆ€ (u : â„• â†’ E) (x : E) (y : F), Filter.Tendsto u Filter.at_top (nhds x) â†’ Filter.Tendsto (â‡‘g âˆ˜ u) Filter.at_top (nhds y) â†’ y = â‡‘g x) : Continuous â‡‘g
{C : Type u} [CategoryTheory.Category C] {x : C} (P : Cáµ’áµ– â¥¤ Type v) (R S : CategoryTheory.Sieve x) (hR : CategoryTheory.Presieve.IsSheafFor P â‡‘R) (hR' : âˆ€ â¦ƒY : Câ¦„ â¦ƒF : Y âŸ¶ xâ¦„, â‡‘S F â†’ CategoryTheory.Presieve.IsSeparated_for P â‡‘(CategoryTheory.Sieve.pullback F R)) (hS : âˆ€ â¦ƒY : Câ¦„ â¦ƒF : Y âŸ¶ xâ¦„, â‡‘R F â†’ CategoryTheory.Presieve.IsSheafFor P â‡‘(CategoryTheory.Sieve.pullback F S)) : CategoryTheory.Presieve.IsSheafFor P â‡‘S
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {C : â„} {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : Asymptotics._O_with C l F g â†” âˆ€á¶  (x : Î±) in l, âˆ¥F xâˆ¥ â‰¤ C * âˆ¥g xâˆ¥
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] (F : MultilinearMap R mâ‚ mâ‚‚) {Î± : Î¹ â†’ Type u_1} (g : Î  (i : Î¹), Î± i â†’ mâ‚ i) (A : Î  (i : Î¹), Finset (Î± i)) [Fintype Î¹] {n : â„•} (h : Finset.Univ.Sum (Î» (i : Î¹), (A i).Card) = n) : â‡‘F (Î» (i : Î¹), (A i).Sum (Î» (j : Î± i), g i j)) = (Fintype.Pi_Finset A).Sum (Î» (r : Î  (A : Î¹), Î± A), â‡‘F (Î» (i : Î¹), g i (r i)))
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} {C : CategoryTheory.Limits.Cofork F g} (h : CategoryTheory.Limits.IsColimit C) [CategoryTheory.Mono C.Ï€] : CategoryTheory.IsIso C.Ï€
{m : Type u_3} {N : Type u_4} [AddMonoid m] [AddMonoid N] (F : m â†’+ N) (l : List m) : â‡‘F l.Sum = (List.Map â‡‘F l).Sum
{Î± : Type u_1} (P : Î± â†’ Prop) (r : Î± â†’ Î± â†’ Prop) [IsSymm Î± r] (h : âˆ€ (S : Finset Î±), (âˆ€ (x : Î±), x âˆˆ S â†’ P x) â†’ (âˆƒ (y : Î±), P y âˆ§ âˆ€ (x : Î±), x âˆˆ S â†’ r x y)) : âˆƒ (F : â„• â†’ Î±), (âˆ€ (n : â„•), P (F n)) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ r (F m) (F n)
(P : â„•) [Fact (Nat.Prime P)] (x : (Zmod P)Ë£) : (âˆƒ (y : (Zmod P)Ë£), y ^ 2 = x) â†” x ^ (P / 2) = 1
{B : Type u} [Quiver B] {A B C : B} (P : Quiver.Path A B) {F g : CategoryTheory.FreeBicategory.Hom B C} (Î· : F âŸ¶ g) : CategoryTheory.FreeBicategory.normalize_aux P F = CategoryTheory.FreeBicategory.normalize_aux P g
{r : â„} (tr : Transcendental â„š r) : Irrational r
{E : Type u_2} [AddCommGroup E] [module â„ E] (S : Convex_cone â„ E) (F : LinearPmap â„ E â„) (nonneg : âˆ€ (x : â†¥(F.IsDomain)), â†‘x âˆˆ S â†’ 0 â‰¤ â‡‘F x) (Dense : âˆ€ (y : E), âˆƒ (x : â†¥(F.IsDomain)), â†‘x + y âˆˆ S) : âˆƒ (g : E â†’â‚—[â„] â„), (âˆ€ (x : â†¥(F.IsDomain)), â‡‘g â†‘x = â‡‘F x) âˆ§ âˆ€ (x : E), x âˆˆ S â†’ 0 â‰¤ â‡‘g x
{Î± : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : Î± â†’ m} {S : set Î±} (P : m â†’ Prop) (hpâ‚€ : P 0) (hpâ‚ : âˆ€ (x y : m), P x â†’ P y â†’ P (x + y)) (hpâ‚‚ : âˆ€ (x : Î±), x âˆˆ S â†’ P (F x)) : P (finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), F i)))
{m : Type u_1} [AddMonoid m] {x y z : m} : y âˆˆ Multiples x â†’ z âˆˆ Multiples x â†’ y + z âˆˆ Multiples x
{n : â„•} {E : Type u_1} [NormedGroup E] (A : E) (C : Fin n â†’ â„‚) (R : Fin n â†’ â„) : TorusIntegrable (Î» (_x : Fin n â†’ â„‚), A) C R
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) (Î¸ : Real.Angle) : hb.oangle (â‡‘(hb.rotation Î¸) x) (â‡‘(hb.rotation Î¸) y) = hb.oangle x y
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {x : E} {r : ð•œ} (hx : x â‰  0) (hr : r â‰  0) : _R_or_C.Abs (HasInner.inner x (r â€¢ x)) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [AddCommMonoid N] [DecidableEq Î±] (F : Î± â†’â‚€ m) (A : Î±) (B : Î± â†’ m â†’ N) : F.Sum (Î» (x : Î±) (v : m), Ite (x = A) (B x v) 0) = Ite (A âˆˆ F.Support) (B A (â‡‘F A)) 0
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) {r : â„} (hr : 0 â‰¤ r) : hb.oangle x (r â€¢ x) = 0
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A : Î±} : 1 â‰¤ Aâ»Â¹ â†” A â‰¤ 1
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {x y : m} (h : SameRay R x y) (hx : x â‰  0) : âˆƒ (r : R), 0 â‰¤ r âˆ§ r â€¢ x = y
{L : FirstOrder.Language} (m : Type W') [L.structure m] [im : Infinite m] (Îº : Cardinal) (h1 : L.Card.Lift â‰¤ Îº.Lift) (h2 : (Cardinal.Mk m).Lift â‰¤ Îº.Lift) : âˆƒ (N : CategoryTheory.Bundled L.structure), Nonempty (L.elementary_Embedding m â†¥N) âˆ§ Cardinal.Mk â†¥N = Îº.Lift
{Î± : Type u} {Î² : Type v} : (Cardinal.Mk Î±).Lift â‰¤ (Cardinal.Mk Î²).Lift â†” Nonempty (Î± â†ª Î²)
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} : metric.Hausdorff_dist âˆ… S = 0
{K : Type v} {v : Type W} [Field K] [AddCommGroup v] [module K v] (F : module.End K v) : CompleteLattice.Independent F.eigenspace
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (P : Cáµ’áµ– â¥¤ A) {x : C} (S : CategoryTheory.Sieve x) : (âˆ€ (C : CategoryTheory.Limits.Cone (S.Arrows.Diagram.Op â‹™ P)), Subsingleton (C âŸ¶ P.Map_cone S.Arrows.Cocone.Op)) â†” âˆ€ (E : Aáµ’áµ–), CategoryTheory.Presieve.IsSeparated_for (P â‹™ CategoryTheory.coyoneda.obj E) â‡‘S
(L : List â„•) : L.head + L.tail.Sum = L.Sum
{A B : â„•} (ha : A â‰  0) (hb : B â‰  0) : (A * B).Factors ~ A.Factors ++ B.Factors
{ð•œ : Type u_1} {ð•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField ð•œ] [nondiscrete_NormedField ð•œâ‚‚] [NormedSpace ð•œ E] [NormedSpace ð•œâ‚‚ F] {Ïƒâ‚â‚‚ : ð•œ â†’+* ð•œâ‚‚} [Ring_hom_isometric Ïƒâ‚â‚‚] (F : E â†’sl[Ïƒâ‚â‚‚] F) (x : E) : âˆ¥â‡‘F xâˆ¥ â‰¤ âˆ¥Fâˆ¥ * âˆ¥xâˆ¥
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Pos_Mul_StrictMono Î±] (ha : 1 < A) (hb : 1 < B) (A0 : 0 < A) : 1 < A * B
{Î¹ : Type u} (S : Finset Î¹) {F : Î¹ â†’ â„} {P : â„} (hp : 1 â‰¤ P) (hF : âˆ€ (i : Î¹), i âˆˆ S â†’ 0 â‰¤ F i) : S.Sum (Î» (i : Î¹), F i) ^ P â‰¤ â†‘(S.Card) ^ (P - 1) * S.Sum (Î» (i : Î¹), F i ^ P)
{m : Type u_2} [AddCommGroup m] {Î¹ : Type u_4} [DecidableEq Î¹] [Fintype Î¹] {A : Type u_5} [CommRing A] [module A m] {Îº : Type u_6} [Fintype Îº] [DecidableEq Îº] (B : Basis Î¹ A m) (C : Basis Îº A m) (F : m â†’â‚—[A] m) : (â‡‘(Linear_Map.to_Matrix B B) F).det = (â‡‘(Linear_Map.to_Matrix C C) F).det
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [IsRefl Î± r] [IsTrans Î± r] {S : set Î±} (h : S.partially_well_ordered_on r) : {l : List Î± | âˆ€ (x : Î±), x âˆˆ l â†’ x âˆˆ S}.partially_well_ordered_on (List.sublist_forallâ‚‚ r)
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] [CategoryTheory.HasProjectiveResolutions C] [CategoryTheory.Preadditive D] [CategoryTheory.Limits.has_Zero_object D] [CategoryTheory.Limits.HasEqualizers D] [CategoryTheory.Limits.HasCokernels D] [CategoryTheory.Limits.HasImages D] [CategoryTheory.Limits.HasImage_maps D] (F : C â¥¤ D) [F.Additive] (n : â„•) {x Y : C} (F : x âŸ¶ Y) {P : CategoryTheory.ProjectiveResolution x} {q : CategoryTheory.ProjectiveResolution Y} (g : P.Complex âŸ¶ q.Complex) (W : g â‰« q.Ï€ = P.Ï€ â‰« (chain_Complex.singleâ‚€ C).Map F) : (F.Left_derived n).Map F = (F.Left_derived_obj_iso n P).hom â‰« (homology_Functor D (ComplexShape.down â„•) n).Map ((F.Map_homological_Complex (ComplexShape.down â„•)).Map g) â‰« (F.Left_derived_obj_iso n q).Inv
{n : â„•} {Î² : Type u_1} (A : Î²) (q : Fin n â†’ Î²) (B : Î²) : Fin.Cons A (Fin.snoc q B) = Fin.snoc (Fin.Cons A q) B
{m n : â„•} (hmn : m.IsCoprime n) : Squarefree (m * n) â†” Squarefree m âˆ§ Squarefree n
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 : P) {P2 P3 P4 : P} (h : EuclideanGeometry.angle P2 P3 P4 = Real.Pi) : EuclideanGeometry.angle P1 P3 P2 + EuclideanGeometry.angle P1 P3 P4 = Real.Pi
{J : Type uâ‚} [CategoryTheory.Category J] {K : Type uâ‚‚} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J â¥¤ C} [CategoryTheory.Limits.HasColimit F] {E : K â¥¤ J} [CategoryTheory.Limits.HasColimit (E â‹™ F)] (S : CategoryTheory.Limits.Colimit_Cocone (E â‹™ F)) (t : CategoryTheory.Limits.Colimit_Cocone F) : CategoryTheory.Limits.Colimit.pre F E = (CategoryTheory.Limits.Colimit.iso_Colimit_Cocone S).hom â‰« S._Colimit.Desc (CategoryTheory.Limits.Cocone.whisker E t.Cocone) â‰« (CategoryTheory.Limits.Colimit.iso_Colimit_Cocone t).Inv
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasCoproducts C] : CategoryTheory.Limits.has_Finite_coproducts C
{R : Type u_4} {S : Type u_5} [has_Mul R] [has_Add R] [has_Mul S] [has_Add S] (e : R â‰ƒ+* S) (x y : R) : â‡‘e (x * y) = â‡‘e x * â‡‘e y
{Î± : Type u} (S : Seq Î±) {Aâ‚™ : Î±} {n m : â„•} (m_LE_n : m â‰¤ n) (S_nth_Eq_Some : S.nth n = Option.Some Aâ‚™) : âˆƒ (Aâ‚˜ : Î±), S.nth m = Option.Some Aâ‚˜
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {F : Î± â†’ â„} (K : â„) (h : âˆ€ (x : Î±), x âˆˆ S â†’ âˆ€ (y : Î±), y âˆˆ S â†’ F x â‰¤ F y + K * HasDist.dist x y) : LipschitzOnWith K.to_Nnreal F S
{n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n
{Î± : Type u} [UniformSpace Î±] (h : IsComplete set.Univ) : CompleteSpace Î±
{Î± : Type u_1} [Preorder Î±] [locally_Finite_order Î±] {A B : Î±} : Â¬A < B â†’ Multiset.Ico A B = 0
{R : Type u} {Î¹ : Type u'} {mâ‚ : Î¹ â†’ Type vâ‚} {mâ‚‚ : Type vâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] (F : MultilinearMap R mâ‚ mâ‚‚) (m m' : Î  (i : Î¹), mâ‚ i) (t : Finset Î¹) : â‡‘F (t.piecewise (m + m') m') = t.powerset.Sum (Î» (S : Finset Î¹), â‡‘F (S.piecewise m m'))
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î± â†’ Î³} {x : Î± Ã— Î²} (hF : Continuous_at F x.fst) : Continuous_at (Î» (x : Î± Ã— Î²), F x.fst) x
{P : â„•} (hp : Nat.Prime P) {R : Type u_1} [CommRing R] [IsDomain R] {n m : â„•} (hmn : m â‰¤ n) (h : Irreducible (Polynomial.cyclotomic (P ^ n) R)) : Irreducible (Polynomial.cyclotomic (P ^ m) R)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] : 0 < Finite_dimensional.finrank K v â†” âˆƒ (x : v), x â‰  0
{Î¹ : Type u_1} {R : Type u_3} [Ring R] {m : Type u_2} [AddCommGroup m] [module R m] {v : Î¹ â†’ m} (li : LinearIndependent R v) (C D : R) (i j : Î¹) (hc : C â‰  0) (h : C â€¢ v i = D â€¢ v j) : i = j
{Î± : Type u} [SemilatticeInf Î±] [OrderTop Î±] {x y z : Î±} (F : x âŸ¶ z) (g : y âŸ¶ z) : CategoryTheory.Limits.pullback F g = x âŠ“ y
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [BaireSpace Î±] {S : set Î²} {F : Î  (x : Î²), x âˆˆ S â†’ set Î±} (ho : âˆ€ (S : Î²) (h : S âˆˆ S), _GÎ´ (F S h)) (hS : S.countable) (hD : âˆ€ (S : Î²) (h : S âˆˆ S), Dense (F S h)) : Dense (â‹‚ (S : Î²) (h : S âˆˆ S), F S h)
{Î± : Type u_1} [MetricSpace Î±] {Î² : Type u} [Nonempty Î²] (P : Besicovitch.TauPackage Î² Î±) {i : Ordinal} (hi : i < P.Last_step) {N : â„•} (hN : IsEmpty (Besicovitch.SatelliteConfig Î± N P.Ï„)) : P.color i < N
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) : Summable (Î» (i : Î¹), âˆ¥HasInner.inner (v i) xâˆ¥ ^ 2)
{x : Type u_1} [TopologicalSpace x] [SequentialSpace x] {S : set x} {A : x} : A âˆˆ Closure S â†” âˆƒ (x : â„• â†’ x), (âˆ€ (n : â„•), x n âˆˆ S) âˆ§ Filter.Tendsto x Filter.at_top (nhds A)
{R : Type u} {S : Type v} [Ring R] [Ring S] {F g : R â†’+* S} {S : set R} (h : set.Eq_on â‡‘F â‡‘g S) : set.Eq_on â‡‘F â‡‘g â†‘(Subring.Closure S)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) {i : Î¹} (his : i âˆˆ S) (hwi : W i = 1) (hw0 : âˆ€ (i2 : Î¹), i2 âˆˆ S â†’ i2 â‰  i â†’ W i2 = 0) : â‡‘(S.affine_combination P) W = P i
{Î± : Type u} [PseudoEmetricSpace Î±] {F : â„• â†’ Î±} (n : â„•) {D : â„• â†’ Ennreal} (hD : âˆ€ {k : â„•}, k < n â†’ HasEdist.edist (F k) (F (k + 1)) â‰¤ D k) : HasEdist.edist (F 0) (F n) â‰¤ (Finset.Range n).Sum (Î» (i : â„•), D i)
{t : â„} {g : â„ â†’ â„} (hg : Function.Periodic g t) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.MeasureSpace.Volume tâ‚ tâ‚‚) (hâ‚€ : 0 < âˆ« (x : â„) in 0..t, g x) (hT : 0 < t) : Filter.Tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) Filter.at_top Filter.at_top
{P : â„•} [P_Prime : Fact (Nat.Prime P)] {A : â„¤} : multiplicity.Finite â†‘P A â†” A â‰  0
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (hx : x â‰  0) (hy : y â‰  0) : HasInner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥) â†” InnerProductGeometry.angle x y = Real.Pi
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} (ha : A â‰  0) : Char.quadratic_Char F A ^ 2 = 1
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {Î¹ : Type u_5} [DecidableEq Î¹] [Fintype Î¹] (g : G â†’L[ð•œ] E) : IsBoundedLinearMap ð•œ (Î» (F : Continuous_MultilinearMap ð•œ (Î» (i : Î¹), E) F), F.Comp_Continuous_Linear_Map (Î» (_x : Î¹), g))
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.Int_fract_pair K} (nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n) : 0 â‰¤ ifp_n.fr âˆ§ ifp_n.fr < 1
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) : IsUnit A â†” IsUnit A.det
{Î± : Type u_1} (F : set Î± â†’ Î±) : Â¬Function.Injective F
{R : Type u_2} [CommRing R] [IsDomain R] [Fintype R] {F g : Polynomial R} (hF2 : F.degree = 2) (hg2 : g.degree = 2) (hR : Fintype.Card R % 2 = 1) : âˆƒ (A B : R), Polynomial.Eval A F + Polynomial.Eval B g = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} {Sâ‚ Sâ‚‚ : Affine.Simplex â„ P n} (h : set.Range Sâ‚.points = set.Range Sâ‚‚.points) : Sâ‚.monge_point = Sâ‚‚.monge_point
{Î± : Type u_1} [Preorder Î±] [SuccOrder Î±] {A : Î±} : Â¬IsMax A â†’ A < Order.Succ A
{R : Type u_4} {S : Type u_5} [Semiring R] [Semiring S] (F : R â‰ƒ+* Sáµáµ’áµ–) (l : List R) : Mul_Opposite.Unop (â‡‘F l.Prod) = (List.Map (Mul_Opposite.Unop âˆ˜ â‡‘F) l).reverse.Prod
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] {F : x â†’ Y} [SequentialSpace x] : Seq_Continuous F â†’ Continuous F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {m n : WithTop â„•} {S : set E} {F : E â†’ F} (hF : ContDiff_on ð•œ n F S) (hs : UniqueDiffOn ð•œ S) (hmn : m + 1 â‰¤ n) : ContDiff_on ð•œ m (Î» (P : E Ã— E), â‡‘(fderiv_within ð•œ F S P.fst) P.Snd) (S Ã—Ë¢ set.Univ)
(G : Type u_1) [AddMonoid G] : Â¬AddMonoid._torsion_free G â†” âˆƒ (g : G), g â‰  0 âˆ§ _of_Fin_Add_order g
{G : Type u} [Fintype G] [Add_Left_cancel_Monoid G] (x : G) : 0 < Add_order_of x
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (P : Î¹ â†’ P) : â‡‘(S.weighted_vsub P) W = S.Sum (Î» (i : Î¹), W i â€¢ (P i -áµ¥ Classical.choice AddTorsor.Nonempty))
{m : Type u_1} [has_Mul m] (S : set m) {P : Î  (x : m), x âˆˆ Subsemigroup.Closure S â†’ Prop} (Hs : âˆ€ (x : m) (h : x âˆˆ S), P x _) (HMul : âˆ€ (x : m) (hx : x âˆˆ Subsemigroup.Closure S) (y : m) (hy : y âˆˆ Subsemigroup.Closure S), P x hx â†’ P y hy â†’ P (x * y) _) {x : m} (hx : x âˆˆ Subsemigroup.Closure S) : P x hx
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} (hs : S.Nonempty) (bs : Metric.Bounded S) (ht : t.Nonempty) (bt : Metric.Bounded t) : metric.Hausdorff_dist S t â‰¤ Metric.diam (S âˆª t)
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [TopologicalSpace Î²] (F : Filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (x : Î±) (y : Î²) : y âˆˆ OmegaLimit F Ï• {x} â†” Map_ClusterPt y F (Î» (t : Ï„), Ï• t x)
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} (ha : A â‰¤ 0) (hb : B â‰¤ 0) : A + B â‰¤ 0
{m : Type u_1} [has_Mul m] {S : set m} : S âŠ† â†‘(Subsemigroup.Closure S)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [Linear_ordered_AddCommMonoid Î²] [HasScalar ð•œ E] [module ð•œ Î²] [OrderedSmul ð•œ Î²] {S : set E} {F g : E â†’ Î²} (hF : Convex_on ð•œ S F) (hg : Convex_on ð•œ S g) : Convex_on ð•œ S (F âŠ” g)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_NormedGroup E] [semi_NormedGroup F] [semi_NormedGroup G] {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} (hF : Filter.Tendsto F l (nhds 0)) (hg : Filter._bounded_under has_LE.LE l (HasNorm.norm âˆ˜ g)) (Op : E â†’ F â†’ G) (h_Op : âˆƒ (A : â„), âˆ€ (x : E) (y : F), âˆ¥Op x yâˆ¥ â‰¤ A * âˆ¥xâˆ¥ * âˆ¥yâˆ¥) : Filter.Tendsto (Î» (x : Î±), Op (F x) (g x)) l (nhds 0)
(m : â„•) : padic_val_rat m 0 = 0
{m : Type u_1} [has_Add m] {C : Add_Con m} (x y : m) : â†‘(x + y) = â†‘x + â†‘y
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] (F : C(Î± Ã— Î², Î³)) : Continuous F.Curry'
{E : Type u_1} [AddCommGroup E] [module â„ E] {S : set E} : gauge S 0 = 0
{Î± : Type u_1} {Î² : Type u_2} {Î´ : Type u_4} [AddCommMonoid Î±] [TopologicalSpace Î±] [t2_Space Î±] [CompleteLattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (R : Î± â†’ Î± â†’ Prop) (m_supr : âˆ€ (S : â„• â†’ Î²), R (m (â¨† (i : â„•), S i)) (âˆ‘' (i : â„•), m (S i))) (S : Î´ â†’ Î²) (t : Finset Î´) : R (m (â¨† (D : Î´) (h : D âˆˆ t), S D)) (t.Sum (Î» (D : Î´), m (S D)))
{Î± : Type u} {Î² : Type v} : (Cardinal.Mk Î±).Lift = (Cardinal.Mk Î²).Lift â†” Nonempty (Î± â‰ƒ Î²)
{Î± : Type u_1} [cancel_CommMonoid_with_Zero Î±] [Unique_factorization_Monoid Î±] [normalization_Monoid Î±] [DecidableEq Î±] {n : Î±} : (factorization n).Support = (Unique_factorization_Monoid.normalized_Factors n).to_Finset
{Î± : Type u_2} [DecidableEq Î±] [has_div Î±] {u : Finset Î±} {S t : set Î±} : â†‘u âŠ† S / t â†’ (âˆƒ (S' t' : Finset Î±), â†‘S' âŠ† S âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† S' / t')
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : InnerProductGeometry.angle x (x - y) = InnerProductGeometry.angle y (y - x)
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S t : set E) : â†‘(intermediate_Field.Adjoin â†¥(intermediate_Field.Adjoin F S) t) = intermediate_Field.Adjoin F (S âˆª t)
{R : Type u_1} [Semiring R] {x y : R} (h : Commute x y) (n : â„•) : (x + y) ^ n = (Finset.Nat.antidiagonal n).Sum (Î» (m : â„• Ã— â„•), n.choose m.fst â€¢ (x ^ m.fst * y ^ m.Snd))
{Î± : sort u_1} {Sâ‚ : Setoid Î±} {P : Quotient Sâ‚ â†’ Prop} (q : Quotient Sâ‚) (h : âˆ€ (A : Î±), P (Quotient.Mk' A)) : P q
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Ring R] [AddCommGroup N] [module R N] {P : Î¹ â†’ Submodule R N} (h : CompleteLattice.Independent P) : Function.Injective â‡‘(â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (P i).Subtype))
{Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_Semiring Î±} {rÎ² : non_assoc_Semiring Î²} (F : Î± â†’+* Î²) (A B : Î±) : â‡‘F (A * B) = â‡‘F A * â‡‘F B
{Î± : Type u_1} (L : List (List Î±)) {i j : â„•} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : (List.take i (List.Map List.length L)).Sum + j < (List.take (i + 1) (List.Map List.length L)).Sum
{Î± : sort u_1} {P : Î± â†’ Prop} {q : Î  (x : Î±), P x â†’ Prop} : (âˆƒ (x : Î±) (h : P x), q x h) â†” âˆƒ (x : {A // P A}), q â†‘x _
{P : â„•} [Fact (Nat.Prime P)] (x : Zmod P) : x ^ P = x
{m : Type u_1} {N : Type u_2} [has_Add m] [has_Add N] {C : Add_Con m} {D : Add_Con N} {C : C.Quotient â†’ D.Quotient â†’ Prop} (P : C.Quotient) (q : D.Quotient) (h : âˆ€ (x : m) (y : N), C â†‘x â†‘y) : C P q
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} [TopologicalSpace Î²] [TopologicalSpace.pseudo_metrizable_Space Î²] (u : Filter Î¹) [u.Ne_IsBot] [u._countably_generated] {F : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hF : âˆ€ (i : Î¹), MeasureTheory.strongly_Measurable (F i)) (lim : Filter.Tendsto F u (nhds g)) : MeasureTheory.strongly_Measurable g
{Î± : Type u} (P : Î± â†’ Prop) [Decidable_Pred P] (as : List Î±) : (List.zip_with has_Append.Append (List.split_on_P P as) (List.Map (Î» (x : Î±), [x]) (List.Filter P as) ++ [List.Nil])).Join = as
{m : Type u_1} [has_Add m] (C : Add_Con m) (x : m) : â‡‘C x x
{Î± : Type u_1} [canonically_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B C : Î±} (h : C â‰¤ B) (h2 : A - C < B - C) : A < B
(S : set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ 0) : HasSup.Sup S â‰¤ 0
{Î± : Type u} [TopologicalSpace Î±] {S t : set Î±} (h : IsPreconnected S) (Kst : S âŠ† t) (Ktcs : t âŠ† Closure S) : IsPreconnected t
{x : Type u_2} [EmetricSpace x] [TopologicalSpace.SecondCountableTopology x] (S : set x) : (â¨† (x : x), (nhds_within x S).Small_sets.limsup dimH) = dimH S
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} {S : Type u_3} [Monoid S] [Distrib_MulAction S m] [SmulCommClass R S m] (h : SameRay R x y) (S : S) : SameRay R (S â€¢ x) (S â€¢ y)
{G : Type u_6} {h : Type u_7} {F : Type u_8} [AddGroup G] [subtraction_Monoid h] [AddMonoid_hom_class F G h] (F : F) (A B : G) : â‡‘F (A - B) = â‡‘F A - â‡‘F B
{Î± : Type u} {Î¹ : Type v} [MetricSpace Î±] [ProperSpace Î±] {C : Î¹ â†’ Î±} {S : set Î±} {r : Î¹ â†’ â„} (hs : IsClosed S) (uf : âˆ€ (x : Î±), x âˆˆ S â†’ {i : Î¹ | x âˆˆ Metric.Ball (C i) (r i)}.Finite) (us : S âŠ† â‹ƒ (i : Î¹), Metric.Ball (C i) (r i)) : âˆƒ (r' : Î¹ â†’ â„), (S âŠ† â‹ƒ (i : Î¹), Metric.Ball (C i) (r' i)) âˆ§ âˆ€ (i : Î¹), r' i < r i
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {F : Î± â†’ Î²} (hF : _AddGroup_hom F) : _AddMonoid_hom F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P âŸ¶ q) : (âˆ€ (A : â†¥P), â‡‘F A = 0 â†’ A = 0) â†’ CategoryTheory.Mono F
(v : Type u_1) [semi_NormedGroup v] : âˆ¥NormedGroup_hom.Id vâˆ¥ â‰¤ 1
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.IsIso (CategoryTheory.yoneda.Map F)] : CategoryTheory.IsIso F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h : S1 â‰¤ S2) : S1.direction â‰¤ S2.direction
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) {Bâ‚‚ : Basis (Fin 2) â„ v} (hbâ‚‚ : Orthonormal â„ â‡‘Bâ‚‚) (ho : B.Orientation = -Bâ‚‚.Orientation) (Î¸ : Real.Angle) : hb.rotation Î¸ = hbâ‚‚.rotation (-Î¸)
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) (h_anti : Antitone_on (deriv F) (Interior D)) : ConcaveOn â„ D F
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimits_of_shape (CategoryTheory.Limits.WidePullbackShape J) C] {B : C} : CategoryTheory.Limits.HasLimits_of_shape (CategoryTheory.Discrete J) (CategoryTheory.Over B)
 : Continuous_Map.Conj_invariant_Subalgebra (Subalgebra.Restrict_scalars â„ fourier_Subalgebra)
{Î± : Type u_1} [TopologicalSpace Î±] {S : set (set Î±)} (h : âˆ€ (S : set Î±), S âˆˆ S â†’ _GÎ´ S) (hS : S.countable) : _GÎ´ (â‹‚â‚€ S)
{Î¹ : Type u_3} {Ï‡ : Î¹ â†’ Type u_4} [Î  (i : Î¹), TopologicalSpace (Ï‡ i)] {as bs cs : Î  (i : Î¹), Ï‡ i} (Î³â‚€ : Î  (i : Î¹), Path (as i) (bs i)) (Î³â‚ : Î  (i : Î¹), Path (bs i) (cs i)) : (Path.Pi Î³â‚€).Trans (Path.Pi Î³â‚) = Path.Pi (Î» (i : Î¹), (Î³â‚€ i).Trans (Î³â‚ i))
{Î± : Type u_1} {n : Type u_3} {A : Matrix n n Î±} : A.IsSymm â†” âˆ€ (i j : n), A j i = A i j
{Î± J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.Fin_Category J] [SemilatticeSup Î±] [OrderBot Î±] (F : J â¥¤ Î±) : CategoryTheory.Limits.Colimit F = Finset.Univ.Sup F.obj
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {x Y Z x' Y' Z' : C} (F : x âŸ¶ Y) (g : Y âŸ¶ Z) [CategoryTheory.Limits.HasKernel g] (W : F â‰« g = 0) (F' : x' âŸ¶ Y') (g' : Y' âŸ¶ Z') [CategoryTheory.Limits.HasKernel g'] (W' : F' â‰« g' = 0) (P : x âŸ¶ x') (q : Y âŸ¶ Y') (r : Z âŸ¶ Z') (hâ‚ : F â‰« q = P â‰« F') (hâ‚‚ : g â‰« r = q â‰« g') : CategoryTheory.Limits.Kernel.Lift g F W â‰« CategoryTheory.Limits.Kernel.Map g g' q r hâ‚‚ = P â‰« CategoryTheory.Limits.Kernel.Lift g' F' W'
{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : MeasurableSpace Î±} {mâ‚‚ : MeasurableSpace Î²} {F : Î± â†’ Î²} : mâ‚‚ â‰¤ MeasurableSpace.Map F mâ‚ â†’ Measurable F
{Î± : Type u} {Î² : Type v} {Î³ : Type W} [PseudoEmetricSpace Î±] [TopologicalSpace Î²] [PseudoEmetricSpace Î³] (F : Î± Ã— Î² â†’ Î³) (K : Nnreal) (ha : âˆ€ (A : Î±), Continuous (Î» (y : Î²), F (A, y))) (hb : âˆ€ (B : Î²), LipschitzWith K (Î» (x : Î±), F (x, B))) : Continuous F
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {R : Nnreal} {C : â„‚} {F : â„‚ â†’ E} (hD : DifferentiableOn â„‚ F (metric.IsClosed_ball C â†‘R)) (hR : 0 < R) : HasFpowerSeriesOnBall F (Cauchy_PowerSeries F C â†‘R) C â†‘R
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} (F : x âŸ¶ Y) [CategoryTheory.IsIso F.Op] : CategoryTheory.IsIso F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} {F G : top.Presheaf C x} (Î± : F â‰… G) (h : F._sheaf) : G._sheaf
{Î¹ : Type u_1} {ð•œ : Type u_2} {F : Type u_3} [Fintype Î¹] [Semiring ð•œ] [TopologicalSpace ð•œ] [AddCommMonoid F] [module ð•œ F] [TopologicalSpace F] [has_Continuous_Add F] [has_Continuous_Smul ð•œ F] (F : (Î¹ â†’ ð•œ) â†’â‚—[ð•œ] F) : Continuous â‡‘F
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] {S : set E} {F : E â†’ E} {F' : E â†’ (E â†’L[â„] E)} [MeasurableSpace E] [BorelSpace E] (hs : Measurable_set S) (hF' : âˆ€ (x : E), x âˆˆ S â†’ HasFderivWithinAt F (F' x) S x) (hF : set.inj_on F S) : Measurable_Embedding (S.Restrict F)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (x Y : C) : CategoryTheory.IsIso (CategoryTheory.Limits.KernelÎ¹ 0)
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} : A - B â‰¤ 0 â†’ A â‰¤ B
{Î± : Type u_1} [PartialOrder Î±] [SuccOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ico m n â†’ r (Order.Succ i) i) (hmn : m < n) : Relation.TransGen r n m
(n : â„•) (n_Pos : 0 < n) : 4 ^ n â‰¤ 2 * n * n.central_binom
{R : Type u} {Î¹ : Type v} {mâ‚ : Î¹ â†’ Type Wâ‚} {mâ‚‚ : Type Wâ‚‚} [DecidableEq Î¹] [Semiring R] [Î  (i : Î¹), AddCommMonoid (mâ‚ i)] [AddCommMonoid mâ‚‚] [Î  (i : Î¹), module R (mâ‚ i)] [module R mâ‚‚] [Î  (i : Î¹), TopologicalSpace (mâ‚ i)] [TopologicalSpace mâ‚‚] (F : Continuous_MultilinearMap R mâ‚ mâ‚‚) [Fintype Î¹] (m m' : Î  (i : Î¹), mâ‚ i) : â‡‘F (m + m') = Finset.Univ.Sum (Î» (S : Finset Î¹), â‡‘F (S.piecewise m m'))
{Î± : Type u} [TopologicalSpace Î±] (x : Î±) [(nhds_within x {x}á¶œ).Ne_IsBot] : Closure {x}á¶œ = set.Univ
{ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [Linear_ordered_Field ð•œ] [AddCommGroup E] [AddCommGroup F] [ordered_AddCommMonoid Î²] [module ð•œ E] [module ð•œ F] [HasScalar ð•œ Î²] {F : F â†’ Î²} (g : E â†’áµƒ[ð•œ] F) {S : set F} (hF : ConcaveOn ð•œ S F) : ConcaveOn ð•œ (â‡‘g â»Â¹' S) (F âˆ˜ â‡‘g)
{P : â„•} : padic_val_rat P 1 = 0
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {A B C : v} (F : A âŸ¶ B) [CategoryTheory.Limits.HasImage F] (g : B âŸ¶ C) [CategoryTheory.Limits.HasKernel g] (W : F â‰« g = 0) (h : CategoryTheory.Limits.image_Subobject F â‰¤ CategoryTheory.Limits.Kernel_Subobject g) : (CategoryTheory.Limits.image_Subobject F).of_LE (CategoryTheory.Limits.Kernel_Subobject g) h = image_to_Kernel F g W
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {F : Î± â†’ Î² â†’ Î³} (hF : Function.Injective2 F) (A : Î±) : Function.Injective (F A)
{Î± : Type u} {Î² : Type v} [Group Î±] [Group Î²] {F : Î± â†’ Î²} (hF : _Group_hom F) : _Monoid_hom F
{n : â„•} (hn : Even n) (h : n â‰  0) : strict_Convex_on â„ set.Univ (Î» (x : â„), x ^ n)
{R : Type u} [CommRing R] [IsNoetherian_Ring R] : IsNoetherian_Ring (Polynomial R)
{D : set â„} (hD : Convex â„ D) {F : â„ â†’ â„} (hF : Continuous_on F D) (hF' : DifferentiableOn â„ F (Interior D)) {C : â„} (LE_hF' : âˆ€ (x : â„), x âˆˆ Interior D â†’ deriv F x â‰¤ C) (x : â„) (h : x âˆˆ D) (y : â„) (h_1 : y âˆˆ D) : x â‰¤ y â†’ F y - F x â‰¤ C * (y - x)
{R : Type u_1} [has_Mul R] {A : R} : IsLeftRegular A â†” IsSmulRegular R A
{R : Type u_1} {Î± : Type u_2} {Î² : Type u_4} {Î³ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {l' : Type u_14} {m' : Type u_15} {n' : Type u_16} [CommSemiring R] [Fintype m] [Fintype m'] [non_unital_non_assoc_Semiring Î±] [non_unital_non_assoc_Semiring Î²] [non_unital_non_assoc_Semiring Î³] [module R Î±] [module R Î²] [module R Î³] (F : Î± â†’â‚—[R] Î² â†’â‚—[R] Î³) (h_comm : âˆ€ (A B : Î±) (A' B' : Î²), â‡‘(â‡‘F (A * B)) (A' * B') = â‡‘(â‡‘F A) A' * â‡‘(â‡‘F B) B') (A : Matrix l m Î±) (B : Matrix m n Î±) (A' : Matrix l' m' Î²) (B' : Matrix m' n' Î²) : â‡‘(â‡‘(Matrix.kronecker_Map_bilinear F) (A.Mul B)) (A'.Mul B') = (â‡‘(â‡‘(Matrix.kronecker_Map_bilinear F) A) A').Mul (â‡‘(â‡‘(Matrix.kronecker_Map_bilinear F) B) B')
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [SemilatticeSup Î±] [OrderBot Î±] (S : Finset Î²) (t : Finset Î³) (F : Î² Ã— Î³ â†’ Î±) : (S.Product t).Sup F = S.Sup (Î» (i : Î²), t.Sup (Î» (i' : Î³), F (i, i')))
{A : Type u_2} [CommRing A] [IsDomain A] (h : IsDedekindDomain_Inv A) : IsDedekindDomain A
{Î¹ : Type u_1} {Î± : Type u_3} [Preorder Î¹] [Preorder Î±] {l : Filter Î¹} {u : Î¹ â†’ Î±} (h : Monotone u) [l.Ne_IsBot] (hu : Filter.Tendsto u l Filter.at_IsBot) : Filter.Tendsto u Filter.at_IsBot Filter.at_IsBot
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {vâ‚ vâ‚‚ : Ray_Vector R m} : vâ‚ â‰ˆ vâ‚‚ â†” SameRay R â†‘vâ‚ â†‘vâ‚‚
{Î± : Type u} [OrderedSemiring Î±] [Nontrivial Î±] : 0 < 4
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [AddCommMonoid m] {g : Î² â†’ m} (e : Î± â†’ Î²) (hEâ‚€ : Function.Bijective e) : finsum (Î» (i : Î±), g (e i)) = finsum (Î» (j : Î²), g j)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : 0 â‰¤ EuclideanGeometry.angle P1 P2 P3
(n : â„•) : n.choose 2 = n * (n - 1) / 2
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace E] [CompleteSpace â†¥K] (W : E) : W = â†‘(â‡‘(Orthogonal_projection K) W) + â†‘(â‡‘(Orthogonal_projection Ká—®) W)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h1 : â†‘S1.Nonempty) (h2 : â†‘S2.Nonempty) (hE : â†‘S1 âˆ© â†‘S2 = âˆ…) : S1.direction âŠ” S2.direction < (S1 âŠ” S2).direction
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] (e : C â‰Œ D) (Y : D) : e.Unit.App (e.Inverse.obj Y) â‰« e.Inverse.Map (e.counit.App Y) = ðŸ™ (e.Inverse.obj Y)
{Î± : Type u} [Preorder Î±] {A B C : Î±} : B = C â†’ A < B â†’ A < C
(R : Type u) (m : Type v) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] : â†‘(Finite_dimensional.finrank R m) = module.rank R m
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {S : set Y} (F : C(â†¥S, â„)) {t : set â„} [t.Ord_connected] (ht : âˆ€ (x : â†¥S), â‡‘F x âˆˆ t) (hne : t.Nonempty) (hs : IsClosed S) : âˆƒ (g : C(Y, â„)), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ Continuous_Map.Restrict S g = F
{P : Ereal Ã— Ereal} (h : P.fst â‰  âŠ¤ âˆ¨ P.Snd â‰  âŠ¥) (h' : P.fst â‰  âŠ¥ âˆ¨ P.Snd â‰  âŠ¤) : Continuous_at (Î» (P : Ereal Ã— Ereal), P.fst + P.Snd) P
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {S : set Î±} {P : Filter Î¹} (h : TendstoUniformlyOn F F P S) (g : Î³ â†’ Î±) : TendstoUniformlyOn (Î» (n : Î¹), F n âˆ˜ g) (F âˆ˜ g) P (g â»Â¹' S)
{Î± : Type u} [TopologicalSpace Î±] (x : Î±) [(nhds_within x {x}á¶œ).Ne_IsBot] : Dense {x}á¶œ
{n : â„•} {Î± : Fin (n + 1) â†’ Type u} (q : Î  (i : Fin (n + 1)), Î± i) : Fin.snoc (Fin.init q) (q (Fin.Last n)) = q
{R : Type u} {A : Type W} [CommSemiring R] [Semiring A] [Algebra R A] (r : R) (x y : A) : r â€¢ x * y = r â€¢ (x * y)
 : Â¬Small Ordinal
{Î± : Type u} [PseudoEmetricSpace Î±] (E : set Î±) : Closure E = â‹‚ (Î´ : â„) (h : 0 < Î´), Metric.Cthickening Î´ E
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommGroup Î²] [HasScalar ð•œ E] [module ð•œ Î²] {S : set E} {F : E â†’ Î²} : strict_Convex_on ð•œ S F â†’ strict_ConcaveOn ð•œ S (-F)
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {S : Submodule K v} (h : S < âŠ¤) : Finite_dimensional.finrank K â†¥S < Finite_dimensional.finrank K v
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F : â„ â†’ E} {A B : â„} {F' g : â„ â†’ E} (derivf : âˆ€ (x : â„), x âˆˆ set.Ico A B â†’ HasDerivWithinAt F (F' x) (set.ici x) x) (derivg : âˆ€ (x : â„), x âˆˆ set.Ico A B â†’ HasDerivWithinAt g (F' x) (set.ici x) x) (fcont : Continuous_on F (set.icc A B)) (gcont : Continuous_on g (set.icc A B)) (hi : F A = g A) (y : â„) (h : y âˆˆ set.icc A B) : F y = g y
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (hn : x â‰  y) (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : o.oangle y x = â†‘Real.Pi - 2 â€¢ o.oangle (y - x) y
{R : Type u_1} {A : R} [Add_Semigroup R] (B : R) (ha : _Add_Right_regular A) : _Add_Right_regular (B + A) â†” _Add_Right_regular B
{Î± : Type u_1} {G : Type u_5} [TopologicalSpace G] [AddCommGroup G] [topological_AddGroup G] {F : Î± â†’ G} (hF : Summable F) : Filter.Tendsto F Filter.cofinite (nhds 0)
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] (F : â„‚ â†’ E) (z W : â„‚) (hD : DifferentiableOn â„ F (set.Interval z.re W.re Ã—â„‚ set.Interval z.im W.im)) (Hi : MeasureTheory.IntegrableOn (Î» (z : â„‚), Complex.i â€¢ â‡‘(fderiv â„ F z) 1 - â‡‘(fderiv â„ F z) Complex.i) (set.Interval z.re W.re Ã—â„‚ set.Interval z.im W.im) MeasureTheory.MeasureSpace.Volume) : (((âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(z.im) * Complex.i)) - âˆ« (x : â„) in z.re..W.re, F (â†‘x + â†‘(W.im) * Complex.i)) + Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(W.re) + â†‘y * Complex.i)) - Complex.i â€¢ âˆ« (y : â„) in z.im..W.im, F (â†‘(z.re) + â†‘y * Complex.i) = âˆ« (x : â„) in z.re..W.re, âˆ« (y : â„) in z.im..W.im, Complex.i â€¢ â‡‘(fderiv â„ F (â†‘x + â†‘y * Complex.i)) 1 - â‡‘(fderiv â„ F (â†‘x + â†‘y * Complex.i)) Complex.i
(ð•œ : Type u) [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace ð•œ] {r : â„} (rpos : 0 < r) {C : E} (h : IsCompact (metric.IsClosed_ball C r)) : Finite_dimensional ð•œ E
{Î± : Type u} {Î² : Type v} [AddGroup Î±] [AddGroup Î²] {F : Î± â†’ Î²} (hF : _AddGroup_hom F) : Function.Injective F â†” âˆ€ (A : Î±), F A = 0 â†’ A = 0
(m : â„•) {n : â„•} (hn : 0 < n) : (âˆƒ (k : â„•), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} {F : ð•œ â†’ F} {S : set ð•œ} : iterated_deriv_within n F S = â‡‘((Continuous_MultilinearMap.Pi_Field_Equiv ð•œ (Fin n) F).Symm) âˆ˜ iterated_fderiv_within ð•œ n F S
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} {S : set Î²} (hF : Continuous F) : F â»Â¹' Interior S âŠ† Interior (F â»Â¹' S)
{Î± : Type u_1} {Î² : Type u_2} [AddCommGroup Î±] [TopologicalSpace Î±] [topological_AddGroup Î±] {F : Î² â†’ Î±} [t2_Space Î±] [DecidableEq Î²] (hF : Summable F) (B : Î²) : âˆ‘' (n : Î²), F n = F B + âˆ‘' (n : Î²), Ite (n = B) 0 (F n)
{R : Type u} [Ring R] (A : R) {n : â„•} (h : n â‰  0) : (Polynomial.x ^ n - â‡‘Polynomial.C A).monic
{K : Type u_1} {v : K} {n : â„•} [Linear_ordered_Field K] [FloorRing K] (hyp : n = 0 âˆ¨ Â¬(GeneralizedContinuedFraction.of v).TerminatedAt (n - 1)) : â†‘(Nat.fib (n + 1)) â‰¤ (GeneralizedContinuedFraction.of v).denominators n
{Î± : Type u} {Î² : Type v} [complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [complete_LinearOrder Î²] [TopologicalSpace Î²] [OrderTopology Î²] {Î¹ : sort u_1} {F : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : Continuous_at F (supr g)) (Mf : Monotone F) (fbot : F âŠ¥ = âŠ¥) : F (â¨† (i : Î¹), g i) = â¨† (i : Î¹), F (g i)
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] [âˆ€ (x Y : C), Subsingleton (x âŸ¶ Y)] (hC : CategoryTheory.Skeletal C) : CategoryTheory.Skeletal (D â¥¤ C)
{K : Type u} [hring : CommRing K] [hdomain : IsDomain K] {P : Ratfunc K â†’ Prop} (x : Ratfunc K) (F : âˆ€ (P q : Polynomial K), q â‰  0 â†’ P (Ratfunc.Mk P q)) : P x
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [decÎ¹ : DecidableEq Î¹] [Semiring R] [AddCommMonoid N] [module R N] (P : Î¹ â†’ Submodule R N) : supr P = (â‡‘(Dfinsupp.lsum â„•) (Î» (i : Î¹), (P i).Subtype)).Range
{Î± : Type u_1} [PartialOrder Î±] [SuccOrder Î±] [IsSuccArchimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ico m n â†’ r (Order.Succ i) i) (hmn : m â‰¤ n) : Relation.refl_Trans_gen r n m
{x : Type u_1} [TopologicalSpace x] [NormalSpace x] (C : Urysohns.CU x) : Continuous C.lim
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {n : â„•} [Nonempty Î²] (hn : Fintype.Card Î² * n â‰¤ Fintype.Card Î±) : âˆƒ (y : Î²), n â‰¤ (Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Card
 : (Î» (n : â„•), â†‘(Nat.fib n)) = Î» (n : â„•), (GoldenRatio ^ n - golden_Conj ^ n) / Real.sqrt 5
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {F : Î± â†’ Î²} (hi : Inducing F) (ho : IsOpen (set.Range F)) : IsOpen_Map F
{Î± : Type u_3} [SemilatticeInf Î±] [NoMinOrder Î±] (A : Î±) : Filter.Map Coe Filter.at_IsBot = Filter.at_IsBot
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] [h : Group.IsNilpotent G] (F : G â‰ƒ* G') : Group.IsNilpotent G'
{A : Type u_1} (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] (A : A) : minpoly A (â‡‘(Algebra_Map A B) A) = Polynomial.x - â‡‘Polynomial.C A
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} {r : Ennreal} (h1 : âˆ€ (x : Î±), x âˆˆ S â†’ (âˆƒ (y : Î±) (h : y âˆˆ t), HasEdist.edist x y â‰¤ r)) (h2 : âˆ€ (x : Î±), x âˆˆ t â†’ (âˆƒ (y : Î±) (h : y âˆˆ S), HasEdist.edist x y â‰¤ r)) : Emetric.Hausdorff_edist S t â‰¤ r
{R : Type u} [CommSemiring R] (l : List (Polynomial R)) (x : R) : Polynomial.Eval x l.Prod = (List.Map (Polynomial.Eval x) l).Prod
{F : Type v} [NormedGroup F] [NormedSpace â„‚ F] {F : â„‚ â†’ F} (hF : Differentiable â„‚ F) (hb : Metric.Bounded (set.Range F)) (z W : â„‚) : F z = F W
{n : Type u_4} [DecidableEq n] (v : n â†’ â„) : (Matrix.Diagonal v)._hermitian
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {E : Type u_5} [CategoryTheory.Category E] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {L : CategoryTheory.GrothendieckTopology E} {F : C â¥¤ D} (hu : CategoryTheory.CoverLifting J K F) {G : D â¥¤ E} (hv : CategoryTheory.CoverLifting K L G) : CategoryTheory.CoverLifting J L (F â‹™ G)
{Î± : Type u_1} {Î² : Type u_2} [MeasurableSpace Î±] [MeasurableSpace Î²] (F : MeasureTheory.SimpleFunc Î± Î²) : Measurable â‡‘F
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.has_Finite_products D] (F : C â¥¤ D) {L : D â¥¤ C} [CategoryTheory.cartesian_IsClosed C] [CategoryTheory.cartesian_IsClosed D] [CategoryTheory.Limits.PreservesLimits_of_shape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] (h : L âŠ£ F) (A : C) [i : CategoryTheory.IsIso (CategoryTheory.Exp_comparison F A)] : CategoryTheory.IsIso (CategoryTheory.frobenius_morphism F h A)
 : StrictMono (Î» (n : â„•), Nat.fib (n + 2))
{m : Type u_6} {N : Type u_7} [has_Mul m] [has_Mul N] (F : m â‰ƒ* N) (x y : m) : â‡‘F (x * y) = â‡‘F x * â‡‘F y
{k : Type u_1} {G : Type u_2} {v : Type u_3} [CommSemiring k] [Group G] [AddCommMonoid v] [module k v] (Ï : Representation k G v) [Fintype G] [Invertible â†‘(Fintype.Card G)] (v : v) : â‡‘(Ï.average_Map) v âˆˆ Ï.invariants
{Î² : Type u} {Î± : Type v} [CommSemiring Î²] {S : Finset Î±} {i : Î±} {F g h : Î± â†’ Î²} (hi : i âˆˆ S) (h1 : g i + h i = F i) (h2 : âˆ€ (j : Î±), j âˆˆ S â†’ j â‰  i â†’ g j = F j) (h3 : âˆ€ (j : Î±), j âˆˆ S â†’ j â‰  i â†’ h j = F j) : S.Prod (Î» (i : Î±), g i) + S.Prod (Î» (i : Î±), h i) = S.Prod (Î» (i : Î±), F i)
{Î± : Type u_1} {n : â„•} {S t : Finset Î±} : S âˆˆ Finset.powerset_len n t â†” S âŠ† t âˆ§ S.Card = n
{Î± : Type u_1} {Î¹ : Type u_4} (S : Î¹ â†’ set Î±) : (â‹ƒ (i : Î¹), S i) = â‹ƒ (t : Finset Î¹) (i : Î¹) (h : i âˆˆ t), S i
{G : Type u_1} [AddGroup G] (h : AddMonoid.exponent_exists G) : AddMonoid._torsion G
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} {Sâ‚ : Setoid Î±} {Sâ‚‚ : Setoid Î²} {Sâ‚ƒ : Setoid Î³} {P : Quotient Sâ‚ â†’ Quotient Sâ‚‚ â†’ Quotient Sâ‚ƒ â†’ Prop} (qâ‚ : Quotient Sâ‚) (qâ‚‚ : Quotient Sâ‚‚) (qâ‚ƒ : Quotient Sâ‚ƒ) (h : âˆ€ (Aâ‚ : Î±) (Aâ‚‚ : Î²) (Aâ‚ƒ : Î³), P (Quotient.Mk' Aâ‚) (Quotient.Mk' Aâ‚‚) (Quotient.Mk' Aâ‚ƒ)) : P qâ‚ qâ‚‚ qâ‚ƒ
{R : Type u} {S : Type v} {A : Type W} [CommSemiring R] [CommSemiring S] [Semiring A] [Algebra R S] [Algebra S A] [Algebra R A] (h : Algebra_Map R A = (Algebra_Map S A).Comp (Algebra_Map R S)) : IsScalarTower R S A
{R : Type u_1} [Linear_ordered_Field R] [FloorRing R] {B : â„•} (hb : 1 < B) {x : â„¤} {r : R} (hr : 0 < r) : â†‘B ^ x â‰¤ r â†” x â‰¤ Int.log B r
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) [CompleteSpace â†¥K] (v : E) : âˆƒ (y : E) (h : y âˆˆ K) (z : E) (h : z âˆˆ Ká—®), v = y + z
{m : Type u_1} {N : Type u_2} [has_Mul m] [has_Mul N] {F g : m â†’â‚™* N} {S : set m} (h : set.Eq_on â‡‘F â‡‘g S) : set.Eq_on â‡‘F â‡‘g â†‘(Subsemigroup.Closure S)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (F : LocalHomeomorph E F) {F' : E â‰ƒL[ð•œ] F} {A : F} (ha : A âˆˆ F.to_local_Equiv.Target) (htff' : HasStrictFderivAt â‡‘F â†‘F' (â‡‘(F.Symm) A)) : HasStrictFderivAt â‡‘(F.Symm) â†‘(F'.Symm) A
{ð•œ : Type u_1} {E : Type u_2} [OrderedSemiring ð•œ] [AddCommGroup E] [module ð•œ E] {S t : set E} (hc : Convex_Independent ð•œ (Î» (x : â†¥t), â†‘x)) (hs : S âŠ† t) : Convex_Independent ð•œ (Î» (x : â†¥S), â†‘x)
{Î± : Type u} [TopologicalSpace Î±] [t0_Space Î±] {S : set Î±} (hfin : S.Finite) (hne : S.Nonempty) (ho : IsOpen S) : âˆƒ (x : Î±) (h : x âˆˆ S), IsOpen {x}
{Î± : Type u} [DecidableEq Î±] [Fintype Î±] {P : Equiv.perm Î± â†’ Prop} (F : Equiv.perm Î±) : P 1 â†’ (âˆ€ (F : Equiv.perm Î±) (x y : Î±), x â‰  y â†’ P F â†’ P (F * Equiv.Swap x y)) â†’ P F
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] {e : LocalHomeomorph Î± Î²} {S : set Î±} {t : set Î²} : e.to_local_Equiv.Source âˆ© â‡‘e â»Â¹' (e.to_local_Equiv.Target âˆ© t) = e.to_local_Equiv.Source âˆ© S â†’ e._image S t
{Î± : sort u_1} {Î² : sort u_2} {Î³ : sort u_3} [has_Coe Î± Î²] [has_Coe_t Î² Î³] (A : Î±) : â†‘A = â†‘â†‘A
{Î± : Type u} [PseudoMetricSpace Î±] {x : Î±} : metric.Inf_dist x âˆ… = 0
{Î± : Type u_1} [Linear_ordered_Ring Î±] [Archimedean Î±] {x y : Î±} (hx : 1 â‰¤ x) (hy : 1 < y) : âˆƒ (n : â„•), y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [CommMonoid m] {F : Î± â†’ m} {g : Î² â†’ Î±} (hg : set.inj_on g (Function.MulSupport (F âˆ˜ g))) : finprod (Î» (i : Î±), finprod (Î» (h : i âˆˆ set.Range g), F i)) = finprod (Î» (j : Î²), F (g j))
(K : Type u) (v : Type v) [DivisionRing K] [AddCommGroup v] [module K v] [IsNoetherian K v] : module.rank K v < Cardinal.aleph0
{A B C : â„¤} : fermat_42.Minimal A B C â†’ fermat_42.Minimal B A C
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] {A B : â„} (ha : 0 < A) (hb : 0 < B) (hab : A + B = 1) (h : âˆ€ (x y : E), âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥yâˆ¥ â‰¤ 1 â†’ x â‰  y â†’ âˆ¥A â€¢ x + B â€¢ yâˆ¥ < 1) : strict_Convex_Space â„ E
(n : â„•) (z : â„‚) : (Complex.cos z + Complex.sin z * Complex.i) ^ n = Complex.cos (â†‘n * z) + Complex.sin (â†‘n * z) * Complex.i
{C : Type uâ‚} [CategoryTheory.SmallCategory C] {â„° : Type uâ‚‚} [CategoryTheory.Category â„°] (A : C â¥¤ â„°) (P : Cáµ’áµ– â¥¤ Type uâ‚) (Eâ‚ Eâ‚‚ : â„°) (g : Eâ‚ âŸ¶ Eâ‚‚) {C : CategoryTheory.Limits.Cocone ((CategoryTheory.Category_of_Elements.Ï€ P).Left_Op â‹™ A)} (t : CategoryTheory.Limits.IsColimit C) (k : C.x âŸ¶ Eâ‚) : â‡‘(CategoryTheory.Colimit_Adj.Restrict_yoneda_hom_Equiv A P Eâ‚‚ t) (k â‰« g) = â‡‘(CategoryTheory.Colimit_Adj.Restrict_yoneda_hom_Equiv A P Eâ‚ t) k â‰« (CategoryTheory.Colimit_Adj.restricted_yoneda A).Map g
{L : FirstOrder.Language} {m : Type u_3} {N : Type u_4} {P : Type u_5} {q : Type u_6} [L.structure m] [L.structure N] [L.structure P] [L.structure q] (F : L.elementary_Embedding m N) (g : L.elementary_Embedding N P) (h : L.elementary_Embedding P q) : (h.Comp g).Comp F = h.Comp (g.Comp F)
{m : Type u_2} [AddCommGroup m] {A : Type u_1} [CommRing A] [module A m] (F : m â†’â‚—[A] m) (hF : IsUnit F) : IsUnit (â‡‘LinearMap.det F)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : (affine_Span k S).direction = Vector_Span k S
{Î± : Type u} [PartialOrder Î±] [OrderTop Î±] {A : Î±} : IsMax A â†’ A = âŠ¤
{Î± : Type u_1} [PseudoEmetricSpace Î±] {F : â„• â†’ Î±} (D : â„• â†’ Ennreal) (hF : âˆ€ (n : â„•), HasEdist.edist (F n) (F n.Succ) â‰¤ D n) {A : Î±} (ha : Filter.Tendsto F Filter.at_top (nhds A)) : HasEdist.edist (F 0) A â‰¤ âˆ‘' (m : â„•), D m
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (h : âˆ€ {Î¹ : Type u} (U : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ (S âŠ† â‹ƒ (i : Î¹), U i) â†’ (âˆƒ (t : Finset Î¹), S âŠ† â‹ƒ (i : Î¹) (h : i âˆˆ t), U i)) : IsCompact S
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x - y âˆˆ S
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] [CompleteSpace E] {F : â„ â†’ E} {t : â„} (hF : Function.Periodic F t) (hT : 0 < t) (t S : â„) : âˆ« (x : â„) in t..t + t, F x = âˆ« (x : â„) in S..S + t, F x
{G : Type u_1} [AddGroup G] (h : Add_Subgroup G) {x y : G} (hx : x âˆˆ h) (hy : y âˆˆ h) : x - y âˆˆ h
{u : â„• â†’ â„} (h : Subadditive u) (hbdd : BddBelow (set.Range (Î» (n : â„•), u n / â†‘n))) : Filter.Tendsto (Î» (n : â„•), u n / â†‘n) Filter.at_top (nhds h.lim)
{Î± : Type u_1} {m : Type u_5} {N : Type u_6} [AddCommMonoid m] [AddCommMonoid N] {S : set Î±} {F : Î± â†’ m} (g : m â†’+ N) (hâ‚€ : (S âˆ© Function.Support F).Finite) : â‡‘g (finsum (Î» (j : Î±), finsum (Î» (h : j âˆˆ S), F j))) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), â‡‘g (F i)))
{Î³ : Type W} [Preorder Î³] [OrderBot Î³] (S : set Î³) : BddBelow S
{Î± : Type u} [PseudoMetricSpace Î±] {S t u : set Î±} (Fin : Emetric.Hausdorff_edist S t â‰  âŠ¤) : metric.Hausdorff_dist S u â‰¤ metric.Hausdorff_dist S t + metric.Hausdorff_dist t u
{Î± : Type u_2} [DecidableEq Î±] {B : Finset (Finset Î±)} {n : â„•} [Fintype Î±] (h : âˆ€ (A : Î±), n â‰¤ (Finset.Filter (HasMem.Mem A) B).Card) : Fintype.Card Î± * n â‰¤ B.Sum (Î» (S : Finset Î±), S.Card)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y z : v} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle y z + o.oangle x y = o.oangle x z
{t : â„} {g : â„ â†’ â„} (hg : Function.Periodic g t) (h_Int : âˆ€ (tâ‚ tâ‚‚ : â„), IntervalIntegrable g MeasureTheory.MeasureSpace.Volume tâ‚ tâ‚‚) (hâ‚€ : âˆ€ (x : â„), 0 < g x) (hT : 0 < t) : Filter.Tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) Filter.at_top Filter.at_top
{Î± : Type u} (S : Finset Î±) : â†‘S.Finite
{m : Type u_3} {N : Type u_4} [Monoid m] [Monoid N] {F : Type u_1} [Monoid_hom_class F m Náµáµ’áµ–] (F : F) (l : List m) : Mul_Opposite.Unop (â‡‘F l.Prod) = (List.Map (Mul_Opposite.Unop âˆ˜ â‡‘F) l).reverse.Prod
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {F : J â¥¤ C} {x : C} (h : CategoryTheory.coyoneda.obj (Opposite.Op x) â‹™ CategoryTheory.ulift_Functor â‰… F.cocones) {Y : C} (F : x âŸ¶ Y) : CategoryTheory.Limits.IsColimit.of_Nat_iso.Cocone_of_hom h F = (CategoryTheory.Limits.IsColimit.of_Nat_iso.Colimit_Cocone h).extend F
{m : Type u_2} (R : Type u_5) [Semiring R] [AddCommMonoid m] [module R m] (S : set m) : Submodule.Span R S = (Finsupp.Total â†¥S m R Coe).Range
{R : Type u} {S : Type v} [CommSemiring R] [local_Ring R] [CommSemiring S] [local_Ring S] (F : R â†’+* S) [_local_Ring_hom F] (A : R) (h : A âˆˆ local_Ring.Maximal_Ideal R) : â‡‘F A âˆˆ local_Ring.Maximal_Ideal S
{mâ‚€ : Type u_1} [MulZeroOneClass mâ‚€] : 0 = 1 â†’ Subsingleton mâ‚€
{Î± : Type u} (L : List Î±) {i j : â„•} (h : i + j < L.length) : L.nth_LE (i + j) h = (List.Drop i L).nth_LE j _
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {n : WithTop â„•} {S : set (E Ã— F)} {P : E Ã— F} : ContDiff_within_at ð•œ n Prod.fst S P
{G : Type u_3} [Group G] : Group.fg G â†” âˆƒ (S : set G), Subgroup.Closure S = âŠ¤ âˆ§ S.Finite
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {x : E} : Differentiable_at ð•œ F x â†’ MdifferentiableAt (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F x
(R : Type u_1) (m : Type u_4) [Semiring R] [AddCommMonoid m] [module R m] (x : m) : Submodule.Span R {x} = (Linear_Map.to_Span_Singleton R m x).Range
{m n : â„•} : Even (m ^ n) â†” Even m âˆ§ n â‰  0
{F : Type u_3} [InnerProductSpace â„ F] [Finite_dimensional â„ F] : Subgroup.Closure (set.Range (Î» (v : F), reflection (Submodule.Span â„ {v})á—®)) = âŠ¤
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {x y : v} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : o.oangle x (x - y) = o.oangle (y - x) y
{R : Type u_1} [non_assoc_Ring R] [Nontrivial R] (hR : Ring_Char R â‰  2) : -1 â‰  1
{E : Type u_1} [AddCommGroup E] [Star_AddMonoid E] [module â„‚ E] [Star_module â„‚ E] (x : E) : â†‘(â‡‘Star_module.re x) + Complex.i â€¢ â†‘(â‡‘Star_module.im x) = x
{Î± : Type u} [Group Î±] [has_LE Î±] [CovariantClass Î± Î± has_Mul.Mul has_LE.LE] {A : Î±} : Aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ A
{Î± : Type u_1} {Î¹ : sort u_3} [conditionally_CompleteLattice Î±] {F g : Î¹ â†’ Î±} (B : BddBelow (set.Range F)) (h : âˆ€ (x : Î¹), F x â‰¤ g x) : infi F â‰¤ infi g
{Î± : Type u_2} [DecidableEq Î±] {B : Finset (Finset Î±)} {n : â„•} [Fintype Î±] (h : âˆ€ (A : Î±), (Finset.Filter (HasMem.Mem A) B).Card = n) : B.Sum (Î» (S : Finset Î±), S.Card) = Fintype.Card Î± * n
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {e e' : local_Equiv Î± Î²} {F F' : local_Equiv Î² Î³} (hE : e â‰ˆ e') (hF : F â‰ˆ F') : e.Trans F â‰ˆ e'.Trans F'
{Î± : Type u_1} [canonically_ordered_AddMonoid Î±] [HasSub Î±] [HasOrderedSub Î±] {A B C : Î±} [ContravariantClass Î± Î± has_Add.Add has_LE.LE] (h : C â‰¤ B) : A < B - C â†” C + A < B
{Î± : Type u} [TopologicalSpace Î±] [t1_Space Î±] [âˆ€ (x : Î±), (nhds_within x {x}á¶œ).Ne_IsBot] {S : set Î±} (hs : Dense S) {t : set Î±} (ht : t.Finite) : Dense (S  t)
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î²] {F : Î± â†’ Î²} {S : set Î±} {x : Î±} [TopologicalSpace Î±] (hx : x âˆˆ S) (L : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ Uniformity Î² â†’ (âˆƒ (t : set Î±) (h : t âˆˆ nhds_within x S) (F : Î± â†’ Î²), Continuous_within_at F S x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (F y, F y) âˆˆ u)) : Continuous_within_at F S x
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {S : Finset Î¹} {W : Î¹ â†’ k} (h : S.Sum (Î» (i : Î¹), W i) = 0) (P : Î¹ â†’ P) : â‡‘(S.weighted_vsub P) W âˆˆ Vector_Span k (set.Range P)
{ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [OrderedSemiring ð•œ] [AddCommMonoid E] [ordered_AddCommGroup Î²] [HasScalar ð•œ E] [module ð•œ Î²] {S : set E} {F : E â†’ Î²} : strict_ConcaveOn ð•œ S (-F) â†” strict_Convex_on ð•œ S F
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace â„ E] {F : â„ â†’ E} {ca cb : E} {A B : â„} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds A âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb : Filter.Tendsto F (nhds B âŠ“ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) : fderiv â„ (Î» (P : â„ Ã— â„), âˆ« (x : â„) in P.fst..P.Snd, F x) (A, B) = (Continuous_Linear_Map.Snd â„ â„ â„).Smul_Right cb - (Continuous_Linear_Map.fst â„ â„ â„).Smul_Right ca
{Î± : Type u} {A B : Î±} [Mul_Zero_class Î±] [Preorder Î±] [Zero_LT.Mul_Pos_StrictMono Î±] (ha : 0 < A) (hb : 0 < B) : 0 < A * B
{Î± : Type u_1} [AddZeroClass Î±] [Preorder Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B : Î±} (ha : A â‰¤ 0) (hb : B < 0) : A + B < 0
{Î± : Type u_1} [conditionally_CompleteLattice Î±] (A : Î±) : HasSup.Sup {A} = A
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] [Fintype Î±] [Fintype Î²] (F : Î± â†’ Î²) {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] [Nonempty Î²] (hb : Finset.Univ.Sum (Î» (x : Î±), W x) â‰¤ Fintype.Card Î² â€¢ B) : âˆƒ (y : Î²), (Finset.Filter (Î» (x : Î±), F x = y) Finset.Univ).Sum (Î» (x : Î±), W x) â‰¤ B
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [NoMaxOrder Î±] [DenselyOrdered Î±] {A : Î±} {S : set Î±} : S âˆˆ nhds_within A (set.ici A) â†” âˆƒ (u : Î±), A < u âˆ§ set.icc A u âŠ† S
{ð•œ : Type u_1} {F : Type u_3} [_R_or_C ð•œ] [AddCommGroup F] [module ð•œ F] [C : InnerProductSpace.core ð•œ F] (x y : F) : _R_or_C.Abs (HasInner.inner x y) * _R_or_C.Abs (HasInner.inner y x) â‰¤ â‡‘_R_or_C.re (HasInner.inner x x) * â‡‘_R_or_C.re (HasInner.inner y y)
{Î± : Type u_1} [LinearOrder Î±] [PredOrder Î±] [_Pred_Archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (hr : Reflexive r) (h1 : âˆ€ (i : Î±), i âˆˆ set.ioc m n â†’ r i (Order.Pred i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.ioc n m â†’ r (Order.Pred i) i) : Relation.TransGen r n m
{R : Type v} [CommRing R] {n : Type u_1} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) : A.det = A Inhabited.Default Inhabited.Default
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x âŸ¶ Y} (hâ‚€ : F = g) {C : CategoryTheory.Limits.Cofork F g} (h : CategoryTheory.Limits.IsColimit C) : CategoryTheory.IsIso C.Ï€
{x : â„} (hx : 0 â‰¤ x) : x + 1 â‰¤ Real.Exp x
(P : â„•) [hp : Fact (Nat.Prime P)] {q r : â„š} (hne : padic_norm P q â‰  padic_norm P r) : padic_norm P (q + r) = LinearOrder.max (padic_norm P q) (padic_norm P r)
 : fib_rec._solution (has_Pow.Pow golden_Conj)
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (h : â†‘(S.topological_Closure) â‰  set.Univ) : âˆ¥S.normed_Mkâˆ¥ = 1
{G : Type u_1} [Group G] (h : â„• â†’ Subgroup G) (hH : IsAscendingCentralSeries h) (n : â„•) : h n â‰¤ upper_central_series G n
{G : Type W} [TopologicalSpace G] [AddGroup G] [topological_AddGroup G] {m : Type u_1} {hom : Type u_2} [AddZeroClass m] [TopologicalSpace m] [has_Continuous_Add m] [AddMonoid_hom_class hom G m] (F : hom) (hF : Continuous_at â‡‘F 0) : Continuous â‡‘F
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] [LocallyCompactSpace Î±] [t2_Space Î±] [t2_Space Î²] {Î¹ : Type u_3} {l : Filter Î¹} [l.Ne_IsBot] (F : Î¹ â†’ C(Î±, Î²)) : (âˆƒ (F : C(Î±, Î²)), Filter.Tendsto F l (nhds F)) â†” âˆ€ (S : set Î±), IsCompact S â†’ (âˆƒ (F : C(â†¥S, Î²)), Filter.Tendsto (Î» (i : Î¹), Continuous_Map.Restrict S (F i)) l (nhds F))
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {S : set E} (hscomp : IsCompact S) (hAconv : Convex â„ S) : Closure (â‡‘(Convex_hull â„) (set.ExtremePoints â„ S)) = S
{ð•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [DecidableEq Î¹] [Fintype Î¹] [nondiscrete_NormedField ð•œ] [Î  (i : Î¹), NormedGroup (E i)] [Î  (i : Î¹), NormedSpace ð•œ (E i)] [NormedGroup G] [NormedSpace ð•œ G] (F : MultilinearMap ð•œ E G) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘F mâˆ¥ â‰¤ C * Finset.Univ.Prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥F.Mk_Continuous C hâˆ¥ â‰¤ C
{Î± : Type u} {Î² : Type v} [Linear_ordered_Field Î±] [TopologicalSpace Î±] [OrderTopology Î±] {l : Filter Î²} {F g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hF : Filter.Tendsto F l Filter.at_top) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (Î» (x : Î²), F x * g x) l Filter.at_top
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) : hb.Conj_lie.Symm = hb.Conj_lie
{Î¹ : Type u} {F g : Î¹ â†’ â„} {P q : â„} (hpq : P.IsConjugateExponent q) {A B : â„} (hA : 0 â‰¤ A) (hB : 0 â‰¤ B) (hF : âˆ€ (i : Î¹), 0 â‰¤ F i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) (hF_Sum : has_Sum (Î» (i : Î¹), F i ^ P) (A ^ P)) (hg_Sum : has_Sum (Î» (i : Î¹), g i ^ q) (B ^ q)) : âˆƒ (C : â„), 0 â‰¤ C âˆ§ C â‰¤ A * B âˆ§ has_Sum (Î» (i : Î¹), F i * g i) C
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} : Transitive (CategoryTheory.Abelian.PseudoEqual P)
{L : FirstOrder.Language} {m : Type W} [L.structure m] {S : set m} : S âŠ† â†‘(â‡‘(FirstOrder.Language.Substructure.Closure L) S)
{g : Matrix.special_Linear_Group (Fin 2) â„¤} (z : UpperHalfPlane) {P : Fin 2 â†’ â„¤} (hp : _IsCoprime (P 0) (P 1)) (hg : â†‘g 1 = P) : â†‘(g â€¢ z) = â†‘(â‡‘(modular_Group.lc_row0 P) â†‘â†‘g) / (â†‘(P 0) ^ 2 + â†‘(P 1) ^ 2) + (â†‘(P 1) * â†‘z - â†‘(P 0)) / ((â†‘(P 0) ^ 2 + â†‘(P 1) ^ 2) * (â†‘(P 0) * â†‘z + â†‘(P 1)))
{B : Type u_3} {S : B} {m : Type u_1} [CommMonoid m] [set_like B m] [Submonoid_class B m] {Î¹ : Type u_2} {t : Finset Î¹} {F : Î¹ â†’ m} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ S) : t.Prod (Î» (C : Î¹), F C) âˆˆ S
(F : â„ â†’ â„) {A B : â„} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfd : DifferentiableOn â„ F (set.Ioo A B)) (g : â„ â†’ â„) (hgc : Continuous_on g (set.icc A B)) (hgd : DifferentiableOn â„ g (set.Ioo A B)) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), (g B - g A) * deriv F C = (F B - F A) * deriv g C
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) (hp : 0 < P.radius) : 0 < (P.Right_Inv i).radius
{A : Type u_2} [CommRing A] [IsDomain A] : IsDedekindDomain A â†” IsDedekindDomain_Inv A
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (v : v) (nz : v â‰  0) : Finite_dimensional.finrank K v = 1 â†” Submodule.Span K {v} = âŠ¤
{v : Type u_1} [InnerProductSpace â„ v] (x y : v) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” InnerProductGeometry.angle x y = Real.Pi / 2
{m : Type u_1} [has_Mul m] {r S : m â†’ m â†’ Prop} (h : âˆ€ (x y : m), r x y â†’ S x y) : Con_gen r â‰¤ Con_gen S
(x : AlgebraicGeometry.LocallyRingedSpace) (r : â†¥(AlgebraicGeometry.LocallyRingedSpace.Î“.obj (Opposite.Op x))) : x.toÎ“_spec_Map_basic_IsOpen r = x.to_RingedSpace.basic_IsOpen r
{Î± : Type u} {A B : Î±} [MulZeroOneClass Î±] [PartialOrder Î±] [Zero_LT.Mul_Pos_Mono Î±] (ha : 1 â‰¤ A) (hb : 1 â‰¤ B) (B0 : 0 â‰¤ B) : 1 â‰¤ A * B
{n : â„•} (hn : Even n) : Convex_on â„ set.Univ (Î» (x : â„), x ^ n)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {n : â„•} (hs : IsOpen S) : ContDiff_on ð•œ â†‘(n + 1) F S â†” DifferentiableOn ð•œ F S âˆ§ ContDiff_on ð•œ â†‘n (Î» (y : E), fderiv ð•œ F y) S
{Î± : Type u_1} [DecidableEq Î±] {S t u : Multiset Î±} : S - t â‰¤ u â†” S â‰¤ u + t
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [TopologicalSpace Î²] [LocallyCompactSpace Î±] : Continuous Coe_fn
{Î± : Type u} [TopologicalSpace Î±] [RegularSpace Î±] {x y : Î±} (h : x â‰  y) : âˆƒ (Uâ‚ : set Î±) (h : Uâ‚ âˆˆ nhds x) (vâ‚ : set Î±) (h : vâ‚ âˆˆ nhds x) (Uâ‚‚ : set Î±) (h : Uâ‚‚ âˆˆ nhds y) (vâ‚‚ : set Î±) (h : vâ‚‚ âˆˆ nhds y), IsClosed vâ‚ âˆ§ IsClosed vâ‚‚ âˆ§ IsOpen Uâ‚ âˆ§ IsOpen Uâ‚‚ âˆ§ vâ‚ âŠ† Uâ‚ âˆ§ vâ‚‚ âŠ† Uâ‚‚ âˆ§ Uâ‚ âˆ© Uâ‚‚ = âˆ…
{Î± : Type u_1} [comm_Semigroup Î±] {A B : Î±} (h : A âˆ£ B) (C : Î±) : A âˆ£ C * B
{Gâ‚€ : Type u_1} {Gâ‚€' : Type u_2} [Group_with_Zero Gâ‚€] [Group_with_Zero Gâ‚€'] (F : Gâ‚€ â†’*â‚€ Gâ‚€') (x : Gâ‚€) (n : â„¤) : â‡‘F (x ^ n) = â‡‘F x ^ n
{Î± : Type u} {Î² : Type v} {Î³ : Type W} [Preorder Î±] [Preorder Î²] [Preorder Î³] {F : Î± â†’ Î² â†’ Î³} {S : set Î±} {t : set Î²} (hâ‚€ : âˆ€ (B : Î²), Monotone (Function.Swap F B)) (hâ‚ : âˆ€ (A : Î±), Monotone (F A)) : BddBelow S â†’ BddBelow t â†’ BddBelow (set.image2 F S t)
{P : â„• â†’ Prop} [Decidable_Pred P] {n : â„•} : Â¬P n â†’ Nat.count P (n + 1) = Nat.count P n
{m : Type u_1} [Group m] (C : Con m) {W x y z : m} : â‡‘C W x â†’ â‡‘C y z â†’ â‡‘C (W / y) (x / z)
{Î± : Type u} [AddCommGroup Î±] : _AddGroup_hom HasNeg.Neg
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [module k E] [AddTorsor E PE] (F : k â†’ PE) (A B r : k) : â‡‘(affine_Map.line_Map (slope F (â‡‘(affine_Map.line_Map A B) r) B) (slope F A (â‡‘(affine_Map.line_Map A B) r))) r = slope F A B
 : âˆƒ (F : Nat.Partrec.Code â†’ â„• â†’ Nat.Partrec.Code), Computableâ‚‚ F âˆ§ âˆ€ (C : Nat.Partrec.Code) (n x : â„•), (F C n).Eval x = C.Eval (Nat.mkpair n x)
{k : Type u_1} {v : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype Î¹] {P : Î¹ â†’ P} (hi : AffineIndependent k P) {n : â„•} (hc : Fintype.Card Î¹ = n + 1) : Finite_dimensional.finrank k â†¥(Vector_Span k (set.Range P)) = n
{Î± : Type u} {Lâ‚ Lâ‚‚ : List (Î± Ã— Bool)} : free_Group.red Lâ‚ Lâ‚‚ â†’ Lâ‚‚ <+ Lâ‚
(P q : â„•) [Fact (Nat.Prime P)] [Fact (Nat.Prime q)] (hp1 : P â‰  2) (hq1 : q â‰  2) (hpq : P â‰  q) : Zmod.legendre_Sym q â†‘P * Zmod.legendre_Sym P â†‘q = (-1) ^ (P / 2 * (q / 2))
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : C(x, â„)) {t : set â„} {e : x â†’ Y} [hs : t.Ord_connected] (hF : âˆ€ (x : x), â‡‘F x âˆˆ t) (hne : t.Nonempty) (hE : IsClosed_Embedding e) : âˆƒ (g : C(Y, â„)), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ â‡‘g âˆ˜ e = â‡‘F
{K : Type u} {A : Type v} [Field K] [Ring A] [Algebra K A] {x : A} : IsAlgebraic K x â†” IsIntegral K x
{Î± : Type u_1} [MeasurableSpace Î±] [Measurable_Singleton_class Î±] {S : set Î±} (u t : set Î±) (hs : S.Finite) : â‡‘(ProbabilityTheory.Cond_count (S âˆ© u)) t * â‡‘(ProbabilityTheory.Cond_count S) u + â‡‘(ProbabilityTheory.Cond_count (S âˆ© uá¶œ)) t * â‡‘(ProbabilityTheory.Cond_count S) uá¶œ = â‡‘(ProbabilityTheory.Cond_count S) t
{Î± : Type u_1} [Semigroup Î±] {A B : Î±} (h : A âˆ£ B) (C : Î±) : A âˆ£ B * C
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {vâ‚ vâ‚‚ : m} (h : SameRay R vâ‚ vâ‚‚) : âˆƒ (u : m) (A B : R), 0 â‰¤ A âˆ§ 0 â‰¤ B âˆ§ A + B = 1 âˆ§ vâ‚ = A â€¢ u âˆ§ vâ‚‚ = B â€¢ u
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {n : â„•} (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A âˆˆ t) (hn : t.Card * n < S.Card) : âˆƒ (y : Î²) (h : y âˆˆ t), n < (Finset.Filter (Î» (x : Î±), F x = y) S).Card
{Î± : Type u} [Preorder Î±] {A : Î±} {S t P : set Î±} (hs : IsLub S A) (hp : IsLub P A) (hst : S âŠ† t) (htp : t âŠ† P) : IsLub t A
(n : â„•) (R : Type u_1) [Ring R] : Polynomial.Map (Int.cast_Ring_hom R) (Polynomial.cyclotomic n â„¤) = Polynomial.cyclotomic n R
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F = 2) {A : F} (ha : A â‰  0) : Char.quadratic_Char F A = 1
{R : Type u} {Î¹ : Type W} (S : Finset Î¹) [CommSemiring R] [no_Zero_divisors R] (F : Î¹ â†’ Polynomial R) (h : âˆ€ (i : Î¹), i âˆˆ S â†’ F i â‰  0) : (S.Prod (Î» (i : Î¹), F i)).Nat_degree = S.Sum (Î» (i : Î¹), (F i).Nat_degree)
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F g : â„ â†’ E} {x : â„} (F_Diff : âˆ€ (y : â„), y â‰  x â†’ HasDerivAt F (g y) y) (hF : Continuous_at F x) (hg : Continuous_at g x) : HasDerivAt F (g x) x
{E : Type u_2} [NormedGroup E] [NormedSpace â„ E] {r : â„} (hr : 0 â‰¤ r) (x : E) : x +áµ¥ r â€¢ metric.IsClosed_ball 0 1 = metric.IsClosed_ball x r
(n k : â„•) : n.asc_factorial k = (n + k).factorial / n.factorial
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) {râ‚ râ‚‚ : â„} : 2 â€¢ hb.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
{v : Type u} [Fintype v] {G : SimpleGraph v} [Decidable_Rel G.Adj] {v W : v} (h : G.Adj v W) : Fintype.Card â†¥(G.CommonNeighbors v W) < G.degree v
{R : Type u} [CommRing R] {n : Type W} [DecidableEq n] [Fintype n] (m : Matrix n n R) : â‡‘(Polynomial.aeval m) m.charpoly = 0
(C : Type u_1) [CategoryTheory.Category C] : CategoryTheory.IsIdempotentComplete C â†” âˆ€ (x : C) (P : x âŸ¶ x), P â‰« P = P â†’ CategoryTheory.Limits.HasEqualizer (ðŸ™ x) P
(ð•œ : Type v) [_R_or_C ð•œ] {E : Type u} [NormedGroup E] [NormedSpace ð•œ E] (x : E) : âˆƒ (g : E â†’L[ð•œ] ð•œ), âˆ¥gâˆ¥ â‰¤ 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
{Î± : Type u} [PseudoEmetricSpace Î±] (E : set Î±) : Closure E = â‹‚ (Î´ : â„) (h : 0 < Î´), Metric.Thickening Î´ E
{R : Type u} [Semiring R] {A B : AddMonoid_Algebra R â„•} : {to_Finsupp := A} = {to_Finsupp := B} â†” A = B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {n : WithTop â„•} {F : F â†’ G} {x : E Ã— F} (hF : ContDiff_at ð•œ n F x.Snd) : ContDiff_at ð•œ n (Î» (x : E Ã— F), F x.Snd) x
(n : â„•) : Finset.Univ = Finset.Cons 0 (Finset.Map {ToFun := Fin.Succ n, inj' := _} Finset.Univ) _
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} (F : Î² â†’ Î± â†’ Î²) (B : Î²) (v : Vector Î± n) : (Vector.scanl F B v).head = B
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [SuccOrder Î±] [IsSuccArchimedean Î±] [LinearOrder Î²] {F : Î± â†’ Î²} (hF : Monotone F) (m n : Î±) : (â‹ƒ (i : Î±) (h : i âˆˆ set.Ico m n), set.ioc (F i) (F (Order.Succ i))) = set.ioc (F m) (F n)
{n m : â„•} (h : n â‰  m) : _IsCoprime (Polynomial.cyclotomic n â„š) (Polynomial.cyclotomic m â„š)
{Î¹ : Type u} (S : Finset Î¹) (W z : Î¹ â†’ Nnreal) (hw' : S.Sum (Î» (i : Î¹), W i) = 1) (n : â„•) : S.Sum (Î» (i : Î¹), W i * z i) ^ n â‰¤ S.Sum (Î» (i : Î¹), W i * z i ^ n)
{R : Type u_4} {S : Type u_5} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R â‰ƒ+* S) : â†‘F.to_AddMonoid_hom = â†‘F.to_AddMonoid_hom
{n : Type u'} {Î± : Type v} [Fintype n] [DecidableEq n] [CommRing Î±] (A : Matrix n n Î±) (h : IsUnit A.det) : Aâ»Â¹.Mul A = 1
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x : Î±} {r : â„} (hs : S.Nonempty) : metric.Inf_dist x S < r â†” âˆƒ (y : Î±) (h : y âˆˆ S), HasDist.dist x y < r
{m : Type u_1} [AddCommMonoid m] {S : set m} (hs : _Add_Submonoid S) (m : Multiset m) : (âˆ€ (A : m), A âˆˆ m â†’ A âˆˆ S) â†’ m.Sum âˆˆ S
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R â†’+* S} {S : S} (h : S âˆˆ set.Range â‡‘F) : â‡‘Polynomial.C S âˆˆ Polynomial.lifts F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : (S1 âŠ“ S2).direction â‰¤ S1.direction âŠ“ S2.direction
{P : â„•} (hp : 1 < P) : padic_val_rat P â†‘P = 1
{Î± : Type u} {lâ‚ lâ‚‚ : List Î±} {n : â„•} : List.take n (lâ‚ ++ lâ‚‚) = List.take n lâ‚ ++ List.take (n - lâ‚.length) lâ‚‚
 : set.inj_on Nat.factorization {x : â„• | x â‰  0}
{m : Type u_1} [AddZeroClass m] (S : Add_Submonoid m) : S = âŠ¥ âˆ¨ Nontrivial â†¥S
{ð•œ : Type u_1} {E : Type u_2} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] {x : E} {S : set E} : Star_Convex ð•œ x S â†” âˆ€ â¦ƒy : Eâ¦„, y âˆˆ S â†’ âˆ€ â¦ƒA B : ð•œâ¦„, 0 â‰¤ A â†’ 0 â‰¤ B â†’ 0 < A + B â†’ (A / (A + B)) â€¢ x + (B / (A + B)) â€¢ y âˆˆ S
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * HasInner.inner x y + âˆ¥yâˆ¥ ^ 2
{Î² : Type u} {Î± : Type v} [CommMonoid Î²] [Fintype Î±] [DecidableEq Î±] (S : Finset Î±) (F : Î± â†’ Î²) : S.Prod (Î» (i : Î±), F i) * Sá¶œ.Prod (Î» (i : Î±), F i) = Finset.Univ.Prod (Î» (i : Î±), F i)
{Î± : Type uu} {r : Î± â†’ Î± â†’ Prop} [Decidable_Rel r] {l : List Î±} (h : List.Sorted r l) : List.insertion_sort r l = l
{Î± : Type u} [HasSubset Î±] {A B : Î±} [IsAntisymm Î± HasSubset.Subset] (h : A âŠ† B) (h' : B âŠ† A) : B = A
{x k l : â„•} (W : 1 < x) : x ^ k âˆ£ x ^ l â†” k â‰¤ l
{Î± : Type u_1} [IsEmpty Î±] : Finset.Univ = âˆ…
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z â†’ B} [TopologicalSpace Z] [Nonempty F] (h : IsTopologicalFiberBundle F Proj) : Function.Surjective Proj
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (m N P : Matrix m m R) : ((m.Mul N).Mul P).det = ((m.Mul P).Mul N).det
{Î± : Type u} {Î² : Type v} [Group Î±] [MulAction Î± Î²] (g : Î±) (x : Î²) : MulAction.Stabilizer Î± (g â€¢ x) = Subgroup.Map (Mul_Equiv.to_Monoid_hom (â‡‘Mul_aut.Conj g)) (MulAction.Stabilizer Î± x)
{n : â„•} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : â‡‘Fin.cast_Succ j < i) : SimplexCategoryÎ´ i.Succ â‰« SimplexCategoryÏƒ (â‡‘Fin.cast_Succ j) = SimplexCategoryÏƒ j â‰« SimplexCategoryÎ´ i
{ð•œ : Type u_3} {E : Type u_4} [NormedField ð•œ] [semi_NormedGroup E] [NormedSpace ð•œ E] {r : â„} : Balanced ð•œ (Metric.Ball 0 r)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {F : Î± â†’ Î²} {P : Filter Î¹} (h : TendstoUniformly F F P) (x : Î±) : Filter.Tendsto (Î» (n : Î¹), F n x) P (nhds (F x))
{K : Type u} [Field K] {S t : Subfield K} (h : âˆ€ (x : K), x âˆˆ S â†” x âˆˆ t) : S = t
{Î± : Type u_3} {Î² : Type u_4} [Linear_ordered_Field Î±] {l : Filter Î²} {F : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (Î» (x : Î²), F x * r) l Filter.at_IsBot
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] [âˆ€ {x Y : C} (F : x âŸ¶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimage_image_comparison F)] : CategoryTheory.Limits.HasImages C
{R : Type u} {Aâ‚ : Type v} {Aâ‚‚ : Type W} [CommSemiring R] [Semiring Aâ‚] [Semiring Aâ‚‚] [Algebra R Aâ‚] [Algebra R Aâ‚‚] (e : Aâ‚ â‰ƒâ‚[R] Aâ‚‚) : â†‘â†‘e = â†‘â†‘e
{m : Type u_1} [AddZeroClass m] (C : Add_Con m) : Add_Con.Ker C.Mk' = C
{J : Type v} [CategoryTheory.SmallCategory J] (F : J â¥¤ Mon_) [CategoryTheory.IsFiltered J] (x y : Î£ (j : J), â†¥(F.obj j)) (k : J) (F : x.fst âŸ¶ k) (g : y.fst âŸ¶ k) : Mon_.FilteredColimits.m.Mk F x * Mon_.FilteredColimits.m.Mk F y = Mon_.FilteredColimits.m.Mk F âŸ¨k, â‡‘(F.Map F) x.Snd * â‡‘(F.Map g) y.SndâŸ©
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} {x : Î±} (h : IsClosed S) (hs : S.Nonempty) : x âˆ‰ S â†” 0 < metric.Inf_dist x S
(cf cg : Nat.Partrec.Code) (A k : â„•) : (cf.prec cg).Eval (Nat.mkpair A k.Succ) = (cf.prec cg).Eval (Nat.mkpair A k) >>= Î» (ih : â„•), cg.Eval (Nat.mkpair A (Nat.mkpair k ih))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {F : Type u_2} [NormedGroup F] [NormedSpace ð•œ F] {n : â„•} {F : ð•œ â†’ F} : iterated_deriv n F = â‡‘((Continuous_MultilinearMap.Pi_Field_Equiv ð•œ (Fin n) F).Symm) âˆ˜ iterated_fderiv ð•œ n F
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] {F : Î± â†’ Î² Ã— Î³} {x : Î±} (hF : Continuous_at F x) : Continuous_at (Î» (A : Î±), (F A).fst) x
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z â†’ B} [TopologicalSpace Z] [Nonempty F] (h : IsTopologicalFiberBundle F Proj) : QuotientMap Proj
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] {A B : Î±} (hab : A â‰  B) : Closure (set.Ioo A B) = set.icc A B
{m : Type u_3} {N : Type u_4} [MulZeroOneClass m] [MulZeroOneClass N] {F g : m â†’*â‚€ N} : F = g â†” âˆ€ (x : m), â‡‘F x = â‡‘g x
{Î± : Type u_1} [has_LT Î±] {A B : Î±} {o : Ordering} : o.compares B A â†’ o.Swap.compares A B
{Î± : Type u} [Group Î±] (g : Group_topology Î±) : Continuous (Î» (P : Î± Ã— Î±), P.fst * P.Snd)
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} : Metric.Bounded (S âˆª t) â†” Metric.Bounded S âˆ§ Metric.Bounded t
{x : Type u} [Preorder x] {x y : x} (h : x âŸ¶ y) : x â‰¤ y
{v : Type u} [Quiver v] (r : v) [Quiver.RootedConnected r] {A : v} (P : Quiver.Path r A) : (Quiver.shortest_Path r A).length â‰¤ P.length
{ð•œ : Type u_1} [_R_or_C ð•œ] {m : Type u_5} {n : Type u_6} [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (A : Matrix m n ð•œ) : â‡‘Matrix.to_lin' A.Conj_transpose = â‡‘LinearMap.Adjoint (â‡‘Matrix.to_lin' A)
{Î± : Type u} [PseudoMetricSpace Î±] {x y : Î±} : metric.Inf_dist x {y} = HasDist.dist x y
{R : Type u_1} {A B : R} [Semigroup R] (Ab : IsRegular (A * B)) (ba : IsRegular (B * A)) : IsRegular A âˆ§ IsRegular B
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [SuccOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Monotone F) : Pairwise (Disjoint on Î» (n : Î±), set.Ico (F n) (F (Order.Succ n)))
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Mul_Pos_StrictMono Î±] (ha : 1 < A) (hb : 1 < B) (B0 : 0 < B) : 1 < A * B
{Î± : Type u_1} [has_LT Î±] {A B : Î±} : B < A â†’ â‡‘order_dual.to_dual A < â‡‘order_dual.to_dual B
{Î± : Type u} [AddGroup Î±] [has_LT Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LT.LT] {A B : Î±} : A < B â†’ A - B < 0
(R : Type u_1) [has_One R] [HasNeg R] : Cardinal.Mk (Quaternion R) = Cardinal.Mk R ^ 4
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [DecidableEq Î²'] [DecidableEq Î³] [DecidableEq Î´] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²' â†’ Î³} {g : Î² â†’ Î²'} {F' : Î± â†’ Î² â†’ Î´} {g' : Î´ â†’ Î³} (h_Right_comm : âˆ€ (A : Î±) (B : Î²), F A (g B) = g' (F' A B)) : Finset.imageâ‚‚ F S (Finset.image g t) = Finset.image g' (Finset.imageâ‚‚ F' S t)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) : hb.oangle y x = -hb.oangle x y
{F : â„ â†’ â„} {A : â„} (h : IsLocalMin F A) : deriv F A = 0
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] {n : Type W} [Nontrivial R] {B : BilinForm R m} {v : Basis n R m} (h : B._Ortho â‡‘v) (hB : B.nondegenerate) (i : n) : Â¬B.IsOrtho (â‡‘v i) (â‡‘v i)
{Î¹ : Type u_1} {Râ‚‚ : Type u_7} {mâ‚‚ : Type u_8} [CommRing Râ‚‚] [AddCommGroup mâ‚‚] [module Râ‚‚ mâ‚‚] [DecidableEq Î¹] (e : Basis Î¹ Râ‚‚ mâ‚‚) {W : Î¹ â†’ Râ‚‚} (hw : âˆ€ (i : Î¹), IsUnit (W i)) : e.to_Matrix â‡‘(e.IsUnit_Smul hw) = Matrix.Diagonal W
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x : L} : x âˆˆ S â†’ -x âˆˆ S
{A B : Prop} (hâ‚ : A â†’ B) (hâ‚‚ : Â¬B) : Â¬A
{Î± : Type u_2} [Bornology Î±] {S : set Î±} : Bornology._cobounded S â†’ Bornology._bounded Sá¶œ
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {ð•œ : Type u_3} {G : Type u_4} [_R_or_C ð•œ] [NormedSpace ð•œ E] [NormedGroup G] [NormedSpace ð•œ G] {F : E â†’ G} {S : set E} {C : Nnreal} (hF : DifferentiableOn ð•œ F S) (bound : âˆ€ (x : E), x âˆˆ S â†’ âˆ¥fderiv_within ð•œ F S xâˆ¥â‚Š â‰¤ C) (hs : Convex â„ S) : LipschitzOnWith C F S
{m : Type u} [MulOneClass m] (A : m) : SemiconjBy A 1 1
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {F G : C â¥¤ D} (Î± : F âŸ¶ G) [âˆ€ (x : C), CategoryTheory.Mono (Î±.App x)] : CategoryTheory.Mono Î±
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {F : m â†’* N} (h : âˆ€ (y : â†¥S), IsUnit (â‡‘F â†‘y)) (y : â†¥S) (W z : N) : W * â†‘(â‡‘(IsUnit.Lift_Right (F.Restrict S) h) y)â»Â¹ = z â†” W = â‡‘F â†‘y * z
{K : Type u} [Field K] (S : Subfield K) : 1 âˆˆ S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] (O : Finset C) : âˆƒ (S : C), âˆ€ {x : C}, x âˆˆ O â†’ Nonempty (S âŸ¶ x)
{Î± : Type u_1} {Î² : Type u_2} {Op : Î² â†’ Î² â†’ Î²} [hc : IsCommutative Î² Op] [ha : IsAssociative Î² Op] {F : Î± â†’ Î²} {B : Î²} {S : Finset Î±} {g : Î± â†’ Î²} (hb : Op B B = B) (P : Î± â†’ Prop) [Decidable_Pred P] : Finset.Fold Op B (Î» (i : Î±), Ite (P i) (F i) (g i)) S = Op (Finset.Fold Op B F (Finset.Filter P S)) (Finset.Fold Op B g (Finset.Filter (Î» (i : Î±), Â¬P i) S))
{F : Type u_1} [Field F] [Fintype F] : IsSquare (-1) â†” Fintype.Card F % 4 â‰  3
(F : â†¥(MeasureTheory.Lp â„‚ 2 haar_Circle)) : has_Sum (Î» (i : â„¤), â‡‘(â‡‘(fourier_series.repr) F) i â€¢ fourier_Lp 2 i) F
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [DivisionRing K] : g.convergents' (n + 1) = (g.squash_gcf n).convergents' n
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {Î¹ : Type u_1} (B : Basis Î¹ R m) (h : module.rank R m < Cardinal.aleph0) : Nonempty (Fintype Î¹)
{E : Type u} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {C : â„‚} {r R : â„} (h0 : 0 < r) (hle : r â‰¤ R) {F : â„‚ â†’ E} {S : set â„‚} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C R  Metric.Ball C r)) (hD : âˆ€ (z : â„‚), z âˆˆ Metric.Ball C R  metric.IsClosed_ball C r  S â†’ Differentiable_at â„‚ F z) : âˆ® (z : â„‚) in C(C, R), (z - C)â»Â¹ â€¢ F z = âˆ® (z : â„‚) in C(C, r), (z - C)â»Â¹ â€¢ F z
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) (i : Fin (n + 1)) : S.points_with_circumcenter (Affine.Simplex.points_with_circumcenter_Index.point_Index i) = S.points i
{C : Type uâ‚} [CategoryTheory.Category C] (x : Type vâ‚) [CategoryTheory.Limits.HasProducts_of_shape x C] : CategoryTheory.Limits.HasCoproductsOfShape x Cáµ’áµ–
{Î± : Type u_1} [TopologicalSpace Î±] {Î³ : Type u_4} [Linear_ordered_AddCommMonoid Î³] [TopologicalSpace Î³] [OrderTopology Î³] {F g : Î± â†’ Î³} (hF : LowerSemicontinuous F) (hg : LowerSemicontinuous g) (hcont : âˆ€ (x : Î±), Continuous_at (Î» (P : Î³ Ã— Î³), P.fst + P.Snd) (F x, g x)) : LowerSemicontinuous (Î» (z : Î±), F z + g z)
{Î² : Type u_2} [EmetricSpace Î²] {A : Î²} {r : Ennreal} (x y : â†¥(Emetric.Ball A r)) : HasEdist.edist x.val y.val â‰  âŠ¤
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A B C : Î±} : A + B â‰¤ C â†’ B â‰¤ -A + C
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} (h : IsTotallySeparated S) : IsTotallyDisconnected S
{ð•œ : Type u_1} {E : Type u_2} [NormedField ð•œ] [AddCommGroup E] [module ð•œ E] [TopologicalSpace E] [has_Continuous_Smul ð•œ E] (x : E) : Bornology._vonN_bounded ð•œ {x}
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B : Î±} (ha : A < 0) (hb : B < 0) : 1 / A â‰¤ 1 / B â†” B â‰¤ A
{Î± : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [AddCommMonoid N] {S : Finset Î±} {F : Î± â†’ m} {g : Î± â†’ m â†’ N} (hF : âˆ€ (A : Î±), F A â‰  0 â†’ A âˆˆ S) (hg : âˆ€ (A : Î±), g A 0 = 0) : (Finsupp.on_Finset S F hF).Sum g = S.Sum (Î» (A : Î±), g A (F A))
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [TopologicalSpace Î²] {S : set Î±} {t : set Î²} : IsOpen (S Ã—Ë¢ t) â†” IsOpen S âˆ§ IsOpen t âˆ¨ S = âˆ… âˆ¨ t = âˆ…
{Î± : Type u_1} {Î¹ : Type u_2} {Î² : Type u_3} {S : Î¹ â†’ set Î±} {F : Î  (i : Î¹), â†¥(S i) â†’ Î²} {hF : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), F i âŸ¨x, hxiâŸ© = F j âŸ¨x, hxjâŸ©} {t : set Î±} {hT : t âŠ† set.Union S} (C : â†¥t) (ci : Î  (i : Î¹), â†¥(S i)) (hci : âˆ€ (i : Î¹), â†‘(ci i) = â†‘C) (CÎ² : Î²) (h : âˆ€ (i : Î¹), F i (ci i) = CÎ²) : set.Union_Lift S F hF t hT C = CÎ²
{G : Type u_1} [AddGroup G] {k : set G} {P : G â†’ Prop} {x : G} (h : x âˆˆ Add_Subgroup.Closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ P x) (h1 : P 0) (HMul : âˆ€ (x y : G), P x â†’ P y â†’ P (x + y)) (Hinv : âˆ€ (x : G), P x â†’ P (-x)) : P x
{x : top} (F : top.Presheaf (Type v) x) : F._sheaf â†” F._sheaf_Unique_gluing
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (x Y : C) : CategoryTheory.IsIso (CategoryTheory.Limits.CokernelÏ€ 0)
{Î± : Type u_1} {Î¹ : Type u_4} (S : Î¹ â†’ set Î±) : (â‹‚ (i : Î¹), S i) = â‹‚ (t : Finset Î¹) (i : Î¹) (h : i âˆˆ t), S i
{Î± : Type u} {Î² : Type v} [PseudoEmetricSpace Î±] [PseudoEmetricSpace Î²] {K : Nnreal} {F : Î± â†’ Î²} (hF : LipschitzWith K F) : uniform_Continuous F
{E : Type u_1} [NormedGroup E] [NormedSpace â„ E] {F : Type u_2} [NormedGroup F] [NormedSpace â„ F] [Finite_dimensional â„ F] {S : set E} {F : E â†’ F} {F' : E â‰ƒL[â„] F} {C : Nnreal} (hF : ApproximatesLinearOn F â†‘F' S C) (hc : Subsingleton E âˆ¨ lipschitz_extension_constant F * C < âˆ¥â†‘(F'.Symm)âˆ¥â‚Šâ»Â¹) : âˆƒ (g : E â‰ƒâ‚œ F), set.Eq_on F â‡‘g S
{R : Type u_1} [CommRing R] (v W : Fin 3 â†’ R) : -â‡‘(â‡‘CrossProduct v) W = â‡‘(â‡‘CrossProduct W) v
(P : â„•) [P_Prime : Fact (Nat.Prime P)] {nâ‚ nâ‚‚ Dâ‚ Dâ‚‚ : â„¤} (hnâ‚ : nâ‚ â‰  0) (hnâ‚‚ : nâ‚‚ â‰  0) (hDâ‚ : Dâ‚ â‰  0) (hDâ‚‚ : Dâ‚‚ â‰  0) : padic_val_rat P (Rat.Mk nâ‚ Dâ‚) â‰¤ padic_val_rat P (Rat.Mk nâ‚‚ Dâ‚‚) â†” âˆ€ (n : â„•), â†‘P ^ n âˆ£ nâ‚ * Dâ‚‚ â†’ â†‘P ^ n âˆ£ nâ‚‚ * Dâ‚
{R : Type u} [CommSemiring R] [Star_Ring R] (x : R) : â‡‘(Star_Ring_end R) (â‡‘(Star_Ring_end R) x) = x
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} {F' : E â†’L[ð•œ] F} {S : set E} {C : Nnreal} : ApproximatesLinearOn F F' S C â†’ LipschitzOnWith C (F - â‡‘F') S
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {n : WithTop â„•} (h : ContDiff_on ð•œ n F S) (hs : UniqueDiffOn ð•œ S) : HasFtaylorSeriesUpToOn n F (ftaylor_series_within ð•œ F S) S
{Î± : Type u_1} (L : List (List Î±)) {i j : â„•} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : (List.take i (List.Map List.length L)).Sum + j < L.Join.length
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {F' : Î± â†’ E'} {g' : Î± â†’ F'} {l : Filter Î±} : ((Î» (x : Î±), âˆ¥F' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ F' =O[l] g'
{ð•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [NormedGroup E] [NormedGroup Fâ‚—] [nondiscrete_NormedField ð•œ] [NormedSpace ð•œ E] [NormedSpace ð•œ Fâ‚—] (C : E â†’L[ð•œ] ð•œ) (F : Fâ‚—) : âˆ¥C.Smul_Right Fâˆ¥ = âˆ¥Câˆ¥ * âˆ¥Fâˆ¥
(P : â„•) [P_Prime : Fact (Nat.Prime P)] {q r : â„š} (hq : q â‰  0) (hr : r â‰  0) : padic_val_rat P (q * r) = padic_val_rat P q + padic_val_rat P r
{Î“â‚€ : Type u_1} [Linear_ordered_comm_Group_with_Zero Î“â‚€] (Î³ : Î“â‚€) (h : Î³ â‰  0) : {Î³} âˆˆ nhds Î³
{K : Type v} {v : Type W} [Field K] [AddCommGroup v] [module K v] [_alg_IsClosed K] [Finite_dimensional K v] [Nontrivial v] (F : module.End K v) : âˆƒ (C : K), F.HasEigenvalue C
{x : Type u} [MetricSpace x] [CompactSpace x] [Nonempty x] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : GromovHausdorff.to_GH_Space x = GromovHausdorff.to_GH_Space Y â†” Nonempty (x â‰ƒáµ¢ Y)
{Î± : Type u} : TopologicalSpace.induced has_pure.pure Ultrafilter.TopologicalSpace = âŠ¥
(P : â„•) : â†‘(mersenne P) = 0
{C : Type uâ‚} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {x Y Z : C} [CategoryTheory.HasRightDual x] [CategoryTheory.HasRightDual Y] [CategoryTheory.HasRightDual Z] {F : x âŸ¶ Y} {g : Y âŸ¶ Z} : (F â‰« g)á˜ = gá˜ â‰« Fá˜
{Î± : Type u} [PseudoEmetricSpace Î±] : Isometry Id
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [CommMonoid Î²] {S : Finset Î±} {t : Finset Î³} {F : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (A : Î±), A âˆˆ S â†’ Î³) (hi : âˆ€ (A : Î±) (ha : A âˆˆ S), i A ha âˆˆ t) (h : âˆ€ (A : Î±) (ha : A âˆˆ S), F A = g (i A ha)) (j : Î  (A : Î³), A âˆˆ t â†’ Î±) (hj : âˆ€ (A : Î³) (ha : A âˆˆ t), j A ha âˆˆ S) (Left_Inv : âˆ€ (A : Î±) (ha : A âˆˆ S), j (i A ha) _ = A) (Right_Inv : âˆ€ (A : Î³) (ha : A âˆˆ t), i (j A ha) _ = A) : S.Prod (Î» (x : Î±), F x) = t.Prod (Î» (x : Î³), g x)
{K : Type u_1} {v : Type u_2} [Field K] [Ring v] [Algebra K v] {S : Subalgebra K v} (h : Finite_dimensional K â†¥(S.to_Submodule)) : Finite_dimensional K â†¥S
{Î± : Type u_1} (l : List Î±) (C : Composition l.length) : List.Map List.length (l.split_wrt_Composition C) = C.blocks
(u : pnat.xgcd_Type) (hr : u.r â‰  0) : sizeOf u.step < sizeOf u
(A : Type u_4) (K : Type u_5) (C : Type u_6) [CommRing A] [IsDomain A] [Field K] [Algebra A K] [_fraction_Ring A K] [CommRing C] [Algebra A C] [Algebra K C] [IsScalarTower A K C] {x : C} : IsAlgebraic A x â†” IsAlgebraic K x
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k â†’ E} {A B r : k} (h : 0 < (1 - r) * (B - A)) : â‡‘(affine_Map.line_Map (F A) (F B)) r < F (â‡‘(affine_Map.line_Map A B) r) â†” slope F (â‡‘(affine_Map.line_Map A B) r) B < slope F A B
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (Sâ‚‚ : Finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (P : Î¹ â†’ P) : Finset.centroid k (Finset.Map e Sâ‚‚) P = Finset.centroid k Sâ‚‚ (P âˆ˜ â‡‘e)
{G : Type u} [Monoid G] (h : Submonoid G) (x : â†¥h) : _of_Fin_order x â†” _of_Fin_order â†‘x
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_LinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±] [TopologicalSpace Î²] {S : set Î²} {F : Î² â†’ Î±} (hF : Continuous_on F S) (hsc : IsClosed S) {xâ‚€ : Î²} (hâ‚€ : xâ‚€ âˆˆ S) (hc : âˆ€á¶  (x : Î²) in Filter.cocompact Î² âŠ“ Filter.principal S, F xâ‚€ â‰¤ F x) : âˆƒ (x : Î²) (h : x âˆˆ S), âˆ€ (y : Î²), y âˆˆ S â†’ F x â‰¤ F y
{Î± : Type u_1} {C : set (set Î±)} (hu : â‹ƒâ‚€C = set.Univ) (h : C.Pairwise_Disjoint Id) (A : Î±) : âˆƒ! (B : set Î±) (h : B âˆˆ C), A âˆˆ B
{G : Type u_4} [NormedGroup G] [NormedSpace â„ G] {S : set G} (conv : Convex â„ S) (hs : (Interior S).Nonempty) {x : G} (hx : x âˆˆ Closure S) : UniqueDiffWithinAt â„ S x
{A k : â„•} (h0 : 0 < A) (h1 : A < k) (n : â„•) : (k + n).Prime_counting' â‰¤ k.Prime_counting' + A.Totient * (n / A + 1)
{cb : CharBuffer} {n n' val : â„•} (h : Parser.Nat cb n = ParseResult.done n' val) (hn : n' â‰¤ Buffer.size cb) (k : â„•) (hk : k < n') : n â‰¤ k â†’ '0' â‰¤ Buffer.read cb âŸ¨k, _âŸ© âˆ§ Buffer.read cb âŸ¨k, _âŸ© â‰¤ '9'
{Î± : Type u_1} {râ‚ râ‚‚ : Setoid Î±} : râ‚ = râ‚‚ â†” âˆ€ (x : Î±), {y : Î± | râ‚.Rel x y} = {y : Î± | râ‚‚.Rel x y}
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {E : Type v} [NormedGroup E] [NormedSpace ð•œ E] [CompleteSpace ð•œ] {C : ð•œ} (hc : 1 < âˆ¥Câˆ¥) {R : â„} (hR : âˆ¥Câˆ¥ < R) (h : Â¬Finite_dimensional ð•œ E) (S : Finset E) : âˆƒ (x : E), âˆ¥xâˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ S â†’ 1 â‰¤ âˆ¥y - xâˆ¥
(R : Type u) (m : Type v) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] : module.rank R m < Cardinal.aleph0
{Î± : Type u_3} [OrderedSemiring Î±] {n : â„•} (hn : 1 â‰¤ n) : Filter.Tendsto (Î» (x : Î±), x ^ n) Filter.at_top Filter.at_top
{Î± : Type u_1} {Î¹' : sort u_5} (S : Î¹' â†’ set Î±) : (â‹ƒ (i : Î¹'), S i) = â‹ƒ (t : Finset (plift Î¹')) (i : plift Î¹') (h : i âˆˆ t), S i.down
{R : Type u_1} [AddCommGroup R] {F g : â„• â†’ R} : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.Sum (Î» (i : â„•), F i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.Sum (Î» (x : â„• Ã— â„•), â‡‘Nat.ArithmeticFunction.moebius x.fst â€¢ g x.Snd) = F n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasBinaryBiproducts C] (P q : C) : (CategoryTheory.Limits.biprod.braiding P q).hom â‰« (CategoryTheory.Limits.biprod.braiding q P).hom = ðŸ™ (P âŠž q)
{F : â„‚ â†’ â„‚} {C : â„‚} {R : â„} (hD : DifferentiableOn â„‚ F (Metric.Ball C R)) (h_maps : set.maps_to F (Metric.Ball C R) (Metric.Ball C R)) (hc : F C = C) (hâ‚€ : 0 < R) : Complex.Abs (deriv F C) â‰¤ 1
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (F : R â†’+* S) (n : â„•) : Polynomial.x ^ n âˆˆ Polynomial.lifts F
{C : Type uâ‚} [CategoryTheory.Category C] (t : CategoryTheory.Monad C) {A B : t.Algebra} (F : A âŸ¶ B) [CategoryTheory.IsIso F.F] : CategoryTheory.IsIso F
{R : Type u} [CommRing R] {P q : Polynomial R} (hmonic : q.monic) (hdegree : q.degree â‰¤ P.degree) : (P /â‚˜ q).leading_Coeff = P.leading_Coeff
{R : Type u} [non_assoc_Semiring R] {S : set R} : S âŠ† â†‘(Subsemiring.Closure S)
{P A B : â„•} (hab : A.IsCoprime B) (hpa : P âˆˆ A.Factors) : â‡‘((A * B).factorization) P = â‡‘(A.factorization) P
{m n : â„•+} : m.factor_Multiset â‰¤ n.factor_Multiset â†” m âˆ£ n
{mâ‚€ : Type u_1} [Mul_Zero_class mâ‚€] [no_Zero_divisors mâ‚€] {A B : mâ‚€} : A * B = 0 â†” A = 0 âˆ¨ B = 0
{ð•œ : Type u_3} {E : Type u_4} [semi_NormedRing ð•œ] [AddCommGroup E] [module ð•œ E] (P : Seminorm ð•œ E) (x y : E) : â‡‘P y â‰¤ â‡‘P x + â‡‘P (x - y)
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) {râ‚ râ‚‚ : â„} (hrâ‚ : 0 â‰¤ râ‚) (hrâ‚‚ : 0 â‰¤ râ‚‚) : hb.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {G : Type u_4} [NormedGroup G] [NormedSpace ð•œ G] {S : set E} {F : E â†’ F} {x : E} {n : WithTop â„•} (e : F â‰ƒL[ð•œ] G) : ContDiff_within_at ð•œ n (â‡‘e âˆ˜ F) S x â†” ContDiff_within_at ð•œ n F S x
(x : â„) : Real.sinh (Real.arsinh x) = x
{m : Type u_3} [AddMonoid m] [Preorder m] (L : List m) (h : 0 < L.Sum) : 0 < L.length
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ Submodule ð•œ E} (hV : OrthogonalFamily ð•œ (Î» (i : Î¹), (v i).Subtypeâ‚—áµ¢)) : CompleteLattice.Independent v
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_3} (S : Finset Î¹) (F : Î¹ â†’ E) (x : E) : HasInner.inner (S.Sum (Î» (i : Î¹), F i)) x = S.Sum (Î» (i : Î¹), HasInner.inner (F i) x)
{G : Type u_1} [Group G] [TopologicalSpace G] [nonarchimedean_Group G] {h : Type u_2} [Group h] [TopologicalSpace h] [topological_Group h] (F : G â†’* h) (emb : IsOpen_Embedding â‡‘F) : nonarchimedean_Group h
{P : â„•} {z : â„¤} : padic_val_rat P â†‘z = â†‘(padic_val_Int P z)
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] (S : Submodule R m) : S.fg â†” CompleteLattice.IsCompact_element S
{Î± : Type u_1} [MulOneClass Î±] [Preorder Î±] [CovariantClass Î± Î± (Function.Swap has_Mul.Mul) has_LE.LE] {A B : Î±} (ha : A < 1) (hb : B < 1) : A * B < 1
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [Î  (i : Î¹), AddCommMonoid (Î² i)] : â‡‘Dfinsupp.Lift_Add_hom (Dfinsupp.single_Add_hom Î²) = AddMonoid_hom.Id (Î â‚€ (i : Î¹), Î² i)
{x : Type u_1} {Y : Type u_2} [PseudoEmetricSpace x] [PseudoEmetricSpace Y] {C : Nnreal} {F : x â†’ Y} {S : set x} : LipschitzOnWith C F S â†’ HolderOnWith C 1 F S
{Î² : Type u} {Î± : Type v} {Î³ : Type W} {S : Finset Î±} [AddCommMonoid Î²] [DecidableEq Î³] (F : Î³ â†’ Î²) (g : Î± â†’ Î³) : S.Sum (Î» (A : Î±), F (g A)) = (Finset.image g S).Sum (Î» (B : Î³), (Finset.Filter (Î» (A : Î±), g A = B) S).Card â€¢ F B)
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Mul_Pos_Mono Î±] (ha : A â‰¤ 1) (hb : B â‰¤ 1) (B0 : 0 < B) : A * B â‰¤ 1
{Gâ‚€ : Type u_2} {Gâ‚€' : Type u_4} [Group_with_Zero Gâ‚€] [Group_with_Zero Gâ‚€'] (F : Gâ‚€ â†’*â‚€ Gâ‚€') (A : Gâ‚€) : â‡‘F Aâ»Â¹ = (â‡‘F A)â»Â¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] (P q : C) : (CategoryTheory.Limits.Coprod.braiding P q).hom â‰« (CategoryTheory.Limits.Coprod.braiding q P).hom = ðŸ™ (P â¨¿ q)
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (Î¸ : Real.Angle) : â‡‘LinearMap.det â†‘((o.rotation Î¸).to_Linear_Equiv) = 1
{J : Type uâ‚} [CategoryTheory.Category J] {C : Type uâ‚ƒ} [CategoryTheory.Category C] {K : J â¥¤ C} {C D : CategoryTheory.Limits.Cone K} (F : C âŸ¶ D) [i : CategoryTheory.IsIso F.hom] : CategoryTheory.IsIso F
{Î± : Type u} {Î² : Type v} [Preorder Î±] [PartialOrder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : GaloisConnection l u) (B : Î²) : (âˆƒ (A : Î±), B = l A) â†” B = l (u B)
{Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [Fintype Î¹] [Preorder Î¹'] [_Directed Î¹' (Function.Swap has_LE.LE)] [Nonempty Î¹'] {S : Î¹ â†’ Î¹' â†’ set Î±} (hs : âˆ€ (i : Î¹), Monotone (S i)) : (â‹‚ (j : Î¹'), â‹ƒ (i : Î¹), S i j) = â‹ƒ (i : Î¹), â‹‚ (j : Î¹'), S i j
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), AddGroup (Gs i)] (tfGs : âˆ€ (i : Î·), AddMonoid._torsion_free (Gs i)) : AddMonoid._torsion_free (Î  (i : Î·), Gs i)
{v : Type u_1} (Î± : Type u_2) (G : SimpleGraph v) [Decidable_Rel G.Adj] [has_Zero Î±] [has_One Î±] : (SimpleGraph.Adj_Matrix Î± G)._Adj_Matrix
{C : Type uâ‚} [CategoryTheory.Category C] {x Y : C} {F : x âŸ¶ Y} [CategoryTheory.SplitEpi F] [CategoryTheory.Epi (CategoryTheory.section_ F)] : CategoryTheory.IsIso F
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (A : F) : Char.quadratic_Char F A = 0 â†” A = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P : P} (hp : P âˆˆ S) (P2 : P) : P -áµ¥ P2 âˆˆ S.direction â†” P2 âˆˆ S
{Î± : Type u_1} [Semigroup Î±] {A B : Î±} (C : Î±) (h : A * C = B) : A âˆ£ B
{Î± : Type u} [TopologicalSpace Î±] {S t : set Î±} (hs : IsCompact S) (ht : IsClosed t) (h : t âŠ† S) : IsCompact t
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {F : Î± â†’ Î² â†’ Î³} {ta1 ta2 : TopologicalSpace Î±} {tb1 tb2 : TopologicalSpace Î²} {Tc1 : TopologicalSpace Î³} (h : Continuous (Î» (P : Î± Ã— Î²), F P.fst P.Snd)) : Continuous (Î» (P : Î± Ã— Î²), F P.fst P.Snd)
{m : Type u_3} {N : Type u_4} [MulOneClass m] [MulOneClass N] (F : m â†’* N) : â‡‘F 1 = 1
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 P2 : P) : P1 -áµ¥ P2 +áµ¥ P2 = P1
(P L : Type u) [HasMem P L] [Configuration.HasLines P L] [Fintype P] [Fintype L] : Fintype.Card P â‰¤ Fintype.Card L
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {Î¹ : Type u_4} (S : Finset Î¹) (W : Î¹ â†’ k) (Pâ‚ : Î¹ â†’ P) (Pâ‚‚ B : P) : S.Sum (Î» (i : Î¹), W i â€¢ (Pâ‚ i -áµ¥ Pâ‚‚)) = â‡‘(S.weighted_vsub_of_point Pâ‚ B) W - S.Sum (Î» (i : Î¹), W i) â€¢ (Pâ‚‚ -áµ¥ B)
{Î± : Type u} {S : set Î±} (hs : S.Nonempty) : S.countable â†” âˆƒ (F : â„• â†’ â†¥S), Function.Surjective F
{ð•‚ : Type u_1} [nondiscrete_NormedField ð•‚] [CompleteSpace ð•‚] [CharZero ð•‚] {x : ð•‚} (hx : x âˆˆ Emetric.Ball 0 (Exp_series ð•‚ ð•‚).radius) : HasStrictDerivAt (Exp ð•‚) (Exp ð•‚ x) x
{Î± : Type u_1} {Î² : Type u_2} [TopologicalSpace Î±] [BaireSpace Î±] {S : set Î²} {F : Î² â†’ set Î±} (hc : âˆ€ (S : Î²), S âˆˆ S â†’ IsClosed (F S)) (hS : S.countable) (hU : (â‹ƒ (S : Î²) (h : S âˆˆ S), F S) = set.Univ) : Dense (â‹ƒ (S : Î²) (h : S âˆˆ S), Interior (F S))
{n : â„•} {P : Fin n} {i : Fin (n + 1)} (h : i â‰  â‡‘Fin.cast_Succ P) : â‡‘((â‡‘Fin.cast_Succ P).Succ_above) (P.Pred_above i) = i
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] (P : P) : â‡‘(EuclideanGeometry.reflection S) P = P â†” P âˆˆ S
{Î± : Type u_1} (A : Î±) [Subsingleton Î±] : Fintype.Card Î± = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasWidePullbacks C] {B : C} : CategoryTheory.Limits.HasProducts (CategoryTheory.Over B)
{F : Type u_3} [InnerProductSpace â„ F] (x y : F) : HasInner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = -1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), r < 0 âˆ§ y = r â€¢ x
{G : Type u} {x y : G} [AddCommMonoid G] (hx : _of_Fin_Add_order x) (hy : _of_Fin_Add_order y) : _of_Fin_Add_order (x + y)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) [Nontrivial B] : Â¬IsUnit (minpoly A x)
{Î± : Type u} {Î¹ : sort x} {F : Î¹ â†’ Filter Î±} [Nonempty Î¹] (hD : Directed Ge F) (hb : âˆ€ (i : Î¹), (F i).Ne_IsBot) : (infi F).Ne_IsBot
{m : Type u_5} [AddCommGroup m] (h : module â„¤ m) (n : â„¤) (x : m) : n â€¢ x = n â€¢ x
{R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (S : Finset Î¹) (hs : S.Nonempty) (P : Î¹ â†’ E) : Finset.centroid R S P = S.Center_mass (Finset.centroid_weights R S) P
{Î± : Type u_1} [Preorder Î±] {A B : Î±} (h : B < A) : Â¬IsMin A
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³] (e : LocalHomeomorph Î± Î²) {F : Î³ â†’ Î±} {x : Î³} (h : F â»Â¹' e.to_local_Equiv.Source âˆˆ nhds x) : Continuous_at F x â†” Continuous_at (â‡‘e âˆ˜ F) x
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} : B â‰¤ A â†’ 0 â‰¤ A - B
{x : Type u_1} [TopologicalSpace x] {A B : x} (Î³ : Path A B) : Continuous (Î» (x : â„ Ã— â„ Ã— â†¥Unit_Interval), â‡‘(Î³.truncate x.fst x.Snd.fst) x.Snd.Snd)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {x : E} : mfderiv (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F x = fderiv ð•œ F x
{Î± : Type u} [PseudoMetricSpace Î±] {S : â„• â†’ set Î±} (h0 : IsComplete (S 0)) (hs : âˆ€ (n : â„•), IsClosed (S n)) (h'S : âˆ€ (n : â„•), Metric.Bounded (S n)) (h : âˆ€ (N : â„•), (â‹‚ (n : â„•) (h : n â‰¤ N), S n).Nonempty) (h' : Filter.Tendsto (Î» (n : â„•), Metric.diam (S n)) Filter.at_top (nhds 0)) : (â‹‚ (n : â„•), S n).Nonempty
{G : Type W} [TopologicalSpace G] [Group G] [topological_Group G] {K U : set G} (hK : IsCompact K) (hU : IsOpen U) (hKU : K âŠ† U) : âˆƒ (v : set G) (h : v âˆˆ nhds 1), K * v âŠ† U
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) (x : K) : â‡‘(Algebra_Map K L) x âˆˆ S
{Î± : Type u_1} [DecidableEq Î±] (xs : List Î±) (x D D' : Î±) (x_mem : x âˆˆ xs) (x_Ne : x â‰  xs.Last _) : xs.next_or x D = xs.next_or x D'
{Î¹ : Type u_1} {R : Type u_3} {m : Type u_5} {v : Î¹ â†’ m} [Ring R] [AddCommGroup m] [module R m] {hli : LinearIndependent R v} {hsp : Submodule.Span R (set.Range v) = âŠ¤} (i : Î¹) : â‡‘((Basis.Mk hli hsp).coord i) (v i) = 1
{Î± : Type u_1} [Preorder Î±] [locally_Finite_order Î±] {A B : Î±} : Â¬A â‰¤ B â†’ Multiset.icc A B = 0
{m : Type u_3} {N : Type u_4} [AddZeroClass m] [AddZeroClass N] {F g : m â†’+ N} (h : F = g) (x : m) : â‡‘F x = â‡‘g x
{v : Type u_1} [InnerProductSpace â„ v] {P : Type u_2} [MetricSpace P] [NormedAddTorsor v P] {A B C D P : P} (h : EuclideanGeometry.Cospherical {A, B, C, D}) (hab : A â‰  B) (hcd : C â‰  D) (hapb : EuclideanGeometry.angle A P B = 0) (hcpd : EuclideanGeometry.angle C P D = 0) : HasDist.dist A P * HasDist.dist B P = HasDist.dist C P * HasDist.dist D P
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [SuccOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Antitone F) : Pairwise (Disjoint on Î» (n : Î±), set.Ioo (F (Order.Succ n)) (F n))
(P : Nat.Primes) : â†‘P.factor_Multiset = Prime_Multiset.of_Prime P
{m : Type u_1} [has_Mul m] (r : m â†’ m â†’ Prop) : Con_gen â‡‘(Con_gen r) = Con_gen r
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [module.Finite K L] [_alg_IsClosed E] (pB : power_Basis K L) [_IsSeparable K L] (e : Fin pB.dim â‰ƒ (L â†’â‚[K] E)) : â‡‘(Algebra_Map K E) (Algebra.discr K â‡‘(pB.Basis)) = Finset.Univ.Prod (Î» (i : Fin pB.dim), (Finset.Filter (Î» (j : Fin pB.dim), i < j) Finset.Univ).Prod (Î» (j : Fin pB.dim), -((â‡‘(â‡‘e j) pB.gen - â‡‘(â‡‘e i) pB.gen) * (â‡‘(â‡‘e i) pB.gen - â‡‘(â‡‘e j) pB.gen))))
{S : Type u_2} [CommRing S] {K : Type u_6} [Field K] [Algebra K S] (pB : power_Basis K S) : Finite_dimensional K S
{Î± : Type u} [AddCommGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B C : Î±} : B < C - A â†’ A + B < C
{m : Type u_1} [AddMonoid m] {S : set m} {A : m} (h : A âˆˆ AddMonoid.Closure S) : âˆƒ (l : List m), (âˆ€ (x : m), x âˆˆ l â†’ x âˆˆ S) âˆ§ l.Sum = A
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] [DenselyOrdered Î±] [Nontrivial Î±] {S : set Î±} : Dense S â†” âˆ€ (A B : Î±), A < B â†’ (âˆƒ (C : Î±) (h : C âˆˆ S), A < C âˆ§ C < B)
{ð•œ : Type u_1} {E : Type u} [Linear_ordered_Field ð•œ] [AddCommGroup E] [module ð•œ E] [DecidableEq E] {t : Finset E} (h : Â¬AffineIndependent ð•œ Coe) {x : E} (m : x âˆˆ â‡‘(Convex_hull ð•œ) â†‘t) : âˆƒ (y : â†¥â†‘t), x âˆˆ â‡‘(Convex_hull ð•œ) â†‘(t.erase â†‘y)
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B : Î±} (ha : 0 < A) (hb : 0 < B) : Aâ»Â¹ < B â†” Bâ»Â¹ < A
{E : Type u_4} {F : Type u_5} [NormedGroup E] [NormedSpace â„ E] [Finite_dimensional â„ E] [NormedGroup F] [NormedSpace â„ F] {F : E â†’ F} (h : ContDiff â„ 1 F) : dimH (set.Range F) â‰¤ â†‘(Finite_dimensional.finrank â„ E)
{P A B : â„•} (hpa : P âˆˆ A.Factors) (hb : B â‰  0) : P âˆˆ (A * B).Factors
{Î± : Type u_1} [Group Î±] [Fintype Î±] (S : Subgroup Î±) [Fintype â†¥S] : Fintype.Card â†¥S âˆ£ Fintype.Card Î±
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} (F : top.Presheaf C x) (U : TopologicalSpace.Opens â†¥x) (R : CategoryTheory.Presieve U) : CategoryTheory.presheaf.first_Map R F â‰« (top.Presheaf.covering_of_Presieve.second_obj_iso_Pi_inters F U R).hom = (top.Presheaf.covering_of_Presieve.FirstObj_iso_Pi_Opens F U R).hom â‰« top.Presheaf.sheaf_condition_Equalizer_products.Left_res F (top.Presheaf.covering_of_Presieve U R)
{Î± : Type u} {Î¹ : Type v} [MetricSpace Î±] [ProperSpace Î±] {C : Î¹ â†’ Î±} {r : Î¹ â†’ â„} (uf : âˆ€ (x : Î±), {i : Î¹ | x âˆˆ Metric.Ball (C i) (r i)}.Finite) (uU : (â‹ƒ (i : Î¹), Metric.Ball (C i) (r i)) = set.Univ) : âˆƒ (r' : Î¹ â†’ â„), (â‹ƒ (i : Î¹), Metric.Ball (C i) (r' i)) = set.Univ âˆ§ âˆ€ (i : Î¹), r' i < r i
{Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [IsIrrefl Î± r] : {C : Cardinal | âˆƒ (S : set Î±), set.Unbounded r S âˆ§ Cardinal.Mk â†¥S = C}.Nonempty
(R : Type u_2) {m : Type u_5} [Ring R] [AddCommGroup m] [module R m] (n : â„¤) (B : m) : n â€¢ B = â†‘n â€¢ B
{Î± : Type u_1} {Î³ : Type u_3} {Î¹ : sort u_2} {P : Î¹ â†’ Prop} {S : Î¹ â†’ set Î±} {F : Filter Î±} (hF : F.has_Basis P S) {Î² : Î¹ â†’ Type u_4} {pg : Î  (i : Î¹), Î² i â†’ Prop} {sg : Î  (i : Î¹), Î² i â†’ set Î³} {g : set Î± â†’ Filter Î³} (hg : âˆ€ (i : Î¹), (g (S i)).has_Basis (pg i) (sg i)) (gm : Monotone g) {S_1 : set Î³} : S_1 âˆˆ F.Lift g â†” âˆƒ (i : Î¹) (hi : P i) (x : Î² i) (hx : pg i x), sg i x âŠ† S_1
(R : Type u) [Ring R] [strong_RankCondition R] {Î¹ : Type u} : module.rank R (Î¹ â†’â‚€ R) = Cardinal.Mk Î¹
{Î± : Type u_1} [CompleteLattice Î±] {k : Î±} (h : CompleteLattice.IsCompact_element k) : IsCoatomic â†¥(set.Iic k)
{Î± : Type u_1} [Fintype Î±] {ð’œ : Finset (Finset Î±)} {r : â„•} : set.sized r â†‘ð’œ â†’ ð’œ âŠ† Finset.powerset_len r Finset.Univ
{m : Type u_1} [has_Mul m] {S : set m} {P : m â†’ m â†’ Prop} {x y : m} (hx : x âˆˆ Subsemigroup.Closure S) (hy : y âˆˆ Subsemigroup.Closure S) (Hs : âˆ€ (x : m), x âˆˆ S â†’ âˆ€ (y : m), y âˆˆ S â†’ P x y) (HMul_Left : âˆ€ (x y z : m), P x z â†’ P y z â†’ P (x * y) z) (HMul_Right : âˆ€ (x y z : m), P z x â†’ P z y â†’ P z (x * y)) : P x y
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : affine_Span k âˆ… = âŠ¥
{Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [Fintype Î¹] [Preorder Î¹'] [_Directed Î¹' has_LE.LE] [Nonempty Î¹'] {S : Î¹ â†’ Î¹' â†’ set Î±} (hs : âˆ€ (i : Î¹), Antitone (S i)) : (â‹‚ (j : Î¹'), â‹ƒ (i : Î¹), S i j) = â‹ƒ (i : Î¹), â‹‚ (j : Î¹'), S i j
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : set P} (hs : EuclideanGeometry.Cospherical S) {P : Fin 3 â†’ P} (hps : set.Range P âŠ† S) (hpi : Function.Injective P) : AffineIndependent â„ P
{R : Type u_1} [Mul_Zero_class R] : Â¬IsLeftRegular 0 â†” Nontrivial R
{Î± : Type u} [PseudoMetricSpace Î±] {S : set Î±} (h : IsCompact S) : Metric.Bounded S
{Î± : Type} {D : â„•} {ds : List â„•} [Ring Î±] (x : Holor Î± (D :: ds)) : (Finset.Range D).attach.Sum (Î» (i : {x // x âˆˆ Finset.Range D}), (Holor.Unit_vec D â†‘i).Mul (x.Slice â†‘i _)) = x
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : â„•} {i : Fin (n + 1)} : x.Î´ i.Succ â‰« x.Ïƒ i = ðŸ™ (x.obj (SimplexCategory.Mk n))
{C : Type uâ‚} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) : CategoryTheory.CoverPreserving J J (ðŸ­ C)
{Î± : Type u} [SemilatticeSup Î±] [Nonempty Î±] {S : set Î±} (hs : S.Finite) : BddAbove S
{R : Type u} [CommSemiring R] [no_Zero_divisors R] (t : Multiset (Polynomial R)) [Nontrivial R] : t.Prod.degree = (Multiset.Map (Î» (F : Polynomial R), F.degree) t).Sum
{C : Type u} [CategoryTheory.Category C] [âˆ€ (x Y : C), Subsingleton (x âŸ¶ Y)] : CategoryTheory.EssentiallySmall C â†” Small (CategoryTheory.Skeleton C)
{Î± : sort u_1} (P : Prop) [Decidable P] (x : Â¬P â†’ Î±) (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (Î» (h : P), y _) x
{R : Type u} [Ring R] (S : Subring R) : Subring.Closure â†‘S = S
{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {S : set A} {P : A â†’ A â†’ Prop} {A B : A} (ha : A âˆˆ Algebra.Adjoin R S) (hb : B âˆˆ Algebra.Adjoin R S) (Hs : âˆ€ (x : A), x âˆˆ S â†’ âˆ€ (y : A), y âˆˆ S â†’ P x y) (Halg : âˆ€ (râ‚ râ‚‚ : R), P (â‡‘(Algebra_Map R A) râ‚) (â‡‘(Algebra_Map R A) râ‚‚)) (Halg_Left : âˆ€ (r : R) (x : A), x âˆˆ S â†’ P (â‡‘(Algebra_Map R A) r) x) (Halg_Right : âˆ€ (r : R) (x : A), x âˆˆ S â†’ P x (â‡‘(Algebra_Map R A) r)) (HAdd_Left : âˆ€ (xâ‚ xâ‚‚ y : A), P xâ‚ y â†’ P xâ‚‚ y â†’ P (xâ‚ + xâ‚‚) y) (HAdd_Right : âˆ€ (x yâ‚ yâ‚‚ : A), P x yâ‚ â†’ P x yâ‚‚ â†’ P x (yâ‚ + yâ‚‚)) (HMul_Left : âˆ€ (xâ‚ xâ‚‚ y : A), P xâ‚ y â†’ P xâ‚‚ y â†’ P (xâ‚ * xâ‚‚) y) (HMul_Right : âˆ€ (x yâ‚ yâ‚‚ : A), P x yâ‚ â†’ P x yâ‚‚ â†’ P x (yâ‚ * yâ‚‚)) : P A B
{Î± : Type u} (F : Filter Î±) : (â¨† (g : Ultrafilter Î±) (hg : â†‘g â‰¤ F), â†‘g) = F
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (h : InnerProductGeometry.angle x (x - y) = InnerProductGeometry.angle y (y - x)) (hpi : InnerProductGeometry.angle x y â‰  Real.Pi) : âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{R S : Type u} [CommRing R] [CommRing S] (m : Submonoid R) (R' : Type u) [CommRing R'] [Algebra R R'] [Algebra R' S] [Algebra R S] [IsScalarTower R R' S] [IsLocalization m R'] (S : set S) (x : S) (hx : x âˆˆ Submodule.Span R' S) : âˆƒ (t : â†¥m), t â€¢ x âˆˆ Submodule.Span R S
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type W} [CategoryTheory.Category D] [CategoryTheory.ConcreteCategory D] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget D)] [âˆ€ (x : C), CategoryTheory.Limits.HasColimits_of_shape (J.cover x)áµ’áµ– D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (x : C) (S : J.cover x), CategoryTheory.Limits.HasMultiequalizer (S.Index P)] [Î  (x : C), CategoryTheory.Limits.PreservesColimitsOfShape (J.cover x)áµ’áµ– (CategoryTheory.Forget D)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget D)] (P : Cáµ’áµ– â¥¤ D) : CategoryTheory.Presheaf.IsSheaf J (J.plus_obj (J.plus_obj P))
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] (P : FormalMultilinearSeries ð•œ E F) (i : E â‰ƒL[ð•œ] F) : P.remove_Zero.Left_Inv i = P.Left_Inv i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} (F : top.Presheaf C x) {Î¹ : Type v} (U : Î¹ â†’ TopologicalSpace.Opens â†¥x) (S : CategoryTheory.Limits.Fork (top.Presheaf.sheaf_condition_Equalizer_products.Left_res F U) (top.Presheaf.sheaf_condition_Equalizer_products.Right_res F U)) : S.Î¹ â‰« top.Presheaf.Presieve_of_covering.Pi_Opens_to_FirstObj F U â‰« top.Presheaf.Presieve_of_covering.FirstObj_to_Pi_Opens F U = S.Î¹
{k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [Semiring k] [MulOneClass G] [Semiring R] {F g : Monoid_Algebra k G â†’+* R} (hâ‚ : âˆ€ (B : k), â‡‘F (Finsupp.single 1 B) = â‡‘g (Finsupp.single 1 B)) (h_of : âˆ€ (A : G), â‡‘F (Finsupp.single A 1) = â‡‘g (Finsupp.single A 1)) : F = g
{Î± : Type u_1} {Î¹ : sort u_3} [conditionally_CompleteLattice Î±] {F g : Î¹ â†’ Î±} (B : BddAbove (set.Range g)) (h : âˆ€ (x : Î¹), F x â‰¤ g x) : supr F â‰¤ supr g
{m : Type u_1} [AddGroup m] (C : Add_Con m) (n : â„¤) {W x : m} : â‡‘C W x â†’ â‡‘C (n â€¢ W) (n â€¢ x)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_5} [NormedGroup E'] [NormedSpace ð•œ E'] {n : WithTop â„•} {F : E â†’ E'} {S : set E} : ContDiff_on ð•œ n F S â†’ Cont_mdiff_on (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') n F S
{Î± : Type u_6} {Î² : Type u_7} [has_Mul Î²] [HasScalar Î± Î²] [SmulCommClass Î± Î² Î²] (S : Î±) (x y : Î²) : x * S â€¢ y = S â€¢ (x * y)
{Î± : Type u_1} [PartialOrder Î±] (C : Closure_operator Î±) : _.Closure_operator = C
(Î± : Type u_1) [CompleteLattice Î±] : WellFounded Gt â†’ CompleteLattice._Sup_IsClosed_IsCompact Î±
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (h : 0 < Finite_dimensional.finrank K v) : Nontrivial v
{x : Type u_2} [EmetricSpace x] {S : set x} (h : S.Subsingleton) : dimH S = 0
{Î± : Type u} [TopologicalSpace Î±] [LinearOrder Î±] [OrderTopology Î±] {A B : Î±} (hab : A < B) (S : set Î±) : [S âˆˆ nhds_within A (set.ioi A), S âˆˆ nhds_within A (set.ioc A B), S âˆˆ nhds_within A (set.Ioo A B), âˆƒ (u : Î±) (h : u âˆˆ set.ioc A B), set.Ioo A u âŠ† S, âˆƒ (u : Î±) (h : u âˆˆ set.ioi A), set.Ioo A u âŠ† S].tfae
{Î¹ : Type W} [Fintype Î¹] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [module.Finite K L] [_IsSeparable K L] (B : Basis Î¹ K L) : IsUnit (Algebra.discr K â‡‘B)
{E : Type u_2} [semi_NormedGroup E] [NormedSpace â„ E] {r : â„} (hr : 0 < r) : r â€¢ Metric.Ball 0 1 = Metric.Ball 0 r
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : Orthonormal ð•œ v) (l : Î¹ â†’â‚€ ð•œ) (i : Î¹) : HasInner.inner (v i) (â‡‘(Finsupp.Total Î¹ E ð•œ v) l) = â‡‘l i
{Î± : sort u_1} (P : Prop) [Decidable P] (A B : Î±) : Ite (Â¬P) A B = Ite P B A
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {S : set Î±} (h : IsChain r S) : IsChain (Flip r) S
{Î± : Type u} [PseudoEmetricSpace Î±] {S t : set Î±} {r : Ennreal} (h1 : âˆ€ (x : Î±), x âˆˆ S â†’ Emetric.Inf_edist x t â‰¤ r) (h2 : âˆ€ (x : Î±), x âˆˆ t â†’ Emetric.Inf_edist x S â‰¤ r) : Emetric.Hausdorff_edist S t â‰¤ r
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N' : Type u_5} [AddCommGroup N'] [module R N'] {Î¹ : Type u_6} [DecidableEq Î¹] {N'â‚‚ : Type u_7} [AddCommGroup N'â‚‚] [module R N'â‚‚] [Fintype Î¹] (g : N' â†’â‚—[R] N'â‚‚) (F : MultilinearMap R (Î» (_x : Î¹), m) N') : â‡‘MultilinearMap.alternatization (g.Comp_MultilinearMap F) = â‡‘(g.Comp_AlternatingMap) (â‡‘MultilinearMap.alternatization F)
{Î± : Type u_1} {Î² : Type u_2} [UniformSpace Î±] [MetricSpace Î²] {F : Î± â†’ Î²} (h : uniform_Embedding F) : Isometry F
{Î± : Type u_1} {ð•œ : Type u_14} [NormedField ð•œ] {l : Filter Î±} {F g : Î± â†’ ð•œ} (hgf : âˆ€á¶  (x : Î±) in l, g x = 0 â†’ F x = 0) : Filter.Tendsto (Î» (x : Î±), F x / g x) l (nhds 0) â†’ F =o[l] g
{Î± : Type u_2} [Fintype Î±] {ð’œ : Finset (Finset Î±)} (hð’œ : IsAntichain HasSubset.Subset â†‘ð’œ) : ð’œ.Card â‰¤ (Fintype.Card Î±).choose (Fintype.Card Î± / 2)
{Î± : Type u_2} [DecidableEq Î±] [Fintype Î±] {ð’œ : Finset (Finset Î±)} {r : â„•} (hð’œ : set.sized r â†‘ð’œ) : ð’œ.Card * r â‰¤ ð’œ.shadow.Card * (Fintype.Card Î± - r + 1)
{A : Ennreal} : A - âŠ¤ = 0
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} {P : P} {v : v} (hp : P âˆˆ SpanPoints k S) (hv : v âˆˆ Vector_Span k S) : v +áµ¥ P âˆˆ SpanPoints k S
{Î± : Type u} [t : TopologicalSpace Î±] [TopologicalSpace.IsSeparable_Space Î±] {Î¹ : Type u_1} {S : Î¹ â†’ set Î±} {A : set Î¹} (h : A.Pairwise_Disjoint S) (ha : âˆ€ (i : Î¹), i âˆˆ A â†’ (Interior (S i)).Nonempty) : A.countable
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {x Y : C} (F : x âŸ¶ Y) (i : Function.Injective â‡‘F) : CategoryTheory.Mono F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] : Function.Injective Coe
{R : Type u_1} {G : Type u_2} [CommRing R] [IsDomain R] [Group G] [Fintype G] (F : G â†’* R) (hF : Function.Injective â‡‘F) : IsCyclic G
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A âˆˆ t) (ht : t.Nonempty) (hb : S.Sum (Î» (x : Î±), W x) â‰¤ t.Card â€¢ B) : âˆƒ (y : Î²) (h : y âˆˆ t), (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x) â‰¤ B
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace â„ P) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] : Function.involutive â‡‘(EuclideanGeometry.reflection S)
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (hx : x â‰  0) (hy : y â‰  0) : InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x) = Real.Pi
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P n) (fs : Finset (Fin (n + 1))) : Finset.centroid â„ fs S.points = â‡‘(Finset.Univ.affine_combination S.points_with_circumcenter) (Affine.Simplex.centroid_weights_with_circumcenter fs)
{ð•œ : Type u_1} {Î± : Type u_2} [Linear_ordered_Field ð•œ] {ð’œ : Finset (Finset Î±)} [Fintype Î±] (hð’œ : IsAntichain HasSubset.Subset â†‘ð’œ) : (Finset.Range (Fintype.Card Î± + 1)).Sum (Î» (r : â„•), â†‘((ð’œ.Slice r).Card) / â†‘((Fintype.Card Î±).choose r)) â‰¤ 1
{Î± : Type u_1} {l : List Î±} {x : Î±} : List.Duplicate x l â†” âˆƒ (n : â„•) (hn : n < l.length) (m : â„•) (hm : m < l.length) (h : n < m), x = l.nth_LE n hn âˆ§ x = l.nth_LE m hm
{Î± : Type u} [Group Î±] [has_LT Î±] [CovariantClass Î± Î± has_Mul.Mul has_LT.LT] {A B C : Î±} : Bâ»Â¹ * A < C â†’ A < B * C
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {S : Î² â†’ Î² â†’ Prop} [IsTrichotomous Î± r] [IsIrrefl Î² S] (F : r â†’r S) : Function.Injective â‡‘F
{C : Type uâ‚} [CategoryTheory.Category C] {D : Type uâ‚‚} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (E : C â¥¤ D) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasColimits_of_shape J D] : CategoryTheory.Limits.HasColimits_of_shape J C
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : â„•} [DivisionRing K] {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K} (Succ_nth_S_Eq : g.S.nth (n + 1) = Option.Some gp) (nth_Num_Eq : g.numerators n = ppredA) (Succ_nth_Num_Eq : g.numerators (n + 1) = predA) : g.numerators (n + 2) = gp.B * predA + gp.A * ppredA
{K : Type u} [Field K] (S : Subfield K) (m : Multiset K) : (âˆ€ (A : K), A âˆˆ m â†’ A âˆˆ S) â†’ m.Sum âˆˆ S
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : Î± â†’ F} {F' : Î± â†’ E'} {l : Filter Î±} : F' =O[l] g â†’ (Î» (x : Î±), âˆ¥F' xâˆ¥) =O[l] g
{Î± : Type u_2} [AddGroup Î±] {S t : set Î±} : Disjoint S t â†’ 0 âˆ‰ S - t
{vâ‚ : Type u_2} {vâ‚‚ : Type u_3} [semi_NormedGroup vâ‚] [semi_NormedGroup vâ‚‚] (F : vâ‚ â†’+ vâ‚‚) {C : â„} (h : âˆ€ (x : vâ‚), âˆ¥â‡‘F xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥F.Mk_NormedGroup_hom C hâˆ¥ â‰¤ LinearOrder.max C 0
{Î± : Type u_1} [semi_NormedGroup Î±] {r C : â„} {F : â„• â†’ Î±} (hr : r < 1) (hF : âˆ€ (n : â„•), âˆ¥F nâˆ¥ â‰¤ C * r ^ n) : Cauchy_Seq (Î» (S : Finset â„•), S.Sum (Î» (x : â„•), F x))
{F : Type u_3} [InnerProductSpace â„ F] {x y : F} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * HasInner.inner x y + âˆ¥yâˆ¥ ^ 2
(F : â„ â†’ â„) {A B : â„} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfd : DifferentiableOn â„ F (set.Ioo A B)) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), deriv F C = (F B - F A) / (B - A)
{Î± : Type u_1} [conditionally_CompleteLattice Î±] {S : set Î±} {A B : Î±} : BddBelow S â†’ A âˆˆ S â†’ A < B â†’ HasInf.Inf S < B
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C â¥¤ D) {x Y Z : C} {F : x âŸ¶ Y} {g : Y âŸ¶ Z} [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.Additive] [CategoryTheory.Limits.PreservesFiniteLimits F] [CategoryTheory.Mono F] (ex : CategoryTheory.Exact F g) : CategoryTheory.Exact (F.Map F) (F.Map g)
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} {ps : set P} (h : ps âŠ† â†‘S) [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] : EuclideanGeometry.Cospherical ps â†” âˆƒ (Center : P) (h : Center âˆˆ S) (radius : â„), âˆ€ (P : P), P âˆˆ ps â†’ HasDist.dist P Center = radius
{Î± : Type u} {A B : Î±} [MulOneClass Î±] [has_Zero Î±] [Preorder Î±] [Zero_LT.Mul_Pos_StrictMono Î±] (ha : A < 1) (hb : B â‰¤ 1) (B0 : 0 < B) : A * B < 1
{Î± : Type u_1} [PartialOrder Î±] (C : Closure_operator Î±) : C = Closure_operator.Mkâ‚ƒ â‡‘C C.IsClosed _ _ _
{Î± : Type u_1} {Î² : Type u_2} (t : Î±) (ts : List Î±) (r : List Î²) (ys : List Î±) (F : List Î± â†’ Î²) : (List.PermutationsAux2 t ts List.Nil ys F).Snd ++ r = (List.PermutationsAux2 t ts r ys F).Snd
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} [Nonempty â†¥S] [CompleteSpace â†¥(S.direction)] {Pâ‚ : P} (Pâ‚‚ : P) (r : â„) (hpâ‚ : Pâ‚ âˆˆ S) : â‡‘(EuclideanGeometry.reflection S) (r â€¢ (Pâ‚‚ -áµ¥ â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) Pâ‚‚)) +áµ¥ Pâ‚) = -(r â€¢ (Pâ‚‚ -áµ¥ â†‘(â‡‘(EuclideanGeometry.Orthogonal_projection S) Pâ‚‚))) +áµ¥ Pâ‚
{E : Type u_1} [NormedGroup E] [NormedSpace â„‚ E] [CompleteSpace E] {F : â„‚ â†’ E} {C : â„‚} {R : â„} {W : â„‚} (hF : CircleIntegrable F C R) (hw : Complex.Abs W < R) : (Cauchy_PowerSeries F C R).Sum W = (2 * â†‘Real.Pi * Complex.i)â»Â¹ â€¢ âˆ® (z : â„‚) in C(C, R), (z - (C + W))â»Â¹ â€¢ F z
{R : Type u_1} {S : Type u_2} {m : Type u_3} {Î¹ : Type u_4} [CommSemiring R] [Semiring S] [AddCommMonoid m] [Algebra R S] [module R m] [module S m] [IsScalarTower R S m] (hinj : Function.Injective â‡‘(Algebra_Map R S)) {v : Î¹ â†’ m} (li : LinearIndependent S v) : LinearIndependent R v
{ð•œ : Type u_1} {F : Type u_3} [_R_or_C ð•œ] [AddCommGroup F] [module ð•œ F] [C : InnerProductSpace.core ð•œ F] (x y : F) : _R_or_C.Abs (HasInner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{n : â„•} [Fact (0 < n)] (i : Zmod n) : order_of (dihedral_Group.r i) = n / n.Gcd i.val
{Î± : Type u_2} {Gâ‚€ : Type u_6} [Group_with_Zero Gâ‚€] [MulAction Gâ‚€ Î±] [TopologicalSpace Î±] [has_Continuous_Const_Smul Gâ‚€ Î±] {C : Gâ‚€} {S : set Î±} {x : Î±} (hs : S âˆˆ nhds x) (hc : C â‰  0) : C â€¢ S âˆˆ nhds (C â€¢ x)
{m : Type u_1} [Monoid m] {N : Type u_2} [Monoid N] {F : m â†’ N} (hF : _Monoid_hom F) {S : set N} (hs : _Submonoid S) : _Submonoid (F â»Â¹' S)
(F F' : â„ â†’ â„) {A B : â„} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivAt F (F' x) x) (g g' : â„ â†’ â„) (hgc : Continuous_on g (set.icc A B)) (hgg' : âˆ€ (x : â„), x âˆˆ set.Ioo A B â†’ HasDerivAt g (g' x) x) : âˆƒ (C : â„) (h : C âˆˆ set.Ioo A B), (g B - g A) * F' C = (F B - F A) * g' C
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {Î¹ : Type u_3} {S : Finset Î¹} {Wâ‚ Wâ‚‚ : Î¹ â†’ â„} (P : Î¹ â†’ P) (hâ‚ : S.Sum (Î» (i : Î¹), Wâ‚ i) = 1) (hâ‚‚ : S.Sum (Î» (i : Î¹), Wâ‚‚ i) = 1) : HasDist.dist (â‡‘(S.affine_combination P) Wâ‚) (â‡‘(S.affine_combination P) Wâ‚‚) * HasDist.dist (â‡‘(S.affine_combination P) Wâ‚) (â‡‘(S.affine_combination P) Wâ‚‚) = -S.Sum (Î» (iâ‚ : Î¹), S.Sum (Î» (iâ‚‚ : Î¹), (Wâ‚ - Wâ‚‚) iâ‚ * (Wâ‚ - Wâ‚‚) iâ‚‚ * (HasDist.dist (P iâ‚) (P iâ‚‚) * HasDist.dist (P iâ‚) (P iâ‚‚)))) / 2
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B C D : Î±} (hc : C â‰  0) (hD : D â‰  0) : (A * D - B * C) / (C * D) < 0 â†’ A / C < B / D
{K : Type u_1} {n : â„•} {g : GeneralizedContinuedFraction K} [Linear_ordered_Field K] (S_Pos : âˆ€ {gp : GeneralizedContinuedFraction.Pair K} {m : â„•}, m < n â†’ g.S.nth m = Option.Some gp â†’ 0 < gp.A âˆ§ 0 < gp.B) : g.convergents n = g.convergents' n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryCoproducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{Î± : Type u} {Î¹ : sort x} {F : Î¹ â†’ Î±} : Function.Surjective F â†’ set.Range F = set.Univ
{m : Type u_1} [has_Mul m] {S : set m} {P : m â†’ Prop} {x : m} (h : x âˆˆ Subsemigroup.Closure S) (Hs : âˆ€ (x : m), x âˆˆ S â†’ P x) (HMul : âˆ€ (x y : m), P x â†’ P y â†’ P (x * y)) : P x
(P : â„•) [P_Prime : Fact (Nat.Prime P)] {q r : â„š} (hqr : q + r â‰  0) : LinearOrder.min (padic_val_rat P q) (padic_val_rat P r) â‰¤ padic_val_rat P (q + r)
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {Î¹ : Type u_3} [DecidableEq Î¹] [Fintype Î¹] [Nontrivial R] [Nonempty Î¹] (e : Basis Î¹ R m) (x : Orientation R m Î¹) : (e.adjust_to_Orientation x).Orientation = x
{R : Type u_1} [CommRing R] [Fintype R] (P : â„•) [Fact (Nat.Prime P)] : P âˆ£ Ring_Char R â†” P âˆ£ Fintype.Card R
{Î± : Type u} [TopologicalSpace Î±] [LocallyCompactSpace Î±] {x : Î±} {U : set Î±} (hU : IsOpen U) (hx : x âˆˆ U) : âˆƒ (K : set Î±), IsCompact K âˆ§ x âˆˆ Interior K âˆ§ K âŠ† U
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.has_Finite_products D] (F : C â¥¤ D) {L : D â¥¤ C} [CategoryTheory.cartesian_IsClosed C] [CategoryTheory.cartesian_IsClosed D] [CategoryTheory.Limits.PreservesLimits_of_shape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] (h : L âŠ£ F) (A : C) [i : CategoryTheory.IsIso (CategoryTheory.frobenius_morphism F h A)] : CategoryTheory.IsIso (CategoryTheory.Exp_comparison F A)
{Î± : Type u_1} {Î² : Type u_2} {Op : Î² â†’ Î² â†’ Î²} [hc : IsCommutative Î² Op] [ha : IsAssociative Î² Op] {F : Î± â†’ Î²} {B : Î²} {S : Finset Î±} [IsIdempotent Î² Op] {g : Î± â†’ Î²} (P : Î± â†’ Prop) [Decidable_Pred P] : Finset.Fold Op B (Î» (i : Î±), Ite (P i) (F i) (g i)) S = Op (Finset.Fold Op B F (Finset.Filter P S)) (Finset.Fold Op B g (Finset.Filter (Î» (i : Î±), Â¬P i) S))
(R : Type u) [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] (P : Polynomial S) : P âˆˆ Polynomial.lifts (Algebra_Map R S) â†” P âˆˆ (Polynomial.Map_alg R S).Range
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {x y : m} : SameRay R x y â†’ SameRay R (-x) (-y)
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : Î± â†’ E} {g : Î± â†’ F} {l : Filter Î±} : (âˆ€ â¦ƒC : â„â¦„, 0 < C â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥F xâˆ¥ â‰¤ C * âˆ¥g xâˆ¥)) â†’ F =o[l] g
{R : Type u_2} [cancel_CommMonoid_with_Zero R] [Unique_factorization_Monoid R] {A B C : R} (ha : A â‰  0) : (âˆ€ {D : R}, D âˆ£ A â†’ D âˆ£ C â†’ Â¬Prime D) â†’ A âˆ£ B * C â†’ A âˆ£ B
(ð•œ : Type u_1) {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] {Î¹ : Type u_3} [LinearOrder Î¹] [OrderBot Î¹] [locally_Finite_order Î¹] [IsWellOrder Î¹ has_LT.LT] [SuccOrder Î¹] [IsSuccArchimedean Î¹] (F : Î¹ â†’ E) (n : Î¹) (hâ‚€ : LinearIndependent ð•œ F) : gram_schmidt ð•œ F n â‰  0
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (h : B.Orientation = o) (x y : v) : o.oangle x y = hb.oangle x y
{ð•œ : Type u} [nondiscrete_NormedField ð•œ] {F g : ð•œ â†’ ð•œ} {F' A : ð•œ} (hg : Continuous_at g A) (hF : HasDerivAt F F' (g A)) (hF' : F' â‰  0) (hfg : âˆ€á¶  (y : ð•œ) in nhds A, F (g y) = y) : HasDerivAt g F'â»Â¹ A
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] [Algebra R S] {Î¹ : Type W} [Fintype Î¹] (B : Basis Î¹ R S) (x : R) : â‡‘(Algebra.norm R) (â‡‘(Algebra_Map R S) x) = x ^ Fintype.Card Î¹
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} {Râ‚ƒ : Type u_3} [Semiring Râ‚] [Semiring Râ‚‚] [Semiring Râ‚ƒ] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Ïƒâ‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ} {Ïƒâ‚â‚ƒ : Râ‚ â†’+* Râ‚ƒ} [Ring_hom_Comp_triple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [Ring_hom_surjective Ïƒâ‚â‚‚] [Ring_hom_surjective Ïƒâ‚‚â‚ƒ] : Ring_hom_surjective Ïƒâ‚â‚ƒ
{Gâ‚€ : Type u_2} [Group_with_Zero Gâ‚€] (A : Gâ‚€) : Aâ»Â¹ * A * A = A
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] {A : Î±} : 0 â‰¤ -A â†” A â‰¤ 0
{Î± : Type u_1} {m : Type u_5} {N : Type u_6} [AddCommMonoid m] [AddCommMonoid N] {S : set Î±} (F : Î± â†’ m) (g : m â†’+ N) (hs : S.Finite) : â‡‘g (finsum (Î» (j : Î±), finsum (Î» (h : j âˆˆ S), F j))) = finsum (Î» (i : Î±), finsum (Î» (h : i âˆˆ S), â‡‘g (F i)))
{Î± : Type u_1} {Î² : Type u_2} [has_Add Î±] [AddCommGroup Î²] {F : Î± â†’ Î²} (hF : _Add_hom F) : _Add_hom (Î» (A : Î±), -F A)
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [CommMonoid m] (S : Finset (Î± Ã— Î²)) (F : Î± Ã— Î² â†’ m) : finprod (Î» (Ab : Î± Ã— Î²), finprod (Î» (h : Ab âˆˆ S), F Ab)) = finprod (Î» (A : Î±), finprod (Î» (B : Î²), finprod (Î» (h : (A, B) âˆˆ S), F (A, B))))
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] (A : R) : module._IsTorsionBy R â†¥(Submodule.IsTorsionBy R m A) A
{Î± : Type u} (l : List Î±) (n k : â„•) (hk : k < l.length) : (l.Rotate n).nth_LE ((l.length - n % l.length + k) % l.length) _ = l.nth_LE k hk
{Î± : Type u} [PseudoMetricSpace Î±] {S t : set Î±} {x : Î±} (h : S âŠ† t) (hs : S.Nonempty) : metric.Inf_dist x t â‰¤ metric.Inf_dist x S
{G : Type u_1} [comm_Group G] (K : Subgroup G) {Î¹ : Type u_2} {t : Finset Î¹} {F : Î¹ â†’ G} (h : âˆ€ (C : Î¹), C âˆˆ t â†’ F C âˆˆ K) : t.Prod (Î» (C : Î¹), F C) âˆˆ K
{m : Type u_1} [has_Mul m] (C : Con m) {x y z : m} : â‡‘C x y â†’ â‡‘C y z â†’ â‡‘C x z
(n : â„•) : (Finset.Nat.antidiagonal n).Card = n + 1
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [LinearOrder Î±] [order_IsClosed_topology Î±] [Nonempty Î±] [TopologicalSpace Î²] [has_One Î±] {F : Î² â†’ Î±} (hF : Continuous F) (h : HasCompactMulSupport F) : BddAbove (set.Range F)
{Î± : Type u} {Î² : Type v} [PseudoEmetricSpace Î±] [PseudoEmetricSpace Î²] {K : Nnreal} {F : Î± â†’ Î²} (hF : LipschitzWith K F) : Continuous F
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {E' : Type u_3} [NormedGroup E'] [NormedSpace ð•œ E'] {F : E â†’ E'} {x : E} {F' : TangentSpace (model_with_corners_self ð•œ E) x â†’L[ð•œ] TangentSpace (model_with_corners_self ð•œ E') (F x)} : HasFderivAt F F' x â†’ HasMfderivAt (model_with_corners_self ð•œ E) (model_with_corners_self ð•œ E') F x F'
{Î± : Type u_1} [PartialOrder Î±] [PredOrder Î±] {A B : Î±} [NoMinOrder Î±] : A â‰  B â†’ Order.Pred A â‰  Order.Pred B
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {n : WithTop â„•} [CompleteSpace ð•œ] (F : LocalHomeomorph ð•œ ð•œ) {Fâ‚€' A : ð•œ} (hâ‚€ : Fâ‚€' â‰  0) (ha : A âˆˆ F.to_local_Equiv.Target) (hFâ‚€' : HasDerivAt â‡‘F Fâ‚€' (â‡‘(F.Symm) A)) (hF : ContDiff_at ð•œ n â‡‘F (â‡‘(F.Symm) A)) : ContDiff_at ð•œ n â‡‘(F.Symm) A
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : RË£) (n : â„•) : (Î» (t : R), Ring.Inverse (â†‘x + t) - (Finset.Range n).Sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ n
{ð•œ : Type u_1} {E : Type u_2} [_R_or_C ð•œ] [InnerProductSpace ð•œ E] (K : Submodule ð•œ E) (h : IsComplete â†‘K) (u : E) : âˆƒ (v : E) (h : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (W : â†¥â†‘K), âˆ¥u - â†‘Wâˆ¥
{Î± : Type u_1} {P : set Î± â†’ Prop} {m : Î  (S : set Î±), P S â†’ Ennreal} {P0 : P âˆ…} {m0 : m âˆ… P0 = 0} (PU : âˆ€ â¦ƒF : â„• â†’ set Î±â¦„, (âˆ€ (i : â„•), P (F i)) â†’ P (â‹ƒ (i : â„•), F i)) (msU : âˆ€ â¦ƒF : â„• â†’ set Î±â¦„ (hm : âˆ€ (i : â„•), P (F i)), m (â‹ƒ (i : â„•), F i) _ â‰¤ âˆ‘' (i : â„•), m (F i) _) (m_Mono : âˆ€ â¦ƒSâ‚ Sâ‚‚ : set Î±â¦„ (hsâ‚ : P Sâ‚) (hsâ‚‚ : P Sâ‚‚), Sâ‚ âŠ† Sâ‚‚ â†’ m Sâ‚ hsâ‚ â‰¤ m Sâ‚‚ hsâ‚‚) (S : set Î±) : Measurable_set S â†” âˆ€ (t : set Î±), P t â†’ â‡‘(MeasureTheory.induced_OuterMeasure m P0 m0) (t âˆ© S) + â‡‘(MeasureTheory.induced_OuterMeasure m P0 m0) (t  S) â‰¤ â‡‘(MeasureTheory.induced_OuterMeasure m P0 m0) t
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x : v) : hb.oangle x x = 0
{Î± : Type u} (r S : Î± â†’ Î± â†’ Prop) [IsNonstrictStrictOrder Î± r S] {A B : Î±} : S A B â†” r A B âˆ§ Â¬r B A
{Î± : Type u} [TopologicalSpace Î±] {S t : set Î±} (hs : IsPreconnected S) (ht : IsClopen t) (hne : (S âˆ© t).Nonempty) : S âŠ† t
{Î± : Type u} [AddCommGroup Î±] [has_LT Î±] [CovariantClass Î± Î± has_Add.Add has_LT.LT] {A B C : Î±} : A + B < C â†’ B < C - A
{Î² : Type u} {Î± : Type v} {Î³ : Type W} [CommSemiring Î²] [CommSemiring Î³] (g : Î² â†’+* Î³) (F : Î± â†’ Î²) (S : Finset Î±) : â‡‘g (S.Prod (Î» (x : Î±), F x)) = S.Prod (Î» (x : Î±), â‡‘g (F x))
{Î± : Type u} [AddMonoid Î±] (F : â„• â†’ Î±) (n : â„•) : (List.Map F (List.Range n.Succ)).Sum = F 0 + (List.Map (Î» (i : â„•), F i.Succ) (List.Range n)).Sum
{Î± : Type u_1} {Î² : Type u_3} [MeasurableSpace Î±] [MeasurableSpace Î²] {Î½ : MeasureTheory.Measure Î²} [MeasureTheory.sigma_Finite Î½] {F : Î± â†’ Î² â†’ Ennreal} (hF : Measurable (Function.uncurry F)) : Measurable (Î» (x : Î±), âˆ«â» (y : Î²), F x y âˆ‚Î½)
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [module.Finite K L] [_alg_IsClosed E] (pB : power_Basis K L) [_IsSeparable K L] (e : Fin pB.dim â‰ƒ (L â†’â‚[K] E)) : â‡‘(Algebra_Map K E) (Algebra.discr K â‡‘(pB.Basis)) = (-1) ^ (Finite_dimensional.finrank K L * (Finite_dimensional.finrank K L - 1) / 2) * Finset.Univ.Prod (Î» (i : Fin pB.dim), (Finset.Filter (Î» (j : Fin pB.dim), i < j) Finset.Univ).Prod (Î» (j : Fin pB.dim), (â‡‘(â‡‘e j) pB.gen - â‡‘(â‡‘e i) pB.gen) * (â‡‘(â‡‘e i) pB.gen - â‡‘(â‡‘e j) pB.gen)))
{R : Type uâ‚} [OrderedSemiring R] {A : R} (Hsq : 0 â‰¤ A * A) (Hsq' : 0 â‰¤ (1 + A) * (1 + A)) (h : 0 â‰¤ 2 + A) (n : â„•) : 1 + â†‘n * A â‰¤ (1 + A) ^ n
(m : Type u_1) (Î± : Type u_2) [Group m] [MulAction m Î±] {Î¹ : sort u_3} {P : Î¹ â†’ Subgroup m} : MulAction.FixedPoints â†¥(supr P) Î± = â‹‚ (i : Î¹), MulAction.FixedPoints â†¥(P i) Î±
{R : Type u} [Ring R] (S : Subring R) {x y : R} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
 : â‡‘MeasureTheory.MeasureSpace.Volume (â‹ƒ (P : â„) (hp : 2 < P), {x : â„ | LiouvilleWith P x}) = 0
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (hx : x â‰  0) (hy : y â‰  0) : Real.cos (InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = -1
{C : Type uâ‚} [CategoryTheory.Category C] {A : Type uâ‚‚} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cáµ’áµ– â¥¤ A) : CategoryTheory.Presheaf.IsSheaf J P â†” âˆ€ â¦ƒx : Câ¦„ (S : CategoryTheory.Sieve x), S âˆˆ â‡‘J x â†’ Nonempty (CategoryTheory.Limits.IsLimit (P.Map_cone S.Arrows.Cocone.Op))
{Î± : Type u} [AddGroup Î±] [has_LE Î±] [CovariantClass Î± Î± has_Add.Add has_LE.LE] [CovariantClass Î± Î± (Function.Swap has_Add.Add) has_LE.LE] {A B : Î±} : -A â‰¤ B â†’ -B â‰¤ A
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {F : E â†’ F} (K : set (E â†’L[ð•œ] F)) : {x : E | Differentiable_at ð•œ F x âˆ§ fderiv ð•œ F x âˆˆ K} âŠ† fderiv_Measurable_aux.D F K
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryBiproducts C] (x : C) [CategoryTheory.Simple x] : CategoryTheory.Indecomposable x
{v : Type u_1} [InnerProductSpace â„ v] {x y : v} (h : InnerProductGeometry.angle x y = Real.Pi) : HasInner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
(x : Pgame) : (1 * x).Equiv x
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} (F : C.Quotient â†’* P) : C.Lift (F.Comp C.Mk') _ = F
{Î± : Type u_1} {râ‚ râ‚‚ : Setoid Î±} : râ‚ = râ‚‚ â†” râ‚.Rel = râ‚‚.Rel
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [OrderedSemiring ð•œ] [AddCommGroup E] [module ð•œ E] {P : Î¹ â†’ E} (hc : Convex_Independent ð•œ P) : Convex_Independent ð•œ (Î» (x : â†¥(set.Range P)), â†‘x)
{R : Type u_1} [Add_Right_cancel_Semigroup R] (g : R) : _Add_Right_regular g
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x y : v) : o.oangle x (-y) + o.oangle y (-x) = 0
{Î± : Type u_1} {E : Î± â†’ Type u_2} {P : Ennreal} [Î  (i : Î±), NormedGroup (E i)] [Fact (1 â‰¤ P)] : uniform_Continuous Coe
{Î± : Type u} {Î² : Type v} {m : Type W} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {W : Î± â†’ m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : âˆ€ (y : Î²), y âˆ‰ t â†’ 0 â‰¤ (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x)) (ht : t.Nonempty) (hb : S.Sum (Î» (x : Î±), W x) â‰¤ t.Card â€¢ B) : âˆƒ (y : Î²) (h : y âˆˆ t), (Finset.Filter (Î» (x : Î±), F x = y) S).Sum (Î» (x : Î±), W x) â‰¤ B
{Î± : Type u} {Î² : Type v} [TopologicalSpace Î±] [LinearOrder Î±] [order_IsClosed_topology Î±] [Nonempty Î±] [TopologicalSpace Î²] [has_Zero Î±] {F : Î² â†’ Î±} (hF : Continuous F) (h : has_IsCompact_Support F) : BddBelow (set.Range F)
{ð•œ : Type u_1} [nondiscrete_NormedField ð•œ] {E : Type u_2} [NormedGroup E] [NormedSpace ð•œ E] {F : Type u_3} [NormedGroup F] [NormedSpace ð•œ F] {S : set E} {F : E â†’ F} {x : E} {n : WithTop â„•} {P : E â†’ FormalMultilinearSeries ð•œ E F} (h : HasFtaylorSeriesUpToOn n F P S) {m : â„•} (hmn : â†‘m â‰¤ n) (hs : UniqueDiffOn ð•œ S) (hx : x âˆˆ S) : P x m = iterated_fderiv_within ð•œ m F S x
{Î± : Type u_1} [Linear_ordered_Field Î±] {A B C : Î±} (hb : 0 â‰¤ B) (hc : 0 â‰¤ C) (h : A â‰¤ C * B) : A / B â‰¤ C
{Ï„ : Type u_1} [AddMonoid Ï„] [TopologicalSpace Ï„] [has_Continuous_Add Ï„] {Î± : Type u_2} [TopologicalSpace Î±] (Ï• : Flow Ï„ Î±) {Î² : Type u_3} [TopologicalSpace Î²] {t : Î² â†’ Ï„} (ht : Continuous t) {F : Î² â†’ Î±} (hF : Continuous F) : Continuous (Î» (x : Î²), â‡‘Ï• (t x) (F x))
{Î± : Type u} {Î² : Type v} [DecidableEq Î²] {S : Finset Î±} {t : Finset Î²} {F : Î± â†’ Î²} {n : â„•} (hF : âˆ€ (A : Î±), A âˆˆ S â†’ F A âˆˆ t) (ht : t.Nonempty) (hn : t.Card * n â‰¤ S.Card) : âˆƒ (y : Î²) (h : y âˆˆ t), n â‰¤ (Finset.Filter (Î» (x : Î±), F x = y) S).Card
{R : Type u_2} {m : Type u_3} {N : Type u_4} [CommSemiring R] [AddCommMonoid m] [AddCommMonoid N] [module R m] [module R N] {m : Type u_1} {n : Type u_5} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] (bM : Basis m R m) (bN : Basis n R N) (j : m) (i : n) : â‡‘(Linear_Map.to_Matrix bM bN) (â‡‘(dual_tensor_hom R m N) (bM.coord j âŠ—â‚œ[R] â‡‘bN i)) = Matrix.std_Basis_Matrix i j 1
(n : â„•) (Î¸ : â„‚) : Complex.sin ((â†‘n + 1) * Î¸) = Polynomial.Eval (Complex.cos Î¸) (Polynomial.Chebyshev.U â„‚ n) * Complex.sin Î¸
{Î± : Type u} [TopologicalSpace Î±] [t2_Space Î±] [CompactSpace Î±] (x : Î±) : ConnectedComponent x = â‹‚ (Z : {Z // IsClopen Z âˆ§ x âˆˆ Z}), â†‘Z
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {Î¹ : Type u_4} [Invertible 2] (P : Î¹ â†’ P) (iâ‚ iâ‚‚ : Î¹) : Finset.centroid k {iâ‚, iâ‚‚} P = 2â»Â¹ â€¢ (P iâ‚‚ -áµ¥ P iâ‚) +áµ¥ P iâ‚
{G : Type u_1} [AddGroup G] (K : Add_Subgroup G) {k : set G} : Add_Subgroup.Closure k â‰¤ K â†” k âŠ† â†‘K
{R : Type u_1} {m : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup m] [module R m] [no_Zero_divisors R] {B : m â†’â‚—[R] m â†’â‚—[R] R} (v : Basis n R m) (hO : B._Ortho â‡‘v) (h : âˆ€ (i : n), Â¬B.IsOrtho (â‡‘v i) (â‡‘v i)) : B.nondegenerate
{v : Type u_1} [InnerProductSpace â„ v] {B : Basis (Fin 2) â„ v} (hb : Orthonormal â„ â‡‘B) (x y : v) {r : â„} (hr : r < 0) : hb.oangle x (r â€¢ y) = hb.oangle x (-y)
{R : Type u1} [CommSemiring R] {m : Type u2} [AddCommMonoid m] [module R m] {A : Type u_1} [Semiring A] [Algebra R A] {F g : exterior_Algebra R m â†’â‚[R] A} (h : F.to_Linear_Map.Comp (exterior_Algebra.Î¹ R) = g.to_Linear_Map.Comp (exterior_Algebra.Î¹ R)) : F = g
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace â„ P} {P1 P2 : P} (hp1 : P1 âˆˆ S) (hp2 : P2 âˆˆ S) (r1 r2 : â„) {v : v} (hv : v âˆˆ (S.direction)á—®) : HasDist.dist (r1 â€¢ v +áµ¥ P1) (r2 â€¢ v +áµ¥ P2) * HasDist.dist (r1 â€¢ v +áµ¥ P1) (r2 â€¢ v +áµ¥ P2) = HasDist.dist P1 P2 * HasDist.dist P1 P2 + (r1 - r2) * (r1 - r2) * (âˆ¥vâˆ¥ * âˆ¥vâˆ¥)
{Î³ : Type u_3} [tÎ³ : TopologicalSpace Î³] [PolishSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³] {Î² : Type u_4} [tÎ² : TopologicalSpace Î²] [t2_Space Î²] [MeasurableSpace Î²] [BorelSpace Î²] {F : Î³ â†’ Î²} [TopologicalSpace.SecondCountableTopology Î²] (F_Meas : Measurable F) (F_inj : Function.Injective F) : Measurable_Embedding F
 : Cardinal.Mk â†¥set.Univ = Cardinal.Continuum
{R : Type x} [has_Mul R] [has_Add R] [Left_Distrib_class R] (A B C : R) : A * (B + C) = A * B + A * C
{Î± : Type u_1} [Linear_ordered_Field Î±] {m n : â„•} : â†‘(m / n) â‰¤ â†‘m / â†‘n
{v : Type u_1} [InnerProductSpace â„ v] [hD2 : Fact (Finite_dimensional.finrank â„ v = 2)] (o : Orientation â„ v (Fin 2)) (x : v) {r : â„} (hr : 0 â‰¤ r) : o.oangle (r â€¢ x) x = 0
{Î± : Type u_1} {Î² : Type u_2} [LinearOrder Î±] [PredOrder Î±] [Preorder Î²] {F : Î± â†’ Î²} (hF : Monotone F) : Pairwise (Disjoint on Î» (n : Î±), set.ioc (F (Order.Pred n)) (F n))
{v : Type u_1} {P : Type u_2} [InnerProductSpace â„ v] [MetricSpace P] [NormedAddTorsor v P] {n : â„•} (S : Affine.Simplex â„ P (n + 2)) {iâ‚ iâ‚‚ : Fin (n + 3)} : (S.monge_plane iâ‚ iâ‚‚).direction = (Submodule.Span â„ {S.points iâ‚ -áµ¥ S.points iâ‚‚})á—® âŠ“ Vector_Span â„ (set.Range S.points)
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] (F : m â†’+ P) : Function.Injective â‡‘(Add_Con.Ker_Lift F)
{Î± : Type u} [TopologicalSpace Î±] {S : set Î±} : S.Nonempty â†’ (Closure S).Nonempty
{Î± : Type u_1} {Î² : Type u_2} {m : Type u_5} [CommMonoid m] [DecidableEq Î±] [DecidableEq Î²] (S : Finset (Î± Ã— Î²)) (F : Î± Ã— Î² â†’ m) : finprod (Î» (Ab : Î± Ã— Î²), finprod (Î» (h : Ab âˆˆ S), F Ab)) = finprod (Î» (A : Î±), finprod (Î» (B : Î²), finprod (Î» (h : B âˆˆ Finset.image Prod.Snd (Finset.Filter (Î» (Ab : Î± Ã— Î²), Ab.fst = A) S)), F (A, B))))
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] {F : x â†’ Y} (hF : IsLocallyConstant F) {S : set x} (hs : IsPreconnected S) {x y : x} (hx : x âˆˆ S) (hy : y âˆˆ S) : F x = F y
{Î¹ : Type u_1} {R : Type u_8} [canonically_ordered_CommSemiring R] {F g h : Î¹ â†’ R} {S : Finset Î¹} {i : Î¹} (hi : i âˆˆ S) (h2i : g i + h i â‰¤ F i) (hgf : âˆ€ (j : Î¹), j âˆˆ S â†’ j â‰  i â†’ g j â‰¤ F j) (hhf : âˆ€ (j : Î¹), j âˆˆ S â†’ j â‰  i â†’ h j â‰¤ F j) : S.Prod (Î» (i : Î¹), g i) + S.Prod (Î» (i : Î¹), h i) â‰¤ S.Prod (Î» (i : Î¹), F i)
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {x y : m} (F : m â†’â‚—[R] N) (h : SameRay R x y) : SameRay R (â‡‘F x) (â‡‘F y)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {Pâ‚ Pâ‚‚ : P} (h : Pâ‚ â‰  Pâ‚‚) : AffineIndependent k ![Pâ‚, Pâ‚‚]
{Î± : Type u_1} [Preorder Î±] [locally_Finite_order Î±] {A B : Î±} : Â¬A < B â†’ Finset.Ico A B = âˆ…
{m : Type u_1} [Monoid m] (A : m) (u : mË£) : IsUnit (A * â†‘u) â†” IsUnit A
{Î± : Type u} {Î² : Type v} [DecidableEq Î±] [CommMonoid Î²] {S : Finset Î±} {x : Î±} (h : x âˆ‰ S) (F : Finset Î± â†’ Î²) : (HasInsert.Insert x S).powerset.Prod (Î» (A : Finset Î±), F A) = S.powerset.Prod (Î» (A : Finset Î±), F A) * S.powerset.Prod (Î» (t : Finset Î±), F (HasInsert.Insert x t))
{Î± : Type u} [TopologicalSpace Î±] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (Z : Î¹ â†’ set Î±) (hZd : Directed Superset Z) (hZn : âˆ€ (i : Î¹), (Z i).Nonempty) (hZc : âˆ€ (i : Î¹), IsCompact (Z i)) (hZcl : âˆ€ (i : Î¹), IsClosed (Z i)) : (â‹‚ (i : Î¹), Z i).Nonempty
{Î¹ : Type uâ‚} {k : Type uâ‚‚} {v : Type uâ‚ƒ} {P : Type uâ‚„} [AddCommGroup v] [AddTorsor v P] [CommRing k] [module k v] [DecidableEq Î¹] [Fintype Î¹] (B Bâ‚‚ : affine_Basis Î¹ k P) (x : P) : (B.to_Matrix Bâ‚‚.points).det â€¢ â‡‘(Bâ‚‚.coords) x = â‡‘((B.to_Matrix Bâ‚‚.points).transpose.cramer) (â‡‘(B.coords) x)
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (m : m) : âˆ¥â†‘mâˆ¥ â‰¤ âˆ¥mâˆ¥
