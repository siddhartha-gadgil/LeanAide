{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {n : with_top â„•} : cont_mdiff I I' n f â†” continuous f âˆ§ âˆ€ (x : M) (y : M'), cont_diff_on ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (f â»Â¹' (ext_chart_at I' y).source))
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] {n : â„•} (dec : vector bool n â†’ Î“) : turing.TM1.stmt Î“ Î› Ïƒ â†’ turing.TM1.stmt bool turing.TM1to1.Î›' Ïƒ
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] (f : Î± â†’ E) (h_mem_â„’p : measure_theory.mem_â„’p f p Î¼) : â†¥(measure_theory.Lp E p Î¼)
(Ï† fn : interactive.parse (lean.parser.pexpr std.prec.max)) : tactic unit
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : is_open_map (tangent_bundle.proj I M)
{ğ•œ : Type u_1} {ğ• : Type u_2} {E : Type u_3} [normed_field ğ•œ] [normed_ring ğ•] [normed_space ğ•œ ğ•] [add_comm_group E] [module ğ•œ E] [smul_with_zero ğ• E] [is_scalar_tower ğ•œ ğ• E] {s : set E} (hs : balanced ğ• s) {a : ğ•} {b : ğ•œ} (h : âˆ¥aâˆ¥ â‰¤ âˆ¥bâˆ¥) : a â€¢ s âŠ† b â€¢ s
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {Î¹ : Type u_1} [topological_space Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} : tendsto_locally_uniformly F f p â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆ€ (x : Î²), âˆƒ (t : set Î²) (H : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_dist.dist (f y) (F n y) < Îµ
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F : C â¥¤ D} {G : D â¥¤ C} (Î· : ğŸ­ C â‰… F â‹™ G) (Îµ : G â‹™ F â‰… ğŸ­ D) : ğŸ­ C â‰… F â‹™ G
{c : Type u â†’ Type u} (hom : Î  â¦ƒÎ± Î² : Type uâ¦„, c Î± â†’ c Î² â†’ Type u) [ğ’ : category_theory.bundled_hom hom] : category_theory.concrete_category (category_theory.bundled c)
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) {W X Y : C} (f : W âŸ¶ X) (g : W âŸ¶ Y) [category_theory.limits.preserves_colimit (category_theory.limits.span f g) G] : category_theory.limits.preserves_colimit (category_theory.limits.span g f) G
{Î± : Type u_1} {E' : Type u_5} {ğ•œ : Type u_11} {p : ennreal} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E'] [complete_space E'] [normed_space â„ E'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (f g : â†¥(measure_theory.Lp E' p Î¼)) (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) (hf_int_finite : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ measure_theory.integrable_on â‡‘f s Î¼) (hg_int_finite : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ measure_theory.integrable_on â‡‘g s Î¼) (hfg : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘g x âˆ‚Î¼) (hf_meas : measure_theory.ae_strongly_measurable' m â‡‘f Î¼) (hg_meas : measure_theory.ae_strongly_measurable' m â‡‘g Î¼) : â‡‘f =áµ[Î¼] â‡‘g
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {Î¼ : measure_theory.measure â„} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X â†’ â„ â†’ E} {bound : â„ â†’ â„} {a b : â„} (hF_meas : âˆ€ (x : X), measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€ (x : X), âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ¥F x tâˆ¥ â‰¤ bound t) (bound_integrable : interval_integrable bound Î¼ a b) (h_cont : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ continuous (Î» (x : X), F x t)) : continuous (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼)
{R : Type u} {S : Type v} [comm_semiring R] [semiring S] [algebra R S] (a : set R) : submodule.span R (â‡‘(algebra_map R S) '' a) = submodule.map (algebra.linear_map R S) (submodule.span R a)
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (h'f' : âˆ€ (x : E), x âˆˆ s â†’ (f' x).det = 0) : â‡‘Î¼ (f '' s) = 0
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) {Î¼ : ğ•œ} (hÎ¼ : module.End.has_eigenvalue T Î¼) : â‡‘(star_ring_end ğ•œ) Î¼ = Î¼
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b : â„} {f g : â„‚ â†’ E} (hdf : diff_cont_on_cl â„‚ f (complex.im â»Â¹' set.Ioo a b)) (hBf : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.re) filter.at_top âŠ“ filter.principal (complex.im â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.re|))) (hdg : diff_cont_on_cl â„‚ g (complex.im â»Â¹' set.Ioo a b)) (hBg : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), g =O[filter.comap (has_abs.abs âˆ˜ complex.re) filter.at_top âŠ“ filter.principal (complex.im â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.re|))) (ha : âˆ€ (z : â„‚), z.im = a â†’ f z = g z) (hb : âˆ€ (z : â„‚), z.im = b â†’ f z = g z) : set.eq_on f g (complex.im â»Â¹' set.Icc a b)
{Î¹ : Type u_4} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), semi_normed_ring (Ï€ i)] : semi_normed_ring (Î  (i : Î¹), Ï€ i)
{Î± : Type u_1} (s : set Î±) (r : Î± â†’ Î± â†’ Prop) : s.pairwise r â†’ pairwise (Î» (x y : â†¥s), r â†‘x â†‘y)
{R : Type u} [comm_ring R] (I : ideal R) [hI : I.is_maximal] : field (R â§¸ I)
{R : Type u} {Î¹ : Type v} [comm_ring R] {L : Type w} [lie_ring L] [lie_algebra R L] (I : Î¹ â†’ lie_ideal R L) : lie_algebra R (direct_sum Î¹ (Î» (i : Î¹), â†¥(I i)))
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary (f âˆ˜ â‡‘Ïƒ) g
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] [category_theory.limits.preserves_limit I.multicospan (category_theory.forget C)] : â†¥(category_theory.limits.multiequalizer I) â‰ƒ {x // âˆ€ (i : I.R), â‡‘(I.fst i) (x (I.fst_to i)) = â‡‘(I.snd i) (x (I.snd_to i))}
{Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), comm_ring (G i)] {f' : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’+* G j} [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h))] [is_directed Î¹ has_le.le] {i : Î¹} {x : G i} (hix : â‡‘(ring.direct_limit.of G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h)) i) x = 0) : âˆƒ (j : Î¹) (hij : i â‰¤ j), â‡‘(f' i j hij) x = 0
(s : simp_lemmas) (to_unfold : list name := list.nil) (e : expr) (cfg : tactic.simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}) (r : name := name.mk_string "eq" name.anonymous) (discharger : tactic unit := tactic.failed) : tactic (expr Ã— expr Ã— name_set)
(Î± : Type u_1) (E : Type u_2) [normed_group E] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_space â„ E] : â†¥(measure_theory.Lp.simple_func E 1 Î¼) â†’L[â„] E
{n : â„•} (i : fin2 n) â¦ƒÎ± : typevec nâ¦„ â¦ƒÎ² : typevec nâ¦„ (f : Î±.arrow Î²) : mvqpf.prj i Î± â†’ mvqpf.prj i Î²
{Î± : Type u_1} {Ïƒ : Type u_2} [primcodable Î±] [primcodable Ïƒ] {c : Î± â†’ nat.partrec.code} (hc : computable c) {z : Î± â†’ Ïƒ} (hz : computable z) {s : Î± â†’ Ïƒ} (hs : computable s) {l : Î± â†’ Ïƒ} (hl : computable l) {r : Î± â†’ Ïƒ} (hr : computable r) {pr : Î± â†’ nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ â†’ Ïƒ} (hpr : computableâ‚‚ pr) {co : Î± â†’ nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ â†’ Ïƒ} (hco : computableâ‚‚ co) {pc : Î± â†’ nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ â†’ Ïƒ} (hpc : computableâ‚‚ pc) {rf : Î± â†’ nat.partrec.code Ã— Ïƒ â†’ Ïƒ} (hrf : computableâ‚‚ rf) : let PR : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), pr a (cf, cg, hf, hg), CO : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), co a (cf, cg, hf, hg), PC : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), pc a (cf, cg, hf, hg), RF : Î± â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf : nat.partrec.code) (hf : Ïƒ), rf a (cf, hf), F : Î± â†’ nat.partrec.code â†’ Ïƒ := Î» (a : Î±) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a) in computable (Î» (a : Î±), F a (c a))
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] : category_theory.limits.multifork I
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) : Î± â†’ ennreal
(attr_name src tgt : name) (p : option bool := option.none) : tactic unit
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î²] {m : measurable_space Î±} (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{Î± : Type u_1} {Ïƒ : Î± â†’ Type u_5} (s : multiset Î±) (t : Î  (a : Î±), multiset (Ïƒ a)) : multiset (Î£ (a : Î±), Ïƒ a)
{Î¹a : Type u_7} {Î¹b : Type u_8} [decidable_eq Î¹a] [decidable_eq Î¹b] [fintype Î¹a] [fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [comm_semiring R'] [add_comm_group Nâ‚] [module R' Nâ‚] [add_comm_group Nâ‚‚] [module R' Nâ‚‚] [add_comm_monoid Máµ¢] [module R' Máµ¢] (a : alternating_map R' Máµ¢ Nâ‚ Î¹a) (b : alternating_map R' Máµ¢ Nâ‚‚ Î¹b) (Ïƒ : equiv.perm.mod_sum_congr Î¹a Î¹b) : multilinear_map R' (Î» (_x : Î¹a âŠ• Î¹b), Máµ¢) (tensor_product R' Nâ‚ Nâ‚‚)
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â‰ƒg G') : G â†’g G'
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î¼ : measure_theory.finite_measure Î±} {fs : â„• â†’ bounded_continuous_function Î± nnreal} {c : nnreal} (fs_le_const : âˆ€ (n : â„•) (a : Î±), â‡‘(fs n) a â‰¤ c) {f : bounded_continuous_function Î± nnreal} (fs_lim : âˆ€ (a : Î±), filter.tendsto (Î» (n : â„•), â‡‘(fs n) a) filter.at_top (nhds (â‡‘f a))) : filter.tendsto (Î» (n : â„•), Î¼.test_against_nn (fs n)) filter.at_top (nhds (Î¼.test_against_nn f))
{Î± : Sort u_1} {d : Î±} (x : Î± := d) : Î±
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a : â„} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [measure_theory.is_locally_finite_measure Î¼] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : u â‰¤á¶ [lt] v) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real
{x : pgame} : 0.lf x â†” âˆƒ (i : x.left_moves), 0 â‰¤ x.move_left i
{n : â„•+} {K : Type u_1} [field K] {L : Type u_2} [field L] {Î¼ : L} (hÎ¼ : is_primitive_root Î¼ â†‘n) [algebra K L] [is_cyclotomic_extension {n} K L] (h : irreducible (polynomial.cyclotomic â†‘n K)) [ne_zero â†‘â†‘n] : L â‰ƒâ‚[K] L
{G : Type u_1} [hG : group G] [hf : fintype G] (e : (Î  (p : â†¥((fintype.card G).factorization.support)) (P : sylow â†‘p G), â†¥â†‘P) â‰ƒ* G) : group.is_nilpotent G
{p : â„•} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] [char_p R p] (x y : witt_vector p R) (i j : â„•) : (â‡‘witt_vector.verschiebung^[i] x * â‡‘witt_vector.verschiebung^[j] y).coeff (i + j) = x.coeff 0 ^ p ^ j * y.coeff 0 ^ p ^ i
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {xâ‚ xâ‚‚ y z : V} (hxâ‚yne : xâ‚ â‰  y) (hxâ‚zne : xâ‚ â‰  z) (hxâ‚‚yne : xâ‚‚ â‰  y) (hxâ‚‚zne : xâ‚‚ â‰  z) {r : â„} (hxâ‚ : âˆ¥xâ‚âˆ¥ = r) (hxâ‚‚ : âˆ¥xâ‚‚âˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : 2 â€¢ o.oangle (y - xâ‚) (z - xâ‚) = 2 â€¢ o.oangle (y - xâ‚‚) (z - xâ‚‚)
{elab : bool := bool.tt} : expr elab â†’ option (name Ã— name Ã— binder_info Ã— expr elab)
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] (f : Î± â†’ Î²) (hf : function.injective f) (hfm : measurable f) (hfi : âˆ€ (s : set Î±), measurable_set s â†’ measurable_set (f '' s)) : Î± â‰ƒáµ â†¥(set.range f)
{V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = 0
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space ğ•œ H] {F : H â†’ Î± â†’ E} {F' : Î± â†’ (H â†’L[ğ•œ] E)} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ measure_theory.ae_strongly_measurable (F x) Î¼) (hF_int : measure_theory.integrable (F xâ‚€) Î¼) (hF'_meas : measure_theory.ae_strongly_measurable F' Î¼) (h_lipsch : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ âˆ¥F x a - F xâ‚€ aâˆ¥ â‰¤ bound a * âˆ¥x - xâ‚€âˆ¥) (bound_integrable : measure_theory.integrable bound Î¼) (h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, has_fderiv_at (Î» (x : H), F x a) (F' a) xâ‚€) : measure_theory.integrable F' Î¼ âˆ§ has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
{Râ‚ : Type u_3} {A : Type u_5} {B : Type u_6} [comm_semiring Râ‚] [comm_ring A] [comm_ring B] [algebra Râ‚ A] [algebra Râ‚ B] {I : ideal A} (J : ideal B) (f : A â†’â‚[Râ‚] B) (hIJ : I â‰¤ ideal.comap â†‘f J) : A â§¸ I â†’â‚[Râ‚] B â§¸ J
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] {f g : Î± â†’ F'} (hf : measure_theory.integrable f Î¼) (hg_int_finite : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ measure_theory.integrable_on g s Î¼) (hg_eq : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ âˆ« (x : Î±) in s, g x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼) (hgm : measure_theory.ae_strongly_measurable' m g Î¼) : g =áµ[Î¼] measure_theory.condexp m Î¼ f
{Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} (hp_pos : p â‰  0) (hp_ne_top : p â‰  âŠ¤) {P : â†¥(measure_theory.Lp.simple_func E p Î¼) â†’ Prop} (h_ind : âˆ€ (c : E) {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s < âŠ¤), P (measure_theory.Lp.simple_func.indicator_const p hs _ c)) (h_add : âˆ€ â¦ƒf g : measure_theory.simple_func Î± Eâ¦„ (hf : measure_theory.mem_â„’p â‡‘f p Î¼) (hg : measure_theory.mem_â„’p â‡‘g p Î¼), disjoint (function.support â‡‘f) (function.support â‡‘g) â†’ P (measure_theory.Lp.simple_func.to_Lp f hf) â†’ P (measure_theory.Lp.simple_func.to_Lp g hg) â†’ P (measure_theory.Lp.simple_func.to_Lp f hf + measure_theory.Lp.simple_func.to_Lp g hg)) (f : â†¥(measure_theory.Lp.simple_func E p Î¼)) : P f
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] (M : turing.TM0.machine Î“ Î›) : turing.TM0.cfg Î“ Î› â†’ turing.TM1.cfg Î“ turing.TM0to1.Î›' unit
{Ïƒ : Type u} {m : Type u â†’ Type v} [monad m] [monad_state Ïƒ m] (st : Ïƒ) : m punit
{Î± : Type u_1} {E : Type u_2} [normed_group E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_space â„ E] [complete_space E] : â†¥(measure_theory.Lp E 1 Î¼) â†’L[â„] E
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] [measure_theory.is_finite_measure Î¼] (f : bounded_continuous_function Î± E) : âˆ¥âŸ¨continuous_map.to_ae_eq_fun Î¼ f.to_continuous_map, _âŸ©âˆ¥ â‰¤ â†‘(measure_theory.measure_univ_nnreal Î¼) ^ (p.to_real)â»Â¹ * âˆ¥fâˆ¥
{E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {c : â„‚} {R C : â„} (hR : 0 < R) (hc : continuous_on f (metric.sphere c R)) (hf : âˆ€ (z : â„‚), z âˆˆ metric.sphere c R â†’ âˆ¥f zâˆ¥ â‰¤ C) (hlt : âˆƒ (z : â„‚) (H : z âˆˆ metric.sphere c R), âˆ¥f zâˆ¥ < C) : âˆ¥âˆ® (z : â„‚) in C(c, R), f zâˆ¥ < 2 * real.pi * R * C
{Î± : Type u} [pseudo_metric_space Î±] (x : Î±) (Îµ : â„) : set Î±
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â†’g G') (d : G.dart) : G'.dart
(t : tactic unit := tactic.skip) : tactic unit
(R : Type u) (Ïƒ : Type u_1) [comm_semiring R] : multiplicative (Ïƒ â†’â‚€ â„•) â†’* mv_polynomial Ïƒ R
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} : cont_mdiff_on I I' n f s â†” continuous_on f s âˆ§ âˆ€ (x : M) (y : M'), cont_diff_on ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source))
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : cont_mdiff_map I I' M M' âŠ¤) (x : M) : point_derivation I x â†’â‚—[ğ•œ] point_derivation I' (â‡‘f x)
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) (i : fin (n + 2)) : vector_span â„ (s.points '' â†‘(finset.univ.erase i)) â‰¤ ((s.altitude i).direction)á—®
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) {W X Y : C} (f : W âŸ¶ X) (g : W âŸ¶ Y) [category_theory.limits.preserves_colimit (category_theory.limits.span f g) G] [category_theory.limits.has_pushout f g] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (G.map category_theory.limits.pushout.inl) (G.map category_theory.limits.pushout.inr) _)
{P : Type u_1} [has_le P] (I : order.ideal P) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {W X Y Z : C} [category_theory.limits.has_binary_biproduct W X] [category_theory.limits.has_binary_biproduct Y Z] (f : W â‰… Y) (g : X â‰… Z) : W âŠ X â‰… Y âŠ Z
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] {H' : Type u_5} [topological_space H'] {E' : Type u_6} [normed_group E'] [normed_space ğ•œ E'] (I : model_with_corners ğ•œ E H) (I' : model_with_corners ğ•œ E' H') (G : Type u_8) [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] (G' : Type u_9) [topological_space G'] [charted_space H' G'] [monoid G'] [has_smooth_mul I' G'] : Type (max u_8 u_9)
{R : Type u} [comm_ring R] (I : ideal R) {Î¹ : Type u_1} [fintype Î¹] {Î¹' : Type w} (x : Î¹ â†’ R) (hi : âˆ€ (i : Î¹), x i âˆˆ I) (f : (Î¹ â†’ R) â†’â‚—[R] Î¹' â†’ R) (i : Î¹') : â‡‘f x i âˆˆ I
{R : Type u} [ring R] {Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type v) [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [decidable_eq Î¹] [nonempty Î¹] [is_directed Î¹ has_le.le] : category_theory.limits.is_colimit (Module.direct_limit_cocone G f)
{Î± : Type u} [linear_ordered_ring Î±] (a : Î±) : |a| = a âˆ§ 0 â‰¤ a âˆ¨ |a| = -a âˆ§ a < 0
{M : Type u} [mul_one_class M] : reflexive (Î» (a b : M), âˆƒ (c : M), semiconj_by c a b)
{A : Type u_1} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module â„‚ A] [nontrivial A] {a : A} (ha : a âˆˆ self_adjoint A) : spectrum â„‚ a = coe âˆ˜ complex.re '' spectrum â„‚ a
{M : Type u_1} [has_mul M] (S : set (con M)) : has_Sup.Sup S = con_gen (Î» (x y : M), âˆƒ (c : con M), c âˆˆ S âˆ§ â‡‘c x y)
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] (h : box_integral.integrable I l f vol) {Ï€â‚ Ï€â‚‚ : box_integral.prepartition I} (hU : Ï€â‚.Union = Ï€â‚‚.Union) : Ï€â‚.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol) = Ï€â‚‚.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)
(I : name) : tactic tactic.eliminate.inductive_info
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g i) < s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â†” Â¬antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
{Î· : Type u_5} {f : Î· â†’ Type u_6} [Î  (i : Î·), add_zero_class (f i)] (I : set Î·) (s : Î  (i : Î·), add_submonoid (f i)) : add_submonoid (Î  (i : Î·), f i)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_4} [topological_space H] {H' : Type u_5} [topological_space H'] {I : model_with_corners ğ•œ E H} {I' : model_with_corners ğ•œ E' H'} {M : Type u_6} [topological_space M] [charted_space H M] {M' : Type u_7} [topological_space M'] [charted_space H' M'] {E'' : Type u_8} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_9} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_10} [topological_space M''] [charted_space H'' M''] {n : with_top â„•} (f : cont_mdiff_map I' I'' M' M'' n) (g : cont_mdiff_map I I' M M' n) : cont_mdiff_map I I'' M M'' n
{Î± : Type u_1} [semi_normed_ring Î±] [norm_one_class Î±] (a : Î±) (n : â„•) : âˆ¥a ^ nâˆ¥ â‰¤ âˆ¥aâˆ¥ ^ n
{I : Type wâ‚€} (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] {J : Type wâ‚} {K : Type wâ‚‚} (f : K â†’ J) (g : J â†’ I) : category_theory.pi.comap C g â‹™ category_theory.pi.comap (C âˆ˜ g) f â‰… category_theory.pi.comap C (g âˆ˜ f)
{Ïƒ : Type u_1} {Ï„ : Type u_2} {R : Type u_4} [comm_semiring R] (f : mv_polynomial Ïƒ R â†’â‚[R] mv_polynomial Ï„ R) : (Ï„ â†’ R) â†’ Ïƒ â†’ R
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T âˆˆ dist_triang C) : T.morâ‚‚ â‰« T.morâ‚ƒ = 0
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {X Y Z : Î£ (i : I), C i} : category_theory.sigma.sigma_hom X Y â†’ category_theory.sigma.sigma_hom Y Z â†’ category_theory.sigma.sigma_hom X Z
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J â¥¤ C} {F : C â¥¤ D} [category_theory.reflects_isomorphisms F] (h : Î  (c : category_theory.limits.cocone (K â‹™ F)) (t : category_theory.limits.is_colimit c), category_theory.lifts_to_colimit K F c t) : category_theory.creates_colimit K F
{Î¹ : Type u_1} {ğ•œ : Type u_2} {ğ”¸ : Type u_3} [normed_field ğ•œ] [normed_group ğ”¸] [normed_space ğ•œ ğ”¸] {l : filter Î¹} {Îµ : Î¹ â†’ ğ•œ} {f : Î¹ â†’ ğ”¸} (hÎµ : filter.tendsto Îµ l (nhds 0)) (hf : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ f)) : filter.tendsto (Îµ â€¢ f) l (nhds 0)
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {F : Type u_2} [semi_normed_group F] [normed_space ğ•œ F] [normed_space â„ F] [is_scalar_tower â„ ğ•œ F] (fr : F â†’L[â„] â„) (x : F) : âˆ¥â‡‘(fr.to_linear_map.extend_to_ğ•œ') xâˆ¥ â‰¤ âˆ¥frâˆ¥ * âˆ¥xâˆ¥
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (W : submodule R M) : bilin_form R â†¥W
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] {X : C} {K : Type (max v u)} [category_theory.small_category K] [category_theory.limits.has_limits_of_shape K D] {W : (J.cover X)áµ’áµ–} (F : K â¥¤ Cáµ’áµ– â¥¤ D) (E : category_theory.limits.cone (F â‹™ J.diagram_functor D X â‹™ (category_theory.evaluation (J.cover X)áµ’áµ– D).obj W)) : E.X âŸ¶ (J.diagram (category_theory.limits.limit F) X).obj W
{a b : â„} {f f' : â„ â†’ â„} (hab : a â‰¤ b) (hf : âˆ€ (x : â„), x âˆˆ set.Icc a b â†’ has_deriv_within_at f (f' x) (set.Icc a b) x) {m : â„} (hma : m < f' a) (hmb : f' b < m) : m âˆˆ f' '' set.Icc a b
{Î¹ : Type uÎ¹} (R : Type uR) (A : Î¹ â†’ Type uA) {B : Type uB} [decidable_eq Î¹] [comm_semiring R] [Î  (i : Î¹), add_comm_monoid (A i)] [Î  (i : Î¹), module R (A i)] [add_monoid Î¹] [direct_sum.gsemiring A] [semiring B] [direct_sum.galgebra R A] [algebra R B] â¦ƒf g : direct_sum Î¹ (Î» (i : Î¹), A i) â†’â‚[R] Bâ¦„ (h : âˆ€ (i : Î¹), f.to_linear_map.comp (direct_sum.lof R Î¹ A i) = g.to_linear_map.comp (direct_sum.lof R Î¹ A i)) : f = g
{R : Type u_1} [comm_ring R] {f : polynomial R} {I : prime_spectrum (polynomial R)} (H : I âˆˆ (prime_spectrum.zero_locus {f})á¶œ) : â‡‘(prime_spectrum.comap polynomial.C) I âˆˆ algebraic_geometry.polynomial.image_of_Df f
{Î² : Type u} {Î± : Type v} [comm_monoid Î²] {Ïƒ : Î± â†’ Type u_1} (s : finset Î±) (t : Î  (a : Î±), finset (Ïƒ a)) (f : sigma Ïƒ â†’ Î²) : (s.sigma t).prod (Î» (x : Î£ (i : Î±), Ïƒ i), f x) = s.prod (Î» (a : Î±), (t a).prod (Î» (s : Ïƒ a), f âŸ¨a, sâŸ©))
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î±] [topological_space.second_countable_topology Î±] (s : set Î±) (hs : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (u : set Î±) (H : u âˆˆ nhds_within x s), â‡‘Î¼ u = 0)) : â‡‘Î¼ s = 0
(cs : list name) (e : expr) (cfg : tactic.delta_config := {max_steps := simp.default_max_steps, visit_instances := bool.tt}) : tactic expr
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] {s t : set Î±} (hs : measurable_set s) (ht : measurable_set t) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (hÎ¼t : â‡‘Î¼ t â‰  âŠ¤) (hst : s âˆ© t = âˆ…) (c : E) : measure_theory.indicator_const_Lp p _ _ c = measure_theory.indicator_const_Lp p hs hÎ¼s c + measure_theory.indicator_const_Lp p ht hÎ¼t c
{R : Type u_1} {S : Type u_6} {M : Type u_9} {Mâ‚ƒ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid Mâ‚ƒ] [module R M] [module S Mâ‚ƒ] {Ïƒ : R â†’+* S} : has_coe_to_fun (M â†’â‚›â‚—[Ïƒ] Mâ‚ƒ) (Î» (_x : M â†’â‚›â‚—[Ïƒ] Mâ‚ƒ), M â†’ Mâ‚ƒ)
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_2} [linear_order Î¹] [topological_space Î¹] [order_topology Î¹] [densely_ordered Î¹] [topological_space.first_countable_topology Î¹] {s : Î¹ â†’ set Î±} {a : Î¹} (hs : âˆ€ (r : Î¹), r > a â†’ measurable_set (s r)) (hm : âˆ€ (i j : Î¹), a < i â†’ i â‰¤ j â†’ s i âŠ† s j) (hf : âˆƒ (r : Î¹) (H : r > a), â‡‘Î¼ (s r) â‰  âŠ¤) : filter.tendsto (â‡‘Î¼ âˆ˜ s) (nhds_within a (set.Ioi a)) (nhds (â‡‘Î¼ (â‹‚ (r : Î¹) (H : r > a), s r)))
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a : â„} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [measure_theory.is_locally_finite_measure Î¼] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} : tendsto_uniformly F f p â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), has_edist.edist (f x) (F n x) < Îµ)
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î¼ : measure_theory.measure Î±} (s : Î¼.finite_spanning_sets_in {U : set Î± | is_open U âˆ§ (Î¼.restrict U).outer_regular}) : Î¼.outer_regular
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [fintype J] {K : Type v} [fintype K] {f : J â†’ C} {g : K â†’ C} [category_theory.limits.has_finite_biproducts C] : (â¨ f âŸ¶ â¨ g) â‰ƒ Î  (j : J) (k : K), f j âŸ¶ g k
(V : Type u_1) (W : Type u_2) [semi_normed_group V] [semi_normed_group W] : Type (max u_1 u_2)
{V W : SemiNormedGroup} (f g : V âŸ¶ W) : category_theory.limits.fork f g
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [measurable_space Î±] [measurable_space Î²] {f : Î¹ â†’ Î± â†’ Î²} {Î¼ : measure_theory.measure Î±} (hf : âˆ€ (i : Î¹), ae_measurable (f i) Î¼) (p : Î± â†’ (Î¹ â†’ Î²) â†’ Prop) : set Î±
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =o[l] g' â†’ (f =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{Î± : Type u_1} {Î³ : Type u_3} [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î³] [measurable_space Î³] [borel_space Î³] {f : Î± â†’ Î³} (h : continuous f) {Î¼ : measure_theory.measure Î±} : ae_measurable f Î¼
(e : expr) (n : â„•) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr Ã— expr)
{C : Type uâ‚} [category_theory.category C] {A : Type uâ‚‚} [category_theory.category A] {B : Type uâ‚ƒ} [category_theory.category B] (J : category_theory.grothendieck_topology C) (F : A â¥¤ B) [Î  (X : C) (S : J.cover X) (P : Cáµ’áµ– â¥¤ A), category_theory.limits.preserves_limit (S.index P).multicospan F] : category_theory.Sheaf J A â¥¤ category_theory.Sheaf J B
{Î± : Sort u_1} {Î² : Sort u_2} (Ï† : Î± â†’ Î² â†’ Sort u_3) : (Î  (a : Î±) (b : Î²), Ï† a b) â‰ƒ Î  (b : Î²) (a : Î±), Ï† a b
{elab : bool} : expr elab â†’ option (name Ã— expr elab)
(Îµ : â„) (l : â„•) : â„•
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {f : Î± â†’ ennreal} (h_mf : measurable f) {g : Î± â†’ ennreal} : measurable g â†’ âˆ«â» (a : Î±), g a âˆ‚Î¼.with_density f = âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼
{Î± : Type u} {C : list Î± â†’ Sort u_1} (H0 : C list.nil) (H1 : Î  (a : Î±), C [a]) (Hn : Î  (a : Î±) (l : list Î±) (b : Î±), C l â†’ C (a :: (l ++ [b]))) (l : list Î±) : C l
{Î± : Type u_1} {Î³ : Type u_3} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î³] [monoid Î³] [has_continuous_mul Î³] : (Î± â†’â‚˜[Î¼] Î³) â†’* Î¼.ae.germ Î³
{Î± : Type u_1} {G : Type u_8} [normed_group G] [normed_space â„ G] {m m0 : measurable_space Î±} (hm : m â‰¤ m0) (Î¼ : measure_theory.measure Î±) (s : set Î±) [measure_theory.sigma_finite (Î¼.trim hm)] (x : G) : â†¥(measure_theory.Lp G 1 Î¼)
{Î± : Type u_1} {ğ•œ : Type u_4} [is_R_or_C ğ•œ] [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (f : â†¥(measure_theory.Lp ğ•œ 2 Î¼)) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s 1) f = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
(md : tactic.transparency := tactic.transparency.reducible) : list (tactic string)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) {G : Type u_4} [has_add G] [topological_space G] [charted_space H G] [has_smooth_add I G] : has_continuous_add G
{P : Type u_2} [has_le P] (I : set P) : Prop
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} {S : J.cover X} {T : Î  (I : S.arrow), J.cover I.Y} (I : (S.bind T).arrow) : S.arrow
{Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_3} {f : Î± â†’ E} (hf : measure_theory.integrable f Î¼) {l : filter Î¹} {s : Î¹ â†’ set Î±} (hs : filter.tendsto (â‡‘Î¼ âˆ˜ s) l (nhds 0)) : filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} (t : category_theory.limits.pushout_cocone f g) {W : C} {k l : t.X âŸ¶ W} (hâ‚€ : t.inl â‰« k = t.inl â‰« l) (hâ‚ : t.inr â‰« k = t.inr â‰« l) (j : category_theory.limits.walking_span) : t.Î¹.app j â‰« k = t.Î¹.app j â‰« l
{R : Type u_1} {V : Type u_2} {W : Type u_3} {P : Type u_4} {Q : Type u_5} [ring R] [add_comm_group V] [module R V] [topological_space P] [add_torsor V P] [add_comm_group W] [module R W] [topological_space Q] [add_torsor W Q] : has_coe_to_fun (P â†’A[R] Q) (Î» (_x : P â†’A[R] Q), P â†’ Q)
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} {Ïƒ : Type u_3} : turing.TM1.stmt Î“ Î› Ïƒ â†’ Ïƒ â†’ turing.tape Î“ â†’ turing.TM1.cfg Î“ Î› Ïƒ
(e : expr) (check : bool := bool.tt) : tactic unit
{A : Type u} [comm_ring A] [is_domain A] [is_noetherian_ring A] (h_fA : Â¬is_field A) {I : ideal A} (h_nzI : I â‰  âŠ¥) : âˆƒ (Z : multiset (prime_spectrum A)), (multiset.map coe Z).prod â‰¤ I âˆ§ (multiset.map coe Z).prod â‰  âŠ¥
(X : Topáµ’áµ–) {R S : TopCommRing} (Ï† : R âŸ¶ S) : Top.continuous_functions X R âŸ¶ Top.continuous_functions X S
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â†ªg G') (v : V) : â†¥(G.neighbor_set v) â†ª â†¥(G'.neighbor_set (â‡‘f v))
{Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_metric_space (Ï€ b)] (x : Î  (b : Î²), Ï€ b) {r : â„} (hr : 0 < r) : metric.ball x r = set.univ.pi (Î» (b : Î²), metric.ball (x b) r)
{F : Type u_3} [inner_product_space â„ F] {x y : F} (h : has_inner.inner x y = 0) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) (f : Î± â†’ set (set Î±)) (s : set Î±) : Prop
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] {S : set (add_monoid_algebra R M)} (hS : algebra.adjoin R S = âŠ¤) : algebra.adjoin R (add_monoid_algebra.of' R M '' â‹ƒ (f : add_monoid_algebra R M) (H : f âˆˆ S), â†‘(f.support)) = âŠ¤
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal (R Ã— S)) : I.is_prime â†” (âˆƒ (p : ideal R), p.is_prime âˆ§ I = p.prod âŠ¤) âˆ¨ âˆƒ (p : ideal S), p.is_prime âˆ§ I = âŠ¤.prod p
{C : Type u} [category_theory.category C] {P Q : C} {t : category_theory.limits.binary_fan P Q} (I : category_theory.limits.is_limit t) : category_theory.limits.is_limit t.swap
{G : Type u_2} [group G] [topological_space G] [measurable_space G] (Î¼ : measure_theory.measure G) : Prop
{Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {u v w : set Î±} (hu : measurable_set u) (hv : measurable_set v) (hw : measurable_set w) (hsu : 0.restrict u â‰¤ measure_theory.vector_measure.restrict s u) (hwâ‚ : â‡‘s w = 0) (hwâ‚‚ : w âŠ† u) (hwt : v âŠ† w) : â‡‘s v = 0
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} : uniform_embedding f â†’ ((âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a b : Î±}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : ennreal), Î´ > 0 â†’ (âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î±}, has_edist.edist (f a) (f b) < Îµ â†’ has_edist.edist a b < Î´))
{C : Type u} [category_theory.category C] [category_theory.abelian C] (X : C) (I : category_theory.InjectiveResolution X) : homotopy (category_theory.InjectiveResolution.desc (ğŸ™ X) I I) (ğŸ™ I.cocomplex)
{M : Type u_1} [comm_monoid M] {Î¶ : M} {n a b : â„•} (hn : 0 < n) (h : is_primitive_root Î¶ n) (hprod : n = a * b) : is_primitive_root (Î¶ ^ a) b
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {Î¹ : Type v} [fintype Î¹] {E : Î¹ â†’ Type w} [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] {H : Î¹ â†’ Type u'} [Î  (i : Î¹), topological_space (H i)] (I : Î  (i : Î¹), model_with_corners ğ•œ (E i) (H i)) : model_with_corners ğ•œ (Î  (i : Î¹), E i) (model_pi H)
{R : Type u_5} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (h : is_primitive_root Î¶ n) : polynomial.nth_roots_finset n R = n.divisors.bUnion (Î» (i : â„•), primitive_roots i R)
{Î· : Type u_5} {f : Î· â†’ Type u_6} [Î  (i : Î·), mul_one_class (f i)] (I : set Î·) (s : Î  (i : Î·), submonoid (f i)) : submonoid (Î  (i : Î·), f i)
{L : first_order.language} {M : Type w} [L.Structure M] {Î± : Type u'} (Ï† : L.formula Î±) (v : Î± â†’ M) : Prop
{Î± : Type u_1} (E : Type u_4) [measurable_space Î±] [normed_group E] (p : ennreal) (Î¼ : measure_theory.measure Î±) : add_subgroup â†¥(measure_theory.Lp E p Î¼)
{Î± : Type u} [pseudo_metric_space Î±] : uniformity (uniform_space.completion Î±) = â¨… (Îµ : {Îµ // 0 < Îµ}), filter.principal {p : uniform_space.completion Î± Ã— uniform_space.completion Î± | has_dist.dist p.fst p.snd < Îµ.val}
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds a) (hfs : f '' s âˆˆ nhds (f a)) : continuous_at f a
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆƒ (c : ennreal), filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds c)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_4} [normed_group F] [normed_space ğ•œ F] {H : Type u_5} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_8) [topological_space M] [charted_space H M] (e : diffeomorph (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ F) E F âŠ¤) : diffeomorph I (I.trans_diffeomorph e) M M âŠ¤
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : f '' s âˆˆ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â†” Â¬antivary (f âˆ˜ â‡‘Ïƒ) g
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] (s : set Î±) (t : set Î²) : â‡‘(Î¼.prod Î½) (s Ã—Ë¢ t) = â‡‘Î¼ s * â‡‘Î½ t
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {Î¹ : Type u_5} (S : Î¹ â†’ set Î±) (Ï† : Î  (i : Î¹), C(â†¥(S i), Î²)) (hÏ† : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), â‡‘(Ï† i) âŸ¨x, hxiâŸ© = â‡‘(Ï† j) âŸ¨x, hxjâŸ©) (hS : âˆ€ (x : Î±), âˆƒ (i : Î¹), S i âˆˆ nhds x) : C(Î±, Î²)
{J : Type uâ‚} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J â¥¤ C) [category_theory.limits.has_limit F] (W : C) : ulift (W âŸ¶ category_theory.limits.limit F) â‰… F.cones.obj (opposite.op W)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] {Î¼ : Î  (i : Î¹), measure_theory.measure (Î± i)} [âˆ€ (i : Î¹), measure_theory.sigma_finite (Î¼ i)] {Î¼' : measure_theory.measure (Î  (i : Î¹), Î± i)} (h : âˆ€ (s : Î  (i : Î¹), set (Î± i)), (âˆ€ (i : Î¹), measurable_set (s i)) â†’ â‡‘Î¼' (set.univ.pi s) = finset.univ.prod (Î» (i : Î¹), â‡‘(Î¼ i) (s i))) : measure_theory.measure.pi Î¼ = Î¼'
{Ïƒ : Type u_1} {R : Type u_4} [comm_semiring R] (pâ‚ pâ‚‚ : mv_polynomial Ïƒ R) : âˆƒ (s : finset Ïƒ) (qâ‚ qâ‚‚ : mv_polynomial â†¥s R), pâ‚ = â‡‘(mv_polynomial.rename coe) qâ‚ âˆ§ pâ‚‚ = â‡‘(mv_polynomial.rename coe) qâ‚‚
{F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
(G : Type u_1) {Î± : Type u_3} {m : measurable_space Î±} [group G] [mul_action G Î±] [measurable_space G] [has_measurable_smul G Î±] (Î¼ : measure_theory.measure Î±) : [measure_theory.smul_invariant_measure G Î± Î¼, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (has_scalar.smul c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (c â€¢ s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (has_scalar.smul c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (c â€¢ s) = â‡‘Î¼ s, âˆ€ (c : G), measure_theory.measure.map (has_scalar.smul c) Î¼ = Î¼, âˆ€ (c : G), measure_theory.measure_preserving (has_scalar.smul c) Î¼ Î¼].tfae
{Î± : Type u_1} {s : finset Î±} {p : Î  (t : finset Î±), t âŠ† s â†’ Prop} [Î  (t : finset Î±) (h : t âŠ† s), decidable (p t h)] : decidable (âˆ€ (t : finset Î±) (h : t âŠ† s), p t h)
{Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (hÎ¼Î½ : â‡‘Î¼ set.univ = â‡‘Î½ set.univ) (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ioc a b) = â‡‘Î½ (set.Ioc a b)) : Î¼ = Î½
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [complete_space F] (T : set Î± â†’ (E â†’L[â„] F)) {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) (f : Î± â†’ E) : F
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i))
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (f g : Î± â†’ ennreal) : âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼ â‰¤ âˆ«â» (a : Î±), f a + g a âˆ‚Î¼
{elab : bool := bool.tt} : expr elab â†’ option â„•
(h e : expr) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic (expr Ã— expr Ã— list expr)
{R : Type u_1} [semiring R] {M : Type u_2} [topological_space M] [add_comm_monoid M] [module R M] {Î¹ : Type u_4} {Ï† : Î¹ â†’ Type u_5} [Î  (i : Î¹), topological_space (Ï† i)] [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] (f : Î  (i : Î¹), M â†’L[R] Ï† i) : M â†’L[R] Î  (i : Î¹), Ï† i
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] {s : category_theory.limits.cotrident f} (hs : category_theory.limits.is_colimit s) {W : C} (k : Y âŸ¶ W) (h : âˆ€ (jâ‚ jâ‚‚ : J), f jâ‚ â‰« k = f jâ‚‚ â‰« k) : {l // s.Ï€ â‰« l = k}
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) < s.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (Î¼ : measure_theory.measure G) [Î¼.is_haar_measure] [locally_compact_space G] (E : set G) (hE : measurable_set E) (hEpos : 0 < â‡‘Î¼ E) : E / E âˆˆ nhds 1
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) (C : â„) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : continuous_multilinear_map ğ•œ E G
{Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} (f : measure_theory.simple_func Î± E) (hf : measure_theory.mem_â„’p â‡‘f p Î¼) : â†¥(measure_theory.Lp.simple_func E p Î¼)
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : â†‘r' < r) : âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (y : E), y âˆˆ metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥f (x + y) - p.partial_sum n yâˆ¥ â‰¤ C * (a * (âˆ¥yâˆ¥ / â†‘r')) ^ n
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} (h : Î½ â‰¤ Î¼) {C : set (set Î±)} (S : Î¼.finite_spanning_sets_in C) : Î½.finite_spanning_sets_in C
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {p : â„• â†’ Î± â†’ Prop} (hp : âˆ‘' (i : â„•), â‡‘Î¼ {x : Î± | p i x} â‰  âŠ¤) : â‡‘Î¼ {x : Î± | âˆƒá¶  (n : â„•) in filter.at_top, p n x} = 0
{Î¹ : Type u_1} {Î± : Type u_2} {E : Type u_3} [semi_normed_group E] {f : Î¹ â†’ E} (hf : summable (Î» (a : Î¹), âˆ¥f aâˆ¥)) {s : Î± â†’ finset Î¹} {p : filter Î±} [p.ne_bot] (hs : filter.tendsto s p filter.at_top) {a : E} (ha : filter.tendsto (Î» (b : Î±), (s b).sum (Î» (i : Î¹), f i)) p (nhds a)) : has_sum f a
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} (j : Î¹) : (Î  (i j : Î¹), C.X i âŸ¶ D.X j) â†’+ (C.X j âŸ¶ D.X j)
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] {L : Type u_3} {W : Type u_4} [field L] [add_comm_group W] [module L W] {Ïƒ : K â†’+* L} {Ï„ : L â†’+* K} [ring_hom_inv_pair Ïƒ Ï„] (f : V â†’â‚›â‚—[Ïƒ] W) (hf : function.injective â‡‘f) : function.injective (projectivization.map f hf)
{Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), metric_space (Ï€ b)] : metric_space (Î  (b : Î²), Ï€ b)
{Fq : Type u_1} [fintype Fq] [field Fq] {b : polynomial Fq} (hb : b â‰  0) {Îµ : â„} (hÎµ : 0 < Îµ) (A : fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š).succ â†’ polynomial Fq) : âˆƒ (iâ‚€ iâ‚ : fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š).succ), iâ‚€ â‰  iâ‚ âˆ§ â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} (C : set (set Î±)) (B : â„• â†’ set Î±) (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) (h1B : (â‹ƒ (i : â„•), B i) = set.univ) (h2B : âˆ€ (i : â„•), B i âˆˆ C) (hÎ¼B : âˆ€ (i : â„•), â‡‘Î¼ (B i) â‰  âŠ¤) (h_eq : âˆ€ (s : set Î±), s âˆˆ C â†’ â‡‘Î¼ s = â‡‘Î½ s) : Î¼ = Î½
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {R' : Type u_3} {S' : Type u_4} [comm_ring R'] [comm_ring S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'} (hfg : f'.comp g = g'.comp f) (I : ideal S') : (I.quotient_map g' le_rfl).comp ((ideal.comap g' I).quotient_map f le_rfl) = (I.quotient_map f' le_rfl).comp ((ideal.comap f' I).quotient_map g _)
{Ïƒ : Type u_1} {Î± : Ïƒ â†’ Type u_2} [Î  (s : Ïƒ), linear_order (Î± s)] [âˆ€ (s : Ïƒ), is_well_order (Î± s) has_lt.lt] [fintype Ïƒ] (S : set (Î  (s : Ïƒ), Î± s)) : S.is_pwo
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} [discrete_topology â†¥s] {x : Î±} (hx : x âˆˆ s) : âˆƒ (Îµ : â„) (H : Îµ > 0), metric.closed_ball x Îµ âˆ© s = {x}
{Î± : Type u_1} {s : set (setoid Î±)} : has_Sup.Sup s = eqv_gen.setoid (has_Sup.Sup (setoid.rel '' s))
{Î± : Type u} [pseudo_emetric_space Î±] {f : filter Î±} : cauchy f â†” f â‰  âŠ¥ âˆ§ âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (t : set Î±) (H : t âˆˆ f), âˆ€ (x : Î±), x âˆˆ t â†’ âˆ€ (y : Î±), y âˆˆ t â†’ has_edist.edist x y < Îµ)
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add G] (Î¼ : measure_theory.measure G) [Î¼.is_add_left_invariant] (g : G) (A : set G) : â‡‘Î¼ ((Î» (h : G), g + h) â»Â¹' A) = â‡‘Î¼ A
{Î³ : Type u_1} {P : Î³ â†’ set Î³ â†’ Prop} (h : âˆ€ (t : set Î³), t.finite â†’ (âˆƒ (c : Î³), P c t)) : âˆƒ (u : â„• â†’ Î³), âˆ€ (n : â„•), P (u n) (u '' set.Iio n)
(bang : interactive.parse (optional (lean.parser.tk "!"))) (trace : interactive.parse (optional (lean.parser.tk "?"))) (cfg : tactic.tidy.cfg := {trace_result := bool.ff, trace_result_prefix := "Try this: ", tactics := tactic.tidy.default_tactics}) : tactic unit
(t s : expr) (md : tactic.transparency := tactic.transparency.semireducible) (approx : bool := bool.ff) : tactic unit
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} {s : set Î±} : uniform_continuous_on f s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a : Î±} {H : a âˆˆ s} {b : Î±} {H : b âˆˆ s}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hs : strict_convex â„ s) (hsc : is_closed s) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ interior s
(ğ•œ : Type v) [is_R_or_C ğ•œ] {E : Type u} [normed_group E] [normed_space ğ•œ E] (x : E) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (f : normed_space.dual ğ•œ E), âˆ¥â‡‘f xâˆ¥ â‰¤ M * âˆ¥fâˆ¥) : âˆ¥xâˆ¥ â‰¤ M
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {y : F} : box_integral.has_integral I l f vol y â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (r : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)), (âˆ€ (c : nnreal), l.r_cond (r c)) âˆ§ âˆ€ (c : nnreal) (Ï€ : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) Ï€ â†’ Ï€.is_partition â†’ has_dist.dist (box_integral.integral_sum f vol Ï€) y â‰¤ Îµ)
(p : Prop) [slim_check.testable p] (cfg : slim_check.slim_check_cfg := {num_inst := 100, max_size := 100, trace_discarded := bool.ff, trace_success := bool.ff, trace_shrink := bool.ff, trace_shrink_candidates := bool.ff, random_seed := option.none â„•, quiet := bool.ff}) : io (slim_check.test_result p)
{Î¹ : Type u_5} {Ï€ : Î¹ â†’ Type u_6} [Î  (i : Î¹), topological_space (Ï€ i)] [decidable_eq Î¹] (i : Î¹) : continuous (Î» (f : (Î  (j : Î¹), Ï€ j) Ã— Ï€ i), function.update f.fst i f.snd)
{Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_3} [encodable Î¹] {F : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î¹ â†’ Î± â†’ â„) (hF_meas : âˆ€ (n : Î¹), measure_theory.ae_strongly_measurable (F n) Î¼) (h_bound : âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ¥F n aâˆ¥ â‰¤ bound n a) (bound_summable : âˆ€áµ (a : Î±) âˆ‚Î¼, summable (Î» (n : Î¹), bound n a)) (bound_integrable : measure_theory.integrable (Î» (a : Î±), âˆ‘' (n : Î¹), bound n a) Î¼) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, has_sum (Î» (n : Î¹), F n a) (f a)) : has_sum (Î» (n : Î¹), âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)
(attr_name src tgt : name) (p : option bool := option.none) : tactic unit
{C : Type uâ‚} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X âŸ¶ Y) [I : category_theory.normal_mono f] : category_theory.regular_mono f
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â‰¤ s.sum (Î» (i : Î¹), f i â€¢ g i)
{Mâ‚ : Type u_1} {Mâ‚‚ : Type u_2} {Î± : Type u_3} {R : Type u_4} {S : Type u_5} [topological_space Mâ‚‚] [t2_space Mâ‚‚] [semiring R] [semiring S] [add_comm_monoid Mâ‚] [add_comm_monoid Mâ‚‚] [module R Mâ‚] [module S Mâ‚‚] [has_continuous_const_smul S Mâ‚‚] [has_continuous_add Mâ‚‚] {Ïƒ : R â†’+* S} {l : filter Î±} (f : Mâ‚ â†’ Mâ‚‚) (g : Î± â†’ (Mâ‚ â†’â‚›â‚—[Ïƒ] Mâ‚‚)) [l.ne_bot] (h : filter.tendsto (Î» (a : Î±) (x : Mâ‚), â‡‘(g a) x) l (nhds f)) : Mâ‚ â†’â‚›â‚—[Ïƒ] Mâ‚‚
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {c d : nnreal} (hcd : c < d) (s : set Î±) (hc : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒá¶  (a : set Î±) in v.filter_at x, â‡‘Ï a â‰¤ â†‘c * â‡‘Î¼ a)) (hd : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒá¶  (a : set Î±) in v.filter_at x, â†‘d * â‡‘Î¼ a â‰¤ â‡‘Ï a)) : â‡‘Î¼ s = 0
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â†” Â¬antivary f (g âˆ˜ â‡‘Ïƒ)
{X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra â„ C(X, â„)) (w : A.separates_points) (f : C(X, â„)) (Îµ : â„) (pos : 0 < Îµ) : âˆƒ (g : â†¥A), âˆ¥â†‘g - fâˆ¥ < Îµ
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian R M] {P : submodule R M â†’ Prop} (hgt : âˆ€ (I : submodule R M), (âˆ€ (J : submodule R M), J < I â†’ P J) â†’ P I) (I : submodule R M) : P I
{Î± : Type u_1} {m : measurable_space Î±} (s : measure_theory.signed_measure Î±) (i : set Î±) (hiâ‚ : measurable_set i) (hiâ‚‚ : 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i) : measure_theory.measure Î±
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : â„} {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : asymptotics.is_O_with c l f g â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {f : Î± â†’ Î²} (hf : measure_theory.mem_â„’p f 1 Î¼) (hmeas : measure_theory.strongly_measurable f) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (M : â„), 0 â‰¤ M âˆ§ âˆ«â» (x : Î±), â†‘âˆ¥{x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f xâˆ¥â‚Š âˆ‚Î¼ â‰¤ ennreal.of_real Îµ
{L : first_order.language} {M : Type u_3} [L.Structure M] (S : L.substructure M) (htv : âˆ€ (n : â„•) (Ï† : L.bounded_formula empty (n + 1)) (x : fin n â†’ â†¥S) (a : M), Ï†.realize inhabited.default (fin.snoc (coe âˆ˜ x) a) â†’ (âˆƒ (b : â†¥S), Ï†.realize inhabited.default (fin.snoc (coe âˆ˜ x) â†‘b))) : L.elementary_substructure M
{A : Type u_2} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] [norm_one_class A] (a : A) : filter.tendsto (Î» (n : â„•), ennreal.of_real (âˆ¥a ^ nâˆ¥ ^ (1 / â†‘n))) filter.at_top (nhds (spectral_radius â„‚ a))
(args : list (name Ã— option name Ã— expr)) (md : tactic.transparency := tactic.transparency.semireducible) (unify : bool := bool.tt) : tactic (list expr Ã— list expr)
{Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] (f : measure_theory.simple_func (Î¹ â†’ â„) E) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] (I : box_integral.box Î¹) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.integral I l â‡‘f Î¼.to_box_additive.to_smul = measure_theory.simple_func.integral (Î¼.restrict â†‘I) f
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M â†’+ N} (h : âˆ€ (y : â†¥S), is_add_unit (â‡‘f â†‘y)) {y : â†¥S} {z : N} (H : â‡‘f â†‘y + z = 0) : â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y = z
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} {Ïƒ : Type u_4} [inhabited Î›] [inhabited Ïƒ] (M : Î› â†’ turing.TM2.stmt Î“ Î› Ïƒ) (k : K) (L : list (Î“ k)) : part (list (Î“ k))
(n : name) (n' : name := n.append_suffix "_apply") : tactic unit
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {C D : set (set Î±)} (h : Î¼.finite_spanning_sets_in C) (hC : C âˆ© {s : set Î± | â‡‘Î¼ s < âŠ¤} âŠ† D) : Î¼.finite_spanning_sets_in D
(M : Type v) (X : Type x) [_inst_1 _inst_3 : uniform_space X] [has_vadd M X] : Prop
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr Ã— expr)
{R : Type u} [comm_ring R] {I : ideal R} : I.jacobson = I â†” âŠ¥.jacobson = âŠ¥
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s t : set Î±} (H : s =áµ[Î¼] t) : â‡‘Î¼ s = â‡‘Î¼ t
{Î± : Type u} {Î² : Type v} [semilattice_inf Î±] [nonempty Î±] {I : set Î²} {S : Î² â†’ set Î±} (H : I.finite) : bdd_below (â‹ƒ (i : Î²) (H : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ bdd_below (S i)
{Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), semi_normed_group (Ï€ i)] {r : â„} (hr : 0 â‰¤ r) {x : Î  (i : Î¹), Ï€ i} : âˆ¥xâˆ¥ â‰¤ r â†” âˆ€ (i : Î¹), âˆ¥x iâˆ¥ â‰¤ r
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_continuous C hâˆ¥ â‰¤ C
{R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] (H : algebra.is_integral R S) (P : ideal R) [P.is_prime] (I : ideal S) [I.is_prime] (hIP : ideal.comap (algebra_map R S) I â‰¤ P) : âˆƒ (Q : ideal S) (H : Q â‰¥ I), Q.is_prime âˆ§ ideal.comap (algebra_map R S) Q = P
{Î± : Type u_1} {Î³ : Type u_3} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î³] [add_monoid Î³] [has_continuous_add Î³] : (Î± â†’â‚˜[Î¼] Î³) â†’+ Î¼.ae.germ Î³
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {f : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} {g : Î³ â†’ Î´} {f' : Î²' â†’ Î± â†’ Î´} {g' : Î² â†’ Î²'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' (g' b) a) : g '' set.image2 f s t = set.image2 f' (g' '' t) s
(ns : list name) (base : name := name.mk_string "h" name.anonymous) (offset : option â„• := option.some 1) : tactic unit
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {K : nnreal} {f : X â†’ Y} {s : set X} (h : lipschitz_on_with K f s) {d : â„} (hd : 0 â‰¤ d) : â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘K ^ d * â‡‘(measure_theory.measure.hausdorff_measure d) s
{Î± : Type u_1} {Ïƒ : Type u_2} [primcodable Î±] [primcodable Ïƒ] {c : Î± â†’ nat.partrec.code} (hc : primrec c) {z : Î± â†’ Ïƒ} (hz : primrec z) {s : Î± â†’ Ïƒ} (hs : primrec s) {l : Î± â†’ Ïƒ} (hl : primrec l) {r : Î± â†’ Ïƒ} (hr : primrec r) {pr : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ} (hpr : primrec (Î» (a : Î± Ã— nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ), pr a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {co : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ} (hco : primrec (Î» (a : Î± Ã— nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ), co a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {pc : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ} (hpc : primrec (Î» (a : Î± Ã— nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ), pc a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {rf : Î± â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ} (hrf : primrec (Î» (a : Î± Ã— nat.partrec.code Ã— Ïƒ), rf a.fst a.snd.fst a.snd.snd)) : let F : Î± â†’ nat.partrec.code â†’ Ïƒ := Î» (a : Î±) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a) in primrec (Î» (a : Î±), F a (c a))
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : add_subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_add_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [t2_space (G â§¸ Î“)] [topological_space.second_countable_topology (G â§¸ Î“)] (K : topological_space.positive_compacts (G â§¸ Î“)) [Î“.normal] [Î¼.is_add_haar_measure] [Î¼.is_add_right_invariant] (hğ“•_finite : â‡‘Î¼ ğ“• < âŠ¤) : measure_theory.measure.map â‡‘(quotient_add_group.mk' Î“) (Î¼.restrict ğ“•) = â‡‘Î¼ (ğ“• âˆ© â‡‘(quotient_add_group.mk' Î“) â»Â¹' â†‘K) â€¢ measure_theory.measure.add_haar_measure K
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) < finset.univ.sum (Î» (i : Î¹), f i * g i) â†” Â¬monovary (f âˆ˜ â‡‘Ïƒ) g
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} {k : â„•} : s âˆˆ finset.up_shadow^[k] ğ’œ â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), t âŠ† s âˆ§ t.card + k = s.card
{a b : â„} (n : â„•) : âˆ« (x : â„) in set.interval_oc a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T âˆˆ dist_triang C) : T.morâ‚ƒ â‰« (category_theory.shift_equiv C 1).functor.map T.morâ‚ = 0
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) â¦ƒÎ¹ : Type vâ¦„ (U : Î¹ â†’ topological_space.opens â†¥X) : category_theory.limits.cone ((category_theory.pairwise.diagram U).op â‹™ F) â¥¤ category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U)
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [second_countable_topology_either Î± Î²] {f : Î± â†’ Î²} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hs : is_open s) (hf : continuous_on f s) (x : Î±) (H : x âˆˆ s) : strongly_measurable_at_filter f (nhds x) Î¼
{L : first_order.language} {M : Type u_3} [L.Structure M] (S : L.substructure M) (htv : âˆ€ (n : â„•) (Ï† : L.bounded_formula empty (n + 1)) (x : fin n â†’ â†¥S) (a : M), Ï†.realize inhabited.default (fin.snoc (coe âˆ˜ x) a) â†’ (âˆƒ (b : â†¥S), Ï†.realize inhabited.default (fin.snoc (coe âˆ˜ x) â†‘b))) : S.is_elementary
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] â¦ƒU : set Î±â¦„ (hU : is_open U) (Î¼ : measure_theory.measure Î±) [Î¼.weakly_regular] : â‡‘Î¼ U = â¨† (F : set Î±) (H : F âŠ† U) (h : is_closed F), â‡‘Î¼ F
{Î± : Type u_1} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [metric_space E] {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hf : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (f n) Î¼) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (g x))) : measure_theory.tendsto_in_measure Î¼ f filter.at_top g
(fn : name) (args : list (option expr)) (md : tactic.transparency := tactic.transparency.semireducible) : tactic expr
{Î¹ : Type u_1} (I J : box_integral.box Î¹) (h : J â‰¤ I) : box_integral.prepartition I
{R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring Sâ‚] (f : R â†’+* Sâ‚) (g : Ïƒ â†’ Sâ‚) (p : mv_polynomial Ïƒ R) : Sâ‚
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] {H : Type w} [topological_space H] (I : model_with_corners ğ•œ E H) {E' : Type v'} [normed_group E'] [normed_space ğ•œ E'] {H' : Type w'} [topological_space H'] (I' : model_with_corners ğ•œ E' H') : model_with_corners ğ•œ (E Ã— E') (model_prod H H')
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] (m : Ïƒ â†’â‚€ â„•) : mv_polynomial Ïƒ R â†’+ R
{Î± : Type u_1} [measurable_space Î±] (s1 s2 : set (set Î±)) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [Î  (i : Î¹), topological_space (Ï€ i)] {s : Î  (i : Î¹), set (Ï€ i)} : (âˆ€ (i : Î¹), is_compact (s i)) â†’ is_compact {x : Î  (i : Î¹), Ï€ i | âˆ€ (i : Î¹), x i âˆˆ s i}
{Î± : Type u_1} {m : measurable_space Î±} (s : measure_theory.signed_measure Î±) (Î¼ : measure_theory.measure Î±) : Î± â†’ â„
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] {p : ennreal} {f : Î¹ â†’ Î± â†’ Î²} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) (hf : âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) (h : âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (C : nnreal), âˆ€ (i : Î¹), measure_theory.snorm ({x : Î± | C â‰¤ âˆ¥f i xâˆ¥â‚Š}.indicator (f i)) p Î¼ â‰¤ ennreal.of_real Îµ)) : measure_theory.uniform_integrable f p Î¼
(hs : interactive.parse tactic.simp_arg_list) (ps : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.pexpr_list_or_texpr))) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{F : Type u_3} [inner_product_space â„ F] (K : submodule â„ F) {u v : F} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : F), w âˆˆ K â†’ has_inner.inner (u - v) w = 0
{Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {X Y : Î© â†’ â„} (hX : measure_theory.mem_â„’p X 2 measure_theory.measure_space.volume) (hY : measure_theory.mem_â„’p Y 2 measure_theory.measure_space.volume) (h : probability_theory.indep_fun X Y measure_theory.measure_space.volume) : probability_theory.variance (X + Y) measure_theory.measure_space.volume = probability_theory.variance X measure_theory.measure_space.volume + probability_theory.variance Y measure_theory.measure_space.volume
{c d : Type u â†’ Type u} (F : Î  {Î± : Type u}, d Î± â†’ c Î±) : Type
{V : Type u_1} {W : Type u_2} [semi_normed_group V] [semi_normed_group W] (f : V â†’+ W) (C : nnreal) (hC : âˆ€ (x : V), âˆ¥â‡‘f xâˆ¥â‚Š â‰¤ C * âˆ¥xâˆ¥â‚Š) : normed_group_hom V W
(Î“ : Type u_1) [inhabited Î“] (Î› : Type u_2) (Ïƒ : Type u_3) : Type (max u_1 u_2 u_3)
{Î± : Type u} {Î² : Type v} (e : Î± â‰ƒ Î²) [has_mul Î²] : let _inst : has_mul Î± := e.has_mul in Î± â‰ƒ* Î²
{R : Type u_1} [semiring R] {Ï† : power_series R} {n : â„•} : Ï†.order = â†‘n â†” â‡‘(power_series.coeff R n) Ï† â‰  0 âˆ§ âˆ€ (i : â„•), i < n â†’ â‡‘(power_series.coeff R i) Ï† = 0
(input : interactive.parse (optional (linear_combo.as_linear_combo bool.ff list.nilî€€functor.mapî€ <$> î€‚î€€interactive.types.texprî€interactive.types.texprî€‚))) (_x : interactive.parse (optional (lean.parser.tk "with"))) (config : linear_combo.linear_combination_config := {normalize := bool.tt, normalization_tactic := has_bind.seq (tactic.save_info {line := 75, column := 41}) (tactic.interactive.ring1 option.none).step}) : tactic unit
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_probability_measure Î¼] (hg : concave_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : âˆ« (x : Î±), g (f x) âˆ‚Î¼ â‰¤ g (âˆ« (x : Î±), f x âˆ‚Î¼)
(e t : expr) (unify : bool := bool.tt) : tactic.unsafe.type_context expr
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] (b : I.R) : I.right b âŸ¶ category_theory.limits.multicoequalizer I
{Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] [Î¼.outer_regular] {Îµ : ennreal} (hÎµ : Îµ â‰  0) (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (Î´ : â„), Î´ > 0 â†’ (f x âˆ© set.Ioo 0 Î´).nonempty) : âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable âˆ§ t âŠ† s âˆ§ (âˆ€ (x : Î±), x âˆˆ t â†’ r x âˆˆ f x) âˆ§ (s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) âˆ§ âˆ‘' (x : â†¥t), â‡‘Î¼ (metric.closed_ball â†‘x (r â†‘x)) â‰¤ â‡‘Î¼ s + Îµ
{Î¹ : Type u_1} (I : box_integral.box Î¹) (i : Î¹) (x : â„) : with_bot (box_integral.box Î¹)
(Ïƒ : Type u_1) (R : Type u_2) [comm_semiring R] [fintype Ïƒ] (n : â„•) : mv_polynomial Ïƒ R
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] {Î¹ : Type u_5} [normed_group E] [topological_space Î±] [opens_measurable_space Î±] [normed_space â„ E] [complete_space E] [second_countable_topology_either Î± E] {Î¼ : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Î¼] {a : Î±} {t : set Î±} {f : Î± â†’ E} (hft : continuous_on f t) (ha : a âˆˆ t) (ht : measurable_set t) {s : Î¹ â†’ set Î±} {li : filter Î¹} (hs : filter.tendsto s li (nhds_within a t).small_sets) (m : Î¹ â†’ â„ := Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) (hsÎ¼ : (Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) =á¶ [li] m . "refl") : (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
{Î± : Type u} {Î² : Type v} {Ï† : ultrafilter Î±} [division_ring Î²] : division_ring (â†‘Ï†.germ Î²)
{Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] [normed_space â„ F] (hm : m â‰¤ m0) (hp_ne_top : p â‰  âŠ¤) (P : â†¥(measure_theory.Lp F p Î¼) â†’ Prop) (h_ind : âˆ€ (c : F) {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s < âŠ¤), P â†‘(measure_theory.Lp.simple_func.indicator_const p _ _ c)) (h_add : âˆ€ â¦ƒf g : Î± â†’ Fâ¦„ (hf : measure_theory.mem_â„’p f p Î¼) (hg : measure_theory.mem_â„’p g p Î¼), measure_theory.strongly_measurable f â†’ measure_theory.strongly_measurable g â†’ disjoint (function.support f) (function.support g) â†’ P (measure_theory.mem_â„’p.to_Lp f hf) â†’ P (measure_theory.mem_â„’p.to_Lp g hg) â†’ P (measure_theory.mem_â„’p.to_Lp f hf + measure_theory.mem_â„’p.to_Lp g hg)) (h_closed : is_closed {f : â†¥(measure_theory.Lp_meas F â„ m p Î¼) | P â†‘f}) (f : â†¥(measure_theory.Lp F p Î¼)) : measure_theory.ae_strongly_measurable' m â‡‘f Î¼ â†’ P f
{R : Type u} {Mâ‚‚ : Type vâ‚‚} {Mâ‚ƒ : Type vâ‚ƒ} [semiring R] [add_comm_monoid Mâ‚‚] [add_comm_monoid Mâ‚ƒ] [module R Mâ‚‚] [module R Mâ‚ƒ] {Î¹â‚ : Type u_1} {Î¹â‚‚ : Type u_2} [decidable_eq Î¹â‚] [decidable_eq Î¹â‚‚] (Ïƒ : Î¹â‚ â‰ƒ Î¹â‚‚) (f g : multilinear_map R (Î» (i : Î¹â‚), Mâ‚‚) Mâ‚ƒ) : multilinear_map.dom_dom_congr Ïƒ f = multilinear_map.dom_dom_congr Ïƒ g â†” f = g
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] (A : set Î±) (Î¼ : measure_theory.measure Î±) [Î¼.outer_regular] : â‡‘Î¼ A = â¨… (U : set Î±) (h : A âŠ† U) (h2 : is_open U), â‡‘Î¼ U
{Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {F : â„• â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„) (F_measurable : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (F n) Î¼) (bound_integrable : measure_theory.integrable bound Î¼) (h_bound : âˆ€ (n : â„•), âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ¥F n aâˆ¥ â‰¤ bound a) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), F n a) filter.at_top (nhds (f a))) : filter.tendsto (Î» (n : â„•), âˆ« (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ« (a : Î±), f a âˆ‚Î¼))
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {xâ‚ xâ‚‚ y z : V} (hxâ‚yne : xâ‚ â‰  y) (hxâ‚zne : xâ‚ â‰  z) (hxâ‚‚yne : xâ‚‚ â‰  y) (hxâ‚‚zne : xâ‚‚ â‰  z) {r : â„} (hxâ‚ : âˆ¥xâ‚âˆ¥ = r) (hxâ‚‚ : âˆ¥xâ‚‚âˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : 2 â€¢ hb.oangle (y - xâ‚) (z - xâ‚) = 2 â€¢ hb.oangle (y - xâ‚‚) (z - xâ‚‚)
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {f : Î± â†’ E} {Î¼ : measure_theory.measure Î±} {l : filter Î±} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l Î¼) (hÎ¼ : Î¼.finite_at_filter l) {b : E} (hf : filter.tendsto f (l âŠ“ Î¼.ae) (nhds b)) : measure_theory.integrable_at_filter f l Î¼
{Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), comm_ring (G i)] {f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’ G j} [nonempty Î¹] [is_directed Î¹ has_le.le] (z : ring.direct_limit G f) : âˆƒ (i : Î¹) (x : G i), â‡‘(ring.direct_limit.of G f i) x = z
{R : Type u_16} {S : Type u_17} [semiring R] [semiring S] (Ïƒ : R â†’+* S) {Ïƒ' : S â†’+* R} [ring_hom_inv_pair Ïƒ Ïƒ'] [ring_hom_inv_pair Ïƒ' Ïƒ] (M : Type u_18) (Mâ‚‚ : Type u_19) [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module S Mâ‚‚] : Type (max u_18 u_19)
{Î± : Type u_1} [measurable_space Î±] (s : measure_theory.signed_measure Î±) : âˆƒ (i : set Î±), measurable_set i âˆ§ 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i âˆ§ measure_theory.vector_measure.restrict s iá¶œ â‰¤ 0.restrict iá¶œ
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) [topological_space Î±] [borel_space Î±] [topological_space Î²] [second_countable_topology_either Î± Î²] [topological_space.pseudo_metrizable_space Î²] [add_group Î²] [topological_add_group Î²] : C(Î±, Î²) â†’+ Î± â†’â‚˜[Î¼] Î²
(R : Type u_1) [semiring R] : is_noetherian_ring R â†” âˆ€ (I : ideal R), I.fg
(ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {v : E} (w : E) : â†‘(â‡‘(orthogonal_projection (submodule.span ğ•œ {v})) w) = (has_inner.inner v w / â†‘âˆ¥vâˆ¥ ^ 2) â€¢ v
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] {F G : V â¥¤ W} [F.additive] [G.additive] (Î± : F âŸ¶ G) (c : complex_shape Î¹) : F.map_homological_complex c âŸ¶ G.map_homological_complex c
{Î¹ : Type u_1} [fintype Î¹] (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] : box_integral.box_additive_map Î¹ â„ âŠ¤
(I : Type u_1) (R : Type u_2) (A : Type u_3) (m : I â†’ Type u_4) [comm_semiring R] [semiring A] [algebra R A] [Î  (i : I), fintype (m i)] [Î  (i : I), decidable_eq (m i)] : algebra R (Î  (i : I), matrix (m i) (m i) A)
{Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s : Î¹ â†’ set Î±} (hs : âˆ€ (i : Î¹), measurable_set (s i)) (H : â‡‘Î¼ set.univ < âˆ‘' (i : Î¹), â‡‘Î¼ (s i)) : âˆƒ (i j : Î¹) (h : i â‰  j), (s i âˆ© s j).nonempty
{C : Type uâ‚} [category_theory.category C] {C' : Type uâ‚‚} [category_theory.category C'] (D : category_theory.glue_data C) (F : C â¥¤ C') [H : Î  (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] : D.diagram.multispan â‹™ F â‰… (D.map_glue_data F).diagram.multispan
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} : (nhds_within (â‡‘(ext_chart_at I c) c) (set.range â‡‘I)).has_basis (Î» (f : smooth_bump_function I c), true) (Î» (f : smooth_bump_function I c), euclidean.closed_ball (â‡‘(ext_chart_at I c) c) f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R âˆ© set.range â‡‘I)
{C : Type u} [category_theory.category C] (ğ’¯ : category_theory.limits.limit_cone (category_theory.functor.empty C)) (â„¬ : Î  (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) : category_theory.symmetric_category (category_theory.monoidal_of_chosen_finite_products.monoidal_of_chosen_finite_products_synonym ğ’¯ â„¬)
{R : Type u_1} {S : Type u_6} {Mâ‚ƒ : Type u_12} [semiring R] [semiring S] [add_comm_monoid Mâ‚ƒ] [module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ} (h : â‡‘f 1 = â‡‘g 1) : f = g
{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] â¦ƒf g : zero_hom M Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
{V : Type u} {G : simple_graph V} {u v : V} (p : G.walk u v) â¦ƒe : sym2 Vâ¦„ (h : e âˆˆ p.edges) : e âˆˆ G.edge_set
{c : Type u â†’ Type u} (hom : Î  â¦ƒÎ± Î² : Type uâ¦„, c Î± â†’ c Î² â†’ Type u) [ğ’ : category_theory.bundled_hom hom] : category_theory.category (category_theory.bundled c)
{Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] [no_max_order Î±] (Î¼ Î½ : measure_theory.measure Î±) (hÎ¼ : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ico a b) â‰  âŠ¤) (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ico a b) = â‡‘Î½ (set.Ico a b)) : Î¼ = Î½
{G : Type w} [topological_space G] (Î¼ : measure_theory.content G) (U : topological_space.opens G) : ennreal
{R : Type u_5} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (h : is_primitive_root Î¶ n) : (polynomial.nth_roots n 1).nodup
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] : C
{Î¹ : Type u_1} {E : Type u_3} [semi_normed_group E] [complete_space E] {f : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : summable g) (h : âˆ€á¶  (i : Î¹) in filter.cofinite, âˆ¥f iâˆ¥ â‰¤ g i) : summable f
{R : Type u} [comm_semiring R] (I : ideal R) : Prop
{Î± : Type u_1} {Î² : Type u_2} [semi_normed_group Î²] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (T : set Î± â†’ Î²) (C : â„) : Prop
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] {S : finset Î¹} {p : Î¹ â†’ ideal R} (hp : â†‘S.pairwise (Î» (i j : Î¹), p i âŠ” p j = âŠ¤)) (hM : module.is_torsion_by_set R M (â†‘â¨… (i : Î¹) (H : i âˆˆ S), p i)) : direct_sum.is_internal (Î» (i : â†¥S), submodule.torsion_by_set R M â†‘(p â†‘i))
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (c : M) [t2_space M] : (nhds c).has_basis (Î» (f : smooth_bump_function I c), true) (Î» (f : smooth_bump_function I c), tsupport â‡‘f)
{Î± : Type u_1} {Î² : Type u_2} [linear_ordered_add_comm_group Î²] [uniform_space Î²] [uniform_add_group Î²] [complete_space Î²] {f : Î± â†’ Î²} : summable f â†’ summable (Î» (x : Î±), |f x|)
{Î± : Type u_1} {Î² : Type u_2} [add_zero_class Î±] [add_zero_class Î²] (f : Î± â†’+ Î²) (I : Type u_3) : (I â†’ Î±) â†’+ I â†’ Î²
{F : Type u_3} [inner_product_space â„ F] (x : F) (r : â„) : has_inner.inner x (r â€¢ x) = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {c : E} {lb lb' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [interval_integral.FTC_filter b lb lb'] [measure_theory.is_locally_finite_measure Î¼] (hab : interval_integrable f Î¼ a b) (hmeas : strongly_measurable_at_filter f lb' Î¼) (hf : filter.tendsto f (lb' âŠ“ Î¼.ae) (nhds c)) (hu : filter.tendsto u lt lb) (hv : filter.tendsto v lt lb) : (Î» (t : Î¹), âˆ« (x : â„) in a..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in a..u t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
(Ïƒ : Type u_1) (R : Type u_3) [comm_semiring R] (n : â„•) : submodule R (mv_polynomial Ïƒ R)
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R â‰ƒ+* S) : ideal.map â†‘f I = ideal.comap â†‘(f.symm) I
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] {H : Type w} [topological_space H] (I : model_with_corners ğ•œ E H) [I.boundaryless] {E' : Type v'} [normed_group E'] [normed_space ğ•œ E'] {H' : Type w'} [topological_space H'] (I' : model_with_corners ğ•œ E' H') [I'.boundaryless] : (I.prod I').boundaryless
(name : module_info.module_name) (cur_module : module_info.module_id := "") : module_info
{E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] [nontrivial E] {f : E â†’ F} {U : set E} (hU : metric.bounded U) (hd : diff_cont_on_cl â„‚ f U) {C : â„} (hC : âˆ€ (z : E), z âˆˆ frontier U â†’ âˆ¥f zâˆ¥ â‰¤ C) {z : E} (hz : z âˆˆ closure U) : âˆ¥f zâˆ¥ â‰¤ C
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€â‚ Ï€â‚‚ : box_integral.prepartition I) (h : disjoint Ï€â‚.Union Ï€â‚‚.Union) : box_integral.prepartition I
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [sigma_compact_space Î±] [Î¼.regular] : measure_theory.sigma_finite Î¼
{f f' : â„ â†’ â„} {s : set â„} (hs : convex â„ s) (hf : âˆ€ (x : â„), x âˆˆ s â†’ has_deriv_at f (f' x) x) : convex â„ (f' '' s)
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] : âˆ¥0âˆ¥ = 0
{X : Type u} {Y : Type v} {Z : Type w} [metric_space X] [metric_space Y] (Î¦ : Z â†’ X) (Î¨ : Z â†’ Y) (Îµ : â„) : X âŠ• Y â†’ X âŠ• Y â†’ â„
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X âŸ¶ Y} {W : C} (g : W âŸ¶ X) (h : W âŸ¶ Y) {c : category_theory.limits.cokernel_cofork h} (i : category_theory.limits.is_colimit c) (hf : f â‰« category_theory.limits.cofork.Ï€ c = 0) (hfg : g â‰« f = h) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_Ï€ (category_theory.limits.cofork.Ï€ c) hf)
{J : Type v} {C : Type u} [category_theory.category C] {F : category_theory.limits.wide_pullback_shape J â¥¤ C} {X : C} (f : X âŸ¶ F.obj option.none) (Ï€ : Î  (j : J), X âŸ¶ F.obj (option.some j)) (w : âˆ€ (j : J), Ï€ j â‰« F.map (category_theory.limits.wide_pullback_shape.hom.term j) = f) : category_theory.limits.cone F
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) {s : set Î±} (hs : is_open s) : is_open (â‡‘e '' (e.to_local_equiv.source âˆ© s))
{Î± : Type u_1} [preorder Î±] {f : Î± â†’ Î±} {x : Î±} (hf : strict_mono f) (hx : x < f x) : strict_mono (Î» (n : â„•), f^[n] x)
{X : Type u} {G : Type u_2} [group G] [mul_action G X] {P : Î  â¦ƒa b : category_theory.action_category G Xâ¦„, (a âŸ¶ b) â†’ Sort u_1} (hyp : Î  (t : X) (g : G), P (category_theory.action_category.hom_of_pair t g)) â¦ƒa b : category_theory.action_category G Xâ¦„ (f : a âŸ¶ b) : P f
(no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (locat : interactive.parse interactive.types.location) (cfg : tactic.simp_config_ext := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}, discharger := tactic.field_simp.ne_zero}) : tactic unit
{X : Type u_1} [emetric_space X] [sigma_compact_space X] [measurable_space X] [borel_space X] (Î¼ : measure_theory.measure X) [measure_theory.is_locally_finite_measure Î¼] : Î¼.regular
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î±} {s : set Î±} (hf : measure_theory.measure_preserving f Î¼ Î¼) (hs : measurable_set s) {n : â„•} (hvol : â‡‘Î¼ set.univ < â†‘n * â‡‘Î¼ s) : âˆƒ (x : Î±) (H : x âˆˆ s) (m : â„•) (H : m âˆˆ set.Ioo 0 n), f^[m] x âˆˆ s
{R : Type u} [comm_ring R] (I : ideal R) (f : polynomial R) : polynomial (R â§¸ I) â§¸ ideal.span {polynomial.map (ideal.quotient.mk I) f} â‰ƒ+* (polynomial R â§¸ ideal.map polynomial.C I) â§¸ ideal.span {â‡‘(ideal.quotient.mk (ideal.map polynomial.C I)) f}
{Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {u v : set Î±} (hu : measurable_set u) (hv : measurable_set v) (hsu : measure_theory.vector_measure.restrict s u â‰¤ 0.restrict u) (hsv : measure_theory.vector_measure.restrict s v â‰¤ 0.restrict v) (hs : â‡‘s (u âˆ† v) = 0) : â‡‘s (u  v) = 0 âˆ§ â‡‘s (v  u) = 0
(p : â„•) [fact (nat.prime p)] (R : Type uâ‚) [comm_semiring R] [char_p R p] [perfect_ring R p] (S : Type uâ‚‚) [comm_semiring S] [char_p S p] (P : Type uâ‚ƒ) [comm_semiring P] [char_p P p] [perfect_ring P p] (Ï€ : P â†’+* S) (m : perfection_map p Ï€) : (R â†’+* S) â‰ƒ (R â†’+* P)
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [group G] [topological_group G] [Î¼.is_mul_left_invariant] {U : set G} (hU : (interior U).nonempty) (h : â‡‘Î¼ U â‰  âŠ¤) {K : set G} (hK : is_compact K) : â‡‘Î¼ K < âŠ¤
(e : expr) (ids : list name := list.nil) (md dmd : tactic.transparency := tactic.transparency.semireducible) : tactic (list (name Ã— list expr))
{C : â„š â†’ Sort u} (a : â„š) (H : Î  (n : â„¤) (d : â„•), 0 < d â†’ n.nat_abs.coprime d â†’ C (rat.mk n â†‘d)) : C a
{Î± : Type u} {C : list Î± â†’ Sort u_1} (l : list Î±) (H0 : C list.nil) (H1 : Î  (a : Î±), C [a]) (Hn : Î  (a : Î±) (l : list Î±) (b : Î±), C l â†’ C (a :: (l ++ [b]))) : C l
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : â„• â†’ set Î±} (hs : âˆ‘' (i : â„•), â‡‘Î¼ (s i) â‰  âŠ¤) : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€á¶  (n : â„•) in filter.at_top, x âˆ‰ s n
{C : Type uâ‚} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] {W : C} (f : X âŸ¶ Y) [category_theory.normal_mono f] (k : W âŸ¶ Y) (h : k â‰« category_theory.normal_mono.g = 0) : {l // l â‰« f = k}
(Î± : Type u) (Î² : Type v) [add_group Î±] [add_action Î± Î²] : Î² â‰ƒ Î£ (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), Î± â§¸ add_action.stabilizer Î± Ï‰.out'
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} {t : category_theory.limits.pushout_cocone f g} (ht : category_theory.limits.is_colimit t) {W : C} (h : Y âŸ¶ W) (k : Z âŸ¶ W) (w : f â‰« h = g â‰« k) : {l // t.inl â‰« l = h âˆ§ t.inr â‰« l = k}
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] (M : turing.TM0.machine Î“ Î›) (l : list Î“) : part (turing.list_blank Î“)
{n : â„•} (I : box_integral.box (fin (n + 1))) (i : fin (n + 1)) : box_integral.box (fin n)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {Ïƒ Ï„ : Type v} [fintype Ï„] {S : Ïƒ â†’ C} [category_theory.limits.has_biproduct S] {T : Ï„ â†’ C} [category_theory.limits.has_biproduct T] (s : Ïƒ) (nz : ğŸ™ (S s) â‰  0) (f : â¨ S âŸ¶ â¨ T) [category_theory.is_iso f] : trunc (Î£' (t : Ï„), category_theory.limits.biproduct.Î¹ S s â‰« f â‰« category_theory.limits.biproduct.Ï€ T t â‰  0)
{p : â„•} {g : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R} {f : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R} (hg : witt_vector.is_polyâ‚‚ p g) (hf : witt_vector.is_poly p f) : witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x) y)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {x : M} {n : with_top â„•} : cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_mdiff_within_at I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' (f x)) âˆ˜ f) (s âˆ© f â»Â¹' (ext_chart_at I' (f x)).source) x
{elab : bool} (e : expr elab) (mappings : list (expr Ã— expr)) : expr elab
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} {c : category_theory.limits.cofork f g} (i : category_theory.limits.is_colimit c) {W : C} (h : W âŸ¶ X) [hm : category_theory.epi h] : category_theory.limits.is_colimit (category_theory.limits.cofork.of_Ï€ c.Ï€ _)
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (fs : smooth_bump_covering Î¹ I M s) [t2_space M] : smooth_partition_of_unity Î¹ I M s
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Ïƒ : Type u_4} [inhabited Ïƒ] (k : K) : Type (max u_2 u_4)
{a b : â„} {g' g Ï† : â„ â†’ â„} (hab : a â‰¤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_within_at g (g' x) (set.Ioi x) x) (Ï†int : measure_theory.integrable_on Ï† (set.Icc a b) measure_theory.measure_space.volume) (hÏ†g : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ g' x â‰¤ Ï† x) : g b - g a â‰¤ âˆ« (y : â„) in a..b, Ï† y
{G : Type u} [group G] {A : Type v} [monoid A] (Ï† Ïˆ : abelianization G â†’* A) (h : Ï†.comp abelianization.of = Ïˆ.comp abelianization.of) : Ï† = Ïˆ
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f (set.Iio 0 Ã—â„‚ set.Iio 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Iio 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz_re : z.re â‰¤ 0) (hz_im : z.im â‰¤ 0) : âˆ¥f zâˆ¥ â‰¤ C
{Î± : Type u} {s : set Î±} {Ïƒ : equiv.perm Î±} (hs : {a : Î± | â‡‘Ïƒ a â‰  a} âŠ† s) : â‡‘Ïƒ '' s = s
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) {u v : E} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : E), w âˆˆ K â†’ has_inner.inner (u - v) w = 0
{Î± : Type u_1} {G : Type u_5} [normed_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {f : Î± â†’ G} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : measure_theory.ae_fin_strongly_measurable f Î¼ â†” ae_measurable f Î¼
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) (p : box_integral.box Î¹ â†’ Prop) : box_integral.prepartition I
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X : C} (I : category_theory.InjectiveResolution X) (J : category_theory.InjectiveResolution X) : homotopy_equiv I.cocomplex J.cocomplex
{C : Type uâ‚} [category_theory.category C] {C' : Type uâ‚‚} [category_theory.category C'] (D : category_theory.glue_data C) (F : C â¥¤ C') [H : Î  (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] [category_theory.limits.has_multicoequalizer D.diagram] [category_theory.limits.preserves_colimit D.diagram.multispan F] (i j : D.J) [category_theory.limits.reflects_limit (category_theory.limits.cospan (D.Î¹ i) (D.Î¹ j)) F] (hc : category_theory.limits.is_limit ((D.map_glue_data F).V_pullback_cone i j)) : category_theory.limits.is_limit (D.V_pullback_cone i j)
(generate_induction_hyps : bool) (major_premise : expr) (eq_name : option name := option.none) (gm : tactic.eliminate.generalization_mode := tactic.eliminate.generalization_mode.generalize_all_except list.nil) (with_patterns : list tactic.eliminate.with_pattern := list.nil) : tactic unit
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ W) (g : Y âŸ¶ W) (i : W âŸ¶ Z) [category_theory.mono i] (s : category_theory.limits.pullback_cone f g) (H : category_theory.limits.is_limit s) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk s.fst s.snd _)
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) {s : set Î±} (hs : is_open s) (h : s âŠ† e.to_local_equiv.source) : is_open (â‡‘e '' s)
{C : Type u} [category_theory.category C] {W X Y : C} [category_theory.limits.has_binary_coproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) : {l // category_theory.limits.coprod.inl â‰« l = f âˆ§ category_theory.limits.coprod.inr â‰« l = g}
{ğ•œ : Type u_3} {E : Type u_4} [normed_field ğ•œ] [semi_normed_group E] [normed_space ğ•œ E] {r : â„} {x : E} (hx : âˆ¥xâˆ¥ < r) : absorbent ğ•œ (metric.ball x r)
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_addâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [has_measurable_neg G] [Î¼.is_add_left_invariant] [Î½.is_add_left_invariant] (hÎ½ : Î½ â‰  0) : Î¼.absolutely_continuous Î½
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (Ï† : R â†’+* S) (P : cubic R) : cubic S
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (f : E â‰ƒL[â„] E) (s : set E) : â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |â‡‘linear_map.det â†‘(f.symm)| * â‡‘Î¼ s
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) [category_theory.is_iso (category_theory.limits.biprod.map f g)] : category_theory.is_iso g
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {t : set Î±} (Hf : monotone_on f t) {a : Î±} (Ha : is_greatest t a) : is_greatest (f '' t) (f a)
{Î± : Type u_1} {Î¹ : Type u_3} {m : measurable_space Î±} [preorder Î¹] (Î¼ : measure_theory.measure Î±) (f : measure_theory.filtration Î¹ m) : Prop
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) (i : fin (n + 2)) : s.altitude i = affine_subspace.mk' (s.points i) ((affine_span â„ (s.points '' â†‘(finset.univ.erase i))).direction)á—® âŠ“ affine_span â„ (set.range s.points)
{Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), has_zero (Î² i)] [Î  (i : Î¹) (x : Î² i), decidable (x â‰  0)] [comm_monoid Î³] (f : Î â‚€ (i : Î¹), Î² i) (g : Î  (i : Î¹), Î² i â†’ Î³) : Î³
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} : uniform_continuous f â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a b : Î±}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)
{I : Type u_1} [decidable_eq I] {Z : I â†’ Type u_2} [Î  (i : I), add_comm_monoid (Z i)] [fintype I] (M : Type u_3) [add_comm_monoid M] (g h : (Î  (i : I), Z i) â†’+ M) (H : âˆ€ (i : I), g.comp (add_monoid_hom.single Z i) = h.comp (add_monoid_hom.single Z i)) : g = h
{n : â„•} {K : Type u_8} [comm_ring K] {Î¼ : K} (h : is_primitive_root Î¼ n) (hpos : 0 < n) : is_integral â„¤ Î¼
{Î± : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] â¦ƒÏ† Ïˆ : (Î± â†’â‚€ M) â†’â‚—[R] Nâ¦„ (h : âˆ€ (a : Î±) (b : M), â‡‘Ï† (finsupp.single a b) = â‡‘Ïˆ (finsupp.single a b)) : Ï† = Ïˆ
(G : Type u_1) {Î± : Type u_2} [has_one G] [has_scalar G Î±] [measurable_space Î±] (s : set Î±) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{Î± : Type u_1} {Î¹ : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {E : Type u_3} [normed_group E] {f : Î¹ â†’ Î± â†’ E} {g : Î± â†’ E} {l : filter Î¹} (hfg : filter.tendsto (Î» (n : Î¹), measure_theory.snorm (f n - g) âŠ¤ Î¼) l (nhds 0)) : measure_theory.tendsto_in_measure Î¼ f l g
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space â†¥K] : âˆ¥orthogonal_projection Kâˆ¥ â‰¤ 1
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] (f : add_monoid_algebra R M) : f âˆˆ algebra.adjoin R (add_monoid_algebra.of' R M '' â†‘(f.support))
(R : Type u_1) [comm_ring R] (I : ideal R) [is_adic_complete I R] : henselian_ring R I
{Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) (h0 : â‡‘Î¼ s â‰  0) : âˆƒá¶  (m : â„•) in filter.at_top, â‡‘Î¼ (s âˆ© f^[m] â»Â¹' s) â‰  0
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) < s.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (W : submodule R M) : module.dual R M â†’â‚—[R] module.dual R â†¥W
{Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (hs : s.nonempty) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
{R : Type u_1} [semiring R] (Ï† : power_series R) : Ï† = power_series.X * power_series.mk (Î» (p : â„•), â‡‘(power_series.coeff R (p + 1)) Ï†) + â‡‘(power_series.C R) (â‡‘(power_series.constant_coeff R) Ï†)
{R : Type u_1} [semiring R] (Ï† : power_series R) : Ï† = power_series.mk (Î» (p : â„•), â‡‘(power_series.coeff R (p + 1)) Ï†) * power_series.X + â‡‘(power_series.C R) (â‡‘(power_series.constant_coeff R) Ï†)
{Î¹ : Type u} (s : finset Î¹) (f g : Î¹ â†’ â„) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), |f i + g i| ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), |f i| ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), |g i| ^ p) ^ (1 / p)
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) â‰¤ s.sum (Î» (i : Î¹), f i * g i)
{N : Type u_2} {Î± : Type u_3} [preorder Î±] [preorder N] {f : N â†’ Î±} {Î¼ : N â†’ N â†’ N} [covariant_class N N (function.swap Î¼) has_le.le] (hf : antitone f) (m : N) : antitone (Î» (n : N), f (Î¼ n m))
{G : Type u_1} [measurable_space G] [has_mul G] (Î¼ : measure_theory.measure G) : Prop
{S : Type u_2} [comm_ring S] [is_domain S] {R : Type u_1} [comm_ring R] [is_domain R] [ideal.is_jacobson R] (Râ‚˜ : Type u_3) (Sâ‚˜ : Type u_4) [comm_ring Râ‚˜] [comm_ring Sâ‚˜] (Ï† : R â†’+* S) (hÏ† : function.injective â‡‘Ï†) (x : R) (hx : x â‰  0) [algebra R Râ‚˜] [is_localization.away x Râ‚˜] [algebra S Sâ‚˜] [is_localization (submonoid.map â†‘Ï† (submonoid.powers x)) Sâ‚˜] (hÏ†' : (is_localization.map Sâ‚˜ Ï† _).is_integral) : âŠ¥.jacobson = âŠ¥
{C : Type uâ‚} [category_theory.category C] {C' : Type uâ‚‚} [category_theory.category C'] (D : category_theory.glue_data C) (F : C â¥¤ C') [H : Î  (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] : category_theory.glue_data C'
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M â†’ M') (x : M) : Prop
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type v} [add_comm_group M] [module R M] [module.finite R M] (hM : module.is_torsion R M) : âˆƒ (Î¹ : Type u) [_inst_9 : fintype Î¹] [_inst_10 : decidable_eq Î¹] (p : Î¹ â†’ R) [_inst_11 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), direct_sum.is_internal (Î» (i : Î¹), submodule.torsion_by R M (p i ^ e i))
{G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [topological_space G] [add_group G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.regular] (hÎ¼ : Î¼ â‰  0) {f : G â†’ ennreal} (hf : continuous f) : âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {xâ‚€ : E} (hf : has_fderiv_at f f' xâ‚€) {s : set E} (hs : s âˆˆ nhds xâ‚€) {C : nnreal} (hlip : lipschitz_on_with C f s) : âˆ¥f'âˆ¥ â‰¤ â†‘C
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} {W : C} (fst : W âŸ¶ X) (snd : W âŸ¶ Y) (eq : fst â‰« f = snd â‰« g) : category_theory.limits.pullback_cone f g
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (k : â„•) : â†‘(lie_module.lower_central_series R â†¥I â†¥I k) â‰¤ â†‘(lie_module.lower_central_series R L â†¥I k)
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} [category_theory.limits.has_pushout f g] {W : C} {k l : category_theory.limits.pushout f g âŸ¶ W} (hâ‚€ : category_theory.limits.pushout.inl â‰« k = category_theory.limits.pushout.inl â‰« l) (hâ‚ : category_theory.limits.pushout.inr â‰« k = category_theory.limits.pushout.inr â‰« l) : k = l
{a b : â„} {g' g Ï† : â„ â†’ â„} (hab : a â‰¤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_within_at g (g' x) (set.Ioi x) x) (Ï†int : measure_theory.integrable_on Ï† (set.Icc a b) measure_theory.measure_space.volume) (hÏ†g : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ Ï† x â‰¤ g' x) : âˆ« (y : â„) in a..b, Ï† y â‰¤ g b - g a
{C : Type u} [category_theory.category C] (I : C) (h : âˆ€ (A : C) (f : I âŸ¶ A), category_theory.is_iso f) : category_theory.limits.has_strict_terminal_objects C
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] {n : â„•} (enc : Î“ â†’ vector bool n) (dec : vector bool n â†’ Î“) (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) : turing.TM1to1.Î›' â†’ turing.TM1.stmt bool turing.TM1to1.Î›' Ïƒ
{ğ•œ : Type u_1} {ğ•œ' : Type u_2} {E : Type u_3} [normed_field ğ•œ'] [semi_normed_group E] [I : normed_space ğ•œ' E] : normed_space ğ•œ' (restrict_scalars ğ•œ ğ•œ' E)
(ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {v : E} (hv : âˆ¥vâˆ¥ = 1) (w : E) : â†‘(â‡‘(orthogonal_projection (submodule.span ğ•œ {v})) w) = has_inner.inner v w â€¢ v
{R : Type u} [comm_ring R] (I : ideal R) (f : polynomial R) : adjoin_root f â§¸ ideal.map (adjoin_root.of f) I â‰ƒ+* polynomial (R â§¸ I) â§¸ ideal.span {polynomial.map (ideal.quotient.mk I) f}
{Î± : Type u_1} {Î¹ : Type u_2} (m : Î¹ â†’ measurable_space Î±) [measurable_space Î±] (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{F : Type u_3} [inner_product_space â„ F] (x y : F) : |has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)| = 1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), r â‰  0 âˆ§ y = r â€¢ x
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (A : E â†’L[â„] E) {m : nnreal} (hm : â†‘m < ennreal.of_real |A.det|) : âˆ€á¶  (Î´ : nnreal) in nhds_within 0 (set.Ioi 0), âˆ€ (s : set E) (f : E â†’ E), approximates_linear_on f A s Î´ â†’ â†‘m * â‡‘Î¼ s â‰¤ â‡‘Î¼ (f '' s)
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] {K : Type (max v u)} [category_theory.small_category K] [category_theory.limits.has_limits_of_shape K D] (F : K â¥¤ category_theory.Sheaf J D) (E : category_theory.limits.cone (F â‹™ category_theory.Sheaf_to_presheaf J D)) (hE : category_theory.limits.is_limit E) (X : C) (W : J.cover X) : category_theory.limits.is_limit (W.multifork E.X)
{A : Type uâ‚} [category_theory.category A] {B : Type uâ‚‚} [category_theory.category B] {C : Type uâ‚ƒ} [category_theory.category C] {D : Type uâ‚„} [category_theory.category D] {F G : A â¥¤ B} {H I : C â¥¤ D} (Î± : F âŸ¶ G) (Î² : H âŸ¶ I) : F.prod H âŸ¶ G.prod I
{Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_emetric_space (Ï€ b)] : pseudo_emetric_space (Î  (b : Î²), Ï€ b)
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] (Î¼ : measure_theory.measure Î±) : Prop
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] {Î¹ : Type u_5} [normed_group E] [topological_space Î±] [opens_measurable_space Î±] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Î¼] {a : Î±} {t : set Î±} {f : Î± â†’ E} (ha : continuous_within_at f t a) (ht : measurable_set t) (hfm : strongly_measurable_at_filter f (nhds_within a t) Î¼) {s : Î¹ â†’ set Î±} {li : filter Î¹} (hs : filter.tendsto s li (nhds_within a t).small_sets) (m : Î¹ â†’ â„ := Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) (hsÎ¼ : (Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) =á¶ [li] m . "refl") : (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {x : ğ•œ} {f' : F} : has_deriv_at f f' x â†’ has_fderiv_at f (1.smul_right f') x
{C : Type uâ‚} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] {X Y : C} (f : ğŸ™_ W âŸ¶ category_theory.enriched_category.hom X Y) : category_theory.forget_enrichment.of W X âŸ¶ category_theory.forget_enrichment.of W Y
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space â„ F] [normed_space ğ•œ F] [complete_space F] [measurable_space G] {Î¼ : measure_theory.measure G} (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [normed_group G] [borel_space G] [topological_space.second_countable_topology G] [sigma_compact_space G] [measure_theory.sigma_finite Î¼] [Î¼.is_add_left_invariant] [normed_space ğ•œ G] [proper_space G] (hcg : has_compact_support g) (hf : measure_theory.locally_integrable f Î¼) (hg : cont_diff ğ•œ 1 g) (xâ‚€ : G) : has_fderiv_at (convolution f g L Î¼) (convolution f (fderiv ğ•œ g) (continuous_linear_map.precompR G L) Î¼ xâ‚€) xâ‚€
{Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] {l : box_integral.integration_params} {I : box_integral.box Î¹} {f : (Î¹ â†’ â„) â†’ E} {Î¼ : measure_theory.measure (Î¹ â†’ â„)} [measure_theory.is_locally_finite_measure Î¼] (hf : f =áµ[Î¼.restrict â†‘I] 0) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l f Î¼.to_box_additive.to_smul 0
{Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group E] {p : ennreal} {f : Î¹ â†’ Î± â†’ E} {g : Î± â†’ E} (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) (hf : âˆ€ (n : Î¹), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) {l : filter Î¹} (hfg : filter.tendsto (Î» (n : Î¹), measure_theory.snorm (f n - g) p Î¼) l (nhds 0)) : measure_theory.tendsto_in_measure Î¼ f l g
{Î± : Type u} [uniform_space Î±] {f : filter Î±} (hf : cauchy f) {U : â„• â†’ set (Î± Ã— Î±)} (U_mem : âˆ€ (n : â„•), U n âˆˆ uniformity Î±) (U_le : âˆ€ (s : set (Î± Ã— Î±)), s âˆˆ uniformity Î± â†’ (âˆƒ (n : â„•), U n âŠ† s)) â¦ƒa : Î±â¦„ (ha : filter.tendsto (sequentially_complete.seq hf U_mem) filter.at_top (nhds a)) : f â‰¤ nhds a
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] [proper_space F] {s : set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hb : metric.bounded s) (hc : is_closed (coe_fn '' s)) : is_compact (coe_fn '' s)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (s : set M) : Prop
{P : Type u_1} [has_le P] {I : set P} (h : order.is_ideal I) : order.ideal P
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {C : set (set Î±)} (h : Î¼.finite_spanning_sets_in C) : measure_theory.sigma_finite Î¼
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [metric_space Î²] {Î¼ : measure_theory.measure Î±} [semilattice_sup Î¹] [nonempty Î¹] [encodable Î¹] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [measure_theory.is_finite_measure Î¼] (hf : âˆ€ (n : Î¹), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : Î¹), f n x) filter.at_top (nhds (g x))) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (t : set Î±), measurable_set t âˆ§ â‡‘Î¼ t â‰¤ ennreal.of_real Îµ âˆ§ tendsto_uniformly_on f g filter.at_top tá¶œ
{Î± : Type u_1} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [metric_space E] {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} (hfg : measure_theory.tendsto_in_measure Î¼ f filter.at_top g) : âˆƒ (ns : â„• â†’ â„•), strict_mono ns âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (i : â„•), f (ns i) x) filter.at_top (nhds (g x))
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {c : â„} {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ asymptotics.is_O_with c l f' g'
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [complete_space F] {T : set Î± â†’ (E â†’L[â„] F)} {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) {fs : â„• â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„) (fs_measurable : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (fs n) Î¼) (bound_integrable : measure_theory.integrable bound Î¼) (h_bound : âˆ€ (n : â„•), âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ¥fs n aâˆ¥ â‰¤ bound a) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), fs n a) filter.at_top (nhds (f a))) : filter.tendsto (Î» (n : â„•), measure_theory.set_to_fun Î¼ T hT (fs n)) filter.at_top (nhds (measure_theory.set_to_fun Î¼ T hT f))
{Ïƒ : Type} {Î± : Type u} (state : Ïƒ) (tac : interaction_monad Ïƒ Î±) : interaction_monad Ïƒ Î±
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³' : Type u_6} {Î´ : Type u_7} {Îµ : Type u_9} [decidable_eq Î²'] [decidable_eq Î³'] [decidable_eq Î´] [decidable_eq Îµ] {s : finset Î±} {t : finset Î²} {Î³ : Type u_2} {u : finset Î³} {f : Î± â†’ Î´ â†’ Îµ} {g : Î² â†’ Î³ â†’ Î´} {fâ‚ : Î± â†’ Î² â†’ Î²'} {fâ‚‚ : Î± â†’ Î³ â†’ Î³'} {g' : Î²' â†’ Î³' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), f a (g b c) = g' (fâ‚ a b) (fâ‚‚ a c)) : finset.imageâ‚‚ f s (finset.imageâ‚‚ g t u) âŠ† finset.imageâ‚‚ g' (finset.imageâ‚‚ fâ‚ s t) (finset.imageâ‚‚ fâ‚‚ s u)
{Î± : Sort uâ‚} {Î² : Sort uâ‚‚} {Ï† : Sort uâ‚ƒ} (f : Î² â†’ Î² â†’ Ï†) (g : Î± â†’ Î²) : Î± â†’ Î± â†’ Ï†
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] (c : category_theory.limits.cofork I.fst_sigma_map I.snd_sigma_map) : category_theory.limits.multicofork I
{E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] {f : E â†’ F} {c : E} (hd : âˆ€á¶  (z : E) in nhds c, differentiable_at â„‚ f z) (hc : is_local_max (has_norm.norm âˆ˜ f) c) : âˆ€á¶  (y : E) in nhds c, âˆ¥f yâˆ¥ = âˆ¥f câˆ¥
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =O[filter.at_top] Î» (n : â„•), 1) : â†‘r â‰¤ p.radius
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : â„} {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : asymptotics.is_O_with c l f g' â†’ asymptotics.is_O_with c l f (Î» (x : Î±), âˆ¥g' xâˆ¥)
(Î¹ : Type uÎ¹) {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) (M : Type uM) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (s : set M := set.univ) : Type (max uM uÎ¹)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X âŸ¶ Y} {W : C} (g : Y âŸ¶ W) (h : X âŸ¶ W) {c : category_theory.limits.kernel_fork h} (i : category_theory.limits.is_limit c) (hf : category_theory.limits.fork.Î¹ c â‰« f = 0) (hfg : f â‰« g = h) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Î¹ (category_theory.limits.fork.Î¹ c) hf)
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i))
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M â†’ M') (x : M) : tangent_space I x â†’L[ğ•œ] tangent_space I' (f x)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} : cont_mdiff_on I I' n f s â†” continuous_on f s âˆ§ âˆ€ (y : M'), cont_mdiff_on I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' y) âˆ˜ f) (s âˆ© f â»Â¹' (ext_chart_at I' y).source)
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (Î¼ : K) {k : â„•} (hk : finite_dimensional.finrank K V â‰¤ k) : â‡‘(f.generalized_eigenspace Î¼) k = â‡‘(f.generalized_eigenspace Î¼) (finite_dimensional.finrank K V)
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) (Ï€i : Î  (J : box_integral.box Î¹), box_integral.prepartition J) (J : box_integral.box Î¹) : box_integral.box Î¹
{C : Type u} [category_theory.category C] {I : category_theory.limits.multispan_index C} [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] (K : category_theory.limits.multicofork I) : category_theory.limits.cofork I.fst_sigma_map I.snd_sigma_map
{Î± : Type u_2} {_x : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : Prop
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g i) < s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â†” Â¬antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
{I : Type u} {f : I â†’ Type v} {Î± : Type u_1} [Î  (i : I), has_scalar Î± (f i)] [âˆ€ (i : I), nonempty (f i)] (i : I) [has_faithful_smul Î± (f i)] : has_faithful_smul Î± (Î  (i : I), f i)
{Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), emetric_space (Ï€ b)] : emetric_space (Î  (b : Î²), Ï€ b)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) : cont_diff_groupoid 0 I = continuous_groupoid H
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” antivary (f âˆ˜ â‡‘Ïƒ) g
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] (W : subspace K V) : module.dual K â†¥W â†’â‚—[K] module.dual K V
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] â¦ƒA B : GL n Râ¦„ (h : âˆ€ (i j : n), â†‘A i j = â†‘B i j) : A = B
(s : simp_lemmas) (e : expr) (prove : tactic unit := tactic.failed) (r : name := name.mk_string "eq" name.anonymous) (md : tactic.transparency := tactic.transparency.reducible) : tactic (expr Ã— expr)
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î½ : measure_theory.measure Î²} [normed_group E] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î½] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„ (hf : measure_theory.strongly_measurable (function.uncurry f)) : measure_theory.strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½)
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ğ’œ : â„• â†’ submodule R A) [graded_algebra ğ’œ] : galois_connection (Î» (I : ideal A), projective_spectrum.zero_locus ğ’œ â†‘I) (Î» (t : (set (projective_spectrum ğ’œ))áµ’áµˆ), (projective_spectrum.vanishing_ideal t).to_ideal)
(attr_name c_name : name) (persistent : bool := bool.ff) (prio : option â„• := option.none) : tactic unit
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {E : Type u_5} [normed_group E] [normed_space â„ E] {f : Î± â†’ nnreal} (f_meas : measurable f) : â†¥(measure_theory.Lp E 1 (Î¼.with_density (Î» (x : Î±), â†‘(f x)))) â†’â‚—áµ¢[â„] â†¥(measure_theory.Lp E 1 Î¼)
{Î± : Type u_1} [topological_space Î±] (dist : Î± â†’ Î± â†’ â„) (dist_self : âˆ€ (x : Î±), dist x x = 0) (dist_comm : âˆ€ (x y : Î±), dist x y = dist y x) (dist_triangle : âˆ€ (x y z : Î±), dist x z â‰¤ dist x y + dist y z) (H : âˆ€ (s : set Î±), is_open s â†” âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ (y : Î±), dist x y < Îµ â†’ y âˆˆ s)) : pseudo_metric_space Î±
{F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * has_inner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{Î± : Type u_1} {Î³ : Type u_3} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î³] [linear_order Î³] [order_closed_topology Î³] [has_zero Î³] (f : Î± â†’â‚˜[Î¼] Î³) : Î± â†’â‚˜[Î¼] Î³
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.multiequalizer I âŸ¶ âˆ I.left
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} (p : ennreal) (Î¼ : measure_theory.measure Î±) [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] [measure_theory.is_finite_measure Î¼] [fact (1 â‰¤ p)] : normed_group_hom (bounded_continuous_function Î± E) â†¥(measure_theory.Lp E p Î¼)
{Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_3} {f : Î± â†’ E} (hf : measure_theory.has_finite_integral f Î¼) {l : filter Î¹} {s : Î¹ â†’ set Î±} (hs : filter.tendsto (â‡‘Î¼ âˆ˜ s) l (nhds 0)) : filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
(e t : expr) (md : tactic.transparency := tactic.transparency.reducible) : tactic bool
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [locally_compact_space G] (Î¼ : measure_theory.measure G) [Î¼.is_haar_measure] : measure_theory.is_locally_finite_measure Î¼
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) (hf : continuous â‡‘f) : âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥
{Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} (f : â†¥(measure_theory.Lp.simple_func E p Î¼)) : measure_theory.mem_â„’p â‡‘(measure_theory.Lp.simple_func.to_simple_func f) p Î¼
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (s : set Î±) : measure_theory.measure Î±
{Î± : Type u_1} {F : Type u_4} [measurable_space Î±] {ğ•œ : Type u_5} [normed_field ğ•œ] [normed_group F] [normed_space ğ•œ F] {p : ennreal} {Î¼ : measure_theory.measure Î±} (c : ğ•œ) (f : â†¥(measure_theory.Lp F p Î¼)) (s : set Î±) : measure_theory.mem_â„’p.to_Lp â‡‘(c â€¢ f) _ = c â€¢ measure_theory.mem_â„’p.to_Lp â‡‘f _
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (h_meas : âˆ€ (n : â„•), measurable (f n)) (h_anti : antitone f) (h_fin : âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤) : âˆ«â» (a : Î±), (â¨… (n : â„•), f n a) âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
{Î± : Type u_1} [measurable_space Î±] [pseudo_emetric_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.finite_measure Î±) {F : set Î±} (F_closed : is_closed F) {Î´s : â„• â†’ â„} (Î´s_pos : âˆ€ (n : â„•), 0 < Î´s n) (Î´s_lim : filter.tendsto Î´s filter.at_top (nhds 0)) : filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(thickened_indicator _ F) a) âˆ‚â†‘Î¼) filter.at_top (nhds (â‡‘â†‘Î¼ F))
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} {R : Î  (x : Î±), Î² x â†’ Prop} [Î  (a : Î±), encodable (Î² a)] [Î  (x : Î±) (y : Î² x), decidable (R x y)] (H : âˆ€ (x : Î±), âˆƒ (y : Î² x), R x y) : âˆƒ (f : Î  (a : Î±), Î² a), âˆ€ (x : Î±), R x (f x)
{J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) (W : C) : ulift (t.X âŸ¶ W) â‰… {p // âˆ€ {j j' : J} (f : j âŸ¶ j'), F.map f â‰« p j' = p j}
{Ï† : Sort u_1} (dâ‚ dâ‚‚ : many_one_degree) (f : set â„• â†’ set â„• â†’ Ï†) (h : âˆ€ (pâ‚ pâ‚‚ qâ‚ qâ‚‚ : â„• â†’ Prop), many_one_equiv pâ‚ pâ‚‚ â†’ many_one_equiv qâ‚ qâ‚‚ â†’ f pâ‚ qâ‚ = f pâ‚‚ qâ‚‚) : Ï†
{Î± : Type u_1} {Î¹ : Type u_2} [measurable_space Î±] (Ï€ : Î¹ â†’ set (set Î±)) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X âŸ¶ Y} {c : category_theory.limits.cokernel_cofork f} (i : category_theory.limits.is_colimit c) {W : C} (g : W âŸ¶ X) [hg : category_theory.epi g] {h : W âŸ¶ Y} (hh : h = g â‰« f) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_Ï€ (category_theory.limits.cofork.Ï€ c) _)
{F : Type u_3} [inner_product_space â„ F] {x : F} {r : â„} (hx : x â‰  0) (hr : r â‰  0) : |has_inner.inner x (r â€¢ x)| / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
{Î± : Type u} {Î² : Type v} {Ï† : ultrafilter Î±} [linear_ordered_comm_ring Î²] : linear_ordered_comm_ring (â†‘Ï†.germ Î²)
{Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] [no_min_order Î±] (Î¼ Î½ : measure_theory.measure Î±) (hÎ¼ : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ioc a b) â‰  âŠ¤) (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ioc a b) = â‡‘Î½ (set.Ioc a b)) : Î¼ = Î½
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (Hf : monotone f) {s : set Î±} : bdd_above s â†’ bdd_above (f '' s)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} {I : category_theory.InjectiveResolution Y} {J : category_theory.InjectiveResolution Z} (f : I.cocomplex âŸ¶ J.cocomplex) (n : â„•) (g : I.cocomplex.X (n + 1) âŸ¶ J.cocomplex.X n) (g' : I.cocomplex.X (n + 2) âŸ¶ J.cocomplex.X (n + 1)) (w : f.f (n + 1) = I.cocomplex.d (n + 1) (n + 2) â‰« g' + g â‰« J.cocomplex.d n (n + 1)) : I.cocomplex.X (n + 3) âŸ¶ J.cocomplex.X (n + 2)
{U : Type u_1} [quiver U] {V : Type u_3} [quiver V] {W : Type u_5} [quiver W] (F : prefunctor U V) (G : prefunctor V W) : prefunctor U W
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (F : V â¥¤ W) [F.additive] (h : homotopy_equiv C D) : homotopy_equiv ((F.map_homological_complex c).obj C) ((F.map_homological_complex c).obj D)
{Î± : Type u_1} [preorder Î±] [succ_order Î±] [is_succ_archimedean Î±] {P : Î± â†’ Prop} {m : Î±} (h0 : P m) (h1 : âˆ€ (n : Î±), m â‰¤ n â†’ P n â†’ P (order.succ n)) â¦ƒn : Î±â¦„ (hmn : m â‰¤ n) : P n
{R : Type u} {Î¹ : Type x} [semiring R] {Ï† : Î¹ â†’ Type i} [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] [decidable_eq Î¹] (i j : Î¹) : Ï† i â†’â‚—[R] Ï† j
{Î± : Type u} {Ïƒ : Type v} (M : Îµ_NFA Î± Ïƒ) (start : set Ïƒ) : list Î± â†’ set Ïƒ
{R : Type u_1} [comm_ring R] (I : ideal R) {M : Type u_2} [add_comm_group M] [module R M] {N : Type u_3} [add_comm_group N] [module R N] [h : is_Hausdorff I N] (f : M â†’â‚—[R] N) (g : Hausdorffification I M â†’â‚—[R] N) (hg : g.comp (Hausdorffification.of I M) = f) : g = Hausdorffification.lift I f
{F : Type u_3} [inner_product_space â„ F] {x : F} {r : â„} (hx : x â‰  0) (hr : r < 0) : has_inner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = -1
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' â†’ M''} (x : M) (hg : cont_mdiff_within_at I' I'' n g t (f x)) (hf : cont_mdiff_within_at I I' n f s x) (st : set.maps_to f s t) : cont_mdiff_within_at I I'' n (g âˆ˜ f) s x
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [nonempty Î²] [semilattice_sup Î²] [no_max_order Î²] {u : Î² â†’ Î±} {a : Î±} : filter.tendsto u filter.at_top (nhds a) â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), n > N â†’ has_dist.dist (u n) a < Îµ)
{p : â„•+} {k : â„•} {K : Type u} [field K] [char_zero K] {Î¶ : K} [hp : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ (k + 1)} â„š K] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) (hk : p ^ (k + 1) â‰  2) : algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = (-1) ^ ((â†‘p ^ (k + 1)).totient / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
{Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] {N : â„•} {Ï„ : â„} (hÏ„ : 1 < Ï„) (hN : is_empty (besicovitch.satellite_config Î± N Ï„)) (s : set Î±) (r : Î± â†’ â„) (rpos : âˆ€ (x : Î±), x âˆˆ s â†’ 0 < r x) (rle : âˆ€ (x : Î±), x âˆˆ s â†’ r x â‰¤ 1) : âˆƒ (t : finset Î±), â†‘t âŠ† s âˆ§ â‡‘Î¼ (s  â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) â‰¤ â†‘N / (â†‘N + 1) * â‡‘Î¼ s âˆ§ â†‘t.pairwise_disjoint (Î» (x : Î±), metric.closed_ball x (r x))
(G : Type u_1) {Î± : Type u_3} {m : measurable_space Î±} [add_group G] [add_action G Î±] [measurable_space G] [has_measurable_vadd G Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.vadd_invariant_measure G Î± Î¼] [topological_space Î±] [has_continuous_const_vadd G Î±] [add_action.is_minimal G Î±] {K U : set Î±} (hK : is_compact K) (hÎ¼K : â‡‘Î¼ K â‰  0) (hU : is_open U) (hne : U.nonempty) : 0 < â‡‘Î¼ U
{ğ•œ : Type u_1} [normed_field ğ•œ] [complete_space ğ•œ] {r : ğ•œ} (hr : âˆ¥râˆ¥ < 1) : has_sum (Î» (n : â„•), â†‘n * r ^ n) (r / (1 - r) ^ 2)
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] [normed_group F] [normed_space â„ F] [complete_space F] {f : E â†’ F} {Ï† : E â†’ â„} {xâ‚€ : E} {f' : E â†’L[â„] F} {Ï†' : E â†’L[â„] â„} (hextr : is_local_extr_on Ï† {x : E | f x = f xâ‚€} xâ‚€) (hf' : has_strict_fderiv_at f f' xâ‚€) (hÏ†' : has_strict_fderiv_at Ï† Ï†' xâ‚€) : âˆƒ (Î› : module.dual â„ F) (Î›â‚€ : â„), (Î›, Î›â‚€) â‰  0 âˆ§ âˆ€ (x : E), â‡‘Î› (â‡‘f' x) + Î›â‚€ â€¢ â‡‘Ï†' x = 0
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 4
{f : â„ â†’ â„} (hf' : differentiable â„ f) (hf'' : âˆ€ (x : â„), deriv^[2] f x < 0) : strict_concave_on â„ set.univ f
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] {f : â„ â†’ E} {Î¼ : measure_theory.measure â„} {l l' : filter â„} (hfm : strongly_measurable_at_filter f l' Î¼) [filter.tendsto_Ixx_class set.Ioc l l'] [l'.is_measurably_generated] (hÎ¼ : Î¼.finite_at_filter l') {c : E} (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) {u v : Î¹ â†’ â„} {lt : filter Î¹} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : âˆ€á¶  (t : Î¹) in lt, interval_integrable f Î¼ (u t) (v t)
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} : Î¼.ae â‰¤ Î½.ae â†’ Î¼.absolutely_continuous Î½
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] {Î¹ : Type u_1} [topological_space Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} : tendsto_locally_uniformly F f p â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ âˆ€ (x : Î²), âˆƒ (t : set Î²) (H : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_edist.edist (f y) (F n y) < Îµ
{J : Type uâ‚} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J â¥¤ C) [category_theory.limits.has_colimit F] (W : C) : ulift (category_theory.limits.colimit F âŸ¶ W) â‰… {p // âˆ€ {j j' : J} (f : j âŸ¶ j'), F.map f â‰« p j' = p j}
{R : Type u} [comm_ring R] (I : ideal R) (s : set R) : â‡‘(ideal.quotient.mk I) â»Â¹' (â‡‘(ideal.quotient.mk I) '' s) = â‹ƒ (x : â†¥I), (Î» (y : R), x.val + y) '' s
{Ïƒ : Type u_1} {R : Type u_2} [ring R] (Ï† : mv_power_series Ïƒ R) (u : RË£) : mv_power_series Ïƒ R
{c : Type u â†’ Type u} (hom : Î  â¦ƒÎ± Î² : Type uâ¦„, c Î± â†’ c Î² â†’ Type u) {d : Type u â†’ Type u} (F : Î  {Î± : Type u}, d Î± â†’ c Î±) â¦ƒÎ± Î² : Type uâ¦„ (IÎ± : d Î±) (IÎ² : d Î²) : Type u
{R : Type u} [comm_ring R] (I : ideal R) (Î¹ : Type v) : ((Î¹ â†’ R) â§¸ I.pi Î¹) â‰ƒâ‚—[R â§¸ I] Î¹ â†’ R â§¸ I
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s : set Î²} {g : Î² â†’ Î±} (hg : set.inj_on g s) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ g '' s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ s), f (g j)))
(Ïƒ : Type u) (R : Type v) [comm_ring R] : basis (Ïƒ â†’â‚€ â„•) R (mv_polynomial Ïƒ R)
{c : Type u â†’ Type u} (hom : Î  â¦ƒÎ± Î² : Type uâ¦„, c Î± â†’ c Î² â†’ Type u) [ğ’ : category_theory.bundled_hom hom] {d : Type u â†’ Type u} (F : Î  {Î± : Type u}, d Î± â†’ c Î±) : category_theory.bundled_hom (category_theory.bundled_hom.map_hom hom F)
{P : â„• â†’ Sort u_1} (h0 : P 0) (hp : Î  (p n : â„•), nat.prime p â†’ P (p ^ n)) (h : Î  (a b : â„•), 1 < a â†’ 1 < b â†’ a.coprime b â†’ P a â†’ P b â†’ P (a * b)) (a : â„•) : P a
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) (h : W âŸ¶ X) [category_theory.epi h] [category_theory.limits.has_pushout f g] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk category_theory.limits.pushout.inl category_theory.limits.pushout.inr _)
{Ïƒ : Type u_1} {R : Type u_2} [comm_semiring R] : has_coe (mv_polynomial Ïƒ R) (mv_power_series Ïƒ R)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_4} [normed_group F] [normed_space ğ•œ F] {H : Type u_5} [topological_space H] {G : Type u_7} [topological_space G] {I : model_with_corners ğ•œ E H} {J : model_with_corners ğ•œ F G} {M : Type u_8} [topological_space M] [charted_space H M] {N : Type u_10} [topological_space N] [charted_space G N] {n : with_top â„•} (h : diffeomorph I J M N n) : M â‰ƒâ‚œ N
{R : Type u_1} {M : Type u_5} [comm_ring R] [add_comm_group M] [module R M] {B : M â†’â‚—[R] M â†’â‚—[R] R} (hB : B.is_refl) {W : submodule R M} (hW : disjoint W (W.orthogonal_bilin B)) : (B.dom_restrictâ‚â‚‚ W W).nondegenerate
{R : Type u_1} [comm_ring R] (I : ideal R) (n : â„•) : open_add_subgroup R
{Î± : Type u} {Ïƒ : Type v} (M : Îµ_NFA Î± Ïƒ) : NFA Î± Ïƒ
â¦ƒJ : Type uâ¦„ (F : J â†’ category_theory.Groupoid) : category_theory.limits.fan F
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} {Ïƒ : Type u_4} [inhabited Î›] [inhabited Ïƒ] (k : K) (L : list (Î“ k)) : turing.TM2.cfg Î“ Î› Ïƒ
{I : Type wâ‚€} (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] {J : Type wâ‚} (h : J â†’ I) (j : J) : category_theory.pi.comap C h â‹™ category_theory.pi.eval (C âˆ˜ h) j â‰… category_theory.pi.eval C (h j)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] {p : ennreal} {f : Î¹ â†’ Î± â†’ Î²} [fintype Î¹] (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) (hf : âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) (hf' : âˆ€ (i : Î¹), measure_theory.mem_â„’p (f i) p Î¼) : measure_theory.uniform_integrable f p Î¼
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) â¦ƒÎ¹ : Type vâ¦„ (U : Î¹ â†’ topological_space.opens â†¥X) (c : category_theory.limits.cone ((category_theory.pairwise.diagram U).op â‹™ F)) : (ğŸ­ (category_theory.limits.cone ((category_theory.pairwise.diagram U).op â‹™ F))).obj c â‰… (Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_functor F U â‹™ Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_inverse F U).obj c
(reduce_semi only_on : bool) (hyps : list pexpr) (cfg : linarith.linarith_config := {discharger := has_bind.seq (tactic.save_info {line := 312, column := 31}) (tactic.interactive.ring option.none).step, restrict_type := option.none Type, restrict_type_reflect := `(option.none Type), exfalso := bool.tt, transparency := tactic.transparency.reducible, split_hypotheses := bool.tt, split_ne := bool.ff, preprocessors := option.none (list linarith.global_branching_preprocessor), oracle := option.none linarith.certificate_oracle}) : tactic unit
{Î¹ : Type u} {E : Type v} [normed_group E] [normed_space â„ E] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {g : (Î¹ â†’ â„) â†’ â„} (hle : âˆ€ (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I â†’ âˆ¥f xâˆ¥ â‰¤ g x) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] (hg : box_integral.integrable I l g Î¼.to_box_additive.to_smul) : âˆ¥box_integral.integral I l f Î¼.to_box_additive.to_smulâˆ¥ â‰¤ box_integral.integral I l g Î¼.to_box_additive.to_smul
(e : expr) (timeout : â„• := 1000) : tactic expr
{I : Type u} {f : I â†’ Type vâ‚} [decidable_eq I] [Î  (i : I), has_one (f i)] {i i' : I} (h : i â‰  i') (x : f i) : pi.mul_single i x i' = 1
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C â¥¤ D) [F.initial] {d : D} (Z : Î  (X : C), (F.obj X âŸ¶ d) â†’ Sort u_1) (hâ‚ : Î  (Xâ‚ Xâ‚‚ : C) (kâ‚ : F.obj Xâ‚ âŸ¶ d) (kâ‚‚ : F.obj Xâ‚‚ âŸ¶ d) (f : Xâ‚ âŸ¶ Xâ‚‚), F.map f â‰« kâ‚‚ = kâ‚ â†’ Z Xâ‚ kâ‚ â†’ Z Xâ‚‚ kâ‚‚) (hâ‚‚ : Î  (Xâ‚ Xâ‚‚ : C) (kâ‚ : F.obj Xâ‚ âŸ¶ d) (kâ‚‚ : F.obj Xâ‚‚ âŸ¶ d) (f : Xâ‚ âŸ¶ Xâ‚‚), F.map f â‰« kâ‚‚ = kâ‚ â†’ Z Xâ‚‚ kâ‚‚ â†’ Z Xâ‚ kâ‚) {Xâ‚€ : C} {kâ‚€ : F.obj Xâ‚€ âŸ¶ d} (z : Z Xâ‚€ kâ‚€) : Z (category_theory.functor.initial.lift F d) (category_theory.functor.initial.hom_to_lift F d)
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (Hf : monotone f) {a : Î±} {s : set Î±} (Ha : is_greatest s a) : is_greatest (f '' s) (f a)
{R : Type u_1} [comm_ring R] {I J : ideal R} (h : I = J) : R â§¸ I â‰ƒ+* R â§¸ J
{Î± : Type u_1} [metric_space Î±] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : Type u_1
{Râ‚ : Type u_3} {Mâ‚ : Type u_4} [ring Râ‚] [add_comm_group Mâ‚] [module Râ‚ Mâ‚] (B : bilin_form Râ‚ Mâ‚) (b : B.is_refl) {W : submodule Râ‚ Mâ‚} (hW : disjoint W (B.orthogonal W)) : (B.restrict W).nondegenerate
{Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (Î´ : â„), Î´ > 0 â†’ (f x âˆ© set.Ioo 0 Î´).nonempty) (R : Î± â†’ â„) (hR : âˆ€ (x : Î±), x âˆˆ s â†’ 0 < R x) : âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable âˆ§ t âŠ† s âˆ§ (âˆ€ (x : Î±), x âˆˆ t â†’ r x âˆˆ f x âˆ© set.Ioo 0 (R x)) âˆ§ â‡‘Î¼ (s  â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) = 0 âˆ§ t.pairwise_disjoint (Î» (x : Î±), metric.closed_ball x (r x))
(x : â„) (h1 : 0 < x) (h2 : x â‰¤ 1) : |real.log x * x| < 1
{G : Type w} [topological_space G] (Î¼ : measure_theory.content G) â¦ƒU V : set Gâ¦„ (hU : is_open U) (hV : is_open V) (h2 : U âŠ† V) : Î¼.inner_content âŸ¨U, hUâŸ© â‰¤ Î¼.inner_content âŸ¨V, hVâŸ©
{Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] (U : set Î²) : quotient.mk â»Â¹' (quotient.mk '' U) = â‹ƒ (a : Î±), has_scalar.smul a '' U
{Ïƒ : Type u_1} {Ï„ : Type u_2} {R : Type u_3} [comm_semiring R] (f : Ïƒ â†’ mv_polynomial Ï„ R) : mv_polynomial Ïƒ R â†’â‚[R] mv_polynomial Ï„ R
{E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f f' : â„‚ â†’ E} {c : â„‚} {R : â„} (h : âˆ€ (z : â„‚), z âˆˆ metric.sphere c |R| â†’ has_deriv_within_at f (f' z) (metric.sphere c |R|) z) : âˆ® (z : â„‚) in C(c, R), f' z = 0
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measurable_space Î²] (f : Î² â†’ ennreal) (g : Î± â‰ƒáµ Î²) : âˆ«â» (a : Î²), f a âˆ‚measure_theory.measure.map â‡‘g Î¼ = âˆ«â» (a : Î±), f (â‡‘g a) âˆ‚Î¼
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_lattice Î²] {m : measurable_space Î±} (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î±) : Î²
{I : Type u} {f : I â†’ Type vâ‚} [decidable_eq I] [Î  (i : I), has_zero (f i)] (i : I) (x : f i) (i_1 : I) : f i_1
{f : â„ â†’ â„} (hf : differentiable â„ f) {C : â„} (le_hf' : âˆ€ (x : â„), deriv f x â‰¤ C) â¦ƒx y : â„â¦„ (hxy : x â‰¤ y) : f y - f x â‰¤ C * (y - x)
{Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) {s : set (Î¹ â†’ â„)} (hs : measurable_set s) (I : box_integral.box Î¹) (y : E) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] : box_integral.has_integral I l (s.indicator (Î» (_x : Î¹ â†’ â„), y)) Î¼.to_box_additive.to_smul ((â‡‘Î¼ (s âˆ© â†‘I)).to_real â€¢ y)
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} [inhabited Î›] {Ïƒ : Type u_4} [inhabited Ïƒ] {k : K} (q : turing.TM1.stmt turing.TM2to1.Î“' turing.TM2to1.Î›' Ïƒ) : turing.TM2to1.st_act k â†’ turing.TM1.stmt turing.TM2to1.Î“' turing.TM2to1.Î›' Ïƒ
{C : Type u} [category_theory.category C] {W X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} [category_theory.limits.has_pullback f g] (h : W âŸ¶ X) (k : W âŸ¶ Y) (w : h â‰« f = k â‰« g) : W âŸ¶ category_theory.limits.pullback f g
{I : Type vâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {J : Type vâ‚} [category_theory.small_category J] {F : J â¥¤ Î  (i : I), C i} {c : Î  (i : I), category_theory.limits.cocone (F â‹™ category_theory.pi.eval C i)} (P : Î  (i : I), category_theory.limits.is_colimit (c i)) : category_theory.limits.is_colimit (category_theory.pi.cocone_of_cocone_comp_eval c)
{E : Type u_1} [inner_product_space â„ E] {c : E} (f : cont_diff_bump_of_inner c) [measurable_space E] (Î¼ : measure_theory.measure E) : E â†’ â„
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} [t2_space M] {f : smooth_bump_covering Î¹ I M s} {U : M â†’ set M} : f.is_subordinate U â†’ f.to_bump_covering.is_subordinate (Î» (i : Î¹), U (f.c i))
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_probability_measure Î¼] (hg : convex_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : g (âˆ« (x : Î±), f x âˆ‚Î¼) â‰¤ âˆ« (x : Î±), g (f x) âˆ‚Î¼
{E : Type u_3} [normed_group E] {f : â„ â†’ E} {a b : â„} {Î¼ : measure_theory.measure â„} (hf : measure_theory.integrable f Î¼) : interval_integrable f Î¼ a b
{p : â„•+} {k : â„•} {K : Type u} [field K] [char_zero K] {Î¶ : K} [hp : fact (nat.prime â†‘p)] [hcycl : is_cyclotomic_extension {p ^ k} â„š K] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ k)) : is_integral_closure â†¥(algebra.adjoin â„¤ {Î¶}) â„¤ K
{Î± : Type u} [linear_ordered_add_comm_group Î±] {a b x y : Î±} (h : set.interval x y âŠ† set.interval a b) : |y - x| â‰¤ |b - a|
{n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] {p : â„•} [hprime : fact (nat.prime p)] (hdiv : Â¬p âˆ£ n) : minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p)
{S : Type uâ‚} {L : Type uâ‚‚} {D : Type uâ‚ƒ} [category_theory.category S] [category_theory.category L] [category_theory.category D] (Î¹ : S â¥¤ L) (F : S â¥¤ D) [I : âˆ€ (x : L), category_theory.limits.has_colimit (category_theory.Lan.diagram Î¹ F x)] (G : L â¥¤ D) : (category_theory.Lan.loc Î¹ F âŸ¶ G) â‰ƒ (F âŸ¶ ((category_theory.whiskering_left S L D).obj Î¹).obj G)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {xâ‚€ : E} (hf : differentiable_at ğ•œ f xâ‚€) {s : set E} (hs : s âˆˆ nhds xâ‚€) {C : nnreal} (hlip : lipschitz_on_with C f s) : âˆ¥fderiv ğ•œ f xâ‚€âˆ¥ â‰¤ â†‘C
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X âŸ¶ Y) [category_theory.limits.has_kernel f] {W : C} (h : W âŸ¶ X) (w : h â‰« f = 0) : W âŸ¶ â†‘(category_theory.limits.kernel_subobject f)
(M : Type u_4) (Î± : Type u_5) [has_scalar M Î±] {_x : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : Prop
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {S : set (set Î±)} (hc : S.countable) (hs : â‹ƒâ‚€S = set.univ) : Î¼ = Î½ â†” âˆ€ (s : set Î±), s âˆˆ S â†’ Î¼.restrict s = Î½.restrict s
{Î¹ : Type u_1} {Î± : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (hd : pairwise (measure_theory.ae_disjoint Î¼ on s)) : âˆƒ (t : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), measurable_set (t i)) âˆ§ (âˆ€ (i : Î¹), â‡‘Î¼ (t i) = 0) âˆ§ pairwise (disjoint on Î» (i : Î¹), s i  t i)
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : x = y â†” o.oangle x y = 0
{Î± : Sort u_1} {sâ‚ : setoid Î±} {Ï† : quotient sâ‚ â†’ Sort u_2} [h : âˆ€ (a : Î±), subsingleton (Ï† âŸ¦aâŸ§)] (q : quotient sâ‚) (f : Î  (a : Î±), Ï† (quotient.mk' a)) : Ï† q
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {W X Y : C} [category_theory.limits.has_binary_biproduct X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) : W âŸ¶ X âŠ Y
{c : Type u â†’ Type u} (hom : Î  â¦ƒÎ± Î² : Type uâ¦„, c Î± â†’ c Î² â†’ Type u) : Type (u+1)
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [add_group G] [topological_add_group G] [Î¼.is_add_left_invariant] [Î¼.regular] (hâ‚€ : Î¼ â‰  0) : Î¼.is_open_pos_measure
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {f : Î± â†’ Î²} (hf : measure_theory.mem_â„’p f 1 Î¼) (hmeas : measure_theory.strongly_measurable f) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (M : â„), âˆ«â» (x : Î±), â†‘âˆ¥{x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f xâˆ¥â‚Š âˆ‚Î¼ â‰¤ ennreal.of_real Îµ
{n : â„•} {Î² : Type u_1} [comm_monoid Î²] (f : â„• â†’ Î²) : n.factorization.prod (Î» (p k : â„•), f p) = n.factors.to_finset.prod (Î» (p : â„•), f p)
{E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y : E} (h : Â¬same_ray â„ x y) : âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (G i)] {f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’+ G j} [is_directed Î¹ has_le.le] [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] (i : Î¹) (x : G i) (h : â‡‘(add_comm_group.direct_limit.of G f i) x = 0) : âˆƒ (j : Î¹) (hij : i â‰¤ j), â‡‘(f i j hij) x = 0
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {Î¼ : measure_theory.measure â„} {E : Type u_2} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {a b Îµ : â„} {bound : â„ â†’ â„} {F : ğ•œ â†’ â„ â†’ E} {F' : â„ â†’ E} {xâ‚€ : ğ•œ} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : ğ•œ) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F xâ‚€) Î¼ a b) (hF'_meas : measure_theory.ae_strongly_measurable F' (Î¼.restrict (set.interval_oc a b))) (h_lipsch : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ lipschitz_on_with (â‡‘real.nnabs (bound t)) (Î» (x : ğ•œ), F x t) (metric.ball xâ‚€ Îµ)) (bound_integrable : interval_integrable bound Î¼ a b) (h_diff : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ has_deriv_at (Î» (x : ğ•œ), F x t) (F' t) xâ‚€) : interval_integrable F' Î¼ a b âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' t âˆ‚Î¼) xâ‚€
(cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : state_t tactic.ext_state tactic unit
{Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] [normed_space â„ F] (hm : m â‰¤ m0) (hp_ne_top : p â‰  âŠ¤) (P : â†¥(measure_theory.Lp F p Î¼) â†’ Prop) (h_ind : âˆ€ (c : F) {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s < âŠ¤), P â†‘(measure_theory.Lp.simple_func.indicator_const p _ _ c)) (h_add : âˆ€ â¦ƒf g : Î± â†’ Fâ¦„ (hf : measure_theory.mem_â„’p f p Î¼) (hg : measure_theory.mem_â„’p g p Î¼), measure_theory.ae_strongly_measurable' m f Î¼ â†’ measure_theory.ae_strongly_measurable' m g Î¼ â†’ disjoint (function.support f) (function.support g) â†’ P (measure_theory.mem_â„’p.to_Lp f hf) â†’ P (measure_theory.mem_â„’p.to_Lp g hg) â†’ P (measure_theory.mem_â„’p.to_Lp f hf + measure_theory.mem_â„’p.to_Lp g hg)) (h_closed : is_closed {f : â†¥(measure_theory.Lp_meas F â„ m p Î¼) | P â†‘f}) (f : â†¥(measure_theory.Lp F p Î¼)) : measure_theory.ae_strongly_measurable' m â‡‘f Î¼ â†’ P f
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] (fâ‚€ : E' â†’SL[Ïƒâ‚â‚‚] F) (r : â„) â¦ƒf : E' â†’SL[Ïƒâ‚â‚‚] Fâ¦„ (hf : â‡‘f âˆˆ closure (coe_fn '' metric.closed_ball fâ‚€ r)) : f âˆˆ metric.closed_ball fâ‚€ r
{E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b C : â„} (hf : differentiable_on â„ f (set.Icc a b)) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥deriv_within f (set.Icc a b) xâˆ¥ â‰¤ C) (x : â„) (H : x âˆˆ set.Icc a b) : âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
{L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] [L.Structure N] (f : L.embedding M N) (htv : âˆ€ (n : â„•) (Ï† : L.bounded_formula empty (n + 1)) (x : fin n â†’ M) (a : N), Ï†.realize inhabited.default (fin.snoc (â‡‘f âˆ˜ x) a) â†’ (âˆƒ (b : M), Ï†.realize inhabited.default (fin.snoc (â‡‘f âˆ˜ x) (â‡‘f b)))) : L.elementary_embedding M N
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] {C : Î  (i : Î¹), set (set (Î± i))} (hC : âˆ€ (i : Î¹), is_countably_spanning (C i)) : is_countably_spanning (set.univ.pi '' set.univ.pi C)
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F) (r : â„) : is_closed (coe_fn '' metric.closed_ball fâ‚€ r)
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) [t2_space M] [smooth_manifold_with_corners I M] : smooth I (model_with_corners_self â„ â„) â‡‘f
{Î± : Type u} [pseudo_metric_space Î±] : (uniformity Î±).has_basis (Î» (Îµ : â„), 0 < Îµ) (Î» (Îµ : â„), {p : Î± Ã— Î± | has_dist.dist p.fst p.snd â‰¤ Îµ})
(P : Î  (X : algebraic_geometry.Scheme), topological_space.opens â†¥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier) â†’ Prop) (hâ‚ : âˆ€ (X : algebraic_geometry.Scheme) (U : topological_space.opens â†¥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)), (âˆ€ (x : â†¥U), âˆƒ {V : topological_space.opens â†¥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (h : x.val âˆˆ V) (i : V âŸ¶ U), P X V) â†’ P X U) (hâ‚‚ : âˆ€ {X Y : algebraic_geometry.Scheme} (f : X âŸ¶ Y) [hf : algebraic_geometry.is_open_immersion f], âˆƒ {U : set â†¥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} {V : set â†¥(Y.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (hU : U = âŠ¤) (hV : V = set.range â‡‘(f.val.base)), P X âŸ¨U, _âŸ© â†’ P Y âŸ¨V, _âŸ©) (hâ‚ƒ : âˆ€ (R : CommRing), P (algebraic_geometry.Scheme.Spec.obj (opposite.op R)) âŠ¤) (X : algebraic_geometry.Scheme) (U : topological_space.opens â†¥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)) : P X U
{R : Type u_1} [semiring R] {S : Type u_2} {F : Type u_3} [semiring S] [add_monoid_hom_class F (polynomial R) (polynomial S)] {Ï† : F} {p : polynomial R} (k : â„•) (fu : â„• â†’ â„•) (fu0 : âˆ€ {n : â„•}, n â‰¤ k â†’ fu n = 0) (fc : âˆ€ {n m : â„•}, k â‰¤ n â†’ n < m â†’ fu n < fu m) (Ï†_k : âˆ€ {f : polynomial R}, f.nat_degree < k â†’ â‡‘Ï† f = 0) (Ï†_mon_nat : âˆ€ (n : â„•) (c : R), c â‰  0 â†’ (â‡‘Ï† (â‡‘(polynomial.monomial n) c)).nat_degree = fu n) : (â‡‘Ï† p).nat_degree = fu p.nat_degree
{I : Type u} {f : I â†’ Type v} [decidable_eq I] [Î  (i : I), mul_one_class (f i)] (x : Î  (i : I), f i) (i j : I) : commute (pi.mul_single i (x i)) (pi.mul_single j (x j))
{elab : bool := bool.tt} : expr elab â†’ option (name Ã— expr elab Ã— expr elab Ã— expr elab)
{Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} [decidable_eq Î²] (I : function.injective f) : decidable_eq Î±
{Î² : Type u} [metric_space Î²] [measurable_space Î²] [borel_space Î²] [sigma_compact_space Î²] [has_besicovitch_covering Î²] (Î¼ : measure_theory.measure Î²) [measure_theory.is_locally_finite_measure Î¼] {s : set Î²} (hs : measurable_set s) : âˆ€áµ (x : Î²) âˆ‚Î¼, filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (s.indicator 1 x))
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) {a : Î±} {s : set Î±} : is_least s a â†’ is_greatest (f '' s) (f a)
{X : Type u_1} [pseudo_metric_space X] [proper_space X] {s : set X} (hs : metric.bounded s) {x : â„• â†’ X} (hx : âˆ€ (n : â„•), x n âˆˆ s) : âˆƒ (a : X) (H : a âˆˆ closure s) (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ filter.tendsto (x âˆ˜ Ï†) filter.at_top (nhds a)
{Î¹ : Type u_1} [decidable_eq Î¹] {A : Î¹ â†’ Type u_2} {R : Type u_3} [Î  (i : Î¹), add_comm_monoid (A i)] [add_monoid Î¹] [direct_sum.gsemiring A] [semiring R] â¦ƒF G : direct_sum Î¹ (Î» (i : Î¹), A i) â†’+* Râ¦„ (h : âˆ€ (i : Î¹), â†‘F.comp (direct_sum.of A i) = â†‘G.comp (direct_sum.of A i)) : F = G
(cs : interactive.parse (lean.parser.many lean.parser.ident)) (locat : interactive.parse interactive.types.location) (cfg : tactic.unfold_config := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}}) : tactic unit
{Î± : Type u_1} {m0 : measurable_space Î±} [topological_space Î±] (Î¼ : measure_theory.measure Î±) : Prop
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {A : E â†’L[â„] E} {Î´ : nnreal} (hf : approximates_linear_on f A s Î´) (hs : measurable_set s) (f' : E â†’ (E â†’L[â„] E)) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) : âˆ€áµ (x : E) âˆ‚Î¼.restrict s, âˆ¥f' x - Aâˆ¥â‚Š â‰¤ Î´
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring ğ•œ] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] {x : E} (f : E â†’áµƒ[ğ•œ] F) {s : set E} (hs : star_convex ğ•œ x s) : star_convex ğ•œ (â‡‘f x) (â‡‘f '' s)
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b : â„} {f : â„‚ â†’ E} (hd : diff_cont_on_cl â„‚ f (complex.im â»Â¹' set.Ioo a b)) (hB : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.re) filter.at_top âŠ“ filter.principal (complex.im â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.re|))) (ha : âˆ€ (z : â„‚), z.im = a â†’ f z = 0) (hb : âˆ€ (z : â„‚), z.im = b â†’ f z = 0) : set.eq_on f 0 (complex.im â»Â¹' set.Icc a b)
{C : Type u} [category_theory.category C] {W X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} [category_theory.limits.has_pushout f g] (h : Y âŸ¶ W) (k : Z âŸ¶ W) (w : f â‰« h = g â‰« k) : category_theory.limits.pushout f g âŸ¶ W
{Î¹ : Type u_1} (I : box_integral.box Î¹) (i : Î¹) (x : â„) : with_bot (box_integral.box Î¹)
{C : Type uâ‚} [category_theory.category C] {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z} (s : category_theory.comm_sq f g h i) : category_theory.limits.pushout_cocone f g
{Î¹ : Type u_1} [decidable_eq Î¹] {A : Î¹ â†’ Type u_2} {R : Type u_3} [Î  (i : Î¹), add_comm_monoid (A i)] [add_monoid Î¹] [direct_sum.gsemiring A] [semiring R] â¦ƒf g : direct_sum Î¹ (Î» (i : Î¹), A i) â†’+* Râ¦„ (h : âˆ€ (i : Î¹) (x : A i), â‡‘f (â‡‘(direct_sum.of A i) x) = â‡‘g (â‡‘(direct_sum.of A i) x)) : f = g
{Î± : Type u_1} {E : Type u_2} [normed_group E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_space â„ E] (f : â†¥(measure_theory.Lp.simple_func E 1 Î¼)) : E
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} {I : category_theory.InjectiveResolution Y} {J : category_theory.InjectiveResolution Z} (f : I.cocomplex âŸ¶ J.cocomplex) (comm : I.Î¹ â‰« f = 0) : I.cocomplex.X 1 âŸ¶ J.cocomplex.X 0
(G W : expr) (u : list name) : tactic expr
{E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {c : â„‚} (hd : âˆ€á¶  (z : â„‚) in nhds_within c {c}á¶œ, differentiable_at â„‚ f z) (hb : filter.is_bounded_under has_le.le (nhds_within c {c}á¶œ) (Î» (z : â„‚), âˆ¥f z - f câˆ¥)) : filter.tendsto f (nhds_within c {c}á¶œ) (nhds (lim (nhds_within c {c}á¶œ) f))
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * â†‘(fintype.card Î¹) * linear_order.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
(Î± : Type u_1) [measurable_space Î±] (Î¼ : measure_theory.measure Î± . "volume_tac") : Type u_1
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} [inhabited Î›] {Ïƒ : Type u_4} [inhabited Ïƒ] {k : K} : turing.TM2to1.st_act k â†’ turing.TM2.stmt Î“ Î› Ïƒ â†’ turing.TM2.stmt Î“ Î› Ïƒ
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} {C : Î  (i : Î¹), set (set (Î± i))} (hC : âˆ€ (i : Î¹), is_pi_system (C i)) : is_pi_system (set.univ.pi '' set.univ.pi C)
{Î¹ : Type u_1} (I : box_integral.box Î¹) (s : set Î¹) : box_integral.box Î¹
{Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group E] {p : ennreal} {f : Î¹ â†’ Î± â†’ E} {g : Î± â†’ E} {l : filter Î¹} (hp_ne_zero : p â‰  0) (hf : âˆ€ (n : Î¹), measure_theory.ae_strongly_measurable (f n) Î¼) (hg : measure_theory.ae_strongly_measurable g Î¼) (hfg : filter.tendsto (Î» (n : Î¹), measure_theory.snorm (f n - g) p Î¼) l (nhds 0)) : measure_theory.tendsto_in_measure Î¼ f l g
{Ïƒ : Type u_1} {R : Type u} [comm_semiring R] (s : set Ïƒ) : â†¥(mv_polynomial.supported R s) â‰ƒâ‚[R] mv_polynomial â†¥s R
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {Ïƒ : equiv.perm Î±} (hÏƒ : Ïƒ.is_cycle) : â†¥â†‘(subgroup.zpowers Ïƒ) â‰ƒ â†¥â†‘(Ïƒ.support)
{M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} [preorder N] [covariant_class M N Î¼ has_le.le] (m : M) : monotone (Î¼ m)
(e : expr) (md : tactic.transparency := tactic.transparency.reducible) : tactic â„•
{C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (G : D â¥¤ C) [category_theory.is_right_adjoint G] [âˆ€ â¦ƒA B : Dâ¦„ (f g : A âŸ¶ B) [_inst_5 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g] [Î  â¦ƒA B : Dâ¦„ (f g : A âŸ¶ B) [_inst_7 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G] [Î  â¦ƒA B : Dâ¦„ (f g : A âŸ¶ B) [_inst_9 : G.is_split_pair f g], category_theory.limits.reflects_colimit (category_theory.limits.parallel_pair f g) G] : category_theory.monadic_right_adjoint G
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {x : M} {n : â„•} : cont_mdiff_within_at I I' â†‘n f s x â†” âˆƒ (u : set M) (H_1 : u âˆˆ nhds_within x (has_insert.insert x s)), cont_mdiff_on I I' â†‘n f u
{C : Type u} [category_theory.category C] (all_unique : Î  {X Y : C}, unique (X âŸ¶ Y)) : category_theory.groupoid C
{Î¹ : Type u_1} [decidable_eq Î¹] {R : Type u_4} [comm_semiring R] {s : Î¹ â†’ Type u_7} [Î  (i : Î¹), add_comm_monoid (s i)] [Î  (i : Î¹), module R (s i)] {E : Type u_9} [add_comm_monoid E] [module R E] (Ï† : multilinear_map R s E) : pi_tensor_product R (Î» (i : Î¹), s i) â†’+ E
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) {G : Type u_4} [has_mul G] [topological_space G] [charted_space H G] [has_smooth_mul I G] (g : G) : cont_mdiff_map I I G G âŠ¤
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] (f : measure_theory.simple_func Î± nnreal) (int_f : âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚Î¼ â‰  âŠ¤) {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ â‡‘f x) âˆ§ upper_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} {I : category_theory.InjectiveResolution Y} {J : category_theory.InjectiveResolution Z} (f : I.cocomplex âŸ¶ J.cocomplex) (comm : I.Î¹ â‰« f = 0) : homotopy f 0
(no_dflt : interactive.parse interactive.types.only_flag) (es : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (l : interactive.parse interactive.types.location) (cfg : tactic.dsimp_config := {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}) : tactic unit
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {F : Type u_2} [semi_normed_group F] [normed_space ğ•œ F] (p : subspace ğ•œ F) (f : â†¥p â†’L[ğ•œ] ğ•œ) : âˆƒ (g : F â†’L[ğ•œ] ğ•œ), (âˆ€ (x : â†¥p), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥
{R : Type u_1} [comm_semiring R] (Ïƒ : Type u_2) [fintype Ïƒ] : finset.univ.prod (Î» (i : Ïƒ), â‡‘polynomial.C (mv_polynomial.X i) + polynomial.X) = (finset.range (fintype.card Ïƒ + 1)).sum (Î» (j : â„•), â‡‘polynomial.C (mv_polynomial.esymm Ïƒ R j) * polynomial.X ^ (fintype.card Ïƒ - j))
{p : â„•} {g : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R} {f : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R} (hg : witt_vector.is_polyâ‚‚ p g) (hf : witt_vector.is_poly p f) : witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g x (f y))
{Ïƒ : Type u_1} (R : Type u_2) [semiring R] (n : Ïƒ â†’â‚€ â„•) : R â†’â‚—[R] mv_power_series Ïƒ R
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {I : set Î²} {s : Î² â†’ set Î±} (H : I.finite) : metric.bounded (â‹ƒ (i : Î²) (H : i âˆˆ I), s i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ metric.bounded (s i)
{Î± : Type u_1} {m0 : measurable_space Î±} [pseudo_metric_space Î±] [proper_space Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure_on_compacts Î¼] â¦ƒs : set Î±â¦„ (hs : metric.bounded s) : â‡‘Î¼ s < âŠ¤
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [category_theory.limits.has_wide_equalizer f] [nonempty J] {W : C} (k : W âŸ¶ X) (h : âˆ€ (jâ‚ jâ‚‚ : J), k â‰« f jâ‚ = k â‰« f jâ‚‚) : {l // l â‰« category_theory.limits.wide_equalizer.Î¹ f = k}
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (f : Y âŸ¶ Z) {I : category_theory.InjectiveResolution Y} {J : category_theory.InjectiveResolution Z} (g h : I.cocomplex âŸ¶ J.cocomplex) (g_comm : I.Î¹ â‰« g = (cochain_complex.singleâ‚€ C).map f â‰« J.Î¹) (h_comm : I.Î¹ â‰« h = (cochain_complex.singleâ‚€ C).map f â‰« J.Î¹) : homotopy g h
{Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {Î² : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (Î² i)] {Î³ : Type u_1} [add_monoid Î³] â¦ƒf g : direct_sum Î¹ (Î» (i : Î¹), Î² i) â†’+ Î³â¦„ (H : âˆ€ (i : Î¹), f.comp (direct_sum.of (Î» (i : Î¹), Î² i) i) = g.comp (direct_sum.of Î² i)) : f = g
{Î¹ : Type u} (Î² : Î¹ â†’ Type v) [I : nonempty Î¹] : âˆƒ (i : Î¹), nonempty (Î  (j : Î¹), Î² i â†ª Î² j)
{E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {Ï† : E â†’ â„} {xâ‚€ : E} {Ï†' : E â†’L[â„] â„} {Î¹ : Type u_2} [fintype Î¹] {f : Î¹ â†’ E â†’ â„} {f' : Î¹ â†’ (E â†’L[â„] â„)} (hextr : is_local_extr_on Ï† {x : E | âˆ€ (i : Î¹), f i x = f i xâ‚€} xâ‚€) (hf' : âˆ€ (i : Î¹), has_strict_fderiv_at (f i) (f' i) xâ‚€) (hÏ†' : has_strict_fderiv_at Ï† Ï†' xâ‚€) : âˆƒ (Î› : Î¹ â†’ â„) (Î›â‚€ : â„), (Î›, Î›â‚€) â‰  0 âˆ§ finset.univ.sum (Î» (i : Î¹), Î› i â€¢ f' i) + Î›â‚€ â€¢ Ï†' = 0
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ s : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : measurable f) (hs : s.mutually_singular Î½) (hadd : Î¼ = s + Î½.with_density f) : Î½.with_density f = Î½.with_density (Î¼.rn_deriv Î½)
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary (f âˆ˜ â‡‘Ïƒ) g
{C : Type u} [category_theory.category C] (B : C) [category_theory.limits.has_finite_products C] {I : C} (t : category_theory.limits.is_initial I) [category_theory.cartesian_closed C] : (category_theory.exp I).obj B â‰… âŠ¤_ C
{Î¹ : Type u_1} {N : Type u_5} [topological_space N] [add_monoid N] [has_continuous_add N] [t2_space N] {f : Î¹ â†’ add_units N} {râ‚ râ‚‚ : N} {l : filter Î¹} [l.ne_bot] (hâ‚ : filter.tendsto (Î» (x : Î¹), â†‘(f x)) l (nhds râ‚)) (hâ‚‚ : filter.tendsto (Î» (x : Î¹), â†‘-f x) l (nhds râ‚‚)) : add_units N
{C : Type uâ‚} [category_theory.category C] {X Y W : C} (f : X âŸ¶ Y) [category_theory.regular_mono f] (k : W âŸ¶ Y) (h : k â‰« category_theory.regular_mono.left = k â‰« category_theory.regular_mono.right) : {l // l â‰« f = k}
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) : orthogonal_family ğ•œ (Î» (Î¼ : ğ•œ), (module.End.eigenspace T Î¼).subtypeâ‚—áµ¢)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) : local_equiv M E
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [Î  (i : Î¹), measurable_space (Î± i)] : is_pi_system (set.univ.pi '' set.univ.pi (Î» (i : Î¹), {s : set (Î± i) | measurable_set s}))
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : f '' s âˆˆ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') (n : with_top â„•) (f : H â†’ H') (s : set H) (x : H) : Prop
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {s : set ğ•œ} [complete_space F] (h : analytic_on ğ•œ f s) (n : â„•) : analytic_on ğ•œ (deriv^[n] f) s
(n : â„•) (t : Type u_1) (t' : Type u_2) (v : typevec n) (v' : typevec n) {Î² : (v ::: t).arrow (v' ::: t') â†’ Sort u_3} (F : Î  (f : t â†’ t') (fs : v.arrow v'), Î² (fs ::: f)) (fs : (v ::: t).arrow (v' ::: t')) : Î² fs
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) : category_theory.limits.walking_multispan I.fst_from I.snd_from â¥¤ C
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ C
(all_goals : interactive.parse (optional (lean.parser.tk "*"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (opt : tactic.solve_by_elim.opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := Î» (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (Î» (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}) : tactic unit
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ?? E] {x y : E} (hx : âˆ¥xâˆ¥ = 1) (hy : âˆ¥yâˆ¥ = 1) : has_inner.inner x y = 1 â†” x = y
{Î± : Type u} [pseudo_emetric_space Î±] {Îµ : ennreal} (Îµ0 : 0 < Îµ) : {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < Îµ} âˆˆ uniformity Î±
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (Î¼ : R) : submodule R M
{Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : â„• â†’ Î© â†’ â„) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hindep : pairwise (Î» (i j : â„•), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) (hident : âˆ€ (i : â„•), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) (hnonneg : âˆ€ (i : â„•) (Ï‰ : Î©), 0 â‰¤ X i Ï‰) : âˆ€áµ (Ï‰ : Î©), filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), X i Ï‰) / â†‘n) filter.at_top (nhds (âˆ« (a : Î©), X 0 a))
{Î± : Type u_1} {Î² : Î± â†’ Type u_4} {Î³ : Î  (a : Î±), Î² a â†’ Type u_2} (f : Î  (x : Î±) (y : Î² x), Î³ x y) (x : sigma Î²) : Î³ x.fst x.snd
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {v : vitali_family Î¼} {f : Î± â†’ set (set Î±)} {s : set Î±} (h : v.fine_subfamily_on f s) : Î± â†’ set Î±
{Î± : Type u_1} {F : Type u_3} [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [decidable_pred (Î» (x : F), x â‰  0)] {f : measure_theory.simple_func Î± F} {s : finset F} (hs : finset.filter (Î» (x : F), x â‰  0) f.range âŠ† s) : measure_theory.simple_func.integral Î¼ f = s.sum (Î» (x : F), (â‡‘Î¼ (â‡‘f â»Â¹' {x})).to_real â€¢ x)
{R : Type u_1} [comm_semiring R] (S : Type u_2) [comm_semiring S] [algebra R S] (I : ideal R) [hp : I.is_prime] : Prop
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] {p q : submodule R E} (h : is_compl p q) (Ï† : â†¥p â†’â‚—[R] F) (Ïˆ : â†¥q â†’â‚—[R] F) : E â†’â‚—[R] F
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type wâ‚} [category_theory.category D] {E : Type wâ‚‚} [category_theory.category E] (F : D â¥¤ E) [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [Î  (X : C) (W : J.cover X) (P : Cáµ’áµ– â¥¤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] (P : Cáµ’áµ– â¥¤ D) [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– E] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– F] : J.plus_obj P â‹™ F â‰… J.plus_obj (P â‹™ F)
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} {Ïƒ : Type u_4} (M : Î› â†’ turing.TM2.stmt Î“ Î› Ïƒ) : turing.TM2.cfg Î“ Î› Ïƒ â†’ option (turing.TM2.cfg Î“ Î› Ïƒ)
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : add_subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_add_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [Î¼.is_add_left_invariant] [Î¼.is_add_right_invariant] : measure_theory.vadd_invariant_measure G (G â§¸ Î“) (measure_theory.measure.map quotient_add_group.mk (Î¼.restrict ğ“•))
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] [complete_space F] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (g : E â†’ F) : âˆ« (x : E) in f '' s, g x âˆ‚Î¼ = âˆ« (x : E) in s, |(f' x).det| â€¢ g (f x) âˆ‚Î¼
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X âŸ¶ Y) [category_theory.limits.has_cokernel f] {W : C} (k : Y âŸ¶ W) (h : f â‰« k = 0) : category_theory.limits.cokernel f âŸ¶ W
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {e : local_homeomorph M M'} (he : local_homeomorph.mdifferentiable I I' e) [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] {x : M} (hx : x âˆˆ e.to_local_equiv.source) : tangent_space I x â‰ƒL[ğ•œ] tangent_space I' (â‡‘e x)
(B : Type uâ‚) [quiver B] [Î  (a b : B), quiver (a âŸ¶ b)] (C : Type uâ‚‚) [quiver C] [Î  (a b : C), quiver (a âŸ¶ b)] : Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚ wâ‚ wâ‚‚)
{C : Type u} [category_theory.category C] {W X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} [category_theory.limits.has_pushout f g] (h : Y âŸ¶ W) (k : Z âŸ¶ W) (w : f â‰« h = g â‰« k) : {l // category_theory.limits.pushout.inl â‰« l = h âˆ§ category_theory.limits.pushout.inr â‰« l = k}
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R â†’+* P} {T : submonoid P} {Q : Type u_4} [comm_semiring Q] (hy : M â‰¤ submonoid.comap â†‘g T) [algebra P Q] [is_localization T Q] {A : Type u_5} [comm_semiring A] {U : submonoid A} {W : Type u_6} [comm_semiring W] [algebra A W] [is_localization U W] {l : P â†’+* A} (hl : T â‰¤ submonoid.comap â†‘l U) (x : S) : â‡‘(is_localization.map W l hl) (â‡‘(is_localization.map Q g hy) x) = â‡‘(is_localization.map W (l.comp g) _) x
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) : â‡‘Î¼ {x : Î± | v.lim_ratio_meas hÏ x = âŠ¤} = 0
{R : Type u} [comm_ring R] [is_domain R] {ğ“Ÿ : ideal R} {f : polynomial R} (hf : f.is_eisenstein_at ğ“Ÿ) (hprime : ğ“Ÿ.is_prime) (hu : f.is_primitive) (hfd0 : 0 < f.nat_degree) : irreducible f
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M â†’+ N} (h : âˆ€ (y : â†¥S), is_add_unit (â‡‘f â†‘y)) {xâ‚ xâ‚‚ : M} {yâ‚ yâ‚‚ : â†¥S} : â‡‘f xâ‚ + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) yâ‚ = â‡‘f xâ‚‚ + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) yâ‚‚ â†” â‡‘f (xâ‚ + â†‘yâ‚‚) = â‡‘f (xâ‚‚ + â†‘yâ‚)
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (s : affine_subspace â„ E) (hs : s â‰  âŠ¤) : â‡‘Î¼ â†‘s = 0
{R : Type u} [ring R] {I : ideal R} : I.jacobson = I â†” âˆ€ (x : R), x âˆ‰ I â†’ (âˆƒ (M : ideal R), (I â‰¤ M âˆ§ M.is_maximal) âˆ§ x âˆ‰ M)
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : real.angle) : o.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x
{B : Type uâ‚} [category_theory.bicategory B] {C : Type uâ‚‚} [category_theory.bicategory C] (obj : B â†’ C) (map : Î  {X Y : B}, (X âŸ¶ Y) â†’ (obj X âŸ¶ obj Y)) (mapâ‚‚ : Î  {a b : B} {f g : a âŸ¶ b}, (f âŸ¶ g) â†’ (map f âŸ¶ map g)) (map_comp : Î  {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c), map (f â‰« g) â‰… map f â‰« map g) {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d) : Prop
{Î± : Type u_1} {C : free_monoid Î± â†’ Sort u_2} (xs : free_monoid Î±) (h0 : C 1) (ih : Î  (x : Î±) (xs : free_monoid Î±), C xs â†’ C (free_monoid.of x * xs)) : C xs
{Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : â„• â†’ Î© â†’ â„) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hindep : pairwise (Î» (i j : â„•), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) (hident : âˆ€ (i : â„•), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) : âˆ€áµ (Ï‰ : Î©), filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), X i Ï‰) / â†‘n) filter.at_top (nhds (âˆ« (a : Î©), X 0 a))
{Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} (hf : measurable f) {s : set Î²} (hs : measurable_set s) : (measure_theory.measure.map f Î¼).restrict s = measure_theory.measure.map f (Î¼.restrict (f â»Â¹' s))
(p : Prop) [slim_check.testable p] (cfg : slim_check.slim_check_cfg := {num_inst := 100, max_size := 100, trace_discarded := bool.ff, trace_success := bool.ff, trace_shrink := bool.ff, trace_shrink_candidates := bool.ff, random_seed := option.none â„•, quiet := bool.ff}) : rand (slim_check.test_result p)
{R : Type u_5} {S : Type u_6} [comm_semiring R] [comm_semiring S] (Ïƒ : R â‰ƒ+* S) (n : â„•+) : â†¥(roots_of_unity n R) â‰ƒ* â†¥(roots_of_unity n S)
(h : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
(h : name) (t : option expr := option.none) (pr : expr) : tactic expr
{R : Type u_1} [comm_ring R] [is_domain R] (Ï† Ïˆ : power_series R) : (Ï† * Ïˆ).order = Ï†.order + Ïˆ.order
{Râ‚ : Type u_5} {Râ‚‚ : Type u_6} [semiring Râ‚] [semiring Râ‚‚] [has_norm Râ‚] [has_norm Râ‚‚] (Ïƒ : Râ‚ â†’+* Râ‚‚) : Prop
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] [measurable_space G] [has_sub G] (f : G â†’ E) (g : G â†’ E') (x : G) (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) (Î¼ : measure_theory.measure G . "volume_tac") : Prop
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} (ht : t âˆˆ nhds_within x s) : â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds_within (â‡‘(ext_chart_at I x) x) (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I)
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Î¹] (p : Î¹ â†’ P) (s : set Î¹) : finite_dimensional k â†¥(vector_span k (p '' s))
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [Î¼.is_add_left_invariant] [measure_theory.sigma_finite Î¼] [normed_space â„ E'] [complete_space E'] {Î¹ : Type u_1} {l : filter Î¹} {Ï† : Î¹ â†’ G â†’ â„} (hnÏ† : âˆ€ (i : Î¹) (x : G), 0 â‰¤ Ï† i x) (hiÏ† : âˆ€ (i : Î¹), âˆ« (s : G), Ï† i s âˆ‚Î¼ = 1) (hÏ† : filter.tendsto (Î» (n : Î¹), function.support (Ï† n)) l (nhds 0).small_sets) (hmg : measure_theory.ae_strongly_measurable g Î¼) {xâ‚€ : G} (hcg : continuous_at g xâ‚€) : filter.tendsto (Î» (i : Î¹), convolution (Ï† i) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) l (nhds (g xâ‚€))
(lemmas : option (list expr) := option.none) (opt : tactic.apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}) (tac : tactic unit := tactic.interactive.skip) : tactic unit
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : filter.is_bounded_under has_le.le filter.at_top (Î» (x : â„), âˆ¥f â†‘xâˆ¥)) (him : âˆ€ (x : â„), âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz : 0 â‰¤ z.re) : âˆ¥f zâˆ¥ â‰¤ C
{E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y : E} {a b r : â„} (hx : âˆ¥xâˆ¥ â‰¤ r) (hy : âˆ¥yâˆ¥ â‰¤ r) (hne : x â‰  y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : âˆ¥a â€¢ x + b â€¢ yâˆ¥ < r
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (Ïƒ : equiv.perm n) : (equiv.to_pequiv Ïƒ).to_matrix.det = â†‘(â‡‘equiv.perm.sign Ïƒ)
(f : expr) (nargs : option â„• := option.none) : tactic.unsafe.type_context fun_info
{Î± : Type u} {Î² : Type v} {s : set Î±} {t : set Î²} {f : Î± â†’ Î²} : f '' s âŠ† t â†” s âŠ† f â»Â¹' t
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {E : intermediate_field K L} (Ïƒ : L â‰ƒâ‚[K] L) [finite_dimensional K â†¥E] : finite_dimensional K â†¥(E.map Ïƒ.to_alg_hom)
{R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) : (Î» (t : R), ring.inverse (â†‘x + t) - â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type wâ‚} [category_theory.category D] {E : Type wâ‚‚} [category_theory.category E] (F : D â¥¤ E) [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [Î  (X : C) (W : J.cover X) (P : Cáµ’áµ– â¥¤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] (P : Cáµ’áµ– â¥¤ D) (X : C) : J.diagram P X â‹™ F â‰… J.diagram (P â‹™ F) X
{Î± : Type u_1} [uniform_space Î±] {s : set (Î± Ã— Î±)} (hs : s âˆˆ uniformity Î±) (n : â„•) : âˆ€á¶  (t : set (Î± Ã— Î±)) in (uniformity Î±).small_sets, comp_rel t^[n] t âŠ† s
{E : Type u_1} [normed_group E] [measurable_space E] [normed_space â„ E] [finite_dimensional â„ E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (r : â„) (s : set E) : â‡‘Î¼ (r â€¢ s) = ennreal.of_real |r ^ finite_dimensional.finrank â„ E| * â‡‘Î¼ s
{C : Type uâ‚} [category_theory.category C] {I I' : C} (hI : category_theory.limits.is_initial I) (hI' : category_theory.limits.is_initial I') : I â‰… I'
{R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] {e : Î¹ â†’ M} {Îµ : Î¹ â†’ module.dual R M} [decidable_eq Î¹] (h : dual_pair e Îµ) (m : M) : Î¹ â†’â‚€ R
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
{M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} {Î± : Type u_3} [preorder Î±] [preorder N] {f : N â†’ Î±} [covariant_class M N Î¼ has_le.le] (hf : antitone f) (m : M) : antitone (Î» (n : N), f (Î¼ m n))
{a b : â„} {E : Type u_1} [normed_group E] {f : â„ â†’ E} {f' : â„ â†’ â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ (âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), slope (has_norm.norm âˆ˜ f) x z < r)) {B B' : â„ â†’ â„} (ha : âˆ¥f aâˆ¥ â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f xâˆ¥ = B x â†’ f' x < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {r : nnreal} {f : X â†’ Y} (hr : 0 < r) {s : set X} (hf : âˆ€ (x : X), x âˆˆ s â†’ (âˆƒ (C : nnreal) (t : set X) (H : t âˆˆ nhds_within x s), holder_on_with C r f t)) : dimH (f '' s) â‰¤ dimH s / â†‘r
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {M : mv_polynomial Ïƒ R â†’ Prop} (p : mv_polynomial Ïƒ R) (h_C : âˆ€ (a : R), M (â‡‘mv_polynomial.C a)) (h_add_weak : âˆ€ (a : Ïƒ â†’â‚€ â„•) (b : R) (f : (Ïƒ â†’â‚€ â„•) â†’â‚€ R), a âˆ‰ f.support â†’ b â‰  0 â†’ M f â†’ M (â‡‘(mv_polynomial.monomial a) b) â†’ M (â‡‘(mv_polynomial.monomial a) b + f)) (h_X : âˆ€ (p : mv_polynomial Ïƒ R) (n : Ïƒ), M p â†’ M (p * mv_polynomial.X n)) : M p
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f g : measure_theory.simple_func Î± ennreal} (h : â‡‘f =áµ[Î¼] â‡‘g) : f.lintegral Î¼ = g.lintegral Î¼
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] [proper_space F] (fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F) (r : â„) : is_compact (coe_fn '' metric.closed_ball fâ‚€ r)
{I : Type wâ‚€} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {D : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (D i)] (F : Î  (i : I), C i â¥¤ D i) : (Î  (i : I), C i) â¥¤ Î  (i : I), D i
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] â¦ƒU : set Î±â¦„ (hU : is_open U) (Î¼ : measure_theory.measure Î±) [Î¼.regular] : â‡‘Î¼ U = â¨† (K : set Î±) (h : K âŠ† U) (h2 : is_compact K), â‡‘Î¼ K
(R : Type u) [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] {N : Type uâ‚} [add_comm_monoid N] [module R N] (Ïˆ : direct_sum Î¹ (Î» (i : Î¹), M i) â†’â‚—[R] N) (f : direct_sum Î¹ (Î» (i : Î¹), M i)) : â‡‘Ïˆ f = â‡‘(direct_sum.to_module R Î¹ N (Î» (i : Î¹), Ïˆ.comp (direct_sum.lof R Î¹ M i))) f
{Î± : Type u_1} {s : set (setoid Î±)} : (has_Inf.Inf s).rel = has_Inf.Inf (setoid.rel '' s)
{f : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ€ (r : â„), B' x < r â†’ (âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), slope f x z < r)) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
{k : Type uâ‚} {G : Type uâ‚‚} [semiring k] (f : add_monoid_algebra k G) : f âˆˆ submodule.span k (add_monoid_algebra.of' k G '' â†‘(f.support))
{Î¹ : Type u} {Î± : Î¹ â†’ Type u_2} {Î´ : Î  (i : Î¹), Î± i â†’ Type v} [Î  (i : Î¹) (j : Î± i), has_zero (Î´ i j)] : (Î â‚€ (i : Î£ (i : Î¹), Î± i), Î´ i.fst i.snd) â‰ƒ Î â‚€ (i : Î¹) (j : Î± i), Î´ i j
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] {F : Type w} [normed_group F] [normed_space ğ•œ F] [complete_space ğ•œ] {Î¹ : Type u_1} [fintype Î¹] (v : basis Î¹ ğ•œ E) : âˆƒ (C : â„) (H : C > 0), âˆ€ {u : E â†’L[ğ•œ] F} {M : â„}, 0 â‰¤ M â†’ (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥ â‰¤ M) â†’ âˆ¥uâˆ¥ â‰¤ C * M
{M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] â¦ƒf g : M â†’+ Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (S : Î¼.finite_spanning_sets_in {s : set Î± | measurable_set s}) : Î¼.finite_spanning_sets_in {s : set Î± | measurable_set s}
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} : â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© t) âˆ© set.range â‡‘I = â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' t
{R : Type u_5} [comm_ring R] [is_domain R] {Î¶ : R} {k : â„•} (h : is_primitive_root Î¶ k) : (primitive_roots k R).card = k.totient
{R : Type u} {S : Type v} [ring R] [ring S] (f : R â†’+* S) (s : set R) : subring.map f (subring.closure s) = subring.closure (â‡‘f '' s)
{Î¹ : Type u_4} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), non_unital_normed_ring (Ï€ i)] : non_unital_normed_ring (Î  (i : Î¹), Ï€ i)
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] {K : Type (max v u)} [category_theory.small_category K] (F : K â¥¤ category_theory.Sheaf J D) (E : category_theory.limits.cone (F â‹™ category_theory.Sheaf_to_presheaf J D)) (X : C) (W : J.cover X) (S : category_theory.limits.multifork (W.index E.X)) : category_theory.limits.cone (F â‹™ category_theory.Sheaf_to_presheaf J D â‹™ (category_theory.evaluation Cáµ’áµ– D).obj (opposite.op X))
{P : Type u_1} [preorder P] (p : P) {Î¹ : Type u_2} [encodable Î¹] (ğ’Ÿ : Î¹ â†’ order.cofinal P) : â„• â†’ P
{elab : bool} : expr â†’ expr elab â†’ tactic unit
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.finite_measure Î±) {c : nnreal} {E : set Î±} (E_mble : measurable_set E) (fs : â„• â†’ bounded_continuous_function Î± nnreal) (fs_bdd : âˆ€ (n : â„•) (a : Î±), â‡‘(fs n) a â‰¤ c) (fs_lim : filter.tendsto (Î» (n : â„•), â‡‘(fs n)) filter.at_top (nhds (E.indicator (Î» (x : Î±), 1)))) : filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) filter.at_top (nhds (â‡‘â†‘Î¼ E))
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] {K : set Î±} {V : set (Î² Ã— Î²)} (f : C(Î±, Î²)) (hK : is_compact K) (hV : V âˆˆ uniformity Î²) : âˆƒ (Î¹ : Type uâ‚) [_inst_3 : fintype Î¹] (C : Î¹ â†’ set Î±) (hC : âˆ€ (i : Î¹), is_compact (C i)) (U : Î¹ â†’ set Î²) (hU : âˆ€ (i : Î¹), is_open (U i)), (f âˆˆ â‹‚ (i : Î¹), continuous_map.compact_open.gen (C i) (U i)) âˆ§ (â‹‚ (i : Î¹), continuous_map.compact_open.gen (C i) (U i)) âŠ† continuous_map.compact_conv_nhd K V f
{C : Type u} [category_theory.category C] {W X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} [category_theory.limits.has_pullback f g] (h : W âŸ¶ X) (k : W âŸ¶ Y) (w : h â‰« f = k â‰« g) : {l // l â‰« category_theory.limits.pullback.fst = h âˆ§ l â‰« category_theory.limits.pullback.snd = k}
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {U : M â†’ set M} [t2_space M] [sigma_compact_space M] (hs : is_closed s) (hU : âˆ€ (x : M), x âˆˆ s â†’ U x âˆˆ nhds x) : âˆƒ (Î¹ : Type uM) (f : smooth_bump_covering Î¹ I M s), f.is_subordinate U
{Ïƒ : Type u_1} {R : Type u_3} [comm_semiring R] (p : â„•) : mv_polynomial Ïƒ R â†’â‚[R] mv_polynomial Ïƒ R
{Î´ : Type u_4} {Ï€ : Î´ â†’ Type u_5} [Î  (x : Î´), measurable_space (Ï€ x)] (l : list Î´) (Î¼ : Î  (i : Î´), measure_theory.measure (Ï€ i)) : measure_theory.measure (list.tprod Ï€ l)
(Ï€ Î± : Type) : Type
{k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [monoid G] {A : Type uâ‚ƒ} [semiring A] [algebra k A] â¦ƒÏ†â‚ Ï†â‚‚ : monoid_algebra k G â†’â‚[k] Aâ¦„ (h : â†‘Ï†â‚.comp (monoid_algebra.of k G) = â†‘Ï†â‚‚.comp (monoid_algebra.of k G)) : Ï†â‚ = Ï†â‚‚
{K : Type u_1} {Ïƒ : Type u_2} [fintype K] [field K] [fintype Ïƒ] [decidable_eq K] [decidable_eq Ïƒ] (p : â„•) [char_p K p] {f : mv_polynomial Ïƒ K} (h : f.total_degree < fintype.card Ïƒ) : p âˆ£ fintype.card {x // â‡‘(mv_polynomial.eval x) f = 0}
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {C : set (set Î±)} (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) (h : Î¼.finite_spanning_sets_in C) (h_eq : âˆ€ (s : set Î±), s âˆˆ C â†’ â‡‘Î¼ s = â‡‘Î½ s) : Î¼ = Î½
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î²] [topological_space Î³] [topological_space Î´] (g : Î² â†’ Î³ â†’ Î´) (hg : continuous (function.uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) : Î± â†’â‚˜[Î¼] Î´
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : âˆ I.right âŸ¶ category_theory.limits.multicoequalizer I
{Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) {f : Î± â†’ ennreal} (hf : measurable f) {s : set Î±} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : â‡‘Î¼ s = â‡‘Î¼ (s âˆ© f â»Â¹' {0}) + â‡‘Î¼ (s âˆ© f â»Â¹' {âŠ¤}) + âˆ‘' (n : â„¤), â‡‘Î¼ (s âˆ© f â»Â¹' set.Ico (â†‘t ^ n) (â†‘t ^ (n + 1)))
(e : expr) (md : tactic.transparency := tactic.transparency.instances) : tactic expr
{V : Type u_1} {W : Type u_2} {Vâ‚ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group Vâ‚] {f g : normed_group_hom V W} : {Ï† // f.comp Ï† = g.comp Ï†} â‰ƒ normed_group_hom Vâ‚ â†¥(f.equalizer g)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : category_theory.limits.multicofork I â‰Œ category_theory.limits.cofork I.fst_sigma_map I.snd_sigma_map
{Î¹ : Type u_1} (I : box_integral.box Î¹) : Type u_1
{J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) (W : C) : ulift (t.X âŸ¶ W) â‰… F âŸ¶ (category_theory.functor.const J).obj W
{R : Type u} {M : Type v} [monoid R] [mul_action R M] {p : sub_mul_action R M} (m : â†¥p) : coe '' mul_action.orbit R m = mul_action.orbit R â†‘m
{K : Type u_1} [field K] {V : Type u_2} [add_comm_group V] [module K V] [finite_dimensional K V] {W : Type u_3} [add_comm_group W] [module K W] [finite_dimensional K W] {A : Type u_4} [ring A] [algebra K A] [module A V] [is_scalar_tower K A V] [module A W] [is_scalar_tower K A W] : finite_dimensional K (V â†’â‚—[A] W)
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {t : set Î±} (Hf : monotone_on f t) {a : Î±} (Ha : is_least t a) : is_least (f '' t) (f a)
{Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {Î¼ : measure_theory.measure Î±} (P : (Î± â†’ E) â†’ Prop) (h_ind : âˆ€ (c : E) â¦ƒs : set Î±â¦„, measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ P (s.indicator (Î» (_x : Î±), c))) (h_add : âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, disjoint (function.support f) (function.support g) â†’ measure_theory.integrable f Î¼ â†’ measure_theory.integrable g Î¼ â†’ P f â†’ P g â†’ P (f + g)) (h_closed : is_closed {f : â†¥(measure_theory.Lp E 1 Î¼) | P â‡‘f}) (h_ae : âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =áµ[Î¼] g â†’ measure_theory.integrable f Î¼ â†’ P f â†’ P g) â¦ƒf : Î± â†’ Eâ¦„ (hf : measure_theory.integrable f Î¼) : P f
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [metric_space Î²] {Î¼ : measure_theory.measure Î±} {s : set Î±} {Îµ : â„} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [semilattice_sup Î¹] [nonempty Î¹] [encodable Î¹] (hÎµ : 0 < Îµ) (hf : âˆ€ (n : Î¹), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hsm : measurable_set s) (hs : â‡‘Î¼ s â‰  âŠ¤) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ s â†’ filter.tendsto (Î» (n : Î¹), f n x) filter.at_top (nhds (g x))) (n : â„•) : Î¹
{Î± : Type u_1} {E : Type u_2} {m mâ‚‚ m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space E] [has_zero E] (hm : m â‰¤ m0) {s : set Î±} {f : Î± â†’ E} (hs_m : measurable_set s) (hs : âˆ€ (t : set Î±), measurable_set (s âˆ© t) â†’ measurable_set (s âˆ© t)) (hf : measure_theory.ae_strongly_measurable' m f Î¼) (hf_zero : f =áµ[Î¼.restrict sá¶œ] 0) : measure_theory.ae_strongly_measurable' mâ‚‚ f Î¼
(n : â„• := 1) : tactic unit
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : Î± â†’ ennreal) (h : âˆ€ (p q : nnreal), p < q â†’ (âˆƒ (u v : set Î±), measurable_set u âˆ§ measurable_set v âˆ§ {x : Î± | f x < â†‘p} âŠ† u âˆ§ {x : Î± | â†‘q < f x} âŠ† v âˆ§ â‡‘Î¼ (u âˆ© v) = 0)) : ae_measurable f Î¼
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {x : M} {s : set M} [Is : smooth_manifold_with_corners I M] [I's : smooth_manifold_with_corners I' M'] {f' fâ‚' : tangent_space I x â†’L[ğ•œ] tangent_space I' (f x)} (U : unique_mdiff_within_at I s x) (h : has_mfderiv_within_at I I' f s x f') (hâ‚ : has_mfderiv_within_at I I' f s x fâ‚') : f' = fâ‚'
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] (p : mv_polynomial Ïƒ R) : â„•
{C : Type u} [category_theory.category C] {X Y : C} {J : category_theory.grothendieck_topology C} {f : Y âŸ¶ X} {S : J.cover X} (I : (S.pullback f).relation) : S.relation
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i * g i)
{M : Type u_1} [monoid M] {Î³ : Type u_2} [monoid Î³] {f : M â†’ Î³} (hf : is_monoid_hom f) {s : set M} (hs : is_submonoid s) : is_submonoid (f '' s)
{K : Type u_1} [field K] {V : Type u_2} [add_comm_group V] [module K V] [finite_dimensional K V] {W : Type u_3} [add_comm_group W] [module K W] [finite_dimensional K W] : finite_dimensional.finrank K (V â†’â‚—[K] W) = finite_dimensional.finrank K V * finite_dimensional.finrank K W
(R : Type u) [semiring R] {Î¹ : Type v} {Î± : Î¹ â†’ Type u_1} {Î´ : Î  (i : Î¹), Î± i â†’ Type w} [Î  (i : Î¹) (j : Î± i), add_comm_monoid (Î´ i j)] [Î  (i : Î¹) (j : Î± i), module R (Î´ i j)] : direct_sum (Î£ (i : Î¹), Î± i) (Î» (i : Î£ (i : Î¹), Î± i), Î´ i.fst i.snd) â†’â‚—[R] direct_sum Î¹ (Î» (i : Î¹), direct_sum (Î± i) (Î» (j : Î± i), Î´ i j))
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} {Ïƒ : Type u_3} [inhabited Î›] (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) (S : finset Î›) : Prop
{R : Type u_1} [comm_monoid_with_zero R] (f : nat.arithmetic_function R) (hf : f.is_multiplicative) {n : â„•} : n â‰  0 â†’ â‡‘f n = n.factorization.prod (Î» (p k : â„•), â‡‘f (p ^ k))
{Î± : Type u} [pseudo_metric_space Î±] {Î² : Type u_1} {p : Î² â†’ Prop} {f : Î² â†’ â„} (hfâ‚€ : âˆ€ (x : Î²), p x â†’ 0 < f x) (hf : âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (x : Î²) (hx : p x), f x â‰¤ Îµ)) : (uniformity Î±).has_basis p (Î» (x : Î²), {p : Î± Ã— Î± | has_dist.dist p.fst p.snd â‰¤ f x})
(var : string) (Î² : Prop â†’ Prop) [I : Î  (b : bool), slim_check.testable (Î² â†¥b)] : slim_check.testable (slim_check.named_binder var (âˆ€ (p : Prop), Î² p))
{Î± : Type u_1} {E' : Type u_6} {E'' : Type u_9} [semi_normed_group E'] [normed_group E''] {f' : Î± â†’ E'} {l : filter Î±} {c : E''} (hc : c â‰  0) : (Î» (x : Î±), c) =O[l] f' â†” âˆƒ (b : â„), 0 < b âˆ§ âˆ€á¶  (x : Î±) in l, b â‰¤ âˆ¥f' xâˆ¥
{Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [conditionally_complete_linear_order Î±] [order_topology Î±] [borel_space Î±] [no_max_order Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ico a b) = â‡‘Î½ (set.Ico a b)) : Î¼ = Î½
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [complete_space F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] [complete_space G] (Ï† : implicit_function_data ğ•œ E F G) (x : E) : F Ã— G
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) [fintype Î¹] (x : Î¹ â†’ â„) : (finset.filter (Î» (J : box_integral.box Î¹), x âˆˆ â‡‘box_integral.box.Icc J) Ï€.boxes).card â‰¤ 2 ^ fintype.card Î¹
{E : Type u_1} [normed_group E] [measurable_space E] [normed_space â„ E] [finite_dimensional â„ E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)) (t : set E) (ht : measurable_set t) (h't : â‡‘Î¼ t â‰  0) : âˆ€á¶  (r : â„) in nhds_within 0 (set.Ioi 0), (s âˆ© ({x} + r â€¢ t)).nonempty
{ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f : ğ•œ â†’ G} {s : set ğ•œ} {x y : ğ•œ} {C : â„} (hf : âˆ€ (x : ğ•œ), x âˆˆ s â†’ differentiable_at ğ•œ f x) (bound : âˆ€ (x : ğ•œ), x âˆˆ s â†’ âˆ¥deriv f xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_4} [topological_space H] {I : model_with_corners ğ•œ E H} {H' : Type u_5} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {N : Type u_6} [topological_space N] [charted_space H N] {R : Type u_7} [comm_ring R] [topological_space R] [charted_space H' R] [smooth_ring I' R] (n : N) : cont_mdiff_map I I' N R âŠ¤ â†’+* R
{Î“ : Type u_1} [inhabited Î“] {Î“' : Type u_2} [inhabited Î“'] {Î› : Type u_3} [inhabited Î›] {Î›' : Type u_4} [inhabited Î›'] (f : turing.pointed_map Î“ Î“') (g : Î› â†’ Î›') : turing.TM0.cfg Î“ Î› â†’ turing.TM0.cfg Î“' Î›'
{X : Type u_1} [topological_space X] [sigma_compact_space X] [measurable_space X] (Î¼ : measure_theory.measure X) : Î¼.inner_regular is_compact is_closed
{Î± : Type u} {Î² : Type v} (R : Type u_1) [monoid R] (e : Î± â‰ƒ Î²) [add_comm_monoid Î²] : let _inst : add_comm_monoid Î± := e.add_comm_monoid in Î  [_inst_3 : distrib_mul_action R Î²], distrib_mul_action R Î±
{C : Type u} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {X Y : C} {f g : X âŸ¶ Y} {Z : C} {Ï€ : Y âŸ¶ Z} (q : category_theory.is_split_coequalizer f g Ï€) (F : C â¥¤ D) : category_theory.is_split_coequalizer (F.map f) (F.map g) (F.map Ï€)
{C : Type u} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) {Z : C} (g : Y âŸ¶ Z) {W : C} (h : Z âŸ¶ W) [category_theory.limits.has_image (g â‰« h)] [category_theory.limits.has_image (f â‰« g â‰« h)] [category_theory.limits.has_image h] [category_theory.limits.has_image ((f â‰« g) â‰« h)] : category_theory.limits.image.pre_comp f (g â‰« h) â‰« category_theory.limits.image.pre_comp g h = category_theory.limits.image.eq_to_hom _ â‰« category_theory.limits.image.pre_comp (f â‰« g) h
{Î± : Type u_1} {Ïƒ : Î± â†’ Type u_2} (lâ‚ : list Î±) (lâ‚‚ : Î  (a : Î±), list (Ïƒ a)) : list (Î£ (a : Î±), Ïƒ a)
{Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] {ğ’œ : Î¹ â†’ submodule R A} [decidable_eq Î¹] [add_monoid Î¹] [graded_algebra ğ’œ] (I : homogeneous_ideal ğ’œ) : ideal A
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] (f g : â†¥(measure_theory.Lp Î² 1 Î¼)) : âˆ¥f - gâˆ¥ = (âˆ«â» (x : Î±), â†‘âˆ¥â‡‘f x - â‡‘g xâˆ¥â‚Š âˆ‚Î¼).to_real
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} (f : Î± â†’ Î²) (h : ae_measurable f Î¼) : Î± â†’ Î²
{R : Type u} [comm_ring R] (I J : ideal R) : R â†’+* (R â§¸ I) â§¸ ideal.map (ideal.quotient.mk I) J
{E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] {n : â„•} (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) â†’ â„) â†’ fin (n + 1) â†’ E) (f' : (fin (n + 1) â†’ â„) â†’ ((fin (n + 1) â†’ â„) â†’L[â„] fin (n + 1) â†’ E)) (s : set (fin (n + 1) â†’ â„)) (hs : s.countable) (Hc : continuous_on f (â‡‘box_integral.box.Icc I)) (Hd : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ â‡‘box_integral.box.Ioo I  s â†’ has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (Î» (x : fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i)) (â‡‘box_integral.box.Icc I) measure_theory.measure_space.volume) : âˆ« (x : fin (n + 1) â†’ â„) in â‡‘box_integral.box.Icc I, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (f : smooth_partition_of_unity Î¹ I M s) (U : Î¹ â†’ set M) : Prop
{g : matrix.special_linear_group (fin 2) â„¤} {z : upper_half_plane} (hz : z âˆˆ modular_group.fdo) (hg : g â€¢ z âˆˆ modular_group.fdo) : |â†‘g 1 0| â‰¤ 1
(R : Type u) [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] {N : Type uâ‚} [add_comm_monoid N] [module R N] {Ï† : Î  (i : Î¹), M i â†’â‚—[R] N} (i : Î¹) (x : M i) : â‡‘(direct_sum.to_module R Î¹ N Ï†) (â‡‘(direct_sum.lof R Î¹ M i) x) = â‡‘(Ï† i) x
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I : ideal R} {N N' : submodule R M} (hN' : N'.fg) (hIJ : I â‰¤ âŠ¥.jacobson) (hNN : N âŠ” N' â‰¤ N âŠ” I â€¢ N') : I â€¢ N' â‰¤ N
{E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] (f : E â†’+ F) (C : â„) (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : continuous â‡‘f
{I : Type u} (f : I â†’ Type v) [decidable_eq I] [Î  (i : I), mul_one_class (f i)] (i : I) : f i â†’* Î  (i : I), f i
{X : Type u_1} [emetric_space X] {Î¹ : Type u_2} {I : finset Î¹} {s : set X} {t : Î¹ â†’ set X} : (âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated s (t i)) â†’ is_metric_separated s (â‹ƒ (i : Î¹) (H : i âˆˆ I), t i)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [category_theory.limits.has_wide_coequalizer f] [nonempty J] {W : C} (k : Y âŸ¶ W) (h : âˆ€ (jâ‚ jâ‚‚ : J), f jâ‚ â‰« k = f jâ‚‚ â‰« k) : {l // category_theory.limits.wide_coequalizer.Ï€ f â‰« l = k}
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' â†’ M''} (x : M) (hg : cont_mdiff_within_at I' I'' n g t (f x)) (hf : cont_mdiff_within_at I I' n f s x) : cont_mdiff_within_at I I'' n (g âˆ˜ f) (s âˆ© f â»Â¹' t) x
{Î± : Type u_1} {t : set Î±} {m0 : measurable_space Î±} {m : set (measure_theory.measure Î±)} (hm : m.nonempty) (ht : measurable_set t) : (has_Inf.Inf m).restrict t = has_Inf.Inf ((Î» (Î¼ : measure_theory.measure Î±), Î¼.restrict t) '' m)
{R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] {H K : lie_subalgebra R L} (hâ‚ : H â‰¤ K) (hâ‚‚ : K â‰¤ H.normalizer) : âˆƒ (I : lie_ideal R â†¥K), â†‘I = lie_subalgebra.of_le hâ‚
{Î± : Type u_1} [semi_normed_group Î±] {r C : â„} {f : â„• â†’ Î±} (hr : r < 1) (hf : âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ C * r ^ n) {a : Î±} (ha : has_sum f a) (n : â„•) : âˆ¥(finset.range n).sum (Î» (x : â„•), f x) - aâˆ¥ â‰¤ C * r ^ n / (1 - r)
{Î± : Type u} {Ï€ : Î± â†’ Type v} (s : set Î±) (f : Î  (a : Î±), Ï€ a) (a : â†¥s) : Ï€ â†‘a
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = s.sum (Î» (i : Î¹), f i * g i) â†” antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
{L : first_order.language} {Î¹ : Type u_3} [encodable Î¹] [preorder Î¹] [is_directed Î¹ has_le.le] [nonempty Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) (h : âˆ€ (i : Î¹), first_order.language.Structure.cg L (G i)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] : first_order.language.Structure.cg L (first_order.language.direct_limit G f)
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” antivary f (g âˆ˜ â‡‘Ïƒ)
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {s : set Î±} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : â‡‘Ï s â‰¤ â†‘t * â‡‘(Î¼.with_density (v.lim_ratio_meas hÏ)) s
{R : Type u_1} [semiring R] {Ï† Ïˆ : power_series R} (h : âˆ€ (n : â„•), â‡‘(power_series.coeff R n) Ï† = â‡‘(power_series.coeff R n) Ïˆ) : Ï† = Ïˆ
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} {f : G â†’ E} {g : G} [add_group G] [has_measurable_add G] [Î¼.is_add_left_invariant] (hf' : âˆ€ (x : G), f (g + x) = -f x) : âˆ« (x : G), f x âˆ‚Î¼ = 0
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : filter Î±) : Prop
{Î± : Type u} {Ïƒ : Type v} (M : Îµ_NFA Î± Ïƒ) (S : set Ïƒ) (a : Î±) : set Ïƒ
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±] [topological_space.pseudo_metrizable_space Î±] [opens_measurable_space Î±] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] {f : Î± â†’ Î²} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : continuous_on f s) (hs : measurable_set s) (h's : topological_space.is_separable s) : measure_theory.ae_strongly_measurable f (Î¼.restrict s)
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} [normed_group E] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„ (hf : measure_theory.strongly_measurable (function.uncurry f)) : measure_theory.strongly_measurable (Î» (y : Î²), âˆ« (x : Î±), f x y âˆ‚Î¼)
{L : first_order.language} {M : Type w} [L.Structure M] â¦ƒs t : set Mâ¦„ (h : s âŠ† t) : â‡‘(first_order.language.substructure.closure L) s â‰¤ â‡‘(first_order.language.substructure.closure L) t
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type wâ‚} [category_theory.category D] {E : Type wâ‚‚} [category_theory.category E] [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– E] (P : Cáµ’áµ– â¥¤ D) [Î  (F : D â¥¤ E) (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– F] [Î  (F : D â¥¤ E) (X : C) (W : J.cover X) (P : Cáµ’áµ– â¥¤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] : (category_theory.whiskering_left Cáµ’áµ– D E).obj (J.sheafify P) â‰… (category_theory.whiskering_left Cáµ’áµ– D E).obj P â‹™ J.sheafification E
{Î± : Type u} {Ïƒ : Type v} (M : DFA Î± Ïƒ) (start : Ïƒ) : list Î± â†’ Ïƒ
{k : Type u_1} [field k] {Ïƒ : Type u_2} (I : ideal (mv_polynomial Ïƒ k)) : set (Ïƒ â†’ k)
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (expr Ã— list expr)
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : add_subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_add_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [Î“.normal] [Î¼.is_add_left_invariant] [Î¼.is_add_right_invariant] : (measure_theory.measure.map â‡‘(quotient_add_group.mk' Î“) (Î¼.restrict ğ“•)).is_add_left_invariant
{Î± : Sort u_1} {Ïƒ : Î± â†’ Sort u_4} (P : Prop) [decidable P] (f g : Î  (a : Î±), Ïƒ a) (a : Î±) : ite P f g a = ite P (f a) (g a)
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I J : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] (h : box_integral.integrable I l f vol) (hJ : J â‰¤ I) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I (box_integral.prepartition.single I J hJ)) (nhds (box_integral.integral J l f vol))
{Î± : Type u_1} {E : Type u_4} {ğ•œ : Type u_6} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_field ğ•œ] [normed_space ğ•œ E] : has_scalar ğ•œ â†¥(measure_theory.Lp.simple_func E p Î¼)
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) < finset.univ.sum (Î» (i : Î¹), f i * g i) â†” Â¬monovary f (g âˆ˜ â‡‘Ïƒ)
{Î± : Type u_1} [generalized_boolean_algebra Î±] {f : â„• â†’ Î±} {p : Î± â†’ Sort u_2} (hdiff : Î  â¦ƒt : Î±â¦„ â¦ƒi : â„•â¦„, p t â†’ p (t  f i)) â¦ƒn : â„•â¦„ : p (f n) â†’ p (disjointed f n)
{Î± : Type u} {C : free_add_magma Î± â†’ Sort l} (x : free_add_magma Î±) (ih1 : Î  (x : Î±), C (has_pure.pure x)) (ih2 : Î  (x y : free_add_magma Î±), C x â†’ C y â†’ C (x + y)) : C x
{G : Type u_1} [measurable_space G] [has_inv G] (Î¼ : measure_theory.measure G) : measure_theory.measure G
(e : expr) (show_expr : bool := bool.tt) : tactic (list (widget.html empty))
{Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : â„• â†’ Î© â†’ â„) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hident : âˆ€ (i : â„•), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) (hnonneg : âˆ€ (i : â„•) (Ï‰ : Î©), 0 â‰¤ X i Ï‰) : âˆ€áµ (Ï‰ : Î©), (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), probability_theory.truncation (X i) â†‘i Ï‰) - (finset.range n).sum (Î» (i : â„•), X i Ï‰)) =o[filter.at_top] Î» (n : â„•), â†‘n
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) {r : ennreal} (hr : r < â‡‘Î¼ A) : âˆƒ (K : set Î±) (H : K âŠ† A), is_closed K âˆ§ r < â‡‘Î¼ K
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] {Î¹ : Type u_5} [normed_group E] [topological_space Î±] [opens_measurable_space Î±] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Î¼] {a : Î±} {f : Î± â†’ E} (ha : continuous_at f a) (hfm : strongly_measurable_at_filter f (nhds a) Î¼) {s : Î¹ â†’ set Î±} {li : filter Î¹} (hs : filter.tendsto s li (nhds a).small_sets) (m : Î¹ â†’ â„ := Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) (hsÎ¼ : (Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) =á¶ [li] m . "refl") : (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
{C : Type uâ‚} [category_theory.category C] (X Y : C) (p : Î  {Z : C}, (Z âŸ¶ X) â†’ (Z âŸ¶ Y)) (q : Î  {Z : C}, (Z âŸ¶ Y) â†’ (Z âŸ¶ X)) (hâ‚ : âˆ€ {Z : C} (f : Z âŸ¶ X), q (p f) = f) (hâ‚‚ : âˆ€ {Z : C} (f : Z âŸ¶ Y), p (q f) = f) (n : âˆ€ {Z Z' : C} (f : Z' âŸ¶ Z) (g : Z âŸ¶ X), p (f â‰« g) = f â‰« p g) : X â‰… Y
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) (hf : âˆ€ (n : â„•), measure_theory.mem_â„’p (f n) p Î¼) (hg : measure_theory.mem_â„’p g p Î¼) : measure_theory.tendsto_in_measure Î¼ f filter.at_top g âˆ§ measure_theory.unif_integrable f p Î¼ â†” filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î²' : Type u_4} {Î´ : Type u_7} {Îµ : Type u_9} [decidable_eq Î±'] [decidable_eq Î²'] [decidable_eq Î´] [decidable_eq Îµ] {s : finset Î±} {t : finset Î²} {Î³ : Type u_5} {u : finset Î³} {f : Î´ â†’ Î³ â†’ Îµ} {g : Î± â†’ Î² â†’ Î´} {fâ‚ : Î± â†’ Î³ â†’ Î±'} {fâ‚‚ : Î² â†’ Î³ â†’ Î²'} {g' : Î±' â†’ Î²' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), f (g a b) c = g' (fâ‚ a c) (fâ‚‚ b c)) : finset.imageâ‚‚ f (finset.imageâ‚‚ g s t) u âŠ† finset.imageâ‚‚ g' (finset.imageâ‚‚ fâ‚ s u) (finset.imageâ‚‚ fâ‚‚ t u)
{R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] {e : Î¹ â†’ M} {Îµ : Î¹ â†’ module.dual R M} [decidable_eq Î¹] (h : dual_pair e Îµ) (m : M) : dual_pair.lc e (h.coeffs m) = m
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z} (s : category_theory.comm_sq f g h i) : category_theory.comm_sq (F.map f) (F.map g) (F.map h) (F.map i)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {p : Î¹ â†’ P} (ha : affine_independent k p) (i : Î¹) (s : set Î¹) : p i âˆ‰ affine_span k (p '' (s  {i}))
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ ennrealâ¦„ (hf : ae_measurable (function.uncurry f) (Î¼.prod Î½)) : âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (z : Î² Ã— Î±), f z.snd z.fst âˆ‚Î½.prod Î¼
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {pâ‚ : P} (hpâ‚ : pâ‚ âˆˆ s) : affine_independent k (Î» (p : â†¥s), â†‘p) â†” linear_independent k (Î» (v : â†¥((Î» (p : P), p -áµ¥ pâ‚) '' (s  {pâ‚}))), â†‘v)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] [topological_space Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : continuous g) (hf : measure_theory.ae_strongly_measurable f Î¼) : measure_theory.ae_strongly_measurable (Î» (x : Î±), g (f x)) Î¼
{Î¹ : Type u_1} {I J Js : box_integral.box Î¹} {s : finset (Î¹ Ã— â„)} (H : âˆ€ (i : Î¹), {(i, J.lower i), (i, J.upper i)} âŠ† s) (HJs : Js âˆˆ box_integral.prepartition.split_many I s) (Hn : Â¬disjoint â†‘J â†‘Js) : Js â‰¤ J
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {F F' : ğ•œ â†’ Î± â†’ E} {xâ‚€ : ğ•œ} {Îµ : â„} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : ğ•œ) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) Î¼) (hF_int : measure_theory.integrable (F xâ‚€) Î¼) (hF'_meas : measure_theory.ae_strongly_measurable (F' xâ‚€) Î¼) {bound : Î± â†’ â„} (h_bound : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : ğ•œ), x âˆˆ metric.ball xâ‚€ Îµ â†’ âˆ¥F' x aâˆ¥ â‰¤ bound a) (bound_integrable : measure_theory.integrable bound Î¼) (h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : ğ•œ), x âˆˆ metric.ball xâ‚€ Îµ â†’ has_deriv_at (Î» (x : ğ•œ), F x a) (F' x a) x) : measure_theory.integrable (F' xâ‚€) Î¼ âˆ§ has_deriv_at (Î» (n : ğ•œ), âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€
{Î· : Type u_5} {f : Î· â†’ Type u_6} [Î  (i : Î·), add_group (f i)] (I : set Î·) (H : Î  (i : Î·), add_subgroup (f i)) : add_subgroup (Î  (i : Î·), f i)
(R : Type u_1) [comm_ring R] (I : ideal R) : Prop
{M : Type u_1} [add_zero_class M] â¦ƒs t : set Mâ¦„ (h : s âŠ† t) : add_submonoid.closure s â‰¤ add_submonoid.closure t
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] (c : category_theory.limits.fork I.fst_pi_map I.snd_pi_map) : category_theory.limits.multifork I
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : E â†’ F) (K : set (E â†’L[ğ•œ] F)) (r s Îµ : â„) : set E
{Î± : Type u_1} {E : Type u_3} [semi_normed_group E] {l : filter Î±} {f : Î± â†’ E} (h : filter.tendsto (Î» (y : Î±), âˆ¥f yâˆ¥) l filter.at_top) (x : E) : âˆ€á¶  (y : Î±) in l, f y â‰  x
(tac : tactic unit := tactic.skip) : tactic unit
{elab : bool := bool.tt} : expr elab â†’ option (name Ã— binder_info Ã— expr elab Ã— expr elab)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [compact_space Î±] [pseudo_metric_space Î²] (s : set Î²) (hs : is_compact s) (A : set (bounded_continuous_function Î± Î²)) (closed : is_closed A) (in_s : âˆ€ (f : bounded_continuous_function Î± Î²) (x : Î±), f âˆˆ A â†’ â‡‘f x âˆˆ s) (H : âˆ€ (x : Î±) (Îµ : â„), Îµ > 0 â†’ (âˆƒ (U : set Î±) (H : U âˆˆ nhds x), âˆ€ (y : Î±), y âˆˆ U â†’ âˆ€ (z : Î±), z âˆˆ U â†’ âˆ€ (f : bounded_continuous_function Î± Î²), f âˆˆ A â†’ has_dist.dist (â‡‘f y) (â‡‘f z) < Îµ)) : is_compact A
{R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] â¦ƒj k : S â†’* Pâ¦„ (h : j.comp â†‘(algebra_map R S) = k.comp â†‘(algebra_map R S)) : j = k
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [add_group G] [topological_add_group G] [Î¼.is_add_left_invariant] (K : set G) (hK : is_compact K) (h : â‡‘Î¼ K â‰  0) : Î¼.is_open_pos_measure
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Ïƒ : Type u_4} [inhabited Ïƒ] {k : K} (v : Ïƒ) (l : list (Î“ k)) : turing.TM2to1.st_act k â†’ list (Î“ k)
{Î± : Type u} [preorder Î±] â¦ƒs t : set Î±â¦„ (h : s âŠ† t) : bdd_above t â†’ bdd_above s
{ğ•œ : Type u_1} {G : Type u_2} {F : Type u_6} [normed_group F] {x : G} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ F] [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [has_sub G] {f : G â†’ ğ•œ} {g : G â†’ F} : convolution f g (continuous_linear_map.lsmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f t â€¢ g (x - t) âˆ‚Î¼
{C : Type u} [category_theory.category C] {W X Y Z S T : C} (fâ‚ : W âŸ¶ S) (fâ‚‚ : X âŸ¶ S) [category_theory.limits.has_pullback fâ‚ fâ‚‚] (gâ‚ : Y âŸ¶ T) (gâ‚‚ : Z âŸ¶ T) [category_theory.limits.has_pullback gâ‚ gâ‚‚] (iâ‚ : W âŸ¶ Y) (iâ‚‚ : X âŸ¶ Z) (iâ‚ƒ : S âŸ¶ T) (eqâ‚ : fâ‚ â‰« iâ‚ƒ = iâ‚ â‰« gâ‚) (eqâ‚‚ : fâ‚‚ â‰« iâ‚ƒ = iâ‚‚ â‰« gâ‚‚) : category_theory.limits.pullback fâ‚ fâ‚‚ âŸ¶ category_theory.limits.pullback gâ‚ gâ‚‚
{F : Type u â†’ Type u} [functor F] [q : qpf F] {G : Type u â†’ Type u} [functor G] {FG_abs : Î  {Î± : Type u}, F Î± â†’ G Î±} {FG_repr : Î  {Î± : Type u}, G Î± â†’ F Î±} (FG_abs_repr : âˆ€ {Î± : Type u} (x : G Î±), FG_abs (FG_repr x) = x) (FG_abs_map : âˆ€ {Î± Î² : Type u} (f : Î± â†’ Î²) (x : F Î±), FG_abs (fî€€functor.mapî€ <$> î€‚x) = fî€€functor.mapî€ <$> î€‚FG_abs x) : qpf G
{Î¹ : Type v} {Î± : Î¹ â†’ Type u} {Î´ : Î  (i : Î¹), Î± i â†’ Type w} [Î  (i : Î¹) (j : Î± i), add_comm_monoid (Î´ i j)] : direct_sum (Î£ (i : Î¹), Î± i) (Î» (i : Î£ (i : Î¹), Î± i), Î´ i.fst i.snd) â‰ƒ+ direct_sum Î¹ (Î» (i : Î¹), direct_sum (Î± i) (Î» (j : Î± i), Î´ i j))
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] [fintype Î“] : turing.TM1.stmt Î“ Î› Ïƒ â†’ finset turing.TM1to1.Î›'
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (fs : smooth_bump_covering Î¹ I M s) [compact_space M] : fintype Î¹
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} {I : category_theory.InjectiveResolution Y} {J : category_theory.InjectiveResolution Z} (f : I.cocomplex âŸ¶ J.cocomplex) (comm : I.Î¹ â‰« f = 0) : I.cocomplex.X 2 âŸ¶ J.cocomplex.X 1
{Î± : Type u} {Î² : Type v} {Ï† : ultrafilter Î±} [ordered_ring Î²] : ordered_ring (â†‘Ï†.germ Î²)
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] {a : set (Î± Ã— Î±)} (ha : a âˆˆ uniformity Î±) {b : set (Î² Ã— Î²)} (hb : b âˆˆ uniformity Î²) : (Î» (p : Î± Ã— Î±), (sum.inl p.fst, sum.inl p.snd)) '' a âˆª (Î» (p : Î² Ã— Î²), (sum.inr p.fst, sum.inr p.snd)) '' b âˆˆ uniform_space.core.sum.uniformity
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} {W : C} (inl : Y âŸ¶ W) (inr : Z âŸ¶ W) (eq : f â‰« inl = g â‰« inr) : category_theory.limits.pushout_cocone f g
{V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi
{M : Type u_1} [monoid M] {A : Type u_2} [monoid A] {f : M â†’ A} (hf : is_monoid_hom f) (s : set M) : f '' monoid.closure s = monoid.closure (f '' s)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] {s : set (weak_dual ğ•œ E)} (hb : metric.bounded (â‡‘normed_space.dual.to_weak_dual â»Â¹' s)) (hc : is_closed s) : is_closed (coe_fn '' s)
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [sigma_compact_space M] {s t : set M} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : âˆƒ (f : cont_mdiff_map I (model_with_corners_self â„ â„) M â„ âŠ¤), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : M), â‡‘f x âˆˆ set.Icc 0 1
(p : pexpr) (e : expr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) : Prop
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) : measure_theory.measure Î±
{X : Type u_1} [topological_space X] [compact_space X] (f : C(X, â„)) : C(X, â†¥(set.Icc (-âˆ¥fâˆ¥) âˆ¥fâˆ¥))
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} {Î² : Î¹ â†’ Type u_3} {Î³ : Î¹ â†’ Type u_4} [decidable_eq Î¹] (f : Î  â¦ƒi : Î¹â¦„, Î± i â†’ Î² i â†’ finset (Î³ i)) (a : sigma Î±) (b : sigma Î²) : finset (sigma Î³)
{P : Î  (Î± : Type u) [_inst_1 : fintype Î±], Prop} (of_equiv : âˆ€ (Î± Î² : Type u) [_inst_2 : fintype Î²] (e : Î± â‰ƒ Î²), P Î± â†’ P Î²) (h_empty : P pempty) (h_option : âˆ€ (Î± : Type u) [_inst_3 : fintype Î±], P Î± â†’ P (option Î±)) (Î± : Type u) [fintype Î±] : P Î±
{Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] (hp_ne_top : p â‰  âŠ¤) (P : (Î± â†’ E) â†’ Prop) (h_ind : âˆ€ (c : E) â¦ƒs : set Î±â¦„, measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ P (s.indicator (Î» (_x : Î±), c))) (h_add : âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, disjoint (function.support f) (function.support g) â†’ measure_theory.mem_â„’p f p Î¼ â†’ measure_theory.mem_â„’p g p Î¼ â†’ P f â†’ P g â†’ P (f + g)) (h_closed : is_closed {f : â†¥(measure_theory.Lp E p Î¼) | P â‡‘f}) (h_ae : âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =áµ[Î¼] g â†’ measure_theory.mem_â„’p f p Î¼ â†’ P f â†’ P g) â¦ƒf : Î± â†’ Eâ¦„ (hf : measure_theory.mem_â„’p f p Î¼) : P f
{R : Type u} [comm_ring R] (I J : ideal R) : (double_quot.quot_left_to_quot_sup I J).ker = ideal.map (ideal.quotient.mk I) J
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {n : with_top â„•} (hf : cont_mdiff I I' n f) (hmn : 1 â‰¤ n) : continuous (tangent_map I I' f)
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (Î¸ : real.angle) : o.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (hf : âˆ€ (n : â„•), measurable (f n)) (h_mono : âˆ€ (n : â„•), âˆ€áµ (a : Î±) âˆ‚Î¼, f n a â‰¤ f n.succ a) : âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s : set Î²} {g : Î² â†’ Î±} (hg : set.inj_on g (s âˆ© function.support (f âˆ˜ g))) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ g '' s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ s), f (g j)))
{ğ•œ : Type u_1} {_x : ring ğ•œ} {E : Type u_2} [semi_normed_group E] {_x_1 : module ğ•œ E} {s : submodule ğ•œ E} (x : â†¥s) : âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ W) : category_theory.limits.biprod.map f g â‰« (category_theory.limits.biprod.braiding Y W).hom = (category_theory.limits.biprod.braiding X Z).hom â‰« category_theory.limits.biprod.map g f
{C : Type uâ‚} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_coproducts C] {A : C} (s : set (category_theory.subobject A)) : (âˆ Î» (j : â†¥(â‡‘(equiv_shrink (category_theory.subobject A)) '' s)), â†‘(â‡‘((equiv_shrink (category_theory.subobject A)).symm) â†‘j)) âŸ¶ A
{L : first_order.language} {Î± : Type u'} (Ï† Ïˆ : L.formula Î±) : L.formula Î±
{L : first_order.language} {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] (i : Î¹) (x : G i) (h : i â‰¤ i) : â‡‘(f i i h) x = x
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [Î¼.is_add_left_invariant] [measure_theory.sigma_finite Î¼] {xâ‚€ : G} {R Îµ : â„} (hÎµ : 0 â‰¤ Îµ) (hif : measure_theory.integrable f Î¼) (hf : function.support f âŠ† metric.ball 0 R) (hmg : measure_theory.ae_strongly_measurable g Î¼) (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ R â†’ has_dist.dist (g x) (g xâ‚€) â‰¤ Îµ) : has_dist.dist (convolution f g L Î¼ xâ‚€) (âˆ« (t : G), â‡‘(â‡‘L (f t)) (g xâ‚€) âˆ‚Î¼) â‰¤ âˆ¥Lâˆ¥ * âˆ« (x : G), âˆ¥f xâˆ¥ âˆ‚Î¼ * Îµ
{Î± : Type u_1} {Î¹ : Type u_2} [measurable_space Î±] (s : Î¹ â†’ set Î±) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (f : Î± â†’ ennreal) {g : Î± â†’ ennreal} (hg : measurable g) : âˆ«â» (a : Î±), f a + g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] {s : set Î±} (h : is_compact s) (Î¼ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] : âˆƒ (U : set Î±) (H : U âŠ‡ s), is_open U âˆ§ â‡‘Î¼ U < âŠ¤
{I : Type vâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {J : Type vâ‚} [category_theory.small_category J] {F : J â¥¤ Î  (i : I), C i} (c : category_theory.limits.cocone F) (i : I) : category_theory.limits.cocone (F â‹™ category_theory.pi.eval C i)
(limit : option â„• := option.none) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := Î» (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (Î» (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic (list string)
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] {F G : V â¥¤ W} [F.additive] [G.additive] (Î± : F âŸ¶ G) (c : complex_shape Î¹) : category_theory.functor.map_homotopy_category c F âŸ¶ category_theory.functor.map_homotopy_category c G
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (h : box_integral.integrable I l f vol) (Ï€â‚€ : box_integral.prepartition I) : cauchy (filter.map (box_integral.integral_sum f vol) (l.to_filter_Union I Ï€â‚€))
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³} [topological_space Î³] [topological_space.metrizable_space Î³] [borel_space Î³] (h : probability_theory.ident_distrib f g Î¼ Î½) (hf : measure_theory.ae_strongly_measurable f Î¼) : measure_theory.ae_strongly_measurable g Î½
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {ğ’¢ : measure_theory.filtration â„• m0} [measure_theory.is_finite_measure Î¼] {f : â„• â†’ Î± â†’ â„} (hadp : measure_theory.adapted ğ’¢ f) (hint : âˆ€ (i : â„•), measure_theory.integrable (f i) Î¼) (hf : âˆ€ (Ï„ Ï€ : Î± â†’ â„•), measure_theory.is_stopping_time ğ’¢ Ï„ â†’ measure_theory.is_stopping_time ğ’¢ Ï€ â†’ Ï„ â‰¤ Ï€ â†’ (âˆƒ (N : â„•), âˆ€ (x : Î±), Ï€ x â‰¤ N) â†’ âˆ« (x : Î±), measure_theory.stopped_value f Ï„ x âˆ‚Î¼ â‰¤ âˆ« (x : Î±), measure_theory.stopped_value f Ï€ x âˆ‚Î¼) : measure_theory.submartingale f ğ’¢ Î¼
{Î¹ : Type u_1} (I : box_integral.box Î¹) : set Î¹ â†ª box_integral.box Î¹
{f : C(â†¥unit_interval, â„)} {Îµ : â„} {h : 0 < Îµ} {n : â„•} {x : â†¥unit_interval} {k : fin (n + 1)} (m : k âˆˆ (bernstein_approximation.S f Îµ h n x)á¶œ) : 1 â‰¤ bernstein_approximation.Î´ f Îµ h ^ -2 * (â†‘x - â†‘(bernstein.z k)) ^ 2
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.tagged_prepartition I) (p : box_integral.box Î¹ â†’ Prop) : box_integral.tagged_prepartition I
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {ğ•œâ‚ƒ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [nondiscrete_normed_field ğ•œâ‚ƒ] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] [normed_space ğ•œâ‚ƒ G] {Ïƒâ‚‚â‚ƒ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ} {Ïƒâ‚â‚ƒ : ğ•œ â†’+* ğ•œâ‚ƒ} [ring_hom_isometric Ïƒâ‚‚â‚ƒ] (f : E â†’â‚›â‚—[Ïƒâ‚â‚ƒ] F â†’â‚›â‚—[Ïƒâ‚‚â‚ƒ] G) (C : â„) (hC : âˆ€ (x : E) (y : F), âˆ¥â‡‘(â‡‘f x) yâˆ¥ â‰¤ C * âˆ¥xâˆ¥ * âˆ¥yâˆ¥) : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) (g' : Z âŸ¶ W) [category_theory.limits.has_pushout f g] [category_theory.limits.has_pushout category_theory.limits.pushout.inr g'] [category_theory.limits.has_pushout f (g â‰« g')] : category_theory.limits.pushout category_theory.limits.pushout.inr g' â‰… category_theory.limits.pushout f (g â‰« g')
{ğ•œ : Type u_1} {G : Type u_2} {F : Type u_6} [normed_group F] {x : G} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ F] [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.is_neg_invariant] {f : G â†’ ğ•œ} {g : G â†’ F} : convolution f g (continuous_linear_map.lsmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f (x - t) â€¢ g t âˆ‚Î¼
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g i) < s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) â†” Â¬antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) (Î¼ : ğ•œ) : module.End.eigenspace (T.restrict _) Î¼ = âŠ¥
{Î± : Type u} [topological_space Î±] [linear_ordered_add_comm_group Î±] [order_topology Î±] [no_min_order Î±] [no_max_order Î±] {a : Î±} (ha : 0 < a) : (nhds a).has_basis (Î» (Îµ : Î±), 0 < Îµ âˆ§ Îµ â‰¤ a) (Î» (Îµ : Î±), set.Ioo (a - Îµ) (a + Îµ))
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} (hs : convex â„ s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) : â¨ (x : Î±) in t, f x âˆ‚Î¼ âˆˆ closure s
{X : â„• â†’ Type u} [Î  (n : â„•), metric_space (X n)] {f : Î  (n : â„•), X n â†’ X (n + 1)} (I : âˆ€ (n : â„•), isometry (f n)) (n : â„•) : isometry (metric.to_inductive_limit I n)
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R â„¤) (I : â†¥(non_zero_divisors (ideal S))) : âˆƒ (b : S) (H : b âˆˆ â†‘I), b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â‡‘abv (â‡‘(algebra.norm R) c) < â‡‘abv (â‡‘(algebra.norm R) b) â†’ c = 0
{Î± : Type u} [lattice Î±] [comm_group Î±] [covariant_class Î± Î± has_mul.mul has_le.le] (a : Î±) : ||a|| = |a|
{p : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [hne : ne_zero â†‘â†‘p] {k s : â„•} (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) [hpri : fact (nat.prime â†‘p)] [hcycl : is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (hs : s â‰¤ k) (hk : 1 â‰¤ k) : â‡‘(algebra.norm K) (Î¶ ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
{Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {u v : set Î±} (hu : measurable_set u) (hv : measurable_set v) (hsu : 0.restrict u â‰¤ measure_theory.vector_measure.restrict s u) (hsv : 0.restrict v â‰¤ measure_theory.vector_measure.restrict s v) (hs : â‡‘s (u âˆ† v) = 0) : â‡‘s (u  v) = 0 âˆ§ â‡‘s (v  u) = 0
(Î´ K Îµ x : â„) : â„
{R : Type u_1} [euclidean_domain R] {abv : absolute_value R â„¤} (n : â„•) (h : abv.is_admissible) {Îµ : â„} (hÎµ : 0 < Îµ) {b : R} (hb : b â‰  0) (A : fin (h.card Îµ ^ n).succ â†’ fin n â†’ R) : âˆƒ (iâ‚€ iâ‚ : fin (h.card Îµ ^ n).succ), iâ‚€ â‰  iâ‚ âˆ§ âˆ€ (k : fin n), â†‘(â‡‘abv (A iâ‚ k % b - A iâ‚€ k % b)) < â‡‘abv b â€¢ Îµ
{Î± : Type u} {C : free_magma Î± â†’ Sort l} (x : free_magma Î±) (ih1 : Î  (x : Î±), C (has_pure.pure x)) (ih2 : Î  (x y : free_magma Î±), C x â†’ C y â†’ C (x * y)) : C x
(Ï‰ Ï‰' : out_param (Type u)) (m m' : Type u â†’ Type v) : Type (max (u+1) v)
 : interactive.parse (î€€list.joinî€list.joinî€‚î€€functor.mapî€ <$> î€‚lean.parser.many tactic.rintro_patt_parse_hi) â†’ tactic unit
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (f : smooth_bump_covering Î¹ I M s) (U : M â†’ set M) : Prop
{Î± : Type u} {Î² : Type v} (R : Type u_1) [comm_semiring R] (e : Î± â‰ƒ Î²) [semiring Î²] : let _inst : semiring Î± := e.semiring in Î  [_inst_3 : algebra R Î²], algebra R Î±
{Î² : Type v} [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {Î± : Type u_1} [linear_order Î±] [topological_space Î±] [order_topology Î±] {f : Î± â†’ Î²} (Mf : monotone f) (x : Î±) : filter.tendsto f (nhds_within x (set.Ioi x)) (nhds (has_Inf.Inf (f '' set.Ioi x)))
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {Râ‚ Râ‚‚ : â„} {f : â„‚ â†’ E} {c : â„‚} (hd : differentiable_on â„‚ f (metric.ball c Râ‚)) (h_maps : set.maps_to f (metric.ball c Râ‚) (metric.ball (f c) Râ‚‚)) (hâ‚€ : 0 < Râ‚) : âˆ¥deriv f câˆ¥ â‰¤ Râ‚‚ / Râ‚
(opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := Î» (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (Î» (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic string
{Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [topological_space Î²] {s : set Î±} (hs : measure_theory.analytic_set s) {f : Î± â†’ Î²} (hf : continuous_on f s) : measure_theory.analytic_set (f '' s)
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î³ : Type u_2} {F : filter Î³} {Î¼s : Î³ â†’ measure_theory.probability_measure Î±} {Î¼ : measure_theory.probability_measure Î±} : filter.tendsto Î¼s F (nhds Î¼) â†” âˆ€ (f : bounded_continuous_function Î± nnreal), filter.tendsto (Î» (i : Î³), âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚â†‘(Î¼s i)) F (nhds (âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚â†‘Î¼))
(Î¹ : Type uÎ¹) {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) (M : Type uM) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (s : set M := set.univ) : Type (max uM uÎ¹)
{Î± : Type u_1} {E : Type u_2} (ğ•œ : Type u_4) [is_R_or_C ğ•œ] [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [inner_product_space ğ•œ E] {s : set Î±} [complete_space E] [normed_space â„ E] (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (c : E) (f : â†¥(measure_theory.Lp E 2 Î¼)) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s c) f = has_inner.inner c (âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼)
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I : ideal R} (hM : module.is_torsion_by_set R M â†‘I) : module (R â§¸ I) M
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_addâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [Î½.is_add_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.fst, z.fst + z.snd)) (Î¼.prod Î½) = Î¼.prod Î½
{Î± : Type u_2} [measurable_space Î±] [topological_space Î±] [topological_space.second_countable_topology Î±] [opens_measurable_space Î±] {f : Î± â†’ Î±} {Î¼ : measure_theory.measure Î±} (h : measure_theory.conservative f Î¼) : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€ (s : set Î±), s âˆˆ nhds x â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ Î¼' : measure_theory.measure Î±} (T : set Î± â†’ (E â†’L[â„] F)) (h_zero : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s = 0 â†’ T s = 0) (h_add : measure_theory.fin_meas_additive Î¼ T) (hÎ¼ : Î¼.absolutely_continuous Î¼') (f : â†¥(measure_theory.Lp.simple_func E 1 Î¼)) (f' : â†¥(measure_theory.Lp.simple_func E 1 Î¼')) (h : â‡‘f =áµ[Î¼] â‡‘f') : measure_theory.L1.simple_func.set_to_L1s T f = measure_theory.L1.simple_func.set_to_L1s T f'
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : ae_measurable f Î¼) {Îµ : ennreal} (hÎµ : Îµ â‰  0) (hÎµ' : Îµ â‰  âŠ¤) : â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼ / Îµ
{I : Type vâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {J : Type vâ‚} [category_theory.small_category J] {F : J â¥¤ Î  (i : I), C i} {c : Î  (i : I), category_theory.limits.cone (F â‹™ category_theory.pi.eval C i)} (P : Î  (i : I), category_theory.limits.is_limit (c i)) : category_theory.limits.is_limit (category_theory.pi.cone_of_cone_comp_eval c)
{E : Type u} [normed_group E] [normed_space â„ E] {n : â„•} [complete_space E] (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) â†’ â„) â†’ E) (f' : (fin (n + 1) â†’ â„) â†’ ((fin (n + 1) â†’ â„) â†’L[â„] E)) (s : set (fin (n + 1) â†’ â„)) (hs : s.countable) (Hs : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ s â†’ continuous_within_at f (â‡‘box_integral.box.Icc I) x) (Hd : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I  s â†’ has_fderiv_within_at f (f' x) (â‡‘box_integral.box.Icc I) x) (i : fin (n + 1)) : box_integral.has_integral I âŠ¥ (Î» (x : fin (n + 1) â†’ â„), â‡‘(f' x) (pi.single i 1)) box_integral.box_additive_map.volume (box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.upper i) x)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.lower i) x)) box_integral.box_additive_map.volume)
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {p : â„} {f g : Î± â†’ ennreal} (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) (hp1 : 1 â‰¤ p) : (âˆ«â» (a : Î±), (f + g) a ^ p âˆ‚Î¼) ^ (1 / p) â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) + (âˆ«â» (a : Î±), g a ^ p âˆ‚Î¼) ^ (1 / p)
(p : pexpr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (expr Ã— list expr)
{c : Type u â†’ Type u} {hom : Î  â¦ƒÎ± Î² : Type uâ¦„, c Î± â†’ c Î² â†’ Type u} [ğ’ : category_theory.bundled_hom hom] {d : Type u â†’ Type u} {hom_d : Î  â¦ƒÎ± Î² : Type uâ¦„, d Î± â†’ d Î² â†’ Type u} [category_theory.bundled_hom hom_d] (obj : Î  â¦ƒÎ± : Type uâ¦„, c Î± â†’ d Î±) (map : Î  {X Y : category_theory.bundled c}, (X âŸ¶ Y) â†’ (category_theory.bundled.map obj X âŸ¶ category_theory.bundled.map obj Y)) (h_map : âˆ€ {X Y : category_theory.bundled c} (f : X âŸ¶ Y), â‡‘(map f) = â‡‘f) : category_theory.has_forgetâ‚‚ (category_theory.bundled c) (category_theory.bundled d)
{ğ•œ : Type u_1} {G : Type u_2} {x : G} [nondiscrete_normed_field ğ•œ] [measurable_space G] {Î¼ : measure_theory.measure G} [has_sub G] [normed_space â„ ğ•œ] [complete_space ğ•œ] {f g : G â†’ ğ•œ} : convolution f g (continuous_linear_map.lmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f t * g (x - t) âˆ‚Î¼
{Î± : Type u_1} (F : Type u_6) (ğ•œ : Type u_11) (p : ennreal) [is_R_or_C ğ•œ] [normed_group F] [normed_space ğ•œ F] {m m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp_meas F ğ•œ m p Î¼)) : â†¥(measure_theory.Lp F p (Î¼.trim hm))
{n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] {m : â„•} (hcop : m.coprime n) : (polynomial.map (int.cast_ring_hom K) (minpoly â„¤ Î¼)).is_root (Î¼ ^ m)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_equalizer f g] {W : C} {k l : W âŸ¶ category_theory.limits.equalizer f g} (h : k â‰« category_theory.limits.equalizer.Î¹ f g = l â‰« category_theory.limits.equalizer.Î¹ f g) : k = l
{E : Type u_1} [semi_normed_group E] {s : add_subgroup E} (x : â†¥s) : âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
{Î± : Type u_1} [pseudo_metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s : set Î±} (hs : âˆƒ (R : â„) (H : R > 0), â‡‘Î¼ (metric.cthickening R s) â‰  âŠ¤) (h's : is_closed s) : filter.tendsto (Î» (r : â„), â‡‘Î¼ (metric.cthickening r s)) (nhds 0) (nhds (â‡‘Î¼ s))
{Î± : Type u} {Î² : Type v} [uniform_space Î±] [uniform_space Î²] {f : Î± â†’ Î²} {s : set Î±} (hs : totally_bounded s) (hf : uniform_continuous f) : totally_bounded (f '' s)
{n : â„•+} (K : Type u_1) [field K] {L : Type u_2} [field L] {Î¼ : L} (hÎ¼ : is_primitive_root Î¼ â†‘n) [algebra K L] [is_cyclotomic_extension {n} K L] : function.injective â‡‘(is_primitive_root.aut_to_pow K hÎ¼)
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) : set ennreal
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.tagged_prepartition I) (Ï€i : Î  (J : box_integral.box Î¹), box_integral.prepartition J) : box_integral.tagged_prepartition I
{Î± : Type u} [t : topological_space Î±] {s : set (set Î±)} (hs : t = topological_space.generate_from s) : topological_space.is_topological_basis ((Î» (f : set (set Î±)), â‹‚â‚€ f) '' {f : set (set Î±) | f.finite âˆ§ f âŠ† s âˆ§ (â‹‚â‚€ f).nonempty})
{Î¹ : Type u_1} {R : Type u_2} {M : Î¹ â†’ Type u_4} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] [add_comm_monoid N] [module R N] â¦ƒÏ† Ïˆ : (Î â‚€ (i : Î¹), M i) â†’â‚—[R] Nâ¦„ (h : âˆ€ (i : Î¹) (x : M i), â‡‘Ï† (dfinsupp.single i x) = â‡‘Ïˆ (dfinsupp.single i x)) : Ï† = Ïˆ
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] {I : ideal R} (h : I.fg) (f : R â†’+* S) : (ideal.map f I).fg
{Î² : Type w} {C : Type u} [category_theory.category C] {Î³ : Type v} (Îµ : Î² â‰ƒ Î³) (f : Î³ â†’ C) [category_theory.limits.has_product f] [category_theory.limits.has_product (f âˆ˜ â‡‘Îµ)] : âˆ f âˆ˜ â‡‘Îµ â‰… âˆ f
{elab : bool} : expr elab â†’ expr elab â†’ expr elab
{Î± : Type u_1} {ğ•œ : Type u_2} [linear_ordered_field ğ•œ] (G : simple_graph Î±) [decidable_rel G.adj] (Îµ : ğ•œ) (s t : finset Î±) : finset Î±
{Î± : Type u_1} (l : filter Î±) (Îµ : Î± â†’ Type u_2) : setoid (Î  (a : Î±), Îµ a)
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : Type u_2
{F : Type u_1} [normed_group F] [normed_space â„ F] (f : â„ â†’ F) (K : set F) (r s Îµ : â„) : set â„
(R : Type u) [semiring R] (M : Type v) (Î¹ : Type u_1 := punit) [add_comm_monoid M] [module R M] [unique Î¹] : direct_sum Î¹ (Î» (_x : Î¹), M) â‰ƒâ‚—[R] M
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) (Ï€i : Î  (J : box_integral.box Î¹), box_integral.prepartition J) : box_integral.prepartition I
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] (Î¼ : Î  (i : Î¹), measure_theory.measure (Î± i)) : measure_theory.measure (Î  (i : Î¹), Î± i)
{R : Type u} [non_assoc_semiring R] â¦ƒs t : set Râ¦„ (h : s âŠ† t) : subsemiring.closure s â‰¤ subsemiring.closure t
{f f' : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ (âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), slope f x z < r)) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : âˆ€ (x : â„), has_deriv_at B (B' x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f x = B x â†’ f' x < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
{Î± : Type u_1} {F : Type u_3} [normed_group F] [normed_space â„ F] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (s : set Î±) : F â†’L[â„] F
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] [dec_ğ•œ : decidable_eq ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ğ•œ E] (v : E) (Î¼ : module.End.eigenvalues T) : â‡‘(hT.diagonalization) (â‡‘T v) Î¼ = â†‘Î¼ â€¢ â‡‘(hT.diagonalization) v Î¼
{Î± : Type u} {Î² : Type v} {f g : Î± â†’ Î²} {s : set Î±} (h : âˆ€ (x : Î±), f x = g x) : f '' s = g '' s
{Î± : Type u_1} {C : Î  {n : â„•}, vector3 Î± n â†’ Sort u} {n : â„•} (v : vector3 Î± n) (H0 : C vector3.nil) (Hs : Î  {n : â„•} (a : Î±) (w : vector3 Î± n), C w â†’ C (a::w)) : C v
(name : module_info.module_name) (cur_module : string := "") : environment
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} {Ïƒ : Type u_4} : turing.TM2.stmt Î“ Î› Ïƒ â†’ finset (turing.TM2.stmt Î“ Î› Ïƒ)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {F : Type u_5} [normed_group F] [normed_space ğ•œ F] (Z : basic_smooth_vector_bundle_core I M F) : charted_space (model_prod H F) Z.to_topological_vector_bundle_core.total_space
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (f' : W âŸ¶ X) [category_theory.limits.has_pullback f g] [category_theory.limits.has_pullback f' category_theory.limits.pullback.fst] [category_theory.limits.has_pullback (f' â‰« f) g] : category_theory.limits.pullback f' category_theory.limits.pullback.fst â‰… category_theory.limits.pullback (f' â‰« f) g
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] (x : Î±) : â„•
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {D : Type uâ‚‚} [category_theory.category D] (F : Î  (i : I), C i â¥¤ D) (q : (Î£ (i : I), C i) â¥¤ D) (h : Î  (i : I), category_theory.sigma.incl i â‹™ q â‰… F i) : q â‰… category_theory.sigma.desc F
{I : Type u} (f : I â†’ Type v) [decidable_eq I] [Î  (i : I), has_one (f i)] (i : I) : one_hom (f i) (Î  (i : I), f i)
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] (Ï• Ïˆ : A â†’â‚[R] B) : subalgebra R A
{Ï„ : Type u_1} [topological_space Ï„] [add_comm_group Ï„] [topological_add_group Ï„] {Î± : Type u_2} [topological_space Î±] (f : filter Ï„) (Ï• : flow Ï„ Î±) (s : set Î±) (hf : âˆ€ (t : Ï„), filter.tendsto (Î» (_x : Ï„), _x + t) f f) (t : Ï„) : omega_limit f â‡‘Ï• (â‡‘Ï• t '' s) = omega_limit f â‡‘Ï• s
{Î± : Type u_1} {E : Type u_4} {ğ•œ : Type u_6} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_field ğ•œ] [normed_space ğ•œ E] [fact (1 â‰¤ p)] : normed_space ğ•œ â†¥(measure_theory.Lp.simple_func E p Î¼)
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (I : ideal R) (J : ideal S) (f : R â‰ƒ+* S) (hIJ : J = ideal.map â†‘f I) : R â§¸ I â‰ƒ+* S â§¸ J
{R : Type u} [comm_semiring R] (I : ideal R) : ideal R
{Î± : Type u_1} {F : Type u_3} [normed_group F] {m : measurable_space Î±} (f : Î± â†’ F) (q : â„) (Î¼ : measure_theory.measure Î±) : ennreal
{Î± : Type u_1} (E : Type u_2) {m0 : measurable_space Î±} (p : ennreal) (Î¼ : measure_theory.measure Î±) [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] : add_subgroup â†¥(measure_theory.Lp E p Î¼)
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {r : â„} (r_nonneg : 0 â‰¤ r) {x : E} (hx : x â‰  0) : âˆ¥(â†‘r * (â†‘âˆ¥xâˆ¥)â»Â¹) â€¢ xâˆ¥ = r
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X âŸ¶ Y) [category_theory.limits.has_kernel f] {W : C} (k : W âŸ¶ X) (h : k â‰« f = 0) : W âŸ¶ category_theory.limits.kernel f
(cs : interactive.parse (lean.parser.many lean.parser.ident)) (locat : interactive.parse interactive.types.location) (cfg : tactic.unfold_config := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.tt, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}}) : tactic unit
(l : interactive.parse interactive.types.location) (cfg : tactic.unfold_proj_config := {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}}) : tactic unit
{G : Type u_1} {Î± : Type u_2} [group G] [mul_action G Î±] [measurable_space Î±] {s t : set Î±} {Î¼ : measure_theory.measure Î±} [measurable_space G] [has_measurable_smul G Î±] [measure_theory.smul_invariant_measure G Î± Î¼] [encodable G] (hs : measure_theory.is_fundamental_domain G s Î¼) (ht : measure_theory.is_fundamental_domain G t Î¼) : â‡‘Î¼ s = â‡‘Î¼ t
{Î± : Type u_1} (S : set (setoid Î±)) : has_Sup.Sup S = eqv_gen.setoid (Î» (x y : Î±), âˆƒ (r : setoid Î±), r âˆˆ S âˆ§ r.rel x y)
{Î± : Type u_1} {m : measurable_space Î±} (s : measure_theory.signed_measure Î±) (i : set Î±) (hi : 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i) (j : set Î±) (hj : measurable_set j) : ennreal
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {Î¹ : Type u_3} [topological_space.pseudo_metrizable_space Î²] (u : filter Î¹) [u.ne_bot] [u.is_countably_generated] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ (i : Î¹), measure_theory.ae_strongly_measurable (f i) Î¼) (lim : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : Î¹), f n x) u (nhds (g x))) : measure_theory.ae_strongly_measurable g Î¼
{Î± : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} {Î¼ : measure_theory.measure E} {X : Î± â†’ E} [measure_theory.has_pdf X Â«â„™Â» Î¼] : measure_theory.measure.quasi_measure_preserving X Â«â„™Â» Î¼
{R : Type u_1} [semiring R] (Ï† : power_series R) (n : enat) (h : âˆ€ (i : â„•), â†‘i < n â†’ â‡‘(power_series.coeff R i) Ï† = 0) : n â‰¤ Ï†.order
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {B : bilin_form K V} {W : subspace K V} (bâ‚ : B.is_refl) (bâ‚‚ : (B.restrict W).nondegenerate) : is_compl W (B.orthogonal W)
(ns : list name) (p : name := name.mk_string "interactive" (name.mk_string "tactic" name.anonymous)) : tactic unit
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_4} [topological_space H] {I : model_with_corners ğ•œ E H} {H' : Type u_5} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {N : Type u_6} [topological_space N] [charted_space H N] {R : Type u_7} [comm_ring R] [topological_space R] [charted_space H' R] [smooth_ring I' R] : cont_mdiff_map I I' N R âŠ¤ â†’+* N â†’ R
{Î± : Sort u_1} {Ïƒ : Î± â†’ Sort u_4} (P : Prop) [decidable P] (f : P â†’ Î  (a : Î±), Ïƒ a) (g : Â¬P â†’ Î  (a : Î±), Ïƒ a) (a : Î±) : dite P f g a = dite P (Î» (h : P), f h a) (Î» (h : Â¬P), g h a)
{Î± : Type u_1} [emetric_space Î±] {K : nnreal} {f : Î± â†’ Î±} {s : set Î±} (hsc : is_complete s) (hsf : set.maps_to f s s) (hf : contracting_with K (set.maps_to.restrict f s s hsf)) {x : Î±} (hxs : x âˆˆ s) (hx : has_edist.edist x (f x) â‰  âŠ¤) : âˆƒ (y : Î±) (H : y âˆˆ s), function.is_fixed_pt f y âˆ§ filter.tendsto (Î» (n : â„•), f^[n] x) filter.at_top (nhds y) âˆ§ âˆ€ (n : â„•), has_edist.edist (f^[n] x) y â‰¤ has_edist.edist x (f x) * â†‘K ^ n / (1 - â†‘K)
{Ïƒ : Type u_1} {R : Type u_3} [comm_semiring R] : mv_polynomial (mv_polynomial Ïƒ R) R â†’â‚[R] mv_polynomial Ïƒ R
{L : first_order.language} {Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [is_directed Î¹ has_le.le] [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [nonempty Î¹] : L.prestructure (first_order.language.direct_limit.setoid G f)
{Î± : Type u_1} [metric_space Î±] {K : nnreal} {f : Î± â†’ Î±} (hf : contracting_with K f) [nonempty Î±] [complete_space Î±] (x : Î±) (n : â„•) : has_dist.dist (f^[n] x) (contracting_with.fixed_point f hf) â‰¤ has_dist.dist (f^[n] x) (f^[n + 1] x) / (1 - â†‘K)
{L : first_order.language} {Î± : Type u'} {n : â„•} (Ï† : L.bounded_formula Î± n) : L.bounded_formula Î± n
{Î± : Type u} {C : free_add_magma Î± â†’ Sort l} (x : free_add_magma Î±) (ih1 : Î  (x : Î±), C (free_add_magma.of x)) (ih2 : Î  (x y : free_add_magma Î±), C x â†’ C y â†’ C (x + y)) : C x
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : set Î±} (hâ‚ : s âŠ† t) (hâ‚‚ : â‡‘Î¼ t â‰¤ â‡‘Î¼ s) (hsm : measurable_set s) (ht : â‡‘Î¼ t â‰  âŠ¤) : s =áµ[Î¼] t
{Î± : Type} (inner : tactic.unsafe.type_context Î±) (tr : tactic.transparency := tactic.transparency.semireducible) : tactic Î±
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i * g i) â†” antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {t : set Î±} {f : Î± â†’ E} {C : â„} [strict_convex_space â„ E] (ht : â‡‘Î¼ t â‰  âŠ¤) (h_le : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, âˆ¥f xâˆ¥ â‰¤ C) : f =áµ[Î¼.restrict t] function.const Î± (â¨ (x : Î±) in t, f x âˆ‚Î¼) âˆ¨ âˆ¥âˆ« (x : Î±) in t, f x âˆ‚Î¼âˆ¥ < (â‡‘Î¼ t).to_real * C
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] [measurable_space G] [has_sub G] (f : G â†’ E) (g : G â†’ E') (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) (Î¼ : measure_theory.measure G . "volume_tac") : Prop
{Î¹ : Type u} (s : finset Î¹) (f g : Î¹ â†’ â„) {p q : â„} (hpq : p.is_conjugate_exponent q) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), |f i| ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), |g i| ^ q) ^ (1 / q)
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [nonempty Î²] [semilattice_sup Î²] {u : Î² â†’ Î±} : cauchy_seq u â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ has_edist.edist (u m) (u n) < Îµ)
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (hn : x â‰  y) (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : hb.oangle y x = â†‘real.pi - 2 â€¢ hb.oangle (y - x) y
{R : Type u} [semiring R] (I : ideal (polynomial R)) : ideal R
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (âˆ€ (a : set (submodule R M)), a.nonempty â†’ (âˆƒ (M' : submodule R M) (H : M' âˆˆ a), âˆ€ (I : submodule R M), I âˆˆ a â†’ I â‰¤ M' â†’ I = M')) â†” is_artinian R M
{G : Type u_1} [measurable_space G] [group G] [topological_space G] (Î¼ : measure_theory.measure G) [Î¼.is_haar_measure] [borel_space G] [topological_group G] {H : Type u_2} [group H] [topological_space H] [measurable_space H] [borel_space H] [t2_space H] [topological_group H] (f : G â‰ƒ* H) (hf : continuous â‡‘f) (hfsymm : continuous â‡‘(f.symm)) : (measure_theory.measure.map â‡‘f Î¼).is_haar_measure
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) [t2_space M] [smooth_manifold_with_corners I M] {G : Type u_1} [normed_group G] [normed_space â„ G] {g : M â†’ G} (hg : smooth_on I (model_with_corners_self â„ G) g (charted_space.chart_at H c).to_local_equiv.source) : smooth I (model_with_corners_self â„ G) (Î» (x : M), â‡‘f x â€¢ g x)
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {s t : set Î±} {Î¦ : Î± â†’ Î²} (h : isometry Î¦) : emetric.Hausdorff_edist (Î¦ '' s) (Î¦ '' t) = emetric.Hausdorff_edist s t
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} [add_group G] [has_measurable_add G] [Î¼.is_add_left_invariant] (f : G â†’ E) (g : G) : âˆ« (x : G), f (g + x) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) : âˆƒ (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (Î¼ : K) (k : â„•) : â‡‘(f.generalized_eigenspace Î¼) k â‰¤ â‡‘(f.generalized_eigenspace Î¼) (finite_dimensional.finrank K V)
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (Hf : monotone f) {a : Î±} {s : set Î±} (Ha : is_least s a) : is_least (f '' s) (f a)
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [has_measurable_inv G] [Î¼.is_mul_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.snd, (z.snd)â»Â¹ * z.fst)) (Î¼.prod Î½) = Î½.prod Î¼
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {Îµ : Type u_5} (f : Î± â†’ Î² â†’ Î³ â†’ Î´ â†’ Îµ) : list Î± â†’ list Î² â†’ list Î³ â†’ list Î´ â†’ list Îµ
{p : â„•+} {k : â„•} {K : Type u} {L : Type v} {Î¶ : L} [field K] [field L] [algebra K L] [hcycl : is_cyclotomic_extension {p ^ k} K L] [hp : fact (nat.prime â†‘p)] [ne_zero â†‘â†‘p] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ k)) (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ k) K)) : algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p ^ k).totient / 2) * â†‘p ^ (â†‘p ^ (k - 1) * ((â†‘p - 1) * k - 1))
{M : Type u_1} [has_mul M] (c : con M) [d : Î  (a b : M), decidable (â‡‘c a b)] : decidable_eq c.quotient
{k : Type u_1} [field k] {Ïƒ : Type u_2} (x : Ïƒ â†’ k) : prime_spectrum (mv_polynomial Ïƒ k)
{Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq Î¹] [add_monoid Î¹] [comm_semiring R] [semiring A] [algebra R A] (ğ’œ : Î¹ â†’ submodule R A) [graded_algebra ğ’œ] [Î  (i : Î¹) (x : â†¥(ğ’œ i)), decidable (x â‰  0)] (r : A) : finset Î¹
{Ïƒ : Type u_1} (f : Ïƒ â†’ option Ïƒ) (a : Ïƒ) : turing.evals_to_in_time f a â†‘a 0
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] (f : Î± Ã— Î² â†’ E) (hf : measure_theory.integrable f (Î¼.prod Î½)) : âˆ« (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} {C : Î  {n : â„•}, vector Î± n â†’ vector Î² n â†’ Sort u_3} (v : vector Î± n) (w : vector Î² n) (h_nil : C vector.nil vector.nil) (h_cons : Î  {n : â„•} {a : Î±} {b : Î²} {x : vector Î± n} {y : vector Î² n}, C x y â†’ C (a::áµ¥x) (b::áµ¥y)) : C v w
(e : expr) (n : â„•) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr Ã— expr)
(R : Type u) {Î¹ : Type x} {Î¹' : Type x'} [semiring R] (Ï† : Î¹ â†’ Type u_1) [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] (e : Î¹ â‰ƒ Î¹') : (Î  (i' : Î¹), Ï† i') â‰ƒâ‚—[R] Î  (i : Î¹'), Ï† (â‡‘(e.symm) i)
{Î± : Type u_1} {Î¹ : Type u_5} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {S : set Î¹} {s : Î¹ â†’ set Î±} (hc : S.countable) (hs : (â‹ƒ (i : Î¹) (H : i âˆˆ S), s i) = set.univ) : (âˆ€ (i : Î¹), i âˆˆ S â†’ Î¼.restrict (s i) = Î½.restrict (s i)) â†’ Î¼ = Î½
{ğ•† : Type u_1} {â„™ : Type u_2} {Î± : Type u_3} [preorder ğ•†] [preorder Â«â„™Â»] [preorder Î±] [grade_max_order ğ•† Î±] (f : ğ•† â†’ Â«â„™Â») (hf : strict_mono f) (hcovby : âˆ€ (a b : ğ•†), a â‹– b â†’ f a â‹– f b) (hmax : âˆ€ (a : ğ•†), is_max a â†’ is_max (f a)) : grade_max_order Â«â„™Â» Î±
(P : Î  {R S : Type u} [_inst_7 : comm_ring R] [_inst_8 : comm_ring S], (R â†’+* S) â†’ Prop) : Prop
{G : Type u} [group G] (N : subgroup G) [nN : N.normal] {H : Type v} [group H] (Ï† : G â†’* H) (HN : âˆ€ (x : G), x âˆˆ N â†’ â‡‘Ï† x = 1) : G â§¸ N â†’* H
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p âˆˆ s) : vector_span k s = submodule.span k (has_vsub.vsub p '' s)
{P : Type u_1} [preorder P] {I : order.ideal P} (h : I.is_prime) : order.ideal.prime_pair P
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {c : E} {la la' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [interval_integral.FTC_filter a la la'] [measure_theory.is_locally_finite_measure Î¼] (hab : interval_integrable f Î¼ a b) (hmeas : strongly_measurable_at_filter f la' Î¼) (hf : filter.tendsto f (la' âŠ“ Î¼.ae) (nhds c)) (hu : filter.tendsto u lt la) (hv : filter.tendsto v lt la) : (Î» (t : Î¹), âˆ« (x : â„) in v t..b, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..b, f x âˆ‚Î¼ + âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
(R : Type u_1) {Î¹ : Type u_2} [semiring R] (Ï† : Î¹ â†’ Type u_3) [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] [decidable_eq Î¹] (i : Î¹) : Ï† i â†’â‚—[R] Î  (i : Î¹), Ï† i
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] : mv_polynomial Ïƒ R â†’+* R
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a bâ‚ bâ‚‚ : â„} {Î¼ : measure_theory.measure â„} {f : â„ â†’ E} [measure_theory.has_no_atoms Î¼] (h_int : interval_integrable f Î¼ bâ‚ bâ‚‚) (ha : a âˆˆ set.interval bâ‚ bâ‚‚) : continuous_on (Î» (b : â„), âˆ« (x : â„) in a..b, f x âˆ‚Î¼) (set.interval bâ‚ bâ‚‚)
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] [has_zero Î²] (f : Î± â†’ Î²) (hf : measure_theory.ae_fin_strongly_measurable f Î¼) : Î± â†’ Î²
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : set Î±} (ht : measurable_set t) : â‡‘(Î¼.restrict s) t = â‡‘Î¼ (t âˆ© s)
(Ïƒ K : Type u) [fintype K] [comm_ring K] : Type u
{Î± : Type u_1} {Î¹ : Type u_5} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (hs : (â‹ƒ (i : Î¹), s i) = set.univ) : Î¼ = Î½ â†” âˆ€ (i : Î¹), Î¼.restrict (s i) = Î½.restrict (s i)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (f : Z âŸ¶ Y) (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) : J.cocomplex âŸ¶ I.cocomplex
{x : pgame} : 0 â‰¤ x â†” âˆ€ (j : x.right_moves), 0.lf (x.move_right j)
{Î± : Type u_1} {m : measurable_space Î±} (c : measure_theory.complex_measure Î±) (Î¼ : measure_theory.measure Î±) : Prop
{V : Type u_1} [inner_product_space â„ V] (x y : V) (h : inner_product_geometry.angle x y = real.pi / 2) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½â‚ Î½â‚‚ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] (A2 : Î¼ + Î½â‚ â‰¤ Î¼ + Î½â‚‚) : Î½â‚ â‰¤ Î½â‚‚
{C : Type uâ‚‚} [category_theory.category C] {I : Type uâ‚} {F G : category_theory.discrete I â¥¤ C} (f : Î  (i : category_theory.discrete I), F.obj i â‰… G.obj i) : F â‰… G
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (g : Î² â†’ ennreal) (f : measure_theory.simple_func Î± Î²) : (measure_theory.simple_func.map g f).lintegral Î¼ = f.range.sum (Î» (x : Î²), g x * â‡‘Î¼ (â‡‘f â»Â¹' {x}))
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic expr
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) (x : E) : âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} (t : category_theory.limits.pullback_cone f g) {W : C} {k l : W âŸ¶ t.X} (hâ‚€ : k â‰« t.fst = l â‰« t.fst) (hâ‚ : k â‰« t.snd = l â‰« t.snd) (j : category_theory.limits.walking_cospan) : k â‰« t.Ï€.app j = l â‰« t.Ï€.app j
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) : M â†’ â„
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (f : Z âŸ¶ Y) (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) : J.Î¹ â‰« category_theory.InjectiveResolution.desc f I J = (cochain_complex.singleâ‚€ C).map f â‰« I.Î¹
(explain : interactive.parse (optional (lean.parser.tk "?"))) (rs : interactive.parse (optional (interactive.types.list_of (tactic.interactive.rw_rule_p (lean.parser.pexpr 0))))) (cfg : tactic.rewrite_search.config := {to_cfg := {to_rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}, try_simp := bool.ff, discharger := tactic.skip, simplifier := Î» (e : expr), tactic.failed}, max_iterations := 5000, explain_using_conv := bool.tt}) : tactic unit
(red : tactic.transparency) (mode : tactic.ring.normalize_mode := tactic.ring.normalize_mode.horner) (e : expr) : tactic (expr Ã— expr)
{Î± : Type u_1} (Î² : Type u_2) [measurable_space Î±] [topological_space Î²] (Î¼ : measure_theory.measure Î±) : setoid {f // measure_theory.ae_strongly_measurable f Î¼}
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : Prop
{Î± : Type u} {C : free_semigroup Î± â†’ Sort l} (x : free_semigroup Î±) (ih1 : Î  (x : Î±), C (has_pure.pure x)) (ih2 : Î  (x : Î±) (y : free_semigroup Î±), C (has_pure.pure x) â†’ C y â†’ C (has_pure.pure x * y)) : C x
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (h_meas : âˆ€ (n : â„•), measurable (f n)) (h_mono : âˆ€ (n : â„•), f n.succ â‰¤áµ[Î¼] f n) (h_fin : âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤) : âˆ«â» (a : Î±), (â¨… (n : â„•), f n a) âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} {s : set Î²} : tendsto_uniformly_on F f p s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), x âˆˆ s â†’ has_dist.dist (f x) (F n x) < Îµ)
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {K : nnreal} {f : X â†’ Y} (h : lipschitz_with K f) {d : â„} (hd : 0 â‰¤ d) (s : set X) : â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘K ^ d * â‡‘(measure_theory.measure.hausdorff_measure d) s
{Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), add_comm_group (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’+ G j) (P : Type uâ‚) [add_comm_group P] (g : Î  (i : Î¹), G i â†’+ P) (Hg : âˆ€ (i j : Î¹) (hij : i â‰¤ j) (x : G i), â‡‘(g j) (â‡‘(f i j hij) x) = â‡‘(g i) x) : add_comm_group.direct_limit G f â†’â‚—[â„¤] P
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_4} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_6} [topological_space M] [charted_space H M] {n : with_top â„•} : cont_mdiff_map I I M M n
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : measurable f) (Îµ : ennreal) : Îµ * â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼
(Î± : Type u_1) (E : Type u_2) {F : Type u_3} (ğ•œ : Type u_6) [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ F] {T : set Î± â†’ (E â†’L[â„] F)} {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) (h_smul : âˆ€ (c : ğ•œ) (s : set Î±) (x : E), â‡‘(T s) (c â€¢ x) = c â€¢ â‡‘(T s) x) : â†¥(measure_theory.Lp.simple_func E 1 Î¼) â†’L[ğ•œ] F
{M : Type u_1} [has_add M] {S : set (add_con M)} : has_Sup.Sup S = add_con_gen (has_Sup.Sup (coe_fn '' S))
{Î± : Type} (tactics : list (tactic Î±)) (sort_by : tactic â„• := tactic.num_goals) : tactic (list (Î± Ã— â„•))
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) (r : â„) (hr : r âˆˆ set.Ioo 0 f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R) : smooth_bump_function I c
{Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€ (k : â„•), f^[k] x âˆˆ s â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
{Ïƒ : Type u_1} (f : Ïƒ â†’ option Ïƒ) : Ïƒ â†’ Ïƒ â†’ Prop
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) : Type (max u v)
{M : Type u} [add_zero_class M] : reflexive (Î» (a b : M), âˆƒ (c : M), add_semiconj_by c a b)
(nm : name) (cfg : simps_cfg := {attrs := [name.mk_string "simp" name.anonymous], simp_rhs := bool.ff, type_md := tactic.transparency.instances, rhs_md := tactic.transparency.none, fully_applied := bool.tt, not_recursive := [name.mk_string "prod" name.anonymous, name.mk_string "pprod" name.anonymous], trace := bool.ff, add_additive := option.none name}) (todo : list string := list.nil) (trc : bool := bool.ff) : tactic unit
{M : Type u_1} [has_add M] (c d : add_con M) : c âŠ” d = add_con_gen (Î» (x y : M), â‡‘c x y âˆ¨ â‡‘d x y)
{Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_metric_space (Ï€ b)] (x : Î  (b : Î²), Ï€ b) {r : â„} (hr : 0 â‰¤ r) : metric.closed_ball x r = set.univ.pi (Î» (b : Î²), metric.closed_ball (x b) r)
{Î± : Type u_1} {m : set (measure_theory.outer_measure Î±)} {s : set Î±} (h : s.nonempty) : â‡‘(has_Inf.Inf m) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (Î¼ : measure_theory.outer_measure Î±) (h3 : Î¼ âˆˆ m), â‡‘Î¼ (t n)
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [complete_space F] {T : set Î± â†’ (E â†’L[â„] F)} {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) : â†¥(measure_theory.Lp E 1 Î¼) â†’L[â„] F
{I : Type u} (f : I â†’ Type v) [decidable_eq I] [Î  (i : I), mul_zero_class (f i)] (i : I) : f i â†’â‚™* Î  (i : I), f i
{C : Type uâ‚} [category_theory.category C] {X : C} (S : category_theory.presieve X) (R : Î  â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, S f â†’ category_theory.presieve Y) : category_theory.presieve X
{Î¹ : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [fintype Î¹] {S : Type u_3} [comm_ring S] [is_domain S] [algebra R S] (b : basis Î¹ R S) (I : ideal S) (hI : I â‰  âŠ¥) : basis.smith_normal_form (submodule.restrict_scalars R I) Î¹ (fintype.card Î¹)
{M : Type u_1} [has_add M] (S : set (add_con M)) : â‡‘(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) : Type (max u v)
{F : Type u_3} [inner_product_space â„ F] (x y : F) : |has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)| â‰¤ 1
{E : Type u_3} [normed_group E] {Î¼ : measure_theory.measure â„} [measure_theory.is_locally_finite_measure Î¼] {u : â„ â†’ E} (hu : continuous u) (a b : â„) : interval_integrable u Î¼ a b
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [add_group G] [has_measurable_addâ‚‚ G] [has_measurable_neg G] {xâ‚€ : G} {s : set G} (hbg : bdd_above ((Î» (i : G), âˆ¥g iâˆ¥) '' ((Î» (t : G), -t + xâ‚€) â»Â¹' s))) (hs : measurable_set s) (h2s : function.support (Î» (t : G), â‡‘(â‡‘L (f t)) (g (xâ‚€ - t))) âŠ† s) (hf : measure_theory.integrable_on f s Î¼) (hmf : measure_theory.ae_strongly_measurable f Î¼) (hmg : measure_theory.ae_strongly_measurable g (measure_theory.measure.map (Î» (t : G), xâ‚€ - t) Î¼)) : convolution_exists_at f g xâ‚€ L Î¼
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measure_theory.measure.map (s.restrict f) (â‡‘(measure_theory.measure.comap coe) (Î¼.with_density (Î» (x : E), ennreal.of_real |(f' x).det|))) = Î¼.restrict (f '' s)
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] [measurable_space G] [normed_space â„ F] [complete_space F] [has_sub G] (f : G â†’ E) (g : G â†’ E') (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) (Î¼ : measure_theory.measure G . "volume_tac") : G â†’ F
{R : Type u_17} {S : Type u_18} [semiring R] [semiring S] (Ïƒ : R â†’+* S) (M : Type u_19) (Mâ‚‚ : Type u_20) [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module S Mâ‚‚] : Type (max u_19 u_20)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] (f : â„ â†’ E) (a b : â„) (Î¼ : measure_theory.measure â„) : E
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : Î± â†’ Î²} (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) (hf : measure_theory.mem_â„’p f p Î¼) (hmeas : measure_theory.strongly_measurable f) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (Î´ : â„) (hÎ´ : 0 < Î´), âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰¤ ennreal.of_real Î´ â†’ measure_theory.snorm (s.indicator f) p Î¼ â‰¤ ennreal.of_real Îµ
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {C D : set (set Î±)} (h : Î¼.finite_spanning_sets_in C) (hC : C âŠ† D) : Î¼.finite_spanning_sets_in D
{C : Type uâ‚} [category_theory.category C] (F : category_theory.discrete pempty â¥¤ C) (Y : C) : category_theory.limits.is_limit {X := Y, Ï€ := {app := category_theory.limits.is_terminal_equiv_unique._aux_1 F Y, naturality' := _}} â‰ƒ Î  (X : C), unique (X âŸ¶ Y)
{p : â„•} {h : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R} {f g : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R} (hh : witt_vector.is_polyâ‚‚ p h) (hf : witt_vector.is_poly p f) (hg : witt_vector.is_poly p g) : witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), h (f x) (g y))
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : â„ â†’ E} {g : â„ â†’ F} {a b c : â„} (h_deriv : âˆ€á¶  (x : â„) in nhds_within c {c}á¶œ, differentiable_at â„ f x) (h_infty : filter.tendsto (Î» (x : â„), âˆ¥f xâˆ¥) (nhds_within c {c}á¶œ) filter.at_top) (hg : deriv f =O[nhds_within c {c}á¶œ] g) (hne : a â‰  b) (hc : c âˆˆ set.interval a b) : Â¬interval_integrable g measure_theory.measure_space.volume a b
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : topological_space M
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : category_theory.limits.multicofork I â¥¤ category_theory.limits.cofork I.fst_sigma_map I.snd_sigma_map
{Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group E] {p : ennreal} {f : Î¹ â†’ Î± â†’ E} {g : Î± â†’ E} (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) (hf : âˆ€ (n : Î¹), measure_theory.ae_strongly_measurable (f n) Î¼) (hg : measure_theory.ae_strongly_measurable g Î¼) {l : filter Î¹} (hfg : filter.tendsto (Î» (n : Î¹), measure_theory.snorm (f n - g) p Î¼) l (nhds 0)) : measure_theory.tendsto_in_measure Î¼ f l g
{Î± : Type u_1} {m : measurable_space Î±} (s : measure_theory.signed_measure Î±) (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : measure_theory.vector_measure.absolutely_continuous s Î¼.to_ennreal_vector_measure â†” Î¼.with_densityáµ¥ (s.rn_deriv Î¼) = s
{Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) (s : set Î±) : âˆƒ (t : set Î±), s âŠ† t âˆ§ measurable_set t âˆ§ â‡‘Î¼ t = â‡‘Î¼ s
{X : Type u_1} [topological_space X] {m : measurable_space X} (Î¼ : measure_theory.measure X) : Prop
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} {S : J.cover X} {T : Î  (I : S.arrow), J.cover I.Y} (I : (S.bind T).arrow) : (T I.from_middle).arrow
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [normed_group F] {g : E â†’ F} {c : nnreal} (hg : lipschitz_with c g) (g0 : g 0 = 0) (f : â†¥(measure_theory.Lp E p Î¼)) : â†¥(measure_theory.Lp F p Î¼)
(x t : â„) (h1 : 0 < x) (h2 : x â‰¤ 1) (ht : 0 < t) : |real.log x * x ^ t| < 1 / t
{R : Type u} {S : Type v} [comm_ring R] [is_domain R] [comm_ring S] [is_domain S] (Ï† : R â†’+* S) (f : polynomial R) (h_mon : f.monic) (h_irr : irreducible (polynomial.map Ï† f)) : irreducible f
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.tagged_prepartition I) (Ï€' : box_integral.prepartition I) : box_integral.tagged_prepartition I
{M : Type u_1} [monoid M] {Î¹ : Type u_2} [hdec : decidable_eq Î¹] [fintype Î¹] {N : Î¹ â†’ Type u_3} [Î  (i : Î¹), monoid (N i)] : {Ï• // pairwise (Î» (i j : Î¹), âˆ€ (x : N i) (y : N j), commute (â‡‘(Ï• i) x) (â‡‘(Ï• j) y))} â‰ƒ ((Î  (i : Î¹), N i) â†’* M)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : category_theory.limits.walking_parallel_pair â¥¤ C
{R : Type u_1} {A : Type u_2} [comm_ring R] [ring A] [algebra R A] {câ‚ câ‚‚ : R} â¦ƒqâ‚ qâ‚‚ : quaternion_algebra.basis A câ‚ câ‚‚â¦„ (hi : qâ‚.i = qâ‚‚.i) (hj : qâ‚.j = qâ‚‚.j) : qâ‚ = qâ‚‚
{E : Type u_1} [normed_group E] [measurable_space E] [normed_space â„ E] [finite_dimensional â„ E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)) (t : set E) (ht : measurable_set t) (h't : â‡‘Î¼ t â‰  0) (h''t : â‡‘Î¼ t â‰  âŠ¤) : filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© ({x} + r â€¢ t)) / â‡‘Î¼ ({x} + r â€¢ t)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} [normed_group Î²] {m : measurable_space Î±} (f : Î¹ â†’ Î± â†’ Î²) (p : ennreal) (Î¼ : measure_theory.measure Î±) : Prop
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) (hxy : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) (hxz : âˆ¥xâˆ¥ = âˆ¥zâˆ¥) : hb.oangle y z = 2 â€¢ hb.oangle (y - x) (z - x)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] (H : Type u_3) [topological_space H] (I : model_with_corners ğ•œ E H) : tangent_bundle I H â‰ƒâ‚œ model_prod H E
{G : Type u} [group G] {H : Type v} [group H] (Ï† : G â†’* H) (Ïˆ : H â†’ G) (hÏ† : function.right_inverse Ïˆ â‡‘Ï†) : G â§¸ Ï†.ker â‰ƒ* H
{Î± : Type u_1} {Î¹ : Type u_2} {I : set Î¹} (hI : I.nonempty) (m : Î¹ â†’ measure_theory.outer_measure Î±) (s : set Î±) : (â‡‘â¨… (i : Î¹) (H : i âˆˆ I), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹) (H : i âˆˆ I), â‡‘(m i) (t n)
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {P : mv_polynomial Ïƒ R â†’ Prop} (p : mv_polynomial Ïƒ R) (h1 : âˆ€ (u : Ïƒ â†’â‚€ â„•) (a : R), P (â‡‘(mv_polynomial.monomial u) a)) (h2 : âˆ€ (p q : mv_polynomial Ïƒ R), P p â†’ P q â†’ P (p + q)) : P p
{C : â„• â†’ Sort u_1} {n m : â„•} : n â‰¤ m â†’ (Î  â¦ƒk : â„•â¦„, n â‰¤ k â†’ C k â†’ C (k + 1)) â†’ C n â†’ C m
{Î± : Type u} {Î¹ : Type u_1} (I : finset Î¹) {l : filter Î±} {p : Î¹ â†’ Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in l, âˆ€ (i : Î¹), i âˆˆ I â†’ p i x) â†” âˆ€ (i : Î¹), i âˆˆ I â†’ (âˆ€á¶  (x : Î±) in l, p i x)
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} (hs : convex â„ s) (hsc : is_closed s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) : â¨ (x : Î±) in t, f x âˆ‚Î¼ âˆˆ s
{E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {C : â„} (hf : differentiable_on â„ f (set.Icc 0 1)) (bound : âˆ€ (x : â„), x âˆˆ set.Ico 0 1 â†’ âˆ¥deriv_within f (set.Icc 0 1) xâˆ¥ â‰¤ C) : âˆ¥f 1 - f 0âˆ¥ â‰¤ C
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] [proper_space F] {s : set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hb : metric.bounded s) (hc : âˆ€ (f : E' â†’SL[Ïƒâ‚â‚‚] F), â‡‘f âˆˆ closure (coe_fn '' s) â†’ f âˆˆ s) : is_compact (coe_fn '' s)
{p : â„•} {g f : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R} (hg : witt_vector.is_poly p g) (hf : witt_vector.is_poly p f) : witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), g âˆ˜ f)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X âŸ¶ Y} {P : C} {Ï€ Ï€' : Y âŸ¶ P} {w : f â‰« Ï€ = 0} (h : Ï€ = Ï€') : category_theory.limits.cokernel_cofork.of_Ï€ Ï€ w â‰… category_theory.limits.cokernel_cofork.of_Ï€ Ï€' _
{V : Type u_1} [inner_product_space â„ V] (x y : V) : real.cos (inner_product_geometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = has_inner.inner x y
(xs : list tactic.rcases_patt) (fuel : option â„•) (cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) (trace : bool := bool.ff) : tactic (list tactic.rcases_patt)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M â†’ M') (x : M) : Prop
{E : Type u_1} [semi_normed_group E] {s : set E} : metric.bounded s â†’ (âˆƒ (R : â„), âˆ€ (x : E), x âˆˆ s â†’ âˆ¥xâˆ¥ â‰¤ R)
{Î± : Type u} [pseudo_metric_space Î±] {Î² : Type u_1} {Îµ : â„} (hÎµ : 0 < Îµ) {f : Î² â†’ Î±} (hf : pairwise (Î» (x y : Î²), Îµ â‰¤ has_dist.dist (f x) (f y))) : uniform_embedding f
{Ïƒ : Type u_1} (f : Ïƒ â†’ option Ïƒ) : Ïƒ â†’ Ïƒ â†’ Prop
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) {Îµ : Î¹ â†’ â„} {C : â„} (hÎµ : âˆ€ (i : Î¹), 0 < Îµ i) {c : Î¹ â†’ ğ•œ} (hc : âˆ€ (i : Î¹), 1 < âˆ¥c iâˆ¥) (hf : âˆ€ (m : Î  (i : Î¹), E i), (âˆ€ (i : Î¹), Îµ i / âˆ¥c iâˆ¥ â‰¤ âˆ¥m iâˆ¥) â†’ (âˆ€ (i : Î¹), âˆ¥m iâˆ¥ < Îµ i) â†’ âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) (m : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {p q : tangent_bundle I M} (h : q.fst âˆˆ (charted_space.chart_at H p.fst).to_local_equiv.source) : tangent_map I I â‡‘(charted_space.chart_at H p.fst) q = â‡‘((equiv.sigma_equiv_prod H E).symm) (â‡‘(charted_space.chart_at (model_prod H E) p) q)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (f : bounded_continuous_function Î± Î²) [h : nonempty Î±] : âˆ¥fâˆ¥ = has_Inf.Inf {C : â„ | âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C}
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] (Ï : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Ï] : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds (Ï.rn_deriv Î¼ x))
{G : Type u_1} [normed_group G] [complete_space G] {H : Type u_2} [normed_group H] {f : normed_group_hom G H} {K : Type u_3} [semi_normed_group K] {j : normed_group_hom K H} (hj : âˆ€ (x : K), âˆ¥â‡‘j xâˆ¥ = âˆ¥xâˆ¥) {C Îµ : â„} (hC : 0 < C) (hÎµ : 0 < Îµ) (hyp : âˆ€ (k : K), âˆƒ (g : G), â‡‘f g = â‡‘j k âˆ§ âˆ¥gâˆ¥ â‰¤ C * âˆ¥kâˆ¥) : f.surjective_on_with j.range.topological_closure (C + Îµ)
{K : Type u_1} [comm_ring K] [is_domain K] {Î¶ : K} {n : â„•} (hpos : 0 < n) (h : is_primitive_root Î¶ n) : polynomial.cyclotomic' n K = (polynomial.X ^ n - 1) /â‚˜ n.proper_divisors.prod (Î» (i : â„•), polynomial.cyclotomic' i K)
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ â„} (hf : measure_theory.integrable f Î¼) : âˆ« (a : Î±), f a âˆ‚Î¼ = (âˆ«â» (a : Î±), ennreal.of_real (f a) âˆ‚Î¼).to_real - (âˆ«â» (a : Î±), ennreal.of_real (-f a) âˆ‚Î¼).to_real
(r e : expr) (cfg : tactic.nth_rewrite.cfg := {to_rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}, try_simp := bool.ff, discharger := tactic.skip, simplifier := Î» (e : expr), tactic.failed}) : tactic (expr Ã— expr)
{Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} [has_zero Î²] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] (hf : measure_theory.fin_strongly_measurable f Î¼) : measurable f
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {ğ’¢ : measure_theory.filtration â„• m0} [measure_theory.is_finite_measure Î¼] {f : â„• â†’ Î± â†’ â„} (hadp : measure_theory.adapted ğ’¢ f) (hint : âˆ€ (i : â„•), measure_theory.integrable (f i) Î¼) : measure_theory.submartingale f ğ’¢ Î¼ â†” âˆ€ (Ï„ Ï€ : Î± â†’ â„•), measure_theory.is_stopping_time ğ’¢ Ï„ â†’ measure_theory.is_stopping_time ğ’¢ Ï€ â†’ Ï„ â‰¤ Ï€ â†’ (âˆƒ (N : â„•), âˆ€ (x : Î±), Ï€ x â‰¤ N) â†’ âˆ« (x : Î±), measure_theory.stopped_value f Ï„ x âˆ‚Î¼ â‰¤ âˆ« (x : Î±), measure_theory.stopped_value f Ï€ x âˆ‚Î¼
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (p q : set Î± â†’ Prop) : Prop
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_5} [topological_space H] {H' : Type u_6} [topological_space H'] {I : model_with_corners ğ•œ E H} {I' : model_with_corners ğ•œ E' H'} {M : Type u_8} [topological_space M] [charted_space H M] {M' : Type u_9} [topological_space M'] [charted_space H' M'] {n : with_top â„•} : function.injective (Î» (h : diffeomorph I I' M M' n) (x : M), â‡‘h x)
{Î± : Type u_1} [decidable_eq Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} {k : â„•} : s âˆˆ finset.shadow^[k] ğ’œ â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), s âŠ† t âˆ§ t.card = s.card + k
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X â†’ Y} (h : holder_with C r f) (hr : 0 < r) (s : set X) : dimH (f '' s) â‰¤ dimH s / â†‘r
(h : name) (t : option expr := option.none) (pr : expr) : smt_tactic unit
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s t : set Î±} [measure_theory.is_finite_measure Î¼] (hms : measurable_set s) (hmt : measurable_set t) : â‡‘(probability_theory.cond Î¼ s) t = (â‡‘Î¼ s)â»Â¹ * â‡‘(probability_theory.cond Î¼ t) s * â‡‘Î¼ t
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (h : 0 < p.radius) : âˆƒ (C r : â„) (hC : 0 < C) (hr : 0 < r), âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C * r ^ n
(s : simp_lemmas) (e : expr) (symm : bool := decidable.to_bool false) : tactic simp_lemmas
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k : â„•} (hk : 0 < k) (hÎ¼ : f.has_eigenvalue Î¼) : f.has_generalized_eigenvalue Î¼ k
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f g : normed_group_hom Vâ‚ Vâ‚‚) : âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) : Prop
{C : Type uâ‚‚} [category_theory.category C] {I : Type uâ‚} {D : Type uâ‚ƒ} [category_theory.category D] (F : I â†’ C) (G : C â¥¤ D) : category_theory.discrete.functor F â‹™ G â‰… category_theory.discrete.functor (G.obj âˆ˜ F)
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€â‚ Ï€â‚‚ : box_integral.tagged_prepartition I) (h : disjoint Ï€â‚.Union Ï€â‚‚.Union) : box_integral.tagged_prepartition I
{R : Type u} {Mâ‚‚ : Type w} {Mâ‚ƒ : Type y} [semiring R] [add_comm_monoid Mâ‚‚] [module R Mâ‚‚] [add_comm_monoid Mâ‚ƒ] [module R Mâ‚ƒ] (f : Mâ‚‚ â†’â‚—[R] Mâ‚ƒ) (I : Type u_1) : (I â†’ Mâ‚‚) â†’â‚—[R] I â†’ Mâ‚ƒ
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [Î¼.is_add_left_invariant] [measure_theory.sigma_finite Î¼] [normed_space â„ E'] [complete_space E'] {f : G â†’ â„} {xâ‚€ : G} {R Îµ : â„} (hÎµ : 0 â‰¤ Îµ) (hf : function.support f âŠ† metric.ball 0 R) (hnf : âˆ€ (x : G), 0 â‰¤ f x) (hintf : âˆ« (x : G), f x âˆ‚Î¼ = 1) (hmg : measure_theory.ae_strongly_measurable g Î¼) (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ R â†’ has_dist.dist (g x) (g xâ‚€) â‰¤ Îµ) : has_dist.dist (convolution f g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) (g xâ‚€) â‰¤ Îµ
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) (m : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
{a b : â„} {f f' : â„ â†’ â„} (hab : a â‰¤ b) (hf : âˆ€ (x : â„), x âˆˆ set.Icc a b â†’ has_deriv_within_at f (f' x) (set.Icc a b) x) {m : â„} (hma : f' a < m) (hmb : m < f' b) : m âˆˆ f' '' set.Icc a b
{Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {Î² : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (Î² i)] {Î³ : Type u_1} [add_monoid Î³] â¦ƒf g : direct_sum Î¹ (Î» (i : Î¹), Î² i) â†’+ Î³â¦„ (H : âˆ€ (i : Î¹) (y : Î² i), â‡‘f (â‡‘(direct_sum.of (Î» (i : Î¹), Î² i) i) y) = â‡‘g (â‡‘(direct_sum.of (Î» (i : Î¹), Î² i) i) y)) : f = g
{Î± : Type u_1} {Ïƒ : Type u_3} (F : cfilter (set Î±) Ïƒ) : filter Î±
{V : Type u_1} {W : Type u_2} [semi_normed_group V] [semi_normed_group W] (f g : normed_group_hom V W) : add_subgroup V
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} [measure_theory.sigma_finite Î¼] {r : ennreal} (hs : measurable_set s) (h's : r < â‡‘Î¼ s) : âˆƒ (t : set Î±), measurable_set t âˆ§ t âŠ† s âˆ§ r < â‡‘Î¼ t âˆ§ â‡‘Î¼ t < âŠ¤
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_finite_measure Î¼] (hg : strict_concave_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ â¨ (x : Î±), g (f x) âˆ‚Î¼ < g (â¨ (x : Î±), f x âˆ‚Î¼)
{Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] (f : measure_theory.simple_func (Î¹ â†’ â„) E) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] (I : box_integral.box Î¹) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l â‡‘f Î¼.to_box_additive.to_smul (measure_theory.simple_func.integral (Î¼.restrict â†‘I) f)
{Î± : Type u_2} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{m : Type â†’ Type u} [applicative m] {elab elab' : bool} (f : expr elab â†’ m (expr elab')) : expr elab â†’ m (expr elab')
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [Î½.is_mul_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.fst, z.fst * z.snd)) (Î¼.prod Î½) = Î¼.prod Î½
{Î± : Type u_1} {n : Type u_4} [decidable_eq n] [has_zero Î±] [has_one Î±] : 1.is_diag
{n : â„•} {A : Type u} (F : A â†’ typevec n â†’ Type u) [Î  (Î± : A), mvfunctor (F Î±)] [Î  (Î± : A), mvqpf (F Î±)] â¦ƒÎ± : typevec nâ¦„ : mvqpf.sigma F Î± â†’ (mvqpf.sigma.P F).obj Î±
{Î± : Type u_1} {E : Type u_4} (ğ•œ : Type u_11) [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [complete_space E] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) : â†¥(measure_theory.Lp E 2 Î¼) â†’L[ğ•œ] â†¥(measure_theory.Lp_meas E ğ•œ m 2 Î¼)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (n : with_top â„•) (f : M â†’ M') (x : M) : Prop
{G : Type u_1} [measurable_space G] [has_add G] (Î¼ : measure_theory.measure G) : Prop
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [normed_field ğ•œ] [normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’â‚›â‚—[Ïƒ] F) (h : âˆƒ (C : â„), âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : E â†’SL[Ïƒ] F
{Î± : Type u_1} {Î¹ : Type u_4} {Î¹' : Type u_5} [normed_ring Î±] [complete_space Î±] {f : Î¹ â†’ Î±} {g : Î¹' â†’ Î±} (hf : summable (Î» (x : Î¹), âˆ¥f xâˆ¥)) (hg : summable (Î» (x : Î¹'), âˆ¥g xâˆ¥)) : (âˆ‘' (x : Î¹), f x) * âˆ‘' (y : Î¹'), g y = âˆ‘' (z : Î¹ Ã— Î¹'), f z.fst * g z.snd
{Î± : Type u_1} (mâ‚€ : measurable_space Î±) {Î¼ Î½ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] (C : set (set Î±)) (hÎ¼Î½ : âˆ€ (s : set Î±), s âˆˆ C â†’ â‡‘Î¼ s = â‡‘Î½ s) {m : measurable_space Î±} (h : m â‰¤ mâ‚€) (hA : m = measurable_space.generate_from C) (hC : is_pi_system C) (h_univ : â‡‘Î¼ set.univ = â‡‘Î½ set.univ) {s : set Î±} (hs : measurable_set s) : â‡‘Î¼ s = â‡‘Î½ s
{M : Type u} [add_monoid M] (u : add_units M) (x : M) : add_semiconj_by â†‘u x (â†‘u + x + â†‘-u)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (f : bounded_continuous_function Î± Î²) (x y : Î±) : has_dist.dist (â‡‘f x) (â‡‘f y) â‰¤ 2 * âˆ¥fâˆ¥
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ hb.oangle x y = 0
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (h_meas : âˆ€ (n : â„•), ae_measurable (f n) Î¼) : âˆ«â» (a : Î±), filter.at_top.liminf (Î» (n : â„•), f n a) âˆ‚Î¼ â‰¤ filter.at_top.liminf (Î» (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (p : submodule R M) (k : â„•) (Î¼ : R) (hfp : âˆ€ (x : M), x âˆˆ p â†’ â‡‘f x âˆˆ p) : â‡‘(module.End.generalized_eigenspace (linear_map.restrict f hfp) Î¼) k = submodule.comap p.subtype (â‡‘(f.generalized_eigenspace Î¼) k)
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {câ‚ câ‚‚ : nnreal} {Îµâ‚ Îµâ‚‚ : â„} {Ï€â‚ Ï€â‚‚ : box_integral.tagged_prepartition I} (h : box_integral.integrable I l f vol) (hposâ‚ : 0 < Îµâ‚) (hposâ‚‚ : 0 < Îµâ‚‚) (hâ‚ : l.mem_base_set I câ‚ (h.convergence_r Îµâ‚ câ‚) Ï€â‚) (hâ‚‚ : l.mem_base_set I câ‚‚ (h.convergence_r Îµâ‚‚ câ‚‚) Ï€â‚‚) (HU : Ï€â‚.Union = Ï€â‚‚.Union) : has_dist.dist (box_integral.integral_sum f vol Ï€â‚) (box_integral.integral_sum f vol Ï€â‚‚) â‰¤ Îµâ‚ + Îµâ‚‚
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {f : Î± â†’ Î²} [topological_space Î±] [opens_measurable_space Î±] [topological_space.pseudo_metrizable_space Î²] [second_countable_topology_either Î± Î²] (hf : continuous f) : measure_theory.ae_strongly_measurable f Î¼
(R : Type u_1) [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] {K : Type u_5} {L : Type u_3} [is_domain R] [is_domain S] [field K] [field L] [algebra R K] [algebra R L] [algebra S L] [is_integral_closure S R L] [is_fraction_ring S L] [algebra K L] [is_scalar_tower R S L] [is_scalar_tower R K L] {a : S} {b : set S} (alg : algebra.is_algebraic R L) (inj : function.injective â‡‘(algebra_map R L)) (h : â†‘(ideal.span {a}) âŠ† â†‘(submodule.span R b)) : â†‘(ideal.span {â‡‘(algebra_map S L) a}) âŠ† â†‘(submodule.span K (â‡‘(algebra_map S L) '' b))
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] {f : Î± Ã— Î² â†’ ennreal} (hf : measurable f) : measurable (Î» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼)
{V : Type u_2} {P : Type u_3} [semi_normed_group V] [pseudo_metric_space P] [normed_add_torsor V P] {W : Type u_4} {Q : Type u_5} [normed_group W] [metric_space Q] [normed_add_torsor W Q] [normed_space â„ V] [normed_space â„ W] (f : P â†’ Q) (h : âˆ€ (x y : P), f (midpoint â„ x y) = midpoint â„ (f x) (f y)) (hfc : continuous f) : P â†’áµƒ[â„] Q
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} (p : ennreal) (Î¼ : measure_theory.measure Î±) [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] [measure_theory.is_finite_measure Î¼] (ğ•œ : Type u_5) [normed_field ğ•œ] [normed_space ğ•œ E] [fact (1 â‰¤ p)] : bounded_continuous_function Î± E â†’L[ğ•œ] â†¥(measure_theory.Lp E p Î¼)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M â†’ M') (s : set M) (x : M) (f' : tangent_space I x â†’L[ğ•œ] tangent_space I' (f x)) : Prop
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p âˆˆ s) : â†‘(s.direction) = (Î» (_x : P), _x -áµ¥ p) '' â†‘s
{E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y : E} : Â¬same_ray â„ x y â†” âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{Î¹ : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Î¹ â†’ E} (hf : summable (Î» (i : Î¹), âˆ¥f iâˆ¥)) : âˆ¥âˆ‘' (i : Î¹), f iâˆ¥ â‰¤ âˆ‘' (i : Î¹), âˆ¥f iâˆ¥
(R : Type u) [semiring R] {Î¹ : Type v} {Î± : Î¹ â†’ Type u_1} {Î´ : Î  (i : Î¹), Î± i â†’ Type w} [Î  (i : Î¹) (j : Î± i), add_comm_monoid (Î´ i j)] [Î  (i : Î¹) (j : Î± i), module R (Î´ i j)] : direct_sum (Î£ (i : Î¹), Î± i) (Î» (i : Î£ (i : Î¹), Î± i), Î´ i.fst i.snd) â‰ƒâ‚—[R] direct_sum Î¹ (Î» (i : Î¹), direct_sum (Î± i) (Î» (j : Î± i), Î´ i j))
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_addâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] {E : set G} [has_measurable_neg G] [Î¼.is_add_left_invariant] [Î½.is_add_left_invariant] (hE : measurable_set E) (h2E : â‡‘Î½ E â‰  0) (h3E : â‡‘Î½ E â‰  âŠ¤) : Î¼ = (â‡‘Î¼ E / â‡‘Î½ E) â€¢ Î½
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) : Prop
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] {s : set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hb : metric.bounded s) (hc : âˆ€ (f : E' â†’SL[Ïƒâ‚â‚‚] F), â‡‘f âˆˆ closure (coe_fn '' s) â†’ f âˆˆ s) : is_closed (coe_fn '' s)
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (Ï† : L.hom M N) (S : L.substructure N) : L.substructure M
{n : â„•} (Î± : typevec n) {Î² : Type u_1} (p : Î² â†’ Prop) â¦ƒi : fin2 (n + 1)â¦„ : (Î± ::: Î²) i â†’ Prop
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : has_inner.inner x y = (â†‘âˆ¥x + yâˆ¥ ^ 2 - â†‘âˆ¥x - yâˆ¥ ^ 2 + (â†‘âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ ^ 2 - â†‘âˆ¥x + is_R_or_C.I â€¢ yâˆ¥ ^ 2) * is_R_or_C.I) / 4
(nondep : bool) : expr â†’ list name â†’ (option (option expr) := option.none) â†’ tactic unit
{R : Type u} {S : Type v} [comm_semiring R] [local_ring R] [comm_semiring S] [local_ring S] (f : R â†’+* S) : [is_local_ring_hom f, â‡‘f '' (local_ring.maximal_ideal R).carrier âŠ† â†‘(local_ring.maximal_ideal S), ideal.map f (local_ring.maximal_ideal R) â‰¤ local_ring.maximal_ideal S, local_ring.maximal_ideal R â‰¤ ideal.comap f (local_ring.maximal_ideal S), ideal.comap f (local_ring.maximal_ideal S) = local_ring.maximal_ideal R].tfae
{Î¹ : Type u_1} [fintype Î¹] (s : finset (box_integral.box Î¹)) : âˆ€á¶  (t : finset (Î¹ Ã— â„)) in filter.at_top, âˆ€ (I J : box_integral.box Î¹), J âˆˆ s â†’ âˆ€ (J' : box_integral.box Î¹), J' âˆˆ box_integral.prepartition.split_many I t â†’ Â¬disjoint â†‘J â†‘J' â†’ J' â‰¤ J
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {E : Type uâ‚ƒ} [category_theory.category E] {F G : C â¥¤ D} {H I : D â¥¤ E} (Î± : F âŸ¶ G) (Î² : H âŸ¶ I) : F â‹™ H âŸ¶ G â‹™ I
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) {r : ennreal} (hr : r < â‡‘Î¼ A) : âˆƒ (K : set Î±) (H : K âŠ† A), is_compact K âˆ§ r < â‡‘Î¼ K
(hs : interactive.parse tactic.simp_arg_list) (ps : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.pexpr_list_or_texpr))) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
(p : pexpr) (e : expr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (n : with_top â„•) (f : M â†’ M') (s : set M) (x : M) : Prop
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), (f - g) (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
{Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (hd : directed has_subset.subset s) : â‡‘Î¼ (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), â‡‘Î¼ (s i)
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {ğ’¢ : measure_theory.filtration â„• m0} [measure_theory.sigma_finite_filtration Î¼ ğ’¢] {f : â„• â†’ Î± â†’ â„} (hf : measure_theory.submartingale f ğ’¢ Î¼) {Ï„ Ï€ : Î± â†’ â„•} (hÏ„ : measure_theory.is_stopping_time ğ’¢ Ï„) (hÏ€ : measure_theory.is_stopping_time ğ’¢ Ï€) (hle : Ï„ â‰¤ Ï€) {N : â„•} (hbdd : âˆ€ (x : Î±), Ï€ x â‰¤ N) : âˆ« (x : Î±), measure_theory.stopped_value f Ï„ x âˆ‚Î¼ â‰¤ âˆ« (x : Î±), measure_theory.stopped_value f Ï€ x âˆ‚Î¼
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) {s : set Î¹} {i : Î¹} (hi : i âˆˆ s) : vector_span k (p '' s) = submodule.span k ((Î» (_x : P), _x -áµ¥ p i) '' (p '' (s  {i})))
{C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] {D : Type uâ‚‚} [category_theory.category D] [category_theory.limits.has_zero_object D] [category_theory.has_shift D â„¤] [category_theory.preadditive D] [âˆ€ (n : â„¤), (category_theory.shift_functor D n).additive] [category_theory.triangulated.pretriangulated C] [category_theory.triangulated.pretriangulated D] (F : category_theory.triangulated.pretriangulated.triangulated_functor C D) (T : category_theory.triangulated.triangle C) (h : T âˆˆ dist_triang C) : F.map_triangle.obj T âˆˆ dist_triang D
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k : â„•} (hk : 0 < k) : f.has_generalized_eigenvalue Î¼ k â†” f.has_eigenvalue Î¼
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) {W X Y : C} (f : W âŸ¶ X) (g : W âŸ¶ Y) [category_theory.limits.preserves_colimit (category_theory.limits.span f g) G] [category_theory.limits.has_pushout f g] [category_theory.limits.has_pushout (G.map f) (G.map g)] : category_theory.limits.pushout (G.map f) (G.map g) â‰… G.obj (category_theory.limits.pushout f g)
(V W : SemiNormedGroup) : (V âŸ¶ W) â†’+ (SemiNormedGroup.Completion.obj V âŸ¶ SemiNormedGroup.Completion.obj W)
{F : Type u_3} [inner_product_space â„ F] (x y : F) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” has_inner.inner x y = 0
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) (G : Type u_4) [has_add G] [topological_space G] [charted_space H G] : Prop
{Î± : Type u_1} {Ïƒ : Type u_3} {Ï„ : Type u_4} [partial_order Î±] (E : Ïƒ â‰ƒ Ï„) : cfilter Î± Ïƒ â†’ cfilter Î± Ï„
(n : with_top â„•) {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) : structure_groupoid H
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} {f : G â†’ E} {g : G} [add_group G] [has_measurable_add G] [Î¼.is_add_right_invariant] (hf' : âˆ€ (x : G), f (x + g) = -f x) : âˆ« (x : G), f x âˆ‚Î¼ = 0
{M : Type u_1} {Ïƒ : Type u_4} [has_mul M] {N : Type u_2} [has_mul N] [set_like Ïƒ M] [mul_mem_class Ïƒ M] (f : M â†’â‚™* N) (S : Ïƒ) : â†¥S â†’â‚™* N
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) : âˆ¥fâˆ¥ = 0 â†” f = 0
{R : Type u_17} {S : Type u_18} [semiring R] [semiring S] {Ïƒ : R â†’+* S} {M : Type u_19} {Mâ‚‚ : Type u_20} [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module S Mâ‚‚] (self : M â†’â‚›â‚—[Ïƒ] Mâ‚‚) : add_hom M Mâ‚‚
(red : interactive.parse (optional (lean.parser.tk "!"))) (restr : interactive.parse (optional (lean.parser.tk "only"))) (hyps : interactive.parse (optional interactive.types.pexpr_list)) (cfg : linarith.linarith_config := {discharger := has_bind.seq (tactic.save_info {line := 312, column := 31}) (tactic.interactive.ring option.none).step, restrict_type := option.none Type, restrict_type_reflect := `(option.none Type), exfalso := bool.tt, transparency := tactic.transparency.reducible, split_hypotheses := bool.tt, split_ne := bool.ff, preprocessors := option.none (list linarith.global_branching_preprocessor), oracle := option.none linarith.certificate_oracle}) : tactic unit
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} (Î¼ : measure_theory.measure Î±) [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] [compact_space Î±] [measure_theory.is_finite_measure Î¼] {ğ•œ : Type u_5} [fact (1 â‰¤ p)] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] : âˆ¥continuous_map.to_Lp p Î¼ ğ•œâˆ¥ â‰¤ â†‘(measure_theory.measure_univ_nnreal Î¼) ^ (p.to_real)â»Â¹
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : âˆ¥0âˆ¥ = 0
{Î± : Type u} {Î² : Type v} (R : Type u_1) [semiring R] (e : Î± â‰ƒ Î²) [add_comm_monoid Î²] : let _inst : add_comm_monoid Î± := e.add_comm_monoid in Î  [_inst_3 : module R Î²], module R Î±
(R : Type u) [semiring R] {Î¹ : Type v} {Î± : Î¹ â†’ Type u_1} {Î´ : Î  (i : Î¹), Î± i â†’ Type w} [Î  (i : Î¹) (j : Î± i), add_comm_monoid (Î´ i j)] [Î  (i : Î¹) (j : Î± i), module R (Î´ i j)] : direct_sum Î¹ (Î» (i : Î¹), direct_sum (Î± i) (Î» (j : Î± i), Î´ i j)) â†’â‚—[R] direct_sum (Î£ (i : Î¹), Î± i) (Î» (i : Î£ (i : Î¹), Î± i), Î´ i.fst i.snd)
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (C : â„) {r : nnreal} (h : âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C) : â†‘r â‰¤ p.radius
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] {f : Î± â†’ Î² â†’ E} (hf : measure_theory.integrable (function.uncurry f) (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (z : Î± Ã— Î²), f z.fst z.snd âˆ‚Î¼.prod Î½
{C : Type u} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] [category_theory.limits.has_coequalizers C] [category_theory.limits.has_finite_coproducts C] (G : C â¥¤ D) [category_theory.limits.preserves_colimits_of_shape category_theory.limits.walking_parallel_pair G] [Î  (J : Type v) [_inst_8 : fintype J], category_theory.limits.preserves_colimits_of_shape (category_theory.discrete J) G] : category_theory.limits.preserves_finite_colimits G
{M : Type u} [add_monoid M] {a : M} {x y : add_units M} (h : add_semiconj_by a â†‘x â†‘y) : add_semiconj_by a (â†‘-x) (â†‘-y)
{Î¹ : Type u_1} (I J : box_integral.box Î¹) (h : I â‰¤ J) : box_integral.tagged_prepartition I â†ª box_integral.tagged_prepartition J
{Î± : Type u} [semiring Î±] (I : ideal Î±) : Prop
{Î¹ : Type u_1} [fintype Î¹] {I : box_integral.box Î¹} (r : (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)) (Ï€ : box_integral.prepartition I) : âˆƒ (Ï€' : box_integral.tagged_prepartition I), Ï€'.to_prepartition â‰¤ Ï€ âˆ§ Ï€'.is_Henstock âˆ§ Ï€'.is_subordinate r âˆ§ Ï€'.distortion = Ï€.distortion âˆ§ Ï€'.Union = Ï€.Union
{Î± : Type u_1} {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} (hm : m â‰¤ m0) {f g : Î± â†’ â„} (hf : measure_theory.strongly_measurable f) (hfi : measure_theory.integrable_on f s Î¼) (hg : measure_theory.strongly_measurable g) (hgi : measure_theory.integrable_on g s Î¼) (hgf : âˆ€ (t : set Î±), measurable_set t â†’ â‡‘Î¼ t < âŠ¤ â†’ âˆ« (x : Î±) in t, g x âˆ‚Î¼ = âˆ« (x : Î±) in t, f x âˆ‚Î¼) (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) : âˆ« (x : Î±) in s, âˆ¥g xâˆ¥ âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, âˆ¥f xâˆ¥ âˆ‚Î¼
{C : Type u_1} [category_theory.category C] (r : hom_rel C) â¦ƒs t : Câ¦„ : (s âŸ¶ t) â†’ (s âŸ¶ t) â†’ Prop
(Ïƒ : out_param (Type u)) (m : Type u â†’ Type v) : Type (max (u+1) v)
{Î± : Type u} [pseudo_metric_space Î±] (s : set (uniform_space.completion Î± Ã— uniform_space.completion Î±)) : s âˆˆ uniformity (uniform_space.completion Î±) â†” âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ {a b : uniform_space.completion Î±}, has_dist.dist a b < Îµ â†’ (a, b) âˆˆ s
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : set Î±) (H : set.inj_on f s) : â†¥s â‰ƒ â†¥(f '' s)
{ğ•œ : Type u_1} {A : Type u_2} [comm_semiring ğ•œ] [topological_space ğ•œ] [has_continuous_add ğ•œ] [has_continuous_const_smul ğ•œ ğ•œ] [non_unital_non_assoc_semiring A] [topological_space A] [module ğ•œ A] (Ï† : â†¥(weak_dual.character_space ğ•œ A)) : A â†’L[ğ•œ] ğ•œ
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] {s : set E} {x' : normed_space.dual ğ•œ E} {c : ğ•œ} (hc : âˆ€ (z : E), z âˆˆ s â†’ âˆ¥â‡‘x' zâˆ¥ â‰¤ âˆ¥câˆ¥) : câ»Â¹ â€¢ x' âˆˆ normed_space.polar ğ•œ s
{C : Type u} [category_theory.category C] {I : category_theory.limits.multicospan_index C} (K : category_theory.limits.multifork I) (a : I.L) : K.X âŸ¶ I.left a
(I : Type u_1) {R : Type u_2} (A : Type u_3) [comm_semiring R] [ring A] [algebra R A] : algebra R (I â†’ A)
{Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_metric_space (Ï€ b)] : pseudo_metric_space (Î  (b : Î²), Ï€ b)
{R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [nontrivial R] {m : M} {S : set M} (h : â‡‘(monoid_algebra.of R M) m âˆˆ submodule.span R â†‘(submonoid.closure (â‡‘(monoid_algebra.of R M) '' S))) : m âˆˆ submonoid.closure S
{R : Type u_1} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (h : is_primitive_root Î¶ n) : (polynomial.cyclotomic' n R).degree = â†‘(n.totient)
{Î± : Type u_1} [preorder Î±] {f : Î± â†’ Î±} {x : Î±} (hf : monotone f) (hx : x â‰¤ f x) : monotone (Î» (n : â„•), f^[n] x)
{Î± : Type u_1} {f : Î± â†’ ennreal} {Mf mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hMf : Mf â‰¤ mÎ±) (c : ennreal) {T : set Î±} (h_meas_T : measurable_set T) (h_ind : probability_theory.indep_sets {s : set Î± | measurable_set s} {T} Î¼) (h_meas_f : measurable f) : âˆ«â» (a : Î±), f a * T.indicator (Î» (_x : Î±), c) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), T.indicator (Î» (_x : Î±), c) a âˆ‚Î¼
(s : simp_lemmas) (id : name) (symm : bool := decidable.to_bool false) : tactic simp_lemmas
{X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra â„ C(X, â„)) (f : â†¥A) (g : polynomial â„) : (g.to_continuous_map_on (set.Icc (-âˆ¥fâˆ¥) âˆ¥fâˆ¥)).comp â†‘f.attach_bound âˆˆ A
{Î± : Type u_1} (F : Type u_6) (ğ•œ : Type u_11) (p : ennreal) [is_R_or_C ğ•œ] [normed_group F] [normed_space ğ•œ F] {m m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [hp : fact (1 â‰¤ p)] : â†¥(measure_theory.Lp_meas_subgroup F m p Î¼) â‰ƒáµ¢ â†¥(measure_theory.Lp_meas F ğ•œ m p Î¼)
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î²] (f : Î± â†’ Î²) (l : filter Î±) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{c : Type u â†’ Type u} {hom : Î  â¦ƒÎ± Î² : Type uâ¦„, c Î± â†’ c Î² â†’ (Î± â†’ Î²) â†’ Prop} [ğ’ : category_theory.unbundled_hom hom] {c' : Type u â†’ Type u} {hom' : Î  â¦ƒÎ± Î² : Type uâ¦„, c' Î± â†’ c' Î² â†’ (Î± â†’ Î²) â†’ Prop} [ğ’' : category_theory.unbundled_hom hom'] (obj : Î  â¦ƒÎ± : Type uâ¦„, c Î± â†’ c' Î±) (map : âˆ€ â¦ƒÎ± Î² : Type uâ¦„ â¦ƒIÎ± : c Î±â¦„ â¦ƒIÎ² : c Î²â¦„ â¦ƒf : Î± â†’ Î²â¦„, hom IÎ± IÎ² f â†’ hom' (obj IÎ±) (obj IÎ²) f) : category_theory.has_forgetâ‚‚ (category_theory.bundled c) (category_theory.bundled c')
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : â‡‘(hb.rotation (hb.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {E'' : Type u_8} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_9} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_10} [topological_space M''] [charted_space H'' M''] {f : M â†’ M'} (x : M) {g : M' â†’ M''} [Is : smooth_manifold_with_corners I M] [I's : smooth_manifold_with_corners I' M'] [I''s : smooth_manifold_with_corners I'' M''] {f' : tangent_space I x â†’L[ğ•œ] tangent_space I' (f x)} {g' : tangent_space I' (f x) â†’L[ğ•œ] tangent_space I'' (g (f x))} (hg : has_mfderiv_at I' I'' g (f x) g') (hf : has_mfderiv_at I I' f x f') : has_mfderiv_at I I'' (g âˆ˜ f) x (g'.comp f')
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} [inhabited Î›] {Ïƒ : Type u_4} [inhabited Ïƒ] : turing.TM2.stmt Î“ Î› Ïƒ â†’ turing.TM1.stmt turing.TM2to1.Î“' turing.TM2to1.Î›' Ïƒ
{R : Type u_1} [comm_ring R] (I : ideal R) : topological_space R
{E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : âˆ¥f aâˆ¥ â‰¤ B a) (hB : âˆ€ (x : â„), has_deriv_at B (B' x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] {n : â„•} {enc : Î“ â†’ vector bool n} (enc0 : enc inhabited.default = vector.repeat bool.ff n) : turing.TM1.cfg Î“ Î› Ïƒ â†’ turing.TM1.cfg bool turing.TM1to1.Î›' Ïƒ
{R : Type u_1} [comm_ring R] {K : Type u_3} [field K] [algebra R K] [is_fraction_ring R K] {I : fractional_ideal (non_zero_divisors R) K} [nontrivial R] (hI : I â‰  0) : âˆƒ (x : R) (H : x â‰  0), â‡‘(algebra_map R K) x âˆˆ I
{Ïƒ : Type u_1} (R : Type u) [comm_semiring R] (s : set Ïƒ) : subalgebra R (mv_polynomial Ïƒ R)
{V : Type u} [fintype V] [decidable_eq V] {G : simple_graph V} [decidable_rel G.adj] {n k â„“ Î¼ : â„•} {v w : V} (h : G.is_SRG_with n k â„“ Î¼) (hne : v â‰  w) (ha : Â¬G.adj v w) : (G.neighbor_finset v âˆª G.neighbor_finset w).card = 2 * k - Î¼
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] [locally_compact_space G] [t2_space G] (hcg : has_compact_support g) (hf : measure_theory.locally_integrable f Î¼) (hg : continuous g) : continuous (convolution f g L Î¼)
{I : Type u} [decidable_eq I] {Î² : Type u_1} [has_zero Î²] (i : I) (x : Î²) (i' : I) : pi.single i x i' = ite (i' = i) x 0
{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : |v - (generalized_continued_fraction.of v).convergents n| â‰¤ 1 / (b * (generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators n)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {F : Type u_8} [normed_group F] [normed_space ğ•œ F] {G : Type u_9} [topological_space G] {J : model_with_corners ğ•œ F G} {N : Type u_10} [topological_space N] [charted_space G N] {F' : Type u_11} [normed_group F'] [normed_space ğ•œ F'] {G' : Type u_12} [topological_space G'] {J' : model_with_corners ğ•œ F' G'} {N' : Type u_13} [topological_space N'] [charted_space G' N'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {g : N â†’ N'} {r : set N} {p : M Ã— N} (hf : cont_mdiff_within_at I I' n f s p.fst) (hg : cont_mdiff_within_at J J' n g r p.snd) : cont_mdiff_within_at (I.prod J) (I'.prod J') n (prod.map f g) (s Ã—Ë¢ r) p
{G : Type u} [group G] {H : Type v} [group H] (Ï† : G â†’* H) : G â§¸ Ï†.ker â‰ƒ* â†¥(Ï†.range)
(md : tactic.transparency := tactic.transparency.semireducible) : â„• â†’ expr â†’ tactic (â„• Ã— expr)
 : 1.factor_multiset = 0
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {R : Type u_2} {S : Type u_3} [comm_ring R] [is_domain R] [comm_semiring S] [algebra S (polynomial K)] [algebra S (polynomial R)] (Ï† : polynomial K â†’â‚[S] polynomial R) (hÏ† : non_zero_divisors (polynomial K) â‰¤ submonoid.comap â†‘Ï† (non_zero_divisors (polynomial R))) : ratfunc K â†’â‚[S] ratfunc R
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) : Prop
{n : â„•} {A : Type u} (F : A â†’ typevec n â†’ Type u) [Î  (Î± : A), mvfunctor (F Î±)] [Î  (Î± : A), mvqpf (F Î±)] â¦ƒÎ± : typevec nâ¦„ : mvqpf.pi F Î± â†’ (mvqpf.pi.P F).obj Î±
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] (f : Î± Ã— Î² â†’ E) (hf : measure_theory.integrable f (Î¼.prod Î½)) : âˆ« (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ« (y : Î²), âˆ« (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : chain_complex V â„•} (e : P âŸ¶ Q) (zero : P.X 0 âŸ¶ Q.X 1) (comm_zero : e.f 0 = zero â‰« Q.d 1 0) (one : P.X 1 âŸ¶ Q.X 2) (comm_one : e.f 1 = P.d 1 0 â‰« zero + one â‰« Q.d 2 1) (succ : Î  (n : â„•) (p : Î£' (f : P.X n âŸ¶ Q.X (n + 1)) (f' : P.X (n + 1) âŸ¶ Q.X (n + 2)), e.f (n + 1) = P.d (n + 1) n â‰« f + f' â‰« Q.d (n + 2) (n + 1)), Î£' (f'' : P.X (n + 2) âŸ¶ Q.X (n + 3)), e.f (n + 2) = P.d (n + 2) (n + 1) â‰« p.snd.fst + f'' â‰« Q.d (n + 3) (n + 2)) [category_theory.limits.has_zero_object V] (n : â„•) : Î£' (f : homological_complex.X_next P n âŸ¶ Q.X n) (f' : P.X n âŸ¶ homological_complex.X_prev Q n), e.f n = homological_complex.d_from P n â‰« f + f' â‰« homological_complex.d_to Q n
{G : Type u_1} [measurable_space G] [has_add G] (Î¼ : measure_theory.measure G) : Prop
{S : Type v} {Ïƒ : Type u_1} [comm_ring S] : (mv_polynomial Ïƒ â„¤ â†’+* S) â‰ƒ (Ïƒ â†’ S)
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : f' =o[l] g â†’ (Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] g
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {D : Type uâ‚‚} [category_theory.category D] (F : Î  (i : I), C i â¥¤ D) (X Y : Î£ (i : I), C i) : (X âŸ¶ Y) â†’ ((F X.fst).obj X.snd âŸ¶ (F Y.fst).obj Y.snd)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {p : Î¹ â†’ P} (ha : affine_independent k p) {s1 s2 : set Î¹} {p0 : P} (hp0s1 : p0 âˆˆ affine_span k (p '' s1)) (hp0s2 : p0 âˆˆ affine_span k (p '' s2)) : âˆƒ (i : Î¹), i âˆˆ s1 âˆ© s2
{R : Type u} [ring R] â¦ƒs t : set Râ¦„ (h : s âŠ† t) : subring.closure s â‰¤ subring.closure t
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ linear_order.max C 0
{Î³ : Type w} [emetric_space Î³] : uniformity Î³ = â¨… (Îµ : ennreal) (H : Îµ > 0), filter.principal {p : Î³ Ã— Î³ | has_edist.edist p.fst p.snd < Îµ}
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : continuous (tangent_bundle.proj I M)
(slow : bool := bool.tt) (verbose : lint_verbosity := lint_verbosity.medium) (extra : list name := list.nil) (use_only : bool := bool.ff) : tactic (name_set Ã— format)
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (I : ideal R) (hp : I.is_prime) (hd : disjoint â†‘M â†‘I) : (ideal.map (algebra_map R S) I).is_prime
{I : Type wâ‚€} (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] {J : Type wâ‚} (h : J â†’ I) : (Î  (i : I), C i) â¥¤ Î  (j : J), C (h j)
{E : Type u_1} [normed_group E] [measurable_space E] [normed_space â„ E] [finite_dimensional â„ E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 0)) (t : set E) (ht : measurable_set t) (h''t : â‡‘Î¼ t â‰  âŠ¤) : filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© ({x} + r â€¢ t)) / â‡‘Î¼ ({x} + r â€¢ t)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
{Î± : Type u_1} {Î¹ : Type u_2} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) (l : filter Î¹) (Ï† : Î¹ â†’ set Î±) : Prop
{F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner (x + y) (x - y) = 0 â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{Î± : Type u_1} {E : Type u_2} (ğ•œ : Type u_4) [normed_group E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_space â„ E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [smul_comm_class â„ ğ•œ E] [complete_space E] : â†¥(measure_theory.Lp E 1 Î¼) â†’L[ğ•œ] E
{Î± : Type u_1} {Î² : Type u_2} (S : set Î±) (f : Î± â‰ƒ Î²) : â‡‘f '' S = â‡‘(f.symm) â»Â¹' S
(R : Type u) {Î¹ : Type x} [semiring R] (Ï† : Î¹ â†’ Type i) [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] {I J : set Î¹} [decidable_pred (Î» (i : Î¹), i âˆˆ I)] (hd : disjoint I J) (hu : set.univ âŠ† I âˆª J) : (â†¥â¨… (i : Î¹) (H : i âˆˆ J), (linear_map.proj i).ker) â‰ƒâ‚—[R] Î  (i : â†¥I), Ï† â†‘i
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] {E' : Type u_7} [normed_group E'] [complete_space E'] [normed_space â„ E'] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ E') (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) + g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ + âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
{M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] â¦ƒf g : M â†’* Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
{C : Type u} [category_theory.category C] {W X Y Z S T : C} (fâ‚ : S âŸ¶ W) (fâ‚‚ : S âŸ¶ X) [category_theory.limits.has_pushout fâ‚ fâ‚‚] (gâ‚ : T âŸ¶ Y) (gâ‚‚ : T âŸ¶ Z) [category_theory.limits.has_pushout gâ‚ gâ‚‚] (iâ‚ : W âŸ¶ Y) (iâ‚‚ : X âŸ¶ Z) (iâ‚ƒ : S âŸ¶ T) (eqâ‚ : fâ‚ â‰« iâ‚ = iâ‚ƒ â‰« gâ‚) (eqâ‚‚ : fâ‚‚ â‰« iâ‚‚ = iâ‚ƒ â‰« gâ‚‚) : category_theory.limits.pushout fâ‚ fâ‚‚ âŸ¶ category_theory.limits.pushout gâ‚ gâ‚‚
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M â†’+ N} (h : âˆ€ (y : â†¥S), is_add_unit (â‡‘f â†‘y)) (y : â†¥S) (w z : N) : w + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y = z â†” w = â‡‘f â†‘y + z
{Î¹â‚ : Sort u_1} {Î¹â‚‚ : Sort u_2} {Îºâ‚ : Î¹â‚ â†’ Sort u_3} {Îºâ‚‚ : Î¹â‚‚ â†’ Sort u_4} {Ï† : Î  (iâ‚ : Î¹â‚), Îºâ‚ iâ‚ â†’ Î  (iâ‚‚ : Î¹â‚‚), Îºâ‚‚ iâ‚‚ â†’ Sort u_5} (f : Î  (iâ‚ : Î¹â‚) (jâ‚ : Îºâ‚ iâ‚) (iâ‚‚ : Î¹â‚‚) (jâ‚‚ : Îºâ‚‚ iâ‚‚), Ï† iâ‚ jâ‚ iâ‚‚ jâ‚‚) (iâ‚‚ : Î¹â‚‚) (jâ‚‚ : Îºâ‚‚ iâ‚‚) (iâ‚ : Î¹â‚) (jâ‚ : Îºâ‚ iâ‚) : Ï† iâ‚ jâ‚ iâ‚‚ jâ‚‚
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {y : F} (a : â„) (h : âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (r : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)), (âˆ€ (c : nnreal), l.r_cond (r c)) âˆ§ âˆ€ (c : nnreal) (Ï€ : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) Ï€ â†’ Ï€.is_partition â†’ has_dist.dist (box_integral.integral_sum f vol Ï€) y â‰¤ a * Îµ)) : box_integral.has_integral I l f vol y
{Ïƒ : Type u_1} {R : Type u_4} [comm_semiring R] (p : mv_polynomial Ïƒ R) : âˆƒ (n : â„•) (f : fin n â†’ Ïƒ) (hf : function.injective f) (q : mv_polynomial (fin n) R), p = â‡‘(mv_polynomial.rename f) q
{ğ•œ : Type u_1} {n : Type u_3} [is_R_or_C ğ•œ] [fintype n] [decidable_eq n] {U : matrix n n ğ•œ} (hU : U âˆˆ matrix.unitary_group n ğ•œ) : âˆ¥Uâˆ¥ â‰¤ 1
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [borel_space Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (H : Î¼.inner_regular is_closed is_open) : Î¼.weakly_regular
{Î± : Type u_1} {Î¹ : Type u_2} [measurable_space Î±] {Î² : Î¹ â†’ Type u_3} (m : Î  (x : Î¹), measurable_space (Î² x)) (f : Î  (x : Î¹), Î± â†’ Î² x) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {F : â„• â†’ Î± â†’ ennreal} {f : Î± â†’ ennreal} (bound : Î± â†’ ennreal) (hF_meas : âˆ€ (n : â„•), measurable (F n)) (h_bound : âˆ€ (n : â„•), F n â‰¤áµ[Î¼] bound) (h_fin : âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), F n a) filter.at_top (nhds (f a))) : filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
{G : Type u} [add_group G] {H : Type v} [add_group H] (Ï† : G â†’+ H) (Ïˆ : H â†’ G) (hÏ† : function.right_inverse Ïˆ â‡‘Ï†) : G â§¸ Ï†.ker â‰ƒ+ H
{C : Type v} {D : Type v'} [category_theory.category C] [category_theory.concrete_category C] [category_theory.category D] [category_theory.concrete_category D] (obj : C â†’ D) (h_obj : âˆ€ (X : C), (category_theory.forget D).obj (obj X) = (category_theory.forget C).obj X) (map : Î  {X Y : C}, (X âŸ¶ Y) â†’ (obj X âŸ¶ obj Y)) (h_map : âˆ€ {X Y : C} {f : X âŸ¶ Y}, (category_theory.forget D).map (map f) == (category_theory.forget C).map f) : category_theory.has_forgetâ‚‚ C D
{E : Type u_1} [semi_normed_group E] [normed_space â„ E] {x y : E} (h : same_ray â„ x y) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {x : M} : algebra (pointed_smooth_map ğ•œ I M âŠ¤ x) ğ•œ
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} (hf : has_fpower_series_at f p x) : (Î» (y : E Ã— E), f y.fst - f y.snd - â‡‘(p 1) (Î» (_x : fin 1), y.fst - y.snd)) =O[nhds (x, x)] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.sndâˆ¥
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} [add_group G] [has_measurable_add G] [Î¼.is_add_right_invariant] (f : G â†’ E) (g : G) : âˆ« (x : G), f (x + g) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : Î± â†’ ennreal) : âˆƒ (g : Î± â†’ ennreal), measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼
{G : Type u} [group G] {H : Type v} [group H] (Ï† : G â†’* H) : G â§¸ Ï†.ker â†’* â†¥(Ï†.range)
(f : expr) (nargs : option â„• := option.none) (md : tactic.transparency := tactic.transparency.semireducible) : tactic congr_lemma
{G : Type u} [add_group G] {H : Type v} [add_group H] (Ï† : G â†’+ H) : G â§¸ Ï†.ker â‰ƒ+ â†¥(Ï†.range)
{C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (G : D â¥¤ C) [category_theory.is_right_adjoint G] [category_theory.limits.has_reflexive_coequalizers D] [category_theory.reflects_isomorphisms G] [Î  â¦ƒA B : Dâ¦„ (f g : A âŸ¶ B) [_inst_7 : category_theory.is_reflexive_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G] : category_theory.monadic_right_adjoint G
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : â†‘r' < r) : âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (y : E), y âˆˆ metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥f (x + y) - p.partial_sum n yâˆ¥ â‰¤ C * a ^ n
{Î± : Type u} [pseudo_emetric_space Î±] {Î´ : â„} (Îµ : â„) (hÎ´ : 0 â‰¤ Î´) (s : set Î±) : metric.thickening Îµ (metric.cthickening Î´ s) âŠ† metric.thickening (Îµ + Î´) s
{G : Type u} [group G] [fintype G] (hn : âˆ€ {p : â„•} [_inst_3 : fact (nat.prime p)] (P : sylow p G), â†‘P.normal) : (Î  (p : â†¥((fintype.card G).factorization.support)) (P : sylow â†‘p G), â†¥â†‘P) â‰ƒ* G
{Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (hÎ¼Î½ : â‡‘Î¼ set.univ = â‡‘Î½ set.univ) (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ico a b) = â‡‘Î½ (set.Ico a b)) : Î¼ = Î½
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} {Ïƒ : Type u_4} (M : Î› â†’ turing.TM2.stmt Î“ Î› Ïƒ) : turing.TM2.cfg Î“ Î› Ïƒ â†’ turing.TM2.cfg Î“ Î› Ïƒ â†’ Prop
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : â‡‘(o.rotation (o.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{R : Type u_1} [comm_semiring R] (I : ideal R) [hp : I.is_prime] : local_ring (localization I.prime_compl)
{Î± : Type u} {Î² : Type v} (e : Î± â‰ƒ Î²) [has_add Î²] [has_mul Î²] : let _inst : has_add Î± := e.has_add, _inst_3 : has_mul Î± := e.has_mul in Î± â‰ƒ+* Î²
{Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {f : Î± â†’ E} : summable (Î» (x : Î±), âˆ¥f xâˆ¥) â†” summable f
{R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [comm_semiring R] [add_comm_monoid M] [module R M] [decidable_eq Î¹] (e : Î¹ â†’ M) (Îµ : Î¹ â†’ module.dual R M) : Type (max u_2 u_3)
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} (f : Î± â†’â‚˜[Î¼] ennreal) : ennreal
{R : Type u} [ring R] {Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type v) [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [decidable_eq Î¹] : category_theory.limits.cocone (Module.direct_limit_diagram G f)
(h : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic congr_lemma
{n : â„•} {K : Type u_1} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) (hpos : 0 < n) [char_zero K] : minpoly â„¤ Î¼ âˆ£ polynomial.cyclotomic n â„¤
{Ïƒ : Type u_1} {R : Type u_2} [comm_semiring R] (A : Type u_3) [comm_semiring A] [algebra R A] : mv_polynomial Ïƒ R â†’â‚[R] mv_power_series Ïƒ A
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} (p : ennreal) (Î¼ : measure_theory.measure Î±) [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] [compact_space Î±] [measure_theory.is_finite_measure Î¼] (ğ•œ : Type u_5) [fact (1 â‰¤ p)] [normed_field ğ•œ] [normed_space ğ•œ E] : C(Î±, E) â†’L[ğ•œ] â†¥(measure_theory.Lp E p Î¼)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (Î¼ : R) (k : â„•) : Prop
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r r' : ennreal} (hf : has_fpower_series_on_ball f p x r) (hr : r' < r) : (Î» (y : E Ã— E), f y.fst - f y.snd - â‡‘(p 1) (Î» (_x : fin 1), y.fst - y.snd)) =O[filter.principal (emetric.ball (x, x) r')] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.sndâˆ¥
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] (f : Î± â†’ E) (l : filter Î±) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {F : Type u_5} [normed_group F] [normed_space ğ•œ F] (Z : basic_smooth_vector_bundle_core I M F) : smooth_manifold_with_corners (I.prod (model_with_corners_self ğ•œ F)) Z.to_topological_vector_bundle_core.total_space
{L : first_order.language} {Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [is_directed Î¹ has_le.le] : Type (max v w)
(use_iota_eqn : interactive.parse (optional (lean.parser.tk "!"))) (trace_lemmas : interactive.parse (optional (lean.parser.tk "?"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (locat : interactive.parse interactive.types.location) (cfg : tactic.simp_config_ext := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}, discharger := tactic.failed unit}) : tactic unit
(Ïƒ : Type u_1) (R : Type u_2) (p : â„•) [comm_semiring R] [invertible â†‘p] : invertible â†‘p
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] {s : set (Î± Ã— Î²)} (h : â‡‘(Î¼.prod Î½) s = 0) : (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s)) =áµ[Î¼] 0
{Î± : Type u_2} [preorder Î±] {Î¹ : Type u_6} {Ï€ : Î¹ â†’ Type u_7} [Î  (i : Î¹), preorder (Ï€ i)] (f : Î  (i : Î¹), Î± â†’o Ï€ i) : Î± â†’o Î  (i : Î¹), Ï€ i
{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (Î¼ : measure_theory.measure G) [Î¼.is_add_haar_measure] [locally_compact_space G] (E : set G) (hE : measurable_set E) (hEpos : 0 < â‡‘Î¼ E) : E - E âˆˆ nhds 0
{R : Type u} [comm_ring R] {L : Type v} {M : Type w} [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (I : lie_ideal R L) (N : lie_submodule R L M) : â…I,Nâ† = ((lie_module.to_module_hom R L M).comp (tensor_product.lie_module.map_incl I N)).range
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} [subsingleton Î¹] (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) {f : Î¹ â†’ Î± â†’ Î²} (hf : âˆ€ (i : Î¹), measure_theory.mem_â„’p (f i) p Î¼) : measure_theory.unif_integrable f p Î¼
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X âŸ¶ Y) [category_theory.limits.has_kernel f] {W : C} (k : W âŸ¶ X) (h : k â‰« f = 0) : {l // l â‰« category_theory.limits.kernel.Î¹ f = k}
{Ïƒ : Type u_1} {R : Type u_2} [semiring R] {Ï† Ïˆ : mv_power_series Ïƒ R} (h : âˆ€ (n : Ïƒ â†’â‚€ â„•), â‡‘(mv_power_series.coeff R n) Ï† = â‡‘(mv_power_series.coeff R n) Ïˆ) : Ï† = Ïˆ
{Ïƒ : Type u_1} {R : Type u_3} [comm_semiring R] : mv_polynomial Ïƒ (mv_polynomial Ïƒ R) â†’+* mv_polynomial Ïƒ R
{M : Type u_1} [add_monoid M] {Î³ : Type u_2} [add_monoid Î³] {f : M â†’ Î³} (hf : is_add_monoid_hom f) {s : set M} (hs : is_add_submonoid s) : is_add_submonoid (f '' s)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) (G : Type u_4) [has_mul G] [topological_space G] [charted_space H G] : Prop
(hs : interactive.parse tactic.simp_arg_list) (ps : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.pexpr_list_or_texpr))) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (P Q : cochain_complex V â„•) (zero : P.X 0 âŸ¶ Q.X 0) (one : P.X 1 âŸ¶ Q.X 1) (one_zero_comm : zero â‰« Q.d 0 1 = P.d 0 1 â‰« one) (succ : Î  (n : â„•) (p : Î£' (f : P.X n âŸ¶ Q.X n) (f' : P.X (n + 1) âŸ¶ Q.X (n + 1)), f â‰« Q.d n (n + 1) = P.d n (n + 1) â‰« f'), Î£' (f'' : P.X (n + 2) âŸ¶ Q.X (n + 2)), p.snd.fst â‰« Q.d (n + 1) (n + 2) = P.d (n + 1) (n + 2) â‰« f'') (n : â„•) : Î£' (f : P.X n âŸ¶ Q.X n) (f' : P.X (n + 1) âŸ¶ Q.X (n + 1)), f â‰« Q.d n (n + 1) = P.d n (n + 1) â‰« f'
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i)
{Î± : Type u} [pseudo_emetric_space Î±] (x : Î±) (Îµ : ennreal) : set Î±
(t : tactic unit := tactic.skip) : tactic unit
{Î± : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space Î±} (X : Î± â†’ E) (support : set E) (â„™ : measure_theory.measure Î±) (Î¼ : measure_theory.measure E . "volume_tac") : Prop
{X : Type u_1} [pseudo_emetric_space X] [measurable_space X] (Î¼ : measure_theory.measure X) : Î¼.inner_regular is_closed is_open
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) : ae_measurable f' (Î¼.restrict s)
{n : â„•} (hn : n â‰  0) : n.totient = n.factorization.prod (Î» (p k : â„•), p ^ (k - 1) * (p - 1))
{R : Type u_1} [comm_ring R] (I : ideal R) : ring_filter_basis R
{Î± : Type u_1} [preorder Î±] {f : Î± â†’ Î±} {x : Î±} (hf : strict_mono f) (hx : f x < x) : strict_anti (Î» (n : â„•), f^[n] x)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {s : set M} [smooth_manifold_with_corners I' M'] (hs : unique_mdiff_on I s) {e : local_homeomorph M M'} (he : local_homeomorph.mdifferentiable I I' e) : unique_mdiff_on I' (e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s)
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [has_measurable_inv G] [Î¼.is_mul_left_invariant] [Î½.is_mul_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.snd * z.fst, (z.fst)â»Â¹)) (Î¼.prod Î½) = Î¼.prod Î½
{Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), add_comm_group (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’+ G j) : Type (max v w)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X âŸ¶ Y} {Z : C} (Ï€ : Y âŸ¶ Z) (w : f â‰« Ï€ = 0) : category_theory.limits.cokernel_cofork f
{Î± : Type u_1} {Î² : Type u_2} {Ïƒ : Type u_3} [primcodable Î±] [primcodable Î²] [primcodable Ïƒ] (f : Î± â†’ Î² â†’ Ïƒ) : Prop
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â†’ D) [I : category_theory.functorial F] : C â¥¤ D
{E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {Ï† : E â†’ â„} {xâ‚€ : E} {Ï†' : E â†’L[â„] â„} {Î¹ : Type u_2} [fintype Î¹] {f : Î¹ â†’ E â†’ â„} {f' : Î¹ â†’ (E â†’L[â„] â„)} (hextr : is_local_extr_on Ï† {x : E | âˆ€ (i : Î¹), f i x = f i xâ‚€} xâ‚€) (hf' : âˆ€ (i : Î¹), has_strict_fderiv_at (f i) (f' i) xâ‚€) (hÏ†' : has_strict_fderiv_at Ï† Ï†' xâ‚€) : Â¬linear_independent â„ (option.elim Ï†' f')
{I : Type u} (X : I â†’ Top) : category_theory.limits.cone (category_theory.discrete.functor X â‹™ fundamental_groupoid.fundamental_groupoid_functor) â‰Œ category_theory.limits.cone (category_theory.discrete.functor (Î» (i : I), fundamental_groupoid.fundamental_groupoid_functor.obj (X i)))
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {y : F} (h : box_integral.has_integral I l f vol y) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I âŠ¤) (nhds y)
{elab : bool := bool.tt} : expr elab â†’ option (expr elab Ã— expr elab)
{Î± : Type u_1} [normed_ring Î±] [complete_space Î±] {f g : â„• â†’ Î±} (hf : summable (Î» (x : â„•), âˆ¥f xâˆ¥)) (hg : summable (Î» (x : â„•), âˆ¥g xâˆ¥)) : (âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.nat.antidiagonal n).sum (Î» (kl : â„• Ã— â„•), f kl.fst * g kl.snd)
(Î± : Type u) (Î² : Type v) [group Î±] [mul_action Î± Î²] : Î² â‰ƒ Î£ (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), Î± â§¸ mul_action.stabilizer Î± Ï‰.out'
(e : expr) (md : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{Ïƒ : Type u_1} (R : Type u_2) {A : Type u_3} [comm_semiring R] [add_comm_monoid A] [module R A] [module (mv_polynomial Ïƒ R) A] [is_scalar_tower R (mv_polynomial Ïƒ R) A] : (Ïƒ â†’ A) â‰ƒâ‚—[R] derivation R (mv_polynomial Ïƒ R) A
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] (f g : â†¥(measure_theory.Lp Î² 1 Î¼)) : ennreal.of_real âˆ¥f - gâˆ¥ = âˆ«â» (x : Î±), â†‘âˆ¥â‡‘f x - â‡‘g xâˆ¥â‚Š âˆ‚Î¼
{p : â„•} [fact (nat.prime p)] {R : Type uâ‚} [comm_semiring R] [char_p R p] {P : Type uâ‚ƒ} [comm_semiring P] [char_p P p] [perfect_ring P p] {Ï€ : P â†’+* R} (m : perfection_map p Ï€) : P â‰ƒ+* ring.perfection R p
(V : Type uâ‚) [quiver V] (W : Type uâ‚‚) [quiver W] : Sort (max (imax (uâ‚+1) (uâ‚+1) vâ‚ vâ‚‚) (uâ‚+1) (uâ‚‚+1))
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} [inhabited Î›] {Ïƒ : Type u_4} [inhabited Ïƒ] : Type (max u_1 u_2 u_3 u_4)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î²] [topological_space Î³] (f : Î± â†’â‚˜[Î¼] Î²) (g : Î± â†’â‚˜[Î¼] Î³) : Î± â†’â‚˜[Î¼] Î² Ã— Î³
{Î± : Sort uâ‚} {Î² : Sort uâ‚‚} {Ï† : Sort uâ‚ƒ} (f : Î² â†’ Ï†) (g : Î± â†’ Î²) : Î± â†’ Ï†
{Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s : finset Î¹} {t : Î¹ â†’ set Î±} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ measurable_set (t i)) (H : â‡‘Î¼ set.univ < s.sum (Î» (i : Î¹), â‡‘Î¼ (t i))) : âˆƒ (i : Î¹) (H : i âˆˆ s) (j : Î¹) (H : j âˆˆ s) (h : i â‰  j), (t i âˆ© t j).nonempty
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary f (g âˆ˜ â‡‘Ïƒ)
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (T : set Î± â†’ (E â†’L[â„] F)) (f : â†¥(measure_theory.Lp.simple_func E 1 Î¼)) : F
{L : first_order.language} {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] {i j k : Î¹} (hij : i â‰¤ j) (hjk : j â‰¤ k) (x : G i) : â‡‘(f j k hjk) (â‡‘(f i j hij) x) = â‡‘(f i k _) x
{X : Type u_1} {R : Type u_9} {Î¹ : Type u_10} {U : Î¹ â†’ set X} [topological_space X] [has_one R] {f : Î¹ â†’ X â†’ R} (hlf : locally_finite (Î» (i : Î¹), function.mul_support (f i))) (hso : âˆ€ (i : Î¹), mul_tsupport (f i) âŠ† U i) (ho : âˆ€ (i : Î¹), is_open (U i)) (x : X) : âˆƒ (is : finset Î¹) {n : set X} (hnâ‚ : n âˆˆ nhds x) (hnâ‚‚ : n âŠ† â‹‚ (i : Î¹) (H : i âˆˆ is), U i), âˆ€ (z : X), z âˆˆ n â†’ function.mul_support (Î» (i : Î¹), f i z) âŠ† â†‘is
{P : Î  (G : Type u_1) [_inst_3 : group G] [_inst_4 : group.is_nilpotent G], Prop} (G : Type u_1) [group G] [group.is_nilpotent G] (hbase : âˆ€ (G : Type u_1) [_inst_6 : group G] [_inst_7 : subsingleton G], P G) (hstep : âˆ€ (G : Type u_1) [_inst_8 : group G] [_inst_9 : group.is_nilpotent G], P (G â§¸ subgroup.center G) â†’ P G) : P G
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (F : V â¥¤ W) [F.additive] (c : complex_shape Î¹) : homological_complex V c â¥¤ homological_complex W c
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s : set Î±} (hms : measurable_set s) (t : set Î±) : â‡‘(probability_theory.cond Î¼ s) t = (â‡‘Î¼ s)â»Â¹ * â‡‘Î¼ (s âˆ© t)
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] (I J : fractional_ideal S P) : fractional_ideal S P
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {cM : add_con M} {cN : add_con N} {Ï† : cM.quotient â†’ cN.quotient â†’ Sort u_3} (a : cM.quotient) (b : cN.quotient) (f : Î  (x : M) (y : N), Ï† â†‘x â†‘y) (h : âˆ€ (x : M) (y : N) (x' : M) (y' : N), â‡‘cM x x' â†’ â‡‘cN y y' â†’ f x y == f x' y') : Ï† a b
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} : uniform_embedding f â†” function.injective f âˆ§ uniform_continuous f âˆ§ âˆ€ (Î´ : ennreal), Î´ > 0 â†’ (âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î±}, has_edist.edist (f a) (f b) < Îµ â†’ has_edist.edist a b < Î´)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : local_homeomorph M M') : Prop
{n : â„•+} {K : Type u} [field K] [char_zero K] {Î¶ : K} [is_cyclotomic_extension {n} â„š K] (hÎ¶ : is_primitive_root Î¶ â†‘n) : algebra.discr â„š â‡‘((is_primitive_root.power_basis â„š hÎ¶).basis) = algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis)
{C : Type uâ‚} [category_theory.category C] {X Y W : C} (f : X âŸ¶ Y) [category_theory.regular_epi f] (k : X âŸ¶ W) (h : category_theory.regular_epi.left â‰« k = category_theory.regular_epi.right â‰« k) : {l // f â‰« l = k}
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle â„ P) {iâ‚ iâ‚‚ : fin 3} (h : iâ‚ â‰  iâ‚‚) : has_dist.dist t.orthocenter (â‡‘(euclidean_geometry.reflection (affine_span â„ (t.points '' {iâ‚, iâ‚‚}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [topological_space.second_countable_topology Î±] : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€á¶  (a : set Î±) in v.filter_at x, 0 < â‡‘Î¼ a
{Î± : Sort uâ‚} {Î² : Î± â†’ Sort uâ‚‚} {Ï† : Î  {x : Î±}, Î² x â†’ Sort uâ‚ƒ} (f : Î  {x : Î±} (y : Î² x), Ï† y) (g : Î  (x : Î±), Î² x) (x : Î±) : Ï† (g x)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) : category_theory.limits.walking_multicospan I.fst_to I.snd_to â¥¤ C
{Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} {s : Î¹ â†’ set Î±} (H : âˆ€ (i : Î¹), is_preconnected (s i)) (K : âˆ€ (i j : Î¹), relation.refl_trans_gen (Î» (i j : Î¹), (s i âˆ© s j).nonempty) i j) : is_preconnected (â‹ƒ (n : Î¹), s n)
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i * g i) â†” monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b : â„} {f g : â„‚ â†’ E} (hdf : diff_cont_on_cl â„‚ f (complex.re â»Â¹' set.Ioo a b)) (hBf : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.im) filter.at_top âŠ“ filter.principal (complex.re â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.im|))) (hdg : diff_cont_on_cl â„‚ g (complex.re â»Â¹' set.Ioo a b)) (hBg : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), g =O[filter.comap (has_abs.abs âˆ˜ complex.im) filter.at_top âŠ“ filter.principal (complex.re â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.im|))) (ha : âˆ€ (z : â„‚), z.re = a â†’ f z = g z) (hb : âˆ€ (z : â„‚), z.re = b â†’ f z = g z) : set.eq_on f g (complex.re â»Â¹' set.Icc a b)
(Î± : Type u_1) (M : Type u_2) (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] (v : Î± â†’ M) (s : set Î±) : â†¥(finsupp.supported R R s) â†’â‚—[R] â†¥(submodule.span R (v '' s))
{Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [topological_space Î²] [polish_space Î²] {s : set Î²} (hs : is_open s) {f : Î² â†’ Î±} (f_cont : continuous f) : measure_theory.analytic_set (f '' s)
{Î± : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} {Î¼ : measure_theory.measure E} [measure_theory.is_finite_measure Â«â„™Â»] {X : Î± â†’ E} [measure_theory.has_pdf X Â«â„™Â» Î¼] {f : E â†’ â„} (hf : measurable f) : âˆ« (x : E), f x * (measure_theory.pdf X Â«â„™Â» Î¼ x).to_real âˆ‚Î¼ = âˆ« (x : Î±), f (X x) âˆ‚Â«â„™Â»
(p : pexpr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {F : ğ•œ â†’ Î± â†’ E} {F' : Î± â†’ E} {xâ‚€ : ğ•œ} {Îµ : â„} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : ğ•œ) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) Î¼) (hF_int : measure_theory.integrable (F xâ‚€) Î¼) (hF'_meas : measure_theory.ae_strongly_measurable F' Î¼) {bound : Î± â†’ â„} (h_lipsch : âˆ€áµ (a : Î±) âˆ‚Î¼, lipschitz_on_with (â‡‘real.nnabs (bound a)) (Î» (x : ğ•œ), F x a) (metric.ball xâ‚€ Îµ)) (bound_integrable : measure_theory.integrable bound Î¼) (h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, has_deriv_at (Î» (x : ğ•œ), F x a) (F' a) xâ‚€) : measure_theory.integrable F' Î¼ âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : real.angle) : hb.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x
(Ïƒ Ïƒ' : out_param (Type u)) (m m' : Type u â†’ Type v) : Type (max (u+1) v)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_4} [topological_space H] {I : model_with_corners ğ•œ E H} {H' : Type u_5} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {N : Type u_6} [topological_space N] [charted_space H N] {G : Type u_7} [monoid G] [topological_space G] [charted_space H' G] [has_smooth_mul I' G] : cont_mdiff_map I I' N G âŠ¤ â†’* N â†’ G
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {G : Î¹ â†’ Type u_5} [Î  (i : Î¹), inner_product_space ğ•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ğ•œ] E} (hV : orthogonal_family ğ•œ V) [complete_space E] (f : Î  (i : Î¹), G i) : summable (Î» (i : Î¹), â‡‘(V i) (f i)) â†” summable (Î» (i : Î¹), âˆ¥f iâˆ¥ ^ 2)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {W X Y Z : C} [category_theory.limits.has_binary_biproduct W X] [category_theory.limits.has_binary_biproduct Y Z] (f : W âŸ¶ Y) (g : X âŸ¶ Z) : W âŠ X âŸ¶ Y âŠ Z
{R : Type u} {Mâ‚‚ : Type w} {Î¹ : Type x} [semiring R] [add_comm_monoid Mâ‚‚] [module R Mâ‚‚] {Ï† : Î¹ â†’ Type i} [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] (f : Î  (i : Î¹), Mâ‚‚ â†’â‚—[R] Ï† i) : Mâ‚‚ â†’â‚—[R] Î  (i : Î¹), Ï† i
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {x : Î±} {t : set Î±} {Î¦ : Î± â†’ Î²} (hÎ¦ : isometry Î¦) : emetric.inf_edist (Î¦ x) (Î¦ '' t) = emetric.inf_edist x t
{Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (b : Î²) : âˆ¥bounded_continuous_function.const Î± bâˆ¥ â‰¤ âˆ¥bâˆ¥
(V : Type u_1) [semi_normed_group V] (h : âˆƒ (x : V), âˆ¥xâˆ¥ â‰  0) : âˆ¥normed_group_hom.id Vâˆ¥ = 1
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X âŸ¶ Y} {s : category_theory.limits.kernel_fork f} (hs : category_theory.limits.is_limit s) {W : C} (k : W âŸ¶ X) (h : k â‰« f = 0) : {l // l â‰« category_theory.limits.fork.Î¹ s = k}
{M : Type u_1} {N : Type u_2} {Ïƒ : Type u_4} [has_add M] [has_add N] [set_like Ïƒ N] [add_mem_class Ïƒ N] (f : add_hom M N) (S : Ïƒ) (h : âˆ€ (x : M), â‡‘f x âˆˆ S) : add_hom M â†¥S
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} {s : category_theory.limits.fork f g} (hs : category_theory.limits.is_limit s) {W : C} (k : W âŸ¶ X) (h : k â‰« f = k â‰« g) : {l // l â‰« s.Î¹ = k}
(fr : name) (to : list name) : tactic unit
{X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X â†’ E} {Î¼ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure Î¼] (hf : continuous f) : measure_theory.locally_integrable f Î¼
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {L : Type u_1} {S : Type u_3} [field L] [comm_semiring S] [algebra S (polynomial K)] [algebra S L] (Ï† : polynomial K â†’â‚[S] L) (hÏ† : non_zero_divisors (polynomial K) â‰¤ submonoid.comap â†‘Ï† (non_zero_divisors L)) : ratfunc K â†’â‚[S] L
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) (h : has_inner.inner x y = 0) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (h_meas : âˆ€ (n : â„•), measurable (f n)) : âˆ«â» (a : Î±), filter.at_top.liminf (Î» (n : â„•), f n a) âˆ‚Î¼ â‰¤ filter.at_top.liminf (Î» (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼)
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} {Fâ‚— : Type u_7} [normed_group E] [normed_group F] [normed_group Fâ‚—] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] [normed_space ğ•œ Fâ‚—] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) [complete_space F] (e : E â†’L[ğ•œ] Fâ‚—) (h_dense : dense_range â‡‘e) {N : nnreal} (h_e : âˆ€ (x : E), âˆ¥xâˆ¥ â‰¤ â†‘N * âˆ¥â‡‘e xâˆ¥) [ring_hom_isometric Ïƒâ‚â‚‚] : âˆ¥f.extend e h_dense _âˆ¥ â‰¤ â†‘N * âˆ¥fâˆ¥
(ğ•œ : Type u) {Î¹ : Type v} {Î¹' : Type v'} (G : Type wG) (G' : Type wG') [decidable_eq Î¹] [fintype Î¹] [decidable_eq Î¹'] [fintype Î¹'] [nondiscrete_normed_field ğ•œ] [normed_group G] [normed_space ğ•œ G] [normed_group G'] [normed_space ğ•œ G'] (Ïƒ : Î¹ â‰ƒ Î¹') : continuous_multilinear_map ğ•œ (Î» (_x : Î¹), G) G' â‰ƒâ‚—áµ¢[ğ•œ] continuous_multilinear_map ğ•œ (Î» (_x : Î¹'), G) G'
{Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] {f : bounded_continuous_function Î± Î²} {C : â„} (C0 : 0 â‰¤ C) : âˆ¥fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C
{I : Type vâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {J : Type vâ‚} [category_theory.small_category J] {F : J â¥¤ Î  (i : I), C i} [âˆ€ (i : I), category_theory.limits.has_colimit (F â‹™ category_theory.pi.eval C i)] : category_theory.limits.has_colimit F
{X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] (f : X â†’ E) (Î¼ : measure_theory.measure X . "volume_tac") : Prop
{Î± : Type u_1} [emetric_space Î±] [cs : complete_space Î±] {K : nnreal} {f : Î± â†’ Î±} (hf : contracting_with K f) (x : Î±) (hx : has_edist.edist x (f x) â‰  âŠ¤) : âˆƒ (y : Î±), function.is_fixed_pt f y âˆ§ filter.tendsto (Î» (n : â„•), f^[n] x) filter.at_top (nhds y) âˆ§ âˆ€ (n : â„•), has_edist.edist (f^[n] x) y â‰¤ has_edist.edist x (f x) * â†‘K ^ n / (1 - â†‘K)
{Î± : Type u} [pseudo_emetric_space Î±] {Î² : Type u_1} {p : Î² â†’ Prop} {f : Î² â†’ ennreal} (hfâ‚€ : âˆ€ (x : Î²), p x â†’ 0 < f x) (hf : âˆ€ (Îµ : ennreal), 0 < Îµ â†’ (âˆƒ (x : Î²) (hx : p x), f x â‰¤ Îµ)) : (uniformity Î±).has_basis p (Î» (x : Î²), {p : Î± Ã— Î± | has_edist.edist p.fst p.snd â‰¤ f x})
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type wâ‚} [category_theory.category D] {E : Type wâ‚‚} [category_theory.category E] (F : D â¥¤ E) [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– E] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– F] [Î  (X : C) (W : J.cover X) (P : Cáµ’áµ– â¥¤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] (P : Cáµ’áµ– â¥¤ D) : J.sheafify P â‹™ F â‰… J.sheafify (P â‹™ F)
{G : Type u_1} [measurable_space G] [group G] [topological_space G] [topological_group G] [borel_space G] [t1_space G] [locally_compact_space G] [(nhds_within 1 {1}á¶œ).ne_bot] (Î¼ : measure_theory.measure G) [Î¼.is_haar_measure] : measure_theory.has_no_atoms Î¼
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} {Ïƒ : Type u_4} (M : Î› â†’ turing.TM2.stmt Î“ Î› Ïƒ) (S : finset Î›) : finset (option (turing.TM2.stmt Î“ Î› Ïƒ))
{X : Type u_1} [topological_space X] {U W : set X} (hW : is_path_connected W) (hWU : W âŠ† U) : is_path_connected (coe â»Â¹' W)
{n : â„•} {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {C : Î  {n : â„•}, vector Î± n â†’ vector Î² n â†’ vector Î³ n â†’ Sort u_4} (u : vector Î± n) (v : vector Î² n) (w : vector Î³ n) (h_nil : C vector.nil vector.nil vector.nil) (h_cons : Î  {n : â„•} {a : Î±} {b : Î²} {c : Î³} {x : vector Î± n} {y : vector Î² n} {z : vector Î³ n}, C x y z â†’ C (a::áµ¥x) (b::áµ¥y) (c::áµ¥z)) : C u v w
{R : Type u_1} [semiring R] {Ï† : power_series R} : Ï†.order = âŠ¤ â†” Ï† = 0
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {f : Î± â†’ E} {Î¼ : measure_theory.measure Î±} {l : filter Î±} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l Î¼) (hÎ¼ : Î¼.finite_at_filter l) {b : E} (hf : filter.tendsto f l (nhds b)) : measure_theory.integrable_at_filter f l Î¼
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (s : submodule â„ E) (hs : s â‰  âŠ¤) : â‡‘Î¼ â†‘s = 0
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s t : set Î±} (H : s â‰¤áµ[Î¼] t) : â‡‘Î¼ s â‰¤ â‡‘Î¼ t
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] (l : list Î“) : turing.TM0.cfg Î“ Î›
{E : Type u} [normed_group E] [normed_space â„ E] {n : â„•} [complete_space E] (I : box_integral.box (fin (n + 1))) {i : fin (n + 1)} {f : (fin (n + 1) â†’ â„) â†’ E} {f' : (fin (n + 1) â†’ â„) â†’L[â„] E} (hfc : continuous_on f (â‡‘box_integral.box.Icc I)) {x : fin (n + 1) â†’ â„} (hxI : x âˆˆ â‡‘box_integral.box.Icc I) {a : E} {Îµ : â„} (h0 : 0 < Îµ) (hÎµ : âˆ€ (y : fin (n + 1) â†’ â„), y âˆˆ â‡‘box_integral.box.Icc I â†’ âˆ¥f y - a - â‡‘f' (y - x)âˆ¥ â‰¤ Îµ * âˆ¥y - xâˆ¥) {c : nnreal} (hc : I.distortion â‰¤ c) : âˆ¥finset.univ.prod (Î» (j : fin (n + 1)), I.upper j - I.lower j) â€¢ â‡‘f' (pi.single i 1) - (box_integral.integral (I.face i) âŠ¥ (f âˆ˜ i.insert_nth (I.upper i)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (f âˆ˜ i.insert_nth (I.lower i)) box_integral.box_additive_map.volume)âˆ¥ â‰¤ 2 * Îµ * â†‘c * finset.univ.prod (Î» (j : fin (n + 1)), I.upper j - I.lower j)
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Ïƒ : Type u_4} [inhabited Ïƒ] {k : K} (v : Ïƒ) (l : list (Î“ k)) : turing.TM2to1.st_act k â†’ Ïƒ
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i * g i) < finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â†” Â¬antivary (f âˆ˜ â‡‘Ïƒ) g
(aggressive : bool := bool.ff) : tactic unit
{Î¹ : Type u_1} {I J : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) (h : I â‰¤ J) : (Ï€.restrict J).boxes = Ï€.boxes
(I : Type u) (Î± : Type u_1) (Î² : Type u_2) [semiring Î±] [add_comm_monoid Î²] [module Î± Î²] : module Î± (I â†’ Î²)
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} [t2_space M] {s : set M} (hs : s âˆˆ nhds c) : (nhds c).has_basis (Î» (f : smooth_bump_function I c), tsupport â‡‘f âŠ† s) (Î» (f : smooth_bump_function I c), function.support â‡‘f)
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ E'] [inner_product_space â„ G] [complete_space E'] [borel_space G] [measure_theory.is_locally_finite_measure Î¼] [Î¼.is_open_pos_measure] [finite_dimensional â„ G] [Î¼.is_add_left_invariant] {Î¹ : Type u_1} {Ï† : Î¹ â†’ cont_diff_bump_of_inner 0} {l : filter Î¹} (hÏ† : filter.tendsto (Î» (i : Î¹), (Ï† i).R) l (nhds 0)) (hmg : measure_theory.ae_strongly_measurable g Î¼) {xâ‚€ : G} (hcg : continuous_at g xâ‚€) : filter.tendsto (Î» (i : Î¹), convolution (Î» (x : G), (Ï† i).normed Î¼ x) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) l (nhds (g xâ‚€))
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {s : set E} {f' : E â†’L[ğ•œ] F} {x : E} (h : has_fderiv_within_at f f' s x) (hs : unique_diff_within_at ğ•œ s x) (h' : dense_range â‡‘f') : unique_diff_within_at ğ•œ (f '' s) (f x)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] {C : Î  (i : Î¹), set (set (Î± i))} (hC : âˆ€ (i : Î¹), is_countably_spanning (C i)) : measurable_space.pi = measurable_space.generate_from (set.univ.pi '' set.univ.pi C)
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} (hf : has_fpower_series_at f p x) (n : â„•) : (Î» (y : E), f (x + y) - p.partial_sum n y) =O[nhds 0] Î» (y : E), âˆ¥yâˆ¥ ^ n
{Î± : Type u} [linear_ordered_add_comm_group Î±] {a b x : Î±} (h : x âˆˆ set.interval a b) : |x - a| â‰¤ |b - a|
{Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : Î± â†’ E) : E
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr Ã— expr)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_coequalizer f g] {W : C} (k : Y âŸ¶ W) (h : f â‰« k = g â‰« k) : category_theory.limits.coequalizer f g âŸ¶ W
{I : Type u} (f : I â†’ Type v) [decidable_eq I] [Î  (i : I), add_zero_class (f i)] (i : I) : f i â†’+ Î  (i : I), f i
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [cs : complete_space E] {f : E â†’ F} {s : set E} {c : nnreal} {f' : E â†’L[ğ•œ] F} (hf : approximates_linear_on f f' s c) (f'symm : f'.nonlinear_right_inverse) {Îµ : â„} {b : E} (Îµ0 : 0 â‰¤ Îµ) (hÎµ : metric.closed_ball b Îµ âŠ† s) : set.surj_on f (metric.closed_ball b Îµ) (metric.closed_ball (f b) (((â†‘(f'symm.nnnorm))â»Â¹ - â†‘c) * Îµ))
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] (f : E' â†’ F) {s : set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hs : metric.bounded s) (hf : f âˆˆ closure (coe_fn '' s)) : E' â†’SL[Ïƒâ‚â‚‚] F
(F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] (K : Type u_3) [field K] [algebra F K] (Ï† : E â†’â‚[F] K) (x : â†¥(set.range â‡‘(finite_dimensional.fin_basis F E))) : {l // l âˆˆ (polynomial.map (algebra_map F K) (minpoly F x.val)).roots}
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a : â„} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [measure_theory.is_locally_finite_measure Î¼] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : v â‰¤á¶ [lt] u) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ + (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.fork I.fst_pi_map I.snd_pi_map â¥¤ category_theory.limits.multifork I
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M â†’ M') : Prop
{Î± : Type u_1} {Î² : Type u_2} [normed_group Î²] {m : measurable_space Î±} (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
(attr_name c_name : name) (persistent : bool := bool.tt) (prio : option â„• := option.none) : tactic unit
{Î¹ : Type u_1} {Ïƒ : Type u_2} {R : Type u_4} [decidable_eq Î¹] [has_add Î¹] [non_unital_non_assoc_semiring R] [set_like Ïƒ R] [add_submonoid_class Ïƒ R] (A : Î¹ â†’ Ïƒ) [set_like.has_graded_mul A] : direct_sum.gnon_unital_non_assoc_semiring (Î» (i : Î¹), â†¥(A i))
{Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {Îµ : â„} : emetric.ball x (ennreal.of_real Îµ) = metric.ball x Îµ
{Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (Î´ : â„), Î´ > 0 â†’ (f x âˆ© set.Ioo 0 Î´).nonempty) : âˆƒ (t : set (Î± Ã— â„)), t.countable âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.fst âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.snd âˆˆ f p.fst) âˆ§ â‡‘Î¼ (s  â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), metric.closed_ball p.fst p.snd) = 0 âˆ§ t.pairwise_disjoint (Î» (p : Î± Ã— â„), metric.closed_ball p.fst p.snd)
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {f g : â„‚ â†’ E} (hfd : diff_cont_on_cl â„‚ f {z : â„‚ | 0 < z.re}) (hgd : diff_cont_on_cl â„‚ g {z : â„‚ | 0 < z.re}) (hfexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hgexp : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : asymptotics.superpolynomial_decay filter.at_top real.exp (Î» (x : â„), âˆ¥f â†‘x - g â†‘xâˆ¥)) (hfim : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hgim : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥g (â†‘x * complex.I)âˆ¥ â‰¤ C) : set.eq_on f g {z : â„‚ | 0 â‰¤ z.re}
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (h : W âŸ¶ Z) [category_theory.mono h] (x : X âŸ¶ W) (y : Y âŸ¶ W) (hxh : x â‰« h = f) (hyh : y â‰« h = g) (s : category_theory.limits.pullback_cone f g) (hs : category_theory.limits.is_limit s) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk s.fst s.snd _)
{M : Type u_1} [has_add M] â¦ƒs t : set Mâ¦„ (h : s âŠ† t) : add_subsemigroup.closure s â‰¤ add_subsemigroup.closure t
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {g : Î± â†’ Î²} (hp : 1 â‰¤ p) (hp_ne_top : p â‰  âŠ¤) (hg : measure_theory.mem_â„’p g p Î¼) : measure_theory.unif_integrable (Î» (n : Î¹), g) p Î¼
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [nonempty Î²] [semilattice_sup Î²] {u : Î² â†’ Î±} : cauchy_seq u â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), n â‰¥ N â†’ has_edist.edist (u n) (u N) < Îµ)
{Î¹ : Type u_1} [nontrivial Î¹] {G : Type u_1} [group G] (a : Î¹ â†’ G) {Î± : Type u_4} [mul_action G Î±] (X Y : Î¹ â†’ set Î±) (hXnonempty : âˆ€ (i : Î¹), (X i).nonempty) (hXdisj : pairwise (Î» (i j : Î¹), disjoint (X i) (X j))) (hYdisj : pairwise (Î» (i j : Î¹), disjoint (Y i) (Y j))) (hXYdisj : âˆ€ (i j : Î¹), disjoint (X i) (Y j)) (hX : âˆ€ (i : Î¹), a i â€¢ (Y i)á¶œ âŠ† X i) (hY : âˆ€ (i : Î¹), aâ»Â¹ i â€¢ (X i)á¶œ âŠ† Y i) : function.injective â‡‘(â‡‘free_group.lift a)
{Î± : Type u_1} [semi_normed_ring Î±] (a : Î±) {n : â„•} (h : 0 < n) : âˆ¥a ^ nâˆ¥ â‰¤ âˆ¥aâˆ¥ ^ n
{Î± : Type u} {C : free_add_semigroup Î± â†’ Sort l} (x : free_add_semigroup Î±) (ih1 : Î  (x : Î±), C (free_add_semigroup.of x)) (ih2 : Î  (x : Î±) (y : free_add_semigroup Î±), C (free_add_semigroup.of x) â†’ C y â†’ C (free_add_semigroup.of x + y)) : C x
{Vâ‚ : Type u_3} {Vâ‚‚ : Type u_4} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] {Wâ‚ : Type u_6} {Wâ‚‚ : Type u_7} [semi_normed_group Wâ‚] [semi_normed_group Wâ‚‚] {fâ‚ gâ‚ : normed_group_hom Vâ‚ Wâ‚} {fâ‚‚ gâ‚‚ : normed_group_hom Vâ‚‚ Wâ‚‚} (Ï† : normed_group_hom Vâ‚ Vâ‚‚) (Ïˆ : normed_group_hom Wâ‚ Wâ‚‚) (hf : Ïˆ.comp fâ‚ = fâ‚‚.comp Ï†) (hg : Ïˆ.comp gâ‚ = gâ‚‚.comp Ï†) : normed_group_hom â†¥(fâ‚.equalizer gâ‚) â†¥(fâ‚‚.equalizer gâ‚‚)
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.finite_measure Î±) : weak_dual nnreal (bounded_continuous_function Î± nnreal)
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ ennreal) (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ«â» (x : Î±), F (âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ«â» (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ - âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (hS : is_closed â†‘S) (m : M) (h : âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ = 0) : m âˆˆ S
{Ï‰ Ï‰' : Type u} {m m' n n' : Type u â†’ Type v} [monad_writer_adapter Ï‰ Ï‰' m m'] [monad_functor m m' n n'] : monad_writer_adapter Ï‰ Ï‰' n n'
{C : Type uâ‚‚} [category_theory.category C] {I : Type uâ‚} (F : I â†’ C) : category_theory.discrete I â¥¤ C
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] (f : Î± â†’ nnreal) (fint : measure_theory.integrable (Î» (x : Î±), â†‘(f x)) Î¼) {Îµ : â„} (Îµpos : 0 < Îµ) : âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ f x) âˆ§ upper_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), â†‘(g x)) Î¼ âˆ§ âˆ« (x : Î±), â†‘(f x) âˆ‚Î¼ - Îµ â‰¤ âˆ« (x : Î±), â†‘(g x) âˆ‚Î¼
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {n : with_top â„•} : cont_mdiff I I' n f â†” continuous f âˆ§ âˆ€ (y : M'), cont_mdiff_on I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' y) âˆ˜ f) (f â»Â¹' (ext_chart_at I' y).source)
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {ps : set P} (hps : ps âŠ† â†‘s) (p : P) : ps.pairwise (Î» (p1 p2 : P), has_dist.dist p1 p = has_dist.dist p2 p) â†” ps.pairwise (Î» (p1 p2 : P), has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = has_dist.dist p2 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p))
(red : interactive.parse (optional (lean.parser.tk "!"))) (restr : interactive.parse (optional (lean.parser.tk "only"))) (hyps : interactive.parse (optional interactive.types.pexpr_list)) (cfg : linarith.linarith_config := {discharger := has_bind.seq (tactic.save_info {line := 312, column := 31}) (tactic.interactive.ring option.none).step, restrict_type := option.none Type, restrict_type_reflect := `(option.none Type), exfalso := bool.tt, transparency := tactic.transparency.reducible, split_hypotheses := bool.tt, split_ne := bool.ff, preprocessors := option.none (list linarith.global_branching_preprocessor), oracle := option.none linarith.certificate_oracle}) : tactic unit
{M : Type u_1} {N : Type u_2} {Ïƒ : Type u_4} [has_mul M] [has_mul N] [set_like Ïƒ N] [mul_mem_class Ïƒ N] (f : M â†’â‚™* N) (S : Ïƒ) (h : âˆ€ (x : M), â‡‘f x âˆˆ S) : M â†’â‚™* â†¥S
{m n : with_top â„•} {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (h : m â‰¤ n) : cont_diff_groupoid n I â‰¤ cont_diff_groupoid m I
(pp_name : name) (type : expr) (context : option local_context := option.none) : tactic.unsafe.type_context expr
(Î± : Type u) (Î² : Type v) [group Î±] [mul_action Î± Î²] {Ï† : quotient (mul_action.orbit_rel Î± Î²) â†’ Î²} (hÏ† : function.left_inverse quotient.mk' Ï†) : Î² â‰ƒ Î£ (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), Î± â§¸ mul_action.stabilizer Î± (Ï† Ï‰)
{I : Type wâ‚} (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] {J : Type wâ‚‚} {K : Type wâ‚ƒ} (f : K â†’ J) (g : J â†’ I) : category_theory.sigma.map (C âˆ˜ g) f â‹™ category_theory.sigma.map C g â‰… category_theory.sigma.map C (g âˆ˜ f)
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s t : set Î±} [measure_theory.is_finite_measure Î¼] (hms : measurable_set s) (hmt : measurable_set t) (hci : â‡‘Î¼ (s âˆ© t) â‰  0) : probability_theory.cond (probability_theory.cond Î¼ s) t = probability_theory.cond Î¼ (s âˆ© t)
{Î¹ : Type u_1} (I : box_integral.box Î¹) (s : finset (Î¹ Ã— â„)) : box_integral.prepartition I
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] (i : I) : C i â¥¤ Î£ (i : I), C i
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f : module.End K V} {k : â„•} {Î¼ : K} (hx : f.has_eigenvalue Î¼) (hk : 0 < k) : 0 < finite_dimensional.finrank K â†¥(â‡‘(f.generalized_eigenspace Î¼) k)
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ E'] [inner_product_space â„ G] [complete_space E'] {Ï† : cont_diff_bump_of_inner 0} {xâ‚€ : G} (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ Ï†.R â†’ g x = g xâ‚€) : convolution â‡‘Ï† g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€ = measure_theory.integral Î¼ â‡‘Ï† â€¢ g xâ‚€
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] {Î¼ : Î  (i : Î¹), measure_theory.measure (Î± i)} {C : Î  (i : Î¹), set (set (Î± i))} (hC : âˆ€ (i : Î¹), measurable_space.generate_from (C i) = _inst_3 i) (h2C : âˆ€ (i : Î¹), is_pi_system (C i)) (h3C : Î  (i : Î¹), (Î¼ i).finite_spanning_sets_in (C i)) {Î¼Î½ : measure_theory.measure (Î  (i : Î¹), Î± i)} (hâ‚ : âˆ€ (s : Î  (i : Î¹), set (Î± i)), (âˆ€ (i : Î¹), s i âˆˆ C i) â†’ â‡‘Î¼Î½ (set.univ.pi s) = finset.univ.prod (Î» (i : Î¹), â‡‘(Î¼ i) (s i))) : measure_theory.measure.pi Î¼ = Î¼Î½
(n : interactive.parse (optional interactive.types.texpr)) (bounds : interactive.parse (optional (lean.parser.tk "using" *> (î€€prod.mkî€prod.mkî€‚î€€functor.mapî€ <$> î€‚î€€lean.parser.identî€lean.parser.identî€‚ <*> lean.parser.ident)))) (lname : interactive.parse (optional (lean.parser.tk "with" *> lean.parser.ident))) : tactic unit
{Î± : Sort u_1} (f : Î  (x : pgame) (y : pgame), x.numeric â†’ y.numeric â†’ Î±) (H : âˆ€ {xâ‚ : pgame} {yâ‚ : pgame} {xâ‚‚ : pgame} {yâ‚‚ : pgame} (oxâ‚ : xâ‚.numeric) (oyâ‚ : yâ‚.numeric) (oxâ‚‚ : xâ‚‚.numeric) (oyâ‚‚ : yâ‚‚.numeric), xâ‚.equiv xâ‚‚ â†’ yâ‚.equiv yâ‚‚ â†’ f xâ‚ yâ‚ oxâ‚ oyâ‚ = f xâ‚‚ yâ‚‚ oxâ‚‚ oyâ‚‚) : surreal â†’ surreal â†’ Î±
(Ïƒ : Type u_1) (R : Type u_2) [semiring R] : mv_power_series Ïƒ R â†’+* R
{Î± : Type u} [lattice Î±] [add_comm_group Î±] [covariant_class Î± Î± has_add.add has_le.le] (a : Î±) : ||a|| = |a|
(proj_folder proj_name : string) (slow : bool := bool.tt) (verbose : lint_verbosity := lint_verbosity.medium) (extra : list name := list.nil) (use_only : bool := bool.ff) : tactic (name_set Ã— format)
(s : option simp_lemmas := option.none) (u : list name := list.nil) (cfg : tactic.dsimp_config := {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}) : conv unit
{Î± : Type u_1} (F : Type u_6) (p : ennreal) [normed_group F] {m m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp F p (Î¼.trim hm))) : â†¥(measure_theory.Lp_meas_subgroup F m p Î¼)
(R : Type u) [comm_ring R] [is_noetherian_ring R] (I : ideal R) : âˆƒ (Z : multiset (prime_spectrum R)), (multiset.map coe Z).prod â‰¤ I
{Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {i : set Î±} (hi : â‡‘s i < 0) : âˆƒ (j : set Î±), measurable_set j âˆ§ j âŠ† i âˆ§ measure_theory.vector_measure.restrict s j â‰¤ 0.restrict j âˆ§ â‡‘s j < 0
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] {f : â„ â†’ E} {Î¼ : measure_theory.measure â„} {l l' : filter â„} (hfm : strongly_measurable_at_filter f l' Î¼) [filter.tendsto_Ixx_class set.Ioc l l'] [l'.is_measurably_generated] (hÎ¼ : Î¼.finite_at_filter l') {c : E} (hf : filter.tendsto f l' (nhds c)) {u v : Î¹ â†’ â„} {lt : filter Î¹} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : âˆ€á¶  (t : Î¹) in lt, interval_integrable f Î¼ (u t) (v t)
{Î± : Type u_1} {m : measurable_space Î±} (f : measure_theory.simple_func Î± ennreal) (Î¼ : measure_theory.measure Î±) : ennreal
{V : Type u} {W : Type v} (G : simple_graph V) (G' : simple_graph W) : Type (max u v)
{I : Type vâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {J : Type vâ‚} [category_theory.small_category J] {F : J â¥¤ Î  (i : I), C i} (c : Î  (i : I), category_theory.limits.cone (F â‹™ category_theory.pi.eval C i)) : category_theory.limits.cone F
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] {Ïƒ : R â†’+* S} {Ïƒ' : S â†’+* R} [ring_hom_inv_pair Ïƒ Ïƒ'] [ring_hom_inv_pair Ïƒ' Ïƒ] {M : Type u_3} {Mâ‚‚ : Type u_4} [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module S Mâ‚‚] (e : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚) : Mâ‚‚ â†’ M
{Î± : Type u} {Î¹ : Type u_1} {I : set Î¹} (hI : I.finite) {l : filter Î±} {p : Î¹ â†’ Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in l, âˆ€ (i : Î¹), i âˆˆ I â†’ p i x) â†” âˆ€ (i : Î¹), i âˆˆ I â†’ (âˆ€á¶  (x : Î±) in l, p i x)
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s : set Î±} (h : is_compact s) (hÎ¼ : âˆ€ (x : Î±), x âˆˆ s â†’ Î¼.finite_at_filter (nhds x)) : âˆƒ (U : set Î±) (H : U âŠ‡ s), is_open U âˆ§ â‡‘Î¼ U < âŠ¤
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î³' : Type u_6} {Î´ : Type u_7} {Îµ : Type u_9} {f : filter Î±} {g : filter Î²} {h : filter Î³} {m : Î± â†’ Î´ â†’ Îµ} {n : Î² â†’ Î³ â†’ Î´} {mâ‚ : Î± â†’ Î² â†’ Î²'} {mâ‚‚ : Î± â†’ Î³ â†’ Î³'} {n' : Î²' â†’ Î³' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), m a (n b c) = n' (mâ‚ a b) (mâ‚‚ a c)) : filter.mapâ‚‚ m f (filter.mapâ‚‚ n g h) â‰¤ filter.mapâ‚‚ n' (filter.mapâ‚‚ mâ‚ f g) (filter.mapâ‚‚ mâ‚‚ f h)
{R : Type u} [comm_ring R] (I : ideal R) (f : polynomial R) : adjoin_root f â§¸ ideal.map (ideal.quotient.mk (ideal.span {f})) (ideal.map polynomial.C I) â‰ƒ+* (polynomial R â§¸ ideal.map polynomial.C I) â§¸ ideal.map (ideal.quotient.mk (ideal.map polynomial.C I)) (ideal.span {f})
{n : â„•} {Î± : fin (n + 1) â†’ Type u} {P : (Î  (i : fin n.succ), Î± i) â†’ Sort v} (h : Î  (xâ‚€ : Î± 0) (x : Î  (i : fin n), Î± i.succ), P (fin.cons xâ‚€ x)) (x : Î  (i : fin n.succ), Î± i) : P x
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (Î¼ : R) : â„• â†’o submodule R M
{E : Type u_3} [has_norm E] [add_comm_group E] [pseudo_metric_space E] (H1 : âˆ€ (x : E), âˆ¥xâˆ¥ = has_dist.dist x 0) (H2 : âˆ€ (x y z : E), has_dist.dist x y â‰¤ has_dist.dist (x + z) (y + z)) : semi_normed_group E
{Râ‚ : Type u_3} [comm_ring Râ‚] {K : Type u_4} [field K] [algebra Râ‚ K] [frac : is_fraction_ring Râ‚ K] [is_domain Râ‚] [is_noetherian_ring Râ‚] (I : fractional_ideal (non_zero_divisors Râ‚) K) : is_noetherian Râ‚ â†¥I
(Î“ : Type u_1) [inhabited Î“] (Î› : Type u_2) [inhabited Î›] : Type (max u_1 u_2)
{Î¹ : Type u} (s : finset Î¹) (f : Î¹ â†’ â„) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), |f i|) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), |f i| ^ p)
{ğ•œ : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] {ğ•œ' : Type u_10} [normed_field ğ•œ'] [normed_algebra ğ•œ ğ•œ'] [normed_space ğ•œ' E] [is_scalar_tower ğ•œ ğ•œ' E] : âˆ¥continuous_linear_map.lsmul ğ•œ ğ•œ'âˆ¥ â‰¤ 1
{Î± : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space Î±} (X : Î± â†’ E) (â„™ : measure_theory.measure Î±) (Î¼ : measure_theory.measure E . "volume_tac") : Prop
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_4} [topological_space H] {I : model_with_corners ğ•œ E H} {N : Type u_6} [topological_space N] [charted_space H N] {A : Type u_10} [normed_ring A] [normed_algebra ğ•œ A] [smooth_ring (model_with_corners_self ğ•œ A) A] : cont_mdiff_map I (model_with_corners_self ğ•œ A) N A âŠ¤ â†’â‚[ğ•œ] N â†’ A
{Î± : Type u} [linear_ordered_add_comm_group Î±] (a b : Î±) : |a + b| â‰¤ |a| + |b|
{I : Type vâ‚} (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] : category_theory.category (Î  (i : I), C i)
{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] (not_terminated_at_n : Â¬(generalized_continued_fraction.of v).terminated_at n) : |v - (generalized_continued_fraction.of v).convergents n| â‰¤ 1 / ((generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators (n + 1))
{K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] (hÎ¶ : is_primitive_root Î¶ 2) : â‡‘(algebra.norm K) Î¶ = (-1) ^ finite_dimensional.finrank K L
{Ïƒ Î± : Type u_1} (cmd : state Ïƒ Î±) (s : Ïƒ) : stream Î±
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] (f : Î± Ã— Î² â†’ ennreal) (hf : measurable f) : âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
{Î¹ : Type u_1} [fintype Î¹] (I : box_integral.box Î¹) : nnreal
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (P Q : cochain_complex V â„•) (zero : P.X 0 âŸ¶ Q.X 0) (one : P.X 1 âŸ¶ Q.X 1) (one_zero_comm : zero â‰« Q.d 0 1 = P.d 0 1 â‰« one) (succ : Î  (n : â„•) (p : Î£' (f : P.X n âŸ¶ Q.X n) (f' : P.X (n + 1) âŸ¶ Q.X (n + 1)), f â‰« Q.d n (n + 1) = P.d n (n + 1) â‰« f'), Î£' (f'' : P.X (n + 2) âŸ¶ Q.X (n + 2)), p.snd.fst â‰« Q.d (n + 1) (n + 2) = P.d (n + 1) (n + 2) â‰« f'') : P âŸ¶ Q
{R : Type u_1} {M : Type u_5} [comm_semiring R] [add_comm_monoid M] [module R M] {I : R â†’+* R} (B : M â†’â‚›â‚—[I] M â†’â‚—[R] R) : Prop
{E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} (hf : differentiable_on ğ•œ f s) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv_within ğ•œ f s xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
(e : expr) (n : â„•) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr Ã— expr)
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) (s : set Î±) : emetric.diam (f '' s) = emetric.diam s
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : f' =O[l] g' â†’ ((Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X â„) (e : C(X, Y)) (he : closed_embedding â‡‘e) : âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ â‰¤ âˆ¥fâˆ¥ / 3 âˆ§ has_dist.dist (g.comp_continuous e) f â‰¤ 2 / 3 * âˆ¥fâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {f : Î± â†’ Î²} [measurable_space Î²] [topological_space.pseudo_metrizable_space Î²] [borel_space Î²] [topological_space.second_countable_topology Î²] : measure_theory.ae_strongly_measurable f Î¼ â†” ae_measurable f Î¼
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} (i : Î¹) : (Î  (i j : Î¹), C.X i âŸ¶ D.X j) â†’+ (C.X i âŸ¶ D.X i)
(a b : â„) {p q : â„} (hpq : p.is_conjugate_exponent q) : a * b â‰¤ |a| ^ p / p + |b| ^ q / q
{Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_metric_space (Ï€ b)] [nonempty Î²] (x : Î  (b : Î²), Ï€ b) (r : â„) : metric.ball x r = set.univ.pi (Î» (b : Î²), metric.ball (x b) r)
{Î± : Type u_1} [measurable_space Î±] (j : measure_theory.jordan_decomposition Î±) : âˆƒ (S : set Î±), measurable_set S âˆ§ measure_theory.vector_measure.restrict j.to_signed_measure S â‰¤ 0.restrict S âˆ§ 0.restrict Sá¶œ â‰¤ measure_theory.vector_measure.restrict j.to_signed_measure Sá¶œ âˆ§ â‡‘(j.pos_part) S = 0 âˆ§ â‡‘(j.neg_part) Sá¶œ = 0
{Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [comm_ring A] [algebra R A] [linear_ordered_cancel_add_comm_monoid Î¹] {ğ’œ : Î¹ â†’ submodule R A} [graded_algebra ğ’œ] (I : homogeneous_ideal ğ’œ) : homogeneous_ideal ğ’œ
{k : Type u} [comm_ring k] (G : Type u) [group G] {V : Type u} [add_comm_group V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] {W : Type u} [add_comm_group W] [module k W] [module (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (Ï€ : W â†’â‚—[k] V) [fintype G] [inv : invertible â†‘(fintype.card G)] : W â†’â‚—[monoid_algebra k G] V
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s t : set Î±} (Hf : monotone_on f t) (Hst : s âŠ† t) : (upper_bounds s âˆ© t).nonempty â†’ bdd_above (f '' s)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) {Râ‚‚ : Type u_3} {Mâ‚‚ : Type u_4} [ring Râ‚‚] [add_comm_group Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚} â¦ƒf g : M â§¸ p â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚â¦„ (h : f.comp p.mkq = g.comp p.mkq) : f = g
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} : Î¼.absolutely_continuous Î½ â†’ Î¼.ae â‰¤ Î½.ae
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] : Prop
{Ïƒ : Type u_1} {R : Type u_2} [comm_ring R] [local_ring R] : local_ring (mv_power_series Ïƒ R)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (n : with_top â„•) (f : M â†’ M') : Prop
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {F : Type u_5} [normed_group F] [normed_space ğ•œ F] (Z : basic_smooth_vector_bundle_core I M F) {e : local_homeomorph M H} (he : e âˆˆ charted_space.atlas H M) : local_homeomorph Z.to_topological_vector_bundle_core.total_space (model_prod H F)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {p : localization S â†’ Sort u} (f : Î  (a : M) (b : â†¥S), p (localization.mk a b)) (H : âˆ€ {a c : M} {b d : â†¥S} (h : â‡‘(localization.r S) (a, b) (c, d)), eq.rec (f a b) _ = f c d) (x : localization S) : p x
{Îµ : Type u_1} {p : Îµ â†’ Prop} [decidable_pred p] (ep : equiv.perm {a // p a}) (en : equiv.perm {a // Â¬p a}) : equiv.perm Îµ
{ğ•œ : Type u_1} {G : Type u_2} {x : G} [nondiscrete_normed_field ğ•œ] [measurable_space G] {Î¼ : measure_theory.measure G} [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.is_neg_invariant] [normed_space â„ ğ•œ] [complete_space ğ•œ] {f g : G â†’ ğ•œ} : convolution f g (continuous_linear_map.lmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f (x - t) * g t âˆ‚Î¼
{E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} {Ï† : E â†’L[ğ•œ] G} (hf : differentiable_on ğ•œ f s) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv_within ğ•œ f s x - Ï†âˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{C : Type u} [category_theory.category C] {W X Y Z : C} [category_theory.limits.has_binary_coproduct W X] [category_theory.limits.has_binary_coproduct Y Z] (f : W âŸ¶ Y) (g : X âŸ¶ Z) : W â¨¿ X âŸ¶ Y â¨¿ Z
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : f =O[l] g â†” âˆƒ (c : â„), âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : category_theory.limits.cofork I.fst_sigma_map I.snd_sigma_map â¥¤ category_theory.limits.multicofork I
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) : â‡‘Ï {x : Î± | v.lim_ratio_meas hÏ x = 0} = 0
{X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] {s : set X} (Î¦ : â†¥s â†’ Y) {Îµâ‚ Îµâ‚‚ Îµâ‚ƒ : â„} (hs : âˆ€ (x : X), âˆƒ (y : X) (H : y âˆˆ s), has_dist.dist x y â‰¤ Îµâ‚) (hs' : âˆ€ (x : Y), âˆƒ (y : â†¥s), has_dist.dist x (Î¦ y) â‰¤ Îµâ‚ƒ) (H : âˆ€ (x y : â†¥s), |has_dist.dist x y - has_dist.dist (Î¦ x) (Î¦ y)| â‰¤ Îµâ‚‚) : Gromov_Hausdorff.GH_dist X Y â‰¤ Îµâ‚ + Îµâ‚‚ / 2 + Îµâ‚ƒ
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] : Type (max u_1 u_2)
{Î± : Type u} {Î² : Type v} [semilattice_sup Î±] [nonempty Î±] {I : set Î²} {S : Î² â†’ set Î±} (H : I.finite) : bdd_above (â‹ƒ (i : Î²) (H : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ bdd_above (S i)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {s : set E} {c : nnreal} (hf : approximates_linear_on f â†‘f' s c) (hc : subsingleton E âˆ¨ c < âˆ¥â†‘(f'.symm)âˆ¥â‚Šâ»Â¹) : continuous_on â‡‘((hf.to_local_equiv hc).symm) (f '' s)
{Î± : Type u} {Î² : Type v} (R : Type u_1) [semiring R] (e : Î± â‰ƒ Î²) [add_comm_monoid Î²] [module R Î²] : let _inst : add_comm_monoid Î± := e.add_comm_monoid, _inst_4 : module R Î± := equiv.module R e in Î± â‰ƒâ‚—[R] Î²
{V : Type u} [category_theory.category V] [category_theory.abelian V] {A B C D A' B' C' D' : V} {f : A âŸ¶ B} {g : B âŸ¶ C} {h : C âŸ¶ D} {f' : A' âŸ¶ B'} {g' : B' âŸ¶ C'} {h' : C' âŸ¶ D'} {Î± : A âŸ¶ A'} {Î² : B âŸ¶ B'} {Î³ : C âŸ¶ C'} {Î´ : D âŸ¶ D'} (commâ‚ : Î± â‰« f' = f â‰« Î²) (commâ‚‚ : Î² â‰« g' = g â‰« Î³) (commâ‚ƒ : Î³ â‰« h' = h â‰« Î´) {E E' : V} {i : D âŸ¶ E} {i' : D' âŸ¶ E'} {Îµ : E âŸ¶ E'} (commâ‚„ : Î´ â‰« i' = i â‰« Îµ) (hfg : category_theory.exact f g) (hgh : category_theory.exact g h) (hhi : category_theory.exact h i) (hf'g' : category_theory.exact f' g') (hg'h' : category_theory.exact g' h') (hh'i' : category_theory.exact h' i') [category_theory.is_iso Î±] [category_theory.is_iso Î²] [category_theory.is_iso Î´] [category_theory.is_iso Îµ] : category_theory.is_iso Î³
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (f n) Î¼) (hg : measure_theory.mem_â„’p g p Î¼) (hui : measure_theory.unif_integrable f p Î¼) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (g x))) : filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
{C : â„• â†’ Sort u} {n m : â„•} : n â‰¤ m â†’ (Î  {k : â„•}, C k â†’ C (k + 1)) â†’ C n â†’ C m
{Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (f : Î± â†’ Î²) (Hf : continuous f) (C : â„) (H : âˆ€ (x : Î±), âˆ¥f xâˆ¥ â‰¤ C) : bounded_continuous_function Î± Î²
{Z : Type u_1} {N : Type u_2} {R : Type u_3} [pseudo_metric_space R] {d : N â†’ â„} {j : Z â†’ N â†’ R} {f : R â†’ R} {Î± : R} {Îµ M : â„} (d0 : âˆ€ (a : N), 1 â‰¤ d a) (e0 : 0 < Îµ) (B : âˆ€ â¦ƒy : Râ¦„, y âˆˆ metric.closed_ball Î± Îµ â†’ has_dist.dist (f Î±) (f y) â‰¤ has_dist.dist Î± y * M) (L : âˆ€ â¦ƒz : Zâ¦„ â¦ƒa : Nâ¦„, j z a âˆˆ metric.closed_ball Î± Îµ â†’ 1 â‰¤ d a * has_dist.dist (f Î±) (f (j z a))) : âˆƒ (A : â„), 0 < A âˆ§ âˆ€ (z : Z) (a : N), 1 â‰¤ d a * (has_dist.dist Î± (j z a) * A)
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : Î± â†’ ennreal) : measure_theory.measure Î±
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.outer_regular] (A : set Î±) (r : ennreal) (hr : â‡‘Î¼ A < r) : âˆƒ (U : set Î±) (H : U âŠ‡ A), is_open U âˆ§ â‡‘Î¼ U < r
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (hâ‚ : I â‰¤ lie_algebra.center R L) (hâ‚‚ : lie_algebra.is_nilpotent R (L â§¸ I)) : lie_algebra.is_nilpotent R L
{R : Type u} [comm_ring R] (I J : ideal R) : R â§¸ I â†’+* R â§¸ I âŠ” J
{Î± : Type u_1} {F : Type u_3} [normed_group F] {m : measurable_space Î±} (f : Î± â†’ F) (p : ennreal) (Î¼ : measure_theory.measure Î±) : ennreal
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} (s : category_theory.limits.cofork f g) {W : C} {k l : s.X âŸ¶ W} (h : s.Ï€ â‰« k = s.Ï€ â‰« l) (j : category_theory.limits.walking_parallel_pair) : s.Î¹.app j â‰« k = s.Î¹.app j â‰« l
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (Î¸ : real.angle) : hb.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {E'' : Type u_5} {F : Type u_6} {F' : Type u_7} {F'' : Type u_8} [normed_group E] [normed_group E'] [normed_group E''] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ E''] [normed_space â„ F] [normed_space ğ•œ F] [complete_space F] [measurable_space G] {Î¼ : measure_theory.measure G} (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [normed_group F'] [normed_space â„ F'] [normed_space ğ•œ F'] [complete_space F'] [normed_group F''] [normed_space â„ F''] [normed_space ğ•œ F''] [complete_space F''] {k : G â†’ E''} (Lâ‚‚ : F â†’L[ğ•œ] E'' â†’L[ğ•œ] F') (Lâ‚ƒ : E â†’L[ğ•œ] F'' â†’L[ğ•œ] F') (Lâ‚„ : E' â†’L[ğ•œ] E'' â†’L[ğ•œ] F'') [add_group G] [has_measurable_add G] [measure_theory.sigma_finite Î¼] {Î½ : measure_theory.measure G} [measure_theory.sigma_finite Î½] [Î½.is_add_right_invariant] (hL : âˆ€ (x : E) (y : E') (z : E''), â‡‘(â‡‘Lâ‚‚ (â‡‘(â‡‘L x) y)) z = â‡‘(â‡‘Lâ‚ƒ x) (â‡‘(â‡‘Lâ‚„ y) z)) {xâ‚€ : G} (hâ‚„ : convolution_exists g k Lâ‚„ Î½) (hâ‚ : convolution_exists f g L Î¼) (hi : measure_theory.integrable (function.uncurry (Î» (x y : G), â‡‘(â‡‘Lâ‚ƒ (f y)) (â‡‘(â‡‘Lâ‚„ (g (x - y))) (k (xâ‚€ - x))))) (Î½.prod Î¼)) : convolution (convolution f g L Î¼) k Lâ‚‚ Î½ xâ‚€ = convolution f (convolution g k Lâ‚„ Î½) Lâ‚ƒ Î¼ xâ‚€
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) [fintype Î¹] : nnreal
{E : Type u_3} [has_norm E] [add_comm_group E] [metric_space E] (H1 : âˆ€ (x : E), âˆ¥xâˆ¥ = has_dist.dist x 0) (H2 : âˆ€ (x y z : E), has_dist.dist x y â‰¤ has_dist.dist (x + z) (y + z)) : normed_group E
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {t : set Î±} {x : Î±} {Î¦ : Î± â†’ Î²} (hÎ¦ : isometry Î¦) : metric.inf_dist (Î¦ x) (Î¦ '' t) = metric.inf_dist x t
{Î± : Type u} [topological_space Î±] {Î² : Type u_1} [topological_space Î²] [totally_disconnected_space Î²] {f : Î± â†’ Î²} (h : continuous f) (a : Î±) : f '' connected_component a = {f a}
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {S : J.cover X} (I : S.relation) : S.arrow
{ğ•œ : Type u_1} [normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : subspace ğ•œ E} (hFc : is_closed â†‘F) (hF : âˆƒ (x : E), x âˆ‰ F) {r : â„} (hr : r < 1) : âˆƒ (xâ‚€ : E), xâ‚€ âˆ‰ F âˆ§ âˆ€ (y : E), y âˆˆ F â†’ r * âˆ¥xâ‚€âˆ¥ â‰¤ âˆ¥xâ‚€ - yâˆ¥
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : set Î±) (H : function.injective f) : â†¥s â‰ƒ â†¥(f '' s)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_artinian R M] (f : â„• â†’ submodule R M) (h : âˆ€ (n : â„•), disjoint (â‡‘(partial_sups (â‡‘order_dual.to_dual âˆ˜ f)) n) (â‡‘order_dual.to_dual (f (n + 1)))) : âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ f m = âŠ¤
{Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), comm_ring (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’ G j) (P : Type uâ‚) [comm_ring P] (g : Î  (i : Î¹), G i â†’+* P) (Hg : âˆ€ (i j : Î¹) (hij : i â‰¤ j) (x : G i), â‡‘(g j) (f i j hij x) = â‡‘(g i) x) : ring.direct_limit G f â†’+* P
{M : Type u_1} {Î± : Type u_4} [monoid M] {c : con M} (u : c.quotientË£) (f : Î  (x y : M), â‡‘c (x * y) 1 â†’ â‡‘c (y * x) 1 â†’ Î±) (Hf : âˆ€ (x y : M) (hxy : â‡‘c (x * y) 1) (hyx : â‡‘c (y * x) 1) (x' y' : M) (hxy' : â‡‘c (x' * y') 1) (hyx' : â‡‘c (y' * x') 1), â‡‘c x x' â†’ â‡‘c y y' â†’ f x y hxy hyx = f x' y' hxy' hyx') : Î±
{R : Type u} [comm_ring R] {I : ideal R} : I.radical = I.jacobson â†” âŠ¥.radical = âŠ¥.jacobson
{K : Type u_4} [normed_field K] {Î¾ : K} : summable (Î» (n : â„•), Î¾ ^ n) â†” âˆ¥Î¾âˆ¥ < 1
{Î± : Type u_1} {m0 : measurable_space Î±} [encodable Î±] [measurable_singleton_class Î±] (Î¼ : measure_theory.measure Î±) : measure_theory.measure.sum (Î» (a : Î±), â‡‘Î¼ {a} â€¢ measure_theory.measure.dirac a) = Î¼
{I : Type wâ‚€} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {D : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (D i)] {F G : Î  (i : I), C i â¥¤ D i} (Î± : Î  (i : I), F i âŸ¶ G i) : category_theory.functor.pi F âŸ¶ category_theory.functor.pi G
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [linear_order Î±] {a b : Î±} {P : Î± â†’ Prop} : (âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.interval_oc a b â†’ P x) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.Ioc a b â†’ P x) âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.Ioc b a â†’ P x
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} {G' : Type wG'} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] [normed_group G'] [normed_space ğ•œ G'] (f : G â†’â‚—[ğ•œ] multilinear_map ğ•œ E G') (C : â„) (H : âˆ€ (x : G) (m : Î  (i : Î¹), E i), âˆ¥â‡‘(â‡‘f x) mâˆ¥ â‰¤ C * âˆ¥xâˆ¥ * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : G â†’L[ğ•œ] continuous_multilinear_map ğ•œ E G'
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_zero_class N] â¦ƒf g : (Î± â†’â‚€ M) â†’+ Nâ¦„ (H : âˆ€ (x : Î±) (y : M), â‡‘f (finsupp.single x y) = â‡‘g (finsupp.single x y)) : f = g
{R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {s : set M} {f g : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (H : set.eq_on â‡‘f â‡‘g s) â¦ƒx : Mâ¦„ (h : x âˆˆ submodule.span R s) : â‡‘f x = â‡‘g x
{E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] (f : E â†’+ F) (C : â„) (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : lipschitz_with C.to_nnreal â‡‘f
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : âˆ€áµ (x : Î±) âˆ‚Î½, Î¼.rn_deriv Î½ x < âŠ¤
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â‰ƒg G') : G â†ªg G'
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R â†’+* S) (g : S â†’+* R) (I : ideal R) (h : function.left_inverse â‡‘g â‡‘f) : ideal.map f I â‰¤ ideal.comap g I
{Î± : Type u_1} {m : measurable_space Î±} (c : measure_theory.complex_measure Î±) (Î¼ : measure_theory.measure Î±) : Î± â†’ â„‚
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] (I : category_theory.limits.multicospan_index C) : â†¥((I.multicospan â‹™ category_theory.forget C).sections) â‰ƒ {x // âˆ€ (i : I.R), â‡‘(I.fst i) (x (I.fst_to i)) = â‡‘(I.snd i) (x (I.snd_to i))}
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ = 0 â†” m âˆˆ closure â†‘S
{C : Type u} [category_theory.category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) (U : category_theory.sieve X) (B : Î  â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, â‡‘U f â†’ category_theory.sieve Y) (hU : category_theory.presieve.is_sheaf_for P â‡‘U) (hB : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„ (hf : â‡‘U f), category_theory.presieve.is_sheaf_for P â‡‘(B hf)) (hB' : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„ (h : â‡‘U f) â¦ƒZ : Câ¦„ (g : Z âŸ¶ Y), category_theory.presieve.is_separated_for P â‡‘(category_theory.sieve.pullback g (B h))) : category_theory.presieve.is_sheaf_for P â‡‘(category_theory.sieve.bind â‡‘U B)
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} {g : E â†’ â„} (hg : concave_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) (hgi : measure_theory.integrable_on (g âˆ˜ f) t Î¼) : (â¨ (x : Î±) in t, f x âˆ‚Î¼, â¨ (x : Î±) in t, g (f x) âˆ‚Î¼) âˆˆ {p : E Ã— â„ | p.fst âˆˆ s âˆ§ p.snd â‰¤ g p.fst}
(I : Type u_1) (R : Type u_2) [non_unital_ring R] [topological_space R] [topological_ring R] : topological_ring (I â†’ R)
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =O[l] g' â†’ (f =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} [group G] [has_measurable_mul G] [Î¼.is_mul_left_invariant] (f : G â†’ E) (g : G) : âˆ« (x : G), f (g * x) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
{N : Type u_1} {G : Type u_2} [group N] [group G] {Ï† : G â†’* mul_aut N} : N â‹Š[Ï†] G â†’* G
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [complete_space F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] [complete_space G] (Ï† : implicit_function_data ğ•œ E F G) : F â†’ G â†’ E
{A : Type uâ‚} [category_theory.category A] {B : Type uâ‚} [category_theory.category B] {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚} [category_theory.category D] {F G : A â¥¤ B} {H I : C â¥¤ D} (Î± : F âŸ¶ G) (Î² : H âŸ¶ I) : F.sum H âŸ¶ G.sum I
{L : first_order.language} {Î± : Type u'} (Ï† : L.formula Î±) : L.formula Î±
{Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : bounded_continuous_function â†¥s â„) (hs : is_closed s) : âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ g.restrict s = f
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : add_subgroup G} [Î¼.is_add_right_invariant] : measure_theory.vadd_invariant_measure â†¥(Î“.opposite) G Î¼
{Î¹ : Type u} {Î± : Î¹ â†’ Type u_2} {Î´ : Î  (i : Î¹), Î± i â†’ Type v} [Î  (i : Î¹) (j : Î± i), has_zero (Î´ i j)] (f : Î â‚€ (i : Î£ (i : Î¹), Î± i), Î´ i.fst i.snd) : Î â‚€ (i : Î¹) (j : Î± i), Î´ i j
{Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {u v w : set Î±} (hu : measurable_set u) (hv : measurable_set v) (hw : measurable_set w) (hsu : measure_theory.vector_measure.restrict s u â‰¤ 0.restrict u) (hwâ‚ : â‡‘s w = 0) (hwâ‚‚ : w âŠ† u) (hwt : v âŠ† w) : â‡‘s v = 0
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s t : set Î±} (H : s =áµ[Î¼] t) : â‡‘Î¼ s = â‡‘Î¼ t
{Î± : Type u_1} {f g : Î± â†’ ennreal} {Mf Mg mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hMf : Mf â‰¤ mÎ±) (hMg : Mg â‰¤ mÎ±) (h_ind : probability_theory.indep Mf Mg Î¼) (h_meas_f : measurable f) (h_meas_g : measurable g) : âˆ«â» (a : Î±), f a * g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] {Î¼ : Î  (i : Î¹), measure_theory.measure (Î± i)} [âˆ€ (i : Î¹), measure_theory.sigma_finite (Î¼ i)] (i : Î¹) [measure_theory.has_no_atoms (Î¼ i)] : measure_theory.has_no_atoms (measure_theory.measure.pi Î¼)
{Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} [has_dist E] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : Î¹ â†’ Î± â†’ E) (l : filter Î¹) (g : Î± â†’ E) : Prop
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] [complete_space E] {T : E â†’L[ğ•œ] E} (hT : inner_product_space.is_self_adjoint â†‘T) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0) (hextr : is_min_on T.re_apply_inner_self (metric.sphere 0 âˆ¥xâ‚€âˆ¥) xâ‚€) : module.End.has_eigenvector â†‘T (â†‘â¨… (x : {x // x â‰  0}), (Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) â†‘x) xâ‚€
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î¹ : Type u_2} {L : filter Î¹} [L.is_countably_generated] (Î¼ : measure_theory.finite_measure Î±) {fs : Î¹ â†’ bounded_continuous_function Î± nnreal} {c : nnreal} (fs_le_const : âˆ€á¶  (i : Î¹) in L, âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, â‡‘(fs i) a â‰¤ c) {f : Î± â†’ nnreal} (fs_lim : âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, filter.tendsto (Î» (i : Î¹), â‡‘(fs i) a) L (nhds (f a))) : filter.tendsto (Î» (i : Î¹), âˆ«â» (a : Î±), â†‘(â‡‘(fs i) a) âˆ‚â†‘Î¼) L (nhds (âˆ«â» (a : Î±), â†‘(f a) âˆ‚â†‘Î¼))
{K : Type u_1} [comm_ring K] [is_domain K] [char_zero K] {Î¶ : K} {n : â„•+} (h : is_primitive_root Î¶ â†‘n) : âˆƒ! (P : polynomial â„¤), polynomial.map (int.cast_ring_hom K) P = polynomial.cyclotomic' â†‘n K
{Î± : Type u_1} [topological_space Î±] (dist : Î± â†’ Î± â†’ â„) (dist_self : âˆ€ (x : Î±), dist x x = 0) (dist_comm : âˆ€ (x y : Î±), dist x y = dist y x) (dist_triangle : âˆ€ (x y z : Î±), dist x z â‰¤ dist x y + dist y z) (H : âˆ€ (s : set Î±), is_open s â†” âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ (y : Î±), dist x y < Îµ â†’ y âˆˆ s)) (eq_of_dist_eq_zero : âˆ€ (x y : Î±), dist x y = 0 â†’ x = y) : metric_space Î±
{R : Type u} [comm_semiring R] (I J : ideal R) : I â€¢ J = I * J
{Î¹ : Type u_1} [decidable_eq Î¹] (A : Î¹ â†’ Type u_2) [Î  (i : Î¹), add_comm_monoid (A i)] [add_monoid Î¹] [direct_sum.gsemiring A] [Î  (i : Î¹) (x : A i), decidable (x â‰  0)] (a a' : direct_sum Î¹ (Î» (i : Î¹), A i)) : a * a' = ((dfinsupp.support a).product (dfinsupp.support a')).sum (Î» (ij : Î¹ Ã— Î¹), â‡‘(direct_sum.of A (ij.fst + ij.snd)) (graded_monoid.ghas_mul.mul (â‡‘a ij.fst) (â‡‘a' ij.snd)))
{Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : vitali_family Î¼
{Î± : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] â¦ƒÏ† Ïˆ : (Î± â†’â‚€ M) â†’â‚—[R] Nâ¦„ (h : âˆ€ (a : Î±), Ï†.comp (finsupp.lsingle a) = Ïˆ.comp (finsupp.lsingle a)) : Ï† = Ïˆ
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : Prop
{V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : âˆ¥x - yâˆ¥ = |âˆ¥xâˆ¥ - âˆ¥yâˆ¥|
(p : Prop) (cfg : slim_check.slim_check_cfg := {num_inst := 100, max_size := 100, trace_discarded := bool.ff, trace_success := bool.ff, trace_shrink := bool.ff, trace_shrink_candidates := bool.ff, random_seed := option.none â„•, quiet := bool.ff}) (p' : slim_check.tactic.decorations_of p . "mk_decorations") [slim_check.testable p'] : io punit
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : set â†¥(set.range f)) : â†¥(set.range_splitting f '' s) â‰ƒ â†¥s
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {W X Y : C} [category_theory.limits.has_binary_biproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) : X âŠ Y âŸ¶ W
{n : â„•+} {K : Type u} {L : Type v} (C : Type w) [field K] [field L] [comm_ring C] [algebra K L] [algebra K C] [is_cyclotomic_extension {n} K L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) [is_domain C] [ne_zero â†‘â†‘n] (hirr : irreducible (polynomial.cyclotomic â†‘n K)) : (L â†’â‚[K] C) â‰ƒ â†¥(primitive_roots â†‘n C)
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [add_group G] [topological_add_group G] [Î¼.is_add_left_invariant] {U : set G} (hU : (interior U).nonempty) (h : â‡‘Î¼ U â‰  âŠ¤) {K : set G} (hK : is_compact K) : â‡‘Î¼ K < âŠ¤
{R : Type u} [semiring R] {f : polynomial R} {I : submodule (polynomial R) (polynomial R)} (cf : âˆ€ (i : â„•), f.coeff i âˆˆ â‡‘polynomial.C â»Â¹' I.carrier) : submodule.span (polynomial R) {g : polynomial R | âˆƒ (i : â„•), g = â‡‘polynomial.C (f.coeff i)} â‰¤ I
{Î´' : Type u_5} {Ï€ : Î´' â†’ Type u_7} {Ï€' : Î´' â†’ Type u_8} [Î  (x : Î´'), measurable_space (Ï€ x)] [Î  (x : Î´'), measurable_space (Ï€' x)] (e : Î  (a : Î´'), Ï€ a â‰ƒáµ Ï€' a) : (Î  (a : Î´'), Ï€ a) â‰ƒáµ Î  (a : Î´'), Ï€' a
{E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} {f' : E â†’ (E â†’L[ğ•œ] G)} (hf : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥f' xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} [topological_space Î²] [has_zero Î²] {m0 : measurable_space Î±} (hf : measure_theory.strongly_measurable f) (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : measure_theory.fin_strongly_measurable f Î¼
{Î² : Type v} [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {Î± : Type u_1} [linear_order Î±] [topological_space Î±] [order_topology Î±] {f : Î± â†’ Î²} (Mf : monotone f) (x : Î±) : filter.tendsto f (nhds_within x (set.Iio x)) (nhds (has_Sup.Sup (f '' set.Iio x)))
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M â†’â‚™* N) (s : set M) : subsemigroup.map f (subsemigroup.closure s) = subsemigroup.closure (â‡‘f '' s)
{L : first_order.language} {L' : first_order.language} (Ï† : L â‰ƒá´¸ L') : L.sentence â‰ƒ L'.sentence
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} (Î¼ : measure_theory.measure Î±) [normed_group E] {f : Î± â†’ E} (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) (hf : measure_theory.ae_strongly_measurable f Î¼) (Îµ : ennreal) : Îµ ^ p.to_real * â‡‘Î¼ {x : Î± | Îµ â‰¤ â†‘âˆ¥f xâˆ¥â‚Š} â‰¤ measure_theory.snorm f p Î¼ ^ p.to_real
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (c : M) : Type
{Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (n : â„•) : measure_theory.conservative f^[n] Î¼
{Î± : Type u} [semiring Î±] (I : ideal Î±) : Prop
{Î± : Type u_1} [measurable_space Î±] {P : (Î± â†’ ennreal) â†’ Prop} (h_ind : âˆ€ (c : ennreal) â¦ƒs : set Î±â¦„, measurable_set s â†’ P (s.indicator (Î» (_x : Î±), c))) (h_add : âˆ€ â¦ƒf g : Î± â†’ ennrealâ¦„, disjoint (function.support f) (function.support g) â†’ measurable f â†’ measurable g â†’ P f â†’ P g â†’ P (f + g)) (h_supr : âˆ€ â¦ƒf : â„• â†’ Î± â†’ ennrealâ¦„, (âˆ€ (n : â„•), measurable (f n)) â†’ monotone f â†’ (âˆ€ (n : â„•), P (f n)) â†’ P (Î» (x : Î±), â¨† (n : â„•), f n x)) â¦ƒf : Î± â†’ ennrealâ¦„ (hf : measurable f) : P f
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set V} (hs : âˆ€ (v : V), v âˆˆ s â†’ v â‰  0) (pâ‚ : P) : linear_independent k (Î» (v : â†¥s), â†‘v) â†” affine_independent k (Î» (p : â†¥({pâ‚} âˆª (Î» (v : V), v +áµ¥ pâ‚) '' s)), â†‘p)
{R : Type u_1} [euclidean_domain R] {abv : absolute_value R â„¤} {Î¹ : Type u_2} [fintype Î¹] {Îµ : â„} (hÎµ : 0 < Îµ) {b : R} (hb : b â‰  0) (h : abv.is_admissible) (A : fin (h.card Îµ ^ fintype.card Î¹).succ â†’ Î¹ â†’ R) : âˆƒ (iâ‚€ iâ‚ : fin (h.card Îµ ^ fintype.card Î¹).succ), iâ‚€ â‰  iâ‚ âˆ§ âˆ€ (k : Î¹), â†‘(â‡‘abv (A iâ‚ k % b - A iâ‚€ k % b)) < â‡‘abv b â€¢ Îµ
{Î± : Type u_1} {Î² : Type u_2} [primcodable Î±] [primcodable Î²] (s : Î± â†’ Î² â†’ Prop) [Î  (a : Î±) (b : Î²), decidable (s a b)] : Prop
{G : Type w} [topological_space G] (Î¼ : measure_theory.content G) [t2_space G] â¦ƒU : â„• â†’ set Gâ¦„ (hU : âˆ€ (i : â„•), is_open (U i)) : Î¼.inner_content âŸ¨â‹ƒ (i : â„•), U i, _âŸ© â‰¤ âˆ‘' (i : â„•), Î¼.inner_content âŸ¨U i, _âŸ©
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) {n : â„•} {f : fin n â†’ Î± â†’ Î²} (hf : âˆ€ (i : fin n), measure_theory.mem_â„’p (f i) p Î¼) : measure_theory.unif_integrable f p Î¼
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : category_theory.limits.multicoequalizer I â‰… category_theory.limits.coequalizer I.fst_sigma_map I.snd_sigma_map
{A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] {I J : ideal A} : I âˆ£ J â†” J â‰¤ I
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î±} {s : set Î±} [measure_theory.is_finite_measure Î¼] (hf : measure_theory.measure_preserving f Î¼ Î¼) (hs : measurable_set s) (hs' : â‡‘Î¼ s â‰  0) : âˆƒ (x : Î±) (H : x âˆˆ s) (m : â„•) (H : m â‰  0), f^[m] x âˆˆ s
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {Î¼ : measure_theory.measure â„} [measure_theory.is_finite_measure Î¼] (c : E) : âˆ« (x : â„) in a..b, c âˆ‚Î¼ = ((â‡‘Î¼ (set.Iic b)).to_real - (â‡‘Î¼ (set.Iic a)).to_real) â€¢ c
{Î± : Type u} [pseudo_emetric_space Î±] : uniformity Î± = â¨… (Îµ : ennreal) (H : Îµ > 0), filter.principal {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < Îµ}
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (W : submodule R M) : submodule R (module.dual R M)
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (W : submodule ğ•œ E) (x y : â†¥W) : has_inner.inner x y = has_inner.inner â†‘x â†‘y
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {p : nnreal} {s : set Î±} (h : s âŠ† {x : Î± | v.lim_ratio_meas hÏ x < â†‘p}) : â‡‘Ï s â‰¤ â†‘p * â‡‘Î¼ s
{F : Type u_3} [inner_product_space â„ F] {x y : F} : has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆ¥yâˆ¥ â€¢ x = âˆ¥xâˆ¥ â€¢ y
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {C : â„} (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_continuous C hâˆ¥ â‰¤ linear_order.max C 0
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} [inhabited Î›] {Ïƒ : Type u_4} [inhabited Ïƒ] (M : Î› â†’ turing.TM2.stmt Î“ Î› Ïƒ) : turing.TM2.cfg Î“ Î› Ïƒ â†’ turing.TM1.cfg turing.TM2to1.Î“' turing.TM2to1.Î›' Ïƒ â†’ Prop
{C : Type u} [category_theory.category C] {W X Y : C} [category_theory.limits.has_binary_product X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) : W âŸ¶ X â¨¯ Y
{R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) (t : R) (h : âˆ¥tâˆ¥ < âˆ¥â†‘xâ»Â¹âˆ¥â»Â¹) : RË£
{Î² : Type u_2} [uniform_space Î²] {Î± : Type u_1} {f : Î± â†’ Î²} {s : set (Î² Ã— Î²)} (hs : s âˆˆ uniformity Î²) (hf : pairwise (Î» (x y : Î±), (f x, f y) âˆ‰ s)) : uniform_embedding f
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
{Î± : Type u_1} [normed_field Î±] {E : Type u_5} [semi_normed_group E] [normed_space Î± E] {c : Î±} (hc : 1 < âˆ¥câˆ¥) {Îµ : â„} (Îµpos : 0 < Îµ) {x : E} (hx : âˆ¥xâˆ¥ â‰  0) : âˆƒ (d : Î±), d â‰  0 âˆ§ âˆ¥d â€¢ xâˆ¥ < Îµ âˆ§ Îµ / âˆ¥câˆ¥ â‰¤ âˆ¥d â€¢ xâˆ¥ âˆ§ âˆ¥dâˆ¥â»Â¹ â‰¤ Îµâ»Â¹ * âˆ¥câˆ¥ * âˆ¥xâˆ¥
{R : Type u} [semiring R] (I : ideal (polynomial R)) (n : â„•) : ideal R
{X : Type u} {Y : Type v} {Z : Type w} [metric_space X] [metric_space Y] [nonempty Z] (Î¦ : Z â†’ X) (Î¨ : Z â†’ Y) (Îµ : â„) (Îµ0 : 0 < Îµ) (H : âˆ€ (p q : Z), |has_dist.dist (Î¦ p) (Î¦ q) - has_dist.dist (Î¨ p) (Î¨ q)| â‰¤ 2 * Îµ) : metric_space (X âŠ• Y)
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s t u : set Î±} (ht : measurable_set t) (h's : s âŠ† u) (h't : t âŠ† u) (h : â‡‘Î¼ u < â‡‘Î¼ s + â‡‘Î¼ t) : (s âˆ© t).nonempty
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} {Ïƒ : Type u_4} : turing.TM2.stmt Î“ Î› Ïƒ â†’ Ïƒ â†’ (Î  (k : K), list (Î“ k)) â†’ turing.TM2.cfg Î“ Î› Ïƒ
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) (G : Type u_4) [add_group G] [topological_space G] [charted_space H G] : Prop
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (f : E â‰ƒL[â„] E) (s : set E) : â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det â†‘f| * â‡‘Î¼ s
{R : Type u} [comm_ring R] (I J : ideal R) : R â§¸ I âŠ” J â†’+* (R â§¸ I) â§¸ ideal.map (ideal.quotient.mk I) J
(Ïƒ : Type u_1) (R : Type u_2) [comm_semiring R] [fintype Ïƒ] (n : â„•) : mv_polynomial.esymm Ïƒ R n = finset.univ.sum (Î» (t : {s // s.card = n}), â†‘t.prod (Î» (i : Ïƒ), mv_polynomial.X i))
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b C : â„} {f : â„‚ â†’ E} {z : â„‚} (hfd : diff_cont_on_cl â„‚ f (complex.re â»Â¹' set.Ioo a b)) (hB : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.im) filter.at_top âŠ“ filter.principal (complex.re â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.im|))) (hle_a : âˆ€ (z : â„‚), z.re = a â†’ âˆ¥f zâˆ¥ â‰¤ C) (hle_b : âˆ€ (z : â„‚), z.re = b â†’ âˆ¥f zâˆ¥ â‰¤ C) (hza : a â‰¤ z.re) (hzb : z.re â‰¤ b) : âˆ¥f zâˆ¥ â‰¤ C
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) : cont_mdiff_map I (model_with_corners_self ğ•œ ğ•œ) M ğ•œ âŠ¤ â†’â‚—[pointed_smooth_map ğ•œ I M âŠ¤ x] ğ•œ
{f f' : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ (âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), slope f x z < r)) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f x = B x â†’ f' x < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {f : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} {g : Î³ â†’ Î´} {f' : Î± â†’ Î²' â†’ Î´} {g' : Î² â†’ Î²'} (h_distrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' a (g' b)) : g '' set.image2 f s t = set.image2 f' s (g' '' t)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (G : Type u_4) [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] : Type (max u_1 u_4)
{C : snum â†’ Sort u_1} (z : Î  (b : bool), C (snum.zero b)) (s : Î  (b : bool) (p : snum), C p â†’ C (b::p)) (p : snum) : C p
{Î± : Type u} {Î² : Type v} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (ne : s.nonempty) (H : bdd_below s) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
{p : â„•} [hp_prime : fact (nat.prime p)] {u : â„š_[p]} (h : âˆ¥uâˆ¥ = 1) : â„¤_[p]Ë£
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] (f : A â†’â‚[R] B) (I : Type u_1) : (I â†’ A) â†’â‚[R] I â†’ B
{ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {p : Î¹ â†’ E} : convex_independent ğ•œ p â†” âˆ€ (i : Î¹) (s : set Î¹), p i âˆ‰ â‡‘(convex_hull ğ•œ) (p '' (s  {i}))
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {D : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (D i)] (F : Î  (i : I), C i â¥¤ D i) : (Î£ (i : I), C i) â¥¤ Î£ (i : I), D i
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) (H : finset (Î£' (X Y : C) (mX : X âˆˆ O) (mY : Y âˆˆ O), X âŸ¶ Y)) : âˆƒ (S : C) (T : Î  {X : C}, X âˆˆ O â†’ (S âŸ¶ X)), âˆ€ {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y}, âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H â†’ T mX â‰« f = T mY
{R : Type u} [comm_ring R] [is_domain R] {M : Type v} [add_comm_group M] [module R M] [is_dedekind_domain R] [module.finite R M] (hM : module.is_torsion R M) : âˆƒ (P : finset (ideal R)) [_inst_7 : decidable_eq â†¥P] [_inst_8 : âˆ€ (p : ideal R), p âˆˆ P â†’ prime p] (e : â†¥P â†’ â„•), direct_sum.is_internal (Î» (p : â†¥P), submodule.torsion_by_set R M â†‘(â†‘p ^ e p))
(c : â„‚) (R : â„) : circle_map c R '' set.Ioc 0 (2 * real.pi) = metric.sphere c |R|
{x : â„} (h : |x| < 1) : has_sum (Î» (n : â„•), x ^ (n + 1) / (â†‘n + 1)) (-real.log (1 - x))
{Ïƒ : Type u_1} {R : Type u_3} {S : Type u_4} [comm_semiring R] [comm_semiring S] (f : R â†’+* mv_polynomial Ïƒ S) : mv_polynomial Ïƒ R â†’+* mv_polynomial Ïƒ S
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {G : Type u_5} [topological_space Î±] [add_comm_group Î±] [topological_add_group Î±] [topological_space Î²] [add_comm_group Î²] [topological_add_group Î²] [topological_space Î³] [add_comm_group Î³] [topological_add_group Î³] [topological_space Î´] [add_comm_group Î´] [topological_add_group Î´] [uniform_space G] [add_comm_group G] [uniform_add_group G] [separated_space G] [complete_space G] {e : Î² â†’+ Î±} (de : dense_inducing â‡‘e) {f : Î´ â†’+ Î³} (df : dense_inducing â‡‘f) {Ï† : Î² â†’+ Î´ â†’+ G} (hÏ† : continuous (Î» (p : Î² Ã— Î´), â‡‘(â‡‘Ï† p.fst) p.snd)) : continuous (_.extend (Î» (p : Î² Ã— Î´), â‡‘(â‡‘Ï† p.fst) p.snd))
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : â„} {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : asymptotics.is_O_with c l f (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ asymptotics.is_O_with c l f g'
{Fq : Type u_1} [fintype Fq] [field Fq] (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : polynomial Fq} (hb : b â‰  0) (A : fin n â†’ polynomial Fq) : âˆƒ (t : fin n â†’ fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š)), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†’ â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
{C : Type u} [category_theory.category C] {I : category_theory.limits.multispan_index C} (K : category_theory.limits.multicofork I) (b : I.R) : I.right b âŸ¶ K.X
{C : Type u} [category_theory.category C] (I J : category_theory.limits.has_zero_morphisms C) : I = J
{R : Type u_1} [semiring R] (Ï† : power_series R) (n : â„•) (h : âˆ€ (i : â„•), i < n â†’ â‡‘(power_series.coeff R i) Ï† = 0) : â†‘n â‰¤ Ï†.order
{Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} {L : filter Î¹} [L.is_countably_generated] [topological_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.finite_measure Î±) {c : nnreal} {E : set Î±} (E_mble : measurable_set E) (fs : Î¹ â†’ bounded_continuous_function Î± nnreal) (fs_bdd : âˆ€á¶  (i : Î¹) in L, âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, â‡‘(fs i) a â‰¤ c) (fs_lim : âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, filter.tendsto (Î» (i : Î¹), â‡‘(fs i) a) L (nhds (E.indicator (Î» (x : Î±), 1) a))) : filter.tendsto (Î» (n : Î¹), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) L (nhds (â‡‘â†‘Î¼ E))
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] : C
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (âˆ€ (a : set (submodule R M)), a.nonempty â†’ (âˆƒ (M' : submodule R M) (H : M' âˆˆ a), âˆ€ (I : submodule R M), I âˆˆ a â†’ M' â‰¤ I â†’ I = M')) â†” is_noetherian R M
{Î¹ : Type u_1} {I : box_integral.box Î¹} : has_le (box_integral.prepartition I)
{Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) (s : set Î±) : â‡‘Î¼ s = â¨… (t : {t // s âŠ† t âˆ§ measurable_set t}), â‡‘Î¼ â†‘t
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [normal_space Î±] [borel_space Î±] (E : Type u_2) [normed_group E] [second_countable_topology_either Î± E] {p : ennreal} [fact (1 â‰¤ p)] (hp : p â‰  âŠ¤) (Î¼ : measure_theory.measure Î±) [normed_space â„ E] [Î¼.weakly_regular] : (measure_theory.Lp.bounded_continuous_function E p Î¼).topological_closure = âŠ¤
{E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] {f : E â†’ F} {C : nnreal} : lipschitz_with C f â†’ âˆ€ (x y : E), âˆ¥f x - f yâˆ¥ â‰¤ â†‘C * âˆ¥x - yâˆ¥
{Î± : Type u} {Î² : Type v} {Ï† : ultrafilter Î±} [linear_order Î²] : linear_order (â†‘Ï†.germ Î²)
{F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s t : set Î±} [measure_theory.is_finite_measure Î¼] (hms : measurable_set s) (hcs : â‡‘Î¼ s â‰  0) (hcs' : â‡‘Î¼ sá¶œ â‰  0) : â‡‘(probability_theory.cond Î¼ s) t * â‡‘Î¼ s + â‡‘(probability_theory.cond Î¼ sá¶œ) t * â‡‘Î¼ sá¶œ = â‡‘Î¼ t
{Î± : Type u} [pseudo_emetric_space Î±] {s : set (Î± Ã— Î±)} : s âˆˆ uniformity Î± â†” âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î±}, has_edist.edist a b < Îµ â†’ (a, b) âˆˆ s
{Î² : Type u_2} [normed_group Î²] {Î± : Type u_1} {m : measurable_space Î±} (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (f : Z âŸ¶ Y) (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) : J.cocomplex.X 1 âŸ¶ I.cocomplex.X 1
{a b : â„} (n : â„•) : âˆ« (x : â„) in a..b, real.sin x ^ (n + 2) = (real.sin a ^ (n + 1) * real.cos a - real.sin b ^ (n + 1) * real.cos b) / (â†‘n + 2) + (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, real.sin x ^ n
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) (i : fin (n + 2)) : (s.altitude i).direction = (vector_span â„ (s.points '' â†‘(finset.univ.erase i)))á—® âŠ“ vector_span â„ (set.range s.points)
{Î² : Type u_1} [comm_monoid Î²] (f : â„• â†’ Î²) (h_mult : âˆ€ (x y : â„•), x.coprime y â†’ f (x * y) = f x * f y) (hf : f 1 = 1) {n : â„•} : n â‰  0 â†’ f n = n.factorization.prod (Î» (p k : â„•), f (p ^ k))
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} : smooth_manifold_with_corners I H
{E : Type u_3} [normed_group E] (f : â„ â†’ E) (Î¼ : measure_theory.measure â„) (a b : â„) : Prop
{Î± : Type u_1} {m : measurable_space Î±} (s : measure_theory.signed_measure Î±) (Î¼ : measure_theory.measure Î±) : measure_theory.signed_measure Î±
(semireducible : interactive.parse (optional (lean.parser.tk "!"))) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (use : interactive.parse (lean.parser.tk "using" *> lean.parser.many interactive.types.ident_ <|> return list.nil)) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := Î» (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (Î» (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic unit
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {f : smooth_partition_of_unity Î¹ I M s} {U : Î¹ â†’ set M} : f.is_subordinate U â†’ f.to_partition_of_unity.is_subordinate U
{p q : Prop} (h : q â†’ p) : slim_check.test_result p â†’ (psum unit (p â†’ q) := psum.inl ()) â†’ slim_check.test_result q
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} {s : set Î²} : tendsto_uniformly_on F f p s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), x âˆˆ s â†’ has_edist.edist (f x) (F n x) < Îµ)
{Sâ‚ : Type v} {Sâ‚‚ : Type w} (Ïƒ : Type u_1) [comm_semiring Sâ‚] [comm_semiring Sâ‚‚] (e : Sâ‚ â‰ƒ+* Sâ‚‚) : mv_polynomial Ïƒ Sâ‚ â‰ƒ+* mv_polynomial Ïƒ Sâ‚‚
{Î± : Type u_1} [topological_space Î±] [sigma_compact_space Î±] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] : Î¼.finite_spanning_sets_in {K : set Î± | is_open K}
{R : Type u} [comm_ring R] (I : ideal R) : Prop
{C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (G : D â¥¤ C) [category_theory.is_right_adjoint G] [Î  â¦ƒA B : Dâ¦„ (f g : A âŸ¶ B) [_inst_5 : G.is_split_pair f g], category_theory.creates_colimit (category_theory.limits.parallel_pair f g) G] : category_theory.monadic_right_adjoint G
(fn : name) (args : list expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic expr
{Î± : Type u_1} [fintype Î±] [decidable_eq Î±] (Ïƒ : equiv.perm Î±) : multiset â„•
{Î± : Type u} (p : Î± â†’ Sort u_1) {f : Î± â†’ Î±} (h : Î  (a : Î±), p a â†’ p (f a)) {a : Î±} (ha : p a) (n : â„•) : p (f^[n] a)
{elab : bool} : expr elab â†’ option pos
{F : Type u_2} [normed_group F] [normed_space â„ F] {x y : F} (hx : x â‰  0) (hy : y â‰  0) : same_ray â„ x y â†” âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [hÎ¼ : measure_theory.is_finite_measure Î¼] : measure_theory.signed_measure Î±
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ E} {C : â„} [strict_convex_space â„ E] [measure_theory.is_finite_measure Î¼] (h_le : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ¥f xâˆ¥ â‰¤ C) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆ¥âˆ« (x : Î±), f x âˆ‚Î¼âˆ¥ < (â‡‘Î¼ set.univ).to_real * C
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] (f : Î± â†’ Î²) (hf : measure_theory.integrable f Î¼) : â†¥(measure_theory.Lp Î² 1 Î¼)
{R : Type u} [comm_semiring R] (I : ideal (polynomial R)) (p : polynomial R) (hp : âˆ€ (n : â„•), p.coeff n âˆˆ ideal.comap polynomial.C I) : p âˆˆ I
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {c : â„} {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : asymptotics.is_O_with c l f' g' â†’ asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥)
(renames : name_map name) (strict : bool := bool.tt) (use_unique_names : bool := bool.ff) : tactic unit
{Î± : Type u} [pseudo_metric_space Î±] : (uniformity Î±).has_basis (Î» (Îµ : ennreal), 0 < Îµ) (Î» (Îµ : ennreal), {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < Îµ})
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {s : set M} (hs : unique_mdiff_on I s) (x : M) (y : M') {f : M â†’ M'} (hf : continuous_on f s) : unique_diff_on ğ•œ ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source))
{G : Type u_1} [measurable_space G] [add_comm_group G] {Î¼ : measure_theory.measure G} [Î¼.is_add_left_invariant] : Î¼.is_add_right_invariant
{R : Type u_1} [comm_ring R] (I : ideal R) : (nhds 0).has_basis (Î» (n : â„•), true) (Î» (n : â„•), â†‘(I ^ n))
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] (P : Î± â†’ Prop) (h : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, P x)) : âˆ€áµ (x : Î±) âˆ‚Î¼, P x
(P : Î  (R : Type u) [_inst_7 : comm_ring R], Prop) : Prop
{a b : â„} (ha : a â‰¤ 0) {z : â„‚} (hz : |z.im| â‰¤ b) (hb : b â‰¤ real.pi / 2) : complex.abs (complex.exp (â†‘a * (complex.exp z + complex.exp (-z)))) â‰¤ real.exp (a * real.cos b * real.exp |z.re|)
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [normed_group F] {f : Î± â†’ E} {g : Î± â†’ F} (hg : measure_theory.mem_â„’p g p Î¼) (hf : measure_theory.ae_strongly_measurable f Î¼) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ¥f xâˆ¥ â‰¤ âˆ¥g xâˆ¥) : measure_theory.mem_â„’p f p Î¼
{R : Type u_1} [ring R] (Ï† : power_series R) : Ï† - â‡‘(power_series.C R) (â‡‘(power_series.constant_coeff R) Ï†) = power_series.mk (Î» (p : â„•), â‡‘(power_series.coeff R (p + 1)) Ï†) * power_series.X
{I : Type u_5} {A : Type u_6} {X : I â†’ Type u_7} [topological_space A] [Î  (i : I), topological_space (X i)] (f : Î  (i : I), C(A, X i)) : C(A, Î  (i : I), X i)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_5} [topological_space H] {H' : Type u_6} [topological_space H'] (I : model_with_corners ğ•œ E H) (I' : model_with_corners ğ•œ E' H') (M : Type u_8) [topological_space M] [charted_space H M] (M' : Type u_9) [topological_space M'] [charted_space H' M'] (n : with_top â„•) : Type (max u_8 u_9)
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (Ïƒ : R â†’+* S) (M : Type u_3) [topological_space M] [add_comm_monoid M] (Mâ‚‚ : Type u_4) [topological_space Mâ‚‚] [add_comm_monoid Mâ‚‚] [module R M] [module S Mâ‚‚] : Type (max u_3 u_4)
{E : Type u} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {f' : E} {x r : â„} (hf : has_deriv_within_at f f' (set.Ici x) x) (hr : âˆ¥f'âˆ¥ < r) : âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), âˆ¥z - xâˆ¥â»Â¹ * âˆ¥f z - f xâˆ¥ < r
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {Ïƒâ‚‚â‚ : ğ•œâ‚‚ â†’+* ğ•œ} [ring_hom_inv_pair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] [ring_hom_inv_pair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] (f : E â‰ƒâ‚›â‚—[Ïƒâ‚â‚‚] F) (a : â„) (ha : 0 < a) (hf : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ = a * âˆ¥xâˆ¥) : E â‰ƒSL[Ïƒâ‚â‚‚] F
{Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} (f : â†¥(measure_theory.Lp.simple_func E p Î¼)) : measure_theory.simple_func Î± E
{Î± : Type u_1} {Î² : Type u_2} [add_monoid Î²] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (T : set Î± â†’ Î²) : Prop
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x : E) (S : submodule ğ•œ E) [complete_space E] [complete_space â†¥S] : âˆ¥xâˆ¥ ^ 2 = âˆ¥â‡‘(orthogonal_projection S) xâˆ¥ ^ 2 + âˆ¥â‡‘(orthogonal_projection Sá—®) xâˆ¥ ^ 2
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (h : W âŸ¶ X) (k : W âŸ¶ Y) (Hâ‚ : category_theory.limits.is_terminal Z) (Hâ‚‚ : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk h k)) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk h k _)
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.tagged_prepartition I) : Prop
(env : environment) (results : list (name Ã— linter Ã— native.rb_map name string)) (decls non_auto_decls : list declaration) (group_by_filename : option â„•) (where_desc : string) (slow : bool) (verbose : lint_verbosity) (num_linters : â„•) (emit_workflow_commands : bool := bool.ff) : format
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (h : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰  âŠ¤) {Îµ : ennreal} (hÎµ : Îµ â‰  0) : âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ (s : set Î±), â‡‘Î¼ s < Î´ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ < Îµ
{R : Type u} {Î¹ : Type v} [comm_ring R] {L : Type w} [lie_ring L] [lie_algebra R L] (I : Î¹ â†’ lie_ideal R L) [decidable_eq Î¹] : Prop
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (C : set (set Î±)) : Type u_1
{Î± : Type u_1} {G : Type u_5} [normed_group G] {m : measurable_space Î±} {Î¼ Î¼' : measure_theory.measure Î±} (c' : ennreal) (hc' : c' â‰  âŠ¤) (hÎ¼'_le : Î¼' â‰¤ c' â€¢ Î¼) : continuous (Î» (f : â†¥(measure_theory.Lp G 1 Î¼)), measure_theory.integrable.to_L1 â‡‘f _)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {x : E} {s : set E} (h : has_fderiv_within_at f f' s x) {Î± : Type u_4} (l : filter Î±) {c : Î± â†’ ğ•œ} {d : Î± â†’ E} {v : E} (dtop : âˆ€á¶  (n : Î±) in l, x + d n âˆˆ s) (clim : filter.tendsto (Î» (n : Î±), âˆ¥c nâˆ¥) l filter.at_top) (cdlim : filter.tendsto (Î» (n : Î±), c n â€¢ d n) l (nhds v)) : filter.tendsto (Î» (n : Î±), c n â€¢ (f (x + d n) - f x)) l (nhds (â‡‘f' v))
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [nontrivial R] {m : M} {S : set M} (h : add_monoid_algebra.of' R M m âˆˆ submodule.span R â†‘(submonoid.closure (add_monoid_algebra.of' R M '' S))) : m âˆˆ add_submonoid.closure S
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î²] [measurable_space Î±] (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î±) : measure_theory.measure Î²
(bang : interactive.parse (optional (lean.parser.tk "!"))) (trace : interactive.parse (optional (lean.parser.tk "?"))) (cfg : tactic.tidy.cfg := {trace_result := bool.ff, trace_result_prefix := "Try this: ", tactics := tactic.tidy.default_tactics}) : tactic unit
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M â†’ M') : tangent_bundle I M â†’ tangent_bundle I' M'
{G : Type u_1} [group G] [topological_space G] [topological_group G] {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) : âˆƒ (n : â„•), n âˆˆ finset.card '' {t : finset G | K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g * h) â»Â¹' V}
(a b : â„) (f : â„ â†’ â„) (c : continuous_on f (set.Icc a b)) (Îµ : â„) (pos : 0 < Îµ) : âˆƒ (p : polynomial â„), âˆ€ (x : â„), x âˆˆ set.Icc a b â†’ |polynomial.eval x p - f x| < Îµ
{Î¹ : Type u_10} {R : Type u_11} {Râ‚‚ : Type u_12} {M : Type u_13} {Mâ‚‚ : Type u_14} [semiring R] [semiring Râ‚‚] [add_comm_monoid M] [module R M] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [topological_space M] [topological_space Mâ‚‚] {Ïƒ : R â†’+* Râ‚‚} {Ïƒ' : Râ‚‚ â†’+* R} [ring_hom_inv_pair Ïƒ Ïƒ'] [ring_hom_inv_pair Ïƒ' Ïƒ] {f : Î¹ â†’ M} (e : M â‰ƒSL[Ïƒ] Mâ‚‚) {y : Mâ‚‚} : has_sum (Î» (b : Î¹), â‡‘e (f b)) y â†” has_sum f (â‡‘(e.symm) y)
{a b : â„} {g' g Ï† : â„ â†’ â„} (hab : a â‰¤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at g (g' x) (set.Ioi x) x) (Ï†int : measure_theory.integrable_on Ï† (set.Icc a b) measure_theory.measure_space.volume) (hÏ†g : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ g' x â‰¤ Ï† x) : g b - g a â‰¤ âˆ« (y : â„) in a..b, Ï† y
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (b : B.is_symm) (W : submodule R M) : (B.restrict W).is_symm
{ğ•† : Type u_1} {â„™ : Type u_2} {Î± : Type u_3} [preorder ğ•†] [preorder Â«â„™Â»] [preorder Î±] [grade_order ğ•† Î±] (f : ğ•† â†’ Â«â„™Â») (hf : strict_mono f) (hcovby : âˆ€ (a b : ğ•†), a â‹– b â†’ f a â‹– f b) : grade_order Â«â„™Â» Î±
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (c : complex_shape Î¹) (F : V â¥¤ W) [F.additive] : homotopy_category V c â¥¤ homotopy_category W c
{P : â„• â†’ Sort u_1} (h0 : P 0) (h1 : P 1) (h : Î  (a p n : â„•), nat.prime p â†’ Â¬p âˆ£ a â†’ 0 < n â†’ P a â†’ P (p ^ n * a)) (a : â„•) : P a
{V : Type u_1} [inner_product_space â„ V] (x y : V) : real.sin (inner_product_geometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = real.sqrt (has_inner.inner x x * has_inner.inner y y - has_inner.inner x y * has_inner.inner x y)
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) [ring_hom_isometric Ïƒâ‚â‚‚] : âˆ¥fâˆ¥ = 0 â†” f = 0
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] : category_theory.limits.multicofork I
{R : Type u_1} [semiring R] {Ï† Ïˆ : power_series R} : Ï† = Ïˆ â†” âˆ€ (n : â„•), â‡‘(power_series.coeff R n) Ï† = â‡‘(power_series.coeff R n) Ïˆ
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr Ã— expr)
{p : â„•} {f : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R} (hf : witt_vector.is_polyâ‚‚ p f) : witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), f x x)
{S : Type uâ‚} {L : Type uâ‚‚} {D : Type uâ‚ƒ} [category_theory.category S] [category_theory.category L] [category_theory.category D] (Î¹ : S â¥¤ L) (F : S â¥¤ D) [I : âˆ€ (x : L), category_theory.limits.has_colimit (category_theory.Lan.diagram Î¹ F x)] : L â¥¤ D
{V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {G : Type u_4} [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] (g : G) (X : left_invariant_derivation I G) : â‡‘(hfdifferential _) (â‡‘(derivation.eval_at 1) â†‘X) = â‡‘(derivation.eval_at g) â†‘X
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] (f : Î± â†’ Î²) (hf : measure_theory.ae_strongly_measurable f Î¼) : Î± â†’ Î²
{Î± : Type u} {Î² : Type v} {Ï† : ultrafilter Î±} [linear_ordered_ring Î²] : linear_ordered_ring (â†‘Ï†.germ Î²)
{Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] [decidable_eq Î¹] [add_monoid Î¹] (ğ’œ : Î¹ â†’ submodule R A) [graded_algebra ğ’œ] (I : ideal A) : homogeneous_ideal ğ’œ
{Î± : Type u_1} (m : set (measure_theory.outer_measure Î±)) {s : set Î±} (hm : m.nonempty) : â‡‘(measure_theory.outer_measure.restrict s) (has_Inf.Inf m) = has_Inf.Inf (â‡‘(measure_theory.outer_measure.restrict s) '' m)
{Î± : Type u_1} [measurable_space Î±] (f : Î± â†’ ennreal) (p : â„) (Î¼ : measure_theory.measure Î±) : Î± â†’ ennreal
{Î± : Type u} [topological_space Î±] (U : set Î±) : coe â»Â¹' (coe '' U) = â‹ƒ (x : Î±) (H : x âˆˆ U), connected_component x
(p : pos) (pre post : string) (args : list tactic.simp_arg_type) (at_pos : bool := bool.ff) : tactic unit
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} (hf : cont_mdiff_on I I' n f s) (hmn : 1 â‰¤ n) (hs : unique_mdiff_on I s) : continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I M â»Â¹' s)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) {G : Type u_4} [has_mul G] [topological_space G] [charted_space H G] [has_smooth_mul I G] (g : G) : cont_mdiff_map I I G G âŠ¤
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (ğ•œ : Type u_3) [field ğ•œ] [is_alg_closed ğ•œ] [category_theory.linear ğ•œ C] [category_theory.limits.has_kernels C] (X : C) [category_theory.simple X] [I : finite_dimensional ğ•œ (X âŸ¶ X)] : finite_dimensional.finrank ğ•œ (X âŸ¶ X) = 1
{Î± : Type u_1} {F : Type u_3} [normed_group F] {m : measurable_space Î±} (f : Î± â†’ F) (Î¼ : measure_theory.measure Î±) : ennreal
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (h : â†‘(S.topological_closure) = set.univ) : âˆ¥S.normed_mkâˆ¥ = 0
{Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (hs : s.nonempty) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
{N : Type u_1} {G : Type u_2} [group N] [group G] {Ï† : G â†’* mul_aut N} {Nâ‚ : Type u_4} {Gâ‚ : Type u_5} [group Nâ‚] [group Gâ‚] {Ï†â‚ : Gâ‚ â†’* mul_aut Nâ‚} (fâ‚ : N â†’* Nâ‚) (fâ‚‚ : G â†’* Gâ‚) (h : âˆ€ (g : G), fâ‚.comp (mul_equiv.to_monoid_hom (â‡‘Ï† g)) = (mul_equiv.to_monoid_hom (â‡‘Ï†â‚ (â‡‘fâ‚‚ g))).comp fâ‚) : N â‹Š[Ï†] G â†’* Nâ‚ â‹Š[Ï†â‚] Gâ‚
{elab : bool} : expr elab â†’ expr elab
{R : Type u} [ring R] {Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) (i j : Î¹) : G i â†’â‚—[R] G j
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (Î¼ : R) : â„•
{S : Type u} [semigroup S] : transitive (Î» (a b : S), âˆƒ (c : S), semiconj_by c a b)
{X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X â†’ E} {Î¼ : measure_theory.measure X} {K : set X} (hK : is_compact K) (hf : âˆ€ (x : X), x âˆˆ K â†’ measure_theory.integrable_at_filter f (nhds_within x K) Î¼) : measure_theory.integrable_on f K Î¼
{C : Type u} [category_theory.category C] {A : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] {I : C} (t : category_theory.limits.is_initial I) : A â¨¯ I â‰… I
{Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), topological_space (E i)] {s : Î  (i : Î¹), set (set (E i))} (hs : âˆ€ (i : Î¹), topological_space.is_topological_basis (s i)) : topological_space.is_topological_basis (â‹ƒ (i : Î¹), (Î» (u : set (E i)), sigma.mk i '' u) '' s i)
{Î± : Type u} {Ïƒ : Type v} (M : NFA Î± Ïƒ) : language Î±
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : nnreal
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_equalizer f g] {W : C} (k : W âŸ¶ X) (h : k â‰« f = k â‰« g) : W âŸ¶ category_theory.limits.equalizer f g
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {f : â„‚ â†’ E} (hd : diff_cont_on_cl â„‚ f {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : asymptotics.superpolynomial_decay filter.at_top real.exp (Î» (x : â„), âˆ¥f â†‘xâˆ¥)) (him : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) : set.eq_on f 0 {z : â„‚ | 0 â‰¤ z.re}
(R : Type u) [comm_ring R] : galois_connection (Î» (I : ideal R), prime_spectrum.zero_locus â†‘I) (Î» (t : (set (prime_spectrum R))áµ’áµˆ), prime_spectrum.vanishing_ideal t)
{Î± : Type u_1} {C : free_add_monoid Î± â†’ Sort u_2} (xs : free_add_monoid Î±) (h0 : C 0) (ih : Î  (x : Î±) (xs : free_add_monoid Î±), C xs â†’ C (free_add_monoid.of x + xs)) : C xs
{Î± : Type u_1} {m0 : measurable_space Î±} â¦ƒs s' : set Î±â¦„ (hs : s âŠ† s') â¦ƒÎ¼ Î½ : measure_theory.measure Î±â¦„ (hÎ¼Î½ : Î¼ â‰¤ Î½) : Î¼.restrict s â‰¤ Î½.restrict s'
{R : Type u} {Î¹ : Type x} [semiring R] {Ï† : Î¹ â†’ Type i} [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] [decidable_eq Î¹] (i : Î¹) : Ï† i â†’â‚—[R] Î  (i : Î¹), Ï† i
{R : Type u_1} [comm_semiring R] (I : ideal R) [hp : I.is_prime] : submonoid R
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] {H : Type w} [topological_space H] (I : model_with_corners ğ•œ E H) : model_with_corners ğ•œ (E Ã— E) (model_prod H E)
{ğ•œ : Type u_1} {A : Type u_2} [comm_ring ğ•œ] [no_zero_divisors ğ•œ] [topological_space ğ•œ] [has_continuous_add ğ•œ] [has_continuous_const_smul ğ•œ ğ•œ] [topological_space A] [semiring A] [algebra ğ•œ A] (Ï† : â†¥(weak_dual.character_space ğ•œ A)) : A â†’â‚[ğ•œ] ğ•œ
{Î± : Type u_1} {Î³ : Type u_3} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) [topological_space Î±] [borel_space Î±] {ğ•œ : Type u_5} [semiring ğ•œ] [topological_space Î³] [topological_space.pseudo_metrizable_space Î³] [add_comm_group Î³] [module ğ•œ Î³] [topological_add_group Î³] [has_continuous_const_smul ğ•œ Î³] [second_countable_topology_either Î± Î³] : C(Î±, Î³) â†’â‚—[ğ•œ] Î± â†’â‚˜[Î¼] Î³
{V : Type u_1} {W : Type u_2} [semi_normed_group V] [semi_normed_group W] (f : V â†’+ W) (C : â„) (h : âˆ€ (v : V), âˆ¥â‡‘f vâˆ¥ â‰¤ C * âˆ¥vâˆ¥) : normed_group_hom V W
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (n : with_top â„•) (f : M â†’ M') (s : set M) : Prop
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] {p : ennreal} {g : Î± â†’ Î²} (hp : 1 â‰¤ p) (hp_ne_top : p â‰  âŠ¤) (hgm : measure_theory.strongly_measurable g) (hg : measure_theory.mem_â„’p g p Î¼) : measure_theory.uniform_integrable (Î» (n : Î¹), g) p Î¼
{Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [hp : fact (1 â‰¤ p)] (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp_meas_subgroup F m p Î¼)) : âˆ¥measure_theory.Lp_meas_subgroup_to_Lp_trim F p Î¼ hm fâˆ¥ = âˆ¥fâˆ¥
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_noetherian R M] (f : M â†’â‚—[R] M) : âˆƒ (n : â„•), n â‰  0 âˆ§ (f ^ n).ker âŠ“ (f ^ n).range = âŠ¥
{Î± : Type u_1} {ğ•œ : Type u_2} [linear_ordered_field ğ•œ] (G : simple_graph Î±) [decidable_rel G.adj] (Îµ : ğ•œ) (s t : finset Î±) : finset Î± Ã— finset Î±
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [measure_theory.is_locally_finite_measure Î¼] (x : Î±) : âˆ€á¶  (a : set Î±) in v.filter_at x, â‡‘Î¼ a < âŠ¤
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} {P : Î  (x : Î±), Î² x â†’ Prop} [c : Î  (a : Î±), encodable (Î² a)] [d : Î  (x : Î±) (y : Î² x), decidable (P x y)] : (âˆ€ (x : Î±), âˆƒ (y : Î² x), P x y) â†” âˆƒ (f : Î  (a : Î±), Î² a), âˆ€ (x : Î±), P x (f x)
{Î¹ : Type u_1} [fintype Î¹] [decidable_eq Î¹] {D : Î¹ â†’ â„} (h : (matrix.diagonal D).det â‰  0) : ennreal.of_real |(matrix.diagonal D).det| â€¢ measure_theory.measure.map â‡‘(â‡‘matrix.to_lin' (matrix.diagonal D)) measure_theory.measure_space.volume = measure_theory.measure_space.volume
{C : Type u} [category_theory.category C] [category_theory.limits.has_strict_initial_objects C] {I : C} (X : C) [category_theory.limits.has_binary_product X I] (hI : category_theory.limits.is_initial I) : X â¨¯ I â‰… I
{R : Type u} [comm_ring R] (I : ideal R) (h : âˆ€ (J : ideal R) (hJ : J.is_maximal), is_localization.coe_submodule (localization.at_prime J) I = 0) : I = 0
{R : Type u_1} [semiring R] {Ï† Ïˆ : power_series R} {n : â„•} (h : â†‘n < Ïˆ.order) : â‡‘(power_series.coeff R n) (Ï† * Ïˆ) = 0
(Î¹ : Type u_1) (X : Type u_2) [topological_space X] (s : set X := set.univ) : Type (max u_1 u_2)
{Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] [encodable Î²] [measurable_singleton_class Î²] (Î¼ : measure_theory.measure Î±) (f : Î± â†’ Î²) (hf : measurable f) : measure_theory.measure.map f Î¼ = measure_theory.measure.sum (Î» (b : Î²), â‡‘Î¼ (f â»Â¹' {b}) â€¢ measure_theory.measure.dirac b)
{Î± : Type u_1} [pseudo_metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s : set Î±} (hs : âˆƒ (R : â„) (H : R > 0), â‡‘Î¼ (metric.cthickening R s) â‰  âŠ¤) : filter.tendsto (Î» (r : â„), â‡‘Î¼ (metric.cthickening r s)) (nhds 0) (nhds (â‡‘Î¼ (closure s)))
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [semiring Râ‚] [semiring Râ‚‚] (Ïƒ : Râ‚ â†’+* Râ‚‚) (Ïƒ' : out_param (Râ‚‚ â†’+* Râ‚)) : Prop
{V : Type u} [category_theory.category V] [category_theory.preadditive V] [category_theory.limits.has_zero_object V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] [category_theory.limits.has_zero_object W] (F : V â¥¤ W) [F.additive] : cochain_complex.singleâ‚€ V â‹™ F.map_homological_complex (complex_shape.up â„•) â‰… F â‹™ cochain_complex.singleâ‚€ W
{Î± : Type u} {Ïƒ : Type v} (M : Îµ_NFA Î± Ïƒ) : language Î±
{I : Type vâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {J : Type vâ‚} [category_theory.small_category J] {F : J â¥¤ Î  (i : I), C i} [âˆ€ (i : I), category_theory.limits.has_limit (F â‹™ category_theory.pi.eval C i)] : category_theory.limits.has_limit F
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {s : set Î±} {t : set Î²} {f : Î± â†’ Î²' â†’ Î³} {g : Î² â†’ Î²'} {f' : Î² â†’ Î± â†’ Î´} {g' : Î´ â†’ Î³} (h_right_anticomm : âˆ€ (a : Î±) (b : Î²), f a (g b) = g' (f' b a)) : set.image2 f s (g '' t) = g' '' set.image2 f' t s
{Î¹a : Type u_7} {Î¹b : Type u_8} [decidable_eq Î¹a] [decidable_eq Î¹b] [fintype Î¹a] [fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [comm_semiring R'] [add_comm_group Nâ‚] [module R' Nâ‚] [add_comm_group Nâ‚‚] [module R' Nâ‚‚] [add_comm_monoid Máµ¢] [module R' Máµ¢] (a : alternating_map R' Máµ¢ Nâ‚ Î¹a) (b : alternating_map R' Máµ¢ Nâ‚‚ Î¹b) (Ïƒ : equiv.perm.mod_sum_congr Î¹a Î¹b) {v : Î¹a âŠ• Î¹b â†’ Máµ¢} {i j : Î¹a âŠ• Î¹b} (hv : v i = v j) (hij : i â‰  j) : â‡‘(alternating_map.dom_coprod.summand a b Ïƒ) v + â‡‘(alternating_map.dom_coprod.summand a b (equiv.swap i j â€¢ Ïƒ)) v = 0
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [group G] [topological_group G] [Î¼.is_mul_left_invariant] (U : set G) (hU : is_open U) (h'U : U.nonempty) (h : â‡‘Î¼ U â‰  âŠ¤) {K : set G} (hK : is_compact K) : â‡‘Î¼ K < âŠ¤
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {S T : J.cover X} (I : S.relation) (f : S âŸ¶ T) : T.relation
{Î± : Type u_1} {E : Type u_2} [normed_group E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : measure_theory.simple_func Î± E} {g : E â†’ ennreal} (hf : measure_theory.integrable â‡‘f Î¼) (hg0 : g 0 = 0) (ht : âˆ€ (b : E), g b â‰  âŠ¤) : measure_theory.simple_func.integral Î¼ (measure_theory.simple_func.map (ennreal.to_real âˆ˜ g) f) = (âˆ«â» (a : Î±), g (â‡‘f a) âˆ‚Î¼).to_real
{Î¹ : Type u_1} {M : Type u_2} [add_comm_monoid M] {Iâ‚€ : with_top (box_integral.box Î¹)} {I : box_integral.box Î¹} [fintype Î¹] (f : box_integral.box_additive_map Î¹ M Iâ‚€) (hI : â†‘I â‰¤ Iâ‚€) {Ï€â‚ Ï€â‚‚ : box_integral.prepartition I} (h : Ï€â‚.Union = Ï€â‚‚.Union) : Ï€â‚.boxes.sum (Î» (J : box_integral.box Î¹), â‡‘f J) = Ï€â‚‚.boxes.sum (Î» (J : box_integral.box Î¹), â‡‘f J)
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} {Ïƒ : Type u_3} : turing.TM1.stmt Î“ Î› Ïƒ â†’ finset (turing.TM1.stmt Î“ Î› Ïƒ)
{X : Top} {Î¹ : Type v} (U : Î¹ â†’ topological_space.opens â†¥X) {V W : category_theory.pairwise Î¹} : (V âŸ¶ W) â†’ (Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover_obj U V âŸ¶ Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover_obj U W)
{I : Type u} (X : I â†’ Top) (i : I) : â†¥(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Î  (i : I), â†¥(X i)))) â¥¤ â†¥(fundamental_groupoid.fundamental_groupoid_functor.obj (X i))
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens â†¥X) (R : category_theory.presieve U) (f g : Î£ (V : topological_space.opens â†¥X), {f // R f}) : (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom â‰« category_theory.limits.pi.Ï€ (Î» (p : (Î£ (V : topological_space.opens â†¥X), {f // R f}) Ã— Î£ (V : topological_space.opens â†¥X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R p.fst âŠ“ Top.presheaf.covering_of_presieve U R p.snd))) (f, g) = category_theory.limits.pi.Ï€ (Î» (fg : (Î£ (V : topological_space.opens â†¥X), {f // R f}) Ã— Î£ (W : topological_space.opens â†¥X), {g // R g}), F.obj (opposite.op (category_theory.limits.pullback fg.fst.snd.val fg.snd.snd.val))) (f, g) â‰« F.map (category_theory.eq_to_hom _).op
{x : pgame} : 0.lf x â†” âˆƒ (i : x.left_moves), âˆ€ (j : (x.move_left i).right_moves), 0.lf ((x.move_left i).move_right j)
(I p : name) : tactic (list (list name))
{V : Type u} {W : Type v} (G : simple_graph V) (G' : simple_graph W) : Type (max u v)
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (J : ideal S) : ideal (R Ã— S)
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : âˆƒ (Î½ : measure_theory.measure Î±), measure_theory.is_finite_measure Î½ âˆ§ Î¼.absolutely_continuous Î½
{Î± : Type u_1} {p : multiset Î± â†’ Sort u_2} {n : â„•} (s : multiset Î±) : (Î  (tâ‚ : multiset Î±), (Î  {tâ‚‚ : multiset Î±}, â‡‘multiset.card tâ‚‚ â‰¤ n â†’ tâ‚ < tâ‚‚ â†’ p tâ‚‚) â†’ â‡‘multiset.card tâ‚ â‰¤ n â†’ p tâ‚) â†’ â‡‘multiset.card s â‰¤ n â†’ p s
{Î± : Type u_1} {Î² : Type u_2} (e : Î± â‰ƒ Î²) (s : set Î±) : â†¥s â‰ƒ â†¥(â‡‘e '' s)
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (v : n â†’ R) (A : matrix n n R) : matrix.det (Î» (i j : n), v i * A i j) = finset.univ.prod (Î» (i : n), v i) * A.det
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} [fintype Î¹] (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) {f : Î¹ â†’ Î± â†’ Î²} (hf : âˆ€ (i : Î¹), measure_theory.mem_â„’p (f i) p Î¼) : measure_theory.unif_integrable f p Î¼
(ps : list pexpr) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{P : Type u_1} [preorder P] (p : P) {Î¹ : Type u_2} [encodable Î¹] (ğ’Ÿ : Î¹ â†’ order.cofinal P) (i : Î¹) : âˆƒ (x : P), x âˆˆ ğ’Ÿ i âˆ§ x âˆˆ order.ideal_of_cofinals p ğ’Ÿ
{R : Type u_1} {S : Type u_6} {M : Type u_7} {Mâ‚‚ : Type u_9} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid Mâ‚‚] {module_M : module R M} {module_S_Mâ‚‚ : module S Mâ‚‚} {Ïƒ : R â†’+* S} {Ïƒ' : S â†’+* R} {reâ‚ : ring_hom_inv_pair Ïƒ Ïƒ'} {reâ‚‚ : ring_hom_inv_pair Ïƒ' Ïƒ} (e : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚) : e.to_linear_map.to_add_monoid_hom = e.to_add_equiv.to_add_monoid_hom
{K : Type u} [field K] â¦ƒs t : set Kâ¦„ (h : s âŠ† t) : subfield.closure s â‰¤ subfield.closure t
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h0 : 0 < r) (h : â†‘r < p.radius) : âˆƒ (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C / â†‘r ^ n
(N : Type u_1) (G : Type u_2) [group N] [group G] (Ï† : G â†’* mul_aut N) : Type (max u_1 u_2)
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} (h : Î¼ = Î½) : Î¼.absolutely_continuous Î½
{R : Type u_1} [ring R] (n : â„•) : â†‘-1 = â†‘n - 1
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ E} {C : â„} [strict_convex_space â„ E] (h_le : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ¥f xâˆ¥ â‰¤ C) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆ¥â¨ (x : Î±), f x âˆ‚Î¼âˆ¥ < C
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T âˆˆ dist_triang C) : T.morâ‚ â‰« T.morâ‚‚ = 0
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary f (g âˆ˜ â‡‘Ïƒ)
{L : first_order.language} {Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [is_directed Î¹ has_le.le] : setoid (Î£ (i : Î¹), G i)
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) (x : Î¹ â†’ â„) : set.inj_on (Î» (J : box_integral.box Î¹), {i : Î¹ | J.lower i = x i}) {J : box_integral.box Î¹ | J âˆˆ Ï€ âˆ§ x âˆˆ â‡‘box_integral.box.Icc J}
{ğ•œ : Type u} {A : Type v} [field ğ•œ] [ring A] [algebra ğ•œ A] [is_alg_closed ğ•œ] [nontrivial A] (a : A) (p : polynomial ğ•œ) (hnon : (spectrum ğ•œ a).nonempty) : spectrum ğ•œ (â‡‘(polynomial.aeval a) p) = (Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a
{T : â„} {g : â„ â†’ â„} (hg : function.periodic g T) (h_int : âˆ€ (tâ‚ tâ‚‚ : â„), interval_integrable g measure_theory.measure_space.volume tâ‚ tâ‚‚) (hT : 0 < T) (t : â„) : âˆ« (x : â„) in 0..t, g x â‰¤ has_Sup.Sup ((Î» (t : â„), âˆ« (x : â„) in 0..t, g x) '' set.Icc 0 T) + âŒŠt / TâŒ‹ â€¢ âˆ« (x : â„) in 0..T, g x
{G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [topological_space G] [group G] [topological_group G] [borel_space G] [Î¼.is_mul_left_invariant] [Î¼.regular] (hÎ¼ : Î¼ â‰  0) {f : G â†’ ennreal} (hf : continuous f) : âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0
{R : Type u_1} [comm_ring R] (I : ideal R) {M : Type u_2} [add_comm_group M] [module R M] {N : Type u_3} [add_comm_group N] [module R N] [h : is_Hausdorff I N] (f : M â†’â‚—[R] N) : Hausdorffification I M â†’â‚—[R] N
{F : pfunctor} {r : F.M â†’ Sort w} (x : F.M) (f : Î  (a : F.A) (f : F.B a â†’ F.M), r (pfunctor.M.mk âŸ¨a, fâŸ©)) : r x
{Î¹ : Type u_5} {Ï€ : Î¹ â†’ Type u_6} [fintype Î¹] [Î  (i : Î¹), topological_space (Ï€ i)] [âˆ€ (i : Î¹), discrete_topology (Ï€ i)] : discrete_topology (Î  (i : Î¹), Ï€ i)
{Î± : Type u_1} {ğ•œ : Type u_2} [linear_ordered_field ğ•œ] [decidable_eq Î±] {A : finset Î±} (P : finpartition A) (G : simple_graph Î±) [decidable_rel G.adj] (Îµ : ğ•œ) : finset (finset Î± Ã— finset Î±)
{L : first_order.language} {L' : first_order.language} {Î± : Type u'} (Ï† : L â‰ƒá´¸ L') : L.term Î± â‰ƒ L'.term Î±
{Ïƒ : Type u} : Ïƒ â†ª cardinal
{Î± : Type u} [decidable_eq Î±] (i j : Î±) (Ïƒ : equiv.perm Î±) : equiv.swap i j * (equiv.swap i j * Ïƒ) = Ïƒ
{V : Type (u+1)} [category_theory.large_category V] {W : Type (u+1)} [category_theory.large_category W] (F : V â¥¤ W) (G : Mon) : Action V G â¥¤ Action W G
(I : Type wâ‚€) (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] : category_theory.pi.comap C id â‰… ğŸ­ (Î  (i : I), C i)
(P : Î  {R S : Type u} [_inst_7 : comm_ring R] [_inst_8 : comm_ring S], (R â†’+* S) â†’ Prop) : Prop
{Î± : Type u_1} [non_unital_semi_normed_ring Î±] (x y : Î±) : âˆ¥â‡‘(add_monoid_hom.mul_right x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{B : Type uâ‚} [category_theory.bicategory B] {C : Type uâ‚‚} [category_theory.bicategory C] (obj : B â†’ C) (map : Î  {X Y : B}, (X âŸ¶ Y) â†’ (obj X âŸ¶ obj Y)) (mapâ‚‚ : Î  {a b : B} {f g : a âŸ¶ b}, (f âŸ¶ g) â†’ (map f âŸ¶ map g)) (map_comp : Î  {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c), map (f â‰« g) âŸ¶ map f â‰« map g) {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d) : Prop
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [linear_order Î±] {a b : Î±} {P : Î± â†’ Prop} : (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.interval_oc a b), P x) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.Ioc a b), P x) âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.Ioc b a), P x
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_finite_measure Î¼] (hg : concave_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hÎ¼ : Î¼ â‰  0) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : â¨ (x : Î±), g (f x) âˆ‚Î¼ â‰¤ g (â¨ (x : Î±), f x âˆ‚Î¼)
{G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [add_group G] [has_measurable_add G] [Î¼.is_add_right_invariant] (f : G â†’ ennreal) (g : G) : âˆ«â» (x : G), f (x + g) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {I : ideal S} {f : R â†’+* S} : function.injective â‡‘(I.quotient_map f le_rfl)
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î²] (m : measurable_space Î±) {m0 : measurable_space Î±} (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î±) : Prop
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I : ideal R} (hM : module.is_torsion_by_set R M â†‘I) : has_scalar (R â§¸ I) M
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : Î± â†’ Î²} (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) (hf : measure_theory.mem_â„’p f p Î¼) (hmeas : measure_theory.strongly_measurable f) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (Î´ : â„) (hÎ´ : 0 < Î´), âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰¤ ennreal.of_real Î´ â†’ measure_theory.snorm (s.indicator f) p Î¼ â‰¤ 2 * ennreal.of_real Îµ
{Î± : Type u_1} [nonempty Î±] [semilattice_sup Î±] [no_max_order Î±] {Î² : Type u_2} [semi_normed_group Î²] {f : Î± â†’ Î²} {b : Î²} : filter.tendsto f filter.at_top (nhds b) â†” âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (N : Î±), âˆ€ (n : Î±), N < n â†’ âˆ¥f n - bâˆ¥ < Îµ)
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : (f =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f =O[l] g'
{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] â¦ƒf g : dual_number R â†’â‚[R] Aâ¦„ (h : â‡‘f dual_number.eps = â‡‘g dual_number.eps) : f = g
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [borel_space Î±] [Î¼.weakly_regular] (A : set Î±) (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) : (Î¼.restrict A).weakly_regular
{M : Type u_1} [semi_normed_group M] {S : add_subgroup M} (x : M â§¸ S) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (m : M), â‡‘(quotient_add_group.mk' S) m = x âˆ§ âˆ¥mâˆ¥ < âˆ¥xâˆ¥ + Îµ
{X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X â†’ E} {Î¼ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure Î¼] {K : set X} (hK : is_compact K) (hf : continuous_on f K) : measure_theory.integrable_on f K Î¼
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} {x' : M} (h : x' âˆˆ (ext_chart_at I x).source) (ht : t âˆˆ nhds_within x' s) : â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds_within (â‡‘(ext_chart_at I x) x') (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I)
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [h : measure_theory.sigma_finite Î¼] : Î¼.finite_spanning_sets_in {s : set Î± | measurable_set s}
{R : Type u_1} [semiring R] : 0.order = âŠ¤
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] (p : tangent_bundle I M) : tangent_map I I.tangent (tangent_bundle.zero_section I M) p = âŸ¨âŸ¨p.fst, 0âŸ©, (p.snd, 0)âŸ©
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (f : G â†’+ N) (s : set G) : add_subgroup.map f (add_subgroup.closure s) = add_subgroup.closure (â‡‘f '' s)
{F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
{R : Type u_1} [comm_semiring R] {I : ideal R} [hI : I.is_prime] : ideal.map (algebra_map R (localization.at_prime I)) I = local_ring.maximal_ideal (localization I.prime_compl)
{G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [group G] [has_measurable_mul G] [Î¼.is_mul_left_invariant] (f : G â†’ ennreal) (g : G) : âˆ«â» (x : G), f (g * x) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [topological_space Î²] {f : Î± â†’ Î²} {s : set Î±} (hf : continuous_on f s) (hs : topological_space.is_separable s) : topological_space.is_separable (f '' s)
{R : Type u} {Î¹ : Type x} [semiring R] {Ï† : Î¹ â†’ Type i} [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] (i : Î¹) : (Î  (i : Î¹), Ï† i) â†’â‚—[R] Ï† i
{Î± : Type u_1} [measurable_space Î±] (s : measure_theory.signed_measure Î±) : âˆƒ (i j : set Î±), measurable_set i âˆ§ 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i âˆ§ measurable_set j âˆ§ measure_theory.vector_measure.restrict s j â‰¤ 0.restrict j âˆ§ is_compl i j
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [nonempty Î²] [semilattice_sup Î²] {u : Î² â†’ Î±} : cauchy_seq u â†” âˆ€ (Îµ : nnreal), 0 < Îµ â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), N â‰¤ n â†’ has_edist.edist (u n) (u N) < â†‘Îµ)
(Râ‚ : Type u_3) {A : Type u_5} [comm_semiring Râ‚] [comm_ring A] [algebra Râ‚ A] (I : ideal A) : â†‘(ideal.quotient.mkâ‚ Râ‚ I).ker = I
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p âˆˆ s) : vector_span k s = submodule.span k ((Î» (_x : P), _x -áµ¥ p) '' s)
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds (Ï.rn_deriv Î¼ x))
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] {Ï : measure_theory.measure Î±} (Î½ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î½] (hÏ : Ï.absolutely_continuous Î¼) (s : set Î±) (hs : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒá¶  (a : set Î±) in v.filter_at x, â‡‘Ï a â‰¤ â‡‘Î½ a)) : â‡‘Ï s â‰¤ â‡‘Î½ s
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} [category_theory.limits.has_pullback f g] {W : C} {k l : W âŸ¶ category_theory.limits.pullback f g} (hâ‚€ : k â‰« category_theory.limits.pullback.fst = l â‰« category_theory.limits.pullback.fst) (hâ‚ : k â‰« category_theory.limits.pullback.snd = l â‰« category_theory.limits.pullback.snd) : k = l
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k : â„•} (h : f.has_generalized_eigenvalue Î¼ k) : k â‰  0
{f : â„ â†’ â„} (hf : differentiable â„ f) {C : â„} (hf'_ge : âˆ€ (x : â„), C â‰¤ deriv f x) â¦ƒx y : â„â¦„ (hxy : x â‰¤ y) : C * (y - x) â‰¤ f y - f x
{R : Type u_1} {V : Type u_2} {W : Type u_3} {P : Type u_4} {Q : Type u_5} [ring R] [add_comm_group V] [module R V] [topological_space P] [add_torsor V P] [add_comm_group W] [module R W] [topological_space Q] [add_torsor W Q] {Wâ‚‚ : Type u_6} {Qâ‚‚ : Type u_7} [add_comm_group Wâ‚‚] [module R Wâ‚‚] [topological_space Qâ‚‚] [add_torsor Wâ‚‚ Qâ‚‚] (f : Q â†’A[R] Qâ‚‚) (g : P â†’A[R] Q) : P â†’A[R] Qâ‚‚
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] (W : subspace K V) : (module.dual K V â§¸ submodule.dual_annihilator W) â‰ƒâ‚—[K] module.dual K â†¥W
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (v : n â†’ R) (A : matrix n n R) : matrix.det (Î» (i j : n), v j * A i j) = finset.univ.prod (Î» (i : n), v i) * A.det
(E : Type u_1) [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] : âˆƒ (Î´ : â„), 0 < Î´ âˆ§ Î´ < 1 âˆ§ âˆ€ (s : finset E), (âˆ€ (c : E), c âˆˆ s â†’ âˆ¥câˆ¥ â‰¤ 2) â†’ (âˆ€ (c : E), c âˆˆ s â†’ âˆ€ (d : E), d âˆˆ s â†’ c â‰  d â†’ 1 - Î´ â‰¤ âˆ¥c - dâˆ¥) â†’ s.card â‰¤ besicovitch.multiplicity E
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_equalizer f g] {W : C} (k : W âŸ¶ X) (h : k â‰« f = k â‰« g) : {l // l â‰« category_theory.limits.equalizer.Î¹ f g = k}
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {f : Î± â†’ F'} {s : set Î±} {m mâ‚‚ m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (hmâ‚‚ : mâ‚‚ â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] [measure_theory.sigma_finite (Î¼.trim hmâ‚‚)] (hs_m : measurable_set s) (hs : âˆ€ (t : set Î±), measurable_set (s âˆ© t) â†” measurable_set (s âˆ© t)) : measure_theory.condexp m Î¼ f =áµ[Î¼.restrict s] measure_theory.condexp mâ‚‚ Î¼ f
{Î± : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Î± â†’ E} {g : Î± â†’ â„} {tâ‚€ : filter Î±} (h : âˆ€ (n : Î±), âˆ¥f nâˆ¥ â‰¤ g n) (h' : filter.tendsto g tâ‚€ (nhds 0)) : filter.tendsto f tâ‚€ (nhds 0)
{Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] (ğ’œ : Î¹ â†’ submodule R A) [decidable_eq Î¹] [add_monoid Î¹] [graded_algebra ğ’œ] (I : ideal A) : Prop
{E : Type u} [normed_group E] [normed_space â„ E] {n : â„•} [complete_space E] (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) â†’ â„) â†’ fin (n + 1) â†’ E) (f' : (fin (n + 1) â†’ â„) â†’ ((fin (n + 1) â†’ â„) â†’L[â„] fin (n + 1) â†’ E)) (s : set (fin (n + 1) â†’ â„)) (hs : s.countable) (Hs : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ s â†’ continuous_within_at f (â‡‘box_integral.box.Icc I) x) (Hd : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I  s â†’ has_fderiv_within_at f (f' x) (â‡‘box_integral.box.Icc I) x) : box_integral.has_integral I âŠ¥ (Î» (x : fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i)) box_integral.box_additive_map.volume (finset.univ.sum (Î» (i : fin (n + 1)), box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.upper i) x) i) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.lower i) x) i) box_integral.box_additive_map.volume))
{X : â„• â†’ Type u} [Î  (n : â„•), metric_space (X n)] {f : Î  (n : â„•), X n â†’ X (n + 1)} (I : âˆ€ (n : â„•), isometry (f n)) : metric_space (metric.inductive_limit I)
{Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), normed_group (Ï€ i)] : normed_group (Î  (i : Î¹), Ï€ i)
{K : Type u} [division_ring K] (I : ideal K) : I = âŠ¥ âˆ¨ I = âŠ¤
{Î± : Type u_1} {E : Î± â†’ Type u_2} [Î  (i : Î±), normed_group (E i)] {p q : ennreal} (hpq : p.to_real.is_conjugate_exponent q.to_real) (f : â†¥(lp E p)) (g : â†¥(lp E q)) : summable (Î» (i : Î±), âˆ¥â‡‘f iâˆ¥ * âˆ¥â‡‘g iâˆ¥) âˆ§ âˆ‘' (i : Î±), âˆ¥â‡‘f iâˆ¥ * âˆ¥â‡‘g iâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥gâˆ¥
{E : Type u_2} [normed_group E] [normed_space â„ E] (h : âˆ€ (x y : E), âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†’ same_ray â„ x y) : strict_convex_space â„ E
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : âˆ I.left âŸ¶ âˆ I.right
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {f : E â†’â‚—[â„] E} (hf : â‡‘linear_map.det f â‰  0) (s : set E) : â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |(â‡‘linear_map.det f)â»Â¹| * â‡‘Î¼ s
(p : â„•) [fact (nat.prime p)] {R : Type uâ‚} [comm_semiring R] [char_p R p] {P : Type uâ‚‚} [comm_semiring P] [char_p P p] [perfect_ring P p] (Ï€ : P â†’+* R) : Prop
{Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] [complete_space E] {f : (Î¹ â†’ â„) â†’ E} {Î¼ : measure_theory.measure (Î¹ â†’ â„)} [measure_theory.is_locally_finite_measure Î¼] {I : box_integral.box Î¹} (hf : measure_theory.integrable_on f â†‘I Î¼) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l f Î¼.to_box_additive.to_smul (âˆ« (x : Î¹ â†’ â„) in â†‘I, f x âˆ‚Î¼)
{Î± : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} {Î¼ : measure_theory.measure E} {F : Type u_3} [measurable_space F] {Î½ : measure_theory.measure F} {X : Î± â†’ E} [measure_theory.has_pdf X Â«â„™Â» Î¼] {g : E â†’ F} (hg : measure_theory.measure.quasi_measure_preserving g Î¼ Î½) (hmap : (measure_theory.measure.map g (measure_theory.measure.map X Â«â„™Â»)).have_lebesgue_decomposition Î½) : measure_theory.has_pdf (g âˆ˜ X) Â«â„™Â» Î½
 : interactive.parse (î€€sum.inlî€sum.inlî€‚î€€functor.mapî€ <$> î€‚(lean.parser.tk ":" *> interactive.types.texpr) <|> î€€sum.inrî€sum.inrî€‚î€€functor.mapî€ <$> î€‚interactive.parse_binders interactive.types.tac_rbp) â†’ tactic unit
{R : Type u_1} [comm_ring R] {I J : ideal R} (hIJ : I â‰¤ J) {x : R} : â‡‘(ideal.quotient.mk I) x âˆˆ ideal.map (ideal.quotient.mk I) J â†” x âˆˆ J
{V : Type u} {W : Type v} {X : Type w} {G : simple_graph V} {G' : simple_graph W} {G'' : simple_graph X} (f' : G' â†’g G'') (f : G â†’g G') : G â†’g G''
(ğ•œ : Type u_1) (V : Type u_3) (W : Type u_4) [normed_group V] [normed_group W] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ V] [normed_space ğ•œ W] : (V â†’A[ğ•œ] W) â‰ƒâ‚—áµ¢[ğ•œ] W Ã— (V â†’L[ğ•œ] W)
{R : Type u_1} [comm_semiring R] {I : ideal R} [hI : I.is_prime] : ideal.comap (algebra_map R (localization.at_prime I)) (local_ring.maximal_ideal (localization I.prime_compl)) = I
{Î± : Type u_1} {m0 : measurable_space Î±} â¦ƒs s' : set Î±â¦„ â¦ƒÎ¼ Î½ : measure_theory.measure Î±â¦„ (hs : s â‰¤áµ[Î¼] s') (hÎ¼Î½ : Î¼ â‰¤ Î½) : Î¼.restrict s â‰¤ Î½.restrict s'
{F : Type u_3} [inner_product_space â„ F] {K : set F} (ne : K.nonempty) (hâ‚ : is_complete K) (hâ‚‚ : convex â„ K) (u : F) : âˆƒ (v : F) (H : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (w : â†¥K), âˆ¥u - â†‘wâˆ¥
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} (ğ•œ : Type u_6) [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ F] [complete_space F] {T : set Î± â†’ (E â†’L[â„] F)} {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) (h_smul : âˆ€ (c : ğ•œ) (s : set Î±) (x : E), â‡‘(T s) (c â€¢ x) = c â€¢ â‡‘(T s) x) : â†¥(measure_theory.Lp E 1 Î¼) â†’L[ğ•œ] F
{F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
{I : Type wâ‚€} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {X Y : Î  (i : I), C i} (f : X â‰… Y) (i : I) : X i â‰… Y i
(ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] {s : set E} (s_nhd : s âˆˆ nhds 0) : is_closed (coe_fn '' normed_space.polar ğ•œ s)
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] (h : box_integral.integrable I l f vol) : box_integral.box_additive_map Î¹ F â†‘I
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr)
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), add_zero_class (Î² i)] {Î³ : Type w} [add_zero_class Î³] â¦ƒf g : (Î â‚€ (i : Î¹), Î² i) â†’+ Î³â¦„ (H : âˆ€ (x : Î¹), f.comp (dfinsupp.single_add_hom Î² x) = g.comp (dfinsupp.single_add_hom Î² x)) : f = g
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} {W : C} {inl : Y âŸ¶ W} {inr : Z âŸ¶ W} (eq : f â‰« inl = g â‰« inr) (desc : Î  (s : category_theory.limits.pushout_cocone f g), W âŸ¶ s.X) (fac_left : âˆ€ (s : category_theory.limits.pushout_cocone f g), inl â‰« desc s = s.inl) (fac_right : âˆ€ (s : category_theory.limits.pushout_cocone f g), inr â‰« desc s = s.inr) (uniq : âˆ€ (s : category_theory.limits.pushout_cocone f g) (m : W âŸ¶ s.X), inl â‰« m = s.inl â†’ inr â‰« m = s.inr â†’ m = desc s) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk inl inr eq)
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds a) (hfs : f '' s âˆˆ nhds (f a)) : continuous_at f a
{Î± : Type u_1} (C : lists Î± â†’ Sort u_2) (D : lists' Î± bool.tt â†’ Sort u_3) (C0 : Î  (a : Î±), C (lists.atom a)) (C1 : Î  (l : lists' Î± bool.tt), D l â†’ C (lists.of' l)) (D0 : D lists'.nil) (D1 : Î  (a : lists Î±) (l : lists' Î± bool.tt), C a â†’ D l â†’ D (lists'.cons a l)) : pprod (Î  (l : lists Î±), C l) (Î  (l : lists' Î± bool.tt), D l)
{Î¹ : Type u_1} {Î² : Î¹ â†’ Type u_2} (r : Î¹ â†’ Î¹ â†’ Prop) (s : Î  {i : Î¹}, Î² i â†’ Î² i â†’ Prop) (x y : Î  (i : Î¹), Î² i) : Prop
{Î± : Type u_1} [topological_space Î±] [sigma_compact_space Î±] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] : Î¼.finite_spanning_sets_in {K : set Î± | is_compact K}
{C : Type u} [category_theory.category C] {W X Y : C} {s : category_theory.limits.binary_cofan X Y} (h : category_theory.limits.is_colimit s) (f : X âŸ¶ W) (g : Y âŸ¶ W) : {l // s.inl â‰« l = f âˆ§ s.inr â‰« l = g}
{Î± : Type u} {Î² : Type v} [topological_space Î±] [discrete_topology Î±] [semi_normed_group Î²] (f : Î± â†’ Î²) (C : â„) (H : âˆ€ (x : Î±), âˆ¥f xâˆ¥ â‰¤ C) : bounded_continuous_function Î± Î²
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î²] [topological_space Î³] [topological_space Î´] [measurable_space Î²] [topological_space.pseudo_metrizable_space Î²] [borel_space Î²] [topological_space.second_countable_topology Î²] [measurable_space Î³] [topological_space.pseudo_metrizable_space Î³] [borel_space Î³] [topological_space.second_countable_topology Î³] [measurable_space Î´] [topological_space.pseudo_metrizable_space Î´] [opens_measurable_space Î´] [topological_space.second_countable_topology Î´] (g : Î² â†’ Î³ â†’ Î´) (hg : measurable (function.uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) : Î± â†’â‚˜[Î¼] Î´
{Î± : Type u_1} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} (f : â†¥(measure_theory.Lp â„ p Î¼)) : â†¥(measure_theory.Lp â„ p Î¼)
{Î± : Type u_1} {Î¹ : Type u_3} [preorder Î¹] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {â„± : measure_theory.filtration Î¹ m0} [measure_theory.sigma_finite_filtration Î¼ â„±] {f : Î¹ â†’ Î± â†’ â„} (hf : measure_theory.submartingale f â„± Î¼) {i j : Î¹} (hij : i â‰¤ j) {s : set Î±} (hs : measurable_set s) : âˆ« (x : Î±) in s, f i x âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, f j x âˆ‚Î¼
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
{Î± : Type u_1} {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (C : ennreal) {f : Î± â†’ ennreal} (hf_meas : ae_measurable f Î¼) (hf : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰  âŠ¤ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ â‰¤ C) : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
{E : Type u_2} [add_comm_group E] [module â„ E] [topological_space E] [topological_add_group E] [has_continuous_smul â„ E] {s : set E} (hs : convex â„ s) {x : E} (hx : x âˆˆ interior s) (t : â„) (ht : 1 < t) : closure s âŠ† interior (â‡‘(affine_map.homothety x t) '' s)
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) (s : Î“) : turing.TM1.stmt Î“ Î› Ïƒ â†’ Ïƒ â†’ turing.TM1to0.Î›' M Ã— turing.TM0.stmt Î“
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) : lie_subalgebra R L
{Ïƒ R : Type u} [comm_semiring R] : cardinal.mk (mv_polynomial Ïƒ R) â‰¤ linear_order.max (linear_order.max (cardinal.mk R) (cardinal.mk Ïƒ)) cardinal.aleph_0
{ğ•œ : Type u_1} [linear_ordered_field ğ•œ] [topological_space ğ•œ] [topological_ring ğ•œ] (a b : ğ•œ) (h : 0 < a) : â‡‘(affine_homeomorph a b _) '' set.Icc 0 1 = set.Icc b (a + b)
{R : Type u_1} [semiring R] (Ï† Ïˆ : power_series R) (h : Ï†.order â‰  Ïˆ.order) : (Ï† + Ïˆ).order = Ï†.order âŠ“ Ïˆ.order
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î²] {m0 : measurable_space Î±} (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î±) : Prop
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} (f g : â†¥(measure_theory.Lp E p Î¼)) (s : set Î±) : measure_theory.mem_â„’p.to_Lp â‡‘(f + g) _ = measure_theory.mem_â„’p.to_Lp â‡‘f _ + measure_theory.mem_â„’p.to_Lp â‡‘g _
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : closure (f '' s) âˆˆ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [complete_space F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] [complete_space G] (Ï† : implicit_function_data ğ•œ E F G) : local_homeomorph E (F Ã— G)
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (h : W âŸ¶ X) (k : W âŸ¶ Y) (Hâ‚ : category_theory.limits.is_initial W) (Hâ‚‚ : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk f g _)) : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk f g)
{Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) : function.right_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p Î¼ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p Î¼ hm)
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) : Prop
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : â„ â†’ E} {g : â„ â†’ F} {a b c : â„} (hne : a â‰  b) (hc : c âˆˆ set.interval a b) (h_deriv : âˆ€á¶  (x : â„) in nhds_within c (set.interval a b  {c}), differentiable_at â„ f x) (h_infty : filter.tendsto (Î» (x : â„), âˆ¥f xâˆ¥) (nhds_within c (set.interval a b  {c})) filter.at_top) (hg : deriv f =O[nhds_within c (set.interval a b  {c})] g) : Â¬interval_integrable g measure_theory.measure_space.volume a b
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) : âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1), (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =o[filter.at_top] has_pow.pow a
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [semi_normed_group G] {xâ‚€ : G} {R : â„} (hf : function.support f âŠ† metric.ball 0 R) (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ R â†’ g x = g xâ‚€) : convolution f g L Î¼ xâ‚€ = âˆ« (t : G), â‡‘(â‡‘L (f t)) (g xâ‚€) âˆ‚Î¼
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) {W X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} {h : W âŸ¶ X} {k : W âŸ¶ Y} (comm : h â‰« f = k â‰« g) [category_theory.limits.reflects_limit (category_theory.limits.cospan f g) G] (l : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (G.map h) (G.map k) _)) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk h k comm)
{Î± : Type u_1} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} (f : â†¥(measure_theory.Lp â„ p Î¼)) : â†¥(measure_theory.Lp â„ p Î¼)
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {Îµ : Type u_9} {f : filter Î±} {g : filter Î²} {h : filter Î³} {m : Î´ â†’ Î³ â†’ Îµ} {n : Î± â†’ Î² â†’ Î´} {mâ‚ : Î± â†’ Î³ â†’ Î±'} {mâ‚‚ : Î² â†’ Î³ â†’ Î²'} {n' : Î±' â†’ Î²' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), m (n a b) c = n' (mâ‚ a c) (mâ‚‚ b c)) : filter.mapâ‚‚ m (filter.mapâ‚‚ n f g) h â‰¤ filter.mapâ‚‚ n' (filter.mapâ‚‚ mâ‚ f h) (filter.mapâ‚‚ mâ‚‚ g h)
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measurable_space Î²] {g : Î± â†’ Î²} (hg : measurable_embedding g) (f : Î² â†’ ennreal) : âˆ«â» (a : Î²), f a âˆ‚measure_theory.measure.map g Î¼ = âˆ«â» (a : Î±), f (g a) âˆ‚Î¼
{Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [has_add Î²] (f : add_hom Î± Î²) (I : Type u_3) : add_hom (I â†’ Î±) (I â†’ Î²)
{F : Type u_2} [normed_group F] [normed_space â„ F] {x y : F} : same_ray â„ x y â†” x = 0 âˆ¨ y = 0 âˆ¨ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_4} [topological_space H] {I : model_with_corners ğ•œ E H} {H' : Type u_5} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {N : Type u_6} [topological_space N] [charted_space H N] {G : Type u_7} [add_monoid G] [topological_space G] [charted_space H' G] [has_smooth_add I' G] : cont_mdiff_map I I' N G âŠ¤ â†’+ N â†’ G
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {D : Type uâ‚‚} [category_theory.category D] (F : Î  (i : I), C i â¥¤ D) : (Î£ (i : I), C i) â¥¤ D
{Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} {t : set Î¹} {s : Î¹ â†’ set Î±} (ht : t.nonempty) (H : âˆ€ (i : Î¹), i âˆˆ t â†’ is_connected (s i)) (K : âˆ€ (i : Î¹), i âˆˆ t â†’ âˆ€ (j : Î¹), j âˆˆ t â†’ relation.refl_trans_gen (Î» (i j : Î¹), (s i âˆ© s j).nonempty âˆ§ i âˆˆ t) i j) : is_connected (â‹ƒ (n : Î¹) (H : n âˆˆ t), s n)
{Î± : Type u_1} {m : measurable_space Î±} (f : Î± â†’ ennreal) (Î¼ : measure_theory.measure Î±) : âˆ«â» (a : Î±), f a âˆ‚Î¼ = â¨† (Ï† : measure_theory.simple_func Î± nnreal) (hf : âˆ€ (x : Î±), â†‘(â‡‘Ï† x) â‰¤ f x), (measure_theory.simple_func.map coe Ï†).lintegral Î¼
{M : Type u_1} [add_monoid M] {Î¹ : Type u_2} [hdec : decidable_eq Î¹] [fintype Î¹] {N : Î¹ â†’ Type u_3} [Î  (i : Î¹), add_monoid (N i)] : {Ï• // pairwise (Î» (i j : Î¹), âˆ€ (x : N i) (y : N j), add_commute (â‡‘(Ï• i) x) (â‡‘(Ï• j) y))} â‰ƒ ((Î  (i : Î¹), N i) â†’+ M)
{R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [ring_hom_surjective Ïƒâ‚â‚‚] (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) {x : M} {s : set M} (h : â‡‘f x âˆ‰ submodule.span Râ‚‚ (â‡‘f '' s)) : x âˆ‰ submodule.span R s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p âˆˆ s) : â†‘(s.direction) = has_vsub.vsub p '' â†‘s
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] [measure_theory.sigma_finite Î¼] (f : Î± â†’ â„) (hf : measure_theory.integrable f Î¼) {Îµ : â„} (Îµpos : 0 < Îµ) : âˆƒ (g : Î± â†’ ereal), (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§ upper_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ + Îµ
{Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) {p q : â„} (hpq : p.is_conjugate_exponent q) {f g : Î± â†’ ennreal} (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) : âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼) ^ (1 / q)
(n : with_top â„•) {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {s : set H} (hs : is_open s) : local_homeomorph.of_set s hs âˆˆ cont_diff_groupoid n I
{X : Type u_2} [emetric_space X] {Î¼ : measure_theory.outer_measure X} (hm : Î¼.is_metric) : borel X â‰¤ Î¼.caratheodory
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : chain_complex V â„•} (e : P âŸ¶ Q) (zero : P.X 0 âŸ¶ Q.X 1) (comm_zero : e.f 0 = zero â‰« Q.d 1 0) (one : P.X 1 âŸ¶ Q.X 2) (comm_one : e.f 1 = P.d 1 0 â‰« zero + one â‰« Q.d 2 1) (succ : Î  (n : â„•) (p : Î£' (f : P.X n âŸ¶ Q.X (n + 1)) (f' : P.X (n + 1) âŸ¶ Q.X (n + 2)), e.f (n + 1) = P.d (n + 1) n â‰« f + f' â‰« Q.d (n + 2) (n + 1)), Î£' (f'' : P.X (n + 2) âŸ¶ Q.X (n + 3)), e.f (n + 2) = P.d (n + 2) (n + 1) â‰« p.snd.fst + f'' â‰« Q.d (n + 3) (n + 2)) [category_theory.limits.has_zero_object V] : homotopy e 0
{Î± : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Î± â†’ E} {g : Î± â†’ â„} {tâ‚€ : filter Î±} (h : âˆ€á¶  (n : Î±) in tâ‚€, âˆ¥f nâˆ¥ â‰¤ g n) (h' : filter.tendsto g tâ‚€ (nhds 0)) : filter.tendsto f tâ‚€ (nhds 0)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I : model_with_corners ğ•œ E H} {I' : model_with_corners ğ•œ E' H'} {e : local_homeomorph H H} {e' : local_homeomorph H' H'} (he : e âˆˆ cont_diff_groupoid âŠ¤ I) (he' : e' âˆˆ cont_diff_groupoid âŠ¤ I') : e.prod e' âˆˆ cont_diff_groupoid âŠ¤ (I.prod I')
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : filter Î±
{Î± : Type u_1} {m : measurable_space Î±} (s : measure_theory.signed_measure Î±) {i : set Î±} (hi : 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i) (hiâ‚ : measurable_set i) : measure_theory.is_finite_measure (s.to_measure_of_zero_le i hiâ‚ hi)
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {C r : nnreal} {f : X â†’ Y} {s : set X} (h : holder_on_with C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) : â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘C ^ d * â‡‘(measure_theory.measure.hausdorff_measure (â†‘r * d)) s
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (s : set Î±) : measure_theory.measure Î±
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : cochain_complex V â„•} (e : P âŸ¶ Q) (zero : P.X 1 âŸ¶ Q.X 0) (comm_zero : e.f 0 = P.d 0 1 â‰« zero) (one : P.X 2 âŸ¶ Q.X 1) (comm_one : e.f 1 = zero â‰« Q.d 0 1 + P.d 1 2 â‰« one) (succ : Î  (n : â„•) (p : Î£' (f : P.X (n + 1) âŸ¶ Q.X n) (f' : P.X (n + 2) âŸ¶ Q.X (n + 1)), e.f (n + 1) = f â‰« Q.d n (n + 1) + P.d (n + 1) (n + 2) â‰« f'), Î£' (f'' : P.X (n + 3) âŸ¶ Q.X (n + 2)), e.f (n + 2) = p.snd.fst â‰« Q.d (n + 1) (n + 2) + P.d (n + 2) (n + 3) â‰« f'') [category_theory.limits.has_zero_object V] : homotopy e 0
(hyp : name) (cfg : tactic.equiv_rw_cfg) (permissive : bool := bool.ff) : list expr â†’ tactic.interactive.itactic
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.sum (Î» (i : Î¹), finset.univ.prod (Î» (j : Î¹), ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (linear_order.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
{L : first_order.language} {L' : first_order.language} {Î± : Type u'} {n : â„•} (Ï† : L â‰ƒá´¸ L') : L.bounded_formula Î± n â‰ƒ L'.bounded_formula Î± n
(ns : name) (s : tactic.local_cache.internal.cache_scope := tactic.local_cache.cache_scope.block_local) : tactic unit
{L : first_order.language} (M : Type w) [L.Structure M] (Ï† : L.sentence) : Prop
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) < s.sum (Î» (i : Î¹), f i * g i) â†” Â¬monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (x : M) : Type u_2
{f : â„ â†’ â„} (hf : differentiable â„ f) {C : â„} (lt_hf' : âˆ€ (x : â„), deriv f x < C) â¦ƒx y : â„â¦„ (hxy : x < y) : f y - f x < C * (y - x)
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] (p : mv_polynomial Ïƒ R) : finset (Ïƒ â†’â‚€ â„•)
{R : Type u} [comm_semiring R] (f : polynomial R) (ğ“Ÿ : ideal R) : Prop
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (s : measure_theory.signed_measure Î±) [s.have_lebesgue_decomposition Î¼] : s.singular_part Î¼ + Î¼.with_densityáµ¥ (s.rn_deriv Î¼) = s
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} {Ïƒ : Type u_3} (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) : turing.TM1.cfg Î“ Î› Ïƒ â†’ option (turing.TM1.cfg Î“ Î› Ïƒ)
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (hf : âˆ€ (n : â„•), ae_measurable (f n) Î¼) (h_mono : âˆ€áµ (x : Î±) âˆ‚Î¼, monotone (Î» (n : â„•), f n x)) : âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : hb.oangle x (x - y) = hb.oangle (y - x) y
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : (f =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f =o[l] g'
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (xs : list Î±) (chunk_size : â„• := 1024) : list Î²
{Î± : Type u_2} [preorder Î±] {Î¹ : Type u_6} {Ï€ : Î¹ â†’ Type u_7} [Î  (i : Î¹), preorder (Ï€ i)] : (Î± â†’o Î  (i : Î¹), Ï€ i) â‰ƒo Î  (i : Î¹), Î± â†’o Ï€ i
{Î± : Type u_1} {G : Type u_5} [normed_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {f : Î± â†’ G} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : measure_theory.fin_strongly_measurable f Î¼ â†” measurable f
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {W X Y Z : C} [category_theory.limits.has_binary_biproduct W X] [category_theory.limits.has_binary_biproduct Y Z] (f : W âŸ¶ Y) (g : X âŸ¶ Z) : W âŠ X âŸ¶ Y âŠ Z
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (hf : monotone_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : closure (f '' s) âˆˆ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : Î± â†’ Prop} (hst : s =áµ[Î¼] t) {p : Î± â†’ Prop} : (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, p x) â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, p x)
{R : Type u_1} [semiring R] {Ï† : power_series R} (n : â„•) (h : â‡‘(power_series.coeff R n) Ï† â‰  0) : Ï†.order â‰¤ â†‘n
{R : Type u_5} {S : Type u_6} {F : Type u_7} [comm_semiring R] [comm_semiring S] [ring_hom_class F R S] (Ïƒ : F) (n : â„•+) : â†¥(roots_of_unity n R) â†’* â†¥(roots_of_unity n S)
{R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] {I I' : R â†’+* R} [nontrivial R] {B : M â†’â‚›â‚—[I] M â†’â‚›â‚—[I'] R} {v : basis n R M} (h : B.is_Ortho â‡‘v) (hB : B.separating_right) (i : n) : Â¬B.is_ortho (â‡‘v i) (â‡‘v i)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (hs : unique_mdiff_on I s) (x : M) : unique_diff_on ğ•œ ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' s)
{Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) (s : set Î²) : â‡‘Î¼ (f â»Â¹' s) â‰¤ â‡‘(measure_theory.measure.map f Î¼) s
{Î± : Type u} [pseudo_emetric_space Î±] (x : Î±) (Îµ : ennreal) : set Î±
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] [dec_ğ•œ : decidable_eq ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ğ•œ E] : E â‰ƒâ‚—áµ¢[ğ•œ] pi_Lp 2 (Î» (Î¼ : module.End.eigenvalues T), â†¥(module.End.eigenspace T â†‘Î¼))
(ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} [linear_order Î¹] [order_bot Î¹] [locally_finite_order Î¹] [is_well_order Î¹ has_lt.lt] (f : Î¹ â†’ E) : pairwise (Î» (a b : Î¹), has_inner.inner (gram_schmidt ğ•œ f a) (gram_schmidt ğ•œ f b) = 0)
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary (f âˆ˜ â‡‘Ïƒ) g
(close_goals : bool) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := Î» (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (Î» (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) (e : expr) : tactic â„•
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â‰¤ finset.univ.sum (Î» (i : Î¹), f i â€¢ g i)
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] [measure_theory.is_finite_measure Î½] : Î¼.have_lebesgue_decomposition Î½
{Î± : Type u_1} [metric_space Î±] {K : nnreal} {f : Î± â†’ Î±} [nonempty Î±] [complete_space Î±] {n : â„•} (hf : contracting_with K f^[n]) : function.is_fixed_pt f (contracting_with.fixed_point f^[n] hf)
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) {r : â„} (hx : âˆ¥xâˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : o.oangle y z = 2 â€¢ o.oangle (y - x) (z - x)
{V : Type u} {W : Type v} {X : Type w} {G : simple_graph V} {G' : simple_graph W} {G'' : simple_graph X} (f' : G' â†ªg G'') (f : G â†ªg G') : G â†ªg G''
{R : Type u} [comm_ring R] (I : ideal R) (hqf : is_field (R â§¸ I)) : I.is_maximal
{Î± : Type u_1} [measurable_space Î±] (s t : set Î±) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} {t : set Î¹} {s : Î¹ â†’ set Î±} (H : âˆ€ (i : Î¹), i âˆˆ t â†’ is_preconnected (s i)) (K : âˆ€ (i : Î¹), i âˆˆ t â†’ âˆ€ (j : Î¹), j âˆˆ t â†’ relation.refl_trans_gen (Î» (i j : Î¹), (s i âˆ© s j).nonempty âˆ§ i âˆˆ t) i j) : is_preconnected (â‹ƒ (n : Î¹) (H : n âˆˆ t), s n)
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] (hbg : bdd_above (set.range (Î» (x : G), âˆ¥g xâˆ¥))) (hf : measure_theory.integrable f Î¼) (hg : continuous g) : continuous (convolution f g L Î¼)
(n : name) (hide_non_prop : bool := bool.tt) : tactic tactic.explode.entries
{Î± : Type u} {Î² : Type v} {Ï† : ultrafilter Î±} [linear_ordered_field Î²] : linear_ordered_field (â†‘Ï†.germ Î²)
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R â†’+* P} {T : submonoid P} {Q : Type u_4} [comm_semiring Q] (hy : M â‰¤ submonoid.comap â†‘g T) [algebra P Q] [is_localization T Q] {A : Type u_5} [comm_semiring A] {U : submonoid A} {W : Type u_6} [comm_semiring W] [algebra A W] [is_localization U W] {l : P â†’+* A} (hl : T â‰¤ submonoid.comap â†‘l U) : (is_localization.map W l hl).comp (is_localization.map Q g hy) = is_localization.map W (l.comp g) _
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±] [topological_space Î²] [h : second_countable_topology_either Î± Î²] [opens_measurable_space Î±] [topological_space.pseudo_metrizable_space Î²] {f : Î± â†’ Î²} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : continuous_on f s) (hs : measurable_set s) : measure_theory.ae_strongly_measurable f (Î¼.restrict s)
{C : Type u} [category_theory.category C] {W X Y : C} [category_theory.limits.has_binary_product X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) : {l // l â‰« category_theory.limits.prod.fst = f âˆ§ l â‰« category_theory.limits.prod.snd = g}
{P : â„• â†’ Sort u_1} (h0 : P 0) (h1 : P 1) (hp : Î  (p : â„•), nat.prime p â†’ P p) (h : Î  (a b : â„•), P a â†’ P b â†’ P (a * b)) (a : â„•) : P a
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : â„} {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) g â†’ asymptotics.is_O_with c l f' g
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type wâ‚} [category_theory.category D] {E : Type wâ‚‚} [category_theory.category E] (F : D â¥¤ E) [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [Î  (X : C) (W : J.cover X) (P : Cáµ’áµ– â¥¤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– E] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– F] : J.plus_functor D â‹™ (category_theory.whiskering_right Cáµ’áµ– D E).obj F â‰… (category_theory.whiskering_right Cáµ’áµ– D E).obj F â‹™ J.plus_functor E
{C : Type u} [category_theory.category C] (ğ’¯ : category_theory.limits.limit_cone (category_theory.functor.empty C)) (â„¬ : Î  (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) : Type u
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] [mÎ² : measurable_space Î²] [mÎ³ : measurable_space Î³] (f : Î± â†’ Î²) (g : Î± â†’ Î³) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
(c : â„‚) (R : â„) : set.range (circle_map c R) = metric.sphere c |R|
{G : Type u_1} [measurable_space G] [group G] [topological_space G] [topological_group G] [borel_space G] (Î¼ : measure_theory.measure G) [Î¼.is_mul_left_invariant] (K : set G) (hK : is_compact K) (h'K : (interior K).nonempty) (h : â‡‘Î¼ K â‰  0) (h' : â‡‘Î¼ K â‰  âŠ¤) : Î¼.is_haar_measure
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] (f : Î± â†’ Î²) (s : set Î±) (hf : function.injective f) (hfm : measurable f) (hfi : âˆ€ (s : set Î±), measurable_set s â†’ measurable_set (f '' s)) : â†¥s â‰ƒáµ â†¥(f '' s)
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr Ã— expr)
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) (C : â„) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : continuous â‡‘f
{f : â„ â†’ â„} (hf' : differentiable â„ f) (hf'' : differentiable â„ (deriv f)) (hf''_nonneg : âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) : convex_on â„ set.univ f
{Î´' : Type u_5} (Ï€ : Î´' â†’ Type u_7) [Î  (x : Î´'), measurable_space (Ï€ x)] (p : Î´' â†’ Prop) [decidable_pred p] : (Î  (i : Î´'), Ï€ i) â‰ƒáµ (Î  (i : subtype p), Ï€ â†‘i) Ã— Î  (i : {i // Â¬p i}), Ï€ â†‘i
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â†ªg G') : G â†’g G'
{I : Type u_3} {f : I â†’ Type u_4} (i' : I) [inst : âˆ€ (i : I), nonempty (f i)] [nontrivial (f i')] : nontrivial (Î  (i : I), f i)
(opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := Î» (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (Î» (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic.mllist tactic tactic.suggest.application
(R : Type u) [semiring R] (Î¹ : Type v) [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] (N : Type uâ‚) [add_comm_monoid N] [module R N] (Ï† : Î  (i : Î¹), M i â†’â‚—[R] N) : â‡‘(direct_sum.to_module R Î¹ N Ï†) = â‡‘(direct_sum.to_add_monoid (Î» (i : Î¹), (Ï† i).to_add_monoid_hom))
{Î± : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (s t : set Î±) : Prop
{Î± : Sort u_1} {sâ‚ : setoid Î±} {Ï† : quotient sâ‚ â†’ Sort u_2} (qa : quotient sâ‚) (f : Î  (a : Î±), Ï† (quotient.mk' a)) (c : âˆ€ (aâ‚ aâ‚‚ : Î±), aâ‚ â‰ˆ aâ‚‚ â†’ f aâ‚ == f aâ‚‚) : Ï† qa
(n : â„•) {Î² : typevec (n + 1) â†’ Sort u_2} (f : Î  (t : Type u_1) (v : typevec n), Î² (v ::: t)) (v : typevec (n + 1)) : Î² v
{Ïƒ : Type u_1} (f : Ïƒ â†’ option Ïƒ) : Ïƒ â†’ part Ïƒ
{R : Type u} {Î¹ : Type x} [semiring R] {Ï† : Î¹ â†’ Type u_1} {Ïˆ : Î¹ â†’ Type u_2} [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] [Î  (i : Î¹), add_comm_monoid (Ïˆ i)] [Î  (i : Î¹), module R (Ïˆ i)] (e : Î  (i : Î¹), Ï† i â‰ƒâ‚—[R] Ïˆ i) : (Î  (i : Î¹), Ï† i) â‰ƒâ‚—[R] Î  (i : Î¹), Ïˆ i
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.tagged_prepartition I) [fintype Î¹] : nnreal
{M : Type u} [add_monoid M] {a : add_units M} {x y : M} (h : add_semiconj_by â†‘a x y) : add_semiconj_by (â†‘-a) y x
{p : â„•+} {k : â„•} {K : Type u} {L : Type v} {Î¶ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : fact (nat.prime â†‘p)] [ne_zero â†‘â†‘p] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (hk : p ^ (k + 1) â‰  2) : algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ (â†‘p ^ k * (â†‘p - 1) / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
{ğ•œ : Type u_1} {V : Type u_3} {W : Type u_4} [normed_group V] [normed_group W] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ V] [normed_space ğ•œ W] : has_norm (V â†’A[ğ•œ] W)
{E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : âˆ¥f aâˆ¥ â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
{G : Type u_1} [measurable_space G] [has_add G] [has_measurable_add G] (Î¼ : measure_theory.measure G) : (âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), g + h) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_add_left_invariant
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {m n : with_top â„•} {f : H â†’ H'} {s : set H} (hf : cont_mdiff_on I I' n f s) (hmn : m + 1 â‰¤ n) (hs : unique_mdiff_on I s) : cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I H â»Â¹' s)
{Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (set.Icc a b)) : set.Icc (f b) (f a) âŠ† f '' set.Icc a b
{Î± : Type u_1} {f : filter Î±} {u : Î± â†’ ennreal} {a : ennreal} (ha : a â‰  âŠ¤) : filter.tendsto u f (nhds a) â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (x : Î±) in f, u x âˆˆ set.Icc (a - Îµ) (a + Îµ))
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {f : X â†’ Y} {s : set X} (hf : âˆ€ (x : X), x âˆˆ s â†’ (âˆƒ (C : nnreal) (t : set X) (H : t âˆˆ nhds_within x s), lipschitz_on_with C f t)) : dimH (f '' s) â‰¤ dimH s
{Î´ : Type u_4} {Ï€ : Î´ â†’ Type u_7} [Î  (a : Î´), measurable_space (Ï€ a)] (f : Î  (a : Î´), Ï€ a) {a : Î´} [decidable_eq Î´] : measurable (function.update f a)
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {f : Î± â†’ E} {Î¼ : measure_theory.measure Î±} {l : filter Î±} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l Î¼) (hÎ¼ : Î¼.finite_at_filter l) (hf : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ f)) : measure_theory.integrable_at_filter f l Î¼
{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp : generalized_continued_fraction.int_fract_pair K} (stream_nth_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp) : let g : generalized_continued_fraction K := generalized_continued_fraction.of v, B : K := (g.continuants_aux (n + 1)).b, pB : K := (g.continuants_aux n).b in v - g.convergents n = ite (ifp.fr = 0) 0 ((-1) ^ n / (B * ((ifp.fr)â»Â¹ * B + pB)))
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J â¥¤ C} {F : C â¥¤ D} [category_theory.reflects_isomorphisms F] (h : Î  (c : category_theory.limits.cone (K â‹™ F)) (t : category_theory.limits.is_limit c), category_theory.lifts_to_limit K F c t) : category_theory.creates_limit K F
{Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] {l : box_integral.integration_params} {I : box_integral.box Î¹} {y : E} {f g : (Î¹ â†’ â„) â†’ E} {Î¼ : measure_theory.measure (Î¹ â†’ â„)} [measure_theory.is_locally_finite_measure Î¼] (hf : box_integral.has_integral I l f Î¼.to_box_additive.to_smul y) (hfg : f =áµ[Î¼.restrict â†‘I] g) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l g Î¼.to_box_additive.to_smul y
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.multiequalizer I â‰… category_theory.limits.equalizer I.fst_pi_map I.snd_pi_map
(rep : interactive.parse tactic.interactive.arity) : interactive.parse (optional tactic.interactive.assert_or_rule) â†’ (tactic.interactive.mono_cfg := {unify := bool.ff}) â†’ tactic unit
{C : Type uâ‚} [category_theory.category C] {C' : Type uâ‚‚} [category_theory.category C'] (D : category_theory.glue_data C) (F : C â¥¤ C') [H : Î  (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] [category_theory.limits.has_multicoequalizer D.diagram] [category_theory.limits.preserves_colimit D.diagram.multispan F] : F.obj D.glued â‰… (D.map_glue_data F).glued
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] (h : box_integral.integrable I l f vol) (Ï€â‚€ : box_integral.prepartition I) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I Ï€â‚€) (nhds (Ï€â‚€.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)))
{L : first_order.language} {L' : first_order.language} (Ï• : L â†’á´¸ L') {L'' : first_order.language} (Ïˆ : L'' â†’á´¸ L') : L.sum L'' â†’á´¸ L'
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] [h' : module.finite R N] : âˆƒ (n : â„•) (Î¹ : Type u) [_inst_8 : fintype Î¹] (p : Î¹ â†’ R) [_inst_9 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), nonempty (N â‰ƒâ‚—[R] (fin n â†’â‚€ R) Ã— direct_sum Î¹ (Î» (i : Î¹), R â§¸ submodule.span R {p i ^ e i}))
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] : measure_theory.sigma_finite Î¼
{n : â„•} {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : (fin n â†’ â„‚) â†’ E} {c : fin n â†’ â„‚} {R : fin n â†’ â„} {C : â„} (hf : âˆ€ (Î¸ : fin n â†’ â„), âˆ¥f (torus_map c R Î¸)âˆ¥ â‰¤ C) : âˆ¥âˆ¯ (x : fin n â†’ â„‚) in T(c, R), f xâˆ¥ â‰¤ (2 * real.pi) ^ n * finset.univ.prod (Î» (i : fin n), |R i|) * C
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) : set (Î± â†’ ennreal)
{Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f g : Î± â†’ ennreal} (h_meas_f : measurable f) (h_meas_g : measurable g) (h_indep_fun : probability_theory.indep_fun f g Î¼) : âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} [inhabited Î›] {Ïƒ : Type u_4} [inhabited Ïƒ] (M : Î› â†’ turing.TM2.stmt Î“ Î› Ïƒ) : turing.TM2to1.Î›' â†’ turing.TM1.stmt turing.TM2to1.Î“' turing.TM2to1.Î›' Ïƒ
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î²] [has_zero Î²] {m0 : measurable_space Î±} (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î±) : Prop
(Ïƒ K : Type u) [fintype K] [comm_ring K] : mv_polynomial.R Ïƒ K â†’â‚—[K] (Ïƒ â†’ K) â†’ K
{Î´' : Type u_5} {Ï€ : Î´' â†’ Type u_7} [Î  (x : Î´'), measurable_space (Ï€ x)] [decidable_eq Î´'] {l : list Î´'} (hnd : l.nodup) (h : âˆ€ (i : Î´'), i âˆˆ l) : (Î  (i : Î´'), Ï€ i) â‰ƒáµ list.tprod Ï€ l
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’. Î² âŠ• Î±) (b : Î²) {C : Î± â†’ Sort u_3} {a : Î±} (h : b âˆˆ f.fix a) (hbase : Î  (a_final : Î±), sum.inl b âˆˆ f a_final â†’ C a_final) (hind : Î  (aâ‚€ aâ‚ : Î±), b âˆˆ f.fix aâ‚ â†’ sum.inr aâ‚ âˆˆ f aâ‚€ â†’ C aâ‚ â†’ C aâ‚€) : C a
{R : Type u} [ring R] {I : ideal R} : I.jacobson = I â†” âˆƒ (M : set (ideal R)), (âˆ€ (J : ideal R), J âˆˆ M â†’ J.is_maximal âˆ¨ J = âŠ¤) âˆ§ I = has_Inf.Inf M
(V : Type u_1) (W : Type u_2) : (complete_bipartite_graph V W).coloring bool
{p : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero â†‘â†‘p] {k : â„•} (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) [hpri : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (h : p â‰  2) : â‡‘(algebra.norm K) (Î¶ - 1) = â†‘p
(R : Type u_5) {S : Type u_6} [comm_ring S] [is_domain S] {Î¼ : S} {n : â„•+} (hÎ¼ : is_primitive_root Î¼ â†‘n) [comm_ring R] [algebra R S] : (S â‰ƒâ‚[R] S) â†’* (zmod â†‘n)Ë£
{Î± : Type u_1} {Î¹ : Type u_5} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (hs : (â‹ƒ (i : Î¹), s i) = set.univ) : (âˆ€ (i : Î¹), Î¼.restrict (s i) = Î½.restrict (s i)) â†’ Î¼ = Î½
{A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [h : is_dedekind_domain A] (I : ideal A) (hI0 : I â‰  âŠ¥) : â†‘I * (â†‘I)â»Â¹ = 1
{S : Type u_2} {R : Type u_3} {A : Type u_4} {N : Type u_1} [semiring S] [add_comm_monoid R] [add_comm_monoid A] [add_comm_monoid N] [module S R] [module S A] [module S N] â¦ƒf g : unitization R A â†’â‚—[S] Nâ¦„ (hl : âˆ€ (r : R), â‡‘f (unitization.inl r) = â‡‘g (unitization.inl r)) (hr : âˆ€ (a : A), â‡‘f â†‘a = â‡‘g â†‘a) : f = g
{C : Type uâ‚} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] (X : category_theory.forget_enrichment W C) : category_theory.forget_enrichment.hom_to W (ğŸ™ X) = category_theory.e_id W (category_theory.forget_enrichment.to W X)
{Î¹ : Type u_1} [hnontriv : nontrivial Î¹] {G : Type u_4} [group G] {H : Î¹ â†’ Type u_5} [Î  (i : Î¹), group (H i)] (f : Î  (i : Î¹), H i â†’* G) (hcard : 3 â‰¤ cardinal.mk Î¹ âˆ¨ âˆƒ (i : Î¹), 3 â‰¤ cardinal.mk (H i)) {Î± : Type u_6} [mul_action G Î±] (X : Î¹ â†’ set Î±) (hXnonempty : âˆ€ (i : Î¹), (X i).nonempty) (hXdisj : pairwise (Î» (i j : Î¹), disjoint (X i) (X j))) (hpp : pairwise (Î» (i j : Î¹), âˆ€ (h : H i), h â‰  1 â†’ â‡‘(f i) h â€¢ X j âŠ† X i)) : function.injective â‡‘(â‡‘free_product.lift f)
{n : â„•} {K : Type u_1} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) (hpos : 0 < n) [char_zero K] : polynomial.cyclotomic n â„¤ = minpoly â„¤ Î¼
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] (p : mv_polynomial Ïƒ R) : finset Ïƒ
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {M : mv_polynomial Ïƒ R â†’ Prop} (p : mv_polynomial Ïƒ R) (h_C : âˆ€ (a : R), M (â‡‘mv_polynomial.C a)) (h_add_weak : âˆ€ (a : Ïƒ â†’â‚€ â„•) (b : R) (f : (Ïƒ â†’â‚€ â„•) â†’â‚€ R), a âˆ‰ f.support â†’ b â‰  0 â†’ M f â†’ M (â‡‘(mv_polynomial.monomial a) b + f)) : M p
{R : Type u} [comm_ring R] (I : ideal R) (Î¹ : Type v) : module (R â§¸ I) ((Î¹ â†’ R) â§¸ I.pi Î¹)
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle â„ P) {iâ‚ iâ‚‚ : fin 3} (h : iâ‚ â‰  iâ‚‚) : has_dist.dist t.orthocenter (â‡‘(euclidean_geometry.reflection (affine_span â„ (t.points '' â†‘{iâ‚, iâ‚‚}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
(ğ•œ : Type u_1) {E : Type u_4} [normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] (ğ•œ' : Type u_12) [normed_field ğ•œ'] [normed_algebra ğ•œ ğ•œ'] [normed_space ğ•œ' E] [is_scalar_tower ğ•œ ğ•œ' E] [nontrivial E] : âˆ¥continuous_linear_map.lsmul ğ•œ ğ•œ'âˆ¥ = 1
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : E â†’L[ğ•œ] F) [complete_space F] (surj : function.surjective â‡‘f) : âˆƒ (C : â„) (H : C â‰¥ 0), âˆ€ (y : F), âˆƒ (x : E), has_dist.dist (â‡‘f x) y â‰¤ 1 / 2 * âˆ¥yâˆ¥ âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {p q : nnreal} (hpq : p < q) : âˆƒ (a b : set Î±), measurable_set a âˆ§ measurable_set b âˆ§ {x : Î± | v.lim_ratio Ï x < â†‘p} âŠ† a âˆ§ {x : Î± | â†‘q < v.lim_ratio Ï x} âŠ† b âˆ§ â‡‘Î¼ (a âˆ© b) = 0
{Î± : Type u_1} {M : Î± â†’ Type u_2} {u : ultrafilter Î±} {L : first_order.language} [Î  (a : Î±), L.Structure (M a)] [âˆ€ (a : Î±), nonempty (M a)] (Ï† : L.sentence) : â†‘u.product M âŠ¨ Ï† â†” âˆ€á¶  (a : Î±) in â†‘u, M a âŠ¨ Ï†
{A : Type u} [category_theory.category A] [category_theory.abelian A] {X Y Z : A} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (w : f â‰« g = 0) {W : A} (e : category_theory.limits.kernel g âŸ¶ W) (he : category_theory.limits.kernel.lift g f w â‰« e = 0) : homology f g w âŸ¶ W
{Î¹ : Type u} {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {g : (Î¹ â†’ â„) â†’ â„} (hg : âˆ€ (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I â†’ 0 â‰¤ g x) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] : 0 â‰¤ box_integral.integral I l g Î¼.to_box_additive.to_smul
{Î± : Type u_1} {Î² : Type u_2} [metric_space Î±] [compact_space Î±] [metric_space Î²] (f : C(Î±, Î²)) (Îµ : â„) (h : 0 < Îµ) : â„
{p : â„•} {g : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R} {f : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R} (hg : witt_vector.is_poly p g) (hf : witt_vector.is_polyâ‚‚ p f) : witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x y))
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (Î¼ : R) (x : M) : Prop
{Î± : Type u_1} [metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [proper_space Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure_on_compacts Î¼] {s : set Î±} (hs : is_compact s) : filter.tendsto (Î» (r : â„), â‡‘Î¼ (metric.cthickening r s)) (nhds 0) (nhds (â‡‘Î¼ s))
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {s : set E} {t : set F} {y : F} (hs : x âˆˆ closure s) : â‡‘(linear_map.inr ğ•œ E F) '' tangent_cone_at ğ•œ t y âŠ† tangent_cone_at ğ•œ (s Ã—Ë¢ t) (x, y)
{Î¹ : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [fintype Î¹] {S : Type u_3} [comm_ring S] [is_domain S] [algebra R S] (b : basis Î¹ R S) (I : ideal S) (hI : I â‰  âŠ¥) : âˆƒ (b' : basis Î¹ R S) (a : Î¹ â†’ R) (ab' : basis Î¹ R â†¥I), âˆ€ (i : Î¹), â†‘(â‡‘ab' i) = a i â€¢ â‡‘b' i
{Î± : Type u_1} (E : Type u_2) {m : measurable_space Î±} [normed_group E] (p : ennreal) (Î¼ : measure_theory.measure Î± . "volume_tac") : add_subgroup (Î± â†’â‚˜[Î¼] E)
{n : â„•} {F : typevec n â†’ Type v} [mvfunctor F] {Î± : typevec n} (r : Î  {i : fin2 n}, Î± i â†’ Î± i â†’ Prop) (x y : F Î±) : Prop
{C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C â¥¤ D} (hu : category_theory.cover_lifting J K G) (â„± : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S âˆˆ â‡‘K U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj â„±.val â‹™ category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) {V : D} (f : V âŸ¶ U) (y : X âŸ¶ ((category_theory.Ran G.op).obj â„±.val).obj (opposite.op V)) (W : category_theory.structured_arrow (opposite.op V) G.op) (H : âˆ€ {V' : C} {fV : G.obj V' âŸ¶ V} (hV : S.arrows (fV â‰« f)), y â‰« ((category_theory.Ran G.op).obj â„±.val).map fV.op = x (fV â‰« f) hV) : y â‰« category_theory.limits.limit.Ï€ (category_theory.Ran.diagram G.op â„±.val (opposite.op V)) W = (category_theory.Ran_is_sheaf_of_cover_lifting.glued_limit_cone hu â„± hS hx).Ï€.app ((category_theory.structured_arrow.map f.op).obj W)
{ğ•† : Type u_1} {â„™ : Type u_2} {Î± : Type u_3} [preorder ğ•†] [preorder Â«â„™Â»] [preorder Î±] [grade_min_order ğ•† Î±] (f : ğ•† â†’ Â«â„™Â») (hf : strict_mono f) (hcovby : âˆ€ (a b : ğ•†), a â‹– b â†’ f a â‹– f b) (hmin : âˆ€ (a : ğ•†), is_min a â†’ is_min (f a)) : grade_min_order Â«â„™Â» Î±
{Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [semilattice_sup Î¹] [encodable Î¹] {s : Î¹ â†’ set Î±} (hm : monotone s) : filter.tendsto (â‡‘Î¼ âˆ˜ s) filter.at_top (nhds (â‡‘Î¼ (â‹ƒ (n : Î¹), s n)))
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : Î  (n : â„•) (x : A), x âˆˆ M ^ n â†’ Prop} (hr : âˆ€ (r : R), C 0 (â‡‘(algebra_map R A) r) _) (hadd : âˆ€ (x y : A) (i : â„•) (hx : x âˆˆ M ^ i) (hy : y âˆˆ M ^ i), C i x hx â†’ C i y hy â†’ C i (x + y) _) (hmul : âˆ€ (i : â„•) (x : A) (hx : x âˆˆ M ^ i), C i x hx â†’ âˆ€ (m : A) (H : m âˆˆ M), C i.succ (x * m) _) {x : A} {n : â„•} (hx : x âˆˆ M ^ n) : C n x hx
{p : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero â†‘â†‘p] {k s : â„•} (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) [hpri : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (hs : s â‰¤ k) (htwo : p ^ (k - s + 1) â‰  2) : â‡‘(algebra.norm K) (Î¶ ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
{I : Type wâ‚} (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] {J : Type wâ‚‚} (g : J â†’ I) : (Î£ (j : J), C (g j)) â¥¤ Î£ (i : I), C i
(n : with_top â„•) {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] (e : local_homeomorph M H) : e.symm.trans e âˆˆ cont_diff_groupoid n I
{Î² : Î  (v : typevec 0) (v' : typevec 0), v.arrow v' â†’ Sort u_3} (f : Î² fin2.elim0 fin2.elim0 typevec.nil_fun) (v : typevec 0) (v' : typevec 0) (fs : v.arrow v') : Î² v v' fs
{V : Type u} [fintype V] [decidable_eq V] {Î¼ : â„•} : âŠ¤.is_SRG_with (fintype.card V) (fintype.card V - 1) (fintype.card V - 2) Î¼
{Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), add_zero_class (Î² i)] [add_comm_monoid Î³] (Ï† : Î  (i : Î¹), Î² i â†’+ Î³) : (Î â‚€ (i : Î¹), Î² i) â†’+ Î³
{Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) (h0 : â‡‘Î¼ s â‰  0) : âˆƒáµ (x : Î±) âˆ‚Î¼, x âˆˆ s âˆ§ âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] (f : Î± â†’ E) (s : set Î±) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{M : Type u_1} [has_mul M] (S : set (con M)) : â‡‘(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
{G : Type u_1} [measurable_space G] [add_group G] [topological_space G] (Î¼ : measure_theory.measure G) [Î¼.is_add_haar_measure] [borel_space G] [topological_add_group G] {H : Type u_2} [add_group H] [topological_space H] [measurable_space H] [borel_space H] [t2_space H] [topological_add_group H] (f : G â‰ƒ+ H) (hf : continuous â‡‘f) (hfsymm : continuous â‡‘(f.symm)) : (measure_theory.measure.map â‡‘f Î¼).is_add_haar_measure
{Ïƒ : Type u_1} {R : Type u_2} {S : Type u_3} [comm_ring R] [comm_ring S] (f : R â†’+* S) [is_local_ring_hom f] : is_local_ring_hom (mv_power_series.map Ïƒ f)
{R : Type u_1} {S : Type u_2} [comm_ring R] [strong_rank_condition R] [ring S] [is_domain S] [algebra R S] {n : Type u_3} {m : Type u_4} [fintype n] [fintype m] (b : basis n R S) {I : ideal S} (hI : I â‰  âŠ¥) (c : basis m R â†¥I) : fintype.card m = fintype.card n
{X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra â„ C(X, â„)) (w : A.separates_points) (f : X â†’ â„) (c : continuous f) (Îµ : â„) (pos : 0 < Îµ) : âˆƒ (g : â†¥A), âˆ€ (x : X), âˆ¥â‡‘g x - f xâˆ¥ < Îµ
(n : name) (offset : option â„• := option.none) : tactic expr
{f g : â„ â†’ â„} {a b : â„} {Î¼ : measure_theory.measure â„} (hab : a â‰¤ b) (hfi : interval_integrable f Î¼ a b) (hgi : interval_integrable g Î¼ a b) (hle : f â‰¤áµ[Î¼.restrict (set.Ioc a b)] g) (hlt : â‡‘(Î¼.restrict (set.Ioc a b)) {x : â„ | f x < g x} â‰  0) : âˆ« (x : â„) in a..b, f x âˆ‚Î¼ < âˆ« (x : â„) in a..b, g x âˆ‚Î¼
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] (s : category_theory.limits.trident f) {W : C} {k l : W âŸ¶ s.X} (h : k â‰« s.Î¹ = l â‰« s.Î¹) (j : category_theory.limits.walking_parallel_family J) : k â‰« s.Ï€.app j = l â‰« s.Ï€.app j
(Î¹ : Type u_1) (X : Type u_2) [topological_space X] (s : set X := set.univ) : Type (max u_1 u_2)
{R : Type u} [ring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] {f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)} [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [is_directed Î¹ has_le.le] {i : Î¹} {x : G i} (H : â‡‘(module.direct_limit.of R Î¹ G f i) x = 0) : âˆƒ (j : Î¹) (hij : i â‰¤ j), â‡‘(f i j hij) x = 0
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (f : E â†’L[â„] E) (s : set E) : â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det â†‘f| * â‡‘Î¼ s
{Î± : Type u_2} {_x : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : measure_theory.measure (measure_theory.null_measurable_space Î± Î¼)
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : chain_complex V â„•} (e : P âŸ¶ Q) (zero : P.X 0 âŸ¶ Q.X 1) (comm_zero : e.f 0 = zero â‰« Q.d 1 0) (one : P.X 1 âŸ¶ Q.X 2) (comm_one : e.f 1 = P.d 1 0 â‰« zero + one â‰« Q.d 2 1) (succ : Î  (n : â„•) (p : Î£' (f : P.X n âŸ¶ Q.X (n + 1)) (f' : P.X (n + 1) âŸ¶ Q.X (n + 2)), e.f (n + 1) = P.d (n + 1) n â‰« f + f' â‰« Q.d (n + 2) (n + 1)), Î£' (f'' : P.X (n + 2) âŸ¶ Q.X (n + 3)), e.f (n + 2) = P.d (n + 2) (n + 1) â‰« p.snd.fst + f'' â‰« Q.d (n + 3) (n + 2)) (n : â„•) : Î£' (f : P.X n âŸ¶ Q.X (n + 1)) (f' : P.X (n + 1) âŸ¶ Q.X (n + 2)), e.f (n + 1) = P.d (n + 1) n â‰« f + f' â‰« Q.d (n + 2) (n + 1)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') (n : with_top â„•) : (cont_diff_groupoid âŠ¤ I).local_invariant_prop (cont_diff_groupoid âŠ¤ I') (cont_diff_within_at_prop I I' n)
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– (category_theory.forget D)] (P : Cáµ’áµ– â¥¤ D) (hsep : âˆ€ (X : C) (S : J.cover X) (x y : â†¥(P.obj (opposite.op X))), (âˆ€ (I : S.arrow), â‡‘(P.map I.f.op) x = â‡‘(P.map I.f.op) y) â†’ x = y) (X : C) (S : J.cover X) (s : category_theory.meq (J.plus_obj P) S) (T : Î  (I : S.arrow), J.cover I.Y) (t : Î  (I : S.arrow), category_theory.meq P (T I)) (ht : âˆ€ (I : S.arrow), â‡‘s I = category_theory.grothendieck_topology.plus.mk (t I)) : category_theory.meq P (S.bind T)
{Î¹ : Type u_10} {R : Type u_11} {Râ‚‚ : Type u_12} {M : Type u_13} {Mâ‚‚ : Type u_14} [semiring R] [semiring Râ‚‚] [add_comm_monoid M] [module R M] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [topological_space M] [topological_space Mâ‚‚] {Ïƒ : R â†’+* Râ‚‚} {f : Î¹ â†’ M} (Ï† : M â†’SL[Ïƒ] Mâ‚‚) {x : M} (hf : has_sum f x) : has_sum (Î» (b : Î¹), â‡‘Ï† (f b)) (â‡‘Ï† x)
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [opens_measurable_space Î±] [t2_space Î±] [Î¼.regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) {Îµ : ennreal} (hÎµ : Îµ â‰  0) : âˆƒ (K : set Î±) (H : K âŠ† A), is_compact K âˆ§ â‡‘Î¼ (A  K) < Îµ
{Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hf : dense_range f) {s : set Î²} (hs : is_open s) : s âŠ† closure (f '' (f â»Â¹' s))
{K : Type u_1} {Ïƒ : Type u_2} [fintype K] [fintype Ïƒ] [comm_ring K] (a : Ïƒ â†’ K) : mv_polynomial Ïƒ K
{I : Type vâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {J : Type vâ‚} [category_theory.small_category J] {F : J â¥¤ Î  (i : I), C i} (c : category_theory.limits.cone F) (i : I) : category_theory.limits.cone (F â‹™ category_theory.pi.eval C i)
{R : Type u_1} (Î¹ : Type u_4) [linear_ordered_field R] [fintype Î¹] : â‡‘(convex_hull R) (set.range (Î» (i j : Î¹), ite (i = j) 1 0)) = std_simplex R Î¹
{Î± : Type u_1} {Î¹ : Type u_3} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {I : set Î¹} {t : Î¹ â†’ set Î±} (h : I.pairwise_disjoint t) (hI : I.finite) (ht : âˆ€ (i : Î¹), i âˆˆ I â†’ (t i).finite) : finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒ (x : Î¹) (H : x âˆˆ I), t x), f a)) = finprod (Î» (i : Î¹), finprod (Î» (H : i âˆˆ I), finprod (Î» (j : Î±), finprod (Î» (H : j âˆˆ t i), f j))))
{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] â¦ƒf g : add_hom M Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
{G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [add_group G] [has_measurable_add G] [Î¼.is_add_left_invariant] (f : G â†’ ennreal) (g : G) : âˆ«â» (x : G), f (g + x) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f (set.Ioi 0 Ã—â„‚ set.Ioi 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Ioi 0 Ã—â„‚ set.Ioi 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz_re : 0 â‰¤ z.re) (hz_im : 0 â‰¤ z.im) : âˆ¥f zâˆ¥ â‰¤ C
{Fq : Type u_1} [fintype Fq] [field Fq] (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : polynomial Fq} (hb : b â‰  0) (A : fin n â†’ polynomial Fq) : âˆƒ (t : fin n â†’ fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š)), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†” â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
{R : Type u} {Î¹ : Type v} [comm_ring R] {L : Type w} [lie_ring L] [lie_algebra R L] (I : Î¹ â†’ lie_ideal R L) : lie_ring (direct_sum Î¹ (Î» (i : Î¹), â†¥(I i)))
(ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] {s : set E} (s_nhd : s âˆˆ nhds 0) : is_closed (coe_fn '' weak_dual.polar ğ•œ s)
(Ïƒ : Type u_1) (R : Type u_2) [comm_semiring R] : Type (max u_1 u_2)
{Î± : Type u_1} {G : Type u_8} [normed_group G] [normed_space â„ G] {m m0 : measurable_space Î±} (hm : m â‰¤ m0) (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite (Î¼.trim hm)] (s : set Î±) : G â†’L[â„] â†¥(measure_theory.Lp G 1 Î¼)
{R : Type u} [ring R] {Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type v) [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] : Î¹ â¥¤ Module R
(p : pexpr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{E : Type u_2} [add_comm_group E] [module â„ E] [topological_space E] [topological_add_group E] [has_continuous_smul â„ E] {s : set E} (hs : convex â„ s) {x : E} (hx : x âˆˆ interior s) (t : â„) (ht : 1 < t) : s âŠ† interior (â‡‘(affine_map.homothety x t) '' s)
{G : Type w} [topological_space G] (Î¼ : measure_theory.content G) : measure_theory.outer_measure G
{Ïƒ : Type u_1} (f : Ïƒ â†’ option Ïƒ) (mâ‚ mâ‚‚ : â„•) (a b : Ïƒ) (c : option Ïƒ) (hâ‚ : turing.evals_to_in_time f a â†‘b mâ‚) (hâ‚‚ : turing.evals_to_in_time f b c mâ‚‚) : turing.evals_to_in_time f a c (mâ‚‚ + mâ‚)
{Î± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_zero_class N] â¦ƒf g : (Î± â†’â‚€ M) â†’+ Nâ¦„ (H : âˆ€ (x : Î±), f.comp (finsupp.single_add_hom x) = g.comp (finsupp.single_add_hom x)) : f = g
{R : Type uâ‚} [comm_semiring R] (p : â„•) [hp : fact (nat.prime p)] [char_p R p] {S : Type uâ‚‚} [comm_semiring S] [char_p S p] (Ï† : R â†’+* S) : ring.perfection R p â†’+* ring.perfection S p
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] (f : equiv.perm Î±) (comm : (âˆ€ (g : equiv.perm Î±), g âˆˆ f.cycle_factors_finset â†’ âˆ€ (h : equiv.perm Î±), h âˆˆ f.cycle_factors_finset â†’ commute (id g) (id h)) := _) : f.cycle_factors_finset.noncomm_prod id comm = f
(t : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic (list subsingleton_info)
{R : Type u} {L : Type v} {L' : Type wâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] {f : L â†’â‚—â…Râ† L'} {I : lie_ideal R L} : I â‰¤ lie_ideal.comap f (lie_ideal.map f I)
{F : Type u_3} [inner_product_space â„ F] (x y : F) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” has_inner.inner x y = 0
{Ïƒ : Type u} : Ïƒ â†’ Ïƒ â†’ Prop
{A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] (hNF : Â¬is_field A) {I M : ideal A} (hI0 : I â‰  âŠ¥) (hIM : I â‰¤ M) [hM : M.is_maximal] : âˆƒ (Z : multiset (prime_spectrum A)), (M ::â‚˜ multiset.map prime_spectrum.as_ideal Z).prod â‰¤ I âˆ§ Â¬(multiset.map prime_spectrum.as_ideal Z).prod â‰¤ I
(Î± : Type u_1) (Ïƒ : Type u_2) [partial_order Î±] : Type (max u_1 u_2)
{G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] {H : Type v} [add_group H] â¦ƒf g : G â§¸ N â†’+ Hâ¦„ (h : f.comp (quotient_add_group.mk' N) = g.comp (quotient_add_group.mk' N)) : f = g
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_4} [normed_group F] [normed_space ğ•œ F] {H : Type u_5} [topological_space H] {G : Type u_7} [topological_space G] {I : model_with_corners ğ•œ E H} {J : model_with_corners ğ•œ F G} {M : Type u_8} [topological_space M] [charted_space H M] {N : Type u_10} [topological_space N] [charted_space G N] {n : with_top â„•} (h : diffeomorph I J M N n) : diffeomorph J I N M n
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {f f' : â„ â†’ â„} {g : â„ â†’ E} (hf : continuous_on f (set.interval a b)) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo (linear_order.min a b) (linear_order.max a b) â†’ has_deriv_within_at f (f' x) (set.Ioi x) x) (hf' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (u : â„) in f a..f b, g u
(R : Type u) {M : Type v} {Î¹ : Type x} [semiring R] (Ï† : Î¹ â†’ Type i) [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] (S : Type u_1) [add_comm_monoid M] [module R M] [fintype Î¹] [decidable_eq Î¹] [semiring S] [module S M] [smul_comm_class R S M] : (Î  (i : Î¹), Ï† i â†’â‚—[R] M) â‰ƒâ‚—[S] (Î  (i : Î¹), Ï† i) â†’â‚—[R] M
{Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] (ğ’œ : Î¹ â†’ submodule R A) [decidable_eq Î¹] [add_monoid Î¹] [graded_algebra ğ’œ] (I : ideal A) : homogeneous_ideal ğ’œ
{G : Type w} [topological_space G] (Î¼ : measure_theory.content G) [t2_space G] [S : measurable_space G] [borel_space G] [locally_compact_space G] : Î¼.measure.regular
{M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] â¦ƒf g : M â†’â‚™* Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
{Î¹ : Type u_1} {Ïƒ : Type u_2} {R : Type u_4} [decidable_eq Î¹] [add_monoid Î¹] [semiring R] [set_like Ïƒ R] [add_submonoid_class Ïƒ R] (A : Î¹ â†’ Ïƒ) [set_like.graded_monoid A] : direct_sum Î¹ (Î» (i : Î¹), â†¥(A i)) â†’+* R
{Î± : Type u} {Î² : Type v} (s : set Î±) {f : Î± â†’ Î²} {g : Î² â†’ option Î±} (I : function.is_partial_inv f g) [fintype â†¥(f '' s)] : fintype â†¥s
{E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] {n : â„•} (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) â†’ â„) â†’ fin (n + 1) â†’ E) (f' : (fin (n + 1) â†’ â„) â†’ ((fin (n + 1) â†’ â„) â†’L[â„] fin (n + 1) â†’ E)) (s : set (fin (n + 1) â†’ â„)) (hs : s.countable) (Hc : continuous_on f (â‡‘box_integral.box.Icc I)) (Hd : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I  s â†’ has_fderiv_within_at f (f' x) (â‡‘box_integral.box.Icc I) x) (Hi : measure_theory.integrable_on (Î» (x : fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i)) (â‡‘box_integral.box.Icc I) measure_theory.measure_space.volume) : âˆ« (x : fin (n + 1) â†’ â„) in â‡‘box_integral.box.Icc I, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
(ns : name) (s : tactic.local_cache.internal.cache_scope := tactic.local_cache.cache_scope.block_local) : tactic bool
{I : Type u} (f : I â†’ Type v) [decidable_eq I] [Î  (i : I), has_zero (f i)] (i : I) : zero_hom (f i) (Î  (i : I), f i)
{Î¹ : Type u_1} {I : box_integral.box Î¹} [fintype Î¹] (Ï€ : box_integral.prepartition I) : âˆƒ (Ï€' : box_integral.prepartition I), Ï€'.Union = â†‘I  Ï€.Union
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) : set (Î¹ â†’ â„)
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.outer_measure Î±} {s : set Î±} (hs : measurable_set s) : (â‡‘(measure_theory.outer_measure.restrict s) Î¼).trim = â‡‘(measure_theory.outer_measure.restrict s) Î¼.trim
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (s : set M) : add_subsemigroup.map f (add_subsemigroup.closure s) = add_subsemigroup.closure (â‡‘f '' s)
{Î¹ : Type u_1} [fintype Î¹] {f : (Î¹ â†’ â„) â†’â‚—[â„] Î¹ â†’ â„} (hf : â‡‘linear_map.det f â‰  0) : measure_theory.measure.map â‡‘f measure_theory.measure_space.volume = ennreal.of_real |(â‡‘linear_map.det f)â»Â¹| â€¢ measure_theory.measure_space.volume
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : x = y â†” hb.oangle x y = 0
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {s t : set Î±} : Î¼.restrict (s âˆª t) = Î½.restrict (s âˆª t) â†” Î¼.restrict s = Î½.restrict s âˆ§ Î¼.restrict t = Î½.restrict t
{Î± : Type u_1} [topological_space Î±] [measure_theory.measure_space Î±] [borel_space Î±] {ğ•œ : Type u_2} [is_R_or_C ğ•œ] (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (f g : bounded_continuous_function Î± ğ•œ) : has_inner.inner (â‡‘(bounded_continuous_function.to_Lp 2 Î¼ ğ•œ) f) (â‡‘(bounded_continuous_function.to_Lp 2 Î¼ ğ•œ) g) = âˆ« (x : Î±), â‡‘(star_ring_end ğ•œ) (â‡‘f x) * â‡‘g x âˆ‚Î¼
{n : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) [field K] [algebra K L] [ne_zero â†‘â†‘n] (hn : is_prime_pow â†‘n) [is_cyclotomic_extension {n} K L] (hirr : irreducible (polynomial.cyclotomic â†‘n K)) (h : n â‰  2) : â‡‘(algebra.norm K) (Î¶ - 1) = â†‘(â†‘n.min_fac)
{I : Type u} {f : I â†’ Type vâ‚} {g : I â†’ Type vâ‚‚} (f' : Î  (i : I), f i) (g' : Î  (i : I), g i) (i : I) : f i Ã— g i
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) {a : Î±} {s : set Î±} : is_greatest s a â†’ is_least (f '' s) (f a)
{Ïƒ : Type u_1} {R : Type u_4} [comm_semiring R] (p : mv_polynomial Ïƒ R) : âˆƒ (s : finset Ïƒ) (q : mv_polynomial {x // x âˆˆ s} R), p = â‡‘(mv_polynomial.rename coe) q
{Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), semi_normed_group (Ï€ i)] : semi_normed_group (Î  (i : Î¹), Ï€ i)
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] {s : set (Î± Ã— Î²)} (hs : measurable_set s) : measurable (Î» (y : Î²), â‡‘Î¼ ((Î» (x : Î±), (x, y)) â»Â¹' s))
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (R : â„) (hs : s âŠ† metric.closed_ball 0 R) (Îµ : nnreal) (Îµpos : 0 < Îµ) (h'f' : âˆ€ (x : E), x âˆˆ s â†’ (f' x).det = 0) : â‡‘Î¼ (f '' s) â‰¤ â†‘Îµ * â‡‘Î¼ (metric.closed_ball 0 R)
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {t : set Î±} (Hf : antitone_on f t) {a : Î±} : is_least t a â†’ is_greatest (f '' t) (f a)
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : filter Î±} : Î¼.finite_at_filter (f âŠ“ Î¼.ae) â†’ Î¼.finite_at_filter f
{Î“ : Type u_1} [inhabited Î“] {Î“' : Type u_2} [inhabited Î“'] {Î› : Type u_3} [inhabited Î›] {Î›' : Type u_4} [inhabited Î›'] (M : turing.TM0.machine Î“ Î›) (fâ‚ : turing.pointed_map Î“ Î“') (fâ‚‚ : turing.pointed_map Î“' Î“) (gâ‚ : Î› â†’ Î›') (gâ‚‚ : Î›' â†’ Î›) : turing.TM0.machine Î“' Î›'
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic unit
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R â†’+* S) (g : S â†’+* R) (I : ideal S) (h : function.left_inverse â‡‘g â‡‘f) : ideal.comap f I â‰¤ ideal.map g I
(Râ‚ : Type u_3) {A : Type u_5} [comm_semiring Râ‚] [comm_ring A] [algebra Râ‚ A] {I : ideal A} : algebra Râ‚ (A â§¸ I)
{V : Type u_1} [inner_product_space â„ V] (x y : V) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space ğ•œ H] {F : H â†’ Î± â†’ E} {F' : Î± â†’ (H â†’L[ğ•œ] E)} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : H) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) Î¼) (hF_int : measure_theory.integrable (F xâ‚€) Î¼) (hF'_meas : measure_theory.ae_strongly_measurable F' Î¼) (h_lip : âˆ€áµ (a : Î±) âˆ‚Î¼, lipschitz_on_with (â‡‘real.nnabs (bound a)) (Î» (x : H), F x a) (metric.ball xâ‚€ Îµ)) (bound_integrable : measure_theory.integrable bound Î¼) (h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, has_fderiv_at (Î» (x : H), F x a) (F' a) xâ‚€) : measure_theory.integrable F' Î¼ âˆ§ has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (Î¼ : R) (k : â„•) (x : M) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X âŸ¶ Y} {W : C} (g : W âŸ¶ X) (eq : g â‰« f = 0) (lift : Î  {W' : C} (g' : W' âŸ¶ X), g' â‰« f = 0 â†’ (W' âŸ¶ W)) (fac : âˆ€ {W' : C} (g' : W' âŸ¶ X) (eq' : g' â‰« f = 0), lift g' eq' â‰« g = g') (uniq : âˆ€ {W' : C} (g' : W' âŸ¶ X) (eq' : g' â‰« f = 0) (m : W' âŸ¶ W), m â‰« g = g' â†’ m = lift g' eq') : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Î¹ g eq)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Z âŸ¶ Y) (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) : J.cocomplex.X 0 âŸ¶ I.cocomplex.X 0
(B : Type uâ‚) [quiver B] [Î  (a b : B), quiver (a âŸ¶ b)] : category_theory.prelax_functor B B
{I : Type u} [decidable_eq I] {Î² : Type u_1} [has_zero Î²] (i : I) (x : Î²) (i' : I) : pi.single i x i' = pi.single i' x i
{C : Type u} [category_theory.category C] {I : category_theory.limits.multicospan_index C} [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] (K : category_theory.limits.multifork I) : category_theory.limits.fork I.fst_pi_map I.snd_pi_map
{R : Type u} {Mâ‚‚ : Type vâ‚‚} {Mâ‚ƒ : Type vâ‚ƒ} [semiring R] [add_comm_monoid Mâ‚‚] [add_comm_monoid Mâ‚ƒ] [module R Mâ‚‚] [module R Mâ‚ƒ] {Î¹â‚ : Type u_1} {Î¹â‚‚ : Type u_2} [decidable_eq Î¹â‚] [decidable_eq Î¹â‚‚] (Ïƒ : Î¹â‚ â‰ƒ Î¹â‚‚) (m : multilinear_map R (Î» (i : Î¹â‚), Mâ‚‚) Mâ‚ƒ) : multilinear_map R (Î» (i : Î¹â‚‚), Mâ‚‚) Mâ‚ƒ
{I : Type wâ‚} (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] {J : Type wâ‚‚} (g : J â†’ I) (j : J) : category_theory.sigma.incl j â‹™ category_theory.sigma.map C g â‰… category_theory.sigma.incl (g j)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) {G : Type u_4} [has_mul G] [topological_space G] [charted_space H G] [has_smooth_mul I G] : has_continuous_mul G
(p : pos) (w : widget.component tactic_state empty) (text : string := "(widget)") : tactic unit
{Î± : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [preorder Î¹] {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] (f : Î¹ â†’ Î± â†’ E) (â„± : measure_theory.filtration Î¹ m0) (Î¼ : measure_theory.measure Î±) : Prop
{Î± : Type u_3} {f : filter Î±} {s : â„• â†’ set Î±} (hs : f.has_antitone_basis s) {r : â„• â†’ â„• â†’ Prop} (hr : âˆ€ (m : â„•), âˆ€á¶  (n : â„•) in filter.at_top, r m n) : âˆƒ (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ (âˆ€ â¦ƒm n : â„•â¦„, m < n â†’ r (Ï† m) (Ï† n)) âˆ§ f.has_antitone_basis (s âˆ˜ Ï†)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M â†’ M') (s : set M) : Prop
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), 0 < g x) âˆ§ measurable g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ < Îµ
{Ïƒ : Type u_1} (R : Type u_2) {A : Type u_3} [comm_semiring R] [add_comm_monoid A] [module R A] [module (mv_polynomial Ïƒ R) A] (f : Ïƒ â†’ A) : mv_polynomial Ïƒ R â†’â‚—[R] A
{R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) (y : R) (h : âˆ¥y - â†‘xâˆ¥ < âˆ¥â†‘xâ»Â¹âˆ¥â»Â¹) : RË£
{R : Type u} [comm_ring R] (I J : ideal R) : (double_quot.quot_quot_mk I J).ker = I âŠ” J
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (i : Î¹) (s : set M) : smooth_partition_of_unity Î¹ I M s
{ğ•œ : Type u_1} [normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {c : ğ•œ} (hc : 1 < âˆ¥câˆ¥) {R : â„} (hR : âˆ¥câˆ¥ < R) {F : subspace ğ•œ E} (hFc : is_closed â†‘F) (hF : âˆƒ (x : E), x âˆ‰ F) : âˆƒ (xâ‚€ : E), âˆ¥xâ‚€âˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ F â†’ 1 â‰¤ âˆ¥xâ‚€ - yâˆ¥
{Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) : function.left_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p Î¼ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p Î¼ hm)
{Î± : Type u_1} {E : Type u_4} {ğ•œ : Type u_11} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [complete_space E] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp E 2 Î¼)) (c : E) : â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) (measure_theory.mem_â„’p.to_Lp (Î» (a : Î±), has_inner.inner c (â‡‘f a)) _)) =áµ[Î¼] Î» (a : Î±), has_inner.inner c (â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) f) a)
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X âŸ¶ Y) (â„± : Top.presheaf C Y) (U : topological_space.opens â†¥X) (H : is_open (â‡‘f '' â†‘U)) : (Top.presheaf.pullback_obj f â„±).obj (opposite.op U) â‰… â„±.obj (opposite.op âŸ¨â‡‘f '' â†‘U, HâŸ©)
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) {C : â„} (hC : 0 â‰¤ C) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ C * â†‘(fintype.card Î¹) * linear_order.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
{N : Type u_2} {Î± : Type u_3} [preorder Î±] [preorder N] {f : N â†’ Î±} {Î¼ : N â†’ N â†’ N} [covariant_class N N (function.swap Î¼) has_le.le] (hf : monotone f) (m : N) : monotone (Î» (n : N), f (Î¼ n m))
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} {P : C} (Ï€ : Y âŸ¶ P) (w : f â‰« Ï€ = g â‰« Ï€) : category_theory.limits.cofork f g
{Î¹ : Type u_1} [decidable_eq Î¹] {R : Type u_4} [comm_semiring R] {s : Î¹ â†’ Type u_7} [Î  (i : Î¹), add_comm_monoid (s i)] [Î  (i : Î¹), module R (s i)] {F : Type u_10} [add_comm_monoid F] (Ï† : (R Ã— Î  (i : Î¹), s i) â†’ F) (C0 : âˆ€ (r : R) (f : Î  (i : Î¹), s i) (i : Î¹), f i = 0 â†’ Ï† (r, f) = 0) (C0' : âˆ€ (f : Î  (i : Î¹), s i), Ï† (0, f) = 0) (C_add : âˆ€ (r : R) (f : Î  (i : Î¹), s i) (i : Î¹) (mâ‚ mâ‚‚ : s i), Ï† (r, function.update f i mâ‚) + Ï† (r, function.update f i mâ‚‚) = Ï† (r, function.update f i (mâ‚ + mâ‚‚))) (C_add_scalar : âˆ€ (r r' : R) (f : Î  (i : Î¹), s i), Ï† (r, f) + Ï† (r', f) = Ï† (r + r', f)) (C_smul : âˆ€ (r : R) (f : Î  (i : Î¹), s i) (i : Î¹) (r' : R), Ï† (r, function.update f i (r' â€¢ f i)) = Ï† (r' * r, f)) : pi_tensor_product R (Î» (i : Î¹), s i) â†’+ F
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ W) (g : Y âŸ¶ W) (i : W âŸ¶ Z) [category_theory.mono i] [category_theory.limits.has_pullback f g] : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk category_theory.limits.pullback.fst category_theory.limits.pullback.snd _)
{F : Type u_3} [inner_product_space â„ F] {x y : F} (hx : âˆ¥xâˆ¥ = 1) (hy : âˆ¥yâˆ¥ = 1) : has_inner.inner x y < 1 â†” x â‰  y
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hfi : measure_theory.integrable f Î¼) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆƒ (t : set Î±), measurable_set t âˆ§ â‡‘Î¼ t â‰  0 âˆ§ â‡‘Î¼ tá¶œ â‰  0 âˆ§ â¨ (x : Î±) in t, f x âˆ‚Î¼ â‰  â¨ (x : Î±) in tá¶œ, f x âˆ‚Î¼
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : cont_mdiff_map I I' M M' âŠ¤} {x : M} {y : M'} (h : â‡‘f x = y) : point_derivation I x â†’â‚—[ğ•œ] point_derivation I' y
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] (n : â„•) : (vector bool n â†’ turing.TM1.stmt bool turing.TM1to1.Î›' Ïƒ) â†’ turing.TM1.stmt bool turing.TM1to1.Î›' Ïƒ
{G : Type u_1} [measurable_space G] [has_mul G] [has_measurable_mul G] (Î¼ : measure_theory.measure G) : (âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), h * g) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_mul_right_invariant
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [complete_space F] {T : set Î± â†’ (E â†’L[â„] F)} {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) (f : â†¥(measure_theory.Lp E 1 Î¼)) {Î¹ : Type u_4} (fs : Î¹ â†’ â†¥(measure_theory.Lp E 1 Î¼)) {l : filter Î¹} (hfs : filter.tendsto fs l (nhds f)) : filter.tendsto (Î» (i : Î¹), â‡‘(measure_theory.L1.set_to_L1 hT) (fs i)) l (nhds (â‡‘(measure_theory.L1.set_to_L1 hT) f))
{Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] (p : ennreal) {Î¼ : measure_theory.measure Î±} {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (c : E) : â†¥(measure_theory.Lp.simple_func E p Î¼)
{L : first_order.language} {L' : first_order.language} {Î± : Type u'} (Ï† : L â‰ƒá´¸ L') : L.formula Î± â‰ƒ L'.formula Î±
{ğ•œ : Type u_1} {E : Type u_3} {F : Type u_4} [ordered_ring ğ•œ] [topological_space E] [topological_space F] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] {s : set E} (hs : strict_convex ğ•œ s) {f : E â†’áµƒ[ğ•œ] F} (hf : is_open_map â‡‘f) : strict_convex ğ•œ (â‡‘f '' s)
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {Î² : Type u_2} [topological_space Î²] (f : Î± â†’ Î²) (hf : measure_theory.ae_strongly_measurable f Î¼) : Î± â†’â‚˜[Î¼] Î²
{E : Type u_3} [semi_normed_group E] (g h : E) : âˆ¥g + hâˆ¥ â‰¤ âˆ¥gâˆ¥ + âˆ¥hâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î²] {f : Î² â†’ Î± â†’ ennreal} (hf : âˆ€ (b : Î²), measurable (f b)) (h_directed : directed has_le.le f) : âˆ«â» (a : Î±), (â¨† (b : Î²), f b a) âˆ‚Î¼ = â¨† (b : Î²), âˆ«â» (a : Î±), f b a âˆ‚Î¼
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] {n : â„•} (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (c : composition n) : âˆ¥q.comp_along_composition p câˆ¥ â‰¤ âˆ¥q c.lengthâˆ¥ * finset.univ.prod (Î» (i : fin c.length), âˆ¥p (c.blocks_fun i)âˆ¥)
(Î± : Type u) (Î² : Type v) [group Î±] [mul_action Î± Î²] : Î² â‰ƒ Î£ (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), â†¥(mul_action.orbit Î± Ï‰.out')
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_5} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_8) [topological_space M] [charted_space H M] (n : with_top â„•) : diffeomorph I I M M n
{Î± : Type u_1} {ğ•œ : Type u_14} [normed_field ğ•œ] {l : filter Î±} {u v : Î± â†’ ğ•œ} : u =O[l] v â†’ (âˆƒ (Ï† : Î± â†’ ğ•œ) (hÏ† : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ Ï†)), u =á¶ [l] Ï† * v)
{Î± : Type u_1} {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} (hm : m â‰¤ m0) {f g : Î± â†’ â„} (hf : measure_theory.strongly_measurable f) (hfi : measure_theory.integrable_on f s Î¼) (hg : measure_theory.strongly_measurable g) (hgi : measure_theory.integrable_on g s Î¼) (hgf : âˆ€ (t : set Î±), measurable_set t â†’ â‡‘Î¼ t < âŠ¤ â†’ âˆ« (x : Î±) in t, g x âˆ‚Î¼ = âˆ« (x : Î±) in t, f x âˆ‚Î¼) (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) : âˆ«â» (x : Î±) in s, â†‘âˆ¥g xâˆ¥â‚Š âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±) in s, â†‘âˆ¥f xâˆ¥â‚Š âˆ‚Î¼
{Î± : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space Î±} (X : Î± â†’ E) (â„™ : measure_theory.measure Î±) (Î¼ : measure_theory.measure E . "volume_tac") : E â†’ ennreal
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {v w : E} (h : has_inner.inner v w = 0) : âˆ¥w - vâˆ¥ = âˆ¥w + vâˆ¥
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {Îµ : Type u_9} {s : set Î±} {t : set Î²} {u : set Î³} {f : Î´ â†’ Î³ â†’ Îµ} {g : Î± â†’ Î² â†’ Î´} {fâ‚ : Î± â†’ Î³ â†’ Î±'} {fâ‚‚ : Î² â†’ Î³ â†’ Î²'} {g' : Î±' â†’ Î²' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), f (g a b) c = g' (fâ‚ a c) (fâ‚‚ b c)) : set.image2 f (set.image2 g s t) u âŠ† set.image2 g' (set.image2 fâ‚ s u) (set.image2 fâ‚‚ t u)
{I : Type uâ‚} [category_theory.category I] {B : Type uâ‚‚} [category_theory.bicategory B] [category_theory.bicategory.strict B] (F : I â¥¤ B) : category_theory.oplax_functor (category_theory.locally_discrete I) B
{R : Type u} [ring R] {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] {i j k : Î¹} (hij : i â‰¤ j) (hjk : j â‰¤ k) (x : G i) : â‡‘(f j k hjk) (â‡‘(f i j hij) x) = â‡‘(f i k _) x
{Î± : Type u_1} {m : measurable_space Î±} (s : measure_theory.signed_measure Î±) {i : set Î±} (hi : measure_theory.vector_measure.restrict s i â‰¤ 0.restrict i) (hiâ‚ : measurable_set i) : measure_theory.is_finite_measure (s.to_measure_of_le_zero i hiâ‚ hi)
{p : â„•} {R : Type u_1} [comm_ring R] {k : â„•} (Ï† : â„• â†’ mv_polynomial (fin k Ã— â„•) â„¤) (x : fin k â†’ witt_vector p R) : witt_vector p R
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.tagged_prepartition I) : set (Î¹ â†’ â„)
{V : Type u} {W : Type v} {X : Type w} {G : simple_graph V} {G' : simple_graph W} {G'' : simple_graph X} (f' : G' â‰ƒg G'') (f : G â‰ƒg G') : G â‰ƒg G''
{C : Type uâ‚} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X âŸ¶ Y) [I : category_theory.normal_epi f] : category_theory.regular_epi f
(L : first_order.language) (Î¹ : Type v) [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [is_directed Î¹ has_le.le] [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [nonempty Î¹] {P : Type uâ‚} [L.Structure P] (g : Î  (i : Î¹), L.embedding (G i) P) (Hg : âˆ€ (i j : Î¹) (hij : i â‰¤ j) (x : G i), â‡‘(g j) (â‡‘(f i j hij) x) = â‡‘(g i) x) : L.embedding (first_order.language.direct_limit G f) P
{J : Type uâ‚} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J â¥¤ C) [category_theory.limits.has_colimit F] (W : C) : ulift (category_theory.limits.colimit F âŸ¶ W) â‰… F.cocones.obj W
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] (Î¼ : measure_theory.measure Î±) [Î¼.weakly_regular] [measure_theory.sigma_finite Î¼] (f : Î± â†’ nnreal) (fmeas : ae_measurable f Î¼) {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
{ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f : ğ•œ â†’ G} {s : set ğ•œ} {x y : ğ•œ} {C : â„} (hf : differentiable_on ğ•œ f s) (bound : âˆ€ (x : ğ•œ), x âˆˆ s â†’ âˆ¥deriv_within f s xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {ca cb : E} {la la' lb lb' : filter â„} {lt : filter Î¹} {a b : â„} {ua ub va vb : Î¹ â†’ â„} [interval_integral.FTC_filter a la la'] [interval_integral.FTC_filter b lb lb'] (hab : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f la' measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb' measure_theory.measure_space.volume) (ha_lim : filter.tendsto f (la' âŠ“ measure_theory.measure_space.volume.ae) (nhds ca)) (hb_lim : filter.tendsto f (lb' âŠ“ measure_theory.measure_space.volume.ae) (nhds cb)) (hua : filter.tendsto ua lt la) (hva : filter.tendsto va lt la) (hub : filter.tendsto ub lt lb) (hvb : filter.tendsto vb lt lb) : (Î» (t : Î¹), ((âˆ« (x : â„) in va t..vb t, f x) - âˆ« (x : â„) in ua t..ub t, f x) - ((vb t - ub t) â€¢ cb - (va t - ua t) â€¢ ca)) =o[lt] Î» (t : Î¹), âˆ¥va t - ua tâˆ¥ + âˆ¥vb t - ub tâˆ¥
{Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), has_zero (Î² i)] [Î  (i : Î¹) (x : Î² i), decidable (x â‰  0)] [add_comm_monoid Î³] (f : Î â‚€ (i : Î¹), Î² i) (g : Î  (i : Î¹), Î² i â†’ Î³) : Î³
{elab : bool := bool.tt} : expr elab â†’ option (name Ã— binder_info Ã— expr elab Ã— expr elab)
{Î± : Type u_1} {m : set (measure_theory.outer_measure Î±)} {s : set Î±} (h : m.nonempty) : â‡‘(has_Inf.Inf m) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (Î¼ : measure_theory.outer_measure Î±) (h3 : Î¼ âˆˆ m), â‡‘Î¼ (t n)
{G : Type u_1} [measurable_space G] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] (Î¼ : measure_theory.measure G) [Î¼.is_add_left_invariant] (K : set G) (hK : is_compact K) (h'K : (interior K).nonempty) (h : â‡‘Î¼ K â‰  0) (h' : â‡‘Î¼ K â‰  âŠ¤) : Î¼.is_add_haar_measure
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) (H : finset (Î£' (X Y : C) (mX : X âˆˆ O) (mY : Y âˆˆ O), X âŸ¶ Y)) : âˆƒ (S : C) (T : Î  {X : C}, X âˆˆ O â†’ (X âŸ¶ S)), âˆ€ {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y}, âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H â†’ f â‰« T mY = T mX
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i))
{ğ•† : Type u_1} {â„™ : Type u_2} {Î± : Type u_3} [preorder ğ•†] [preorder Â«â„™Â»] [preorder Î±] [grade_bounded_order ğ•† Î±] (f : ğ•† â†’ Â«â„™Â») (hf : strict_mono f) (hcovby : âˆ€ (a b : ğ•†), a â‹– b â†’ f a â‹– f b) (hmin : âˆ€ (a : ğ•†), is_min a â†’ is_min (f a)) (hmax : âˆ€ (a : ğ•†), is_max a â†’ is_max (f a)) : grade_bounded_order Â«â„™Â» Î±
{X : Type u_1} {R : Type u_9} {Î¹ : Type u_10} {U : Î¹ â†’ set X} [topological_space X] [has_zero R] {f : Î¹ â†’ X â†’ R} (hlf : locally_finite (Î» (i : Î¹), function.support (f i))) (hso : âˆ€ (i : Î¹), tsupport (f i) âŠ† U i) (ho : âˆ€ (i : Î¹), is_open (U i)) (x : X) : âˆƒ (is : finset Î¹) {n : set X} (hnâ‚ : n âˆˆ nhds x) (hnâ‚‚ : n âŠ† â‹‚ (i : Î¹) (H : i âˆˆ is), U i), âˆ€ (z : X), z âˆˆ n â†’ function.support (Î» (i : Î¹), f i z) âŠ† â†‘is
{Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : â„• â†’ Î© â†’ â„) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hident : âˆ€ (i : â„•), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) : (Î» (n : â„•), (âˆ« (a : Î©), (finset.range n).sum (Î» (i : â„•), probability_theory.truncation (X i) â†‘i) a) - â†‘n * âˆ« (a : Î©), X 0 a) =o[filter.at_top] coe
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : Type (max u_4 u_2)
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : âˆ¥S.normed_mkâˆ¥ â‰¤ 1
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {p q : â„} (hpq : p.is_conjugate_exponent q) {f g : Î± â†’ ennreal} (hf : ae_measurable f Î¼) (hf_nontop : âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼ â‰  âŠ¤) (hg_nontop : âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼ â‰  âŠ¤) (hf_nonzero : âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼ â‰  0) (hg_nonzero : âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼ â‰  0) : âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼) ^ (1 / q)
{M : Type u_1} [has_mul M] (c d : con M) : c âŠ” d = con_gen (Î» (x y : M), â‡‘c x y âˆ¨ â‡‘d x y)
(R : Type u) (Ïƒ : Type v) [comm_ring R] [fintype Ïƒ] [is_domain R] : is_domain (mv_polynomial Ïƒ R)
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] (M : turing.TM0.machine Î“ Î›) : turing.TM0to1.Î›' â†’ turing.TM1.stmt Î“ turing.TM0to1.Î›' unit
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {F : Type u_4} [normed_group F] [normed_space ğ•œ F] {H : Type u_5} [topological_space H] {H' : Type u_6} [topological_space H'] {G : Type u_7} [topological_space G] {I : model_with_corners ğ•œ E H} {I' : model_with_corners ğ•œ E' H'} {J : model_with_corners ğ•œ F G} {M : Type u_8} [topological_space M] [charted_space H M] {M' : Type u_9} [topological_space M'] [charted_space H' M'] {N : Type u_10} [topological_space N] [charted_space G N] {n : with_top â„•} (hâ‚ : diffeomorph I I' M M' n) (hâ‚‚ : diffeomorph I' J M' N n) : diffeomorph I J M N n
{Î± : Type u} {Î² : Type v} (e : Î± â‰ƒ Î²) [has_add Î²] : let _inst : has_add Î± := e.has_add in Î± â‰ƒ+ Î²
{ğ•œ : Type u} {A : Type v} [field ğ•œ] [ring A] [algebra ğ•œ A] [is_alg_closed ğ•œ] (a : A) (p : polynomial ğ•œ) (hdeg : 0 < p.degree) : spectrum ğ•œ (â‡‘(polynomial.aeval a) p) = (Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {t : set Î±} (Hf : antitone_on f t) {a : Î±} : is_greatest t a â†’ is_least (f '' t) (f a)
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] (hcg : has_compact_support g) (hf : measure_theory.integrable f Î¼) (hg : continuous g) : continuous (convolution f g L Î¼)
{Î± : Type u} {Ïƒ : Type v} (M : DFA Î± Ïƒ) : language Î±
{f f' : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f x = B x â†’ f' x < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} {W : C} {h : Y âŸ¶ W} {k : Z âŸ¶ W} {comm : f â‰« h = g â‰« k} (t : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk k h category_theory.limits.pushout_cocone.flip_is_colimit._proof_1)) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk h k comm)
{K : Type u_1} [comm_ring K] [is_domain K] {Î¶ : K} {n : â„•} (hpos : 0 < n) (h : is_primitive_root Î¶ n) : n.divisors.prod (Î» (i : â„•), polynomial.cyclotomic' i K) = polynomial.X ^ n - 1
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hl : Î¼.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : v â‰¤á¶ [lt] u) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ + (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real
{Î± : Type u_1} {ğ•œ : Type u_2} [linear_ordered_field ğ•œ] (G : simple_graph Î±) [decidable_rel G.adj] (Îµ : ğ•œ) (s t : finset Î±) : Prop
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ = has_Inf.Inf ((Î» (x : M), âˆ¥m + xâˆ¥) '' â†‘S)
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {f : Î± â†’ E} {Î¼ : measure_theory.measure Î±} {l : filter Î±} : measure_theory.integrable_at_filter f (l âŠ“ Î¼.ae) Î¼ â†’ measure_theory.integrable_at_filter f l Î¼
{Î± : Type u_1} {m0 : measurable_space Î±} [topological_space Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure_on_compacts Î¼] â¦ƒK : set Î±â¦„ (hK : is_compact K) : â‡‘Î¼ K < âŠ¤
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [fintype Î¹] {s : set M} (f : smooth_bump_covering Î¹ I M s) : cont_mdiff_map I (model_with_corners_self â„ (Î¹ â†’ E Ã— â„)) M (Î¹ â†’ E Ã— â„) âŠ¤
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {W X Y Z : C} [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] [category_theory.monoidal_category.monoidal_coherence X Y] (f : W âŸ¶ X) (g : Y âŸ¶ Z) : W âŸ¶ Z
{Î± : Type u_1} {E : Type u_3} [topological_space Î±] [compact_space Î±] [normed_group E] (f : C(Î±, E)) (x y : Î±) : has_dist.dist (â‡‘f x) (â‡‘f y) â‰¤ 2 * âˆ¥fâˆ¥
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î½ : measure_theory.measure Î²} [normed_group E] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î½] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.strongly_measurable f) : measure_theory.strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½)
{L : first_order.language} {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), L.Structure (G i)] {f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)} [is_directed Î¹ has_le.le] [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [nonempty Î¹] (z : first_order.language.direct_limit G f) : âˆƒ (i : Î¹) (x : G i), â‡‘(first_order.language.direct_limit.of L Î¹ G f i) x = z
(Î± : Type u_1) (Ï€ : Î± â†’ Type u_2) [decidable_eq Î±] [fintype Î±] [Î  (a : Î±), encodable (Ï€ a)] : trunc (encodable (Î  (a : Î±), Ï€ a))
{G : Type u_1} [measurable_space G] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [t1_space G] [locally_compact_space G] [(nhds_within 0 {0}á¶œ).ne_bot] (Î¼ : measure_theory.measure G) [Î¼.is_add_haar_measure] : measure_theory.has_no_atoms Î¼
{Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} [encodable Î¹] (Î¼ : Î¹ â†’ measure_theory.outer_measure Î±) : (â¨† (i : Î¹), Î¼ i).trim = â¨† (i : Î¹), (Î¼ i).trim
{G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {K : Type u_3} [group K] [topological_space K] [nonarchimedean_group K] {U : set (G Ã— K)} (hU : U âˆˆ nhds 1) : âˆƒ (V : open_subgroup G) (W : open_subgroup K), â†‘V Ã—Ë¢ â†‘W âŠ† U
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measurable_space Î²] {f : measure_theory.simple_func Î± ennreal} {g : measure_theory.simple_func Î² ennreal} {Î½ : measure_theory.measure Î²} (H : âˆ€ (y : ennreal), â‡‘Î¼ (â‡‘f â»Â¹' {y}) = â‡‘Î½ (â‡‘g â»Â¹' {y})) : f.lintegral Î¼ = g.lintegral Î½
{Î± : Type u_1} {Î² : Type u_2} [has_zero Î²] {m : measurable_space Î±} (f : measure_theory.simple_func Î± Î²) (Î¼ : measure_theory.measure Î±) : Prop
{Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] (x : Î±) : filter.tendsto (Î» (r : â„), metric.closed_ball x r) (nhds_within 0 (set.Ioi 0)) ((besicovitch.vitali_family Î¼).filter_at x)
{R : Type u_1} {V : Type u_2} {W : Type u_3} [ring R] [add_comm_group V] [module R V] [topological_space V] [add_comm_group W] [module R W] [topological_space W] (f : V â†’L[R] W) : V â†’A[R] W
{ğ•œ : Type u_1} {R : Type u_2} {E : Type u_3} {H : Type u_4} [topological_space R] [topological_space H] [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [charted_space H R] (I : model_with_corners ğ•œ E H) [semiring R] [smooth_ring I R] : topological_semiring R
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {x : E} (hf : has_fderiv_at f f' x) (v : E) {Î± : Type u_4} {c : Î± â†’ ğ•œ} {l : filter Î±} (hc : filter.tendsto (Î» (n : Î±), âˆ¥c nâˆ¥) l filter.at_top) : filter.tendsto (Î» (n : Î±), c n â€¢ (f (x + (c n)â»Â¹ â€¢ v) - f x)) l (nhds (â‡‘f' v))
{I : Type u} {f : I â†’ Type vâ‚} [decidable_eq I] [Î  (i : I), has_one (f i)] (i : I) (x : f i) (i_1 : I) : f i_1
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hf : differentiable_on â„ f s) (hs : â‡‘Î¼ s = 0) : â‡‘Î¼ (f '' s) = 0
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} [measure_theory.is_probability_measure Î¼] (hs : convex â„ s) (hsc : is_closed s) (hf : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) : âˆ« (x : Î±), f x âˆ‚Î¼ âˆˆ s
{Î¹ : Type u_1} {Ïƒ : Type u_2} {R : Type u_4} [decidable_eq Î¹] [add_monoid Î¹] [semiring R] [set_like Ïƒ R] [add_submonoid_class Ïƒ R] (A : Î¹ â†’ Ïƒ) [set_like.graded_monoid A] : direct_sum.gsemiring (Î» (i : Î¹), â†¥(A i))
{f : â„ â†’ â„} (hf : differentiable â„ f) {C : â„} (hf'_gt : âˆ€ (x : â„), C < deriv f x) â¦ƒx y : â„â¦„ (hxy : x < y) : C * (y - x) < f y - f x
{ğ•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [normed_group E] [normed_group Fâ‚—] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ Fâ‚—] {r : â„} (r_pos : 0 < r) (c : â„) (f : E â†’â‚—[ğ•œ] Fâ‚—) (h : âˆ€ (z : E), z âˆˆ metric.ball 0 r â†’ âˆ¥â‡‘f zâˆ¥ â‰¤ c) : âˆƒ (C : â„), âˆ€ (z : E), âˆ¥â‡‘f zâˆ¥ â‰¤ C * âˆ¥zâˆ¥
{F : Type u_3} [inner_product_space â„ F] [finite_dimensional â„ F] {n : â„•} (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finite_dimensional.finrank â„ â†¥((continuous_linear_map.id â„ F - â†‘(Ï†.to_continuous_linear_equiv)).ker)á—® â‰¤ n) : âˆƒ (l : list F), l.length â‰¤ n âˆ§ Ï† = (list.map (Î» (v : F), reflection (submodule.span â„ {v})á—®) l).prod
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s : set Î²} {g : Î² â†’ Î±} (hg : set.inj_on g s) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ g '' s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ s), f (g j)))
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X â†’ Y} (h : lipschitz_with K f) (s : set X) : dimH (f '' s) â‰¤ dimH s
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i * g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p âˆˆ s) : vector_span k s = submodule.span k (has_vsub.vsub p '' (s  {p}))
{J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) {W : C} {f f' : W âŸ¶ t.X} (w : âˆ€ (j : J), f â‰« t.Ï€.app j = f' â‰« t.Ï€.app j) : f = f'
{G : Type u_1} [measurable_space G] [has_mul G] (Î¼ : measure_theory.measure G) : Prop
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) (Ï€i : Î  (J : box_integral.box Î¹), box_integral.tagged_prepartition J) : box_integral.tagged_prepartition I
{Î± : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [preorder Î¹] {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] [has_le E] (f : Î¹ â†’ Î± â†’ E) (â„± : measure_theory.filtration Î¹ m0) (Î¼ : measure_theory.measure Î±) : Prop
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) < s.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
{Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] [measurable_space Î³] [borel_space Î³] {Î² : Type u_4} [tÎ² : topological_space Î²] [t2_space Î²] [measurable_space Î²] [borel_space Î²] {s : set Î³} {f : Î³ â†’ Î²} (hs : measurable_set s) (f_cont : continuous_on f s) (f_inj : set.inj_on f s) : measurable_set (f '' s)
(M : Type u_1) (N : Type u_2) (Î¼ : M â†’ N â†’ N) (r : N â†’ N â†’ Prop) : Prop
(s : string := "") (l : list expr) : tactic unit
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {J : ideal R} {I : ideal S} {f : R â†’+* S} {H : J â‰¤ ideal.comap f I} (h : ideal.comap f I â‰¤ J) : function.injective â‡‘(I.quotient_map f H)
{Î± : Type u_1} {Ïƒ : Type u_3} (F : ctop Î± Ïƒ) : topological_space Î±
(h : name) (t : option expr := option.none) (pr : expr) : smt_tactic unit
{L : first_order.language} {Î± : Type u'} {n : â„•} (Ï† Ïˆ : L.bounded_formula Î± n) : L.bounded_formula Î± n
{Î¹ : Type u_6} {Ï€ : Î¹ â†’ Type u_7} [Î  (i : Î¹), preorder (Ï€ i)] (i : Î¹) : (Î  (j : Î¹), Ï€ j) â†’o Ï€ i
{f f' : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f' x â‰¤ B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
{Î± : Sort u_1} {Î² : Sort u_2} {sâ‚ : setoid Î±} {sâ‚‚ : setoid Î²} {Ï† : quotient sâ‚ â†’ quotient sâ‚‚ â†’ Sort u_3} [h : âˆ€ (a : Î±) (b : Î²), subsingleton (Ï† âŸ¦aâŸ§ âŸ¦bâŸ§)] (qâ‚ : quotient sâ‚) (qâ‚‚ : quotient sâ‚‚) (f : Î  (aâ‚ : Î±) (aâ‚‚ : Î²), Ï† (quotient.mk' aâ‚) (quotient.mk' aâ‚‚)) : Ï† qâ‚ qâ‚‚
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â†” Â¬antivary f (g âˆ˜ â‡‘Ïƒ)
(lemmas : list expr) (opt : tactic.apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}) (tac : tactic unit := tactic.skip) : tactic unit
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary f (g âˆ˜ â‡‘Ïƒ)
(h_eqs_names coeffs : list pexpr) (config : linear_combo.linear_combination_config := {normalize := bool.tt, normalization_tactic := has_bind.seq (tactic.save_info {line := 75, column := 41}) (tactic.interactive.ring1 option.none).step}) : tactic unit
{R : Type u_1} [semiring R] {Ï† : power_series R} {n : enat} : Ï†.order = n â†” (âˆ€ (i : â„•), â†‘i = n â†’ â‡‘(power_series.coeff R i) Ï† â‰  0) âˆ§ âˆ€ (i : â„•), â†‘i < n â†’ â‡‘(power_series.coeff R i) Ï† = 0
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_5} [topological_space H] (I : model_with_corners ğ•œ E H) (e : diffeomorph (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') E E' âŠ¤) : model_with_corners ğ•œ E' H
{a b : â„} (n : â„•) : âˆ« (x : â„) in a..b, real.cos x ^ (n + 2) = (real.cos b ^ (n + 1) * real.sin b - real.cos a ^ (n + 1) * real.sin a) / (â†‘n + 2) + (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, real.cos x ^ n
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : basic_smooth_vector_bundle_core I M E
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) â¦ƒf g : M â§¸ N â†’â‚—â…R,Lâ† Mâ¦„ (h : f.comp (lie_submodule.quotient.mk' N) = g.comp (lie_submodule.quotient.mk' N)) : f = g
{n : â„•} {K : Type u_1} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) (hpos : 0 < n) [char_zero K] : polynomial.cyclotomic n â„š = minpoly â„š Î¼
{p : â„•+} {k : â„•} {K : Type u} {L : Type v} {Î¶ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ k} K L] [hp : fact (nat.prime â†‘p)] [ne_zero â†‘â†‘p] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ k)) (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ k) K)) : âˆƒ (u : â„¤Ë£) (n : â„•), algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = â†‘u * â†‘p ^ n
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} [inhabited Î›] {Ïƒ : Type u_4} [inhabited Ïƒ] {C : turing.TM2.stmt Î“ Î› Ïƒ â†’ Sort l} (Hâ‚ : Î  (k : K) (s : turing.TM2to1.st_act k) (q : turing.TM2.stmt Î“ Î› Ïƒ), C q â†’ C (turing.TM2to1.st_run s q)) (Hâ‚‚ : Î  (a : Ïƒ â†’ Ïƒ) (q : turing.TM2.stmt Î“ Î› Ïƒ), C q â†’ C (turing.TM2.stmt.load a q)) (Hâ‚ƒ : Î  (p : Ïƒ â†’ bool) (qâ‚ qâ‚‚ : turing.TM2.stmt Î“ Î› Ïƒ), C qâ‚ â†’ C qâ‚‚ â†’ C (turing.TM2.stmt.branch p qâ‚ qâ‚‚)) (Hâ‚„ : Î  (l : Ïƒ â†’ Î›), C (turing.TM2.stmt.goto l)) (Hâ‚… : C turing.TM2.stmt.halt) (n : turing.TM2.stmt Î“ Î› Ïƒ) : C n
(opt : tactic.solve_by_elim.opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := Î» (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (Î» (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}) : tactic unit
(Î± : Type u_1) (Î² : Î± â†’ Type u_2) (Î³ : Î  (a : Î±), Î² a â†’ Type u_3) [Î  (x : Î±) (y : Î² x), preorder (Î³ x y)] : (Î  (a : Î±) (b : Î² a), Î³ a b) â†’o Î  (x : Î£ (a : Î±), Î² a), Î³ x.fst x.snd
(Î± : Type u) (Î² : Type v) [add_group Î±] [add_action Î± Î²] {Ï† : quotient (add_action.orbit_rel Î± Î²) â†’ Î²} (hÏ† : function.left_inverse quotient.mk' Ï†) : Î² â‰ƒ Î£ (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), Î± â§¸ add_action.stabilizer Î± (Ï† Ï‰)
{C : Type u} [category_theory.category C] [category_theory.limits.has_strict_initial_objects C] {I : C} (X : C) [category_theory.limits.has_binary_product I X] (hI : category_theory.limits.is_initial I) : I â¨¯ X â‰… I
{k : Type u_1} {G : Type u_2} {V : Type u_3} {W : Type u_4} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] [add_comm_monoid W] [module k W] (ÏV : representation k G V) (ÏW : representation k G W) : representation k G (V â†’â‚—[k] W)
{Î± : Type u_1} {Î¹ : Type u_2} {L : filter Î¹} [measurable_space Î±] [pseudo_emetric_space Î±] [opens_measurable_space Î±] {Î¼ : measure_theory.finite_measure Î±} {Î¼s : Î¹ â†’ measure_theory.finite_measure Î±} (Î¼s_lim : filter.tendsto Î¼s L (nhds Î¼)) {F : set Î±} (F_closed : is_closed F) : L.limsup (Î» (i : Î¹), â‡‘â†‘(Î¼s i) F) â‰¤ â‡‘â†‘Î¼ F
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) â¦ƒÎ¹ : Type vâ¦„ (U : Î¹ â†’ topological_space.opens â†¥X) : category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U) â¥¤ category_theory.limits.cone ((category_theory.pairwise.diagram U).op â‹™ F)
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.faithful F.to_lax_monoidal_functor.to_functor] [category_theory.braided_category D] (Î² : Î  (X Y : C), X âŠ— Y â‰… Y âŠ— X) (w : âˆ€ (X Y : C), F.to_lax_monoidal_functor.Î¼ X Y â‰« F.to_lax_monoidal_functor.to_functor.map (Î² X Y).hom = (Î²_ (F.to_lax_monoidal_functor.to_functor.obj X) (F.to_lax_monoidal_functor.to_functor.obj Y)).hom â‰« F.to_lax_monoidal_functor.Î¼ Y X) : category_theory.braided_category C
{M : Type u_1} [comm_monoid M] {Î¼ : M} {n : â„•+} (h : is_primitive_root Î¼ â†‘n) : â†¥(roots_of_unity n M)
{R : Type u} {M : Type v} {Î¹ : Type x} [semiring R] {Ï† : Î¹ â†’ Type i} [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] [fintype Î¹] [decidable_eq Î¹] [add_comm_monoid M] [module R M] {f g : (Î  (i : Î¹), Ï† i) â†’â‚—[R] M} (h : âˆ€ (i : Î¹), f.comp (linear_map.single i) = g.comp (linear_map.single i)) : f = g
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : measure_theory.ae_strongly_measurable f (Î¼.prod Î½)) : measure_theory.integrable f (Î¼.prod Î½) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼, measure_theory.integrable (Î» (y : Î²), f (x, y)) Î½) âˆ§ measure_theory.integrable (Î» (x : Î±), âˆ« (y : Î²), âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] {Î¼ : Î  (i : Î¹), measure_theory.measure (Î± i)} {C : Î  (i : Î¹), set (set (Î± i))} (hÎ¼ : Î  (i : Î¹), (Î¼ i).finite_spanning_sets_in (C i)) : (measure_theory.measure.pi Î¼).finite_spanning_sets_in (set.univ.pi '' set.univ.pi C)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {s : set Î±} {f : Î± â†’ Î²} (hf : embedding f) : is_compact s â†” is_compact (f '' s)
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} {W : C} {h : W âŸ¶ X} {k : W âŸ¶ Y} {comm : h â‰« f = k â‰« g} (t : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk k h category_theory.limits.pullback_cone.flip_is_limit._proof_1)) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk h k comm)
{F : Type u_3} [inner_product_space â„ F] {K : set F} (h : convex â„ K) {u v : F} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (w : â†¥K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : F), w âˆˆ K â†’ has_inner.inner (u - v) (w - v) â‰¤ 0
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [linear_order Î²] [densely_ordered Î±] [no_min_order Î±] [no_max_order Î±] [nonempty Î±] (b : Î²) (I : order.ideal (order.partial_iso Î± Î²)) : (âˆƒ (f : order.partial_iso Î± Î²), f âˆˆ order.partial_iso.defined_at_right Î± b âˆ§ f âˆˆ I) â†’ {a // âˆƒ (f : {f // âˆ€ (p : Î± Ã— Î²), p âˆˆ f â†’ âˆ€ (q : Î± Ã— Î²), q âˆˆ f â†’ cmp p.fst q.fst = cmp p.snd q.snd}) (H : f âˆˆ I), (a, b) âˆˆ f.val}
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : âˆ«â» (x : E) in s, ennreal.of_real |(f' x).det| âˆ‚Î¼ = â‡‘Î¼ (f '' s)
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] (Î¼ : measure_theory.measure Î±) [Î¼.weakly_regular] (f : Î± â†’ ennreal) (hf : measurable f) {Îµ : ennreal} (Îµpos : Îµ â‰  0) : âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), f x â‰¤ g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), f x âˆ‚Î¼ + Îµ
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_2} {l : filter Î¹} [l.is_countably_generated] {F : Î¹ â†’ Î± â†’ ennreal} {f : Î± â†’ ennreal} (bound : Î± â†’ ennreal) (hF_meas : âˆ€á¶  (n : Î¹) in l, measurable (F n)) (h_bound : âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) (h_fin : âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : Î¹), F n a) l (nhds (f a))) : filter.tendsto (Î» (n : Î¹), âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
{Î¹ : Type u_4} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), normed_ring (Ï€ i)] : normed_ring (Î  (i : Î¹), Ï€ i)
{F : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [add_zero_class Î±] [add_zero_class Î²] [add_monoid_hom_class F Î± Î²] (Ï† : F) : filter Î± â†’+ filter Î²
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) (Ï : measure_theory.measure Î±) (x : Î±) : ennreal
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pushouts C] {W X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) (gâ‚ : X âŸ¶ W) [category_theory.epi gâ‚] (gâ‚‚ : W âŸ¶ Z) [category_theory.mono gâ‚‚] (hg : gâ‚ â‰« gâ‚‚ = g) (f' : W âŸ¶ Y) (hf : gâ‚ â‰« f' = f) (t : category_theory.limits.pushout_cocone f g) (ht : category_theory.limits.is_colimit t) : category_theory.mono t.inl
{V : Type u_1} [inner_product_space â„ V] (x y : V) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - 2 * âˆ¥xâˆ¥ * âˆ¥yâˆ¥ * real.cos (inner_product_geometry.angle x y)
{R : Type u} [comm_ring R] {S : Type v} [comm_ring S] (I : ideal R) (f : R â†’+* S) (H : âˆ€ (a : R), a âˆˆ I â†’ â‡‘f a = 0) : R â§¸ I â†’+* S
{C : Type uâ‚} [category_theory.category C] {J : Type u} [category_theory.category J] {j : J} (I : category_theory.limits.is_initial j) (F : J â¥¤ C) [category_theory.limits.has_limit F] : category_theory.is_iso (category_theory.limits.limit.Ï€ F j)
{L : first_order.language} {L' : first_order.language} {Î± : Type u'} (Ï† : L â†’á´¸ L') : L.term Î± â†’ L'.term Î±
{E : Type u_2} [normed_group E] {Î± : Type u_1} {m : measurable_space Î±} (f : Î± â†’ E) (p : ennreal) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] : (Î£ (i : I), C i) â†’ (Î£ (i : I), C i) â†’ Type (max wâ‚ vâ‚ uâ‚)
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] (M : turing.TM0.machine Î“ Î›) : turing.TM0.cfg Î“ Î› â†’ option (turing.TM0.cfg Î“ Î›)
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : measurable f) (g : Î± â†’ ennreal) : âˆ«â» (a : Î±), f a + g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.regular] : Î¼.inner_regular is_compact (Î» (s : set Î±), measurable_set s âˆ§ â‡‘Î¼ s â‰  âŠ¤)
{Î± : Type u_1} {ğ•œ : Type u_14} [normed_field ğ•œ] {c : â„} {l : filter Î±} {u v : Î± â†’ ğ•œ} (Ï† : Î± â†’ ğ•œ) (hÏ† : âˆ€á¶  (x : Î±) in l, âˆ¥Ï† xâˆ¥ â‰¤ c) (h : u =á¶ [l] Ï† * v) : asymptotics.is_O_with c l u v
(a b : â„) (f : C(â†¥(set.Icc a b), â„)) (Îµ : â„) (pos : 0 < Îµ) : âˆƒ (p : polynomial â„), âˆ¥p.to_continuous_map_on (set.Icc a b) - fâˆ¥ < Îµ
(Îµ : out_param (Type u)) (m : Type v â†’ Type w) : Type (max u (v+1) w)
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : Prop
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] [complete_space ğ•œ] {c : ğ•œ} (hc : 1 < âˆ¥câˆ¥) {R : â„} (hR : âˆ¥câˆ¥ < R) (h : Â¬finite_dimensional ğ•œ E) : âˆƒ (f : â„• â†’ E), (âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ R) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ 1 â‰¤ âˆ¥f m - f nâˆ¥
{M : Type u_1} {Î± : Type u_4} [add_monoid M] {c : add_con M} (u : add_units c.quotient) (f : Î  (x y : M), â‡‘c (x + y) 0 â†’ â‡‘c (y + x) 0 â†’ Î±) (Hf : âˆ€ (x y : M) (hxy : â‡‘c (x + y) 0) (hyx : â‡‘c (y + x) 0) (x' y' : M) (hxy' : â‡‘c (x' + y') 0) (hyx' : â‡‘c (y' + x') 0), â‡‘c x x' â†’ â‡‘c y y' â†’ f x y hxy hyx = f x' y' hxy' hyx') : Î±
{I : Type u} {Î± : Type u_1} {Î² : Type u_2} [monoid Î±] [add_monoid Î²] [distrib_mul_action Î± Î²] [decidable_eq I] (i : I) (r : Î±) (x : Î²) : pi.single i (r â€¢ x) = r â€¢ pi.single i x
(ids : interactive.parse (lean.parser.many interactive.types.ident_)) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (cfg : tactic.simp_intros_config := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}, use_hyps := bool.ff}) : tactic unit
{Î¹ : Type v} {Î± : Î¹ â†’ Type u} {Î´ : Î  (i : Î¹), Î± i â†’ Type w} [Î  (i : Î¹) (j : Î± i), add_comm_monoid (Î´ i j)] : direct_sum Î¹ (Î» (i : Î¹), direct_sum (Î± i) (Î» (j : Î± i), Î´ i j)) â†’+ direct_sum (Î£ (i : Î¹), Î± i) (Î» (i : Î£ (i : Î¹), Î± i), Î´ i.fst i.snd)
{E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] {f : E â†’ F} {z : E} {r : â„} (hd : diff_cont_on_cl â„‚ f (metric.ball z r)) (hz : is_max_on (has_norm.norm âˆ˜ f) (metric.ball z r) z) : set.eq_on (has_norm.norm âˆ˜ f) (function.const E âˆ¥f zâˆ¥) (metric.closed_ball z r)
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] (f : Î± Ã— Î² â†’ ennreal) (hf : ae_measurable f (Î¼.prod Î½)) : âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} {f : G â†’ E} {g : G} [group G] [has_measurable_mul G] [Î¼.is_mul_right_invariant] (hf' : âˆ€ (x : G), f (x * g) = -f x) : âˆ« (x : G), f x âˆ‚Î¼ = 0
{G : Type u_1} {Î± : Type u_2} [group G] [mul_action G Î±] [measurable_space Î±] {s : set Î±} {Î¼ : measure_theory.measure Î±} (h_meas : measure_theory.null_measurable_set s Î¼) (h_exists : âˆ€ (x : Î±), âˆƒ! (g : G), g â€¢ x âˆˆ s) : measure_theory.is_fundamental_domain G s Î¼
{R : Type u_1} [normed_ring R] [complete_space R] (t : R) (h : âˆ¥tâˆ¥ < 1) : RË£
{Î± : Type u} {Ïƒ : Type v} (M : Îµ_NFA Î± Ïƒ) (S : set Ïƒ) : set Ïƒ
{f f' : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : âˆ€ (x : â„), has_deriv_at B (B' x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f x = B x â†’ f' x < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
{Î± : Type u} [lattice Î±] [comm_group Î±] [covariant_class Î± Î± has_mul.mul has_le.le] (a b : Î±) : |a * b| â‰¤ |a| * |b|
{M : Type u_1} [has_add M] (S : set (add_con M)) : has_Sup.Sup S = add_con_gen (Î» (x y : M), âˆƒ (c : add_con M), c âˆˆ S âˆ§ â‡‘c x y)
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic unit
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X â„) {e : X â†’ Y} (he : closed_embedding e) : âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ â‡‘g âˆ˜ e = â‡‘f
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] {f : â†¥(measure_theory.Lp E p Î¼)} : f âˆˆ measure_theory.Lp.bounded_continuous_function E p Î¼ â†” âˆƒ (fâ‚€ : bounded_continuous_function Î± E), continuous_map.to_ae_eq_fun Î¼ fâ‚€.to_continuous_map = â†‘f
{Ïƒ : Type u_1} (R : Type u_2) {A : Type u_3} [comm_semiring R] [add_comm_monoid A] [module R A] [module (mv_polynomial Ïƒ R) A] [is_scalar_tower R (mv_polynomial Ïƒ R) A] (f : Ïƒ â†’ A) : derivation R (mv_polynomial Ïƒ R) A
{A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [is_dedekind_domain A] {I : fractional_ideal (non_zero_divisors A) K} (hne : I â‰  0) : I * Iâ»Â¹ = 1
{Î± : Type u_1} {ğ•œ : Type u_2} [linear_ordered_field ğ•œ] [decidable_eq Î±] {A : finset Î±} (P : finpartition A) (G : simple_graph Î±) [decidable_rel G.adj] (Îµ : ğ•œ) : Prop
{C : Type uâ‚} [category_theory.category C] [category_theory.well_powered C] {A : C} (s : set (category_theory.subobject A)) : category_theory.limits.wide_pullback_shape â†¥(â‡‘(equiv_shrink (category_theory.subobject A)) '' s) â¥¤ C
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {D : Type uâ‚‚} [category_theory.category D] {qâ‚ qâ‚‚ : (Î£ (i : I), C i) â¥¤ D} (h : Î  (i : I), category_theory.sigma.incl i â‹™ qâ‚ â‰… category_theory.sigma.incl i â‹™ qâ‚‚) : qâ‚ â‰… qâ‚‚
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {S T : set (set Î±)} (h_gen : m0 = measurable_space.generate_from S) (h_inter : is_pi_system S) (h_sub : T âŠ† S) (hc : T.countable) (hU : â‹ƒâ‚€T = set.univ) (htop : âˆ€ (s : set Î±), s âˆˆ T â†’ â‡‘Î¼ s â‰  âŠ¤) (h_eq : âˆ€ (s : set Î±), s âˆˆ S â†’ â‡‘Î¼ s = â‡‘Î½ s) : Î¼ = Î½
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {s : set E} (hs : convex â„ s) : â‡‘Î¼ (frontier s) = 0
{Ïƒ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [add_comm_monoid A] [module R A] [module (mv_polynomial Ïƒ R) A] {Dâ‚ Dâ‚‚ : derivation R (mv_polynomial Ïƒ R) A} {s : set Ïƒ} (h : set.eq_on (â‡‘Dâ‚ âˆ˜ mv_polynomial.X) (â‡‘Dâ‚‚ âˆ˜ mv_polynomial.X) s) {f : mv_polynomial Ïƒ R} (hf : f âˆˆ mv_polynomial.supported R s) : â‡‘Dâ‚ f = â‡‘Dâ‚‚ f
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {s : set Î±} (H : is_preconnected s) (f : Î± â†’ Î²) (hf : continuous_on f s) : is_preconnected (f '' s)
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} (f : Î± â‰ƒáµ Î²) (s : set Î²) : â‡‘(measure_theory.measure.map â‡‘f Î¼) s = â‡‘Î¼ (â‡‘f â»Â¹' s)
(n : name) (msg : string := "") : tactic unit
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {Î¼ : measure_theory.measure â„} {E : Type u_2} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {H : Type u_3} [normed_group H] [normed_space ğ•œ H] {a b Îµ : â„} {bound : â„ â†’ â„} {F : H â†’ â„ â†’ E} {F' : H â†’ â„ â†’ (H â†’L[ğ•œ] E)} {xâ‚€ : H} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : H) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F xâ‚€) Î¼ a b) (hF'_meas : measure_theory.ae_strongly_measurable (F' xâ‚€) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ âˆ¥F' x tâˆ¥ â‰¤ bound t) (bound_integrable : interval_integrable bound Î¼ a b) (h_diff : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ has_fderiv_at (Î» (x : H), F x t) (F' x t) x) : has_fderiv_at (Î» (x : H), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' xâ‚€ t âˆ‚Î¼) xâ‚€
{Î± : Type u_1} (s : set Î±) [conditionally_complete_linear_order Î±] [inhabited â†¥s] (h_Sup : âˆ€ {t : set â†¥s}, t.nonempty â†’ bdd_above t â†’ has_Sup.Sup (coe '' t) âˆˆ s) (h_Inf : âˆ€ {t : set â†¥s}, t.nonempty â†’ bdd_below t â†’ has_Inf.Inf (coe '' t) âˆˆ s) : conditionally_complete_linear_order â†¥s
{E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {Ï† : E â†’ â„} {xâ‚€ : E} {Ï†' : E â†’L[â„] â„} {f : E â†’ â„} {f' : E â†’L[â„] â„} (hextr : is_local_extr_on Ï† {x : E | f x = f xâ‚€} xâ‚€) (hf' : has_strict_fderiv_at f f' xâ‚€) (hÏ†' : has_strict_fderiv_at Ï† Ï†' xâ‚€) : âˆƒ (a b : â„), (a, b) â‰  0 âˆ§ a â€¢ f' + b â€¢ Ï†' = 0
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] [normed_group F] [normed_space â„ F] [complete_space F] {f : E â†’ F} {Ï† : E â†’ â„} {xâ‚€ : E} {f' : E â†’L[â„] F} {Ï†' : E â†’L[â„] â„} (hextr : is_local_extr_on Ï† {x : E | f x = f xâ‚€} xâ‚€) (hf' : has_strict_fderiv_at f f' xâ‚€) (hÏ†' : has_strict_fderiv_at Ï† Ï†' xâ‚€) : (f'.prod Ï†').range â‰  âŠ¤
{Î± : Type u} {Ïƒ : Type v} (M : Îµ_NFA Î± Ïƒ) : list Î± â†’ set Ïƒ
{p : â„•+} {k : â„•} {K : Type u} {L : Type v} {Î¶ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : fact (nat.prime â†‘p)] [ne_zero â†‘â†‘p] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (hk : p ^ (k + 1) â‰  2) : algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p ^ (k + 1)).totient / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (Î½ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] [measure_theory.sigma_finite Î½] (P : Î± â†’ Prop) (h : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ â‡‘Î½ s < âŠ¤ â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, P x)) : âˆ€áµ (x : Î±) âˆ‚Î¼, P x
{Mâ‚ : Type u_1} {Mâ‚‚ : Type u_2} {R : Type u_4} {S : Type u_5} [topological_space Mâ‚‚] [t2_space Mâ‚‚] [semiring R] [semiring S] [add_comm_monoid Mâ‚] [add_comm_monoid Mâ‚‚] [module R Mâ‚] [module S Mâ‚‚] [has_continuous_const_smul S Mâ‚‚] [has_continuous_add Mâ‚‚] {Ïƒ : R â†’+* S} (f : Mâ‚ â†’ Mâ‚‚) (hf : f âˆˆ closure (set.range coe_fn)) : Mâ‚ â†’â‚›â‚—[Ïƒ] Mâ‚‚
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [Î“.normal] [Î¼.is_mul_left_invariant] [Î¼.is_mul_right_invariant] : (measure_theory.measure.map â‡‘(quotient_group.mk' Î“) (Î¼.restrict ğ“•)).is_mul_left_invariant
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {hm : m â‰¤ m0} [measure_theory.sigma_finite (Î¼.trim hm)] {s : set Î±} (f : â†¥(measure_theory.Lp F' 1 Î¼)) (hs : measurable_set s) : âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L1_clm hm Î¼) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
 : expr â†’ (tactic.transparency := tactic.transparency.semireducible) â†’ (bool := bool.tt) â†’ tactic expr
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] {E : set G} [has_measurable_inv G] [Î¼.is_mul_left_invariant] [Î½.is_mul_left_invariant] (Em : measurable_set E) (f : G â†’ ennreal) (hf : measurable f) : â‡‘Î¼ E * âˆ«â» (y : G), f y âˆ‚Î½ = âˆ«â» (x : G), â‡‘Î½ ((Î» (z : G), z * x) â»Â¹' E) * f xâ»Â¹ âˆ‚Î¼
{Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), semi_normed_group (Ï€ i)] {r : â„} (hr : 0 < r) {x : Î  (i : Î¹), Ï€ i} : âˆ¥xâˆ¥ < r â†” âˆ€ (i : Î¹), âˆ¥x iâˆ¥ < r
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {f : Î± â†’ Î²} : uniform_embedding f â†’ ((âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ {a b : Î±}, has_dist.dist a b < Î´ â†’ has_dist.dist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : â„), Î´ > 0 â†’ (âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ {a b : Î±}, has_dist.dist (f a) (f b) < Îµ â†’ has_dist.dist a b < Î´))
{X : Type u_1} [pseudo_emetric_space X] [sigma_compact_space X] [measurable_space X] [borel_space X] (Î¼ : measure_theory.measure X) [measure_theory.is_locally_finite_measure Î¼] : Î¼.weakly_regular
{n : â„•} (P : mvpfunctor (n + 1)) {Î± : typevec n} {C : Type u_2} (g : Î  (a : P.A) (f : P.last.B a â†’ P.last.W), typevec.arrow (P.W_path (W_type.mk a f)) Î± â†’ (P.last.B a â†’ C) â†’ C) (x : P.last.W) (f' : typevec.arrow (P.W_path x) Î±) : C
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] (I : lie_ideal R L) : lie_algebra.is_solvable R â†¥I â†” I â‰¤ lie_algebra.radical R L
(Î± : Type u_1) (F : Type u_4) [measurable_space Î±] (ğ•œ : Type u_5) [normed_field ğ•œ] [normed_group F] [normed_space ğ•œ F] (Î¼ : measure_theory.measure Î±) (p : ennreal) [hp : fact (1 â‰¤ p)] (s : set Î±) : â†¥(measure_theory.Lp F p Î¼) â†’L[ğ•œ] â†¥(measure_theory.Lp F p (Î¼.restrict s))
{Ïƒ : Type u_1} {R : Type u_2} [semiring R] {Ï† Ïˆ : mv_power_series Ïƒ R} : Ï† = Ïˆ â†” âˆ€ (n : Ïƒ â†’â‚€ â„•), â‡‘(mv_power_series.coeff R n) Ï† = â‡‘(mv_power_series.coeff R n) Ïˆ
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) : âˆ‘' (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2 â‰¤ âˆ¥xâˆ¥ ^ 2
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] [h : is_noetherian R M] (f : module.End R M) (Î¼ : R) : f.maximal_generalized_eigenspace Î¼ = â‡‘(f.generalized_eigenspace Î¼) (f.maximal_generalized_eigenspace_index Î¼)
{Î· : Type u_5} {f : Î· â†’ Type u_6} [Î  (i : Î·), group (f i)] (I : set Î·) (H : Î  (i : Î·), subgroup (f i)) : subgroup (Î  (i : Î·), f i)
{Î± : Type u_1} (F : Type u_6) (p : ennreal) [normed_group F] {m m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [hp : fact (1 â‰¤ p)] (hm : m â‰¤ m0) : â†¥(measure_theory.Lp_meas_subgroup F m p Î¼) â‰ƒáµ¢ â†¥(measure_theory.Lp F p (Î¼.trim hm))
{V : Type u_1} [inner_product_space â„ V] (x y : V) (h : inner_product_geometry.angle x y = real.pi / 2) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{R : Type u_1} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (hpos : 0 < n) (h : is_primitive_root Î¶ n) : polynomial.X ^ n - 1 = (polynomial.nth_roots_finset n R).prod (Î» (Î¶ : R), polynomial.X - â‡‘polynomial.C Î¶)
{F : Type u_3} [inner_product_space â„ F] {x y : F} (h : has_inner.inner x y = 0) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
(h : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic congr_lemma
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {x : M} {n : â„•} : cont_mdiff_at I I' â†‘n f x â†” âˆƒ (u : set M) (H_1 : u âˆˆ nhds x), cont_mdiff_on I I' â†‘n f u
{Î± : Type u} {L : list (Î± Ã— bool)} {x : Î±} {b : bool} : free_group.red ((x, b) :: L) list.nil â†” free_group.red L [(x, !b)]
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) : Type (max (max u_1 u_2 u_3) u_3)
{G : Type u_1} [measurable_space G] [has_neg G] (Î¼ : measure_theory.measure G) : Prop
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [t2_space Î±] [Î¼.regular] : Î¼.weakly_regular
{Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î² : Type u_2} [measurable_space Î²] {X Y : Î± â†’ Î²} [normed_division_ring Î²] [borel_space Î²] (hXY : probability_theory.indep_fun X Y Î¼) (hX : measure_theory.integrable X Î¼) (hY : measure_theory.integrable Y Î¼) : measure_theory.integrable (X * Y) Î¼
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {f : Î± â†’ Î²} [has_zero Î²] [t2_space Î²] (hf : measure_theory.ae_fin_strongly_measurable f Î¼) : set Î±
{X : â„• â†’ Type u} [Î  (n : â„•), metric_space (X n)] {f : Î  (n : â„•), X n â†’ X (n + 1)} (I : âˆ€ (n : â„•), isometry (f n)) : Type u
{Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {i j : set Î±} (hi : measurable_set i) (hj : measurable_set j) (hi' : 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i âˆ§ measure_theory.vector_measure.restrict s iá¶œ â‰¤ 0.restrict iá¶œ) (hj' : 0.restrict j â‰¤ measure_theory.vector_measure.restrict s j âˆ§ measure_theory.vector_measure.restrict s já¶œ â‰¤ 0.restrict já¶œ) : â‡‘s (i âˆ† j) = 0 âˆ§ â‡‘s (iá¶œ âˆ† já¶œ) = 0
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (x : M) (f : M â†’ M') : E â†’ E'
{X : Type u_2} [emetric_space X] (Î¼ : measure_theory.outer_measure X) : Prop
(R : Type u) {Î¹ : Type u'} (Mâ‚ : Î¹ â†’ Type vâ‚) (Mâ‚‚ : Type vâ‚‚) [decidable_eq Î¹] [comm_semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] {Î¹' : Type u_1} [decidable_eq Î¹'] (Ïƒ : Î¹ â‰ƒ Î¹') : multilinear_map R Mâ‚ Mâ‚‚ â‰ƒâ‚—[R] multilinear_map R (Î» (i : Î¹'), Mâ‚ (â‡‘(Ïƒ.symm) i)) Mâ‚‚
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (ğ•œ : Type u_3) [field ğ•œ] [is_alg_closed ğ•œ] [category_theory.linear ğ•œ C] {X : C} (is_iso_iff_nonzero : âˆ€ (f : X âŸ¶ X), category_theory.is_iso f â†” f â‰  0) [I : finite_dimensional ğ•œ (X âŸ¶ X)] : finite_dimensional.finrank ğ•œ (X âŸ¶ X) = 1
{Î± : Type uu} [monoid Î±] {lâ‚ lâ‚‚ : list Î±} (h : lâ‚ ~ lâ‚‚) (hc : list.pairwise (Î» (x y : Î±), x * y = y * x) lâ‚) : lâ‚.prod = lâ‚‚.prod
{L : first_order.language} {M : Type w} [L.Structure M] {L' : first_order.language} [L'.Structure M] (Ï† : L â†’á´¸ L') [Ï†.is_expansion_on M] : L'.substructure M â†ªo L.substructure M
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (hl : l.bRiemann = bool.ff) (B : box_integral.box_additive_map Î¹ â„ â†‘I) (hB0 : âˆ€ (J : box_integral.box Î¹), 0 â‰¤ â‡‘B J) (g : box_integral.box_additive_map Î¹ F â†‘I) (s : set (Î¹ â†’ â„)) (hs : s.countable) (hlH : s.nonempty â†’ l.bHenstock = bool.tt) (Hâ‚ : âˆ€ (c : nnreal) (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I âˆ© s â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ â‡‘box_integral.box.Icc J âŠ† metric.closed_ball x Î´ â†’ x âˆˆ â‡‘box_integral.box.Icc J â†’ (â†¥(l.bDistortion) â†’ J.distortion â‰¤ c) â†’ has_dist.dist (â‡‘(â‡‘vol J) (f x)) (â‡‘g J) â‰¤ Îµ)) (Hâ‚‚ : âˆ€ (c : nnreal) (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I  s â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ â‡‘box_integral.box.Icc J âŠ† metric.closed_ball x Î´ â†’ (â†¥(l.bHenstock) â†’ x âˆˆ â‡‘box_integral.box.Icc J) â†’ (â†¥(l.bDistortion) â†’ J.distortion â‰¤ c) â†’ has_dist.dist (â‡‘(â‡‘vol J) (f x)) (â‡‘g J) â‰¤ Îµ * â‡‘B J)) : box_integral.has_integral I l f vol (â‡‘g I)
{Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) (f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’ G j) : Prop
{Î± : Type u_1} {Ïƒ : Type u_2} [has_zero Î±] [linear_order Î±] [is_well_order Î± has_lt.lt] [fintype Ïƒ] (S : set (Ïƒ â†’â‚€ Î±)) : S.is_pwo
{R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [ring R] [add_comm_group M] [module R M] {Ï† : Î¹ â†’ Type u_4} (b : Î  (i : Î¹), basis (Ï† i) R M) : basis (Î£ (i : Î¹), Ï† i) R (Î¹ â†’â‚€ M)
{G : Type u} [add_group G] {H : Type v} [add_group H] (Ï† : G â†’+ H) (hÏ† : function.surjective â‡‘Ï†) : G â§¸ Ï†.ker â‰ƒ+ H
{p : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero â†‘â†‘p] [hpri : fact (nat.prime â†‘p)] [hcyc : is_cyclotomic_extension {p} K L] (hÎ¶ : is_primitive_root Î¶ â†‘p) (hirr : irreducible (polynomial.cyclotomic â†‘p K)) (h : p â‰  2) : â‡‘(algebra.norm K) (Î¶ - 1) = â†‘p
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} [normed_group Î²] {m : measurable_space Î±} (f : Î¹ â†’ Î± â†’ Î²) (p : ennreal) (Î¼ : measure_theory.measure Î±) : Prop
{Î¹ : Type u_1} [fintype Î¹] (l : box_integral.integration_params) (I : box_integral.box Î¹) (c : nnreal) (Ï€â‚€ : box_integral.prepartition I) : filter (box_integral.tagged_prepartition I)
(p : â„•) [fact (nat.prime p)] {R : Type uâ‚} [comm_semiring R] [char_p R p] {P : Type uâ‚ƒ} [comm_semiring P] [char_p P p] [perfect_ring P p] {S : Type uâ‚‚} [comm_semiring S] [char_p S p] {Q : Type uâ‚„} [comm_semiring Q] [char_p Q p] [perfect_ring Q p] {Ï€ : P â†’+* R} (m : perfection_map p Ï€) {Ïƒ : Q â†’+* S} (n : perfection_map p Ïƒ) (Ï† : R â†’+* S) : P â†’+* Q
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] [complete_space E] {T : E â†’L[ğ•œ] E} (hT : inner_product_space.is_self_adjoint â†‘T) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0) (hextr : is_max_on T.re_apply_inner_self (metric.sphere 0 âˆ¥xâ‚€âˆ¥) xâ‚€) : module.End.has_eigenvector â†‘T (â†‘â¨† (x : {x // x â‰  0}), (Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) â†‘x) xâ‚€
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) : turing.TM1.cfg Î“ Î› Ïƒ â†’ turing.TM0.cfg Î“ (turing.TM1to0.Î›' M)
{Ïƒ : Type u_1} (f : Ïƒ â†’ option Ïƒ) (a b : Ïƒ) : Prop
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F : C â¥¤ D} {G_obj : D â†’ C} (e : Î  (X : C) (Y : D), (F.obj X âŸ¶ Y) â‰ƒ (X âŸ¶ G_obj Y)) (he : âˆ€ (X' X : C) (Y : D) (f : X' âŸ¶ X) (g : F.obj X âŸ¶ Y), â‡‘(e X' Y) (F.map f â‰« g) = f â‰« â‡‘(e X Y) g) : F âŠ£ category_theory.adjunction.right_adjoint_of_equiv e he
{c : Type u â†’ Type u} (hom : Î  {Î± Î² : Type u}, c Î± â†’ c Î² â†’ (Î± â†’ Î²) â†’ Prop) : Type
{Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] [topological_space Î²] {f : Î² â†’ Î±} {K : set Î²} (hK : is_compact K) (hf : continuous_on f K) : bdd_above (f '' K)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (I : category_theory.InjectiveResolution X) (J : category_theory.InjectiveResolution Y) (K : category_theory.InjectiveResolution Z) : homotopy (category_theory.InjectiveResolution.desc (f â‰« g) K I) (category_theory.InjectiveResolution.desc f J I â‰« category_theory.InjectiveResolution.desc g K J)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T âˆˆ dist_triang C) : T.inv_rotate âˆˆ dist_triang C
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' â†’ M''} (hg : cont_mdiff I' I'' n g) (hf : cont_mdiff I I' n f) : cont_mdiff I I'' n (g âˆ˜ f)
{R : Type u} [ring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) : Type (max v w)
{R : Type u_1} [semiring R] (Ï† Ïˆ : power_series R) : Ï†.order + Ïˆ.order â‰¤ (Ï† * Ïˆ).order
{B : Type uâ‚} [category_theory.bicategory B] {C : Type uâ‚‚} [category_theory.bicategory C] {F G H I : category_theory.oplax_functor B C} (Î· : F âŸ¶ G) (Î¸ : G âŸ¶ H) (Î¹ : H âŸ¶ I) : (Î· â‰« Î¸) â‰« Î¹ â‰… Î· â‰« Î¸ â‰« Î¹
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {hm : m â‰¤ m0} [measure_theory.sigma_finite (Î¼.trim hm)] {f : Î± â†’ F'} {s : set Î±} (hf : measure_theory.integrable f Î¼) (hs : measurable_set s) : âˆ« (x : Î±) in s, â‡‘(measure_theory.condexp_L1 hm Î¼ f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â‰ƒg G') (v : V) : â†¥(G.neighbor_set v) â‰ƒ â†¥(G'.neighbor_set (â‡‘f v))
{V : Type u} [fintype V] [decidable_eq V] {G : simple_graph V} [decidable_rel G.adj] {n k â„“ Î¼ : â„•} (h : G.is_SRG_with n k â„“ Î¼) : Gá¶œ.is_SRG_with n (n - k - 1) (n - (2 * k - Î¼) - 2) (n - (2 * k - â„“))
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] {f : â„• â†’ Î± â†’ Î²} (hf : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (f n) Î¼) (h_ae_tendsto : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆƒ (l : Î²), filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds l)) : âˆƒ (f_lim : Î± â†’ Î²) (hf_lim_meas : measure_theory.strongly_measurable f_lim), âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (f_lim x))
{R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (I : ideal R) : submodule R S
{E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} (hf : âˆ€ (x : E), x âˆˆ s â†’ differentiable_at ğ•œ f x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv ğ•œ f xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{ğ•œ : Type u_1} {A : Type u_2} [normed_field ğ•œ] [normed_ring A] [normed_algebra ğ•œ A] [complete_space A] [norm_one_class A] (Ï† : A â†’â‚[ğ•œ] ğ•œ) : A â†’L[ğ•œ] ğ•œ
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t u : set Î±} (hs : measurable_set s) (h : â‡‘Î¼ t = â‡‘Î¼ u) (htu : t âŠ† u) (ht_ne_top : â‡‘Î¼ t â‰  âŠ¤) : â‡‘Î¼ (t âˆ© s) = â‡‘Î¼ (u âˆ© s)
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î¹ : Type u_2} {L : filter Î¹} [L.is_countably_generated] {Î¼ : measure_theory.finite_measure Î±} {fs : Î¹ â†’ bounded_continuous_function Î± nnreal} {c : nnreal} (fs_le_const : âˆ€á¶  (i : Î¹) in L, âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, â‡‘(fs i) a â‰¤ c) {f : bounded_continuous_function Î± nnreal} (fs_lim : âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, filter.tendsto (Î» (i : Î¹), â‡‘(fs i) a) L (nhds (â‡‘f a))) : filter.tendsto (Î» (i : Î¹), Î¼.test_against_nn (fs i)) L (nhds (Î¼.test_against_nn f))
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) â¦ƒÎ¹ : Type vâ¦„ (U : Î¹ â†’ topological_space.opens â†¥X) (Q : category_theory.limits.is_limit (category_theory.functor.map_cone F (category_theory.pairwise.cocone U).op)) : category_theory.limits.is_limit (Top.presheaf.sheaf_condition_equalizer_products.fork F U)
{Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (h : âˆ€ (a : Î±), â‡‘Î¼ (set.Ici a) = â‡‘Î½ (set.Ici a)) : Î¼ = Î½
{R : Type u} [semiring R] {M : polynomial R â†’ Sort u_1} (p : polynomial R) : M 0 â†’ (Î  (p : polynomial R) (a : R), p.coeff 0 = 0 â†’ a â‰  0 â†’ M p â†’ M (p + â‡‘polynomial.C a)) â†’ (Î  (p : polynomial R), p â‰  0 â†’ M p â†’ M (p * polynomial.X)) â†’ M p
{L : first_order.language} {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) {Î± : Type u_3} (x : Î± â†’ (Î£ (i : Î¹), G i)) (i : Î¹) (h : i âˆˆ upper_bounds (set.range (sigma.fst âˆ˜ x))) (a : Î±) : G i
{M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] â¦ƒf g : M â†’*â‚€ Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) {W X Y Z : C} {h : X âŸ¶ Z} {k : Y âŸ¶ Z} {f : W âŸ¶ X} {g : W âŸ¶ Y} (comm : f â‰« h = g â‰« k) [category_theory.limits.reflects_colimit (category_theory.limits.span f g) G] (l : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (G.map h) (G.map k) _)) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk h k comm)
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î²] (p : Î² â†’ Prop) (f : Î± â†’â‚˜[Î¼] Î²) : Prop
{ğ•œ : Type u_1} {E : Type u_4} [normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [nontrivial E] : âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ = 1
{W X Y Z S T : Top} (fâ‚ : W âŸ¶ S) (fâ‚‚ : X âŸ¶ S) (gâ‚ : Y âŸ¶ T) (gâ‚‚ : Z âŸ¶ T) {iâ‚ : W âŸ¶ Y} {iâ‚‚ : X âŸ¶ Z} (Hâ‚ : open_embedding â‡‘iâ‚) (Hâ‚‚ : open_embedding â‡‘iâ‚‚) (iâ‚ƒ : S âŸ¶ T) [Hâ‚ƒ : category_theory.mono iâ‚ƒ] (eqâ‚ : fâ‚ â‰« iâ‚ƒ = iâ‚ â‰« gâ‚) (eqâ‚‚ : fâ‚‚ â‰« iâ‚ƒ = iâ‚‚ â‰« gâ‚‚) : open_embedding â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚)
{I : Type u} (f : I â†’ Type v) [Î  (i : I), has_mul (f i)] (i : I) : (Î  (i : I), f i) â†’â‚™* f i
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : â„} {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥) â†’ asymptotics.is_O_with c l f g
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f (set.Ioi 0 Ã—â„‚ set.Iio 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Ioi 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz_re : 0 â‰¤ z.re) (hz_im : z.im â‰¤ 0) : âˆ¥f zâˆ¥ â‰¤ C
{I : Type uâ‚} {J : Type uâ‚‚} (e : I â‰ƒ J) : category_theory.discrete I â‰Œ category_theory.discrete J
(e : expr) (cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : tactic (list (name Ã— expr))
(h : interactive.parse (optional lean.parser.ident)) (pat : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) (cases : interactive.parse (optional (lean.parser.tk ":=" *> interactive.types.texpr))) (perms : interactive.parse (optional (lean.parser.tk "using" *> (interactive.types.list_of (lean.parser.many lean.parser.ident) <|> (Î» (x : list name), [x])î€€functor.mapî€ <$> î€‚lean.parser.many lean.parser.ident)))) (discharger : tactic unit := tactic.solve_by_elim <|> tactic.tautology {classical := bool.tt, closer := has_pure.pure ()} <|> (using_smt (smt_tactic.intros >> smt_tactic.solve_goals))) : tactic unit
{Ïƒ : Type u} {m : Type u â†’ Type v} [monad m] [monad_state Ïƒ m] (f : Ïƒ â†’ Ïƒ) : m punit
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_coequalizer f g] {W : C} (k : Y âŸ¶ W) (h : f â‰« k = g â‰« k) : {l // category_theory.limits.coequalizer.Ï€ f g â‰« l = k}
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î²] (f : Î± â†’â‚˜[Î¼] Î²) : Î¼.ae.germ Î²
{n : â„•} (i : fin n) {C : Î  (n : â„•), fin n â†’ Sort u_1} (H0 : Î  (n : â„•), C n.succ 0) (Hs : Î  (n : â„•) (i : fin n), C n i â†’ C n.succ i.succ) : C n i
(Ï‰ : out_param (Type u)) (m : Type u â†’ Type v) : Type (max (u+1) v)
{n : â„•} {R : Type u_1} [comm_ring R] [is_domain R] [char_zero R] {Î¼ : R} (hn : 0 < n) : (polynomial.cyclotomic n R).is_root Î¼ â†” is_primitive_root Î¼ n
{R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring Sâ‚] {f : R â†’+* Sâ‚} {g : Sâ‚ â†’+* R} (hf : function.right_inverse â‡‘f â‡‘g) : function.right_inverse â‡‘(mv_polynomial.map f) â‡‘(mv_polynomial.map g)
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} [encodable Î¹] (Î¼ : Î¹ â†’ measure_theory.outer_measure Î±) (s : set Î±) : âˆƒ (t : set Î±), s âŠ† t âˆ§ measurable_set t âˆ§ âˆ€ (i : Î¹), â‡‘(Î¼ i) t = â‡‘((Î¼ i).trim) s
{Î¹ : Type u} {Î³ : Type w} [dec : decidable_eq Î¹] [add_comm_monoid Î³] (S : Î¹ â†’ add_submonoid Î³) [Î  (i : Î¹) (x : â†¥(S i)), decidable (x â‰  0)] (x : Î³) : x âˆˆ supr S â†” âˆƒ (f : Î â‚€ (i : Î¹), â†¥(S i)), f.sum (Î» (i : Î¹) (xi : â†¥(S i)), â†‘xi) = x
{R : Type u_1} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (h : is_primitive_root Î¶ n) : (polynomial.cyclotomic' n R).nat_degree = n.totient
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î³' : Type u_6} {Î´ : Type u_7} {Îµ : Type u_9} {s : set Î±} {t : set Î²} {u : set Î³} {f : Î± â†’ Î´ â†’ Îµ} {g : Î² â†’ Î³ â†’ Î´} {fâ‚ : Î± â†’ Î² â†’ Î²'} {fâ‚‚ : Î± â†’ Î³ â†’ Î³'} {g' : Î²' â†’ Î³' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), f a (g b c) = g' (fâ‚ a b) (fâ‚‚ a c)) : set.image2 f s (set.image2 g t u) âŠ† set.image2 g' (set.image2 fâ‚ s t) (set.image2 fâ‚‚ s u)
{E : Type u_1} [normed_group E] [measurable_space E] [normed_space â„ E] [finite_dimensional â„ E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (x : E) {r : â„} (hr : 0 â‰¤ r) : â‡‘Î¼ (metric.closed_ball x r) = ennreal.of_real (r ^ finite_dimensional.finrank â„ E) * â‡‘Î¼ (metric.closed_ball 0 1)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type wâ‚} [category_theory.category D] {E : Type wâ‚‚} [category_theory.category E] {F : D â¥¤ E} {G : E â¥¤ D} [Î  (X : C) (S : J.cover X) (P : Cáµ’áµ– â¥¤ D), category_theory.limits.preserves_limit (S.index P).multicospan F] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (adj : G âŠ£ F) : category_theory.Sheaf.compose_and_sheafify J G âŠ£ category_theory.Sheaf_compose J F
{Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] {Ïƒ : Î± â†’ Type u_1} (s : finset Î±) (t : Î  (a : Î±), finset (Ïƒ a)) (f : sigma Ïƒ â†’ Î²) : (s.sigma t).sum (Î» (x : Î£ (i : Î±), Ïƒ i), f x) = s.sum (Î» (a : Î±), (t a).sum (Î» (s : Ïƒ a), f âŸ¨a, sâŸ©))
{Î¹ : Type u_4} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), non_unital_semi_normed_ring (Ï€ i)] : non_unital_semi_normed_ring (Î  (i : Î¹), Ï€ i)
{F : Type u_2} [normed_group F] [normed_space â„ F] {x y : F} (hx : x â‰  0) (hy : y â‰  0) : same_ray â„ x y â†’ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
{R : Type u} {Ïƒ : Type v} [comm_ring R] [is_domain R] : is_domain (mv_polynomial Ïƒ R)
{Î¹ : Type u_1} [fintype Î¹] (l : box_integral.integration_params) (I : box_integral.box Î¹) (c : nnreal) (r : (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)) (Ï€ : box_integral.tagged_prepartition I) : Prop
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M â†’+ N} (h : âˆ€ (y : â†¥S), is_add_unit (â‡‘f â†‘y)) (y : â†¥S) (w z : N) : z = w + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y â†” z + â‡‘f â†‘y = w
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : measure_theory.signed_measure Î±} (t : measure_theory.signed_measure Î±) (f : Î± â†’ â„) (hfi : measure_theory.integrable f Î¼) (htÎ¼ : measure_theory.vector_measure.mutually_singular t Î¼.to_ennreal_vector_measure) (hadd : s = t + Î¼.with_densityáµ¥ f) : f =áµ[Î¼] s.rn_deriv Î¼
{Î² : Type u_2} [topological_space Î²] {Î¹ : Type u_5} {Ïƒ : Î¹ â†’ Type u_6} [Î  (i : Î¹), topological_space (Ïƒ i)] : (Î£ (i : Î¹), Ïƒ i) Ã— Î² â‰ƒâ‚œ Î£ (i : Î¹), Ïƒ i Ã— Î²
{E : Type u_4} [normed_group E] [normed_space â„ E] {b : â„} {f : â„• â†’ â„} {z : â„• â†’ E} (hfa : antitone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) (hzb : âˆ€ (n : â„•), âˆ¥(finset.range n).sum (Î» (i : â„•), z i)âˆ¥ â‰¤ b) : cauchy_seq (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), f i â€¢ z i))
{n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] {p : â„•} [fact (nat.prime p)] (hdiv : Â¬p âˆ£ n) : (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly â„¤ Î¼)).separable
(s : tactic_state) (target_lhs_only : bool := bool.ff) : format
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {Î¼ : measure_theory.measure â„} {E : Type u_2} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {H : Type u_3} [normed_group H] [normed_space ğ•œ H] {a b Îµ : â„} {bound : â„ â†’ â„} {F : H â†’ â„ â†’ E} {F' : â„ â†’ (H â†’L[ğ•œ] E)} {xâ‚€ : H} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : H) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F xâ‚€) Î¼ a b) (hF'_meas : measure_theory.ae_strongly_measurable F' (Î¼.restrict (set.interval_oc a b))) (h_lip : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ lipschitz_on_with (â‡‘real.nnabs (bound t)) (Î» (x : H), F x t) (metric.ball xâ‚€ Îµ)) (bound_integrable : interval_integrable bound Î¼ a b) (h_diff : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ has_fderiv_at (Î» (x : H), F x t) (F' t) xâ‚€) : interval_integrable F' Î¼ a b âˆ§ has_fderiv_at (Î» (x : H), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' t âˆ‚Î¼) xâ‚€
{Ï† : Sort u_1} (d : many_one_degree) (f : set â„• â†’ Ï†) (h : âˆ€ (p q : â„• â†’ Prop), many_one_equiv p q â†’ f p = f q) : Ï†
{R : Type u_1} {S : Type u_6} {M : Type u_9} {Mâ‚ƒ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid Mâ‚ƒ] [module R M] [module S Mâ‚ƒ] {Ïƒ : R â†’+* S} (f : M â†’â‚›â‚—[Ïƒ] Mâ‚ƒ) : M â†’+ Mâ‚ƒ
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) â¦ƒÎ¹ : Type vâ¦„ (U : Î¹ â†’ topological_space.opens â†¥X) : Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_inverse F U â‹™ Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_functor F U â‰… ğŸ­ (category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U))
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {C : set (set Î±)} {D : set (set Î²)} (hÎ¼ : Î¼.finite_spanning_sets_in C) (hÎ½ : Î½.finite_spanning_sets_in D) : (Î¼.prod Î½).finite_spanning_sets_in (set.image2 has_set_prod.prod C D)
{P : â„• â†’ Sort u_1} (hp : Î  (p n : â„•), nat.prime p â†’ 0 < n â†’ P (p ^ n)) (h0 : P 0) (h1 : P 1) (h : Î  (a b : â„•), 1 < a â†’ 1 < b â†’ a.coprime b â†’ P a â†’ P b â†’ P (a * b)) (a : â„•) : P a
{m : Type u_2} {n : Type u_3} [fintype m] [fintype n] {Î± : m â†’ n â†’ Type v} [Î  (i : m) (j : n), add_monoid (Î± i j)] {Î² : m â†’ n â†’ Type w} [Î  (i : m) (j : n), add_monoid (Î² i j)] (f : Î  â¦ƒi : mâ¦„ â¦ƒj : nâ¦„, Î± i j â†’+ Î² i j) : dmatrix m n Î± â†’+ dmatrix m n Î²
{F : Type u_3} [inner_product_space â„ F] {x : F} {r : â„} (hx : x â‰  0) (hr : 0 < r) : has_inner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
{f : â„ â†’ â„} {a b : â„} {Î¼ : measure_theory.measure â„} (hf : 0 â‰¤áµ[Î¼.restrict (set.interval_oc a b)] f) (hfi : interval_integrable f Î¼ a b) : 0 < âˆ« (x : â„) in a..b, f x âˆ‚Î¼ â†” a < b âˆ§ 0 < â‡‘Î¼ (function.support f âˆ© set.Ioc a b)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} (s : category_theory.limits.fork f g) {W : C} {k l : W âŸ¶ s.X} (h : k â‰« s.Î¹ = l â‰« s.Î¹) (j : category_theory.limits.walking_parallel_pair) : k â‰« s.Ï€.app j = l â‰« s.Ï€.app j
{Î¹ : Type u_1} [fintype Î¹] (I : box_integral.box Î¹) : box_integral.prepartition I
{Î± : Type u_1} {Î¹ : Type u_2} [nonempty Î¹] (s : set Î±) (f : Î± â†’ Î¹) : s.pairwise (Î» (x y : Î±), f x = f y) â†” âˆƒ (z : Î¹), âˆ€ (x : Î±), x âˆˆ s â†’ f x = z
{Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (h : âˆ€ (a : Î±), â‡‘Î¼ (set.Iic a) = â‡‘Î½ (set.Iic a)) : Î¼ = Î½
{P : Î  (Î± : Type u_1) [_inst_1 : fintype Î±], Prop} (Î± : Type u_1) [fintype Î±] (hbase : âˆ€ (Î± : Type u_1) [_inst_3 : fintype Î±] [_inst_4 : subsingleton Î±], P Î±) (hstep : âˆ€ (Î± : Type u_1) [_inst_5 : fintype Î±] [_inst_6 : nontrivial Î±], (âˆ€ (Î² : Type u_1) [_inst_7 : fintype Î²], fintype.card Î² < fintype.card Î± â†’ P Î²) â†’ P Î±) : P Î±
{Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} [encodable Î¹] (Î¼ : Î¹ â†’ measure_theory.measure Î±) (s : set Î±) : âˆƒ (t : set Î±), s âŠ† t âˆ§ measurable_set t âˆ§ âˆ€ (i : Î¹), â‡‘(Î¼ i) t = â‡‘(Î¼ i) s
(ğ•œ : Type v) [is_R_or_C ğ•œ] {E : Type u} [normed_group E] [normed_space ğ•œ E] (x : E) (h : x â‰  0) : âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
{Ïƒ : Type u} {F : Type u â†’ Type u} [applicative F] {Î± : Type u_1} {Î² : Type u} (f : Î± â†’ F Î²) : Ïƒ âŠ• Î± â†’ F (Ïƒ âŠ• Î²)
(n : with_top â„•) {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) : closed_under_restriction (cont_diff_groupoid n I)
{n : Type u_4} {Î± : Type v} [decidable_eq n] [has_zero Î±] [has_one Î±] (Ïƒ : n â‰ƒ n) (i j : n) : Ïƒ.to_pequiv.to_matrix i j = 1 (â‡‘Ïƒ i) j
{L : first_order.language} {T : L.Theory} {L' : first_order.language} (Ï† : L â†’á´¸ L') (M : (Ï†.on_Theory T).Model) : T.Model
{X : algebraic_geometry.Scheme} (ğ’° : X.open_cover) {W : algebraic_geometry.Scheme} (f : W âŸ¶ X) : W.open_cover
{I : Type u} [decidable_eq I] {Î² : Type u_1} [has_one Î²] (i : I) (x : Î²) (i' : I) : pi.mul_single i x i' = pi.mul_single i' x i
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : has_inner.inner x y = â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥ â†” â†‘âˆ¥yâˆ¥ â€¢ x = â†‘âˆ¥xâˆ¥ â€¢ y
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{Î¹ : Type u_5} {Ï€ : Î¹ â†’ Type u_6} {X : Type u_1} [Î  (i : Î¹), topological_space (Ï€ i)] (f : Î  (i : Î¹), X â†’ Ï€ i) : inducing (Î» (x : X) (i : Î¹), f i x)
{Î³ : Type v} [has_repr Î³] (var : string) (x : Î³) {p q : Prop} (h : q â†’ p) : slim_check.test_result p â†’ (psum unit (p â†’ q) := psum.inl ()) â†’ slim_check.test_result q
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) : isometry â‡‘f â†” âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ = âˆ¥xâˆ¥
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b C : â„} {f : â„‚ â†’ E} {z : â„‚} (hfd : diff_cont_on_cl â„‚ f (complex.im â»Â¹' set.Ioo a b)) (hB : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.re) filter.at_top âŠ“ filter.principal (complex.im â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.re|))) (hle_a : âˆ€ (z : â„‚), z.im = a â†’ âˆ¥f zâˆ¥ â‰¤ C) (hle_b : âˆ€ (z : â„‚), z.im = b â†’ âˆ¥f zâˆ¥ â‰¤ C) (hza : a â‰¤ z.im) (hzb : z.im â‰¤ b) : âˆ¥f zâˆ¥ â‰¤ C
(I : Type wâ‚) (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] : category_theory.sigma.map C id â‰… ğŸ­ (Î£ (i : I), C i)
{Î± : Type u_1} {p : multiset Î± â†’ Sort u_2} {n : â„•} (H : Î  (tâ‚ : multiset Î±), (Î  {tâ‚‚ : multiset Î±}, â‡‘multiset.card tâ‚‚ â‰¤ n â†’ tâ‚ < tâ‚‚ â†’ p tâ‚‚) â†’ â‡‘multiset.card tâ‚ â‰¤ n â†’ p tâ‚) (s : multiset Î±) : â‡‘multiset.card s â‰¤ n â†’ p s
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] (a : I.L) : category_theory.limits.multiequalizer I âŸ¶ I.left a
{R : Type u_1} [comm_ring R] [is_domain R] [infinite R] {Ïƒ : Type u_2} {p q : mv_polynomial Ïƒ R} (h : âˆ€ (x : Ïƒ â†’ R), â‡‘(mv_polynomial.eval x) p = â‡‘(mv_polynomial.eval x) q) : p = q
{F : Type u_1} [normed_group F] [normed_space â„ F] (f : â„ â†’ F) (L : F) (r Îµ : â„) : set â„
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X â„) (e : C(X, Y)) (he : closed_embedding â‡‘e) : âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ g.comp_continuous e = f
{Î± : Type u} [pseudo_metric_space Î±] (x : Î±) (Îµ : â„) : set Î±
{C : Type u} [category_theory.category C] {A : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] {I : C} (t : category_theory.limits.is_initial I) (f : A âŸ¶ I) : category_theory.is_iso f
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R â†’+* S) (I : ideal S) : ideal R
{C : â„¤ â†’ Sort u} (n : â„¤) (h : Î  (b : bool) (n : â„¤), C (int.bit b n)) : C n
{Î± : Type u_1} [conditionally_complete_linear_order Î±] {s : set Î±} [hs : s.ord_connected] â¦ƒt : set â†¥sâ¦„ (ht : t.nonempty) (h_bdd : bdd_below t) : has_Inf.Inf (coe '' t) âˆˆ s
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.multifork I â¥¤ category_theory.limits.fork I.fst_pi_map I.snd_pi_map
{Ïƒ : Type u_1} {Ï„ : Type u_2} {R : Type u_4} [comm_semiring R] {f : Ïƒ â†’ Ï„} (hf : function.injective f) : mv_polynomial Ï„ R â†’â‚[R] mv_polynomial Ïƒ R
(e : expr) (n : â„•) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr Ã— expr)
{G : Type u_1} {Î± : Type u_2} [add_group G] [add_action G Î±] [measurable_space Î±] {s : set Î±} {Î¼ : measure_theory.measure Î±} (h_meas : measure_theory.null_measurable_set s Î¼) (h_exists : âˆ€ (x : Î±), âˆƒ! (g : G), g +áµ¥ x âˆˆ s) : measure_theory.is_add_fundamental_domain G s Î¼
(Ïƒ : Type u) (R : Type v) [comm_ring R] (m : â„•) : submodule R (mv_polynomial Ïƒ R)
{Î± : Type u_1} {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} [measure_theory.is_finite_measure Â«â„™Â»] {X : Î± â†’ â„} (hX : measurable X) : measure_theory.has_pdf X Â«â„™Â» measure_theory.measure_space.volume â†” (measure_theory.measure.map X Â«â„™Â»).absolutely_continuous measure_theory.measure_space.volume
{R : Type u} [semiring R] (I : ideal (polynomial R)) : submodule R (polynomial R)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M â†’ M') : Prop
{E : Type u_1} [normed_group E] [normed_space â„ E] {f f' : â„ â†’ E} {C : â„} (hf : âˆ€ (x : â„), x âˆˆ set.Icc 0 1 â†’ has_deriv_within_at f (f' x) (set.Icc 0 1) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico 0 1 â†’ âˆ¥f' xâˆ¥ â‰¤ C) : âˆ¥f 1 - f 0âˆ¥ â‰¤ C
{Î¹ : Type u_1} {M : Type u_2} [add_comm_monoid M] [fintype Î¹] (f : box_integral.box Î¹ â†’ M) (Iâ‚€ : with_top (box_integral.box Î¹)) (hf : âˆ€ (I : box_integral.box Î¹), â†‘I â‰¤ Iâ‚€ â†’ âˆ€ {i : Î¹} {x : â„}, x âˆˆ set.Ioo (I.lower i) (I.upper i) â†’ option.elim 0 f (I.split_lower i x) + option.elim 0 f (I.split_upper i x) = f I) : box_integral.box_additive_map Î¹ M Iâ‚€
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {ğ•œâ‚ƒ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [normed_group E] [normed_group F] [normed_group G] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [nondiscrete_normed_field ğ•œâ‚ƒ] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] [normed_space ğ•œâ‚ƒ G] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {Ïƒâ‚‚â‚ƒ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ} {Ïƒâ‚â‚ƒ : ğ•œ â†’+* ğ•œâ‚ƒ} [ring_hom_comp_triple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [ring_hom_isometric Ïƒâ‚â‚‚] (f : F â†’â‚›â‚—áµ¢[Ïƒâ‚‚â‚ƒ] G) {g : E â†’SL[Ïƒâ‚â‚‚] F} : âˆ¥f.to_continuous_linear_map.comp gâˆ¥ = âˆ¥gâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [measurable_space Î±] [measurable_space Î²] {f : Î¹ â†’ Î± â†’ Î²} {Î¼ : measure_theory.measure Î±} (hf : âˆ€ (i : Î¹), ae_measurable (f i) Î¼) (p : Î± â†’ (Î¹ â†’ Î²) â†’ Prop) : Î¹ â†’ Î± â†’ Î²
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (fs : smooth_bump_covering Î¹ I M s) (x : M) (hx : x âˆˆ s) : Î¹
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {A : Type u_2} [semiring A] {f g : mv_polynomial Ïƒ R â†’+* A} (hC : f.comp mv_polynomial.C = g.comp mv_polynomial.C) (hX : âˆ€ (i : Ïƒ), â‡‘f (mv_polynomial.X i) = â‡‘g (mv_polynomial.X i)) : f = g
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} {Ïƒ : Type u_3} [inhabited Î›] [inhabited Ïƒ] (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) (l : list Î“) : part (turing.list_blank Î“)
(t : expr) (cfg : tactic.simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}) (discharger : tactic unit := tactic.failed) (no_defaults : bool := bool.ff) (attr_names : list name := list.nil) (hs : list tactic.simp_arg_type := list.nil) : tactic (expr Ã— expr Ã— name_set)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : tangent_bundle I M â†’ M
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : f =o[l] g â†’ âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_finite_measure Î¼] (hg : convex_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hÎ¼ : Î¼ â‰  0) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : g (â¨ (x : Î±), f x âˆ‚Î¼) â‰¤ â¨ (x : Î±), g (f x) âˆ‚Î¼
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [normed_field ğ•œ] [normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’â‚›â‚—[Ïƒ] F) (C : â„) (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : E â†’SL[Ïƒ] F
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) (G : D â¥¤ C) (Î· : ğŸ­ C â‰… F â‹™ G) (Îµ : G â‹™ F â‰… ğŸ­ D) : C â‰Œ D
(M : Type u_1) (N : Type u_2) (Î¼ : M â†’ N â†’ N) (r : N â†’ N â†’ Prop) : Prop
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [nontrivial R] {m : M} {S : set M} : add_monoid_algebra.of' R M m âˆˆ submodule.span R (add_monoid_algebra.of' R M '' S) â†” m âˆˆ S
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (s : M) (H : s âˆˆ S), âˆ¥m + sâˆ¥ < âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ + Îµ
(t : expr) (cfg : tactic.dsimp_config := {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}) (no_defaults : bool := bool.ff) (attr_names : list name := list.nil) (hs : list tactic.simp_arg_type := list.nil) : tactic expr
{Î± : Type u_1} {Î² : Type u_2} [non_assoc_semiring Î±] [non_assoc_semiring Î²] (f : Î± â†’+* Î²) (I : Type u_3) : (I â†’ Î±) â†’+* I â†’ Î²
{F : Type v} [normed_group F] [normed_space â„‚ F] {c : â„‚} {R C : â„} {f : â„‚ â†’ F} (hR : 0 < R) (hd : diff_cont_on_cl â„‚ f (metric.ball c R)) (hC : âˆ€ (z : â„‚), z âˆˆ metric.sphere c R â†’ âˆ¥f zâˆ¥ â‰¤ C) : âˆ¥deriv f câˆ¥ â‰¤ C / R
{Î± : Type u_1} (F : Type u_6) (p : ennreal) [normed_group F] {m m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp_meas_subgroup F m p Î¼)) : â†¥(measure_theory.Lp F p (Î¼.trim hm))
{n : â„•} {A : Type u} (F : A â†’ typevec n â†’ Type u) [Î  (Î± : A), mvfunctor (F Î±)] [Î  (Î± : A), mvqpf (F Î±)] â¦ƒÎ± : typevec nâ¦„ : (mvqpf.sigma.P F).obj Î± â†’ mvqpf.sigma F Î±
{K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero 2] {k : â„•} (hÎ¶ : is_primitive_root Î¶ (2 ^ k)) (hk : 2 â‰¤ k) [H : is_cyclotomic_extension {2 ^ k} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ k) K)) : â‡‘(algebra.norm K) (Î¶ - 1) = 2
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k m : â„•} (hm : k â‰¤ m) (hk : f.has_generalized_eigenvalue Î¼ k) : f.has_generalized_eigenvalue Î¼ m
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {p : tangent_bundle I M} {q : tangent_bundle I H} (h : q.fst âˆˆ (charted_space.chart_at H p.fst).to_local_equiv.target) : tangent_map I I â‡‘((charted_space.chart_at H p.fst).symm) q = â‡‘((charted_space.chart_at (model_prod H E) p).symm) (â‡‘(equiv.sigma_equiv_prod H E) q)
{Î± : Type u_1} {n : â„•} {p : finset Î± â†’ Sort u_2} (s : finset Î±) (H : Î  (tâ‚ : finset Î±), (Î  {tâ‚‚ : finset Î±}, tâ‚‚.card â‰¤ n â†’ tâ‚ âŠ‚ tâ‚‚ â†’ p tâ‚‚) â†’ tâ‚.card â‰¤ n â†’ p tâ‚) : s.card â‰¤ n â†’ p s
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [preorder Î²] (f : Î± â†’ Î²) (s : set Î±) (hf : strict_mono_on f s) : â†¥s â‰ƒo â†¥(f '' s)
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] : continuous (Î» (f : â†¥(measure_theory.Lp E 1 (Î¼.prod Î½))), âˆ« (x : Î±), âˆ« (y : Î²), â‡‘f (x, y) âˆ‚Î½ âˆ‚Î¼)
(Ïƒ : Type u_1) (R : Type u_2) [comm_semiring R] : subalgebra R (mv_polynomial Ïƒ R)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] (x : M) : cont_mdiff_map I (model_with_corners_self ğ•œ ğ•œ) M ğ•œ âŠ¤ â†’â‚[pointed_smooth_map ğ•œ I M âŠ¤ x] ğ•œ
{Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp F p (Î¼.trim hm))) : measure_theory.mem_â„’p.to_Lp â‡‘f _ âˆˆ measure_theory.Lp_meas_subgroup F m p Î¼
{G : Type w} [topological_space G] (Î¼ : measure_theory.content G) [t2_space G] [S : measurable_space G] [borel_space G] : measure_theory.measure G
(f : â†¥(measure_theory.Lp â„‚ 2 haar_circle)) : âˆ‘' (i : â„¤), âˆ¥â‡‘(â‡‘(fourier_series.repr) f) iâˆ¥ ^ 2 = âˆ« (t : â†¥circle), âˆ¥â‡‘f tâˆ¥ ^ 2 âˆ‚haar_circle
{Î¹ : Type u_1} [fintype Î¹] [decidable_eq Î¹] {M : matrix Î¹ Î¹ â„} (hM : M.det â‰  0) : measure_theory.measure.map â‡‘(â‡‘matrix.to_lin' M) measure_theory.measure_space.volume = ennreal.of_real |(M.det)â»Â¹| â€¢ measure_theory.measure_space.volume
{V : Type u_1} {W : Type u_2} [semi_normed_group V] [semi_normed_group W] (f : normed_group_hom V W) : Prop
{n : â„•} {A : Type u} (F : A â†’ typevec n â†’ Type u) [Î  (Î± : A), mvfunctor (F Î±)] [Î  (Î± : A), mvqpf (F Î±)] â¦ƒÎ± : typevec nâ¦„ : (mvqpf.pi.P F).obj Î± â†’ mvqpf.pi F Î±
(size : â„•) : string â†’ (list string := list.nil) â†’ list string
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [Î¼.is_mul_left_invariant] [Î¼.is_mul_right_invariant] : measure_theory.smul_invariant_measure G (G â§¸ Î“) (measure_theory.measure.map quotient_group.mk (Î¼.restrict ğ“•))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) {Î¹â‚‚ : Type u_5} (sâ‚‚ : finset Î¹â‚‚) {p : Î¹ â†’ P} (hi : âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ p i = p j â†’ i = j) {pâ‚‚ : Î¹â‚‚ â†’ P} (hiâ‚‚ : âˆ€ (i : Î¹â‚‚), i âˆˆ sâ‚‚ â†’ âˆ€ (j : Î¹â‚‚), j âˆˆ sâ‚‚ â†’ pâ‚‚ i = pâ‚‚ j â†’ i = j) (he : p '' â†‘s = pâ‚‚ '' â†‘sâ‚‚) : finset.centroid k s p = finset.centroid k sâ‚‚ pâ‚‚
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' â†’ M''} (hg : cont_mdiff_on I' I'' n g t) (hf : cont_mdiff_on I I' n f s) : cont_mdiff_on I I'' n (g âˆ˜ f) (s âˆ© f â»Â¹' t)
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} [inhabited Î›] {Ïƒ : Type u_4} [inhabited Ïƒ] : turing.TM2.stmt Î“ Î› Ïƒ â†’ finset turing.TM2to1.Î›'
{I : Type u} [decidable_eq I] {Î² : Type u_1} [has_one Î²] (i : I) (x : Î²) (i' : I) : pi.mul_single i x i' = ite (i' = i) x 1
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_noetherian R M] (f : â„• â†’ submodule R M) (h : âˆ€ (n : â„•), disjoint (â‡‘(partial_sups f) n) (f (n + 1))) : âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ f m = âŠ¥
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : â‡‘is_R_or_C.im (has_inner.inner x y) = (âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ * âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ - âˆ¥x + is_R_or_C.I â€¢ yâˆ¥ * âˆ¥x + is_R_or_C.I â€¢ yâˆ¥) / 4
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k : â„•} (hÎ¼ : f.has_generalized_eigenvalue Î¼ k) : f.has_eigenvalue Î¼
(t : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic level
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {f g : Î± â†’ â„} {s : set Î±} [measure_theory.sigma_finite Î¼] (f_int : measure_theory.integrable_on f s Î¼) (g_int : measure_theory.integrable_on g s Î¼) (hs : measurable_set s) (hfg : âˆ€ (x : Î±), x âˆˆ s â†’ f x â‰¤ g x) : â‡‘(Î¼.prod measure_theory.measure_space.volume) (region_between f g s) = ennreal.of_real (âˆ« (y : Î±) in s, (g - f) y âˆ‚Î¼)
{R : Type u} {Sâ‚ : Type v} {Sâ‚‚ : Type w} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring Sâ‚] [comm_semiring Sâ‚‚] [algebra R Sâ‚] [algebra R Sâ‚‚] (f : Sâ‚ â†’â‚[R] Sâ‚‚) : mv_polynomial Ïƒ Sâ‚ â†’â‚[R] mv_polynomial Ïƒ Sâ‚‚
{Î¹ : Type u_1} [fintype Î¹] {p : box_integral.box Î¹ â†’ Prop} (I : box_integral.box Î¹) (H_ind : âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ (âˆ€ (J' : box_integral.box Î¹), J' âˆˆ box_integral.prepartition.split_center J â†’ p J') â†’ p J) (H_nhds : âˆ€ (z : Î¹ â†’ â„), z âˆˆ â‡‘box_integral.box.Icc I â†’ (âˆƒ (U : set (Î¹ â†’ â„)) (H : U âˆˆ nhds_within z (â‡‘box_integral.box.Icc I)), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ âˆ€ (m : â„•), z âˆˆ â‡‘box_integral.box.Icc J â†’ â‡‘box_integral.box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J)) : p I
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_artinian R M] (f : M â†’â‚—[R] M) : âˆƒ (n : â„•), n â‰  0 âˆ§ (f ^ n).ker âŠ” (f ^ n).range = âŠ¤
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {f : â„ â†’ E} {Î¼ : measure_theory.measure â„} {Î¹ : Type u_1} [encodable Î¹] {F : Î¹ â†’ â„ â†’ E} (bound : Î¹ â†’ â„ â†’ â„) (hF_meas : âˆ€ (n : Î¹), measure_theory.ae_strongly_measurable (F n) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€ (n : Î¹), âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ¥F n tâˆ¥ â‰¤ bound n t) (bound_summable : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ summable (Î» (n : Î¹), bound n t)) (bound_integrable : interval_integrable (Î» (t : â„), âˆ‘' (n : Î¹), bound n t) Î¼ a b) (h_lim : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ has_sum (Î» (n : Î¹), F n t) (f t)) : has_sum (Î» (n : Î¹), âˆ« (t : â„) in a..b, F n t âˆ‚Î¼) (âˆ« (t : â„) in a..b, f t âˆ‚Î¼)
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
{Î± : Type u_1} (l : filter Î±) (Îµ : Î± â†’ Type u_2) : Type (max u_1 u_2)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {xâ‚€ : E} (hf : has_fderiv_at f f' xâ‚€) {C : â„} (hCâ‚€ : 0 â‰¤ C) (hlip : âˆ€á¶  (x : E) in nhds xâ‚€, âˆ¥f x - f xâ‚€âˆ¥ â‰¤ C * âˆ¥x - xâ‚€âˆ¥) : âˆ¥f'âˆ¥ â‰¤ C
{J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {c c' : category_theory.limits.cone F} (Ï† : c.X â‰… c'.X) (w : âˆ€ (j : J), c.Ï€.app j = Ï†.hom â‰« c'.Ï€.app j) : c â‰… c'
{Î± : Type u} [preorder Î±] â¦ƒs t : set Î±â¦„ (h : s âŠ† t) : bdd_below t â†’ bdd_below s
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (B : box_integral.box_additive_map Î¹ â„ â†‘I) (hB0 : âˆ€ (J : box_integral.box Î¹), 0 â‰¤ â‡‘B J) (g : box_integral.box_additive_map Î¹ F â†‘I) (H : nnreal â†’ âˆ€ (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ â‡‘box_integral.box.Icc J âŠ† metric.closed_ball x Î´ â†’ has_dist.dist (â‡‘(â‡‘vol J) (f x)) (â‡‘g J) â‰¤ Îµ * â‡‘B J)) : box_integral.has_integral I box_integral.integration_params.McShane f vol (â‡‘g I)
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X â†’ Y} {s : set X} (h : holder_on_with C r f s) (hr : 0 < r) : dimH (f '' s) â‰¤ dimH s / â†‘r
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {S : set (set Î±)} (hc : S.countable) (hs : â‹ƒâ‚€S = set.univ) : (âˆ€ (s : set Î±), s âˆˆ S â†’ Î¼.restrict s = Î½.restrict s) â†’ Î¼ = Î½
{R : Type u} [comm_ring R] (I : ideal R) : R â†’+* R â§¸ I
{Î± : Type u_1} [decidable_eq Î±] {s : finset Î±} {p : Î  (t : finset Î±), t âŠ‚ s â†’ Prop} [Î  (t : finset Î±) (h : t âŠ‚ s), decidable (p t h)] : decidable (âˆ€ (t : finset Î±) (h : t âŠ‚ s), p t h)
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) (Î½ : measure_theory.measure Î±) (hÎ½ : Î½.absolutely_continuous Î¼) : vitali_family Î½
{p : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero â†‘â†‘p] {k : â„•} (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) [hpri : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) {s : â„•} (hs : s â‰¤ k) (hodd : p â‰  2) : â‡‘(algebra.norm K) (Î¶ ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
{R : Type u_1} {V : Type u_2} {W : Type u_3} {P : Type u_4} {Q : Type u_5} [ring R] [add_comm_group V] [module R V] [topological_space P] [add_torsor V P] [add_comm_group W] [module R W] [topological_space Q] [add_torsor W Q] (f : P â†’A[R] Q) : C(P, Q)
{R : Type u} [comm_ring R] (I : ideal R) : I.is_maximal â†” is_field (R â§¸ I)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {m n : with_top â„•} (hf : cont_mdiff_on I I' n f s) (hmn : m + 1 â‰¤ n) (hs : unique_mdiff_on I s) : cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I M â»Â¹' s)
(Mâ‚‚ : Type vâ‚‚) (Mâ‚ƒ : Type vâ‚ƒ) [add_comm_monoid Mâ‚‚] (R' : Type u_1) (A : Type u_2) [semiring R'] [semiring A] [module A Mâ‚‚] [add_comm_monoid Mâ‚ƒ] [module R' Mâ‚ƒ] [module A Mâ‚ƒ] [smul_comm_class A R' Mâ‚ƒ] {Î¹â‚ : Type u_3} {Î¹â‚‚ : Type u_4} [decidable_eq Î¹â‚] [decidable_eq Î¹â‚‚] (Ïƒ : Î¹â‚ â‰ƒ Î¹â‚‚) : multilinear_map A (Î» (i : Î¹â‚), Mâ‚‚) Mâ‚ƒ â‰ƒâ‚—[R'] multilinear_map A (Î» (i : Î¹â‚‚), Mâ‚‚) Mâ‚ƒ
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³} [topological_space Î³] [topological_space.metrizable_space Î³] [opens_measurable_space Î³] [topological_space.second_countable_topology Î³] (h : probability_theory.ident_distrib f g Î¼ Î½) : measure_theory.ae_strongly_measurable f Î¼
{Î± : Type u_1} (E : Type u_2) {m0 : measurable_space Î±} (p : ennreal) (Î¼ : measure_theory.measure Î±) [normed_group E] (ğ•œ : Type u_5) [normed_field ğ•œ] [normed_space ğ•œ E] : submodule ğ•œ (Î± â†’â‚˜[Î¼] E)
{Î± : Type u} {Î² : Type v} {Ï† : ultrafilter Î±} [field Î²] : field (â†‘Ï†.germ Î²)
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] {f : Î± â†’ Î² â†’ ennreal} (hf : measurable (function.uncurry f)) : measurable (Î» (y : Î²), âˆ«â» (x : Î±), f x y âˆ‚Î¼)
(w : widget.component tactic_state empty) (text : string := "(widget)") : tactic unit
{P : pfunctor} {Î± : Type u} (F : Î  {X : Type u}, (Î± â†’ X) â†’ Î± â†’ P.M âŠ• P.obj X) (x : Î±) : P.M
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {W X Y Z : C} [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] [category_theory.monoidal_category.monoidal_coherence X Y] (f : W â‰… X) (g : Y â‰… Z) : W â‰… Z
{C : Type uâ‚} [ğ’ : category_theory.enriched_category (Type v) C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.enriched_category (Type v) D] : category_theory.enriched_functor (Type v) C D â‰ƒ C â¥¤ D
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (Î¼ : measure_theory.measure G) [measure_theory.sigma_finite Î¼] [Î¼.is_mul_left_invariant] (Kâ‚€ : topological_space.positive_compacts G) : Î¼ = â‡‘Î¼ â†‘Kâ‚€ â€¢ measure_theory.measure.haar_measure Kâ‚€
{C : Type u} [category_theory.category C] (L : Î  (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) (X Y Z : C) : (L (L X Y).cone.X Z).cone.X â‰… (L X (L Y Z).cone.X).cone.X
(Î± : Type u) (Î² : Type v) [add_group Î±] [add_action Î± Î²] [fintype Î±] [fintype Î²] [fintype (quotient (add_action.orbit_rel Î± Î²))] [Î  (b : Î²), fintype â†¥(add_action.stabilizer Î± b)] {Ï† : quotient (add_action.orbit_rel Î± Î²) â†’ Î²} (hÏ† : function.left_inverse quotient.mk' Ï†) : fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(add_action.stabilizer Î± (Ï† Ï‰)))
(e : interactive.parse interactive.types.texpr) (cfg : tactic.equiv_rw_cfg := {max_depth := 10}) : tactic.interactive.itactic
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set V} (p : P) (h : submodule.span k (set.range coe) = âŠ¤) : affine_span k ({p} âˆª (Î» (v : V), v +áµ¥ p) '' s) = âŠ¤
{X : â„• â†’ Type u} [Î  (n : â„•), metric_space (X n)] {f : Î  (n : â„•), X n â†’ X (n + 1)} (I : âˆ€ (n : â„•), isometry (f n)) : pseudo_metric_space (Î£ (n : â„•), X n)
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] [nontrivial M] : Â¬0.nondegenerate
{E : Type u_4} {F : Type u_5} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] {f : E â†’ F} {s t : set E} (hf : cont_diff_on â„ 1 f s) (hc : convex â„ s) (ht : t âŠ† s) : dimH (f '' t) â‰¤ dimH t
{R : Type u} [comm_ring R] (I J : ideal R) : (R â§¸ I) â§¸ ideal.map (ideal.quotient.mk I) J â†’+* R â§¸ I âŠ” J
(h : expr) (ns : list name := list.nil) (rec : option name := option.none) (md : tactic.transparency := tactic.transparency.semireducible) : tactic (list (name Ã— list expr Ã— list (name Ã— expr)))
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] {f : Î± â†’ â„} (hfm : measure_theory.strongly_measurable f) (hf : measure_theory.integrable f Î¼) (hf_zero : âˆ€ (s : set Î±), measurable_set s â†’ 0 â‰¤ âˆ« (x : Î±) in s, f x âˆ‚Î¼) : 0 â‰¤áµ[Î¼] f
{ğ•œ : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] : âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ â‰¤ 1
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (s : set M) (x : M) : Prop
(e : expr) (md : tactic.transparency := tactic.transparency.instances) : tactic expr
{Î± : Type u} [pseudo_emetric_space Î±] (E : set Î±) (s : set â„) (hsâ‚€ : s âŠ† set.Ioi 0) (hs : âˆ€ (Îµ : â„), 0 < Îµ â†’ (s âˆ© set.Ioc 0 Îµ).nonempty) : closure E = â‹‚ (Î´ : â„) (H : Î´ âˆˆ s), metric.thickening Î´ E
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] {E : set G} [has_measurable_inv G] [Î¼.is_mul_left_invariant] [Î½.is_mul_left_invariant] (Em : measurable_set E) (h2E : â‡‘Î½ E â‰  0) (h3E : â‡‘Î½ E â‰  âŠ¤) (f : G â†’ ennreal) (hf : measurable f) : â‡‘Î¼ E * âˆ«â» (y : G), f yâ»Â¹ / â‡‘Î½ ((Î» (x : G), x * yâ»Â¹) â»Â¹' E) âˆ‚Î½ = âˆ«â» (x : G), f x âˆ‚Î¼
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} [group G] [has_measurable_mul G] [Î¼.is_mul_right_invariant] (f : G â†’ E) (g : G) : âˆ« (x : G), f (x * g) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
{Î¹ : Type u_10} {R : Type u_11} {Râ‚‚ : Type u_12} {M : Type u_13} {Mâ‚‚ : Type u_14} [semiring R] [semiring Râ‚‚] [add_comm_monoid M] [module R M] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [topological_space M] [topological_space Mâ‚‚] {Ïƒ : R â†’+* Râ‚‚} {f : Î¹ â†’ M} (Ï† : M â†’SL[Ïƒ] Mâ‚‚) (hf : summable f) : summable (Î» (b : Î¹), â‡‘Ï† (f b))
{I : Type u} {f : I â†’ Type v} {Î³ : Type w} [Î  (i : I), non_assoc_semiring (f i)] [non_assoc_semiring Î³] (g : Î  (i : I), Î³ â†’+* f i) : Î³ â†’+* Î  (i : I), f i
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} [discrete_topology â†¥s] {x : Î±} (hx : x âˆˆ s) : âˆƒ (Îµ : â„) (H : Îµ > 0), metric.ball x Îµ âˆ© s = {x}
{Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} [measurable_space E] (f : â†¥(measure_theory.Lp.simple_func E p Î¼)) : measurable â‡‘(measure_theory.Lp.simple_func.to_simple_func f)
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (s : finset Î²) {f : Î± â†’ Î²} (hf : âˆ€ (y : Î²), y âˆˆ s â†’ measurable_set (f â»Â¹' {y})) : s.sum (Î» (b : Î²), â‡‘Î¼ (f â»Â¹' {b})) = â‡‘Î¼ (f â»Â¹' â†‘s)
{Î± : Type u_2} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {t : set Î±} (s : set Î±) (ht : measure_theory.null_measurable_set t Î¼) : â‡‘Î¼ (s âˆ© t) + â‡‘Î¼ (s  t) = â‡‘Î¼ s
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (B : bilin_form K V) (b : B.nondegenerate) (Ïˆ Ï† : V â†’â‚—[K] V) : B.is_adjoint_pair B Ïˆ Ï† â†” Ïˆ = B.left_adjoint_of_nondegenerate b Ï†
{Î± : Type u_1} {s : finset Î±} {Ïƒ : equiv.perm Î±} (hs : {a : Î± | â‡‘Ïƒ a â‰  a} âŠ† â†‘s) : finset.map â†‘Ïƒ s = s
(n : interactive.parse (optional (interactive.with_desc â†‘"n" lean.parser.small_nat))) : interactive.parse (optional (lean.parser.tk "with" *> î€€prod.mkî€prod.mkî€‚î€€functor.mapî€ <$> î€‚lean.parser.many tactic.rintro_patt_parse_hi <*> optional (lean.parser.tk ":" *> lean.parser.small_nat))) â†’ tactic unit
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (BR : ring_filter_basis R) (BM : add_group_filter_basis M) (smul : âˆ€ {U : set M}, U âˆˆ BM â†’ (âˆƒ (V : set R) (H : V âˆˆ BR) (W : set M) (H : W âˆˆ BM), V â€¢ W âŠ† U)) (smul_left : âˆ€ (xâ‚€ : R) {U : set M}, U âˆˆ BM â†’ (âˆƒ (V : set M) (H : V âˆˆ BM), V âŠ† (Î» (x : M), xâ‚€ â€¢ x) â»Â¹' U)) (smul_right : âˆ€ (mâ‚€ : M) {U : set M}, U âˆˆ BM â†’ (âˆƒ (V : set R) (H : V âˆˆ BR), V âŠ† (Î» (x : R), x â€¢ mâ‚€) â»Â¹' U)) : module_filter_basis R M
{Î± : Type uâ‚} {Î² : Type uâ‚‚} {Ï† : Type uâ‚ƒ} : (Î± â†’ Î² â†’ Ï†) â†’ Î± Ã— Î² â†’ Ï†
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ M * âˆ¥xâˆ¥) : âˆ¥fâˆ¥ â‰¤ M
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} {S : J.cover X} {T : Î  (I : S.arrow), J.cover I.Y} (I : (S.bind T).arrow) : C
{Î± : Type u_1} (F : Type u_6) [normed_group F] (m : measurable_space Î±) [measurable_space Î±] (p : ennreal) (Î¼ : measure_theory.measure Î±) : add_subgroup â†¥(measure_theory.Lp F p Î¼)
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â†’g G') (e : â†¥(G.edge_set)) : â†¥(G'.edge_set)
{Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) {s : set Î²} (hs : measurable_set s) : â‡‘(measure_theory.measure.map f Î¼) s = â‡‘Î¼ (f â»Â¹' s)
{E : Type u_3} [has_norm E] [add_comm_group E] [pseudo_metric_space E] (H1 : âˆ€ (x : E), âˆ¥xâˆ¥ = has_dist.dist x 0) (H2 : âˆ€ (x y z : E), has_dist.dist (x + z) (y + z) â‰¤ has_dist.dist x y) : semi_normed_group E
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] {Ïƒ : R â†’+* R} [ring_hom_surjective Ïƒ] {Î¹ : Sort u_2} (f : M â†’â‚›â‚—[Ïƒ] M) {p : Î¹ â†’ submodule R M} (hf : âˆ€ (i : Î¹) (v : M), v âˆˆ p i â†’ â‡‘f v âˆˆ p i) (v : M) (H : v âˆˆ infi p) : â‡‘f v âˆˆ infi p
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {s : set E} {t : set F} {y : F} (ht : y âˆˆ closure t) : â‡‘(linear_map.inl ğ•œ E F) '' tangent_cone_at ğ•œ s x âŠ† tangent_cone_at ğ•œ (s Ã—Ë¢ t) (x, y)
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â‰ƒg G') : â†¥(G.edge_set) â‰ƒ â†¥(G'.edge_set)
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} {F : Î± â†’ ennreal} (hf : âˆ€ (n : â„•), ae_measurable (f n) Î¼) (h_mono : âˆ€áµ (x : Î±) âˆ‚Î¼, monotone (Î» (n : â„•), f n x)) (h_tendsto : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (F x))) : filter.tendsto (Î» (n : â„•), âˆ«â» (x : Î±), f n x âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r r' : ennreal} (hf : has_fpower_series_on_ball f p x r) (hr : r' < r) : âˆƒ (C : â„), âˆ€ (y : E), y âˆˆ emetric.ball x r' â†’ âˆ€ (z : E), z âˆˆ emetric.ball x r' â†’ âˆ¥f y - f z - â‡‘(p 1) (Î» (_x : fin 1), y - z)âˆ¥ â‰¤ C * linear_order.max âˆ¥y - xâˆ¥ âˆ¥z - xâˆ¥ * âˆ¥y - zâˆ¥
{Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {Î² : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (Î² i)] {Î³ : Type uâ‚} [add_comm_monoid Î³] (Ï† : Î  (i : Î¹), Î² i â†’+ Î³) : direct_sum Î¹ (Î» (i : Î¹), Î² i) â†’+ Î³
{I : Type u_1} {A : Type u_2} {X : I â†’ Type u_3} [Î  (i : I), topological_space (X i)] [topological_space A] {f g : Î  (i : I), C(A, X i)} {S : set A} (homotopies : Î  (i : I), (f i).homotopy_rel (g i) S) : (continuous_map.pi f).homotopy_rel (continuous_map.pi g) S
{p x : â„} (h : liouville_with p x) : âˆƒ (C : â„) (hâ‚€ : 0 < C), âˆƒá¶  (n : â„•) in filter.at_top, 1 â‰¤ n âˆ§ âˆƒ (m : â„¤), x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < C / â†‘n ^ p
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) [category_theory.is_iso (category_theory.limits.biprod.map f g)] : category_theory.is_iso f
{G : Type u} [add_group G] {H : Type v} [add_group H] (Ï† : G â†’+ H) : G â§¸ Ï†.ker â†’+ H
{K : Type u_1} [field K] {Î¶ : K} {n : â„•} (h : is_primitive_root Î¶ n) : polynomial.splits (ring_hom.id K) (polynomial.X ^ n - â‡‘polynomial.C 1)
{Ïƒ : Type u_1} {Ï„ : Type u_2} {R : Type u_4} [comm_semiring R] (f : mv_polynomial Ïƒ R â‰ƒâ‚[R] mv_polynomial Ï„ R) : (Ï„ â†’ R) â‰ƒ (Ïƒ â†’ R)
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) [fintype Ïƒ] (S : finset Î›) : finset (turing.TM1to0.Î›' M)
(post : expr â†’ tactic (expr Ã— expr)) (e : expr) (cfg : tactic.simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}) : tactic (expr Ã— expr)
{Î± : Type u_1} {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (C : ennreal) {f : Î± â†’ ennreal} (hf_meas : measurable f) (hf : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰  âŠ¤ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ â‰¤ C) : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
{R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] {e : Î¹ â†’ M} {Îµ : Î¹ â†’ module.dual R M} [decidable_eq Î¹] (h : dual_pair e Îµ) : basis Î¹ R M
{Î± : Type u} [pseudo_emetric_space Î±] {Îµ : â„} (hÎµ : 0 â‰¤ Îµ) (Î´ : â„) (s : set Î±) : metric.cthickening Îµ (metric.thickening Î´ s) âŠ† metric.cthickening (Îµ + Î´) s
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : ((Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f' =o[l] g'
(args : list (name Ã— option name Ã— expr)) (md : tactic.transparency := tactic.transparency.semireducible) (unify : bool := bool.tt) : tactic unit
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³} (h : probability_theory.ident_distrib f g Î¼ Î½) {s : set Î³} (hs : measurable_set s) : â‡‘Î¼ (f â»Â¹' s) = â‡‘Î½ (g â»Â¹' s)
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z} [category_theory.limits.preserves_colimit (category_theory.limits.span f g) F] (s : category_theory.is_pushout f g h i) : category_theory.is_pushout (F.map f) (F.map g) (F.map h) (F.map i)
{G : Type u_1} [measurable_space G] [group G] [topological_space G] (Î¼ : measure_theory.measure G) [Î¼.is_haar_measure] [sigma_compact_space G] : measure_theory.sigma_finite Î¼
{Î± : Type u_1} {Î² : Type u_2} [add_monoid Î²] [decidable_eq Î±] {s t : finset Î±} (h : disjoint s t) (f : Î± â†’ Î²) (comm : âˆ€ (x : Î±), x âˆˆ s âˆª t â†’ âˆ€ (y : Î±), y âˆˆ s âˆª t â†’ add_commute (f x) (f y)) (scomm : (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ add_commute (f x) (f y)) := _) (tcomm : (âˆ€ (x : Î±), x âˆˆ t â†’ âˆ€ (y : Î±), y âˆˆ t â†’ add_commute (f x) (f y)) := _) : (s âˆª t).noncomm_sum f comm = s.noncomm_sum f scomm + t.noncomm_sum f tcomm
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space Î±} (p : ennreal) (Î¼ : measure_theory.measure Î±) [normed_group E] [normed_group F] {ğ•œ : Type u_5} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ F] [fact (1 â‰¤ p)] (L : E â†’L[ğ•œ] F) : â†¥(measure_theory.Lp E p Î¼) â†’L[ğ•œ] â†¥(measure_theory.Lp F p Î¼)
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : f '' s âˆˆ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
{Î± : Type u_1} [non_unital_semi_normed_ring Î±] (x y : Î±) : âˆ¥â‡‘(add_monoid_hom.mul_left x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{R : Type u} [comm_ring R] (I : ideal R) (f : polynomial R) : adjoin_root f â§¸ ideal.map (adjoin_root.of f) I â‰ƒ+* adjoin_root f â§¸ ideal.map (ideal.quotient.mk (ideal.span {f})) (ideal.map polynomial.C I)
{E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {s : set â„‚} {c : â„‚} (hc : s âˆˆ nhds c) (hd : differentiable_on â„‚ f (s  {c})) (hb : bdd_above (has_norm.norm âˆ˜ f '' (s  {c}))) : differentiable_on â„‚ (function.update f c (lim (nhds_within c {c}á¶œ) f)) s
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (h : W âŸ¶ X) (k : W âŸ¶ Y) (Hâ‚ : category_theory.limits.is_terminal Z) (Hâ‚‚ : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk h k _)) : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk h k)
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â‰¤ s.sum (Î» (i : Î¹), f i * g i)
{E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : âˆ¥f aâˆ¥ â‰¤ B a) (hB : âˆ€ (x : â„), has_deriv_at B (B' x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f xâˆ¥ = B x â†’ âˆ¥f' xâˆ¥ < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.is_neg_invariant] [topological_space.second_countable_topology G] (hcf : has_compact_support f) (hf : continuous f) (hg : measure_theory.integrable g Î¼) : continuous (convolution f g L Î¼)
{Î± : Type u_1} [preorder Î±] {f : Î± â†’ Î±} {x : Î±} (hf : monotone f) (hx : f x â‰¤ x) : antitone (Î» (n : â„•), f^[n] x)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' â†’ M''} (x : M) (hg : cont_mdiff_at I' I'' n g (f x)) (hf : cont_mdiff_at I I' n f x) : cont_mdiff_at I I'' n (g âˆ˜ f) x
{Î¹ : Type u_1} [fintype Î¹] (l : box_integral.integration_params) (I : box_integral.box Î¹) (c : nnreal) : filter (box_integral.tagged_prepartition I)
{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] â¦ƒf g : one_hom M Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [h : Î  (i : Î¹), measurable_space (Î± i)] {C : Î  (i : Î¹), set (set (Î± i))} (hC : âˆ€ (i : Î¹), measurable_space.generate_from (C i) = h i) (h2C : âˆ€ (i : Î¹), is_countably_spanning (C i)) : measurable_space.generate_from (set.univ.pi '' set.univ.pi C) = measurable_space.pi
{Ïƒ : Type u_1} {R : Type u_2} [ring R] (a : R) (Ï† : mv_power_series Ïƒ R) : mv_power_series Ïƒ R
{C : Type uâ‚‚} [category_theory.category C] {I : Type uâ‚} {F G : category_theory.discrete I â¥¤ C} (f : Î  (i : category_theory.discrete I), F.obj i âŸ¶ G.obj i) : F âŸ¶ G
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds a) (hfs : closure (f '' s) âˆˆ nhds (f a)) : continuous_at f a
{R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [nontrivial R] {m : M} {S : set M} : â‡‘(monoid_algebra.of R M) m âˆˆ submodule.span R (â‡‘(monoid_algebra.of R M) '' S) â†” m âˆˆ S
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal (R Ã— S)) : I = (ideal.map (ring_hom.fst R S) I).prod (ideal.map (ring_hom.snd R S) I)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {y : E} {Î± : Type u_3} (l : filter Î±) {c : Î± â†’ ğ•œ} {d : Î± â†’ E} (hc : filter.tendsto (Î» (n : Î±), âˆ¥c nâˆ¥) l filter.at_top) (hd : filter.tendsto (Î» (n : Î±), c n â€¢ d n) l (nhds y)) : filter.tendsto d l (nhds 0)
{L : first_order.language} {Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [is_directed Î¹ has_le.le] [nonempty Î¹] : L.Structure (Î£ (i : Î¹), G i)
{Î¹ : Type u_1} {I J : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) {Ï€i : Î  (J : box_integral.box Î¹), box_integral.prepartition J} (hJ : J âˆˆ Ï€) {J' : box_integral.box Î¹} (hJ' : J' âˆˆ Ï€i J) : Ï€.bUnion_index Ï€i J' = J
{C : Type u} [category_theory.category C] {W X Y Z : C} [category_theory.limits.has_binary_coproduct W X] [category_theory.limits.has_binary_coproduct Y Z] (f : W â‰… Y) (g : X â‰… Z) : W â¨¿ X â‰… Y â¨¿ Z
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] [subsingleton R] : unique (mv_polynomial Ïƒ R)
(Î¼ : measure_theory.measure â„) [measure_theory.is_locally_finite_measure Î¼] : Î¼.finite_spanning_sets_in (â‹ƒ (a b : â„š) (h : a < b), {set.Ioo â†‘a â†‘b})
{Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] {Î² : Type u_2} {Î²' : Type u_3} {mÎ² : measurable_space Î²} {mÎ²' : measurable_space Î²'} {f : Î± â†’ Î²} {g : Î± â†’ Î²'} {hfm : measurable f} {hgm : measurable g} : probability_theory.indep_fun f g Î¼ â†” âˆ€ {Ï† : Î² â†’ â„} {Ïˆ : Î²' â†’ â„}, measurable Ï† â†’ measurable Ïˆ â†’ measure_theory.integrable (Ï† âˆ˜ f) Î¼ â†’ measure_theory.integrable (Ïˆ âˆ˜ g) Î¼ â†’ measure_theory.integral Î¼ (Ï† âˆ˜ f * Ïˆ âˆ˜ g) = measure_theory.integral Î¼ (Ï† âˆ˜ f) * measure_theory.integral Î¼ (Ïˆ âˆ˜ g)
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {x : ğ•œ} {f' : F} : has_deriv_at f f' x â†” has_fderiv_at f (1.smul_right f') x
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) {C : â„} (hC : 0 â‰¤ C) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ C * finset.univ.sum (Î» (i : Î¹), finset.univ.prod (Î» (j : Î¹), ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (linear_order.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
(Î± : Type u) (Î² : Type v) [group Î±] [mul_action Î± Î²] [fintype Î±] [fintype Î²] [fintype (quotient (mul_action.orbit_rel Î± Î²))] [Î  (b : Î²), fintype â†¥(mul_action.stabilizer Î± b)] {Ï† : quotient (mul_action.orbit_rel Î± Î²) â†’ Î²} (hÏ† : function.left_inverse quotient.mk' Ï†) : fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(mul_action.stabilizer Î± (Ï† Ï‰)))
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {s : set Î±} {t : set Î²} {f : Î±' â†’ Î² â†’ Î³} {g : Î± â†’ Î±'} {f' : Î² â†’ Î± â†’ Î´} {g' : Î´ â†’ Î³} (h_left_anticomm : âˆ€ (a : Î±) (b : Î²), f (g a) b = g' (f' b a)) : set.image2 f (g '' s) t = g' '' set.image2 f' t s
{Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {a b : Î±} {f : Î± â†’ Î´} (hf : continuous_on f (set.interval a b)) : set.interval (f a) (f b) âŠ† f '' set.interval a b
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {G : D â¥¤ C} {F_obj : C â†’ D} (e : Î  (X : C) (Y : D), (F_obj X âŸ¶ Y) â‰ƒ (X âŸ¶ G.obj Y)) (he : âˆ€ (X : C) (Y Y' : D) (g : Y âŸ¶ Y') (h : F_obj X âŸ¶ Y), â‡‘(e X Y') (h â‰« g) = â‡‘(e X Y) h â‰« G.map g) : C â¥¤ D
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [t2_space Î²] (f : cocompact_map Î± Î²) â¦ƒs : set Î²â¦„ (hs : is_compact s) : is_compact (â‡‘f â»Â¹' s)
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [add_group G] [topological_add_group G] [Î¼.is_add_left_invariant] (U : set G) (hU : is_open U) (h'U : U.nonempty) (h : â‡‘Î¼ U â‰  âŠ¤) {K : set G} (hK : is_compact K) : â‡‘Î¼ K < âŠ¤
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] {P : C} (Ï€ : Y âŸ¶ P) (w : âˆ€ (jâ‚ jâ‚‚ : J), f jâ‚ â‰« Ï€ = f jâ‚‚ â‰« Ï€) : category_theory.limits.cotrident f
{X Y Z : Type u} (f g : X âŸ¶ Y) (Ï€ : Y âŸ¶ Z) (e : f â‰« Ï€ = g â‰« Ï€) (h : category_theory.limits.is_colimit (category_theory.limits.cofork.of_Ï€ Ï€ e)) (U : set Y) (H : f â»Â¹' U = g â»Â¹' U) : Ï€ â»Â¹' (Ï€ '' U) = U
{F : Type u_3} [inner_product_space â„ F] {Î¹â‚ : Type u_1} {sâ‚ : finset Î¹â‚} {wâ‚ : Î¹â‚ â†’ â„} (vâ‚ : Î¹â‚ â†’ F) (hâ‚ : sâ‚.sum (Î» (i : Î¹â‚), wâ‚ i) = 0) {Î¹â‚‚ : Type u_2} {sâ‚‚ : finset Î¹â‚‚} {wâ‚‚ : Î¹â‚‚ â†’ â„} (vâ‚‚ : Î¹â‚‚ â†’ F) (hâ‚‚ : sâ‚‚.sum (Î» (i : Î¹â‚‚), wâ‚‚ i) = 0) : has_inner.inner (sâ‚.sum (Î» (iâ‚ : Î¹â‚), wâ‚ iâ‚ â€¢ vâ‚ iâ‚)) (sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚‚ iâ‚‚ â€¢ vâ‚‚ iâ‚‚)) = -sâ‚.sum (Î» (iâ‚ : Î¹â‚), sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚ iâ‚ * wâ‚‚ iâ‚‚ * (âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥ * âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥))) / 2
{E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} {Ï† : E â†’L[ğ•œ] G} (hf : âˆ€ (x : E), x âˆˆ s â†’ differentiable_at ğ•œ f x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv ğ•œ f x - Ï†âˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] (i : â„•) : set Î±
{Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (h : âˆ€ (i : Î¹), measurable_set (s i)) (hd : directed superset s) (hfin : âˆƒ (i : Î¹), â‡‘Î¼ (s i) â‰  âŠ¤) : â‡‘Î¼ (â‹‚ (i : Î¹), s i) = â¨… (i : Î¹), â‡‘Î¼ (s i)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {p : Î¹ â†’ P} (ha : affine_independent k p) {s1 s2 : set Î¹} (hd : s1 âˆ© s2 = âˆ…) : â†‘(affine_span k (p '' s1)) âˆ© â†‘(affine_span k (p '' s2)) = âˆ…
(classical : interactive.parse (optional (lean.parser.tk "!"))) : interactive.parse (optional (î€€option.someî€option.someî€‚î€€functor.mapî€ <$> î€‚î€€interactive.types.pexpr_listî€interactive.types.pexpr_listî€‚ <|> lean.parser.tk "*" *> has_pure.pure option.none)) â†’ tactic unit
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î±] [locally_compact_space Î±] [measure_theory.is_finite_measure_on_compacts Î¼] : measure_theory.is_locally_finite_measure Î¼
{Î± : Sort u_1} {Î² : Sort u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} {Ï† : quot r â†’ quot s â†’ Sort u_3} [h : âˆ€ (a : Î±) (b : Î²), subsingleton (Ï† (quot.mk r a) (quot.mk s b))] (qâ‚ : quot r) (qâ‚‚ : quot s) (f : Î  (a : Î±) (b : Î²), Ï† (quot.mk r a) (quot.mk s b)) : Ï† qâ‚ qâ‚‚
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] (Î¼ : measure_theory.measure Î±) : Prop
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) â¦ƒÎ¹ : Type vâ¦„ (U : Î¹ â†’ topological_space.opens â†¥X) : category_theory.limits.cone ((category_theory.pairwise.diagram U).op â‹™ F) â‰Œ category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_4} [topological_space H] {I : model_with_corners ğ•œ E H} {N : Type u_6} [topological_space N] [charted_space H N] {A : Type u_10} [normed_ring A] [normed_algebra ğ•œ A] [smooth_ring (model_with_corners_self ğ•œ A) A] : ğ•œ â†’+* cont_mdiff_map I (model_with_corners_self ğ•œ A) N A âŠ¤
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (Î¼ : R) (k : â„•) : submodule R M
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : closure (f '' s) âˆˆ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
{C : Type u_1} [category_theory.category C] (r : hom_rel C) â¦ƒa b c : category_theory.quotient râ¦„ : category_theory.quotient.hom r a b â†’ category_theory.quotient.hom r b c â†’ category_theory.quotient.hom r a c
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ E'] [inner_product_space â„ G] [complete_space E'] {Ï† : cont_diff_bump_of_inner 0} [borel_space G] [measure_theory.is_locally_finite_measure Î¼] [Î¼.is_open_pos_measure] [finite_dimensional â„ G] {xâ‚€ : G} (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ Ï†.R â†’ g x = g xâ‚€) : convolution (Ï†.normed Î¼) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€ = g xâ‚€
{Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [conditionally_complete_linear_order Î±] [order_topology Î±] [borel_space Î±] [no_min_order Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ioc a b) = â‡‘Î½ (set.Ioc a b)) : Î¼ = Î½
{Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) (h0 : â‡‘Î¼ s â‰  0) (N : â„•) : âˆƒ (m : â„•) (H : m > N), â‡‘Î¼ (s âˆ© f^[m] â»Â¹' s) â‰  0
{Î¹ : Type u_1} [fintype Î¹] {I : box_integral.box Î¹} {Ï€ : box_integral.prepartition I} (h : Ï€.is_partition) : âˆƒ (s : finset (Î¹ Ã— â„)), box_integral.prepartition.split_many I s â‰¤ Ï€
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {ca cb : E} {la la' lb lb' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {ua va ub vb : Î¹ â†’ â„} [interval_integral.FTC_filter a la la'] [interval_integral.FTC_filter b lb lb'] [measure_theory.is_locally_finite_measure Î¼] (hab : interval_integrable f Î¼ a b) (hmeas_a : strongly_measurable_at_filter f la' Î¼) (hmeas_b : strongly_measurable_at_filter f lb' Î¼) (ha_lim : filter.tendsto f (la' âŠ“ Î¼.ae) (nhds ca)) (hb_lim : filter.tendsto f (lb' âŠ“ Î¼.ae) (nhds cb)) (hua : filter.tendsto ua lt la) (hva : filter.tendsto va lt la) (hub : filter.tendsto ub lt lb) (hvb : filter.tendsto vb lt lb) : (Î» (t : Î¹), âˆ« (x : â„) in va t..vb t, f x âˆ‚Î¼ - âˆ« (x : â„) in ua t..ub t, f x âˆ‚Î¼ - (âˆ« (x : â„) in ub t..vb t, cb âˆ‚Î¼ - âˆ« (x : â„) in ua t..va t, ca âˆ‚Î¼)) =o[lt] Î» (t : Î¹), âˆ¥âˆ« (x : â„) in ua t..va t, 1 âˆ‚Î¼âˆ¥ + âˆ¥âˆ« (x : â„) in ub t..vb t, 1 âˆ‚Î¼âˆ¥
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] : measurable_space.generate_from (set.univ.pi '' set.univ.pi (Î» (i : Î¹), {s : set (Î± i) | measurable_set s})) = measurable_space.pi
{P : Type u_1} [preorder P] (p : P) {Î¹ : Type u_2} [encodable Î¹] (ğ’Ÿ : Î¹ â†’ order.cofinal P) : order.ideal P
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} {Ïƒ : Type u_4} [inhabited Î›] (M : Î› â†’ turing.TM2.stmt Î“ Î› Ïƒ) (S : finset Î›) : Prop
(ğ•œ : Type u_5) (E : Type u_6) [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [nontrivial E] (c : â„) : âˆƒ (x : E), c < âˆ¥xâˆ¥
{C : Î  (n : â„•), fin n â†’ Sort u_1} (H0 : Î  (n : â„•), C n.succ 0) (Hs : Î  (n : â„•) (i : fin n), C n i â†’ C n.succ i.succ) {n : â„•} (i : fin n) : C n i
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [has_measurable_inv G] [Î¼.is_mul_left_invariant] [Î½.is_mul_left_invariant] (hÎ½ : Î½ â‰  0) : Î¼.absolutely_continuous Î½
{R : Type u_2} {A : Type u_3} [comm_semiring R] [non_unital_semiring A] [module R A] [smul_comm_class R A A] [is_scalar_tower R A A] {C : Type u_5} [ring C] [algebra R C] {Ï† Ïˆ : unitization R A â†’â‚[R] C} (h : Ï†.to_non_unital_alg_hom.comp (unitization.coe_non_unital_alg_hom R A) = Ïˆ.to_non_unital_alg_hom.comp (unitization.coe_non_unital_alg_hom R A)) : Ï† = Ïˆ
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} (s : set Î±) (f : â†¥(measure_theory.Lp E p Î¼)) : âˆ¥measure_theory.mem_â„’p.to_Lp â‡‘f _âˆ¥ â‰¤ âˆ¥fâˆ¥
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) {W X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} {h : W âŸ¶ X} {k : W âŸ¶ Y} (comm : h â‰« f = k â‰« g) : category_theory.limits.is_limit (G.map_cone (category_theory.limits.pullback_cone.mk h k comm)) â‰ƒ category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (G.map h) (G.map k) _)
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] [is_noetherian R M] {P : submodule R M â†’ Prop} (hgt : âˆ€ (I : submodule R M), (âˆ€ (J : submodule R M), J > I â†’ P J) â†’ P I) (I : submodule R M) : P I
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} {p : set Î± â†’ Prop} [Î¼.outer_regular] (H : Î¼.inner_regular p is_open) (h0 : p âˆ…) (hd : âˆ€ â¦ƒs U : set Î±â¦„, p s â†’ is_open U â†’ p (s  U)) : Î¼.inner_regular p (Î» (s : set Î±), measurable_set s âˆ§ â‡‘Î¼ s â‰  âŠ¤)
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ â‰¤ âˆ¥mâˆ¥
(e : environment) (results : native.rb_map name string) (drop_fn_chars : â„• := 0) (formatter : native.rb_map name string â†’ format) : format
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (B : bilin_form K V) (b : B.nondegenerate) (Ï† : V â†’â‚—[K] V) : V â†’â‚—[K] V
(M : Type v) (Î¹ : Type u_1 := punit) [add_comm_monoid M] [unique Î¹] : direct_sum Î¹ (Î» (_x : Î¹), M) â‰ƒ+ M
(Î± : Type u) (Ïƒ : Type v) : Type (max u v)
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : closure (f '' s) âˆˆ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
{E : Type u} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {f' : E} {s : set â„} {x r : â„} (hf : has_deriv_within_at f f' s x) (hr : âˆ¥f'âˆ¥ < r) : âˆ€á¶  (z : â„) in nhds_within x s, âˆ¥z - xâˆ¥â»Â¹ * âˆ¥f z - f xâˆ¥ < r
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– (category_theory.forget D)] {X : C} (P : Cáµ’áµ– â¥¤ D) (S : J.cover X) (x y : â†¥((J.plus_obj P).obj (opposite.op X))) (h : âˆ€ (I : S.arrow), â‡‘((J.plus_obj P).map I.f.op) x = â‡‘((J.plus_obj P).map I.f.op) y) : x = y
{B : Type uâ‚} [quiver B] [Î  (a b : B), quiver (a âŸ¶ b)] {C : Type uâ‚‚} [quiver C] [Î  (a b : C), quiver (a âŸ¶ b)] (self : category_theory.prelax_functor B C) : prefunctor B C
{V : Type u} [fintype V] [decidable_eq V] (G : simple_graph V) [decidable_rel G.adj] (n k â„“ Î¼ : â„•) : Prop
(cache_ty param_ty : Type := unit) : Type
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] â¦ƒU : set Î±â¦„ (hU : is_open U) {r : ennreal} (hr : r < â‡‘Î¼ U) : âˆƒ (F : set Î±) (H : F âŠ† U), is_closed F âˆ§ r < â‡‘Î¼ F
{Î± : Type u_1} [metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space.second_countable_topology Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] (C : nnreal) (h : âˆ€ (x : Î±) (Îµ : â„), Îµ > 0 â†’ (âˆƒ (r : â„) (H : r âˆˆ set.Ioc 0 Îµ), â‡‘Î¼ (metric.closed_ball x (6 * r)) â‰¤ â†‘C * â‡‘Î¼ (metric.closed_ball x r))) : vitali_family Î¼
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X âŸ¶ Y) [category_theory.limits.has_cokernel f] {W : C} (k : Y âŸ¶ W) (h : f â‰« k = 0) : {l // category_theory.limits.cokernel.Ï€ f â‰« l = k}
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (I : ideal R) (N : submodule R M) (hn : N.fg) (hin : N â‰¤ I â€¢ N) : âˆƒ (r : R), r - 1 âˆˆ I âˆ§ âˆ€ (n : M), n âˆˆ N â†’ r â€¢ n = 0
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : normed_group_hom Vâ‚ Vâ‚‚) (x : Vâ‚) : âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) â‰¤ finset.univ.sum (Î» (i : Î¹), f i * g i)
{m k p : â„•} {R : Type u_1} [comm_ring R] [is_domain R] [hp : fact (nat.prime p)] [hchar : char_p R p] {Î¼ : R} [ne_zero â†‘m] : (polynomial.cyclotomic (p ^ k * m) R).is_root Î¼ â†” is_primitive_root Î¼ m
{R : Type u} [comm_ring R] (I : ideal (polynomial R)) (x : â†¥(((ideal.quotient.mk I).comp polynomial.C).range)) (hx : â‡‘polynomial.C x âˆˆ ideal.map (polynomial.map_ring_hom ((ideal.quotient.mk I).comp polynomial.C).range_restrict) I) : x = 0
{R : Type u_1} [comm_ring R] : ideal.is_jacobson R â†” âˆ€ {I : ideal R}, I.is_prime â†’ (âˆƒ (M : set (ideal R)), (âˆ€ (J : ideal R), J âˆˆ M â†’ J.is_maximal âˆ¨ J = âŠ¤) âˆ§ I = has_Inf.Inf M)
{T : â„} {g : â„ â†’ â„} (hg : function.periodic g T) (h_int : âˆ€ (tâ‚ tâ‚‚ : â„), interval_integrable g measure_theory.measure_space.volume tâ‚ tâ‚‚) (hT : 0 < T) (t : â„) : has_Inf.Inf ((Î» (t : â„), âˆ« (x : â„) in 0..t, g x) '' set.Icc 0 T) + âŒŠt / TâŒ‹ â€¢ âˆ« (x : â„) in 0..T, g x â‰¤ âˆ« (x : â„) in 0..t, g x
{E : Type u_1} [normed_group E] [normed_space â„ E] {f f' : â„ â†’ E} {Î´ K Îµ a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) (ha : âˆ¥f aâˆ¥ â‰¤ Î´) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ K * âˆ¥f xâˆ¥ + Îµ) (x : â„) (H : x âˆˆ set.Icc a b) : âˆ¥f xâˆ¥ â‰¤ gronwall_bound Î´ K Îµ (x - a)
{Î± : Type} [reflected Î±] [has_reflect Î±] (ns : name) (t : tactic Î±) (s : tactic.local_cache.internal.cache_scope := tactic.local_cache.cache_scope.block_local) : tactic Î±
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {n : with_top â„•} {f : H â†’ H'} {s : set H} (hf : cont_mdiff_on I I' n f s) (hn : 1 â‰¤ n) (hs : unique_mdiff_on I s) : continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I H â»Â¹' s)
{G : Type w} [topological_space G] (Î¼ : measure_theory.content G) [t2_space G] (U : â„• â†’ topological_space.opens G) : Î¼.inner_content (â¨† (i : â„•), U i) â‰¤ âˆ‘' (i : â„•), Î¼.inner_content (U i)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k : â„•} (hk : 0 < k) : f.eigenspace Î¼ â‰¤ â‡‘(f.generalized_eigenspace Î¼) k
(h : expr) (base : name := name.mk_string "h" name.anonymous) (offset : option â„• := option.some 1) : tactic (list expr)
{Î± : Type u_1} [fintype Î±] [decidable_eq Î±] (Ïƒ : equiv.perm Î±) : (fintype.card Î±).partition
{Î± : Type u_1} [metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space.second_countable_topology Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] (s : set Î±) (t : set (set Î±)) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (a : set Î±) (H : a âˆˆ t), x âˆˆ a âˆ§ a âŠ† metric.closed_ball x Îµ)) (ht : âˆ€ (a : set Î±), a âˆˆ t â†’ (interior a).nonempty) (h't : âˆ€ (a : set Î±), a âˆˆ t â†’ is_closed a) (C : nnreal) (h : âˆ€ (a : set Î±), a âˆˆ t â†’ (âˆƒ (x : Î±) (H : x âˆˆ a), â‡‘Î¼ (metric.closed_ball x (3 * metric.diam a)) â‰¤ â†‘C * â‡‘Î¼ a)) : âˆƒ (u : set (set Î±)) (H : u âŠ† t), u.countable âˆ§ u.pairwise_disjoint id âˆ§ â‡‘Î¼ (s  â‹ƒ (a : set Î±) (H : a âˆˆ u), a) = 0
{G : Type u_1} [measurable_space G] [has_neg G] (Î¼ : measure_theory.measure G) : measure_theory.measure G
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î²] {f : Î± â†’ Î²} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measurable_space Î²] [topological_space.pseudo_metrizable_space Î²] [topological_space.second_countable_topology Î²] [opens_measurable_space Î²] (hf : measurable f) : measure_theory.ae_strongly_measurable f Î¼
{G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] {H : Type v} [add_group H] (Ï† : G â†’+ H) (HN : âˆ€ (x : G), x âˆˆ N â†’ â‡‘Ï† x = 0) : G â§¸ N â†’+ H
{Î± : Type u} {Î² : Type v} (R : Type u_1) [comm_semiring R] (e : Î± â‰ƒ Î²) [semiring Î²] [algebra R Î²] : let _inst : semiring Î± := e.semiring, _inst_4 : algebra R Î± := equiv.algebra R e in Î± â‰ƒâ‚[R] Î²
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (v : F) (h : âˆ€ (i j : Î¹) (x : B), x âˆˆ Z.base_set i âˆ© Z.base_set j â†’ Z.coord_change i j x v = v) : continuous (show B â†’ Z.total_space, from Î» (x : B), âŸ¨x, vâŸ©)
{Ïƒ : Type u_1} (R : Type u_2) [comm_semiring R] (n : Ïƒ â†’â‚€ â„•) : mv_power_series Ïƒ R â†’+ mv_polynomial Ïƒ R
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] [finite_dimensional ğ•œ E] [nontrivial E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) : module.End.has_eigenvalue T (â†‘â¨† (x : {x // x â‰  0}), â‡‘is_R_or_C.re (has_inner.inner (â‡‘T â†‘x) â†‘x) / âˆ¥â†‘xâˆ¥ ^ 2)
{Gâ‚€ : Type u_1} {R : Type u_3} [comm_group_with_zero Gâ‚€] [comm_ring R] (Ï† : polynomial R â†’*â‚€ Gâ‚€) (hÏ† : non_zero_divisors (polynomial R) â‰¤ submonoid.comap â†‘Ï† (non_zero_divisors Gâ‚€)) : ratfunc R â†’*â‚€ Gâ‚€
{Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [has_mul Î²] (f : Î± â†’â‚™* Î²) (I : Type u_3) : (I â†’ Î±) â†’â‚™* I â†’ Î²
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M â†’ M') (x : M) (f' : tangent_space I x â†’L[ğ•œ] tangent_space I' (f x)) : Prop
{E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : âˆ¥f aâˆ¥ â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f xâˆ¥ = B x â†’ âˆ¥f' xâˆ¥ < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {x : E} (hx : x â‰  0) : âˆ¥(â†‘âˆ¥xâˆ¥)â»Â¹ â€¢ xâˆ¥ = 1
(t s : expr) (md : tactic.transparency := tactic.transparency.semireducible) (approx : bool := bool.ff) : tactic unit
{F : Type u_3} [inner_product_space â„ F] (x : F) (r : â„) : has_inner.inner (r â€¢ x) x = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
{Î² : Type v} {Î¹ : Type u_5} {Ïƒ : Î¹ â†’ Type u_6} [Î  (i : Î¹), topological_space (Ïƒ i)] [topological_space Î²] {f : sigma Ïƒ â†’ Î²} (h : âˆ€ (i : Î¹), continuous (Î» (a : Ïƒ i), f âŸ¨i, aâŸ©)) : continuous f
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] {f : Î± â†’ Î² â†’ E} (hf : measure_theory.integrable (function.uncurry f) (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (z : Î² Ã— Î±), f z.snd z.fst âˆ‚Î½.prod Î¼
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) {Îµ : ennreal} (hÎµ : Îµ â‰  0) : âˆƒ (K : set Î±) (H : K âŠ† s), is_closed K âˆ§ â‡‘Î¼ s < â‡‘Î¼ K + Îµ
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f g : Î± â†’ ennreal} (hle : f â‰¤áµ[Î¼] g) (hg : ae_measurable g Î¼) (Îµ : ennreal) : âˆ«â» (a : Î±), f a âˆ‚Î¼ + Îµ * â‡‘Î¼ {x : Î± | f x + Îµ â‰¤ g x} â‰¤ âˆ«â» (a : Î±), g a âˆ‚Î¼
(name : module_info.module_name) (cur_module : module_info.module_id := "") : module_info.module_id
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_4} [topological_space H] {I : model_with_corners ğ•œ E H} {N : Type u_6} [topological_space N] [charted_space H N] {V : Type u_3} [normed_group V] [normed_space ğ•œ V] : cont_mdiff_map I (model_with_corners_self ğ•œ V) N V âŠ¤ â†’â‚—[ğ•œ] N â†’ V
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {r : â„} (r_pos : 0 < r) (c : â„) (f : E â†’â‚—[ğ•œ] ğ•œ) (h : âˆ€ (z : E), z âˆˆ metric.closed_ball 0 r â†’ âˆ¥â‡‘f zâˆ¥ â‰¤ c) (z : E) : âˆ¥â‡‘f zâˆ¥ â‰¤ c / r * âˆ¥zâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : Î± â†’ Î²} (hf : measure_theory.mem_â„’p f p Î¼) (hmeas : measure_theory.strongly_measurable f) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (M : â„), 0 < M âˆ§ measure_theory.snorm ({x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f) p Î¼ â‰¤ ennreal.of_real Îµ
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ (n : â„•), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hg' : measure_theory.mem_â„’p g p Î¼) (hui : measure_theory.unif_integrable f p Î¼) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (g x))) : filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
(t : interactive.parse interactive.types.texpr) (m : tactic.transparency := tactic.transparency.reducible) : tactic unit
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ C
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s t : set Î±} (Hf : antitone_on f t) (Hst : s âŠ† t) : (lower_bounds s âˆ© t).nonempty â†’ bdd_above (f '' s)
{C : Type u} [category_theory.category C] {W X Y : C} [category_theory.limits.has_binary_coproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) : X â¨¿ Y âŸ¶ W
{Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] (h : measure_theory.measure_preserving f Î¼ Î¼) : measure_theory.conservative f Î¼
{R : Type u_1} [semiring R] (Ï† : power_series R) : enat
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f (set.Iio 0 Ã—â„‚ set.Ioi 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Iio 0 Ã—â„‚ set.Ioi 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz_re : z.re â‰¤ 0) (hz_im : 0 â‰¤ z.im) : âˆ¥f zâˆ¥ â‰¤ C
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [h : algebra.finite_type R (add_monoid_algebra R M)] : âˆƒ (G : finset M), algebra.adjoin R (add_monoid_algebra.of' R M '' â†‘G) = âŠ¤
{Î¹ : Type u_1} {p : box_integral.box Î¹ â†’ Prop} (I : box_integral.box Î¹) (H_ind : âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ (âˆ€ (s : set Î¹), p (J.split_center_box s)) â†’ p J) (H_nhds : âˆ€ (z : Î¹ â†’ â„), z âˆˆ â‡‘box_integral.box.Icc I â†’ (âˆƒ (U : set (Î¹ â†’ â„)) (H : U âˆˆ nhds_within z (â‡‘box_integral.box.Icc I)), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ âˆ€ (m : â„•), z âˆˆ â‡‘box_integral.box.Icc J â†’ â‡‘box_integral.box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J)) : p I
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), is_add_unit (â‡‘g â†‘y)) (x : M) (y : â†¥S) : â‡‘(f.lift hg) (f.mk' x y) = â‡‘g x + â†‘-â‡‘(is_add_unit.lift_right (g.restrict S) hg) y
{ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f f' : ğ•œ â†’ G} {s : set ğ•œ} {x y : ğ•œ} {C : â„} (hf : âˆ€ (x : ğ•œ), x âˆˆ s â†’ has_deriv_within_at f (f' x) s x) (bound : âˆ€ (x : ğ•œ), x âˆˆ s â†’ âˆ¥f' xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
{E : Type u_4} [normed_group E] [normed_space â„ E] {b : â„} {f : â„• â†’ â„} {z : â„• â†’ E} (hfa : monotone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) (hgb : âˆ€ (n : â„•), âˆ¥(finset.range n).sum (Î» (i : â„•), z i)âˆ¥ â‰¤ b) : cauchy_seq (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), f i â€¢ z i))
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} : tendsto_uniformly F f p â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), has_dist.dist (f x) (F n x) < Îµ)
{E : Type u_3} [semi_normed_group E] {f : â„• â†’ E} (g : â„• â†’ â„) (hg : cauchy_seq (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), g i))) (hf : âˆ€ (i : â„•), âˆ¥f iâˆ¥ â‰¤ g i) : cauchy_seq (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i))
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic expr
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} (S : J.cover X) (T : Î  (I : S.arrow), J.cover I.Y) : S.bind T âŸ¶ S
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (h : o.oangle x y = 0) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{L : Type u_2} {R : Type u_3} [field L] [comm_ring R] (Ï† : polynomial R â†’+* L) (hÏ† : non_zero_divisors (polynomial R) â‰¤ submonoid.comap â†‘Ï† (non_zero_divisors L)) : ratfunc R â†’+* L
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F} (hf : continuous â‡‘f) {x : E} (hx : âˆ¥xâˆ¥ = 0) : âˆ¥â‡‘f xâˆ¥ = 0
{R : Type u} {Ïƒ : Type v} [comm_ring R] (I : ideal (mv_polynomial Ïƒ R)) (p : mv_polynomial Ïƒ R) (hcoe : âˆ€ (m : Ïƒ â†’â‚€ â„•), mv_polynomial.coeff m p âˆˆ ideal.comap mv_polynomial.C I) : p âˆˆ I
{L : first_order.language} {K : set (category_theory.bundled L.Structure)} (hn : K.nonempty) (h : âˆ€ (M N : category_theory.bundled L.Structure), nonempty (L.equiv â†¥M â†¥N) â†’ (M âˆˆ K â†” N âˆˆ K)) (hc : (quotient.mk '' K).countable) (fg : âˆ€ (M : category_theory.bundled L.Structure), M âˆˆ K â†’ first_order.language.Structure.fg L â†¥M) (hp : first_order.language.hereditary K) (jep : first_order.language.joint_embedding K) : âˆƒ (M : category_theory.bundled L.Structure), first_order.language.Structure.cg L â†¥M âˆ§ L.age â†¥M = K
(cfg : slim_check.slim_check_cfg := {num_inst := 100, max_size := 100, trace_discarded := bool.ff, trace_success := bool.ff, trace_shrink := bool.ff, trace_shrink_candidates := bool.ff, random_seed := option.none â„•, quiet := bool.ff}) : tactic unit
(Î± : Type u) (Ïƒ : Type v) : Type (max u v)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : E â†’ F) (L : E â†’L[ğ•œ] F) (r Îµ : â„) : set E
{a b : â„} {f f' g : â„ â†’ â„} (hf : continuous_on f (set.interval a b)) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo (linear_order.min a b) (linear_order.max a b) â†’ has_deriv_within_at f (f' x) (set.Ioi x) x) (hf' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (u : â„) in f a..f b, g u
{M : Type u_1} [has_mul M] â¦ƒs t : set Mâ¦„ (h : s âŠ† t) : subsemigroup.closure s â‰¤ subsemigroup.closure t
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F : C â¥¤ D} (G : D â¥¤ C) (Î· : ğŸ­ C â‰… F â‹™ G) (Îµ : G â‹™ F â‰… ğŸ­ D) : category_theory.is_equivalence F
{G : Type u_2} [add_group G] [topological_space G] [measurable_space G] (Î¼ : measure_theory.measure G) : Prop
{f : C(â†¥unit_interval, â„)} {Îµ : â„} {h : 0 < Îµ} {n : â„•} {x : â†¥unit_interval} {k : fin (n + 1)} (m : k âˆˆ bernstein_approximation.S f Îµ h n x) : |â‡‘f (bernstein.z k) - â‡‘f x| < Îµ / 2
{M : Type u_2} [add_comm_group M] {R : Type u_1} (v : ray_vector R M) : â†‘-v = -â†‘v
{Î± : Type u_1} {s : finset Î±} {p : Î  (t : finset Î±), t âŠ† s â†’ Prop} [Î  (t : finset Î±) (h : t âŠ† s), decidable (p t h)] : decidable (âˆƒ (t : finset Î±) (h : t âŠ† s), p t h)
{R : Type u} [comm_ring R] [is_domain R] {M : Type v} [add_comm_group M] [module R M] [is_dedekind_domain R] {I : ideal R} (hI : I â‰  âŠ¥) (hM : module.is_torsion_by_set R M â†‘I) : âˆƒ (P : finset (ideal R)) [_inst_6 : decidable_eq â†¥P] [_inst_7 : âˆ€ (p : ideal R), p âˆˆ P â†’ prime p] (e : â†¥P â†’ â„•), direct_sum.is_internal (Î» (p : â†¥P), submodule.torsion_by_set R M â†‘(â†‘p ^ e p))
{X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X â†’ E} {Î¼ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure Î¼] (hf : continuous f) (hcf : has_compact_support f) : measure_theory.integrable f Î¼
(M : Type u_4) (Î± : Type u_5) [has_vadd M Î±] {_x : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : Prop
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) (m : Î  (i : Î¹), E i) (h : âˆ¥mâˆ¥ â‰¤ 1) : âˆ¥â‡‘f mâˆ¥ â‰¤ âˆ¥fâˆ¥
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î²] [has_zero Î²] {m0 : measurable_space Î±} (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î±) : Prop
{Îµ : Type u} {m : Type v â†’ Type w} [monad_except Îµ m] {Î± : Type v} (tâ‚ tâ‚‚ : m Î±) (use_first_ex : bool := bool.tt) : m Î±
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] (x : M) : derivation ğ•œ (cont_mdiff_map I (model_with_corners_self ğ•œ ğ•œ) M ğ•œ âŠ¤) (cont_mdiff_map I (model_with_corners_self ğ•œ ğ•œ) M ğ•œ âŠ¤) â†’â‚—[ğ•œ] point_derivation I x
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M â†’+ N) (s : set M) : add_submonoid.map f (add_submonoid.closure s) = add_submonoid.closure (â‡‘f '' s)
{A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [is_dedekind_domain A] (I J : fractional_ideal (non_zero_divisors A) K) : I / J = I * Jâ»Â¹
{R : Type u_1} [ring R] (Ï† : power_series R) (u : RË£) : power_series R
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} {Ïƒ : Type u_3} (S : finset Î›) : turing.TM1.stmt Î“ Î› Ïƒ â†’ Prop
{n : â„•+} (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [is_cyclotomic_extension {n} K L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) : power_basis K L
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F : C â¥¤ D} {G_obj : D â†’ C} (e : Î  (X : C) (Y : D), (F.obj X âŸ¶ Y) â‰ƒ (X âŸ¶ G_obj Y)) (he : âˆ€ (X' X : C) (Y : D) (f : X' âŸ¶ X) (g : F.obj X âŸ¶ Y), â‡‘(e X' Y) (F.map f â‰« g) = f â‰« â‡‘(e X Y) g) : D â¥¤ C
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (P : Cáµ’áµ– â¥¤ D) (hsep : âˆ€ (X : C) (S : J.cover X) (x y : â†¥(P.obj (opposite.op X))), (âˆ€ (I : S.arrow), â‡‘(P.map I.f.op) x = â‡‘(P.map I.f.op) y) â†’ x = y) : category_theory.presheaf.is_sheaf J (J.plus_obj P)
{R : Type u_2} {V : Type u_3} {W : Type u_4} {P : Type u_6} {Q : Type u_7} [normed_group V] [metric_space P] [normed_add_torsor V P] [normed_group W] [metric_space Q] [normed_add_torsor W Q] [normed_field R] [normed_space R V] [normed_space R W] (f : P â†’A[R] Q) : V â†’L[R] W
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_2} {f : Î± â†’ ennreal} (h : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰  âŠ¤) {l : filter Î¹} {s : Î¹ â†’ set Î±} (hl : filter.tendsto (â‡‘Î¼ âˆ˜ s) l (nhds 0)) : filter.tendsto (Î» (i : Î¹), âˆ«â» (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
{K : Type u} {L : Type v} [field K] [field L] (f : K â†’+* L) (s : set K) : subfield.map f (subfield.closure s) = subfield.closure (â‡‘f '' s)
{V : Type u} [category_theory.category V] [category_theory.limits.has_images V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_kernels V] {W : Type uâ‚‚} [category_theory.category W] [category_theory.limits.has_images W] [category_theory.limits.has_zero_morphisms W] [category_theory.limits.has_kernels W] (F : V â¥¤ W) : Type
{Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), comm_ring (G i)] (f' : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’+* G j) [is_directed Î¹ has_le.le] [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h))] (hf : âˆ€ (i j : Î¹) (hij : i â‰¤ j), function.injective â‡‘(f' i j hij)) (i : Î¹) : function.injective â‡‘(ring.direct_limit.of G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h)) i)
{n : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) [field K] [algebra K L] [ne_zero â†‘â†‘n] [is_cyclotomic_extension {n} K L] (hn : n â‰  2) (hirr : irreducible (polynomial.cyclotomic â†‘n K)) : â‡‘(algebra.norm K) Î¶ = 1
{k : Type u_1} [field k] {Ïƒ : Type u_2} (V : set (Ïƒ â†’ k)) : ideal (mv_polynomial Ïƒ k)
(Î“ : Type u_1) [inhabited Î“] (Î› : Type u_2) (Ïƒ : Type u_3) : Type (max u_1 u_2 u_3)
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {ğ•œâ‚ƒ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [nondiscrete_normed_field ğ•œâ‚ƒ] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] [normed_space ğ•œâ‚ƒ G] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {Ïƒâ‚‚â‚ƒ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ} {Ïƒâ‚â‚ƒ : ğ•œ â†’+* ğ•œâ‚ƒ} [ring_hom_comp_triple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [ring_hom_isometric Ïƒâ‚â‚‚] [ring_hom_isometric Ïƒâ‚‚â‚ƒ] (h : F â†’SL[Ïƒâ‚‚â‚ƒ] G) (f : E â†’SL[Ïƒâ‚â‚‚] F) : âˆ¥h.comp fâˆ¥ â‰¤ âˆ¥hâˆ¥ * âˆ¥fâˆ¥
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] {E : set G} [has_measurable_inv G] [Î¼.is_mul_left_invariant] [Î½.is_mul_left_invariant] (hE : measurable_set E) (h2E : â‡‘Î½ E â‰  0) (h3E : â‡‘Î½ E â‰  âŠ¤) : Î¼ = (â‡‘Î¼ E / â‡‘Î½ E) â€¢ Î½
{Î¹ : Type u_1} {E : Type u_3} [semi_normed_group E] [complete_space E] {f : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : summable g) (h : âˆ€ (i : Î¹), âˆ¥f iâˆ¥ â‰¤ g i) : summable f
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) {C : â„} (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥f.mk_continuous C Hâˆ¥ â‰¤ linear_order.max C 0
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) {W X Y Z : C} {h : X âŸ¶ Z} {k : Y âŸ¶ Z} {f : W âŸ¶ X} {g : W âŸ¶ Y} (comm : f â‰« h = g â‰« k) : category_theory.limits.is_colimit (G.map_cocone (category_theory.limits.pushout_cocone.mk h k comm)) â‰ƒ category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (G.map h) (G.map k) _)
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (g : Î² â†’ Î³) (f : Î± â†’ Î²) (s : set Î±) : g '' (f '' s) = (Î» (x : Î±), g (f x)) '' s
{Î¹ : Type u_1} [fintype Î¹] (I : box_integral.box Î¹) (r : (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)) : âˆƒ (Ï€ : box_integral.tagged_prepartition I), Ï€.is_partition âˆ§ Ï€.is_Henstock âˆ§ Ï€.is_subordinate r âˆ§ (âˆ€ (J : box_integral.box Î¹), J âˆˆ Ï€ â†’ (âˆƒ (m : â„•), âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m)) âˆ§ Ï€.distortion = I.distortion
{R : Type u_1} [semiring R] (Ï† : power_series R) (h : is_unit Ï†) : is_unit (â‡‘(power_series.constant_coeff R) Ï†)
{Î¹ : Type u_1} (I : box_integral.box Î¹) : Type u_1
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (P Q : chain_complex V â„•) (zero : P.X 0 âŸ¶ Q.X 0) (one : P.X 1 âŸ¶ Q.X 1) (one_zero_comm : one â‰« Q.d 1 0 = P.d 1 0 â‰« zero) (succ : Î  (n : â„•) (p : Î£' (f : P.X n âŸ¶ Q.X n) (f' : P.X (n + 1) âŸ¶ Q.X (n + 1)), f' â‰« Q.d (n + 1) n = P.d (n + 1) n â‰« f), Î£' (f'' : P.X (n + 2) âŸ¶ Q.X (n + 2)), f'' â‰« Q.d (n + 2) (n + 1) = P.d (n + 2) (n + 1) â‰« p.snd.fst) : P âŸ¶ Q
{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] [is_localization M S] {I : ideal S} [I.is_prime] {J : ideal R} {H : J â‰¤ ideal.comap (algebra_map R S) I} (hI : (ideal.comap (algebra_map R S) I).is_maximal) : function.surjective â‡‘(I.quotient_map (algebra_map R S) H)
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R â‰ƒ+* S) : ideal.map â†‘(f.symm) (ideal.map â†‘f I) = I
{Râ‚ : Type u_3} {A : Type u_5} {B : Type u_6} [comm_semiring Râ‚] [comm_ring A] [comm_ring B] [algebra Râ‚ A] [algebra Râ‚ B] (I : ideal A) (J : ideal B) (f : A â‰ƒâ‚[Râ‚] B) (hIJ : J = ideal.map â†‘f I) : (A â§¸ I) â‰ƒâ‚[Râ‚] B â§¸ J
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [linear_order Î²] [densely_ordered Î²] [no_min_order Î²] [no_max_order Î²] [nonempty Î²] (a : Î±) (I : order.ideal (order.partial_iso Î± Î²)) : (âˆƒ (f : order.partial_iso Î± Î²), f âˆˆ order.partial_iso.defined_at_left Î² a âˆ§ f âˆˆ I) â†’ {b // âˆƒ (f : {f // âˆ€ (p : Î± Ã— Î²), p âˆˆ f â†’ âˆ€ (q : Î± Ã— Î²), q âˆˆ f â†’ cmp p.fst q.fst = cmp p.snd q.snd}) (H : f âˆˆ I), (a, b) âˆˆ f.val}
{Î¹ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] (ğ’œ : Î¹ â†’ submodule R A) (I : ideal A) : ideal A
{c w : â„‚} {R : â„} {n : â„¤} : circle_integrable (Î» (z : â„‚), (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ w âˆ‰ metric.sphere c |R|
{Î± : Type u} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (n : â„•) : function.is_fixed_pt f^[n] x
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î²} (hs : s.countable) {f : Î± â†’ Î²} (hf : âˆ€ (y : Î²), y âˆˆ s â†’ measurable_set (f â»Â¹' {y})) : âˆ‘' (b : â†¥s), â‡‘Î¼ (f â»Â¹' {â†‘b}) = â‡‘Î¼ (f â»Â¹' s)
{Ïƒ : Type u_1} {R : Type u_2} [comm_semiring R] (Ï† : mv_polynomial Ïƒ R) : Prop
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) (a : â„) (hf : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ = a * âˆ¥xâˆ¥) : E â†’SL[Ïƒâ‚â‚‚] F
(R : Type u) (S : Type v) [ring R] [ring S] : {K // K.is_prime} â‰ƒ {I // I.is_prime} âŠ• {J // J.is_prime}
{C : Type uâ‚} [category_theory.category C] (all_split_mono : Î  {X Y : C} (f : X âŸ¶ Y), trunc (category_theory.split_mono f)) : category_theory.groupoid C
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.regular] â¦ƒU : set Î±â¦„ (hU : is_open U) {r : ennreal} (hr : r < â‡‘Î¼ U) : âˆƒ (K : set Î±) (H : K âŠ† U), is_compact K âˆ§ r < â‡‘Î¼ K
{C : Type u} [category_theory.category C] {X Y : C} (I : X â‰… Y) : Y â‰… X
{Î± : Type u_1} {E' : Type u_5} {ğ•œ : Type u_11} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E'] [complete_space E'] [normed_space â„ E'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (x : E') : measure_theory.integrable â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) (measure_theory.indicator_const_Lp 2 hs hÎ¼s x)) Î¼
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' â†’ M''} (x : M) (hg : cont_mdiff_at I' I'' n g (f x)) (hf : cont_mdiff_within_at I I' n f s x) : cont_mdiff_within_at I I'' n (g âˆ˜ f) s x
{n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] {m : â„•} (hcop : m.coprime n) : minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ m)
(Î± : Type u) (Ïƒ : Type v) : Type (max u v)
{Î¹ : Type u_1} {I : box_integral.box Î¹} {i : Î¹} {x : â„} (h : x âˆ‰ set.Ioo (I.lower i) (I.upper i)) : box_integral.prepartition.split I i x = âŠ¤
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_4} [topological_space H] {H' : Type u_5} [topological_space H'] {I : model_with_corners ğ•œ E H} {I' : model_with_corners ğ•œ E' H'} {M : Type u_6} [topological_space M] [charted_space H M] {M' : Type u_7} [topological_space M'] [charted_space H' M'] {n : with_top â„•} (y : M') : cont_mdiff_map I I' M M' n
(h : expr) (ns : list name := list.nil) (md : tactic.transparency := tactic.transparency.semireducible) : tactic (list (name Ã— list expr Ã— list (name Ã— expr)))
{Î± : Type u} {Î² : Type v} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (ne : s.nonempty) (H : bdd_above s) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (G : V â¥¤ W) [G.additive] (hom : Î  (i j : Î¹), C.X i âŸ¶ D.X j) : (G.map_homological_complex c).map (homotopy.null_homotopic_map hom) = homotopy.null_homotopic_map (Î» (i j : Î¹), G.map (hom i j))
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {hm : m â‰¤ m0} [measure_theory.sigma_finite (Î¼.trim hm)] {s : set Î±} (f : â†¥(measure_theory.Lp F' 1 Î¼)) (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) : âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L1_clm hm Î¼) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ o.oangle x y = 0
{V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = 0
{V : Type u_1} {W : Type u_2} {Vâ‚ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group Vâ‚] {f g : normed_group_hom V W} (Ï† : normed_group_hom Vâ‚ V) (h : f.comp Ï† = g.comp Ï†) (C : â„) (hÏ† : âˆ¥Ï†âˆ¥ â‰¤ C) : âˆ¥normed_group_hom.equalizer.lift Ï† hâˆ¥ â‰¤ C
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] : âˆ¥0âˆ¥ = 0
(Î¹ : Type u_1) (Ï€ : Î¹ â†’ Type u_2) : (Î  (i : Î¹), Ï€ i) â‰ƒ {f // âˆ€ (i : Î¹), (f i).fst = i}
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [metric_space Î²] {Î¼ : measure_theory.measure Î±} {s : set Î±} {Îµ : â„} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [semilattice_sup Î¹] [nonempty Î¹] [encodable Î¹] (hÎµ : 0 < Îµ) (hf : âˆ€ (n : Î¹), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hsm : measurable_set s) (hs : â‡‘Î¼ s â‰  âŠ¤) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ s â†’ filter.tendsto (Î» (n : Î¹), f n x) filter.at_top (nhds (g x))) : set Î±
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {f : â„ â†’ E} {Î¼ : measure_theory.measure â„} {Î¹ : Type u_1} {l : filter Î¹} [l.is_countably_generated] {F : Î¹ â†’ â„ â†’ E} (bound : â„ â†’ â„) (hF_meas : âˆ€á¶  (n : Î¹) in l, measure_theory.ae_strongly_measurable (F n) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€á¶  (n : Î¹) in l, âˆ€áµ (x : â„) âˆ‚Î¼, x âˆˆ set.interval_oc a b â†’ âˆ¥F n xâˆ¥ â‰¤ bound x) (bound_integrable : interval_integrable bound Î¼ a b) (h_lim : âˆ€áµ (x : â„) âˆ‚Î¼, x âˆˆ set.interval_oc a b â†’ filter.tendsto (Î» (n : Î¹), F n x) l (nhds (f x))) : filter.tendsto (Î» (n : Î¹), âˆ« (x : â„) in a..b, F n x âˆ‚Î¼) l (nhds (âˆ« (x : â„) in a..b, f x âˆ‚Î¼))
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] [measure_theory.sigma_finite Î¼] (f : Î± â†’ nnreal) (fint : measure_theory.integrable (Î» (x : Î±), â†‘(f x)) Î¼) {Îµ : â„} (Îµpos : 0 < Îµ) : âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ < âˆ« (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (Î¼ : K) : disjoint (f.generalized_eigenrange Î¼ (finite_dimensional.finrank K V)) (â‡‘(f.generalized_eigenspace Î¼) (finite_dimensional.finrank K V))
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} {Ïƒ : Type u_3} (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) (S : finset Î›) : finset (option (turing.TM1.stmt Î“ Î› Ïƒ))
{C : Type uâ‚‚} [category_theory.category C] {I : Type uâ‚} {F : category_theory.discrete I â¥¤ C} : F â‰… category_theory.discrete.functor (F.obj âˆ˜ category_theory.discrete.mk)
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] {Î¹ : Type u_5} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {l : filter Î±} [l.is_measurably_generated] {f : Î± â†’ E} {b : E} (h : filter.tendsto f (l âŠ“ Î¼.ae) (nhds b)) (hfm : strongly_measurable_at_filter f l Î¼) (hÎ¼ : Î¼.finite_at_filter l) {s : Î¹ â†’ set Î±} {li : filter Î¹} (hs : filter.tendsto s li l.small_sets) (m : Î¹ â†’ â„ := Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) (hsÎ¼ : (Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) =á¶ [li] m . "refl") : (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ b) =o[li] m
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] {s : set Î±} (hs : measurable_set s) (t : set Î±) : â‡‘Î¼ (measure_theory.to_measurable Î¼ t âˆ© s) = â‡‘Î¼ (t âˆ© s)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_4} [topological_space H] {I : model_with_corners ğ•œ E H} {H' : Type u_5} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} (M : Type u_6) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (M' : Type u_7) [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I' M'] : smooth_manifold_with_corners (I.prod I') (M Ã— M')
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} [category_theory.limits.has_zero_object V] (i : Î¹) : (Î  (i j : Î¹), C.X i âŸ¶ D.X j) â†’+ (C.X_next i âŸ¶ D.X i)
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) : âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C * a ^ n
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p âˆˆ s) : vector_span k s = submodule.span k ((Î» (_x : P), _x -áµ¥ p) '' (s  {p}))
(use_iota_eqn : interactive.parse (optional (lean.parser.tk "!"))) (trace_lemmas : interactive.parse (optional (lean.parser.tk "?"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (tgt : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.texpr))) (cfg : tactic.simp_config_ext := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}, discharger := tactic.failed unit}) : tactic unit
{Î± : Type} (t : tactic Î±) (cfg : tactic.simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.ff, memoize := bool.tt, trace_lemmas := bool.ff}) (discharger : tactic unit := tactic.failed) (no_defaults : bool := bool.ff) (attr_names : list name := list.nil) (hs : list tactic.simp_arg_type := list.nil) : tactic Î±
{Ïƒ : Type u_1} {R : Type u_3} [comm_semiring R] (Ï† : mv_polynomial Ïƒ R) (n : â„•) : Prop
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) (Ïƒ : L â‰ƒâ‚[K] L) : Ïƒ âˆˆ E.fixing_subgroup â†” âˆ€ (x : L), x âˆˆ E â†’ â‡‘Ïƒ x = x
(xs : list tactic.rcases_patt) (cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) (trace : bool := bool.ff) : tactic (list tactic.rcases_patt)
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {s : set Î±} [measure_theory.is_finite_measure Î½] (hâ‚ : measurable_set s) (hâ‚‚ : Î½ â‰¤ Î¼) : â‡‘(Î¼ - Î½) s = â‡‘Î¼ s - â‡‘Î½ s
{R : Type u_1} [comm_ring R] {f : polynomial R} : algebraic_geometry.polynomial.image_of_Df f = â‡‘(prime_spectrum.comap polynomial.C) '' (prime_spectrum.zero_locus {f})á¶œ
(e : expr) (r : expr Ã— bool) (cfg : tactic.nth_rewrite.cfg := {to_rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}, try_simp := bool.ff, discharger := tactic.skip, simplifier := Î» (e : expr), tactic.failed}) : tactic (list tactic.nth_rewrite.tracked_rewrite)
{Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î¹] [semilattice_sup Î¹] {s : Î¹ â†’ set Î±} (hs : âˆ€ (n : Î¹), measurable_set (s n)) (hm : antitone s) (hf : âˆƒ (i : Î¹), â‡‘Î¼ (s i) â‰  âŠ¤) : filter.tendsto (â‡‘Î¼ âˆ˜ s) filter.at_top (nhds (â‡‘Î¼ (â‹‚ (n : Î¹), s n)))
{X : Type u_1} [emetric_space X] {Î¹ : Type u_2} {I : set Î¹} (hI : I.finite) {s : Î¹ â†’ set X} {t : set X} : (âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated (s i) t) â†’ is_metric_separated (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) t
{Î± : Type u_1} {Î² : Î± â†’ Type u_2} (Î³ : Î  (a : Î±), Î² a â†’ Type u_3) : (Î  (x : Î£ (i : Î±), Î² i), Î³ x.fst x.snd) â‰ƒ Î  (a : Î±) (b : Î² a), Î³ a b
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] (M : turing.TM0.machine Î“ Î›) : turing.TM0.cfg Î“ Î› â†’ turing.TM0.cfg Î“ Î› â†’ Prop
{Î² : Type v} {Î± : Type u_1} [decidable_eq Î±] (Ïƒ : Î± â†’ equiv.perm Î²) {l : list Î±} (hl : l.nodup) (mem_l : âˆ€ (a : Î±), a âˆˆ l) : (list.map (Î» (a : Î±), equiv.perm.prod_extend_right a (Ïƒ a)) l).prod = equiv.prod_congr_right Ïƒ
{L : first_order.language} {Î± : Type w} {n : â„•} (T : L.Theory) (Ï† Ïˆ : L.bounded_formula Î± n) : Prop
{L : first_order.language} {L' : first_order.language} (Ï• : L â†’á´¸ L') {Lâ‚ : first_order.language} {Lâ‚‚ : first_order.language} (Ïˆ : Lâ‚ â†’á´¸ Lâ‚‚) : L.sum Lâ‚ â†’á´¸ L'.sum Lâ‚‚
{K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero 2] {k : â„•} (hÎ¶ : is_primitive_root Î¶ (2 ^ (k + 1))) [is_cyclotomic_extension {2 ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ (k + 1)) K)) : â‡‘(algebra.norm K) (Î¶ ^ 2 ^ k - 1) = (-2) ^ 2 ^ k
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : f =o[l] g â†” âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
{Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group E] {p : ennreal} [hp : fact (1 â‰¤ p)] {f : Î¹ â†’ â†¥(measure_theory.Lp E p Î¼)} {g : â†¥(measure_theory.Lp E p Î¼)} {l : filter Î¹} (hfg : filter.tendsto f l (nhds g)) : measure_theory.tendsto_in_measure Î¼ (Î» (n : Î¹), â‡‘(f n)) l â‡‘g
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) {W X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} {h : W âŸ¶ X} {k : W âŸ¶ Y} (comm : h â‰« f = k â‰« g) [category_theory.limits.preserves_limit (category_theory.limits.cospan f g) G] (l : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk h k comm)) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (G.map h) (G.map k) _)
(Î± : Type u) (Î² : Type v) [add_group Î±] [add_action Î± Î²] : Î² â‰ƒ Î£ (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), â†¥(add_action.orbit Î± Ï‰.out')
{Î± : Type u_2} [measurable_space Î±] (s : set Î±) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{Î² : Type u_2} [uniform_space Î²] {Î± : Type u_1} {f : Î± â†’ Î²} {s : set (Î² Ã— Î²)} (hs : s âˆˆ uniformity Î²) (hf : pairwise (Î» (x y : Î±), (f x, f y) âˆ‰ s)) : filter.comap (prod.map f f) (uniformity Î²) = filter.principal id_rel
{A : Type u} [category_theory.category A] [category_theory.abelian A] {X Y Z : A} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (w : f â‰« g = 0) {W : A} (e : W âŸ¶ category_theory.limits.cokernel f) (he : e â‰« category_theory.limits.cokernel.desc f g w = 0) : W âŸ¶ homology f g w
{Î± : Type u_1} {m m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (hm : m â‰¤ m0) : measure_theory.measure Î±
{F : Type u_3} [inner_product_space â„ F] [finite_dimensional â„ F] (Ï† : F â‰ƒâ‚—áµ¢[â„] F) : âˆƒ (l : list F), l.length â‰¤ finite_dimensional.finrank â„ F âˆ§ Ï† = (list.map (Î» (v : F), reflection (submodule.span â„ {v})á—®) l).prod
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] : M â†’ tangent_bundle I M
{B : Type uâ‚} [quiver B] [Î  (a b : B), quiver (a âŸ¶ b)] {C : Type uâ‚‚} [quiver C] [Î  (a b : C), quiver (a âŸ¶ b)] {D : Type uâ‚ƒ} [quiver D] [Î  (a b : D), quiver (a âŸ¶ b)] (F : category_theory.prelax_functor B C) (G : category_theory.prelax_functor C D) : category_theory.prelax_functor B D
{Î± : Type u_1} {Î² : Type u_2} (S : set Î±) (f : Î² â‰ƒ Î±) : â‡‘f â»Â¹' S = â‡‘(f.symm) '' S
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] (n : Ïƒ) (p : mv_polynomial Ïƒ R) : â„•
{E : Type u_1} [add_comm_group E] [module â„ E] {Î± : Type u_2} [linear_ordered_field Î±] [mul_action_with_zero Î± â„] [ordered_smul Î± â„] [module Î± E] [is_scalar_tower Î± â„ (set E)] {s : set E} (symmetric : âˆ€ (x : E), x âˆˆ s â†’ -x âˆˆ s) (r : Î±) (x : E) : gauge s (r â€¢ x) = |r| â€¢ gauge s x
{Î± : Type u_1} {E : Type u_3} [topological_space Î±] [compact_space Î±] [normed_group E] (f : C(Î±, E)) {C : â„} (C0 : 0 â‰¤ C) : âˆ¥fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C
{M : Type u_1} [has_add M] (S : set (add_con M)) : (has_Inf.Inf S).to_setoid = has_Inf.Inf (add_con.to_setoid '' S)
(md : tactic.transparency := tactic.transparency.semireducible) : list (tactic string)
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : M â†’â‚—[R] â†¥(adic_completion I M)
{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] {Î¹ : Type u_1} [topological_space Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} {s : set Î²} : tendsto_locally_uniformly_on F f p s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ âˆ€ (x : Î²), x âˆˆ s â†’ (âˆƒ (t : set Î²) (H : t âˆˆ nhds_within x s), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_edist.edist (f y) (F n y) < Îµ)
{C : Type uâ‚} [category_theory.category C] {I : C} (hI : category_theory.limits.is_initial I) (h : âˆ€ (X : C), category_theory.mono (hI.to X)) : category_theory.limits.initial_mono_class C
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {f : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} {g : Î³ â†’ Î´} {f' : Î±' â†’ Î² â†’ Î´} {g' : Î± â†’ Î±'} (h_distrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' (g' a) b) : g '' set.image2 f s t = set.image2 f' (g' '' s) t
(M : Type v) (X : Type x) [_inst_1 _inst_3 : uniform_space X] [has_scalar M X] : Prop
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : âˆƒ (Ï€ : K), â‡‘(v.valuation) Ï€ = â†‘(â‡‘multiplicative.of_add (-1))
{Ïƒ : Type u_1} {R : Type u_2} [semiring R] (Ï† : mv_power_series Ïƒ R) (h : is_unit Ï†) : is_unit (â‡‘(mv_power_series.constant_coeff Ïƒ R) Ï†)
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F : C â¥¤ D} {G : D â¥¤ C} {E : Type uâ‚ƒ} [â„° : category_theory.category E] (H : D â¥¤ E) (I : E â¥¤ D) (adjâ‚ : F âŠ£ G) (adjâ‚‚ : H âŠ£ I) : F â‹™ H âŠ£ I â‹™ G
{J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {c c' : category_theory.limits.cocone F} (Ï† : c.X â‰… c'.X) (w : âˆ€ (j : J), c.Î¹.app j â‰« Ï†.hom = c'.Î¹.app j) : c â‰… c'
{Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f g : Î± â†’ ennreal} (h_meas_f : ae_measurable f Î¼) (h_meas_g : ae_measurable g Î¼) (h_indep_fun : probability_theory.indep_fun f g Î¼) : âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
{G : Type u} [add_group G] {H : Type v} [add_group H] (Ï† : G â†’+ H) : G â§¸ Ï†.ker â†’+ â†¥(Ï†.range)
{G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [group G] [has_measurable_mul G] [Î¼.is_mul_right_invariant] (f : G â†’ ennreal) (g : G) : âˆ«â» (x : G), f (x * g) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
{V : Type u_1} [inner_product_space â„ V] (x y : V) : âˆ¥x + yâˆ¥ = âˆ¥x - yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) {s : set Î±} : bdd_above s â†’ bdd_below (f '' s)
(n : â„•) (base : name) (offset : option â„• := option.none) : tactic (list expr)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : is_lie_abelian â†¥(lie_algebra.radical R L) â†” âˆ€ (I : lie_ideal R L), lie_algebra.is_solvable R â†¥I â†’ is_lie_abelian â†¥I
(ğ•œ : Type v) [is_R_or_C ğ•œ] {E : Type u} [normed_group E] [normed_space ğ•œ E] [nontrivial E] (x : E) : âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
{Î± : Type u_2} {Î² : Type u_3} [bornology Î±] [bornology Î²] (f : Î± â†’ Î²) (h : âˆ€ â¦ƒs : set Î±â¦„, bornology.is_bounded s â†’ bornology.is_bounded (f '' s)) : locally_bounded_map Î± Î²
{C : Type uâ‚} [category_theory.category C] {J : category_theory.grothendieck_topology C} {A : Type uâ‚‚} [category_theory.category A] {E : A} {X : C} {P : Cáµ’áµ– â¥¤ A} (hP : category_theory.presheaf.is_sheaf J P) (S : J.cover X) (x : Î  (I : S.arrow), E âŸ¶ P.obj (opposite.op I.Y)) (hx : âˆ€ (I : S.relation), x I.fst â‰« P.map I.gâ‚.op = x I.snd â‰« P.map I.gâ‚‚.op) : E âŸ¶ P.obj (opposite.op X)
(n : â„• := 2) : tactic unit
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {F : â„• â†’ Î± â†’ ennreal} {f : Î± â†’ ennreal} (bound : Î± â†’ ennreal) (hF_meas : âˆ€ (n : â„•), ae_measurable (F n) Î¼) (h_bound : âˆ€ (n : â„•), F n â‰¤áµ[Î¼] bound) (h_fin : âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), F n a) filter.at_top (nhds (f a))) : filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
{Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.probability_measure Î±) : measure_theory.finite_measure Î±
{I : Type u} (f : I â†’ Type v) [Î  (i : I), add_zero_class (f i)] (i : I) : (Î  (i : I), f i) â†’+ f i
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : subgroup G} [Î¼.is_mul_right_invariant] : measure_theory.smul_invariant_measure â†¥(Î“.opposite) G Î¼
{E : Type u_1} [inner_product_space â„ E] {v : E} (hv : âˆ¥vâˆ¥ = 1) (w : â†¥(submodule.span â„ {v})á—®) : â†¥(metric.sphere 0 1)
{Î± : Type u} {Î² : Type v} {a b : set Î±} (f : Î± â†’ Î²) (h : a âŠ† b) : f '' a âŠ† f '' b
{Î± : Type u_1} {E : Type u_2} [normed_group E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_space â„ E] [complete_space E] (f : â†¥(measure_theory.Lp E 1 Î¼)) : E
{C : Type uâ‚} [category_theory.category C] {J : Type u} [category_theory.category J] {j : J} (I : category_theory.limits.is_terminal j) (F : J â¥¤ C) [category_theory.limits.has_colimit F] : category_theory.is_iso (category_theory.limits.colimit.Î¹ F j)
{I : Type u} (X : I â†’ Top) : (Î  (i : I), â†¥(fundamental_groupoid.fundamental_groupoid_functor.obj (X i))) â¥¤ â†¥(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Î  (i : I), â†¥(X i))))
{Î¹ : Type u_1} {M : Type u_2} [add_comm_monoid M] {Iâ‚€ : with_top (box_integral.box Î¹)} (f : box_integral.box_additive_map Î¹ M Iâ‚€) (I : with_top (box_integral.box Î¹)) (hI : I â‰¤ Iâ‚€) : box_integral.box_additive_map Î¹ M I
{R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] {S : set (monoid_algebra R M)} (hS : algebra.adjoin R S = âŠ¤) : algebra.adjoin R (â‹ƒ (f : monoid_algebra R M) (H : f âˆˆ S), â‡‘(monoid_algebra.of R M) '' â†‘(f.support)) = âŠ¤
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) : Type (max u_4 u_1)
{Î± : Type u_1} (r s : setoid Î±) : r âŠ” s = eqv_gen.setoid (Î» (x y : Î±), r.rel x y âˆ¨ s.rel x y)
(e t : expr) (md : tactic.transparency := tactic.transparency.reducible) (unify : bool := bool.tt) : tactic expr
{X : Type u_1} [emetric_space X] {Î¹ : Type u_2} {I : finset Î¹} {s : Î¹ â†’ set X} {t : set X} : (âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated (s i) t) â†’ is_metric_separated (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) t
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (f : measure_theory.simple_func Î± E) (g : E â†’ F) (hf : measure_theory.integrable â‡‘f Î¼) (hg : g 0 = 0) : measure_theory.simple_func.integral Î¼ (measure_theory.simple_func.map g f) = f.range.sum (Î» (x : E), (â‡‘Î¼ (â‡‘f â»Â¹' {x})).to_real â€¢ g x)
{Î¹ : Type u_1} (I J : box_integral.box Î¹) (hJ : J â‰¤ I) (x : Î¹ â†’ â„) (h : x âˆˆ â‡‘box_integral.box.Icc I) : box_integral.tagged_prepartition I
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] (Î¼ : measure_theory.measure Î±) [Î¼.weakly_regular] (f : measure_theory.simple_func Î± nnreal) {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), â‡‘f x â‰¤ g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚Î¼ + Îµ
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} [normed_group E] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.strongly_measurable f) : measure_theory.strongly_measurable (Î» (y : Î²), âˆ« (x : Î±), f (x, y) âˆ‚Î¼)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) : lie_ideal R L
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {Î² : Type u_2} [complete_linear_order Î²] [densely_ordered Î²] [topological_space Î²] [order_topology Î²] [topological_space.second_countable_topology Î²] [measurable_space Î²] [borel_space Î²] (s : set Î²) (s_count : s.countable) (s_dense : dense s) (f : Î± â†’ Î²) (h : âˆ€ (p : Î²), p âˆˆ s â†’ âˆ€ (q : Î²), q âˆˆ s â†’ p < q â†’ (âˆƒ (u v : set Î±), measurable_set u âˆ§ measurable_set v âˆ§ {x : Î± | f x < p} âŠ† u âˆ§ {x : Î± | q < f x} âŠ† v âˆ§ â‡‘Î¼ (u âˆ© v) = 0)) : ae_measurable f Î¼
{V : Type u_1} [normed_group V] [nontrivial V] : âˆ¥normed_group_hom.id Vâˆ¥ = 1
{elab : bool := bool.tt} : expr elab â†’ option (name Ã— name Ã— expr elab)
(mod_nam : module_info.module_name) (decl : name) (cur_mod : string := "") : environment
{Î² : Type u_2} [topological_space Î²] {Î± : Type u_1} (p : Î± â†’ Prop) (e : Î± â†’ Î²) (x : {x // p x}) : {x // x âˆˆ closure (e '' {x : Î± | p x})}
(h : name) (t : option expr := option.none) (pr : expr) : tactic expr
{k : Type u} [comm_ring k] (G : Type u) [group G] {V : Type u} [add_comm_group V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] {W : Type u} [add_comm_group W] [module k W] [module (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (Ï€ : W â†’â‚—[k] V) [fintype G] : W â†’â‚—[k] V
(p : tactic.pattern) (e : expr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list level Ã— list expr)
(R : Type u) [semiring R] (Î¹ : Type v) [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] (N : Type uâ‚) [add_comm_monoid N] [module R N] (Ï† : Î  (i : Î¹), M i â†’â‚—[R] N) : direct_sum Î¹ (Î» (i : Î¹), M i) â†’â‚—[R] N
{k : Type u} [comm_ring k] {G : Type u} [group G] {V : Type u} [add_comm_group V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] {W : Type u} [add_comm_group W] [module k W] [module (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (Ï€ : W â†’â‚—[k] V) (g : G) : W â†’â‚—[k] V
(e : expr) (cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : tactic (list (name Ã— expr))
{C : Type uâ‚} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] {X Y : category_theory.forget_enrichment W C} (f : X âŸ¶ Y) : ğŸ™_ W âŸ¶ category_theory.enriched_category.hom (category_theory.forget_enrichment.to W X) (category_theory.forget_enrichment.to W Y)
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf' : dense_range f) (hf : continuous f) {s : set Î±} (hs : dense s) : dense (f '' s)
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : â„ â†’ E} {g : â„ â†’ F} {a b : â„} (l : filter â„) [l.ne_bot] [filter.tendsto_Ixx_class set.Icc l l] (hl : set.interval a b âˆˆ l) (hd : âˆ€á¶  (x : â„) in l, differentiable_at â„ f x) (hf : filter.tendsto (Î» (x : â„), âˆ¥f xâˆ¥) l filter.at_top) (hfg : deriv f =O[l] g) : Â¬interval_integrable g measure_theory.measure_space.volume a b
{Î± : Type u_1} (s : set Î±) (r : Î± â†’ Î± â†’ Prop) : pairwise (Î» (x y : â†¥s), r â†‘x â†‘y) â†’ s.pairwise r
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] (n : Ïƒ) : mv_polynomial Ïƒ R
{R : Type u_4} [normed_ring R] [complete_space R] (x : R) (h : âˆ¥xâˆ¥ < 1) : âˆ¥âˆ‘' (n : â„•), x ^ nâˆ¥ â‰¤ âˆ¥1âˆ¥ - 1 + (1 - âˆ¥xâˆ¥)â»Â¹
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : inducing f) {s : set Î±} : is_compact (f '' s) â†” is_compact s
{Ïƒ : Type u_1} {k : Type u_3} [field k] (Ï† : mv_power_series Ïƒ k) : mv_power_series Ïƒ k
{Î± : Type u_1} (F : Type u_6) (ğ•œ : Type u_11) [is_R_or_C ğ•œ] [normed_group F] [normed_space ğ•œ F] (m : measurable_space Î±) [measurable_space Î±] (p : ennreal) (Î¼ : measure_theory.measure Î±) : submodule ğ•œ â†¥(measure_theory.Lp F p Î¼)
{Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), add_zero_class (Î² i)] [Î  (i : Î¹) (x : Î² i), decidable (x â‰  0)] [add_comm_monoid Î³] (Ï† : Î  (i : Î¹), Î² i â†’+ Î³) (f : Î â‚€ (i : Î¹), Î² i) : â‡‘(dfinsupp.sum_add_hom Ï†) f = f.sum (Î» (x : Î¹), â‡‘(Ï† x))
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (Ïƒ : R â†’+* S) {Ïƒ' : S â†’+* R} [ring_hom_inv_pair Ïƒ Ïƒ'] [ring_hom_inv_pair Ïƒ' Ïƒ] (M : Type u_3) [topological_space M] [add_comm_monoid M] (Mâ‚‚ : Type u_4) [topological_space Mâ‚‚] [add_comm_monoid Mâ‚‚] [module R M] [module S Mâ‚‚] : Type (max u_3 u_4)
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] [category_theory.limits.has_zero_object V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] [category_theory.limits.has_zero_object W] (F : V â¥¤ W) [F.additive] (c : complex_shape Î¹) (j : Î¹) : homological_complex.single V c j â‹™ F.map_homological_complex c â‰… F â‹™ homological_complex.single W c j
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : measure_theory.signed_measure Î±} (t : measure_theory.signed_measure Î±) (f : Î± â†’ â„) (htÎ¼ : measure_theory.vector_measure.mutually_singular t Î¼.to_ennreal_vector_measure) (hadd : s = t + Î¼.with_densityáµ¥ f) : t = s.singular_part Î¼
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I J : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] (h : box_integral.integrable I l f vol) (hJ : J â‰¤ I) : box_integral.integrable J l f vol
(rbp : â„• := std.prec.max) (pat : bool := bool.ff) : lean.parser pexpr
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D E : homological_complex V c} (f : C âŸ¶ D) (hom : Î  (i j : Î¹), D.X i âŸ¶ E.X j) : f â‰« homotopy.null_homotopic_map hom = homotopy.null_homotopic_map (Î» (i j : Î¹), f.f i â‰« hom i j)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {x : M} {n : with_top â„•} : cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_diff_within_at ğ•œ n (written_in_ext_chart_at I I' x f) (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I) (â‡‘(ext_chart_at I x) x)
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s t u : set Î±} (hs : measurable_set s) (h's : s âŠ† u) (h't : t âŠ† u) (h : â‡‘Î¼ u < â‡‘Î¼ s + â‡‘Î¼ t) : (s âˆ© t).nonempty
{ğ•œâ‚‚ : Type u_2} {ğ•œâ‚ƒ : Type u_3} {F : Type u_6} {G : Type u_8} [normed_group F] [normed_group G] [nondiscrete_normed_field ğ•œâ‚‚] [nondiscrete_normed_field ğ•œâ‚ƒ] [normed_space ğ•œâ‚‚ F] [normed_space ğ•œâ‚ƒ G] {Ïƒâ‚‚â‚ƒ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ} {ğ•œâ‚‚' : Type u_10} [nondiscrete_normed_field ğ•œâ‚‚'] {F' : Type u_11} [normed_group F'] [normed_space ğ•œâ‚‚' F'] {Ïƒâ‚‚' : ğ•œâ‚‚' â†’+* ğ•œâ‚‚} {Ïƒâ‚‚'' : ğ•œâ‚‚ â†’+* ğ•œâ‚‚'} {Ïƒâ‚‚â‚ƒ' : ğ•œâ‚‚' â†’+* ğ•œâ‚ƒ} [ring_hom_inv_pair Ïƒâ‚‚' Ïƒâ‚‚''] [ring_hom_inv_pair Ïƒâ‚‚'' Ïƒâ‚‚'] [ring_hom_comp_triple Ïƒâ‚‚' Ïƒâ‚‚â‚ƒ Ïƒâ‚‚â‚ƒ'] [ring_hom_comp_triple Ïƒâ‚‚'' Ïƒâ‚‚â‚ƒ' Ïƒâ‚‚â‚ƒ] [ring_hom_isometric Ïƒâ‚‚â‚ƒ] [ring_hom_isometric Ïƒâ‚‚'] [ring_hom_isometric Ïƒâ‚‚''] [ring_hom_isometric Ïƒâ‚‚â‚ƒ'] (f : F â†’SL[Ïƒâ‚‚â‚ƒ] G) (g : F' â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚‚'] F) : âˆ¥f.comp g.to_linear_isometry.to_continuous_linear_mapâˆ¥ = âˆ¥fâˆ¥
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (I : ideal R) {Î¹ : Type u_1} (s : set Î¹) (f : Î¹ â†’ M) (x : M) (hx : x âˆˆ I â€¢ submodule.span R (f '' s)) : âˆƒ (a : â†¥s â†’â‚€ R) (ha : âˆ€ (i : â†¥s), â‡‘a i âˆˆ I), a.sum (Î» (i : â†¥s) (c : R), c â€¢ f â†‘i) = x
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) {r : â„} (hx : âˆ¥xâˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : hb.oangle y z = 2 â€¢ hb.oangle (y - x) (z - x)
{Î± : Type u_1} {Î² : Type u_2} {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] (f : Î± â†’ Î²) (hfm : measure_theory.ae_strongly_measurable' m f Î¼) : Î± â†’ Î²
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [category_theory.limits.has_wide_coequalizer f] [nonempty J] {W : C} {k l : category_theory.limits.wide_coequalizer f âŸ¶ W} (h : category_theory.limits.wide_coequalizer.Ï€ f â‰« k = category_theory.limits.wide_coequalizer.Ï€ f â‰« l) : k = l
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ğ•œ E] : (â¨† (Î¼ : ğ•œ), module.End.eigenspace T Î¼)á—® = âŠ¥
{Râ‚ Râ‚‚ : â„} {c z : â„‚} {f : â„‚ â†’ â„‚} (hd : differentiable_on â„‚ f (metric.ball c Râ‚)) (h_maps : set.maps_to f (metric.ball c Râ‚) (metric.ball (f c) Râ‚‚)) (hz : z âˆˆ metric.ball c Râ‚) : âˆ¥dslope f c zâˆ¥ â‰¤ Râ‚‚ / Râ‚
{R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] {s : set E} (hs : s.finite) : â‡‘(convex_hull R) s = â‡‘(finset.univ.sum (Î» (x : â†¥s), (linear_map.proj x).smul_right x.val)) '' std_simplex R â†¥s
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type wâ‚} [category_theory.category D] {E : Type wâ‚‚} [category_theory.category E] [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– E] (P : Cáµ’áµ– â¥¤ D) [Î  (F : D â¥¤ E) (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– F] [Î  (F : D â¥¤ E) (X : C) (W : J.cover X) (P : Cáµ’áµ– â¥¤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] : (category_theory.whiskering_left Cáµ’áµ– D E).obj (J.plus_obj P) â‰… (category_theory.whiskering_left Cáµ’áµ– D E).obj P â‹™ J.plus_functor E
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b : â„} {f : â„‚ â†’ E} (hd : diff_cont_on_cl â„‚ f (complex.re â»Â¹' set.Ioo a b)) (hB : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.im) filter.at_top âŠ“ filter.principal (complex.re â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.im|))) (ha : âˆ€ (z : â„‚), z.re = a â†’ f z = 0) (hb : âˆ€ (z : â„‚), z.re = b â†’ f z = 0) : set.eq_on f 0 (complex.re â»Â¹' set.Icc a b)
(F : Type u_17) {R : out_param (Type u_18)} {S : out_param (Type u_19)} [semiring R] [semiring S] (Ïƒ : out_param (R â†’+* S)) (M : out_param (Type u_20)) (Mâ‚‚ : out_param (Type u_21)) [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module S Mâ‚‚] : Type (max u_17 u_20 u_21)
{p : â„•+} {K : Type u} {L : Type v} {Î¶ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p} K L] [hp : fact (nat.prime â†‘p)] [ne_zero â†‘â†‘p] (hÎ¶ : is_primitive_root Î¶ â†‘p) (hirr : irreducible (polynomial.cyclotomic â†‘p K)) (hodd : p â‰  2) : algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p - 1) / 2) * â†‘p ^ (â†‘p - 2)
{E : Type u_4} {F : Type u_5} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] [finite_dimensional â„ F] {f : E â†’ F} {s t : set E} (h : cont_diff_on â„ 1 f s) (hc : convex â„ s) (ht : t âŠ† s) (htF : dimH t < â†‘(finite_dimensional.finrank â„ F)) : dense (f '' t)á¶œ
{Ïƒ : Type u_1} {R : Type u_2} [semiring R] (s : Ïƒ) : mv_power_series Ïƒ R
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g i) < s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â†” Â¬antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
{I : Type vâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {J : Type vâ‚} [category_theory.small_category J] {F : J â¥¤ Î  (i : I), C i} (c : Î  (i : I), category_theory.limits.cocone (F â‹™ category_theory.pi.eval C i)) : category_theory.limits.cocone F
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] [fintype Î¹] (I : box_integral.box Î¹) (l : box_integral.integration_params) (f : (Î¹ â†’ â„) â†’ E) (vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤) (y : F) : Prop
{R : Type u} [comm_semiring R] {I : ideal R} {f : polynomial R} : f âˆˆ ideal.map polynomial.C I â†” âˆ€ (n : â„•), f.coeff n âˆˆ I
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] (Îµ : C â‰Œ D) : category_theory.is_idempotent_complete C â†” category_theory.is_idempotent_complete D
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [compact_space M] : âˆƒ (n : â„•) (e : M â†’ euclidean_space â„ (fin n)), smooth I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e âˆ§ closed_embedding e âˆ§ âˆ€ (x : M), function.injective â‡‘(mfderiv I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e x)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) : Prop
{I : Type u} {fg : I â†’ Type v} [Î  (i : I), add_group (fg i)] {fp : I â†’ Type w} [T : Î  (i : I), add_torsor (fg i) (fp i)] : add_torsor (Î  (i : I), fg i) (Î  (i : I), fp i)
{Î± : Type u_1} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [metric_space E] {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} (hfg : measure_theory.tendsto_in_measure Î¼ f filter.at_top g) (n : â„•) : â„•
{p : â„•+} {k : â„•} {K : Type u} [field K] [char_zero K] {Î¶ : K} [hp : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ k} â„š K] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ k)) : algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = (-1) ^ ((â†‘p ^ k).totient / 2) * â†‘p ^ (â†‘p ^ (k - 1) * ((â†‘p - 1) * k - 1))
(x : string) {p q : Prop} (h : q â†’ p) : slim_check.test_result p â†’ (psum unit (p â†’ q) := psum.inl ()) â†’ slim_check.test_result q
{I : Type u} {f : I â†’ Type v} [decidable_eq I] [Î  (i : I), mul_one_class (f i)] : pairwise (Î» (i j : I), âˆ€ (x : f i) (y : f j), commute (pi.mul_single i x) (pi.mul_single j y))
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : filter Î±
{N : Type u_1} {G : Type u_2} [group N] [group G] {Ï† : G â†’* mul_aut N} : G â†’* N â‹Š[Ï†] G
{E : Type u_1} {F : Type u_2} {ğ•œ : Type u_3} {ğ•œâ‚‚ : Type u_4} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] {Î¹ : Type u_5} [complete_space E] {g : Î¹ â†’ (E â†’SL[Ïƒâ‚â‚‚] F)} (h : âˆ€ (x : E), âˆƒ (C : â„), âˆ€ (i : Î¹), âˆ¥â‡‘(g i) xâˆ¥ â‰¤ C) : âˆƒ (C' : â„), âˆ€ (i : Î¹), âˆ¥g iâˆ¥ â‰¤ C'
{W X Y Z S T : Top} (fâ‚ : W âŸ¶ S) (fâ‚‚ : X âŸ¶ S) (gâ‚ : Y âŸ¶ T) (gâ‚‚ : Z âŸ¶ T) {iâ‚ : W âŸ¶ Y} {iâ‚‚ : X âŸ¶ Z} (Hâ‚ : embedding â‡‘iâ‚) (Hâ‚‚ : embedding â‡‘iâ‚‚) (iâ‚ƒ : S âŸ¶ T) (eqâ‚ : fâ‚ â‰« iâ‚ƒ = iâ‚ â‰« gâ‚) (eqâ‚‚ : fâ‚‚ â‰« iâ‚ƒ = iâ‚‚ â‰« gâ‚‚) : embedding â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚)
{C : Type uâ‚} [category_theory.category C] {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z} (s : category_theory.comm_sq f g h i) : category_theory.limits.pullback_cone h i
{M : Type u_1} [comm_monoid M] (Î¶ : M) (k : â„•) : Prop
{n : â„•} {F : typevec (n + 1) â†’ Type u} [mvfunctor F] [q : mvqpf F] {Î± : typevec n} {Î² : Type u} (g : Î  {X : Type u}, (mvqpf.cofix F Î± â†’ X) â†’ (Î² â†’ X) â†’ Î² â†’ F (Î± ::: X)) (x : Î²) : mvqpf.cofix F Î±
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s : set Î²} {g : Î² â†’ Î±} (hg : set.inj_on g (s âˆ© function.mul_support (f âˆ˜ g))) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ g '' s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ s), f (g j)))
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} {s : finset Î¹} (hv : orthonormal ğ•œ v) : s.sum (Î» (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2) â‰¤ âˆ¥xâˆ¥ ^ 2
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.tagged_prepartition I) : Prop
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (Ïƒ : R â†’+* S) (M : Type u_3) (Mâ‚ƒ : Type u_4) [add_comm_monoid M] [add_comm_monoid Mâ‚ƒ] [module R M] [module S Mâ‚ƒ] (f : M â†’â‚›â‚—[Ïƒ] Mâ‚ƒ) : M â†’ Mâ‚ƒ
{Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), comm_ring (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’ G j) : Type (max v w)
{Î± : Type u_1} {m : measurable_space Î±} (s : measure_theory.signed_measure Î±) (Î¼ : measure_theory.measure Î±) : Prop
(Îµ : â„) (l : â„•) : â„•
{n : â„•} : â‡‘(0.succ_above) = fin.succ
{Î² : Type u_1} [comm_monoid Î²] (f : â„• â†’ Î²) (h_mult : âˆ€ (x y : â„•), x.coprime y â†’ f (x * y) = f x * f y) (hf0 : f 0 = 1) (hf1 : f 1 = 1) {n : â„•} : f n = n.factorization.prod (Î» (p k : â„•), f (p ^ k))
{n : â„•} {F : typevec n â†’ Type u} [mvfunctor F] [q : mvqpf F] {G : typevec n â†’ Type u} [mvfunctor G] {FG_abs : Î  {Î± : typevec n}, F Î± â†’ G Î±} {FG_repr : Î  {Î± : typevec n}, G Î± â†’ F Î±} (FG_abs_repr : âˆ€ {Î± : typevec n} (x : G Î±), FG_abs (FG_repr x) = x) (FG_abs_map : âˆ€ {Î± Î² : typevec n} (f : Î±.arrow Î²) (x : F Î±), FG_abs (mvfunctor.map f x) = mvfunctor.map f (FG_abs x)) : mvqpf G
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.mutually_singular Î¼) : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds 0)
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {f : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} {g : Î³ â†’ Î´} {f' : Î² â†’ Î±' â†’ Î´} {g' : Î± â†’ Î±'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' b (g' a)) : g '' set.image2 f s t = set.image2 f' t (g' '' s)
(Î± : Type u_1) (Î² : Î± â†’ Type u_2) (Î³ : Î  (a : Î±), Î² a â†’ Type u_3) [Î  (x : Î±) (y : Î² x), preorder (Î³ x y)] : (Î  (x : Î£ (a : Î±), Î² a), Î³ x.fst x.snd) â†’o Î  (a : Î±) (b : Î² a), Î³ a b
{f : â„ â†’ â„} {a b : â„} {Î¼ : measure_theory.measure â„} (hf : 0 â‰¤áµ[Î¼] f) (hfi : interval_integrable f Î¼ a b) : 0 < âˆ« (x : â„) in a..b, f x âˆ‚Î¼ â†” a < b âˆ§ 0 < â‡‘Î¼ (function.support f âˆ© set.Ioc a b)
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds a) (hfs : closure (f '' s) âˆˆ nhds (f a)) : continuous_at f a
{R : Type u} {Ïƒ : Type v} [comm_semiring R] (i : Ïƒ) : derivation R (mv_polynomial Ïƒ R) (mv_polynomial Ïƒ R)
{G : Type u_1} [measurable_space G] [has_mul G] [has_measurable_mul G] (Î¼ : measure_theory.measure G) : (âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), g * h) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_mul_left_invariant
{I : Type u} (f : I â†’ Type v) [Î  (i : I), non_assoc_semiring (f i)] (i : I) : (Î  (i : I), f i) â†’+* f i
{Î¹ : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Î¹ â†’ E} {g : Î¹ â†’ â„} {a : â„} (hg : has_sum g a) (h : âˆ€ (i : Î¹), âˆ¥f iâˆ¥ â‰¤ g i) : âˆ¥âˆ‘' (i : Î¹), f iâˆ¥ â‰¤ a
{Î± : Type u} {C : free_add_semigroup Î± â†’ Sort l} (x : free_add_semigroup Î±) (ih1 : Î  (x : Î±), C (has_pure.pure x)) (ih2 : Î  (x : Î±) (y : free_add_semigroup Î±), C (has_pure.pure x) â†’ C y â†’ C (has_pure.pure x + y)) : C x
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} {s : set ğ•œ} {x : ğ•œ} (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) : iterated_deriv_within n f s x = (Î» (g : ğ•œ â†’ F), deriv_within g s)^[n] f x
(Î± : Type u) (Î² : Type v) [group Î±] [mul_action Î± Î²] {Ï† : quotient (mul_action.orbit_rel Î± Î²) â†’ Î²} (hÏ† : function.right_inverse Ï† quotient.mk') : Î² â‰ƒ Î£ (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), â†¥(mul_action.orbit Î± (Ï† Ï‰))
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (g : E â†’ F) : measure_theory.integrable_on g (f '' s) Î¼ â†” measure_theory.integrable_on (Î» (x : E), |(f' x).det| â€¢ g (f x)) s Î¼
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] [measure_theory.is_finite_measure Î¼] (f : bounded_continuous_function Î± E) : continuous_map.to_ae_eq_fun Î¼ f.to_continuous_map âˆˆ measure_theory.Lp E p Î¼
{R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [h : algebra.finite_type R (monoid_algebra R M)] : âˆƒ (G : finset M), algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â†‘G) = âŠ¤
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.walking_parallel_pair â¥¤ C
{X : Top} {T : â†¥X â†’ Type v} (P : Top.local_predicate T) (x : â†¥X) (w : âˆ€ (U V : topological_space.open_nhds x) (fU : Î  (y : â†¥(U.val)), T â†‘y), P.to_prelocal_predicate.pred fU â†’ âˆ€ (fV : Î  (y : â†¥(V.val)), T â†‘y), P.to_prelocal_predicate.pred fV â†’ fU âŸ¨x, _âŸ© = fV âŸ¨x, _âŸ© â†’ (âˆƒ (W : topological_space.open_nhds x) (iU : W âŸ¶ U) (iV : W âŸ¶ V), âˆ€ (w : â†¥(W.val)), fU (â‡‘iU w) = fV (â‡‘iV w))) : function.injective (Top.stalk_to_fiber P x)
{R : Type u_1} [semiring R] [nontrivial R] : 1.order = 0
{elab : bool := bool.tt} : expr elab â†’ option level
{Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) : âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ s â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
(e : expr) (include_goal : bool := bool.tt) : tactic expr
{M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} {Î± : Type u_3} [preorder Î±] [preorder N] {f : N â†’ Î±} [covariant_class M N Î¼ has_le.le] (hf : monotone f) (m : M) : monotone (Î» (n : N), f (Î¼ m n))
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} {s : category_theory.limits.cofork f g} (hs : category_theory.limits.is_colimit s) {W : C} (k : Y âŸ¶ W) (h : f â‰« k = g â‰« k) : {l // s.Ï€ â‰« l = k}
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {s : set Î±} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : â‡‘(Î¼.with_density (v.lim_ratio_meas hÏ)) s â‰¤ â†‘t ^ 2 * â‡‘Ï s
{Î± : Type u} {C : free_magma Î± â†’ Sort l} (x : free_magma Î±) (ih1 : Î  (x : Î±), C (free_magma.of x)) (ih2 : Î  (x y : free_magma Î±), C x â†’ C y â†’ C (x * y)) : C x
{C : Type uâ‚} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] (X : category_theory.forget_enrichment W C) : C
{n : â„•} {F : typevec n â†’ Type u} (R : Î  â¦ƒÎ± : typevec nâ¦„, F Î± â†’ F Î± â†’ Prop) [mvfunctor F] (Hfunc : âˆ€ â¦ƒÎ± Î² : typevec nâ¦„ (a b : F Î±) (f : Î±.arrow Î²), R a b â†’ R (mvfunctor.map f a) (mvfunctor.map f b)) â¦ƒÎ± Î² : typevec nâ¦„ (f : Î±.arrow Î²) : mvqpf.quot1 R Î± â†’ mvqpf.quot1 R Î²
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (Î¼ : R) : submodule R M
{Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (f : bounded_continuous_function Î± Î²) : âˆ¥fâˆ¥ = has_Inf.Inf {C : â„ | 0 â‰¤ C âˆ§ âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C}
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] (s : set Î±) : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, filter.tendsto (Î» (a : set Î±), â‡‘Î¼ (s âˆ© a) / â‡‘Î¼ a) (v.filter_at x) (nhds 1)
{V : Type uâ‚} [quiver V] {W : Type uâ‚‚} [quiver W] (F : prefunctor V W) {a b : V} : quiver.path a b â†’ quiver.path (F.obj a) (F.obj b)
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : f' =o[l] g' â†’ ((Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
{Î¹ : Type u_1} {R : Type u_2} {M : Î¹ â†’ Type u_4} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] [add_comm_monoid N] [module R N] â¦ƒÏ† Ïˆ : (Î â‚€ (i : Î¹), M i) â†’â‚—[R] Nâ¦„ (h : âˆ€ (i : Î¹), Ï†.comp (dfinsupp.lsingle i) = Ïˆ.comp (dfinsupp.lsingle i)) : Ï† = Ïˆ
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {m n : with_top â„•} (hf : cont_mdiff I I' n f) (hmn : m + 1 â‰¤ n) : cont_mdiff I.tangent I'.tangent m (tangent_map I I' f)
(step : expr â†’ tactic (expr Ã— expr)) (no_dflt : bool := bool.ff) (hs : list tactic.simp_arg_type := list.nil) (attr_names : list name := list.nil) : expr â†’ tactic (expr Ã— expr)
{ğ•œ : Type u} {Î¹ : Type v} {Î¹' : Type v'} {E : Î¹ â†’ Type wE} {E' : Î¹' â†’ Type wE'} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [decidable_eq Î¹'] [fintype Î¹'] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [Î  (i : Î¹'), normed_group (E' i)] [Î  (i : Î¹'), normed_space ğ•œ (E' i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E (multilinear_map ğ•œ E' G)) (C : â„) (H : âˆ€ (mâ‚ : Î  (i : Î¹), E i) (mâ‚‚ : Î  (i : Î¹'), E' i), âˆ¥â‡‘(â‡‘f mâ‚) mâ‚‚âˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥mâ‚ iâˆ¥) * finset.univ.prod (Î» (i : Î¹'), âˆ¥mâ‚‚ iâˆ¥)) : continuous_multilinear_map ğ•œ E (continuous_multilinear_map ğ•œ E' G)
{R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring Sâ‚] {f : R â†’+* Sâ‚} {g : Sâ‚ â†’+* R} (hf : function.left_inverse â‡‘f â‡‘g) : function.left_inverse â‡‘(mv_polynomial.map f) â‡‘(mv_polynomial.map g)
{G : Type u_1} [hG : group G] [hf : fintype G] : [group.is_nilpotent G, normalizer_condition G, âˆ€ (H : subgroup G), is_coatom H â†’ H.normal, âˆ€ (p : â„•), fact (nat.prime p) â†’ âˆ€ (P : sylow p G), â†‘P.normal, nonempty ((Î  (p : â†¥((fintype.card G).factorization.support)) (P : sylow â†‘p G), â†¥â†‘P) â‰ƒ* G)].tfae
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [complete_space F] {T : set Î± â†’ (E â†’L[â„] F)} {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) {Î¹ : Type u_4} {l : filter Î¹} [l.is_countably_generated] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„) (hfs_meas : âˆ€á¶  (n : Î¹) in l, measure_theory.ae_strongly_measurable (fs n) Î¼) (h_bound : âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ¥fs n aâˆ¥ â‰¤ bound a) (bound_integrable : measure_theory.integrable bound Î¼) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : Î¹), fs n a) l (nhds (f a))) : filter.tendsto (Î» (n : Î¹), measure_theory.set_to_fun Î¼ T hT (fs n)) l (nhds (measure_theory.set_to_fun Î¼ T hT f))
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] (m : measurable_space Î±) {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : Î± â†’ F') : Î± â†’ F'
{Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), comm_ring (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’ G j) (i : Î¹) : G i â†’+* ring.direct_limit G f
{C : Type u} [category_theory.category C] (â„¬ : Î  (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) (X Y : C) : C
{Î± : Type u} [pseudo_emetric_space Î±] {Î² : Type u_1} {p : Î² â†’ Prop} {f : Î² â†’ ennreal} (hfâ‚€ : âˆ€ (x : Î²), p x â†’ 0 < f x) (hf : âˆ€ (Îµ : ennreal), 0 < Îµ â†’ (âˆƒ (x : Î²) (hx : p x), f x â‰¤ Îµ)) : (uniformity Î±).has_basis p (Î» (x : Î²), {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < f x})
{Î± : Type u_1} {m0 : measurable_space Î±} [topological_space Î±] (Î¼ : measure_theory.measure Î±) : Prop
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) {iâ‚ iâ‚‚ : fin (n + 1)} (h : iâ‚ â‰  iâ‚‚) : â‡‘(euclidean_geometry.reflection (affine_span â„ (s.points '' {iâ‚, iâ‚‚}))) s.circumcenter = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.reflection_circumcenter_weights_with_circumcenter iâ‚ iâ‚‚)
{elab : bool} : has_coe_to_fun (expr elab) (Î» (e : expr elab), expr elab â†’ expr elab)
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} {g : E â†’ â„} (hg : convex_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) (hgi : measure_theory.integrable_on (g âˆ˜ f) t Î¼) : g (â¨ (x : Î±) in t, f x âˆ‚Î¼) â‰¤ â¨ (x : Î±) in t, g (f x) âˆ‚Î¼
{Ïƒ : Type u_1} (f : Ïƒ â†’ option Ïƒ) (a b : Ïƒ) (c : option Ïƒ) (hâ‚ : turing.evals_to f a â†‘b) (hâ‚‚ : turing.evals_to f b c) : turing.evals_to f a c
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : is_R_or_C.abs (has_inner.inner x y / (â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥)) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : ğ•œ), r â‰  0 âˆ§ y = r â€¢ x
{R : Type u_1} {S : Type u_2} (L : Type u_4) [euclidean_domain R] [comm_ring S] [is_domain S] [field L] [algRL : algebra R L] [algebra R S] [algebra S L] [ist : is_scalar_tower R S L] [iic : is_integral_closure S R L] {abv : absolute_value R â„¤} {Î¹ : Type u_5} [decidable_eq Î¹] [fintype Î¹] (bS : basis Î¹ R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] [is_dedekind_domain S] [is_fraction_ring S L] (h : algebra.is_algebraic R L) (I : â†¥(non_zero_divisors (ideal S))) : âˆƒ (J : â†¥(non_zero_divisors (ideal S))), â‡‘(class_group.mk0 L) I = â‡‘(class_group.mk0 L) J âˆ§ â‡‘(algebra_map R S) ((class_group.finset_approx bS adm).prod (Î» (m : R), m)) âˆˆ â†‘J
{K : Type u_1} [decidable_eq K] (Î“ : K â†’ Type u_2) (Î› : Type u_3) (Ïƒ : Type u_4) : Type (max u_1 u_2 u_3 u_4)
(G : Type u_1) {Î± : Type u_3} {m : measurable_space Î±} [group G] [mul_action G Î±] [measurable_space G] [has_measurable_smul G Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.smul_invariant_measure G Î± Î¼] [topological_space Î±] [has_continuous_const_smul G Î±] [mul_action.is_minimal G Î±] {K U : set Î±} (hK : is_compact K) (hÎ¼K : â‡‘Î¼ K â‰  0) (hU : is_open U) (hne : U.nonempty) : 0 < â‡‘Î¼ U
{R : Type u} {L : Type v} {L' : Type wâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L â†’â‚—â…Râ† L') (I : lie_ideal R L) : lie_ideal R L'
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : Î  (n : â„•) (x : A), x âˆˆ M ^ n â†’ Prop} (hr : âˆ€ (r : R), C 0 (â‡‘(algebra_map R A) r) _) (hadd : âˆ€ (x y : A) (i : â„•) (hx : x âˆˆ M ^ i) (hy : y âˆˆ M ^ i), C i x hx â†’ C i y hy â†’ C i (x + y) _) (hmul : âˆ€ (m : A) (H : m âˆˆ M) (i : â„•) (x : A) (hx : x âˆˆ M ^ i), C i x hx â†’ C i.succ (m * x) _) {x : A} {n : â„•} (hx : x âˆˆ M ^ n) : C n x hx
{n : â„•+} (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [is_cyclotomic_extension {n} K L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) : power_basis K L
{M : Type u_1} [comm_monoid M] (Î¶ : M) {n : â„•+} (h : Î¶ ^ â†‘n = 1) : â†¥(roots_of_unity n M)
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {p q : â„} (hpq : p.is_conjugate_exponent q) {f g : Î± â†’ nnreal} (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) : âˆ«â» (a : Î±), â†‘((f * g) a) âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), â†‘(f a) ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), â†‘(g a) ^ q âˆ‚Î¼) ^ (1 / q)
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] (Ï† : A â†’â‚[R] B) : subalgebra R B
{Î± : Type u} [pseudo_emetric_space Î±] (E : set Î±) (s : set â„) (hs : âˆ€ (Îµ : â„), 0 < Îµ â†’ (s âˆ© set.Ioc 0 Îµ).nonempty) : closure E = â‹‚ (Î´ : â„) (H : Î´ âˆˆ s), metric.cthickening Î´ E
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] (f : Î± Ã— Î² â†’ ennreal) (hf : measurable f) : âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
{Î± : Type u} [t : topological_space Î±] [topological_space.first_countable_topology Î±] {u : â„• â†’ Î±} {x : Î±} (hx : map_cluster_pt x filter.at_top u) : âˆƒ (Ïˆ : â„• â†’ â„•), strict_mono Ïˆ âˆ§ filter.tendsto (u âˆ˜ Ïˆ) filter.at_top (nhds x)
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] (Î¼ : measure_theory.measure Î±) : Prop
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” monovary (f âˆ˜ â‡‘Ïƒ) g
{Î± : Type u_1} {ğ•œ : Type u_2} [linear_ordered_field ğ•œ] [decidable_eq Î±] {A : finset Î±} (P : finpartition A) (G : simple_graph Î±) [decidable_rel G.adj] (Îµ : ğ•œ) (s : finset Î±) : finset (finset Î±)
{ğ•œ : Type u_1} {V : Type u_2} {W : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group V] [normed_space ğ•œ V] [normed_group W] [normed_space ğ•œ W] {n : with_top â„•} (f : V â†’A[ğ•œ] W) : cont_diff ğ•œ n â‡‘f
(R : Type u_1) {V : Type u_2} {W : Type u_3} (P : Type u_4) (Q : Type u_5) [ring R] [add_comm_group V] [module R V] [topological_space P] [add_torsor V P] [add_comm_group W] [module R W] [topological_space Q] [add_torsor W Q] : Type (max u_2 u_3 u_4 u_5)
{X : â„• â†’ Type u} [Î  (n : â„•), metric_space (X n)] {f : Î  (n : â„•), X n â†’ X (n + 1)} (I : âˆ€ (n : â„•), isometry (f n)) (n : â„•) (x : X n) : metric.inductive_limit I
{R : Type u} {Î¹ : Type x} [semiring R] {Ï† : Î¹ â†’ Type u_1} [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] (I : set Î¹) (p : Î  (i : Î¹), submodule R (Ï† i)) : submodule R (Î  (i : Î¹), Ï† i)
(R : Type u) [ring R] (Î¹ : Type v) [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) {P : Type uâ‚} [add_comm_group P] [module R P] (g : Î  (i : Î¹), G i â†’â‚—[R] P) (Hg : âˆ€ (i j : Î¹) (hij : i â‰¤ j) (x : G i), â‡‘(g j) (â‡‘(f i j hij) x) = â‡‘(g i) x) : module.direct_limit G f â†’â‚—[R] P
{X : â„• â†’ Type u} [Î  (n : â„•), metric_space (X n)] {f : Î  (n : â„•), X n â†’ X (n + 1)} (I : âˆ€ (n : â„•), isometry (f n)) (x y : Î£ (n : â„•), X n) (m : â„•) (hx : x.fst â‰¤ m) (hy : y.fst â‰¤ m) : metric.inductive_limit_dist f x y = has_dist.dist (nat.le_rec_on hx f x.snd) (nat.le_rec_on hy f y.snd)
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) (hx0 : x â‰  0) (hy0 : y â‰  0) : is_R_or_C.abs (has_inner.inner x y) = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆƒ (r : ğ•œ), r â‰  0 âˆ§ y = r â€¢ x
{Î± : Type u} {Ïƒ : Type v} (M : DFA Î± Ïƒ) : list Î± â†’ Ïƒ
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} (S : J.cover X) (T : Î  (I : S.arrow), J.cover I.Y) : J.cover X
{Ïƒ : Type u_1} {Ï„ : Type u_2} {R : Type u_4} [comm_semiring R] (f : Ïƒ â†’ Ï„) : mv_polynomial Ïƒ R â†’â‚[R] mv_polynomial Ï„ R
{C : Type u} [category_theory.category C] {W X Y Z : C} [category_theory.limits.has_binary_product W X] [category_theory.limits.has_binary_product Y Z] (f : W â‰… Y) (g : X â‰… Z) : W â¨¯ X â‰… Y â¨¯ Z
(Îµ Îµ' : out_param (Type u)) (m m' : Type u â†’ Type v) : Type (max (u+1) v)
{G : Type u_1} {Î± : Type u_2} [group G] [mul_action G Î±] [measurable_space Î±] {s : set Î±} {Î¼ : measure_theory.measure Î±} [measurable_space G] [has_measurable_smul G Î±] [measure_theory.smul_invariant_measure G Î± Î¼] [encodable G] (hs : measure_theory.is_fundamental_domain G s Î¼) {f : Î± â†’ ennreal} (hf : âˆ€ (Î³ : G) (x : Î±), f (Î³ â€¢ x) = f x) : ess_sup f (Î¼.restrict s) = ess_sup f Î¼
{Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {Îµ : nnreal} : emetric.closed_ball x â†‘Îµ = metric.closed_ball x â†‘Îµ
{k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [monoid G] {V : Type u_2} [add_comm_monoid V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] (W : submodule k V) (h : âˆ€ (g : G) (v : V), v âˆˆ W â†’ â‡‘(monoid_algebra.of k G) g â€¢ v âˆˆ W) : submodule (monoid_algebra k G) V
{Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {Î¹ : Type u_2} {X : Î¹ â†’ Î© â†’ â„} {s : finset Î¹} (hs : âˆ€ (i : Î¹), i âˆˆ s â†’ measure_theory.mem_â„’p (X i) 2 measure_theory.measure_space.volume) (h : â†‘s.pairwise (Î» (i j : Î¹), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) : probability_theory.variance (s.sum (Î» (i : Î¹), X i)) measure_theory.measure_space.volume = s.sum (Î» (i : Î¹), probability_theory.variance (X i) measure_theory.measure_space.volume)
(M : Type u_1) (N : Type u_2) (Î¼ : M â†’ N â†’ N) (r : N â†’ N â†’ Prop) : Prop
{M : Type u_1} [mul_one_class M] (N : submonoid (M Ã— M)) (H : equivalence (Î» (x y : M), (x, y) âˆˆ N)) : con M
{n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] : primitive_roots n K âŠ† (polynomial.map (int.cast_ring_hom K) (minpoly â„¤ Î¼)).roots.to_finset
{Î¹ : Type u_1} [fintype Î¹] (l : box_integral.integration_params) (I : box_integral.box Î¹) (Ï€â‚€ : box_integral.prepartition I) : filter (box_integral.tagged_prepartition I)
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [has_measurable_inv G] [Î½.is_mul_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.fst, (z.fst)â»Â¹ * z.snd)) (Î¼.prod Î½) = Î¼.prod Î½
{V : Type u_1} [inner_product_space â„ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b p q : P} (hp : âˆƒ (k : â„), k â‰  1 âˆ§ b -áµ¥ p = k â€¢ (a -áµ¥ p)) (hq : has_dist.dist a q = has_dist.dist b q) : has_dist.dist a p * has_dist.dist b p = |has_dist.dist b q ^ 2 - has_dist.dist p q ^ 2|
{K : Type u_1} [decidable_eq K] (Î“ : K â†’ Type u_2) (Î› : Type u_3) (Ïƒ : Type u_4) : Type (max u_1 u_2 u_3 u_4)
{Î± : Type u} {Ïƒ : Type v} (M : NFA Î± Ïƒ) : list Î± â†’ set Ïƒ
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} {Ï€ : box_integral.tagged_prepartition I} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {c : nnreal} {Îµ : â„} [complete_space F] (h : box_integral.integrable I l f vol) (h0 : 0 < Îµ) (hÏ€ : l.mem_base_set I c (h.convergence_r Îµ c) Ï€) {Ï€â‚€ : box_integral.prepartition I} (hU : Ï€.Union = Ï€â‚€.Union) : has_dist.dist (box_integral.integral_sum f vol Ï€) (Ï€â‚€.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)) â‰¤ Îµ
{n : â„•} (i : fin2 n) â¦ƒÎ± : typevec nâ¦„ : mvqpf.prj i Î± â†’ (mvqpf.prj.P i).obj Î±
{R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), add_comm_monoid (Mâ‚' i)] [Î  (i : Î¹), module R (Mâ‚' i)] (f : Î  (i : Î¹), Mâ‚ i â†’â‚—[R] Mâ‚' i) : 0.comp_linear_map f = 0
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (F : Type u_5) [normed_group F] [normed_space ğ•œ F] : Type (max u_3 u_4 u_5)
{E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y : E} : same_ray â„ x y â†” âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{R : Type u_1} [comm_ring R] {I J : ideal R} {x : R} : â‡‘(ideal.quotient.mk I) x âˆˆ ideal.map (ideal.quotient.mk I) J â†” x âˆˆ J âŠ” I
{M : Type u_1} [has_mul M] {S : set (con M)} : has_Sup.Sup S = con_gen (has_Sup.Sup (coe_fn '' S))
{J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) {W : C} {f f' : t.X âŸ¶ W} (w : âˆ€ (j : J), t.Î¹.app j â‰« f = t.Î¹.app j â‰« f') : f = f'
{V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type wâ‚} [category_theory.category D] {E : Type wâ‚‚} [category_theory.category E] {F : D â¥¤ E} {G : E â¥¤ D} [Î  (X : C) (S : J.cover X) (P : Cáµ’áµ– â¥¤ D), category_theory.limits.preserves_limit (S.index P).multicospan F] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (adj : G âŠ£ F) (X : category_theory.Sheaf J E) (Y : category_theory.Sheaf J D) : ((category_theory.Sheaf.compose_and_sheafify J G).obj X âŸ¶ Y) â‰ƒ (X âŸ¶ (category_theory.Sheaf_compose J F).obj Y)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {n : with_top â„•} {e : local_homeomorph M H} (h : e âˆˆ smooth_manifold_with_corners.maximal_atlas I M) : cont_mdiff_on I I n â‡‘e e.to_local_equiv.source
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurable_space Î±} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] {Î¼ : measure_theory.measure Î±} (hf : measure_theory.strongly_measurable f) : ae_measurable f Î¼
{R : Type u} [comm_ring R] (I J : ideal R) : (R â§¸ I) â§¸ ideal.map (ideal.quotient.mk I) J â‰ƒ+* R â§¸ I âŠ” J
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : Prop
{K : Type u_1} [comm_ring K] [is_domain K] {Î¶ : K} {n : â„•} (h : is_primitive_root Î¶ n) : âˆƒ (P : polynomial â„¤), polynomial.map (int.cast_ring_hom K) P = polynomial.cyclotomic' n K âˆ§ P.degree = (polynomial.cyclotomic' n K).degree âˆ§ P.monic
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {Îµ : Type u_5} {Î¶ : Type u_6} (f : Î± â†’ Î²) (f' : Î³ â†’ Î´) (g : Î² â†’ Îµ) (g' : Î´ â†’ Î¶) (x : Î± Ã— Î³) : prod.map g g' (prod.map f f' x) = prod.map (g âˆ˜ f) (g' âˆ˜ f') x
{C : Type u} [category_theory.category C] {X Y : C} {J : category_theory.grothendieck_topology C} {f : Y âŸ¶ X} {S : J.cover X} (I : (S.pullback f).arrow) : S.arrow
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M â†’ M') (s : set M) (x : M) : tangent_space I x â†’L[ğ•œ] tangent_space I' (f x)
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] [fintype Î¹] (I : box_integral.box Î¹) (l : box_integral.integration_params) (f : (Î¹ â†’ â„) â†’ E) (vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤) : Prop
{F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
{n : â„•} {F : typevec n â†’ Type u} (R : Î  â¦ƒÎ± : typevec nâ¦„, F Î± â†’ F Î± â†’ Prop) [mvfunctor F] [q : mvqpf F] (Hfunc : âˆ€ â¦ƒÎ± Î² : typevec nâ¦„ (a b : F Î±) (f : Î±.arrow Î²), R a b â†’ R (mvfunctor.map f a) (mvfunctor.map f b)) : mvqpf (mvqpf.quot1 R)
{Î² : Type w} {C : Type u} [category_theory.category C] {Î³ : Type v} (Îµ : Î² â‰ƒ Î³) (f : Î³ â†’ C) [category_theory.limits.has_coproduct f] [category_theory.limits.has_coproduct (f âˆ˜ â‡‘Îµ)] : âˆ f âˆ˜ â‡‘Îµ â‰… âˆ f
{Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {X Y : Î± â†’ â„} (hXY : probability_theory.indep_fun X Y Î¼) (hXp : 0 â‰¤ X) (hYp : 0 â‰¤ Y) (hXm : ae_measurable X Î¼) (hYm : ae_measurable Y Î¼) : measure_theory.integral Î¼ (X * Y) = measure_theory.integral Î¼ X * measure_theory.integral Î¼ Y
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} {g : E â†’ â„} (hg : convex_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) (hgi : measure_theory.integrable_on (g âˆ˜ f) t Î¼) : (â¨ (x : Î±) in t, f x âˆ‚Î¼, â¨ (x : Î±) in t, g (f x) âˆ‚Î¼) âˆˆ {p : E Ã— â„ | p.fst âˆˆ s âˆ§ g p.fst â‰¤ p.snd}
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] (C : ennreal) {f : Î± â†’ ennreal} (hf_meas : ae_measurable f Î¼) (hf : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰  âŠ¤ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ â‰¤ C) : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
(Î¹ : Type u_3) (M : Type u_4) [add_comm_monoid M] (I : with_top (box_integral.box Î¹)) : Type (max u_3 u_4)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) {Iâ‚ Iâ‚‚ : lie_ideal R L} (hâ‚ : Iâ‚ â‰¤ I) (hâ‚‚ : Iâ‚‚ â‰¤ I) : â…lie_ideal.comap I.incl Iâ‚,lie_ideal.comap I.incl Iâ‚‚â† = lie_ideal.comap I.incl â…Iâ‚,Iâ‚‚â†
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (W : subspace K V) : (module.dual K V â§¸ W.dual_lift.range) â‰ƒâ‚—[K] â†¥(submodule.dual_annihilator W)
{Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_3} {l : filter Î¹} [l.is_countably_generated] {F : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„) (hF_meas : âˆ€á¶  (n : Î¹) in l, measure_theory.ae_strongly_measurable (F n) Î¼) (h_bound : âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ¥F n aâˆ¥ â‰¤ bound a) (bound_integrable : measure_theory.integrable bound Î¼) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : Î¹), F n a) l (nhds (f a))) : filter.tendsto (Î» (n : Î¹), âˆ« (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ« (a : Î±), f a âˆ‚Î¼))
{R : Type u_1} [semiring R] (I : ideal R) : Prop
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) (s : set Î±) : metric.diam (f '' s) = metric.diam s
{Ïƒ : Type u_1} (n : â„•) (Ï† : mv_polynomial Ïƒ â„¤) : â‡‘mv_polynomial.C â†‘n âˆ£ Ï† â†” â‡‘(mv_polynomial.map (int.cast_ring_hom (zmod n))) Ï† = 0
{Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (set.Icc a b)) : set.Icc (f a) (f b) âŠ† f '' set.Icc a b
{Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {s : set Î±} {t : set Î²} {f : Î± â†’ Î²' â†’ Î³} {g : Î² â†’ Î²'} {f' : Î± â†’ Î² â†’ Î´} {g' : Î´ â†’ Î³} (h_right_comm : âˆ€ (a : Î±) (b : Î²), f a (g b) = g' (f' a b)) : set.image2 f s (g '' t) = g' '' set.image2 f' s t
{C : nonote â†’ Sort u_1} (o : nonote) (H0 : C 0) (H1 : Î  (e : nonote) (n : â„•+) (a : nonote) (h : a.below e), C e â†’ C a â†’ C (e.oadd n a h)) : C o
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) {p : submodule R M} (hfp : âˆ€ (x : M), x âˆˆ p â†’ â‡‘f x âˆˆ p) (Î¼ : R) : submodule.map p.subtype (module.End.eigenspace (linear_map.restrict f hfp) Î¼) â‰¤ f.eigenspace Î¼
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} (hf : filter.tendsto f l (nhds 0)) (hg : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ g)) (op : E â†’ F â†’ G) (h_op : âˆ€ (x : E) (y : F), âˆ¥op x yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥) : filter.tendsto (Î» (x : Î±), op (f x) (g x)) l (nhds 0)
{E : Type u} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {f' : E} {x r : â„} (hf : has_deriv_within_at f f' (set.Ici x) x) (hr : âˆ¥f'âˆ¥ < r) : âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), (z - x)â»Â¹ * (âˆ¥f zâˆ¥ - âˆ¥f xâˆ¥) < r
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (F : Type u_5) [normed_group F] [normed_space ğ•œ F] : basic_smooth_vector_bundle_core I M F
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic unit
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : (Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] g â†’ f' =O[l] g
{G : Type u_1} [group G] {H : subgroup G} {R S : set G} (hR : R âˆˆ subgroup.right_transversals â†‘H) (hR1 : 1 âˆˆ R) (hS : subgroup.closure S = âŠ¤) : subgroup.closure ((Î» (g : G), g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹) '' (R * S)) = H
{Î± : Type u} [pseudo_metric_space Î±] (H : âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (s : set Î±), s.countable âˆ§ âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), has_dist.dist x y â‰¤ Îµ)) : topological_space.second_countable_topology Î±
(generate_ihs : bool) (major_premise : expr) (gm : tactic.eliminate.generalization_mode := tactic.eliminate.generalization_mode.generalize_all_except list.nil) (with_patterns : list tactic.eliminate.with_pattern := list.nil) : tactic unit
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} (hm : m â‰¤ m0) (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite (Î¼.trim hm)] : â†¥(measure_theory.Lp F' 1 Î¼) â†’L[â„] â†¥(measure_theory.Lp F' 1 Î¼)
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : Î± â‰ƒâ‚œ Î²) (s : set Î±) : â†¥s â‰ƒâ‚œ â†¥(â‡‘e '' s)
{Ïƒ : Type u_1} {R : Type u_3} [comm_semiring R] : set_like.graded_monoid (mv_polynomial.homogeneous_submodule Ïƒ R)
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hs : convex â„ s) (h0 : â‡‘Î¼ t â‰  0) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (ht : â¨ (x : Î±) in t, f x âˆ‚Î¼ âˆˆ interior s) : â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ interior s
{Î¹a : Type u_7} {Î¹b : Type u_8} [decidable_eq Î¹a] [decidable_eq Î¹b] [fintype Î¹a] [fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [comm_semiring R'] [add_comm_group Nâ‚] [module R' Nâ‚] [add_comm_group Nâ‚‚] [module R' Nâ‚‚] [add_comm_monoid Máµ¢] [module R' Máµ¢] (a : alternating_map R' Máµ¢ Nâ‚ Î¹a) (b : alternating_map R' Máµ¢ Nâ‚‚ Î¹b) (Ïƒ : equiv.perm.mod_sum_congr Î¹a Î¹b) {v : Î¹a âŠ• Î¹b â†’ Máµ¢} {i j : Î¹a âŠ• Î¹b} (hv : v i = v j) (hij : i â‰  j) : equiv.swap i j â€¢ Ïƒ = Ïƒ â†’ â‡‘(alternating_map.dom_coprod.summand a b Ïƒ) v = 0
{I : Type u_1} {A : Type u_2} {X : I â†’ Type u_3} [Î  (i : I), topological_space (X i)] [topological_space A] {f g : Î  (i : I), C(A, X i)} (homotopies : Î  (i : I), (f i).homotopy (g i)) : (continuous_map.pi f).homotopy (continuous_map.pi g)
{n : â„•} {C : typevec (n + 1) â†’ Sort u} (H : Î  (Î± : typevec n) (Î² : Type u_1), C (Î± ::: Î²)) (Î³ : typevec (n + 1)) : C Î³
{ğ•œ : Type u_1} {E : Type u_3} [linear_ordered_field ğ•œ] [topological_space E] [add_comm_group E] [module ğ•œ E] {s : set E} : strict_convex ğ•œ s â†” s.pairwise (Î» (x y : E), âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ interior s)
{K : Type u_1} [comm_ring K] [is_domain K] {Î¶ : K} {n : â„•} (hz : is_primitive_root Î¶ n) : polynomial.cyclotomic n K = (primitive_roots n K).prod (Î» (Î¼ : K), polynomial.X - â‡‘polynomial.C Î¼)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) {s : set Î¹} {i : Î¹} (hi : i âˆˆ s) : vector_span k (p '' s) = submodule.span k (has_vsub.vsub (p i) '' (p '' (s  {i})))
{A : Type u_1} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module â„‚ A] [nontrivial A] (a : â†¥(self_adjoint A)) : spectrum â„‚ â†‘a = coe âˆ˜ complex.re '' spectrum â„‚ â†‘a
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] {S : set (add_monoid_algebra R M)} (hS : algebra.adjoin R S = âŠ¤) : algebra.adjoin R (â‹ƒ (f : add_monoid_algebra R M) (H : f âˆˆ S), add_monoid_algebra.of' R M '' â†‘(f.support)) = âŠ¤
{R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] â¦ƒj k : S â†’+* Pâ¦„ (h : j.comp (algebra_map R S) = k.comp (algebra_map R S)) : j = k
{R : Type u_1} {n : â„•} [comm_ring R] [is_domain R] (hpos : 0 < n) {Î¼ : R} (h : is_primitive_root Î¼ n) : (polynomial.cyclotomic n R).is_root Î¼
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ s : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : measurable f) (hs : s.mutually_singular Î½) (hadd : Î¼ = s + Î½.with_density f) : s = Î¼.singular_part Î½
{r : â„} (hr : |r| < 1) : filter.tendsto (Î» (n : â„•), â†‘n * r ^ n) filter.at_top (nhds 0)
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] {L : Type u_3} {W : Type u_4} [field L] [add_comm_group W] [module L W] {Ïƒ : K â†’+* L} (f : V â†’â‚›â‚—[Ïƒ] W) (hf : function.injective â‡‘f) : â„™ K V â†’ â„™ L W
{Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {s : set Î±} {t : set Î²} {f : Î±' â†’ Î² â†’ Î³} {g : Î± â†’ Î±'} {f' : Î± â†’ Î² â†’ Î´} {g' : Î´ â†’ Î³} (h_left_comm : âˆ€ (a : Î±) (b : Î²), f (g a) b = g' (f' a b)) : set.image2 f (g '' s) t = g' '' set.image2 f' s t
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) (h : X âŸ¶ W) [category_theory.epi h] (x : W âŸ¶ Y) (y : W âŸ¶ Z) (hhx : h â‰« x = f) (hhy : h â‰« y = g) (s : category_theory.limits.pushout_cocone f g) (hs : category_theory.limits.is_colimit s) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk s.inl s.inr _)
{R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring Sâ‚] (f : R â†’+* Sâ‚) : mv_polynomial Ïƒ R â†’+* mv_polynomial Ïƒ Sâ‚
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] (W : C) (k : Î  (a : I.L), W âŸ¶ I.left a) (h : âˆ€ (b : I.R), k (I.fst_to b) â‰« I.fst b = k (I.snd_to b) â‰« I.snd b) : W âŸ¶ category_theory.limits.multiequalizer I
 : â‡‘(linear_map.to_matrix complex.basis_one_I complex.basis_one_I) complex.conj_ae.to_linear_map = ![![1, 0], ![0, -1]]
{n : â„•+} {L : Type v} [field L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) {K : Type u_1} [linear_ordered_field K] [algebra K L] (hodd : odd â†‘n) : â‡‘(algebra.norm K) Î¶ = 1
{elab : bool} : expr elab â†’ expr elab â†’ expr elab
{Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), semi_normed_group (Ï€ i)] (x : Î  (i : Î¹), Ï€ i) : finset.univ.sum (Î» (i : Î¹), âˆ¥x iâˆ¥â‚Š) â‰¤ fintype.card Î¹ â€¢ âˆ¥xâˆ¥â‚Š
{Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} [has_zero Î²] [topological_space Î²] (hf : measure_theory.fin_strongly_measurable f Î¼) : â„• â†’ measure_theory.simple_func Î± Î²
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) {p : Î¹ â†’ P} (hi : âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ p i = p j â†’ i = j) {ps : set P} [fintype â†¥ps] (hps : ps = p '' â†‘s) : finset.centroid k s p = finset.centroid k finset.univ (Î» (x : â†¥ps), â†‘x)
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) â¦ƒÎ¹ : Type vâ¦„ (U : Î¹ â†’ topological_space.opens â†¥X) (P : category_theory.limits.is_limit (Top.presheaf.sheaf_condition_equalizer_products.fork F U)) : category_theory.limits.is_limit (category_theory.functor.map_cone F (category_theory.pairwise.cocone U).op)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) {G : Type u_5} [topological_space G] [charted_space H G] [add_group G] [lie_add_group I G] : topological_add_group G
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) : â‡‘Î¼ A = â¨† (K : set Î±) (H : K âŠ† A) (h : is_compact K), â‡‘Î¼ K
(Ïƒ : Type u_1) (R : Type u_3) [comm_semiring R] (n : â„•) : mv_polynomial.homogeneous_submodule Ïƒ R n = finsupp.supported R R {d : Ïƒ â†’â‚€ â„• | d.support.sum (Î» (i : Ïƒ), â‡‘d i) = n}
(V : Type u_2) {P : Type u_3} [semi_normed_group V] [pseudo_metric_space P] [normed_add_torsor V P] (x y : P) : has_dist.dist x y = âˆ¥x -áµ¥ yâˆ¥
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) {s : set Î±} : bdd_below s â†’ bdd_above (f '' s)
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] (f : Ïƒ â†’ R) : mv_polynomial Ïƒ R â†’+* R
{R : Type u} [ring R] (hR : is_field R) (I : ideal (polynomial R)) [hI : I.is_maximal] (x : R) (hx : â‡‘polynomial.C x âˆˆ I) : x = 0
{Ïƒ : Type u_1} {R : Type u_2} [comm_semiring R] (n : Ïƒ â†’â‚€ â„•) (Ï† : mv_power_series Ïƒ R) : mv_polynomial Ïƒ R
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (I : ideal R) (N : submodule R M) (hN : N.fg) (hIN : N â‰¤ I â€¢ N) (hIjac : I â‰¤ âŠ¥.jacobson) : N = âŠ¥
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] â¦ƒf : Î± â†’ Î² â†’ ennrealâ¦„ (hf : ae_measurable (function.uncurry f) (Î¼.prod Î½)) : âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (z : Î± Ã— Î²), f z.fst z.snd âˆ‚Î¼.prod Î½
(Î± : Type u) [fintype Î±] (Îº : Type v) [fintype Îº] : âˆƒ (Î¹ : Type) [_inst_3 : fintype Î¹], âˆ€ (C : (Î¹ â†’ Î±) â†’ Îº), âˆƒ (l : combinatorics.line Î± Î¹), combinatorics.line.is_mono C l
{C : Type uâ‚} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] {X Y Z : category_theory.forget_enrichment W C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : category_theory.forget_enrichment.hom_to W (f â‰« g) = ((Î»_ (ğŸ™_ W)).inv â‰« (category_theory.forget_enrichment.hom_to W f âŠ— category_theory.forget_enrichment.hom_to W g)) â‰« category_theory.e_comp W (category_theory.forget_enrichment.to W X) (category_theory.forget_enrichment.to W Y) (category_theory.forget_enrichment.to W Z)
(R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [I : module S M] : module S (restrict_scalars R S M)
{Î± : Type u} [pseudo_metric_space Î±] {Îµ : â„} (Îµ0 : 0 < Îµ) : {p : Î± Ã— Î± | has_dist.dist p.fst p.snd < Îµ} âˆˆ uniformity Î±
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (W : subspace K V) : (V â§¸ W) â‰ƒâ‚—[K] â†¥(submodule.dual_annihilator W)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) (G : Type u_4) [group G] [topological_space G] [charted_space H G] : Prop
(e old new : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unify : bool := bool.tt) : tactic expr
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {Î¹ : Type u_2} {s : finset Î¹} (f : Î¹ â†’ mv_polynomial Ïƒ R) : (s.prod (Î» (i : Î¹), f i)).vars âŠ† s.bUnion (Î» (i : Î¹), (f i).vars)
{I : Type u} {f : I â†’ Type v} [decidable_eq I] [Î  (i : I), add_zero_class (f i)] (x : Î  (i : I), f i) (i j : I) : add_commute (pi.single i (x i)) (pi.single j (x j))
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) (i : fin (n + 2)) (p : P) : affine_span â„ {p, s.points i} = s.altitude i â†” p â‰  s.points i âˆ§ p âˆˆ affine_span â„ (set.range s.points) âˆ§ p -áµ¥ s.points i âˆˆ ((affine_span â„ (s.points '' â†‘(finset.univ.erase i))).direction)á—®
{C : Type u} [category_theory.category C] {W X Y : C} {s : category_theory.limits.binary_fan X Y} (h : category_theory.limits.is_limit s) (f : W âŸ¶ X) (g : W âŸ¶ Y) : {l // l â‰« s.fst = f âˆ§ l â‰« s.snd = g}
 : pexpr â†’ (list pexpr := list.nil) â†’ pexpr Ã— list pexpr
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : â„•} (hn : 2 â‰¤ n + 1) (p : formal_multilinear_series ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) {r a C : â„} (hr : 0 â‰¤ r) (ha : 0 â‰¤ a) (hC : 0 â‰¤ C) (hp : âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C * r ^ n) : (finset.Ico 1 (n + 1)).sum (Î» (k : â„•), a ^ k * âˆ¥p.right_inv i kâˆ¥) â‰¤ âˆ¥â†‘(i.symm)âˆ¥ * a + âˆ¥â†‘(i.symm)âˆ¥ * C * (finset.Ico 2 (n + 1)).sum (Î» (k : â„•), (r * (finset.Ico 1 n).sum (Î» (j : â„•), a ^ j * âˆ¥p.right_inv i jâˆ¥)) ^ k)
{Î± : Type u_1} (F : Type u_6) (ğ•œ : Type u_11) (p : ennreal) [is_R_or_C ğ•œ] [normed_group F] [normed_space ğ•œ F] {m m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [hp : fact (1 â‰¤ p)] (hm : m â‰¤ m0) : â†¥(measure_theory.Lp_meas F ğ•œ m p Î¼) â‰ƒâ‚—áµ¢[ğ•œ] â†¥(measure_theory.Lp F p (Î¼.trim hm))
{C : â„š â†’ Sort u} (a : â„š) (H : Î  (n : â„¤) (d : â„•), d â‰  0 â†’ C (rat.mk n â†‘d)) : C a
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] (f : Î± Ã— Î² â†’ E) {s : set Î±} {t : set Î²} (hf : measure_theory.integrable_on f (s Ã—Ë¢ t) (Î¼.prod Î½)) : âˆ« (z : Î± Ã— Î²) in s Ã—Ë¢ t, f z âˆ‚Î¼.prod Î½ = âˆ« (x : Î±) in s, âˆ« (y : Î²) in t, f (x, y) âˆ‚Î½ âˆ‚Î¼
(md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] (f : Î± â†’ Î³) (g : Î² â†’ Î³) (Î¼ : measure_theory.measure Î± . "volume_tac") (Î½ : measure_theory.measure Î² . "volume_tac") : Prop
{Î± : Type u_1} {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} [measure_theory.is_finite_measure Â«â„™Â»] {X : Î± â†’ â„} [measure_theory.has_pdf X Â«â„™Â» measure_theory.measure_space.volume] : âˆ« (x : â„), x * (measure_theory.pdf X Â«â„™Â» measure_theory.measure_space.volume x).to_real = âˆ« (x : Î±), X x âˆ‚Â«â„™Â»
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ ennrealâ¦„ (hf : ae_measurable (function.uncurry f) (Î¼.prod Î½)) : âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f x y âˆ‚Î¼ âˆ‚Î½
{R : Type u_1} {S : Type u_6} {M : Type u_9} {Mâ‚ƒ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid Mâ‚ƒ] [module R M] [module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : M â†’â‚›â‚—[Ïƒ] Mâ‚ƒ} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
(Ïƒ : Type u_1) (R : Type u_2) [semiring R] : R â†’+* mv_power_series Ïƒ R
{Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp F p Î¼)) (hf_meas : f âˆˆ measure_theory.Lp_meas_subgroup F m p Î¼) : measure_theory.mem_â„’p (Exists.some _) p (Î¼.trim hm)
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I J : ideal R} {N N' : submodule R M} (hN' : N'.fg) (hIJ : I â‰¤ J.jacobson) (hNN : N âŠ” N' â‰¤ N âŠ” I â€¢ N') : N âŠ” I â€¢ N' = N âŠ” J â€¢ N'
{Î± : Type u} [semiring Î±] (I : ideal Î±) (Î¹ : Type v) : ideal (Î¹ â†’ Î±)
(f : â„• â†’ â„) (R : â„) : [âˆƒ (a : â„) (H : a âˆˆ set.Ioo (-R) R), f =o[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), f =o[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo (-R) R), f =O[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), f =O[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a < R) (C : â„) (hâ‚€ : 0 < C âˆ¨ 0 < R), âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R) (C : â„) (H : C > 0), âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n, âˆƒ (a : â„) (H : a < R), âˆ€á¶  (n : â„•) in filter.at_top, |f n| â‰¤ a ^ n, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), âˆ€á¶  (n : â„•) in filter.at_top, |f n| â‰¤ a ^ n].tfae
{C : Type u} [category_theory.category C] {W X Y Z : C} {f : W âŸ¶ X} [category_theory.limits.has_image f] {g : Y âŸ¶ Z} [category_theory.limits.has_image g] (sq : category_theory.arrow.mk f âŸ¶ category_theory.arrow.mk g) [category_theory.limits.has_image_map sq] : â†‘(category_theory.limits.image_subobject f) âŸ¶ â†‘(category_theory.limits.image_subobject g)
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) (hf : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (f n) Î¼) (hg : measure_theory.mem_â„’p g p Î¼) (hui : measure_theory.unif_integrable f p Î¼) (hfg : measure_theory.tendsto_in_measure Î¼ f filter.at_top g) : filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
{elab : bool := bool.tt} : expr elab â†’ option (name Ã— list level)
{Î± : Type u_1} [normed_field Î±] {E : Type u_5} [normed_group E] [normed_space Î± E] {c : Î±} (hc : 1 < âˆ¥câˆ¥) {Îµ : â„} (Îµpos : 0 < Îµ) {x : E} (hx : x â‰  0) : âˆƒ (d : Î±), d â‰  0 âˆ§ âˆ¥d â€¢ xâˆ¥ < Îµ âˆ§ Îµ / âˆ¥câˆ¥ â‰¤ âˆ¥d â€¢ xâˆ¥ âˆ§ âˆ¥dâˆ¥â»Â¹ â‰¤ Îµâ»Â¹ * âˆ¥câˆ¥ * âˆ¥xâˆ¥
{ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {p : Î¹ â†’ E} (hc : convex_independent ğ•œ p) (s : set Î¹) (i : Î¹) : p i âˆˆ â‡‘(convex_hull ğ•œ) (p '' s) â†” i âˆˆ s
{Î± : Type u_1} {Î¹ : Type u_3} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {I : set Î¹} {t : Î¹ â†’ set Î±} (h : I.pairwise_disjoint t) (hI : I.finite) (ht : âˆ€ (i : Î¹), i âˆˆ I â†’ (t i).finite) : finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒ (x : Î¹) (H : x âˆˆ I), t x), f a)) = finsum (Î» (i : Î¹), finsum (Î» (H : i âˆˆ I), finsum (Î» (j : Î±), finsum (Î» (H : j âˆˆ t i), f j))))
{R : Type u_1} [semiring R] {Ï† : power_series R} (n : â„•) (h : â†‘n < Ï†.order) : â‡‘(power_series.coeff R n) Ï† = 0
(cs : interactive.parse (lean.parser.many lean.parser.ident)) (l : interactive.parse interactive.types.location) (cfg : tactic.dunfold_config := {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}}) : tactic unit
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic unit
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {f f' : â„ â†’ â„} {g : â„ â†’ E} (h : âˆ€ (x : â„), x âˆˆ set.interval a b â†’ has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (x : â„) in f a..f b, g x
{I : Type u} (X : I â†’ Top) : category_theory.limits.fan.mk (fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Î  (i : I), â†¥(X i)))) (fundamental_groupoid_functor.proj X) âŸ¶ category_theory.Groupoid.pi_limit_fan (Î» (i : I), fundamental_groupoid.fundamental_groupoid_functor.obj (X i))
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : measure_theory.ae_strongly_measurable f (Î¼.prod Î½)) : measure_theory.integrable f (Î¼.prod Î½) â†” (âˆ€áµ (y : Î²) âˆ‚Î½, measure_theory.integrable (Î» (x : Î±), f (x, y)) Î¼) âˆ§ measure_theory.integrable (Î» (y : Î²), âˆ« (x : Î±), âˆ¥f (x, y)âˆ¥ âˆ‚Î¼) Î½
{L : first_order.language} (M : Type w) [L.Structure M] (h : set.univ.countable) : (quotient.mk '' L.age M).countable
{Î¹ : Type u_1} {I : box_integral.box Î¹} {Ï€ : box_integral.tagged_prepartition I} [fintype Î¹] (h : Ï€.is_Henstock) (x : Î¹ â†’ â„) : (finset.filter (Î» (J : box_integral.box Î¹), Ï€.tag J = x) Ï€.to_prepartition.boxes).card â‰¤ 2 ^ fintype.card Î¹
{C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (G : D â¥¤ C) [category_theory.is_right_adjoint G] [category_theory.reflects_isomorphisms G] [âˆ€ â¦ƒA B : Dâ¦„ (f g : A âŸ¶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g] [Î  â¦ƒA B : Dâ¦„ (f g : A âŸ¶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G] : category_theory.monadic_right_adjoint G
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] {s : set (Î± Ã— Î²)} (hs : measurable_set s) : â‡‘(Î¼.prod Î½) s = 0 â†” (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s)) =áµ[Î¼] 0
{R : Type u_1} [normed_ring R] {x : R} (h : âˆ¥xâˆ¥ < 1) : filter.tendsto (Î» (n : â„•), x ^ n) filter.at_top (nhds 0)
{R : Type u_1} [comm_semiring R] {P : Type u_3} [comm_semiring P] (I : ideal R) [hI : I.is_prime] (J : ideal P) [hJ : J.is_prime] (f : R â†’+* P) (hIJ : I = ideal.comap f J) : localization.at_prime I â†’+* localization.at_prime J
(cls : name) (tac : tactic unit) (univ_poly : bool := bool.tt) (modify_target : name â†’ list expr â†’ expr â†’ tactic expr := Î» (_x : name) (_x : list expr), has_pure.pure) : derive_handler
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} [Î¼.have_lebesgue_decomposition Î½] : Î¼.absolutely_continuous Î½ â†” Î½.with_density (Î¼.rn_deriv Î½) = Î¼
{Ïƒ : Type u_1} {R : Type u_3} [comm_semiring R] (n : â„•) : mv_polynomial Ïƒ R â†’â‚—[R] mv_polynomial Ïƒ R
{I : Type u} (X : I â†’ Top) (i : I) (xâ‚€ xâ‚ : â†¥(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Î  (i : I), â†¥(X i))))) (p : xâ‚€ âŸ¶ xâ‚) : (fundamental_groupoid_functor.proj X i).map p = path.homotopic.proj i p
(n : interactive.parse lean.parser.ident) (p : interactive.parse (lean.parser.tk ":" *> interactive.types.texpr)) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{W : Type (v+1)} [category_theory.category W] [category_theory.monoidal_category W] {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.enriched_category W C] [category_theory.enriched_category W D] (F : category_theory.enriched_functor W C D) : category_theory.forget_enrichment W C â¥¤ category_theory.forget_enrichment W D
{Î± : Type u} [setoid Î±] [topological_space Î±] {s : set Î±} (H : dense s) : dense (quotient.mk '' s)
{R : Type u_1} (I : Type u_2) (A : Type u_3) [comm_semiring R] [semiring A] [algebra R A] : algebra R (I â†’ A)
(R : Type u) (Ïƒ : Type u_1) [comm_semiring R] [he : is_empty Ïƒ] : mv_polynomial Ïƒ R â‰ƒ+* R
(G : Type u_1) {Î± : Type u_3} {m : measurable_space Î±} [add_group G] [add_action G Î±] [measurable_space G] [has_measurable_vadd G Î±] (Î¼ : measure_theory.measure Î±) : [measure_theory.vadd_invariant_measure G Î± Î¼, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (has_vadd.vadd c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (c +áµ¥ s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (has_vadd.vadd c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (c +áµ¥ s) = â‡‘Î¼ s, âˆ€ (c : G), measure_theory.measure.map (has_vadd.vadd c) Î¼ = Î¼, âˆ€ (c : G), measure_theory.measure_preserving (has_vadd.vadd c) Î¼ Î¼].tfae
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] {I : C} (B : C) (t : category_theory.limits.is_initial I) [category_theory.cartesian_closed C] : category_theory.mono (t.to B)
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} (C : set (set Î±)) (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) [measure_theory.is_finite_measure Î¼] (hÎ¼Î½ : âˆ€ (s : set Î±), s âˆˆ C â†’ â‡‘Î¼ s = â‡‘Î½ s) (h_univ : â‡‘Î¼ set.univ = â‡‘Î½ set.univ) : Î¼ = Î½
{Î± : Type u_1} (F : Type u_6) (ğ•œ : Type u_11) (p : ennreal) [is_R_or_C ğ•œ] [normed_group F] [normed_space ğ•œ F] {m m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp F p (Î¼.trim hm))) : â†¥(measure_theory.Lp_meas F ğ•œ m p Î¼)
{Î± : Sort u} {Î² : Sort v} {r : Î± â†’ Î± â†’ Prop} (e : Î± â‰ƒ Î²) : quot r â‰ƒ quot (Î» (b b' : Î²), r (â‡‘(e.symm) b) (â‡‘(e.symm) b'))
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [second_countable_topology_either Î± Î²] {f : Î± â†’ Î²} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : continuous_on f s) (hs : measurable_set s) (x : Î±) : strongly_measurable_at_filter f (nhds_within x s) Î¼
{L : first_order.language} (Î± : Type w) {L' : first_order.language} (Ï† : L â†’á´¸ L') : L.with_constants Î± â†’á´¸ L'.with_constants Î±
{k : Type uâ‚} {G : Type uâ‚‚} [semiring k] [mul_one_class G] (f : monoid_algebra k G) : f âˆˆ submodule.span k (â‡‘(monoid_algebra.of k G) '' â†‘(f.support))
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (Ï† : L.hom M N) (S : L.substructure M) : L.substructure N
(G : Type u_1) {Î± : Type u_2} [has_zero G] [has_vadd G Î±] [measurable_space Î±] (s : set Î±) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î² â†’ Prop) {s : finset Î±} {t : finset Î²} {m n : â„•} [Î  (a : Î±) (b : Î²), decidable (r a b)] (hm : âˆ€ (a : Î±), a âˆˆ s â†’ m â‰¤ (finset.bipartite_above r t a).card) (hn : âˆ€ (b : Î²), b âˆˆ t â†’ (finset.bipartite_below r s b).card â‰¤ n) : s.card * m â‰¤ t.card * n
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} (hom : Î  (i j : Î¹), C.X i âŸ¶ D.X j) : C âŸ¶ D
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {S : Type u_2} {A : Type u_3} [comm_semiring S] [comm_semiring A] [algebra S R] [algebra S A] (f : R â†’â‚[S] A) (x : Ïƒ â†’ A) : mv_polynomial Ïƒ R â†’â‚[S] A
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group E] {s : set Î±} (p : ennreal) (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (c : E) : â†¥(measure_theory.Lp E p Î¼)
{Î± : Type u} {Î² : Type v} {m : Î± â†’ Î²} {s : set Î±} {g : ultrafilter Î²} (h : m '' s âˆˆ g) : ultrafilter Î±
{Î± : Type u} {C : list Î± â†’ Sort u_1} (l : list Î±) (H0 : C list.nil) (H1 : Î  (l : list Î±) (a : Î±), C l â†’ C (l ++ [a])) : C l
{R : Type u_1} [semiring R] (Ï† Ïˆ : power_series R) : linear_order.min Ï†.order Ïˆ.order â‰¤ (Ï† + Ïˆ).order
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : 0 â‰¤ âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {s : set Î±} (hs : measurable_set s) : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Î¼ (s âˆ© a) / â‡‘Î¼ a) (v.filter_at x) (nhds (s.indicator 1 x))
{Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) {s : set Î²} (hs : â‡‘(measure_theory.measure.map f Î¼) s = 0) : â‡‘Î¼ (f â»Â¹' s) = 0
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic name
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] {n : â„•} (p : formal_multilinear_series ğ•œ E F) (c : composition n) (f : continuous_multilinear_map ğ•œ (Î» (i : fin c.length), F) G) (v : fin n â†’ E) : âˆ¥â‡‘(continuous_multilinear_map.comp_along_composition p c f) vâˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.prod (Î» (i : fin c.length), âˆ¥p (c.blocks_fun i)âˆ¥) * finset.univ.prod (Î» (i : fin n), âˆ¥v iâˆ¥)
{M : Type u_1} [mul_one_class M] â¦ƒs t : set Mâ¦„ (h : s âŠ† t) : submonoid.closure s â‰¤ submonoid.closure t
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : Î± â†’ ennreal) : ennreal
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x : E} : âˆ¥â‡‘innerSL xâˆ¥ = âˆ¥xâˆ¥
{Î± : Type u_1} {E : Type u_3} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : Î± â†’ E) : measure_theory.vector_measure Î± E
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] : R â†’+* mv_polynomial Ïƒ R
{R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) (M : Type u_3) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (k : â„•) : lie_submodule R L M
{R : Type u} [comm_semiring R] (h : âˆƒ! (I : ideal R), I.is_maximal) : local_ring R
(f : expr) (nargs : option â„• := option.none) (md : tactic.transparency := tactic.transparency.semireducible) : tactic fun_info
{C : Type uâ‚} [category_theory.category C] {X : C} (S : category_theory.presieve X) (R : Î  â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, S f â†’ category_theory.sieve Y) : category_theory.sieve X
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [metric_space Î²] {Î¼ : measure_theory.measure Î±} [semilattice_sup Î¹] [nonempty Î¹] [encodable Î¹] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} {s : set Î±} (hf : âˆ€ (n : Î¹), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hsm : measurable_set s) (hs : â‡‘Î¼ s â‰  âŠ¤) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ s â†’ filter.tendsto (Î» (n : Î¹), f n x) filter.at_top (nhds (g x))) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (t : set Î±) (H : t âŠ† s), measurable_set t âˆ§ â‡‘Î¼ t â‰¤ ennreal.of_real Îµ âˆ§ tendsto_uniformly_on f g filter.at_top (s  t)
{L : first_order.language} (T : L.Theory) {Î± : Type w} {n : â„•} (Ï† : L.bounded_formula Î± n) : Prop
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {B : bilin_form K V} {W : subspace K V} (bâ‚ : B.is_refl) : (B.restrict W).nondegenerate â†” is_compl W (B.orthogonal W)
{R : Type u_1} [comm_semiring R] (Ïƒ : Type u_2) [fintype Ïƒ] (r : Ïƒ â†’ R) : finset.univ.prod (Î» (i : Ïƒ), â‡‘polynomial.C (r i) + polynomial.X) = (finset.range (fintype.card Ïƒ + 1)).sum (Î» (i : â„•), (finset.powerset_len i finset.univ).sum (Î» (t : finset Ïƒ), t.prod (Î» (i : Ïƒ), â‡‘polynomial.C (r i))) * polynomial.X ^ (fintype.card Ïƒ - i))
{E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} {C : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ C) (x : â„) (H : x âˆˆ set.Icc a b) : âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
{G : Type u_1} [group G] â¦ƒh k : set Gâ¦„ (h' : h âŠ† k) : subgroup.closure h â‰¤ subgroup.closure k
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {E : Type uâ‚ƒ} [category_theory.category E] {F G : C â¥¤ D} {H I : D â¥¤ E} (Î± : F â‰… G) (Î² : H â‰… I) : F â‹™ H â‰… G â‹™ I
{R : Type u_1} [normed_ring R] (k : â„•) {râ‚ : R} {râ‚‚ : â„} (h : âˆ¥râ‚âˆ¥ < râ‚‚) : (Î» (n : â„•), â†‘n ^ k * râ‚ ^ n) =o[filter.at_top] Î» (n : â„•), râ‚‚ ^ n
{L : first_order.language} {Î¹ : Type w} [preorder Î¹] [is_directed Î¹ has_le.le] [nonempty Î¹] (G : Î¹ â†’ Type (max w w')) [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] : L.age (first_order.language.direct_limit G f) = â‹ƒ (i : Î¹), L.age (G i)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : âˆƒ (Ï€ : R), v.int_valuation_def Ï€ = â†‘(â‡‘multiplicative.of_add (-1))
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M â†’* N) (s : set M) : submonoid.map f (submonoid.closure s) = submonoid.closure (â‡‘f '' s)
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) (hf : continuous â‡‘f) : âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
(R : Type u) [ring R] (Î¹ : Type v) [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) (i : Î¹) : G i â†’â‚—[R] module.direct_limit G f
{Î± : Type u_1} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [metric_space E] {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hf : âˆ€ (n : â„•), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (g x))) : measure_theory.tendsto_in_measure Î¼ f filter.at_top g
(Î± : Type u_1) (E : Type u_2) {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {T : set Î± â†’ (E â†’L[â„] F)} {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) : â†¥(measure_theory.Lp.simple_func E 1 Î¼) â†’L[â„] F
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [nonempty Î²] [semilattice_sup Î²] {u : Î² â†’ Î±} : cauchy_seq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), n â‰¥ N â†’ has_dist.dist (u n) (u N) < Îµ)
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â‰¤ s.sum (Î» (i : Î¹), f i â€¢ g i)
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {E : Type u_3} [normed_group E] [normed_space â„ E] [complete_space E] {f g : Î± â†’ E} (hf : measure_theory.integrable f Î¼) (hg : measure_theory.integrable g Î¼) (hfg : Î¼.with_densityáµ¥ f = Î¼.with_densityáµ¥ g) : f =áµ[Î¼] g
(K : Type u_4) {L : Type u_5} [field K] [field L] [algebra K L] (E : Type u_7) [field E] [algebra K E] [finite_dimensional K L] [is_separable K L] [is_alg_closed E] {x : L} : â‡‘(algebra_map K E) (â‡‘(algebra.norm K) x) = finset.univ.prod (Î» (Ïƒ : L â†’â‚[K] E), â‡‘Ïƒ x)
{Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {X : Î© â†’ â„} (hX : measure_theory.mem_â„’p X 2 measure_theory.measure_space.volume) {c : â„} (hc : 0 < c) : â‡‘measure_theory.measure_space.volume {Ï‰ : Î© | c â‰¤ |X Ï‰ - âˆ« (a : Î©), X a|} â‰¤ ennreal.of_real (probability_theory.variance X measure_theory.measure_space.volume / c ^ 2)
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measurable_set (f '' s)
{Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {X Y : Î± â†’ â„} (hXY : probability_theory.indep_fun X Y Î¼) (hX : measure_theory.integrable X Î¼) (hY : measure_theory.integrable Y Î¼) : measure_theory.integral Î¼ (X * Y) = measure_theory.integral Î¼ X * measure_theory.integral Î¼ Y
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {f : Î± â†’ Î²} [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] : measure_theory.ae_strongly_measurable f Î¼ â†” ae_measurable f Î¼ âˆ§ âˆƒ (t : set Î²), topological_space.is_separable t âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ t
{G : Type u} [group G] (N : subgroup G) [nN : N.normal] {H : Type v} [group H] â¦ƒf g : G â§¸ N â†’* Hâ¦„ (h : f.comp (quotient_group.mk' N) = g.comp (quotient_group.mk' N)) : f = g
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {Îµ : Type u_5} {Î¶ : Type u_6} (f : Î± â†’ Î² â†’ Î³ â†’ Î´ â†’ Îµ â†’ Î¶) : list Î± â†’ list Î² â†’ list Î³ â†’ list Î´ â†’ list Îµ â†’ list Î¶
{X : Type u_1} [pseudo_emetric_space X] [measurable_space X] [borel_space X] (Î¼ : measure_theory.measure X) [measure_theory.is_finite_measure Î¼] : Î¼.weakly_regular
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : set Î±} (hs : measurable_set s) (ht : â‡‘Î¼ t â‰  âŠ¤) : â‡‘Î¼ (measure_theory.to_measurable Î¼ t âˆ© s) = â‡‘Î¼ (t âˆ© s)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' â†’ M''} (hg : cont_mdiff_on I' I'' n g t) (hf : cont_mdiff_on I I' n f s) (st : s âŠ† f â»Â¹' t) : cont_mdiff_on I I'' n (g âˆ˜ f) s
{Î± : Type u_1} [conditionally_complete_linear_order Î±] {s : set Î±} [hs : s.ord_connected] â¦ƒt : set â†¥sâ¦„ (ht : t.nonempty) (h_bdd : bdd_above t) : has_Sup.Sup (coe '' t) âˆˆ s
{V : Type u_1} [inner_product_space â„ V] (x y : V) : real.cos (inner_product_geometry.angle x y) = has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (P Q : chain_complex V â„•) (zero : P.X 0 âŸ¶ Q.X 0) (one : P.X 1 âŸ¶ Q.X 1) (one_zero_comm : one â‰« Q.d 1 0 = P.d 1 0 â‰« zero) (succ : Î  (n : â„•) (p : Î£' (f : P.X n âŸ¶ Q.X n) (f' : P.X (n + 1) âŸ¶ Q.X (n + 1)), f' â‰« Q.d (n + 1) n = P.d (n + 1) n â‰« f), Î£' (f'' : P.X (n + 2) âŸ¶ Q.X (n + 2)), f'' â‰« Q.d (n + 2) (n + 1) = P.d (n + 2) (n + 1) â‰« p.snd.fst) (n : â„•) : Î£' (f : P.X n âŸ¶ Q.X n) (f' : P.X (n + 1) âŸ¶ Q.X (n + 1)), f' â‰« Q.d (n + 1) n = P.d (n + 1) n â‰« f
{Î± : Type u_2} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) : measure_theory.conservative id Î¼
{X : Type u_1} {Y : Type u_2} [topological_space X] {m : measurable_space X} [topological_space Y] [t2_space Y] {Î¼ : measure_theory.measure X} [Î¼.is_open_pos_measure] {f g : X â†’ Y} (h : f =áµ[Î¼] g) (hf : continuous f) (hg : continuous g) : f = g
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : Prop
{Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) (J : box_integral.box Î¹) : box_integral.prepartition J
{Î± : Type u} [pseudo_metric_space Î±] (x : Î±) (Îµ : â„) : set Î±
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] {I : ideal A} (h : I.fg) (hfp : algebra.finite_presentation R A) : algebra.finite_presentation R (A â§¸ I)
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] {p : Î± Ã— Î² â†’ Prop} (h : âˆ€áµ (z : Î± Ã— Î²) âˆ‚Î¼.prod Î½, p z) : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€áµ (y : Î²) âˆ‚Î½, p (x, y)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X âŸ¶ Y} {s : category_theory.limits.cokernel_cofork f} (hs : category_theory.limits.is_colimit s) {W : C} (k : Y âŸ¶ W) (h : f â‰« k = 0) : {l // category_theory.limits.cofork.Ï€ s â‰« l = k}
{Î± : Type u_1} {E : Type u_3} [normed_group E] [topological_space Î±] {f : Î± â†’ E} : has_compact_support f â†’ has_compact_support (Î» (x : Î±), âˆ¥f xâˆ¥)
{R : Type u} {Ïƒ : Type v} [comm_ring R] (I : ideal R) : mv_polynomial Ïƒ (R â§¸ I) â‰ƒâ‚[R] mv_polynomial Ïƒ R â§¸ ideal.map mv_polynomial.C I
{Î² : Type v} {Î³ : Type w} [emetric_space Î³] [emetric_space Î²] {f : Î³ â†’ Î²} : uniform_embedding f â†” (âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a b : Î³}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : ennreal), Î´ > 0 â†’ (âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î³}, has_edist.edist (f a) (f b) < Îµ â†’ has_edist.edist a b < Î´)
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] (s : finset E) (hs : âˆ€ (c : E), c âˆˆ s â†’ âˆ¥câˆ¥ â‰¤ 2) (h : âˆ€ (c : E), c âˆˆ s â†’ âˆ€ (d : E), d âˆˆ s â†’ c â‰  d â†’ 1 â‰¤ âˆ¥c - dâˆ¥) : s.card â‰¤ 5 ^ finite_dimensional.finrank â„ E
(n : name) (n' : name := n.append_suffix "_assoc") : tactic unit
{R : Type u_1} {S : Type u_6} {M : Type u_7} {Mâ‚‚ : Type u_9} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid Mâ‚‚] {module_M : module R M} {module_S_Mâ‚‚ : module S Mâ‚‚} {Ïƒ : R â†’+* S} {Ïƒ' : S â†’+* R} {reâ‚ : ring_hom_inv_pair Ïƒ Ïƒ'} {reâ‚‚ : ring_hom_inv_pair Ïƒ' Ïƒ} (e : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚) : Mâ‚‚ â‰ƒâ‚›â‚—[Ïƒ'] M
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) : (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =o[filter.at_top] Î» (_x : â„•), 1
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ â„} (hf : measure_theory.integrable f Î¼) : filter.tendsto (Î» (A : â„), âˆ« (x : Î±), probability_theory.truncation f A x âˆ‚Î¼) filter.at_top (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) (hf : âˆ€ (n : â„•), measure_theory.mem_â„’p (f n) p Î¼) (hg : measure_theory.mem_â„’p g p Î¼) (hfg : filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)) : measure_theory.unif_integrable f p Î¼
{Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_lattice Î²] {m : measurable_space Î±} (f : Î± â†’ Î²) (Î¼ : measure_theory.measure Î±) : Î²
{Ïƒ : Type u_1} (f : Ïƒ â†’ option Ïƒ) (a : Ïƒ) (b : option Ïƒ) : Type
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {s : set E} (u : â„• â†’ E) (sb : metric.bounded s) (hu : metric.bounded (set.range u)) (hs : pairwise (disjoint on Î» (n : â„•), {u n} + s)) (h's : measurable_set s) : â‡‘Î¼ s = 0
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] [measurable_space Î²] [topological_space Î²] [borel_space Î²] {f : Î± â†’ Î²} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : continuous_on f s) (hs : measurable_set s) : ae_measurable f (Î¼.restrict s)
{E : Type u_3} [semi_normed_group E] (u v : E) : âˆ¥vâˆ¥ â‰¤ âˆ¥uâˆ¥ + âˆ¥u - vâˆ¥
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), (f + g) (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ + âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {s : set E} {c : nnreal} (hf : approximates_linear_on f â†‘f' s c) (hc : subsingleton E âˆ¨ c < âˆ¥â†‘(f'.symm)âˆ¥â‚Šâ»Â¹) : approximates_linear_on â‡‘((hf.to_local_equiv hc).symm) â†‘(f'.symm) (f '' s) (âˆ¥â†‘(f'.symm)âˆ¥â‚Š * (âˆ¥â†‘(f'.symm)âˆ¥â‚Šâ»Â¹ - c)â»Â¹ * c)
{n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] {p : â„•} [fact (nat.prime p)] (hdiv : Â¬p âˆ£ n) : squarefree (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly â„¤ Î¼))
{S : Type u} [add_semigroup S] : transitive (Î» (a b : S), âˆƒ (c : S), add_semiconj_by c a b)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) : local_equiv E H
(V : Type u_1) (W : Type u_2) : simple_graph (V âŠ• W)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_4} [topological_space H] {H' : Type u_5} [topological_space H'] (I : model_with_corners ğ•œ E H) (I' : model_with_corners ğ•œ E' H') (M : Type u_6) [topological_space M] [charted_space H M] (M' : Type u_7) [topological_space M'] [charted_space H' M'] (n : with_top â„•) : Type (max u_6 u_7)
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring ğ•œ] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] {s : set E} (f : E â†’áµƒ[ğ•œ] F) (hs : convex ğ•œ s) : convex ğ•œ (â‡‘f '' s)
{Î± : Type u_1} [measurable_space Î±] (p : ennreal) (Î¼ : measure_theory.measure Î±) (G : Type u_7) [normed_lattice_add_comm_group G] : {g // 0 â‰¤ g} â†’ {g // 0 â‰¤ g}
{G : Type u} [group G] (X : Type u) (of : X â†’ G) (lift : Î  {H : Type u} [_inst_5 : group H], (X â†’ H) â‰ƒ (G â†’* H)) (lift_of : âˆ€ {H : Type u} [_inst_6 : group H] (f : X â†’ H) (a : X), â‡‘(â‡‘lift f) (of a) = f a) : is_free_group G
{X : â„• â†’ Type u} [Î  (n : â„•), metric_space (X n)] {f : Î  (n : â„•), X n â†’ X (n + 1)} (I : âˆ€ (n : â„•), isometry (f n)) (n : â„•) : metric.to_inductive_limit I n.succ âˆ˜ f n = metric.to_inductive_limit I n
(lemmas : list (tactic expr)) (opt : tactic.apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}) (tac : tactic unit := tactic.skip) (on_success : expr â†’ tactic unit := Î» (_x : expr), tactic.skip) (on_failure : tactic unit := tactic.skip) : tactic unit
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] [proper_space F] {s : set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hb : metric.bounded s) : is_compact (closure (coe_fn '' s))
{E : Type u_3} [normed_group E] {f : â„ â†’ E} {a b : â„} {Î¼ : measure_theory.measure â„} : interval_integrable f Î¼ a b â†” measure_theory.integrable_on f (set.interval_oc a b) Î¼
(s : â„• := 0) : std_gen
{Î± : Type u} [decidable_eq Î±] (i j : Î±) (Ïƒ : equiv.perm Î±) : Ïƒ * equiv.swap i j * equiv.swap i j = Ïƒ
(n : â„•) : 3 âˆ£ n â†” 3 âˆ£ (10.digits n).sum
{n : â„¤} {c w : â„‚} {R : â„} (hn : n < 0) (hw : w âˆˆ metric.sphere c |R|) : âˆ® (z : â„‚) in C(c, R), (z - w) ^ n = 0
{I : Type u} (f : I â†’ Type v) [Î  (i : I), mul_one_class (f i)] (i : I) : (Î  (i : I), f i) â†’* f i
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] (s : category_theory.limits.cotrident f) {W : C} {k l : s.X âŸ¶ W} (h : s.Ï€ â‰« k = s.Ï€ â‰« l) (j : category_theory.limits.walking_parallel_family J) : s.Î¹.app j â‰« k = s.Î¹.app j â‰« l
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {D : Type uâ‚‚} [category_theory.category D] (F : Î  (i : I), C i â¥¤ D) (i : I) : category_theory.sigma.incl i â‹™ category_theory.sigma.desc F â‰… F i
{N : Type u_1} {G : Type u_2} {H : Type u_3} [group N] [group G] [group H] {Ï† : G â†’* mul_aut N} (fâ‚ : N â†’* H) (fâ‚‚ : G â†’* H) (h : âˆ€ (g : G), fâ‚.comp (mul_equiv.to_monoid_hom (â‡‘Ï† g)) = (mul_equiv.to_monoid_hom (â‡‘mul_aut.conj (â‡‘fâ‚‚ g))).comp fâ‚) : N â‹Š[Ï†] G â†’* H
{G : Type u} [group G] {H : Type v} [group H] (Ï† : G â†’* H) (hÏ† : function.surjective â‡‘Ï†) : G â§¸ Ï†.ker â‰ƒ* H
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : submodule R (Î  (n : â„•), M â§¸ I ^ n â€¢ âŠ¤)
{N : Type u_1} {G : Type u_2} [group N] [group G] {Ï† : G â†’* mul_aut N} : N â†’* N â‹Š[Ï†] G
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {p : Î¹ â†’ P} (ha : affine_independent k p) (i : Î¹) (s : set Î¹) : p i âˆˆ affine_span k (p '' s) â†” i âˆˆ s
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {Ïƒâ‚‚â‚ : ğ•œâ‚‚ â†’+* ğ•œ} [ring_hom_inv_pair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] [ring_hom_inv_pair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] (e : E â‰ƒâ‚›â‚—[Ïƒâ‚â‚‚] F) (C_to C_inv : â„) (h_to : âˆ€ (x : E), âˆ¥â‡‘e xâˆ¥ â‰¤ C_to * âˆ¥xâˆ¥) (h_inv : âˆ€ (x : F), âˆ¥â‡‘(e.symm) xâˆ¥ â‰¤ C_inv * âˆ¥xâˆ¥) : E â‰ƒSL[Ïƒâ‚â‚‚] F
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {f' : F} {x : ğ•œ} : has_strict_deriv_at f f' x â†’ has_strict_fderiv_at f (1.smul_right f') x
{Ïƒ : Type u_1} (R : Type u_2) [semiring R] (n : Ïƒ â†’â‚€ â„•) : mv_power_series Ïƒ R â†’â‚—[R] R
(use_iota_eqn : interactive.parse (optional (lean.parser.tk "!"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (cfg : tactic.simp_config_ext := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}, discharger := tactic.failed unit}) : smt_tactic unit
(x : name) (e : expr) (cfg : tactic.equiv_rw_cfg := {max_depth := 10}) : tactic unit
{Î± : Type u_1} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [metric_space E] {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} (hfg : measure_theory.tendsto_in_measure Î¼ f filter.at_top g) : â„• â†’ â„•
{R : Type u_1} [comm_ring R] [is_domain R] {s : multiset (ideal R)} : s.prod = âŠ¥ â†” âˆƒ (I : ideal R) (H : I âˆˆ s), I = âŠ¥
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] [measure_theory.is_finite_measure Î½] (h : Â¬Î¼.mutually_singular Î½) : âˆƒ (Îµ : nnreal), 0 < Îµ âˆ§ âˆƒ (E : set Î±), measurable_set E âˆ§ 0 < â‡‘Î½ E âˆ§ 0.restrict E â‰¤ (Î¼.to_signed_measure - (Îµ â€¢ Î½).to_signed_measure).restrict E
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] [complete_space E] {T : E â†’L[ğ•œ] E} (hT : inner_product_space.is_self_adjoint â†‘T) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0) (hextr : is_local_extr_on T.re_apply_inner_self (metric.sphere 0 âˆ¥xâ‚€âˆ¥) xâ‚€) : module.End.has_eigenvector â†‘T â†‘((Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) xâ‚€) xâ‚€
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] (W : subspace K V) : module.dual K â†¥W â‰ƒâ‚—[K] â†¥(W.dual_lift.range)
{R : Type u_3} {S : Type u_4} {F : Type u_5} [comm_ring R] [comm_ring S] [ring_hom_class F (polynomial R) (polynomial S)] (Ï† : F) (hÏ† : non_zero_divisors (polynomial R) â‰¤ submonoid.comap â†‘Ï† (non_zero_divisors (polynomial S))) : ratfunc R â†’+* ratfunc S
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} {W : C} {fst : W âŸ¶ X} {snd : W âŸ¶ Y} (eq : fst â‰« f = snd â‰« g) (lift : Î  (s : category_theory.limits.pullback_cone f g), s.X âŸ¶ W) (fac_left : âˆ€ (s : category_theory.limits.pullback_cone f g), lift s â‰« fst = s.fst) (fac_right : âˆ€ (s : category_theory.limits.pullback_cone f g), lift s â‰« snd = s.snd) (uniq : âˆ€ (s : category_theory.limits.pullback_cone f g) (m : s.X âŸ¶ W), m â‰« fst = s.fst â†’ m â‰« snd = s.snd â†’ m = lift s) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk fst snd eq)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {p : submodule R M} (hfp : âˆ€ (x : M), x âˆˆ p â†’ â‡‘f x âˆˆ p) {Î¼ : R} (hÎ¼p : disjoint (f.eigenspace Î¼) p) : module.End.eigenspace (linear_map.restrict f hfp) Î¼ = âŠ¥
{R : Type u} {Ïƒ : Type v} [comm_ring R] [fintype Ïƒ] [is_noetherian_ring R] : is_noetherian_ring (mv_polynomial Ïƒ R)
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {D : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (D i)] {F G : Î  (i : I), C i â¥¤ D i} (Î± : Î  (i : I), F i âŸ¶ G i) : category_theory.sigma.functor.sigma F âŸ¶ category_theory.sigma.functor.sigma G
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [normed_group F] {ğ•œ : Type u_5} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] F) (f : â†¥(measure_theory.Lp E p Î¼)) : â†¥(measure_theory.Lp F p Î¼)
{R : Type u} [comm_ring R] (I : ideal R) : polynomial (R â§¸ I) â‰ƒ+* polynomial R â§¸ ideal.map polynomial.C I
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] {E' : Type u_7} [normed_group E'] [complete_space E'] [normed_space â„ E'] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ E') (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ - âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
(h : expr) (nargs : option â„• := option.none) (md : tactic.transparency := tactic.transparency.semireducible) : tactic congr_lemma
{Î± : Sort u_1} {Î² : Sort u_2} [sa : setoid Î±] [sb : setoid Î²] {Ï† : quotient sa â†’ quotient sb â†’ Sort u_3} (qa : quotient sa) (qb : quotient sb) (f : Î  (a : Î±) (b : Î²), Ï† âŸ¦aâŸ§ âŸ¦bâŸ§) (c : âˆ€ (aâ‚ : Î±) (bâ‚ : Î²) (aâ‚‚ : Î±) (bâ‚‚ : Î²), aâ‚ â‰ˆ aâ‚‚ â†’ bâ‚ â‰ˆ bâ‚‚ â†’ f aâ‚ bâ‚ == f aâ‚‚ bâ‚‚) : Ï† qa qb
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T âˆˆ dist_triang C) : T.rotate âˆˆ dist_triang C
{E : Type u_3} [normed_group E] {f : â„ â†’ E} {a b : â„} {Î¼ : measure_theory.measure â„} (h : interval_integrable f Î¼ a b) : measure_theory.integrable_on f (set.interval_oc a b) Î¼
{Î¹ : Type u} (s : finset Î¹) (f : Î¹ â†’ nnreal) {p q : â„} (hpq : p.is_conjugate_exponent q) : is_greatest ((Î» (g : Î¹ â†’ nnreal), s.sum (Î» (i : Î¹), f i * g i)) '' {g : Î¹ â†’ nnreal | s.sum (Î» (i : Î¹), g i ^ q) â‰¤ 1}) (s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p))
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) : â‡‘Î¼ A = â¨† (K : set Î±) (H : K âŠ† A) (h : is_closed K), â‡‘Î¼ K
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} (h : Î  (i j : Î¹), c.rel j i â†’ (C.X i âŸ¶ D.X j)) : C âŸ¶ D
{ğ•œ : Type u} {A : Type v} [field ğ•œ] [ring A] [algebra ğ•œ A] (a : A) (p : polynomial ğ•œ) : (Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a âŠ† spectrum ğ•œ (â‡‘(polynomial.aeval a) p)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {Î¼ : measure_theory.measure â„} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X â†’ â„ â†’ E} {xâ‚€ : X} {bound : â„ â†’ â„} {a b : â„} {s : set X} (hF_meas : âˆ€á¶  (x : X) in nhds_within xâ‚€ s, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€á¶  (x : X) in nhds_within xâ‚€ s, âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ¥F x tâˆ¥ â‰¤ bound t) (bound_integrable : interval_integrable bound Î¼ a b) (h_cont : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ continuous_within_at (Î» (x : X), F x t) s xâ‚€) : continuous_within_at (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) s xâ‚€
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {t : set M} (ht : t âˆˆ nhds x) : â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds (â‡‘(ext_chart_at I x) x)
{ğ•œ : Type u_1} {_x : ring ğ•œ} {E : Type u_2} [semi_normed_group E] {_x_1 : module ğ•œ E} {s : submodule ğ•œ E} (x : â†¥s) : âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
{X : Type u_1} [pseudo_metric_space X] [proper_space X] {s : set X} (hs : metric.bounded s) {x : â„• â†’ X} (hx : âˆƒá¶  (n : â„•) in filter.at_top, x n âˆˆ s) : âˆƒ (a : X) (H : a âˆˆ closure s) (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ filter.tendsto (x âˆ˜ Ï†) filter.at_top (nhds a)
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hl : Î¼.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : u â‰¤á¶ [lt] v) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R â‰ƒ+* S) : ideal.comap â†‘f (ideal.comap â†‘(f.symm) I) = I
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space Î±} (p : ennreal) (Î¼ : measure_theory.measure Î±) [normed_group E] [normed_group F] {ğ•œ : Type u_5} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] F) : â†¥(measure_theory.Lp E p Î¼) â†’â‚—[ğ•œ] â†¥(measure_theory.Lp F p Î¼)
{Î± : Type u_1} {E : Type u_3} {F'' : Type u_10} [has_norm E] [normed_group F''] {f : Î± â†’ E} {g'' : Î± â†’ F''} (h : f =O[filter.cofinite] g'') : âˆƒ (C : â„) (H : C > 0), âˆ€ â¦ƒx : Î±â¦„, g'' x â‰  0 â†’ âˆ¥f xâˆ¥ â‰¤ C * âˆ¥g'' xâˆ¥
{R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) : (Î» (t : R), ring.inverse (â†‘x + t) - â†‘xâ»Â¹ + â†‘xâ»Â¹ * t * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ 2
{R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] (f : monoid_algebra R M) : f âˆˆ algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â†‘(f.support))
(R : Type u_1) {V : Type u_2} {W : Type u_3} (P : Type u_4) {Q : Type u_5} [ring R] [add_comm_group V] [module R V] [topological_space P] [add_torsor V P] [add_comm_group W] [module R W] [topological_space Q] [add_torsor W Q] (q : Q) : P â†’A[R] Q
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (h : box_integral.integrable I l f vol) : filter.tendsto (Î» (Ï€ : box_integral.tagged_prepartition I Ã— box_integral.tagged_prepartition I), (box_integral.integral_sum f vol Ï€.fst, box_integral.integral_sum f vol Ï€.snd)) ((l.to_filter I).prod (l.to_filter I) âŠ“ filter.principal {Ï€ : box_integral.tagged_prepartition I Ã— box_integral.tagged_prepartition I | Ï€.fst.Union = Ï€.snd.Union}) (uniformity F)
{R : Type u_1} [comm_semiring R] (n : â„•) (Ï† : power_series R) : polynomial R
{L : first_order.language} {Î± : Type u'} {n : â„•} (Ï† : L.bounded_formula Î± (n + 1)) : L.bounded_formula Î± n
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ E'] [inner_product_space â„ G] [complete_space E'] {Ï† : cont_diff_bump_of_inner 0} [borel_space G] [measure_theory.is_locally_finite_measure Î¼] [Î¼.is_open_pos_measure] [finite_dimensional â„ G] [Î¼.is_add_left_invariant] {xâ‚€ : G} {Îµ : â„} (hmg : measure_theory.ae_strongly_measurable g Î¼) (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ Ï†.R â†’ has_dist.dist (g x) (g xâ‚€) â‰¤ Îµ) : has_dist.dist (convolution (Ï†.normed Î¼) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) (g xâ‚€) â‰¤ Îµ
{R : Type u} (Ïƒ : Type u_1) [comm_semiring R] {Aâ‚ : Type u_2} {Aâ‚‚ : Type u_3} [comm_semiring Aâ‚] [comm_semiring Aâ‚‚] [algebra R Aâ‚] [algebra R Aâ‚‚] (e : Aâ‚ â‰ƒâ‚[R] Aâ‚‚) : mv_polynomial Ïƒ Aâ‚ â‰ƒâ‚[R] mv_polynomial Ïƒ Aâ‚‚
{R : Type u_2} [semiring R] {Ïƒ : Type u_1} [fintype Ïƒ] : hahn_series (Ïƒ â†’â‚€ â„•) R â‰ƒ+* mv_power_series Ïƒ R
{Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (fbot : f âŠ¥ = âŠ¥) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
{L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] [L.Structure N] (f : L.embedding M N) (htv : âˆ€ (n : â„•) (Ï† : L.bounded_formula empty (n + 1)) (x : fin n â†’ M) (a : N), Ï†.realize inhabited.default (fin.snoc (â‡‘f âˆ˜ x) a) â†’ (âˆƒ (b : M), Ï†.realize inhabited.default (fin.snoc (â‡‘f âˆ˜ x) (â‡‘f b)))) {n : â„•} (Ï† : L.formula (fin n)) (x : fin n â†’ M) : Ï†.realize (â‡‘f âˆ˜ x) â†” Ï†.realize x
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {Râ‚ Râ‚‚ : â„} {f : â„‚ â†’ E} {c z : â„‚} (hd : differentiable_on â„‚ f (metric.ball c Râ‚)) (h_maps : set.maps_to f (metric.ball c Râ‚) (metric.ball (f c) Râ‚‚)) (hz : z âˆˆ metric.ball c Râ‚) : âˆ¥dslope f c zâˆ¥ â‰¤ Râ‚‚ / Râ‚
{R : Type u_1} [euclidean_domain R] {abv : absolute_value R â„¤} {Î¹ : Type u_2} [fintype Î¹] {Îµ : â„} (hÎµ : 0 < Îµ) {b : R} (hb : b â‰  0) (A : Î¹ â†’ R) (h : abv.is_admissible) : âˆƒ (t : Î¹ â†’ fin (h.card Îµ)), âˆ€ (iâ‚€ iâ‚ : Î¹), t iâ‚€ = t iâ‚ â†’ â†‘(â‡‘abv (A iâ‚ % b - A iâ‚€ % b)) < â‡‘abv b â€¢ Îµ
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] (U : set (L â‰ƒâ‚[K] L)) : U âˆˆ gal_basis K L â†” U âˆˆ subgroup.carrier '' fixed_by_finite K L
{C : Type uâ‚} [category_theory.category C] {W X Y Z : C} (f : W âŸ¶ X) (g : Y âŸ¶ Z) (h : W = Y) (h' : X = Z) : f = category_theory.eq_to_hom h â‰« g â‰« category_theory.eq_to_hom _ â†” f == g
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = s.sum (Î» (i : Î¹), f i * g i) â†” monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
(Î± : Type u_1) {Î² : Type u_2} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î²] (b : Î²) : Î± â†’â‚˜[Î¼] Î²
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : ae_measurable f Î¼) {g : Î± â†’ ennreal} (hg : ae_measurable g (Î¼.with_density f)) : âˆ«â» (a : Î±), g a âˆ‚Î¼.with_density f = âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼
{k : Type uâ‚} {G : Type uâ‚‚} [semiring k] [add_zero_class G] (f : add_monoid_algebra k G) : f âˆˆ submodule.span k (â‡‘(add_monoid_algebra.of k G) '' â†‘(f.support))
{k : Type uâ‚} {G : Type uâ‚‚} [monoid G] [comm_semiring k] {V W : Type uâ‚ƒ} [add_comm_monoid V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] [add_comm_monoid W] [module k W] [module (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (f : V â†’â‚—[k] W) (h : âˆ€ (g : G) (v : V), â‡‘f (finsupp.single g 1 â€¢ v) = finsupp.single g 1 â€¢ â‡‘f v) : V â†’â‚—[monoid_algebra k G] W
{R : Type u} [comm_ring R] (I J : ideal R) : (R â§¸ I) â§¸ ideal.map (ideal.quotient.mk I) J â‰ƒ+* (R â§¸ J) â§¸ ideal.map (ideal.quotient.mk J) I
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (f g : E â†’SL[Ïƒâ‚â‚‚] F) : âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] (p : mv_polynomial Ïƒ R) : multiset Ïƒ
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.ae_strongly_measurable f (Î¼.prod Î½)) : measure_theory.ae_strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½) Î¼
(n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : â„¤} (hb : b â‰  0) (A : fin n â†’ â„¤) : âˆƒ (t : fin n â†’ fin âŒˆ1 / ÎµâŒ‰â‚Š), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†’ â†‘|A iâ‚ % b - A iâ‚€ % b| < |b| â€¢ Îµ
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {f : E â†’L[â„] E} (hf : â‡‘linear_map.det â†‘f â‰  0) (s : set E) : â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |(â‡‘linear_map.det â†‘f)â»Â¹| * â‡‘Î¼ s
(c : interactive.parse (optional (lean.parser.tk "!"))) (cfg : tactic.tauto_cfg := {classical := bool.ff, closer := has_pure.pure ()}) : tactic unit
{ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (hâ‚€ : r â‰  0) {a : â„} (ha : a âˆˆ set.Ioo (-1) 1) (hp : (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =O[filter.at_top] has_pow.pow a) : â†‘r < p.radius
{R : Type u_1} [comm_ring R] (p : â„•) [char_p R p] (I : ideal R) (h : âˆ€ (x : â„•), â†‘x âˆˆ I â†’ â†‘x = 0) : char_p (R â§¸ I) p
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ F'} {s : set Î±} (hm : m â‰¤ m0) (hs : measurable_set s) (hf : f =áµ[Î¼.restrict sá¶œ] 0) : measure_theory.condexp m Î¼ (s.indicator f) =áµ[Î¼] s.indicator (measure_theory.condexp m Î¼ f)
{Î± : Type u_1} {C : multiset Î± â†’ Sort u_4} (m : multiset Î±) (C_0 : C 0) (C_cons : Î  (a : Î±) (m : multiset Î±), C m â†’ C (a ::â‚˜ m)) (C_cons_heq : âˆ€ (a a' : Î±) (m : multiset Î±) (b : C m), C_cons a (a' ::â‚˜ m) (C_cons a' m b) == C_cons a' (a ::â‚˜ m) (C_cons a m b)) : C m
{Î± : Type} [monoid Î±] [add_monoid Î±] (d j : â„•) : holor Î± [d]
{M : Type u_1} [has_add M] (c : add_con M) [d : Î  (a b : M), decidable (â‡‘c a b)] : decidable_eq c.quotient
(c : name) (cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : tactic unit
{Î± : Type u_1} [fintype Î±] [decidable_eq Î±] (Ïƒ : equiv.perm Î±) : Prop
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (f : E â‰ƒâ‚—[â„] E) (s : set E) : â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |â‡‘linear_map.det â†‘(f.symm)| * â‡‘Î¼ s
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s : set Î±} [measure_theory.is_finite_measure Î¼] (hcs : â‡‘Î¼ s â‰  0) : measure_theory.is_probability_measure (probability_theory.cond Î¼ s)
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : normed_group_hom Vâ‚ Vâ‚‚) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ M * âˆ¥xâˆ¥) : âˆ¥fâˆ¥ â‰¤ M
{Î± : Type u} (s : set Î±) : (Î» (x : Î±), x) '' s = s
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : set Î±} (hs : measurable_set s) : â‡‘(Î¼.restrict s) t = â‡‘Î¼ (t âˆ© s)
{Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =O[l] g' â†” âˆ€á¶  (c : â„) in filter.at_top, âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g' xâˆ¥
{Î± : Type u_1} {E : Type u_4} {ğ•œ : Type u_6} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_field ğ•œ] [normed_space ğ•œ E] : module ğ•œ â†¥(measure_theory.Lp.simple_func E p Î¼)
{Î¹ : Type u_1} {X : Type u_2} [emetric_space X] {Î¼ : measure_theory.outer_measure X} (hm : Î¼.is_metric) {I : finset Î¹} {s : Î¹ â†’ set X} (hI : âˆ€ (i : Î¹), i âˆˆ I â†’ âˆ€ (j : Î¹), j âˆˆ I â†’ i â‰  j â†’ is_metric_separated (s i) (s j)) : â‡‘Î¼ (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) = I.sum (Î» (i : Î¹), â‡‘Î¼ (s i))
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (h : W âŸ¶ X) (k : W âŸ¶ Y) (Hâ‚ : category_theory.limits.is_initial W) (Hâ‚‚ : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk f g)) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk f g _)
(k : â„•) {r : â„} (hr : |r| < 1) : filter.tendsto (Î» (n : â„•), â†‘n ^ k * r ^ n) filter.at_top (nhds 0)
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
{F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ x
{C : Type u} [category_theory.category C] {W X Y Z : C} [category_theory.limits.has_binary_product W X] [category_theory.limits.has_binary_product Y Z] (f : W âŸ¶ Y) (g : X âŸ¶ Z) : W â¨¯ X âŸ¶ Y â¨¯ Z
{I : Type u} (f : I â†’ Type v) [Î  (i : I), has_add (f i)] (i : I) : add_hom (Î  (i : I), f i) (f i)
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (h'f : measurable f) : measure_theory.measure.map f ((Î¼.restrict s).with_density (Î» (x : E), ennreal.of_real |(f' x).det|)) = Î¼.restrict (f '' s)
{Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), add_comm_group (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’+ G j) (i : Î¹) : G i â†’â‚—[â„¤] add_comm_group.direct_limit G f
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M â†’ M') (s : set M) (x : M) : Prop
{M : Type u_1} [has_mul M] (S : set (con M)) : (has_Inf.Inf S).to_setoid = has_Inf.Inf (con.to_setoid '' S)
{Î± : Type u_1} [normed_ring Î±] [complete_space Î±] {f g : â„• â†’ Î±} (hf : summable (Î» (x : â„•), âˆ¥f xâˆ¥)) (hg : summable (Î» (x : â„•), âˆ¥g xâˆ¥)) : (âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.range (n + 1)).sum (Î» (k : â„•), f k * g (n - k))
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) [fintype Î“] (S : finset Î›) : finset turing.TM1to1.Î›'
(p : â„•) (f : Î  â¦ƒR : Type u_3â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R) : Prop
(args : interactive.parse interactive.types.opt_pexpr_list) (attrs : interactive.parse interactive.types.with_ident_list) (n : â„• := 50) (opt : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : tactic unit
{E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {v : â„ â†’ E â†’ E} {t_min tâ‚€ t_max : â„} (htâ‚€ : tâ‚€ âˆˆ set.Icc t_min t_max) (xâ‚€ : E) {C R : â„} (hR : 0 â‰¤ R) {L : nnreal} (Hlip : âˆ€ (t : â„), t âˆˆ set.Icc t_min t_max â†’ lipschitz_on_with L (v t) (metric.closed_ball xâ‚€ R)) (Hcont : âˆ€ (x : E), x âˆˆ metric.closed_ball xâ‚€ R â†’ continuous_on (Î» (t : â„), v t x) (set.Icc t_min t_max)) (Hnorm : âˆ€ (t : â„), t âˆˆ set.Icc t_min t_max â†’ âˆ€ (x : E), x âˆˆ metric.closed_ball xâ‚€ R â†’ âˆ¥v t xâˆ¥ â‰¤ C) (Hmul_le : C * linear_order.max (t_max - tâ‚€) (tâ‚€ - t_min) â‰¤ R) : âˆƒ (f : â„ â†’ E), f tâ‚€ = xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ set.Icc t_min t_max â†’ has_deriv_within_at f (v t (f t)) (set.Icc t_min t_max) t
{R : Type u_5} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (h : is_primitive_root Î¶ n) : â‡‘multiset.card (polynomial.nth_roots n 1) = n
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (hp1p2 : p1 â‰  p2) (hp3p2 : p3 â‰  p2) : has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2| â†” euclidean_geometry.angle p1 p2 p3 = 0
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] (M : turing.TM0.machine Î“ Î›) (S : set Î›) : Prop
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i)
{Î± : Type u_1} {Î² : Type u_2} [mul_one_class Î±] [mul_one_class Î²] (f : Î± â†’* Î²) (I : Type u_3) : (I â†’ Î±) â†’* I â†’ Î²
{Î± : Sort u_1} {Ï† : Sort u_4} {sâ‚ : setoid Î±} (q : quotient sâ‚) (f : Î± â†’ Ï†) (h : âˆ€ (a b : Î±), setoid.r a b â†’ f a = f b) : Ï†
{M : Type u_1} [add_monoid M] {A : Type u_2} [add_monoid A] {f : M â†’ A} (hf : is_add_monoid_hom f) (s : set M) : f '' add_monoid.closure s = add_monoid.closure (f '' s)
{C : snum â†’ Sort u_1} (z : Î  (b : bool), C (snum.zero b)) (s : Î  (b : bool) (p : snum), C p â†’ C (b::p)) (p : nzsnum) : C â†‘p
(Î± : Type u) (Î² : Type v) [group Î±] [mul_action Î± Î²] [fintype Î±] [fintype Î²] [fintype (quotient (mul_action.orbit_rel Î± Î²))] [Î  (b : Î²), fintype â†¥(mul_action.stabilizer Î± b)] : fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(mul_action.stabilizer Î± Ï‰.out'))
{Î± : Type u_1} {m : measurable_space Î±} (s : measure_theory.signed_measure Î±) (i : set Î±) (hiâ‚ : measurable_set i) (hiâ‚‚ : measure_theory.vector_measure.restrict s i â‰¤ 0.restrict i) : measure_theory.measure Î±
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (hl : l â‰¤ box_integral.integration_params.Henstock) (B : box_integral.box_additive_map Î¹ â„ â†‘I) (hB0 : âˆ€ (J : box_integral.box Î¹), 0 â‰¤ â‡‘B J) (g : box_integral.box_additive_map Î¹ F â†‘I) (s : set (Î¹ â†’ â„)) (hs : s.countable) (Hâ‚ : âˆ€ (c : nnreal) (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I âˆ© s â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ â‡‘box_integral.box.Icc J âŠ† metric.closed_ball x Î´ â†’ x âˆˆ â‡‘box_integral.box.Icc J â†’ (â†¥(l.bDistortion) â†’ J.distortion â‰¤ c) â†’ has_dist.dist (â‡‘(â‡‘vol J) (f x)) (â‡‘g J) â‰¤ Îµ)) (Hâ‚‚ : âˆ€ (c : nnreal) (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I  s â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ â‡‘box_integral.box.Icc J âŠ† metric.closed_ball x Î´ â†’ x âˆˆ â‡‘box_integral.box.Icc J â†’ (â†¥(l.bDistortion) â†’ J.distortion â‰¤ c) â†’ has_dist.dist (â‡‘(â‡‘vol J) (f x)) (â‡‘g J) â‰¤ Îµ * â‡‘B J)) : box_integral.has_integral I l f vol (â‡‘g I)
(s : â„) (hs : 1 < s) : measure_theory.integrable_on (Î» (x : â„), âˆ¥real.exp (-x) * real.log x * x ^ (s - 1)âˆ¥) (set.Ioi 0) measure_theory.measure_space.volume
{M : Type u_1} {Ïƒ : Type u_4} [has_add M] {N : Type u_2} [has_add N] [set_like Ïƒ M] [add_mem_class Ïƒ M] (f : add_hom M N) (S : Ïƒ) : add_hom â†¥S N
(e : expr) (cfg : tactic.equiv_rw_cfg := {max_depth := 10}) : tactic unit
{C : Type uâ‚} [category_theory.category C] (D : category_theory.glue_data C) [category_theory.limits.has_multicoequalizer D.diagram] (F : C â¥¤ Type v) [category_theory.limits.preserves_colimit D.diagram.multispan F] [Î  (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] (x : F.obj D.glued) : âˆƒ (i : D.J) (y : F.obj (D.U i)), F.map (D.Î¹ i) y = x
{Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hl : Î¼.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
{ğ•œ : Type u_1} [normed_field ğ•œ] [complete_space ğ•œ] {r : ğ•œ} (hr : âˆ¥râˆ¥ < 1) : âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : â„} {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : asymptotics.is_O_with c l f' g â†’ asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) g
(ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} [linear_order Î¹] [order_bot Î¹] [locally_finite_order Î¹] [is_well_order Î¹ has_lt.lt] [succ_order Î¹] [is_succ_archimedean Î¹] (f : Î¹ â†’ E) (c : Î¹) : submodule.span ğ•œ (gram_schmidt ğ•œ f '' set.Iio c) = submodule.span ğ•œ (f '' set.Iio c)
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {S : J.cover X} (I : S.relation) : S.arrow
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {Î² Î³ : Type v} [fintype Î²] [decidable_eq Î²] [decidable_eq Î³] (Îµ : Î² â‰ƒ Î³) (f : Î³ â†’ C) [category_theory.limits.has_biproduct f] [category_theory.limits.has_biproduct (f âˆ˜ â‡‘Îµ)] : â¨ f âˆ˜ â‡‘Îµ â‰… â¨ f
â¦ƒJ : Type uâ¦„ (F : J â†’ category_theory.Groupoid) : category_theory.limits.is_limit (category_theory.Groupoid.pi_limit_fan F)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) {Râ‚‚ : Type u_3} {Mâ‚‚ : Type u_4} [ring Râ‚‚] [add_comm_group Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {Râ‚ƒ : Type u_5} {Mâ‚ƒ : Type u_6} [ring Râ‚ƒ] [add_comm_group Mâ‚ƒ] [module Râ‚ƒ Mâ‚ƒ] (pâ‚‚ : submodule Râ‚‚ Mâ‚‚) (pâ‚ƒ : submodule Râ‚ƒ Mâ‚ƒ) {Ï„â‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ} {Ï„â‚â‚ƒ : R â†’+* Râ‚ƒ} [ring_hom_comp_triple Ï„â‚â‚‚ Ï„â‚‚â‚ƒ Ï„â‚â‚ƒ] (f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚) (g : Mâ‚‚ â†’â‚›â‚—[Ï„â‚‚â‚ƒ] Mâ‚ƒ) (hf : p â‰¤ submodule.comap f pâ‚‚) (hg : pâ‚‚ â‰¤ submodule.comap g pâ‚ƒ) (h : p â‰¤ submodule.comap f (submodule.comap g pâ‚ƒ) := _) : p.mapq pâ‚ƒ (g.comp f) h = (pâ‚‚.mapq pâ‚ƒ g hg).comp (p.mapq pâ‚‚ f hf)
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {p : add_localization S â†’ Sort u} (f : Î  (a : M) (b : â†¥S), p (add_localization.mk a b)) (H : âˆ€ {a c : M} {b d : â†¥S} (h : â‡‘(add_localization.r S) (a, b) (c, d)), eq.rec (f a b) _ = f c d) (x : add_localization S) : p x
{Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) (s : set Î±) : set Î±
(rev : interactive.parse (optional (lean.parser.tk "!"))) (h : interactive.parse (optional interactive.types.ident_)) (_x : interactive.parse (lean.parser.tk ":")) (arg : interactive.parse h_generalize_arg_p) (eqs_h : interactive.parse (lean.parser.tk "with" *> î€€has_pure.pureî€has_pure.pureî€‚î€€functor.mapî€ <$> î€‚î€€interactive.types.ident_î€interactive.types.ident_î€‚ <|> has_pure.pure list.nil)) : tactic unit
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : Î± â†’ Prop} (hst : s =áµ[Î¼] t) {p : Î± â†’ Prop} : (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, p x) â†” âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, p x
(md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x y = real.pi) : âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{Î± : Sort u} {Î² : Sort v} {W : Î± â†’ Sort w} {Z : Î² â†’ Sort z} (hâ‚ : Î± â‰ƒ Î²) (hâ‚‚ : Î  (b : Î²), W (â‡‘(hâ‚.symm) b) â‰ƒ Z b) : (Î  (a : Î±), W a) â‰ƒ Î  (b : Î²), Z b
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} {S : J.cover X} {T : Î  (I : S.arrow), J.cover I.Y} (I : (S.bind T).arrow) : I.Y âŸ¶ I.middle
(M : Type u_1) (N : Type u_2) (Î¼ : M â†’ N â†’ N) (r : N â†’ N â†’ Prop) : Prop
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : normed_group_hom Vâ‚ Vâ‚‚) : lipschitz_with âŸ¨âˆ¥fâˆ¥, _âŸ© â‡‘f
{Î± : Type u} [linear_ordered_add_comm_group Î±] {a b x : Î±} (h : x âˆˆ set.interval a b) : |b - x| â‰¤ |b - a|
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
(R : Type u_1) [semiring R] {Î¹ : Type u_4} (Ï† : Î¹ â†’ Type u_5) [Î  (i : Î¹), topological_space (Ï† i)] [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] {I J : set Î¹} [decidable_pred (Î» (i : Î¹), i âˆˆ I)] (hd : disjoint I J) (hu : set.univ âŠ† I âˆª J) : (â†¥â¨… (i : Î¹) (H : i âˆˆ J), (continuous_linear_map.proj i).ker) â‰ƒL[R] Î  (i : â†¥I), Ï† â†‘i
{N : Type u_1} {G : Type u_2} {H : Type u_3} [group N] [group G] [group H] {Ï† : G â†’* mul_aut N} {f g : N â‹Š[Ï†] G â†’* H} (hl : f.comp semidirect_product.inl = g.comp semidirect_product.inl) (hr : f.comp semidirect_product.inr = g.comp semidirect_product.inr) : f = g
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {G : Type u_4} [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] (g : G) : left_invariant_derivation I G â†’â‚—[ğ•œ] point_derivation I g
{Î¹ : Type u_1} {I : box_integral.box Î¹} [fintype Î¹] (Ï€ : box_integral.prepartition I) : box_integral.prepartition I
{Î± : Type u_1} {G : Type u_8} [normed_group G] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} [normed_space â„ G] (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (x : G) : â†¥(measure_theory.Lp G 1 Î¼)
{Î± : Type u_2} [measurable_space Î±] (f : Î± â†’ Î±) (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} (hom : Î  (i j : Î¹), C.X i âŸ¶ D.X j) (zero' : âˆ€ (i j : Î¹), Â¬c.rel j i â†’ hom i j = 0) : homotopy (homotopy.null_homotopic_map hom) 0
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {f g : measure_theory.simple_func Î± ennreal} (hfg : f â‰¤ g) (hÎ¼Î½ : Î¼ â‰¤ Î½) : f.lintegral Î¼ â‰¤ g.lintegral Î½
{Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), semi_normed_group (Ï€ i)] (x : Î  (i : Î¹), Ï€ i) : finset.univ.sum (Î» (i : Î¹), âˆ¥x iâˆ¥) â‰¤ fintype.card Î¹ â€¢ âˆ¥xâˆ¥
{Î± : Type u_1} {C : multiset Î± â†’ Sort u_4} (C_0 : C 0) (C_cons : Î  (a : Î±) (m : multiset Î±), C m â†’ C (a ::â‚˜ m)) (C_cons_heq : âˆ€ (a a' : Î±) (m : multiset Î±) (b : C m), C_cons a (a' ::â‚˜ m) (C_cons a' m b) == C_cons a' (a ::â‚˜ m) (C_cons a m b)) (m : multiset Î±) : C m
{Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {l : filter Î¹} [normed_group E] [normed_space â„ E] [complete_space E] [l.ne_bot] [l.is_countably_generated] {Ï† : Î¹ â†’ set Î±} (hÏ† : measure_theory.ae_cover Î¼ l Ï†) {f : Î± â†’ E} (I : E) (hfi : measure_theory.integrable f Î¼) (h : filter.tendsto (Î» (n : Î¹), âˆ« (x : Î±) in Ï† n, f x âˆ‚Î¼) l (nhds I)) : âˆ« (x : Î±), f x âˆ‚Î¼ = I
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {F : Type u_5} [normed_group F] [normed_space ğ•œ F] (Z : basic_smooth_vector_bundle_core I M F) : topological_vector_bundle_core ğ•œ M F â†¥(charted_space.atlas H M)
{Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [Î  (i : Î¹), topological_space (Ï€ i)] {s : Î  (i : Î¹), set (Ï€ i)} (h : âˆ€ (i : Î¹), is_compact (s i)) : is_compact (set.univ.pi s)
{E : Type u_1} [semi_normed_group E] {s : add_subgroup E} (x : â†¥s) : âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â†ªg G') : â†¥(G.edge_set) â†ª â†¥(G'.edge_set)
{E : Type u_1} [semi_normed_group E] [normed_space â„ E] (p : subspace â„ E) (f : â†¥p â†’L[â„] â„) : âˆƒ (g : E â†’L[â„] â„), (âˆ€ (x : â†¥p), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥
{R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring Sâ‚] (f : R â†’+* Sâ‚) (g : Ïƒ â†’ Sâ‚) : mv_polynomial Ïƒ R â†’+* Sâ‚
(Î± : Type u_1) (E : Type u_4) (ğ•œ : Type u_6) [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] [normed_field ğ•œ] [normed_space ğ•œ E] : â†¥(measure_theory.Lp.simple_func E p Î¼) â†’L[ğ•œ] â†¥(measure_theory.Lp E p Î¼)
{Vâ‚ : Type u_1} {Vâ‚‚ : Type u_2} [normed_group Vâ‚] [normed_group Vâ‚‚] {f : normed_group_hom Vâ‚ Vâ‚‚} : âˆ¥fâˆ¥ = 0 â†” f = 0
{t : â„‚} {s1 s2 x : â„} (ht1 : s1 â‰¤ t.re) (ht2 : t.re â‰¤ s2) (hx : 0 < x) : âˆ¥dGamma_integrand t xâˆ¥ â‰¤ dGamma_integrand_real s1 x + dGamma_integrand_real s2 x
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {Î¼ : measure_theory.measure G} [measure_theory.sigma_finite Î¼] [Î¼.is_mul_left_invariant] {K : set G} (hK : is_compact K) (h2K : (interior K).nonempty) (hÎ¼K : â‡‘Î¼ K â‰  âŠ¤) : Î¼.regular
{Î¹ : Type u_1} [fintype Î¹] {I : box_integral.box Î¹} (Ï€â‚ : box_integral.tagged_prepartition I) (Ï€â‚‚ : box_integral.prepartition I) (hU : Ï€â‚‚.Union = â†‘I  Ï€â‚.Union) (r : (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)) : box_integral.tagged_prepartition I
(limit : option â„• := option.none) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := Î» (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (Î» (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic (list tactic.suggest.application)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] {s : category_theory.limits.trident f} (hs : category_theory.limits.is_limit s) {W : C} (k : W âŸ¶ X) (h : âˆ€ (jâ‚ jâ‚‚ : J), k â‰« f jâ‚ = k â‰« f jâ‚‚) : {l // l â‰« s.Î¹ = k}
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : E â†’L[ğ•œ] F) [complete_space F] [complete_space E] (surj : function.surjective â‡‘f) : âˆƒ (C : â„) (H : C > 0), âˆ€ (y : F), âˆƒ (x : E), â‡‘f x = y âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
{G : Type u_1} {Î± : Type u_2} [add_group G] [add_action G Î±] [measurable_space Î±] {s t : set Î±} {Î¼ : measure_theory.measure Î±} [measurable_space G] [has_measurable_vadd G Î±] [measure_theory.vadd_invariant_measure G Î± Î¼] [encodable G] (hs : measure_theory.is_add_fundamental_domain G s Î¼) (ht : measure_theory.is_add_fundamental_domain G t Î¼) : â‡‘Î¼ s = â‡‘Î¼ t
{G : Type u} [group G] {H : Type v} [group H] (Ï† : G â†’* H) : G â§¸ Ï†.ker â†’* H
{Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] [measurable_space Î³] [borel_space Î³] {Î² : Type u_4} [tÎ² : topological_space Î²] [t2_space Î²] [measurable_space Î²] [borel_space Î²] {s : set Î³} {f : Î³ â†’ Î²} [topological_space.second_countable_topology Î²] (hs : measurable_set s) (f_meas : measurable f) (f_inj : set.inj_on f s) : measurable_set (f '' s)
{Î± : Type u_1} [decidable_eq Î±] {s : finset Î±} {p : Î  (t : finset Î±), t âŠ‚ s â†’ Prop} [Î  (t : finset Î±) (h : t âŠ‚ s), decidable (p t h)] : decidable (âˆƒ (t : finset Î±) (h : t âŠ‚ s), p t h)
{V : Type u_1} {W : Type u_2} {Vâ‚ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group Vâ‚] {f g : normed_group_hom V W} (Ï† : normed_group_hom Vâ‚ V) (h : f.comp Ï† = g.comp Ï†) : normed_group_hom Vâ‚ â†¥(f.equalizer g)
{E : Type u_1} [inner_product_space â„ E] {v : E} [complete_space E] (hv : âˆ¥vâˆ¥ = 1) : local_homeomorph â†¥(metric.sphere 0 1) â†¥(submodule.span â„ {v})á—®
{n : â„•} {a : fin (n + 2)} {b : fin (n + 1)} (ha : a â‰  0) (hb : b â‰  0) (hk : â‡‘(a.succ_above) b â‰  0 := _) : â‡‘((a.pred ha).succ_above) (b.pred hb) = (â‡‘(a.succ_above) b).pred hk
{Î¹ : Type u} {E : Type v} [normed_group E] [normed_space â„ E] [fintype Î¹] (l : box_integral.integration_params) [complete_space E] {I : box_integral.box Î¹} {f : (Î¹ â†’ â„) â†’ E} (hc : continuous_on f (â‡‘box_integral.box.Icc I)) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] : box_integral.integrable I l f Î¼.to_box_additive.to_smul
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} (h : Î  (i j : Î¹), c.rel j i â†’ (C.X i âŸ¶ D.X j)) : homotopy (homotopy.null_homotopic_map' h) 0
{G : Type u_1} [measurable_space G] [has_add G] [has_measurable_add G] (Î¼ : measure_theory.measure G) : (âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), h + g) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_add_right_invariant
{E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : filter.tendsto (Î» (x : â„), f â†‘x) filter.at_top (nhds 0)) (him : âˆ€ (x : â„), âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz : 0 â‰¤ z.re) : âˆ¥f zâˆ¥ â‰¤ C
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} (h : âˆ€ (x : M), x âˆˆ s â†’ (âˆƒ (u : set M), is_open u âˆ§ x âˆˆ u âˆ§ cont_mdiff_on I I' n f (s âˆ© u))) : cont_mdiff_on I I' n f s
{R : Type u} {S : Type v} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring S] {fâ‚ fâ‚‚ : mv_polynomial Ïƒ R â†’+* S} {pâ‚ pâ‚‚ : mv_polynomial Ïƒ R} (hC : fâ‚.comp mv_polynomial.C = fâ‚‚.comp mv_polynomial.C) (hv : âˆ€ (i : Ïƒ), i âˆˆ pâ‚.vars â†’ i âˆˆ pâ‚‚.vars â†’ â‡‘fâ‚ (mv_polynomial.X i) = â‡‘fâ‚‚ (mv_polynomial.X i)) (hp : pâ‚ = pâ‚‚) : â‡‘fâ‚ pâ‚ = â‡‘fâ‚‚ pâ‚‚
{R : Type u} [semiring R] (I : ideal (polynomial R)) (n : with_bot â„•) : submodule R (polynomial R)
{R : Type u_4} [normed_ring R] [complete_space R] (x : R) (h : âˆ¥xâˆ¥ < 1) : summable (Î» (n : â„•), x ^ n)
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (H : âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î² : Type u) (_x : fintype Î²) (F : â†¥s â†’ Î²), âˆ€ (x y : â†¥s), F x = F y â†’ has_dist.dist â†‘x â†‘y < Îµ)) : totally_bounded s
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {Îµ : Type u_5} {Î¶ : Type u_6} (f : Î± â†’ Î²) (f' : Î³ â†’ Î´) (g : Î² â†’ Îµ) (g' : Î´ â†’ Î¶) : prod.map g g' âˆ˜ prod.map f f' = prod.map (g âˆ˜ f) (g' âˆ˜ f')
(cfg : tactic.interactive.mono_cfg := {unify := bool.ff}) : tactic unit
(Î± : Type u_1) (E : Type u_2) (ğ•œ : Type u_4) [normed_group E] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_field ğ•œ] [normed_space ğ•œ E] [normed_space â„ E] [smul_comm_class â„ ğ•œ E] : â†¥(measure_theory.Lp.simple_func E 1 Î¼) â†’L[ğ•œ] E
{F : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [mul_one_class Î±] [mul_one_class Î²] [monoid_hom_class F Î± Î²] (Ï† : F) : filter Î± â†’* filter Î²
{Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topological_space Î²] (f : filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : set Î±) (y : Î²) : y âˆˆ omega_limit f Ï• s â†” âˆ€ (n : set Î²), n âˆˆ nhds y â†’ (âˆƒá¶  (t : Ï„) in f, (Ï• t '' s âˆ© n).nonempty)
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s t : set Î±} (Hf : monotone_on f t) (Hst : s âŠ† t) : (lower_bounds s âˆ© t).nonempty â†’ bdd_below (f '' s)
{E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (A : E â†’L[â„] E) {m : nnreal} (hm : ennreal.of_real |A.det| < â†‘m) : âˆ€á¶  (Î´ : nnreal) in nhds_within 0 (set.Ioi 0), âˆ€ (s : set E) (f : E â†’ E), approximates_linear_on f A s Î´ â†’ â‡‘Î¼ (f '' s) â‰¤ â†‘m * â‡‘Î¼ s
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} {Ïƒ : Type u_4} (S : finset Î›) : turing.TM2.stmt Î“ Î› Ïƒ â†’ Prop
{ğ•œ : Type u_1} {A : Type u_2} [comm_semiring ğ•œ] [topological_space ğ•œ] [has_continuous_add ğ•œ] [has_continuous_const_smul ğ•œ ğ•œ] [non_unital_non_assoc_semiring A] [topological_space A] [module ğ•œ A] (Ï† : â†¥(weak_dual.character_space ğ•œ A)) : A â†’â‚™â‚[ğ•œ] ğ•œ
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (x y : M â§¸ S) : âˆ¥x + yâˆ¥ â‰¤ âˆ¥xâˆ¥ + âˆ¥yâˆ¥
{Î± : Type u} [decidable_eq Î±] {Î² : Î± â†’ Type v} (hash_fn : Î± â†’ â„•) (nbuckets : â„• := 8) : hash_map Î± Î²
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {E : Type uâ‚ƒ} [category_theory.category E] (F : C â¥¤ E) (G : D â¥¤ E) [category_theory.faithful G] (obj : C â†’ D) (h_obj : âˆ€ (X : C), G.obj (obj X) = F.obj X) (map : Î  {X Y : C}, (X âŸ¶ Y) â†’ (obj X âŸ¶ obj Y)) (h_map : âˆ€ {X Y : C} {f : X âŸ¶ Y}, G.map (map f) == F.map f) : C â¥¤ D
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [ideal.is_jacobson R] (I : ideal R) (hI : I.is_maximal) (hy : y âˆ‰ I) : (ideal.map (algebra_map R S) I).is_maximal
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) {G : Type u_5} [topological_space G] [charted_space H G] [group G] [lie_group I G] : topological_group G
 : â„• â†’ list name â†’ (name := name.mk_string "_" name.anonymous) â†’ (option â„• := option.none) â†’ tactic (list expr Ã— list name)
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D E : homological_complex V c} (hom : Î  (i j : Î¹), C.X i âŸ¶ D.X j) (g : D âŸ¶ E) : homotopy.null_homotopic_map hom â‰« g = homotopy.null_homotopic_map (Î» (i j : Î¹), hom i j â‰« g.f j)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [fintype J] {K : Type v} [fintype K] {f : J â†’ C} {g : K â†’ C} [category_theory.limits.has_finite_biproducts C] (m : Î  (j : J) (k : K), f j âŸ¶ g k) : â¨ f âŸ¶ â¨ g
{Î± : Type u} [metric_space Î±] (H : âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î² : Type u_1) (_x : encodable Î²) (F : Î± â†’ Î²), âˆ€ (x y : Î±), F x = F y â†’ has_dist.dist x y â‰¤ Îµ)) : topological_space.second_countable_topology Î±
{k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [add_monoid G] {A : Type uâ‚ƒ} [semiring A] [algebra k A] â¦ƒÏ†â‚ Ï†â‚‚ : add_monoid_algebra k G â†’â‚[k] Aâ¦„ (h : â†‘Ï†â‚.comp (add_monoid_algebra.of k G) = â†‘Ï†â‚‚.comp (add_monoid_algebra.of k G)) : Ï†â‚ = Ï†â‚‚
(h new_type eq_pr : expr) (tag : name := name.mk_string "star" (name.mk_string "unit" name.anonymous)) : tactic expr
{M : Type u_1} [semi_normed_group M] {S : add_subgroup M} (x : M â§¸ S) : âˆ¥-xâˆ¥ = âˆ¥xâˆ¥
{J : Type uâ‚} [category_theory.category J] [category_theory.is_preconnected J] (Z : J â†’ Sort u_1) (hâ‚ : Î  {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ Z jâ‚ â†’ Z jâ‚‚) (hâ‚‚ : Î  {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ Z jâ‚‚ â†’ Z jâ‚) {jâ‚€ : J} (x : Z jâ‚€) (j : J) : nonempty (Z j)
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) [topological_space Î±] [borel_space Î±] [topological_space Î²] [second_countable_topology_either Î± Î²] [topological_space.pseudo_metrizable_space Î²] (f : C(Î±, Î²)) : Î± â†’â‚˜[Î¼] Î²
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {s : set E} (u : â„• â†’ E) (hu : metric.bounded (set.range u)) (hs : pairwise (disjoint on Î» (n : â„•), {u n} + s)) (h's : measurable_set s) : â‡‘Î¼ s = 0
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : is_R_or_C.abs (has_inner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] {n : â„•} (d : turing.dir) (q : turing.TM1.stmt bool turing.TM1to1.Î›' Ïƒ) : turing.TM1.stmt bool turing.TM1to1.Î›' Ïƒ
{Î± : Type u_1} {Î¹ : Type u_2} (I : set Î¹) (m : Î¹ â†’ measure_theory.outer_measure Î±) {s : set Î±} (hs : s.nonempty) : (â‡‘â¨… (i : Î¹) (H : i âˆˆ I), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹) (H : i âˆˆ I), â‡‘(m i) (t n)
{R : Type u_1} [comm_ring R] {k : â„•} (Ï† : mv_polynomial (fin k Ã— â„•) â„¤) (x : fin k â†’ â„• â†’ R) : R
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} {f : G â†’ E} {g : G} [group G] [has_measurable_mul G] [Î¼.is_mul_left_invariant] (hf' : âˆ€ (x : G), f (g * x) = -f x) : âˆ« (x : G), f x âˆ‚Î¼ = 0
{Ï€ Î± : Type} [decidable_eq Ï€] (Î² Ïƒ : Type) (init : Ï€ â†’ tactic Ïƒ) (update : Ï€ â†’ Ïƒ â†’ Î² â†’ tactic (Ïƒ Ã— option Î±)) (view : Ï€ â†’ Ïƒ â†’ tactic (list (widget.html Î²))) : widget.tc Ï€ Î±
{Î± : Type u_1} {m : measurable_space Î±} (c : measure_theory.complex_measure Î±) (Î¼ : measure_theory.measure Î±) : measure_theory.complex_measure Î±
{C : Type u} [category_theory.category C] {X Y : C} (f g : X âŸ¶ Y) {Z : C} (Ï€ : Y âŸ¶ Z) : Type v
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (Hf : monotone f) {s : set Î±} : bdd_below s â†’ bdd_below (f '' s)
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} (h : measurable_set s) : (Î¼.restrict s).to_outer_measure = â‡‘(measure_theory.outer_measure.restrict s) Î¼.to_outer_measure
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (h : box_integral.integrable I l f vol) (Îµ : â„) : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)
{F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * has_inner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
{C : Type uâ‚} [category_theory.category C] {I T : C} (hI : category_theory.limits.is_initial I) (hT : category_theory.limits.is_terminal T) (f : category_theory.mono (hI.to T)) : category_theory.limits.initial_mono_class C
(s : simp_lemmas Ã— list name) (ps : list pexpr) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {Î¹ : Type u_1} [topological_space Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} {s : set Î²} : tendsto_locally_uniformly_on F f p s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆ€ (x : Î²), x âˆˆ s â†’ (âˆƒ (t : set Î²) (H : t âˆˆ nhds_within x s), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_dist.dist (f y) (F n y) < Îµ)
{Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ennreal} [Î  (i : Î±), normed_group (E i)] {Î¹ : Type u_3} {l : filter Î¹} [l.ne_bot] [fact (1 â‰¤ p)] {C : â„} {F : Î¹ â†’ â†¥(lp E p)} (hCF : âˆ€á¶  (k : Î¹) in l, âˆ¥F kâˆ¥ â‰¤ C) {f : â†¥(lp E p)} (hf : filter.tendsto (id (Î» (i : Î¹), â‡‘(F i))) l (nhds â‡‘f)) : âˆ¥fâˆ¥ â‰¤ C
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {s t : set Î±} {Î¦ : Î± â†’ Î²} (h : isometry Î¦) : metric.Hausdorff_dist (Î¦ '' s) (Î¦ '' t) = metric.Hausdorff_dist s t
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [is_alg_closed K] [finite_dimensional K V] (f : module.End K V) : (â¨† (Î¼ : K) (k : â„•), â‡‘(f.generalized_eigenspace Î¼) k) = âŠ¤
{Î± : Type u_1} [nonempty Î±] [semilattice_sup Î±] {Î² : Type u_2} [semi_normed_group Î²] {f : Î± â†’ Î²} {b : Î²} : filter.tendsto f filter.at_top (nhds b) â†” âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (N : Î±), âˆ€ (n : Î±), N â‰¤ n â†’ âˆ¥f n - bâˆ¥ < Îµ)
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [group G] [topological_group G] [Î¼.is_mul_left_invariant] [Î¼.regular] (hâ‚€ : Î¼ â‰  0) : Î¼.is_open_pos_measure
{G : Type u_1} [measurable_space G] [has_inv G] (Î¼ : measure_theory.measure G) : Prop
{G : Type u_1} [normed_group G] [complete_space G] {H : Type u_2} [normed_group H] {f : normed_group_hom G H} {K : add_subgroup H} {C Îµ : â„} (hC : 0 < C) (hÎµ : 0 < Îµ) (hyp : f.surjective_on_with K C) : f.surjective_on_with K.topological_closure (C + Îµ)
(atoms : tactic.ref (buffer expr)) (red : tactic.transparency) (mode : tactic.ring.normalize_mode := tactic.ring.normalize_mode.horner) (e : expr) : tactic (expr Ã— expr)
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [t2_space (G â§¸ Î“)] [topological_space.second_countable_topology (G â§¸ Î“)] (K : topological_space.positive_compacts (G â§¸ Î“)) [Î“.normal] [Î¼.is_haar_measure] [Î¼.is_mul_right_invariant] (hğ“•_finite : â‡‘Î¼ ğ“• < âŠ¤) : measure_theory.measure.map â‡‘(quotient_group.mk' Î“) (Î¼.restrict ğ“•) = â‡‘Î¼ (ğ“• âˆ© â‡‘(quotient_group.mk' Î“) â»Â¹' â†‘K) â€¢ measure_theory.measure.haar_measure K
{Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {f : Î± â†’ E} {s : set Î±} {Î¼ : measure_theory.measure Î±} [complete_space E] [normed_space â„ E] (hs : measurable_set s) : âˆ« (x : Î±), s.indicator f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
{F : Type u_3} [inner_product_space â„ F] (x y : F) : |has_inner.inner x y| â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
(f : Type u â†’ Type v) (hf : Î  (Î± Î² : Type u), Î± â‰ƒ Î² â†’ f Î± â‰ƒ f Î²) : cardinal â†’ cardinal
(P : Î  {R S : Type u} [_inst_7 : comm_ring R] [_inst_8 : comm_ring S], (R â†’+* S) â†’ Prop) : Prop
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) (h : W âŸ¶ X) [category_theory.epi h] (s : category_theory.limits.pushout_cocone f g) (H : category_theory.limits.is_colimit s) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk s.inl s.inr _)
{elab : bool := bool.tt} : expr elab â†’ option (macro_def Ã— list (expr elab))
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {G : D â¥¤ C} {F_obj : C â†’ D} (e : Î  (X : C) (Y : D), (F_obj X âŸ¶ Y) â‰ƒ (X âŸ¶ G.obj Y)) (he : âˆ€ (X : C) (Y Y' : D) (g : Y âŸ¶ Y') (h : F_obj X âŸ¶ Y), â‡‘(e X Y') (h â‰« g) = â‡‘(e X Y) h â‰« G.map g) : category_theory.adjunction.left_adjoint_of_equiv e he âŠ£ G
{E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] {f : E â†’ F} {s : set E} {z w : E} (hd : diff_cont_on_cl â„‚ f s) (hz : is_max_on (has_norm.norm âˆ˜ f) s z) (hsub : metric.ball z (has_dist.dist w z) âŠ† s) : âˆ¥f wâˆ¥ = âˆ¥f zâˆ¥
{V : Type u} [category_theory.category V] [category_theory.preadditive V] [category_theory.limits.has_zero_object V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] [category_theory.limits.has_zero_object W] (F : V â¥¤ W) [F.additive] : chain_complex.singleâ‚€ V â‹™ F.map_homological_complex (complex_shape.down â„•) â‰… F â‹™ chain_complex.singleâ‚€ W
{G : Type u_1} [measurable_space G] [comm_group G] {Î¼ : measure_theory.measure G} [Î¼.is_mul_left_invariant] : Î¼.is_mul_right_invariant
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] (Z : basic_smooth_vector_bundle_core I M E') (v : E') (h : âˆ€ (i j : â†¥(charted_space.atlas H M)) (x : M), x âˆˆ i.val.to_local_equiv.source âˆ© j.val.to_local_equiv.source â†’ â‡‘(Z.coord_change i j (â‡‘(i.val) x)) v = v) : smooth I (I.prod (model_with_corners_self ğ•œ E')) (show M â†’ Z.to_topological_vector_bundle_core.total_space, from Î» (x : M), âŸ¨x, vâŸ©)
(p : â„•) (f : Î  â¦ƒR : Type u_3â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R) : Prop
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â†’g G') (v : V) (w : â†¥(G.neighbor_set v)) : â†¥(G'.neighbor_set (â‡‘f v))
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C â¥¤ D) [F.final] (I : Î  (d : D), category_theory.limits.colimit (F â‹™ category_theory.coyoneda.obj (opposite.op d)) â‰… punit) : F.final
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) (P : C) (Ï€ : Î  (b : I.R), I.right b âŸ¶ P) (w : âˆ€ (a : I.L), I.fst a â‰« Ï€ (I.fst_from a) = I.snd a â‰« Ï€ (I.snd_from a)) : category_theory.limits.multicofork I
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] (f : Î± Ã— Î² â†’ ennreal) (hf : ae_measurable f (Î¼.prod Î½)) : âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
(timeout : â„• := 200000) (d : declaration) : tactic (option string)
{n : Type u_1} {R : Type uâ‚‚} [decidable_eq n] [comm_ring R] (i j : n) [fintype n] (c : R) : 1.update_row i (1 i + c â€¢ 1 j) = matrix.transvection i j c
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] (M : Î› â†’ turing.TM1.stmt Î“ Î› Ïƒ) : turing.TM0.machine Î“ (turing.TM1to0.Î›' M)
(o : ordinal) : {a : cardinal | âˆƒ {Î¹ : Type u} (f : Î¹ â†’ ordinal), ordinal.lsub f = o âˆ§ cardinal.mk Î¹ = a}.nonempty
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} [measure_theory.sigma_finite Î½] {s : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : measurable f) (hs : s.mutually_singular Î½) (hadd : Î¼ = s + Î½.with_density f) : f =áµ[Î½] Î¼.rn_deriv Î½
{V : Type u} {W : Type v} (G : simple_graph V) (G' : simple_graph W) : Type (max u v)
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : set Î±) : â†¥s â†’ â†¥(f '' s)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {x : M} {n : with_top â„•} : cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_diff_within_at ğ•œ n (â‡‘(ext_chart_at I' (f x)) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' (f x)).source)) (â‡‘(ext_chart_at I x) x)
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) (Î¼ : ğ•œ) (v : E) (hv : v âˆˆ (module.End.eigenspace T Î¼)á—®) : â‡‘T v âˆˆ (module.End.eigenspace T Î¼)á—®
{R : Type u_1} [comm_semiring R] (I : ideal R) [hp : I.is_prime] : Type u_1
{I : Type wâ‚€} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {A : Type uâ‚} [category_theory.category A] (f : Î  (i : I), A â¥¤ C i) : A â¥¤ Î  (i : I), C i
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.is_neg_invariant] : convolution g f L.flip Î¼ = convolution f g L Î¼
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (ğ•œ : Type u_3) [field ğ•œ] [is_alg_closed ğ•œ] [category_theory.linear ğ•œ C] [category_theory.limits.has_kernels C] (X : C) [category_theory.simple X] [I : finite_dimensional ğ•œ (X âŸ¶ X)] : field (category_theory.End X)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) (n : â„•) (g : J.cocomplex.X n âŸ¶ I.cocomplex.X n) (g' : J.cocomplex.X (n + 1) âŸ¶ I.cocomplex.X (n + 1)) (w : J.cocomplex.d n (n + 1) â‰« g' = g â‰« I.cocomplex.d n (n + 1)) : Î£' (g'' : J.cocomplex.X (n + 2) âŸ¶ I.cocomplex.X (n + 2)), J.cocomplex.d (n + 1) (n + 2) â‰« g'' = g' â‰« I.cocomplex.d (n + 1) (n + 2)
{Î± : Type u_1} {E' : Type u_5} {ğ•œ : Type u_11} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E'] [complete_space E'] [normed_space â„ E'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp E' 2 Î¼)) (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) : âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
{a b : â„} {f f' g : â„ â†’ â„} (h : âˆ€ (x : â„), x âˆˆ set.interval a b â†’ has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (x : â„) in f a..f b, g x
{I : Type u} (R : Type u_1) (f : I â†’ Type v) {r : comm_semiring R} [Î  (i : I), semiring (f i)] [Î  (i : I), algebra R (f i)] (i : I) : (Î  (i : I), f i) â†’â‚[R] f i
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} (f : (Î¹ â†’ â„) â†’ E) (vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤) (Ï€ : box_integral.tagged_prepartition I) : F
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} : iterated_deriv n f = deriv^[n] f
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] (Ï† : A â†’â‚[R] B) : A â†’â‚—[R] B
{Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : f '' s âˆˆ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
{ğ•œ : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] (h : âˆƒ (x : E), âˆ¥xâˆ¥ â‰  0) : âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ = 1
{Î± : Type u_1} (mâ‚ mâ‚‚ : measurable_space Î±) [measurable_space Î±] (Î¼ : measure_theory.measure Î± . "volume_tac") : Prop
{Î± : Type u_1} {G : Type u_8} [normed_group G] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} [normed_space â„ G] (hm : m â‰¤ m0) (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (x : G) : â†¥(measure_theory.Lp G 2 Î¼)
{Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_metric_space (Ï€ b)] [nonempty Î²] (x : Î  (b : Î²), Ï€ b) (r : â„) : metric.closed_ball x r = set.univ.pi (Î» (b : Î²), metric.closed_ball (x b) r)
{Î± : Type u_1} {Î¹ : Type u_5} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {S : set Î¹} {s : Î¹ â†’ set Î±} (hc : S.countable) (hs : (â‹ƒ (i : Î¹) (H : i âˆˆ S), s i) = set.univ) : Î¼ = Î½ â†” âˆ€ (i : Î¹), i âˆˆ S â†’ Î¼.restrict (s i) = Î½.restrict (s i)
{Î± : Type u_1} {F : Type u_6} {ğ•œ : Type u_11} {p : ennreal} [is_R_or_C ğ•œ] [normed_group F] [normed_space ğ•œ F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp_meas F ğ•œ m p Î¼)) (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) : âˆƒ (g : Î± â†’ F), measure_theory.fin_strongly_measurable g (Î¼.trim hm) âˆ§ â‡‘f =áµ[Î¼] g
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R â†’+* S) (I : ideal R) : ideal S
{I : Type wâ‚€} (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] {J : Type wâ‚€} {D : J â†’ Type uâ‚} [Î  (j : J), category_theory.category (D j)] : (Î  (i : I), C i) â¥¤ (Î  (j : J), D j) â¥¤ Î  (s : I âŠ• J), sum.elim C D s
{C : Type u} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] [category_theory.limits.has_equalizers C] [category_theory.limits.has_finite_products C] (G : C â¥¤ D) [category_theory.limits.preserves_limits_of_shape category_theory.limits.walking_parallel_pair G] [Î  (J : Type v) [_inst_8 : fintype J], category_theory.limits.preserves_limits_of_shape (category_theory.discrete J) G] : category_theory.limits.preserves_finite_limits G
{R : Type u} {Mâ‚‚ : Type vâ‚‚} {Mâ‚ƒ : Type vâ‚ƒ} [semiring R] [add_comm_monoid Mâ‚‚] [add_comm_monoid Mâ‚ƒ] [module R Mâ‚‚] [module R Mâ‚ƒ] {Î¹â‚ : Type u_1} {Î¹â‚‚ : Type u_2} [decidable_eq Î¹â‚] [decidable_eq Î¹â‚‚] (Ïƒ : Î¹â‚ â‰ƒ Î¹â‚‚) : multilinear_map R (Î» (i : Î¹â‚), Mâ‚‚) Mâ‚ƒ â‰ƒ+ multilinear_map R (Î» (i : Î¹â‚‚), Mâ‚‚) Mâ‚ƒ
{n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] : minpoly â„¤ Î¼ âˆ£ polynomial.X ^ n - 1
{R : Type u_1} {M : Type u_7} [semiring R] [add_comm_monoid M] {Ïƒ Ïƒ' : R â†’+* R} [ring_hom_inv_pair Ïƒ Ïƒ'] [ring_hom_inv_pair Ïƒ' Ïƒ] {module_M : module R M} (f : M â†’â‚›â‚—[Ïƒ] M) (hf : function.involutive â‡‘f) : M â‰ƒâ‚›â‚—[Ïƒ] M
{R : Type u_5} {k : â„•} [comm_ring R] {Î¶ : RË£} (h : is_primitive_root Î¶ k) : zmod k â‰ƒ+ additive â†¥(subgroup.zpowers Î¶)
{A : Type u_3} [semiring A] [algebra â„ A] â¦ƒf g : â„‚ â†’â‚[â„] Aâ¦„ (h : â‡‘f complex.I = â‡‘g complex.I) : f = g
{ğ•œ : Type u} {G : Type wG} {G' : Type wG'} [nondiscrete_normed_field ğ•œ] [normed_group G] [normed_space ğ•œ G] [normed_group G'] [normed_space ğ•œ G'] {k n : â„•} (f : multilinear_map ğ•œ (Î» (i : fin n), G) G') (s : finset (fin n)) (hk : s.card = k) (z : G) {C : â„} (H : âˆ€ (m : fin n â†’ G), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : fin n), âˆ¥m iâˆ¥)) (v : fin k â†’ G) : âˆ¥â‡‘(f.restr s hk z) vâˆ¥ â‰¤ C * âˆ¥zâˆ¥ ^ (n - k) * finset.univ.prod (Î» (i : fin k), âˆ¥v iâˆ¥)
{Î± : Type u_1} {n : â„•} {C : vector3 Î± n.succ â†’ Sort u} (H : Î  (a : Î±) (t : vector3 Î± n), C (a::t)) (v : vector3 Î± n.succ) : C v
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : cochain_complex V â„•} (e : P âŸ¶ Q) (zero : P.X 1 âŸ¶ Q.X 0) (comm_zero : e.f 0 = P.d 0 1 â‰« zero) (one : P.X 2 âŸ¶ Q.X 1) (comm_one : e.f 1 = zero â‰« Q.d 0 1 + P.d 1 2 â‰« one) (succ : Î  (n : â„•) (p : Î£' (f : P.X (n + 1) âŸ¶ Q.X n) (f' : P.X (n + 2) âŸ¶ Q.X (n + 1)), e.f (n + 1) = f â‰« Q.d n (n + 1) + P.d (n + 1) (n + 2) â‰« f'), Î£' (f'' : P.X (n + 3) âŸ¶ Q.X (n + 2)), e.f (n + 2) = p.snd.fst â‰« Q.d (n + 1) (n + 2) + P.d (n + 2) (n + 3) â‰« f'') [category_theory.limits.has_zero_object V] (n : â„•) : Î£' (f : P.X n âŸ¶ homological_complex.X_prev Q n) (f' : homological_complex.X_next P n âŸ¶ Q.X n), e.f n = f â‰« homological_complex.d_to Q n + homological_complex.d_from P n â‰« f'
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : (Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] g â†’ f' =o[l] g
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (f : smooth_partition_of_unity Î¹ I M s) : partition_of_unity Î¹ M s
(c : conv unit) (lhs : expr) (rel : name := name.mk_string "eq" name.anonymous) : tactic (expr Ã— expr)
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (F : V â¥¤ W) [F.additive] {f g : C âŸ¶ D} (h : homotopy f g) : homotopy ((F.map_homological_complex c).map f) ((F.map_homological_complex c).map g)
(Râ‚ : Type u_3) {A : Type u_5} [comm_semiring Râ‚] [comm_ring A] [algebra Râ‚ A] (I : ideal A) : function.surjective â‡‘(ideal.quotient.mkâ‚ Râ‚ I)
{Î± : Type u} {Ïƒ : Type v} (M : NFA Î± Ïƒ) (S : set Ïƒ) (a : Î±) : set Ïƒ
{R : Type u_1} {S : Type u_6} {M : Type u_9} {Mâ‚‚ : Type u_11} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module S Mâ‚‚] {Ïƒ : R â†’+* S} {Ïƒ' : S â†’+* R} [ring_hom_inv_pair Ïƒ Ïƒ'] (f : M â†’â‚›â‚—[Ïƒ] Mâ‚‚) (g : Mâ‚‚ â†’ M) (hâ‚ : function.left_inverse g â‡‘f) (hâ‚‚ : function.right_inverse g â‡‘f) : Mâ‚‚ â†’â‚›â‚—[Ïƒ'] M
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] [fintype Î¹] (I : box_integral.box Î¹) (l : box_integral.integration_params) (f : (Î¹ â†’ â„) â†’ E) (vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤) : F
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {M : mv_polynomial Ïƒ R â†’ Prop} (p : mv_polynomial Ïƒ R) (h_C : âˆ€ (a : R), M (â‡‘mv_polynomial.C a)) (h_add : âˆ€ (p q : mv_polynomial Ïƒ R), M p â†’ M q â†’ M (p + q)) (h_X : âˆ€ (p : mv_polynomial Ïƒ R) (n : Ïƒ), M p â†’ M (p * mv_polynomial.X n)) : M p
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] {f : module.End K V} {Î¼ : K} {n : â„•} : submodule.map f (f.generalized_eigenrange Î¼ n) â‰¤ f.generalized_eigenrange Î¼ n
{Î¹ : Type u} {Î± : Î¹ â†’ Type u_2} {Î´ : Î  (i : Î¹), Î± i â†’ Type v} [Î  (i : Î¹) (j : Î± i), has_zero (Î´ i j)] (f : Î â‚€ (i : Î¹) (j : Î± i), Î´ i j) : Î â‚€ (i : Î£ (i : Î¹), Î± i), Î´ i.fst i.snd
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {Î¼ : measure_theory.measure â„} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X â†’ â„ â†’ E} {xâ‚€ : X} {bound : â„ â†’ â„} {a b : â„} (hF_meas : âˆ€á¶  (x : X) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€á¶  (x : X) in nhds xâ‚€, âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ¥F x tâˆ¥ â‰¤ bound t) (bound_integrable : interval_integrable bound Î¼ a b) (h_cont : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ continuous_at (Î» (x : X), F x t) xâ‚€) : continuous_at (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) xâ‚€
(W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] (C : Type uâ‚) [category_theory.enriched_category W C] : Type uâ‚
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), add_zero_class (Î² i)] {Î³ : Type w} [add_zero_class Î³] â¦ƒf g : (Î â‚€ (i : Î¹), Î² i) â†’+ Î³â¦„ (H : âˆ€ (i : Î¹) (y : Î² i), â‡‘f (dfinsupp.single i y) = â‡‘g (dfinsupp.single i y)) : f = g
{Î± : Type u} [pseudo_emetric_space Î±] {Î´ Îµ : â„} (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (s : set Î±) : metric.cthickening Îµ (metric.cthickening Î´ s) âŠ† metric.cthickening (Îµ + Î´) s
{I : Type wâ‚€} (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] : category_theory.category (Î  (i : I), C i)
(s : simp_lemmas Ã— list name) (ps : list pexpr) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{L : first_order.language} {Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [is_directed Î¹ has_le.le] [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [nonempty Î¹] : L.Structure (first_order.language.direct_limit G f)
{G : Type u_1} {Î± : Type u_2} [add_group G] [add_action G Î±] [measurable_space Î±] {s : set Î±} {Î¼ : measure_theory.measure Î±} [measurable_space G] [has_measurable_vadd G Î±] [measure_theory.vadd_invariant_measure G Î± Î¼] [encodable G] (hs : measure_theory.is_add_fundamental_domain G s Î¼) {f : Î± â†’ ennreal} (hf : âˆ€ (Î³ : G) (x : Î±), f (Î³ +áµ¥ x) = f x) : ess_sup f (Î¼.restrict s) = ess_sup f Î¼
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} [category_theory.limits.has_zero_object V] (j : Î¹) : (Î  (i j : Î¹), C.X i âŸ¶ D.X j) â†’+ (C.X j âŸ¶ D.X_prev j)
{G : Type u_1} [group G] {N : Type u_3} [group N] (f : G â†’* N) (s : set G) : subgroup.map f (subgroup.closure s) = subgroup.closure (â‡‘f '' s)
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Î¹ R M) {Râ‚ : Type u_9} [semiring Râ‚] {Ïƒ : R â†’+* Râ‚} {Mâ‚ : Type u_10} [add_comm_monoid Mâ‚] [module Râ‚ Mâ‚] {fâ‚ fâ‚‚ : M â†’â‚›â‚—[Ïƒ] Mâ‚} (h : âˆ€ (i : Î¹), â‡‘fâ‚ (â‡‘b i) = â‡‘fâ‚‚ (â‡‘b i)) : fâ‚ = fâ‚‚
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (k : â„•) : â†‘(lie_module.lower_central_series R L (L â§¸ I) k) = â†‘(lie_module.lower_central_series R (L â§¸ I) (L â§¸ I) k)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {x : M} {n : with_top â„•} {x' : M} {y : M'} (hx : x' âˆˆ (charted_space.chart_at H x).to_local_equiv.source) (hy : f x' âˆˆ (charted_space.chart_at H' y).to_local_equiv.source) : cont_mdiff_within_at I I' n f s x' â†” continuous_within_at f s x' âˆ§ cont_diff_within_at ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source)) (â‡‘(ext_chart_at I x) x')
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) (hxy : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) (hxz : âˆ¥xâˆ¥ = âˆ¥zâˆ¥) : o.oangle y z = 2 â€¢ o.oangle (y - x) (z - x)
{n : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) [field K] [algebra K L] [ne_zero â†‘â†‘n] [is_cyclotomic_extension {n} K L] (h : 2 < â†‘n) (hirr : irreducible (polynomial.cyclotomic â†‘n K)) : â‡‘(algebra.norm K) (Î¶ - 1) = â†‘(polynomial.eval 1 (polynomial.cyclotomic â†‘n â„¤))
{Ïƒ : Type u_1} {R : Type u_2} [comm_semiring R] : mv_polynomial Ïƒ R â†’+* mv_power_series Ïƒ R
{Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) (n : â„•) : â‡‘Î¼ {x âˆˆ s | âˆ€ (m : â„•), m â‰¥ n â†’ f^[m] x âˆ‰ s} = 0
{Î± : Type u_1} [preorder Î±] [pred_order Î±] [is_pred_archimedean Î±] {P : Î± â†’ Prop} {m : Î±} (h0 : P m) (h1 : âˆ€ (n : Î±), n â‰¤ m â†’ P n â†’ P (order.pred n)) â¦ƒn : Î±â¦„ (hmn : n â‰¤ m) : P n
(K : Type u_1) (Ïƒ : Type u_2) [comm_semiring K] : mv_polynomial Ïƒ K â†’â‚—[K] (Ïƒ â†’ K) â†’ K
{Ïƒ : Type} (state : Ïƒ) : interaction_monad Ïƒ unit
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ M * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥fâˆ¥ â‰¤ M
(P : Î  (R : Type u) [_inst_7 : comm_ring R], Prop) : Prop
{G : Type u_1} [comm_group G] [topological_space G] [topological_group G] [t2_space G] [measurable_space G] [borel_space G] [locally_compact_space G] [topological_space.second_countable_topology G] (Î¼ : measure_theory.measure G) [Î¼.is_haar_measure] : measure_theory.measure.map has_inv.inv Î¼ = Î¼
{Î© : Type u_1} {m : measurable_space Î©} (f : Î© â†’ â„) (Î¼ : measure_theory.measure Î©) : â„
{Î± : Type} [has_mul Î±] [add_monoid Î±] : â„• â†’ Î  {ds : list â„•}, holor Î± ds â†’ Prop
(n : â„•) {Î² : Î  (v : typevec (n + 1)) (v' : typevec (n + 1)), v.arrow v' â†’ Sort u_3} (F : Î  (t : Type u_1) (t' : Type u_2) (f : t â†’ t') (v : typevec n) (v' : typevec n) (fs : v.arrow v'), Î² (v ::: t) (v' ::: t') (fs ::: f)) (v : typevec (n + 1)) (v' : typevec (n + 1)) (fs : v.arrow v') : Î² v v' fs
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type wâ‚} [category_theory.category D] {E : Type wâ‚‚} [category_theory.category E] (F : D â¥¤ E) [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [âˆ€ (Î± Î² : Type (max v u)) (fst snd : Î² â†’ Î±), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– E] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– F] [Î  (X : C) (W : J.cover X) (P : Cáµ’áµ– â¥¤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] : J.sheafification D â‹™ (category_theory.whiskering_right Cáµ’áµ– D E).obj F â‰… (category_theory.whiskering_right Cáµ’áµ– D E).obj F â‹™ J.sheafification E
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} {Ïƒ : Type u_3} [inhabited Î›] [inhabited Ïƒ] (l : list Î“) : turing.TM1.cfg Î“ Î› Ïƒ
{C : Type u} [category_theory.category C] {A : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] {I : C} (t : category_theory.limits.is_initial I) : I â¨¯ A â‰… I
{Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] [topological_space Î²] {f : Î² â†’ Î±} {K : set Î²} (hK : is_compact K) (hf : continuous_on f K) : bdd_below (f '' K)
{I : Type u} {f : I â†’ Type v} [decidable_eq I] [Î  (i : I), add_zero_class (f i)] : pairwise (Î» (i j : I), âˆ€ (x : f i) (y : f j), add_commute (pi.single i x) (pi.single j y))
(ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] (n : with_top â„•) (x : M) : Type (max u_4 u_1)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] (Î¹ : Type u_2) [fintype Î¹] (E : Î¹ â†’ Type u_3) [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] (s : Î  (i : Î¹), set (E i)) (I : set Î¹) (h : âˆ€ (i : Î¹), i âˆˆ I â†’ unique_diff_on ğ•œ (s i)) : unique_diff_on ğ•œ (I.pi s)
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (G : V â¥¤ W) [G.additive] (hom : Î  (i j : Î¹), c.rel j i â†’ (C.X i âŸ¶ D.X j)) : (G.map_homological_complex c).map (homotopy.null_homotopic_map' hom) = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), G.map (hom i j hij))
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {S T : J.cover X} (I : S.arrow) (f : S âŸ¶ T) : T.arrow
{E : Type u_1} [inner_product_space â„ E] {F : Type u_2} [normed_group F] [normed_space â„ F] {H : Type u_3} [topological_space H] {I : model_with_corners â„ F H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {n : â„•} [fact (finite_dimensional.finrank â„ E = n + 1)] {m : with_top â„•} {f : M â†’ E} (hf : cont_mdiff I (model_with_corners_self â„ E) m f) (hf' : âˆ€ (x : M), f x âˆˆ metric.sphere 0 1) : cont_mdiff I (model_with_corners_self â„ (euclidean_space â„ (fin n))) m (set.cod_restrict (Î» (x : M), f x) (metric.sphere 0 1) hf')
{V : Type u_1} {W : Type u_2} [semi_normed_group V] [semi_normed_group W] (f g : normed_group_hom V W) : normed_group_hom â†¥(f.equalizer g) V
{Î¹ : Type u_1} {R : Type u_2} [comm_semiring R] {t : finset Î¹} (h : t.nonempty) (I : Î¹ â†’ ideal R) : (â¨† (i : Î¹) (H : i âˆˆ t), â¨… (j : Î¹) (hj : j âˆˆ t) (ij : j â‰  i), I j) = âŠ¤ â†” â†‘t.pairwise (Î» (i j : Î¹), I i âŠ” I j = âŠ¤)
{C : Type u} [category_theory.category C] (â„¬ : Î  (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) {W X Y Z : C} (f : W âŸ¶ X) (g : Y âŸ¶ Z) : category_theory.monoidal_of_chosen_finite_products.tensor_obj â„¬ W Y âŸ¶ category_theory.monoidal_of_chosen_finite_products.tensor_obj â„¬ X Z
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {W X Y Z : C} [category_theory.monoidal_category.lift_obj W] [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] (f : W âŸ¶ X) (g : X âŸ¶ Y) (h : Y âŸ¶ Z) [category_theory.monoidal_category.lift_hom f] [category_theory.monoidal_category.lift_hom g] : f â‰« g â‰« h = (f â‰« g) â‰« h
{G : Type u_1} [add_group G] â¦ƒh k : set Gâ¦„ (h' : h âŠ† k) : add_subgroup.closure h â‰¤ add_subgroup.closure k
{k : Type u} [comm_ring k] (G : Type u) [group G] {V : Type u} [add_comm_group V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] {W : Type u} [add_comm_group W] [module k W] [module (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (Ï€ : W â†’â‚—[k] V) [fintype G] : W â†’â‚—[monoid_algebra k G] V
{Î² : Type u} [metric_space Î²] [measurable_space Î²] [borel_space Î²] [sigma_compact_space Î²] [has_besicovitch_covering Î²] (Ï Î¼ : measure_theory.measure Î²) [measure_theory.is_locally_finite_measure Î¼] [measure_theory.is_locally_finite_measure Ï] : âˆ€áµ (x : Î²) âˆ‚Î¼, filter.tendsto (Î» (r : â„), â‡‘Ï (metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (Ï.rn_deriv Î¼ x))
{R : Type u} [ring R] (I : ideal R) : ideal R
{Î± : Type u} {Î² : Type v} [topological_space Î±] [compact_space Î±] [pseudo_metric_space Î²] [t2_space Î²] (s : set Î²) (hs : is_compact s) (A : set (bounded_continuous_function Î± Î²)) (in_s : âˆ€ (f : bounded_continuous_function Î± Î²) (x : Î±), f âˆˆ A â†’ â‡‘f x âˆˆ s) (H : âˆ€ (x : Î±) (Îµ : â„), Îµ > 0 â†’ (âˆƒ (U : set Î±) (H : U âˆˆ nhds x), âˆ€ (y : Î±), y âˆˆ U â†’ âˆ€ (z : Î±), z âˆˆ U â†’ âˆ€ (f : bounded_continuous_function Î± Î²), f âˆˆ A â†’ has_dist.dist (â‡‘f y) (â‡‘f z) < Îµ)) : is_compact (closure A)
{E : Type u} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {f' : E} {s : set â„} {x r : â„} (hf : has_deriv_within_at f f' s x) (hr : âˆ¥f'âˆ¥ < r) : âˆ€á¶  (z : â„) in nhds_within x s, âˆ¥z - xâˆ¥â»Â¹ * (âˆ¥f zâˆ¥ - âˆ¥f xâˆ¥) < r
{p q x : â„} (h : liouville_with p x) (hlt : q < p) : âˆƒá¶  (n : â„•) in filter.at_top, âˆƒ (m : â„¤), x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < â†‘n ^ -q
{x : â„} (h : |x| < 1) (n : â„•) : |(finset.range n).sum (Î» (i : â„•), x ^ (i + 1) / (â†‘i + 1)) + real.log (1 - x)| â‰¤ |x| ^ (n + 1) / (1 - |x|)
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] {X : C} {K : Type (max v u)} [category_theory.small_category K] {F : K â¥¤ Cáµ’áµ– â¥¤ D} {W : J.cover X} (i : W.arrow) (E : category_theory.limits.cone (F â‹™ J.diagram_functor D X â‹™ (category_theory.evaluation (J.cover X)áµ’áµ– D).obj (opposite.op W))) : category_theory.limits.cone (F â‹™ (category_theory.evaluation Cáµ’áµ– D).obj (opposite.op i.Y))
{I : Type u_3} {f : I â†’ Type u_4} [inhabited I] [inst : âˆ€ (i : I), nonempty (f i)] [nontrivial (f inhabited.default)] : nontrivial (Î  (i : I), f i)
{Î¹ : Type u_1} [fintype Î¹] {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) (r : (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)) : box_integral.tagged_prepartition I
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) (I : lie_ideal R L) : â†‘â…I,Nâ† = submodule.span R {m : M | âˆƒ (x : â†¥I) (n : â†¥N), â…â†‘x,â†‘nâ† = m}
{m : Type u â†’ Type v} [functor m] {Ïƒ Î± : Type u} (cmd : state_t Ïƒ m Î±) (s : Ïƒ) : m Î±
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : M â†’â‚—[R] Hausdorffification I M
{Î± : Type} (t : tactic Î±) (cfg : tactic.dsimp_config := {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.ff, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}) (no_defaults : bool := bool.ff) (attr_names : list name := list.nil) (hs : list tactic.simp_arg_type := list.nil) : tactic Î±
{Î¹ : Sort u_1} (I : nonempty Î¹) (f : Î¹ â†’ ordinal) : ordinal
{E : Type u_2} [add_comm_group E] [module â„ E] [topological_space E] [topological_add_group E] [has_continuous_smul â„ E] {s : set E} (hs : convex â„ s) {x : E} (hx : x âˆˆ interior s) (t : â„) (ht : 1 < t) : closure s âŠ† â‡‘(affine_map.homothety x t) '' interior s
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (f : â†¥(measure_theory.Lp.simple_func â„ 1 Î¼)) : â†¥(measure_theory.Lp.simple_func â„ 1 Î¼)
{C : Type u} [category_theory.category C] {I : category_theory.limits.multispan_index C} (K : category_theory.limits.multicofork I) (desc : Î  (E : category_theory.limits.multicofork I), K.X âŸ¶ E.X) (fac : âˆ€ (E : category_theory.limits.multicofork I) (i : I.R), K.Ï€ i â‰« desc E = E.Ï€ i) (uniq : âˆ€ (E : category_theory.limits.multicofork I) (m : K.X âŸ¶ E.X), (âˆ€ (i : I.R), K.Ï€ i â‰« m = E.Ï€ i) â†’ m = desc E) : category_theory.limits.is_colimit K
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (f : E â†’â‚—[â„] E) (s : set E) : â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det f| * â‡‘Î¼ s
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (x : M â§¸ S) : 0 â‰¤ âˆ¥xâˆ¥
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {F : Type u_8} [normed_group F] [normed_space ğ•œ F] (Z : basic_smooth_vector_bundle_core I M F) (hs : unique_mdiff_on I s) : unique_mdiff_on (I.prod (model_with_corners_self ğ•œ F)) (Z.to_topological_vector_bundle_core.proj â»Â¹' s)
{C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (G : D â¥¤ C) [category_theory.monadic_right_adjoint G] â¦ƒA B : Dâ¦„ (f g : A âŸ¶ B) [G.is_split_pair f g] : category_theory.creates_colimit (category_theory.limits.parallel_pair f g) G
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] {m : Î± â†’ Î²} {s : set Î±} (hm : uniform_inducing m) : is_complete (m '' s) â†” is_complete s
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (G : Type u_4) [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] : left_invariant_derivation I G â†’+ cont_mdiff_map I (model_with_corners_self ğ•œ ğ•œ) G ğ•œ âŠ¤ â†’ cont_mdiff_map I (model_with_corners_self ğ•œ ğ•œ) G ğ•œ âŠ¤
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (W : submodule ğ•œ E) : inner_product_space ğ•œ â†¥W
{k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [monoid G] {A : Type uâ‚ƒ} [semiring A] [algebra k A] â¦ƒÏ†â‚ Ï†â‚‚ : monoid_algebra k G â†’â‚[k] Aâ¦„ (h : âˆ€ (x : G), â‡‘Ï†â‚ (finsupp.single x 1) = â‡‘Ï†â‚‚ (finsupp.single x 1)) : Ï†â‚ = Ï†â‚‚
{Î± : Type u} {Î² : Type u_1} [topological_space Î±] [topological_space Î²] {s : set (set Î±)} (hs : topological_space.is_topological_basis s) {t : set (set Î²)} (ht : topological_space.is_topological_basis t) : topological_space.is_topological_basis ((Î» (u : set Î±), sum.inl '' u) '' s âˆª (Î» (u : set Î²), sum.inr '' u) '' t)
{G : Type u_1} [group G] {H : subgroup G} {R S : set G} (hR : R âˆˆ subgroup.right_transversals â†‘H) (hR1 : 1 âˆˆ R) (hS : subgroup.closure S = âŠ¤) : subgroup.closure ((Î» (g : G), âŸ¨g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹, _âŸ©) '' (R * S)) = âŠ¤
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (hf : âˆ€ (n : â„•), measurable (f n)) (h_mono : monotone f) : âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
{E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} {C : â„} (hf : âˆ€ (x : â„), x âˆˆ set.Icc a b â†’ has_deriv_within_at f (f' x) (set.Icc a b) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ C) (x : â„) (H : x âˆˆ set.Icc a b) : âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f g : continuous_multilinear_map ğ•œ E G) : âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
{V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : âˆ¥x - yâˆ¥ = |âˆ¥xâˆ¥ - âˆ¥yâˆ¥| â†” inner_product_geometry.angle x y = 0
(Î± : Type u) (Î² : Type v) [add_group Î±] [add_action Î± Î²] [fintype Î±] [fintype Î²] [fintype (quotient (add_action.orbit_rel Î± Î²))] [Î  (b : Î²), fintype â†¥(add_action.stabilizer Î± b)] : fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(add_action.stabilizer Î± Ï‰.out'))
(Ïƒ : Type u_1) (R : Type u_2) [comm_semiring R] [fintype Ïƒ] (n : â„•) : mv_polynomial.esymm Ïƒ R n = (finset.powerset_len n finset.univ).sum (Î» (t : finset Ïƒ), â‡‘(mv_polynomial.monomial (t.sum (Î» (i : Ïƒ), finsupp.single i 1))) 1)
{V : Type u_1} {W : Type u_2} {Vâ‚ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group Vâ‚] {f g : normed_group_hom V W} (Ï† : normed_group_hom Vâ‚ V) (h : f.comp Ï† = g.comp Ï†) (hÏ† : Ï†.norm_noninc) : (normed_group_hom.equalizer.lift Ï† h).norm_noninc
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] {p : ennreal} {f : Î¹ â†’ Î± â†’ Î²} [subsingleton Î¹] (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) (hf : âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) (hf' : âˆ€ (i : Î¹), measure_theory.mem_â„’p (f i) p Î¼) : measure_theory.uniform_integrable f p Î¼
{R : Type u} {Ïƒ : Type v} [comm_ring R] {I : ideal R} {f : mv_polynomial Ïƒ R} : f âˆˆ ideal.map mv_polynomial.C I â†” âˆ€ (m : Ïƒ â†’â‚€ â„•), mv_polynomial.coeff m f âˆˆ I
{Î¹ : Type u_10} {R : Type u_11} {Râ‚‚ : Type u_12} {M : Type u_13} {Mâ‚‚ : Type u_14} [semiring R] [semiring Râ‚‚] [add_comm_monoid M] [module R M] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [topological_space M] [topological_space Mâ‚‚] {Ïƒ : R â†’+* Râ‚‚} {f : Î¹ â†’ M} (Ï† : M â†’SL[Ïƒ] Mâ‚‚) {x : M} (hf : has_sum f x) : has_sum (Î» (b : Î¹), â‡‘Ï† (f b)) (â‡‘Ï† x)
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : cochain_complex V â„•} (e : P âŸ¶ Q) (zero : P.X 1 âŸ¶ Q.X 0) (comm_zero : e.f 0 = P.d 0 1 â‰« zero) (one : P.X 2 âŸ¶ Q.X 1) (comm_one : e.f 1 = zero â‰« Q.d 0 1 + P.d 1 2 â‰« one) (succ : Î  (n : â„•) (p : Î£' (f : P.X (n + 1) âŸ¶ Q.X n) (f' : P.X (n + 2) âŸ¶ Q.X (n + 1)), e.f (n + 1) = f â‰« Q.d n (n + 1) + P.d (n + 1) (n + 2) â‰« f'), Î£' (f'' : P.X (n + 3) âŸ¶ Q.X (n + 2)), e.f (n + 2) = p.snd.fst â‰« Q.d (n + 1) (n + 2) + P.d (n + 2) (n + 3) â‰« f'') (n : â„•) : Î£' (f : P.X (n + 1) âŸ¶ Q.X n) (f' : P.X (n + 2) âŸ¶ Q.X (n + 1)), e.f (n + 1) = f â‰« Q.d n (n + 1) + P.d (n + 1) (n + 2) â‰« f'
{R : Type u} [comm_semiring R] (f : polynomial R) (ğ“Ÿ : ideal R) : Prop
{V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (h : hb.oangle x y = 0) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} (hf : function.injective f) (s : set Î±) (hs : (f '' s).subsingleton) : s.subsingleton
{Î² : Type u_2} {V W : set (Î² Ã— Î²)} {x y z : Î²} (h : y âˆˆ uniform_space.ball x V) (h' : z âˆˆ uniform_space.ball y W) : z âˆˆ uniform_space.ball x (comp_rel V W)
(Ïƒ : Type u) (R : Type v) [comm_ring R] (m : â„•) : submodule R (mv_polynomial Ïƒ R)
{Ïƒ : Type} : interaction_monad Ïƒ Ïƒ
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I J : ideal R} {N : submodule R M} (hN : N.fg) (hIN : N â‰¤ I â€¢ N) (hIjac : I â‰¤ J.jacobson) : N = J â€¢ N
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : â„} {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : asymptotics.is_O_with c l f g â†” âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] [dec_ğ•œ : decidable_eq ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ğ•œ E] : direct_sum.is_internal (Î» (Î¼ : module.End.eigenvalues T), module.End.eigenspace T â†‘Î¼)
(n : interactive.parse (optional (interactive.with_desc â†‘"n" lean.parser.small_nat))) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (use : interactive.parse (lean.parser.tk "using" *> lean.parser.many interactive.types.ident_ <|> return list.nil)) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := Î» (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (Î» (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic unit
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (f : bump_covering Î¹ M s) (hf : âˆ€ (i : Î¹), smooth I (model_with_corners_self â„ â„) â‡‘(â‡‘f i)) : smooth_partition_of_unity Î¹ I M s
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {f : Î± â†’ Î²} [measurable_space Î²] [topological_space.pseudo_metrizable_space Î²] [opens_measurable_space Î²] [topological_space.second_countable_topology Î²] (hf : ae_measurable f Î¼) : measure_theory.ae_strongly_measurable f Î¼
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x : E} {r : ğ•œ} (hx : x â‰  0) (hr : r â‰  0) : is_R_or_C.abs (has_inner.inner x (r â€¢ x)) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
{Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_3} (f : Î± â†’ E) (hfi : measure_theory.integrable f Î¼) {F : Î¹ â†’ Î± â†’ E} {l : filter Î¹} (hFi : âˆ€á¶  (i : Î¹) in l, measure_theory.integrable (F i) Î¼) (hF : filter.tendsto (Î» (i : Î¹), âˆ«â» (x : Î±), â†‘âˆ¥F i x - f xâˆ¥â‚Š âˆ‚Î¼) l (nhds 0)) : filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±), F i x âˆ‚Î¼) l (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {n : with_top â„•} {e : local_homeomorph M H} (h : e âˆˆ smooth_manifold_with_corners.maximal_atlas I M) : cont_mdiff_on I I n â‡‘(e.symm) e.to_local_equiv.target
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : measure_theory.vector_measure Î± ennreal
(md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{R : Type u} [ring R] {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] (i : Î¹) (x : G i) (h : i â‰¤ i) : â‡‘(f i i h) x = x
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X âŸ¶ Y} {Z : C} (g : Y âŸ¶ Z) (eq : f â‰« g = 0) (desc : Î  {Z' : C} (g' : Y âŸ¶ Z'), f â‰« g' = 0 â†’ (Z âŸ¶ Z')) (fac : âˆ€ {Z' : C} (g' : Y âŸ¶ Z') (eq' : f â‰« g' = 0), g â‰« desc g' eq' = g') (uniq : âˆ€ {Z' : C} (g' : Y âŸ¶ Z') (eq' : f â‰« g' = 0) (m : Z âŸ¶ Z'), g â‰« m = g' â†’ m = desc g' eq') : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_Ï€ g eq)
{ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) (x : E) : âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥
{Î¹ : Type u_1} {I : box_integral.box Î¹} [fintype Î¹] (Ï€ : box_integral.tagged_prepartition I) (r : (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)) : Prop
{n : â„•} {Î± : Type u_1} {C : Î  {n : â„•}, vector Î± n â†’ Sort u_2} (v : vector Î± n) (h_nil : C vector.nil) (h_cons : Î  {n : â„•} {x : Î±} {w : vector Î± n}, C w â†’ C (x::áµ¥w)) : C v
{I : Type wâ‚€} (C : I â†’ Type uâ‚) [Î  (i : I), category_theory.category (C i)] (i : I) : (Î  (i : I), C i) â¥¤ C i
{Î± : Type uâ‚} {Î² : Type uâ‚‚} {Ï† : Type uâ‚ƒ} : (Î± Ã— Î² â†’ Ï†) â†’ Î± â†’ Î² â†’ Ï†
{R : Type u_3} {S : Type u_4} {F : Type u_5} [comm_ring R] [comm_ring S] [monoid_hom_class F (polynomial R) (polynomial S)] (Ï† : F) (hÏ† : non_zero_divisors (polynomial R) â‰¤ submonoid.comap â†‘Ï† (non_zero_divisors (polynomial S))) : ratfunc R â†’* ratfunc S
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z} [category_theory.limits.preserves_limit (category_theory.limits.cospan h i) F] (s : category_theory.is_pullback f g h i) : category_theory.is_pullback (F.map f) (F.map g) (F.map h) (F.map i)
{Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s : set Î±} : x âˆˆ closure s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (y : Î±) (H : y âˆˆ s), has_edist.edist x y < Îµ)
{I : Type u} {f : I â†’ Type vâ‚} [decidable_eq I] [Î  (i : I), has_zero (f i)] {i i' : I} (h : i â‰  i') (x : f i) : pi.single i x i' = 0
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] [fintype A] [decidable_eq B] (Ï† : A â†’â‚[R] B) : fintype â†¥(Ï†.range)
{K : Type u_1} [decidable_eq K] {Î“ : K â†’ Type u_2} {Î› : Type u_3} [inhabited Î›] {Ïƒ : Type u_4} [inhabited Ïƒ] (M : Î› â†’ turing.TM2.stmt Î“ Î› Ïƒ) (S : finset Î›) : finset turing.TM2to1.Î›'
(Râ‚ : Type u_3) {A : Type u_5} [comm_semiring Râ‚] [comm_ring A] [algebra Râ‚ A] (I : ideal A) : A â†’â‚[Râ‚] A â§¸ I
(n : name := name.mk_string "_x" name.anonymous) (i : option â„• := option.none) : tactic name
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [nonempty Î²] [semilattice_sup Î²] {Î³ : Type u_1} {F : Î² â†’ Î³ â†’ Î±} {s : set Î³} : uniform_cauchy_seq_on F filter.at_top s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ âˆ€ (x : Î³), x âˆˆ s â†’ has_dist.dist (F m x) (F n x) < Îµ)
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) : summable (Î» (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2)
{Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.finite_measure Î±) : nnreal
{L : Type u_1} [linear_ordered_field L] {W : Type v} [add_comm_group W] [module L W] [finite_dimensional L W] {t : finset W} (h : finite_dimensional.finrank L W + 1 < t.card) : âˆƒ (f : W â†’ L), t.sum (Î» (e : W), f e â€¢ e) = 0 âˆ§ t.sum (Î» (e : W), f e) = 0 âˆ§ âˆƒ (x : W) (H : x âˆˆ t), 0 < f x
{V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : has_inner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥) â†” inner_product_geometry.angle x y = real.pi
{Î² : Type v} {Î³ : Type w} [metric_space Î³] [metric_space Î²] {f : Î³ â†’ Î²} : uniform_embedding f â†” (âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ {a b : Î³}, has_dist.dist a b < Î´ â†’ has_dist.dist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : â„), Î´ > 0 â†’ (âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ {a b : Î³}, has_dist.dist (f a) (f b) < Îµ â†’ has_dist.dist a b < Î´)
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) (Î¼s : set K) (xs : â†¥Î¼s â†’ V) (h_eigenvec : âˆ€ (Î¼ : â†¥Î¼s), f.has_eigenvector â†‘Î¼ (xs Î¼)) : linear_independent K xs
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} (hf : filter.tendsto f l (nhds 0)) (hg : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ g)) (op : E â†’ F â†’ G) (h_op : âˆƒ (A : â„), âˆ€ (x : E) (y : F), âˆ¥op x yâˆ¥ â‰¤ A * âˆ¥xâˆ¥ * âˆ¥yâˆ¥) : filter.tendsto (Î» (x : Î±), op (f x) (g x)) l (nhds 0)
{Ïƒ : Type u_1} (f : Ïƒ â†’ option Ïƒ) (a : Ïƒ) (b : option Ïƒ) (m : â„•) : Type
{V : Type u_1} [inner_product_space â„ V] {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : inner_product_geometry.angle x (x - y) = inner_product_geometry.angle y (y - x)
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) â¦ƒv : Eâ¦„ (hv : v âˆˆ (â¨† (Î¼ : ğ•œ), module.End.eigenspace T Î¼)á—®) : â‡‘T v âˆˆ (â¨† (Î¼ : ğ•œ), module.End.eigenspace T Î¼)á—®
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) : Î± â†’ ennreal
{C : Type uâ‚} [category_theory.category C] {W X Y Z : C} (f : W âŸ¶ X) (g : W âŸ¶ Y) (h : X âŸ¶ Z) (i : Y âŸ¶ Z) : Prop
{Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (Î´ : â„), Î´ > 0 â†’ (f x âˆ© set.Ioo 0 Î´).nonempty) : âˆƒ (t : set (Î± Ã— â„)), t.countable âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.fst âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.snd âˆˆ f p.fst) âˆ§ â‡‘Î¼ (s  â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), metric.closed_ball p.fst p.snd) = 0 âˆ§ t.pairwise_disjoint (Î» (p : Î± Ã— â„), metric.closed_ball p.fst p.snd)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : âˆ I.left âŸ¶ âˆ I.right
(q : pexpr) (allow_mvars subgoals : bool := bool.tt) : tactic expr
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„ (hf : measure_theory.integrable (function.uncurry f) (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (y : Î²), âˆ« (x : Î±), f x y âˆ‚Î¼ âˆ‚Î½
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [add_comm_group G] [has_measurable_addâ‚‚ G] [has_measurable_neg G] [Î¼.is_add_left_invariant] [measure_theory.sigma_finite Î¼] {xâ‚€ : G} {s : set G} (hbg : bdd_above ((Î» (i : G), âˆ¥g iâˆ¥) '' ((Î» (t : G), xâ‚€ - t) â»Â¹' s))) (hs : measurable_set s) (h2s : function.support (Î» (t : G), â‡‘(â‡‘L (f t)) (g (xâ‚€ - t))) âŠ† s) (hf : measure_theory.integrable_on f s Î¼) (hmf : measure_theory.ae_strongly_measurable f Î¼) (hmg : measure_theory.ae_strongly_measurable g Î¼) : convolution_exists_at f g xâ‚€ L Î¼
{Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (ftop : f âŠ¤ = âŠ¤) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
{E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} {f' : E â†’ (E â†’L[ğ•œ] G)} {Ï† : E â†’L[ğ•œ] G} (hf : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥f' x - Ï†âˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
(V : Type u_1) [semi_normed_group V] : âˆ¥normed_group_hom.id Vâˆ¥ â‰¤ 1
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} {g : E â†’ â„} (hg : concave_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) (hgi : measure_theory.integrable_on (g âˆ˜ f) t Î¼) : â¨ (x : Î±) in t, g (f x) âˆ‚Î¼ â‰¤ g (â¨ (x : Î±) in t, f x âˆ‚Î¼)
{f : â„ â†’ â„} (hf' : differentiable â„ f) (hf'' : âˆ€ (x : â„), 0 < deriv^[2] f x) : strict_convex_on â„ set.univ f
(I : name) (T : expr) : tactic (option â„•)
{Ïƒ : Type u_1} (f : Ïƒ â†’ option Ïƒ) (a : Ïƒ) : turing.evals_to f a â†‘a
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] (W : C) (k : Î  (b : I.R), I.right b âŸ¶ W) (h : âˆ€ (a : I.L), I.fst a â‰« k (I.fst_from a) = I.snd a â‰« k (I.snd_from a)) : category_theory.limits.multicoequalizer I âŸ¶ W
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : âˆ I.left âŸ¶ âˆ I.right
(K : Type u_3) [field K] {Râ‚ : Type u_4} [comm_ring Râ‚] [is_domain Râ‚] [algebra Râ‚ K] [is_fraction_ring Râ‚ K] (I J : fractional_ideal (non_zero_divisors Râ‚) K) (h : I * J = 1) : J = Iâ»Â¹
{Î± : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [normed_group F] {ğ•œ : Type u_5} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ F] [fact (1 â‰¤ p)] {ğ•œ' : Type u_4} [normed_field ğ•œ'] [normed_space ğ•œ' F] [smul_comm_class ğ•œ ğ•œ' F] (c : ğ•œ') (L : E â†’L[ğ•œ] F) (f : â†¥(measure_theory.Lp E p Î¼)) : â‡‘(continuous_linear_map.comp_LpL p Î¼ (c â€¢ L)) f = c â€¢ â‡‘(continuous_linear_map.comp_LpL p Î¼ L) f
{Î¹ : Type u_5} {Ïƒ : Î¹ â†’ Type u_6} [Î  (i : Î¹), topological_space (Ïƒ i)] {Ï„ : Î¹ â†’ Type u_1} [Î  (i : Î¹), topological_space (Ï„ i)] {f : Î  (i : Î¹), Ïƒ i â†’ Ï„ i} (hf : âˆ€ (i : Î¹), embedding (f i)) : embedding (sigma.map id f)
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] [measure_theory.sigma_finite Î¼] (f : Î± â†’ â„) (hf : measure_theory.integrable f Î¼) {Îµ : â„} (Îµpos : 0 < Îµ) : âˆƒ (g : Î± â†’ ereal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ
{Î² : Type u} [metric_space Î²] [measurable_space Î²] [borel_space Î²] [sigma_compact_space Î²] [has_besicovitch_covering Î²] (Î¼ : measure_theory.measure Î²) [measure_theory.is_locally_finite_measure Î¼] (s : set Î²) : âˆ€áµ (x : Î²) âˆ‚Î¼.restrict s, filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {C : set (set Î±)} {D : set (set Î²)} (hC : measurable_space.generate_from C = _inst_1) (hD : measurable_space.generate_from D = _inst_3) (h2C : is_pi_system C) (h2D : is_pi_system D) (h3C : Î¼.finite_spanning_sets_in C) (h3D : Î½.finite_spanning_sets_in D) {Î¼Î½ : measure_theory.measure (Î± Ã— Î²)} (hâ‚ : âˆ€ (s : set Î±), s âˆˆ C â†’ âˆ€ (t : set Î²), t âˆˆ D â†’ â‡‘Î¼Î½ (s Ã—Ë¢ t) = â‡‘Î¼ s * â‡‘Î½ t) : Î¼.prod Î½ = Î¼Î½
(c : interactive.parse (optional (lean.parser.tk "!"))) (cfg : tactic.tauto_cfg := {classical := bool.ff, closer := has_pure.pure ()}) : tactic unit
{Î± : Type u_1} {C : list Î± â†’ list Î± â†’ Sort v} (H0 : Î  (is : list Î±), C list.nil is) (H1 : Î  (t : Î±) (ts is : list Î±), C ts (t :: is) â†’ C is list.nil â†’ C (t :: ts) is) (lâ‚ lâ‚‚ : list Î±) : C lâ‚ lâ‚‚
{Î± : Type u} [add_monoid Î±] (u : add_units Î±) (val : Î±) (hv : val = â†‘u) (inv : Î±) (hi : inv = â†‘-u) : add_units Î±
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {q : nnreal} {s : set Î±} (h : s âŠ† {x : Î± | â†‘q < v.lim_ratio_meas hÏ x}) : â†‘q * â‡‘Î¼ s â‰¤ â‡‘Ï s
{n : â„•} {F : typevec n â†’ Type u} (R : Î  â¦ƒÎ± : typevec nâ¦„, F Î± â†’ F Î± â†’ Prop) (Î± : typevec n) : Type u
{Î± : Type u_1} {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} [measure_theory.is_finite_measure Â«â„™Â»] {X : Î± â†’ â„} {s : set â„} (hms : measurable_set s) (hns : â‡‘measure_theory.measure_space.volume s â‰  0) (hnt : â‡‘measure_theory.measure_space.volume s â‰  âŠ¤) (huX : measure_theory.pdf.is_uniform X s Â«â„™Â» measure_theory.measure_space.volume) : âˆ« (x : Î±), X x âˆ‚Â«â„™Â» = (â‡‘measure_theory.measure_space.volume s)â»Â¹.to_real * âˆ« (x : â„) in s, x
(s : simp_lemmas) (u : list name := list.nil) (e : expr) (cfg : tactic.dsimp_config := {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}) : tactic expr
{M : Type u_1} [add_zero_class M] (N : add_submonoid (M Ã— M)) (H : equivalence (Î» (x y : M), (x, y) âˆˆ N)) : add_con M
{C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_coequalizer f g] {W : C} {k l : category_theory.limits.coequalizer f g âŸ¶ W} (h : category_theory.limits.coequalizer.Ï€ f g â‰« k = category_theory.limits.coequalizer.Ï€ f g â‰« l) : k = l
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {v : vitali_family Î¼} {f : Î± â†’ set (set Î±)} {s : set Î±} (h : v.fine_subfamily_on f s) : set Î±
(k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Î¹] (p : Î¹ â†’ P) (s : set Î¹) : finite_dimensional k â†¥((affine_span k (p '' s)).direction)
{R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring Sâ‚] [algebra R Sâ‚] (f : Ïƒ â†’ Sâ‚) : mv_polynomial Ïƒ R â†’â‚[R] Sâ‚
{Î± : Type u_1} [topological_space Î±] [measure_theory.measure_space Î±] [borel_space Î±] {ğ•œ : Type u_2} [is_R_or_C ğ•œ] (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] [compact_space Î±] (f g : C(Î±, ğ•œ)) : has_inner.inner (â‡‘(continuous_map.to_Lp 2 Î¼ ğ•œ) f) (â‡‘(continuous_map.to_Lp 2 Î¼ ğ•œ) g) = âˆ« (x : Î±), â‡‘(star_ring_end ğ•œ) (â‡‘f x) * â‡‘g x âˆ‚Î¼
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (hn : x â‰  y) (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : o.oangle y x = â†‘real.pi - 2 â€¢ o.oangle (y - x) y
{Î± : Type u} {Î² : Type v} [linear_order Î²] {U : filter (Î± Ã— Î±)} (z : Î²) (D : Î± â†’ Î± â†’ Î²) (H : âˆ€ (s : set (Î± Ã— Î±)), s âˆˆ U â†” âˆƒ (Îµ : Î²) (H : Îµ > z), âˆ€ {a b : Î±}, D a b < Îµ â†’ (a, b) âˆˆ s) : U = â¨… (Îµ : Î²) (H : Îµ > z), filter.principal {p : Î± Ã— Î± | D p.fst p.snd < Îµ}
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i â€¢ g i)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_4} [topological_space H] {H' : Type u_5} [topological_space H'] (I : model_with_corners ğ•œ E H) (I' : model_with_corners ğ•œ E' H') (M : Type u_6) [topological_space M] [charted_space H M] (M' : Type u_7) [topological_space M'] [charted_space H' M'] : Type (max u_6 u_7)
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] [measure_theory.sigma_finite Î½] : Î¼.have_lebesgue_decomposition Î½
{f : â„ â†’ â„} (hf' : differentiable â„ f) (hf'' : differentiable â„ (deriv f)) (hf''_nonpos : âˆ€ (x : â„), deriv^[2] f x â‰¤ 0) : concave_on â„ set.univ f
{Î± : Type u_1} {Ïƒ : Type u_3} {Ï„ : Type u_4} (E : Ïƒ â‰ƒ Ï„) : ctop Î± Ïƒ â†’ ctop Î± Ï„
{Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] [normed_space â„ F] (hm : m â‰¤ m0) (hp_ne_top : p â‰  âŠ¤) (P : (Î± â†’ F) â†’ Prop) (h_ind : âˆ€ (c : F) â¦ƒs : set Î±â¦„, measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ P (s.indicator (Î» (_x : Î±), c))) (h_add : âˆ€ â¦ƒf g : Î± â†’ Fâ¦„, disjoint (function.support f) (function.support g) â†’ measure_theory.mem_â„’p f p Î¼ â†’ measure_theory.mem_â„’p g p Î¼ â†’ measure_theory.strongly_measurable f â†’ measure_theory.strongly_measurable g â†’ P f â†’ P g â†’ P (f + g)) (h_closed : is_closed {f : â†¥(measure_theory.Lp_meas F â„ m p Î¼) | P â‡‘f}) (h_ae : âˆ€ â¦ƒf g : Î± â†’ Fâ¦„, f =áµ[Î¼] g â†’ measure_theory.mem_â„’p f p Î¼ â†’ P f â†’ P g) â¦ƒf : Î± â†’ Fâ¦„ (hf : measure_theory.mem_â„’p f p Î¼) (hfm : measure_theory.ae_strongly_measurable' m f Î¼) : P f
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (p : tangent_bundle I H) : (charted_space.chart_at (model_prod H E) p).to_local_equiv = (equiv.sigma_equiv_prod H E).to_local_equiv
(Ïƒ : Type u_1) (R : Type u_2) : Type (max u_1 u_2)
{Î± : Type u_1} {n : Type u_4} [has_zero Î±] : 0.is_diag
{E : Type u_1} [normed_group E] {a : â„} {f g : â„‚ â†’ E} {l : filter â„‚} {u : â„‚ â†’ â„} (hBf : âˆƒ (c : â„) (H : c < a) (B : â„), f =O[l] Î» (z : â„‚), real.exp (B * real.exp (c * |u z|))) (hBg : âˆƒ (c : â„) (H : c < a) (B : â„), g =O[l] Î» (z : â„‚), real.exp (B * real.exp (c * |u z|))) : âˆƒ (c : â„) (H : c < a) (B : â„), (f - g) =O[l] Î» (z : â„‚), real.exp (B * real.exp (c * |u z|))
{Î± : Type u} {Î² : Type v} [topological_space Î±] [compact_space Î±] [pseudo_metric_space Î²] [compact_space Î²] (A : set (bounded_continuous_function Î± Î²)) (closed : is_closed A) (H : âˆ€ (x : Î±) (Îµ : â„), Îµ > 0 â†’ (âˆƒ (U : set Î±) (H : U âˆˆ nhds x), âˆ€ (y : Î±), y âˆˆ U â†’ âˆ€ (z : Î±), z âˆˆ U â†’ âˆ€ (f : bounded_continuous_function Î± Î²), f âˆˆ A â†’ has_dist.dist (â‡‘f y) (â‡‘f z) < Îµ)) : is_compact A
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Î¹} (A B C : homological_complex V c) (Ï† : A.hom B) (Ïˆ : B.hom C) : A.hom C
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {W X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (gâ‚ : Y âŸ¶ W) [category_theory.epi gâ‚] (gâ‚‚ : W âŸ¶ Z) [category_theory.mono gâ‚‚] (hg : gâ‚ â‰« gâ‚‚ = g) (f' : X âŸ¶ W) (hf : f' â‰« gâ‚‚ = f) (t : category_theory.limits.pullback_cone f g) (ht : category_theory.limits.is_limit t) : category_theory.epi t.fst
(Î± : Type u_1) (Ïƒ : Type u_2) : Type (max u_1 u_2)
{Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} [one_le_p : fact (1 â‰¤ p)] [normed_space â„ F] {hm : m â‰¤ m0} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hs : measurable_set s) (hÎ¼s : â‡‘(Î¼.trim hm) s â‰  âŠ¤) (c : F) : â†‘(â‡‘((measure_theory.Lp_meas_to_Lp_trim_lie F â„ p Î¼ hm).symm) (measure_theory.indicator_const_Lp p hs hÎ¼s c)) = measure_theory.indicator_const_Lp p _ _ c
{E : Type u_2} [normed_group E] [normed_space â„ E] {a b : â„} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (h : âˆ€ (x y : E), âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥yâˆ¥ â‰¤ 1 â†’ x â‰  y â†’ âˆ¥a â€¢ x + b â€¢ yâˆ¥ < 1) : strict_convex_space â„ E
{n : â„•} {F : typevec n â†’ Type u} (R : Î  â¦ƒÎ± : typevec nâ¦„, F Î± â†’ F Î± â†’ Prop) [mvfunctor F] (Hfunc : âˆ€ â¦ƒÎ± Î² : typevec nâ¦„ (a b : F Î±) (f : Î±.arrow Î²), R a b â†’ R (mvfunctor.map f a) (mvfunctor.map f b)) : mvfunctor (mvqpf.quot1 R)
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D E : homological_complex V c} (f : C âŸ¶ D) (hom : Î  (i j : Î¹), c.rel j i â†’ (D.X i âŸ¶ E.X j)) : f â‰« homotopy.null_homotopic_map' hom = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), f.f i â‰« hom i j hij)
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] {W X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ W) : category_theory.limits.prod.map f g â‰« (category_theory.limits.prod.braiding Y W).hom = (category_theory.limits.prod.braiding X Z).hom â‰« category_theory.limits.prod.map g f
{Î± : Type u} [pseudo_emetric_space Î±] (s : set Î±) (hs : âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (t : set Î±), t.countable âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), emetric.closed_ball x Îµ)) : âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ s âŠ† closure t
{Î± : Type u} [semiring Î±] (I : ideal Î±) (hI : I â‰  âŠ¤) : âˆƒ (M : ideal Î±), M.is_maximal âˆ§ I â‰¤ M
{Î¹ : Type u_1} {I : box_integral.box Î¹} (boxes : finset (with_bot (box_integral.box Î¹))) (le_of_mem : âˆ€ (J : with_bot (box_integral.box Î¹)), J âˆˆ boxes â†’ J â‰¤ â†‘I) (pairwise_disjoint : â†‘boxes.pairwise disjoint) : box_integral.prepartition I
{C : Type u} [category_theory.category C] (ğ’¯ : category_theory.limits.limit_cone (category_theory.functor.empty C)) (â„¬ : Î  (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) : category_theory.monoidal_category C
(e : environment) (str : name) (trace_if_exists : bool := bool.ff) (rules : list projection_rule := list.nil) (trc : bool := bool.ff) : tactic (list name Ã— list projection_data)
{Î± : Type u_1} {p : finset Î± â†’ Sort u_2} {n : â„•} (H : Î  (tâ‚ : finset Î±), (Î  {tâ‚‚ : finset Î±}, tâ‚‚.card â‰¤ n â†’ tâ‚ âŠ‚ tâ‚‚ â†’ p tâ‚‚) â†’ tâ‚.card â‰¤ n â†’ p tâ‚) (s : finset Î±) : s.card â‰¤ n â†’ p s
{Î± : Type u_1} [measurable_space Î±] {Î¼ Î½ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] [measure_theory.is_finite_measure Î½] : âˆƒ (s : set Î±), measurable_set s âˆ§ (âˆ€ (t : set Î±), measurable_set t â†’ t âŠ† s â†’ â‡‘Î½ t â‰¤ â‡‘Î¼ t) âˆ§ âˆ€ (t : set Î±), measurable_set t â†’ t âŠ† sá¶œ â†’ â‡‘Î¼ t â‰¤ â‡‘Î½ t
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] : Type (max u_1 u_2 u_3)
(s : simp_lemmas Ã— list name) (ps : list pexpr) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{C : Type uâ‚} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] {W : C} (f : X âŸ¶ Y) [category_theory.normal_epi f] (k : X âŸ¶ W) (h : category_theory.normal_epi.g â‰« k = 0) : {l // f â‰« l = k}
(n : name) (r : tactic.decl_reducibility) (persistent : bool := bool.ff) : tactic unit
{I : Type u} (X : I â†’ Top) : category_theory.limits.preserves_limit (category_theory.discrete.functor X) fundamental_groupoid.fundamental_groupoid_functor
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic unit
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) â¦ƒÎ¹ : Type vâ¦„ (U : Î¹ â†’ topological_space.opens â†¥X) : ğŸ­ (category_theory.limits.cone ((category_theory.pairwise.diagram U).op â‹™ F)) â‰… Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_functor F U â‹™ Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_inverse F U
{M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {Î± : Type u_1} {Î² : Type u_2} {s : set (Î² â†’ M)} (h : A.definable L s) (f : Î± â†’ Î²) [fintype Î±] [fintype Î²] : A.definable L ((Î» (g : Î² â†’ M), g âˆ˜ f) '' s)
{Î± : Type u_1} {F : Type u_3} [normed_group F] [normed_space â„ F] {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : measure_theory.simple_func Î± F) : F
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) : â„•
{V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : o.oangle x (x - y) = o.oangle (y - x) y
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} {t : category_theory.limits.pullback_cone f g} (ht : category_theory.limits.is_limit t) {W : C} (h : W âŸ¶ X) (k : W âŸ¶ Y) (w : h â‰« f = k â‰« g) : {l // l â‰« t.fst = h âˆ§ l â‰« t.snd = k}
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} (h : Î¼ â‰¤ Î½) : Î¼.absolutely_continuous Î½
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), has_zero (Î² i)] [Î  (i : Î¹) (x : Î² i), decidable (x â‰  0)] (f : Î â‚€ (i : Î¹), Î² i) : finset Î¹
{R : Type u_1} [semiring R] {Ï† : power_series R} (h : Ï†.order.dom) : â‡‘(power_series.coeff R (Ï†.order.get h)) Ï† â‰  0
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {I : ideal R} (hI : I â‰  âŠ¥) : R â§¸ I â‰ƒ+* Î  (P : â†¥((unique_factorization_monoid.factors I).to_finset)), R â§¸ â†‘P ^ multiset.count â†‘P (unique_factorization_monoid.factors I)
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (h : â†‘(S.topological_closure) â‰  set.univ) : âˆ¥S.normed_mkâˆ¥ = 1
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [category_theory.limits.has_wide_equalizer f] [nonempty J] {W : C} (k : W âŸ¶ X) (h : âˆ€ (jâ‚ jâ‚‚ : J), k â‰« f jâ‚ = k â‰« f jâ‚‚) : W âŸ¶ category_theory.limits.wide_equalizer f
{Î± : Type u} [pseudo_metric_space Î±] {x y : Î±} {Îµ : â„} (h : x âˆˆ metric.ball y Îµ) : âˆƒ (Îµ' : â„) (H : Îµ' < Îµ), x âˆˆ metric.ball y Îµ'
{ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) {C : â„} (hC : 0 â‰¤ C) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥f.mk_continuous C Hâˆ¥ â‰¤ C
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {a : Î±} : a âˆˆ closure s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (b : Î±) (H : b âˆˆ s), has_dist.dist a b < Îµ)
(slow : bool := bool.tt) (verbose : lint_verbosity := lint_verbosity.medium) (extra : list name := list.nil) (use_only : bool := bool.ff) : tactic (name_set Ã— format)
{Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [nonempty Î²] [semilattice_sup Î²] {u : Î² â†’ Î±} : cauchy_seq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ has_dist.dist (u m) (u n) < Îµ)
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] (s : Ïƒ â†’â‚€ â„•) : R â†’â‚—[R] mv_polynomial Ïƒ R
{Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_metric_space (Ï€ b)] [h : âˆ€ (b : Î²), proper_space (Ï€ b)] : proper_space (Î  (b : Î²), Ï€ b)
{V : Type u_1} [inner_product_space â„ V] (x y : V) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {f g : Î± â†’ â„} {s : set Î±} [measure_theory.sigma_finite Î¼] (hf : ae_measurable f (Î¼.restrict s)) (hg : ae_measurable g (Î¼.restrict s)) (hs : measurable_set s) : â‡‘(Î¼.prod measure_theory.measure_space.volume) (region_between f g s) = âˆ«â» (y : Î±) in s, ennreal.of_real ((g - f) y) âˆ‚Î¼
{Î± : Type u} {C : free_semigroup Î± â†’ Sort l} (x : free_semigroup Î±) (ih1 : Î  (x : Î±), C (free_semigroup.of x)) (ih2 : Î  (x : Î±) (y : free_semigroup Î±), C (free_semigroup.of x) â†’ C y â†’ C (free_semigroup.of x * y)) : C x
{J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) (W : C) : ulift (W âŸ¶ t.X) â‰… (category_theory.functor.const J).obj W âŸ¶ F
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G â‰ƒg G') : G' â‰ƒg G
(ğ•œ : Type u_1) (E : Type u_4) [semi_normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] {v : E} (hv : âˆ¥vâˆ¥ = 1) : ğ•œ â†’â‚—áµ¢[ğ•œ] E
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {x : ğ•œ} {s : set ğ•œ} {f' : F} : has_deriv_within_at f f' s x â†” has_fderiv_within_at f (1.smul_right f') s x
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [fintype Î¹] (f : (smooth_bump_covering Î¹ I M)) : âˆƒ (n : â„•) (e : M â†’ euclidean_space â„ (fin n)), smooth I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e âˆ§ function.injective e âˆ§ âˆ€ (x : M), function.injective â‡‘(mfderiv I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e x)
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [sigma_compact_space M] {s : set M} (hs : is_closed s) (U : Î¹ â†’ set M) (ho : âˆ€ (i : Î¹), is_open (U i)) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : smooth_partition_of_unity Î¹ I M s), f.is_subordinate U
{P : Type u â†’ Sort v} (of_equiv : Î  {Î± Î² : Type u}, Î± â‰ƒ Î² â†’ P Î± â†’ P Î²) (h_empty : P pempty) (h_option : Î  {Î± : Type u} [_inst_1 : fintype Î±] [_inst_2 : decidable_eq Î±], P Î± â†’ P (option Î±)) (Î± : Type u) [fintype Î±] [decidable_eq Î±] : trunc (P Î±)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [category_theory.limits.has_wide_coequalizer f] [nonempty J] {W : C} (k : Y âŸ¶ W) (h : âˆ€ (jâ‚ jâ‚‚ : J), f jâ‚ â‰« k = f jâ‚‚ â‰« k) : category_theory.limits.wide_coequalizer f âŸ¶ W
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] : set (local_homeomorph M H)
{n : â„•} (Î± : typevec n) {Î² Î³ : Type u_1} (r : Î² â†’ Î³ â†’ Prop) â¦ƒi : fin2 (n + 1)â¦„ : (Î± ::: Î²) i â†’ (Î± ::: Î³) i â†’ Prop
{Î± : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [preorder Î¹] {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] [has_le E] (f : Î¹ â†’ Î± â†’ E) (â„± : measure_theory.filtration Î¹ m0) (Î¼ : measure_theory.measure Î±) : Prop
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {cM : con M} {cN : con N} {Ï† : cM.quotient â†’ cN.quotient â†’ Sort u_3} (a : cM.quotient) (b : cN.quotient) (f : Î  (x : M) (y : N), Ï† â†‘x â†‘y) (h : âˆ€ (x : M) (y : N) (x' : M) (y' : N), â‡‘cM x x' â†’ â‡‘cN y y' â†’ f x y == f x' y') : Ï† a b
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] {p : ennreal} {f : Î¹ â†’ Î± â†’ Î²} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) : measure_theory.uniform_integrable f p Î¼ â†” (âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) âˆ§ âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (C : nnreal), âˆ€ (i : Î¹), measure_theory.snorm ({x : Î± | C â‰¤ âˆ¥f i xâˆ¥â‚Š}.indicator (f i)) p Î¼ â‰¤ ennreal.of_real Îµ)
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : Prop
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R â†’+* S) (s : set R) : subsemiring.map f (subsemiring.closure s) = subsemiring.closure (â‡‘f '' s)
(ğ•œ : Type v) [is_R_or_C ğ•œ] {E : Type u} [normed_group E] [normed_space ğ•œ E] (x : E) : âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ â‰¤ 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
{M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {Î± : Type u_1} {Î² : Type u_2} {s : set (Î² â†’ M)} (h : A.definable L s) (f : Î± â†ª Î²) [fintype Î²] : A.definable L ((Î» (g : Î² â†’ M), g âˆ˜ â‡‘f) '' s)
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î²] [topological_space Î³] [measurable_space Î²] [topological_space.pseudo_metrizable_space Î²] [borel_space Î²] [measurable_space Î³] [topological_space.pseudo_metrizable_space Î³] [opens_measurable_space Î³] [topological_space.second_countable_topology Î³] (g : Î² â†’ Î³) (hg : measurable g) (f : Î± â†’â‚˜[Î¼] Î²) : Î± â†’â‚˜[Î¼] Î³
{C : Type uâ‚} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] (X : C) : category_theory.forget_enrichment W C
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] (Î¼ : measure_theory.measure Î±) (f : Î± â†’ E) : E
{X : Type u_1} {Y : Type u_2} [topological_space X] {m : measurable_space X} [topological_space Y] [t2_space Y] {Î¼ : measure_theory.measure X} [Î¼.is_open_pos_measure] {U : set X} {f g : X â†’ Y} (h : f =áµ[Î¼.restrict U] g) (hU : is_open U) (hf : continuous_on f U) (hg : continuous_on g U) : set.eq_on f g U
{p : â„•+} {k : â„•} {K : Type u} [field K] [char_zero K] {Î¶ : K} [hp : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ k} â„š K] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ k)) : âˆƒ (u : â„¤Ë£) (n : â„•), algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = â†‘u * â†‘p ^ n
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i * g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i)
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (f : â†¥(measure_theory.Lp.simple_func â„ 1 Î¼)) : â†¥(measure_theory.Lp.simple_func â„ 1 Î¼)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) (R : Type u_4) [semiring R] [topological_space R] [charted_space H R] : Prop
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {Î¼ : measure_theory.measure â„} {E : Type u_2} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {a b Îµ : â„} {bound : â„ â†’ â„} {F F' : ğ•œ â†’ â„ â†’ E} {xâ‚€ : ğ•œ} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : ğ•œ) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F xâ‚€) Î¼ a b) (hF'_meas : measure_theory.ae_strongly_measurable (F' xâ‚€) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ€ (x : ğ•œ), x âˆˆ metric.ball xâ‚€ Îµ â†’ âˆ¥F' x tâˆ¥ â‰¤ bound t) (bound_integrable : interval_integrable bound Î¼ a b) (h_diff : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ€ (x : ğ•œ), x âˆˆ metric.ball xâ‚€ Îµ â†’ has_deriv_at (Î» (x : ğ•œ), F x t) (F' x t) x) : interval_integrable (F' xâ‚€) Î¼ a b âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' xâ‚€ t âˆ‚Î¼) xâ‚€
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space ğ•œ H] {F : H â†’ Î± â†’ E} {F' : H â†’ Î± â†’ (H â†’L[ğ•œ] E)} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : H) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) Î¼) (hF_int : measure_theory.integrable (F xâ‚€) Î¼) (hF'_meas : measure_theory.ae_strongly_measurable (F' xâ‚€) Î¼) (h_bound : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ âˆ¥F' x aâˆ¥ â‰¤ bound a) (bound_integrable : measure_theory.integrable bound Î¼) (h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ has_fderiv_at (Î» (x : H), F x a) (F' x a) x) : has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î²] [topological_space Î³] (g : Î² â†’ Î³) (hg : continuous g) (f : Î± â†’â‚˜[Î¼] Î²) : Î± â†’â‚˜[Î¼] Î³
{Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} : Î¼.absolutely_continuous Î½ â†’ Î¼.ae â‰¤ Î½.ae
{n : â„•} (i : fin2 n) â¦ƒÎ± : typevec nâ¦„ : (mvqpf.prj.P i).obj Î± â†’ mvqpf.prj i Î±
(elaborated : bool := bool.tt) : Type
{F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
{R : Type u} [comm_semiring R] {I J : ideal R} : I âˆ£ J â†’ J â‰¤ I
{R : Type u_1} [semiring R] {Î¹ : Type u_4} {Ï† : Î¹ â†’ Type u_5} [Î  (i : Î¹), topological_space (Ï† i)] [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] (i : Î¹) : (Î  (i : Î¹), Ï† i) â†’L[R] Ï† i
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [category_theory.limits.has_wide_equalizer f] [nonempty J] {W : C} {k l : W âŸ¶ category_theory.limits.wide_equalizer f} (h : k â‰« category_theory.limits.wide_equalizer.Î¹ f = l â‰« category_theory.limits.wide_equalizer.Î¹ f) : k = l
{k : Type u_1} {G : Type u_2} {V : Type u_3} {W : Type u_4} [comm_semiring k] [monoid G] [add_comm_monoid V] [module k V] [add_comm_monoid W] [module k W] (ÏV : representation k G V) (ÏW : representation k G W) : representation k G (tensor_product k V W)
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [Î¼.is_mul_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.snd, z.snd * z.fst)) (Î¼.prod Î½) = Î½.prod Î¼
{G : Type u_1} [measurable_space G] [add_group G] [topological_space G] (Î¼ : measure_theory.measure G) [Î¼.is_add_haar_measure] [sigma_compact_space G] : measure_theory.sigma_finite Î¼
{c d : Type u â†’ Type v} (f : Î  {Î± : Type u}, c Î± â†’ d Î±) (b : category_theory.bundled c) : category_theory.bundled d
{J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) (W : C) : ulift (W âŸ¶ t.X) â‰… {p // âˆ€ {j j' : J} (f : j âŸ¶ j'), p j â‰« F.map f = p j'}
{V W : SemiNormedGroup} [complete_space â†¥W] [separated_space â†¥W] (f : V âŸ¶ W) : SemiNormedGroup.Completion.obj V âŸ¶ W
(f : Type u â†’ Type v â†’ Type w) (hf : Î  (Î± Î² : Type u) (Î³ Î´ : Type v), Î± â‰ƒ Î² â†’ Î³ â‰ƒ Î´ â†’ f Î± Î³ â‰ƒ f Î² Î´) : cardinal â†’ cardinal â†’ cardinal
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_finite_measure Î¼] (hg : strict_convex_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ g (â¨ (x : Î±), f x âˆ‚Î¼) < â¨ (x : Î±), g (f x) âˆ‚Î¼
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.finite_measure Î±) {fs : â„• â†’ bounded_continuous_function Î± nnreal} {c : nnreal} (fs_le_const : âˆ€ (n : â„•) (a : Î±), â‡‘(fs n) a â‰¤ c) {f : Î± â†’ nnreal} (fs_lim : âˆ€ (a : Î±), filter.tendsto (Î» (n : â„•), â‡‘(fs n) a) filter.at_top (nhds (f a))) : filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), â†‘(f a) âˆ‚â†‘Î¼))
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M â†’ M') (s : set M) : tangent_bundle I M â†’ tangent_bundle I' M'
(s : simp_lemmas) (e : expr) (md : tactic.transparency := tactic.transparency.reducible) : tactic expr
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] (f : â†¥(measure_theory.Lp E p Î¼)) (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) (Îµ : ennreal) : Îµ ^ p.to_real * â‡‘Î¼ {x : Î± | Îµ â‰¤ â†‘âˆ¥â‡‘f xâˆ¥â‚Š} â‰¤ ennreal.of_real âˆ¥fâˆ¥ ^ p.to_real
{Ïƒ : Type u_1} {f : Ïƒ â†’ option Ïƒ} {b : Ïƒ} {C : Ïƒ â†’ Sort u_2} {a : Ïƒ} (h : b âˆˆ turing.eval f a) (H : Î  (a : Ïƒ), b âˆˆ turing.eval f a â†’ (Î  (a' : Ïƒ), f a = option.some a' â†’ C a') â†’ C a) : C a
{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s t : set Î±} (Hf : antitone_on f t) (Hst : s âŠ† t) : (upper_bounds s âˆ© t).nonempty â†’ bdd_below (f '' s)
(ns : name) (Î± : Type) [reflected Î±] [has_reflect Î±] (s : tactic.local_cache.internal.cache_scope := tactic.local_cache.cache_scope.block_local) : tactic (option Î±)
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {I : ideal R} (J : ideal S) (f : R â†’+* S) (hIJ : I â‰¤ ideal.comap f J) : R â§¸ I â†’+* S â§¸ J
{Î± : Sort u_1} {Î² : Sort u_2} {ra : Î± â†’ Î± â†’ Prop} {rb : Î² â†’ Î² â†’ Prop} {Ï† : quot ra â†’ quot rb â†’ Sort u_3} (qa : quot ra) (qb : quot rb) (f : Î  (a : Î±) (b : Î²), Ï† (quot.mk ra a) (quot.mk rb b)) (ca : âˆ€ {b : Î²} {aâ‚ aâ‚‚ : Î±}, ra aâ‚ aâ‚‚ â†’ f aâ‚ b == f aâ‚‚ b) (cb : âˆ€ {a : Î±} {bâ‚ bâ‚‚ : Î²}, rb bâ‚ bâ‚‚ â†’ f a bâ‚ == f a bâ‚‚) : Ï† qa qb
{P : Type u_1} [preorder P] (I : order.ideal P) : Prop
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] (f : Î± â†’ nnreal) (int_f : âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ â‰  âŠ¤) {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ f x) âˆ§ upper_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ
(Î± : Type u_1) (Î² : Type u_2) [measurable_space Î±] [topological_space Î²] (Î¼ : measure_theory.measure Î±) : Type (max u_1 u_2)
{R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [semiring R] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} [ring_hom_inv_pair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] [ring_hom_inv_pair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] [semi_normed_group E] [semi_normed_group Eâ‚‚] [module R E] [module Râ‚‚ Eâ‚‚] (e : E â‰ƒâ‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) (hâ‚ : âˆ€ (x : E), âˆ¥â‡‘e xâˆ¥ â‰¤ âˆ¥xâˆ¥) (hâ‚‚ : âˆ€ (y : Eâ‚‚), âˆ¥â‡‘(e.symm) yâˆ¥ â‰¤ âˆ¥yâˆ¥) : E â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚
{Î± : Type u_1} {m : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) : Prop
(ğ•œ : Type u) {A : Type v} [field ğ•œ] [ring A] [algebra ğ•œ A] [is_alg_closed ğ•œ] [nontrivial A] [I : finite_dimensional ğ•œ A] (a : A) : âˆƒ (k : ğ•œ), k âˆˆ spectrum ğ•œ a
{Ïƒ : Type u} {m : Type u â†’ Type v} [monad m] [monad_state Ïƒ m] : m Ïƒ
{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.periodic_orbit f x = â†‘(list.map (Î» (n : â„•), f^[n] x) (list.range (function.minimal_period f x)))
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ F'} {s : set Î±} (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (hf : measure_theory.integrable f Î¼) (hs : measurable_set s) : âˆ« (x : Î±) in s, measure_theory.condexp m Î¼ f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
{Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
{n : â„•} {F : typevec (n + 1) â†’ Type u} [mvfunctor F] [q : mvqpf F] {Î± : typevec n} {Î² : Type u} (g : Î  {X : Type u}, (Î² â†’ X) â†’ F (Î± ::: X)) (x : Î²) : mvqpf.cofix F Î±
{L : first_order.language} {Î± : Type u'} {Î² : Type v'} [decidable_eq Î±] {n : â„•} (Ï† : L.bounded_formula Î± n) (f : â†¥(Ï†.free_var_finset) â†’ Î²) : L.bounded_formula Î² n
{Î± : Sort u} {Î² : Sort v} {W : Î± â†’ Sort w} {Z : Î² â†’ Sort z} (hâ‚ : Î± â‰ƒ Î²) (hâ‚‚ : Î  (a : Î±), W a â‰ƒ Z (â‡‘hâ‚ a)) : (Î  (a : Î±), W a) â‰ƒ Î  (b : Î²), Z b
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : ae_measurable f Î¼) (Îµ : ennreal) : Îµ * â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼
{Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Î¹ R M) {Râ‚ : Type u_9} [semiring Râ‚] {Ïƒ : R â†’+* Râ‚} {Ïƒ' : Râ‚ â†’+* R} [ring_hom_inv_pair Ïƒ Ïƒ'] [ring_hom_inv_pair Ïƒ' Ïƒ] {Mâ‚ : Type u_10} [add_comm_monoid Mâ‚] [module Râ‚ Mâ‚] {fâ‚ fâ‚‚ : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚} (h : âˆ€ (i : Î¹), â‡‘fâ‚ (â‡‘b i) = â‡‘fâ‚‚ (â‡‘b i)) : fâ‚ = fâ‚‚
{Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] (hp_ne_top : p â‰  âŠ¤) (P : â†¥(measure_theory.Lp E p Î¼) â†’ Prop) (h_ind : âˆ€ (c : E) {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s < âŠ¤), P â†‘(measure_theory.Lp.simple_func.indicator_const p hs _ c)) (h_add : âˆ€ â¦ƒf g : Î± â†’ Eâ¦„ (hf : measure_theory.mem_â„’p f p Î¼) (hg : measure_theory.mem_â„’p g p Î¼), disjoint (function.support f) (function.support g) â†’ P (measure_theory.mem_â„’p.to_Lp f hf) â†’ P (measure_theory.mem_â„’p.to_Lp g hg) â†’ P (measure_theory.mem_â„’p.to_Lp f hf + measure_theory.mem_â„’p.to_Lp g hg)) (h_closed : is_closed {f : â†¥(measure_theory.Lp E p Î¼) | P f}) (f : â†¥(measure_theory.Lp E p Î¼)) : P f
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] : box_integral.integrable I l f vol â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (r : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)), (âˆ€ (c : nnreal), l.r_cond (r c)) âˆ§ âˆ€ (câ‚ câ‚‚ : nnreal) (Ï€â‚ Ï€â‚‚ : box_integral.tagged_prepartition I), l.mem_base_set I câ‚ (r câ‚) Ï€â‚ â†’ Ï€â‚.is_partition â†’ l.mem_base_set I câ‚‚ (r câ‚‚) Ï€â‚‚ â†’ Ï€â‚‚.is_partition â†’ has_dist.dist (box_integral.integral_sum f vol Ï€â‚) (box_integral.integral_sum f vol Ï€â‚‚) â‰¤ Îµ)
(I : Type u_1) (A : Type u_2) (m : I â†’ Type u_3) [ring A] [topological_space A] [topological_ring A] [Î  (i : I), fintype (m i)] : topological_ring (Î  (i : I), matrix (m i) (m i) A)
{Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} {Ï€ : box_integral.tagged_prepartition I} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {c : nnreal} {Îµ : â„} [complete_space F] (h : box_integral.integrable I l f vol) (h0 : 0 < Îµ) (hÏ€ : l.mem_base_set I c (h.convergence_r Îµ c) Ï€) : has_dist.dist (box_integral.integral_sum f vol Ï€) (Ï€.to_prepartition.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)) â‰¤ Îµ
(R : Type u) {Î¹ : Type x} {Î¹' : Type x'} [semiring R] (Ï† : Î¹ â†’ Type u_1) [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] (e : Î¹' â‰ƒ Î¹) : (Î  (i' : Î¹'), Ï† (â‡‘e i')) â‰ƒâ‚—[R] Î  (i : Î¹), Ï† i
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.multifork I â‰Œ category_theory.limits.fork I.fst_pi_map I.snd_pi_map
{Î± : Type u_1} [topological_space Î±] [t2_space Î±] {f : Î± â†’ Î±} {x y : Î±} (hy : filter.tendsto (Î» (n : â„•), f^[n] x) filter.at_top (nhds y)) (hf : continuous_at f y) : function.is_fixed_pt f y
{R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] (I : submodule R P) : Prop
{Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [has_zero M] (f : Î± â†’ Î²) (hif : set.inj_on f (f â»Â¹' â†‘(0.support)) := _) : finsupp.comap_domain f 0 hif = 0
{E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {s : set E} (hs : convex â„ s) : measure_theory.null_measurable_set s Î¼
{R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] {I I' : R â†’+* R} [nontrivial R] {B : M â†’â‚›â‚—[I] M â†’â‚›â‚—[I'] R} {v : basis n R M} (h : B.is_Ortho â‡‘v) (hB : B.separating_left) (i : n) : Â¬B.is_ortho (â‡‘v i) (â‡‘v i)
{J : Type uâ‚} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J â¥¤ C) [category_theory.limits.has_limit F] (W : C) : ulift (W âŸ¶ category_theory.limits.limit F) â‰… {p // âˆ€ {j j' : J} (f : j âŸ¶ j'), p j â‰« F.map f = p j'}
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î²] : has_coe_to_fun (Î± â†’â‚˜[Î¼] Î²) (Î» (_x : Î± â†’â‚˜[Î¼] Î²), Î± â†’ Î²)
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) â¦ƒÎ¹ : Type vâ¦„ (U : Î¹ â†’ topological_space.opens â†¥X) (c : category_theory.limits.cone ((category_theory.pairwise.diagram U).op â‹™ F)) : category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U)
(z : upper_half_plane) {cd : fin 2 â†’ â„¤} (hcd : is_coprime (cd 0) (cd 1)) : âˆƒ (g : matrix.special_linear_group (fin 2) â„¤), â†‘g 1 = cd âˆ§ âˆ€ (g' : matrix.special_linear_group (fin 2) â„¤), â†‘g 1 = â†‘g' 1 â†’ |(g â€¢ z).re| â‰¤ |(g' â€¢ z).re|
{Î¹ : Type u_1} {Î± : Type u_2} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (h : âˆ€ (i : Î¹), measure_theory.null_measurable_set (s i) Î¼) (hd : pairwise (measure_theory.ae_disjoint Î¼ on s)) : âˆƒ (t : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), t i âŠ† s i) âˆ§ (âˆ€ (i : Î¹), s i =áµ[Î¼] t i) âˆ§ (âˆ€ (i : Î¹), measurable_set (t i)) âˆ§ pairwise (disjoint on t)
(R : Type u) [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] {N : Type uâ‚} [add_comm_monoid N] [module R N] â¦ƒÏˆ Ïˆ' : direct_sum Î¹ (Î» (i : Î¹), M i) â†’â‚—[R] Nâ¦„ (H : âˆ€ (i : Î¹), Ïˆ.comp (direct_sum.lof R Î¹ M i) = Ïˆ'.comp (direct_sum.lof R Î¹ M i)) : Ïˆ = Ïˆ'
{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.periodic_orbit f x = cycle.map (Î» (n : â„•), f^[n] x) â†‘(list.range (function.minimal_period f x))
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {s : set E} {f' : E â†’L[ğ•œ] F} {x : E} (h : has_fderiv_within_at f f' s x) : set.maps_to â‡‘f' (tangent_cone_at ğ•œ s x) (tangent_cone_at ğ•œ (f '' s) (f x))
{M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {Î± : Type u_1} (m : â„•) {s : set (Î± âŠ• fin m â†’ M)} (h : A.definable L s) : A.definable L ((Î» (g : Î± âŠ• fin m â†’ M), g âˆ˜ sum.inl) '' s)
{Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {Îµ : nnreal} : emetric.ball x â†‘Îµ = metric.ball x â†‘Îµ
{Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : ((Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f' =O[l] g'
{ğ•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [normed_group E] [normed_group Fâ‚—] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—) : âˆ¥c.smul_right fâˆ¥ = âˆ¥câˆ¥ * âˆ¥fâˆ¥
{P : Type u_1} [has_le P] (I : order.ideal P) : Prop
{Î± : Sort u_1} {Î² : Sort u_2} {sâ‚ : setoid Î±} {sâ‚‚ : setoid Î²} {Ï† : quotient sâ‚ â†’ quotient sâ‚‚ â†’ Sort u_3} (qa : quotient sâ‚) (qb : quotient sâ‚‚) (f : Î  (a : Î±) (b : Î²), Ï† (quotient.mk' a) (quotient.mk' b)) (c : âˆ€ (aâ‚ : Î±) (bâ‚ : Î²) (aâ‚‚ : Î±) (bâ‚‚ : Î²), aâ‚ â‰ˆ aâ‚‚ â†’ bâ‚ â‰ˆ bâ‚‚ â†’ f aâ‚ bâ‚ == f aâ‚‚ bâ‚‚) : Ï† qa qb
{Î± : Type u_1} {ğ•œ : Type u_14} [normed_field ğ•œ] {l : filter Î±} {u v : Î± â†’ ğ•œ} : u =o[l] v â†’ (âˆƒ (Ï† : Î± â†’ ğ•œ) (hÏ† : filter.tendsto Ï† l (nhds 0)), u =á¶ [l] Ï† * v)
{Î³ : Type w} [emetric_space Î³] {x y : Î³} (h : âˆ€ (Îµ : ennreal), Îµ > 0 â†’ has_edist.edist x y â‰¤ Îµ) : x = y
(f : C(â†¥unit_interval, â„)) (Îµ : â„) (h : 0 < Îµ) (n : â„•) (x : â†¥unit_interval) : finset (fin (n + 1))
{E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) {s : set M} (hsc : is_closed s) (hs : s âŠ† function.support â‡‘f) : âˆƒ (r : â„) (hr : r âˆˆ set.Ioo 0 f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R), s âŠ† (charted_space.chart_at H c).to_local_equiv.source âˆ© â‡‘(ext_chart_at I c) â»Â¹' euclidean.ball (â‡‘(ext_chart_at I c) c) r
 : 0.prod = 1
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [group G] [topological_group G] [Î¼.is_mul_left_invariant] (K : set G) (hK : is_compact K) (h : â‡‘Î¼ K â‰  0) : Î¼.is_open_pos_measure
{ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] [complete_space ğ•œ] {c : ğ•œ} (hc : 1 < âˆ¥câˆ¥) {R : â„} (hR : âˆ¥câˆ¥ < R) (h : Â¬finite_dimensional ğ•œ E) (s : finset E) : âˆƒ (x : E), âˆ¥xâˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ s â†’ 1 â‰¤ âˆ¥y - xâˆ¥
{Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D E : homological_complex V c} (hom : Î  (i j : Î¹), c.rel j i â†’ (C.X i âŸ¶ D.X j)) (g : D âŸ¶ E) : homotopy.null_homotopic_map' hom â‰« g = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), hom i j hij â‰« g.f j)
(R : Type u) (Ïƒ : Type u_1) [comm_semiring R] [he : is_empty Ïƒ] : mv_polynomial Ïƒ R â‰ƒâ‚[R] R
{Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [nonempty Î¹] [is_directed Î¹ has_le.le] [Î  (i : Î¹), field (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’ G j) (p : ring.direct_limit G f) : ring.direct_limit G f
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} {S : J.cover X} {T : Î  (I : S.arrow), J.cover I.Y} (I : (S.bind T).arrow) : I.middle âŸ¶ X
(cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : state_t tactic.ext_state tactic unit
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] (X : Î£ (i : I), C i) : category_theory.sigma.sigma_hom X X
(Î± : Type u) (Î² : Type v) [add_group Î±] [add_action Î± Î²] {Ï† : quotient (add_action.orbit_rel Î± Î²) â†’ Î²} (hÏ† : function.right_inverse Ï† quotient.mk') : Î² â‰ƒ Î£ (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), â†¥(add_action.orbit Î± (Ï† Ï‰))
{Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” monovary f (g âˆ˜ â‡‘Ïƒ)
{ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] [finite_dimensional ğ•œ E] [nontrivial E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) : module.End.has_eigenvalue T (â†‘â¨… (x : {x // x â‰  0}), â‡‘is_R_or_C.re (has_inner.inner (â‡‘T â†‘x) â†‘x) / âˆ¥â†‘xâˆ¥ ^ 2)
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ F'} {s : set Î±} (hf_int : measure_theory.integrable f Î¼) (hs : measurable_set s) : measure_theory.condexp m Î¼ (s.indicator f) =áµ[Î¼] s.indicator (measure_theory.condexp m Î¼ f)
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î²] {m0 : measurable_space Î±} (f : measure_theory.outer_measure Î± â†’â‚—[ennreal] measure_theory.outer_measure Î²) (hf : âˆ€ (Î¼ : measure_theory.measure Î±), _inst_1 â‰¤ (â‡‘f Î¼.to_outer_measure).caratheodory) : measure_theory.measure Î± â†’â‚—[ennreal] measure_theory.measure Î²
{Î¹ : Type v} {Î± : Î¹ â†’ Type u} {Î´ : Î  (i : Î¹), Î± i â†’ Type w} [Î  (i : Î¹) (j : Î± i), add_comm_monoid (Î´ i j)] : direct_sum (Î£ (i : Î¹), Î± i) (Î» (i : Î£ (i : Î¹), Î± i), Î´ i.fst i.snd) â†’+ direct_sum Î¹ (Î» (i : Î¹), direct_sum (Î± i) (Î» (j : Î± i), Î´ i j))
{Î± : Type u_1} {G : Type u_8} [normed_group G] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} [normed_space â„ G] (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (x : G) : measure_theory.integrable â‡‘(measure_theory.condexp_ind_smul hm hs hÎ¼s x) Î¼
(L : first_order.language) (Î¹ : Type v) [preorder Î¹] (G : Î¹ â†’ Type w) [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [is_directed Î¹ has_le.le] [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [nonempty Î¹] (i : Î¹) : L.embedding (G i) (first_order.language.direct_limit G f)
{Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hs : convex â„ s) (hsc : is_closed s) (hÎ¼ : Î¼ â‰  0) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) : â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ s
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M â†’ M') (s : set M) : Prop
{R : Type u} [ring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] {f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)} [nonempty Î¹] [is_directed Î¹ has_le.le] (z : module.direct_limit G f) : âˆƒ (i : Î¹) (x : G i), â‡‘(module.direct_limit.of R Î¹ G f i) x = z
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] {H' : Type u_5} [topological_space H'] {E' : Type u_6} [normed_group E'] [normed_space ğ•œ E'] (I : model_with_corners ğ•œ E H) (I' : model_with_corners ğ•œ E' H') (G : Type u_8) [topological_space G] [charted_space H G] [add_monoid G] [has_smooth_add I G] (G' : Type u_9) [topological_space G'] [charted_space H' G'] [add_monoid G'] [has_smooth_add I' G'] : Type (max u_8 u_9)
(trace : interactive.parse (optional (lean.parser.tk "?"))) (cfg : tactic.tidy.cfg := {trace_result := bool.ff, trace_result_prefix := "Try this: ", tactics := tactic.tidy.default_tactics}) : tactic unit
{Î± : Type u_1} {E : Type u_2} (ğ•œ : Type u_4) [is_R_or_C ğ•œ] [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [inner_product_space ğ•œ E] {s : set Î±} (f : â†¥(measure_theory.Lp E 2 Î¼)) (hs : measurable_set s) (c : E) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s c) f = âˆ« (x : Î±) in s, has_inner.inner c (â‡‘f x) âˆ‚Î¼
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = 0) : has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2|
(Ïƒ : Type u_1) {R : Type u_2} {S : Type u_3} [semiring R] [semiring S] (f : R â†’+* S) : mv_power_series Ïƒ R â†’+* mv_power_series Ïƒ S
{Î± : Type u} {Ïƒ : Type v} (M : NFA Î± Ïƒ) : DFA Î± (set Ïƒ)
{F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = -1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), r < 0 âˆ§ y = r â€¢ x
{ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} {x : G} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.is_neg_invariant] : convolution f g L Î¼ x = âˆ« (t : G), â‡‘(â‡‘L (f (x - t))) (g t) âˆ‚Î¼
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_strict_total_order' Î± r] [Î  (x y : Î±), decidable (Â¬r x y)] : linear_order Î±
{Î¹ : Type u_1} {R : Type u} [comm_ring R] {s : finset Î¹} {f : Î¹ â†’ ideal R} (a b : Î¹) (hp : âˆ€ (i : Î¹), i âˆˆ s â†’ i â‰  a â†’ i â‰  b â†’ (f i).is_prime) {I : ideal R} : (â†‘I âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ â†‘s), â†‘(f i)) â†” âˆƒ (i : Î¹) (H : i âˆˆ s), I â‰¤ f i
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {Îµ : Type u_5} (f : Î³ â†’ Î´ â†’ Îµ) (g : Î± â†’ Î³) (h : Î² â†’ Î´) (a : Î±) (b : Î²) : Îµ
{X : Type u} {Î± : Type v} [topological_space X] [linear_order Î±] [topological_space Î±] [order_closed_topology Î±] {s : set X} (hs : is_preconnected s) {a b : X} (ha : a âˆˆ s) (hb : b âˆˆ s) {f : X â†’ Î±} (hf : continuous_on f s) : set.Icc (f a) (f b) âŠ† f '' s
{Ïƒ : Type u_1} {Ï„ : Type u_2} (R : Type u_4) [comm_semiring R] (f : Ïƒ â‰ƒ Ï„) : mv_polynomial Ïƒ R â‰ƒâ‚[R] mv_polynomial Ï„ R
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] (Î¼ : Î  (i : Î¹), measure_theory.measure (Î± i)) [encodable Î¹] : measure_theory.measure (Î  (i : Î¹), Î± i)
{K : Type u_1} [linear_ordered_field K] {f : polynomial â„¤} {a b : â„¤} (b0 : 0 < b) (fab : polynomial.eval (â†‘a / â†‘b) (polynomial.map (algebra_map â„¤ K) f) â‰  0) : 1 â‰¤ â†‘b ^ f.nat_degree * |polynomial.eval (â†‘a / â†‘b) (polynomial.map (algebra_map â„¤ K) f)|
{Î± : Type u} [ring Î±] (u : Î±Ë£) : â†‘-u = -â†‘u
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : â„• â†’ set Î±} (hs : âˆ‘' (i : â„•), â‡‘Î¼ (s i) â‰  âŠ¤) : â‡‘Î¼ (filter.at_top.limsup s) = 0
{Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {Îµ : â„} (h : 0 â‰¤ Îµ) : emetric.closed_ball x (ennreal.of_real Îµ) = metric.closed_ball x Îµ
{R : Type u_5} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•+} (h : is_primitive_root Î¶ â†‘n) : polynomial.nth_roots_finset â†‘n R = â†‘n.divisors.bUnion (Î» (i : â„•), primitive_roots i R)
{Î± : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : set Î±} (h : measure_theory.ae_disjoint Î¼ s t) : âˆƒ (u : set Î±), measurable_set u âˆ§ â‡‘Î¼ u = 0 âˆ§ disjoint (s  u) t
(close_goals : bool) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := Î» (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (Î» (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) (d : tactic.suggest.decl_data) : tactic â„•
{Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [add_comm_monoid N] [module R N] (p : Î¹ â†’ submodule R N) [Î  (i : Î¹) (x : â†¥(p i)), decidable (x â‰  0)] (x : N) : x âˆˆ supr p â†” âˆƒ (f : Î â‚€ (i : Î¹), â†¥(p i)), f.sum (Î» (i : Î¹) (xi : â†¥(p i)), â†‘xi) = x
{R : Type u} {Ïƒ : Type u_1} [comm_semiring R] (m : Ïƒ â†’â‚€ â„•) (p : mv_polynomial Ïƒ R) : R
{I : Type wâ‚€} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {A : Type uâ‚} [category_theory.category A] (f f' : A â¥¤ Î  (i : I), C i) (h : âˆ€ (i : I), f â‹™ category_theory.pi.eval C i = f' â‹™ category_theory.pi.eval C i) : f = f'
(pp_name : name) (type : expr) (bi : binder_info := binder_info.default) : tactic.unsafe.type_context expr
{m : Type u_2} {n : Type u_3} [fintype m] [fintype n] {Î± : m â†’ n â†’ Type v} (M : dmatrix m n Î±) {Î² : m â†’ n â†’ Type w} (f : Î  â¦ƒi : mâ¦„ â¦ƒj : nâ¦„, Î± i j â†’ Î² i j) : dmatrix m n Î²
{V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x (x - y) = inner_product_geometry.angle y (y - x)) (hpi : inner_product_geometry.angle x y â‰  real.pi) : âˆ¥xâˆ¥ = âˆ¥yâˆ¥
{Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) (x : Î±) : filter (set Î±)
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] {Î¼Î½ : measure_theory.measure (Î± Ã— Î²)} (h : âˆ€ (s : set Î±) (t : set Î²), measurable_set s â†’ measurable_set t â†’ â‡‘Î¼Î½ (s Ã—Ë¢ t) = â‡‘Î¼ s * â‡‘Î½ t) : Î¼.prod Î½ = Î¼Î½
(f : C(â†¥unit_interval, â„)) (Îµ : â„) (h : 0 < Îµ) : â„
(l : interactive.parse interactive.types.pexpr_list_or_texpr) (locat : interactive.parse interactive.types.location) (cfg : tactic.equiv_rw_cfg := {max_depth := 10}) : tactic.interactive.itactic
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) : â†¥I â†’â‚—â…Râ† L
{Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} (hm : m â‰¤ m0) (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite (Î¼.trim hm)] (f : Î± â†’ F') : â†¥(measure_theory.Lp F' 1 Î¼)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : â„•} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : â„•} (h : fs.card = m + 1) : set.range (s.face h).points = s.points '' â†‘fs
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X â†’ Y} {s : set X} (h : lipschitz_on_with K f s) : dimH (f '' s) â‰¤ dimH s
{R : Type u_1} {S : Type u_6} {M : Type u_9} {Mâ‚ƒ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid Mâ‚ƒ] [module R M] [module S Mâ‚ƒ] {Ïƒ : R â†’+* S} (f : M â†’â‚›â‚—[Ïƒ] Mâ‚ƒ) (f' : M â†’ Mâ‚ƒ) (h : f' = â‡‘f) : M â†’â‚›â‚—[Ïƒ] Mâ‚ƒ
{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) [topological_space Î±] [borel_space Î±] [topological_space Î²] [second_countable_topology_either Î± Î²] [topological_space.pseudo_metrizable_space Î²] [group Î²] [topological_group Î²] : C(Î±, Î²) â†’* Î± â†’â‚˜[Î¼] Î²
{n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] : n.totient â‰¤ (minpoly â„¤ Î¼).nat_degree
{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] (f : Î± â†’â‚˜[Î¼] Î²) : Prop
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] [h' : module.finite R N] (hN : module.is_torsion R N) : âˆƒ (Î¹ : Type u) [_inst_8 : fintype Î¹] (p : Î¹ â†’ R) [_inst_9 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), nonempty (N â‰ƒâ‚—[R] direct_sum Î¹ (Î» (i : Î¹), R â§¸ submodule.span R {p i ^ e i}))
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : âˆ I.left âŸ¶ âˆ I.right
{Î¹ : Type u_1} [fintype Î¹] (l : box_integral.integration_params) (I : box_integral.box Î¹) : filter (box_integral.tagged_prepartition I)
{W X Y Z S T : Top} (fâ‚ : W âŸ¶ S) (fâ‚‚ : X âŸ¶ S) (gâ‚ : Y âŸ¶ T) (gâ‚‚ : Z âŸ¶ T) (iâ‚ : W âŸ¶ Y) (iâ‚‚ : X âŸ¶ Z) (iâ‚ƒ : S âŸ¶ T) [Hâ‚ƒ : category_theory.mono iâ‚ƒ] (eqâ‚ : fâ‚ â‰« iâ‚ƒ = iâ‚ â‰« gâ‚) (eqâ‚‚ : fâ‚‚ â‰« iâ‚ƒ = iâ‚‚ â‰« gâ‚‚) : set.range â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚) = â‡‘category_theory.limits.pullback.fst â»Â¹' set.range â‡‘iâ‚ âˆ© â‡‘category_theory.limits.pullback.snd â»Â¹' set.range â‡‘iâ‚‚
{f f' : â„ â†’ â„} {Î´ K Îµ a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ (âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), (z - x)â»Â¹ * (f z - f x) < r)) (ha : f a â‰¤ Î´) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f' x â‰¤ K * f x + Îµ) (x : â„) (H : x âˆˆ set.Icc a b) : f x â‰¤ gronwall_bound Î´ K Îµ (x - a)
{Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : f' =O[l] g â†’ (Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] g
{Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ linear_order.max C 0
{Î± : Type u_1} [semi_normed_group Î±] {r C : â„} {f : â„• â†’ Î±} (hr : r < 1) (hf : âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ C * r ^ n) : cauchy_seq (Î» (s : finset â„•), s.sum (Î» (x : â„•), f x))
{F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
{Î± : Type u} {Ïƒ : Type v} (M : NFA Î± Ïƒ) : Îµ_NFA Î± Ïƒ
{Î± : Type u} {Î² : Type v} {Ï† : ultrafilter Î±} [linear_ordered_add_comm_group Î²] : linear_ordered_add_comm_group (â†‘Ï†.germ Î²)
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] (n : â„•) : â†¥(adic_completion I M) â†’â‚—[R] M â§¸ I ^ n â€¢ âŠ¤
{R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [ring_hom_surjective Ïƒâ‚â‚‚] (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) (s : set M) : submodule.map f (submodule.span R s) = submodule.span Râ‚‚ (â‡‘f '' s)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) (P : C) (Î¹ : Î  (a : I.L), P âŸ¶ I.left a) (w : âˆ€ (b : I.R), Î¹ (I.fst_to b) â‰« I.fst b = Î¹ (I.snd_to b) â‰« I.snd b) : category_theory.limits.multifork I
{ğ•œ : Type u_1} {F : Type u_3} [is_R_or_C ğ•œ] [add_comm_group F] [module ğ•œ F] [c : inner_product_space.core ğ•œ F] (x y : F) : is_R_or_C.abs (has_inner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
{Î¹ : Type v} [preorder Î¹] (G : Î¹ â†’ Type w) [nonempty Î¹] [is_directed Î¹ has_le.le] [Î  (i : Î¹), field (G i)] (f' : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’+* G j) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h))] : field (ring.direct_limit G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h)))
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [locally_compact_space G] (Î¼ : measure_theory.measure G) [Î¼.is_add_haar_measure] : measure_theory.is_locally_finite_measure Î¼
{Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {f : Î± â†’ Î²} {t : set Î²} (ht : measure_theory.null_measurable_set t Î½) (hf : measure_theory.measure.quasi_measure_preserving f Î¼ Î½) : measure_theory.null_measurable_set (f â»Â¹' t) Î¼
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {Î¹ : Type u_2} [fintype Î¹] (I : ideal R) (P : Î¹ â†’ ideal R) (e : Î¹ â†’ â„•) (prime : âˆ€ (i : Î¹), _root_.prime (P i)) (coprime : âˆ€ (i j : Î¹), i â‰  j â†’ P i â‰  P j) (prod_eq : finset.univ.prod (Î» (i : Î¹), P i ^ e i) = I) : R â§¸ I â‰ƒ+* Î  (i : Î¹), R â§¸ P i ^ e i
{Î± : Type u_1} {Î¹ : Type u_2} {s : set Î±} (hs : s.nonempty) {f : Î± â†’ Î¹} : s.pairwise (Î» (x y : Î±), f x = f y) â†” âˆƒ (z : Î¹), âˆ€ (x : Î±), x âˆˆ s â†’ f x = z
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C â¥¤ D) [F.final] {d : D} (Z : Î  (X : C), (d âŸ¶ F.obj X) â†’ Sort u_1) (hâ‚ : Î  (Xâ‚ Xâ‚‚ : C) (kâ‚ : d âŸ¶ F.obj Xâ‚) (kâ‚‚ : d âŸ¶ F.obj Xâ‚‚) (f : Xâ‚ âŸ¶ Xâ‚‚), kâ‚ â‰« F.map f = kâ‚‚ â†’ Z Xâ‚ kâ‚ â†’ Z Xâ‚‚ kâ‚‚) (hâ‚‚ : Î  (Xâ‚ Xâ‚‚ : C) (kâ‚ : d âŸ¶ F.obj Xâ‚) (kâ‚‚ : d âŸ¶ F.obj Xâ‚‚) (f : Xâ‚ âŸ¶ Xâ‚‚), kâ‚ â‰« F.map f = kâ‚‚ â†’ Z Xâ‚‚ kâ‚‚ â†’ Z Xâ‚ kâ‚) {Xâ‚€ : C} {kâ‚€ : d âŸ¶ F.obj Xâ‚€} (z : Z Xâ‚€ kâ‚€) : Z (category_theory.functor.final.lift F d) (category_theory.functor.final.hom_to_lift F d)
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ E'] [inner_product_space â„ G] [complete_space E'] [borel_space G] [measure_theory.is_locally_finite_measure Î¼] [Î¼.is_open_pos_measure] [finite_dimensional â„ G] [Î¼.is_add_left_invariant] {Î¹ : Type u_1} {Ï† : Î¹ â†’ cont_diff_bump_of_inner 0} {l : filter Î¹} (hÏ† : filter.tendsto (Î» (i : Î¹), (Ï† i).R) l (nhds 0)) (hg : continuous g) (xâ‚€ : G) : filter.tendsto (Î» (i : Î¹), convolution (Î» (x : G), (Ï† i).normed Î¼ x) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) l (nhds (g xâ‚€))
{K : Type u_1} {Ïƒ : Type u_2} [fintype K] [field K] [fintype Ïƒ] [decidable_eq K] [decidable_eq Ïƒ] (p : â„•) [char_p K p] {Î¹ : Type u_3} {s : finset Î¹} {f : Î¹ â†’ mv_polynomial Ïƒ K} (h : s.sum (Î» (i : Î¹), (f i).total_degree) < fintype.card Ïƒ) : p âˆ£ fintype.card {x // âˆ€ (i : Î¹), i âˆˆ s â†’ â‡‘(mv_polynomial.eval x) (f i) = 0}
{C : Type u} [category_theory.category C] {I : category_theory.limits.multicospan_index C} (K : category_theory.limits.multifork I) (lift : Î  (E : category_theory.limits.multifork I), E.X âŸ¶ K.X) (fac : âˆ€ (E : category_theory.limits.multifork I) (i : I.L), lift E â‰« K.Î¹ i = E.Î¹ i) (uniq : âˆ€ (E : category_theory.limits.multifork I) (m : E.X âŸ¶ K.X), (âˆ€ (i : I.L), m â‰« K.Î¹ i = E.Î¹ i) â†’ m = lift E) : category_theory.limits.is_limit K
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] (e : Î± â‰ƒáµ¤ Î²) (s : set Î±) : â†¥s â‰ƒáµ¤ â†¥(â‡‘e '' s)
{Î± : Type u_1} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) : Prop
{Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] (Î¼ : measure_theory.measure Î±) [Î¼.weakly_regular] [measure_theory.sigma_finite Î¼] (f : Î± â†’ nnreal) (fmeas : measurable f) {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
{Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : (âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)) â†’ f =o[l] g
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [topological_space Î²] [topological_space Î³] (r : Î² â†’ Î³ â†’ Prop) (f : Î± â†’â‚˜[Î¼] Î²) (g : Î± â†’â‚˜[Î¼] Î³) : Prop
{Î¹ : Type u_1} {I : box_integral.box Î¹} [fintype Î¹] {Ï€â‚ Ï€â‚‚ : box_integral.prepartition I} (h : Ï€â‚.Union = Ï€â‚‚.Union) : Ï€â‚.compl = Ï€â‚‚.compl
{Î± : Type u} {Ïƒ : Type v} (M : NFA Î± Ïƒ) (start : set Ïƒ) : list Î± â†’ set Ïƒ
{Î± : Type u} [pseudo_emetric_space Î±] (Îµ Î´ : â„) (s : set Î±) : metric.thickening Îµ (metric.thickening Î´ s) âŠ† metric.thickening (Îµ + Î´) s
{E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f g : â„ â†’ E} {Î¼ : measure_theory.measure â„} {a b : â„} (h : set.eq_on f g (set.interval a b)) : âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„) in a..b, g x âˆ‚Î¼
{x : â„} (hx : liouville x) (n : â„•) : âˆƒá¶  (b : â„•) in filter.at_top, âˆƒ (a : â„¤), x â‰  â†‘a / â†‘b âˆ§ |x - â†‘a / â†‘b| < 1 / â†‘b ^ n
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) â¦ƒÎ¹ : Type vâ¦„ (U : Î¹ â†’ topological_space.opens â†¥X) (c : category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U)) : category_theory.limits.cone ((category_theory.pairwise.diagram U).op â‹™ F)
{Î± : Type u_1} {Î² : Type u_2} [linear_ordered_add_comm_group Î²] [uniform_space Î²] [uniform_add_group Î²] [complete_space Î²] {f : Î± â†’ Î²} : summable (Î» (x : Î±), |f x|) â†’ summable f
{I : Type u} (X : I â†’ Top) : category_theory.Groupoid.of (Î  (i : I), â†¥(fundamental_groupoid.fundamental_groupoid_functor.obj (X i))) â‰… fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Î  (i : I), â†¥(X i)))
{Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [semiring Râ‚] [semiring Râ‚‚] (Ïƒ : Râ‚ â†’+* Râ‚‚) : Prop
{R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) (n : â„•) : (Î» (t : R), ring.inverse (â†‘x + t) - (finset.range n).sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ n
{ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) (h : is_complete â†‘K) (u : E) : âˆƒ (v : E) (H : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥
{Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) + g (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ + âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
{k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [add_monoid G] {A : Type uâ‚ƒ} [semiring A] [algebra k A] â¦ƒÏ†â‚ Ï†â‚‚ : add_monoid_algebra k G â†’â‚[k] Aâ¦„ (h : âˆ€ (x : G), â‡‘Ï†â‚ (finsupp.single x 1) = â‡‘Ï†â‚‚ (finsupp.single x 1)) : Ï†â‚ = Ï†â‚‚
{Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) {f : Î¹ â†’ Î± â†’ Î²} (hf : âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) (h : âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (C : nnreal), 0 < C âˆ§ âˆ€ (i : Î¹), measure_theory.snorm ({x : Î± | C â‰¤ âˆ¥f i xâˆ¥â‚Š}.indicator (f i)) p Î¼ â‰¤ ennreal.of_real Îµ)) : measure_theory.unif_integrable f p Î¼
{I : Type wâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {D : Type uâ‚‚} [category_theory.category D] {F G : (Î£ (i : I), C i) â¥¤ D} (h : Î  (i : I), category_theory.sigma.incl i â‹™ F âŸ¶ category_theory.sigma.incl i â‹™ G) : F âŸ¶ G
{S : Type u_2} {R : Type u} {M : Type v} {N : Type u_1} [semiring S] [add_comm_monoid R] [add_comm_monoid M] [add_comm_monoid N] [module S R] [module S M] [module S N] â¦ƒf g : triv_sq_zero_ext R M â†’â‚—[S] Nâ¦„ (hl : âˆ€ (r : R), â‡‘f (triv_sq_zero_ext.inl r) = â‡‘g (triv_sq_zero_ext.inl r)) (hr : âˆ€ (m : M), â‡‘f (triv_sq_zero_ext.inr m) = â‡‘g (triv_sq_zero_ext.inr m)) : f = g
{V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x y = real.pi) : has_inner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
{Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (fs : smooth_bump_covering Î¹ I M s) [t2_space M] : bump_covering Î¹ M s
(Î“ : Type u_1) [inhabited Î“] (Î› : Type u_2) [inhabited Î›] : Type (max u_2 u_1)
{G : Type w} [topological_space G] (Î¼ : measure_theory.content G) [t2_space G] [S : measurable_space G] [borel_space G] : S â‰¤ Î¼.outer_measure.caratheodory
{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] (Î¼ : measure_theory.measure Î±) (Î½ : measure_theory.measure Î²) : measure_theory.measure (Î± Ã— Î²)
{C : Type u} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) [I : category_theory.is_iso f] : Y âŸ¶ X
{k : Type u_1} [field k] {Ïƒ : Type u_2} [is_alg_closed k] [fintype Ïƒ] (I : ideal (mv_polynomial Ïƒ k)) : mv_polynomial.vanishing_ideal (mv_polynomial.zero_locus I) = I.radical
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] (Î¼ : measure_theory.finite_measure Î±) (f : bounded_continuous_function Î± nnreal) : nnreal
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] {n : â„•} (dec : vector bool n â†’ Î“) (f : Î“ â†’ turing.TM1.stmt bool turing.TM1to1.Î›' Ïƒ) : turing.TM1.stmt bool turing.TM1to1.Î›' Ïƒ
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul G] (Î¼ : measure_theory.measure G) [Î¼.is_mul_left_invariant] (g : G) (A : set G) : â‡‘Î¼ ((Î» (h : G), g * h) â»Â¹' A) = â‡‘Î¼ A
{C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) {W X Y Z : C} {h : X âŸ¶ Z} {k : Y âŸ¶ Z} {f : W âŸ¶ X} {g : W âŸ¶ Y} (comm : f â‰« h = g â‰« k) [category_theory.limits.preserves_colimit (category_theory.limits.span f g) G] (l : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk h k comm)) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (G.map h) (G.map k) _)
{ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M â†’ M') (s : set M) (x : M) : Prop
(h : expr) (nargs : option â„• := option.none) (md : tactic.transparency := tactic.transparency.semireducible) : tactic congr_lemma
{R : Type u_1} [comm_semiring R] (Ïƒ : Type u_2) [fintype Ïƒ] (r : Ïƒ â†’ R) (k : â„•) (h : k â‰¤ fintype.card Ïƒ) : (finset.univ.prod (Î» (i : Ïƒ), â‡‘polynomial.C (r i) + polynomial.X)).coeff k = (finset.powerset_len (fintype.card Ïƒ - k) finset.univ).sum (Î» (t : finset Ïƒ), t.prod (Î» (i : Ïƒ), r i))
{Î¹ : Type u_1} {Ïƒ : Type u_2} {R : Type u_4} [decidable_eq Î¹] [add_comm_monoid Î¹] [comm_semiring R] [set_like Ïƒ R] [add_submonoid_class Ïƒ R] (A : Î¹ â†’ Ïƒ) [set_like.graded_monoid A] : direct_sum.gcomm_semiring (Î» (i : Î¹), â†¥(A i))
{Îµ : â„} (hÎµ : 0 < Îµ) (Î¹ : Type u_1) [encodable Î¹] : {Îµ' // (âˆ€ (i : Î¹), 0 < Îµ' i) âˆ§ âˆƒ (c : â„), has_sum Îµ' c âˆ§ c â‰¤ Îµ}
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (Ïƒ : equiv.perm n) (M : matrix n n R) : matrix.det (Î» (i : n), M (â‡‘Ïƒ i)) = â†‘(â‡‘equiv.perm.sign Ïƒ) * M.det
{V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} {p1 p2 : P} (hp1 : p1 âˆˆ s) (hp2 : p2 âˆˆ s) (r1 r2 : â„) {v : V} (hv : v âˆˆ (s.direction)á—®) : has_dist.dist (r1 â€¢ v +áµ¥ p1) (r2 â€¢ v +áµ¥ p2) * has_dist.dist (r1 â€¢ v +áµ¥ p1) (r2 â€¢ v +áµ¥ p2) = has_dist.dist p1 p2 * has_dist.dist p1 p2 + (r1 - r2) * (r1 - r2) * (âˆ¥vâˆ¥ * âˆ¥vâˆ¥)
{Î± : Type u} [pseudo_metric_space Î±] {Î² : Type u_1} {p : Î² â†’ Prop} {f : Î² â†’ â„} (hfâ‚€ : âˆ€ (i : Î²), p i â†’ 0 < f i) (hf : âˆ€ â¦ƒÎµ : â„â¦„, 0 < Îµ â†’ (âˆƒ (i : Î²) (hi : p i), f i â‰¤ Îµ)) : (uniformity Î±).has_basis p (Î» (i : Î²), {p : Î± Ã— Î± | has_dist.dist p.fst p.snd < f i})
{Î“ : Type u_1} [inhabited Î“] {Î› : Type u_2} [inhabited Î›] {Ïƒ : Type u_3} [inhabited Ïƒ] : list bool â†’ turing.TM1.stmt bool turing.TM1to1.Î›' Ïƒ â†’ turing.TM1.stmt bool turing.TM1to1.Î›' Ïƒ
{Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s t : set Î±} (H : s â‰¤áµ[Î¼] t) : â‡‘Î¼ s â‰¤ â‡‘Î¼ t
{Î¹ : Type u_1} (I : box_integral.box Î¹) (i : Î¹) (x : â„) : box_integral.prepartition I
{Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : measure_theory.simple_func Î± â„} (hf : measure_theory.integrable â‡‘f Î¼) (h_pos : 0 â‰¤áµ[Î¼] â‡‘f) : measure_theory.simple_func.integral Î¼ f = (âˆ«â» (a : Î±), ennreal.of_real (â‡‘f a) âˆ‚Î¼).to_real
{R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] {S : set (monoid_algebra R M)} (hS : algebra.adjoin R S = âŠ¤) : algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â‹ƒ (f : monoid_algebra R M) (H : f âˆˆ S), â†‘(f.support)) = âŠ¤
(e : expr) (n : name := name.mk_string "_x" name.anonymous) (md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) {Îµ : ennreal} (hÎµ : Îµ â‰  0) : âˆƒ (K : set Î±) (H : K âŠ† A), is_compact K âˆ§ â‡‘Î¼ A < â‡‘Î¼ K + Îµ
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : âˆ¥â†‘mâˆ¥ â‰¤ âˆ¥mâˆ¥
{V : Type v} [category_theory.category V] [category_theory.monoidal_category V] {W : Type v} [category_theory.category W] [category_theory.monoidal_category W] (F : category_theory.lax_monoidal_functor V W) (C : Type uâ‚) : Type uâ‚
